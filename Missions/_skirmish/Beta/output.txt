// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12724 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 70
 744: PUSH
 745: LD_EXP 70
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 70
 777: PUSH
 778: LD_EXP 70
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 56091 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12581 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12581 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 70
1974: PUSH
1975: LD_EXP 70
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18475 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18475 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18475 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18475 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18475 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 79419 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 79363 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 78422 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 79251 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 78933 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 78664 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 78283 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 78098 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 77990 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 78840 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 79045 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 79419 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 79363 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 78422 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 79251 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 78933 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 78664 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 78283 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 78098 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 77990 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 78840 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 79045 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 78146 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 78146 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 78146 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 78494 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 89
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 92
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 89
7660: PUSH
7661: LD_EXP 89
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 89
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 70
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 78146 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 78146 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 78146 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 79564 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 89
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 92
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 89
8875: PUSH
8876: LD_EXP 89
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 89
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 70
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18475 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18475 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18475 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18475 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18475 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18475 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL 98886 0 1
// if un = Brighton then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_EXP 9
11276: EQUAL
11277: IFFALSE 11293
// begin wait ( 0 0$1 ) ;
11279: LD_INT 35
11281: PPUSH
11282: CALL_OW 67
// YouLost ( Brighton ) ;
11286: LD_STRING Brighton
11288: PPUSH
11289: CALL_OW 104
// end ; if un = JMM then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_EXP 37
11302: EQUAL
11303: IFFALSE 11319
// begin wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// YouLost ( JMM ) ;
11312: LD_STRING JMM
11314: PPUSH
11315: CALL_OW 104
// end ; if un = Megan then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_EXP 11
11328: EQUAL
11329: IFFALSE 11343
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11331: LD_EXP 9
11335: PPUSH
11336: LD_STRING DBrighton-MeganDeath
11338: PPUSH
11339: CALL_OW 88
// end ; if un = Palmer then
11343: LD_VAR 0 1
11347: PUSH
11348: LD_EXP 10
11352: EQUAL
11353: IFFALSE 11367
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING DBrighton-PalmerDeath
11362: PPUSH
11363: CALL_OW 88
// end ; if un = Burlak then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11409
// begin if JMM_Arrived then
11379: LD_EXP 6
11383: IFFALSE 11397
// Say ( JMM , DJMM-BurlakDead ) ;
11385: LD_EXP 37
11389: PPUSH
11390: LD_STRING DJMM-BurlakDead
11392: PPUSH
11393: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11397: LD_EXP 10
11401: PPUSH
11402: LD_STRING DSol-BurlakDead
11404: PPUSH
11405: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 1
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_INT 3
11425: EQUAL
11426: OR
11427: IFFALSE 11443
// begin wait ( 0 0$1 ) ;
11429: LD_INT 35
11431: PPUSH
11432: CALL_OW 67
// YouLost ( Depot ) ;
11436: LD_STRING Depot
11438: PPUSH
11439: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 255
11452: PUSH
11453: LD_INT 1
11455: EQUAL
11456: PUSH
11457: LD_VAR 0 1
11461: PPUSH
11462: CALL_OW 247
11466: PUSH
11467: LD_INT 1
11469: EQUAL
11470: AND
11471: IFFALSE 11487
// Losses := Losses + 1 ;
11473: LD_ADDR_EXP 45
11477: PUSH
11478: LD_EXP 45
11482: PUSH
11483: LD_INT 1
11485: PLUS
11486: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: CALL 81566 0 1
// end ;
11496: PPOPN 1
11498: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11499: LD_VAR 0 1
11503: PPUSH
11504: CALL_OW 247
11508: PUSH
11509: LD_INT 2
11511: EQUAL
11512: PUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_EXP 17
11522: IN
11523: AND
11524: IFFALSE 11538
// SetLives ( un , 0 ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: LD_INT 0
11533: PPUSH
11534: CALL_OW 234
// if un = Yashin then
11538: LD_VAR 0 1
11542: PUSH
11543: LD_EXP 13
11547: EQUAL
11548: IFFALSE 11562
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11550: LD_EXP 13
11554: PPUSH
11555: LD_STRING DDeath-Yas-3
11557: PPUSH
11558: CALL_OW 91
// if un = Popov then
11562: LD_VAR 0 1
11566: PUSH
11567: LD_EXP 14
11571: EQUAL
11572: IFFALSE 11586
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11574: LD_EXP 14
11578: PPUSH
11579: LD_STRING DDeath-Pop-3
11581: PPUSH
11582: CALL_OW 91
// if un = Gaydar then
11586: LD_VAR 0 1
11590: PUSH
11591: LD_EXP 15
11595: EQUAL
11596: IFFALSE 11610
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11598: LD_EXP 15
11602: PPUSH
11603: LD_STRING DDeath-Gay-3
11605: PPUSH
11606: CALL_OW 91
// if un = Sevi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 16
11619: EQUAL
11620: IFFALSE 11634
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11622: LD_EXP 16
11626: PPUSH
11627: LD_STRING DDeath-Vse-3
11629: PPUSH
11630: CALL_OW 91
// end ;
11634: PPOPN 1
11636: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11637: LD_VAR 0 1
11641: PUSH
11642: LD_INT 10
11644: EQUAL
11645: IFFALSE 11683
// begin Say ( Brighton , DBrighton-C1 ) ;
11647: LD_EXP 9
11651: PPUSH
11652: LD_STRING DBrighton-C1
11654: PPUSH
11655: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_STRING DMegan-C1
11666: PPUSH
11667: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11671: LD_EXP 9
11675: PPUSH
11676: LD_STRING DBrighton-C2
11678: PPUSH
11679: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: CALL 81262 0 2
// end ;
11697: PPOPN 2
11699: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_VAR 0 2
11709: PPUSH
11710: CALL 83900 0 2
// end ;
11714: PPOPN 2
11716: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11717: LD_VAR 0 1
11721: PPUSH
11722: CALL 82968 0 1
// end ;
11726: PPOPN 1
11728: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 266
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 1
11747: PPUSH
11748: CALL_OW 255
11752: PUSH
11753: LD_INT 3
11755: EQUAL
11756: AND
11757: IFFALSE 11819
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 274
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 10000
11774: PPUSH
11775: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 274
11788: PPUSH
11789: LD_INT 2
11791: PPUSH
11792: LD_INT 250
11794: PPUSH
11795: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 274
11808: PPUSH
11809: LD_INT 3
11811: PPUSH
11812: LD_INT 100
11814: PPUSH
11815: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL 83209 0 1
// end ;
11828: PPOPN 1
11830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_VAR 0 2
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: LD_VAR 0 5
11855: PPUSH
11856: CALL 80882 0 5
// end ;
11860: PPOPN 5
11862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11863: LD_VAR 0 1
11867: PPUSH
11868: LD_VAR 0 2
11872: PPUSH
11873: CALL 80463 0 2
// end ;
11877: PPOPN 2
11879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL 80301 0 4
// end ;
11904: PPOPN 4
11906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_VAR 0 2
11916: PPUSH
11917: LD_VAR 0 3
11921: PPUSH
11922: CALL 80076 0 3
// end ;
11926: PPOPN 3
11928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: CALL 79961 0 2
// end ;
11943: PPOPN 2
11945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_VAR 0 2
11955: PPUSH
11956: CALL 84195 0 2
// end ;
11960: PPOPN 2
11962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 255
11972: PUSH
11973: LD_INT 6
11975: EQUAL
11976: IFFALSE 12106
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_EXP 13
11987: PUSH
11988: LD_EXP 16
11992: PUSH
11993: LD_EXP 15
11997: PUSH
11998: LD_EXP 14
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: IN
12009: IFFALSE 12013
// exit ;
12011: GO 12130
// if AssaultStarted then
12013: LD_EXP 8
12017: IFFALSE 12091
// case Rand ( 1 , 4 ) of 1 .. 3 :
12019: LD_INT 1
12021: PPUSH
12022: LD_INT 4
12024: PPUSH
12025: CALL_OW 12
12029: PUSH
12030: LD_INT 1
12032: DOUBLE
12033: GREATEREQUAL
12034: IFFALSE 12042
12036: LD_INT 3
12038: DOUBLE
12039: LESSEQUAL
12040: IFTRUE 12044
12042: GO 12062
12044: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 67
12052: PPUSH
12053: LD_INT 37
12055: PPUSH
12056: CALL_OW 114
12060: GO 12089
12062: LD_INT 4
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12088
12070: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_INT 120
12078: PPUSH
12079: LD_INT 131
12081: PPUSH
12082: CALL_OW 111
12086: GO 12089
12088: POP
12089: GO 12106
// ComMoveXY ( driver , 120 , 131 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 120
12098: PPUSH
12099: LD_INT 131
12101: PPUSH
12102: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12106: LD_VAR 0 1
12110: PPUSH
12111: LD_VAR 0 2
12115: PPUSH
12116: LD_VAR 0 3
12120: PPUSH
12121: LD_VAR 0 4
12125: PPUSH
12126: CALL 84411 0 4
// end ;
12130: PPOPN 4
12132: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12133: LD_VAR 0 1
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 79770 0 2
// end ;
12147: PPOPN 2
12149: END
// on Command ( cmd ) do var i ;
12150: LD_INT 0
12152: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12153: LD_VAR 0 1
12157: PUSH
12158: LD_INT 77
12160: EQUAL
12161: PUSH
12162: LD_EXP 2
12166: AND
12167: IFFALSE 12243
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12169: LD_ADDR_VAR 0 2
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_INT 1
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 2
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 21
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PPUSH
12216: CALL_OW 69
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12241
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 20
12231: PPUSH
12232: LD_INT 19
12234: PPUSH
12235: CALL 50946 0 3
12239: GO 12221
12241: POP
12242: POP
// end ; SOS_Command ( cmd ) ;
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL 98992 0 1
// end ;
12252: PPOPN 2
12254: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12255: LD_EXP 2
12259: PUSH
12260: LD_INT 16
12262: PPUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 1
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 1
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 21
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 70
12309: AND
12310: IFFALSE 12396
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin enable ;
12318: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 16
12326: PPUSH
12327: LD_INT 22
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 2
12339: PUSH
12340: LD_INT 21
12342: PUSH
12343: LD_INT 1
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 2
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PPUSH
12369: CALL_OW 70
12373: PUSH
12374: FOR_IN
12375: IFFALSE 12394
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12377: LD_VAR 0 1
12381: PPUSH
12382: LD_INT 18
12384: PPUSH
12385: LD_INT 19
12387: PPUSH
12388: CALL 50946 0 3
12392: GO 12374
12394: POP
12395: POP
// end ; end_of_file
12396: PPOPN 1
12398: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12399: LD_EXP 6
12403: PUSH
12404: LD_EXP 44
12408: AND
12409: IFFALSE 12580
12411: GO 12413
12413: DISABLE
// begin wait ( 0 0$2 ) ;
12414: LD_INT 70
12416: PPUSH
12417: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12421: LD_EXP 9
12425: PPUSH
12426: LD_STRING DBrighton-G1
12428: PPUSH
12429: CALL_OW 88
// if Losses < 1 then
12433: LD_EXP 45
12437: PUSH
12438: LD_INT 1
12440: LESS
12441: IFFALSE 12455
// AddMedal ( Losses , 1 ) else
12443: LD_STRING Losses
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: CALL_OW 101
12453: GO 12488
// if Losses < 5 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 5
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 2 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 2
12470: PPUSH
12471: CALL_OW 101
12475: GO 12488
// AddMedal ( Losses , - 1 ) ;
12477: LD_STRING Losses
12479: PPUSH
12480: LD_INT 1
12482: NEG
12483: PPUSH
12484: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12488: LD_EXP 7
12492: PUSH
12493: LD_INT 10
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 321
12503: PUSH
12504: LD_INT 2
12506: EQUAL
12507: AND
12508: IFFALSE 12522
// AddMedal ( Laser , 1 ) else
12510: LD_STRING Laser
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 101
12520: GO 12569
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12522: LD_EXP 7
12526: NOT
12527: PUSH
12528: LD_INT 10
12530: PPUSH
12531: LD_INT 1
12533: PPUSH
12534: CALL_OW 321
12538: PUSH
12539: LD_INT 2
12541: EQUAL
12542: AND
12543: IFFALSE 12558
// AddMedal ( Laser , - 1 ) else
12545: LD_STRING Laser
12547: PPUSH
12548: LD_INT 1
12550: NEG
12551: PPUSH
12552: CALL_OW 101
12556: GO 12569
// AddMedal ( Laser , - 2 ) ;
12558: LD_STRING Laser
12560: PPUSH
12561: LD_INT 2
12563: NEG
12564: PPUSH
12565: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12569: LD_STRING BaseMain
12571: PPUSH
12572: CALL_OW 102
// YouWin ;
12576: CALL_OW 103
// end ; end_of_file
12580: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12581: LD_INT 0
12583: PPUSH
12584: PPUSH
// area = ListEnvironmentArea ( area ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: CALL_OW 353
12599: ST_TO_ADDR
// if bulldozer > 0 then
12600: LD_VAR 0 1
12604: PUSH
12605: LD_INT 0
12607: GREATER
12608: IFFALSE 12719
// for i = area downto 1 do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: DOUBLE
12616: LD_VAR 0 2
12620: INC
12621: ST_TO_ADDR
12622: LD_INT 1
12624: PUSH
12625: FOR_DOWNTO
12626: IFFALSE 12717
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 351
12662: IFFALSE 12715
// if not HasTask ( bulldozer ) then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 314
12673: NOT
12674: IFFALSE 12715
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PUSH
12692: LD_INT 1
12694: ARRAY
12695: PPUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PUSH
12707: LD_INT 2
12709: ARRAY
12710: PPUSH
12711: CALL_OW 171
12715: GO 12625
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
12732: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12733: LD_ADDR_VAR 0 8
12737: PUSH
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_INT 22
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 21
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: PPUSH
12778: CALL_OW 72
12782: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12783: LD_ADDR_VAR 0 9
12787: PUSH
12788: LD_VAR 0 1
12792: PPUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 21
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 3
12815: PUSH
12816: LD_INT 25
12818: PUSH
12819: LD_INT 1
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 72
12839: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12840: LD_ADDR_EXP 47
12844: PUSH
12845: LD_VAR 0 8
12849: PPUSH
12850: LD_VAR 0 9
12854: PPUSH
12855: CALL 13248 0 2
12859: ST_TO_ADDR
// offset = 0 ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// for i := 1 to sold_team do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 8
12882: PUSH
12883: FOR_TO
12884: IFFALSE 13015
// begin if IsInUnit ( sold_team [ i ] ) then
12886: LD_VAR 0 8
12890: PUSH
12891: LD_VAR 0 4
12895: ARRAY
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12918
// ComExitBuilding ( sold_team [ i ] ) ;
12903: LD_VAR 0 8
12907: PUSH
12908: LD_VAR 0 4
12912: ARRAY
12913: PPUSH
12914: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12918: LD_VAR 0 8
12922: PUSH
12923: LD_VAR 0 4
12927: ARRAY
12928: PPUSH
12929: LD_EXP 47
12933: PUSH
12934: LD_INT 1
12936: ARRAY
12937: PUSH
12938: LD_VAR 0 4
12942: PUSH
12943: LD_VAR 0 7
12947: PLUS
12948: ARRAY
12949: PPUSH
12950: LD_EXP 47
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: PUSH
12959: LD_VAR 0 4
12963: PUSH
12964: LD_INT 1
12966: PLUS
12967: PUSH
12968: LD_VAR 0 7
12972: PLUS
12973: ARRAY
12974: PPUSH
12975: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12979: LD_VAR 0 8
12983: PUSH
12984: LD_VAR 0 4
12988: ARRAY
12989: PPUSH
12990: LD_EXP 9
12994: PPUSH
12995: CALL_OW 179
// offset = offset + 1 ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 7
13008: PUSH
13009: LD_INT 1
13011: PLUS
13012: ST_TO_ADDR
// end ;
13013: GO 12883
13015: POP
13016: POP
// offset = 0 ;
13017: LD_ADDR_VAR 0 7
13021: PUSH
13022: LD_INT 0
13024: ST_TO_ADDR
// tmp = 1 ;
13025: LD_ADDR_VAR 0 6
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// for i := 2 to rows do
13033: LD_ADDR_VAR 0 4
13037: PUSH
13038: DOUBLE
13039: LD_INT 2
13041: DEC
13042: ST_TO_ADDR
13043: LD_EXP 47
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13241
// begin for x := 1 to sold_team do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13229
// begin if IsInUnit ( civil_team [ tmp ] ) then
13069: LD_VAR 0 9
13073: PUSH
13074: LD_VAR 0 6
13078: ARRAY
13079: PPUSH
13080: CALL_OW 310
13084: IFFALSE 13101
// ComExitBuilding ( civil_team [ tmp ] ) ;
13086: LD_VAR 0 9
13090: PUSH
13091: LD_VAR 0 6
13095: ARRAY
13096: PPUSH
13097: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13101: LD_VAR 0 9
13105: PUSH
13106: LD_VAR 0 6
13110: ARRAY
13111: PPUSH
13112: LD_EXP 47
13116: PUSH
13117: LD_VAR 0 4
13121: ARRAY
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: PLUS
13133: ARRAY
13134: PPUSH
13135: LD_EXP 47
13139: PUSH
13140: LD_VAR 0 4
13144: ARRAY
13145: PUSH
13146: LD_VAR 0 5
13150: PUSH
13151: LD_INT 1
13153: PLUS
13154: PUSH
13155: LD_VAR 0 7
13159: PLUS
13160: ARRAY
13161: PPUSH
13162: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13166: LD_VAR 0 9
13170: PUSH
13171: LD_VAR 0 6
13175: ARRAY
13176: PPUSH
13177: LD_EXP 9
13181: PPUSH
13182: CALL_OW 179
// offset = offset + 1 ;
13186: LD_ADDR_VAR 0 7
13190: PUSH
13191: LD_VAR 0 7
13195: PUSH
13196: LD_INT 1
13198: PLUS
13199: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13200: LD_VAR 0 6
13204: PUSH
13205: LD_VAR 0 9
13209: EQUAL
13210: NOT
13211: IFFALSE 13227
// tmp = tmp + 1 ;
13213: LD_ADDR_VAR 0 6
13217: PUSH
13218: LD_VAR 0 6
13222: PUSH
13223: LD_INT 1
13225: PLUS
13226: ST_TO_ADDR
// end ;
13227: GO 13066
13229: POP
13230: POP
// offset = 0 ;
13231: LD_ADDR_VAR 0 7
13235: PUSH
13236: LD_INT 0
13238: ST_TO_ADDR
// end ;
13239: GO 13048
13241: POP
13242: POP
// end ;
13243: LD_VAR 0 3
13247: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
// start_pos = [ 65 , 34 ] ;
13260: LD_ADDR_VAR 0 6
13264: PUSH
13265: LD_INT 65
13267: PUSH
13268: LD_INT 34
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
// row_size = 0 ;
13275: LD_ADDR_VAR 0 7
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// result_rows = [ ] ;
13283: LD_ADDR_VAR 0 9
13287: PUSH
13288: EMPTY
13289: ST_TO_ADDR
// new_row = [ ] ;
13290: LD_ADDR_VAR 0 8
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// for i := 1 to sold_team do
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: DOUBLE
13303: LD_INT 1
13305: DEC
13306: ST_TO_ADDR
13307: LD_VAR 0 1
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13367
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_VAR 0 8
13324: PUSH
13325: LD_VAR 0 6
13329: PUSH
13330: LD_INT 1
13332: ARRAY
13333: ADD
13334: PUSH
13335: LD_VAR 0 6
13339: PUSH
13340: LD_INT 2
13342: ARRAY
13343: PUSH
13344: LD_VAR 0 4
13348: PLUS
13349: ADD
13350: ST_TO_ADDR
// row_size = row_size + 1 ;
13351: LD_ADDR_VAR 0 7
13355: PUSH
13356: LD_VAR 0 7
13360: PUSH
13361: LD_INT 1
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13312
13367: POP
13368: POP
// result_rows = result_rows ^ [ new_row ] ;
13369: LD_ADDR_VAR 0 9
13373: PUSH
13374: LD_VAR 0 9
13378: PUSH
13379: LD_VAR 0 8
13383: PUSH
13384: EMPTY
13385: LIST
13386: ADD
13387: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13388: LD_ADDR_VAR 0 10
13392: PUSH
13393: LD_VAR 0 2
13397: PUSH
13398: LD_VAR 0 1
13402: DIV
13403: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13404: LD_VAR 0 10
13408: PUSH
13409: LD_VAR 0 1
13413: MOD
13414: PUSH
13415: LD_INT 0
13417: GREATER
13418: IFFALSE 13434
// civil_rows = civil_rows + 1 ;
13420: LD_ADDR_VAR 0 10
13424: PUSH
13425: LD_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ST_TO_ADDR
// offsetX = 2 ;
13434: LD_ADDR_VAR 0 11
13438: PUSH
13439: LD_INT 2
13441: ST_TO_ADDR
// offsetY = 1 ;
13442: LD_ADDR_VAR 0 12
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// for i := 1 to civil_rows do
13450: LD_ADDR_VAR 0 4
13454: PUSH
13455: DOUBLE
13456: LD_INT 1
13458: DEC
13459: ST_TO_ADDR
13460: LD_VAR 0 10
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13594
// begin new_row = [ ] ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: EMPTY
13474: ST_TO_ADDR
// for x := 1 to row_size do
13475: LD_ADDR_VAR 0 5
13479: PUSH
13480: DOUBLE
13481: LD_INT 1
13483: DEC
13484: ST_TO_ADDR
13485: LD_VAR 0 7
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13543
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13493: LD_ADDR_VAR 0 8
13497: PUSH
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 6
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_VAR 0 11
13516: PLUS
13517: ADD
13518: PUSH
13519: LD_VAR 0 6
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: PUSH
13528: LD_VAR 0 12
13532: PLUS
13533: PUSH
13534: LD_VAR 0 5
13538: PLUS
13539: ADD
13540: ST_TO_ADDR
// end ;
13541: GO 13490
13543: POP
13544: POP
// result_rows = result_rows ^ [ new_row ] ;
13545: LD_ADDR_VAR 0 9
13549: PUSH
13550: LD_VAR 0 9
13554: PUSH
13555: LD_VAR 0 8
13559: PUSH
13560: EMPTY
13561: LIST
13562: ADD
13563: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13564: LD_ADDR_VAR 0 11
13568: PUSH
13569: LD_VAR 0 11
13573: PUSH
13574: LD_INT 2
13576: PLUS
13577: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13578: LD_ADDR_VAR 0 12
13582: PUSH
13583: LD_VAR 0 12
13587: PUSH
13588: LD_INT 1
13590: PLUS
13591: ST_TO_ADDR
// end ;
13592: GO 13465
13594: POP
13595: POP
// result = result_rows ;
13596: LD_ADDR_VAR 0 3
13600: PUSH
13601: LD_VAR 0 9
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 3
13610: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
// if exist_mode then
13615: LD_VAR 0 2
13619: IFFALSE 13644
// unit := CreateCharacter ( prefix & ident ) else
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_VAR 0 3
13630: PUSH
13631: LD_VAR 0 1
13635: STR
13636: PPUSH
13637: CALL_OW 34
13641: ST_TO_ADDR
13642: GO 13659
// unit := NewCharacter ( ident ) ;
13644: LD_ADDR_VAR 0 5
13648: PUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 25
13658: ST_TO_ADDR
// result := unit ;
13659: LD_ADDR_VAR 0 4
13663: PUSH
13664: LD_VAR 0 5
13668: ST_TO_ADDR
// end ;
13669: LD_VAR 0 4
13673: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13674: LD_INT 0
13676: PPUSH
13677: PPUSH
// if not side or not nation then
13678: LD_VAR 0 1
13682: NOT
13683: PUSH
13684: LD_VAR 0 2
13688: NOT
13689: OR
13690: IFFALSE 13694
// exit ;
13692: GO 14462
// case nation of nation_american :
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 1
13701: DOUBLE
13702: EQUAL
13703: IFTRUE 13707
13705: GO 13921
13707: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13708: LD_ADDR_VAR 0 4
13712: PUSH
13713: LD_INT 35
13715: PUSH
13716: LD_INT 45
13718: PUSH
13719: LD_INT 46
13721: PUSH
13722: LD_INT 47
13724: PUSH
13725: LD_INT 82
13727: PUSH
13728: LD_INT 83
13730: PUSH
13731: LD_INT 84
13733: PUSH
13734: LD_INT 85
13736: PUSH
13737: LD_INT 86
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: LD_INT 2
13745: PUSH
13746: LD_INT 6
13748: PUSH
13749: LD_INT 15
13751: PUSH
13752: LD_INT 16
13754: PUSH
13755: LD_INT 7
13757: PUSH
13758: LD_INT 12
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: LD_INT 20
13772: PUSH
13773: LD_INT 21
13775: PUSH
13776: LD_INT 22
13778: PUSH
13779: LD_INT 25
13781: PUSH
13782: LD_INT 32
13784: PUSH
13785: LD_INT 27
13787: PUSH
13788: LD_INT 36
13790: PUSH
13791: LD_INT 69
13793: PUSH
13794: LD_INT 39
13796: PUSH
13797: LD_INT 34
13799: PUSH
13800: LD_INT 40
13802: PUSH
13803: LD_INT 48
13805: PUSH
13806: LD_INT 49
13808: PUSH
13809: LD_INT 50
13811: PUSH
13812: LD_INT 51
13814: PUSH
13815: LD_INT 52
13817: PUSH
13818: LD_INT 53
13820: PUSH
13821: LD_INT 54
13823: PUSH
13824: LD_INT 55
13826: PUSH
13827: LD_INT 56
13829: PUSH
13830: LD_INT 57
13832: PUSH
13833: LD_INT 58
13835: PUSH
13836: LD_INT 59
13838: PUSH
13839: LD_INT 60
13841: PUSH
13842: LD_INT 61
13844: PUSH
13845: LD_INT 62
13847: PUSH
13848: LD_INT 80
13850: PUSH
13851: LD_INT 82
13853: PUSH
13854: LD_INT 83
13856: PUSH
13857: LD_INT 84
13859: PUSH
13860: LD_INT 85
13862: PUSH
13863: LD_INT 86
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: ST_TO_ADDR
13919: GO 14386
13921: LD_INT 2
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 14155
13929: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_INT 35
13937: PUSH
13938: LD_INT 45
13940: PUSH
13941: LD_INT 46
13943: PUSH
13944: LD_INT 47
13946: PUSH
13947: LD_INT 82
13949: PUSH
13950: LD_INT 83
13952: PUSH
13953: LD_INT 84
13955: PUSH
13956: LD_INT 85
13958: PUSH
13959: LD_INT 87
13961: PUSH
13962: LD_INT 70
13964: PUSH
13965: LD_INT 1
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: LD_INT 5
13979: PUSH
13980: LD_INT 6
13982: PUSH
13983: LD_INT 15
13985: PUSH
13986: LD_INT 18
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: LD_INT 17
13994: PUSH
13995: LD_INT 8
13997: PUSH
13998: LD_INT 20
14000: PUSH
14001: LD_INT 21
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 72
14009: PUSH
14010: LD_INT 26
14012: PUSH
14013: LD_INT 69
14015: PUSH
14016: LD_INT 39
14018: PUSH
14019: LD_INT 40
14021: PUSH
14022: LD_INT 41
14024: PUSH
14025: LD_INT 42
14027: PUSH
14028: LD_INT 43
14030: PUSH
14031: LD_INT 48
14033: PUSH
14034: LD_INT 49
14036: PUSH
14037: LD_INT 50
14039: PUSH
14040: LD_INT 51
14042: PUSH
14043: LD_INT 52
14045: PUSH
14046: LD_INT 53
14048: PUSH
14049: LD_INT 54
14051: PUSH
14052: LD_INT 55
14054: PUSH
14055: LD_INT 56
14057: PUSH
14058: LD_INT 60
14060: PUSH
14061: LD_INT 61
14063: PUSH
14064: LD_INT 62
14066: PUSH
14067: LD_INT 66
14069: PUSH
14070: LD_INT 67
14072: PUSH
14073: LD_INT 68
14075: PUSH
14076: LD_INT 81
14078: PUSH
14079: LD_INT 82
14081: PUSH
14082: LD_INT 83
14084: PUSH
14085: LD_INT 84
14087: PUSH
14088: LD_INT 85
14090: PUSH
14091: LD_INT 87
14093: PUSH
14094: LD_INT 88
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14386
14155: LD_INT 3
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14385
14163: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14164: LD_ADDR_VAR 0 4
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: LD_INT 47
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 82
14183: PUSH
14184: LD_INT 83
14186: PUSH
14187: LD_INT 84
14189: PUSH
14190: LD_INT 85
14192: PUSH
14193: LD_INT 86
14195: PUSH
14196: LD_INT 11
14198: PUSH
14199: LD_INT 9
14201: PUSH
14202: LD_INT 20
14204: PUSH
14205: LD_INT 19
14207: PUSH
14208: LD_INT 21
14210: PUSH
14211: LD_INT 24
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 25
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: LD_INT 37
14234: PUSH
14235: LD_INT 38
14237: PUSH
14238: LD_INT 32
14240: PUSH
14241: LD_INT 27
14243: PUSH
14244: LD_INT 33
14246: PUSH
14247: LD_INT 69
14249: PUSH
14250: LD_INT 39
14252: PUSH
14253: LD_INT 34
14255: PUSH
14256: LD_INT 40
14258: PUSH
14259: LD_INT 71
14261: PUSH
14262: LD_INT 23
14264: PUSH
14265: LD_INT 44
14267: PUSH
14268: LD_INT 48
14270: PUSH
14271: LD_INT 49
14273: PUSH
14274: LD_INT 50
14276: PUSH
14277: LD_INT 51
14279: PUSH
14280: LD_INT 52
14282: PUSH
14283: LD_INT 53
14285: PUSH
14286: LD_INT 54
14288: PUSH
14289: LD_INT 55
14291: PUSH
14292: LD_INT 56
14294: PUSH
14295: LD_INT 57
14297: PUSH
14298: LD_INT 58
14300: PUSH
14301: LD_INT 59
14303: PUSH
14304: LD_INT 63
14306: PUSH
14307: LD_INT 64
14309: PUSH
14310: LD_INT 65
14312: PUSH
14313: LD_INT 82
14315: PUSH
14316: LD_INT 83
14318: PUSH
14319: LD_INT 84
14321: PUSH
14322: LD_INT 85
14324: PUSH
14325: LD_INT 86
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: ST_TO_ADDR
14383: GO 14386
14385: POP
// if state > - 1 and state < 3 then
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: NEG
14394: GREATER
14395: PUSH
14396: LD_VAR 0 3
14400: PUSH
14401: LD_INT 3
14403: LESS
14404: AND
14405: IFFALSE 14462
// for i in result do
14407: LD_ADDR_VAR 0 5
14411: PUSH
14412: LD_VAR 0 4
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14460
// if GetTech ( i , side ) <> state then
14420: LD_VAR 0 5
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 321
14434: PUSH
14435: LD_VAR 0 3
14439: NONEQUAL
14440: IFFALSE 14458
// result := result diff i ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: DIFF
14457: ST_TO_ADDR
14458: GO 14417
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// result := true ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: LD_INT 1
14479: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: LD_VAR 0 2
14489: PPUSH
14490: CALL_OW 480
14494: ST_TO_ADDR
// if not tmp then
14495: LD_VAR 0 5
14499: NOT
14500: IFFALSE 14504
// exit ;
14502: GO 14553
// for i in tmp do
14504: LD_ADDR_VAR 0 4
14508: PUSH
14509: LD_VAR 0 5
14513: PUSH
14514: FOR_IN
14515: IFFALSE 14551
// if GetTech ( i , side ) <> state_researched then
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 321
14531: PUSH
14532: LD_INT 2
14534: NONEQUAL
14535: IFFALSE 14549
// begin result := false ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 0
14544: ST_TO_ADDR
// exit ;
14545: POP
14546: POP
14547: GO 14553
// end ;
14549: GO 14514
14551: POP
14552: POP
// end ;
14553: LD_VAR 0 3
14557: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
14572: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14573: LD_VAR 0 1
14577: NOT
14578: PUSH
14579: LD_VAR 0 1
14583: PPUSH
14584: CALL_OW 257
14588: PUSH
14589: LD_INT 9
14591: NONEQUAL
14592: OR
14593: IFFALSE 14597
// exit ;
14595: GO 15170
// side := GetSide ( unit ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 255
14611: ST_TO_ADDR
// tech_space := tech_spacanom ;
14612: LD_ADDR_VAR 0 12
14616: PUSH
14617: LD_INT 29
14619: ST_TO_ADDR
// tech_time := tech_taurad ;
14620: LD_ADDR_VAR 0 13
14624: PUSH
14625: LD_INT 28
14627: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14628: LD_ADDR_VAR 0 11
14632: PUSH
14633: LD_VAR 0 1
14637: PPUSH
14638: CALL_OW 310
14642: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14643: LD_VAR 0 11
14647: PPUSH
14648: CALL_OW 247
14652: PUSH
14653: LD_INT 2
14655: EQUAL
14656: IFFALSE 14660
// exit ;
14658: GO 15170
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_INT 81
14667: PUSH
14668: LD_VAR 0 9
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: ST_TO_ADDR
// if not tmp then
14703: LD_VAR 0 8
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15170
// if in_unit then
14712: LD_VAR 0 11
14716: IFFALSE 14740
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14718: LD_ADDR_VAR 0 10
14722: PUSH
14723: LD_VAR 0 8
14727: PPUSH
14728: LD_VAR 0 11
14732: PPUSH
14733: CALL_OW 74
14737: ST_TO_ADDR
14738: GO 14760
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14740: LD_ADDR_VAR 0 10
14744: PUSH
14745: LD_VAR 0 8
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: ST_TO_ADDR
// if not enemy then
14760: LD_VAR 0 10
14764: NOT
14765: IFFALSE 14769
// exit ;
14767: GO 15170
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14769: LD_VAR 0 11
14773: PUSH
14774: LD_VAR 0 11
14778: PPUSH
14779: LD_VAR 0 10
14783: PPUSH
14784: CALL_OW 296
14788: PUSH
14789: LD_INT 13
14791: GREATER
14792: AND
14793: PUSH
14794: LD_VAR 0 1
14798: PPUSH
14799: LD_VAR 0 10
14803: PPUSH
14804: CALL_OW 296
14808: PUSH
14809: LD_INT 12
14811: GREATER
14812: OR
14813: IFFALSE 14817
// exit ;
14815: GO 15170
// missile := [ 1 ] ;
14817: LD_ADDR_VAR 0 14
14821: PUSH
14822: LD_INT 1
14824: PUSH
14825: EMPTY
14826: LIST
14827: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14828: LD_VAR 0 9
14832: PPUSH
14833: LD_VAR 0 12
14837: PPUSH
14838: CALL_OW 325
14842: IFFALSE 14871
// missile := Replace ( missile , missile + 1 , 2 ) ;
14844: LD_ADDR_VAR 0 14
14848: PUSH
14849: LD_VAR 0 14
14853: PPUSH
14854: LD_VAR 0 14
14858: PUSH
14859: LD_INT 1
14861: PLUS
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 1
14870: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 13
14880: PPUSH
14881: CALL_OW 325
14885: PUSH
14886: LD_VAR 0 10
14890: PPUSH
14891: CALL_OW 255
14895: PPUSH
14896: LD_VAR 0 13
14900: PPUSH
14901: CALL_OW 325
14905: NOT
14906: AND
14907: IFFALSE 14936
// missile := Replace ( missile , missile + 1 , 3 ) ;
14909: LD_ADDR_VAR 0 14
14913: PUSH
14914: LD_VAR 0 14
14918: PPUSH
14919: LD_VAR 0 14
14923: PUSH
14924: LD_INT 1
14926: PLUS
14927: PPUSH
14928: LD_INT 3
14930: PPUSH
14931: CALL_OW 1
14935: ST_TO_ADDR
// if missile < 2 then
14936: LD_VAR 0 14
14940: PUSH
14941: LD_INT 2
14943: LESS
14944: IFFALSE 14948
// exit ;
14946: GO 15170
// x := GetX ( enemy ) ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 250
14962: ST_TO_ADDR
// y := GetY ( enemy ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 10
14972: PPUSH
14973: CALL_OW 251
14977: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: NEG
14991: PPUSH
14992: LD_INT 1
14994: PPUSH
14995: CALL_OW 12
14999: PLUS
15000: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15001: LD_ADDR_VAR 0 7
15005: PUSH
15006: LD_VAR 0 5
15010: PUSH
15011: LD_INT 1
15013: NEG
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 12
15022: PLUS
15023: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15024: LD_VAR 0 6
15028: PPUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: CALL_OW 488
15038: NOT
15039: IFFALSE 15061
// begin _x := x ;
15041: LD_ADDR_VAR 0 6
15045: PUSH
15046: LD_VAR 0 4
15050: ST_TO_ADDR
// _y := y ;
15051: LD_ADDR_VAR 0 7
15055: PUSH
15056: LD_VAR 0 5
15060: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 1
15068: PPUSH
15069: LD_VAR 0 14
15073: PPUSH
15074: CALL_OW 12
15078: ST_TO_ADDR
// case i of 1 :
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: DOUBLE
15087: EQUAL
15088: IFTRUE 15092
15090: GO 15109
15092: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15093: LD_VAR 0 1
15097: PPUSH
15098: LD_VAR 0 10
15102: PPUSH
15103: CALL_OW 115
15107: GO 15170
15109: LD_INT 2
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15139
15117: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15118: LD_VAR 0 1
15122: PPUSH
15123: LD_VAR 0 6
15127: PPUSH
15128: LD_VAR 0 7
15132: PPUSH
15133: CALL_OW 153
15137: GO 15170
15139: LD_INT 3
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15169
15147: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 6
15157: PPUSH
15158: LD_VAR 0 7
15162: PPUSH
15163: CALL_OW 154
15167: GO 15170
15169: POP
// end ;
15170: LD_VAR 0 2
15174: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
// if not unit or not building then
15183: LD_VAR 0 1
15187: NOT
15188: PUSH
15189: LD_VAR 0 2
15193: NOT
15194: OR
15195: IFFALSE 15199
// exit ;
15197: GO 15357
// x := GetX ( building ) ;
15199: LD_ADDR_VAR 0 5
15203: PUSH
15204: LD_VAR 0 2
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// y := GetY ( building ) ;
15214: LD_ADDR_VAR 0 6
15218: PUSH
15219: LD_VAR 0 2
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// for i = 0 to 5 do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 0
15237: DEC
15238: ST_TO_ADDR
15239: LD_INT 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15355
// begin _x := ShiftX ( x , i , 3 ) ;
15245: LD_ADDR_VAR 0 7
15249: PUSH
15250: LD_VAR 0 5
15254: PPUSH
15255: LD_VAR 0 4
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 272
15267: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15268: LD_ADDR_VAR 0 8
15272: PUSH
15273: LD_VAR 0 6
15277: PPUSH
15278: LD_VAR 0 4
15282: PPUSH
15283: LD_INT 3
15285: PPUSH
15286: CALL_OW 273
15290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15291: LD_VAR 0 7
15295: PPUSH
15296: LD_VAR 0 8
15300: PPUSH
15301: CALL_OW 488
15305: NOT
15306: IFFALSE 15310
// continue ;
15308: GO 15242
// if HexInfo ( _x , _y ) = 0 then
15310: LD_VAR 0 7
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 428
15324: PUSH
15325: LD_INT 0
15327: EQUAL
15328: IFFALSE 15353
// begin ComMoveXY ( unit , _x , _y ) ;
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 7
15339: PPUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: CALL_OW 111
// exit ;
15349: POP
15350: POP
15351: GO 15357
// end ; end ;
15353: GO 15242
15355: POP
15356: POP
// end ;
15357: LD_VAR 0 3
15361: RET
// export function ScanBase ( side , base_area ) ; begin
15362: LD_INT 0
15364: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15365: LD_ADDR_VAR 0 3
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_INT 81
15377: PUSH
15378: LD_VAR 0 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 70
15391: ST_TO_ADDR
// end ;
15392: LD_VAR 0 3
15396: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15397: LD_INT 0
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// result := false ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// side := GetSide ( unit ) ;
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 255
15425: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15426: LD_ADDR_VAR 0 4
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 248
15440: ST_TO_ADDR
// case nat of 1 :
15441: LD_VAR 0 4
15445: PUSH
15446: LD_INT 1
15448: DOUBLE
15449: EQUAL
15450: IFTRUE 15454
15452: GO 15465
15454: POP
// tech := tech_lassight ; 2 :
15455: LD_ADDR_VAR 0 5
15459: PUSH
15460: LD_INT 12
15462: ST_TO_ADDR
15463: GO 15504
15465: LD_INT 2
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15484
15473: POP
// tech := tech_mortar ; 3 :
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_INT 41
15481: ST_TO_ADDR
15482: GO 15504
15484: LD_INT 3
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15503
15492: POP
// tech := tech_bazooka ; end ;
15493: LD_ADDR_VAR 0 5
15497: PUSH
15498: LD_INT 44
15500: ST_TO_ADDR
15501: GO 15504
15503: POP
// if Researched ( side , tech ) then
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_VAR 0 5
15513: PPUSH
15514: CALL_OW 325
15518: IFFALSE 15545
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15520: LD_ADDR_VAR 0 2
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 8
15530: PUSH
15531: LD_INT 9
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: PUSH
15539: LD_VAR 0 4
15543: ARRAY
15544: ST_TO_ADDR
// end ;
15545: LD_VAR 0 2
15549: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15550: LD_INT 0
15552: PPUSH
15553: PPUSH
15554: PPUSH
// if not mines then
15555: LD_VAR 0 2
15559: NOT
15560: IFFALSE 15564
// exit ;
15562: GO 15708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_INT 81
15571: PUSH
15572: LD_VAR 0 1
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 3
15583: PUSH
15584: LD_INT 21
15586: PUSH
15587: LD_INT 3
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: ST_TO_ADDR
// for i in mines do
15607: LD_ADDR_VAR 0 4
15611: PUSH
15612: LD_VAR 0 2
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15706
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: CALL_OW 458
15642: NOT
15643: IFFALSE 15647
// continue ;
15645: GO 15617
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: PPUSH
15656: LD_VAR 0 4
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: CALL_OW 428
15669: PUSH
15670: LD_VAR 0 5
15674: IN
15675: IFFALSE 15704
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 4
15690: PUSH
15691: LD_INT 2
15693: ARRAY
15694: PPUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 456
// end ;
15704: GO 15617
15706: POP
15707: POP
// end ;
15708: LD_VAR 0 3
15712: RET
// export function Count ( array ) ; var i ; begin
15713: LD_INT 0
15715: PPUSH
15716: PPUSH
// result := 0 ;
15717: LD_ADDR_VAR 0 2
15721: PUSH
15722: LD_INT 0
15724: ST_TO_ADDR
// for i in array do
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_VAR 0 1
15734: PUSH
15735: FOR_IN
15736: IFFALSE 15760
// if i then
15738: LD_VAR 0 3
15742: IFFALSE 15758
// result := result + 1 ;
15744: LD_ADDR_VAR 0 2
15748: PUSH
15749: LD_VAR 0 2
15753: PUSH
15754: LD_INT 1
15756: PLUS
15757: ST_TO_ADDR
15758: GO 15735
15760: POP
15761: POP
// end ;
15762: LD_VAR 0 2
15766: RET
// export function IsEmpty ( building ) ; begin
15767: LD_INT 0
15769: PPUSH
// if not building then
15770: LD_VAR 0 1
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 15822
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15779: LD_ADDR_VAR 0 2
15783: PUSH
15784: LD_VAR 0 1
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_VAR 0 1
15796: PPUSH
15797: CALL_OW 255
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 58
15808: PUSH
15809: EMPTY
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: IN
15821: ST_TO_ADDR
// end ;
15822: LD_VAR 0 2
15826: RET
// export function IsNotFull ( building ) ; begin
15827: LD_INT 0
15829: PPUSH
// if not building then
15830: LD_VAR 0 1
15834: NOT
15835: IFFALSE 15839
// exit ;
15837: GO 15858
// result := UnitsInside ( building ) < 6 ;
15839: LD_ADDR_VAR 0 2
15843: PUSH
15844: LD_VAR 0 1
15848: PPUSH
15849: CALL_OW 313
15853: PUSH
15854: LD_INT 6
15856: LESS
15857: ST_TO_ADDR
// end ;
15858: LD_VAR 0 2
15862: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15863: LD_INT 0
15865: PPUSH
15866: PPUSH
15867: PPUSH
15868: PPUSH
// tmp := [ ] ;
15869: LD_ADDR_VAR 0 3
15873: PUSH
15874: EMPTY
15875: ST_TO_ADDR
// list := [ ] ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: EMPTY
15882: ST_TO_ADDR
// for i = 16 to 25 do
15883: LD_ADDR_VAR 0 4
15887: PUSH
15888: DOUBLE
15889: LD_INT 16
15891: DEC
15892: ST_TO_ADDR
15893: LD_INT 25
15895: PUSH
15896: FOR_TO
15897: IFFALSE 15970
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15899: LD_ADDR_VAR 0 3
15903: PUSH
15904: LD_VAR 0 3
15908: PUSH
15909: LD_INT 22
15911: PUSH
15912: LD_VAR 0 1
15916: PPUSH
15917: CALL_OW 255
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 91
15928: PUSH
15929: LD_VAR 0 1
15933: PUSH
15934: LD_INT 6
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: LIST
15941: PUSH
15942: LD_INT 30
15944: PUSH
15945: LD_VAR 0 4
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: LIST
15958: PUSH
15959: EMPTY
15960: LIST
15961: PPUSH
15962: CALL_OW 69
15966: ADD
15967: ST_TO_ADDR
15968: GO 15896
15970: POP
15971: POP
// for i = 1 to tmp do
15972: LD_ADDR_VAR 0 4
15976: PUSH
15977: DOUBLE
15978: LD_INT 1
15980: DEC
15981: ST_TO_ADDR
15982: LD_VAR 0 3
15986: PUSH
15987: FOR_TO
15988: IFFALSE 16076
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15990: LD_ADDR_VAR 0 5
15994: PUSH
15995: LD_VAR 0 5
15999: PUSH
16000: LD_VAR 0 3
16004: PUSH
16005: LD_VAR 0 4
16009: ARRAY
16010: PPUSH
16011: CALL_OW 266
16015: PUSH
16016: LD_VAR 0 3
16020: PUSH
16021: LD_VAR 0 4
16025: ARRAY
16026: PPUSH
16027: CALL_OW 250
16031: PUSH
16032: LD_VAR 0 3
16036: PUSH
16037: LD_VAR 0 4
16041: ARRAY
16042: PPUSH
16043: CALL_OW 251
16047: PUSH
16048: LD_VAR 0 3
16052: PUSH
16053: LD_VAR 0 4
16057: ARRAY
16058: PPUSH
16059: CALL_OW 254
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: LIST
16068: LIST
16069: PUSH
16070: EMPTY
16071: LIST
16072: ADD
16073: ST_TO_ADDR
16074: GO 15987
16076: POP
16077: POP
// result := list ;
16078: LD_ADDR_VAR 0 2
16082: PUSH
16083: LD_VAR 0 5
16087: ST_TO_ADDR
// end ;
16088: LD_VAR 0 2
16092: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16093: LD_INT 0
16095: PPUSH
16096: PPUSH
16097: PPUSH
16098: PPUSH
16099: PPUSH
16100: PPUSH
16101: PPUSH
// if not factory then
16102: LD_VAR 0 1
16106: NOT
16107: IFFALSE 16111
// exit ;
16109: GO 16704
// if control = control_apeman then
16111: LD_VAR 0 4
16115: PUSH
16116: LD_INT 5
16118: EQUAL
16119: IFFALSE 16228
// begin tmp := UnitsInside ( factory ) ;
16121: LD_ADDR_VAR 0 8
16125: PUSH
16126: LD_VAR 0 1
16130: PPUSH
16131: CALL_OW 313
16135: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16136: LD_VAR 0 8
16140: PPUSH
16141: LD_INT 25
16143: PUSH
16144: LD_INT 12
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 72
16155: NOT
16156: IFFALSE 16166
// control := control_manual ;
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: LD_INT 1
16165: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16166: LD_ADDR_VAR 0 8
16170: PUSH
16171: LD_VAR 0 1
16175: PPUSH
16176: CALL 15863 0 1
16180: ST_TO_ADDR
// if tmp then
16181: LD_VAR 0 8
16185: IFFALSE 16228
// begin for i in tmp do
16187: LD_ADDR_VAR 0 7
16191: PUSH
16192: LD_VAR 0 8
16196: PUSH
16197: FOR_IN
16198: IFFALSE 16226
// if i [ 1 ] = b_ext_radio then
16200: LD_VAR 0 7
16204: PUSH
16205: LD_INT 1
16207: ARRAY
16208: PUSH
16209: LD_INT 22
16211: EQUAL
16212: IFFALSE 16224
// begin control := control_remote ;
16214: LD_ADDR_VAR 0 4
16218: PUSH
16219: LD_INT 2
16221: ST_TO_ADDR
// break ;
16222: GO 16226
// end ;
16224: GO 16197
16226: POP
16227: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16228: LD_VAR 0 1
16232: PPUSH
16233: LD_VAR 0 2
16237: PPUSH
16238: LD_VAR 0 3
16242: PPUSH
16243: LD_VAR 0 4
16247: PPUSH
16248: LD_VAR 0 5
16252: PPUSH
16253: CALL_OW 448
16257: IFFALSE 16292
// begin result := [ chassis , engine , control , weapon ] ;
16259: LD_ADDR_VAR 0 6
16263: PUSH
16264: LD_VAR 0 2
16268: PUSH
16269: LD_VAR 0 3
16273: PUSH
16274: LD_VAR 0 4
16278: PUSH
16279: LD_VAR 0 5
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: LIST
16288: LIST
16289: ST_TO_ADDR
// exit ;
16290: GO 16704
// end ; _chassis := AvailableChassisList ( factory ) ;
16292: LD_ADDR_VAR 0 9
16296: PUSH
16297: LD_VAR 0 1
16301: PPUSH
16302: CALL_OW 475
16306: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16307: LD_ADDR_VAR 0 11
16311: PUSH
16312: LD_VAR 0 1
16316: PPUSH
16317: CALL_OW 476
16321: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16322: LD_ADDR_VAR 0 12
16326: PUSH
16327: LD_VAR 0 1
16331: PPUSH
16332: CALL_OW 477
16336: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16337: LD_ADDR_VAR 0 10
16341: PUSH
16342: LD_VAR 0 1
16346: PPUSH
16347: CALL_OW 478
16351: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16352: LD_VAR 0 9
16356: NOT
16357: PUSH
16358: LD_VAR 0 11
16362: NOT
16363: OR
16364: PUSH
16365: LD_VAR 0 12
16369: NOT
16370: OR
16371: PUSH
16372: LD_VAR 0 10
16376: NOT
16377: OR
16378: IFFALSE 16413
// begin result := [ chassis , engine , control , weapon ] ;
16380: LD_ADDR_VAR 0 6
16384: PUSH
16385: LD_VAR 0 2
16389: PUSH
16390: LD_VAR 0 3
16394: PUSH
16395: LD_VAR 0 4
16399: PUSH
16400: LD_VAR 0 5
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: LIST
16409: LIST
16410: ST_TO_ADDR
// exit ;
16411: GO 16704
// end ; if not chassis in _chassis then
16413: LD_VAR 0 2
16417: PUSH
16418: LD_VAR 0 9
16422: IN
16423: NOT
16424: IFFALSE 16450
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16426: LD_ADDR_VAR 0 2
16430: PUSH
16431: LD_VAR 0 9
16435: PUSH
16436: LD_INT 1
16438: PPUSH
16439: LD_VAR 0 9
16443: PPUSH
16444: CALL_OW 12
16448: ARRAY
16449: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16450: LD_VAR 0 2
16454: PPUSH
16455: LD_VAR 0 3
16459: PPUSH
16460: CALL 16709 0 2
16464: NOT
16465: IFFALSE 16524
// repeat engine := _engine [ 1 ] ;
16467: LD_ADDR_VAR 0 3
16471: PUSH
16472: LD_VAR 0 11
16476: PUSH
16477: LD_INT 1
16479: ARRAY
16480: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16481: LD_ADDR_VAR 0 11
16485: PUSH
16486: LD_VAR 0 11
16490: PPUSH
16491: LD_INT 1
16493: PPUSH
16494: CALL_OW 3
16498: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16499: LD_VAR 0 2
16503: PPUSH
16504: LD_VAR 0 3
16508: PPUSH
16509: CALL 16709 0 2
16513: PUSH
16514: LD_VAR 0 11
16518: PUSH
16519: EMPTY
16520: EQUAL
16521: OR
16522: IFFALSE 16467
// if not control in _control then
16524: LD_VAR 0 4
16528: PUSH
16529: LD_VAR 0 12
16533: IN
16534: NOT
16535: IFFALSE 16561
// control := _control [ rand ( 1 , _control ) ] ;
16537: LD_ADDR_VAR 0 4
16541: PUSH
16542: LD_VAR 0 12
16546: PUSH
16547: LD_INT 1
16549: PPUSH
16550: LD_VAR 0 12
16554: PPUSH
16555: CALL_OW 12
16559: ARRAY
16560: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16561: LD_VAR 0 2
16565: PPUSH
16566: LD_VAR 0 5
16570: PPUSH
16571: CALL 16929 0 2
16575: NOT
16576: IFFALSE 16635
// repeat weapon := _weapon [ 1 ] ;
16578: LD_ADDR_VAR 0 5
16582: PUSH
16583: LD_VAR 0 10
16587: PUSH
16588: LD_INT 1
16590: ARRAY
16591: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16592: LD_ADDR_VAR 0 10
16596: PUSH
16597: LD_VAR 0 10
16601: PPUSH
16602: LD_INT 1
16604: PPUSH
16605: CALL_OW 3
16609: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16610: LD_VAR 0 2
16614: PPUSH
16615: LD_VAR 0 5
16619: PPUSH
16620: CALL 16929 0 2
16624: PUSH
16625: LD_VAR 0 10
16629: PUSH
16630: EMPTY
16631: EQUAL
16632: OR
16633: IFFALSE 16578
// result := [ ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: EMPTY
16641: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16642: LD_VAR 0 1
16646: PPUSH
16647: LD_VAR 0 2
16651: PPUSH
16652: LD_VAR 0 3
16656: PPUSH
16657: LD_VAR 0 4
16661: PPUSH
16662: LD_VAR 0 5
16666: PPUSH
16667: CALL_OW 448
16671: IFFALSE 16704
// result := [ chassis , engine , control , weapon ] ;
16673: LD_ADDR_VAR 0 6
16677: PUSH
16678: LD_VAR 0 2
16682: PUSH
16683: LD_VAR 0 3
16687: PUSH
16688: LD_VAR 0 4
16692: PUSH
16693: LD_VAR 0 5
16697: PUSH
16698: EMPTY
16699: LIST
16700: LIST
16701: LIST
16702: LIST
16703: ST_TO_ADDR
// end ;
16704: LD_VAR 0 6
16708: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16709: LD_INT 0
16711: PPUSH
// if not chassis or not engine then
16712: LD_VAR 0 1
16716: NOT
16717: PUSH
16718: LD_VAR 0 2
16722: NOT
16723: OR
16724: IFFALSE 16728
// exit ;
16726: GO 16924
// case engine of engine_solar :
16728: LD_VAR 0 2
16732: PUSH
16733: LD_INT 2
16735: DOUBLE
16736: EQUAL
16737: IFTRUE 16741
16739: GO 16779
16741: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16742: LD_ADDR_VAR 0 3
16746: PUSH
16747: LD_INT 11
16749: PUSH
16750: LD_INT 12
16752: PUSH
16753: LD_INT 13
16755: PUSH
16756: LD_INT 14
16758: PUSH
16759: LD_INT 1
16761: PUSH
16762: LD_INT 2
16764: PUSH
16765: LD_INT 3
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: LIST
16772: LIST
16773: LIST
16774: LIST
16775: LIST
16776: ST_TO_ADDR
16777: GO 16908
16779: LD_INT 1
16781: DOUBLE
16782: EQUAL
16783: IFTRUE 16787
16785: GO 16849
16787: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16788: LD_ADDR_VAR 0 3
16792: PUSH
16793: LD_INT 11
16795: PUSH
16796: LD_INT 12
16798: PUSH
16799: LD_INT 13
16801: PUSH
16802: LD_INT 14
16804: PUSH
16805: LD_INT 1
16807: PUSH
16808: LD_INT 2
16810: PUSH
16811: LD_INT 3
16813: PUSH
16814: LD_INT 4
16816: PUSH
16817: LD_INT 5
16819: PUSH
16820: LD_INT 21
16822: PUSH
16823: LD_INT 23
16825: PUSH
16826: LD_INT 22
16828: PUSH
16829: LD_INT 24
16831: PUSH
16832: EMPTY
16833: LIST
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: LIST
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: LIST
16846: ST_TO_ADDR
16847: GO 16908
16849: LD_INT 3
16851: DOUBLE
16852: EQUAL
16853: IFTRUE 16857
16855: GO 16907
16857: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16858: LD_ADDR_VAR 0 3
16862: PUSH
16863: LD_INT 13
16865: PUSH
16866: LD_INT 14
16868: PUSH
16869: LD_INT 2
16871: PUSH
16872: LD_INT 3
16874: PUSH
16875: LD_INT 4
16877: PUSH
16878: LD_INT 5
16880: PUSH
16881: LD_INT 21
16883: PUSH
16884: LD_INT 22
16886: PUSH
16887: LD_INT 23
16889: PUSH
16890: LD_INT 24
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: ST_TO_ADDR
16905: GO 16908
16907: POP
// result := ( chassis in result ) ;
16908: LD_ADDR_VAR 0 3
16912: PUSH
16913: LD_VAR 0 1
16917: PUSH
16918: LD_VAR 0 3
16922: IN
16923: ST_TO_ADDR
// end ;
16924: LD_VAR 0 3
16928: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16929: LD_INT 0
16931: PPUSH
// if not chassis or not weapon then
16932: LD_VAR 0 1
16936: NOT
16937: PUSH
16938: LD_VAR 0 2
16942: NOT
16943: OR
16944: IFFALSE 16948
// exit ;
16946: GO 18010
// case weapon of us_machine_gun :
16948: LD_VAR 0 2
16952: PUSH
16953: LD_INT 2
16955: DOUBLE
16956: EQUAL
16957: IFTRUE 16961
16959: GO 16991
16961: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16962: LD_ADDR_VAR 0 3
16966: PUSH
16967: LD_INT 1
16969: PUSH
16970: LD_INT 2
16972: PUSH
16973: LD_INT 3
16975: PUSH
16976: LD_INT 4
16978: PUSH
16979: LD_INT 5
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: LIST
16988: ST_TO_ADDR
16989: GO 17994
16991: LD_INT 3
16993: DOUBLE
16994: EQUAL
16995: IFTRUE 16999
16997: GO 17029
16999: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17000: LD_ADDR_VAR 0 3
17004: PUSH
17005: LD_INT 1
17007: PUSH
17008: LD_INT 2
17010: PUSH
17011: LD_INT 3
17013: PUSH
17014: LD_INT 4
17016: PUSH
17017: LD_INT 5
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: LIST
17024: LIST
17025: LIST
17026: ST_TO_ADDR
17027: GO 17994
17029: LD_INT 11
17031: DOUBLE
17032: EQUAL
17033: IFTRUE 17037
17035: GO 17067
17037: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17038: LD_ADDR_VAR 0 3
17042: PUSH
17043: LD_INT 1
17045: PUSH
17046: LD_INT 2
17048: PUSH
17049: LD_INT 3
17051: PUSH
17052: LD_INT 4
17054: PUSH
17055: LD_INT 5
17057: PUSH
17058: EMPTY
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: ST_TO_ADDR
17065: GO 17994
17067: LD_INT 4
17069: DOUBLE
17070: EQUAL
17071: IFTRUE 17075
17073: GO 17101
17075: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17076: LD_ADDR_VAR 0 3
17080: PUSH
17081: LD_INT 2
17083: PUSH
17084: LD_INT 3
17086: PUSH
17087: LD_INT 4
17089: PUSH
17090: LD_INT 5
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: LIST
17097: LIST
17098: ST_TO_ADDR
17099: GO 17994
17101: LD_INT 5
17103: DOUBLE
17104: EQUAL
17105: IFTRUE 17109
17107: GO 17135
17109: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17110: LD_ADDR_VAR 0 3
17114: PUSH
17115: LD_INT 2
17117: PUSH
17118: LD_INT 3
17120: PUSH
17121: LD_INT 4
17123: PUSH
17124: LD_INT 5
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: LIST
17131: LIST
17132: ST_TO_ADDR
17133: GO 17994
17135: LD_INT 9
17137: DOUBLE
17138: EQUAL
17139: IFTRUE 17143
17141: GO 17169
17143: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_INT 2
17151: PUSH
17152: LD_INT 3
17154: PUSH
17155: LD_INT 4
17157: PUSH
17158: LD_INT 5
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: LIST
17165: LIST
17166: ST_TO_ADDR
17167: GO 17994
17169: LD_INT 7
17171: DOUBLE
17172: EQUAL
17173: IFTRUE 17177
17175: GO 17203
17177: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17178: LD_ADDR_VAR 0 3
17182: PUSH
17183: LD_INT 2
17185: PUSH
17186: LD_INT 3
17188: PUSH
17189: LD_INT 4
17191: PUSH
17192: LD_INT 5
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: ST_TO_ADDR
17201: GO 17994
17203: LD_INT 12
17205: DOUBLE
17206: EQUAL
17207: IFTRUE 17211
17209: GO 17237
17211: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17212: LD_ADDR_VAR 0 3
17216: PUSH
17217: LD_INT 2
17219: PUSH
17220: LD_INT 3
17222: PUSH
17223: LD_INT 4
17225: PUSH
17226: LD_INT 5
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: LIST
17233: LIST
17234: ST_TO_ADDR
17235: GO 17994
17237: LD_INT 13
17239: DOUBLE
17240: EQUAL
17241: IFTRUE 17245
17243: GO 17271
17245: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17246: LD_ADDR_VAR 0 3
17250: PUSH
17251: LD_INT 2
17253: PUSH
17254: LD_INT 3
17256: PUSH
17257: LD_INT 4
17259: PUSH
17260: LD_INT 5
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: LIST
17267: LIST
17268: ST_TO_ADDR
17269: GO 17994
17271: LD_INT 14
17273: DOUBLE
17274: EQUAL
17275: IFTRUE 17279
17277: GO 17297
17279: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17280: LD_ADDR_VAR 0 3
17284: PUSH
17285: LD_INT 4
17287: PUSH
17288: LD_INT 5
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: ST_TO_ADDR
17295: GO 17994
17297: LD_INT 6
17299: DOUBLE
17300: EQUAL
17301: IFTRUE 17305
17303: GO 17323
17305: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17306: LD_ADDR_VAR 0 3
17310: PUSH
17311: LD_INT 4
17313: PUSH
17314: LD_INT 5
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: ST_TO_ADDR
17321: GO 17994
17323: LD_INT 10
17325: DOUBLE
17326: EQUAL
17327: IFTRUE 17331
17329: GO 17349
17331: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17332: LD_ADDR_VAR 0 3
17336: PUSH
17337: LD_INT 4
17339: PUSH
17340: LD_INT 5
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: ST_TO_ADDR
17347: GO 17994
17349: LD_INT 22
17351: DOUBLE
17352: EQUAL
17353: IFTRUE 17357
17355: GO 17383
17357: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17358: LD_ADDR_VAR 0 3
17362: PUSH
17363: LD_INT 11
17365: PUSH
17366: LD_INT 12
17368: PUSH
17369: LD_INT 13
17371: PUSH
17372: LD_INT 14
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: ST_TO_ADDR
17381: GO 17994
17383: LD_INT 23
17385: DOUBLE
17386: EQUAL
17387: IFTRUE 17391
17389: GO 17417
17391: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17392: LD_ADDR_VAR 0 3
17396: PUSH
17397: LD_INT 11
17399: PUSH
17400: LD_INT 12
17402: PUSH
17403: LD_INT 13
17405: PUSH
17406: LD_INT 14
17408: PUSH
17409: EMPTY
17410: LIST
17411: LIST
17412: LIST
17413: LIST
17414: ST_TO_ADDR
17415: GO 17994
17417: LD_INT 24
17419: DOUBLE
17420: EQUAL
17421: IFTRUE 17425
17423: GO 17451
17425: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17426: LD_ADDR_VAR 0 3
17430: PUSH
17431: LD_INT 11
17433: PUSH
17434: LD_INT 12
17436: PUSH
17437: LD_INT 13
17439: PUSH
17440: LD_INT 14
17442: PUSH
17443: EMPTY
17444: LIST
17445: LIST
17446: LIST
17447: LIST
17448: ST_TO_ADDR
17449: GO 17994
17451: LD_INT 30
17453: DOUBLE
17454: EQUAL
17455: IFTRUE 17459
17457: GO 17485
17459: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17460: LD_ADDR_VAR 0 3
17464: PUSH
17465: LD_INT 11
17467: PUSH
17468: LD_INT 12
17470: PUSH
17471: LD_INT 13
17473: PUSH
17474: LD_INT 14
17476: PUSH
17477: EMPTY
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: ST_TO_ADDR
17483: GO 17994
17485: LD_INT 25
17487: DOUBLE
17488: EQUAL
17489: IFTRUE 17493
17491: GO 17511
17493: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17494: LD_ADDR_VAR 0 3
17498: PUSH
17499: LD_INT 13
17501: PUSH
17502: LD_INT 14
17504: PUSH
17505: EMPTY
17506: LIST
17507: LIST
17508: ST_TO_ADDR
17509: GO 17994
17511: LD_INT 27
17513: DOUBLE
17514: EQUAL
17515: IFTRUE 17519
17517: GO 17537
17519: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17520: LD_ADDR_VAR 0 3
17524: PUSH
17525: LD_INT 13
17527: PUSH
17528: LD_INT 14
17530: PUSH
17531: EMPTY
17532: LIST
17533: LIST
17534: ST_TO_ADDR
17535: GO 17994
17537: LD_EXP 53
17541: DOUBLE
17542: EQUAL
17543: IFTRUE 17547
17545: GO 17573
17547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17548: LD_ADDR_VAR 0 3
17552: PUSH
17553: LD_INT 11
17555: PUSH
17556: LD_INT 12
17558: PUSH
17559: LD_INT 13
17561: PUSH
17562: LD_INT 14
17564: PUSH
17565: EMPTY
17566: LIST
17567: LIST
17568: LIST
17569: LIST
17570: ST_TO_ADDR
17571: GO 17994
17573: LD_INT 28
17575: DOUBLE
17576: EQUAL
17577: IFTRUE 17581
17579: GO 17599
17581: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17582: LD_ADDR_VAR 0 3
17586: PUSH
17587: LD_INT 13
17589: PUSH
17590: LD_INT 14
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: ST_TO_ADDR
17597: GO 17994
17599: LD_INT 29
17601: DOUBLE
17602: EQUAL
17603: IFTRUE 17607
17605: GO 17625
17607: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17608: LD_ADDR_VAR 0 3
17612: PUSH
17613: LD_INT 13
17615: PUSH
17616: LD_INT 14
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: ST_TO_ADDR
17623: GO 17994
17625: LD_INT 31
17627: DOUBLE
17628: EQUAL
17629: IFTRUE 17633
17631: GO 17651
17633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17634: LD_ADDR_VAR 0 3
17638: PUSH
17639: LD_INT 13
17641: PUSH
17642: LD_INT 14
17644: PUSH
17645: EMPTY
17646: LIST
17647: LIST
17648: ST_TO_ADDR
17649: GO 17994
17651: LD_INT 26
17653: DOUBLE
17654: EQUAL
17655: IFTRUE 17659
17657: GO 17677
17659: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17660: LD_ADDR_VAR 0 3
17664: PUSH
17665: LD_INT 13
17667: PUSH
17668: LD_INT 14
17670: PUSH
17671: EMPTY
17672: LIST
17673: LIST
17674: ST_TO_ADDR
17675: GO 17994
17677: LD_INT 42
17679: DOUBLE
17680: EQUAL
17681: IFTRUE 17685
17683: GO 17711
17685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17686: LD_ADDR_VAR 0 3
17690: PUSH
17691: LD_INT 21
17693: PUSH
17694: LD_INT 22
17696: PUSH
17697: LD_INT 23
17699: PUSH
17700: LD_INT 24
17702: PUSH
17703: EMPTY
17704: LIST
17705: LIST
17706: LIST
17707: LIST
17708: ST_TO_ADDR
17709: GO 17994
17711: LD_INT 43
17713: DOUBLE
17714: EQUAL
17715: IFTRUE 17719
17717: GO 17745
17719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17720: LD_ADDR_VAR 0 3
17724: PUSH
17725: LD_INT 21
17727: PUSH
17728: LD_INT 22
17730: PUSH
17731: LD_INT 23
17733: PUSH
17734: LD_INT 24
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: LIST
17741: LIST
17742: ST_TO_ADDR
17743: GO 17994
17745: LD_INT 44
17747: DOUBLE
17748: EQUAL
17749: IFTRUE 17753
17751: GO 17779
17753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17754: LD_ADDR_VAR 0 3
17758: PUSH
17759: LD_INT 21
17761: PUSH
17762: LD_INT 22
17764: PUSH
17765: LD_INT 23
17767: PUSH
17768: LD_INT 24
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: ST_TO_ADDR
17777: GO 17994
17779: LD_INT 45
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17813
17787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17788: LD_ADDR_VAR 0 3
17792: PUSH
17793: LD_INT 21
17795: PUSH
17796: LD_INT 22
17798: PUSH
17799: LD_INT 23
17801: PUSH
17802: LD_INT 24
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: ST_TO_ADDR
17811: GO 17994
17813: LD_INT 49
17815: DOUBLE
17816: EQUAL
17817: IFTRUE 17821
17819: GO 17847
17821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17822: LD_ADDR_VAR 0 3
17826: PUSH
17827: LD_INT 21
17829: PUSH
17830: LD_INT 22
17832: PUSH
17833: LD_INT 23
17835: PUSH
17836: LD_INT 24
17838: PUSH
17839: EMPTY
17840: LIST
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
17845: GO 17994
17847: LD_INT 51
17849: DOUBLE
17850: EQUAL
17851: IFTRUE 17855
17853: GO 17881
17855: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17856: LD_ADDR_VAR 0 3
17860: PUSH
17861: LD_INT 21
17863: PUSH
17864: LD_INT 22
17866: PUSH
17867: LD_INT 23
17869: PUSH
17870: LD_INT 24
17872: PUSH
17873: EMPTY
17874: LIST
17875: LIST
17876: LIST
17877: LIST
17878: ST_TO_ADDR
17879: GO 17994
17881: LD_INT 52
17883: DOUBLE
17884: EQUAL
17885: IFTRUE 17889
17887: GO 17915
17889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17890: LD_ADDR_VAR 0 3
17894: PUSH
17895: LD_INT 21
17897: PUSH
17898: LD_INT 22
17900: PUSH
17901: LD_INT 23
17903: PUSH
17904: LD_INT 24
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: LIST
17911: LIST
17912: ST_TO_ADDR
17913: GO 17994
17915: LD_INT 53
17917: DOUBLE
17918: EQUAL
17919: IFTRUE 17923
17921: GO 17941
17923: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17924: LD_ADDR_VAR 0 3
17928: PUSH
17929: LD_INT 23
17931: PUSH
17932: LD_INT 24
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: ST_TO_ADDR
17939: GO 17994
17941: LD_INT 46
17943: DOUBLE
17944: EQUAL
17945: IFTRUE 17949
17947: GO 17967
17949: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17950: LD_ADDR_VAR 0 3
17954: PUSH
17955: LD_INT 23
17957: PUSH
17958: LD_INT 24
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: ST_TO_ADDR
17965: GO 17994
17967: LD_INT 47
17969: DOUBLE
17970: EQUAL
17971: IFTRUE 17975
17973: GO 17993
17975: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17976: LD_ADDR_VAR 0 3
17980: PUSH
17981: LD_INT 23
17983: PUSH
17984: LD_INT 24
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: ST_TO_ADDR
17991: GO 17994
17993: POP
// result := ( chassis in result ) ;
17994: LD_ADDR_VAR 0 3
17998: PUSH
17999: LD_VAR 0 1
18003: PUSH
18004: LD_VAR 0 3
18008: IN
18009: ST_TO_ADDR
// end ;
18010: LD_VAR 0 3
18014: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18015: LD_INT 0
18017: PPUSH
18018: PPUSH
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
18023: PPUSH
// result := array ;
18024: LD_ADDR_VAR 0 5
18028: PUSH
18029: LD_VAR 0 1
18033: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18034: LD_VAR 0 1
18038: NOT
18039: PUSH
18040: LD_VAR 0 2
18044: NOT
18045: OR
18046: PUSH
18047: LD_VAR 0 3
18051: NOT
18052: OR
18053: PUSH
18054: LD_VAR 0 2
18058: PUSH
18059: LD_VAR 0 1
18063: GREATER
18064: OR
18065: PUSH
18066: LD_VAR 0 3
18070: PUSH
18071: LD_VAR 0 1
18075: GREATER
18076: OR
18077: IFFALSE 18081
// exit ;
18079: GO 18377
// if direction then
18081: LD_VAR 0 4
18085: IFFALSE 18149
// begin d := 1 ;
18087: LD_ADDR_VAR 0 9
18091: PUSH
18092: LD_INT 1
18094: ST_TO_ADDR
// if i_from > i_to then
18095: LD_VAR 0 2
18099: PUSH
18100: LD_VAR 0 3
18104: GREATER
18105: IFFALSE 18131
// length := ( array - i_from ) + i_to else
18107: LD_ADDR_VAR 0 11
18111: PUSH
18112: LD_VAR 0 1
18116: PUSH
18117: LD_VAR 0 2
18121: MINUS
18122: PUSH
18123: LD_VAR 0 3
18127: PLUS
18128: ST_TO_ADDR
18129: GO 18147
// length := i_to - i_from ;
18131: LD_ADDR_VAR 0 11
18135: PUSH
18136: LD_VAR 0 3
18140: PUSH
18141: LD_VAR 0 2
18145: MINUS
18146: ST_TO_ADDR
// end else
18147: GO 18210
// begin d := - 1 ;
18149: LD_ADDR_VAR 0 9
18153: PUSH
18154: LD_INT 1
18156: NEG
18157: ST_TO_ADDR
// if i_from > i_to then
18158: LD_VAR 0 2
18162: PUSH
18163: LD_VAR 0 3
18167: GREATER
18168: IFFALSE 18188
// length := i_from - i_to else
18170: LD_ADDR_VAR 0 11
18174: PUSH
18175: LD_VAR 0 2
18179: PUSH
18180: LD_VAR 0 3
18184: MINUS
18185: ST_TO_ADDR
18186: GO 18210
// length := ( array - i_to ) + i_from ;
18188: LD_ADDR_VAR 0 11
18192: PUSH
18193: LD_VAR 0 1
18197: PUSH
18198: LD_VAR 0 3
18202: MINUS
18203: PUSH
18204: LD_VAR 0 2
18208: PLUS
18209: ST_TO_ADDR
// end ; if not length then
18210: LD_VAR 0 11
18214: NOT
18215: IFFALSE 18219
// exit ;
18217: GO 18377
// tmp := array ;
18219: LD_ADDR_VAR 0 10
18223: PUSH
18224: LD_VAR 0 1
18228: ST_TO_ADDR
// for i = 1 to length do
18229: LD_ADDR_VAR 0 6
18233: PUSH
18234: DOUBLE
18235: LD_INT 1
18237: DEC
18238: ST_TO_ADDR
18239: LD_VAR 0 11
18243: PUSH
18244: FOR_TO
18245: IFFALSE 18365
// begin for j = 1 to array do
18247: LD_ADDR_VAR 0 7
18251: PUSH
18252: DOUBLE
18253: LD_INT 1
18255: DEC
18256: ST_TO_ADDR
18257: LD_VAR 0 1
18261: PUSH
18262: FOR_TO
18263: IFFALSE 18351
// begin k := j + d ;
18265: LD_ADDR_VAR 0 8
18269: PUSH
18270: LD_VAR 0 7
18274: PUSH
18275: LD_VAR 0 9
18279: PLUS
18280: ST_TO_ADDR
// if k > array then
18281: LD_VAR 0 8
18285: PUSH
18286: LD_VAR 0 1
18290: GREATER
18291: IFFALSE 18301
// k := 1 ;
18293: LD_ADDR_VAR 0 8
18297: PUSH
18298: LD_INT 1
18300: ST_TO_ADDR
// if not k then
18301: LD_VAR 0 8
18305: NOT
18306: IFFALSE 18318
// k := array ;
18308: LD_ADDR_VAR 0 8
18312: PUSH
18313: LD_VAR 0 1
18317: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18318: LD_ADDR_VAR 0 10
18322: PUSH
18323: LD_VAR 0 10
18327: PPUSH
18328: LD_VAR 0 8
18332: PPUSH
18333: LD_VAR 0 1
18337: PUSH
18338: LD_VAR 0 7
18342: ARRAY
18343: PPUSH
18344: CALL_OW 1
18348: ST_TO_ADDR
// end ;
18349: GO 18262
18351: POP
18352: POP
// array := tmp ;
18353: LD_ADDR_VAR 0 1
18357: PUSH
18358: LD_VAR 0 10
18362: ST_TO_ADDR
// end ;
18363: GO 18244
18365: POP
18366: POP
// result := array ;
18367: LD_ADDR_VAR 0 5
18371: PUSH
18372: LD_VAR 0 1
18376: ST_TO_ADDR
// end ;
18377: LD_VAR 0 5
18381: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18382: LD_INT 0
18384: PPUSH
18385: PPUSH
// result := 0 ;
18386: LD_ADDR_VAR 0 3
18390: PUSH
18391: LD_INT 0
18393: ST_TO_ADDR
// if not array or not value in array then
18394: LD_VAR 0 1
18398: NOT
18399: PUSH
18400: LD_VAR 0 2
18404: PUSH
18405: LD_VAR 0 1
18409: IN
18410: NOT
18411: OR
18412: IFFALSE 18416
// exit ;
18414: GO 18470
// for i = 1 to array do
18416: LD_ADDR_VAR 0 4
18420: PUSH
18421: DOUBLE
18422: LD_INT 1
18424: DEC
18425: ST_TO_ADDR
18426: LD_VAR 0 1
18430: PUSH
18431: FOR_TO
18432: IFFALSE 18468
// if value = array [ i ] then
18434: LD_VAR 0 2
18438: PUSH
18439: LD_VAR 0 1
18443: PUSH
18444: LD_VAR 0 4
18448: ARRAY
18449: EQUAL
18450: IFFALSE 18466
// begin result := i ;
18452: LD_ADDR_VAR 0 3
18456: PUSH
18457: LD_VAR 0 4
18461: ST_TO_ADDR
// exit ;
18462: POP
18463: POP
18464: GO 18470
// end ;
18466: GO 18431
18468: POP
18469: POP
// end ;
18470: LD_VAR 0 3
18474: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18475: LD_INT 0
18477: PPUSH
// vc_chassis := chassis ;
18478: LD_ADDR_OWVAR 37
18482: PUSH
18483: LD_VAR 0 1
18487: ST_TO_ADDR
// vc_engine := engine ;
18488: LD_ADDR_OWVAR 39
18492: PUSH
18493: LD_VAR 0 2
18497: ST_TO_ADDR
// vc_control := control ;
18498: LD_ADDR_OWVAR 38
18502: PUSH
18503: LD_VAR 0 3
18507: ST_TO_ADDR
// vc_weapon := weapon ;
18508: LD_ADDR_OWVAR 40
18512: PUSH
18513: LD_VAR 0 4
18517: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18518: LD_ADDR_OWVAR 41
18522: PUSH
18523: LD_VAR 0 5
18527: ST_TO_ADDR
// end ;
18528: LD_VAR 0 6
18532: RET
// export function WantPlant ( unit ) ; var task ; begin
18533: LD_INT 0
18535: PPUSH
18536: PPUSH
// result := false ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_INT 0
18544: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18545: LD_ADDR_VAR 0 3
18549: PUSH
18550: LD_VAR 0 1
18554: PPUSH
18555: CALL_OW 437
18559: ST_TO_ADDR
// if task then
18560: LD_VAR 0 3
18564: IFFALSE 18592
// if task [ 1 ] [ 1 ] = p then
18566: LD_VAR 0 3
18570: PUSH
18571: LD_INT 1
18573: ARRAY
18574: PUSH
18575: LD_INT 1
18577: ARRAY
18578: PUSH
18579: LD_STRING p
18581: EQUAL
18582: IFFALSE 18592
// result := true ;
18584: LD_ADDR_VAR 0 2
18588: PUSH
18589: LD_INT 1
18591: ST_TO_ADDR
// end ;
18592: LD_VAR 0 2
18596: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18597: LD_INT 0
18599: PPUSH
18600: PPUSH
18601: PPUSH
18602: PPUSH
// if pos < 1 then
18603: LD_VAR 0 2
18607: PUSH
18608: LD_INT 1
18610: LESS
18611: IFFALSE 18615
// exit ;
18613: GO 18918
// if pos = 1 then
18615: LD_VAR 0 2
18619: PUSH
18620: LD_INT 1
18622: EQUAL
18623: IFFALSE 18656
// result := Replace ( arr , pos [ 1 ] , value ) else
18625: LD_ADDR_VAR 0 4
18629: PUSH
18630: LD_VAR 0 1
18634: PPUSH
18635: LD_VAR 0 2
18639: PUSH
18640: LD_INT 1
18642: ARRAY
18643: PPUSH
18644: LD_VAR 0 3
18648: PPUSH
18649: CALL_OW 1
18653: ST_TO_ADDR
18654: GO 18918
// begin tmp := arr ;
18656: LD_ADDR_VAR 0 6
18660: PUSH
18661: LD_VAR 0 1
18665: ST_TO_ADDR
// s_arr := [ tmp ] ;
18666: LD_ADDR_VAR 0 7
18670: PUSH
18671: LD_VAR 0 6
18675: PUSH
18676: EMPTY
18677: LIST
18678: ST_TO_ADDR
// for i = 1 to pos - 1 do
18679: LD_ADDR_VAR 0 5
18683: PUSH
18684: DOUBLE
18685: LD_INT 1
18687: DEC
18688: ST_TO_ADDR
18689: LD_VAR 0 2
18693: PUSH
18694: LD_INT 1
18696: MINUS
18697: PUSH
18698: FOR_TO
18699: IFFALSE 18744
// begin tmp := tmp [ pos [ i ] ] ;
18701: LD_ADDR_VAR 0 6
18705: PUSH
18706: LD_VAR 0 6
18710: PUSH
18711: LD_VAR 0 2
18715: PUSH
18716: LD_VAR 0 5
18720: ARRAY
18721: ARRAY
18722: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18723: LD_ADDR_VAR 0 7
18727: PUSH
18728: LD_VAR 0 7
18732: PUSH
18733: LD_VAR 0 6
18737: PUSH
18738: EMPTY
18739: LIST
18740: ADD
18741: ST_TO_ADDR
// end ;
18742: GO 18698
18744: POP
18745: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18746: LD_ADDR_VAR 0 6
18750: PUSH
18751: LD_VAR 0 6
18755: PPUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_VAR 0 2
18765: ARRAY
18766: PPUSH
18767: LD_VAR 0 3
18771: PPUSH
18772: CALL_OW 1
18776: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18777: LD_ADDR_VAR 0 7
18781: PUSH
18782: LD_VAR 0 7
18786: PPUSH
18787: LD_VAR 0 7
18791: PPUSH
18792: LD_VAR 0 6
18796: PPUSH
18797: CALL_OW 1
18801: ST_TO_ADDR
// for i = s_arr downto 2 do
18802: LD_ADDR_VAR 0 5
18806: PUSH
18807: DOUBLE
18808: LD_VAR 0 7
18812: INC
18813: ST_TO_ADDR
18814: LD_INT 2
18816: PUSH
18817: FOR_DOWNTO
18818: IFFALSE 18902
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18820: LD_ADDR_VAR 0 6
18824: PUSH
18825: LD_VAR 0 7
18829: PUSH
18830: LD_VAR 0 5
18834: PUSH
18835: LD_INT 1
18837: MINUS
18838: ARRAY
18839: PPUSH
18840: LD_VAR 0 2
18844: PUSH
18845: LD_VAR 0 5
18849: PUSH
18850: LD_INT 1
18852: MINUS
18853: ARRAY
18854: PPUSH
18855: LD_VAR 0 7
18859: PUSH
18860: LD_VAR 0 5
18864: ARRAY
18865: PPUSH
18866: CALL_OW 1
18870: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18871: LD_ADDR_VAR 0 7
18875: PUSH
18876: LD_VAR 0 7
18880: PPUSH
18881: LD_VAR 0 5
18885: PUSH
18886: LD_INT 1
18888: MINUS
18889: PPUSH
18890: LD_VAR 0 6
18894: PPUSH
18895: CALL_OW 1
18899: ST_TO_ADDR
// end ;
18900: GO 18817
18902: POP
18903: POP
// result := s_arr [ 1 ] ;
18904: LD_ADDR_VAR 0 4
18908: PUSH
18909: LD_VAR 0 7
18913: PUSH
18914: LD_INT 1
18916: ARRAY
18917: ST_TO_ADDR
// end ; end ;
18918: LD_VAR 0 4
18922: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18923: LD_INT 0
18925: PPUSH
18926: PPUSH
// if not list then
18927: LD_VAR 0 1
18931: NOT
18932: IFFALSE 18936
// exit ;
18934: GO 19027
// i := list [ pos1 ] ;
18936: LD_ADDR_VAR 0 5
18940: PUSH
18941: LD_VAR 0 1
18945: PUSH
18946: LD_VAR 0 2
18950: ARRAY
18951: ST_TO_ADDR
// if not i then
18952: LD_VAR 0 5
18956: NOT
18957: IFFALSE 18961
// exit ;
18959: GO 19027
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18961: LD_ADDR_VAR 0 1
18965: PUSH
18966: LD_VAR 0 1
18970: PPUSH
18971: LD_VAR 0 2
18975: PPUSH
18976: LD_VAR 0 1
18980: PUSH
18981: LD_VAR 0 3
18985: ARRAY
18986: PPUSH
18987: CALL_OW 1
18991: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18992: LD_ADDR_VAR 0 1
18996: PUSH
18997: LD_VAR 0 1
19001: PPUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 5
19011: PPUSH
19012: CALL_OW 1
19016: ST_TO_ADDR
// result := list ;
19017: LD_ADDR_VAR 0 4
19021: PUSH
19022: LD_VAR 0 1
19026: ST_TO_ADDR
// end ;
19027: LD_VAR 0 4
19031: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19032: LD_INT 0
19034: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19035: LD_ADDR_VAR 0 5
19039: PUSH
19040: LD_VAR 0 1
19044: PPUSH
19045: CALL_OW 250
19049: PPUSH
19050: LD_VAR 0 1
19054: PPUSH
19055: CALL_OW 251
19059: PPUSH
19060: LD_VAR 0 2
19064: PPUSH
19065: LD_VAR 0 3
19069: PPUSH
19070: LD_VAR 0 4
19074: PPUSH
19075: CALL 19085 0 5
19079: ST_TO_ADDR
// end ;
19080: LD_VAR 0 5
19084: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19085: LD_INT 0
19087: PPUSH
19088: PPUSH
19089: PPUSH
19090: PPUSH
// if not list then
19091: LD_VAR 0 3
19095: NOT
19096: IFFALSE 19100
// exit ;
19098: GO 19488
// result := [ ] ;
19100: LD_ADDR_VAR 0 6
19104: PUSH
19105: EMPTY
19106: ST_TO_ADDR
// for i in list do
19107: LD_ADDR_VAR 0 7
19111: PUSH
19112: LD_VAR 0 3
19116: PUSH
19117: FOR_IN
19118: IFFALSE 19320
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19120: LD_ADDR_VAR 0 9
19124: PUSH
19125: LD_VAR 0 7
19129: PPUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: LD_VAR 0 2
19139: PPUSH
19140: CALL_OW 297
19144: ST_TO_ADDR
// if not result then
19145: LD_VAR 0 6
19149: NOT
19150: IFFALSE 19176
// result := [ [ i , tmp ] ] else
19152: LD_ADDR_VAR 0 6
19156: PUSH
19157: LD_VAR 0 7
19161: PUSH
19162: LD_VAR 0 9
19166: PUSH
19167: EMPTY
19168: LIST
19169: LIST
19170: PUSH
19171: EMPTY
19172: LIST
19173: ST_TO_ADDR
19174: GO 19318
// begin if result [ result ] [ 2 ] < tmp then
19176: LD_VAR 0 6
19180: PUSH
19181: LD_VAR 0 6
19185: ARRAY
19186: PUSH
19187: LD_INT 2
19189: ARRAY
19190: PUSH
19191: LD_VAR 0 9
19195: LESS
19196: IFFALSE 19238
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19198: LD_ADDR_VAR 0 6
19202: PUSH
19203: LD_VAR 0 6
19207: PPUSH
19208: LD_VAR 0 6
19212: PUSH
19213: LD_INT 1
19215: PLUS
19216: PPUSH
19217: LD_VAR 0 7
19221: PUSH
19222: LD_VAR 0 9
19226: PUSH
19227: EMPTY
19228: LIST
19229: LIST
19230: PPUSH
19231: CALL_OW 2
19235: ST_TO_ADDR
19236: GO 19318
// for j = 1 to result do
19238: LD_ADDR_VAR 0 8
19242: PUSH
19243: DOUBLE
19244: LD_INT 1
19246: DEC
19247: ST_TO_ADDR
19248: LD_VAR 0 6
19252: PUSH
19253: FOR_TO
19254: IFFALSE 19316
// begin if tmp < result [ j ] [ 2 ] then
19256: LD_VAR 0 9
19260: PUSH
19261: LD_VAR 0 6
19265: PUSH
19266: LD_VAR 0 8
19270: ARRAY
19271: PUSH
19272: LD_INT 2
19274: ARRAY
19275: LESS
19276: IFFALSE 19314
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19278: LD_ADDR_VAR 0 6
19282: PUSH
19283: LD_VAR 0 6
19287: PPUSH
19288: LD_VAR 0 8
19292: PPUSH
19293: LD_VAR 0 7
19297: PUSH
19298: LD_VAR 0 9
19302: PUSH
19303: EMPTY
19304: LIST
19305: LIST
19306: PPUSH
19307: CALL_OW 2
19311: ST_TO_ADDR
// break ;
19312: GO 19316
// end ; end ;
19314: GO 19253
19316: POP
19317: POP
// end ; end ;
19318: GO 19117
19320: POP
19321: POP
// if result and not asc then
19322: LD_VAR 0 6
19326: PUSH
19327: LD_VAR 0 4
19331: NOT
19332: AND
19333: IFFALSE 19408
// begin tmp := result ;
19335: LD_ADDR_VAR 0 9
19339: PUSH
19340: LD_VAR 0 6
19344: ST_TO_ADDR
// for i = tmp downto 1 do
19345: LD_ADDR_VAR 0 7
19349: PUSH
19350: DOUBLE
19351: LD_VAR 0 9
19355: INC
19356: ST_TO_ADDR
19357: LD_INT 1
19359: PUSH
19360: FOR_DOWNTO
19361: IFFALSE 19406
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19363: LD_ADDR_VAR 0 6
19367: PUSH
19368: LD_VAR 0 6
19372: PPUSH
19373: LD_VAR 0 9
19377: PUSH
19378: LD_VAR 0 7
19382: MINUS
19383: PUSH
19384: LD_INT 1
19386: PLUS
19387: PPUSH
19388: LD_VAR 0 9
19392: PUSH
19393: LD_VAR 0 7
19397: ARRAY
19398: PPUSH
19399: CALL_OW 1
19403: ST_TO_ADDR
19404: GO 19360
19406: POP
19407: POP
// end ; tmp := [ ] ;
19408: LD_ADDR_VAR 0 9
19412: PUSH
19413: EMPTY
19414: ST_TO_ADDR
// if mode then
19415: LD_VAR 0 5
19419: IFFALSE 19488
// begin for i = 1 to result do
19421: LD_ADDR_VAR 0 7
19425: PUSH
19426: DOUBLE
19427: LD_INT 1
19429: DEC
19430: ST_TO_ADDR
19431: LD_VAR 0 6
19435: PUSH
19436: FOR_TO
19437: IFFALSE 19476
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19439: LD_ADDR_VAR 0 9
19443: PUSH
19444: LD_VAR 0 9
19448: PPUSH
19449: LD_VAR 0 7
19453: PPUSH
19454: LD_VAR 0 6
19458: PUSH
19459: LD_VAR 0 7
19463: ARRAY
19464: PUSH
19465: LD_INT 1
19467: ARRAY
19468: PPUSH
19469: CALL_OW 1
19473: ST_TO_ADDR
19474: GO 19436
19476: POP
19477: POP
// result := tmp ;
19478: LD_ADDR_VAR 0 6
19482: PUSH
19483: LD_VAR 0 9
19487: ST_TO_ADDR
// end ; end ;
19488: LD_VAR 0 6
19492: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19493: LD_INT 0
19495: PPUSH
19496: PPUSH
19497: PPUSH
19498: PPUSH
19499: PPUSH
19500: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19501: LD_ADDR_VAR 0 5
19505: PUSH
19506: LD_INT 0
19508: PUSH
19509: LD_INT 0
19511: PUSH
19512: LD_INT 0
19514: PUSH
19515: EMPTY
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: ST_TO_ADDR
// if not x or not y then
19523: LD_VAR 0 2
19527: NOT
19528: PUSH
19529: LD_VAR 0 3
19533: NOT
19534: OR
19535: IFFALSE 19539
// exit ;
19537: GO 21191
// if not range then
19539: LD_VAR 0 4
19543: NOT
19544: IFFALSE 19554
// range := 10 ;
19546: LD_ADDR_VAR 0 4
19550: PUSH
19551: LD_INT 10
19553: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19554: LD_ADDR_VAR 0 8
19558: PUSH
19559: LD_INT 81
19561: PUSH
19562: LD_VAR 0 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 92
19573: PUSH
19574: LD_VAR 0 2
19578: PUSH
19579: LD_VAR 0 3
19583: PUSH
19584: LD_VAR 0 4
19588: PUSH
19589: EMPTY
19590: LIST
19591: LIST
19592: LIST
19593: LIST
19594: PUSH
19595: LD_INT 3
19597: PUSH
19598: LD_INT 21
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: LIST
19616: PPUSH
19617: CALL_OW 69
19621: ST_TO_ADDR
// if not tmp then
19622: LD_VAR 0 8
19626: NOT
19627: IFFALSE 19631
// exit ;
19629: GO 21191
// for i in tmp do
19631: LD_ADDR_VAR 0 6
19635: PUSH
19636: LD_VAR 0 8
19640: PUSH
19641: FOR_IN
19642: IFFALSE 21166
// begin points := [ 0 , 0 , 0 ] ;
19644: LD_ADDR_VAR 0 9
19648: PUSH
19649: LD_INT 0
19651: PUSH
19652: LD_INT 0
19654: PUSH
19655: LD_INT 0
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: ST_TO_ADDR
// bpoints := 1 ;
19663: LD_ADDR_VAR 0 10
19667: PUSH
19668: LD_INT 1
19670: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19671: LD_VAR 0 6
19675: PPUSH
19676: CALL_OW 247
19680: PUSH
19681: LD_INT 1
19683: DOUBLE
19684: EQUAL
19685: IFTRUE 19689
19687: GO 20267
19689: POP
// begin if GetClass ( i ) = 1 then
19690: LD_VAR 0 6
19694: PPUSH
19695: CALL_OW 257
19699: PUSH
19700: LD_INT 1
19702: EQUAL
19703: IFFALSE 19724
// points := [ 10 , 5 , 3 ] ;
19705: LD_ADDR_VAR 0 9
19709: PUSH
19710: LD_INT 10
19712: PUSH
19713: LD_INT 5
19715: PUSH
19716: LD_INT 3
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19724: LD_VAR 0 6
19728: PPUSH
19729: CALL_OW 257
19733: PUSH
19734: LD_INT 2
19736: PUSH
19737: LD_INT 3
19739: PUSH
19740: LD_INT 4
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: LIST
19747: IN
19748: IFFALSE 19769
// points := [ 3 , 2 , 1 ] ;
19750: LD_ADDR_VAR 0 9
19754: PUSH
19755: LD_INT 3
19757: PUSH
19758: LD_INT 2
19760: PUSH
19761: LD_INT 1
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: LIST
19768: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19769: LD_VAR 0 6
19773: PPUSH
19774: CALL_OW 257
19778: PUSH
19779: LD_INT 5
19781: EQUAL
19782: IFFALSE 19803
// points := [ 130 , 5 , 2 ] ;
19784: LD_ADDR_VAR 0 9
19788: PUSH
19789: LD_INT 130
19791: PUSH
19792: LD_INT 5
19794: PUSH
19795: LD_INT 2
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: LIST
19802: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19803: LD_VAR 0 6
19807: PPUSH
19808: CALL_OW 257
19812: PUSH
19813: LD_INT 8
19815: EQUAL
19816: IFFALSE 19837
// points := [ 35 , 35 , 30 ] ;
19818: LD_ADDR_VAR 0 9
19822: PUSH
19823: LD_INT 35
19825: PUSH
19826: LD_INT 35
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: LIST
19836: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19837: LD_VAR 0 6
19841: PPUSH
19842: CALL_OW 257
19846: PUSH
19847: LD_INT 9
19849: EQUAL
19850: IFFALSE 19871
// points := [ 20 , 55 , 40 ] ;
19852: LD_ADDR_VAR 0 9
19856: PUSH
19857: LD_INT 20
19859: PUSH
19860: LD_INT 55
19862: PUSH
19863: LD_INT 40
19865: PUSH
19866: EMPTY
19867: LIST
19868: LIST
19869: LIST
19870: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19871: LD_VAR 0 6
19875: PPUSH
19876: CALL_OW 257
19880: PUSH
19881: LD_INT 12
19883: PUSH
19884: LD_INT 16
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: IN
19891: IFFALSE 19912
// points := [ 5 , 3 , 2 ] ;
19893: LD_ADDR_VAR 0 9
19897: PUSH
19898: LD_INT 5
19900: PUSH
19901: LD_INT 3
19903: PUSH
19904: LD_INT 2
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: LIST
19911: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19912: LD_VAR 0 6
19916: PPUSH
19917: CALL_OW 257
19921: PUSH
19922: LD_INT 17
19924: EQUAL
19925: IFFALSE 19946
// points := [ 100 , 50 , 75 ] ;
19927: LD_ADDR_VAR 0 9
19931: PUSH
19932: LD_INT 100
19934: PUSH
19935: LD_INT 50
19937: PUSH
19938: LD_INT 75
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19946: LD_VAR 0 6
19950: PPUSH
19951: CALL_OW 257
19955: PUSH
19956: LD_INT 15
19958: EQUAL
19959: IFFALSE 19980
// points := [ 10 , 5 , 3 ] ;
19961: LD_ADDR_VAR 0 9
19965: PUSH
19966: LD_INT 10
19968: PUSH
19969: LD_INT 5
19971: PUSH
19972: LD_INT 3
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19980: LD_VAR 0 6
19984: PPUSH
19985: CALL_OW 257
19989: PUSH
19990: LD_INT 14
19992: EQUAL
19993: IFFALSE 20014
// points := [ 10 , 0 , 0 ] ;
19995: LD_ADDR_VAR 0 9
19999: PUSH
20000: LD_INT 10
20002: PUSH
20003: LD_INT 0
20005: PUSH
20006: LD_INT 0
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: LIST
20013: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20014: LD_VAR 0 6
20018: PPUSH
20019: CALL_OW 257
20023: PUSH
20024: LD_INT 11
20026: EQUAL
20027: IFFALSE 20048
// points := [ 30 , 10 , 5 ] ;
20029: LD_ADDR_VAR 0 9
20033: PUSH
20034: LD_INT 30
20036: PUSH
20037: LD_INT 10
20039: PUSH
20040: LD_INT 5
20042: PUSH
20043: EMPTY
20044: LIST
20045: LIST
20046: LIST
20047: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20048: LD_VAR 0 1
20052: PPUSH
20053: LD_INT 5
20055: PPUSH
20056: CALL_OW 321
20060: PUSH
20061: LD_INT 2
20063: EQUAL
20064: IFFALSE 20081
// bpoints := bpoints * 1.8 ;
20066: LD_ADDR_VAR 0 10
20070: PUSH
20071: LD_VAR 0 10
20075: PUSH
20076: LD_REAL  1.80000000000000E+0000
20079: MUL
20080: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20081: LD_VAR 0 6
20085: PPUSH
20086: CALL_OW 257
20090: PUSH
20091: LD_INT 1
20093: PUSH
20094: LD_INT 2
20096: PUSH
20097: LD_INT 3
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: LIST
20107: LIST
20108: IN
20109: PUSH
20110: LD_VAR 0 1
20114: PPUSH
20115: LD_INT 51
20117: PPUSH
20118: CALL_OW 321
20122: PUSH
20123: LD_INT 2
20125: EQUAL
20126: AND
20127: IFFALSE 20144
// bpoints := bpoints * 1.2 ;
20129: LD_ADDR_VAR 0 10
20133: PUSH
20134: LD_VAR 0 10
20138: PUSH
20139: LD_REAL  1.20000000000000E+0000
20142: MUL
20143: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20144: LD_VAR 0 6
20148: PPUSH
20149: CALL_OW 257
20153: PUSH
20154: LD_INT 5
20156: PUSH
20157: LD_INT 7
20159: PUSH
20160: LD_INT 9
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: IN
20168: PUSH
20169: LD_VAR 0 1
20173: PPUSH
20174: LD_INT 52
20176: PPUSH
20177: CALL_OW 321
20181: PUSH
20182: LD_INT 2
20184: EQUAL
20185: AND
20186: IFFALSE 20203
// bpoints := bpoints * 1.5 ;
20188: LD_ADDR_VAR 0 10
20192: PUSH
20193: LD_VAR 0 10
20197: PUSH
20198: LD_REAL  1.50000000000000E+0000
20201: MUL
20202: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20203: LD_VAR 0 1
20207: PPUSH
20208: LD_INT 66
20210: PPUSH
20211: CALL_OW 321
20215: PUSH
20216: LD_INT 2
20218: EQUAL
20219: IFFALSE 20236
// bpoints := bpoints * 1.1 ;
20221: LD_ADDR_VAR 0 10
20225: PUSH
20226: LD_VAR 0 10
20230: PUSH
20231: LD_REAL  1.10000000000000E+0000
20234: MUL
20235: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20236: LD_ADDR_VAR 0 10
20240: PUSH
20241: LD_VAR 0 10
20245: PUSH
20246: LD_VAR 0 6
20250: PPUSH
20251: LD_INT 1
20253: PPUSH
20254: CALL_OW 259
20258: PUSH
20259: LD_REAL  1.15000000000000E+0000
20262: MUL
20263: MUL
20264: ST_TO_ADDR
// end ; unit_vehicle :
20265: GO 21095
20267: LD_INT 2
20269: DOUBLE
20270: EQUAL
20271: IFTRUE 20275
20273: GO 21083
20275: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20276: LD_VAR 0 6
20280: PPUSH
20281: CALL_OW 264
20285: PUSH
20286: LD_INT 2
20288: PUSH
20289: LD_INT 42
20291: PUSH
20292: LD_INT 24
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: LIST
20299: IN
20300: IFFALSE 20321
// points := [ 25 , 5 , 3 ] ;
20302: LD_ADDR_VAR 0 9
20306: PUSH
20307: LD_INT 25
20309: PUSH
20310: LD_INT 5
20312: PUSH
20313: LD_INT 3
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: LIST
20320: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20321: LD_VAR 0 6
20325: PPUSH
20326: CALL_OW 264
20330: PUSH
20331: LD_INT 4
20333: PUSH
20334: LD_INT 43
20336: PUSH
20337: LD_INT 25
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: LIST
20344: IN
20345: IFFALSE 20366
// points := [ 40 , 15 , 5 ] ;
20347: LD_ADDR_VAR 0 9
20351: PUSH
20352: LD_INT 40
20354: PUSH
20355: LD_INT 15
20357: PUSH
20358: LD_INT 5
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20366: LD_VAR 0 6
20370: PPUSH
20371: CALL_OW 264
20375: PUSH
20376: LD_INT 3
20378: PUSH
20379: LD_INT 23
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: IN
20386: IFFALSE 20407
// points := [ 7 , 25 , 8 ] ;
20388: LD_ADDR_VAR 0 9
20392: PUSH
20393: LD_INT 7
20395: PUSH
20396: LD_INT 25
20398: PUSH
20399: LD_INT 8
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: LIST
20406: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20407: LD_VAR 0 6
20411: PPUSH
20412: CALL_OW 264
20416: PUSH
20417: LD_INT 5
20419: PUSH
20420: LD_INT 27
20422: PUSH
20423: LD_INT 44
20425: PUSH
20426: EMPTY
20427: LIST
20428: LIST
20429: LIST
20430: IN
20431: IFFALSE 20452
// points := [ 14 , 50 , 16 ] ;
20433: LD_ADDR_VAR 0 9
20437: PUSH
20438: LD_INT 14
20440: PUSH
20441: LD_INT 50
20443: PUSH
20444: LD_INT 16
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: LIST
20451: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20452: LD_VAR 0 6
20456: PPUSH
20457: CALL_OW 264
20461: PUSH
20462: LD_INT 6
20464: PUSH
20465: LD_INT 46
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: IN
20472: IFFALSE 20493
// points := [ 32 , 120 , 70 ] ;
20474: LD_ADDR_VAR 0 9
20478: PUSH
20479: LD_INT 32
20481: PUSH
20482: LD_INT 120
20484: PUSH
20485: LD_INT 70
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: LIST
20492: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20493: LD_VAR 0 6
20497: PPUSH
20498: CALL_OW 264
20502: PUSH
20503: LD_INT 7
20505: PUSH
20506: LD_INT 28
20508: PUSH
20509: LD_INT 45
20511: PUSH
20512: LD_EXP 53
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: LIST
20521: LIST
20522: IN
20523: IFFALSE 20544
// points := [ 35 , 20 , 45 ] ;
20525: LD_ADDR_VAR 0 9
20529: PUSH
20530: LD_INT 35
20532: PUSH
20533: LD_INT 20
20535: PUSH
20536: LD_INT 45
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20544: LD_VAR 0 6
20548: PPUSH
20549: CALL_OW 264
20553: PUSH
20554: LD_INT 47
20556: PUSH
20557: EMPTY
20558: LIST
20559: IN
20560: IFFALSE 20581
// points := [ 67 , 45 , 75 ] ;
20562: LD_ADDR_VAR 0 9
20566: PUSH
20567: LD_INT 67
20569: PUSH
20570: LD_INT 45
20572: PUSH
20573: LD_INT 75
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: LIST
20580: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20581: LD_VAR 0 6
20585: PPUSH
20586: CALL_OW 264
20590: PUSH
20591: LD_INT 26
20593: PUSH
20594: EMPTY
20595: LIST
20596: IN
20597: IFFALSE 20618
// points := [ 120 , 30 , 80 ] ;
20599: LD_ADDR_VAR 0 9
20603: PUSH
20604: LD_INT 120
20606: PUSH
20607: LD_INT 30
20609: PUSH
20610: LD_INT 80
20612: PUSH
20613: EMPTY
20614: LIST
20615: LIST
20616: LIST
20617: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20618: LD_VAR 0 6
20622: PPUSH
20623: CALL_OW 264
20627: PUSH
20628: LD_INT 22
20630: PUSH
20631: EMPTY
20632: LIST
20633: IN
20634: IFFALSE 20655
// points := [ 40 , 1 , 1 ] ;
20636: LD_ADDR_VAR 0 9
20640: PUSH
20641: LD_INT 40
20643: PUSH
20644: LD_INT 1
20646: PUSH
20647: LD_INT 1
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20655: LD_VAR 0 6
20659: PPUSH
20660: CALL_OW 264
20664: PUSH
20665: LD_INT 29
20667: PUSH
20668: EMPTY
20669: LIST
20670: IN
20671: IFFALSE 20692
// points := [ 70 , 200 , 400 ] ;
20673: LD_ADDR_VAR 0 9
20677: PUSH
20678: LD_INT 70
20680: PUSH
20681: LD_INT 200
20683: PUSH
20684: LD_INT 400
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: LIST
20691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20692: LD_VAR 0 6
20696: PPUSH
20697: CALL_OW 264
20701: PUSH
20702: LD_INT 14
20704: PUSH
20705: LD_INT 53
20707: PUSH
20708: EMPTY
20709: LIST
20710: LIST
20711: IN
20712: IFFALSE 20733
// points := [ 40 , 10 , 20 ] ;
20714: LD_ADDR_VAR 0 9
20718: PUSH
20719: LD_INT 40
20721: PUSH
20722: LD_INT 10
20724: PUSH
20725: LD_INT 20
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: LIST
20732: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20733: LD_VAR 0 6
20737: PPUSH
20738: CALL_OW 264
20742: PUSH
20743: LD_INT 9
20745: PUSH
20746: EMPTY
20747: LIST
20748: IN
20749: IFFALSE 20770
// points := [ 5 , 70 , 20 ] ;
20751: LD_ADDR_VAR 0 9
20755: PUSH
20756: LD_INT 5
20758: PUSH
20759: LD_INT 70
20761: PUSH
20762: LD_INT 20
20764: PUSH
20765: EMPTY
20766: LIST
20767: LIST
20768: LIST
20769: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20770: LD_VAR 0 6
20774: PPUSH
20775: CALL_OW 264
20779: PUSH
20780: LD_INT 10
20782: PUSH
20783: EMPTY
20784: LIST
20785: IN
20786: IFFALSE 20807
// points := [ 35 , 110 , 70 ] ;
20788: LD_ADDR_VAR 0 9
20792: PUSH
20793: LD_INT 35
20795: PUSH
20796: LD_INT 110
20798: PUSH
20799: LD_INT 70
20801: PUSH
20802: EMPTY
20803: LIST
20804: LIST
20805: LIST
20806: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20807: LD_VAR 0 6
20811: PPUSH
20812: CALL_OW 265
20816: PUSH
20817: LD_INT 25
20819: EQUAL
20820: IFFALSE 20841
// points := [ 80 , 65 , 100 ] ;
20822: LD_ADDR_VAR 0 9
20826: PUSH
20827: LD_INT 80
20829: PUSH
20830: LD_INT 65
20832: PUSH
20833: LD_INT 100
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: LIST
20840: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20841: LD_VAR 0 6
20845: PPUSH
20846: CALL_OW 263
20850: PUSH
20851: LD_INT 1
20853: EQUAL
20854: IFFALSE 20889
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20856: LD_ADDR_VAR 0 10
20860: PUSH
20861: LD_VAR 0 10
20865: PUSH
20866: LD_VAR 0 6
20870: PPUSH
20871: CALL_OW 311
20875: PPUSH
20876: LD_INT 3
20878: PPUSH
20879: CALL_OW 259
20883: PUSH
20884: LD_INT 4
20886: MUL
20887: MUL
20888: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20889: LD_VAR 0 6
20893: PPUSH
20894: CALL_OW 263
20898: PUSH
20899: LD_INT 2
20901: EQUAL
20902: IFFALSE 20953
// begin j := IsControledBy ( i ) ;
20904: LD_ADDR_VAR 0 7
20908: PUSH
20909: LD_VAR 0 6
20913: PPUSH
20914: CALL_OW 312
20918: ST_TO_ADDR
// if j then
20919: LD_VAR 0 7
20923: IFFALSE 20953
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20925: LD_ADDR_VAR 0 10
20929: PUSH
20930: LD_VAR 0 10
20934: PUSH
20935: LD_VAR 0 7
20939: PPUSH
20940: LD_INT 3
20942: PPUSH
20943: CALL_OW 259
20947: PUSH
20948: LD_INT 3
20950: MUL
20951: MUL
20952: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20953: LD_VAR 0 6
20957: PPUSH
20958: CALL_OW 264
20962: PUSH
20963: LD_INT 5
20965: PUSH
20966: LD_INT 6
20968: PUSH
20969: LD_INT 46
20971: PUSH
20972: LD_INT 44
20974: PUSH
20975: LD_INT 47
20977: PUSH
20978: LD_INT 45
20980: PUSH
20981: LD_INT 28
20983: PUSH
20984: LD_INT 7
20986: PUSH
20987: LD_INT 27
20989: PUSH
20990: LD_INT 29
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: LIST
21003: LIST
21004: IN
21005: PUSH
21006: LD_VAR 0 1
21010: PPUSH
21011: LD_INT 52
21013: PPUSH
21014: CALL_OW 321
21018: PUSH
21019: LD_INT 2
21021: EQUAL
21022: AND
21023: IFFALSE 21040
// bpoints := bpoints * 1.2 ;
21025: LD_ADDR_VAR 0 10
21029: PUSH
21030: LD_VAR 0 10
21034: PUSH
21035: LD_REAL  1.20000000000000E+0000
21038: MUL
21039: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21040: LD_VAR 0 6
21044: PPUSH
21045: CALL_OW 264
21049: PUSH
21050: LD_INT 6
21052: PUSH
21053: LD_INT 46
21055: PUSH
21056: LD_INT 47
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: LIST
21063: IN
21064: IFFALSE 21081
// bpoints := bpoints * 1.2 ;
21066: LD_ADDR_VAR 0 10
21070: PUSH
21071: LD_VAR 0 10
21075: PUSH
21076: LD_REAL  1.20000000000000E+0000
21079: MUL
21080: ST_TO_ADDR
// end ; unit_building :
21081: GO 21095
21083: LD_INT 3
21085: DOUBLE
21086: EQUAL
21087: IFTRUE 21091
21089: GO 21094
21091: POP
// ; end ;
21092: GO 21095
21094: POP
// for j = 1 to 3 do
21095: LD_ADDR_VAR 0 7
21099: PUSH
21100: DOUBLE
21101: LD_INT 1
21103: DEC
21104: ST_TO_ADDR
21105: LD_INT 3
21107: PUSH
21108: FOR_TO
21109: IFFALSE 21162
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21111: LD_ADDR_VAR 0 5
21115: PUSH
21116: LD_VAR 0 5
21120: PPUSH
21121: LD_VAR 0 7
21125: PPUSH
21126: LD_VAR 0 5
21130: PUSH
21131: LD_VAR 0 7
21135: ARRAY
21136: PUSH
21137: LD_VAR 0 9
21141: PUSH
21142: LD_VAR 0 7
21146: ARRAY
21147: PUSH
21148: LD_VAR 0 10
21152: MUL
21153: PLUS
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
21160: GO 21108
21162: POP
21163: POP
// end ;
21164: GO 19641
21166: POP
21167: POP
// result := Replace ( result , 4 , tmp ) ;
21168: LD_ADDR_VAR 0 5
21172: PUSH
21173: LD_VAR 0 5
21177: PPUSH
21178: LD_INT 4
21180: PPUSH
21181: LD_VAR 0 8
21185: PPUSH
21186: CALL_OW 1
21190: ST_TO_ADDR
// end ;
21191: LD_VAR 0 5
21195: RET
// export function DangerAtRange ( unit , range ) ; begin
21196: LD_INT 0
21198: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21199: LD_ADDR_VAR 0 3
21203: PUSH
21204: LD_VAR 0 1
21208: PPUSH
21209: CALL_OW 255
21213: PPUSH
21214: LD_VAR 0 1
21218: PPUSH
21219: CALL_OW 250
21223: PPUSH
21224: LD_VAR 0 1
21228: PPUSH
21229: CALL_OW 251
21233: PPUSH
21234: LD_VAR 0 2
21238: PPUSH
21239: CALL 19493 0 4
21243: ST_TO_ADDR
// end ;
21244: LD_VAR 0 3
21248: RET
// export function DangerInArea ( side , area ) ; begin
21249: LD_INT 0
21251: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21252: LD_ADDR_VAR 0 3
21256: PUSH
21257: LD_VAR 0 2
21261: PPUSH
21262: LD_INT 81
21264: PUSH
21265: LD_VAR 0 1
21269: PUSH
21270: EMPTY
21271: LIST
21272: LIST
21273: PPUSH
21274: CALL_OW 70
21278: ST_TO_ADDR
// end ;
21279: LD_VAR 0 3
21283: RET
// export function IsExtension ( b ) ; begin
21284: LD_INT 0
21286: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21287: LD_ADDR_VAR 0 2
21291: PUSH
21292: LD_VAR 0 1
21296: PUSH
21297: LD_INT 23
21299: PUSH
21300: LD_INT 20
21302: PUSH
21303: LD_INT 22
21305: PUSH
21306: LD_INT 17
21308: PUSH
21309: LD_INT 24
21311: PUSH
21312: LD_INT 21
21314: PUSH
21315: LD_INT 19
21317: PUSH
21318: LD_INT 16
21320: PUSH
21321: LD_INT 25
21323: PUSH
21324: LD_INT 18
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: LIST
21332: LIST
21333: LIST
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: IN
21339: ST_TO_ADDR
// end ;
21340: LD_VAR 0 2
21344: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21345: LD_INT 0
21347: PPUSH
21348: PPUSH
21349: PPUSH
// result := [ ] ;
21350: LD_ADDR_VAR 0 4
21354: PUSH
21355: EMPTY
21356: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21357: LD_ADDR_VAR 0 5
21361: PUSH
21362: LD_VAR 0 2
21366: PPUSH
21367: LD_INT 21
21369: PUSH
21370: LD_INT 3
21372: PUSH
21373: EMPTY
21374: LIST
21375: LIST
21376: PPUSH
21377: CALL_OW 70
21381: ST_TO_ADDR
// if not tmp then
21382: LD_VAR 0 5
21386: NOT
21387: IFFALSE 21391
// exit ;
21389: GO 21455
// if checkLink then
21391: LD_VAR 0 3
21395: IFFALSE 21445
// begin for i in tmp do
21397: LD_ADDR_VAR 0 6
21401: PUSH
21402: LD_VAR 0 5
21406: PUSH
21407: FOR_IN
21408: IFFALSE 21443
// if GetBase ( i ) <> base then
21410: LD_VAR 0 6
21414: PPUSH
21415: CALL_OW 274
21419: PUSH
21420: LD_VAR 0 1
21424: NONEQUAL
21425: IFFALSE 21441
// ComLinkToBase ( base , i ) ;
21427: LD_VAR 0 1
21431: PPUSH
21432: LD_VAR 0 6
21436: PPUSH
21437: CALL_OW 169
21441: GO 21407
21443: POP
21444: POP
// end ; result := tmp ;
21445: LD_ADDR_VAR 0 4
21449: PUSH
21450: LD_VAR 0 5
21454: ST_TO_ADDR
// end ;
21455: LD_VAR 0 4
21459: RET
// export function ComComplete ( units , b ) ; var i ; begin
21460: LD_INT 0
21462: PPUSH
21463: PPUSH
// if not units then
21464: LD_VAR 0 1
21468: NOT
21469: IFFALSE 21473
// exit ;
21471: GO 21563
// for i in units do
21473: LD_ADDR_VAR 0 4
21477: PUSH
21478: LD_VAR 0 1
21482: PUSH
21483: FOR_IN
21484: IFFALSE 21561
// if BuildingStatus ( b ) = bs_build then
21486: LD_VAR 0 2
21490: PPUSH
21491: CALL_OW 461
21495: PUSH
21496: LD_INT 1
21498: EQUAL
21499: IFFALSE 21559
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21501: LD_VAR 0 4
21505: PPUSH
21506: LD_STRING h
21508: PUSH
21509: LD_VAR 0 2
21513: PPUSH
21514: CALL_OW 250
21518: PUSH
21519: LD_VAR 0 2
21523: PPUSH
21524: CALL_OW 251
21528: PUSH
21529: LD_VAR 0 2
21533: PUSH
21534: LD_INT 0
21536: PUSH
21537: LD_INT 0
21539: PUSH
21540: LD_INT 0
21542: PUSH
21543: EMPTY
21544: LIST
21545: LIST
21546: LIST
21547: LIST
21548: LIST
21549: LIST
21550: LIST
21551: PUSH
21552: EMPTY
21553: LIST
21554: PPUSH
21555: CALL_OW 446
21559: GO 21483
21561: POP
21562: POP
// end ;
21563: LD_VAR 0 3
21567: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21568: LD_INT 0
21570: PPUSH
21571: PPUSH
21572: PPUSH
21573: PPUSH
21574: PPUSH
21575: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21576: LD_VAR 0 1
21580: NOT
21581: PUSH
21582: LD_VAR 0 1
21586: PPUSH
21587: CALL_OW 263
21591: PUSH
21592: LD_INT 2
21594: NONEQUAL
21595: OR
21596: IFFALSE 21600
// exit ;
21598: GO 21916
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21600: LD_ADDR_VAR 0 6
21604: PUSH
21605: LD_INT 22
21607: PUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 255
21617: PUSH
21618: EMPTY
21619: LIST
21620: LIST
21621: PUSH
21622: LD_INT 2
21624: PUSH
21625: LD_INT 30
21627: PUSH
21628: LD_INT 36
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 34
21637: PUSH
21638: LD_INT 31
21640: PUSH
21641: EMPTY
21642: LIST
21643: LIST
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: LIST
21649: PUSH
21650: EMPTY
21651: LIST
21652: LIST
21653: PPUSH
21654: CALL_OW 69
21658: ST_TO_ADDR
// if not tmp then
21659: LD_VAR 0 6
21663: NOT
21664: IFFALSE 21668
// exit ;
21666: GO 21916
// result := [ ] ;
21668: LD_ADDR_VAR 0 2
21672: PUSH
21673: EMPTY
21674: ST_TO_ADDR
// for i in tmp do
21675: LD_ADDR_VAR 0 3
21679: PUSH
21680: LD_VAR 0 6
21684: PUSH
21685: FOR_IN
21686: IFFALSE 21757
// begin t := UnitsInside ( i ) ;
21688: LD_ADDR_VAR 0 4
21692: PUSH
21693: LD_VAR 0 3
21697: PPUSH
21698: CALL_OW 313
21702: ST_TO_ADDR
// if t then
21703: LD_VAR 0 4
21707: IFFALSE 21755
// for j in t do
21709: LD_ADDR_VAR 0 7
21713: PUSH
21714: LD_VAR 0 4
21718: PUSH
21719: FOR_IN
21720: IFFALSE 21753
// result := Replace ( result , result + 1 , j ) ;
21722: LD_ADDR_VAR 0 2
21726: PUSH
21727: LD_VAR 0 2
21731: PPUSH
21732: LD_VAR 0 2
21736: PUSH
21737: LD_INT 1
21739: PLUS
21740: PPUSH
21741: LD_VAR 0 7
21745: PPUSH
21746: CALL_OW 1
21750: ST_TO_ADDR
21751: GO 21719
21753: POP
21754: POP
// end ;
21755: GO 21685
21757: POP
21758: POP
// if not result then
21759: LD_VAR 0 2
21763: NOT
21764: IFFALSE 21768
// exit ;
21766: GO 21916
// mech := result [ 1 ] ;
21768: LD_ADDR_VAR 0 5
21772: PUSH
21773: LD_VAR 0 2
21777: PUSH
21778: LD_INT 1
21780: ARRAY
21781: ST_TO_ADDR
// if result > 1 then
21782: LD_VAR 0 2
21786: PUSH
21787: LD_INT 1
21789: GREATER
21790: IFFALSE 21902
// begin for i = 2 to result do
21792: LD_ADDR_VAR 0 3
21796: PUSH
21797: DOUBLE
21798: LD_INT 2
21800: DEC
21801: ST_TO_ADDR
21802: LD_VAR 0 2
21806: PUSH
21807: FOR_TO
21808: IFFALSE 21900
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21810: LD_ADDR_VAR 0 4
21814: PUSH
21815: LD_VAR 0 2
21819: PUSH
21820: LD_VAR 0 3
21824: ARRAY
21825: PPUSH
21826: LD_INT 3
21828: PPUSH
21829: CALL_OW 259
21833: PUSH
21834: LD_VAR 0 2
21838: PUSH
21839: LD_VAR 0 3
21843: ARRAY
21844: PPUSH
21845: CALL_OW 432
21849: MINUS
21850: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21851: LD_VAR 0 4
21855: PUSH
21856: LD_VAR 0 5
21860: PPUSH
21861: LD_INT 3
21863: PPUSH
21864: CALL_OW 259
21868: PUSH
21869: LD_VAR 0 5
21873: PPUSH
21874: CALL_OW 432
21878: MINUS
21879: GREATEREQUAL
21880: IFFALSE 21898
// mech := result [ i ] ;
21882: LD_ADDR_VAR 0 5
21886: PUSH
21887: LD_VAR 0 2
21891: PUSH
21892: LD_VAR 0 3
21896: ARRAY
21897: ST_TO_ADDR
// end ;
21898: GO 21807
21900: POP
21901: POP
// end ; ComLinkTo ( vehicle , mech ) ;
21902: LD_VAR 0 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL_OW 135
// end ;
21916: LD_VAR 0 2
21920: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21921: LD_INT 0
21923: PPUSH
21924: PPUSH
21925: PPUSH
21926: PPUSH
21927: PPUSH
21928: PPUSH
21929: PPUSH
21930: PPUSH
21931: PPUSH
21932: PPUSH
21933: PPUSH
21934: PPUSH
21935: PPUSH
// result := [ ] ;
21936: LD_ADDR_VAR 0 7
21940: PUSH
21941: EMPTY
21942: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21943: LD_VAR 0 1
21947: PPUSH
21948: CALL_OW 266
21952: PUSH
21953: LD_INT 0
21955: PUSH
21956: LD_INT 1
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: IN
21963: NOT
21964: IFFALSE 21968
// exit ;
21966: GO 23602
// if name then
21968: LD_VAR 0 3
21972: IFFALSE 21988
// SetBName ( base_dep , name ) ;
21974: LD_VAR 0 1
21978: PPUSH
21979: LD_VAR 0 3
21983: PPUSH
21984: CALL_OW 500
// base := GetBase ( base_dep ) ;
21988: LD_ADDR_VAR 0 15
21992: PUSH
21993: LD_VAR 0 1
21997: PPUSH
21998: CALL_OW 274
22002: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22003: LD_ADDR_VAR 0 16
22007: PUSH
22008: LD_VAR 0 1
22012: PPUSH
22013: CALL_OW 255
22017: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22018: LD_ADDR_VAR 0 17
22022: PUSH
22023: LD_VAR 0 1
22027: PPUSH
22028: CALL_OW 248
22032: ST_TO_ADDR
// if sources then
22033: LD_VAR 0 5
22037: IFFALSE 22084
// for i = 1 to 3 do
22039: LD_ADDR_VAR 0 8
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_INT 3
22051: PUSH
22052: FOR_TO
22053: IFFALSE 22082
// AddResourceType ( base , i , sources [ i ] ) ;
22055: LD_VAR 0 15
22059: PPUSH
22060: LD_VAR 0 8
22064: PPUSH
22065: LD_VAR 0 5
22069: PUSH
22070: LD_VAR 0 8
22074: ARRAY
22075: PPUSH
22076: CALL_OW 276
22080: GO 22052
22082: POP
22083: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22084: LD_ADDR_VAR 0 18
22088: PUSH
22089: LD_VAR 0 15
22093: PPUSH
22094: LD_VAR 0 2
22098: PPUSH
22099: LD_INT 1
22101: PPUSH
22102: CALL 21345 0 3
22106: ST_TO_ADDR
// InitHc ;
22107: CALL_OW 19
// InitUc ;
22111: CALL_OW 18
// uc_side := side ;
22115: LD_ADDR_OWVAR 20
22119: PUSH
22120: LD_VAR 0 16
22124: ST_TO_ADDR
// uc_nation := nation ;
22125: LD_ADDR_OWVAR 21
22129: PUSH
22130: LD_VAR 0 17
22134: ST_TO_ADDR
// if buildings then
22135: LD_VAR 0 18
22139: IFFALSE 23461
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22141: LD_ADDR_VAR 0 19
22145: PUSH
22146: LD_VAR 0 18
22150: PPUSH
22151: LD_INT 2
22153: PUSH
22154: LD_INT 30
22156: PUSH
22157: LD_INT 29
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: PUSH
22164: LD_INT 30
22166: PUSH
22167: LD_INT 30
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: LIST
22178: PPUSH
22179: CALL_OW 72
22183: ST_TO_ADDR
// if tmp then
22184: LD_VAR 0 19
22188: IFFALSE 22236
// for i in tmp do
22190: LD_ADDR_VAR 0 8
22194: PUSH
22195: LD_VAR 0 19
22199: PUSH
22200: FOR_IN
22201: IFFALSE 22234
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22203: LD_VAR 0 8
22207: PPUSH
22208: CALL_OW 250
22212: PPUSH
22213: LD_VAR 0 8
22217: PPUSH
22218: CALL_OW 251
22222: PPUSH
22223: LD_VAR 0 16
22227: PPUSH
22228: CALL_OW 441
22232: GO 22200
22234: POP
22235: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22236: LD_VAR 0 18
22240: PPUSH
22241: LD_INT 2
22243: PUSH
22244: LD_INT 30
22246: PUSH
22247: LD_INT 32
22249: PUSH
22250: EMPTY
22251: LIST
22252: LIST
22253: PUSH
22254: LD_INT 30
22256: PUSH
22257: LD_INT 33
22259: PUSH
22260: EMPTY
22261: LIST
22262: LIST
22263: PUSH
22264: EMPTY
22265: LIST
22266: LIST
22267: LIST
22268: PPUSH
22269: CALL_OW 72
22273: IFFALSE 22361
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22275: LD_ADDR_VAR 0 8
22279: PUSH
22280: LD_VAR 0 18
22284: PPUSH
22285: LD_INT 2
22287: PUSH
22288: LD_INT 30
22290: PUSH
22291: LD_INT 32
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PUSH
22298: LD_INT 30
22300: PUSH
22301: LD_INT 33
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: EMPTY
22309: LIST
22310: LIST
22311: LIST
22312: PPUSH
22313: CALL_OW 72
22317: PUSH
22318: FOR_IN
22319: IFFALSE 22359
// begin if not GetBWeapon ( i ) then
22321: LD_VAR 0 8
22325: PPUSH
22326: CALL_OW 269
22330: NOT
22331: IFFALSE 22357
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22333: LD_VAR 0 8
22337: PPUSH
22338: LD_VAR 0 8
22342: PPUSH
22343: LD_VAR 0 2
22347: PPUSH
22348: CALL 23607 0 2
22352: PPUSH
22353: CALL_OW 431
// end ;
22357: GO 22318
22359: POP
22360: POP
// end ; for i = 1 to personel do
22361: LD_ADDR_VAR 0 8
22365: PUSH
22366: DOUBLE
22367: LD_INT 1
22369: DEC
22370: ST_TO_ADDR
22371: LD_VAR 0 6
22375: PUSH
22376: FOR_TO
22377: IFFALSE 23441
// begin if i > 4 then
22379: LD_VAR 0 8
22383: PUSH
22384: LD_INT 4
22386: GREATER
22387: IFFALSE 22391
// break ;
22389: GO 23441
// case i of 1 :
22391: LD_VAR 0 8
22395: PUSH
22396: LD_INT 1
22398: DOUBLE
22399: EQUAL
22400: IFTRUE 22404
22402: GO 22484
22404: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22405: LD_ADDR_VAR 0 12
22409: PUSH
22410: LD_VAR 0 18
22414: PPUSH
22415: LD_INT 22
22417: PUSH
22418: LD_VAR 0 16
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: PUSH
22427: LD_INT 58
22429: PUSH
22430: EMPTY
22431: LIST
22432: PUSH
22433: LD_INT 2
22435: PUSH
22436: LD_INT 30
22438: PUSH
22439: LD_INT 32
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: LD_INT 30
22448: PUSH
22449: LD_INT 4
22451: PUSH
22452: EMPTY
22453: LIST
22454: LIST
22455: PUSH
22456: LD_INT 30
22458: PUSH
22459: LD_INT 5
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: LIST
22470: LIST
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: PPUSH
22477: CALL_OW 72
22481: ST_TO_ADDR
22482: GO 22706
22484: LD_INT 2
22486: DOUBLE
22487: EQUAL
22488: IFTRUE 22492
22490: GO 22554
22492: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22493: LD_ADDR_VAR 0 12
22497: PUSH
22498: LD_VAR 0 18
22502: PPUSH
22503: LD_INT 22
22505: PUSH
22506: LD_VAR 0 16
22510: PUSH
22511: EMPTY
22512: LIST
22513: LIST
22514: PUSH
22515: LD_INT 2
22517: PUSH
22518: LD_INT 30
22520: PUSH
22521: LD_INT 0
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 30
22530: PUSH
22531: LD_INT 1
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: EMPTY
22539: LIST
22540: LIST
22541: LIST
22542: PUSH
22543: EMPTY
22544: LIST
22545: LIST
22546: PPUSH
22547: CALL_OW 72
22551: ST_TO_ADDR
22552: GO 22706
22554: LD_INT 3
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22624
22562: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22563: LD_ADDR_VAR 0 12
22567: PUSH
22568: LD_VAR 0 18
22572: PPUSH
22573: LD_INT 22
22575: PUSH
22576: LD_VAR 0 16
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: LD_INT 2
22587: PUSH
22588: LD_INT 30
22590: PUSH
22591: LD_INT 2
22593: PUSH
22594: EMPTY
22595: LIST
22596: LIST
22597: PUSH
22598: LD_INT 30
22600: PUSH
22601: LD_INT 3
22603: PUSH
22604: EMPTY
22605: LIST
22606: LIST
22607: PUSH
22608: EMPTY
22609: LIST
22610: LIST
22611: LIST
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: PPUSH
22617: CALL_OW 72
22621: ST_TO_ADDR
22622: GO 22706
22624: LD_INT 4
22626: DOUBLE
22627: EQUAL
22628: IFTRUE 22632
22630: GO 22705
22632: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22633: LD_ADDR_VAR 0 12
22637: PUSH
22638: LD_VAR 0 18
22642: PPUSH
22643: LD_INT 22
22645: PUSH
22646: LD_VAR 0 16
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: PUSH
22655: LD_INT 2
22657: PUSH
22658: LD_INT 30
22660: PUSH
22661: LD_INT 6
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 30
22670: PUSH
22671: LD_INT 7
22673: PUSH
22674: EMPTY
22675: LIST
22676: LIST
22677: PUSH
22678: LD_INT 30
22680: PUSH
22681: LD_INT 8
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: LIST
22692: LIST
22693: PUSH
22694: EMPTY
22695: LIST
22696: LIST
22697: PPUSH
22698: CALL_OW 72
22702: ST_TO_ADDR
22703: GO 22706
22705: POP
// if i = 1 then
22706: LD_VAR 0 8
22710: PUSH
22711: LD_INT 1
22713: EQUAL
22714: IFFALSE 22825
// begin tmp := [ ] ;
22716: LD_ADDR_VAR 0 19
22720: PUSH
22721: EMPTY
22722: ST_TO_ADDR
// for j in f do
22723: LD_ADDR_VAR 0 9
22727: PUSH
22728: LD_VAR 0 12
22732: PUSH
22733: FOR_IN
22734: IFFALSE 22807
// if GetBType ( j ) = b_bunker then
22736: LD_VAR 0 9
22740: PPUSH
22741: CALL_OW 266
22745: PUSH
22746: LD_INT 32
22748: EQUAL
22749: IFFALSE 22776
// tmp := Insert ( tmp , 1 , j ) else
22751: LD_ADDR_VAR 0 19
22755: PUSH
22756: LD_VAR 0 19
22760: PPUSH
22761: LD_INT 1
22763: PPUSH
22764: LD_VAR 0 9
22768: PPUSH
22769: CALL_OW 2
22773: ST_TO_ADDR
22774: GO 22805
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22776: LD_ADDR_VAR 0 19
22780: PUSH
22781: LD_VAR 0 19
22785: PPUSH
22786: LD_VAR 0 19
22790: PUSH
22791: LD_INT 1
22793: PLUS
22794: PPUSH
22795: LD_VAR 0 9
22799: PPUSH
22800: CALL_OW 2
22804: ST_TO_ADDR
22805: GO 22733
22807: POP
22808: POP
// if tmp then
22809: LD_VAR 0 19
22813: IFFALSE 22825
// f := tmp ;
22815: LD_ADDR_VAR 0 12
22819: PUSH
22820: LD_VAR 0 19
22824: ST_TO_ADDR
// end ; x := personel [ i ] ;
22825: LD_ADDR_VAR 0 13
22829: PUSH
22830: LD_VAR 0 6
22834: PUSH
22835: LD_VAR 0 8
22839: ARRAY
22840: ST_TO_ADDR
// if x = - 1 then
22841: LD_VAR 0 13
22845: PUSH
22846: LD_INT 1
22848: NEG
22849: EQUAL
22850: IFFALSE 23059
// begin for j in f do
22852: LD_ADDR_VAR 0 9
22856: PUSH
22857: LD_VAR 0 12
22861: PUSH
22862: FOR_IN
22863: IFFALSE 23055
// repeat InitHc ;
22865: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22869: LD_VAR 0 9
22873: PPUSH
22874: CALL_OW 266
22878: PUSH
22879: LD_INT 5
22881: EQUAL
22882: IFFALSE 22952
// begin if UnitsInside ( j ) < 3 then
22884: LD_VAR 0 9
22888: PPUSH
22889: CALL_OW 313
22893: PUSH
22894: LD_INT 3
22896: LESS
22897: IFFALSE 22933
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22899: LD_INT 0
22901: PPUSH
22902: LD_INT 5
22904: PUSH
22905: LD_INT 8
22907: PUSH
22908: LD_INT 9
22910: PUSH
22911: EMPTY
22912: LIST
22913: LIST
22914: LIST
22915: PUSH
22916: LD_VAR 0 17
22920: ARRAY
22921: PPUSH
22922: LD_VAR 0 4
22926: PPUSH
22927: CALL_OW 380
22931: GO 22950
// PrepareHuman ( false , i , skill ) ;
22933: LD_INT 0
22935: PPUSH
22936: LD_VAR 0 8
22940: PPUSH
22941: LD_VAR 0 4
22945: PPUSH
22946: CALL_OW 380
// end else
22950: GO 22969
// PrepareHuman ( false , i , skill ) ;
22952: LD_INT 0
22954: PPUSH
22955: LD_VAR 0 8
22959: PPUSH
22960: LD_VAR 0 4
22964: PPUSH
22965: CALL_OW 380
// un := CreateHuman ;
22969: LD_ADDR_VAR 0 14
22973: PUSH
22974: CALL_OW 44
22978: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22979: LD_ADDR_VAR 0 7
22983: PUSH
22984: LD_VAR 0 7
22988: PPUSH
22989: LD_INT 1
22991: PPUSH
22992: LD_VAR 0 14
22996: PPUSH
22997: CALL_OW 2
23001: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23002: LD_VAR 0 14
23006: PPUSH
23007: LD_VAR 0 9
23011: PPUSH
23012: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23016: LD_VAR 0 9
23020: PPUSH
23021: CALL_OW 313
23025: PUSH
23026: LD_INT 6
23028: EQUAL
23029: PUSH
23030: LD_VAR 0 9
23034: PPUSH
23035: CALL_OW 266
23039: PUSH
23040: LD_INT 32
23042: PUSH
23043: LD_INT 31
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: IN
23050: OR
23051: IFFALSE 22865
23053: GO 22862
23055: POP
23056: POP
// end else
23057: GO 23439
// for j = 1 to x do
23059: LD_ADDR_VAR 0 9
23063: PUSH
23064: DOUBLE
23065: LD_INT 1
23067: DEC
23068: ST_TO_ADDR
23069: LD_VAR 0 13
23073: PUSH
23074: FOR_TO
23075: IFFALSE 23437
// begin InitHc ;
23077: CALL_OW 19
// if not f then
23081: LD_VAR 0 12
23085: NOT
23086: IFFALSE 23175
// begin PrepareHuman ( false , i , skill ) ;
23088: LD_INT 0
23090: PPUSH
23091: LD_VAR 0 8
23095: PPUSH
23096: LD_VAR 0 4
23100: PPUSH
23101: CALL_OW 380
// un := CreateHuman ;
23105: LD_ADDR_VAR 0 14
23109: PUSH
23110: CALL_OW 44
23114: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23115: LD_ADDR_VAR 0 7
23119: PUSH
23120: LD_VAR 0 7
23124: PPUSH
23125: LD_INT 1
23127: PPUSH
23128: LD_VAR 0 14
23132: PPUSH
23133: CALL_OW 2
23137: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23138: LD_VAR 0 14
23142: PPUSH
23143: LD_VAR 0 1
23147: PPUSH
23148: CALL_OW 250
23152: PPUSH
23153: LD_VAR 0 1
23157: PPUSH
23158: CALL_OW 251
23162: PPUSH
23163: LD_INT 10
23165: PPUSH
23166: LD_INT 0
23168: PPUSH
23169: CALL_OW 50
// continue ;
23173: GO 23074
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23175: LD_VAR 0 12
23179: PUSH
23180: LD_INT 1
23182: ARRAY
23183: PPUSH
23184: CALL_OW 313
23188: PUSH
23189: LD_VAR 0 12
23193: PUSH
23194: LD_INT 1
23196: ARRAY
23197: PPUSH
23198: CALL_OW 266
23202: PUSH
23203: LD_INT 32
23205: PUSH
23206: LD_INT 31
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: IN
23213: AND
23214: PUSH
23215: LD_VAR 0 12
23219: PUSH
23220: LD_INT 1
23222: ARRAY
23223: PPUSH
23224: CALL_OW 313
23228: PUSH
23229: LD_INT 6
23231: EQUAL
23232: OR
23233: IFFALSE 23253
// f := Delete ( f , 1 ) ;
23235: LD_ADDR_VAR 0 12
23239: PUSH
23240: LD_VAR 0 12
23244: PPUSH
23245: LD_INT 1
23247: PPUSH
23248: CALL_OW 3
23252: ST_TO_ADDR
// if not f then
23253: LD_VAR 0 12
23257: NOT
23258: IFFALSE 23276
// begin x := x + 2 ;
23260: LD_ADDR_VAR 0 13
23264: PUSH
23265: LD_VAR 0 13
23269: PUSH
23270: LD_INT 2
23272: PLUS
23273: ST_TO_ADDR
// continue ;
23274: GO 23074
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23276: LD_VAR 0 12
23280: PUSH
23281: LD_INT 1
23283: ARRAY
23284: PPUSH
23285: CALL_OW 266
23289: PUSH
23290: LD_INT 5
23292: EQUAL
23293: IFFALSE 23367
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23295: LD_VAR 0 12
23299: PUSH
23300: LD_INT 1
23302: ARRAY
23303: PPUSH
23304: CALL_OW 313
23308: PUSH
23309: LD_INT 3
23311: LESS
23312: IFFALSE 23348
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23314: LD_INT 0
23316: PPUSH
23317: LD_INT 5
23319: PUSH
23320: LD_INT 8
23322: PUSH
23323: LD_INT 9
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: LIST
23330: PUSH
23331: LD_VAR 0 17
23335: ARRAY
23336: PPUSH
23337: LD_VAR 0 4
23341: PPUSH
23342: CALL_OW 380
23346: GO 23365
// PrepareHuman ( false , i , skill ) ;
23348: LD_INT 0
23350: PPUSH
23351: LD_VAR 0 8
23355: PPUSH
23356: LD_VAR 0 4
23360: PPUSH
23361: CALL_OW 380
// end else
23365: GO 23384
// PrepareHuman ( false , i , skill ) ;
23367: LD_INT 0
23369: PPUSH
23370: LD_VAR 0 8
23374: PPUSH
23375: LD_VAR 0 4
23379: PPUSH
23380: CALL_OW 380
// un := CreateHuman ;
23384: LD_ADDR_VAR 0 14
23388: PUSH
23389: CALL_OW 44
23393: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23394: LD_ADDR_VAR 0 7
23398: PUSH
23399: LD_VAR 0 7
23403: PPUSH
23404: LD_INT 1
23406: PPUSH
23407: LD_VAR 0 14
23411: PPUSH
23412: CALL_OW 2
23416: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23417: LD_VAR 0 14
23421: PPUSH
23422: LD_VAR 0 12
23426: PUSH
23427: LD_INT 1
23429: ARRAY
23430: PPUSH
23431: CALL_OW 52
// end ;
23435: GO 23074
23437: POP
23438: POP
// end ;
23439: GO 22376
23441: POP
23442: POP
// result := result ^ buildings ;
23443: LD_ADDR_VAR 0 7
23447: PUSH
23448: LD_VAR 0 7
23452: PUSH
23453: LD_VAR 0 18
23457: ADD
23458: ST_TO_ADDR
// end else
23459: GO 23602
// begin for i = 1 to personel do
23461: LD_ADDR_VAR 0 8
23465: PUSH
23466: DOUBLE
23467: LD_INT 1
23469: DEC
23470: ST_TO_ADDR
23471: LD_VAR 0 6
23475: PUSH
23476: FOR_TO
23477: IFFALSE 23600
// begin if i > 4 then
23479: LD_VAR 0 8
23483: PUSH
23484: LD_INT 4
23486: GREATER
23487: IFFALSE 23491
// break ;
23489: GO 23600
// x := personel [ i ] ;
23491: LD_ADDR_VAR 0 13
23495: PUSH
23496: LD_VAR 0 6
23500: PUSH
23501: LD_VAR 0 8
23505: ARRAY
23506: ST_TO_ADDR
// if x = - 1 then
23507: LD_VAR 0 13
23511: PUSH
23512: LD_INT 1
23514: NEG
23515: EQUAL
23516: IFFALSE 23520
// continue ;
23518: GO 23476
// PrepareHuman ( false , i , skill ) ;
23520: LD_INT 0
23522: PPUSH
23523: LD_VAR 0 8
23527: PPUSH
23528: LD_VAR 0 4
23532: PPUSH
23533: CALL_OW 380
// un := CreateHuman ;
23537: LD_ADDR_VAR 0 14
23541: PUSH
23542: CALL_OW 44
23546: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23547: LD_VAR 0 14
23551: PPUSH
23552: LD_VAR 0 1
23556: PPUSH
23557: CALL_OW 250
23561: PPUSH
23562: LD_VAR 0 1
23566: PPUSH
23567: CALL_OW 251
23571: PPUSH
23572: LD_INT 10
23574: PPUSH
23575: LD_INT 0
23577: PPUSH
23578: CALL_OW 50
// result := result ^ un ;
23582: LD_ADDR_VAR 0 7
23586: PUSH
23587: LD_VAR 0 7
23591: PUSH
23592: LD_VAR 0 14
23596: ADD
23597: ST_TO_ADDR
// end ;
23598: GO 23476
23600: POP
23601: POP
// end ; end ;
23602: LD_VAR 0 7
23606: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23607: LD_INT 0
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
23613: PPUSH
23614: PPUSH
23615: PPUSH
23616: PPUSH
23617: PPUSH
23618: PPUSH
23619: PPUSH
23620: PPUSH
23621: PPUSH
23622: PPUSH
23623: PPUSH
23624: PPUSH
// result := false ;
23625: LD_ADDR_VAR 0 3
23629: PUSH
23630: LD_INT 0
23632: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23633: LD_VAR 0 1
23637: NOT
23638: PUSH
23639: LD_VAR 0 1
23643: PPUSH
23644: CALL_OW 266
23648: PUSH
23649: LD_INT 32
23651: PUSH
23652: LD_INT 33
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: IN
23659: NOT
23660: OR
23661: IFFALSE 23665
// exit ;
23663: GO 24774
// nat := GetNation ( tower ) ;
23665: LD_ADDR_VAR 0 12
23669: PUSH
23670: LD_VAR 0 1
23674: PPUSH
23675: CALL_OW 248
23679: ST_TO_ADDR
// side := GetSide ( tower ) ;
23680: LD_ADDR_VAR 0 16
23684: PUSH
23685: LD_VAR 0 1
23689: PPUSH
23690: CALL_OW 255
23694: ST_TO_ADDR
// x := GetX ( tower ) ;
23695: LD_ADDR_VAR 0 10
23699: PUSH
23700: LD_VAR 0 1
23704: PPUSH
23705: CALL_OW 250
23709: ST_TO_ADDR
// y := GetY ( tower ) ;
23710: LD_ADDR_VAR 0 11
23714: PUSH
23715: LD_VAR 0 1
23719: PPUSH
23720: CALL_OW 251
23724: ST_TO_ADDR
// if not x or not y then
23725: LD_VAR 0 10
23729: NOT
23730: PUSH
23731: LD_VAR 0 11
23735: NOT
23736: OR
23737: IFFALSE 23741
// exit ;
23739: GO 24774
// weapon := 0 ;
23741: LD_ADDR_VAR 0 18
23745: PUSH
23746: LD_INT 0
23748: ST_TO_ADDR
// fac_list := [ ] ;
23749: LD_ADDR_VAR 0 17
23753: PUSH
23754: EMPTY
23755: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23756: LD_ADDR_VAR 0 6
23760: PUSH
23761: LD_VAR 0 1
23765: PPUSH
23766: CALL_OW 274
23770: PPUSH
23771: LD_VAR 0 2
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL 21345 0 3
23783: PPUSH
23784: LD_INT 30
23786: PUSH
23787: LD_INT 3
23789: PUSH
23790: EMPTY
23791: LIST
23792: LIST
23793: PPUSH
23794: CALL_OW 72
23798: ST_TO_ADDR
// if not factories then
23799: LD_VAR 0 6
23803: NOT
23804: IFFALSE 23808
// exit ;
23806: GO 24774
// for i in factories do
23808: LD_ADDR_VAR 0 8
23812: PUSH
23813: LD_VAR 0 6
23817: PUSH
23818: FOR_IN
23819: IFFALSE 23844
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23821: LD_ADDR_VAR 0 17
23825: PUSH
23826: LD_VAR 0 17
23830: PUSH
23831: LD_VAR 0 8
23835: PPUSH
23836: CALL_OW 478
23840: UNION
23841: ST_TO_ADDR
23842: GO 23818
23844: POP
23845: POP
// if not fac_list then
23846: LD_VAR 0 17
23850: NOT
23851: IFFALSE 23855
// exit ;
23853: GO 24774
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23855: LD_ADDR_VAR 0 5
23859: PUSH
23860: LD_INT 4
23862: PUSH
23863: LD_INT 5
23865: PUSH
23866: LD_INT 9
23868: PUSH
23869: LD_INT 10
23871: PUSH
23872: LD_INT 6
23874: PUSH
23875: LD_INT 7
23877: PUSH
23878: LD_INT 11
23880: PUSH
23881: EMPTY
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: PUSH
23890: LD_INT 27
23892: PUSH
23893: LD_INT 28
23895: PUSH
23896: LD_INT 26
23898: PUSH
23899: LD_INT 30
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: LIST
23906: LIST
23907: PUSH
23908: LD_INT 43
23910: PUSH
23911: LD_INT 44
23913: PUSH
23914: LD_INT 46
23916: PUSH
23917: LD_INT 45
23919: PUSH
23920: LD_INT 47
23922: PUSH
23923: LD_INT 49
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: LIST
23938: PUSH
23939: LD_VAR 0 12
23943: ARRAY
23944: ST_TO_ADDR
// list := list isect fac_list ;
23945: LD_ADDR_VAR 0 5
23949: PUSH
23950: LD_VAR 0 5
23954: PUSH
23955: LD_VAR 0 17
23959: ISECT
23960: ST_TO_ADDR
// if not list then
23961: LD_VAR 0 5
23965: NOT
23966: IFFALSE 23970
// exit ;
23968: GO 24774
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23970: LD_VAR 0 12
23974: PUSH
23975: LD_INT 3
23977: EQUAL
23978: PUSH
23979: LD_INT 49
23981: PUSH
23982: LD_VAR 0 5
23986: IN
23987: AND
23988: PUSH
23989: LD_INT 31
23991: PPUSH
23992: LD_VAR 0 16
23996: PPUSH
23997: CALL_OW 321
24001: PUSH
24002: LD_INT 2
24004: EQUAL
24005: AND
24006: IFFALSE 24066
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24008: LD_INT 22
24010: PUSH
24011: LD_VAR 0 16
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: PUSH
24020: LD_INT 35
24022: PUSH
24023: LD_INT 49
24025: PUSH
24026: EMPTY
24027: LIST
24028: LIST
24029: PUSH
24030: LD_INT 91
24032: PUSH
24033: LD_VAR 0 1
24037: PUSH
24038: LD_INT 10
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: LIST
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: PPUSH
24051: CALL_OW 69
24055: NOT
24056: IFFALSE 24066
// weapon := ru_time_lapser ;
24058: LD_ADDR_VAR 0 18
24062: PUSH
24063: LD_INT 49
24065: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24066: LD_VAR 0 12
24070: PUSH
24071: LD_INT 1
24073: PUSH
24074: LD_INT 2
24076: PUSH
24077: EMPTY
24078: LIST
24079: LIST
24080: IN
24081: PUSH
24082: LD_INT 11
24084: PUSH
24085: LD_VAR 0 5
24089: IN
24090: PUSH
24091: LD_INT 30
24093: PUSH
24094: LD_VAR 0 5
24098: IN
24099: OR
24100: AND
24101: PUSH
24102: LD_INT 6
24104: PPUSH
24105: LD_VAR 0 16
24109: PPUSH
24110: CALL_OW 321
24114: PUSH
24115: LD_INT 2
24117: EQUAL
24118: AND
24119: IFFALSE 24284
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24121: LD_INT 22
24123: PUSH
24124: LD_VAR 0 16
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: LD_INT 2
24135: PUSH
24136: LD_INT 35
24138: PUSH
24139: LD_INT 11
24141: PUSH
24142: EMPTY
24143: LIST
24144: LIST
24145: PUSH
24146: LD_INT 35
24148: PUSH
24149: LD_INT 30
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: LIST
24160: PUSH
24161: LD_INT 91
24163: PUSH
24164: LD_VAR 0 1
24168: PUSH
24169: LD_INT 18
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: LIST
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: LIST
24181: PPUSH
24182: CALL_OW 69
24186: NOT
24187: PUSH
24188: LD_INT 22
24190: PUSH
24191: LD_VAR 0 16
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PUSH
24200: LD_INT 2
24202: PUSH
24203: LD_INT 30
24205: PUSH
24206: LD_INT 32
24208: PUSH
24209: EMPTY
24210: LIST
24211: LIST
24212: PUSH
24213: LD_INT 30
24215: PUSH
24216: LD_INT 33
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: LIST
24227: PUSH
24228: LD_INT 91
24230: PUSH
24231: LD_VAR 0 1
24235: PUSH
24236: LD_INT 12
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: LIST
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: LIST
24248: PUSH
24249: EMPTY
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PUSH
24257: LD_INT 2
24259: GREATER
24260: AND
24261: IFFALSE 24284
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24263: LD_ADDR_VAR 0 18
24267: PUSH
24268: LD_INT 11
24270: PUSH
24271: LD_INT 30
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PUSH
24278: LD_VAR 0 12
24282: ARRAY
24283: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24284: LD_VAR 0 18
24288: NOT
24289: PUSH
24290: LD_INT 40
24292: PPUSH
24293: LD_VAR 0 16
24297: PPUSH
24298: CALL_OW 321
24302: PUSH
24303: LD_INT 2
24305: EQUAL
24306: AND
24307: PUSH
24308: LD_INT 7
24310: PUSH
24311: LD_VAR 0 5
24315: IN
24316: PUSH
24317: LD_INT 28
24319: PUSH
24320: LD_VAR 0 5
24324: IN
24325: OR
24326: PUSH
24327: LD_INT 45
24329: PUSH
24330: LD_VAR 0 5
24334: IN
24335: OR
24336: AND
24337: IFFALSE 24591
// begin hex := GetHexInfo ( x , y ) ;
24339: LD_ADDR_VAR 0 4
24343: PUSH
24344: LD_VAR 0 10
24348: PPUSH
24349: LD_VAR 0 11
24353: PPUSH
24354: CALL_OW 546
24358: ST_TO_ADDR
// if hex [ 1 ] then
24359: LD_VAR 0 4
24363: PUSH
24364: LD_INT 1
24366: ARRAY
24367: IFFALSE 24371
// exit ;
24369: GO 24774
// height := hex [ 2 ] ;
24371: LD_ADDR_VAR 0 15
24375: PUSH
24376: LD_VAR 0 4
24380: PUSH
24381: LD_INT 2
24383: ARRAY
24384: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24385: LD_ADDR_VAR 0 14
24389: PUSH
24390: LD_INT 0
24392: PUSH
24393: LD_INT 2
24395: PUSH
24396: LD_INT 3
24398: PUSH
24399: LD_INT 5
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: LIST
24406: LIST
24407: ST_TO_ADDR
// for i in tmp do
24408: LD_ADDR_VAR 0 8
24412: PUSH
24413: LD_VAR 0 14
24417: PUSH
24418: FOR_IN
24419: IFFALSE 24589
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24421: LD_ADDR_VAR 0 9
24425: PUSH
24426: LD_VAR 0 10
24430: PPUSH
24431: LD_VAR 0 8
24435: PPUSH
24436: LD_INT 5
24438: PPUSH
24439: CALL_OW 272
24443: PUSH
24444: LD_VAR 0 11
24448: PPUSH
24449: LD_VAR 0 8
24453: PPUSH
24454: LD_INT 5
24456: PPUSH
24457: CALL_OW 273
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 1
24473: ARRAY
24474: PPUSH
24475: LD_VAR 0 9
24479: PUSH
24480: LD_INT 2
24482: ARRAY
24483: PPUSH
24484: CALL_OW 488
24488: IFFALSE 24587
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24490: LD_ADDR_VAR 0 4
24494: PUSH
24495: LD_VAR 0 9
24499: PUSH
24500: LD_INT 1
24502: ARRAY
24503: PPUSH
24504: LD_VAR 0 9
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: PPUSH
24513: CALL_OW 546
24517: ST_TO_ADDR
// if hex [ 1 ] then
24518: LD_VAR 0 4
24522: PUSH
24523: LD_INT 1
24525: ARRAY
24526: IFFALSE 24530
// continue ;
24528: GO 24418
// h := hex [ 2 ] ;
24530: LD_ADDR_VAR 0 13
24534: PUSH
24535: LD_VAR 0 4
24539: PUSH
24540: LD_INT 2
24542: ARRAY
24543: ST_TO_ADDR
// if h + 7 < height then
24544: LD_VAR 0 13
24548: PUSH
24549: LD_INT 7
24551: PLUS
24552: PUSH
24553: LD_VAR 0 15
24557: LESS
24558: IFFALSE 24587
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24560: LD_ADDR_VAR 0 18
24564: PUSH
24565: LD_INT 7
24567: PUSH
24568: LD_INT 28
24570: PUSH
24571: LD_INT 45
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: LIST
24578: PUSH
24579: LD_VAR 0 12
24583: ARRAY
24584: ST_TO_ADDR
// break ;
24585: GO 24589
// end ; end ; end ;
24587: GO 24418
24589: POP
24590: POP
// end ; if not weapon then
24591: LD_VAR 0 18
24595: NOT
24596: IFFALSE 24656
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24598: LD_ADDR_VAR 0 5
24602: PUSH
24603: LD_VAR 0 5
24607: PUSH
24608: LD_INT 11
24610: PUSH
24611: LD_INT 30
24613: PUSH
24614: LD_INT 49
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: LIST
24621: DIFF
24622: ST_TO_ADDR
// if not list then
24623: LD_VAR 0 5
24627: NOT
24628: IFFALSE 24632
// exit ;
24630: GO 24774
// weapon := list [ rand ( 1 , list ) ] ;
24632: LD_ADDR_VAR 0 18
24636: PUSH
24637: LD_VAR 0 5
24641: PUSH
24642: LD_INT 1
24644: PPUSH
24645: LD_VAR 0 5
24649: PPUSH
24650: CALL_OW 12
24654: ARRAY
24655: ST_TO_ADDR
// end ; if weapon then
24656: LD_VAR 0 18
24660: IFFALSE 24774
// begin tmp := CostOfWeapon ( weapon ) ;
24662: LD_ADDR_VAR 0 14
24666: PUSH
24667: LD_VAR 0 18
24671: PPUSH
24672: CALL_OW 451
24676: ST_TO_ADDR
// j := GetBase ( tower ) ;
24677: LD_ADDR_VAR 0 9
24681: PUSH
24682: LD_VAR 0 1
24686: PPUSH
24687: CALL_OW 274
24691: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24692: LD_VAR 0 9
24696: PPUSH
24697: LD_INT 1
24699: PPUSH
24700: CALL_OW 275
24704: PUSH
24705: LD_VAR 0 14
24709: PUSH
24710: LD_INT 1
24712: ARRAY
24713: GREATEREQUAL
24714: PUSH
24715: LD_VAR 0 9
24719: PPUSH
24720: LD_INT 2
24722: PPUSH
24723: CALL_OW 275
24727: PUSH
24728: LD_VAR 0 14
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: GREATEREQUAL
24737: AND
24738: PUSH
24739: LD_VAR 0 9
24743: PPUSH
24744: LD_INT 3
24746: PPUSH
24747: CALL_OW 275
24751: PUSH
24752: LD_VAR 0 14
24756: PUSH
24757: LD_INT 3
24759: ARRAY
24760: GREATEREQUAL
24761: AND
24762: IFFALSE 24774
// result := weapon ;
24764: LD_ADDR_VAR 0 3
24768: PUSH
24769: LD_VAR 0 18
24773: ST_TO_ADDR
// end ; end ;
24774: LD_VAR 0 3
24778: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24779: LD_INT 0
24781: PPUSH
24782: PPUSH
// result := true ;
24783: LD_ADDR_VAR 0 3
24787: PUSH
24788: LD_INT 1
24790: ST_TO_ADDR
// if array1 = array2 then
24791: LD_VAR 0 1
24795: PUSH
24796: LD_VAR 0 2
24800: EQUAL
24801: IFFALSE 24861
// begin for i = 1 to array1 do
24803: LD_ADDR_VAR 0 4
24807: PUSH
24808: DOUBLE
24809: LD_INT 1
24811: DEC
24812: ST_TO_ADDR
24813: LD_VAR 0 1
24817: PUSH
24818: FOR_TO
24819: IFFALSE 24857
// if array1 [ i ] <> array2 [ i ] then
24821: LD_VAR 0 1
24825: PUSH
24826: LD_VAR 0 4
24830: ARRAY
24831: PUSH
24832: LD_VAR 0 2
24836: PUSH
24837: LD_VAR 0 4
24841: ARRAY
24842: NONEQUAL
24843: IFFALSE 24855
// begin result := false ;
24845: LD_ADDR_VAR 0 3
24849: PUSH
24850: LD_INT 0
24852: ST_TO_ADDR
// break ;
24853: GO 24857
// end ;
24855: GO 24818
24857: POP
24858: POP
// end else
24859: GO 24869
// result := false ;
24861: LD_ADDR_VAR 0 3
24865: PUSH
24866: LD_INT 0
24868: ST_TO_ADDR
// end ;
24869: LD_VAR 0 3
24873: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24874: LD_INT 0
24876: PPUSH
24877: PPUSH
// if not array1 or not array2 then
24878: LD_VAR 0 1
24882: NOT
24883: PUSH
24884: LD_VAR 0 2
24888: NOT
24889: OR
24890: IFFALSE 24894
// exit ;
24892: GO 24958
// result := true ;
24894: LD_ADDR_VAR 0 3
24898: PUSH
24899: LD_INT 1
24901: ST_TO_ADDR
// for i = 1 to array1 do
24902: LD_ADDR_VAR 0 4
24906: PUSH
24907: DOUBLE
24908: LD_INT 1
24910: DEC
24911: ST_TO_ADDR
24912: LD_VAR 0 1
24916: PUSH
24917: FOR_TO
24918: IFFALSE 24956
// if array1 [ i ] <> array2 [ i ] then
24920: LD_VAR 0 1
24924: PUSH
24925: LD_VAR 0 4
24929: ARRAY
24930: PUSH
24931: LD_VAR 0 2
24935: PUSH
24936: LD_VAR 0 4
24940: ARRAY
24941: NONEQUAL
24942: IFFALSE 24954
// begin result := false ;
24944: LD_ADDR_VAR 0 3
24948: PUSH
24949: LD_INT 0
24951: ST_TO_ADDR
// break ;
24952: GO 24956
// end ;
24954: GO 24917
24956: POP
24957: POP
// end ;
24958: LD_VAR 0 3
24962: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24963: LD_INT 0
24965: PPUSH
24966: PPUSH
24967: PPUSH
// pom := GetBase ( fac ) ;
24968: LD_ADDR_VAR 0 5
24972: PUSH
24973: LD_VAR 0 1
24977: PPUSH
24978: CALL_OW 274
24982: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24983: LD_ADDR_VAR 0 4
24987: PUSH
24988: LD_VAR 0 2
24992: PUSH
24993: LD_INT 1
24995: ARRAY
24996: PPUSH
24997: LD_VAR 0 2
25001: PUSH
25002: LD_INT 2
25004: ARRAY
25005: PPUSH
25006: LD_VAR 0 2
25010: PUSH
25011: LD_INT 3
25013: ARRAY
25014: PPUSH
25015: LD_VAR 0 2
25019: PUSH
25020: LD_INT 4
25022: ARRAY
25023: PPUSH
25024: CALL_OW 449
25028: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25029: LD_ADDR_VAR 0 3
25033: PUSH
25034: LD_VAR 0 5
25038: PPUSH
25039: LD_INT 1
25041: PPUSH
25042: CALL_OW 275
25046: PUSH
25047: LD_VAR 0 4
25051: PUSH
25052: LD_INT 1
25054: ARRAY
25055: GREATEREQUAL
25056: PUSH
25057: LD_VAR 0 5
25061: PPUSH
25062: LD_INT 2
25064: PPUSH
25065: CALL_OW 275
25069: PUSH
25070: LD_VAR 0 4
25074: PUSH
25075: LD_INT 2
25077: ARRAY
25078: GREATEREQUAL
25079: AND
25080: PUSH
25081: LD_VAR 0 5
25085: PPUSH
25086: LD_INT 3
25088: PPUSH
25089: CALL_OW 275
25093: PUSH
25094: LD_VAR 0 4
25098: PUSH
25099: LD_INT 3
25101: ARRAY
25102: GREATEREQUAL
25103: AND
25104: ST_TO_ADDR
// end ;
25105: LD_VAR 0 3
25109: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25110: LD_INT 0
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
// pom := GetBase ( building ) ;
25116: LD_ADDR_VAR 0 3
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 274
25130: ST_TO_ADDR
// if not pom then
25131: LD_VAR 0 3
25135: NOT
25136: IFFALSE 25140
// exit ;
25138: GO 25310
// btype := GetBType ( building ) ;
25140: LD_ADDR_VAR 0 5
25144: PUSH
25145: LD_VAR 0 1
25149: PPUSH
25150: CALL_OW 266
25154: ST_TO_ADDR
// if btype = b_armoury then
25155: LD_VAR 0 5
25159: PUSH
25160: LD_INT 4
25162: EQUAL
25163: IFFALSE 25173
// btype := b_barracks ;
25165: LD_ADDR_VAR 0 5
25169: PUSH
25170: LD_INT 5
25172: ST_TO_ADDR
// if btype = b_depot then
25173: LD_VAR 0 5
25177: PUSH
25178: LD_INT 0
25180: EQUAL
25181: IFFALSE 25191
// btype := b_warehouse ;
25183: LD_ADDR_VAR 0 5
25187: PUSH
25188: LD_INT 1
25190: ST_TO_ADDR
// if btype = b_workshop then
25191: LD_VAR 0 5
25195: PUSH
25196: LD_INT 2
25198: EQUAL
25199: IFFALSE 25209
// btype := b_factory ;
25201: LD_ADDR_VAR 0 5
25205: PUSH
25206: LD_INT 3
25208: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25209: LD_ADDR_VAR 0 4
25213: PUSH
25214: LD_VAR 0 5
25218: PPUSH
25219: LD_VAR 0 1
25223: PPUSH
25224: CALL_OW 248
25228: PPUSH
25229: CALL_OW 450
25233: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25234: LD_ADDR_VAR 0 2
25238: PUSH
25239: LD_VAR 0 3
25243: PPUSH
25244: LD_INT 1
25246: PPUSH
25247: CALL_OW 275
25251: PUSH
25252: LD_VAR 0 4
25256: PUSH
25257: LD_INT 1
25259: ARRAY
25260: GREATEREQUAL
25261: PUSH
25262: LD_VAR 0 3
25266: PPUSH
25267: LD_INT 2
25269: PPUSH
25270: CALL_OW 275
25274: PUSH
25275: LD_VAR 0 4
25279: PUSH
25280: LD_INT 2
25282: ARRAY
25283: GREATEREQUAL
25284: AND
25285: PUSH
25286: LD_VAR 0 3
25290: PPUSH
25291: LD_INT 3
25293: PPUSH
25294: CALL_OW 275
25298: PUSH
25299: LD_VAR 0 4
25303: PUSH
25304: LD_INT 3
25306: ARRAY
25307: GREATEREQUAL
25308: AND
25309: ST_TO_ADDR
// end ;
25310: LD_VAR 0 2
25314: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25315: LD_INT 0
25317: PPUSH
25318: PPUSH
25319: PPUSH
// pom := GetBase ( building ) ;
25320: LD_ADDR_VAR 0 4
25324: PUSH
25325: LD_VAR 0 1
25329: PPUSH
25330: CALL_OW 274
25334: ST_TO_ADDR
// if not pom then
25335: LD_VAR 0 4
25339: NOT
25340: IFFALSE 25344
// exit ;
25342: GO 25445
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25344: LD_ADDR_VAR 0 5
25348: PUSH
25349: LD_VAR 0 2
25353: PPUSH
25354: LD_VAR 0 1
25358: PPUSH
25359: CALL_OW 248
25363: PPUSH
25364: CALL_OW 450
25368: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25369: LD_ADDR_VAR 0 3
25373: PUSH
25374: LD_VAR 0 4
25378: PPUSH
25379: LD_INT 1
25381: PPUSH
25382: CALL_OW 275
25386: PUSH
25387: LD_VAR 0 5
25391: PUSH
25392: LD_INT 1
25394: ARRAY
25395: GREATEREQUAL
25396: PUSH
25397: LD_VAR 0 4
25401: PPUSH
25402: LD_INT 2
25404: PPUSH
25405: CALL_OW 275
25409: PUSH
25410: LD_VAR 0 5
25414: PUSH
25415: LD_INT 2
25417: ARRAY
25418: GREATEREQUAL
25419: AND
25420: PUSH
25421: LD_VAR 0 4
25425: PPUSH
25426: LD_INT 3
25428: PPUSH
25429: CALL_OW 275
25433: PUSH
25434: LD_VAR 0 5
25438: PUSH
25439: LD_INT 3
25441: ARRAY
25442: GREATEREQUAL
25443: AND
25444: ST_TO_ADDR
// end ;
25445: LD_VAR 0 3
25449: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25450: LD_INT 0
25452: PPUSH
25453: PPUSH
25454: PPUSH
25455: PPUSH
25456: PPUSH
25457: PPUSH
25458: PPUSH
25459: PPUSH
25460: PPUSH
25461: PPUSH
25462: PPUSH
// result := false ;
25463: LD_ADDR_VAR 0 8
25467: PUSH
25468: LD_INT 0
25470: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25471: LD_VAR 0 5
25475: NOT
25476: PUSH
25477: LD_VAR 0 1
25481: NOT
25482: OR
25483: PUSH
25484: LD_VAR 0 2
25488: NOT
25489: OR
25490: PUSH
25491: LD_VAR 0 3
25495: NOT
25496: OR
25497: IFFALSE 25501
// exit ;
25499: GO 26315
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25501: LD_ADDR_VAR 0 14
25505: PUSH
25506: LD_VAR 0 1
25510: PPUSH
25511: LD_VAR 0 2
25515: PPUSH
25516: LD_VAR 0 3
25520: PPUSH
25521: LD_VAR 0 4
25525: PPUSH
25526: LD_VAR 0 5
25530: PUSH
25531: LD_INT 1
25533: ARRAY
25534: PPUSH
25535: CALL_OW 248
25539: PPUSH
25540: LD_INT 0
25542: PPUSH
25543: CALL 27552 0 6
25547: ST_TO_ADDR
// if not hexes then
25548: LD_VAR 0 14
25552: NOT
25553: IFFALSE 25557
// exit ;
25555: GO 26315
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25557: LD_ADDR_VAR 0 17
25561: PUSH
25562: LD_VAR 0 5
25566: PPUSH
25567: LD_INT 22
25569: PUSH
25570: LD_VAR 0 13
25574: PPUSH
25575: CALL_OW 255
25579: PUSH
25580: EMPTY
25581: LIST
25582: LIST
25583: PUSH
25584: LD_INT 2
25586: PUSH
25587: LD_INT 30
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 30
25599: PUSH
25600: LD_INT 1
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PUSH
25607: EMPTY
25608: LIST
25609: LIST
25610: LIST
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PPUSH
25616: CALL_OW 72
25620: ST_TO_ADDR
// for i = 1 to hexes do
25621: LD_ADDR_VAR 0 9
25625: PUSH
25626: DOUBLE
25627: LD_INT 1
25629: DEC
25630: ST_TO_ADDR
25631: LD_VAR 0 14
25635: PUSH
25636: FOR_TO
25637: IFFALSE 26313
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25639: LD_ADDR_VAR 0 13
25643: PUSH
25644: LD_VAR 0 14
25648: PUSH
25649: LD_VAR 0 9
25653: ARRAY
25654: PUSH
25655: LD_INT 1
25657: ARRAY
25658: PPUSH
25659: LD_VAR 0 14
25663: PUSH
25664: LD_VAR 0 9
25668: ARRAY
25669: PUSH
25670: LD_INT 2
25672: ARRAY
25673: PPUSH
25674: CALL_OW 428
25678: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25679: LD_VAR 0 14
25683: PUSH
25684: LD_VAR 0 9
25688: ARRAY
25689: PUSH
25690: LD_INT 1
25692: ARRAY
25693: PPUSH
25694: LD_VAR 0 14
25698: PUSH
25699: LD_VAR 0 9
25703: ARRAY
25704: PUSH
25705: LD_INT 2
25707: ARRAY
25708: PPUSH
25709: CALL_OW 351
25713: PUSH
25714: LD_VAR 0 14
25718: PUSH
25719: LD_VAR 0 9
25723: ARRAY
25724: PUSH
25725: LD_INT 1
25727: ARRAY
25728: PPUSH
25729: LD_VAR 0 14
25733: PUSH
25734: LD_VAR 0 9
25738: ARRAY
25739: PUSH
25740: LD_INT 2
25742: ARRAY
25743: PPUSH
25744: CALL_OW 488
25748: NOT
25749: OR
25750: PUSH
25751: LD_VAR 0 13
25755: PPUSH
25756: CALL_OW 247
25760: PUSH
25761: LD_INT 3
25763: EQUAL
25764: OR
25765: IFFALSE 25771
// exit ;
25767: POP
25768: POP
25769: GO 26315
// if not tmp then
25771: LD_VAR 0 13
25775: NOT
25776: IFFALSE 25780
// continue ;
25778: GO 25636
// result := true ;
25780: LD_ADDR_VAR 0 8
25784: PUSH
25785: LD_INT 1
25787: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25788: LD_VAR 0 6
25792: PUSH
25793: LD_VAR 0 13
25797: PPUSH
25798: CALL_OW 247
25802: PUSH
25803: LD_INT 2
25805: EQUAL
25806: AND
25807: PUSH
25808: LD_VAR 0 13
25812: PPUSH
25813: CALL_OW 263
25817: PUSH
25818: LD_INT 1
25820: EQUAL
25821: AND
25822: IFFALSE 25986
// begin if IsDrivenBy ( tmp ) then
25824: LD_VAR 0 13
25828: PPUSH
25829: CALL_OW 311
25833: IFFALSE 25837
// continue ;
25835: GO 25636
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25837: LD_VAR 0 6
25841: PPUSH
25842: LD_INT 3
25844: PUSH
25845: LD_INT 60
25847: PUSH
25848: EMPTY
25849: LIST
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PUSH
25855: LD_INT 3
25857: PUSH
25858: LD_INT 55
25860: PUSH
25861: EMPTY
25862: LIST
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PPUSH
25872: CALL_OW 72
25876: IFFALSE 25984
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25878: LD_ADDR_VAR 0 18
25882: PUSH
25883: LD_VAR 0 6
25887: PPUSH
25888: LD_INT 3
25890: PUSH
25891: LD_INT 60
25893: PUSH
25894: EMPTY
25895: LIST
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PUSH
25901: LD_INT 3
25903: PUSH
25904: LD_INT 55
25906: PUSH
25907: EMPTY
25908: LIST
25909: PUSH
25910: EMPTY
25911: LIST
25912: LIST
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PPUSH
25918: CALL_OW 72
25922: PUSH
25923: LD_INT 1
25925: ARRAY
25926: ST_TO_ADDR
// if IsInUnit ( driver ) then
25927: LD_VAR 0 18
25931: PPUSH
25932: CALL_OW 310
25936: IFFALSE 25947
// ComExit ( driver ) ;
25938: LD_VAR 0 18
25942: PPUSH
25943: CALL 50680 0 1
// AddComEnterUnit ( driver , tmp ) ;
25947: LD_VAR 0 18
25951: PPUSH
25952: LD_VAR 0 13
25956: PPUSH
25957: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25961: LD_VAR 0 18
25965: PPUSH
25966: LD_VAR 0 7
25970: PPUSH
25971: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25975: LD_VAR 0 18
25979: PPUSH
25980: CALL_OW 181
// end ; continue ;
25984: GO 25636
// end ; if not cleaners or not tmp in cleaners then
25986: LD_VAR 0 6
25990: NOT
25991: PUSH
25992: LD_VAR 0 13
25996: PUSH
25997: LD_VAR 0 6
26001: IN
26002: NOT
26003: OR
26004: IFFALSE 26311
// begin if dep then
26006: LD_VAR 0 17
26010: IFFALSE 26146
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26012: LD_ADDR_VAR 0 16
26016: PUSH
26017: LD_VAR 0 17
26021: PUSH
26022: LD_INT 1
26024: ARRAY
26025: PPUSH
26026: CALL_OW 250
26030: PPUSH
26031: LD_VAR 0 17
26035: PUSH
26036: LD_INT 1
26038: ARRAY
26039: PPUSH
26040: CALL_OW 254
26044: PPUSH
26045: LD_INT 5
26047: PPUSH
26048: CALL_OW 272
26052: PUSH
26053: LD_VAR 0 17
26057: PUSH
26058: LD_INT 1
26060: ARRAY
26061: PPUSH
26062: CALL_OW 251
26066: PPUSH
26067: LD_VAR 0 17
26071: PUSH
26072: LD_INT 1
26074: ARRAY
26075: PPUSH
26076: CALL_OW 254
26080: PPUSH
26081: LD_INT 5
26083: PPUSH
26084: CALL_OW 273
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26093: LD_VAR 0 16
26097: PUSH
26098: LD_INT 1
26100: ARRAY
26101: PPUSH
26102: LD_VAR 0 16
26106: PUSH
26107: LD_INT 2
26109: ARRAY
26110: PPUSH
26111: CALL_OW 488
26115: IFFALSE 26146
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26117: LD_VAR 0 13
26121: PPUSH
26122: LD_VAR 0 16
26126: PUSH
26127: LD_INT 1
26129: ARRAY
26130: PPUSH
26131: LD_VAR 0 16
26135: PUSH
26136: LD_INT 2
26138: ARRAY
26139: PPUSH
26140: CALL_OW 111
// continue ;
26144: GO 25636
// end ; end ; r := GetDir ( tmp ) ;
26146: LD_ADDR_VAR 0 15
26150: PUSH
26151: LD_VAR 0 13
26155: PPUSH
26156: CALL_OW 254
26160: ST_TO_ADDR
// if r = 5 then
26161: LD_VAR 0 15
26165: PUSH
26166: LD_INT 5
26168: EQUAL
26169: IFFALSE 26179
// r := 0 ;
26171: LD_ADDR_VAR 0 15
26175: PUSH
26176: LD_INT 0
26178: ST_TO_ADDR
// for j = r to 5 do
26179: LD_ADDR_VAR 0 10
26183: PUSH
26184: DOUBLE
26185: LD_VAR 0 15
26189: DEC
26190: ST_TO_ADDR
26191: LD_INT 5
26193: PUSH
26194: FOR_TO
26195: IFFALSE 26309
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26197: LD_ADDR_VAR 0 11
26201: PUSH
26202: LD_VAR 0 13
26206: PPUSH
26207: CALL_OW 250
26211: PPUSH
26212: LD_VAR 0 10
26216: PPUSH
26217: LD_INT 2
26219: PPUSH
26220: CALL_OW 272
26224: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26225: LD_ADDR_VAR 0 12
26229: PUSH
26230: LD_VAR 0 13
26234: PPUSH
26235: CALL_OW 251
26239: PPUSH
26240: LD_VAR 0 10
26244: PPUSH
26245: LD_INT 2
26247: PPUSH
26248: CALL_OW 273
26252: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26253: LD_VAR 0 11
26257: PPUSH
26258: LD_VAR 0 12
26262: PPUSH
26263: CALL_OW 488
26267: PUSH
26268: LD_VAR 0 11
26272: PPUSH
26273: LD_VAR 0 12
26277: PPUSH
26278: CALL_OW 428
26282: NOT
26283: AND
26284: IFFALSE 26307
// begin ComMoveXY ( tmp , _x , _y ) ;
26286: LD_VAR 0 13
26290: PPUSH
26291: LD_VAR 0 11
26295: PPUSH
26296: LD_VAR 0 12
26300: PPUSH
26301: CALL_OW 111
// break ;
26305: GO 26309
// end ; end ;
26307: GO 26194
26309: POP
26310: POP
// end ; end ;
26311: GO 25636
26313: POP
26314: POP
// end ;
26315: LD_VAR 0 8
26319: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26320: LD_INT 0
26322: PPUSH
// result := true ;
26323: LD_ADDR_VAR 0 3
26327: PUSH
26328: LD_INT 1
26330: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26331: LD_VAR 0 2
26335: PUSH
26336: LD_INT 24
26338: DOUBLE
26339: EQUAL
26340: IFTRUE 26350
26342: LD_INT 33
26344: DOUBLE
26345: EQUAL
26346: IFTRUE 26350
26348: GO 26375
26350: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26351: LD_ADDR_VAR 0 3
26355: PUSH
26356: LD_INT 32
26358: PPUSH
26359: LD_VAR 0 1
26363: PPUSH
26364: CALL_OW 321
26368: PUSH
26369: LD_INT 2
26371: EQUAL
26372: ST_TO_ADDR
26373: GO 26695
26375: LD_INT 20
26377: DOUBLE
26378: EQUAL
26379: IFTRUE 26383
26381: GO 26408
26383: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26384: LD_ADDR_VAR 0 3
26388: PUSH
26389: LD_INT 6
26391: PPUSH
26392: LD_VAR 0 1
26396: PPUSH
26397: CALL_OW 321
26401: PUSH
26402: LD_INT 2
26404: EQUAL
26405: ST_TO_ADDR
26406: GO 26695
26408: LD_INT 22
26410: DOUBLE
26411: EQUAL
26412: IFTRUE 26422
26414: LD_INT 36
26416: DOUBLE
26417: EQUAL
26418: IFTRUE 26422
26420: GO 26447
26422: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26423: LD_ADDR_VAR 0 3
26427: PUSH
26428: LD_INT 15
26430: PPUSH
26431: LD_VAR 0 1
26435: PPUSH
26436: CALL_OW 321
26440: PUSH
26441: LD_INT 2
26443: EQUAL
26444: ST_TO_ADDR
26445: GO 26695
26447: LD_INT 30
26449: DOUBLE
26450: EQUAL
26451: IFTRUE 26455
26453: GO 26480
26455: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26456: LD_ADDR_VAR 0 3
26460: PUSH
26461: LD_INT 20
26463: PPUSH
26464: LD_VAR 0 1
26468: PPUSH
26469: CALL_OW 321
26473: PUSH
26474: LD_INT 2
26476: EQUAL
26477: ST_TO_ADDR
26478: GO 26695
26480: LD_INT 28
26482: DOUBLE
26483: EQUAL
26484: IFTRUE 26494
26486: LD_INT 21
26488: DOUBLE
26489: EQUAL
26490: IFTRUE 26494
26492: GO 26519
26494: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26495: LD_ADDR_VAR 0 3
26499: PUSH
26500: LD_INT 21
26502: PPUSH
26503: LD_VAR 0 1
26507: PPUSH
26508: CALL_OW 321
26512: PUSH
26513: LD_INT 2
26515: EQUAL
26516: ST_TO_ADDR
26517: GO 26695
26519: LD_INT 16
26521: DOUBLE
26522: EQUAL
26523: IFTRUE 26527
26525: GO 26554
26527: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26528: LD_ADDR_VAR 0 3
26532: PUSH
26533: LD_EXP 61
26537: PPUSH
26538: LD_VAR 0 1
26542: PPUSH
26543: CALL_OW 321
26547: PUSH
26548: LD_INT 2
26550: EQUAL
26551: ST_TO_ADDR
26552: GO 26695
26554: LD_INT 19
26556: DOUBLE
26557: EQUAL
26558: IFTRUE 26568
26560: LD_INT 23
26562: DOUBLE
26563: EQUAL
26564: IFTRUE 26568
26566: GO 26595
26568: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26569: LD_ADDR_VAR 0 3
26573: PUSH
26574: LD_EXP 60
26578: PPUSH
26579: LD_VAR 0 1
26583: PPUSH
26584: CALL_OW 321
26588: PUSH
26589: LD_INT 2
26591: EQUAL
26592: ST_TO_ADDR
26593: GO 26695
26595: LD_INT 17
26597: DOUBLE
26598: EQUAL
26599: IFTRUE 26603
26601: GO 26628
26603: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26604: LD_ADDR_VAR 0 3
26608: PUSH
26609: LD_INT 39
26611: PPUSH
26612: LD_VAR 0 1
26616: PPUSH
26617: CALL_OW 321
26621: PUSH
26622: LD_INT 2
26624: EQUAL
26625: ST_TO_ADDR
26626: GO 26695
26628: LD_INT 18
26630: DOUBLE
26631: EQUAL
26632: IFTRUE 26636
26634: GO 26661
26636: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26637: LD_ADDR_VAR 0 3
26641: PUSH
26642: LD_INT 40
26644: PPUSH
26645: LD_VAR 0 1
26649: PPUSH
26650: CALL_OW 321
26654: PUSH
26655: LD_INT 2
26657: EQUAL
26658: ST_TO_ADDR
26659: GO 26695
26661: LD_INT 27
26663: DOUBLE
26664: EQUAL
26665: IFTRUE 26669
26667: GO 26694
26669: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26670: LD_ADDR_VAR 0 3
26674: PUSH
26675: LD_INT 35
26677: PPUSH
26678: LD_VAR 0 1
26682: PPUSH
26683: CALL_OW 321
26687: PUSH
26688: LD_INT 2
26690: EQUAL
26691: ST_TO_ADDR
26692: GO 26695
26694: POP
// end ;
26695: LD_VAR 0 3
26699: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26700: LD_INT 0
26702: PPUSH
26703: PPUSH
26704: PPUSH
26705: PPUSH
26706: PPUSH
26707: PPUSH
26708: PPUSH
26709: PPUSH
26710: PPUSH
26711: PPUSH
26712: PPUSH
// result := false ;
26713: LD_ADDR_VAR 0 6
26717: PUSH
26718: LD_INT 0
26720: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26721: LD_VAR 0 1
26725: NOT
26726: PUSH
26727: LD_VAR 0 1
26731: PPUSH
26732: CALL_OW 266
26736: PUSH
26737: LD_INT 0
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: IN
26747: NOT
26748: OR
26749: PUSH
26750: LD_VAR 0 2
26754: NOT
26755: OR
26756: PUSH
26757: LD_VAR 0 5
26761: PUSH
26762: LD_INT 0
26764: PUSH
26765: LD_INT 1
26767: PUSH
26768: LD_INT 2
26770: PUSH
26771: LD_INT 3
26773: PUSH
26774: LD_INT 4
26776: PUSH
26777: LD_INT 5
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: LIST
26787: IN
26788: NOT
26789: OR
26790: PUSH
26791: LD_VAR 0 3
26795: PPUSH
26796: LD_VAR 0 4
26800: PPUSH
26801: CALL_OW 488
26805: NOT
26806: OR
26807: IFFALSE 26811
// exit ;
26809: GO 27547
// side := GetSide ( depot ) ;
26811: LD_ADDR_VAR 0 9
26815: PUSH
26816: LD_VAR 0 1
26820: PPUSH
26821: CALL_OW 255
26825: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26826: LD_VAR 0 9
26830: PPUSH
26831: LD_VAR 0 2
26835: PPUSH
26836: CALL 26320 0 2
26840: NOT
26841: IFFALSE 26845
// exit ;
26843: GO 27547
// pom := GetBase ( depot ) ;
26845: LD_ADDR_VAR 0 10
26849: PUSH
26850: LD_VAR 0 1
26854: PPUSH
26855: CALL_OW 274
26859: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26860: LD_ADDR_VAR 0 11
26864: PUSH
26865: LD_VAR 0 2
26869: PPUSH
26870: LD_VAR 0 1
26874: PPUSH
26875: CALL_OW 248
26879: PPUSH
26880: CALL_OW 450
26884: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26885: LD_VAR 0 10
26889: PPUSH
26890: LD_INT 1
26892: PPUSH
26893: CALL_OW 275
26897: PUSH
26898: LD_VAR 0 11
26902: PUSH
26903: LD_INT 1
26905: ARRAY
26906: GREATEREQUAL
26907: PUSH
26908: LD_VAR 0 10
26912: PPUSH
26913: LD_INT 2
26915: PPUSH
26916: CALL_OW 275
26920: PUSH
26921: LD_VAR 0 11
26925: PUSH
26926: LD_INT 2
26928: ARRAY
26929: GREATEREQUAL
26930: AND
26931: PUSH
26932: LD_VAR 0 10
26936: PPUSH
26937: LD_INT 3
26939: PPUSH
26940: CALL_OW 275
26944: PUSH
26945: LD_VAR 0 11
26949: PUSH
26950: LD_INT 3
26952: ARRAY
26953: GREATEREQUAL
26954: AND
26955: NOT
26956: IFFALSE 26960
// exit ;
26958: GO 27547
// if GetBType ( depot ) = b_depot then
26960: LD_VAR 0 1
26964: PPUSH
26965: CALL_OW 266
26969: PUSH
26970: LD_INT 0
26972: EQUAL
26973: IFFALSE 26985
// dist := 28 else
26975: LD_ADDR_VAR 0 14
26979: PUSH
26980: LD_INT 28
26982: ST_TO_ADDR
26983: GO 26993
// dist := 36 ;
26985: LD_ADDR_VAR 0 14
26989: PUSH
26990: LD_INT 36
26992: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26993: LD_VAR 0 1
26997: PPUSH
26998: LD_VAR 0 3
27002: PPUSH
27003: LD_VAR 0 4
27007: PPUSH
27008: CALL_OW 297
27012: PUSH
27013: LD_VAR 0 14
27017: GREATER
27018: IFFALSE 27022
// exit ;
27020: GO 27547
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27022: LD_ADDR_VAR 0 12
27026: PUSH
27027: LD_VAR 0 2
27031: PPUSH
27032: LD_VAR 0 3
27036: PPUSH
27037: LD_VAR 0 4
27041: PPUSH
27042: LD_VAR 0 5
27046: PPUSH
27047: LD_VAR 0 1
27051: PPUSH
27052: CALL_OW 248
27056: PPUSH
27057: LD_INT 0
27059: PPUSH
27060: CALL 27552 0 6
27064: ST_TO_ADDR
// if not hexes then
27065: LD_VAR 0 12
27069: NOT
27070: IFFALSE 27074
// exit ;
27072: GO 27547
// hex := GetHexInfo ( x , y ) ;
27074: LD_ADDR_VAR 0 15
27078: PUSH
27079: LD_VAR 0 3
27083: PPUSH
27084: LD_VAR 0 4
27088: PPUSH
27089: CALL_OW 546
27093: ST_TO_ADDR
// if hex [ 1 ] then
27094: LD_VAR 0 15
27098: PUSH
27099: LD_INT 1
27101: ARRAY
27102: IFFALSE 27106
// exit ;
27104: GO 27547
// height := hex [ 2 ] ;
27106: LD_ADDR_VAR 0 13
27110: PUSH
27111: LD_VAR 0 15
27115: PUSH
27116: LD_INT 2
27118: ARRAY
27119: ST_TO_ADDR
// for i = 1 to hexes do
27120: LD_ADDR_VAR 0 7
27124: PUSH
27125: DOUBLE
27126: LD_INT 1
27128: DEC
27129: ST_TO_ADDR
27130: LD_VAR 0 12
27134: PUSH
27135: FOR_TO
27136: IFFALSE 27466
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27138: LD_VAR 0 12
27142: PUSH
27143: LD_VAR 0 7
27147: ARRAY
27148: PUSH
27149: LD_INT 1
27151: ARRAY
27152: PPUSH
27153: LD_VAR 0 12
27157: PUSH
27158: LD_VAR 0 7
27162: ARRAY
27163: PUSH
27164: LD_INT 2
27166: ARRAY
27167: PPUSH
27168: CALL_OW 488
27172: NOT
27173: PUSH
27174: LD_VAR 0 12
27178: PUSH
27179: LD_VAR 0 7
27183: ARRAY
27184: PUSH
27185: LD_INT 1
27187: ARRAY
27188: PPUSH
27189: LD_VAR 0 12
27193: PUSH
27194: LD_VAR 0 7
27198: ARRAY
27199: PUSH
27200: LD_INT 2
27202: ARRAY
27203: PPUSH
27204: CALL_OW 428
27208: PUSH
27209: LD_INT 0
27211: GREATER
27212: OR
27213: PUSH
27214: LD_VAR 0 12
27218: PUSH
27219: LD_VAR 0 7
27223: ARRAY
27224: PUSH
27225: LD_INT 1
27227: ARRAY
27228: PPUSH
27229: LD_VAR 0 12
27233: PUSH
27234: LD_VAR 0 7
27238: ARRAY
27239: PUSH
27240: LD_INT 2
27242: ARRAY
27243: PPUSH
27244: CALL_OW 351
27248: OR
27249: IFFALSE 27255
// exit ;
27251: POP
27252: POP
27253: GO 27547
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27255: LD_ADDR_VAR 0 8
27259: PUSH
27260: LD_VAR 0 12
27264: PUSH
27265: LD_VAR 0 7
27269: ARRAY
27270: PUSH
27271: LD_INT 1
27273: ARRAY
27274: PPUSH
27275: LD_VAR 0 12
27279: PUSH
27280: LD_VAR 0 7
27284: ARRAY
27285: PUSH
27286: LD_INT 2
27288: ARRAY
27289: PPUSH
27290: CALL_OW 546
27294: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27295: LD_VAR 0 8
27299: PUSH
27300: LD_INT 1
27302: ARRAY
27303: PUSH
27304: LD_VAR 0 8
27308: PUSH
27309: LD_INT 2
27311: ARRAY
27312: PUSH
27313: LD_VAR 0 13
27317: PUSH
27318: LD_INT 2
27320: PLUS
27321: GREATER
27322: OR
27323: PUSH
27324: LD_VAR 0 8
27328: PUSH
27329: LD_INT 2
27331: ARRAY
27332: PUSH
27333: LD_VAR 0 13
27337: PUSH
27338: LD_INT 2
27340: MINUS
27341: LESS
27342: OR
27343: PUSH
27344: LD_VAR 0 8
27348: PUSH
27349: LD_INT 3
27351: ARRAY
27352: PUSH
27353: LD_INT 0
27355: PUSH
27356: LD_INT 8
27358: PUSH
27359: LD_INT 9
27361: PUSH
27362: LD_INT 10
27364: PUSH
27365: LD_INT 11
27367: PUSH
27368: LD_INT 12
27370: PUSH
27371: LD_INT 13
27373: PUSH
27374: LD_INT 16
27376: PUSH
27377: LD_INT 17
27379: PUSH
27380: LD_INT 18
27382: PUSH
27383: LD_INT 19
27385: PUSH
27386: LD_INT 20
27388: PUSH
27389: LD_INT 21
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: LIST
27406: IN
27407: NOT
27408: OR
27409: PUSH
27410: LD_VAR 0 8
27414: PUSH
27415: LD_INT 5
27417: ARRAY
27418: NOT
27419: OR
27420: PUSH
27421: LD_VAR 0 8
27425: PUSH
27426: LD_INT 6
27428: ARRAY
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: LD_INT 2
27435: PUSH
27436: LD_INT 7
27438: PUSH
27439: LD_INT 9
27441: PUSH
27442: LD_INT 10
27444: PUSH
27445: LD_INT 11
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: IN
27456: NOT
27457: OR
27458: IFFALSE 27464
// exit ;
27460: POP
27461: POP
27462: GO 27547
// end ;
27464: GO 27135
27466: POP
27467: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27468: LD_VAR 0 9
27472: PPUSH
27473: LD_VAR 0 3
27477: PPUSH
27478: LD_VAR 0 4
27482: PPUSH
27483: LD_INT 20
27485: PPUSH
27486: CALL 19493 0 4
27490: PUSH
27491: LD_INT 4
27493: ARRAY
27494: IFFALSE 27498
// exit ;
27496: GO 27547
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27498: LD_VAR 0 2
27502: PUSH
27503: LD_INT 29
27505: PUSH
27506: LD_INT 30
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: IN
27513: PUSH
27514: LD_VAR 0 3
27518: PPUSH
27519: LD_VAR 0 4
27523: PPUSH
27524: LD_VAR 0 9
27528: PPUSH
27529: CALL_OW 440
27533: NOT
27534: AND
27535: IFFALSE 27539
// exit ;
27537: GO 27547
// result := true ;
27539: LD_ADDR_VAR 0 6
27543: PUSH
27544: LD_INT 1
27546: ST_TO_ADDR
// end ;
27547: LD_VAR 0 6
27551: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27552: LD_INT 0
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
27570: PPUSH
27571: PPUSH
27572: PPUSH
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
27587: PPUSH
27588: PPUSH
27589: PPUSH
27590: PPUSH
27591: PPUSH
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
27602: PPUSH
27603: PPUSH
27604: PPUSH
27605: PPUSH
27606: PPUSH
27607: PPUSH
27608: PPUSH
27609: PPUSH
27610: PPUSH
27611: PPUSH
// result = [ ] ;
27612: LD_ADDR_VAR 0 7
27616: PUSH
27617: EMPTY
27618: ST_TO_ADDR
// temp_list = [ ] ;
27619: LD_ADDR_VAR 0 9
27623: PUSH
27624: EMPTY
27625: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27626: LD_VAR 0 4
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 1
27636: PUSH
27637: LD_INT 2
27639: PUSH
27640: LD_INT 3
27642: PUSH
27643: LD_INT 4
27645: PUSH
27646: LD_INT 5
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: IN
27657: NOT
27658: PUSH
27659: LD_VAR 0 1
27663: PUSH
27664: LD_INT 0
27666: PUSH
27667: LD_INT 1
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: IN
27674: PUSH
27675: LD_VAR 0 5
27679: PUSH
27680: LD_INT 1
27682: PUSH
27683: LD_INT 2
27685: PUSH
27686: LD_INT 3
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: LIST
27693: IN
27694: NOT
27695: AND
27696: OR
27697: IFFALSE 27701
// exit ;
27699: GO 46092
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27701: LD_VAR 0 1
27705: PUSH
27706: LD_INT 6
27708: PUSH
27709: LD_INT 7
27711: PUSH
27712: LD_INT 8
27714: PUSH
27715: LD_INT 13
27717: PUSH
27718: LD_INT 12
27720: PUSH
27721: LD_INT 15
27723: PUSH
27724: LD_INT 11
27726: PUSH
27727: LD_INT 14
27729: PUSH
27730: LD_INT 10
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: LIST
27737: LIST
27738: LIST
27739: LIST
27740: LIST
27741: LIST
27742: LIST
27743: IN
27744: IFFALSE 27754
// btype = b_lab ;
27746: LD_ADDR_VAR 0 1
27750: PUSH
27751: LD_INT 6
27753: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27754: LD_VAR 0 6
27758: PUSH
27759: LD_INT 0
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: LD_INT 2
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: LIST
27772: IN
27773: NOT
27774: PUSH
27775: LD_VAR 0 1
27779: PUSH
27780: LD_INT 0
27782: PUSH
27783: LD_INT 1
27785: PUSH
27786: LD_INT 2
27788: PUSH
27789: LD_INT 3
27791: PUSH
27792: LD_INT 6
27794: PUSH
27795: LD_INT 36
27797: PUSH
27798: LD_INT 4
27800: PUSH
27801: LD_INT 5
27803: PUSH
27804: LD_INT 31
27806: PUSH
27807: LD_INT 32
27809: PUSH
27810: LD_INT 33
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: IN
27826: NOT
27827: PUSH
27828: LD_VAR 0 6
27832: PUSH
27833: LD_INT 1
27835: EQUAL
27836: AND
27837: OR
27838: PUSH
27839: LD_VAR 0 1
27843: PUSH
27844: LD_INT 2
27846: PUSH
27847: LD_INT 3
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: IN
27854: NOT
27855: PUSH
27856: LD_VAR 0 6
27860: PUSH
27861: LD_INT 2
27863: EQUAL
27864: AND
27865: OR
27866: IFFALSE 27876
// mode = 0 ;
27868: LD_ADDR_VAR 0 6
27872: PUSH
27873: LD_INT 0
27875: ST_TO_ADDR
// case mode of 0 :
27876: LD_VAR 0 6
27880: PUSH
27881: LD_INT 0
27883: DOUBLE
27884: EQUAL
27885: IFTRUE 27889
27887: GO 39342
27889: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27890: LD_ADDR_VAR 0 11
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: LD_INT 0
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: PUSH
27905: LD_INT 0
27907: PUSH
27908: LD_INT 1
27910: NEG
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 1
27918: PUSH
27919: LD_INT 0
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: LD_INT 1
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 0
27938: PUSH
27939: LD_INT 1
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 1
27948: NEG
27949: PUSH
27950: LD_INT 0
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PUSH
27957: LD_INT 1
27959: NEG
27960: PUSH
27961: LD_INT 1
27963: NEG
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 1
27971: NEG
27972: PUSH
27973: LD_INT 2
27975: NEG
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 0
27983: PUSH
27984: LD_INT 2
27986: NEG
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 1
28005: PUSH
28006: LD_INT 2
28008: PUSH
28009: EMPTY
28010: LIST
28011: LIST
28012: PUSH
28013: LD_INT 0
28015: PUSH
28016: LD_INT 2
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 1
28025: NEG
28026: PUSH
28027: LD_INT 1
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 1
28036: PUSH
28037: LD_INT 3
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 0
28046: PUSH
28047: LD_INT 3
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: LD_INT 2
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: LIST
28081: LIST
28082: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28083: LD_ADDR_VAR 0 12
28087: PUSH
28088: LD_INT 0
28090: PUSH
28091: LD_INT 0
28093: PUSH
28094: EMPTY
28095: LIST
28096: LIST
28097: PUSH
28098: LD_INT 0
28100: PUSH
28101: LD_INT 1
28103: NEG
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 1
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: LD_INT 1
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: LD_INT 0
28131: PUSH
28132: LD_INT 1
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: NEG
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: PUSH
28150: LD_INT 1
28152: NEG
28153: PUSH
28154: LD_INT 1
28156: NEG
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: LD_INT 1
28167: NEG
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: LD_INT 2
28175: PUSH
28176: LD_INT 0
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 2
28185: PUSH
28186: LD_INT 1
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: LD_INT 1
28195: NEG
28196: PUSH
28197: LD_INT 1
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 2
28206: NEG
28207: PUSH
28208: LD_INT 0
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 2
28217: NEG
28218: PUSH
28219: LD_INT 1
28221: NEG
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 2
28229: NEG
28230: PUSH
28231: LD_INT 1
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 3
28240: NEG
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: EMPTY
28246: LIST
28247: LIST
28248: PUSH
28249: LD_INT 3
28251: NEG
28252: PUSH
28253: LD_INT 1
28255: NEG
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: LIST
28272: LIST
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: LIST
28278: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28279: LD_ADDR_VAR 0 13
28283: PUSH
28284: LD_INT 0
28286: PUSH
28287: LD_INT 0
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 0
28296: PUSH
28297: LD_INT 1
28299: NEG
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: PUSH
28305: LD_INT 1
28307: PUSH
28308: LD_INT 0
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 0
28327: PUSH
28328: LD_INT 1
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 1
28337: NEG
28338: PUSH
28339: LD_INT 0
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 1
28348: NEG
28349: PUSH
28350: LD_INT 1
28352: NEG
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: PUSH
28358: LD_INT 1
28360: NEG
28361: PUSH
28362: LD_INT 2
28364: NEG
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 2
28372: PUSH
28373: LD_INT 1
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 2
28382: PUSH
28383: LD_INT 2
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: PUSH
28393: LD_INT 2
28395: PUSH
28396: EMPTY
28397: LIST
28398: LIST
28399: PUSH
28400: LD_INT 2
28402: NEG
28403: PUSH
28404: LD_INT 1
28406: NEG
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: LD_INT 2
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: LD_INT 3
28430: NEG
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 3
28438: NEG
28439: PUSH
28440: LD_INT 2
28442: NEG
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 3
28450: NEG
28451: PUSH
28452: LD_INT 3
28454: NEG
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28478: LD_ADDR_VAR 0 14
28482: PUSH
28483: LD_INT 0
28485: PUSH
28486: LD_INT 0
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PUSH
28493: LD_INT 0
28495: PUSH
28496: LD_INT 1
28498: NEG
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 1
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 1
28516: PUSH
28517: LD_INT 1
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 0
28526: PUSH
28527: LD_INT 1
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 1
28536: NEG
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 1
28547: NEG
28548: PUSH
28549: LD_INT 1
28551: NEG
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 2
28563: NEG
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 0
28571: PUSH
28572: LD_INT 2
28574: NEG
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: PUSH
28583: LD_INT 1
28585: NEG
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 1
28593: PUSH
28594: LD_INT 2
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 0
28603: PUSH
28604: LD_INT 2
28606: PUSH
28607: EMPTY
28608: LIST
28609: LIST
28610: PUSH
28611: LD_INT 1
28613: NEG
28614: PUSH
28615: LD_INT 1
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 1
28624: NEG
28625: PUSH
28626: LD_INT 3
28628: NEG
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 0
28636: PUSH
28637: LD_INT 3
28639: NEG
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: LD_INT 1
28647: PUSH
28648: LD_INT 2
28650: NEG
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: LIST
28672: LIST
28673: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28674: LD_ADDR_VAR 0 15
28678: PUSH
28679: LD_INT 0
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 0
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 1
28702: PUSH
28703: LD_INT 0
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: LD_INT 1
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 0
28722: PUSH
28723: LD_INT 1
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: NEG
28733: PUSH
28734: LD_INT 0
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: PUSH
28741: LD_INT 1
28743: NEG
28744: PUSH
28745: LD_INT 1
28747: NEG
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: LD_INT 1
28758: NEG
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 2
28766: PUSH
28767: LD_INT 0
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 2
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 1
28786: NEG
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 2
28797: NEG
28798: PUSH
28799: LD_INT 0
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 2
28808: NEG
28809: PUSH
28810: LD_INT 1
28812: NEG
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 2
28820: PUSH
28821: LD_INT 1
28823: NEG
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 3
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 3
28841: PUSH
28842: LD_INT 1
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28867: LD_ADDR_VAR 0 16
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: LD_INT 0
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: LD_INT 1
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: LD_INT 0
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 1
28936: NEG
28937: PUSH
28938: LD_INT 1
28940: NEG
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 1
28948: NEG
28949: PUSH
28950: LD_INT 2
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 2
28960: PUSH
28961: LD_INT 1
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: LD_INT 2
28970: PUSH
28971: LD_INT 2
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: LD_INT 2
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: LD_INT 2
28990: NEG
28991: PUSH
28992: LD_INT 1
28994: NEG
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: NEG
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: LD_INT 3
29014: PUSH
29015: LD_INT 2
29017: PUSH
29018: EMPTY
29019: LIST
29020: LIST
29021: PUSH
29022: LD_INT 3
29024: PUSH
29025: LD_INT 3
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: PUSH
29032: LD_INT 2
29034: PUSH
29035: LD_INT 3
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: LIST
29058: LIST
29059: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29060: LD_ADDR_VAR 0 17
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 0
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: LD_INT 0
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 1
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 0
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 1
29118: NEG
29119: PUSH
29120: LD_INT 0
29122: PUSH
29123: EMPTY
29124: LIST
29125: LIST
29126: PUSH
29127: LD_INT 1
29129: NEG
29130: PUSH
29131: LD_INT 1
29133: NEG
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 1
29141: NEG
29142: PUSH
29143: LD_INT 2
29145: NEG
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: LD_INT 2
29156: NEG
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 1
29164: PUSH
29165: LD_INT 1
29167: NEG
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 2
29175: PUSH
29176: LD_INT 0
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: LD_INT 1
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: LD_INT 2
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PUSH
29203: LD_INT 1
29205: PUSH
29206: LD_INT 2
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: LD_INT 2
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 1
29225: NEG
29226: PUSH
29227: LD_INT 1
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 2
29247: NEG
29248: PUSH
29249: LD_INT 1
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 2
29259: NEG
29260: PUSH
29261: LD_INT 2
29263: NEG
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29290: LD_ADDR_VAR 0 18
29294: PUSH
29295: LD_INT 0
29297: PUSH
29298: LD_INT 0
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 0
29307: PUSH
29308: LD_INT 1
29310: NEG
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: LD_INT 0
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: LD_INT 1
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 1
29348: NEG
29349: PUSH
29350: LD_INT 0
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 1
29359: NEG
29360: PUSH
29361: LD_INT 1
29363: NEG
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 1
29371: NEG
29372: PUSH
29373: LD_INT 2
29375: NEG
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 0
29383: PUSH
29384: LD_INT 2
29386: NEG
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: PUSH
29395: LD_INT 1
29397: NEG
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: LD_INT 0
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: PUSH
29416: LD_INT 1
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 2
29425: PUSH
29426: LD_INT 2
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: PUSH
29433: LD_INT 1
29435: PUSH
29436: LD_INT 2
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 0
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: NEG
29456: PUSH
29457: LD_INT 1
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 2
29466: NEG
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 2
29477: NEG
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 2
29489: NEG
29490: PUSH
29491: LD_INT 2
29493: NEG
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: LIST
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: LIST
29516: LIST
29517: LIST
29518: LIST
29519: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29520: LD_ADDR_VAR 0 19
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: LD_INT 0
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: LD_INT 1
29540: NEG
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: LD_INT 1
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: LD_INT 1
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 1
29578: NEG
29579: PUSH
29580: LD_INT 0
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: NEG
29590: PUSH
29591: LD_INT 1
29593: NEG
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PUSH
29599: LD_INT 1
29601: NEG
29602: PUSH
29603: LD_INT 2
29605: NEG
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: LD_INT 0
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: PUSH
29622: LD_INT 1
29624: PUSH
29625: LD_INT 1
29627: NEG
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 2
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 2
29645: PUSH
29646: LD_INT 1
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: LD_INT 2
29655: PUSH
29656: LD_INT 2
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 1
29665: PUSH
29666: LD_INT 2
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 0
29675: PUSH
29676: LD_INT 2
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 1
29685: NEG
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: PUSH
29705: LD_INT 2
29707: NEG
29708: PUSH
29709: LD_INT 1
29711: NEG
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 2
29719: NEG
29720: PUSH
29721: LD_INT 2
29723: NEG
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: LIST
29749: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29750: LD_ADDR_VAR 0 20
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: LD_INT 0
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 0
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: LD_INT 0
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 1
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 0
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: NEG
29809: PUSH
29810: LD_INT 0
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 1
29819: NEG
29820: PUSH
29821: LD_INT 1
29823: NEG
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 1
29831: NEG
29832: PUSH
29833: LD_INT 2
29835: NEG
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 0
29843: PUSH
29844: LD_INT 2
29846: NEG
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PUSH
29852: LD_INT 1
29854: PUSH
29855: LD_INT 1
29857: NEG
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: LD_INT 0
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 2
29875: PUSH
29876: LD_INT 1
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 2
29885: PUSH
29886: LD_INT 2
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: PUSH
29896: LD_INT 2
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 0
29905: PUSH
29906: LD_INT 2
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 1
29915: NEG
29916: PUSH
29917: LD_INT 1
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 2
29926: NEG
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: NEG
29950: PUSH
29951: LD_INT 2
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29980: LD_ADDR_VAR 0 21
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: LD_INT 0
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 0
29997: PUSH
29998: LD_INT 1
30000: NEG
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 1
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 1
30018: PUSH
30019: LD_INT 1
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 1
30038: NEG
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: LD_INT 1
30053: NEG
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 1
30061: NEG
30062: PUSH
30063: LD_INT 2
30065: NEG
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 0
30073: PUSH
30074: LD_INT 2
30076: NEG
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: LD_INT 1
30087: NEG
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 2
30095: PUSH
30096: LD_INT 0
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 2
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 2
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 1
30125: PUSH
30126: LD_INT 2
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 0
30135: PUSH
30136: LD_INT 2
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 1
30145: NEG
30146: PUSH
30147: LD_INT 1
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: LD_INT 2
30156: NEG
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: EMPTY
30162: LIST
30163: LIST
30164: PUSH
30165: LD_INT 2
30167: NEG
30168: PUSH
30169: LD_INT 1
30171: NEG
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 2
30179: NEG
30180: PUSH
30181: LD_INT 2
30183: NEG
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30210: LD_ADDR_VAR 0 22
30214: PUSH
30215: LD_INT 0
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: LD_INT 1
30230: NEG
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 1
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 1
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 0
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: LD_INT 0
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 1
30279: NEG
30280: PUSH
30281: LD_INT 1
30283: NEG
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 1
30291: NEG
30292: PUSH
30293: LD_INT 2
30295: NEG
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: LD_INT 2
30306: NEG
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 1
30314: PUSH
30315: LD_INT 1
30317: NEG
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 2
30335: PUSH
30336: LD_INT 1
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 2
30345: PUSH
30346: LD_INT 2
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 1
30355: PUSH
30356: LD_INT 2
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: LD_INT 2
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 1
30375: NEG
30376: PUSH
30377: LD_INT 1
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 2
30386: NEG
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 2
30397: NEG
30398: PUSH
30399: LD_INT 1
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 2
30409: NEG
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30440: LD_ADDR_VAR 0 23
30444: PUSH
30445: LD_INT 0
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 1
30460: NEG
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 1
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 1
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 0
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 1
30498: NEG
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 1
30509: NEG
30510: PUSH
30511: LD_INT 1
30513: NEG
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: LD_INT 2
30525: NEG
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 0
30533: PUSH
30534: LD_INT 2
30536: NEG
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 2
30555: PUSH
30556: LD_INT 0
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 2
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 2
30575: PUSH
30576: LD_INT 2
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: LD_INT 2
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 0
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 2
30616: NEG
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 2
30627: NEG
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 2
30639: NEG
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 2
30651: NEG
30652: PUSH
30653: LD_INT 3
30655: NEG
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 1
30663: NEG
30664: PUSH
30665: LD_INT 3
30667: NEG
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 1
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 2
30686: PUSH
30687: LD_INT 1
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30720: LD_ADDR_VAR 0 24
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: LD_INT 0
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 0
30737: PUSH
30738: LD_INT 1
30740: NEG
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: LD_INT 0
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: PUSH
30759: LD_INT 1
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 0
30768: PUSH
30769: LD_INT 1
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 1
30789: NEG
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: LD_INT 2
30805: NEG
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 0
30813: PUSH
30814: LD_INT 2
30816: NEG
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 1
30824: PUSH
30825: LD_INT 1
30827: NEG
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: LD_INT 2
30835: PUSH
30836: LD_INT 0
30838: PUSH
30839: EMPTY
30840: LIST
30841: LIST
30842: PUSH
30843: LD_INT 2
30845: PUSH
30846: LD_INT 1
30848: PUSH
30849: EMPTY
30850: LIST
30851: LIST
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: LD_INT 2
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: LD_INT 2
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 0
30875: PUSH
30876: LD_INT 2
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 1
30885: NEG
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 2
30896: NEG
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 2
30907: NEG
30908: PUSH
30909: LD_INT 1
30911: NEG
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: LD_INT 2
30919: NEG
30920: PUSH
30921: LD_INT 2
30923: NEG
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 2
30934: NEG
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 2
30942: PUSH
30943: LD_INT 1
30945: NEG
30946: PUSH
30947: EMPTY
30948: LIST
30949: LIST
30950: PUSH
30951: LD_INT 3
30953: PUSH
30954: LD_INT 1
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 3
30963: PUSH
30964: LD_INT 2
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30996: LD_ADDR_VAR 0 25
31000: PUSH
31001: LD_INT 0
31003: PUSH
31004: LD_INT 0
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 0
31013: PUSH
31014: LD_INT 1
31016: NEG
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: PUSH
31025: LD_INT 0
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 1
31034: PUSH
31035: LD_INT 1
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 0
31044: PUSH
31045: LD_INT 1
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 1
31054: NEG
31055: PUSH
31056: LD_INT 0
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 1
31065: NEG
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: NEG
31078: PUSH
31079: LD_INT 2
31081: NEG
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 0
31089: PUSH
31090: LD_INT 2
31092: NEG
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: LD_INT 1
31103: NEG
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 2
31111: PUSH
31112: LD_INT 0
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 2
31121: PUSH
31122: LD_INT 1
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 2
31131: PUSH
31132: LD_INT 2
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 1
31141: PUSH
31142: LD_INT 2
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: PUSH
31149: LD_INT 0
31151: PUSH
31152: LD_INT 2
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 2
31172: NEG
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: EMPTY
31178: LIST
31179: LIST
31180: PUSH
31181: LD_INT 2
31183: NEG
31184: PUSH
31185: LD_INT 1
31187: NEG
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 2
31195: NEG
31196: PUSH
31197: LD_INT 2
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 3
31207: PUSH
31208: LD_INT 1
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 3
31217: PUSH
31218: LD_INT 2
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 3
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31270: LD_ADDR_VAR 0 26
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: LD_INT 0
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 0
31287: PUSH
31288: LD_INT 1
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 1
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: LD_INT 1
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: LD_INT 1
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 1
31339: NEG
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 1
31351: NEG
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 0
31363: PUSH
31364: LD_INT 2
31366: NEG
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 1
31374: PUSH
31375: LD_INT 1
31377: NEG
31378: PUSH
31379: EMPTY
31380: LIST
31381: LIST
31382: PUSH
31383: LD_INT 2
31385: PUSH
31386: LD_INT 0
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: LD_INT 2
31395: PUSH
31396: LD_INT 1
31398: PUSH
31399: EMPTY
31400: LIST
31401: LIST
31402: PUSH
31403: LD_INT 2
31405: PUSH
31406: LD_INT 2
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 1
31415: PUSH
31416: LD_INT 2
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 0
31425: PUSH
31426: LD_INT 2
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: NEG
31436: PUSH
31437: LD_INT 1
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 2
31446: NEG
31447: PUSH
31448: LD_INT 0
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 2
31457: NEG
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 2
31469: NEG
31470: PUSH
31471: LD_INT 2
31473: NEG
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 2
31481: PUSH
31482: LD_INT 3
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: LD_INT 3
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 1
31501: NEG
31502: PUSH
31503: LD_INT 2
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: NEG
31513: PUSH
31514: LD_INT 1
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31546: LD_ADDR_VAR 0 27
31550: PUSH
31551: LD_INT 0
31553: PUSH
31554: LD_INT 0
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: LD_INT 1
31566: NEG
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 0
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 1
31584: PUSH
31585: LD_INT 1
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 0
31594: PUSH
31595: LD_INT 1
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: LD_INT 0
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: NEG
31616: PUSH
31617: LD_INT 1
31619: NEG
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PUSH
31625: LD_INT 1
31627: NEG
31628: PUSH
31629: LD_INT 2
31631: NEG
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 0
31639: PUSH
31640: LD_INT 2
31642: NEG
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 1
31650: PUSH
31651: LD_INT 1
31653: NEG
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 2
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 2
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 2
31681: PUSH
31682: LD_INT 2
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 1
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: LD_INT 2
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 1
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 2
31722: NEG
31723: PUSH
31724: LD_INT 0
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 2
31733: NEG
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 2
31745: NEG
31746: PUSH
31747: LD_INT 2
31749: NEG
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: LD_INT 2
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 3
31779: NEG
31780: PUSH
31781: LD_INT 1
31783: NEG
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 3
31791: NEG
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31826: LD_ADDR_VAR 0 28
31830: PUSH
31831: LD_INT 0
31833: PUSH
31834: LD_INT 0
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 1
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: LD_INT 1
31899: NEG
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: NEG
31908: PUSH
31909: LD_INT 2
31911: NEG
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 0
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 1
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: LD_INT 1
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 2
31961: PUSH
31962: LD_INT 2
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 2
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: NEG
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 2
32002: NEG
32003: PUSH
32004: LD_INT 0
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 2
32013: NEG
32014: PUSH
32015: LD_INT 1
32017: NEG
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 2
32025: NEG
32026: PUSH
32027: LD_INT 2
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 2
32037: NEG
32038: PUSH
32039: LD_INT 3
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 1
32049: NEG
32050: PUSH
32051: LD_INT 3
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: LD_INT 3
32061: NEG
32062: PUSH
32063: LD_INT 1
32065: NEG
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 3
32073: NEG
32074: PUSH
32075: LD_INT 2
32077: NEG
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32108: LD_ADDR_VAR 0 29
32112: PUSH
32113: LD_INT 0
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: LD_INT 1
32128: NEG
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 1
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 1
32146: PUSH
32147: LD_INT 1
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: LD_INT 1
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: NEG
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: LD_INT 1
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 1
32189: NEG
32190: PUSH
32191: LD_INT 2
32193: NEG
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 0
32201: PUSH
32202: LD_INT 2
32204: NEG
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 1
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 2
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 2
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 1
32243: PUSH
32244: LD_INT 2
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 0
32253: PUSH
32254: LD_INT 2
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 1
32263: NEG
32264: PUSH
32265: LD_INT 1
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 2
32274: NEG
32275: PUSH
32276: LD_INT 1
32278: NEG
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 2
32286: NEG
32287: PUSH
32288: LD_INT 2
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 2
32298: NEG
32299: PUSH
32300: LD_INT 3
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: LD_INT 1
32313: NEG
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 3
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 1
32331: PUSH
32332: LD_INT 3
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 1
32341: NEG
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 3
32352: NEG
32353: PUSH
32354: LD_INT 2
32356: NEG
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32387: LD_ADDR_VAR 0 30
32391: PUSH
32392: LD_INT 0
32394: PUSH
32395: LD_INT 0
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 0
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 1
32415: PUSH
32416: LD_INT 0
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 1
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 0
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: EMPTY
32451: LIST
32452: LIST
32453: PUSH
32454: LD_INT 1
32456: NEG
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: NEG
32469: PUSH
32470: LD_INT 2
32472: NEG
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 0
32480: PUSH
32481: LD_INT 2
32483: NEG
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 2
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 2
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 2
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 1
32542: NEG
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 2
32553: NEG
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 2
32564: NEG
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 1
32576: NEG
32577: PUSH
32578: LD_INT 3
32580: NEG
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: PUSH
32589: LD_INT 2
32591: NEG
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 3
32599: PUSH
32600: LD_INT 2
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: PUSH
32610: LD_INT 3
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 2
32619: NEG
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: LD_INT 3
32630: NEG
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32665: LD_ADDR_VAR 0 31
32669: PUSH
32670: LD_INT 0
32672: PUSH
32673: LD_INT 0
32675: PUSH
32676: EMPTY
32677: LIST
32678: LIST
32679: PUSH
32680: LD_INT 0
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: PUSH
32694: LD_INT 0
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 0
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: NEG
32724: PUSH
32725: LD_INT 0
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 1
32738: NEG
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 1
32746: NEG
32747: PUSH
32748: LD_INT 2
32750: NEG
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: LD_INT 1
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 2
32769: PUSH
32770: LD_INT 0
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 2
32779: PUSH
32780: LD_INT 1
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 2
32789: PUSH
32790: LD_INT 2
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 2
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 2
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 1
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 1
32834: NEG
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 2
32842: NEG
32843: PUSH
32844: LD_INT 2
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 2
32854: NEG
32855: PUSH
32856: LD_INT 3
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 2
32866: PUSH
32867: LD_INT 1
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 3
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: PUSH
32888: LD_INT 3
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 1
32897: NEG
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 3
32908: NEG
32909: PUSH
32910: LD_INT 2
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32943: LD_ADDR_VAR 0 32
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 0
32960: PUSH
32961: LD_INT 1
32963: NEG
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: PUSH
32972: LD_INT 0
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: LD_INT 1
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 0
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 1
33001: NEG
33002: PUSH
33003: LD_INT 0
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: LD_INT 1
33016: NEG
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 1
33024: NEG
33025: PUSH
33026: LD_INT 2
33028: NEG
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 0
33036: PUSH
33037: LD_INT 2
33039: NEG
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 2
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 2
33068: PUSH
33069: LD_INT 2
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 1
33078: PUSH
33079: LD_INT 2
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 0
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 2
33109: NEG
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 2
33120: NEG
33121: PUSH
33122: LD_INT 1
33124: NEG
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: LD_INT 3
33136: NEG
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 2
33147: NEG
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 3
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: PUSH
33166: LD_INT 3
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 2
33175: NEG
33176: PUSH
33177: LD_INT 1
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: LD_INT 3
33186: NEG
33187: PUSH
33188: LD_INT 1
33190: NEG
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33221: LD_ADDR_VAR 0 33
33225: PUSH
33226: LD_INT 0
33228: PUSH
33229: LD_INT 0
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 0
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: PUSH
33260: LD_INT 1
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: NEG
33280: PUSH
33281: LD_INT 0
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 1
33290: NEG
33291: PUSH
33292: LD_INT 1
33294: NEG
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 1
33302: NEG
33303: PUSH
33304: LD_INT 2
33306: NEG
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 2
33325: PUSH
33326: LD_INT 0
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 2
33335: PUSH
33336: LD_INT 1
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: LD_INT 2
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: NEG
33366: PUSH
33367: LD_INT 1
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 2
33376: NEG
33377: PUSH
33378: LD_INT 0
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 2
33387: NEG
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 2
33399: NEG
33400: PUSH
33401: LD_INT 2
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 2
33411: NEG
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 2
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 3
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: PUSH
33445: LD_INT 3
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 1
33454: NEG
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 3
33465: NEG
33466: PUSH
33467: LD_INT 2
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33500: LD_ADDR_VAR 0 34
33504: PUSH
33505: LD_INT 0
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: LD_INT 1
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: LD_INT 1
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 0
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 1
33558: NEG
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 1
33569: NEG
33570: PUSH
33571: LD_INT 1
33573: NEG
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: LD_INT 2
33596: NEG
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: LD_INT 1
33607: NEG
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: LD_INT 2
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: LD_INT 2
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 1
33645: NEG
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 2
33656: NEG
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 2
33679: NEG
33680: PUSH
33681: LD_INT 2
33683: NEG
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 1
33691: NEG
33692: PUSH
33693: LD_INT 3
33695: NEG
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 1
33703: PUSH
33704: LD_INT 2
33706: NEG
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 3
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 2
33724: PUSH
33725: LD_INT 3
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 2
33734: NEG
33735: PUSH
33736: LD_INT 1
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 3
33745: NEG
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33780: LD_ADDR_VAR 0 35
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 0
33797: PUSH
33798: LD_INT 1
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 0
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: PUSH
33836: LD_INT 1
33838: NEG
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 1
33849: NEG
33850: PUSH
33851: LD_INT 1
33853: NEG
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 1
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33892: LD_ADDR_VAR 0 36
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: LD_INT 2
33977: NEG
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: LD_INT 2
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34004: LD_ADDR_VAR 0 37
34008: PUSH
34009: LD_INT 0
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: LD_INT 1
34024: NEG
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 1
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: LD_INT 1
34077: NEG
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 1
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: LD_INT 1
34096: NEG
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: LIST
34115: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34116: LD_ADDR_VAR 0 38
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: LD_INT 0
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 0
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 1
34144: PUSH
34145: LD_INT 0
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: LD_INT 1
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 1
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 1
34174: NEG
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: NEG
34186: PUSH
34187: LD_INT 1
34189: NEG
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 2
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: NEG
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34228: LD_ADDR_VAR 0 39
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 0
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 0
34245: PUSH
34246: LD_INT 1
34248: NEG
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 1
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 1
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 1
34309: NEG
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: PUSH
34322: LD_INT 2
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34340: LD_ADDR_VAR 0 40
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: LD_INT 0
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: LD_INT 1
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: LD_INT 0
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 1
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 1
34398: NEG
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: NEG
34410: PUSH
34411: LD_INT 1
34413: NEG
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 1
34432: NEG
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34452: LD_ADDR_VAR 0 41
34456: PUSH
34457: LD_INT 0
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: LD_INT 0
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: LD_INT 1
34525: NEG
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 2
34537: NEG
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 2
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 2
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: PUSH
34577: LD_INT 2
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 2
34607: NEG
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 2
34618: NEG
34619: PUSH
34620: LD_INT 1
34622: NEG
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: LD_INT 2
34634: NEG
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: NEG
34643: PUSH
34644: LD_INT 3
34646: NEG
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 2
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 3
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 3
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: LD_INT 2
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 3
34695: PUSH
34696: LD_INT 3
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 2
34705: PUSH
34706: LD_INT 3
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 2
34715: NEG
34716: PUSH
34717: LD_INT 1
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 3
34726: NEG
34727: PUSH
34728: LD_INT 0
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 3
34737: NEG
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 3
34749: NEG
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 3
34761: NEG
34762: PUSH
34763: LD_INT 3
34765: NEG
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34802: LD_ADDR_VAR 0 42
34806: PUSH
34807: LD_INT 0
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: LD_INT 0
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 1
34871: NEG
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 2
34887: NEG
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 0
34895: PUSH
34896: LD_INT 2
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: LD_INT 1
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 2
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 0
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 1
34957: NEG
34958: PUSH
34959: LD_INT 1
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 2
34968: NEG
34969: PUSH
34970: LD_INT 1
34972: NEG
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 2
34980: NEG
34981: PUSH
34982: LD_INT 2
34984: NEG
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: LD_INT 3
34996: NEG
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 3
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: LD_INT 3
35019: NEG
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: LD_INT 2
35030: NEG
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 3
35038: PUSH
35039: LD_INT 2
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 3
35048: PUSH
35049: LD_INT 3
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 2
35058: PUSH
35059: LD_INT 3
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: LD_INT 3
35071: PUSH
35072: EMPTY
35073: LIST
35074: LIST
35075: PUSH
35076: LD_INT 0
35078: PUSH
35079: LD_INT 3
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 1
35088: NEG
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 3
35099: NEG
35100: PUSH
35101: LD_INT 2
35103: NEG
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 3
35111: NEG
35112: PUSH
35113: LD_INT 3
35115: NEG
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35152: LD_ADDR_VAR 0 43
35156: PUSH
35157: LD_INT 0
35159: PUSH
35160: LD_INT 0
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: NEG
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 2
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 2
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: LD_INT 1
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: LD_INT 0
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: PUSH
35278: LD_INT 1
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: LD_INT 2
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 2
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: LD_INT 1
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 2
35318: NEG
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: NEG
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: LD_INT 3
35345: NEG
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 3
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: LD_INT 2
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 2
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 3
35386: PUSH
35387: LD_INT 0
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 3
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 1
35406: PUSH
35407: LD_INT 3
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 3
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 2
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 2
35437: NEG
35438: PUSH
35439: LD_INT 1
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 3
35448: NEG
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 3
35459: NEG
35460: PUSH
35461: LD_INT 1
35463: NEG
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35500: LD_ADDR_VAR 0 44
35504: PUSH
35505: LD_INT 0
35507: PUSH
35508: LD_INT 0
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 1
35520: NEG
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: LD_INT 1
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 1
35558: NEG
35559: PUSH
35560: LD_INT 0
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: LD_INT 2
35585: NEG
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 1
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 2
35604: PUSH
35605: LD_INT 0
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 2
35614: PUSH
35615: LD_INT 1
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 2
35624: PUSH
35625: LD_INT 2
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: LD_INT 2
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: LD_INT 1
35644: NEG
35645: PUSH
35646: LD_INT 1
35648: PUSH
35649: EMPTY
35650: LIST
35651: LIST
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: LD_INT 0
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 2
35666: NEG
35667: PUSH
35668: LD_INT 1
35670: NEG
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: LD_INT 2
35682: NEG
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: PUSH
35688: LD_INT 2
35690: NEG
35691: PUSH
35692: LD_INT 3
35694: NEG
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: PUSH
35703: LD_INT 1
35705: NEG
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 3
35713: PUSH
35714: LD_INT 0
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 3
35723: PUSH
35724: LD_INT 1
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 3
35733: PUSH
35734: LD_INT 2
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 3
35743: PUSH
35744: LD_INT 3
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 2
35753: PUSH
35754: LD_INT 3
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 2
35763: NEG
35764: PUSH
35765: LD_INT 1
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 3
35774: NEG
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 3
35785: NEG
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 3
35797: NEG
35798: PUSH
35799: LD_INT 2
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 3
35809: NEG
35810: PUSH
35811: LD_INT 3
35813: NEG
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35850: LD_ADDR_VAR 0 45
35854: PUSH
35855: LD_INT 0
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 0
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: NEG
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: LD_INT 1
35923: NEG
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: LD_INT 2
35935: NEG
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 0
35943: PUSH
35944: LD_INT 2
35946: NEG
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 2
35965: PUSH
35966: LD_INT 1
35968: PUSH
35969: EMPTY
35970: LIST
35971: LIST
35972: PUSH
35973: LD_INT 2
35975: PUSH
35976: LD_INT 2
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: PUSH
35986: LD_INT 2
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 0
35995: PUSH
35996: LD_INT 2
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 2
36016: NEG
36017: PUSH
36018: LD_INT 1
36020: NEG
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: LD_INT 2
36028: NEG
36029: PUSH
36030: LD_INT 2
36032: NEG
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 2
36040: NEG
36041: PUSH
36042: LD_INT 3
36044: NEG
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 1
36052: NEG
36053: PUSH
36054: LD_INT 3
36056: NEG
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 0
36064: PUSH
36065: LD_INT 3
36067: NEG
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 3
36086: PUSH
36087: LD_INT 2
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 3
36096: PUSH
36097: LD_INT 3
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: LD_INT 3
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: LD_INT 3
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: LD_INT 3
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 1
36136: NEG
36137: PUSH
36138: LD_INT 2
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 3
36147: NEG
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 3
36159: NEG
36160: PUSH
36161: LD_INT 3
36163: NEG
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36200: LD_ADDR_VAR 0 46
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: LD_INT 0
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: LD_INT 1
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 0
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: LD_INT 0
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: NEG
36270: PUSH
36271: LD_INT 1
36273: NEG
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 2
36285: NEG
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 0
36293: PUSH
36294: LD_INT 2
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: PUSH
36305: LD_INT 1
36307: NEG
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 2
36315: PUSH
36316: LD_INT 0
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: PUSH
36323: LD_INT 2
36325: PUSH
36326: LD_INT 1
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 0
36345: PUSH
36346: LD_INT 2
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 1
36355: NEG
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: NEG
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 2
36377: NEG
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: LD_INT 3
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 0
36401: PUSH
36402: LD_INT 3
36404: NEG
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 1
36412: PUSH
36413: LD_INT 2
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 2
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 3
36434: PUSH
36435: LD_INT 0
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 3
36444: PUSH
36445: LD_INT 1
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 1
36454: PUSH
36455: LD_INT 3
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: LD_INT 3
36467: PUSH
36468: EMPTY
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 1
36474: NEG
36475: PUSH
36476: LD_INT 2
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 2
36485: NEG
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PUSH
36494: LD_INT 3
36496: NEG
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 3
36507: NEG
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36548: LD_ADDR_VAR 0 47
36552: PUSH
36553: LD_INT 0
36555: PUSH
36556: LD_INT 0
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 1
36586: PUSH
36587: LD_INT 1
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: LD_INT 0
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: LD_INT 2
36633: NEG
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: LD_INT 2
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: LD_INT 1
36655: NEG
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 2
36663: NEG
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 2
36675: NEG
36676: PUSH
36677: LD_INT 2
36679: NEG
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36699: LD_ADDR_VAR 0 48
36703: PUSH
36704: LD_INT 0
36706: PUSH
36707: LD_INT 0
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: LD_INT 1
36719: NEG
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: PUSH
36725: LD_INT 1
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: LD_INT 1
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 0
36747: PUSH
36748: LD_INT 1
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 1
36757: NEG
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 1
36780: NEG
36781: PUSH
36782: LD_INT 2
36784: NEG
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 0
36792: PUSH
36793: LD_INT 2
36795: NEG
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: LD_INT 1
36806: NEG
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 2
36814: PUSH
36815: LD_INT 0
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: LD_INT 2
36824: PUSH
36825: LD_INT 1
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36846: LD_ADDR_VAR 0 49
36850: PUSH
36851: LD_INT 0
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: PUSH
36875: LD_INT 0
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 1
36904: NEG
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: LD_INT 1
36919: NEG
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 1
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 2
36938: PUSH
36939: LD_INT 0
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: LD_INT 2
36948: PUSH
36949: LD_INT 1
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: LD_INT 2
36958: PUSH
36959: LD_INT 2
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 1
36968: PUSH
36969: LD_INT 2
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36990: LD_ADDR_VAR 0 50
36994: PUSH
36995: LD_INT 0
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 0
37007: PUSH
37008: LD_INT 1
37010: NEG
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: LD_INT 0
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 1
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 1
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 1
37059: NEG
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: PUSH
37072: LD_INT 1
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: PUSH
37082: LD_INT 2
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 1
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 0
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37134: LD_ADDR_VAR 0 51
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 0
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 0
37151: PUSH
37152: LD_INT 1
37154: NEG
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 0
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 1
37192: NEG
37193: PUSH
37194: LD_INT 0
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 1
37203: NEG
37204: PUSH
37205: LD_INT 1
37207: NEG
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 0
37225: PUSH
37226: LD_INT 2
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 1
37235: NEG
37236: PUSH
37237: LD_INT 1
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: LD_INT 0
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 2
37257: NEG
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: LIST
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: LIST
37280: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37281: LD_ADDR_VAR 0 52
37285: PUSH
37286: LD_INT 0
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: LD_INT 0
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: LD_INT 1
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 0
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: LD_INT 2
37366: NEG
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 1
37374: NEG
37375: PUSH
37376: LD_INT 1
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 2
37385: NEG
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 2
37396: NEG
37397: PUSH
37398: LD_INT 1
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: LD_INT 2
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37432: LD_ADDR_VAR 0 53
37436: PUSH
37437: LD_INT 0
37439: PUSH
37440: LD_INT 0
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: LD_INT 1
37452: NEG
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 1
37460: PUSH
37461: LD_INT 0
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 0
37480: PUSH
37481: LD_INT 1
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 1
37490: NEG
37491: PUSH
37492: LD_INT 0
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 1
37501: NEG
37502: PUSH
37503: LD_INT 1
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 1
37513: NEG
37514: PUSH
37515: LD_INT 2
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 0
37525: PUSH
37526: LD_INT 2
37528: NEG
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 1
37536: PUSH
37537: LD_INT 1
37539: NEG
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 2
37547: PUSH
37548: LD_INT 0
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 2
37557: PUSH
37558: LD_INT 1
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: LD_INT 2
37567: PUSH
37568: LD_INT 2
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: LD_INT 2
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 1
37597: NEG
37598: PUSH
37599: LD_INT 1
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 2
37608: NEG
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 2
37619: NEG
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 2
37631: NEG
37632: PUSH
37633: LD_INT 2
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37662: LD_ADDR_VAR 0 54
37666: PUSH
37667: LD_INT 0
37669: PUSH
37670: LD_INT 0
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: LD_INT 1
37682: NEG
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: PUSH
37691: LD_INT 0
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: LD_INT 1
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 0
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 1
37720: NEG
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: LD_INT 2
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: LD_INT 2
37758: NEG
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 1
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 2
37777: PUSH
37778: LD_INT 0
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 2
37787: PUSH
37788: LD_INT 1
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 2
37797: PUSH
37798: LD_INT 2
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 1
37807: PUSH
37808: LD_INT 2
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 2
37838: NEG
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 2
37849: NEG
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 2
37861: NEG
37862: PUSH
37863: LD_INT 2
37865: NEG
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37892: LD_ADDR_VAR 0 55
37896: PUSH
37897: LD_INT 0
37899: PUSH
37900: LD_INT 0
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 0
37909: PUSH
37910: LD_INT 1
37912: NEG
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 1
37920: PUSH
37921: LD_INT 0
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 1
37930: PUSH
37931: LD_INT 1
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 0
37940: PUSH
37941: LD_INT 1
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 1
37950: NEG
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 1
37961: NEG
37962: PUSH
37963: LD_INT 1
37965: NEG
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 1
37973: NEG
37974: PUSH
37975: LD_INT 2
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 1
37996: PUSH
37997: LD_INT 1
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 2
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 1
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 2
38027: PUSH
38028: LD_INT 2
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 1
38037: PUSH
38038: LD_INT 2
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: LD_INT 2
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 1
38057: NEG
38058: PUSH
38059: LD_INT 1
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 2
38068: NEG
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: LD_INT 1
38083: NEG
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 2
38091: NEG
38092: PUSH
38093: LD_INT 2
38095: NEG
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: LIST
38120: LIST
38121: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38122: LD_ADDR_VAR 0 56
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 0
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 0
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 1
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 0
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 1
38180: NEG
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 1
38191: NEG
38192: PUSH
38193: LD_INT 1
38195: NEG
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: LD_INT 2
38207: NEG
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: LD_INT 2
38218: NEG
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: LD_INT 1
38229: NEG
38230: PUSH
38231: EMPTY
38232: LIST
38233: LIST
38234: PUSH
38235: LD_INT 2
38237: PUSH
38238: LD_INT 0
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 2
38247: PUSH
38248: LD_INT 1
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 2
38257: PUSH
38258: LD_INT 2
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 1
38267: PUSH
38268: LD_INT 2
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 0
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 1
38287: NEG
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 2
38298: NEG
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 2
38309: NEG
38310: PUSH
38311: LD_INT 1
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 2
38321: NEG
38322: PUSH
38323: LD_INT 2
38325: NEG
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: LIST
38351: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38352: LD_ADDR_VAR 0 57
38356: PUSH
38357: LD_INT 0
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: LD_INT 1
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 1
38380: PUSH
38381: LD_INT 0
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: PUSH
38391: LD_INT 1
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: LD_INT 1
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 1
38410: NEG
38411: PUSH
38412: LD_INT 0
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: PUSH
38419: LD_INT 1
38421: NEG
38422: PUSH
38423: LD_INT 1
38425: NEG
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: NEG
38434: PUSH
38435: LD_INT 2
38437: NEG
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 0
38445: PUSH
38446: LD_INT 2
38448: NEG
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 1
38456: PUSH
38457: LD_INT 1
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: PUSH
38468: LD_INT 0
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: LD_INT 1
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 2
38487: PUSH
38488: LD_INT 2
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: LD_INT 2
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: LD_INT 2
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 2
38551: NEG
38552: PUSH
38553: LD_INT 2
38555: NEG
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: LIST
38573: LIST
38574: LIST
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38582: LD_ADDR_VAR 0 58
38586: PUSH
38587: LD_INT 0
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: LD_INT 1
38602: NEG
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: PUSH
38608: LD_INT 1
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 1
38620: PUSH
38621: LD_INT 1
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 1
38640: NEG
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 1
38651: NEG
38652: PUSH
38653: LD_INT 1
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: NEG
38664: PUSH
38665: LD_INT 2
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 0
38675: PUSH
38676: LD_INT 2
38678: NEG
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 1
38686: PUSH
38687: LD_INT 1
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 2
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 1
38727: PUSH
38728: LD_INT 2
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 0
38737: PUSH
38738: LD_INT 2
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 1
38747: NEG
38748: PUSH
38749: LD_INT 1
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 2
38758: NEG
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 2
38769: NEG
38770: PUSH
38771: LD_INT 1
38773: NEG
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 2
38781: NEG
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38812: LD_ADDR_VAR 0 59
38816: PUSH
38817: LD_INT 0
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 0
38829: PUSH
38830: LD_INT 1
38832: NEG
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 0
38860: PUSH
38861: LD_INT 1
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 1
38870: NEG
38871: PUSH
38872: LD_INT 0
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 1
38881: NEG
38882: PUSH
38883: LD_INT 1
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38900: LD_ADDR_VAR 0 60
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: LD_INT 0
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: LD_INT 1
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 1
38938: PUSH
38939: LD_INT 1
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: LD_INT 1
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: PUSH
38956: LD_INT 1
38958: NEG
38959: PUSH
38960: LD_INT 0
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 1
38969: NEG
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: LIST
38987: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38988: LD_ADDR_VAR 0 61
38992: PUSH
38993: LD_INT 0
38995: PUSH
38996: LD_INT 0
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: LD_INT 0
39005: PUSH
39006: LD_INT 1
39008: NEG
39009: PUSH
39010: EMPTY
39011: LIST
39012: LIST
39013: PUSH
39014: LD_INT 1
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 1
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 0
39036: PUSH
39037: LD_INT 1
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: LD_INT 1
39046: NEG
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: LD_INT 1
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39076: LD_ADDR_VAR 0 62
39080: PUSH
39081: LD_INT 0
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: LD_INT 1
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 1
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 0
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 1
39134: NEG
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 1
39145: NEG
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39164: LD_ADDR_VAR 0 63
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: LD_INT 0
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 0
39181: PUSH
39182: LD_INT 1
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 1
39202: PUSH
39203: LD_INT 1
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 1
39222: NEG
39223: PUSH
39224: LD_INT 0
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: NEG
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39252: LD_ADDR_VAR 0 64
39256: PUSH
39257: LD_INT 0
39259: PUSH
39260: LD_INT 0
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 0
39269: PUSH
39270: LD_INT 1
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 1
39290: PUSH
39291: LD_INT 1
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 0
39300: PUSH
39301: LD_INT 1
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 1
39321: NEG
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: ST_TO_ADDR
// end ; 1 :
39340: GO 45237
39342: LD_INT 1
39344: DOUBLE
39345: EQUAL
39346: IFTRUE 39350
39348: GO 41973
39350: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39351: LD_ADDR_VAR 0 11
39355: PUSH
39356: LD_INT 1
39358: NEG
39359: PUSH
39360: LD_INT 3
39362: NEG
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 0
39370: PUSH
39371: LD_INT 3
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 1
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: LIST
39394: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39395: LD_ADDR_VAR 0 12
39399: PUSH
39400: LD_INT 2
39402: PUSH
39403: LD_INT 1
39405: NEG
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 3
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 3
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: EMPTY
39432: LIST
39433: LIST
39434: LIST
39435: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39436: LD_ADDR_VAR 0 13
39440: PUSH
39441: LD_INT 3
39443: PUSH
39444: LD_INT 2
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 3
39453: PUSH
39454: LD_INT 3
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: PUSH
39464: LD_INT 3
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: LIST
39475: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39476: LD_ADDR_VAR 0 14
39480: PUSH
39481: LD_INT 1
39483: PUSH
39484: LD_INT 3
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: LD_INT 3
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 1
39503: NEG
39504: PUSH
39505: LD_INT 2
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: LIST
39516: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39517: LD_ADDR_VAR 0 15
39521: PUSH
39522: LD_INT 2
39524: NEG
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 3
39535: NEG
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 3
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: LIST
39560: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39561: LD_ADDR_VAR 0 16
39565: PUSH
39566: LD_INT 2
39568: NEG
39569: PUSH
39570: LD_INT 3
39572: NEG
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 3
39580: NEG
39581: PUSH
39582: LD_INT 2
39584: NEG
39585: PUSH
39586: EMPTY
39587: LIST
39588: LIST
39589: PUSH
39590: LD_INT 3
39592: NEG
39593: PUSH
39594: LD_INT 3
39596: NEG
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: LIST
39606: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39607: LD_ADDR_VAR 0 17
39611: PUSH
39612: LD_INT 1
39614: NEG
39615: PUSH
39616: LD_INT 3
39618: NEG
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: LD_INT 3
39629: NEG
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: PUSH
39638: LD_INT 2
39640: NEG
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: LIST
39650: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39651: LD_ADDR_VAR 0 18
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: LD_INT 1
39661: NEG
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 3
39669: PUSH
39670: LD_INT 0
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 3
39679: PUSH
39680: LD_INT 1
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: LIST
39691: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39692: LD_ADDR_VAR 0 19
39696: PUSH
39697: LD_INT 3
39699: PUSH
39700: LD_INT 2
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 3
39709: PUSH
39710: LD_INT 3
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 2
39719: PUSH
39720: LD_INT 3
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: LIST
39731: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39732: LD_ADDR_VAR 0 20
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 3
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 3
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 2
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: LIST
39772: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39773: LD_ADDR_VAR 0 21
39777: PUSH
39778: LD_INT 2
39780: NEG
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 3
39791: NEG
39792: PUSH
39793: LD_INT 0
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 3
39802: NEG
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: LIST
39816: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39817: LD_ADDR_VAR 0 22
39821: PUSH
39822: LD_INT 2
39824: NEG
39825: PUSH
39826: LD_INT 3
39828: NEG
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 3
39836: NEG
39837: PUSH
39838: LD_INT 2
39840: NEG
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 3
39848: NEG
39849: PUSH
39850: LD_INT 3
39852: NEG
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39863: LD_ADDR_VAR 0 23
39867: PUSH
39868: LD_INT 0
39870: PUSH
39871: LD_INT 3
39873: NEG
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 1
39881: NEG
39882: PUSH
39883: LD_INT 4
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 1
39893: PUSH
39894: LD_INT 3
39896: NEG
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: LIST
39906: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39907: LD_ADDR_VAR 0 24
39911: PUSH
39912: LD_INT 3
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 3
39924: PUSH
39925: LD_INT 1
39927: NEG
39928: PUSH
39929: EMPTY
39930: LIST
39931: LIST
39932: PUSH
39933: LD_INT 4
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: LIST
39947: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39948: LD_ADDR_VAR 0 25
39952: PUSH
39953: LD_INT 3
39955: PUSH
39956: LD_INT 3
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: LD_INT 4
39965: PUSH
39966: LD_INT 3
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 3
39975: PUSH
39976: LD_INT 4
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: LIST
39987: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39988: LD_ADDR_VAR 0 26
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: LD_INT 3
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: PUSH
40006: LD_INT 4
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 1
40015: NEG
40016: PUSH
40017: LD_INT 3
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: LIST
40028: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40029: LD_ADDR_VAR 0 27
40033: PUSH
40034: LD_INT 3
40036: NEG
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 3
40047: NEG
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 4
40058: NEG
40059: PUSH
40060: LD_INT 1
40062: NEG
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: LIST
40072: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40073: LD_ADDR_VAR 0 28
40077: PUSH
40078: LD_INT 3
40080: NEG
40081: PUSH
40082: LD_INT 3
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 3
40092: NEG
40093: PUSH
40094: LD_INT 4
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 4
40104: NEG
40105: PUSH
40106: LD_INT 3
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: LIST
40118: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40119: LD_ADDR_VAR 0 29
40123: PUSH
40124: LD_INT 1
40126: NEG
40127: PUSH
40128: LD_INT 3
40130: NEG
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 0
40138: PUSH
40139: LD_INT 3
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 1
40160: NEG
40161: PUSH
40162: LD_INT 4
40164: NEG
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: LD_INT 4
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 1
40183: PUSH
40184: LD_INT 3
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 1
40194: NEG
40195: PUSH
40196: LD_INT 5
40198: NEG
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 5
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 1
40217: PUSH
40218: LD_INT 4
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: NEG
40229: PUSH
40230: LD_INT 6
40232: NEG
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: LD_INT 6
40243: NEG
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: LD_INT 5
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40274: LD_ADDR_VAR 0 30
40278: PUSH
40279: LD_INT 2
40281: PUSH
40282: LD_INT 1
40284: NEG
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 3
40292: PUSH
40293: LD_INT 0
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 3
40302: PUSH
40303: LD_INT 1
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: LD_INT 3
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 4
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 4
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 4
40343: PUSH
40344: LD_INT 1
40346: NEG
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 5
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 5
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 5
40374: PUSH
40375: LD_INT 1
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 6
40385: PUSH
40386: LD_INT 0
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 6
40395: PUSH
40396: LD_INT 1
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40417: LD_ADDR_VAR 0 31
40421: PUSH
40422: LD_INT 3
40424: PUSH
40425: LD_INT 2
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 3
40434: PUSH
40435: LD_INT 3
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 2
40444: PUSH
40445: LD_INT 3
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 4
40454: PUSH
40455: LD_INT 3
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 4
40464: PUSH
40465: LD_INT 4
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 3
40474: PUSH
40475: LD_INT 4
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 5
40484: PUSH
40485: LD_INT 4
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 5
40494: PUSH
40495: LD_INT 5
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 4
40504: PUSH
40505: LD_INT 5
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 6
40514: PUSH
40515: LD_INT 5
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 6
40524: PUSH
40525: LD_INT 6
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 5
40534: PUSH
40535: LD_INT 6
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40556: LD_ADDR_VAR 0 32
40560: PUSH
40561: LD_INT 1
40563: PUSH
40564: LD_INT 3
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 0
40573: PUSH
40574: LD_INT 3
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 1
40583: NEG
40584: PUSH
40585: LD_INT 2
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 1
40594: PUSH
40595: LD_INT 4
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 0
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: NEG
40615: PUSH
40616: LD_INT 3
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: LD_INT 1
40625: PUSH
40626: LD_INT 5
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 0
40635: PUSH
40636: LD_INT 5
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: LD_INT 4
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 1
40656: PUSH
40657: LD_INT 6
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 0
40666: PUSH
40667: LD_INT 6
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: LD_INT 1
40676: NEG
40677: PUSH
40678: LD_INT 5
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40699: LD_ADDR_VAR 0 33
40703: PUSH
40704: LD_INT 2
40706: NEG
40707: PUSH
40708: LD_INT 1
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 3
40717: NEG
40718: PUSH
40719: LD_INT 0
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: LD_INT 1
40732: NEG
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: LD_INT 3
40740: NEG
40741: PUSH
40742: LD_INT 1
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 4
40751: NEG
40752: PUSH
40753: LD_INT 0
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 4
40762: NEG
40763: PUSH
40764: LD_INT 1
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 4
40774: NEG
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 5
40785: NEG
40786: PUSH
40787: LD_INT 0
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 5
40796: NEG
40797: PUSH
40798: LD_INT 1
40800: NEG
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 5
40808: NEG
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 6
40819: NEG
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 6
40830: NEG
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: LIST
40853: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40854: LD_ADDR_VAR 0 34
40858: PUSH
40859: LD_INT 2
40861: NEG
40862: PUSH
40863: LD_INT 3
40865: NEG
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: LD_INT 2
40877: NEG
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 3
40885: NEG
40886: PUSH
40887: LD_INT 3
40889: NEG
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 3
40897: NEG
40898: PUSH
40899: LD_INT 4
40901: NEG
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 4
40909: NEG
40910: PUSH
40911: LD_INT 3
40913: NEG
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 4
40921: NEG
40922: PUSH
40923: LD_INT 4
40925: NEG
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 4
40933: NEG
40934: PUSH
40935: LD_INT 5
40937: NEG
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: PUSH
40943: LD_INT 5
40945: NEG
40946: PUSH
40947: LD_INT 4
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 5
40957: NEG
40958: PUSH
40959: LD_INT 5
40961: NEG
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 5
40969: NEG
40970: PUSH
40971: LD_INT 6
40973: NEG
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 6
40981: NEG
40982: PUSH
40983: LD_INT 5
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 6
40993: NEG
40994: PUSH
40995: LD_INT 6
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: EMPTY
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41017: LD_ADDR_VAR 0 41
41021: PUSH
41022: LD_INT 0
41024: PUSH
41025: LD_INT 2
41027: NEG
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 1
41035: NEG
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 1
41047: PUSH
41048: LD_INT 2
41050: NEG
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: LIST
41060: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41061: LD_ADDR_VAR 0 42
41065: PUSH
41066: LD_INT 2
41068: PUSH
41069: LD_INT 0
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 2
41078: PUSH
41079: LD_INT 1
41081: NEG
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 3
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: LIST
41101: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41102: LD_ADDR_VAR 0 43
41106: PUSH
41107: LD_INT 2
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 3
41119: PUSH
41120: LD_INT 2
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 2
41129: PUSH
41130: LD_INT 3
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: LIST
41141: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41142: LD_ADDR_VAR 0 44
41146: PUSH
41147: LD_INT 0
41149: PUSH
41150: LD_INT 2
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 1
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: LD_INT 2
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: LIST
41182: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41183: LD_ADDR_VAR 0 45
41187: PUSH
41188: LD_INT 2
41190: NEG
41191: PUSH
41192: LD_INT 0
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: PUSH
41199: LD_INT 2
41201: NEG
41202: PUSH
41203: LD_INT 1
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 3
41212: NEG
41213: PUSH
41214: LD_INT 1
41216: NEG
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: LIST
41226: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41227: LD_ADDR_VAR 0 46
41231: PUSH
41232: LD_INT 2
41234: NEG
41235: PUSH
41236: LD_INT 2
41238: NEG
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 2
41246: NEG
41247: PUSH
41248: LD_INT 3
41250: NEG
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: LD_INT 2
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: LIST
41272: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41273: LD_ADDR_VAR 0 47
41277: PUSH
41278: LD_INT 2
41280: NEG
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 1
41292: NEG
41293: PUSH
41294: LD_INT 3
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41306: LD_ADDR_VAR 0 48
41310: PUSH
41311: LD_INT 1
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 2
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41337: LD_ADDR_VAR 0 49
41341: PUSH
41342: LD_INT 3
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 3
41354: PUSH
41355: LD_INT 2
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41366: LD_ADDR_VAR 0 50
41370: PUSH
41371: LD_INT 2
41373: PUSH
41374: LD_INT 3
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 1
41383: PUSH
41384: LD_INT 3
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41395: LD_ADDR_VAR 0 51
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: LD_INT 2
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41426: LD_ADDR_VAR 0 52
41430: PUSH
41431: LD_INT 3
41433: NEG
41434: PUSH
41435: LD_INT 1
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 3
41445: NEG
41446: PUSH
41447: LD_INT 2
41449: NEG
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41459: LD_ADDR_VAR 0 53
41463: PUSH
41464: LD_INT 1
41466: NEG
41467: PUSH
41468: LD_INT 3
41470: NEG
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 0
41478: PUSH
41479: LD_INT 3
41481: NEG
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 1
41489: PUSH
41490: LD_INT 2
41492: NEG
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41503: LD_ADDR_VAR 0 54
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: LD_INT 1
41513: NEG
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 3
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: PUSH
41529: LD_INT 3
41531: PUSH
41532: LD_INT 1
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: EMPTY
41540: LIST
41541: LIST
41542: LIST
41543: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41544: LD_ADDR_VAR 0 55
41548: PUSH
41549: LD_INT 3
41551: PUSH
41552: LD_INT 2
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 3
41561: PUSH
41562: LD_INT 3
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 2
41571: PUSH
41572: LD_INT 3
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: LIST
41583: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41584: LD_ADDR_VAR 0 56
41588: PUSH
41589: LD_INT 1
41591: PUSH
41592: LD_INT 3
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 0
41601: PUSH
41602: LD_INT 3
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 1
41611: NEG
41612: PUSH
41613: LD_INT 2
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: LIST
41624: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41625: LD_ADDR_VAR 0 57
41629: PUSH
41630: LD_INT 2
41632: NEG
41633: PUSH
41634: LD_INT 1
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: PUSH
41641: LD_INT 3
41643: NEG
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 3
41654: NEG
41655: PUSH
41656: LD_INT 1
41658: NEG
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: LIST
41668: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41669: LD_ADDR_VAR 0 58
41673: PUSH
41674: LD_INT 2
41676: NEG
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 3
41688: NEG
41689: PUSH
41690: LD_INT 2
41692: NEG
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 3
41700: NEG
41701: PUSH
41702: LD_INT 3
41704: NEG
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: LIST
41714: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41715: LD_ADDR_VAR 0 59
41719: PUSH
41720: LD_INT 1
41722: NEG
41723: PUSH
41724: LD_INT 2
41726: NEG
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 0
41734: PUSH
41735: LD_INT 2
41737: NEG
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 1
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: LIST
41758: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41759: LD_ADDR_VAR 0 60
41763: PUSH
41764: LD_INT 1
41766: PUSH
41767: LD_INT 1
41769: NEG
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 2
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 2
41787: PUSH
41788: LD_INT 1
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: LIST
41799: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41800: LD_ADDR_VAR 0 61
41804: PUSH
41805: LD_INT 2
41807: PUSH
41808: LD_INT 1
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: LD_INT 2
41817: PUSH
41818: LD_INT 2
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: PUSH
41825: LD_INT 1
41827: PUSH
41828: LD_INT 2
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: LIST
41839: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41840: LD_ADDR_VAR 0 62
41844: PUSH
41845: LD_INT 1
41847: PUSH
41848: LD_INT 2
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 0
41857: PUSH
41858: LD_INT 2
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 1
41867: NEG
41868: PUSH
41869: LD_INT 1
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: LIST
41880: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41881: LD_ADDR_VAR 0 63
41885: PUSH
41886: LD_INT 1
41888: NEG
41889: PUSH
41890: LD_INT 1
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 2
41899: NEG
41900: PUSH
41901: LD_INT 0
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: LD_INT 1
41914: NEG
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: LIST
41924: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41925: LD_ADDR_VAR 0 64
41929: PUSH
41930: LD_INT 1
41932: NEG
41933: PUSH
41934: LD_INT 2
41936: NEG
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 2
41944: NEG
41945: PUSH
41946: LD_INT 1
41948: NEG
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 2
41956: NEG
41957: PUSH
41958: LD_INT 2
41960: NEG
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: LIST
41970: ST_TO_ADDR
// end ; 2 :
41971: GO 45237
41973: LD_INT 2
41975: DOUBLE
41976: EQUAL
41977: IFTRUE 41981
41979: GO 45236
41981: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41982: LD_ADDR_VAR 0 29
41986: PUSH
41987: LD_INT 4
41989: PUSH
41990: LD_INT 0
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 4
41999: PUSH
42000: LD_INT 1
42002: NEG
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 5
42010: PUSH
42011: LD_INT 0
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 5
42020: PUSH
42021: LD_INT 1
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 4
42030: PUSH
42031: LD_INT 1
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 3
42040: PUSH
42041: LD_INT 0
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: LD_INT 1
42053: NEG
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 3
42061: PUSH
42062: LD_INT 2
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 5
42072: PUSH
42073: LD_INT 2
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 3
42082: PUSH
42083: LD_INT 3
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: PUSH
42090: LD_INT 3
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 4
42102: PUSH
42103: LD_INT 3
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 4
42112: PUSH
42113: LD_INT 4
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 3
42122: PUSH
42123: LD_INT 4
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 2
42132: PUSH
42133: LD_INT 3
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 2
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 4
42152: PUSH
42153: LD_INT 2
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 2
42162: PUSH
42163: LD_INT 4
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 0
42172: PUSH
42173: LD_INT 4
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 0
42182: PUSH
42183: LD_INT 3
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 1
42192: PUSH
42193: LD_INT 4
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: LD_INT 5
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 0
42212: PUSH
42213: LD_INT 5
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 1
42222: NEG
42223: PUSH
42224: LD_INT 4
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: LD_INT 3
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 2
42244: PUSH
42245: LD_INT 5
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 2
42254: NEG
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 3
42265: NEG
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 3
42276: NEG
42277: PUSH
42278: LD_INT 1
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 2
42288: NEG
42289: PUSH
42290: LD_INT 0
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 2
42299: NEG
42300: PUSH
42301: LD_INT 1
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: PUSH
42308: LD_INT 3
42310: NEG
42311: PUSH
42312: LD_INT 1
42314: PUSH
42315: EMPTY
42316: LIST
42317: LIST
42318: PUSH
42319: LD_INT 4
42321: NEG
42322: PUSH
42323: LD_INT 0
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: LD_INT 4
42332: NEG
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 4
42344: NEG
42345: PUSH
42346: LD_INT 2
42348: NEG
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 2
42356: NEG
42357: PUSH
42358: LD_INT 2
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 4
42367: NEG
42368: PUSH
42369: LD_INT 4
42371: NEG
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: LD_INT 4
42379: NEG
42380: PUSH
42381: LD_INT 5
42383: NEG
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 3
42391: NEG
42392: PUSH
42393: LD_INT 4
42395: NEG
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 3
42403: NEG
42404: PUSH
42405: LD_INT 3
42407: NEG
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 4
42415: NEG
42416: PUSH
42417: LD_INT 3
42419: NEG
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 5
42427: NEG
42428: PUSH
42429: LD_INT 4
42431: NEG
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 5
42439: NEG
42440: PUSH
42441: LD_INT 5
42443: NEG
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: LD_INT 3
42451: NEG
42452: PUSH
42453: LD_INT 5
42455: NEG
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 5
42463: NEG
42464: PUSH
42465: LD_INT 3
42467: NEG
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: LIST
42518: LIST
42519: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42520: LD_ADDR_VAR 0 30
42524: PUSH
42525: LD_INT 4
42527: PUSH
42528: LD_INT 4
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 4
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 5
42547: PUSH
42548: LD_INT 4
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 5
42557: PUSH
42558: LD_INT 5
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 4
42567: PUSH
42568: LD_INT 5
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: PUSH
42575: LD_INT 3
42577: PUSH
42578: LD_INT 4
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 3
42587: PUSH
42588: LD_INT 3
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 5
42597: PUSH
42598: LD_INT 3
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 3
42607: PUSH
42608: LD_INT 5
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: LD_INT 3
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: LD_INT 2
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: LD_INT 3
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 1
42647: PUSH
42648: LD_INT 4
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 4
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 1
42667: NEG
42668: PUSH
42669: LD_INT 3
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 1
42678: NEG
42679: PUSH
42680: LD_INT 2
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 2
42689: PUSH
42690: LD_INT 4
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 2
42699: NEG
42700: PUSH
42701: LD_INT 2
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 4
42710: NEG
42711: PUSH
42712: LD_INT 0
42714: PUSH
42715: EMPTY
42716: LIST
42717: LIST
42718: PUSH
42719: LD_INT 4
42721: NEG
42722: PUSH
42723: LD_INT 1
42725: NEG
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 3
42733: NEG
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 3
42744: NEG
42745: PUSH
42746: LD_INT 1
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 4
42755: NEG
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 5
42766: NEG
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: PUSH
42775: LD_INT 5
42777: NEG
42778: PUSH
42779: LD_INT 1
42781: NEG
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 5
42789: NEG
42790: PUSH
42791: LD_INT 2
42793: NEG
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 3
42801: NEG
42802: PUSH
42803: LD_INT 2
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 3
42812: NEG
42813: PUSH
42814: LD_INT 3
42816: NEG
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: PUSH
42822: LD_INT 3
42824: NEG
42825: PUSH
42826: LD_INT 4
42828: NEG
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 2
42836: NEG
42837: PUSH
42838: LD_INT 3
42840: NEG
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: LD_INT 2
42848: NEG
42849: PUSH
42850: LD_INT 2
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 3
42860: NEG
42861: PUSH
42862: LD_INT 2
42864: NEG
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 4
42872: NEG
42873: PUSH
42874: LD_INT 3
42876: NEG
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PUSH
42882: LD_INT 4
42884: NEG
42885: PUSH
42886: LD_INT 4
42888: NEG
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: LD_INT 4
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 4
42908: NEG
42909: PUSH
42910: LD_INT 2
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 0
42920: PUSH
42921: LD_INT 4
42923: NEG
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: LD_INT 5
42934: NEG
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 1
42942: PUSH
42943: LD_INT 4
42945: NEG
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 1
42953: PUSH
42954: LD_INT 3
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 0
42964: PUSH
42965: LD_INT 3
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: NEG
42976: PUSH
42977: LD_INT 4
42979: NEG
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 5
42991: NEG
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 2
42999: PUSH
43000: LD_INT 3
43002: NEG
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 2
43010: NEG
43011: PUSH
43012: LD_INT 5
43014: NEG
43015: PUSH
43016: EMPTY
43017: LIST
43018: LIST
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43067: LD_ADDR_VAR 0 31
43071: PUSH
43072: LD_INT 0
43074: PUSH
43075: LD_INT 4
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 0
43084: PUSH
43085: LD_INT 3
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: LD_INT 4
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 1
43104: PUSH
43105: LD_INT 5
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: LD_INT 5
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: LD_INT 1
43124: NEG
43125: PUSH
43126: LD_INT 4
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 1
43135: NEG
43136: PUSH
43137: LD_INT 3
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: LD_INT 2
43146: PUSH
43147: LD_INT 5
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 2
43156: NEG
43157: PUSH
43158: LD_INT 3
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 3
43167: NEG
43168: PUSH
43169: LD_INT 0
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: PUSH
43176: LD_INT 3
43178: NEG
43179: PUSH
43180: LD_INT 1
43182: NEG
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: PUSH
43188: LD_INT 2
43190: NEG
43191: PUSH
43192: LD_INT 0
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 2
43201: NEG
43202: PUSH
43203: LD_INT 1
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 3
43212: NEG
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 4
43223: NEG
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 4
43234: NEG
43235: PUSH
43236: LD_INT 1
43238: NEG
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 4
43246: NEG
43247: PUSH
43248: LD_INT 2
43250: NEG
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 2
43258: NEG
43259: PUSH
43260: LD_INT 2
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: LD_INT 4
43269: NEG
43270: PUSH
43271: LD_INT 4
43273: NEG
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 4
43281: NEG
43282: PUSH
43283: LD_INT 5
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 3
43293: NEG
43294: PUSH
43295: LD_INT 4
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 3
43305: NEG
43306: PUSH
43307: LD_INT 3
43309: NEG
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: LD_INT 4
43317: NEG
43318: PUSH
43319: LD_INT 3
43321: NEG
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PUSH
43327: LD_INT 5
43329: NEG
43330: PUSH
43331: LD_INT 4
43333: NEG
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 5
43341: NEG
43342: PUSH
43343: LD_INT 5
43345: NEG
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 3
43353: NEG
43354: PUSH
43355: LD_INT 5
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 5
43365: NEG
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 0
43377: PUSH
43378: LD_INT 3
43380: NEG
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: PUSH
43386: LD_INT 0
43388: PUSH
43389: LD_INT 4
43391: NEG
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 1
43399: PUSH
43400: LD_INT 3
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 1
43410: PUSH
43411: LD_INT 2
43413: NEG
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: LD_INT 2
43424: NEG
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 1
43432: NEG
43433: PUSH
43434: LD_INT 3
43436: NEG
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 1
43444: NEG
43445: PUSH
43446: LD_INT 4
43448: NEG
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 2
43456: PUSH
43457: LD_INT 2
43459: NEG
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 2
43467: NEG
43468: PUSH
43469: LD_INT 4
43471: NEG
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 4
43479: PUSH
43480: LD_INT 0
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 4
43489: PUSH
43490: LD_INT 1
43492: NEG
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 5
43500: PUSH
43501: LD_INT 0
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 5
43510: PUSH
43511: LD_INT 1
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 4
43520: PUSH
43521: LD_INT 1
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 3
43530: PUSH
43531: LD_INT 0
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 3
43540: PUSH
43541: LD_INT 1
43543: NEG
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 3
43551: PUSH
43552: LD_INT 2
43554: NEG
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PUSH
43560: LD_INT 5
43562: PUSH
43563: LD_INT 2
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: LIST
43616: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43617: LD_ADDR_VAR 0 32
43621: PUSH
43622: LD_INT 4
43624: NEG
43625: PUSH
43626: LD_INT 0
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 4
43635: NEG
43636: PUSH
43637: LD_INT 1
43639: NEG
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: LD_INT 3
43647: NEG
43648: PUSH
43649: LD_INT 0
43651: PUSH
43652: EMPTY
43653: LIST
43654: LIST
43655: PUSH
43656: LD_INT 3
43658: NEG
43659: PUSH
43660: LD_INT 1
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 4
43669: NEG
43670: PUSH
43671: LD_INT 1
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 5
43680: NEG
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 5
43691: NEG
43692: PUSH
43693: LD_INT 1
43695: NEG
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 5
43703: NEG
43704: PUSH
43705: LD_INT 2
43707: NEG
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 3
43715: NEG
43716: PUSH
43717: LD_INT 2
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 3
43726: NEG
43727: PUSH
43728: LD_INT 3
43730: NEG
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 3
43738: NEG
43739: PUSH
43740: LD_INT 4
43742: NEG
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 2
43750: NEG
43751: PUSH
43752: LD_INT 3
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 2
43762: NEG
43763: PUSH
43764: LD_INT 2
43766: NEG
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 3
43774: NEG
43775: PUSH
43776: LD_INT 2
43778: NEG
43779: PUSH
43780: EMPTY
43781: LIST
43782: LIST
43783: PUSH
43784: LD_INT 4
43786: NEG
43787: PUSH
43788: LD_INT 3
43790: NEG
43791: PUSH
43792: EMPTY
43793: LIST
43794: LIST
43795: PUSH
43796: LD_INT 4
43798: NEG
43799: PUSH
43800: LD_INT 4
43802: NEG
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 2
43810: NEG
43811: PUSH
43812: LD_INT 4
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 4
43822: NEG
43823: PUSH
43824: LD_INT 2
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 0
43834: PUSH
43835: LD_INT 4
43837: NEG
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 0
43845: PUSH
43846: LD_INT 5
43848: NEG
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 1
43856: PUSH
43857: LD_INT 4
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 1
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: LD_INT 3
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: NEG
43890: PUSH
43891: LD_INT 4
43893: NEG
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 1
43901: NEG
43902: PUSH
43903: LD_INT 5
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 2
43913: PUSH
43914: LD_INT 3
43916: NEG
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: LD_INT 2
43924: NEG
43925: PUSH
43926: LD_INT 5
43928: NEG
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 3
43936: PUSH
43937: LD_INT 0
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 3
43946: PUSH
43947: LD_INT 1
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 4
43957: PUSH
43958: LD_INT 0
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 4
43967: PUSH
43968: LD_INT 1
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 3
43977: PUSH
43978: LD_INT 1
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 2
43987: PUSH
43988: LD_INT 0
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 2
43997: PUSH
43998: LD_INT 1
44000: NEG
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 2
44008: PUSH
44009: LD_INT 2
44011: NEG
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 4
44019: PUSH
44020: LD_INT 2
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 4
44029: PUSH
44030: LD_INT 4
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: PUSH
44037: LD_INT 4
44039: PUSH
44040: LD_INT 3
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 5
44049: PUSH
44050: LD_INT 4
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 5
44059: PUSH
44060: LD_INT 5
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 4
44069: PUSH
44070: LD_INT 5
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: PUSH
44077: LD_INT 3
44079: PUSH
44080: LD_INT 4
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 3
44089: PUSH
44090: LD_INT 3
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 5
44099: PUSH
44100: LD_INT 3
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 3
44109: PUSH
44110: LD_INT 5
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: LIST
44163: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44164: LD_ADDR_VAR 0 33
44168: PUSH
44169: LD_INT 4
44171: NEG
44172: PUSH
44173: LD_INT 4
44175: NEG
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 4
44183: NEG
44184: PUSH
44185: LD_INT 5
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 3
44195: NEG
44196: PUSH
44197: LD_INT 4
44199: NEG
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: NEG
44208: PUSH
44209: LD_INT 3
44211: NEG
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 4
44219: NEG
44220: PUSH
44221: LD_INT 3
44223: NEG
44224: PUSH
44225: EMPTY
44226: LIST
44227: LIST
44228: PUSH
44229: LD_INT 5
44231: NEG
44232: PUSH
44233: LD_INT 4
44235: NEG
44236: PUSH
44237: EMPTY
44238: LIST
44239: LIST
44240: PUSH
44241: LD_INT 5
44243: NEG
44244: PUSH
44245: LD_INT 5
44247: NEG
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 3
44255: NEG
44256: PUSH
44257: LD_INT 5
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 5
44267: NEG
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 0
44279: PUSH
44280: LD_INT 3
44282: NEG
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 0
44290: PUSH
44291: LD_INT 4
44293: NEG
44294: PUSH
44295: EMPTY
44296: LIST
44297: LIST
44298: PUSH
44299: LD_INT 1
44301: PUSH
44302: LD_INT 3
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 1
44312: PUSH
44313: LD_INT 2
44315: NEG
44316: PUSH
44317: EMPTY
44318: LIST
44319: LIST
44320: PUSH
44321: LD_INT 0
44323: PUSH
44324: LD_INT 2
44326: NEG
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 1
44334: NEG
44335: PUSH
44336: LD_INT 3
44338: NEG
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 1
44346: NEG
44347: PUSH
44348: LD_INT 4
44350: NEG
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 2
44358: PUSH
44359: LD_INT 2
44361: NEG
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 2
44369: NEG
44370: PUSH
44371: LD_INT 4
44373: NEG
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 4
44381: PUSH
44382: LD_INT 0
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 4
44391: PUSH
44392: LD_INT 1
44394: NEG
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: LD_INT 5
44402: PUSH
44403: LD_INT 0
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 5
44412: PUSH
44413: LD_INT 1
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 4
44422: PUSH
44423: LD_INT 1
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 3
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 3
44442: PUSH
44443: LD_INT 1
44445: NEG
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 3
44453: PUSH
44454: LD_INT 2
44456: NEG
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 5
44464: PUSH
44465: LD_INT 2
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: LD_INT 3
44474: PUSH
44475: LD_INT 3
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: LD_INT 3
44484: PUSH
44485: LD_INT 2
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 4
44494: PUSH
44495: LD_INT 3
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 4
44504: PUSH
44505: LD_INT 4
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 3
44514: PUSH
44515: LD_INT 4
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 2
44524: PUSH
44525: LD_INT 3
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 2
44534: PUSH
44535: LD_INT 2
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 4
44544: PUSH
44545: LD_INT 2
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 2
44554: PUSH
44555: LD_INT 4
44557: PUSH
44558: EMPTY
44559: LIST
44560: LIST
44561: PUSH
44562: LD_INT 0
44564: PUSH
44565: LD_INT 4
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 0
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 1
44584: PUSH
44585: LD_INT 4
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 1
44594: PUSH
44595: LD_INT 5
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 0
44604: PUSH
44605: LD_INT 5
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 1
44614: NEG
44615: PUSH
44616: LD_INT 4
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 1
44625: NEG
44626: PUSH
44627: LD_INT 3
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 2
44636: PUSH
44637: LD_INT 5
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 2
44646: NEG
44647: PUSH
44648: LD_INT 3
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: LIST
44701: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44702: LD_ADDR_VAR 0 34
44706: PUSH
44707: LD_INT 0
44709: PUSH
44710: LD_INT 4
44712: NEG
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: LD_INT 5
44723: NEG
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 1
44731: PUSH
44732: LD_INT 4
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 1
44742: PUSH
44743: LD_INT 3
44745: NEG
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 0
44753: PUSH
44754: LD_INT 3
44756: NEG
44757: PUSH
44758: EMPTY
44759: LIST
44760: LIST
44761: PUSH
44762: LD_INT 1
44764: NEG
44765: PUSH
44766: LD_INT 4
44768: NEG
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 1
44776: NEG
44777: PUSH
44778: LD_INT 5
44780: NEG
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 2
44788: PUSH
44789: LD_INT 3
44791: NEG
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 2
44799: NEG
44800: PUSH
44801: LD_INT 5
44803: NEG
44804: PUSH
44805: EMPTY
44806: LIST
44807: LIST
44808: PUSH
44809: LD_INT 3
44811: PUSH
44812: LD_INT 0
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 3
44821: PUSH
44822: LD_INT 1
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 4
44832: PUSH
44833: LD_INT 0
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 4
44842: PUSH
44843: LD_INT 1
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 3
44852: PUSH
44853: LD_INT 1
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 2
44862: PUSH
44863: LD_INT 0
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 2
44872: PUSH
44873: LD_INT 1
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 2
44883: PUSH
44884: LD_INT 2
44886: NEG
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 4
44894: PUSH
44895: LD_INT 2
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 4
44904: PUSH
44905: LD_INT 4
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 4
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 5
44924: PUSH
44925: LD_INT 4
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 5
44934: PUSH
44935: LD_INT 5
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 4
44944: PUSH
44945: LD_INT 5
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: LD_INT 3
44954: PUSH
44955: LD_INT 4
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: LD_INT 3
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 5
44974: PUSH
44975: LD_INT 3
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 3
44984: PUSH
44985: LD_INT 5
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 0
44994: PUSH
44995: LD_INT 3
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 0
45004: PUSH
45005: LD_INT 2
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: LD_INT 1
45014: PUSH
45015: LD_INT 3
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 1
45024: PUSH
45025: LD_INT 4
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 0
45034: PUSH
45035: LD_INT 4
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: PUSH
45042: LD_INT 1
45044: NEG
45045: PUSH
45046: LD_INT 3
45048: PUSH
45049: EMPTY
45050: LIST
45051: LIST
45052: PUSH
45053: LD_INT 1
45055: NEG
45056: PUSH
45057: LD_INT 2
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 2
45066: PUSH
45067: LD_INT 4
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 2
45076: NEG
45077: PUSH
45078: LD_INT 2
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 4
45087: NEG
45088: PUSH
45089: LD_INT 0
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: PUSH
45096: LD_INT 4
45098: NEG
45099: PUSH
45100: LD_INT 1
45102: NEG
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 3
45110: NEG
45111: PUSH
45112: LD_INT 0
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 3
45121: NEG
45122: PUSH
45123: LD_INT 1
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 4
45132: NEG
45133: PUSH
45134: LD_INT 1
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 5
45143: NEG
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 5
45154: NEG
45155: PUSH
45156: LD_INT 1
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 5
45166: NEG
45167: PUSH
45168: LD_INT 2
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 3
45178: NEG
45179: PUSH
45180: LD_INT 2
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: ST_TO_ADDR
// end ; end ;
45234: GO 45237
45236: POP
// case btype of b_depot , b_warehouse :
45237: LD_VAR 0 1
45241: PUSH
45242: LD_INT 0
45244: DOUBLE
45245: EQUAL
45246: IFTRUE 45256
45248: LD_INT 1
45250: DOUBLE
45251: EQUAL
45252: IFTRUE 45256
45254: GO 45457
45256: POP
// case nation of nation_american :
45257: LD_VAR 0 5
45261: PUSH
45262: LD_INT 1
45264: DOUBLE
45265: EQUAL
45266: IFTRUE 45270
45268: GO 45326
45270: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45271: LD_ADDR_VAR 0 9
45275: PUSH
45276: LD_VAR 0 11
45280: PUSH
45281: LD_VAR 0 12
45285: PUSH
45286: LD_VAR 0 13
45290: PUSH
45291: LD_VAR 0 14
45295: PUSH
45296: LD_VAR 0 15
45300: PUSH
45301: LD_VAR 0 16
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: PUSH
45314: LD_VAR 0 4
45318: PUSH
45319: LD_INT 1
45321: PLUS
45322: ARRAY
45323: ST_TO_ADDR
45324: GO 45455
45326: LD_INT 2
45328: DOUBLE
45329: EQUAL
45330: IFTRUE 45334
45332: GO 45390
45334: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45335: LD_ADDR_VAR 0 9
45339: PUSH
45340: LD_VAR 0 17
45344: PUSH
45345: LD_VAR 0 18
45349: PUSH
45350: LD_VAR 0 19
45354: PUSH
45355: LD_VAR 0 20
45359: PUSH
45360: LD_VAR 0 21
45364: PUSH
45365: LD_VAR 0 22
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: PUSH
45378: LD_VAR 0 4
45382: PUSH
45383: LD_INT 1
45385: PLUS
45386: ARRAY
45387: ST_TO_ADDR
45388: GO 45455
45390: LD_INT 3
45392: DOUBLE
45393: EQUAL
45394: IFTRUE 45398
45396: GO 45454
45398: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45399: LD_ADDR_VAR 0 9
45403: PUSH
45404: LD_VAR 0 23
45408: PUSH
45409: LD_VAR 0 24
45413: PUSH
45414: LD_VAR 0 25
45418: PUSH
45419: LD_VAR 0 26
45423: PUSH
45424: LD_VAR 0 27
45428: PUSH
45429: LD_VAR 0 28
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: PUSH
45442: LD_VAR 0 4
45446: PUSH
45447: LD_INT 1
45449: PLUS
45450: ARRAY
45451: ST_TO_ADDR
45452: GO 45455
45454: POP
45455: GO 46010
45457: LD_INT 2
45459: DOUBLE
45460: EQUAL
45461: IFTRUE 45471
45463: LD_INT 3
45465: DOUBLE
45466: EQUAL
45467: IFTRUE 45471
45469: GO 45527
45471: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45472: LD_ADDR_VAR 0 9
45476: PUSH
45477: LD_VAR 0 29
45481: PUSH
45482: LD_VAR 0 30
45486: PUSH
45487: LD_VAR 0 31
45491: PUSH
45492: LD_VAR 0 32
45496: PUSH
45497: LD_VAR 0 33
45501: PUSH
45502: LD_VAR 0 34
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: PUSH
45515: LD_VAR 0 4
45519: PUSH
45520: LD_INT 1
45522: PLUS
45523: ARRAY
45524: ST_TO_ADDR
45525: GO 46010
45527: LD_INT 16
45529: DOUBLE
45530: EQUAL
45531: IFTRUE 45589
45533: LD_INT 17
45535: DOUBLE
45536: EQUAL
45537: IFTRUE 45589
45539: LD_INT 18
45541: DOUBLE
45542: EQUAL
45543: IFTRUE 45589
45545: LD_INT 19
45547: DOUBLE
45548: EQUAL
45549: IFTRUE 45589
45551: LD_INT 22
45553: DOUBLE
45554: EQUAL
45555: IFTRUE 45589
45557: LD_INT 20
45559: DOUBLE
45560: EQUAL
45561: IFTRUE 45589
45563: LD_INT 21
45565: DOUBLE
45566: EQUAL
45567: IFTRUE 45589
45569: LD_INT 23
45571: DOUBLE
45572: EQUAL
45573: IFTRUE 45589
45575: LD_INT 24
45577: DOUBLE
45578: EQUAL
45579: IFTRUE 45589
45581: LD_INT 25
45583: DOUBLE
45584: EQUAL
45585: IFTRUE 45589
45587: GO 45645
45589: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45590: LD_ADDR_VAR 0 9
45594: PUSH
45595: LD_VAR 0 35
45599: PUSH
45600: LD_VAR 0 36
45604: PUSH
45605: LD_VAR 0 37
45609: PUSH
45610: LD_VAR 0 38
45614: PUSH
45615: LD_VAR 0 39
45619: PUSH
45620: LD_VAR 0 40
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: PUSH
45633: LD_VAR 0 4
45637: PUSH
45638: LD_INT 1
45640: PLUS
45641: ARRAY
45642: ST_TO_ADDR
45643: GO 46010
45645: LD_INT 6
45647: DOUBLE
45648: EQUAL
45649: IFTRUE 45701
45651: LD_INT 7
45653: DOUBLE
45654: EQUAL
45655: IFTRUE 45701
45657: LD_INT 8
45659: DOUBLE
45660: EQUAL
45661: IFTRUE 45701
45663: LD_INT 13
45665: DOUBLE
45666: EQUAL
45667: IFTRUE 45701
45669: LD_INT 12
45671: DOUBLE
45672: EQUAL
45673: IFTRUE 45701
45675: LD_INT 15
45677: DOUBLE
45678: EQUAL
45679: IFTRUE 45701
45681: LD_INT 11
45683: DOUBLE
45684: EQUAL
45685: IFTRUE 45701
45687: LD_INT 14
45689: DOUBLE
45690: EQUAL
45691: IFTRUE 45701
45693: LD_INT 10
45695: DOUBLE
45696: EQUAL
45697: IFTRUE 45701
45699: GO 45757
45701: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45702: LD_ADDR_VAR 0 9
45706: PUSH
45707: LD_VAR 0 41
45711: PUSH
45712: LD_VAR 0 42
45716: PUSH
45717: LD_VAR 0 43
45721: PUSH
45722: LD_VAR 0 44
45726: PUSH
45727: LD_VAR 0 45
45731: PUSH
45732: LD_VAR 0 46
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: PUSH
45745: LD_VAR 0 4
45749: PUSH
45750: LD_INT 1
45752: PLUS
45753: ARRAY
45754: ST_TO_ADDR
45755: GO 46010
45757: LD_INT 36
45759: DOUBLE
45760: EQUAL
45761: IFTRUE 45765
45763: GO 45821
45765: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45766: LD_ADDR_VAR 0 9
45770: PUSH
45771: LD_VAR 0 47
45775: PUSH
45776: LD_VAR 0 48
45780: PUSH
45781: LD_VAR 0 49
45785: PUSH
45786: LD_VAR 0 50
45790: PUSH
45791: LD_VAR 0 51
45795: PUSH
45796: LD_VAR 0 52
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: PUSH
45809: LD_VAR 0 4
45813: PUSH
45814: LD_INT 1
45816: PLUS
45817: ARRAY
45818: ST_TO_ADDR
45819: GO 46010
45821: LD_INT 4
45823: DOUBLE
45824: EQUAL
45825: IFTRUE 45847
45827: LD_INT 5
45829: DOUBLE
45830: EQUAL
45831: IFTRUE 45847
45833: LD_INT 34
45835: DOUBLE
45836: EQUAL
45837: IFTRUE 45847
45839: LD_INT 37
45841: DOUBLE
45842: EQUAL
45843: IFTRUE 45847
45845: GO 45903
45847: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45848: LD_ADDR_VAR 0 9
45852: PUSH
45853: LD_VAR 0 53
45857: PUSH
45858: LD_VAR 0 54
45862: PUSH
45863: LD_VAR 0 55
45867: PUSH
45868: LD_VAR 0 56
45872: PUSH
45873: LD_VAR 0 57
45877: PUSH
45878: LD_VAR 0 58
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: PUSH
45891: LD_VAR 0 4
45895: PUSH
45896: LD_INT 1
45898: PLUS
45899: ARRAY
45900: ST_TO_ADDR
45901: GO 46010
45903: LD_INT 31
45905: DOUBLE
45906: EQUAL
45907: IFTRUE 45953
45909: LD_INT 32
45911: DOUBLE
45912: EQUAL
45913: IFTRUE 45953
45915: LD_INT 33
45917: DOUBLE
45918: EQUAL
45919: IFTRUE 45953
45921: LD_INT 27
45923: DOUBLE
45924: EQUAL
45925: IFTRUE 45953
45927: LD_INT 26
45929: DOUBLE
45930: EQUAL
45931: IFTRUE 45953
45933: LD_INT 28
45935: DOUBLE
45936: EQUAL
45937: IFTRUE 45953
45939: LD_INT 29
45941: DOUBLE
45942: EQUAL
45943: IFTRUE 45953
45945: LD_INT 30
45947: DOUBLE
45948: EQUAL
45949: IFTRUE 45953
45951: GO 46009
45953: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45954: LD_ADDR_VAR 0 9
45958: PUSH
45959: LD_VAR 0 59
45963: PUSH
45964: LD_VAR 0 60
45968: PUSH
45969: LD_VAR 0 61
45973: PUSH
45974: LD_VAR 0 62
45978: PUSH
45979: LD_VAR 0 63
45983: PUSH
45984: LD_VAR 0 64
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: PUSH
45997: LD_VAR 0 4
46001: PUSH
46002: LD_INT 1
46004: PLUS
46005: ARRAY
46006: ST_TO_ADDR
46007: GO 46010
46009: POP
// temp_list2 = [ ] ;
46010: LD_ADDR_VAR 0 10
46014: PUSH
46015: EMPTY
46016: ST_TO_ADDR
// for i in temp_list do
46017: LD_ADDR_VAR 0 8
46021: PUSH
46022: LD_VAR 0 9
46026: PUSH
46027: FOR_IN
46028: IFFALSE 46080
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46030: LD_ADDR_VAR 0 10
46034: PUSH
46035: LD_VAR 0 10
46039: PUSH
46040: LD_VAR 0 8
46044: PUSH
46045: LD_INT 1
46047: ARRAY
46048: PUSH
46049: LD_VAR 0 2
46053: PLUS
46054: PUSH
46055: LD_VAR 0 8
46059: PUSH
46060: LD_INT 2
46062: ARRAY
46063: PUSH
46064: LD_VAR 0 3
46068: PLUS
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: EMPTY
46075: LIST
46076: ADD
46077: ST_TO_ADDR
46078: GO 46027
46080: POP
46081: POP
// result = temp_list2 ;
46082: LD_ADDR_VAR 0 7
46086: PUSH
46087: LD_VAR 0 10
46091: ST_TO_ADDR
// end ;
46092: LD_VAR 0 7
46096: RET
// export function EnemyInRange ( unit , dist ) ; begin
46097: LD_INT 0
46099: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46100: LD_ADDR_VAR 0 3
46104: PUSH
46105: LD_VAR 0 1
46109: PPUSH
46110: CALL_OW 255
46114: PPUSH
46115: LD_VAR 0 1
46119: PPUSH
46120: CALL_OW 250
46124: PPUSH
46125: LD_VAR 0 1
46129: PPUSH
46130: CALL_OW 251
46134: PPUSH
46135: LD_VAR 0 2
46139: PPUSH
46140: CALL 19493 0 4
46144: PUSH
46145: LD_INT 4
46147: ARRAY
46148: ST_TO_ADDR
// end ;
46149: LD_VAR 0 3
46153: RET
// export function PlayerSeeMe ( unit ) ; begin
46154: LD_INT 0
46156: PPUSH
// result := See ( your_side , unit ) ;
46157: LD_ADDR_VAR 0 2
46161: PUSH
46162: LD_OWVAR 2
46166: PPUSH
46167: LD_VAR 0 1
46171: PPUSH
46172: CALL_OW 292
46176: ST_TO_ADDR
// end ;
46177: LD_VAR 0 2
46181: RET
// export function ReverseDir ( unit ) ; begin
46182: LD_INT 0
46184: PPUSH
// if not unit then
46185: LD_VAR 0 1
46189: NOT
46190: IFFALSE 46194
// exit ;
46192: GO 46217
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46194: LD_ADDR_VAR 0 2
46198: PUSH
46199: LD_VAR 0 1
46203: PPUSH
46204: CALL_OW 254
46208: PUSH
46209: LD_INT 3
46211: PLUS
46212: PUSH
46213: LD_INT 6
46215: MOD
46216: ST_TO_ADDR
// end ;
46217: LD_VAR 0 2
46221: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46222: LD_INT 0
46224: PPUSH
46225: PPUSH
46226: PPUSH
46227: PPUSH
46228: PPUSH
// if not hexes then
46229: LD_VAR 0 2
46233: NOT
46234: IFFALSE 46238
// exit ;
46236: GO 46386
// dist := 9999 ;
46238: LD_ADDR_VAR 0 5
46242: PUSH
46243: LD_INT 9999
46245: ST_TO_ADDR
// for i = 1 to hexes do
46246: LD_ADDR_VAR 0 4
46250: PUSH
46251: DOUBLE
46252: LD_INT 1
46254: DEC
46255: ST_TO_ADDR
46256: LD_VAR 0 2
46260: PUSH
46261: FOR_TO
46262: IFFALSE 46374
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46264: LD_VAR 0 1
46268: PPUSH
46269: LD_VAR 0 2
46273: PUSH
46274: LD_VAR 0 4
46278: ARRAY
46279: PUSH
46280: LD_INT 1
46282: ARRAY
46283: PPUSH
46284: LD_VAR 0 2
46288: PUSH
46289: LD_VAR 0 4
46293: ARRAY
46294: PUSH
46295: LD_INT 2
46297: ARRAY
46298: PPUSH
46299: CALL_OW 297
46303: PUSH
46304: LD_VAR 0 5
46308: LESS
46309: IFFALSE 46372
// begin hex := hexes [ i ] ;
46311: LD_ADDR_VAR 0 7
46315: PUSH
46316: LD_VAR 0 2
46320: PUSH
46321: LD_VAR 0 4
46325: ARRAY
46326: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46327: LD_ADDR_VAR 0 5
46331: PUSH
46332: LD_VAR 0 1
46336: PPUSH
46337: LD_VAR 0 2
46341: PUSH
46342: LD_VAR 0 4
46346: ARRAY
46347: PUSH
46348: LD_INT 1
46350: ARRAY
46351: PPUSH
46352: LD_VAR 0 2
46356: PUSH
46357: LD_VAR 0 4
46361: ARRAY
46362: PUSH
46363: LD_INT 2
46365: ARRAY
46366: PPUSH
46367: CALL_OW 297
46371: ST_TO_ADDR
// end ; end ;
46372: GO 46261
46374: POP
46375: POP
// result := hex ;
46376: LD_ADDR_VAR 0 3
46380: PUSH
46381: LD_VAR 0 7
46385: ST_TO_ADDR
// end ;
46386: LD_VAR 0 3
46390: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46391: LD_INT 0
46393: PPUSH
46394: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46395: LD_VAR 0 1
46399: NOT
46400: PUSH
46401: LD_VAR 0 1
46405: PUSH
46406: LD_INT 21
46408: PUSH
46409: LD_INT 2
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 23
46418: PUSH
46419: LD_INT 2
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PPUSH
46430: CALL_OW 69
46434: IN
46435: NOT
46436: OR
46437: IFFALSE 46441
// exit ;
46439: GO 46488
// for i = 1 to 3 do
46441: LD_ADDR_VAR 0 3
46445: PUSH
46446: DOUBLE
46447: LD_INT 1
46449: DEC
46450: ST_TO_ADDR
46451: LD_INT 3
46453: PUSH
46454: FOR_TO
46455: IFFALSE 46486
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46457: LD_VAR 0 1
46461: PPUSH
46462: CALL_OW 250
46466: PPUSH
46467: LD_VAR 0 1
46471: PPUSH
46472: CALL_OW 251
46476: PPUSH
46477: LD_INT 1
46479: PPUSH
46480: CALL_OW 453
46484: GO 46454
46486: POP
46487: POP
// end ;
46488: LD_VAR 0 2
46492: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46493: LD_INT 0
46495: PPUSH
46496: PPUSH
46497: PPUSH
46498: PPUSH
46499: PPUSH
46500: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46501: LD_VAR 0 1
46505: NOT
46506: PUSH
46507: LD_VAR 0 2
46511: NOT
46512: OR
46513: PUSH
46514: LD_VAR 0 1
46518: PPUSH
46519: CALL_OW 314
46523: OR
46524: IFFALSE 46528
// exit ;
46526: GO 46969
// x := GetX ( enemy_unit ) ;
46528: LD_ADDR_VAR 0 7
46532: PUSH
46533: LD_VAR 0 2
46537: PPUSH
46538: CALL_OW 250
46542: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46543: LD_ADDR_VAR 0 8
46547: PUSH
46548: LD_VAR 0 2
46552: PPUSH
46553: CALL_OW 251
46557: ST_TO_ADDR
// if not x or not y then
46558: LD_VAR 0 7
46562: NOT
46563: PUSH
46564: LD_VAR 0 8
46568: NOT
46569: OR
46570: IFFALSE 46574
// exit ;
46572: GO 46969
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46574: LD_ADDR_VAR 0 6
46578: PUSH
46579: LD_VAR 0 7
46583: PPUSH
46584: LD_INT 0
46586: PPUSH
46587: LD_INT 4
46589: PPUSH
46590: CALL_OW 272
46594: PUSH
46595: LD_VAR 0 8
46599: PPUSH
46600: LD_INT 0
46602: PPUSH
46603: LD_INT 4
46605: PPUSH
46606: CALL_OW 273
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PUSH
46615: LD_VAR 0 7
46619: PPUSH
46620: LD_INT 1
46622: PPUSH
46623: LD_INT 4
46625: PPUSH
46626: CALL_OW 272
46630: PUSH
46631: LD_VAR 0 8
46635: PPUSH
46636: LD_INT 1
46638: PPUSH
46639: LD_INT 4
46641: PPUSH
46642: CALL_OW 273
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_VAR 0 7
46655: PPUSH
46656: LD_INT 2
46658: PPUSH
46659: LD_INT 4
46661: PPUSH
46662: CALL_OW 272
46666: PUSH
46667: LD_VAR 0 8
46671: PPUSH
46672: LD_INT 2
46674: PPUSH
46675: LD_INT 4
46677: PPUSH
46678: CALL_OW 273
46682: PUSH
46683: EMPTY
46684: LIST
46685: LIST
46686: PUSH
46687: LD_VAR 0 7
46691: PPUSH
46692: LD_INT 3
46694: PPUSH
46695: LD_INT 4
46697: PPUSH
46698: CALL_OW 272
46702: PUSH
46703: LD_VAR 0 8
46707: PPUSH
46708: LD_INT 3
46710: PPUSH
46711: LD_INT 4
46713: PPUSH
46714: CALL_OW 273
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_VAR 0 7
46727: PPUSH
46728: LD_INT 4
46730: PPUSH
46731: LD_INT 4
46733: PPUSH
46734: CALL_OW 272
46738: PUSH
46739: LD_VAR 0 8
46743: PPUSH
46744: LD_INT 4
46746: PPUSH
46747: LD_INT 4
46749: PPUSH
46750: CALL_OW 273
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_VAR 0 7
46763: PPUSH
46764: LD_INT 5
46766: PPUSH
46767: LD_INT 4
46769: PPUSH
46770: CALL_OW 272
46774: PUSH
46775: LD_VAR 0 8
46779: PPUSH
46780: LD_INT 5
46782: PPUSH
46783: LD_INT 4
46785: PPUSH
46786: CALL_OW 273
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: ST_TO_ADDR
// for i = tmp downto 1 do
46803: LD_ADDR_VAR 0 4
46807: PUSH
46808: DOUBLE
46809: LD_VAR 0 6
46813: INC
46814: ST_TO_ADDR
46815: LD_INT 1
46817: PUSH
46818: FOR_DOWNTO
46819: IFFALSE 46920
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46821: LD_VAR 0 6
46825: PUSH
46826: LD_VAR 0 4
46830: ARRAY
46831: PUSH
46832: LD_INT 1
46834: ARRAY
46835: PPUSH
46836: LD_VAR 0 6
46840: PUSH
46841: LD_VAR 0 4
46845: ARRAY
46846: PUSH
46847: LD_INT 2
46849: ARRAY
46850: PPUSH
46851: CALL_OW 488
46855: NOT
46856: PUSH
46857: LD_VAR 0 6
46861: PUSH
46862: LD_VAR 0 4
46866: ARRAY
46867: PUSH
46868: LD_INT 1
46870: ARRAY
46871: PPUSH
46872: LD_VAR 0 6
46876: PUSH
46877: LD_VAR 0 4
46881: ARRAY
46882: PUSH
46883: LD_INT 2
46885: ARRAY
46886: PPUSH
46887: CALL_OW 428
46891: PUSH
46892: LD_INT 0
46894: NONEQUAL
46895: OR
46896: IFFALSE 46918
// tmp := Delete ( tmp , i ) ;
46898: LD_ADDR_VAR 0 6
46902: PUSH
46903: LD_VAR 0 6
46907: PPUSH
46908: LD_VAR 0 4
46912: PPUSH
46913: CALL_OW 3
46917: ST_TO_ADDR
46918: GO 46818
46920: POP
46921: POP
// j := GetClosestHex ( unit , tmp ) ;
46922: LD_ADDR_VAR 0 5
46926: PUSH
46927: LD_VAR 0 1
46931: PPUSH
46932: LD_VAR 0 6
46936: PPUSH
46937: CALL 46222 0 2
46941: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46942: LD_VAR 0 1
46946: PPUSH
46947: LD_VAR 0 5
46951: PUSH
46952: LD_INT 1
46954: ARRAY
46955: PPUSH
46956: LD_VAR 0 5
46960: PUSH
46961: LD_INT 2
46963: ARRAY
46964: PPUSH
46965: CALL_OW 111
// end ;
46969: LD_VAR 0 3
46973: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46974: LD_INT 0
46976: PPUSH
46977: PPUSH
46978: PPUSH
// uc_side = 0 ;
46979: LD_ADDR_OWVAR 20
46983: PUSH
46984: LD_INT 0
46986: ST_TO_ADDR
// uc_nation = 0 ;
46987: LD_ADDR_OWVAR 21
46991: PUSH
46992: LD_INT 0
46994: ST_TO_ADDR
// InitHc_All ( ) ;
46995: CALL_OW 584
// InitVc ;
46999: CALL_OW 20
// if mastodonts then
47003: LD_VAR 0 6
47007: IFFALSE 47074
// for i = 1 to mastodonts do
47009: LD_ADDR_VAR 0 11
47013: PUSH
47014: DOUBLE
47015: LD_INT 1
47017: DEC
47018: ST_TO_ADDR
47019: LD_VAR 0 6
47023: PUSH
47024: FOR_TO
47025: IFFALSE 47072
// begin vc_chassis := 31 ;
47027: LD_ADDR_OWVAR 37
47031: PUSH
47032: LD_INT 31
47034: ST_TO_ADDR
// vc_control := control_rider ;
47035: LD_ADDR_OWVAR 38
47039: PUSH
47040: LD_INT 4
47042: ST_TO_ADDR
// animal := CreateVehicle ;
47043: LD_ADDR_VAR 0 12
47047: PUSH
47048: CALL_OW 45
47052: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47053: LD_VAR 0 12
47057: PPUSH
47058: LD_VAR 0 8
47062: PPUSH
47063: LD_INT 0
47065: PPUSH
47066: CALL 49209 0 3
// end ;
47070: GO 47024
47072: POP
47073: POP
// if horses then
47074: LD_VAR 0 5
47078: IFFALSE 47145
// for i = 1 to horses do
47080: LD_ADDR_VAR 0 11
47084: PUSH
47085: DOUBLE
47086: LD_INT 1
47088: DEC
47089: ST_TO_ADDR
47090: LD_VAR 0 5
47094: PUSH
47095: FOR_TO
47096: IFFALSE 47143
// begin hc_class := 21 ;
47098: LD_ADDR_OWVAR 28
47102: PUSH
47103: LD_INT 21
47105: ST_TO_ADDR
// hc_gallery :=  ;
47106: LD_ADDR_OWVAR 33
47110: PUSH
47111: LD_STRING 
47113: ST_TO_ADDR
// animal := CreateHuman ;
47114: LD_ADDR_VAR 0 12
47118: PUSH
47119: CALL_OW 44
47123: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47124: LD_VAR 0 12
47128: PPUSH
47129: LD_VAR 0 8
47133: PPUSH
47134: LD_INT 0
47136: PPUSH
47137: CALL 49209 0 3
// end ;
47141: GO 47095
47143: POP
47144: POP
// if birds then
47145: LD_VAR 0 1
47149: IFFALSE 47216
// for i = 1 to birds do
47151: LD_ADDR_VAR 0 11
47155: PUSH
47156: DOUBLE
47157: LD_INT 1
47159: DEC
47160: ST_TO_ADDR
47161: LD_VAR 0 1
47165: PUSH
47166: FOR_TO
47167: IFFALSE 47214
// begin hc_class = 18 ;
47169: LD_ADDR_OWVAR 28
47173: PUSH
47174: LD_INT 18
47176: ST_TO_ADDR
// hc_gallery =  ;
47177: LD_ADDR_OWVAR 33
47181: PUSH
47182: LD_STRING 
47184: ST_TO_ADDR
// animal := CreateHuman ;
47185: LD_ADDR_VAR 0 12
47189: PUSH
47190: CALL_OW 44
47194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47195: LD_VAR 0 12
47199: PPUSH
47200: LD_VAR 0 8
47204: PPUSH
47205: LD_INT 0
47207: PPUSH
47208: CALL 49209 0 3
// end ;
47212: GO 47166
47214: POP
47215: POP
// if tigers then
47216: LD_VAR 0 2
47220: IFFALSE 47304
// for i = 1 to tigers do
47222: LD_ADDR_VAR 0 11
47226: PUSH
47227: DOUBLE
47228: LD_INT 1
47230: DEC
47231: ST_TO_ADDR
47232: LD_VAR 0 2
47236: PUSH
47237: FOR_TO
47238: IFFALSE 47302
// begin hc_class = class_tiger ;
47240: LD_ADDR_OWVAR 28
47244: PUSH
47245: LD_INT 14
47247: ST_TO_ADDR
// hc_gallery =  ;
47248: LD_ADDR_OWVAR 33
47252: PUSH
47253: LD_STRING 
47255: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47256: LD_ADDR_OWVAR 35
47260: PUSH
47261: LD_INT 7
47263: NEG
47264: PPUSH
47265: LD_INT 7
47267: PPUSH
47268: CALL_OW 12
47272: ST_TO_ADDR
// animal := CreateHuman ;
47273: LD_ADDR_VAR 0 12
47277: PUSH
47278: CALL_OW 44
47282: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47283: LD_VAR 0 12
47287: PPUSH
47288: LD_VAR 0 8
47292: PPUSH
47293: LD_INT 0
47295: PPUSH
47296: CALL 49209 0 3
// end ;
47300: GO 47237
47302: POP
47303: POP
// if apemans then
47304: LD_VAR 0 3
47308: IFFALSE 47431
// for i = 1 to apemans do
47310: LD_ADDR_VAR 0 11
47314: PUSH
47315: DOUBLE
47316: LD_INT 1
47318: DEC
47319: ST_TO_ADDR
47320: LD_VAR 0 3
47324: PUSH
47325: FOR_TO
47326: IFFALSE 47429
// begin hc_class = class_apeman ;
47328: LD_ADDR_OWVAR 28
47332: PUSH
47333: LD_INT 12
47335: ST_TO_ADDR
// hc_gallery =  ;
47336: LD_ADDR_OWVAR 33
47340: PUSH
47341: LD_STRING 
47343: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
47344: LD_ADDR_OWVAR 35
47348: PUSH
47349: LD_INT 2
47351: NEG
47352: PPUSH
47353: LD_INT 2
47355: PPUSH
47356: CALL_OW 12
47360: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47361: LD_ADDR_OWVAR 31
47365: PUSH
47366: LD_INT 1
47368: PPUSH
47369: LD_INT 3
47371: PPUSH
47372: CALL_OW 12
47376: PUSH
47377: LD_INT 1
47379: PPUSH
47380: LD_INT 3
47382: PPUSH
47383: CALL_OW 12
47387: PUSH
47388: LD_INT 0
47390: PUSH
47391: LD_INT 0
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: ST_TO_ADDR
// animal := CreateHuman ;
47400: LD_ADDR_VAR 0 12
47404: PUSH
47405: CALL_OW 44
47409: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47410: LD_VAR 0 12
47414: PPUSH
47415: LD_VAR 0 8
47419: PPUSH
47420: LD_INT 0
47422: PPUSH
47423: CALL 49209 0 3
// end ;
47427: GO 47325
47429: POP
47430: POP
// if enchidnas then
47431: LD_VAR 0 4
47435: IFFALSE 47502
// for i = 1 to enchidnas do
47437: LD_ADDR_VAR 0 11
47441: PUSH
47442: DOUBLE
47443: LD_INT 1
47445: DEC
47446: ST_TO_ADDR
47447: LD_VAR 0 4
47451: PUSH
47452: FOR_TO
47453: IFFALSE 47500
// begin hc_class = 13 ;
47455: LD_ADDR_OWVAR 28
47459: PUSH
47460: LD_INT 13
47462: ST_TO_ADDR
// hc_gallery =  ;
47463: LD_ADDR_OWVAR 33
47467: PUSH
47468: LD_STRING 
47470: ST_TO_ADDR
// animal := CreateHuman ;
47471: LD_ADDR_VAR 0 12
47475: PUSH
47476: CALL_OW 44
47480: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47481: LD_VAR 0 12
47485: PPUSH
47486: LD_VAR 0 8
47490: PPUSH
47491: LD_INT 0
47493: PPUSH
47494: CALL 49209 0 3
// end ;
47498: GO 47452
47500: POP
47501: POP
// if fishes then
47502: LD_VAR 0 7
47506: IFFALSE 47573
// for i = 1 to fishes do
47508: LD_ADDR_VAR 0 11
47512: PUSH
47513: DOUBLE
47514: LD_INT 1
47516: DEC
47517: ST_TO_ADDR
47518: LD_VAR 0 7
47522: PUSH
47523: FOR_TO
47524: IFFALSE 47571
// begin hc_class = 20 ;
47526: LD_ADDR_OWVAR 28
47530: PUSH
47531: LD_INT 20
47533: ST_TO_ADDR
// hc_gallery =  ;
47534: LD_ADDR_OWVAR 33
47538: PUSH
47539: LD_STRING 
47541: ST_TO_ADDR
// animal := CreateHuman ;
47542: LD_ADDR_VAR 0 12
47546: PUSH
47547: CALL_OW 44
47551: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47552: LD_VAR 0 12
47556: PPUSH
47557: LD_VAR 0 9
47561: PPUSH
47562: LD_INT 0
47564: PPUSH
47565: CALL 49209 0 3
// end ;
47569: GO 47523
47571: POP
47572: POP
// end ;
47573: LD_VAR 0 10
47577: RET
// export function WantHeal ( sci , unit ) ; begin
47578: LD_INT 0
47580: PPUSH
// if GetTaskList ( sci ) > 0 then
47581: LD_VAR 0 1
47585: PPUSH
47586: CALL_OW 437
47590: PUSH
47591: LD_INT 0
47593: GREATER
47594: IFFALSE 47664
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47596: LD_VAR 0 1
47600: PPUSH
47601: CALL_OW 437
47605: PUSH
47606: LD_INT 1
47608: ARRAY
47609: PUSH
47610: LD_INT 1
47612: ARRAY
47613: PUSH
47614: LD_STRING l
47616: EQUAL
47617: PUSH
47618: LD_VAR 0 1
47622: PPUSH
47623: CALL_OW 437
47627: PUSH
47628: LD_INT 1
47630: ARRAY
47631: PUSH
47632: LD_INT 4
47634: ARRAY
47635: PUSH
47636: LD_VAR 0 2
47640: EQUAL
47641: AND
47642: IFFALSE 47654
// result := true else
47644: LD_ADDR_VAR 0 3
47648: PUSH
47649: LD_INT 1
47651: ST_TO_ADDR
47652: GO 47662
// result := false ;
47654: LD_ADDR_VAR 0 3
47658: PUSH
47659: LD_INT 0
47661: ST_TO_ADDR
// end else
47662: GO 47672
// result := false ;
47664: LD_ADDR_VAR 0 3
47668: PUSH
47669: LD_INT 0
47671: ST_TO_ADDR
// end ;
47672: LD_VAR 0 3
47676: RET
// export function HealTarget ( sci ) ; begin
47677: LD_INT 0
47679: PPUSH
// if not sci then
47680: LD_VAR 0 1
47684: NOT
47685: IFFALSE 47689
// exit ;
47687: GO 47754
// result := 0 ;
47689: LD_ADDR_VAR 0 2
47693: PUSH
47694: LD_INT 0
47696: ST_TO_ADDR
// if GetTaskList ( sci ) then
47697: LD_VAR 0 1
47701: PPUSH
47702: CALL_OW 437
47706: IFFALSE 47754
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47708: LD_VAR 0 1
47712: PPUSH
47713: CALL_OW 437
47717: PUSH
47718: LD_INT 1
47720: ARRAY
47721: PUSH
47722: LD_INT 1
47724: ARRAY
47725: PUSH
47726: LD_STRING l
47728: EQUAL
47729: IFFALSE 47754
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47731: LD_ADDR_VAR 0 2
47735: PUSH
47736: LD_VAR 0 1
47740: PPUSH
47741: CALL_OW 437
47745: PUSH
47746: LD_INT 1
47748: ARRAY
47749: PUSH
47750: LD_INT 4
47752: ARRAY
47753: ST_TO_ADDR
// end ;
47754: LD_VAR 0 2
47758: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47759: LD_INT 0
47761: PPUSH
47762: PPUSH
47763: PPUSH
47764: PPUSH
// if not base_units then
47765: LD_VAR 0 1
47769: NOT
47770: IFFALSE 47774
// exit ;
47772: GO 47861
// result := false ;
47774: LD_ADDR_VAR 0 2
47778: PUSH
47779: LD_INT 0
47781: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47782: LD_ADDR_VAR 0 5
47786: PUSH
47787: LD_VAR 0 1
47791: PPUSH
47792: LD_INT 21
47794: PUSH
47795: LD_INT 3
47797: PUSH
47798: EMPTY
47799: LIST
47800: LIST
47801: PPUSH
47802: CALL_OW 72
47806: ST_TO_ADDR
// if not tmp then
47807: LD_VAR 0 5
47811: NOT
47812: IFFALSE 47816
// exit ;
47814: GO 47861
// for i in tmp do
47816: LD_ADDR_VAR 0 3
47820: PUSH
47821: LD_VAR 0 5
47825: PUSH
47826: FOR_IN
47827: IFFALSE 47859
// begin result := EnemyInRange ( i , 22 ) ;
47829: LD_ADDR_VAR 0 2
47833: PUSH
47834: LD_VAR 0 3
47838: PPUSH
47839: LD_INT 22
47841: PPUSH
47842: CALL 46097 0 2
47846: ST_TO_ADDR
// if result then
47847: LD_VAR 0 2
47851: IFFALSE 47857
// exit ;
47853: POP
47854: POP
47855: GO 47861
// end ;
47857: GO 47826
47859: POP
47860: POP
// end ;
47861: LD_VAR 0 2
47865: RET
// export function FilterByTag ( units , tag ) ; begin
47866: LD_INT 0
47868: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
47869: LD_ADDR_VAR 0 3
47873: PUSH
47874: LD_VAR 0 1
47878: PPUSH
47879: LD_INT 120
47881: PUSH
47882: LD_VAR 0 2
47886: PUSH
47887: EMPTY
47888: LIST
47889: LIST
47890: PPUSH
47891: CALL_OW 72
47895: ST_TO_ADDR
// end ;
47896: LD_VAR 0 3
47900: RET
// export function IsDriver ( un ) ; begin
47901: LD_INT 0
47903: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47904: LD_ADDR_VAR 0 2
47908: PUSH
47909: LD_VAR 0 1
47913: PUSH
47914: LD_INT 55
47916: PUSH
47917: EMPTY
47918: LIST
47919: PPUSH
47920: CALL_OW 69
47924: IN
47925: ST_TO_ADDR
// end ;
47926: LD_VAR 0 2
47930: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47931: LD_INT 0
47933: PPUSH
47934: PPUSH
// list := [ ] ;
47935: LD_ADDR_VAR 0 5
47939: PUSH
47940: EMPTY
47941: ST_TO_ADDR
// case d of 0 :
47942: LD_VAR 0 3
47946: PUSH
47947: LD_INT 0
47949: DOUBLE
47950: EQUAL
47951: IFTRUE 47955
47953: GO 48088
47955: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47956: LD_ADDR_VAR 0 5
47960: PUSH
47961: LD_VAR 0 1
47965: PUSH
47966: LD_INT 4
47968: MINUS
47969: PUSH
47970: LD_VAR 0 2
47974: PUSH
47975: LD_INT 4
47977: MINUS
47978: PUSH
47979: LD_INT 2
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: LIST
47986: PUSH
47987: LD_VAR 0 1
47991: PUSH
47992: LD_INT 3
47994: MINUS
47995: PUSH
47996: LD_VAR 0 2
48000: PUSH
48001: LD_INT 1
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: LIST
48008: PUSH
48009: LD_VAR 0 1
48013: PUSH
48014: LD_INT 4
48016: PLUS
48017: PUSH
48018: LD_VAR 0 2
48022: PUSH
48023: LD_INT 4
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 3
48038: PLUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 3
48047: PLUS
48048: PUSH
48049: LD_INT 5
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: LIST
48056: PUSH
48057: LD_VAR 0 1
48061: PUSH
48062: LD_VAR 0 2
48066: PUSH
48067: LD_INT 4
48069: PLUS
48070: PUSH
48071: LD_INT 0
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: LIST
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: LIST
48083: LIST
48084: LIST
48085: ST_TO_ADDR
// end ; 1 :
48086: GO 48786
48088: LD_INT 1
48090: DOUBLE
48091: EQUAL
48092: IFTRUE 48096
48094: GO 48229
48096: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48097: LD_ADDR_VAR 0 5
48101: PUSH
48102: LD_VAR 0 1
48106: PUSH
48107: LD_VAR 0 2
48111: PUSH
48112: LD_INT 4
48114: MINUS
48115: PUSH
48116: LD_INT 3
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: LIST
48123: PUSH
48124: LD_VAR 0 1
48128: PUSH
48129: LD_INT 3
48131: MINUS
48132: PUSH
48133: LD_VAR 0 2
48137: PUSH
48138: LD_INT 3
48140: MINUS
48141: PUSH
48142: LD_INT 2
48144: PUSH
48145: EMPTY
48146: LIST
48147: LIST
48148: LIST
48149: PUSH
48150: LD_VAR 0 1
48154: PUSH
48155: LD_INT 4
48157: MINUS
48158: PUSH
48159: LD_VAR 0 2
48163: PUSH
48164: LD_INT 1
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: LIST
48171: PUSH
48172: LD_VAR 0 1
48176: PUSH
48177: LD_VAR 0 2
48181: PUSH
48182: LD_INT 3
48184: PLUS
48185: PUSH
48186: LD_INT 0
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: LIST
48193: PUSH
48194: LD_VAR 0 1
48198: PUSH
48199: LD_INT 4
48201: PLUS
48202: PUSH
48203: LD_VAR 0 2
48207: PUSH
48208: LD_INT 4
48210: PLUS
48211: PUSH
48212: LD_INT 5
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: LIST
48219: PUSH
48220: EMPTY
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: ST_TO_ADDR
// end ; 2 :
48227: GO 48786
48229: LD_INT 2
48231: DOUBLE
48232: EQUAL
48233: IFTRUE 48237
48235: GO 48366
48237: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48238: LD_ADDR_VAR 0 5
48242: PUSH
48243: LD_VAR 0 1
48247: PUSH
48248: LD_VAR 0 2
48252: PUSH
48253: LD_INT 3
48255: MINUS
48256: PUSH
48257: LD_INT 3
48259: PUSH
48260: EMPTY
48261: LIST
48262: LIST
48263: LIST
48264: PUSH
48265: LD_VAR 0 1
48269: PUSH
48270: LD_INT 4
48272: PLUS
48273: PUSH
48274: LD_VAR 0 2
48278: PUSH
48279: LD_INT 4
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: LIST
48286: PUSH
48287: LD_VAR 0 1
48291: PUSH
48292: LD_VAR 0 2
48296: PUSH
48297: LD_INT 4
48299: PLUS
48300: PUSH
48301: LD_INT 0
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: LIST
48308: PUSH
48309: LD_VAR 0 1
48313: PUSH
48314: LD_INT 3
48316: MINUS
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 1
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: LD_VAR 0 1
48335: PUSH
48336: LD_INT 4
48338: MINUS
48339: PUSH
48340: LD_VAR 0 2
48344: PUSH
48345: LD_INT 4
48347: MINUS
48348: PUSH
48349: LD_INT 2
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: LIST
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: ST_TO_ADDR
// end ; 3 :
48364: GO 48786
48366: LD_INT 3
48368: DOUBLE
48369: EQUAL
48370: IFTRUE 48374
48372: GO 48507
48374: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48375: LD_ADDR_VAR 0 5
48379: PUSH
48380: LD_VAR 0 1
48384: PUSH
48385: LD_INT 3
48387: PLUS
48388: PUSH
48389: LD_VAR 0 2
48393: PUSH
48394: LD_INT 4
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: LIST
48401: PUSH
48402: LD_VAR 0 1
48406: PUSH
48407: LD_INT 4
48409: PLUS
48410: PUSH
48411: LD_VAR 0 2
48415: PUSH
48416: LD_INT 4
48418: PLUS
48419: PUSH
48420: LD_INT 5
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: LIST
48427: PUSH
48428: LD_VAR 0 1
48432: PUSH
48433: LD_INT 4
48435: MINUS
48436: PUSH
48437: LD_VAR 0 2
48441: PUSH
48442: LD_INT 1
48444: PUSH
48445: EMPTY
48446: LIST
48447: LIST
48448: LIST
48449: PUSH
48450: LD_VAR 0 1
48454: PUSH
48455: LD_VAR 0 2
48459: PUSH
48460: LD_INT 4
48462: MINUS
48463: PUSH
48464: LD_INT 3
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: LIST
48471: PUSH
48472: LD_VAR 0 1
48476: PUSH
48477: LD_INT 3
48479: MINUS
48480: PUSH
48481: LD_VAR 0 2
48485: PUSH
48486: LD_INT 3
48488: MINUS
48489: PUSH
48490: LD_INT 2
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: LIST
48497: PUSH
48498: EMPTY
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: ST_TO_ADDR
// end ; 4 :
48505: GO 48786
48507: LD_INT 4
48509: DOUBLE
48510: EQUAL
48511: IFTRUE 48515
48513: GO 48648
48515: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48516: LD_ADDR_VAR 0 5
48520: PUSH
48521: LD_VAR 0 1
48525: PUSH
48526: LD_VAR 0 2
48530: PUSH
48531: LD_INT 4
48533: PLUS
48534: PUSH
48535: LD_INT 0
48537: PUSH
48538: EMPTY
48539: LIST
48540: LIST
48541: LIST
48542: PUSH
48543: LD_VAR 0 1
48547: PUSH
48548: LD_INT 3
48550: PLUS
48551: PUSH
48552: LD_VAR 0 2
48556: PUSH
48557: LD_INT 3
48559: PLUS
48560: PUSH
48561: LD_INT 5
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: LIST
48568: PUSH
48569: LD_VAR 0 1
48573: PUSH
48574: LD_INT 4
48576: PLUS
48577: PUSH
48578: LD_VAR 0 2
48582: PUSH
48583: LD_INT 4
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: LIST
48590: PUSH
48591: LD_VAR 0 1
48595: PUSH
48596: LD_VAR 0 2
48600: PUSH
48601: LD_INT 3
48603: MINUS
48604: PUSH
48605: LD_INT 3
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: PUSH
48613: LD_VAR 0 1
48617: PUSH
48618: LD_INT 4
48620: MINUS
48621: PUSH
48622: LD_VAR 0 2
48626: PUSH
48627: LD_INT 4
48629: MINUS
48630: PUSH
48631: LD_INT 2
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: LIST
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: LIST
48643: LIST
48644: LIST
48645: ST_TO_ADDR
// end ; 5 :
48646: GO 48786
48648: LD_INT 5
48650: DOUBLE
48651: EQUAL
48652: IFTRUE 48656
48654: GO 48785
48656: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48657: LD_ADDR_VAR 0 5
48661: PUSH
48662: LD_VAR 0 1
48666: PUSH
48667: LD_INT 4
48669: MINUS
48670: PUSH
48671: LD_VAR 0 2
48675: PUSH
48676: LD_INT 1
48678: PUSH
48679: EMPTY
48680: LIST
48681: LIST
48682: LIST
48683: PUSH
48684: LD_VAR 0 1
48688: PUSH
48689: LD_VAR 0 2
48693: PUSH
48694: LD_INT 4
48696: MINUS
48697: PUSH
48698: LD_INT 3
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: LIST
48705: PUSH
48706: LD_VAR 0 1
48710: PUSH
48711: LD_INT 4
48713: PLUS
48714: PUSH
48715: LD_VAR 0 2
48719: PUSH
48720: LD_INT 4
48722: PLUS
48723: PUSH
48724: LD_INT 5
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: LIST
48731: PUSH
48732: LD_VAR 0 1
48736: PUSH
48737: LD_INT 3
48739: PLUS
48740: PUSH
48741: LD_VAR 0 2
48745: PUSH
48746: LD_INT 4
48748: PUSH
48749: EMPTY
48750: LIST
48751: LIST
48752: LIST
48753: PUSH
48754: LD_VAR 0 1
48758: PUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 3
48766: PLUS
48767: PUSH
48768: LD_INT 0
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: LIST
48782: ST_TO_ADDR
// end ; end ;
48783: GO 48786
48785: POP
// result := list ;
48786: LD_ADDR_VAR 0 4
48790: PUSH
48791: LD_VAR 0 5
48795: ST_TO_ADDR
// end ;
48796: LD_VAR 0 4
48800: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48801: LD_INT 0
48803: PPUSH
48804: PPUSH
48805: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48806: LD_VAR 0 1
48810: NOT
48811: PUSH
48812: LD_VAR 0 2
48816: PUSH
48817: LD_INT 1
48819: PUSH
48820: LD_INT 2
48822: PUSH
48823: LD_INT 3
48825: PUSH
48826: LD_INT 4
48828: PUSH
48829: EMPTY
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: IN
48835: NOT
48836: OR
48837: IFFALSE 48841
// exit ;
48839: GO 48933
// tmp := [ ] ;
48841: LD_ADDR_VAR 0 5
48845: PUSH
48846: EMPTY
48847: ST_TO_ADDR
// for i in units do
48848: LD_ADDR_VAR 0 4
48852: PUSH
48853: LD_VAR 0 1
48857: PUSH
48858: FOR_IN
48859: IFFALSE 48902
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48861: LD_ADDR_VAR 0 5
48865: PUSH
48866: LD_VAR 0 5
48870: PPUSH
48871: LD_VAR 0 5
48875: PUSH
48876: LD_INT 1
48878: PLUS
48879: PPUSH
48880: LD_VAR 0 4
48884: PPUSH
48885: LD_VAR 0 2
48889: PPUSH
48890: CALL_OW 259
48894: PPUSH
48895: CALL_OW 2
48899: ST_TO_ADDR
48900: GO 48858
48902: POP
48903: POP
// if not tmp then
48904: LD_VAR 0 5
48908: NOT
48909: IFFALSE 48913
// exit ;
48911: GO 48933
// result := SortListByListDesc ( units , tmp ) ;
48913: LD_ADDR_VAR 0 3
48917: PUSH
48918: LD_VAR 0 1
48922: PPUSH
48923: LD_VAR 0 5
48927: PPUSH
48928: CALL_OW 77
48932: ST_TO_ADDR
// end ;
48933: LD_VAR 0 3
48937: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48938: LD_INT 0
48940: PPUSH
48941: PPUSH
48942: PPUSH
// result := false ;
48943: LD_ADDR_VAR 0 3
48947: PUSH
48948: LD_INT 0
48950: ST_TO_ADDR
// x := GetX ( building ) ;
48951: LD_ADDR_VAR 0 4
48955: PUSH
48956: LD_VAR 0 2
48960: PPUSH
48961: CALL_OW 250
48965: ST_TO_ADDR
// y := GetY ( building ) ;
48966: LD_ADDR_VAR 0 5
48970: PUSH
48971: LD_VAR 0 2
48975: PPUSH
48976: CALL_OW 251
48980: ST_TO_ADDR
// if not building or not x or not y then
48981: LD_VAR 0 2
48985: NOT
48986: PUSH
48987: LD_VAR 0 4
48991: NOT
48992: OR
48993: PUSH
48994: LD_VAR 0 5
48998: NOT
48999: OR
49000: IFFALSE 49004
// exit ;
49002: GO 49096
// if GetTaskList ( unit ) then
49004: LD_VAR 0 1
49008: PPUSH
49009: CALL_OW 437
49013: IFFALSE 49096
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49015: LD_STRING e
49017: PUSH
49018: LD_VAR 0 1
49022: PPUSH
49023: CALL_OW 437
49027: PUSH
49028: LD_INT 1
49030: ARRAY
49031: PUSH
49032: LD_INT 1
49034: ARRAY
49035: EQUAL
49036: PUSH
49037: LD_VAR 0 4
49041: PUSH
49042: LD_VAR 0 1
49046: PPUSH
49047: CALL_OW 437
49051: PUSH
49052: LD_INT 1
49054: ARRAY
49055: PUSH
49056: LD_INT 2
49058: ARRAY
49059: EQUAL
49060: AND
49061: PUSH
49062: LD_VAR 0 5
49066: PUSH
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL_OW 437
49076: PUSH
49077: LD_INT 1
49079: ARRAY
49080: PUSH
49081: LD_INT 3
49083: ARRAY
49084: EQUAL
49085: AND
49086: IFFALSE 49096
// result := true end ;
49088: LD_ADDR_VAR 0 3
49092: PUSH
49093: LD_INT 1
49095: ST_TO_ADDR
// end ;
49096: LD_VAR 0 3
49100: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49101: LD_INT 0
49103: PPUSH
// result := false ;
49104: LD_ADDR_VAR 0 4
49108: PUSH
49109: LD_INT 0
49111: ST_TO_ADDR
// if GetTaskList ( unit ) then
49112: LD_VAR 0 1
49116: PPUSH
49117: CALL_OW 437
49121: IFFALSE 49204
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49123: LD_STRING M
49125: PUSH
49126: LD_VAR 0 1
49130: PPUSH
49131: CALL_OW 437
49135: PUSH
49136: LD_INT 1
49138: ARRAY
49139: PUSH
49140: LD_INT 1
49142: ARRAY
49143: EQUAL
49144: PUSH
49145: LD_VAR 0 2
49149: PUSH
49150: LD_VAR 0 1
49154: PPUSH
49155: CALL_OW 437
49159: PUSH
49160: LD_INT 1
49162: ARRAY
49163: PUSH
49164: LD_INT 2
49166: ARRAY
49167: EQUAL
49168: AND
49169: PUSH
49170: LD_VAR 0 3
49174: PUSH
49175: LD_VAR 0 1
49179: PPUSH
49180: CALL_OW 437
49184: PUSH
49185: LD_INT 1
49187: ARRAY
49188: PUSH
49189: LD_INT 3
49191: ARRAY
49192: EQUAL
49193: AND
49194: IFFALSE 49204
// result := true ;
49196: LD_ADDR_VAR 0 4
49200: PUSH
49201: LD_INT 1
49203: ST_TO_ADDR
// end ; end ;
49204: LD_VAR 0 4
49208: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49209: LD_INT 0
49211: PPUSH
49212: PPUSH
49213: PPUSH
49214: PPUSH
// if not unit or not area then
49215: LD_VAR 0 1
49219: NOT
49220: PUSH
49221: LD_VAR 0 2
49225: NOT
49226: OR
49227: IFFALSE 49231
// exit ;
49229: GO 49395
// tmp := AreaToList ( area , i ) ;
49231: LD_ADDR_VAR 0 6
49235: PUSH
49236: LD_VAR 0 2
49240: PPUSH
49241: LD_VAR 0 5
49245: PPUSH
49246: CALL_OW 517
49250: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49251: LD_ADDR_VAR 0 5
49255: PUSH
49256: DOUBLE
49257: LD_INT 1
49259: DEC
49260: ST_TO_ADDR
49261: LD_VAR 0 6
49265: PUSH
49266: LD_INT 1
49268: ARRAY
49269: PUSH
49270: FOR_TO
49271: IFFALSE 49393
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49273: LD_ADDR_VAR 0 7
49277: PUSH
49278: LD_VAR 0 6
49282: PUSH
49283: LD_INT 1
49285: ARRAY
49286: PUSH
49287: LD_VAR 0 5
49291: ARRAY
49292: PUSH
49293: LD_VAR 0 6
49297: PUSH
49298: LD_INT 2
49300: ARRAY
49301: PUSH
49302: LD_VAR 0 5
49306: ARRAY
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49312: LD_VAR 0 7
49316: PUSH
49317: LD_INT 1
49319: ARRAY
49320: PPUSH
49321: LD_VAR 0 7
49325: PUSH
49326: LD_INT 2
49328: ARRAY
49329: PPUSH
49330: CALL_OW 428
49334: PUSH
49335: LD_INT 0
49337: EQUAL
49338: IFFALSE 49391
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49340: LD_VAR 0 1
49344: PPUSH
49345: LD_VAR 0 7
49349: PUSH
49350: LD_INT 1
49352: ARRAY
49353: PPUSH
49354: LD_VAR 0 7
49358: PUSH
49359: LD_INT 2
49361: ARRAY
49362: PPUSH
49363: LD_VAR 0 3
49367: PPUSH
49368: CALL_OW 48
// result := IsPlaced ( unit ) ;
49372: LD_ADDR_VAR 0 4
49376: PUSH
49377: LD_VAR 0 1
49381: PPUSH
49382: CALL_OW 305
49386: ST_TO_ADDR
// exit ;
49387: POP
49388: POP
49389: GO 49395
// end ; end ;
49391: GO 49270
49393: POP
49394: POP
// end ;
49395: LD_VAR 0 4
49399: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49400: LD_INT 0
49402: PPUSH
49403: PPUSH
49404: PPUSH
// if not side or side > 8 then
49405: LD_VAR 0 1
49409: NOT
49410: PUSH
49411: LD_VAR 0 1
49415: PUSH
49416: LD_INT 8
49418: GREATER
49419: OR
49420: IFFALSE 49424
// exit ;
49422: GO 49611
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49424: LD_ADDR_VAR 0 4
49428: PUSH
49429: LD_INT 22
49431: PUSH
49432: LD_VAR 0 1
49436: PUSH
49437: EMPTY
49438: LIST
49439: LIST
49440: PUSH
49441: LD_INT 21
49443: PUSH
49444: LD_INT 3
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PPUSH
49455: CALL_OW 69
49459: ST_TO_ADDR
// if not tmp then
49460: LD_VAR 0 4
49464: NOT
49465: IFFALSE 49469
// exit ;
49467: GO 49611
// enable_addtolog := true ;
49469: LD_ADDR_OWVAR 81
49473: PUSH
49474: LD_INT 1
49476: ST_TO_ADDR
// AddToLog ( [ ) ;
49477: LD_STRING [
49479: PPUSH
49480: CALL_OW 561
// for i in tmp do
49484: LD_ADDR_VAR 0 3
49488: PUSH
49489: LD_VAR 0 4
49493: PUSH
49494: FOR_IN
49495: IFFALSE 49602
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49497: LD_STRING [
49499: PUSH
49500: LD_VAR 0 3
49504: PPUSH
49505: CALL_OW 266
49509: STR
49510: PUSH
49511: LD_STRING , 
49513: STR
49514: PUSH
49515: LD_VAR 0 3
49519: PPUSH
49520: CALL_OW 250
49524: STR
49525: PUSH
49526: LD_STRING , 
49528: STR
49529: PUSH
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 251
49539: STR
49540: PUSH
49541: LD_STRING , 
49543: STR
49544: PUSH
49545: LD_VAR 0 3
49549: PPUSH
49550: CALL_OW 254
49554: STR
49555: PUSH
49556: LD_STRING , 
49558: STR
49559: PUSH
49560: LD_VAR 0 3
49564: PPUSH
49565: LD_INT 1
49567: PPUSH
49568: CALL_OW 268
49572: STR
49573: PUSH
49574: LD_STRING , 
49576: STR
49577: PUSH
49578: LD_VAR 0 3
49582: PPUSH
49583: LD_INT 2
49585: PPUSH
49586: CALL_OW 268
49590: STR
49591: PUSH
49592: LD_STRING ],
49594: STR
49595: PPUSH
49596: CALL_OW 561
// end ;
49600: GO 49494
49602: POP
49603: POP
// AddToLog ( ]; ) ;
49604: LD_STRING ];
49606: PPUSH
49607: CALL_OW 561
// end ;
49611: LD_VAR 0 2
49615: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49616: LD_INT 0
49618: PPUSH
49619: PPUSH
49620: PPUSH
49621: PPUSH
49622: PPUSH
// if not area or not rate or not max then
49623: LD_VAR 0 1
49627: NOT
49628: PUSH
49629: LD_VAR 0 2
49633: NOT
49634: OR
49635: PUSH
49636: LD_VAR 0 4
49640: NOT
49641: OR
49642: IFFALSE 49646
// exit ;
49644: GO 49835
// while 1 do
49646: LD_INT 1
49648: IFFALSE 49835
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49650: LD_ADDR_VAR 0 9
49654: PUSH
49655: LD_VAR 0 1
49659: PPUSH
49660: LD_INT 1
49662: PPUSH
49663: CALL_OW 287
49667: PUSH
49668: LD_INT 10
49670: MUL
49671: ST_TO_ADDR
// r := rate / 10 ;
49672: LD_ADDR_VAR 0 7
49676: PUSH
49677: LD_VAR 0 2
49681: PUSH
49682: LD_INT 10
49684: DIVREAL
49685: ST_TO_ADDR
// time := 1 1$00 ;
49686: LD_ADDR_VAR 0 8
49690: PUSH
49691: LD_INT 2100
49693: ST_TO_ADDR
// if amount < min then
49694: LD_VAR 0 9
49698: PUSH
49699: LD_VAR 0 3
49703: LESS
49704: IFFALSE 49722
// r := r * 2 else
49706: LD_ADDR_VAR 0 7
49710: PUSH
49711: LD_VAR 0 7
49715: PUSH
49716: LD_INT 2
49718: MUL
49719: ST_TO_ADDR
49720: GO 49748
// if amount > max then
49722: LD_VAR 0 9
49726: PUSH
49727: LD_VAR 0 4
49731: GREATER
49732: IFFALSE 49748
// r := r / 2 ;
49734: LD_ADDR_VAR 0 7
49738: PUSH
49739: LD_VAR 0 7
49743: PUSH
49744: LD_INT 2
49746: DIVREAL
49747: ST_TO_ADDR
// time := time / r ;
49748: LD_ADDR_VAR 0 8
49752: PUSH
49753: LD_VAR 0 8
49757: PUSH
49758: LD_VAR 0 7
49762: DIVREAL
49763: ST_TO_ADDR
// if time < 0 then
49764: LD_VAR 0 8
49768: PUSH
49769: LD_INT 0
49771: LESS
49772: IFFALSE 49789
// time := time * - 1 ;
49774: LD_ADDR_VAR 0 8
49778: PUSH
49779: LD_VAR 0 8
49783: PUSH
49784: LD_INT 1
49786: NEG
49787: MUL
49788: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
49789: LD_VAR 0 8
49793: PUSH
49794: LD_INT 35
49796: PPUSH
49797: LD_INT 875
49799: PPUSH
49800: CALL_OW 12
49804: PLUS
49805: PPUSH
49806: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49810: LD_INT 1
49812: PPUSH
49813: LD_INT 5
49815: PPUSH
49816: CALL_OW 12
49820: PPUSH
49821: LD_VAR 0 1
49825: PPUSH
49826: LD_INT 1
49828: PPUSH
49829: CALL_OW 55
// end ;
49833: GO 49646
// end ;
49835: LD_VAR 0 5
49839: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49840: LD_INT 0
49842: PPUSH
49843: PPUSH
49844: PPUSH
49845: PPUSH
49846: PPUSH
49847: PPUSH
49848: PPUSH
49849: PPUSH
// if not turrets or not factories then
49850: LD_VAR 0 1
49854: NOT
49855: PUSH
49856: LD_VAR 0 2
49860: NOT
49861: OR
49862: IFFALSE 49866
// exit ;
49864: GO 50173
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49866: LD_ADDR_VAR 0 10
49870: PUSH
49871: LD_INT 5
49873: PUSH
49874: LD_INT 6
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: PUSH
49881: LD_INT 2
49883: PUSH
49884: LD_INT 4
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: PUSH
49891: LD_INT 3
49893: PUSH
49894: LD_INT 5
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: LIST
49905: PUSH
49906: LD_INT 24
49908: PUSH
49909: LD_INT 25
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: PUSH
49916: LD_INT 23
49918: PUSH
49919: LD_INT 27
49921: PUSH
49922: EMPTY
49923: LIST
49924: LIST
49925: PUSH
49926: EMPTY
49927: LIST
49928: LIST
49929: PUSH
49930: LD_INT 42
49932: PUSH
49933: LD_INT 43
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: PUSH
49940: LD_INT 44
49942: PUSH
49943: LD_INT 46
49945: PUSH
49946: EMPTY
49947: LIST
49948: LIST
49949: PUSH
49950: LD_INT 45
49952: PUSH
49953: LD_INT 47
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: LIST
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: LIST
49969: ST_TO_ADDR
// result := [ ] ;
49970: LD_ADDR_VAR 0 3
49974: PUSH
49975: EMPTY
49976: ST_TO_ADDR
// for i in turrets do
49977: LD_ADDR_VAR 0 4
49981: PUSH
49982: LD_VAR 0 1
49986: PUSH
49987: FOR_IN
49988: IFFALSE 50171
// begin nat := GetNation ( i ) ;
49990: LD_ADDR_VAR 0 7
49994: PUSH
49995: LD_VAR 0 4
49999: PPUSH
50000: CALL_OW 248
50004: ST_TO_ADDR
// weapon := 0 ;
50005: LD_ADDR_VAR 0 8
50009: PUSH
50010: LD_INT 0
50012: ST_TO_ADDR
// if not nat then
50013: LD_VAR 0 7
50017: NOT
50018: IFFALSE 50022
// continue ;
50020: GO 49987
// for j in list [ nat ] do
50022: LD_ADDR_VAR 0 5
50026: PUSH
50027: LD_VAR 0 10
50031: PUSH
50032: LD_VAR 0 7
50036: ARRAY
50037: PUSH
50038: FOR_IN
50039: IFFALSE 50080
// if GetBWeapon ( i ) = j [ 1 ] then
50041: LD_VAR 0 4
50045: PPUSH
50046: CALL_OW 269
50050: PUSH
50051: LD_VAR 0 5
50055: PUSH
50056: LD_INT 1
50058: ARRAY
50059: EQUAL
50060: IFFALSE 50078
// begin weapon := j [ 2 ] ;
50062: LD_ADDR_VAR 0 8
50066: PUSH
50067: LD_VAR 0 5
50071: PUSH
50072: LD_INT 2
50074: ARRAY
50075: ST_TO_ADDR
// break ;
50076: GO 50080
// end ;
50078: GO 50038
50080: POP
50081: POP
// if not weapon then
50082: LD_VAR 0 8
50086: NOT
50087: IFFALSE 50091
// continue ;
50089: GO 49987
// for k in factories do
50091: LD_ADDR_VAR 0 6
50095: PUSH
50096: LD_VAR 0 2
50100: PUSH
50101: FOR_IN
50102: IFFALSE 50167
// begin weapons := AvailableWeaponList ( k ) ;
50104: LD_ADDR_VAR 0 9
50108: PUSH
50109: LD_VAR 0 6
50113: PPUSH
50114: CALL_OW 478
50118: ST_TO_ADDR
// if not weapons then
50119: LD_VAR 0 9
50123: NOT
50124: IFFALSE 50128
// continue ;
50126: GO 50101
// if weapon in weapons then
50128: LD_VAR 0 8
50132: PUSH
50133: LD_VAR 0 9
50137: IN
50138: IFFALSE 50165
// begin result := [ i , weapon ] ;
50140: LD_ADDR_VAR 0 3
50144: PUSH
50145: LD_VAR 0 4
50149: PUSH
50150: LD_VAR 0 8
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: ST_TO_ADDR
// exit ;
50159: POP
50160: POP
50161: POP
50162: POP
50163: GO 50173
// end ; end ;
50165: GO 50101
50167: POP
50168: POP
// end ;
50169: GO 49987
50171: POP
50172: POP
// end ;
50173: LD_VAR 0 3
50177: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50178: LD_INT 0
50180: PPUSH
// if not side or side > 8 then
50181: LD_VAR 0 3
50185: NOT
50186: PUSH
50187: LD_VAR 0 3
50191: PUSH
50192: LD_INT 8
50194: GREATER
50195: OR
50196: IFFALSE 50200
// exit ;
50198: GO 50259
// if not range then
50200: LD_VAR 0 4
50204: NOT
50205: IFFALSE 50216
// range := - 12 ;
50207: LD_ADDR_VAR 0 4
50211: PUSH
50212: LD_INT 12
50214: NEG
50215: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50216: LD_VAR 0 1
50220: PPUSH
50221: LD_VAR 0 2
50225: PPUSH
50226: LD_VAR 0 3
50230: PPUSH
50231: LD_VAR 0 4
50235: PPUSH
50236: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50240: LD_VAR 0 1
50244: PPUSH
50245: LD_VAR 0 2
50249: PPUSH
50250: LD_VAR 0 3
50254: PPUSH
50255: CALL_OW 331
// end ;
50259: LD_VAR 0 5
50263: RET
// export function Video ( mode ) ; begin
50264: LD_INT 0
50266: PPUSH
// ingame_video = mode ;
50267: LD_ADDR_OWVAR 52
50271: PUSH
50272: LD_VAR 0 1
50276: ST_TO_ADDR
// interface_hidden = mode ;
50277: LD_ADDR_OWVAR 54
50281: PUSH
50282: LD_VAR 0 1
50286: ST_TO_ADDR
// end ;
50287: LD_VAR 0 2
50291: RET
// export function Join ( array , element ) ; begin
50292: LD_INT 0
50294: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50295: LD_ADDR_VAR 0 3
50299: PUSH
50300: LD_VAR 0 1
50304: PPUSH
50305: LD_VAR 0 1
50309: PUSH
50310: LD_INT 1
50312: PLUS
50313: PPUSH
50314: LD_VAR 0 2
50318: PPUSH
50319: CALL_OW 1
50323: ST_TO_ADDR
// end ;
50324: LD_VAR 0 3
50328: RET
// export function JoinUnion ( array , element ) ; begin
50329: LD_INT 0
50331: PPUSH
// result := array union element ;
50332: LD_ADDR_VAR 0 3
50336: PUSH
50337: LD_VAR 0 1
50341: PUSH
50342: LD_VAR 0 2
50346: UNION
50347: ST_TO_ADDR
// end ;
50348: LD_VAR 0 3
50352: RET
// export function GetBehemoths ( side ) ; begin
50353: LD_INT 0
50355: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50356: LD_ADDR_VAR 0 2
50360: PUSH
50361: LD_INT 22
50363: PUSH
50364: LD_VAR 0 1
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 31
50375: PUSH
50376: LD_INT 25
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PPUSH
50387: CALL_OW 69
50391: ST_TO_ADDR
// end ;
50392: LD_VAR 0 2
50396: RET
// export function Shuffle ( array ) ; var i , index ; begin
50397: LD_INT 0
50399: PPUSH
50400: PPUSH
50401: PPUSH
// result := [ ] ;
50402: LD_ADDR_VAR 0 2
50406: PUSH
50407: EMPTY
50408: ST_TO_ADDR
// if not array then
50409: LD_VAR 0 1
50413: NOT
50414: IFFALSE 50418
// exit ;
50416: GO 50517
// Randomize ;
50418: CALL_OW 10
// for i = array downto 1 do
50422: LD_ADDR_VAR 0 3
50426: PUSH
50427: DOUBLE
50428: LD_VAR 0 1
50432: INC
50433: ST_TO_ADDR
50434: LD_INT 1
50436: PUSH
50437: FOR_DOWNTO
50438: IFFALSE 50515
// begin index := rand ( 1 , array ) ;
50440: LD_ADDR_VAR 0 4
50444: PUSH
50445: LD_INT 1
50447: PPUSH
50448: LD_VAR 0 1
50452: PPUSH
50453: CALL_OW 12
50457: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50458: LD_ADDR_VAR 0 2
50462: PUSH
50463: LD_VAR 0 2
50467: PPUSH
50468: LD_VAR 0 2
50472: PUSH
50473: LD_INT 1
50475: PLUS
50476: PPUSH
50477: LD_VAR 0 1
50481: PUSH
50482: LD_VAR 0 4
50486: ARRAY
50487: PPUSH
50488: CALL_OW 2
50492: ST_TO_ADDR
// array := Delete ( array , index ) ;
50493: LD_ADDR_VAR 0 1
50497: PUSH
50498: LD_VAR 0 1
50502: PPUSH
50503: LD_VAR 0 4
50507: PPUSH
50508: CALL_OW 3
50512: ST_TO_ADDR
// end ;
50513: GO 50437
50515: POP
50516: POP
// end ;
50517: LD_VAR 0 2
50521: RET
// export function GetBaseMaterials ( base ) ; begin
50522: LD_INT 0
50524: PPUSH
// result := [ 0 , 0 , 0 ] ;
50525: LD_ADDR_VAR 0 2
50529: PUSH
50530: LD_INT 0
50532: PUSH
50533: LD_INT 0
50535: PUSH
50536: LD_INT 0
50538: PUSH
50539: EMPTY
50540: LIST
50541: LIST
50542: LIST
50543: ST_TO_ADDR
// if not base then
50544: LD_VAR 0 1
50548: NOT
50549: IFFALSE 50553
// exit ;
50551: GO 50602
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50553: LD_ADDR_VAR 0 2
50557: PUSH
50558: LD_VAR 0 1
50562: PPUSH
50563: LD_INT 1
50565: PPUSH
50566: CALL_OW 275
50570: PUSH
50571: LD_VAR 0 1
50575: PPUSH
50576: LD_INT 2
50578: PPUSH
50579: CALL_OW 275
50583: PUSH
50584: LD_VAR 0 1
50588: PPUSH
50589: LD_INT 3
50591: PPUSH
50592: CALL_OW 275
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: LIST
50601: ST_TO_ADDR
// end ;
50602: LD_VAR 0 2
50606: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50607: LD_INT 0
50609: PPUSH
50610: PPUSH
// result := array ;
50611: LD_ADDR_VAR 0 3
50615: PUSH
50616: LD_VAR 0 1
50620: ST_TO_ADDR
// if size > 0 then
50621: LD_VAR 0 2
50625: PUSH
50626: LD_INT 0
50628: GREATER
50629: IFFALSE 50675
// for i := array downto size do
50631: LD_ADDR_VAR 0 4
50635: PUSH
50636: DOUBLE
50637: LD_VAR 0 1
50641: INC
50642: ST_TO_ADDR
50643: LD_VAR 0 2
50647: PUSH
50648: FOR_DOWNTO
50649: IFFALSE 50673
// result := Delete ( result , result ) ;
50651: LD_ADDR_VAR 0 3
50655: PUSH
50656: LD_VAR 0 3
50660: PPUSH
50661: LD_VAR 0 3
50665: PPUSH
50666: CALL_OW 3
50670: ST_TO_ADDR
50671: GO 50648
50673: POP
50674: POP
// end ;
50675: LD_VAR 0 3
50679: RET
// export function ComExit ( unit ) ; var tmp ; begin
50680: LD_INT 0
50682: PPUSH
50683: PPUSH
// if not IsInUnit ( unit ) then
50684: LD_VAR 0 1
50688: PPUSH
50689: CALL_OW 310
50693: NOT
50694: IFFALSE 50698
// exit ;
50696: GO 50758
// tmp := IsInUnit ( unit ) ;
50698: LD_ADDR_VAR 0 3
50702: PUSH
50703: LD_VAR 0 1
50707: PPUSH
50708: CALL_OW 310
50712: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50713: LD_VAR 0 3
50717: PPUSH
50718: CALL_OW 247
50722: PUSH
50723: LD_INT 2
50725: EQUAL
50726: IFFALSE 50739
// ComExitVehicle ( unit ) else
50728: LD_VAR 0 1
50732: PPUSH
50733: CALL_OW 121
50737: GO 50748
// ComExitBuilding ( unit ) ;
50739: LD_VAR 0 1
50743: PPUSH
50744: CALL_OW 122
// result := tmp ;
50748: LD_ADDR_VAR 0 2
50752: PUSH
50753: LD_VAR 0 3
50757: ST_TO_ADDR
// end ;
50758: LD_VAR 0 2
50762: RET
// export function ComExitAll ( units ) ; var i ; begin
50763: LD_INT 0
50765: PPUSH
50766: PPUSH
// if not units then
50767: LD_VAR 0 1
50771: NOT
50772: IFFALSE 50776
// exit ;
50774: GO 50802
// for i in units do
50776: LD_ADDR_VAR 0 3
50780: PUSH
50781: LD_VAR 0 1
50785: PUSH
50786: FOR_IN
50787: IFFALSE 50800
// ComExit ( i ) ;
50789: LD_VAR 0 3
50793: PPUSH
50794: CALL 50680 0 1
50798: GO 50786
50800: POP
50801: POP
// end ;
50802: LD_VAR 0 2
50806: RET
// export function ResetHc ; begin
50807: LD_INT 0
50809: PPUSH
// InitHc ;
50810: CALL_OW 19
// hc_importance := 0 ;
50814: LD_ADDR_OWVAR 32
50818: PUSH
50819: LD_INT 0
50821: ST_TO_ADDR
// end ;
50822: LD_VAR 0 1
50826: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50827: LD_INT 0
50829: PPUSH
50830: PPUSH
50831: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50832: LD_ADDR_VAR 0 6
50836: PUSH
50837: LD_VAR 0 1
50841: PUSH
50842: LD_VAR 0 3
50846: PLUS
50847: PUSH
50848: LD_INT 2
50850: DIV
50851: ST_TO_ADDR
// if _x < 0 then
50852: LD_VAR 0 6
50856: PUSH
50857: LD_INT 0
50859: LESS
50860: IFFALSE 50877
// _x := _x * - 1 ;
50862: LD_ADDR_VAR 0 6
50866: PUSH
50867: LD_VAR 0 6
50871: PUSH
50872: LD_INT 1
50874: NEG
50875: MUL
50876: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50877: LD_ADDR_VAR 0 7
50881: PUSH
50882: LD_VAR 0 2
50886: PUSH
50887: LD_VAR 0 4
50891: PLUS
50892: PUSH
50893: LD_INT 2
50895: DIV
50896: ST_TO_ADDR
// if _y < 0 then
50897: LD_VAR 0 7
50901: PUSH
50902: LD_INT 0
50904: LESS
50905: IFFALSE 50922
// _y := _y * - 1 ;
50907: LD_ADDR_VAR 0 7
50911: PUSH
50912: LD_VAR 0 7
50916: PUSH
50917: LD_INT 1
50919: NEG
50920: MUL
50921: ST_TO_ADDR
// result := [ _x , _y ] ;
50922: LD_ADDR_VAR 0 5
50926: PUSH
50927: LD_VAR 0 6
50931: PUSH
50932: LD_VAR 0 7
50936: PUSH
50937: EMPTY
50938: LIST
50939: LIST
50940: ST_TO_ADDR
// end ;
50941: LD_VAR 0 5
50945: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50946: LD_INT 0
50948: PPUSH
50949: PPUSH
50950: PPUSH
50951: PPUSH
// task := GetTaskList ( unit ) ;
50952: LD_ADDR_VAR 0 7
50956: PUSH
50957: LD_VAR 0 1
50961: PPUSH
50962: CALL_OW 437
50966: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50967: LD_VAR 0 7
50971: NOT
50972: PUSH
50973: LD_VAR 0 1
50977: PPUSH
50978: LD_VAR 0 2
50982: PPUSH
50983: CALL_OW 308
50987: NOT
50988: AND
50989: IFFALSE 50993
// exit ;
50991: GO 51111
// if IsInArea ( unit , area ) then
50993: LD_VAR 0 1
50997: PPUSH
50998: LD_VAR 0 2
51002: PPUSH
51003: CALL_OW 308
51007: IFFALSE 51025
// begin ComMoveToArea ( unit , goAway ) ;
51009: LD_VAR 0 1
51013: PPUSH
51014: LD_VAR 0 3
51018: PPUSH
51019: CALL_OW 113
// exit ;
51023: GO 51111
// end ; if task [ 1 ] [ 1 ] <> M then
51025: LD_VAR 0 7
51029: PUSH
51030: LD_INT 1
51032: ARRAY
51033: PUSH
51034: LD_INT 1
51036: ARRAY
51037: PUSH
51038: LD_STRING M
51040: NONEQUAL
51041: IFFALSE 51045
// exit ;
51043: GO 51111
// x := task [ 1 ] [ 2 ] ;
51045: LD_ADDR_VAR 0 5
51049: PUSH
51050: LD_VAR 0 7
51054: PUSH
51055: LD_INT 1
51057: ARRAY
51058: PUSH
51059: LD_INT 2
51061: ARRAY
51062: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51063: LD_ADDR_VAR 0 6
51067: PUSH
51068: LD_VAR 0 7
51072: PUSH
51073: LD_INT 1
51075: ARRAY
51076: PUSH
51077: LD_INT 3
51079: ARRAY
51080: ST_TO_ADDR
// if InArea ( x , y , area ) then
51081: LD_VAR 0 5
51085: PPUSH
51086: LD_VAR 0 6
51090: PPUSH
51091: LD_VAR 0 2
51095: PPUSH
51096: CALL_OW 309
51100: IFFALSE 51111
// ComStop ( unit ) ;
51102: LD_VAR 0 1
51106: PPUSH
51107: CALL_OW 141
// end ;
51111: LD_VAR 0 4
51115: RET
// export function Abs ( value ) ; begin
51116: LD_INT 0
51118: PPUSH
// result := value ;
51119: LD_ADDR_VAR 0 2
51123: PUSH
51124: LD_VAR 0 1
51128: ST_TO_ADDR
// if value < 0 then
51129: LD_VAR 0 1
51133: PUSH
51134: LD_INT 0
51136: LESS
51137: IFFALSE 51154
// result := value * - 1 ;
51139: LD_ADDR_VAR 0 2
51143: PUSH
51144: LD_VAR 0 1
51148: PUSH
51149: LD_INT 1
51151: NEG
51152: MUL
51153: ST_TO_ADDR
// end ;
51154: LD_VAR 0 2
51158: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51159: LD_INT 0
51161: PPUSH
51162: PPUSH
51163: PPUSH
51164: PPUSH
51165: PPUSH
51166: PPUSH
51167: PPUSH
51168: PPUSH
// if not unit or not building then
51169: LD_VAR 0 1
51173: NOT
51174: PUSH
51175: LD_VAR 0 2
51179: NOT
51180: OR
51181: IFFALSE 51185
// exit ;
51183: GO 51411
// x := GetX ( building ) ;
51185: LD_ADDR_VAR 0 4
51189: PUSH
51190: LD_VAR 0 2
51194: PPUSH
51195: CALL_OW 250
51199: ST_TO_ADDR
// y := GetY ( building ) ;
51200: LD_ADDR_VAR 0 6
51204: PUSH
51205: LD_VAR 0 2
51209: PPUSH
51210: CALL_OW 251
51214: ST_TO_ADDR
// d := GetDir ( building ) ;
51215: LD_ADDR_VAR 0 8
51219: PUSH
51220: LD_VAR 0 2
51224: PPUSH
51225: CALL_OW 254
51229: ST_TO_ADDR
// r := 4 ;
51230: LD_ADDR_VAR 0 9
51234: PUSH
51235: LD_INT 4
51237: ST_TO_ADDR
// for i := 1 to 5 do
51238: LD_ADDR_VAR 0 10
51242: PUSH
51243: DOUBLE
51244: LD_INT 1
51246: DEC
51247: ST_TO_ADDR
51248: LD_INT 5
51250: PUSH
51251: FOR_TO
51252: IFFALSE 51409
// begin _x := ShiftX ( x , d , r + i ) ;
51254: LD_ADDR_VAR 0 5
51258: PUSH
51259: LD_VAR 0 4
51263: PPUSH
51264: LD_VAR 0 8
51268: PPUSH
51269: LD_VAR 0 9
51273: PUSH
51274: LD_VAR 0 10
51278: PLUS
51279: PPUSH
51280: CALL_OW 272
51284: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51285: LD_ADDR_VAR 0 7
51289: PUSH
51290: LD_VAR 0 6
51294: PPUSH
51295: LD_VAR 0 8
51299: PPUSH
51300: LD_VAR 0 9
51304: PUSH
51305: LD_VAR 0 10
51309: PLUS
51310: PPUSH
51311: CALL_OW 273
51315: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51316: LD_VAR 0 5
51320: PPUSH
51321: LD_VAR 0 7
51325: PPUSH
51326: CALL_OW 488
51330: PUSH
51331: LD_VAR 0 5
51335: PPUSH
51336: LD_VAR 0 7
51340: PPUSH
51341: CALL_OW 428
51345: PPUSH
51346: CALL_OW 247
51350: PUSH
51351: LD_INT 3
51353: PUSH
51354: LD_INT 2
51356: PUSH
51357: EMPTY
51358: LIST
51359: LIST
51360: IN
51361: NOT
51362: AND
51363: IFFALSE 51407
// begin ComMoveXY ( unit , _x , _y ) ;
51365: LD_VAR 0 1
51369: PPUSH
51370: LD_VAR 0 5
51374: PPUSH
51375: LD_VAR 0 7
51379: PPUSH
51380: CALL_OW 111
// result := [ _x , _y ] ;
51384: LD_ADDR_VAR 0 3
51388: PUSH
51389: LD_VAR 0 5
51393: PUSH
51394: LD_VAR 0 7
51398: PUSH
51399: EMPTY
51400: LIST
51401: LIST
51402: ST_TO_ADDR
// exit ;
51403: POP
51404: POP
51405: GO 51411
// end ; end ;
51407: GO 51251
51409: POP
51410: POP
// end ;
51411: LD_VAR 0 3
51415: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51416: LD_INT 0
51418: PPUSH
51419: PPUSH
51420: PPUSH
// result := 0 ;
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_INT 0
51428: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51429: LD_VAR 0 1
51433: PUSH
51434: LD_INT 0
51436: LESS
51437: PUSH
51438: LD_VAR 0 1
51442: PUSH
51443: LD_INT 8
51445: GREATER
51446: OR
51447: PUSH
51448: LD_VAR 0 2
51452: PUSH
51453: LD_INT 0
51455: LESS
51456: OR
51457: PUSH
51458: LD_VAR 0 2
51462: PUSH
51463: LD_INT 8
51465: GREATER
51466: OR
51467: IFFALSE 51471
// exit ;
51469: GO 51546
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51471: LD_ADDR_VAR 0 4
51475: PUSH
51476: LD_INT 22
51478: PUSH
51479: LD_VAR 0 2
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: PPUSH
51488: CALL_OW 69
51492: PUSH
51493: FOR_IN
51494: IFFALSE 51544
// begin un := UnitShoot ( i ) ;
51496: LD_ADDR_VAR 0 5
51500: PUSH
51501: LD_VAR 0 4
51505: PPUSH
51506: CALL_OW 504
51510: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51511: LD_VAR 0 5
51515: PPUSH
51516: CALL_OW 255
51520: PUSH
51521: LD_VAR 0 1
51525: EQUAL
51526: IFFALSE 51542
// begin result := un ;
51528: LD_ADDR_VAR 0 3
51532: PUSH
51533: LD_VAR 0 5
51537: ST_TO_ADDR
// exit ;
51538: POP
51539: POP
51540: GO 51546
// end ; end ;
51542: GO 51493
51544: POP
51545: POP
// end ;
51546: LD_VAR 0 3
51550: RET
// export function GetCargoBay ( units ) ; begin
51551: LD_INT 0
51553: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51554: LD_ADDR_VAR 0 2
51558: PUSH
51559: LD_VAR 0 1
51563: PPUSH
51564: LD_INT 2
51566: PUSH
51567: LD_INT 34
51569: PUSH
51570: LD_INT 12
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PUSH
51577: LD_INT 34
51579: PUSH
51580: LD_INT 51
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: PUSH
51587: LD_INT 34
51589: PUSH
51590: LD_INT 32
51592: PUSH
51593: EMPTY
51594: LIST
51595: LIST
51596: PUSH
51597: LD_INT 34
51599: PUSH
51600: LD_EXP 49
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: PUSH
51609: EMPTY
51610: LIST
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: PPUSH
51616: CALL_OW 72
51620: ST_TO_ADDR
// end ;
51621: LD_VAR 0 2
51625: RET
// export function Negate ( value ) ; begin
51626: LD_INT 0
51628: PPUSH
// result := not value ;
51629: LD_ADDR_VAR 0 2
51633: PUSH
51634: LD_VAR 0 1
51638: NOT
51639: ST_TO_ADDR
// end ;
51640: LD_VAR 0 2
51644: RET
// export function Inc ( value ) ; begin
51645: LD_INT 0
51647: PPUSH
// result := value + 1 ;
51648: LD_ADDR_VAR 0 2
51652: PUSH
51653: LD_VAR 0 1
51657: PUSH
51658: LD_INT 1
51660: PLUS
51661: ST_TO_ADDR
// end ;
51662: LD_VAR 0 2
51666: RET
// export function Dec ( value ) ; begin
51667: LD_INT 0
51669: PPUSH
// result := value - 1 ;
51670: LD_ADDR_VAR 0 2
51674: PUSH
51675: LD_VAR 0 1
51679: PUSH
51680: LD_INT 1
51682: MINUS
51683: ST_TO_ADDR
// end ;
51684: LD_VAR 0 2
51688: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
51698: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
51699: LD_VAR 0 1
51703: PPUSH
51704: LD_VAR 0 2
51708: PPUSH
51709: CALL_OW 488
51713: NOT
51714: PUSH
51715: LD_VAR 0 3
51719: PPUSH
51720: LD_VAR 0 4
51724: PPUSH
51725: CALL_OW 488
51729: NOT
51730: OR
51731: IFFALSE 51744
// begin result := - 1 ;
51733: LD_ADDR_VAR 0 5
51737: PUSH
51738: LD_INT 1
51740: NEG
51741: ST_TO_ADDR
// exit ;
51742: GO 51979
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
51744: LD_ADDR_VAR 0 12
51748: PUSH
51749: LD_VAR 0 1
51753: PPUSH
51754: LD_VAR 0 2
51758: PPUSH
51759: LD_VAR 0 3
51763: PPUSH
51764: LD_VAR 0 4
51768: PPUSH
51769: CALL 50827 0 4
51773: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
51774: LD_ADDR_VAR 0 11
51778: PUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: LD_VAR 0 2
51788: PPUSH
51789: LD_VAR 0 12
51793: PUSH
51794: LD_INT 1
51796: ARRAY
51797: PPUSH
51798: LD_VAR 0 12
51802: PUSH
51803: LD_INT 2
51805: ARRAY
51806: PPUSH
51807: CALL_OW 298
51811: ST_TO_ADDR
// distance := 9999 ;
51812: LD_ADDR_VAR 0 10
51816: PUSH
51817: LD_INT 9999
51819: ST_TO_ADDR
// for i := 0 to 5 do
51820: LD_ADDR_VAR 0 6
51824: PUSH
51825: DOUBLE
51826: LD_INT 0
51828: DEC
51829: ST_TO_ADDR
51830: LD_INT 5
51832: PUSH
51833: FOR_TO
51834: IFFALSE 51977
// begin _x := ShiftX ( x1 , i , centerDist ) ;
51836: LD_ADDR_VAR 0 7
51840: PUSH
51841: LD_VAR 0 1
51845: PPUSH
51846: LD_VAR 0 6
51850: PPUSH
51851: LD_VAR 0 11
51855: PPUSH
51856: CALL_OW 272
51860: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
51861: LD_ADDR_VAR 0 8
51865: PUSH
51866: LD_VAR 0 2
51870: PPUSH
51871: LD_VAR 0 6
51875: PPUSH
51876: LD_VAR 0 11
51880: PPUSH
51881: CALL_OW 273
51885: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51886: LD_VAR 0 7
51890: PPUSH
51891: LD_VAR 0 8
51895: PPUSH
51896: CALL_OW 488
51900: NOT
51901: IFFALSE 51905
// continue ;
51903: GO 51833
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
51905: LD_ADDR_VAR 0 9
51909: PUSH
51910: LD_VAR 0 12
51914: PUSH
51915: LD_INT 1
51917: ARRAY
51918: PPUSH
51919: LD_VAR 0 12
51923: PUSH
51924: LD_INT 2
51926: ARRAY
51927: PPUSH
51928: LD_VAR 0 7
51932: PPUSH
51933: LD_VAR 0 8
51937: PPUSH
51938: CALL_OW 298
51942: ST_TO_ADDR
// if tmp < distance then
51943: LD_VAR 0 9
51947: PUSH
51948: LD_VAR 0 10
51952: LESS
51953: IFFALSE 51975
// begin result := i ;
51955: LD_ADDR_VAR 0 5
51959: PUSH
51960: LD_VAR 0 6
51964: ST_TO_ADDR
// distance := tmp ;
51965: LD_ADDR_VAR 0 10
51969: PUSH
51970: LD_VAR 0 9
51974: ST_TO_ADDR
// end ; end ;
51975: GO 51833
51977: POP
51978: POP
// end ;
51979: LD_VAR 0 5
51983: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51984: LD_INT 0
51986: PPUSH
51987: PPUSH
// if not driver or not IsInUnit ( driver ) then
51988: LD_VAR 0 1
51992: NOT
51993: PUSH
51994: LD_VAR 0 1
51998: PPUSH
51999: CALL_OW 310
52003: NOT
52004: OR
52005: IFFALSE 52009
// exit ;
52007: GO 52099
// vehicle := IsInUnit ( driver ) ;
52009: LD_ADDR_VAR 0 3
52013: PUSH
52014: LD_VAR 0 1
52018: PPUSH
52019: CALL_OW 310
52023: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52024: LD_VAR 0 1
52028: PPUSH
52029: LD_STRING \
52031: PUSH
52032: LD_INT 0
52034: PUSH
52035: LD_INT 0
52037: PUSH
52038: LD_INT 0
52040: PUSH
52041: LD_INT 0
52043: PUSH
52044: LD_INT 0
52046: PUSH
52047: LD_INT 0
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: LIST
52057: LIST
52058: PUSH
52059: LD_STRING E
52061: PUSH
52062: LD_INT 0
52064: PUSH
52065: LD_INT 0
52067: PUSH
52068: LD_VAR 0 3
52072: PUSH
52073: LD_INT 0
52075: PUSH
52076: LD_INT 0
52078: PUSH
52079: LD_INT 0
52081: PUSH
52082: EMPTY
52083: LIST
52084: LIST
52085: LIST
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PPUSH
52095: CALL_OW 446
// end ;
52099: LD_VAR 0 2
52103: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52104: LD_INT 0
52106: PPUSH
52107: PPUSH
// if not driver or not IsInUnit ( driver ) then
52108: LD_VAR 0 1
52112: NOT
52113: PUSH
52114: LD_VAR 0 1
52118: PPUSH
52119: CALL_OW 310
52123: NOT
52124: OR
52125: IFFALSE 52129
// exit ;
52127: GO 52219
// vehicle := IsInUnit ( driver ) ;
52129: LD_ADDR_VAR 0 3
52133: PUSH
52134: LD_VAR 0 1
52138: PPUSH
52139: CALL_OW 310
52143: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52144: LD_VAR 0 1
52148: PPUSH
52149: LD_STRING \
52151: PUSH
52152: LD_INT 0
52154: PUSH
52155: LD_INT 0
52157: PUSH
52158: LD_INT 0
52160: PUSH
52161: LD_INT 0
52163: PUSH
52164: LD_INT 0
52166: PUSH
52167: LD_INT 0
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: LIST
52178: PUSH
52179: LD_STRING E
52181: PUSH
52182: LD_INT 0
52184: PUSH
52185: LD_INT 0
52187: PUSH
52188: LD_VAR 0 3
52192: PUSH
52193: LD_INT 0
52195: PUSH
52196: LD_INT 0
52198: PUSH
52199: LD_INT 0
52201: PUSH
52202: EMPTY
52203: LIST
52204: LIST
52205: LIST
52206: LIST
52207: LIST
52208: LIST
52209: LIST
52210: PUSH
52211: EMPTY
52212: LIST
52213: LIST
52214: PPUSH
52215: CALL_OW 447
// end ;
52219: LD_VAR 0 2
52223: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52224: LD_INT 0
52226: PPUSH
52227: PPUSH
52228: PPUSH
// tmp := [ ] ;
52229: LD_ADDR_VAR 0 5
52233: PUSH
52234: EMPTY
52235: ST_TO_ADDR
// for i in units do
52236: LD_ADDR_VAR 0 4
52240: PUSH
52241: LD_VAR 0 1
52245: PUSH
52246: FOR_IN
52247: IFFALSE 52285
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52249: LD_ADDR_VAR 0 5
52253: PUSH
52254: LD_VAR 0 5
52258: PPUSH
52259: LD_VAR 0 5
52263: PUSH
52264: LD_INT 1
52266: PLUS
52267: PPUSH
52268: LD_VAR 0 4
52272: PPUSH
52273: CALL_OW 256
52277: PPUSH
52278: CALL_OW 2
52282: ST_TO_ADDR
52283: GO 52246
52285: POP
52286: POP
// if not tmp then
52287: LD_VAR 0 5
52291: NOT
52292: IFFALSE 52296
// exit ;
52294: GO 52344
// if asc then
52296: LD_VAR 0 2
52300: IFFALSE 52324
// result := SortListByListAsc ( units , tmp ) else
52302: LD_ADDR_VAR 0 3
52306: PUSH
52307: LD_VAR 0 1
52311: PPUSH
52312: LD_VAR 0 5
52316: PPUSH
52317: CALL_OW 76
52321: ST_TO_ADDR
52322: GO 52344
// result := SortListByListDesc ( units , tmp ) ;
52324: LD_ADDR_VAR 0 3
52328: PUSH
52329: LD_VAR 0 1
52333: PPUSH
52334: LD_VAR 0 5
52338: PPUSH
52339: CALL_OW 77
52343: ST_TO_ADDR
// end ;
52344: LD_VAR 0 3
52348: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
52349: LD_INT 0
52351: PPUSH
52352: PPUSH
// task := GetTaskList ( mech ) ;
52353: LD_ADDR_VAR 0 4
52357: PUSH
52358: LD_VAR 0 1
52362: PPUSH
52363: CALL_OW 437
52367: ST_TO_ADDR
// if not task then
52368: LD_VAR 0 4
52372: NOT
52373: IFFALSE 52377
// exit ;
52375: GO 52419
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
52377: LD_ADDR_VAR 0 3
52381: PUSH
52382: LD_VAR 0 4
52386: PUSH
52387: LD_INT 1
52389: ARRAY
52390: PUSH
52391: LD_INT 1
52393: ARRAY
52394: PUSH
52395: LD_STRING r
52397: EQUAL
52398: PUSH
52399: LD_VAR 0 4
52403: PUSH
52404: LD_INT 1
52406: ARRAY
52407: PUSH
52408: LD_INT 4
52410: ARRAY
52411: PUSH
52412: LD_VAR 0 2
52416: EQUAL
52417: AND
52418: ST_TO_ADDR
// end ;
52419: LD_VAR 0 3
52423: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
52424: LD_INT 0
52426: PPUSH
// SetDir ( unit , d ) ;
52427: LD_VAR 0 1
52431: PPUSH
52432: LD_VAR 0 4
52436: PPUSH
52437: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
52441: LD_VAR 0 1
52445: PPUSH
52446: LD_VAR 0 2
52450: PPUSH
52451: LD_VAR 0 3
52455: PPUSH
52456: LD_VAR 0 5
52460: PPUSH
52461: CALL_OW 48
// end ;
52465: LD_VAR 0 6
52469: RET
// export function ToNaturalNumber ( number ) ; begin
52470: LD_INT 0
52472: PPUSH
// result := number div 1 ;
52473: LD_ADDR_VAR 0 2
52477: PUSH
52478: LD_VAR 0 1
52482: PUSH
52483: LD_INT 1
52485: DIV
52486: ST_TO_ADDR
// if number < 0 then
52487: LD_VAR 0 1
52491: PUSH
52492: LD_INT 0
52494: LESS
52495: IFFALSE 52505
// result := 0 ;
52497: LD_ADDR_VAR 0 2
52501: PUSH
52502: LD_INT 0
52504: ST_TO_ADDR
// end ;
52505: LD_VAR 0 2
52509: RET
// export function SortByClass ( units , class ) ; var un ; begin
52510: LD_INT 0
52512: PPUSH
52513: PPUSH
// if not units or not class then
52514: LD_VAR 0 1
52518: NOT
52519: PUSH
52520: LD_VAR 0 2
52524: NOT
52525: OR
52526: IFFALSE 52530
// exit ;
52528: GO 52625
// result := [ ] ;
52530: LD_ADDR_VAR 0 3
52534: PUSH
52535: EMPTY
52536: ST_TO_ADDR
// for un in units do
52537: LD_ADDR_VAR 0 4
52541: PUSH
52542: LD_VAR 0 1
52546: PUSH
52547: FOR_IN
52548: IFFALSE 52623
// if GetClass ( un ) = class then
52550: LD_VAR 0 4
52554: PPUSH
52555: CALL_OW 257
52559: PUSH
52560: LD_VAR 0 2
52564: EQUAL
52565: IFFALSE 52592
// result := Insert ( result , 1 , un ) else
52567: LD_ADDR_VAR 0 3
52571: PUSH
52572: LD_VAR 0 3
52576: PPUSH
52577: LD_INT 1
52579: PPUSH
52580: LD_VAR 0 4
52584: PPUSH
52585: CALL_OW 2
52589: ST_TO_ADDR
52590: GO 52621
// result := Replace ( result , result + 1 , un ) ;
52592: LD_ADDR_VAR 0 3
52596: PUSH
52597: LD_VAR 0 3
52601: PPUSH
52602: LD_VAR 0 3
52606: PUSH
52607: LD_INT 1
52609: PLUS
52610: PPUSH
52611: LD_VAR 0 4
52615: PPUSH
52616: CALL_OW 1
52620: ST_TO_ADDR
52621: GO 52547
52623: POP
52624: POP
// end ;
52625: LD_VAR 0 3
52629: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
52630: LD_INT 0
52632: PPUSH
52633: PPUSH
52634: PPUSH
52635: PPUSH
52636: PPUSH
52637: PPUSH
52638: PPUSH
// result := [ ] ;
52639: LD_ADDR_VAR 0 4
52643: PUSH
52644: EMPTY
52645: ST_TO_ADDR
// if x - r < 0 then
52646: LD_VAR 0 1
52650: PUSH
52651: LD_VAR 0 3
52655: MINUS
52656: PUSH
52657: LD_INT 0
52659: LESS
52660: IFFALSE 52672
// min_x := 0 else
52662: LD_ADDR_VAR 0 8
52666: PUSH
52667: LD_INT 0
52669: ST_TO_ADDR
52670: GO 52688
// min_x := x - r ;
52672: LD_ADDR_VAR 0 8
52676: PUSH
52677: LD_VAR 0 1
52681: PUSH
52682: LD_VAR 0 3
52686: MINUS
52687: ST_TO_ADDR
// if y - r < 0 then
52688: LD_VAR 0 2
52692: PUSH
52693: LD_VAR 0 3
52697: MINUS
52698: PUSH
52699: LD_INT 0
52701: LESS
52702: IFFALSE 52714
// min_y := 0 else
52704: LD_ADDR_VAR 0 7
52708: PUSH
52709: LD_INT 0
52711: ST_TO_ADDR
52712: GO 52730
// min_y := y - r ;
52714: LD_ADDR_VAR 0 7
52718: PUSH
52719: LD_VAR 0 2
52723: PUSH
52724: LD_VAR 0 3
52728: MINUS
52729: ST_TO_ADDR
// max_x := x + r ;
52730: LD_ADDR_VAR 0 9
52734: PUSH
52735: LD_VAR 0 1
52739: PUSH
52740: LD_VAR 0 3
52744: PLUS
52745: ST_TO_ADDR
// max_y := y + r ;
52746: LD_ADDR_VAR 0 10
52750: PUSH
52751: LD_VAR 0 2
52755: PUSH
52756: LD_VAR 0 3
52760: PLUS
52761: ST_TO_ADDR
// for _x = min_x to max_x do
52762: LD_ADDR_VAR 0 5
52766: PUSH
52767: DOUBLE
52768: LD_VAR 0 8
52772: DEC
52773: ST_TO_ADDR
52774: LD_VAR 0 9
52778: PUSH
52779: FOR_TO
52780: IFFALSE 52881
// for _y = min_y to max_y do
52782: LD_ADDR_VAR 0 6
52786: PUSH
52787: DOUBLE
52788: LD_VAR 0 7
52792: DEC
52793: ST_TO_ADDR
52794: LD_VAR 0 10
52798: PUSH
52799: FOR_TO
52800: IFFALSE 52877
// begin if not ValidHex ( _x , _y ) then
52802: LD_VAR 0 5
52806: PPUSH
52807: LD_VAR 0 6
52811: PPUSH
52812: CALL_OW 488
52816: NOT
52817: IFFALSE 52821
// continue ;
52819: GO 52799
// if GetResourceTypeXY ( _x , _y ) then
52821: LD_VAR 0 5
52825: PPUSH
52826: LD_VAR 0 6
52830: PPUSH
52831: CALL_OW 283
52835: IFFALSE 52875
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52837: LD_ADDR_VAR 0 4
52841: PUSH
52842: LD_VAR 0 4
52846: PPUSH
52847: LD_VAR 0 4
52851: PUSH
52852: LD_INT 1
52854: PLUS
52855: PPUSH
52856: LD_VAR 0 5
52860: PUSH
52861: LD_VAR 0 6
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PPUSH
52870: CALL_OW 1
52874: ST_TO_ADDR
// end ;
52875: GO 52799
52877: POP
52878: POP
52879: GO 52779
52881: POP
52882: POP
// end ;
52883: LD_VAR 0 4
52887: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
52888: LD_INT 0
52890: PPUSH
52891: PPUSH
52892: PPUSH
52893: PPUSH
52894: PPUSH
52895: PPUSH
52896: PPUSH
52897: PPUSH
// if not units then
52898: LD_VAR 0 1
52902: NOT
52903: IFFALSE 52907
// exit ;
52905: GO 53332
// result := UnitFilter ( units , [ f_ok ] ) ;
52907: LD_ADDR_VAR 0 3
52911: PUSH
52912: LD_VAR 0 1
52916: PPUSH
52917: LD_INT 50
52919: PUSH
52920: EMPTY
52921: LIST
52922: PPUSH
52923: CALL_OW 72
52927: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52928: LD_ADDR_VAR 0 8
52932: PUSH
52933: LD_VAR 0 1
52937: PUSH
52938: LD_INT 1
52940: ARRAY
52941: PPUSH
52942: CALL_OW 255
52946: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
52947: LD_ADDR_VAR 0 10
52951: PUSH
52952: LD_INT 29
52954: PUSH
52955: LD_EXP 52
52959: PUSH
52960: EMPTY
52961: LIST
52962: LIST
52963: ST_TO_ADDR
// if not result then
52964: LD_VAR 0 3
52968: NOT
52969: IFFALSE 52973
// exit ;
52971: GO 53332
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
52973: LD_ADDR_VAR 0 5
52977: PUSH
52978: LD_INT 81
52980: PUSH
52981: LD_VAR 0 8
52985: PUSH
52986: EMPTY
52987: LIST
52988: LIST
52989: PPUSH
52990: CALL_OW 69
52994: ST_TO_ADDR
// for i in result do
52995: LD_ADDR_VAR 0 4
52999: PUSH
53000: LD_VAR 0 3
53004: PUSH
53005: FOR_IN
53006: IFFALSE 53330
// begin tag := GetTag ( i ) + 1 ;
53008: LD_ADDR_VAR 0 9
53012: PUSH
53013: LD_VAR 0 4
53017: PPUSH
53018: CALL_OW 110
53022: PUSH
53023: LD_INT 1
53025: PLUS
53026: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53027: LD_ADDR_VAR 0 7
53031: PUSH
53032: LD_VAR 0 4
53036: PPUSH
53037: CALL_OW 250
53041: PPUSH
53042: LD_VAR 0 4
53046: PPUSH
53047: CALL_OW 251
53051: PPUSH
53052: LD_INT 6
53054: PPUSH
53055: CALL 52630 0 3
53059: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53060: LD_VAR 0 7
53064: PUSH
53065: LD_VAR 0 4
53069: PPUSH
53070: CALL_OW 264
53074: PUSH
53075: LD_VAR 0 10
53079: IN
53080: NOT
53081: AND
53082: IFFALSE 53121
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53084: LD_VAR 0 4
53088: PPUSH
53089: LD_VAR 0 7
53093: PUSH
53094: LD_INT 1
53096: ARRAY
53097: PUSH
53098: LD_INT 1
53100: ARRAY
53101: PPUSH
53102: LD_VAR 0 7
53106: PUSH
53107: LD_INT 1
53109: ARRAY
53110: PUSH
53111: LD_INT 2
53113: ARRAY
53114: PPUSH
53115: CALL_OW 116
53119: GO 53328
// if path > tag then
53121: LD_VAR 0 2
53125: PUSH
53126: LD_VAR 0 9
53130: GREATER
53131: IFFALSE 53298
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
53133: LD_ADDR_VAR 0 6
53137: PUSH
53138: LD_VAR 0 5
53142: PPUSH
53143: LD_INT 91
53145: PUSH
53146: LD_VAR 0 4
53150: PUSH
53151: LD_INT 12
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: LIST
53158: PPUSH
53159: CALL_OW 72
53163: ST_TO_ADDR
// if nearEnemy then
53164: LD_VAR 0 6
53168: IFFALSE 53196
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53170: LD_VAR 0 4
53174: PPUSH
53175: LD_VAR 0 6
53179: PPUSH
53180: LD_VAR 0 4
53184: PPUSH
53185: CALL_OW 74
53189: PPUSH
53190: CALL_OW 115
53194: GO 53296
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53196: LD_VAR 0 4
53200: PPUSH
53201: LD_VAR 0 2
53205: PUSH
53206: LD_VAR 0 9
53210: ARRAY
53211: PUSH
53212: LD_INT 1
53214: ARRAY
53215: PPUSH
53216: LD_VAR 0 2
53220: PUSH
53221: LD_VAR 0 9
53225: ARRAY
53226: PUSH
53227: LD_INT 2
53229: ARRAY
53230: PPUSH
53231: CALL_OW 297
53235: PUSH
53236: LD_INT 6
53238: GREATER
53239: IFFALSE 53282
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
53241: LD_VAR 0 4
53245: PPUSH
53246: LD_VAR 0 2
53250: PUSH
53251: LD_VAR 0 9
53255: ARRAY
53256: PUSH
53257: LD_INT 1
53259: ARRAY
53260: PPUSH
53261: LD_VAR 0 2
53265: PUSH
53266: LD_VAR 0 9
53270: ARRAY
53271: PUSH
53272: LD_INT 2
53274: ARRAY
53275: PPUSH
53276: CALL_OW 114
53280: GO 53296
// SetTag ( i , tag ) ;
53282: LD_VAR 0 4
53286: PPUSH
53287: LD_VAR 0 9
53291: PPUSH
53292: CALL_OW 109
// end else
53296: GO 53328
// if enemy then
53298: LD_VAR 0 5
53302: IFFALSE 53328
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
53304: LD_VAR 0 4
53308: PPUSH
53309: LD_VAR 0 5
53313: PPUSH
53314: LD_VAR 0 4
53318: PPUSH
53319: CALL_OW 74
53323: PPUSH
53324: CALL_OW 115
// end ;
53328: GO 53005
53330: POP
53331: POP
// end ;
53332: LD_VAR 0 3
53336: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
53337: LD_INT 0
53339: PPUSH
53340: PPUSH
53341: PPUSH
// if not unit or IsInUnit ( unit ) then
53342: LD_VAR 0 1
53346: NOT
53347: PUSH
53348: LD_VAR 0 1
53352: PPUSH
53353: CALL_OW 310
53357: OR
53358: IFFALSE 53362
// exit ;
53360: GO 53453
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
53362: LD_ADDR_VAR 0 4
53366: PUSH
53367: LD_VAR 0 1
53371: PPUSH
53372: CALL_OW 250
53376: PPUSH
53377: LD_VAR 0 2
53381: PPUSH
53382: LD_INT 1
53384: PPUSH
53385: CALL_OW 272
53389: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
53390: LD_ADDR_VAR 0 5
53394: PUSH
53395: LD_VAR 0 1
53399: PPUSH
53400: CALL_OW 251
53404: PPUSH
53405: LD_VAR 0 2
53409: PPUSH
53410: LD_INT 1
53412: PPUSH
53413: CALL_OW 273
53417: ST_TO_ADDR
// if ValidHex ( x , y ) then
53418: LD_VAR 0 4
53422: PPUSH
53423: LD_VAR 0 5
53427: PPUSH
53428: CALL_OW 488
53432: IFFALSE 53453
// ComTurnXY ( unit , x , y ) ;
53434: LD_VAR 0 1
53438: PPUSH
53439: LD_VAR 0 4
53443: PPUSH
53444: LD_VAR 0 5
53448: PPUSH
53449: CALL_OW 118
// end ;
53453: LD_VAR 0 3
53457: RET
// export function SeeUnits ( side , units ) ; var i ; begin
53458: LD_INT 0
53460: PPUSH
53461: PPUSH
// result := false ;
53462: LD_ADDR_VAR 0 3
53466: PUSH
53467: LD_INT 0
53469: ST_TO_ADDR
// if not units then
53470: LD_VAR 0 2
53474: NOT
53475: IFFALSE 53479
// exit ;
53477: GO 53524
// for i in units do
53479: LD_ADDR_VAR 0 4
53483: PUSH
53484: LD_VAR 0 2
53488: PUSH
53489: FOR_IN
53490: IFFALSE 53522
// if See ( side , i ) then
53492: LD_VAR 0 1
53496: PPUSH
53497: LD_VAR 0 4
53501: PPUSH
53502: CALL_OW 292
53506: IFFALSE 53520
// begin result := true ;
53508: LD_ADDR_VAR 0 3
53512: PUSH
53513: LD_INT 1
53515: ST_TO_ADDR
// exit ;
53516: POP
53517: POP
53518: GO 53524
// end ;
53520: GO 53489
53522: POP
53523: POP
// end ;
53524: LD_VAR 0 3
53528: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
53529: LD_INT 0
53531: PPUSH
53532: PPUSH
53533: PPUSH
53534: PPUSH
// if not unit or not points then
53535: LD_VAR 0 1
53539: NOT
53540: PUSH
53541: LD_VAR 0 2
53545: NOT
53546: OR
53547: IFFALSE 53551
// exit ;
53549: GO 53641
// dist := 99999 ;
53551: LD_ADDR_VAR 0 5
53555: PUSH
53556: LD_INT 99999
53558: ST_TO_ADDR
// for i in points do
53559: LD_ADDR_VAR 0 4
53563: PUSH
53564: LD_VAR 0 2
53568: PUSH
53569: FOR_IN
53570: IFFALSE 53639
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
53572: LD_ADDR_VAR 0 6
53576: PUSH
53577: LD_VAR 0 1
53581: PPUSH
53582: LD_VAR 0 4
53586: PUSH
53587: LD_INT 1
53589: ARRAY
53590: PPUSH
53591: LD_VAR 0 4
53595: PUSH
53596: LD_INT 2
53598: ARRAY
53599: PPUSH
53600: CALL_OW 297
53604: ST_TO_ADDR
// if tmpDist < dist then
53605: LD_VAR 0 6
53609: PUSH
53610: LD_VAR 0 5
53614: LESS
53615: IFFALSE 53637
// begin result := i ;
53617: LD_ADDR_VAR 0 3
53621: PUSH
53622: LD_VAR 0 4
53626: ST_TO_ADDR
// dist := tmpDist ;
53627: LD_ADDR_VAR 0 5
53631: PUSH
53632: LD_VAR 0 6
53636: ST_TO_ADDR
// end ; end ;
53637: GO 53569
53639: POP
53640: POP
// end ;
53641: LD_VAR 0 3
53645: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
53646: LD_INT 0
53648: PPUSH
// uc_side := side ;
53649: LD_ADDR_OWVAR 20
53653: PUSH
53654: LD_VAR 0 1
53658: ST_TO_ADDR
// uc_nation := 3 ;
53659: LD_ADDR_OWVAR 21
53663: PUSH
53664: LD_INT 3
53666: ST_TO_ADDR
// vc_chassis := 25 ;
53667: LD_ADDR_OWVAR 37
53671: PUSH
53672: LD_INT 25
53674: ST_TO_ADDR
// vc_engine := engine_siberite ;
53675: LD_ADDR_OWVAR 39
53679: PUSH
53680: LD_INT 3
53682: ST_TO_ADDR
// vc_control := control_computer ;
53683: LD_ADDR_OWVAR 38
53687: PUSH
53688: LD_INT 3
53690: ST_TO_ADDR
// vc_weapon := 59 ;
53691: LD_ADDR_OWVAR 40
53695: PUSH
53696: LD_INT 59
53698: ST_TO_ADDR
// result := CreateVehicle ;
53699: LD_ADDR_VAR 0 5
53703: PUSH
53704: CALL_OW 45
53708: ST_TO_ADDR
// SetDir ( result , d ) ;
53709: LD_VAR 0 5
53713: PPUSH
53714: LD_VAR 0 4
53718: PPUSH
53719: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
53723: LD_VAR 0 5
53727: PPUSH
53728: LD_VAR 0 2
53732: PPUSH
53733: LD_VAR 0 3
53737: PPUSH
53738: LD_INT 0
53740: PPUSH
53741: CALL_OW 48
// end ; end_of_file
53745: LD_VAR 0 5
53749: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
53750: LD_INT 0
53752: PPUSH
// ar_miner := 81 ;
53753: LD_ADDR_EXP 55
53757: PUSH
53758: LD_INT 81
53760: ST_TO_ADDR
// ar_crane := 88 ;
53761: LD_ADDR_EXP 54
53765: PUSH
53766: LD_INT 88
53768: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
53769: LD_ADDR_EXP 49
53773: PUSH
53774: LD_INT 89
53776: ST_TO_ADDR
// us_hack := 99 ;
53777: LD_ADDR_EXP 50
53781: PUSH
53782: LD_INT 99
53784: ST_TO_ADDR
// us_artillery := 97 ;
53785: LD_ADDR_EXP 51
53789: PUSH
53790: LD_INT 97
53792: ST_TO_ADDR
// ar_bio_bomb := 91 ;
53793: LD_ADDR_EXP 52
53797: PUSH
53798: LD_INT 91
53800: ST_TO_ADDR
// ar_mortar := 92 ;
53801: LD_ADDR_EXP 53
53805: PUSH
53806: LD_INT 92
53808: ST_TO_ADDR
// ru_flamethrower := 93 ;
53809: LD_ADDR_EXP 56
53813: PUSH
53814: LD_INT 93
53816: ST_TO_ADDR
// ru_radar := 98 ;
53817: LD_ADDR_EXP 48
53821: PUSH
53822: LD_INT 98
53824: ST_TO_ADDR
// tech_Artillery := 80 ;
53825: LD_ADDR_EXP 57
53829: PUSH
53830: LD_INT 80
53832: ST_TO_ADDR
// tech_RadMat := 81 ;
53833: LD_ADDR_EXP 58
53837: PUSH
53838: LD_INT 81
53840: ST_TO_ADDR
// tech_BasicTools := 82 ;
53841: LD_ADDR_EXP 59
53845: PUSH
53846: LD_INT 82
53848: ST_TO_ADDR
// tech_Cargo := 83 ;
53849: LD_ADDR_EXP 60
53853: PUSH
53854: LD_INT 83
53856: ST_TO_ADDR
// tech_Track := 84 ;
53857: LD_ADDR_EXP 61
53861: PUSH
53862: LD_INT 84
53864: ST_TO_ADDR
// tech_Crane := 85 ;
53865: LD_ADDR_EXP 62
53869: PUSH
53870: LD_INT 85
53872: ST_TO_ADDR
// tech_Bulldozer := 86 ;
53873: LD_ADDR_EXP 63
53877: PUSH
53878: LD_INT 86
53880: ST_TO_ADDR
// tech_Hovercraft := 87 ;
53881: LD_ADDR_EXP 64
53885: PUSH
53886: LD_INT 87
53888: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
53889: LD_ADDR_EXP 65
53893: PUSH
53894: LD_INT 88
53896: ST_TO_ADDR
// class_mastodont := 31 ;
53897: LD_ADDR_EXP 66
53901: PUSH
53902: LD_INT 31
53904: ST_TO_ADDR
// class_horse := 21 ;
53905: LD_ADDR_EXP 67
53909: PUSH
53910: LD_INT 21
53912: ST_TO_ADDR
// end ;
53913: LD_VAR 0 1
53917: RET
// every 1 do
53918: GO 53920
53920: DISABLE
// InitGlobalVariables ; end_of_file
53921: CALL 53750 0 0
53925: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
53926: LD_INT 0
53928: PPUSH
53929: PPUSH
// skirmish := false ;
53930: LD_ADDR_EXP 68
53934: PUSH
53935: LD_INT 0
53937: ST_TO_ADDR
// debug_mc := false ;
53938: LD_ADDR_EXP 69
53942: PUSH
53943: LD_INT 0
53945: ST_TO_ADDR
// mc_bases := [ ] ;
53946: LD_ADDR_EXP 70
53950: PUSH
53951: EMPTY
53952: ST_TO_ADDR
// mc_sides := [ ] ;
53953: LD_ADDR_EXP 96
53957: PUSH
53958: EMPTY
53959: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53960: LD_ADDR_EXP 71
53964: PUSH
53965: EMPTY
53966: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53967: LD_ADDR_EXP 72
53971: PUSH
53972: EMPTY
53973: ST_TO_ADDR
// mc_need_heal := [ ] ;
53974: LD_ADDR_EXP 73
53978: PUSH
53979: EMPTY
53980: ST_TO_ADDR
// mc_healers := [ ] ;
53981: LD_ADDR_EXP 74
53985: PUSH
53986: EMPTY
53987: ST_TO_ADDR
// mc_build_list := [ ] ;
53988: LD_ADDR_EXP 75
53992: PUSH
53993: EMPTY
53994: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53995: LD_ADDR_EXP 102
53999: PUSH
54000: EMPTY
54001: ST_TO_ADDR
// mc_builders := [ ] ;
54002: LD_ADDR_EXP 76
54006: PUSH
54007: EMPTY
54008: ST_TO_ADDR
// mc_construct_list := [ ] ;
54009: LD_ADDR_EXP 77
54013: PUSH
54014: EMPTY
54015: ST_TO_ADDR
// mc_turret_list := [ ] ;
54016: LD_ADDR_EXP 78
54020: PUSH
54021: EMPTY
54022: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54023: LD_ADDR_EXP 79
54027: PUSH
54028: EMPTY
54029: ST_TO_ADDR
// mc_miners := [ ] ;
54030: LD_ADDR_EXP 84
54034: PUSH
54035: EMPTY
54036: ST_TO_ADDR
// mc_mines := [ ] ;
54037: LD_ADDR_EXP 83
54041: PUSH
54042: EMPTY
54043: ST_TO_ADDR
// mc_minefields := [ ] ;
54044: LD_ADDR_EXP 85
54048: PUSH
54049: EMPTY
54050: ST_TO_ADDR
// mc_crates := [ ] ;
54051: LD_ADDR_EXP 86
54055: PUSH
54056: EMPTY
54057: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54058: LD_ADDR_EXP 87
54062: PUSH
54063: EMPTY
54064: ST_TO_ADDR
// mc_crates_area := [ ] ;
54065: LD_ADDR_EXP 88
54069: PUSH
54070: EMPTY
54071: ST_TO_ADDR
// mc_vehicles := [ ] ;
54072: LD_ADDR_EXP 89
54076: PUSH
54077: EMPTY
54078: ST_TO_ADDR
// mc_attack := [ ] ;
54079: LD_ADDR_EXP 90
54083: PUSH
54084: EMPTY
54085: ST_TO_ADDR
// mc_produce := [ ] ;
54086: LD_ADDR_EXP 91
54090: PUSH
54091: EMPTY
54092: ST_TO_ADDR
// mc_defender := [ ] ;
54093: LD_ADDR_EXP 92
54097: PUSH
54098: EMPTY
54099: ST_TO_ADDR
// mc_parking := [ ] ;
54100: LD_ADDR_EXP 94
54104: PUSH
54105: EMPTY
54106: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54107: LD_ADDR_EXP 80
54111: PUSH
54112: EMPTY
54113: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54114: LD_ADDR_EXP 82
54118: PUSH
54119: EMPTY
54120: ST_TO_ADDR
// mc_scan := [ ] ;
54121: LD_ADDR_EXP 93
54125: PUSH
54126: EMPTY
54127: ST_TO_ADDR
// mc_scan_area := [ ] ;
54128: LD_ADDR_EXP 95
54132: PUSH
54133: EMPTY
54134: ST_TO_ADDR
// mc_tech := [ ] ;
54135: LD_ADDR_EXP 97
54139: PUSH
54140: EMPTY
54141: ST_TO_ADDR
// mc_class := [ ] ;
54142: LD_ADDR_EXP 111
54146: PUSH
54147: EMPTY
54148: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54149: LD_ADDR_EXP 112
54153: PUSH
54154: EMPTY
54155: ST_TO_ADDR
// mc_is_defending := [ ] ;
54156: LD_ADDR_EXP 113
54160: PUSH
54161: EMPTY
54162: ST_TO_ADDR
// end ;
54163: LD_VAR 0 1
54167: RET
// export function MC_Kill ( base ) ; begin
54168: LD_INT 0
54170: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54171: LD_ADDR_EXP 70
54175: PUSH
54176: LD_EXP 70
54180: PPUSH
54181: LD_VAR 0 1
54185: PPUSH
54186: EMPTY
54187: PPUSH
54188: CALL_OW 1
54192: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54193: LD_ADDR_EXP 71
54197: PUSH
54198: LD_EXP 71
54202: PPUSH
54203: LD_VAR 0 1
54207: PPUSH
54208: EMPTY
54209: PPUSH
54210: CALL_OW 1
54214: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54215: LD_ADDR_EXP 72
54219: PUSH
54220: LD_EXP 72
54224: PPUSH
54225: LD_VAR 0 1
54229: PPUSH
54230: EMPTY
54231: PPUSH
54232: CALL_OW 1
54236: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54237: LD_ADDR_EXP 73
54241: PUSH
54242: LD_EXP 73
54246: PPUSH
54247: LD_VAR 0 1
54251: PPUSH
54252: EMPTY
54253: PPUSH
54254: CALL_OW 1
54258: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54259: LD_ADDR_EXP 74
54263: PUSH
54264: LD_EXP 74
54268: PPUSH
54269: LD_VAR 0 1
54273: PPUSH
54274: EMPTY
54275: PPUSH
54276: CALL_OW 1
54280: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54281: LD_ADDR_EXP 75
54285: PUSH
54286: LD_EXP 75
54290: PPUSH
54291: LD_VAR 0 1
54295: PPUSH
54296: EMPTY
54297: PPUSH
54298: CALL_OW 1
54302: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54303: LD_ADDR_EXP 76
54307: PUSH
54308: LD_EXP 76
54312: PPUSH
54313: LD_VAR 0 1
54317: PPUSH
54318: EMPTY
54319: PPUSH
54320: CALL_OW 1
54324: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54325: LD_ADDR_EXP 77
54329: PUSH
54330: LD_EXP 77
54334: PPUSH
54335: LD_VAR 0 1
54339: PPUSH
54340: EMPTY
54341: PPUSH
54342: CALL_OW 1
54346: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54347: LD_ADDR_EXP 78
54351: PUSH
54352: LD_EXP 78
54356: PPUSH
54357: LD_VAR 0 1
54361: PPUSH
54362: EMPTY
54363: PPUSH
54364: CALL_OW 1
54368: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54369: LD_ADDR_EXP 79
54373: PUSH
54374: LD_EXP 79
54378: PPUSH
54379: LD_VAR 0 1
54383: PPUSH
54384: EMPTY
54385: PPUSH
54386: CALL_OW 1
54390: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54391: LD_ADDR_EXP 80
54395: PUSH
54396: LD_EXP 80
54400: PPUSH
54401: LD_VAR 0 1
54405: PPUSH
54406: EMPTY
54407: PPUSH
54408: CALL_OW 1
54412: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54413: LD_ADDR_EXP 81
54417: PUSH
54418: LD_EXP 81
54422: PPUSH
54423: LD_VAR 0 1
54427: PPUSH
54428: LD_INT 0
54430: PPUSH
54431: CALL_OW 1
54435: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54436: LD_ADDR_EXP 82
54440: PUSH
54441: LD_EXP 82
54445: PPUSH
54446: LD_VAR 0 1
54450: PPUSH
54451: EMPTY
54452: PPUSH
54453: CALL_OW 1
54457: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54458: LD_ADDR_EXP 83
54462: PUSH
54463: LD_EXP 83
54467: PPUSH
54468: LD_VAR 0 1
54472: PPUSH
54473: EMPTY
54474: PPUSH
54475: CALL_OW 1
54479: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54480: LD_ADDR_EXP 84
54484: PUSH
54485: LD_EXP 84
54489: PPUSH
54490: LD_VAR 0 1
54494: PPUSH
54495: EMPTY
54496: PPUSH
54497: CALL_OW 1
54501: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54502: LD_ADDR_EXP 85
54506: PUSH
54507: LD_EXP 85
54511: PPUSH
54512: LD_VAR 0 1
54516: PPUSH
54517: EMPTY
54518: PPUSH
54519: CALL_OW 1
54523: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54524: LD_ADDR_EXP 86
54528: PUSH
54529: LD_EXP 86
54533: PPUSH
54534: LD_VAR 0 1
54538: PPUSH
54539: EMPTY
54540: PPUSH
54541: CALL_OW 1
54545: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54546: LD_ADDR_EXP 87
54550: PUSH
54551: LD_EXP 87
54555: PPUSH
54556: LD_VAR 0 1
54560: PPUSH
54561: EMPTY
54562: PPUSH
54563: CALL_OW 1
54567: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54568: LD_ADDR_EXP 88
54572: PUSH
54573: LD_EXP 88
54577: PPUSH
54578: LD_VAR 0 1
54582: PPUSH
54583: EMPTY
54584: PPUSH
54585: CALL_OW 1
54589: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54590: LD_ADDR_EXP 89
54594: PUSH
54595: LD_EXP 89
54599: PPUSH
54600: LD_VAR 0 1
54604: PPUSH
54605: EMPTY
54606: PPUSH
54607: CALL_OW 1
54611: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54612: LD_ADDR_EXP 90
54616: PUSH
54617: LD_EXP 90
54621: PPUSH
54622: LD_VAR 0 1
54626: PPUSH
54627: EMPTY
54628: PPUSH
54629: CALL_OW 1
54633: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54634: LD_ADDR_EXP 91
54638: PUSH
54639: LD_EXP 91
54643: PPUSH
54644: LD_VAR 0 1
54648: PPUSH
54649: EMPTY
54650: PPUSH
54651: CALL_OW 1
54655: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54656: LD_ADDR_EXP 92
54660: PUSH
54661: LD_EXP 92
54665: PPUSH
54666: LD_VAR 0 1
54670: PPUSH
54671: EMPTY
54672: PPUSH
54673: CALL_OW 1
54677: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54678: LD_ADDR_EXP 93
54682: PUSH
54683: LD_EXP 93
54687: PPUSH
54688: LD_VAR 0 1
54692: PPUSH
54693: EMPTY
54694: PPUSH
54695: CALL_OW 1
54699: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54700: LD_ADDR_EXP 94
54704: PUSH
54705: LD_EXP 94
54709: PPUSH
54710: LD_VAR 0 1
54714: PPUSH
54715: EMPTY
54716: PPUSH
54717: CALL_OW 1
54721: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54722: LD_ADDR_EXP 95
54726: PUSH
54727: LD_EXP 95
54731: PPUSH
54732: LD_VAR 0 1
54736: PPUSH
54737: EMPTY
54738: PPUSH
54739: CALL_OW 1
54743: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54744: LD_ADDR_EXP 97
54748: PUSH
54749: LD_EXP 97
54753: PPUSH
54754: LD_VAR 0 1
54758: PPUSH
54759: EMPTY
54760: PPUSH
54761: CALL_OW 1
54765: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54766: LD_ADDR_EXP 99
54770: PUSH
54771: LD_EXP 99
54775: PPUSH
54776: LD_VAR 0 1
54780: PPUSH
54781: EMPTY
54782: PPUSH
54783: CALL_OW 1
54787: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54788: LD_ADDR_EXP 100
54792: PUSH
54793: LD_EXP 100
54797: PPUSH
54798: LD_VAR 0 1
54802: PPUSH
54803: EMPTY
54804: PPUSH
54805: CALL_OW 1
54809: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54810: LD_ADDR_EXP 101
54814: PUSH
54815: LD_EXP 101
54819: PPUSH
54820: LD_VAR 0 1
54824: PPUSH
54825: EMPTY
54826: PPUSH
54827: CALL_OW 1
54831: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54832: LD_ADDR_EXP 102
54836: PUSH
54837: LD_EXP 102
54841: PPUSH
54842: LD_VAR 0 1
54846: PPUSH
54847: EMPTY
54848: PPUSH
54849: CALL_OW 1
54853: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54854: LD_ADDR_EXP 103
54858: PUSH
54859: LD_EXP 103
54863: PPUSH
54864: LD_VAR 0 1
54868: PPUSH
54869: EMPTY
54870: PPUSH
54871: CALL_OW 1
54875: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54876: LD_ADDR_EXP 104
54880: PUSH
54881: LD_EXP 104
54885: PPUSH
54886: LD_VAR 0 1
54890: PPUSH
54891: EMPTY
54892: PPUSH
54893: CALL_OW 1
54897: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54898: LD_ADDR_EXP 105
54902: PUSH
54903: LD_EXP 105
54907: PPUSH
54908: LD_VAR 0 1
54912: PPUSH
54913: EMPTY
54914: PPUSH
54915: CALL_OW 1
54919: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54920: LD_ADDR_EXP 106
54924: PUSH
54925: LD_EXP 106
54929: PPUSH
54930: LD_VAR 0 1
54934: PPUSH
54935: EMPTY
54936: PPUSH
54937: CALL_OW 1
54941: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54942: LD_ADDR_EXP 107
54946: PUSH
54947: LD_EXP 107
54951: PPUSH
54952: LD_VAR 0 1
54956: PPUSH
54957: EMPTY
54958: PPUSH
54959: CALL_OW 1
54963: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54964: LD_ADDR_EXP 108
54968: PUSH
54969: LD_EXP 108
54973: PPUSH
54974: LD_VAR 0 1
54978: PPUSH
54979: EMPTY
54980: PPUSH
54981: CALL_OW 1
54985: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54986: LD_ADDR_EXP 109
54990: PUSH
54991: LD_EXP 109
54995: PPUSH
54996: LD_VAR 0 1
55000: PPUSH
55001: EMPTY
55002: PPUSH
55003: CALL_OW 1
55007: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55008: LD_ADDR_EXP 110
55012: PUSH
55013: LD_EXP 110
55017: PPUSH
55018: LD_VAR 0 1
55022: PPUSH
55023: EMPTY
55024: PPUSH
55025: CALL_OW 1
55029: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55030: LD_ADDR_EXP 111
55034: PUSH
55035: LD_EXP 111
55039: PPUSH
55040: LD_VAR 0 1
55044: PPUSH
55045: EMPTY
55046: PPUSH
55047: CALL_OW 1
55051: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55052: LD_ADDR_EXP 112
55056: PUSH
55057: LD_EXP 112
55061: PPUSH
55062: LD_VAR 0 1
55066: PPUSH
55067: LD_INT 0
55069: PPUSH
55070: CALL_OW 1
55074: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55075: LD_ADDR_EXP 113
55079: PUSH
55080: LD_EXP 113
55084: PPUSH
55085: LD_VAR 0 1
55089: PPUSH
55090: LD_INT 0
55092: PPUSH
55093: CALL_OW 1
55097: ST_TO_ADDR
// end ;
55098: LD_VAR 0 2
55102: RET
// export function MC_Add ( side , units ) ; var base ; begin
55103: LD_INT 0
55105: PPUSH
55106: PPUSH
// base := mc_bases + 1 ;
55107: LD_ADDR_VAR 0 4
55111: PUSH
55112: LD_EXP 70
55116: PUSH
55117: LD_INT 1
55119: PLUS
55120: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55121: LD_ADDR_EXP 96
55125: PUSH
55126: LD_EXP 96
55130: PPUSH
55131: LD_VAR 0 4
55135: PPUSH
55136: LD_VAR 0 1
55140: PPUSH
55141: CALL_OW 1
55145: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55146: LD_ADDR_EXP 70
55150: PUSH
55151: LD_EXP 70
55155: PPUSH
55156: LD_VAR 0 4
55160: PPUSH
55161: LD_VAR 0 2
55165: PPUSH
55166: CALL_OW 1
55170: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55171: LD_ADDR_EXP 71
55175: PUSH
55176: LD_EXP 71
55180: PPUSH
55181: LD_VAR 0 4
55185: PPUSH
55186: EMPTY
55187: PPUSH
55188: CALL_OW 1
55192: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55193: LD_ADDR_EXP 72
55197: PUSH
55198: LD_EXP 72
55202: PPUSH
55203: LD_VAR 0 4
55207: PPUSH
55208: EMPTY
55209: PPUSH
55210: CALL_OW 1
55214: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55215: LD_ADDR_EXP 73
55219: PUSH
55220: LD_EXP 73
55224: PPUSH
55225: LD_VAR 0 4
55229: PPUSH
55230: EMPTY
55231: PPUSH
55232: CALL_OW 1
55236: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55237: LD_ADDR_EXP 74
55241: PUSH
55242: LD_EXP 74
55246: PPUSH
55247: LD_VAR 0 4
55251: PPUSH
55252: EMPTY
55253: PPUSH
55254: CALL_OW 1
55258: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55259: LD_ADDR_EXP 75
55263: PUSH
55264: LD_EXP 75
55268: PPUSH
55269: LD_VAR 0 4
55273: PPUSH
55274: EMPTY
55275: PPUSH
55276: CALL_OW 1
55280: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55281: LD_ADDR_EXP 76
55285: PUSH
55286: LD_EXP 76
55290: PPUSH
55291: LD_VAR 0 4
55295: PPUSH
55296: EMPTY
55297: PPUSH
55298: CALL_OW 1
55302: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55303: LD_ADDR_EXP 77
55307: PUSH
55308: LD_EXP 77
55312: PPUSH
55313: LD_VAR 0 4
55317: PPUSH
55318: EMPTY
55319: PPUSH
55320: CALL_OW 1
55324: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55325: LD_ADDR_EXP 78
55329: PUSH
55330: LD_EXP 78
55334: PPUSH
55335: LD_VAR 0 4
55339: PPUSH
55340: EMPTY
55341: PPUSH
55342: CALL_OW 1
55346: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55347: LD_ADDR_EXP 79
55351: PUSH
55352: LD_EXP 79
55356: PPUSH
55357: LD_VAR 0 4
55361: PPUSH
55362: EMPTY
55363: PPUSH
55364: CALL_OW 1
55368: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55369: LD_ADDR_EXP 80
55373: PUSH
55374: LD_EXP 80
55378: PPUSH
55379: LD_VAR 0 4
55383: PPUSH
55384: EMPTY
55385: PPUSH
55386: CALL_OW 1
55390: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55391: LD_ADDR_EXP 81
55395: PUSH
55396: LD_EXP 81
55400: PPUSH
55401: LD_VAR 0 4
55405: PPUSH
55406: LD_INT 0
55408: PPUSH
55409: CALL_OW 1
55413: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55414: LD_ADDR_EXP 82
55418: PUSH
55419: LD_EXP 82
55423: PPUSH
55424: LD_VAR 0 4
55428: PPUSH
55429: EMPTY
55430: PPUSH
55431: CALL_OW 1
55435: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55436: LD_ADDR_EXP 83
55440: PUSH
55441: LD_EXP 83
55445: PPUSH
55446: LD_VAR 0 4
55450: PPUSH
55451: EMPTY
55452: PPUSH
55453: CALL_OW 1
55457: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55458: LD_ADDR_EXP 84
55462: PUSH
55463: LD_EXP 84
55467: PPUSH
55468: LD_VAR 0 4
55472: PPUSH
55473: EMPTY
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55480: LD_ADDR_EXP 85
55484: PUSH
55485: LD_EXP 85
55489: PPUSH
55490: LD_VAR 0 4
55494: PPUSH
55495: EMPTY
55496: PPUSH
55497: CALL_OW 1
55501: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55502: LD_ADDR_EXP 86
55506: PUSH
55507: LD_EXP 86
55511: PPUSH
55512: LD_VAR 0 4
55516: PPUSH
55517: EMPTY
55518: PPUSH
55519: CALL_OW 1
55523: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55524: LD_ADDR_EXP 87
55528: PUSH
55529: LD_EXP 87
55533: PPUSH
55534: LD_VAR 0 4
55538: PPUSH
55539: EMPTY
55540: PPUSH
55541: CALL_OW 1
55545: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55546: LD_ADDR_EXP 88
55550: PUSH
55551: LD_EXP 88
55555: PPUSH
55556: LD_VAR 0 4
55560: PPUSH
55561: EMPTY
55562: PPUSH
55563: CALL_OW 1
55567: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55568: LD_ADDR_EXP 89
55572: PUSH
55573: LD_EXP 89
55577: PPUSH
55578: LD_VAR 0 4
55582: PPUSH
55583: EMPTY
55584: PPUSH
55585: CALL_OW 1
55589: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55590: LD_ADDR_EXP 90
55594: PUSH
55595: LD_EXP 90
55599: PPUSH
55600: LD_VAR 0 4
55604: PPUSH
55605: EMPTY
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55612: LD_ADDR_EXP 91
55616: PUSH
55617: LD_EXP 91
55621: PPUSH
55622: LD_VAR 0 4
55626: PPUSH
55627: EMPTY
55628: PPUSH
55629: CALL_OW 1
55633: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55634: LD_ADDR_EXP 92
55638: PUSH
55639: LD_EXP 92
55643: PPUSH
55644: LD_VAR 0 4
55648: PPUSH
55649: EMPTY
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55656: LD_ADDR_EXP 93
55660: PUSH
55661: LD_EXP 93
55665: PPUSH
55666: LD_VAR 0 4
55670: PPUSH
55671: EMPTY
55672: PPUSH
55673: CALL_OW 1
55677: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55678: LD_ADDR_EXP 94
55682: PUSH
55683: LD_EXP 94
55687: PPUSH
55688: LD_VAR 0 4
55692: PPUSH
55693: EMPTY
55694: PPUSH
55695: CALL_OW 1
55699: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55700: LD_ADDR_EXP 95
55704: PUSH
55705: LD_EXP 95
55709: PPUSH
55710: LD_VAR 0 4
55714: PPUSH
55715: EMPTY
55716: PPUSH
55717: CALL_OW 1
55721: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55722: LD_ADDR_EXP 97
55726: PUSH
55727: LD_EXP 97
55731: PPUSH
55732: LD_VAR 0 4
55736: PPUSH
55737: EMPTY
55738: PPUSH
55739: CALL_OW 1
55743: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55744: LD_ADDR_EXP 99
55748: PUSH
55749: LD_EXP 99
55753: PPUSH
55754: LD_VAR 0 4
55758: PPUSH
55759: EMPTY
55760: PPUSH
55761: CALL_OW 1
55765: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55766: LD_ADDR_EXP 100
55770: PUSH
55771: LD_EXP 100
55775: PPUSH
55776: LD_VAR 0 4
55780: PPUSH
55781: EMPTY
55782: PPUSH
55783: CALL_OW 1
55787: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55788: LD_ADDR_EXP 101
55792: PUSH
55793: LD_EXP 101
55797: PPUSH
55798: LD_VAR 0 4
55802: PPUSH
55803: EMPTY
55804: PPUSH
55805: CALL_OW 1
55809: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55810: LD_ADDR_EXP 102
55814: PUSH
55815: LD_EXP 102
55819: PPUSH
55820: LD_VAR 0 4
55824: PPUSH
55825: EMPTY
55826: PPUSH
55827: CALL_OW 1
55831: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55832: LD_ADDR_EXP 103
55836: PUSH
55837: LD_EXP 103
55841: PPUSH
55842: LD_VAR 0 4
55846: PPUSH
55847: EMPTY
55848: PPUSH
55849: CALL_OW 1
55853: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55854: LD_ADDR_EXP 104
55858: PUSH
55859: LD_EXP 104
55863: PPUSH
55864: LD_VAR 0 4
55868: PPUSH
55869: EMPTY
55870: PPUSH
55871: CALL_OW 1
55875: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55876: LD_ADDR_EXP 105
55880: PUSH
55881: LD_EXP 105
55885: PPUSH
55886: LD_VAR 0 4
55890: PPUSH
55891: EMPTY
55892: PPUSH
55893: CALL_OW 1
55897: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55898: LD_ADDR_EXP 106
55902: PUSH
55903: LD_EXP 106
55907: PPUSH
55908: LD_VAR 0 4
55912: PPUSH
55913: EMPTY
55914: PPUSH
55915: CALL_OW 1
55919: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55920: LD_ADDR_EXP 107
55924: PUSH
55925: LD_EXP 107
55929: PPUSH
55930: LD_VAR 0 4
55934: PPUSH
55935: EMPTY
55936: PPUSH
55937: CALL_OW 1
55941: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55942: LD_ADDR_EXP 108
55946: PUSH
55947: LD_EXP 108
55951: PPUSH
55952: LD_VAR 0 4
55956: PPUSH
55957: EMPTY
55958: PPUSH
55959: CALL_OW 1
55963: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55964: LD_ADDR_EXP 109
55968: PUSH
55969: LD_EXP 109
55973: PPUSH
55974: LD_VAR 0 4
55978: PPUSH
55979: EMPTY
55980: PPUSH
55981: CALL_OW 1
55985: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55986: LD_ADDR_EXP 110
55990: PUSH
55991: LD_EXP 110
55995: PPUSH
55996: LD_VAR 0 4
56000: PPUSH
56001: EMPTY
56002: PPUSH
56003: CALL_OW 1
56007: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56008: LD_ADDR_EXP 111
56012: PUSH
56013: LD_EXP 111
56017: PPUSH
56018: LD_VAR 0 4
56022: PPUSH
56023: EMPTY
56024: PPUSH
56025: CALL_OW 1
56029: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56030: LD_ADDR_EXP 112
56034: PUSH
56035: LD_EXP 112
56039: PPUSH
56040: LD_VAR 0 4
56044: PPUSH
56045: LD_INT 0
56047: PPUSH
56048: CALL_OW 1
56052: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56053: LD_ADDR_EXP 113
56057: PUSH
56058: LD_EXP 113
56062: PPUSH
56063: LD_VAR 0 4
56067: PPUSH
56068: LD_INT 0
56070: PPUSH
56071: CALL_OW 1
56075: ST_TO_ADDR
// result := base ;
56076: LD_ADDR_VAR 0 3
56080: PUSH
56081: LD_VAR 0 4
56085: ST_TO_ADDR
// end ;
56086: LD_VAR 0 3
56090: RET
// export function MC_Start ( ) ; var i ; begin
56091: LD_INT 0
56093: PPUSH
56094: PPUSH
// for i = 1 to mc_bases do
56095: LD_ADDR_VAR 0 2
56099: PUSH
56100: DOUBLE
56101: LD_INT 1
56103: DEC
56104: ST_TO_ADDR
56105: LD_EXP 70
56109: PUSH
56110: FOR_TO
56111: IFFALSE 57211
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56113: LD_ADDR_EXP 70
56117: PUSH
56118: LD_EXP 70
56122: PPUSH
56123: LD_VAR 0 2
56127: PPUSH
56128: LD_EXP 70
56132: PUSH
56133: LD_VAR 0 2
56137: ARRAY
56138: PUSH
56139: LD_INT 0
56141: DIFF
56142: PPUSH
56143: CALL_OW 1
56147: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56148: LD_ADDR_EXP 71
56152: PUSH
56153: LD_EXP 71
56157: PPUSH
56158: LD_VAR 0 2
56162: PPUSH
56163: EMPTY
56164: PPUSH
56165: CALL_OW 1
56169: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56170: LD_ADDR_EXP 72
56174: PUSH
56175: LD_EXP 72
56179: PPUSH
56180: LD_VAR 0 2
56184: PPUSH
56185: EMPTY
56186: PPUSH
56187: CALL_OW 1
56191: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56192: LD_ADDR_EXP 73
56196: PUSH
56197: LD_EXP 73
56201: PPUSH
56202: LD_VAR 0 2
56206: PPUSH
56207: EMPTY
56208: PPUSH
56209: CALL_OW 1
56213: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56214: LD_ADDR_EXP 74
56218: PUSH
56219: LD_EXP 74
56223: PPUSH
56224: LD_VAR 0 2
56228: PPUSH
56229: EMPTY
56230: PUSH
56231: EMPTY
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: PPUSH
56237: CALL_OW 1
56241: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56242: LD_ADDR_EXP 75
56246: PUSH
56247: LD_EXP 75
56251: PPUSH
56252: LD_VAR 0 2
56256: PPUSH
56257: EMPTY
56258: PPUSH
56259: CALL_OW 1
56263: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56264: LD_ADDR_EXP 102
56268: PUSH
56269: LD_EXP 102
56273: PPUSH
56274: LD_VAR 0 2
56278: PPUSH
56279: EMPTY
56280: PPUSH
56281: CALL_OW 1
56285: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56286: LD_ADDR_EXP 76
56290: PUSH
56291: LD_EXP 76
56295: PPUSH
56296: LD_VAR 0 2
56300: PPUSH
56301: EMPTY
56302: PPUSH
56303: CALL_OW 1
56307: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56308: LD_ADDR_EXP 77
56312: PUSH
56313: LD_EXP 77
56317: PPUSH
56318: LD_VAR 0 2
56322: PPUSH
56323: EMPTY
56324: PPUSH
56325: CALL_OW 1
56329: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56330: LD_ADDR_EXP 78
56334: PUSH
56335: LD_EXP 78
56339: PPUSH
56340: LD_VAR 0 2
56344: PPUSH
56345: LD_EXP 70
56349: PUSH
56350: LD_VAR 0 2
56354: ARRAY
56355: PPUSH
56356: LD_INT 2
56358: PUSH
56359: LD_INT 30
56361: PUSH
56362: LD_INT 32
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: PUSH
56369: LD_INT 30
56371: PUSH
56372: LD_INT 33
56374: PUSH
56375: EMPTY
56376: LIST
56377: LIST
56378: PUSH
56379: EMPTY
56380: LIST
56381: LIST
56382: LIST
56383: PPUSH
56384: CALL_OW 72
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56394: LD_ADDR_EXP 79
56398: PUSH
56399: LD_EXP 79
56403: PPUSH
56404: LD_VAR 0 2
56408: PPUSH
56409: LD_EXP 70
56413: PUSH
56414: LD_VAR 0 2
56418: ARRAY
56419: PPUSH
56420: LD_INT 2
56422: PUSH
56423: LD_INT 30
56425: PUSH
56426: LD_INT 32
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: LD_INT 30
56435: PUSH
56436: LD_INT 31
56438: PUSH
56439: EMPTY
56440: LIST
56441: LIST
56442: PUSH
56443: EMPTY
56444: LIST
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 58
56450: PUSH
56451: EMPTY
56452: LIST
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PPUSH
56458: CALL_OW 72
56462: PPUSH
56463: CALL_OW 1
56467: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56468: LD_ADDR_EXP 80
56472: PUSH
56473: LD_EXP 80
56477: PPUSH
56478: LD_VAR 0 2
56482: PPUSH
56483: EMPTY
56484: PPUSH
56485: CALL_OW 1
56489: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56490: LD_ADDR_EXP 84
56494: PUSH
56495: LD_EXP 84
56499: PPUSH
56500: LD_VAR 0 2
56504: PPUSH
56505: EMPTY
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56512: LD_ADDR_EXP 83
56516: PUSH
56517: LD_EXP 83
56521: PPUSH
56522: LD_VAR 0 2
56526: PPUSH
56527: EMPTY
56528: PPUSH
56529: CALL_OW 1
56533: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56534: LD_ADDR_EXP 85
56538: PUSH
56539: LD_EXP 85
56543: PPUSH
56544: LD_VAR 0 2
56548: PPUSH
56549: EMPTY
56550: PPUSH
56551: CALL_OW 1
56555: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56556: LD_ADDR_EXP 86
56560: PUSH
56561: LD_EXP 86
56565: PPUSH
56566: LD_VAR 0 2
56570: PPUSH
56571: EMPTY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56578: LD_ADDR_EXP 87
56582: PUSH
56583: LD_EXP 87
56587: PPUSH
56588: LD_VAR 0 2
56592: PPUSH
56593: EMPTY
56594: PPUSH
56595: CALL_OW 1
56599: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56600: LD_ADDR_EXP 88
56604: PUSH
56605: LD_EXP 88
56609: PPUSH
56610: LD_VAR 0 2
56614: PPUSH
56615: EMPTY
56616: PPUSH
56617: CALL_OW 1
56621: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56622: LD_ADDR_EXP 89
56626: PUSH
56627: LD_EXP 89
56631: PPUSH
56632: LD_VAR 0 2
56636: PPUSH
56637: EMPTY
56638: PPUSH
56639: CALL_OW 1
56643: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56644: LD_ADDR_EXP 90
56648: PUSH
56649: LD_EXP 90
56653: PPUSH
56654: LD_VAR 0 2
56658: PPUSH
56659: EMPTY
56660: PPUSH
56661: CALL_OW 1
56665: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56666: LD_ADDR_EXP 91
56670: PUSH
56671: LD_EXP 91
56675: PPUSH
56676: LD_VAR 0 2
56680: PPUSH
56681: EMPTY
56682: PPUSH
56683: CALL_OW 1
56687: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56688: LD_ADDR_EXP 92
56692: PUSH
56693: LD_EXP 92
56697: PPUSH
56698: LD_VAR 0 2
56702: PPUSH
56703: EMPTY
56704: PPUSH
56705: CALL_OW 1
56709: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56710: LD_ADDR_EXP 81
56714: PUSH
56715: LD_EXP 81
56719: PPUSH
56720: LD_VAR 0 2
56724: PPUSH
56725: LD_INT 0
56727: PPUSH
56728: CALL_OW 1
56732: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56733: LD_ADDR_EXP 94
56737: PUSH
56738: LD_EXP 94
56742: PPUSH
56743: LD_VAR 0 2
56747: PPUSH
56748: LD_INT 0
56750: PPUSH
56751: CALL_OW 1
56755: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56756: LD_ADDR_EXP 82
56760: PUSH
56761: LD_EXP 82
56765: PPUSH
56766: LD_VAR 0 2
56770: PPUSH
56771: EMPTY
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56778: LD_ADDR_EXP 93
56782: PUSH
56783: LD_EXP 93
56787: PPUSH
56788: LD_VAR 0 2
56792: PPUSH
56793: LD_INT 0
56795: PPUSH
56796: CALL_OW 1
56800: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56801: LD_ADDR_EXP 95
56805: PUSH
56806: LD_EXP 95
56810: PPUSH
56811: LD_VAR 0 2
56815: PPUSH
56816: EMPTY
56817: PPUSH
56818: CALL_OW 1
56822: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56823: LD_ADDR_EXP 98
56827: PUSH
56828: LD_EXP 98
56832: PPUSH
56833: LD_VAR 0 2
56837: PPUSH
56838: LD_INT 0
56840: PPUSH
56841: CALL_OW 1
56845: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56846: LD_ADDR_EXP 99
56850: PUSH
56851: LD_EXP 99
56855: PPUSH
56856: LD_VAR 0 2
56860: PPUSH
56861: EMPTY
56862: PPUSH
56863: CALL_OW 1
56867: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56868: LD_ADDR_EXP 100
56872: PUSH
56873: LD_EXP 100
56877: PPUSH
56878: LD_VAR 0 2
56882: PPUSH
56883: EMPTY
56884: PPUSH
56885: CALL_OW 1
56889: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56890: LD_ADDR_EXP 101
56894: PUSH
56895: LD_EXP 101
56899: PPUSH
56900: LD_VAR 0 2
56904: PPUSH
56905: EMPTY
56906: PPUSH
56907: CALL_OW 1
56911: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56912: LD_ADDR_EXP 103
56916: PUSH
56917: LD_EXP 103
56921: PPUSH
56922: LD_VAR 0 2
56926: PPUSH
56927: LD_EXP 70
56931: PUSH
56932: LD_VAR 0 2
56936: ARRAY
56937: PPUSH
56938: LD_INT 2
56940: PUSH
56941: LD_INT 30
56943: PUSH
56944: LD_INT 6
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: PUSH
56951: LD_INT 30
56953: PUSH
56954: LD_INT 7
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PUSH
56961: LD_INT 30
56963: PUSH
56964: LD_INT 8
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: EMPTY
56972: LIST
56973: LIST
56974: LIST
56975: LIST
56976: PPUSH
56977: CALL_OW 72
56981: PPUSH
56982: CALL_OW 1
56986: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56987: LD_ADDR_EXP 104
56991: PUSH
56992: LD_EXP 104
56996: PPUSH
56997: LD_VAR 0 2
57001: PPUSH
57002: EMPTY
57003: PPUSH
57004: CALL_OW 1
57008: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57009: LD_ADDR_EXP 105
57013: PUSH
57014: LD_EXP 105
57018: PPUSH
57019: LD_VAR 0 2
57023: PPUSH
57024: EMPTY
57025: PPUSH
57026: CALL_OW 1
57030: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57031: LD_ADDR_EXP 106
57035: PUSH
57036: LD_EXP 106
57040: PPUSH
57041: LD_VAR 0 2
57045: PPUSH
57046: EMPTY
57047: PPUSH
57048: CALL_OW 1
57052: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57053: LD_ADDR_EXP 107
57057: PUSH
57058: LD_EXP 107
57062: PPUSH
57063: LD_VAR 0 2
57067: PPUSH
57068: EMPTY
57069: PPUSH
57070: CALL_OW 1
57074: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57075: LD_ADDR_EXP 108
57079: PUSH
57080: LD_EXP 108
57084: PPUSH
57085: LD_VAR 0 2
57089: PPUSH
57090: EMPTY
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57097: LD_ADDR_EXP 109
57101: PUSH
57102: LD_EXP 109
57106: PPUSH
57107: LD_VAR 0 2
57111: PPUSH
57112: EMPTY
57113: PPUSH
57114: CALL_OW 1
57118: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57119: LD_ADDR_EXP 110
57123: PUSH
57124: LD_EXP 110
57128: PPUSH
57129: LD_VAR 0 2
57133: PPUSH
57134: EMPTY
57135: PPUSH
57136: CALL_OW 1
57140: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57141: LD_ADDR_EXP 111
57145: PUSH
57146: LD_EXP 111
57150: PPUSH
57151: LD_VAR 0 2
57155: PPUSH
57156: EMPTY
57157: PPUSH
57158: CALL_OW 1
57162: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57163: LD_ADDR_EXP 112
57167: PUSH
57168: LD_EXP 112
57172: PPUSH
57173: LD_VAR 0 2
57177: PPUSH
57178: LD_INT 0
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57186: LD_ADDR_EXP 113
57190: PUSH
57191: LD_EXP 113
57195: PPUSH
57196: LD_VAR 0 2
57200: PPUSH
57201: LD_INT 0
57203: PPUSH
57204: CALL_OW 1
57208: ST_TO_ADDR
// end ;
57209: GO 56110
57211: POP
57212: POP
// MC_InitSides ( ) ;
57213: CALL 57499 0 0
// MC_InitResearch ( ) ;
57217: CALL 57238 0 0
// CustomInitMacro ( ) ;
57221: CALL 5753 0 0
// skirmish := true ;
57225: LD_ADDR_EXP 68
57229: PUSH
57230: LD_INT 1
57232: ST_TO_ADDR
// end ;
57233: LD_VAR 0 1
57237: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57238: LD_INT 0
57240: PPUSH
57241: PPUSH
57242: PPUSH
57243: PPUSH
57244: PPUSH
57245: PPUSH
// if not mc_bases then
57246: LD_EXP 70
57250: NOT
57251: IFFALSE 57255
// exit ;
57253: GO 57494
// for i = 1 to 8 do
57255: LD_ADDR_VAR 0 2
57259: PUSH
57260: DOUBLE
57261: LD_INT 1
57263: DEC
57264: ST_TO_ADDR
57265: LD_INT 8
57267: PUSH
57268: FOR_TO
57269: IFFALSE 57295
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57271: LD_ADDR_EXP 97
57275: PUSH
57276: LD_EXP 97
57280: PPUSH
57281: LD_VAR 0 2
57285: PPUSH
57286: EMPTY
57287: PPUSH
57288: CALL_OW 1
57292: ST_TO_ADDR
57293: GO 57268
57295: POP
57296: POP
// tmp := [ ] ;
57297: LD_ADDR_VAR 0 5
57301: PUSH
57302: EMPTY
57303: ST_TO_ADDR
// for i = 1 to mc_sides do
57304: LD_ADDR_VAR 0 2
57308: PUSH
57309: DOUBLE
57310: LD_INT 1
57312: DEC
57313: ST_TO_ADDR
57314: LD_EXP 96
57318: PUSH
57319: FOR_TO
57320: IFFALSE 57378
// if not mc_sides [ i ] in tmp then
57322: LD_EXP 96
57326: PUSH
57327: LD_VAR 0 2
57331: ARRAY
57332: PUSH
57333: LD_VAR 0 5
57337: IN
57338: NOT
57339: IFFALSE 57376
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57341: LD_ADDR_VAR 0 5
57345: PUSH
57346: LD_VAR 0 5
57350: PPUSH
57351: LD_VAR 0 5
57355: PUSH
57356: LD_INT 1
57358: PLUS
57359: PPUSH
57360: LD_EXP 96
57364: PUSH
57365: LD_VAR 0 2
57369: ARRAY
57370: PPUSH
57371: CALL_OW 2
57375: ST_TO_ADDR
57376: GO 57319
57378: POP
57379: POP
// if not tmp then
57380: LD_VAR 0 5
57384: NOT
57385: IFFALSE 57389
// exit ;
57387: GO 57494
// for j in tmp do
57389: LD_ADDR_VAR 0 3
57393: PUSH
57394: LD_VAR 0 5
57398: PUSH
57399: FOR_IN
57400: IFFALSE 57492
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57402: LD_ADDR_VAR 0 6
57406: PUSH
57407: LD_INT 22
57409: PUSH
57410: LD_VAR 0 3
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PPUSH
57419: CALL_OW 69
57423: ST_TO_ADDR
// if not un then
57424: LD_VAR 0 6
57428: NOT
57429: IFFALSE 57433
// continue ;
57431: GO 57399
// nation := GetNation ( un [ 1 ] ) ;
57433: LD_ADDR_VAR 0 4
57437: PUSH
57438: LD_VAR 0 6
57442: PUSH
57443: LD_INT 1
57445: ARRAY
57446: PPUSH
57447: CALL_OW 248
57451: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57452: LD_ADDR_EXP 97
57456: PUSH
57457: LD_EXP 97
57461: PPUSH
57462: LD_VAR 0 3
57466: PPUSH
57467: LD_VAR 0 3
57471: PPUSH
57472: LD_VAR 0 4
57476: PPUSH
57477: LD_INT 1
57479: PPUSH
57480: CALL 13674 0 3
57484: PPUSH
57485: CALL_OW 1
57489: ST_TO_ADDR
// end ;
57490: GO 57399
57492: POP
57493: POP
// end ;
57494: LD_VAR 0 1
57498: RET
// export function MC_InitSides ( ) ; var i ; begin
57499: LD_INT 0
57501: PPUSH
57502: PPUSH
// if not mc_bases then
57503: LD_EXP 70
57507: NOT
57508: IFFALSE 57512
// exit ;
57510: GO 57586
// for i = 1 to mc_bases do
57512: LD_ADDR_VAR 0 2
57516: PUSH
57517: DOUBLE
57518: LD_INT 1
57520: DEC
57521: ST_TO_ADDR
57522: LD_EXP 70
57526: PUSH
57527: FOR_TO
57528: IFFALSE 57584
// if mc_bases [ i ] then
57530: LD_EXP 70
57534: PUSH
57535: LD_VAR 0 2
57539: ARRAY
57540: IFFALSE 57582
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57542: LD_ADDR_EXP 96
57546: PUSH
57547: LD_EXP 96
57551: PPUSH
57552: LD_VAR 0 2
57556: PPUSH
57557: LD_EXP 70
57561: PUSH
57562: LD_VAR 0 2
57566: ARRAY
57567: PUSH
57568: LD_INT 1
57570: ARRAY
57571: PPUSH
57572: CALL_OW 255
57576: PPUSH
57577: CALL_OW 1
57581: ST_TO_ADDR
57582: GO 57527
57584: POP
57585: POP
// end ;
57586: LD_VAR 0 1
57590: RET
// every 0 0$03 trigger skirmish do
57591: LD_EXP 68
57595: IFFALSE 57749
57597: GO 57599
57599: DISABLE
// begin enable ;
57600: ENABLE
// MC_CheckBuildings ( ) ;
57601: CALL 62247 0 0
// MC_CheckPeopleLife ( ) ;
57605: CALL 62408 0 0
// RaiseSailEvent ( 100 ) ;
57609: LD_INT 100
57611: PPUSH
57612: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57616: LD_INT 103
57618: PPUSH
57619: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57623: LD_INT 104
57625: PPUSH
57626: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57630: LD_INT 105
57632: PPUSH
57633: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57637: LD_INT 106
57639: PPUSH
57640: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57644: LD_INT 107
57646: PPUSH
57647: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57651: LD_INT 108
57653: PPUSH
57654: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57658: LD_INT 109
57660: PPUSH
57661: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57665: LD_INT 110
57667: PPUSH
57668: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57672: LD_INT 111
57674: PPUSH
57675: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57679: LD_INT 112
57681: PPUSH
57682: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57686: LD_INT 113
57688: PPUSH
57689: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57693: LD_INT 120
57695: PPUSH
57696: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57700: LD_INT 121
57702: PPUSH
57703: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57707: LD_INT 122
57709: PPUSH
57710: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57714: LD_INT 123
57716: PPUSH
57717: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57721: LD_INT 124
57723: PPUSH
57724: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57728: LD_INT 125
57730: PPUSH
57731: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57735: LD_INT 126
57737: PPUSH
57738: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57742: LD_INT 200
57744: PPUSH
57745: CALL_OW 427
// end ;
57749: END
// on SailEvent ( event ) do begin if event < 100 then
57750: LD_VAR 0 1
57754: PUSH
57755: LD_INT 100
57757: LESS
57758: IFFALSE 57769
// CustomEvent ( event ) ;
57760: LD_VAR 0 1
57764: PPUSH
57765: CALL 5745 0 1
// if event = 100 then
57769: LD_VAR 0 1
57773: PUSH
57774: LD_INT 100
57776: EQUAL
57777: IFFALSE 57783
// MC_ClassManager ( ) ;
57779: CALL 58175 0 0
// if event = 101 then
57783: LD_VAR 0 1
57787: PUSH
57788: LD_INT 101
57790: EQUAL
57791: IFFALSE 57797
// MC_RepairBuildings ( ) ;
57793: CALL 62993 0 0
// if event = 102 then
57797: LD_VAR 0 1
57801: PUSH
57802: LD_INT 102
57804: EQUAL
57805: IFFALSE 57811
// MC_Heal ( ) ;
57807: CALL 63900 0 0
// if event = 103 then
57811: LD_VAR 0 1
57815: PUSH
57816: LD_INT 103
57818: EQUAL
57819: IFFALSE 57825
// MC_Build ( ) ;
57821: CALL 64322 0 0
// if event = 104 then
57825: LD_VAR 0 1
57829: PUSH
57830: LD_INT 104
57832: EQUAL
57833: IFFALSE 57839
// MC_TurretWeapon ( ) ;
57835: CALL 65963 0 0
// if event = 105 then
57839: LD_VAR 0 1
57843: PUSH
57844: LD_INT 105
57846: EQUAL
57847: IFFALSE 57853
// MC_BuildUpgrade ( ) ;
57849: CALL 65514 0 0
// if event = 106 then
57853: LD_VAR 0 1
57857: PUSH
57858: LD_INT 106
57860: EQUAL
57861: IFFALSE 57867
// MC_PlantMines ( ) ;
57863: CALL 66393 0 0
// if event = 107 then
57867: LD_VAR 0 1
57871: PUSH
57872: LD_INT 107
57874: EQUAL
57875: IFFALSE 57881
// MC_CollectCrates ( ) ;
57877: CALL 67184 0 0
// if event = 108 then
57881: LD_VAR 0 1
57885: PUSH
57886: LD_INT 108
57888: EQUAL
57889: IFFALSE 57895
// MC_LinkRemoteControl ( ) ;
57891: CALL 69034 0 0
// if event = 109 then
57895: LD_VAR 0 1
57899: PUSH
57900: LD_INT 109
57902: EQUAL
57903: IFFALSE 57909
// MC_ProduceVehicle ( ) ;
57905: CALL 69215 0 0
// if event = 110 then
57909: LD_VAR 0 1
57913: PUSH
57914: LD_INT 110
57916: EQUAL
57917: IFFALSE 57923
// MC_SendAttack ( ) ;
57919: CALL 69681 0 0
// if event = 111 then
57923: LD_VAR 0 1
57927: PUSH
57928: LD_INT 111
57930: EQUAL
57931: IFFALSE 57937
// MC_Defend ( ) ;
57933: CALL 69789 0 0
// if event = 112 then
57937: LD_VAR 0 1
57941: PUSH
57942: LD_INT 112
57944: EQUAL
57945: IFFALSE 57951
// MC_Research ( ) ;
57947: CALL 70669 0 0
// if event = 113 then
57951: LD_VAR 0 1
57955: PUSH
57956: LD_INT 113
57958: EQUAL
57959: IFFALSE 57965
// MC_MinesTrigger ( ) ;
57961: CALL 71783 0 0
// if event = 120 then
57965: LD_VAR 0 1
57969: PUSH
57970: LD_INT 120
57972: EQUAL
57973: IFFALSE 57979
// MC_RepairVehicle ( ) ;
57975: CALL 71882 0 0
// if event = 121 then
57979: LD_VAR 0 1
57983: PUSH
57984: LD_INT 121
57986: EQUAL
57987: IFFALSE 57993
// MC_TameApe ( ) ;
57989: CALL 72623 0 0
// if event = 122 then
57993: LD_VAR 0 1
57997: PUSH
57998: LD_INT 122
58000: EQUAL
58001: IFFALSE 58007
// MC_ChangeApeClass ( ) ;
58003: CALL 73452 0 0
// if event = 123 then
58007: LD_VAR 0 1
58011: PUSH
58012: LD_INT 123
58014: EQUAL
58015: IFFALSE 58021
// MC_Bazooka ( ) ;
58017: CALL 74102 0 0
// if event = 124 then
58021: LD_VAR 0 1
58025: PUSH
58026: LD_INT 124
58028: EQUAL
58029: IFFALSE 58035
// MC_TeleportExit ( ) ;
58031: CALL 74300 0 0
// if event = 125 then
58035: LD_VAR 0 1
58039: PUSH
58040: LD_INT 125
58042: EQUAL
58043: IFFALSE 58049
// MC_Deposits ( ) ;
58045: CALL 74947 0 0
// if event = 126 then
58049: LD_VAR 0 1
58053: PUSH
58054: LD_INT 126
58056: EQUAL
58057: IFFALSE 58063
// MC_RemoteDriver ( ) ;
58059: CALL 75572 0 0
// if event = 200 then
58063: LD_VAR 0 1
58067: PUSH
58068: LD_INT 200
58070: EQUAL
58071: IFFALSE 58077
// MC_Idle ( ) ;
58073: CALL 77521 0 0
// end ;
58077: PPOPN 1
58079: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58080: LD_INT 0
58082: PPUSH
58083: PPUSH
// if not mc_bases [ base ] or not tag then
58084: LD_EXP 70
58088: PUSH
58089: LD_VAR 0 1
58093: ARRAY
58094: NOT
58095: PUSH
58096: LD_VAR 0 2
58100: NOT
58101: OR
58102: IFFALSE 58106
// exit ;
58104: GO 58170
// for i in mc_bases [ base ] union mc_ape [ base ] do
58106: LD_ADDR_VAR 0 4
58110: PUSH
58111: LD_EXP 70
58115: PUSH
58116: LD_VAR 0 1
58120: ARRAY
58121: PUSH
58122: LD_EXP 99
58126: PUSH
58127: LD_VAR 0 1
58131: ARRAY
58132: UNION
58133: PUSH
58134: FOR_IN
58135: IFFALSE 58168
// if GetTag ( i ) = tag then
58137: LD_VAR 0 4
58141: PPUSH
58142: CALL_OW 110
58146: PUSH
58147: LD_VAR 0 2
58151: EQUAL
58152: IFFALSE 58166
// SetTag ( i , 0 ) ;
58154: LD_VAR 0 4
58158: PPUSH
58159: LD_INT 0
58161: PPUSH
58162: CALL_OW 109
58166: GO 58134
58168: POP
58169: POP
// end ;
58170: LD_VAR 0 3
58174: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58175: LD_INT 0
58177: PPUSH
58178: PPUSH
58179: PPUSH
58180: PPUSH
58181: PPUSH
58182: PPUSH
58183: PPUSH
58184: PPUSH
// if not mc_bases then
58185: LD_EXP 70
58189: NOT
58190: IFFALSE 58194
// exit ;
58192: GO 58652
// for i = 1 to mc_bases do
58194: LD_ADDR_VAR 0 2
58198: PUSH
58199: DOUBLE
58200: LD_INT 1
58202: DEC
58203: ST_TO_ADDR
58204: LD_EXP 70
58208: PUSH
58209: FOR_TO
58210: IFFALSE 58650
// begin tmp := MC_ClassCheckReq ( i ) ;
58212: LD_ADDR_VAR 0 4
58216: PUSH
58217: LD_VAR 0 2
58221: PPUSH
58222: CALL 58657 0 1
58226: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58227: LD_ADDR_EXP 111
58231: PUSH
58232: LD_EXP 111
58236: PPUSH
58237: LD_VAR 0 2
58241: PPUSH
58242: LD_VAR 0 4
58246: PPUSH
58247: CALL_OW 1
58251: ST_TO_ADDR
// if not tmp then
58252: LD_VAR 0 4
58256: NOT
58257: IFFALSE 58261
// continue ;
58259: GO 58209
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58261: LD_ADDR_VAR 0 6
58265: PUSH
58266: LD_EXP 70
58270: PUSH
58271: LD_VAR 0 2
58275: ARRAY
58276: PPUSH
58277: LD_INT 2
58279: PUSH
58280: LD_INT 30
58282: PUSH
58283: LD_INT 4
58285: PUSH
58286: EMPTY
58287: LIST
58288: LIST
58289: PUSH
58290: LD_INT 30
58292: PUSH
58293: LD_INT 5
58295: PUSH
58296: EMPTY
58297: LIST
58298: LIST
58299: PUSH
58300: EMPTY
58301: LIST
58302: LIST
58303: LIST
58304: PPUSH
58305: CALL_OW 72
58309: PUSH
58310: LD_EXP 70
58314: PUSH
58315: LD_VAR 0 2
58319: ARRAY
58320: PPUSH
58321: LD_INT 2
58323: PUSH
58324: LD_INT 30
58326: PUSH
58327: LD_INT 0
58329: PUSH
58330: EMPTY
58331: LIST
58332: LIST
58333: PUSH
58334: LD_INT 30
58336: PUSH
58337: LD_INT 1
58339: PUSH
58340: EMPTY
58341: LIST
58342: LIST
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: LIST
58348: PPUSH
58349: CALL_OW 72
58353: PUSH
58354: LD_EXP 70
58358: PUSH
58359: LD_VAR 0 2
58363: ARRAY
58364: PPUSH
58365: LD_INT 30
58367: PUSH
58368: LD_INT 3
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PPUSH
58375: CALL_OW 72
58379: PUSH
58380: LD_EXP 70
58384: PUSH
58385: LD_VAR 0 2
58389: ARRAY
58390: PPUSH
58391: LD_INT 2
58393: PUSH
58394: LD_INT 30
58396: PUSH
58397: LD_INT 6
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 30
58406: PUSH
58407: LD_INT 7
58409: PUSH
58410: EMPTY
58411: LIST
58412: LIST
58413: PUSH
58414: LD_INT 30
58416: PUSH
58417: LD_INT 8
58419: PUSH
58420: EMPTY
58421: LIST
58422: LIST
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: LIST
58428: LIST
58429: PPUSH
58430: CALL_OW 72
58434: PUSH
58435: EMPTY
58436: LIST
58437: LIST
58438: LIST
58439: LIST
58440: ST_TO_ADDR
// for j = 1 to 4 do
58441: LD_ADDR_VAR 0 3
58445: PUSH
58446: DOUBLE
58447: LD_INT 1
58449: DEC
58450: ST_TO_ADDR
58451: LD_INT 4
58453: PUSH
58454: FOR_TO
58455: IFFALSE 58646
// begin if not tmp [ j ] then
58457: LD_VAR 0 4
58461: PUSH
58462: LD_VAR 0 3
58466: ARRAY
58467: NOT
58468: IFFALSE 58472
// continue ;
58470: GO 58454
// for p in tmp [ j ] do
58472: LD_ADDR_VAR 0 5
58476: PUSH
58477: LD_VAR 0 4
58481: PUSH
58482: LD_VAR 0 3
58486: ARRAY
58487: PUSH
58488: FOR_IN
58489: IFFALSE 58642
// begin if not b [ j ] then
58491: LD_VAR 0 6
58495: PUSH
58496: LD_VAR 0 3
58500: ARRAY
58501: NOT
58502: IFFALSE 58506
// break ;
58504: GO 58642
// e := 0 ;
58506: LD_ADDR_VAR 0 7
58510: PUSH
58511: LD_INT 0
58513: ST_TO_ADDR
// for k in b [ j ] do
58514: LD_ADDR_VAR 0 8
58518: PUSH
58519: LD_VAR 0 6
58523: PUSH
58524: LD_VAR 0 3
58528: ARRAY
58529: PUSH
58530: FOR_IN
58531: IFFALSE 58558
// if IsNotFull ( k ) then
58533: LD_VAR 0 8
58537: PPUSH
58538: CALL 15827 0 1
58542: IFFALSE 58556
// begin e := k ;
58544: LD_ADDR_VAR 0 7
58548: PUSH
58549: LD_VAR 0 8
58553: ST_TO_ADDR
// break ;
58554: GO 58558
// end ;
58556: GO 58530
58558: POP
58559: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58560: LD_VAR 0 7
58564: PUSH
58565: LD_VAR 0 5
58569: PPUSH
58570: LD_VAR 0 7
58574: PPUSH
58575: CALL 48938 0 2
58579: NOT
58580: AND
58581: IFFALSE 58640
// begin if IsInUnit ( p ) then
58583: LD_VAR 0 5
58587: PPUSH
58588: CALL_OW 310
58592: IFFALSE 58603
// ComExitBuilding ( p ) ;
58594: LD_VAR 0 5
58598: PPUSH
58599: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58603: LD_VAR 0 5
58607: PPUSH
58608: LD_VAR 0 7
58612: PPUSH
58613: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58617: LD_VAR 0 5
58621: PPUSH
58622: LD_VAR 0 3
58626: PPUSH
58627: CALL_OW 183
// AddComExitBuilding ( p ) ;
58631: LD_VAR 0 5
58635: PPUSH
58636: CALL_OW 182
// end ; end ;
58640: GO 58488
58642: POP
58643: POP
// end ;
58644: GO 58454
58646: POP
58647: POP
// end ;
58648: GO 58209
58650: POP
58651: POP
// end ;
58652: LD_VAR 0 1
58656: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58657: LD_INT 0
58659: PPUSH
58660: PPUSH
58661: PPUSH
58662: PPUSH
58663: PPUSH
58664: PPUSH
58665: PPUSH
58666: PPUSH
58667: PPUSH
58668: PPUSH
58669: PPUSH
58670: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58671: LD_VAR 0 1
58675: NOT
58676: PUSH
58677: LD_EXP 70
58681: PUSH
58682: LD_VAR 0 1
58686: ARRAY
58687: NOT
58688: OR
58689: PUSH
58690: LD_EXP 70
58694: PUSH
58695: LD_VAR 0 1
58699: ARRAY
58700: PPUSH
58701: LD_INT 2
58703: PUSH
58704: LD_INT 30
58706: PUSH
58707: LD_INT 0
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: PUSH
58714: LD_INT 30
58716: PUSH
58717: LD_INT 1
58719: PUSH
58720: EMPTY
58721: LIST
58722: LIST
58723: PUSH
58724: EMPTY
58725: LIST
58726: LIST
58727: LIST
58728: PPUSH
58729: CALL_OW 72
58733: NOT
58734: OR
58735: IFFALSE 58739
// exit ;
58737: GO 62242
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58739: LD_ADDR_VAR 0 4
58743: PUSH
58744: LD_EXP 70
58748: PUSH
58749: LD_VAR 0 1
58753: ARRAY
58754: PPUSH
58755: LD_INT 2
58757: PUSH
58758: LD_INT 25
58760: PUSH
58761: LD_INT 1
58763: PUSH
58764: EMPTY
58765: LIST
58766: LIST
58767: PUSH
58768: LD_INT 25
58770: PUSH
58771: LD_INT 2
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: PUSH
58778: LD_INT 25
58780: PUSH
58781: LD_INT 3
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PUSH
58788: LD_INT 25
58790: PUSH
58791: LD_INT 4
58793: PUSH
58794: EMPTY
58795: LIST
58796: LIST
58797: PUSH
58798: LD_INT 25
58800: PUSH
58801: LD_INT 5
58803: PUSH
58804: EMPTY
58805: LIST
58806: LIST
58807: PUSH
58808: LD_INT 25
58810: PUSH
58811: LD_INT 8
58813: PUSH
58814: EMPTY
58815: LIST
58816: LIST
58817: PUSH
58818: LD_INT 25
58820: PUSH
58821: LD_INT 9
58823: PUSH
58824: EMPTY
58825: LIST
58826: LIST
58827: PUSH
58828: EMPTY
58829: LIST
58830: LIST
58831: LIST
58832: LIST
58833: LIST
58834: LIST
58835: LIST
58836: LIST
58837: PPUSH
58838: CALL_OW 72
58842: ST_TO_ADDR
// if not tmp then
58843: LD_VAR 0 4
58847: NOT
58848: IFFALSE 58852
// exit ;
58850: GO 62242
// for i in tmp do
58852: LD_ADDR_VAR 0 3
58856: PUSH
58857: LD_VAR 0 4
58861: PUSH
58862: FOR_IN
58863: IFFALSE 58894
// if GetTag ( i ) then
58865: LD_VAR 0 3
58869: PPUSH
58870: CALL_OW 110
58874: IFFALSE 58892
// tmp := tmp diff i ;
58876: LD_ADDR_VAR 0 4
58880: PUSH
58881: LD_VAR 0 4
58885: PUSH
58886: LD_VAR 0 3
58890: DIFF
58891: ST_TO_ADDR
58892: GO 58862
58894: POP
58895: POP
// if not tmp then
58896: LD_VAR 0 4
58900: NOT
58901: IFFALSE 58905
// exit ;
58903: GO 62242
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58905: LD_ADDR_VAR 0 5
58909: PUSH
58910: LD_EXP 70
58914: PUSH
58915: LD_VAR 0 1
58919: ARRAY
58920: PPUSH
58921: LD_INT 2
58923: PUSH
58924: LD_INT 25
58926: PUSH
58927: LD_INT 1
58929: PUSH
58930: EMPTY
58931: LIST
58932: LIST
58933: PUSH
58934: LD_INT 25
58936: PUSH
58937: LD_INT 5
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: PUSH
58944: LD_INT 25
58946: PUSH
58947: LD_INT 8
58949: PUSH
58950: EMPTY
58951: LIST
58952: LIST
58953: PUSH
58954: LD_INT 25
58956: PUSH
58957: LD_INT 9
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: LIST
58970: PPUSH
58971: CALL_OW 72
58975: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58976: LD_ADDR_VAR 0 6
58980: PUSH
58981: LD_EXP 70
58985: PUSH
58986: LD_VAR 0 1
58990: ARRAY
58991: PPUSH
58992: LD_INT 25
58994: PUSH
58995: LD_INT 2
58997: PUSH
58998: EMPTY
58999: LIST
59000: LIST
59001: PPUSH
59002: CALL_OW 72
59006: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59007: LD_ADDR_VAR 0 7
59011: PUSH
59012: LD_EXP 70
59016: PUSH
59017: LD_VAR 0 1
59021: ARRAY
59022: PPUSH
59023: LD_INT 25
59025: PUSH
59026: LD_INT 3
59028: PUSH
59029: EMPTY
59030: LIST
59031: LIST
59032: PPUSH
59033: CALL_OW 72
59037: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59038: LD_ADDR_VAR 0 8
59042: PUSH
59043: LD_EXP 70
59047: PUSH
59048: LD_VAR 0 1
59052: ARRAY
59053: PPUSH
59054: LD_INT 25
59056: PUSH
59057: LD_INT 4
59059: PUSH
59060: EMPTY
59061: LIST
59062: LIST
59063: PUSH
59064: LD_INT 24
59066: PUSH
59067: LD_INT 251
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: PUSH
59074: EMPTY
59075: LIST
59076: LIST
59077: PPUSH
59078: CALL_OW 72
59082: ST_TO_ADDR
// if mc_is_defending [ base ] then
59083: LD_EXP 113
59087: PUSH
59088: LD_VAR 0 1
59092: ARRAY
59093: IFFALSE 59554
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59095: LD_ADDR_EXP 112
59099: PUSH
59100: LD_EXP 112
59104: PPUSH
59105: LD_VAR 0 1
59109: PPUSH
59110: LD_INT 4
59112: PPUSH
59113: CALL_OW 1
59117: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59118: LD_ADDR_VAR 0 12
59122: PUSH
59123: LD_EXP 70
59127: PUSH
59128: LD_VAR 0 1
59132: ARRAY
59133: PPUSH
59134: LD_INT 2
59136: PUSH
59137: LD_INT 30
59139: PUSH
59140: LD_INT 4
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 5
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: LIST
59161: PPUSH
59162: CALL_OW 72
59166: ST_TO_ADDR
// if not b then
59167: LD_VAR 0 12
59171: NOT
59172: IFFALSE 59176
// exit ;
59174: GO 62242
// p := [ ] ;
59176: LD_ADDR_VAR 0 11
59180: PUSH
59181: EMPTY
59182: ST_TO_ADDR
// if sci >= 2 then
59183: LD_VAR 0 8
59187: PUSH
59188: LD_INT 2
59190: GREATEREQUAL
59191: IFFALSE 59222
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59193: LD_ADDR_VAR 0 8
59197: PUSH
59198: LD_VAR 0 8
59202: PUSH
59203: LD_INT 1
59205: ARRAY
59206: PUSH
59207: LD_VAR 0 8
59211: PUSH
59212: LD_INT 2
59214: ARRAY
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: ST_TO_ADDR
59220: GO 59283
// if sci = 1 then
59222: LD_VAR 0 8
59226: PUSH
59227: LD_INT 1
59229: EQUAL
59230: IFFALSE 59251
// sci := [ sci [ 1 ] ] else
59232: LD_ADDR_VAR 0 8
59236: PUSH
59237: LD_VAR 0 8
59241: PUSH
59242: LD_INT 1
59244: ARRAY
59245: PUSH
59246: EMPTY
59247: LIST
59248: ST_TO_ADDR
59249: GO 59283
// if sci = 0 then
59251: LD_VAR 0 8
59255: PUSH
59256: LD_INT 0
59258: EQUAL
59259: IFFALSE 59283
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59261: LD_ADDR_VAR 0 11
59265: PUSH
59266: LD_VAR 0 4
59270: PPUSH
59271: LD_INT 4
59273: PPUSH
59274: CALL 48801 0 2
59278: PUSH
59279: LD_INT 1
59281: ARRAY
59282: ST_TO_ADDR
// if eng > 4 then
59283: LD_VAR 0 6
59287: PUSH
59288: LD_INT 4
59290: GREATER
59291: IFFALSE 59337
// for i = eng downto 4 do
59293: LD_ADDR_VAR 0 3
59297: PUSH
59298: DOUBLE
59299: LD_VAR 0 6
59303: INC
59304: ST_TO_ADDR
59305: LD_INT 4
59307: PUSH
59308: FOR_DOWNTO
59309: IFFALSE 59335
// eng := eng diff eng [ i ] ;
59311: LD_ADDR_VAR 0 6
59315: PUSH
59316: LD_VAR 0 6
59320: PUSH
59321: LD_VAR 0 6
59325: PUSH
59326: LD_VAR 0 3
59330: ARRAY
59331: DIFF
59332: ST_TO_ADDR
59333: GO 59308
59335: POP
59336: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59337: LD_ADDR_VAR 0 4
59341: PUSH
59342: LD_VAR 0 4
59346: PUSH
59347: LD_VAR 0 5
59351: PUSH
59352: LD_VAR 0 6
59356: UNION
59357: PUSH
59358: LD_VAR 0 7
59362: UNION
59363: PUSH
59364: LD_VAR 0 8
59368: UNION
59369: DIFF
59370: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59371: LD_ADDR_VAR 0 13
59375: PUSH
59376: LD_EXP 70
59380: PUSH
59381: LD_VAR 0 1
59385: ARRAY
59386: PPUSH
59387: LD_INT 2
59389: PUSH
59390: LD_INT 30
59392: PUSH
59393: LD_INT 32
59395: PUSH
59396: EMPTY
59397: LIST
59398: LIST
59399: PUSH
59400: LD_INT 30
59402: PUSH
59403: LD_INT 31
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PUSH
59410: EMPTY
59411: LIST
59412: LIST
59413: LIST
59414: PPUSH
59415: CALL_OW 72
59419: PUSH
59420: LD_EXP 70
59424: PUSH
59425: LD_VAR 0 1
59429: ARRAY
59430: PPUSH
59431: LD_INT 2
59433: PUSH
59434: LD_INT 30
59436: PUSH
59437: LD_INT 4
59439: PUSH
59440: EMPTY
59441: LIST
59442: LIST
59443: PUSH
59444: LD_INT 30
59446: PUSH
59447: LD_INT 5
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: LIST
59458: PPUSH
59459: CALL_OW 72
59463: PUSH
59464: LD_INT 6
59466: MUL
59467: PLUS
59468: ST_TO_ADDR
// if bcount < tmp then
59469: LD_VAR 0 13
59473: PUSH
59474: LD_VAR 0 4
59478: LESS
59479: IFFALSE 59525
// for i = tmp downto bcount do
59481: LD_ADDR_VAR 0 3
59485: PUSH
59486: DOUBLE
59487: LD_VAR 0 4
59491: INC
59492: ST_TO_ADDR
59493: LD_VAR 0 13
59497: PUSH
59498: FOR_DOWNTO
59499: IFFALSE 59523
// tmp := Delete ( tmp , tmp ) ;
59501: LD_ADDR_VAR 0 4
59505: PUSH
59506: LD_VAR 0 4
59510: PPUSH
59511: LD_VAR 0 4
59515: PPUSH
59516: CALL_OW 3
59520: ST_TO_ADDR
59521: GO 59498
59523: POP
59524: POP
// result := [ tmp , 0 , 0 , p ] ;
59525: LD_ADDR_VAR 0 2
59529: PUSH
59530: LD_VAR 0 4
59534: PUSH
59535: LD_INT 0
59537: PUSH
59538: LD_INT 0
59540: PUSH
59541: LD_VAR 0 11
59545: PUSH
59546: EMPTY
59547: LIST
59548: LIST
59549: LIST
59550: LIST
59551: ST_TO_ADDR
// exit ;
59552: GO 62242
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59554: LD_EXP 70
59558: PUSH
59559: LD_VAR 0 1
59563: ARRAY
59564: PPUSH
59565: LD_INT 2
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_INT 6
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: PUSH
59578: LD_INT 30
59580: PUSH
59581: LD_INT 7
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: PUSH
59588: LD_INT 30
59590: PUSH
59591: LD_INT 8
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: LIST
59602: LIST
59603: PPUSH
59604: CALL_OW 72
59608: NOT
59609: PUSH
59610: LD_EXP 70
59614: PUSH
59615: LD_VAR 0 1
59619: ARRAY
59620: PPUSH
59621: LD_INT 30
59623: PUSH
59624: LD_INT 3
59626: PUSH
59627: EMPTY
59628: LIST
59629: LIST
59630: PPUSH
59631: CALL_OW 72
59635: NOT
59636: AND
59637: IFFALSE 59709
// begin if eng = tmp then
59639: LD_VAR 0 6
59643: PUSH
59644: LD_VAR 0 4
59648: EQUAL
59649: IFFALSE 59653
// exit ;
59651: GO 62242
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59653: LD_ADDR_EXP 112
59657: PUSH
59658: LD_EXP 112
59662: PPUSH
59663: LD_VAR 0 1
59667: PPUSH
59668: LD_INT 1
59670: PPUSH
59671: CALL_OW 1
59675: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59676: LD_ADDR_VAR 0 2
59680: PUSH
59681: LD_INT 0
59683: PUSH
59684: LD_VAR 0 4
59688: PUSH
59689: LD_VAR 0 6
59693: DIFF
59694: PUSH
59695: LD_INT 0
59697: PUSH
59698: LD_INT 0
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: LIST
59705: LIST
59706: ST_TO_ADDR
// exit ;
59707: GO 62242
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59709: LD_EXP 97
59713: PUSH
59714: LD_EXP 96
59718: PUSH
59719: LD_VAR 0 1
59723: ARRAY
59724: ARRAY
59725: PUSH
59726: LD_EXP 70
59730: PUSH
59731: LD_VAR 0 1
59735: ARRAY
59736: PPUSH
59737: LD_INT 2
59739: PUSH
59740: LD_INT 30
59742: PUSH
59743: LD_INT 6
59745: PUSH
59746: EMPTY
59747: LIST
59748: LIST
59749: PUSH
59750: LD_INT 30
59752: PUSH
59753: LD_INT 7
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: PUSH
59760: LD_INT 30
59762: PUSH
59763: LD_INT 8
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: LIST
59774: LIST
59775: PPUSH
59776: CALL_OW 72
59780: AND
59781: PUSH
59782: LD_EXP 70
59786: PUSH
59787: LD_VAR 0 1
59791: ARRAY
59792: PPUSH
59793: LD_INT 30
59795: PUSH
59796: LD_INT 3
59798: PUSH
59799: EMPTY
59800: LIST
59801: LIST
59802: PPUSH
59803: CALL_OW 72
59807: NOT
59808: AND
59809: IFFALSE 60023
// begin if sci >= 6 then
59811: LD_VAR 0 8
59815: PUSH
59816: LD_INT 6
59818: GREATEREQUAL
59819: IFFALSE 59823
// exit ;
59821: GO 62242
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59823: LD_ADDR_EXP 112
59827: PUSH
59828: LD_EXP 112
59832: PPUSH
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_INT 2
59840: PPUSH
59841: CALL_OW 1
59845: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59846: LD_ADDR_VAR 0 9
59850: PUSH
59851: LD_VAR 0 4
59855: PUSH
59856: LD_VAR 0 8
59860: DIFF
59861: PPUSH
59862: LD_INT 4
59864: PPUSH
59865: CALL 48801 0 2
59869: ST_TO_ADDR
// p := [ ] ;
59870: LD_ADDR_VAR 0 11
59874: PUSH
59875: EMPTY
59876: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59877: LD_VAR 0 8
59881: PUSH
59882: LD_INT 6
59884: LESS
59885: PUSH
59886: LD_VAR 0 9
59890: PUSH
59891: LD_INT 6
59893: GREATER
59894: AND
59895: IFFALSE 59976
// begin for i = 1 to 6 - sci do
59897: LD_ADDR_VAR 0 3
59901: PUSH
59902: DOUBLE
59903: LD_INT 1
59905: DEC
59906: ST_TO_ADDR
59907: LD_INT 6
59909: PUSH
59910: LD_VAR 0 8
59914: MINUS
59915: PUSH
59916: FOR_TO
59917: IFFALSE 59972
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59919: LD_ADDR_VAR 0 11
59923: PUSH
59924: LD_VAR 0 11
59928: PPUSH
59929: LD_VAR 0 11
59933: PUSH
59934: LD_INT 1
59936: PLUS
59937: PPUSH
59938: LD_VAR 0 9
59942: PUSH
59943: LD_INT 1
59945: ARRAY
59946: PPUSH
59947: CALL_OW 2
59951: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59952: LD_ADDR_VAR 0 9
59956: PUSH
59957: LD_VAR 0 9
59961: PPUSH
59962: LD_INT 1
59964: PPUSH
59965: CALL_OW 3
59969: ST_TO_ADDR
// end ;
59970: GO 59916
59972: POP
59973: POP
// end else
59974: GO 59996
// if sort then
59976: LD_VAR 0 9
59980: IFFALSE 59996
// p := sort [ 1 ] ;
59982: LD_ADDR_VAR 0 11
59986: PUSH
59987: LD_VAR 0 9
59991: PUSH
59992: LD_INT 1
59994: ARRAY
59995: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59996: LD_ADDR_VAR 0 2
60000: PUSH
60001: LD_INT 0
60003: PUSH
60004: LD_INT 0
60006: PUSH
60007: LD_INT 0
60009: PUSH
60010: LD_VAR 0 11
60014: PUSH
60015: EMPTY
60016: LIST
60017: LIST
60018: LIST
60019: LIST
60020: ST_TO_ADDR
// exit ;
60021: GO 62242
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60023: LD_EXP 97
60027: PUSH
60028: LD_EXP 96
60032: PUSH
60033: LD_VAR 0 1
60037: ARRAY
60038: ARRAY
60039: PUSH
60040: LD_EXP 70
60044: PUSH
60045: LD_VAR 0 1
60049: ARRAY
60050: PPUSH
60051: LD_INT 2
60053: PUSH
60054: LD_INT 30
60056: PUSH
60057: LD_INT 6
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: PUSH
60064: LD_INT 30
60066: PUSH
60067: LD_INT 7
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PUSH
60074: LD_INT 30
60076: PUSH
60077: LD_INT 8
60079: PUSH
60080: EMPTY
60081: LIST
60082: LIST
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: LIST
60088: LIST
60089: PPUSH
60090: CALL_OW 72
60094: AND
60095: PUSH
60096: LD_EXP 70
60100: PUSH
60101: LD_VAR 0 1
60105: ARRAY
60106: PPUSH
60107: LD_INT 30
60109: PUSH
60110: LD_INT 3
60112: PUSH
60113: EMPTY
60114: LIST
60115: LIST
60116: PPUSH
60117: CALL_OW 72
60121: AND
60122: IFFALSE 60856
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60124: LD_ADDR_EXP 112
60128: PUSH
60129: LD_EXP 112
60133: PPUSH
60134: LD_VAR 0 1
60138: PPUSH
60139: LD_INT 3
60141: PPUSH
60142: CALL_OW 1
60146: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60147: LD_ADDR_VAR 0 2
60151: PUSH
60152: LD_INT 0
60154: PUSH
60155: LD_INT 0
60157: PUSH
60158: LD_INT 0
60160: PUSH
60161: LD_INT 0
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: LIST
60168: LIST
60169: ST_TO_ADDR
// if not eng then
60170: LD_VAR 0 6
60174: NOT
60175: IFFALSE 60238
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60177: LD_ADDR_VAR 0 11
60181: PUSH
60182: LD_VAR 0 4
60186: PPUSH
60187: LD_INT 2
60189: PPUSH
60190: CALL 48801 0 2
60194: PUSH
60195: LD_INT 1
60197: ARRAY
60198: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60199: LD_ADDR_VAR 0 2
60203: PUSH
60204: LD_VAR 0 2
60208: PPUSH
60209: LD_INT 2
60211: PPUSH
60212: LD_VAR 0 11
60216: PPUSH
60217: CALL_OW 1
60221: ST_TO_ADDR
// tmp := tmp diff p ;
60222: LD_ADDR_VAR 0 4
60226: PUSH
60227: LD_VAR 0 4
60231: PUSH
60232: LD_VAR 0 11
60236: DIFF
60237: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60238: LD_VAR 0 4
60242: PUSH
60243: LD_VAR 0 8
60247: PUSH
60248: LD_INT 6
60250: LESS
60251: AND
60252: IFFALSE 60440
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60254: LD_ADDR_VAR 0 9
60258: PUSH
60259: LD_VAR 0 4
60263: PUSH
60264: LD_VAR 0 8
60268: PUSH
60269: LD_VAR 0 7
60273: UNION
60274: DIFF
60275: PPUSH
60276: LD_INT 4
60278: PPUSH
60279: CALL 48801 0 2
60283: ST_TO_ADDR
// p := [ ] ;
60284: LD_ADDR_VAR 0 11
60288: PUSH
60289: EMPTY
60290: ST_TO_ADDR
// if sort then
60291: LD_VAR 0 9
60295: IFFALSE 60411
// for i = 1 to 6 - sci do
60297: LD_ADDR_VAR 0 3
60301: PUSH
60302: DOUBLE
60303: LD_INT 1
60305: DEC
60306: ST_TO_ADDR
60307: LD_INT 6
60309: PUSH
60310: LD_VAR 0 8
60314: MINUS
60315: PUSH
60316: FOR_TO
60317: IFFALSE 60409
// begin if i = sort then
60319: LD_VAR 0 3
60323: PUSH
60324: LD_VAR 0 9
60328: EQUAL
60329: IFFALSE 60333
// break ;
60331: GO 60409
// if GetClass ( i ) = 4 then
60333: LD_VAR 0 3
60337: PPUSH
60338: CALL_OW 257
60342: PUSH
60343: LD_INT 4
60345: EQUAL
60346: IFFALSE 60350
// continue ;
60348: GO 60316
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60350: LD_ADDR_VAR 0 11
60354: PUSH
60355: LD_VAR 0 11
60359: PPUSH
60360: LD_VAR 0 11
60364: PUSH
60365: LD_INT 1
60367: PLUS
60368: PPUSH
60369: LD_VAR 0 9
60373: PUSH
60374: LD_VAR 0 3
60378: ARRAY
60379: PPUSH
60380: CALL_OW 2
60384: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60385: LD_ADDR_VAR 0 4
60389: PUSH
60390: LD_VAR 0 4
60394: PUSH
60395: LD_VAR 0 9
60399: PUSH
60400: LD_VAR 0 3
60404: ARRAY
60405: DIFF
60406: ST_TO_ADDR
// end ;
60407: GO 60316
60409: POP
60410: POP
// if p then
60411: LD_VAR 0 11
60415: IFFALSE 60440
// result := Replace ( result , 4 , p ) ;
60417: LD_ADDR_VAR 0 2
60421: PUSH
60422: LD_VAR 0 2
60426: PPUSH
60427: LD_INT 4
60429: PPUSH
60430: LD_VAR 0 11
60434: PPUSH
60435: CALL_OW 1
60439: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60440: LD_VAR 0 4
60444: PUSH
60445: LD_VAR 0 7
60449: PUSH
60450: LD_INT 6
60452: LESS
60453: AND
60454: IFFALSE 60642
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60456: LD_ADDR_VAR 0 9
60460: PUSH
60461: LD_VAR 0 4
60465: PUSH
60466: LD_VAR 0 8
60470: PUSH
60471: LD_VAR 0 7
60475: UNION
60476: DIFF
60477: PPUSH
60478: LD_INT 3
60480: PPUSH
60481: CALL 48801 0 2
60485: ST_TO_ADDR
// p := [ ] ;
60486: LD_ADDR_VAR 0 11
60490: PUSH
60491: EMPTY
60492: ST_TO_ADDR
// if sort then
60493: LD_VAR 0 9
60497: IFFALSE 60613
// for i = 1 to 6 - mech do
60499: LD_ADDR_VAR 0 3
60503: PUSH
60504: DOUBLE
60505: LD_INT 1
60507: DEC
60508: ST_TO_ADDR
60509: LD_INT 6
60511: PUSH
60512: LD_VAR 0 7
60516: MINUS
60517: PUSH
60518: FOR_TO
60519: IFFALSE 60611
// begin if i = sort then
60521: LD_VAR 0 3
60525: PUSH
60526: LD_VAR 0 9
60530: EQUAL
60531: IFFALSE 60535
// break ;
60533: GO 60611
// if GetClass ( i ) = 3 then
60535: LD_VAR 0 3
60539: PPUSH
60540: CALL_OW 257
60544: PUSH
60545: LD_INT 3
60547: EQUAL
60548: IFFALSE 60552
// continue ;
60550: GO 60518
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60552: LD_ADDR_VAR 0 11
60556: PUSH
60557: LD_VAR 0 11
60561: PPUSH
60562: LD_VAR 0 11
60566: PUSH
60567: LD_INT 1
60569: PLUS
60570: PPUSH
60571: LD_VAR 0 9
60575: PUSH
60576: LD_VAR 0 3
60580: ARRAY
60581: PPUSH
60582: CALL_OW 2
60586: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60587: LD_ADDR_VAR 0 4
60591: PUSH
60592: LD_VAR 0 4
60596: PUSH
60597: LD_VAR 0 9
60601: PUSH
60602: LD_VAR 0 3
60606: ARRAY
60607: DIFF
60608: ST_TO_ADDR
// end ;
60609: GO 60518
60611: POP
60612: POP
// if p then
60613: LD_VAR 0 11
60617: IFFALSE 60642
// result := Replace ( result , 3 , p ) ;
60619: LD_ADDR_VAR 0 2
60623: PUSH
60624: LD_VAR 0 2
60628: PPUSH
60629: LD_INT 3
60631: PPUSH
60632: LD_VAR 0 11
60636: PPUSH
60637: CALL_OW 1
60641: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60642: LD_VAR 0 4
60646: PUSH
60647: LD_INT 6
60649: GREATER
60650: PUSH
60651: LD_VAR 0 6
60655: PUSH
60656: LD_INT 6
60658: LESS
60659: AND
60660: IFFALSE 60854
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60662: LD_ADDR_VAR 0 9
60666: PUSH
60667: LD_VAR 0 4
60671: PUSH
60672: LD_VAR 0 8
60676: PUSH
60677: LD_VAR 0 7
60681: UNION
60682: PUSH
60683: LD_VAR 0 6
60687: UNION
60688: DIFF
60689: PPUSH
60690: LD_INT 2
60692: PPUSH
60693: CALL 48801 0 2
60697: ST_TO_ADDR
// p := [ ] ;
60698: LD_ADDR_VAR 0 11
60702: PUSH
60703: EMPTY
60704: ST_TO_ADDR
// if sort then
60705: LD_VAR 0 9
60709: IFFALSE 60825
// for i = 1 to 6 - eng do
60711: LD_ADDR_VAR 0 3
60715: PUSH
60716: DOUBLE
60717: LD_INT 1
60719: DEC
60720: ST_TO_ADDR
60721: LD_INT 6
60723: PUSH
60724: LD_VAR 0 6
60728: MINUS
60729: PUSH
60730: FOR_TO
60731: IFFALSE 60823
// begin if i = sort then
60733: LD_VAR 0 3
60737: PUSH
60738: LD_VAR 0 9
60742: EQUAL
60743: IFFALSE 60747
// break ;
60745: GO 60823
// if GetClass ( i ) = 2 then
60747: LD_VAR 0 3
60751: PPUSH
60752: CALL_OW 257
60756: PUSH
60757: LD_INT 2
60759: EQUAL
60760: IFFALSE 60764
// continue ;
60762: GO 60730
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60764: LD_ADDR_VAR 0 11
60768: PUSH
60769: LD_VAR 0 11
60773: PPUSH
60774: LD_VAR 0 11
60778: PUSH
60779: LD_INT 1
60781: PLUS
60782: PPUSH
60783: LD_VAR 0 9
60787: PUSH
60788: LD_VAR 0 3
60792: ARRAY
60793: PPUSH
60794: CALL_OW 2
60798: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60799: LD_ADDR_VAR 0 4
60803: PUSH
60804: LD_VAR 0 4
60808: PUSH
60809: LD_VAR 0 9
60813: PUSH
60814: LD_VAR 0 3
60818: ARRAY
60819: DIFF
60820: ST_TO_ADDR
// end ;
60821: GO 60730
60823: POP
60824: POP
// if p then
60825: LD_VAR 0 11
60829: IFFALSE 60854
// result := Replace ( result , 2 , p ) ;
60831: LD_ADDR_VAR 0 2
60835: PUSH
60836: LD_VAR 0 2
60840: PPUSH
60841: LD_INT 2
60843: PPUSH
60844: LD_VAR 0 11
60848: PPUSH
60849: CALL_OW 1
60853: ST_TO_ADDR
// end ; exit ;
60854: GO 62242
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60856: LD_EXP 97
60860: PUSH
60861: LD_EXP 96
60865: PUSH
60866: LD_VAR 0 1
60870: ARRAY
60871: ARRAY
60872: NOT
60873: PUSH
60874: LD_EXP 70
60878: PUSH
60879: LD_VAR 0 1
60883: ARRAY
60884: PPUSH
60885: LD_INT 30
60887: PUSH
60888: LD_INT 3
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: PPUSH
60895: CALL_OW 72
60899: AND
60900: PUSH
60901: LD_EXP 75
60905: PUSH
60906: LD_VAR 0 1
60910: ARRAY
60911: AND
60912: IFFALSE 61520
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60914: LD_ADDR_EXP 112
60918: PUSH
60919: LD_EXP 112
60923: PPUSH
60924: LD_VAR 0 1
60928: PPUSH
60929: LD_INT 5
60931: PPUSH
60932: CALL_OW 1
60936: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60937: LD_ADDR_VAR 0 2
60941: PUSH
60942: LD_INT 0
60944: PUSH
60945: LD_INT 0
60947: PUSH
60948: LD_INT 0
60950: PUSH
60951: LD_INT 0
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: LIST
60958: LIST
60959: ST_TO_ADDR
// if sci > 1 then
60960: LD_VAR 0 8
60964: PUSH
60965: LD_INT 1
60967: GREATER
60968: IFFALSE 60996
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60970: LD_ADDR_VAR 0 4
60974: PUSH
60975: LD_VAR 0 4
60979: PUSH
60980: LD_VAR 0 8
60984: PUSH
60985: LD_VAR 0 8
60989: PUSH
60990: LD_INT 1
60992: ARRAY
60993: DIFF
60994: DIFF
60995: ST_TO_ADDR
// if tmp and not sci then
60996: LD_VAR 0 4
61000: PUSH
61001: LD_VAR 0 8
61005: NOT
61006: AND
61007: IFFALSE 61076
// begin sort := SortBySkill ( tmp , 4 ) ;
61009: LD_ADDR_VAR 0 9
61013: PUSH
61014: LD_VAR 0 4
61018: PPUSH
61019: LD_INT 4
61021: PPUSH
61022: CALL 48801 0 2
61026: ST_TO_ADDR
// if sort then
61027: LD_VAR 0 9
61031: IFFALSE 61047
// p := sort [ 1 ] ;
61033: LD_ADDR_VAR 0 11
61037: PUSH
61038: LD_VAR 0 9
61042: PUSH
61043: LD_INT 1
61045: ARRAY
61046: ST_TO_ADDR
// if p then
61047: LD_VAR 0 11
61051: IFFALSE 61076
// result := Replace ( result , 4 , p ) ;
61053: LD_ADDR_VAR 0 2
61057: PUSH
61058: LD_VAR 0 2
61062: PPUSH
61063: LD_INT 4
61065: PPUSH
61066: LD_VAR 0 11
61070: PPUSH
61071: CALL_OW 1
61075: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61076: LD_ADDR_VAR 0 4
61080: PUSH
61081: LD_VAR 0 4
61085: PUSH
61086: LD_VAR 0 7
61090: DIFF
61091: ST_TO_ADDR
// if tmp and mech < 6 then
61092: LD_VAR 0 4
61096: PUSH
61097: LD_VAR 0 7
61101: PUSH
61102: LD_INT 6
61104: LESS
61105: AND
61106: IFFALSE 61294
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61108: LD_ADDR_VAR 0 9
61112: PUSH
61113: LD_VAR 0 4
61117: PUSH
61118: LD_VAR 0 8
61122: PUSH
61123: LD_VAR 0 7
61127: UNION
61128: DIFF
61129: PPUSH
61130: LD_INT 3
61132: PPUSH
61133: CALL 48801 0 2
61137: ST_TO_ADDR
// p := [ ] ;
61138: LD_ADDR_VAR 0 11
61142: PUSH
61143: EMPTY
61144: ST_TO_ADDR
// if sort then
61145: LD_VAR 0 9
61149: IFFALSE 61265
// for i = 1 to 6 - mech do
61151: LD_ADDR_VAR 0 3
61155: PUSH
61156: DOUBLE
61157: LD_INT 1
61159: DEC
61160: ST_TO_ADDR
61161: LD_INT 6
61163: PUSH
61164: LD_VAR 0 7
61168: MINUS
61169: PUSH
61170: FOR_TO
61171: IFFALSE 61263
// begin if i = sort then
61173: LD_VAR 0 3
61177: PUSH
61178: LD_VAR 0 9
61182: EQUAL
61183: IFFALSE 61187
// break ;
61185: GO 61263
// if GetClass ( i ) = 3 then
61187: LD_VAR 0 3
61191: PPUSH
61192: CALL_OW 257
61196: PUSH
61197: LD_INT 3
61199: EQUAL
61200: IFFALSE 61204
// continue ;
61202: GO 61170
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61204: LD_ADDR_VAR 0 11
61208: PUSH
61209: LD_VAR 0 11
61213: PPUSH
61214: LD_VAR 0 11
61218: PUSH
61219: LD_INT 1
61221: PLUS
61222: PPUSH
61223: LD_VAR 0 9
61227: PUSH
61228: LD_VAR 0 3
61232: ARRAY
61233: PPUSH
61234: CALL_OW 2
61238: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61239: LD_ADDR_VAR 0 4
61243: PUSH
61244: LD_VAR 0 4
61248: PUSH
61249: LD_VAR 0 9
61253: PUSH
61254: LD_VAR 0 3
61258: ARRAY
61259: DIFF
61260: ST_TO_ADDR
// end ;
61261: GO 61170
61263: POP
61264: POP
// if p then
61265: LD_VAR 0 11
61269: IFFALSE 61294
// result := Replace ( result , 3 , p ) ;
61271: LD_ADDR_VAR 0 2
61275: PUSH
61276: LD_VAR 0 2
61280: PPUSH
61281: LD_INT 3
61283: PPUSH
61284: LD_VAR 0 11
61288: PPUSH
61289: CALL_OW 1
61293: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61294: LD_ADDR_VAR 0 4
61298: PUSH
61299: LD_VAR 0 4
61303: PUSH
61304: LD_VAR 0 6
61308: DIFF
61309: ST_TO_ADDR
// if tmp and eng < 6 then
61310: LD_VAR 0 4
61314: PUSH
61315: LD_VAR 0 6
61319: PUSH
61320: LD_INT 6
61322: LESS
61323: AND
61324: IFFALSE 61518
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61326: LD_ADDR_VAR 0 9
61330: PUSH
61331: LD_VAR 0 4
61335: PUSH
61336: LD_VAR 0 8
61340: PUSH
61341: LD_VAR 0 7
61345: UNION
61346: PUSH
61347: LD_VAR 0 6
61351: UNION
61352: DIFF
61353: PPUSH
61354: LD_INT 2
61356: PPUSH
61357: CALL 48801 0 2
61361: ST_TO_ADDR
// p := [ ] ;
61362: LD_ADDR_VAR 0 11
61366: PUSH
61367: EMPTY
61368: ST_TO_ADDR
// if sort then
61369: LD_VAR 0 9
61373: IFFALSE 61489
// for i = 1 to 6 - eng do
61375: LD_ADDR_VAR 0 3
61379: PUSH
61380: DOUBLE
61381: LD_INT 1
61383: DEC
61384: ST_TO_ADDR
61385: LD_INT 6
61387: PUSH
61388: LD_VAR 0 6
61392: MINUS
61393: PUSH
61394: FOR_TO
61395: IFFALSE 61487
// begin if i = sort then
61397: LD_VAR 0 3
61401: PUSH
61402: LD_VAR 0 9
61406: EQUAL
61407: IFFALSE 61411
// break ;
61409: GO 61487
// if GetClass ( i ) = 2 then
61411: LD_VAR 0 3
61415: PPUSH
61416: CALL_OW 257
61420: PUSH
61421: LD_INT 2
61423: EQUAL
61424: IFFALSE 61428
// continue ;
61426: GO 61394
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61428: LD_ADDR_VAR 0 11
61432: PUSH
61433: LD_VAR 0 11
61437: PPUSH
61438: LD_VAR 0 11
61442: PUSH
61443: LD_INT 1
61445: PLUS
61446: PPUSH
61447: LD_VAR 0 9
61451: PUSH
61452: LD_VAR 0 3
61456: ARRAY
61457: PPUSH
61458: CALL_OW 2
61462: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61463: LD_ADDR_VAR 0 4
61467: PUSH
61468: LD_VAR 0 4
61472: PUSH
61473: LD_VAR 0 9
61477: PUSH
61478: LD_VAR 0 3
61482: ARRAY
61483: DIFF
61484: ST_TO_ADDR
// end ;
61485: GO 61394
61487: POP
61488: POP
// if p then
61489: LD_VAR 0 11
61493: IFFALSE 61518
// result := Replace ( result , 2 , p ) ;
61495: LD_ADDR_VAR 0 2
61499: PUSH
61500: LD_VAR 0 2
61504: PPUSH
61505: LD_INT 2
61507: PPUSH
61508: LD_VAR 0 11
61512: PPUSH
61513: CALL_OW 1
61517: ST_TO_ADDR
// end ; exit ;
61518: GO 62242
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61520: LD_EXP 97
61524: PUSH
61525: LD_EXP 96
61529: PUSH
61530: LD_VAR 0 1
61534: ARRAY
61535: ARRAY
61536: NOT
61537: PUSH
61538: LD_EXP 70
61542: PUSH
61543: LD_VAR 0 1
61547: ARRAY
61548: PPUSH
61549: LD_INT 30
61551: PUSH
61552: LD_INT 3
61554: PUSH
61555: EMPTY
61556: LIST
61557: LIST
61558: PPUSH
61559: CALL_OW 72
61563: AND
61564: PUSH
61565: LD_EXP 75
61569: PUSH
61570: LD_VAR 0 1
61574: ARRAY
61575: NOT
61576: AND
61577: IFFALSE 62242
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61579: LD_ADDR_EXP 112
61583: PUSH
61584: LD_EXP 112
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: LD_INT 6
61596: PPUSH
61597: CALL_OW 1
61601: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61602: LD_ADDR_VAR 0 2
61606: PUSH
61607: LD_INT 0
61609: PUSH
61610: LD_INT 0
61612: PUSH
61613: LD_INT 0
61615: PUSH
61616: LD_INT 0
61618: PUSH
61619: EMPTY
61620: LIST
61621: LIST
61622: LIST
61623: LIST
61624: ST_TO_ADDR
// if sci >= 1 then
61625: LD_VAR 0 8
61629: PUSH
61630: LD_INT 1
61632: GREATEREQUAL
61633: IFFALSE 61655
// tmp := tmp diff sci [ 1 ] ;
61635: LD_ADDR_VAR 0 4
61639: PUSH
61640: LD_VAR 0 4
61644: PUSH
61645: LD_VAR 0 8
61649: PUSH
61650: LD_INT 1
61652: ARRAY
61653: DIFF
61654: ST_TO_ADDR
// if tmp and not sci then
61655: LD_VAR 0 4
61659: PUSH
61660: LD_VAR 0 8
61664: NOT
61665: AND
61666: IFFALSE 61735
// begin sort := SortBySkill ( tmp , 4 ) ;
61668: LD_ADDR_VAR 0 9
61672: PUSH
61673: LD_VAR 0 4
61677: PPUSH
61678: LD_INT 4
61680: PPUSH
61681: CALL 48801 0 2
61685: ST_TO_ADDR
// if sort then
61686: LD_VAR 0 9
61690: IFFALSE 61706
// p := sort [ 1 ] ;
61692: LD_ADDR_VAR 0 11
61696: PUSH
61697: LD_VAR 0 9
61701: PUSH
61702: LD_INT 1
61704: ARRAY
61705: ST_TO_ADDR
// if p then
61706: LD_VAR 0 11
61710: IFFALSE 61735
// result := Replace ( result , 4 , p ) ;
61712: LD_ADDR_VAR 0 2
61716: PUSH
61717: LD_VAR 0 2
61721: PPUSH
61722: LD_INT 4
61724: PPUSH
61725: LD_VAR 0 11
61729: PPUSH
61730: CALL_OW 1
61734: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61735: LD_ADDR_VAR 0 4
61739: PUSH
61740: LD_VAR 0 4
61744: PUSH
61745: LD_VAR 0 7
61749: DIFF
61750: ST_TO_ADDR
// if tmp and mech < 6 then
61751: LD_VAR 0 4
61755: PUSH
61756: LD_VAR 0 7
61760: PUSH
61761: LD_INT 6
61763: LESS
61764: AND
61765: IFFALSE 61947
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61767: LD_ADDR_VAR 0 9
61771: PUSH
61772: LD_VAR 0 4
61776: PUSH
61777: LD_VAR 0 7
61781: DIFF
61782: PPUSH
61783: LD_INT 3
61785: PPUSH
61786: CALL 48801 0 2
61790: ST_TO_ADDR
// p := [ ] ;
61791: LD_ADDR_VAR 0 11
61795: PUSH
61796: EMPTY
61797: ST_TO_ADDR
// if sort then
61798: LD_VAR 0 9
61802: IFFALSE 61918
// for i = 1 to 6 - mech do
61804: LD_ADDR_VAR 0 3
61808: PUSH
61809: DOUBLE
61810: LD_INT 1
61812: DEC
61813: ST_TO_ADDR
61814: LD_INT 6
61816: PUSH
61817: LD_VAR 0 7
61821: MINUS
61822: PUSH
61823: FOR_TO
61824: IFFALSE 61916
// begin if i = sort then
61826: LD_VAR 0 3
61830: PUSH
61831: LD_VAR 0 9
61835: EQUAL
61836: IFFALSE 61840
// break ;
61838: GO 61916
// if GetClass ( i ) = 3 then
61840: LD_VAR 0 3
61844: PPUSH
61845: CALL_OW 257
61849: PUSH
61850: LD_INT 3
61852: EQUAL
61853: IFFALSE 61857
// continue ;
61855: GO 61823
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61857: LD_ADDR_VAR 0 11
61861: PUSH
61862: LD_VAR 0 11
61866: PPUSH
61867: LD_VAR 0 11
61871: PUSH
61872: LD_INT 1
61874: PLUS
61875: PPUSH
61876: LD_VAR 0 9
61880: PUSH
61881: LD_VAR 0 3
61885: ARRAY
61886: PPUSH
61887: CALL_OW 2
61891: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61892: LD_ADDR_VAR 0 4
61896: PUSH
61897: LD_VAR 0 4
61901: PUSH
61902: LD_VAR 0 9
61906: PUSH
61907: LD_VAR 0 3
61911: ARRAY
61912: DIFF
61913: ST_TO_ADDR
// end ;
61914: GO 61823
61916: POP
61917: POP
// if p then
61918: LD_VAR 0 11
61922: IFFALSE 61947
// result := Replace ( result , 3 , p ) ;
61924: LD_ADDR_VAR 0 2
61928: PUSH
61929: LD_VAR 0 2
61933: PPUSH
61934: LD_INT 3
61936: PPUSH
61937: LD_VAR 0 11
61941: PPUSH
61942: CALL_OW 1
61946: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61947: LD_ADDR_VAR 0 4
61951: PUSH
61952: LD_VAR 0 4
61956: PUSH
61957: LD_VAR 0 6
61961: DIFF
61962: ST_TO_ADDR
// if tmp and eng < 4 then
61963: LD_VAR 0 4
61967: PUSH
61968: LD_VAR 0 6
61972: PUSH
61973: LD_INT 4
61975: LESS
61976: AND
61977: IFFALSE 62167
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61979: LD_ADDR_VAR 0 9
61983: PUSH
61984: LD_VAR 0 4
61988: PUSH
61989: LD_VAR 0 7
61993: PUSH
61994: LD_VAR 0 6
61998: UNION
61999: DIFF
62000: PPUSH
62001: LD_INT 2
62003: PPUSH
62004: CALL 48801 0 2
62008: ST_TO_ADDR
// p := [ ] ;
62009: LD_ADDR_VAR 0 11
62013: PUSH
62014: EMPTY
62015: ST_TO_ADDR
// if sort then
62016: LD_VAR 0 9
62020: IFFALSE 62136
// for i = 1 to 4 - eng do
62022: LD_ADDR_VAR 0 3
62026: PUSH
62027: DOUBLE
62028: LD_INT 1
62030: DEC
62031: ST_TO_ADDR
62032: LD_INT 4
62034: PUSH
62035: LD_VAR 0 6
62039: MINUS
62040: PUSH
62041: FOR_TO
62042: IFFALSE 62134
// begin if i = sort then
62044: LD_VAR 0 3
62048: PUSH
62049: LD_VAR 0 9
62053: EQUAL
62054: IFFALSE 62058
// break ;
62056: GO 62134
// if GetClass ( i ) = 2 then
62058: LD_VAR 0 3
62062: PPUSH
62063: CALL_OW 257
62067: PUSH
62068: LD_INT 2
62070: EQUAL
62071: IFFALSE 62075
// continue ;
62073: GO 62041
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62075: LD_ADDR_VAR 0 11
62079: PUSH
62080: LD_VAR 0 11
62084: PPUSH
62085: LD_VAR 0 11
62089: PUSH
62090: LD_INT 1
62092: PLUS
62093: PPUSH
62094: LD_VAR 0 9
62098: PUSH
62099: LD_VAR 0 3
62103: ARRAY
62104: PPUSH
62105: CALL_OW 2
62109: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62110: LD_ADDR_VAR 0 4
62114: PUSH
62115: LD_VAR 0 4
62119: PUSH
62120: LD_VAR 0 9
62124: PUSH
62125: LD_VAR 0 3
62129: ARRAY
62130: DIFF
62131: ST_TO_ADDR
// end ;
62132: GO 62041
62134: POP
62135: POP
// if p then
62136: LD_VAR 0 11
62140: IFFALSE 62165
// result := Replace ( result , 2 , p ) ;
62142: LD_ADDR_VAR 0 2
62146: PUSH
62147: LD_VAR 0 2
62151: PPUSH
62152: LD_INT 2
62154: PPUSH
62155: LD_VAR 0 11
62159: PPUSH
62160: CALL_OW 1
62164: ST_TO_ADDR
// end else
62165: GO 62211
// for i = eng downto 5 do
62167: LD_ADDR_VAR 0 3
62171: PUSH
62172: DOUBLE
62173: LD_VAR 0 6
62177: INC
62178: ST_TO_ADDR
62179: LD_INT 5
62181: PUSH
62182: FOR_DOWNTO
62183: IFFALSE 62209
// tmp := tmp union eng [ i ] ;
62185: LD_ADDR_VAR 0 4
62189: PUSH
62190: LD_VAR 0 4
62194: PUSH
62195: LD_VAR 0 6
62199: PUSH
62200: LD_VAR 0 3
62204: ARRAY
62205: UNION
62206: ST_TO_ADDR
62207: GO 62182
62209: POP
62210: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62211: LD_ADDR_VAR 0 2
62215: PUSH
62216: LD_VAR 0 2
62220: PPUSH
62221: LD_INT 1
62223: PPUSH
62224: LD_VAR 0 4
62228: PUSH
62229: LD_VAR 0 5
62233: DIFF
62234: PPUSH
62235: CALL_OW 1
62239: ST_TO_ADDR
// exit ;
62240: GO 62242
// end ; end ;
62242: LD_VAR 0 2
62246: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62247: LD_INT 0
62249: PPUSH
62250: PPUSH
62251: PPUSH
// if not mc_bases then
62252: LD_EXP 70
62256: NOT
62257: IFFALSE 62261
// exit ;
62259: GO 62403
// for i = 1 to mc_bases do
62261: LD_ADDR_VAR 0 2
62265: PUSH
62266: DOUBLE
62267: LD_INT 1
62269: DEC
62270: ST_TO_ADDR
62271: LD_EXP 70
62275: PUSH
62276: FOR_TO
62277: IFFALSE 62394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62279: LD_ADDR_VAR 0 3
62283: PUSH
62284: LD_EXP 70
62288: PUSH
62289: LD_VAR 0 2
62293: ARRAY
62294: PPUSH
62295: LD_INT 21
62297: PUSH
62298: LD_INT 3
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: PUSH
62305: LD_INT 3
62307: PUSH
62308: LD_INT 2
62310: PUSH
62311: LD_INT 30
62313: PUSH
62314: LD_INT 29
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PUSH
62321: LD_INT 30
62323: PUSH
62324: LD_INT 30
62326: PUSH
62327: EMPTY
62328: LIST
62329: LIST
62330: PUSH
62331: EMPTY
62332: LIST
62333: LIST
62334: LIST
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: PUSH
62340: LD_INT 3
62342: PUSH
62343: LD_INT 24
62345: PUSH
62346: LD_INT 1000
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: LIST
62361: PPUSH
62362: CALL_OW 72
62366: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62367: LD_ADDR_EXP 71
62371: PUSH
62372: LD_EXP 71
62376: PPUSH
62377: LD_VAR 0 2
62381: PPUSH
62382: LD_VAR 0 3
62386: PPUSH
62387: CALL_OW 1
62391: ST_TO_ADDR
// end ;
62392: GO 62276
62394: POP
62395: POP
// RaiseSailEvent ( 101 ) ;
62396: LD_INT 101
62398: PPUSH
62399: CALL_OW 427
// end ;
62403: LD_VAR 0 1
62407: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62408: LD_INT 0
62410: PPUSH
62411: PPUSH
62412: PPUSH
62413: PPUSH
62414: PPUSH
62415: PPUSH
62416: PPUSH
// if not mc_bases then
62417: LD_EXP 70
62421: NOT
62422: IFFALSE 62426
// exit ;
62424: GO 62988
// for i = 1 to mc_bases do
62426: LD_ADDR_VAR 0 2
62430: PUSH
62431: DOUBLE
62432: LD_INT 1
62434: DEC
62435: ST_TO_ADDR
62436: LD_EXP 70
62440: PUSH
62441: FOR_TO
62442: IFFALSE 62979
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62444: LD_ADDR_VAR 0 5
62448: PUSH
62449: LD_EXP 70
62453: PUSH
62454: LD_VAR 0 2
62458: ARRAY
62459: PUSH
62460: LD_EXP 99
62464: PUSH
62465: LD_VAR 0 2
62469: ARRAY
62470: UNION
62471: PPUSH
62472: LD_INT 21
62474: PUSH
62475: LD_INT 1
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: PUSH
62482: LD_INT 1
62484: PUSH
62485: LD_INT 3
62487: PUSH
62488: LD_INT 54
62490: PUSH
62491: EMPTY
62492: LIST
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 3
62500: PUSH
62501: LD_INT 24
62503: PUSH
62504: LD_INT 1000
62506: PUSH
62507: EMPTY
62508: LIST
62509: LIST
62510: PUSH
62511: EMPTY
62512: LIST
62513: LIST
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: LIST
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PPUSH
62524: CALL_OW 72
62528: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62529: LD_ADDR_VAR 0 6
62533: PUSH
62534: LD_EXP 70
62538: PUSH
62539: LD_VAR 0 2
62543: ARRAY
62544: PPUSH
62545: LD_INT 21
62547: PUSH
62548: LD_INT 1
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 1
62557: PUSH
62558: LD_INT 3
62560: PUSH
62561: LD_INT 54
62563: PUSH
62564: EMPTY
62565: LIST
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PUSH
62571: LD_INT 3
62573: PUSH
62574: LD_INT 24
62576: PUSH
62577: LD_INT 250
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: EMPTY
62585: LIST
62586: LIST
62587: PUSH
62588: EMPTY
62589: LIST
62590: LIST
62591: LIST
62592: PUSH
62593: EMPTY
62594: LIST
62595: LIST
62596: PPUSH
62597: CALL_OW 72
62601: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62602: LD_ADDR_VAR 0 7
62606: PUSH
62607: LD_VAR 0 5
62611: PUSH
62612: LD_VAR 0 6
62616: DIFF
62617: ST_TO_ADDR
// if not need_heal_1 then
62618: LD_VAR 0 6
62622: NOT
62623: IFFALSE 62656
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62625: LD_ADDR_EXP 73
62629: PUSH
62630: LD_EXP 73
62634: PPUSH
62635: LD_VAR 0 2
62639: PUSH
62640: LD_INT 1
62642: PUSH
62643: EMPTY
62644: LIST
62645: LIST
62646: PPUSH
62647: EMPTY
62648: PPUSH
62649: CALL 18597 0 3
62653: ST_TO_ADDR
62654: GO 62726
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62656: LD_ADDR_EXP 73
62660: PUSH
62661: LD_EXP 73
62665: PPUSH
62666: LD_VAR 0 2
62670: PUSH
62671: LD_INT 1
62673: PUSH
62674: EMPTY
62675: LIST
62676: LIST
62677: PPUSH
62678: LD_EXP 73
62682: PUSH
62683: LD_VAR 0 2
62687: ARRAY
62688: PUSH
62689: LD_INT 1
62691: ARRAY
62692: PPUSH
62693: LD_INT 3
62695: PUSH
62696: LD_INT 24
62698: PUSH
62699: LD_INT 1000
62701: PUSH
62702: EMPTY
62703: LIST
62704: LIST
62705: PUSH
62706: EMPTY
62707: LIST
62708: LIST
62709: PPUSH
62710: CALL_OW 72
62714: PUSH
62715: LD_VAR 0 6
62719: UNION
62720: PPUSH
62721: CALL 18597 0 3
62725: ST_TO_ADDR
// if not need_heal_2 then
62726: LD_VAR 0 7
62730: NOT
62731: IFFALSE 62764
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62733: LD_ADDR_EXP 73
62737: PUSH
62738: LD_EXP 73
62742: PPUSH
62743: LD_VAR 0 2
62747: PUSH
62748: LD_INT 2
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: PPUSH
62755: EMPTY
62756: PPUSH
62757: CALL 18597 0 3
62761: ST_TO_ADDR
62762: GO 62796
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62764: LD_ADDR_EXP 73
62768: PUSH
62769: LD_EXP 73
62773: PPUSH
62774: LD_VAR 0 2
62778: PUSH
62779: LD_INT 2
62781: PUSH
62782: EMPTY
62783: LIST
62784: LIST
62785: PPUSH
62786: LD_VAR 0 7
62790: PPUSH
62791: CALL 18597 0 3
62795: ST_TO_ADDR
// if need_heal_2 then
62796: LD_VAR 0 7
62800: IFFALSE 62961
// for j in need_heal_2 do
62802: LD_ADDR_VAR 0 3
62806: PUSH
62807: LD_VAR 0 7
62811: PUSH
62812: FOR_IN
62813: IFFALSE 62959
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62815: LD_ADDR_VAR 0 5
62819: PUSH
62820: LD_EXP 70
62824: PUSH
62825: LD_VAR 0 2
62829: ARRAY
62830: PPUSH
62831: LD_INT 2
62833: PUSH
62834: LD_INT 30
62836: PUSH
62837: LD_INT 6
62839: PUSH
62840: EMPTY
62841: LIST
62842: LIST
62843: PUSH
62844: LD_INT 30
62846: PUSH
62847: LD_INT 7
62849: PUSH
62850: EMPTY
62851: LIST
62852: LIST
62853: PUSH
62854: LD_INT 30
62856: PUSH
62857: LD_INT 8
62859: PUSH
62860: EMPTY
62861: LIST
62862: LIST
62863: PUSH
62864: LD_INT 30
62866: PUSH
62867: LD_INT 0
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: PUSH
62874: LD_INT 30
62876: PUSH
62877: LD_INT 1
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PUSH
62884: EMPTY
62885: LIST
62886: LIST
62887: LIST
62888: LIST
62889: LIST
62890: LIST
62891: PPUSH
62892: CALL_OW 72
62896: ST_TO_ADDR
// if tmp then
62897: LD_VAR 0 5
62901: IFFALSE 62957
// begin k := NearestUnitToUnit ( tmp , j ) ;
62903: LD_ADDR_VAR 0 4
62907: PUSH
62908: LD_VAR 0 5
62912: PPUSH
62913: LD_VAR 0 3
62917: PPUSH
62918: CALL_OW 74
62922: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62923: LD_VAR 0 3
62927: PPUSH
62928: LD_VAR 0 4
62932: PPUSH
62933: CALL_OW 296
62937: PUSH
62938: LD_INT 5
62940: GREATER
62941: IFFALSE 62957
// ComMoveToNearbyEntrance ( j , k ) ;
62943: LD_VAR 0 3
62947: PPUSH
62948: LD_VAR 0 4
62952: PPUSH
62953: CALL 51159 0 2
// end ; end ;
62957: GO 62812
62959: POP
62960: POP
// if not need_heal_1 and not need_heal_2 then
62961: LD_VAR 0 6
62965: NOT
62966: PUSH
62967: LD_VAR 0 7
62971: NOT
62972: AND
62973: IFFALSE 62977
// continue ;
62975: GO 62441
// end ;
62977: GO 62441
62979: POP
62980: POP
// RaiseSailEvent ( 102 ) ;
62981: LD_INT 102
62983: PPUSH
62984: CALL_OW 427
// end ;
62988: LD_VAR 0 1
62992: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62993: LD_INT 0
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
63000: PPUSH
63001: PPUSH
63002: PPUSH
// if not mc_bases then
63003: LD_EXP 70
63007: NOT
63008: IFFALSE 63012
// exit ;
63010: GO 63895
// for i = 1 to mc_bases do
63012: LD_ADDR_VAR 0 2
63016: PUSH
63017: DOUBLE
63018: LD_INT 1
63020: DEC
63021: ST_TO_ADDR
63022: LD_EXP 70
63026: PUSH
63027: FOR_TO
63028: IFFALSE 63893
// begin if not mc_building_need_repair [ i ] then
63030: LD_EXP 71
63034: PUSH
63035: LD_VAR 0 2
63039: ARRAY
63040: NOT
63041: IFFALSE 63228
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63043: LD_ADDR_VAR 0 6
63047: PUSH
63048: LD_EXP 89
63052: PUSH
63053: LD_VAR 0 2
63057: ARRAY
63058: PPUSH
63059: LD_INT 3
63061: PUSH
63062: LD_INT 24
63064: PUSH
63065: LD_INT 1000
63067: PUSH
63068: EMPTY
63069: LIST
63070: LIST
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: PUSH
63076: LD_INT 2
63078: PUSH
63079: LD_INT 34
63081: PUSH
63082: LD_INT 13
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: PUSH
63089: LD_INT 34
63091: PUSH
63092: LD_INT 52
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PUSH
63099: LD_INT 34
63101: PUSH
63102: LD_EXP 54
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: LIST
63115: LIST
63116: PUSH
63117: EMPTY
63118: LIST
63119: LIST
63120: PPUSH
63121: CALL_OW 72
63125: ST_TO_ADDR
// if cranes then
63126: LD_VAR 0 6
63130: IFFALSE 63192
// for j in cranes do
63132: LD_ADDR_VAR 0 3
63136: PUSH
63137: LD_VAR 0 6
63141: PUSH
63142: FOR_IN
63143: IFFALSE 63190
// if not IsInArea ( j , mc_parking [ i ] ) then
63145: LD_VAR 0 3
63149: PPUSH
63150: LD_EXP 94
63154: PUSH
63155: LD_VAR 0 2
63159: ARRAY
63160: PPUSH
63161: CALL_OW 308
63165: NOT
63166: IFFALSE 63188
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63168: LD_VAR 0 3
63172: PPUSH
63173: LD_EXP 94
63177: PUSH
63178: LD_VAR 0 2
63182: ARRAY
63183: PPUSH
63184: CALL_OW 113
63188: GO 63142
63190: POP
63191: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63192: LD_ADDR_EXP 72
63196: PUSH
63197: LD_EXP 72
63201: PPUSH
63202: LD_VAR 0 2
63206: PPUSH
63207: EMPTY
63208: PPUSH
63209: CALL_OW 1
63213: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63214: LD_VAR 0 2
63218: PPUSH
63219: LD_INT 101
63221: PPUSH
63222: CALL 58080 0 2
// continue ;
63226: GO 63027
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63228: LD_ADDR_EXP 76
63232: PUSH
63233: LD_EXP 76
63237: PPUSH
63238: LD_VAR 0 2
63242: PPUSH
63243: EMPTY
63244: PPUSH
63245: CALL_OW 1
63249: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63250: LD_VAR 0 2
63254: PPUSH
63255: LD_INT 103
63257: PPUSH
63258: CALL 58080 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63262: LD_ADDR_VAR 0 5
63266: PUSH
63267: LD_EXP 70
63271: PUSH
63272: LD_VAR 0 2
63276: ARRAY
63277: PUSH
63278: LD_EXP 99
63282: PUSH
63283: LD_VAR 0 2
63287: ARRAY
63288: UNION
63289: PPUSH
63290: LD_INT 2
63292: PUSH
63293: LD_INT 25
63295: PUSH
63296: LD_INT 2
63298: PUSH
63299: EMPTY
63300: LIST
63301: LIST
63302: PUSH
63303: LD_INT 25
63305: PUSH
63306: LD_INT 16
63308: PUSH
63309: EMPTY
63310: LIST
63311: LIST
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: LIST
63317: PUSH
63318: EMPTY
63319: LIST
63320: PPUSH
63321: CALL_OW 72
63325: ST_TO_ADDR
// if mc_need_heal [ i ] then
63326: LD_EXP 73
63330: PUSH
63331: LD_VAR 0 2
63335: ARRAY
63336: IFFALSE 63380
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63338: LD_ADDR_VAR 0 5
63342: PUSH
63343: LD_VAR 0 5
63347: PUSH
63348: LD_EXP 73
63352: PUSH
63353: LD_VAR 0 2
63357: ARRAY
63358: PUSH
63359: LD_INT 1
63361: ARRAY
63362: PUSH
63363: LD_EXP 73
63367: PUSH
63368: LD_VAR 0 2
63372: ARRAY
63373: PUSH
63374: LD_INT 2
63376: ARRAY
63377: UNION
63378: DIFF
63379: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63380: LD_ADDR_VAR 0 6
63384: PUSH
63385: LD_EXP 89
63389: PUSH
63390: LD_VAR 0 2
63394: ARRAY
63395: PPUSH
63396: LD_INT 2
63398: PUSH
63399: LD_INT 34
63401: PUSH
63402: LD_INT 13
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 34
63411: PUSH
63412: LD_INT 52
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 34
63421: PUSH
63422: LD_EXP 54
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: PPUSH
63437: CALL_OW 72
63441: ST_TO_ADDR
// if cranes then
63442: LD_VAR 0 6
63446: IFFALSE 63582
// begin for j in cranes do
63448: LD_ADDR_VAR 0 3
63452: PUSH
63453: LD_VAR 0 6
63457: PUSH
63458: FOR_IN
63459: IFFALSE 63580
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63461: LD_VAR 0 3
63465: PPUSH
63466: CALL_OW 256
63470: PUSH
63471: LD_INT 1000
63473: EQUAL
63474: PUSH
63475: LD_VAR 0 3
63479: PPUSH
63480: CALL_OW 314
63484: NOT
63485: AND
63486: IFFALSE 63520
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63488: LD_VAR 0 3
63492: PPUSH
63493: LD_EXP 71
63497: PUSH
63498: LD_VAR 0 2
63502: ARRAY
63503: PPUSH
63504: LD_VAR 0 3
63508: PPUSH
63509: CALL_OW 74
63513: PPUSH
63514: CALL_OW 130
63518: GO 63578
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63520: LD_VAR 0 3
63524: PPUSH
63525: CALL_OW 256
63529: PUSH
63530: LD_INT 500
63532: LESS
63533: PUSH
63534: LD_VAR 0 3
63538: PPUSH
63539: LD_EXP 94
63543: PUSH
63544: LD_VAR 0 2
63548: ARRAY
63549: PPUSH
63550: CALL_OW 308
63554: NOT
63555: AND
63556: IFFALSE 63578
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63558: LD_VAR 0 3
63562: PPUSH
63563: LD_EXP 94
63567: PUSH
63568: LD_VAR 0 2
63572: ARRAY
63573: PPUSH
63574: CALL_OW 113
// end ;
63578: GO 63458
63580: POP
63581: POP
// end ; if tmp > 3 then
63582: LD_VAR 0 5
63586: PUSH
63587: LD_INT 3
63589: GREATER
63590: IFFALSE 63610
// tmp := ShrinkArray ( tmp , 4 ) ;
63592: LD_ADDR_VAR 0 5
63596: PUSH
63597: LD_VAR 0 5
63601: PPUSH
63602: LD_INT 4
63604: PPUSH
63605: CALL 50607 0 2
63609: ST_TO_ADDR
// if not tmp then
63610: LD_VAR 0 5
63614: NOT
63615: IFFALSE 63619
// continue ;
63617: GO 63027
// for j in tmp do
63619: LD_ADDR_VAR 0 3
63623: PUSH
63624: LD_VAR 0 5
63628: PUSH
63629: FOR_IN
63630: IFFALSE 63889
// begin if IsInUnit ( j ) then
63632: LD_VAR 0 3
63636: PPUSH
63637: CALL_OW 310
63641: IFFALSE 63652
// ComExitBuilding ( j ) ;
63643: LD_VAR 0 3
63647: PPUSH
63648: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63652: LD_VAR 0 3
63656: PUSH
63657: LD_EXP 72
63661: PUSH
63662: LD_VAR 0 2
63666: ARRAY
63667: IN
63668: NOT
63669: IFFALSE 63727
// begin SetTag ( j , 101 ) ;
63671: LD_VAR 0 3
63675: PPUSH
63676: LD_INT 101
63678: PPUSH
63679: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63683: LD_ADDR_EXP 72
63687: PUSH
63688: LD_EXP 72
63692: PPUSH
63693: LD_VAR 0 2
63697: PUSH
63698: LD_EXP 72
63702: PUSH
63703: LD_VAR 0 2
63707: ARRAY
63708: PUSH
63709: LD_INT 1
63711: PLUS
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: LD_VAR 0 3
63721: PPUSH
63722: CALL 18597 0 3
63726: ST_TO_ADDR
// end ; wait ( 1 ) ;
63727: LD_INT 1
63729: PPUSH
63730: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63734: LD_ADDR_VAR 0 7
63738: PUSH
63739: LD_EXP 71
63743: PUSH
63744: LD_VAR 0 2
63748: ARRAY
63749: ST_TO_ADDR
// if mc_scan [ i ] then
63750: LD_EXP 93
63754: PUSH
63755: LD_VAR 0 2
63759: ARRAY
63760: IFFALSE 63822
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63762: LD_ADDR_VAR 0 7
63766: PUSH
63767: LD_EXP 71
63771: PUSH
63772: LD_VAR 0 2
63776: ARRAY
63777: PPUSH
63778: LD_INT 3
63780: PUSH
63781: LD_INT 30
63783: PUSH
63784: LD_INT 32
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PUSH
63791: LD_INT 30
63793: PUSH
63794: LD_INT 33
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 30
63803: PUSH
63804: LD_INT 31
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PUSH
63811: EMPTY
63812: LIST
63813: LIST
63814: LIST
63815: LIST
63816: PPUSH
63817: CALL_OW 72
63821: ST_TO_ADDR
// if not to_repair_tmp then
63822: LD_VAR 0 7
63826: NOT
63827: IFFALSE 63831
// continue ;
63829: GO 63629
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63831: LD_ADDR_VAR 0 8
63835: PUSH
63836: LD_VAR 0 7
63840: PPUSH
63841: LD_VAR 0 3
63845: PPUSH
63846: CALL_OW 74
63850: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63851: LD_VAR 0 8
63855: PPUSH
63856: LD_INT 16
63858: PPUSH
63859: CALL 21196 0 2
63863: PUSH
63864: LD_INT 4
63866: ARRAY
63867: PUSH
63868: LD_INT 10
63870: LESS
63871: IFFALSE 63887
// ComRepairBuilding ( j , to_repair ) ;
63873: LD_VAR 0 3
63877: PPUSH
63878: LD_VAR 0 8
63882: PPUSH
63883: CALL_OW 130
// end ;
63887: GO 63629
63889: POP
63890: POP
// end ;
63891: GO 63027
63893: POP
63894: POP
// end ;
63895: LD_VAR 0 1
63899: RET
// export function MC_Heal ; var i , j , tmp ; begin
63900: LD_INT 0
63902: PPUSH
63903: PPUSH
63904: PPUSH
63905: PPUSH
// if not mc_bases then
63906: LD_EXP 70
63910: NOT
63911: IFFALSE 63915
// exit ;
63913: GO 64317
// for i = 1 to mc_bases do
63915: LD_ADDR_VAR 0 2
63919: PUSH
63920: DOUBLE
63921: LD_INT 1
63923: DEC
63924: ST_TO_ADDR
63925: LD_EXP 70
63929: PUSH
63930: FOR_TO
63931: IFFALSE 64315
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63933: LD_EXP 73
63937: PUSH
63938: LD_VAR 0 2
63942: ARRAY
63943: PUSH
63944: LD_INT 1
63946: ARRAY
63947: NOT
63948: PUSH
63949: LD_EXP 73
63953: PUSH
63954: LD_VAR 0 2
63958: ARRAY
63959: PUSH
63960: LD_INT 2
63962: ARRAY
63963: NOT
63964: AND
63965: IFFALSE 64003
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63967: LD_ADDR_EXP 74
63971: PUSH
63972: LD_EXP 74
63976: PPUSH
63977: LD_VAR 0 2
63981: PPUSH
63982: EMPTY
63983: PPUSH
63984: CALL_OW 1
63988: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63989: LD_VAR 0 2
63993: PPUSH
63994: LD_INT 102
63996: PPUSH
63997: CALL 58080 0 2
// continue ;
64001: GO 63930
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64003: LD_ADDR_VAR 0 4
64007: PUSH
64008: LD_EXP 70
64012: PUSH
64013: LD_VAR 0 2
64017: ARRAY
64018: PPUSH
64019: LD_INT 25
64021: PUSH
64022: LD_INT 4
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PPUSH
64029: CALL_OW 72
64033: ST_TO_ADDR
// if not tmp then
64034: LD_VAR 0 4
64038: NOT
64039: IFFALSE 64043
// continue ;
64041: GO 63930
// if mc_taming [ i ] then
64043: LD_EXP 101
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: IFFALSE 64077
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64055: LD_ADDR_EXP 101
64059: PUSH
64060: LD_EXP 101
64064: PPUSH
64065: LD_VAR 0 2
64069: PPUSH
64070: EMPTY
64071: PPUSH
64072: CALL_OW 1
64076: ST_TO_ADDR
// for j in tmp do
64077: LD_ADDR_VAR 0 3
64081: PUSH
64082: LD_VAR 0 4
64086: PUSH
64087: FOR_IN
64088: IFFALSE 64311
// begin if IsInUnit ( j ) then
64090: LD_VAR 0 3
64094: PPUSH
64095: CALL_OW 310
64099: IFFALSE 64110
// ComExitBuilding ( j ) ;
64101: LD_VAR 0 3
64105: PPUSH
64106: CALL_OW 122
// if not j in mc_healers [ i ] then
64110: LD_VAR 0 3
64114: PUSH
64115: LD_EXP 74
64119: PUSH
64120: LD_VAR 0 2
64124: ARRAY
64125: IN
64126: NOT
64127: IFFALSE 64173
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64129: LD_ADDR_EXP 74
64133: PUSH
64134: LD_EXP 74
64138: PPUSH
64139: LD_VAR 0 2
64143: PUSH
64144: LD_EXP 74
64148: PUSH
64149: LD_VAR 0 2
64153: ARRAY
64154: PUSH
64155: LD_INT 1
64157: PLUS
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PPUSH
64163: LD_VAR 0 3
64167: PPUSH
64168: CALL 18597 0 3
64172: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64173: LD_VAR 0 3
64177: PPUSH
64178: CALL_OW 110
64182: PUSH
64183: LD_INT 102
64185: NONEQUAL
64186: IFFALSE 64200
// SetTag ( j , 102 ) ;
64188: LD_VAR 0 3
64192: PPUSH
64193: LD_INT 102
64195: PPUSH
64196: CALL_OW 109
// Wait ( 3 ) ;
64200: LD_INT 3
64202: PPUSH
64203: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64207: LD_EXP 73
64211: PUSH
64212: LD_VAR 0 2
64216: ARRAY
64217: PUSH
64218: LD_INT 1
64220: ARRAY
64221: IFFALSE 64253
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64223: LD_VAR 0 3
64227: PPUSH
64228: LD_EXP 73
64232: PUSH
64233: LD_VAR 0 2
64237: ARRAY
64238: PUSH
64239: LD_INT 1
64241: ARRAY
64242: PUSH
64243: LD_INT 1
64245: ARRAY
64246: PPUSH
64247: CALL_OW 128
64251: GO 64309
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64253: LD_VAR 0 3
64257: PPUSH
64258: CALL_OW 314
64262: NOT
64263: PUSH
64264: LD_EXP 73
64268: PUSH
64269: LD_VAR 0 2
64273: ARRAY
64274: PUSH
64275: LD_INT 2
64277: ARRAY
64278: AND
64279: IFFALSE 64309
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64281: LD_VAR 0 3
64285: PPUSH
64286: LD_EXP 73
64290: PUSH
64291: LD_VAR 0 2
64295: ARRAY
64296: PUSH
64297: LD_INT 2
64299: ARRAY
64300: PUSH
64301: LD_INT 1
64303: ARRAY
64304: PPUSH
64305: CALL_OW 128
// end ;
64309: GO 64087
64311: POP
64312: POP
// end ;
64313: GO 63930
64315: POP
64316: POP
// end ;
64317: LD_VAR 0 1
64321: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64322: LD_INT 0
64324: PPUSH
64325: PPUSH
64326: PPUSH
64327: PPUSH
64328: PPUSH
// if not mc_bases then
64329: LD_EXP 70
64333: NOT
64334: IFFALSE 64338
// exit ;
64336: GO 65509
// for i = 1 to mc_bases do
64338: LD_ADDR_VAR 0 2
64342: PUSH
64343: DOUBLE
64344: LD_INT 1
64346: DEC
64347: ST_TO_ADDR
64348: LD_EXP 70
64352: PUSH
64353: FOR_TO
64354: IFFALSE 65507
// begin if mc_scan [ i ] then
64356: LD_EXP 93
64360: PUSH
64361: LD_VAR 0 2
64365: ARRAY
64366: IFFALSE 64370
// continue ;
64368: GO 64353
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64370: LD_EXP 75
64374: PUSH
64375: LD_VAR 0 2
64379: ARRAY
64380: NOT
64381: PUSH
64382: LD_EXP 77
64386: PUSH
64387: LD_VAR 0 2
64391: ARRAY
64392: NOT
64393: AND
64394: PUSH
64395: LD_EXP 76
64399: PUSH
64400: LD_VAR 0 2
64404: ARRAY
64405: AND
64406: IFFALSE 64444
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64408: LD_ADDR_EXP 76
64412: PUSH
64413: LD_EXP 76
64417: PPUSH
64418: LD_VAR 0 2
64422: PPUSH
64423: EMPTY
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64430: LD_VAR 0 2
64434: PPUSH
64435: LD_INT 103
64437: PPUSH
64438: CALL 58080 0 2
// continue ;
64442: GO 64353
// end ; if mc_construct_list [ i ] then
64444: LD_EXP 77
64448: PUSH
64449: LD_VAR 0 2
64453: ARRAY
64454: IFFALSE 64674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64456: LD_ADDR_VAR 0 4
64460: PUSH
64461: LD_EXP 70
64465: PUSH
64466: LD_VAR 0 2
64470: ARRAY
64471: PPUSH
64472: LD_INT 25
64474: PUSH
64475: LD_INT 2
64477: PUSH
64478: EMPTY
64479: LIST
64480: LIST
64481: PPUSH
64482: CALL_OW 72
64486: PUSH
64487: LD_EXP 72
64491: PUSH
64492: LD_VAR 0 2
64496: ARRAY
64497: DIFF
64498: ST_TO_ADDR
// if not tmp then
64499: LD_VAR 0 4
64503: NOT
64504: IFFALSE 64508
// continue ;
64506: GO 64353
// for j in tmp do
64508: LD_ADDR_VAR 0 3
64512: PUSH
64513: LD_VAR 0 4
64517: PUSH
64518: FOR_IN
64519: IFFALSE 64670
// begin if not mc_builders [ i ] then
64521: LD_EXP 76
64525: PUSH
64526: LD_VAR 0 2
64530: ARRAY
64531: NOT
64532: IFFALSE 64590
// begin SetTag ( j , 103 ) ;
64534: LD_VAR 0 3
64538: PPUSH
64539: LD_INT 103
64541: PPUSH
64542: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64546: LD_ADDR_EXP 76
64550: PUSH
64551: LD_EXP 76
64555: PPUSH
64556: LD_VAR 0 2
64560: PUSH
64561: LD_EXP 76
64565: PUSH
64566: LD_VAR 0 2
64570: ARRAY
64571: PUSH
64572: LD_INT 1
64574: PLUS
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PPUSH
64580: LD_VAR 0 3
64584: PPUSH
64585: CALL 18597 0 3
64589: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64590: LD_VAR 0 3
64594: PPUSH
64595: CALL_OW 310
64599: IFFALSE 64610
// ComExitBuilding ( j ) ;
64601: LD_VAR 0 3
64605: PPUSH
64606: CALL_OW 122
// wait ( 3 ) ;
64610: LD_INT 3
64612: PPUSH
64613: CALL_OW 67
// if not mc_construct_list [ i ] then
64617: LD_EXP 77
64621: PUSH
64622: LD_VAR 0 2
64626: ARRAY
64627: NOT
64628: IFFALSE 64632
// break ;
64630: GO 64670
// if not HasTask ( j ) then
64632: LD_VAR 0 3
64636: PPUSH
64637: CALL_OW 314
64641: NOT
64642: IFFALSE 64668
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64644: LD_VAR 0 3
64648: PPUSH
64649: LD_EXP 77
64653: PUSH
64654: LD_VAR 0 2
64658: ARRAY
64659: PUSH
64660: LD_INT 1
64662: ARRAY
64663: PPUSH
64664: CALL 21460 0 2
// end ;
64668: GO 64518
64670: POP
64671: POP
// end else
64672: GO 65505
// if mc_build_list [ i ] then
64674: LD_EXP 75
64678: PUSH
64679: LD_VAR 0 2
64683: ARRAY
64684: IFFALSE 65505
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64686: LD_ADDR_VAR 0 5
64690: PUSH
64691: LD_EXP 70
64695: PUSH
64696: LD_VAR 0 2
64700: ARRAY
64701: PPUSH
64702: LD_INT 2
64704: PUSH
64705: LD_INT 30
64707: PUSH
64708: LD_INT 0
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 30
64717: PUSH
64718: LD_INT 1
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: EMPTY
64726: LIST
64727: LIST
64728: LIST
64729: PPUSH
64730: CALL_OW 72
64734: ST_TO_ADDR
// if depot then
64735: LD_VAR 0 5
64739: IFFALSE 64757
// depot := depot [ 1 ] else
64741: LD_ADDR_VAR 0 5
64745: PUSH
64746: LD_VAR 0 5
64750: PUSH
64751: LD_INT 1
64753: ARRAY
64754: ST_TO_ADDR
64755: GO 64765
// depot := 0 ;
64757: LD_ADDR_VAR 0 5
64761: PUSH
64762: LD_INT 0
64764: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64765: LD_EXP 75
64769: PUSH
64770: LD_VAR 0 2
64774: ARRAY
64775: PUSH
64776: LD_INT 1
64778: ARRAY
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: PPUSH
64784: CALL 21284 0 1
64788: PUSH
64789: LD_EXP 70
64793: PUSH
64794: LD_VAR 0 2
64798: ARRAY
64799: PPUSH
64800: LD_INT 2
64802: PUSH
64803: LD_INT 30
64805: PUSH
64806: LD_INT 2
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 30
64815: PUSH
64816: LD_INT 3
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: LIST
64827: PPUSH
64828: CALL_OW 72
64832: NOT
64833: AND
64834: IFFALSE 64939
// begin for j = 1 to mc_build_list [ i ] do
64836: LD_ADDR_VAR 0 3
64840: PUSH
64841: DOUBLE
64842: LD_INT 1
64844: DEC
64845: ST_TO_ADDR
64846: LD_EXP 75
64850: PUSH
64851: LD_VAR 0 2
64855: ARRAY
64856: PUSH
64857: FOR_TO
64858: IFFALSE 64937
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64860: LD_EXP 75
64864: PUSH
64865: LD_VAR 0 2
64869: ARRAY
64870: PUSH
64871: LD_VAR 0 3
64875: ARRAY
64876: PUSH
64877: LD_INT 1
64879: ARRAY
64880: PUSH
64881: LD_INT 2
64883: EQUAL
64884: IFFALSE 64935
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64886: LD_ADDR_EXP 75
64890: PUSH
64891: LD_EXP 75
64895: PPUSH
64896: LD_VAR 0 2
64900: PPUSH
64901: LD_EXP 75
64905: PUSH
64906: LD_VAR 0 2
64910: ARRAY
64911: PPUSH
64912: LD_VAR 0 3
64916: PPUSH
64917: LD_INT 1
64919: PPUSH
64920: LD_INT 0
64922: PPUSH
64923: CALL 18015 0 4
64927: PPUSH
64928: CALL_OW 1
64932: ST_TO_ADDR
// break ;
64933: GO 64937
// end ;
64935: GO 64857
64937: POP
64938: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64939: LD_EXP 75
64943: PUSH
64944: LD_VAR 0 2
64948: ARRAY
64949: PUSH
64950: LD_INT 1
64952: ARRAY
64953: PUSH
64954: LD_INT 1
64956: ARRAY
64957: PUSH
64958: LD_INT 0
64960: EQUAL
64961: PUSH
64962: LD_VAR 0 5
64966: PUSH
64967: LD_VAR 0 5
64971: PPUSH
64972: LD_EXP 75
64976: PUSH
64977: LD_VAR 0 2
64981: ARRAY
64982: PUSH
64983: LD_INT 1
64985: ARRAY
64986: PUSH
64987: LD_INT 1
64989: ARRAY
64990: PPUSH
64991: LD_EXP 75
64995: PUSH
64996: LD_VAR 0 2
65000: ARRAY
65001: PUSH
65002: LD_INT 1
65004: ARRAY
65005: PUSH
65006: LD_INT 2
65008: ARRAY
65009: PPUSH
65010: LD_EXP 75
65014: PUSH
65015: LD_VAR 0 2
65019: ARRAY
65020: PUSH
65021: LD_INT 1
65023: ARRAY
65024: PUSH
65025: LD_INT 3
65027: ARRAY
65028: PPUSH
65029: LD_EXP 75
65033: PUSH
65034: LD_VAR 0 2
65038: ARRAY
65039: PUSH
65040: LD_INT 1
65042: ARRAY
65043: PUSH
65044: LD_INT 4
65046: ARRAY
65047: PPUSH
65048: CALL 26700 0 5
65052: AND
65053: OR
65054: IFFALSE 65335
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65056: LD_ADDR_VAR 0 4
65060: PUSH
65061: LD_EXP 70
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: PPUSH
65072: LD_INT 25
65074: PUSH
65075: LD_INT 2
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PPUSH
65082: CALL_OW 72
65086: PUSH
65087: LD_EXP 72
65091: PUSH
65092: LD_VAR 0 2
65096: ARRAY
65097: DIFF
65098: ST_TO_ADDR
// if not tmp then
65099: LD_VAR 0 4
65103: NOT
65104: IFFALSE 65108
// continue ;
65106: GO 64353
// for j in tmp do
65108: LD_ADDR_VAR 0 3
65112: PUSH
65113: LD_VAR 0 4
65117: PUSH
65118: FOR_IN
65119: IFFALSE 65331
// begin if not mc_builders [ i ] then
65121: LD_EXP 76
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: NOT
65132: IFFALSE 65190
// begin SetTag ( j , 103 ) ;
65134: LD_VAR 0 3
65138: PPUSH
65139: LD_INT 103
65141: PPUSH
65142: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65146: LD_ADDR_EXP 76
65150: PUSH
65151: LD_EXP 76
65155: PPUSH
65156: LD_VAR 0 2
65160: PUSH
65161: LD_EXP 76
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PUSH
65172: LD_INT 1
65174: PLUS
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PPUSH
65180: LD_VAR 0 3
65184: PPUSH
65185: CALL 18597 0 3
65189: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65190: LD_VAR 0 3
65194: PPUSH
65195: CALL_OW 310
65199: IFFALSE 65210
// ComExitBuilding ( j ) ;
65201: LD_VAR 0 3
65205: PPUSH
65206: CALL_OW 122
// wait ( 3 ) ;
65210: LD_INT 3
65212: PPUSH
65213: CALL_OW 67
// if not mc_build_list [ i ] then
65217: LD_EXP 75
65221: PUSH
65222: LD_VAR 0 2
65226: ARRAY
65227: NOT
65228: IFFALSE 65232
// break ;
65230: GO 65331
// if not HasTask ( j ) then
65232: LD_VAR 0 3
65236: PPUSH
65237: CALL_OW 314
65241: NOT
65242: IFFALSE 65329
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65244: LD_VAR 0 3
65248: PPUSH
65249: LD_EXP 75
65253: PUSH
65254: LD_VAR 0 2
65258: ARRAY
65259: PUSH
65260: LD_INT 1
65262: ARRAY
65263: PUSH
65264: LD_INT 1
65266: ARRAY
65267: PPUSH
65268: LD_EXP 75
65272: PUSH
65273: LD_VAR 0 2
65277: ARRAY
65278: PUSH
65279: LD_INT 1
65281: ARRAY
65282: PUSH
65283: LD_INT 2
65285: ARRAY
65286: PPUSH
65287: LD_EXP 75
65291: PUSH
65292: LD_VAR 0 2
65296: ARRAY
65297: PUSH
65298: LD_INT 1
65300: ARRAY
65301: PUSH
65302: LD_INT 3
65304: ARRAY
65305: PPUSH
65306: LD_EXP 75
65310: PUSH
65311: LD_VAR 0 2
65315: ARRAY
65316: PUSH
65317: LD_INT 1
65319: ARRAY
65320: PUSH
65321: LD_INT 4
65323: ARRAY
65324: PPUSH
65325: CALL_OW 145
// end ;
65329: GO 65118
65331: POP
65332: POP
// end else
65333: GO 65505
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65335: LD_EXP 70
65339: PUSH
65340: LD_VAR 0 2
65344: ARRAY
65345: PPUSH
65346: LD_EXP 75
65350: PUSH
65351: LD_VAR 0 2
65355: ARRAY
65356: PUSH
65357: LD_INT 1
65359: ARRAY
65360: PUSH
65361: LD_INT 1
65363: ARRAY
65364: PPUSH
65365: LD_EXP 75
65369: PUSH
65370: LD_VAR 0 2
65374: ARRAY
65375: PUSH
65376: LD_INT 1
65378: ARRAY
65379: PUSH
65380: LD_INT 2
65382: ARRAY
65383: PPUSH
65384: LD_EXP 75
65388: PUSH
65389: LD_VAR 0 2
65393: ARRAY
65394: PUSH
65395: LD_INT 1
65397: ARRAY
65398: PUSH
65399: LD_INT 3
65401: ARRAY
65402: PPUSH
65403: LD_EXP 75
65407: PUSH
65408: LD_VAR 0 2
65412: ARRAY
65413: PUSH
65414: LD_INT 1
65416: ARRAY
65417: PUSH
65418: LD_INT 4
65420: ARRAY
65421: PPUSH
65422: LD_EXP 70
65426: PUSH
65427: LD_VAR 0 2
65431: ARRAY
65432: PPUSH
65433: LD_INT 21
65435: PUSH
65436: LD_INT 3
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PPUSH
65443: CALL_OW 72
65447: PPUSH
65448: EMPTY
65449: PPUSH
65450: CALL 25450 0 7
65454: NOT
65455: IFFALSE 65505
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65457: LD_ADDR_EXP 75
65461: PUSH
65462: LD_EXP 75
65466: PPUSH
65467: LD_VAR 0 2
65471: PPUSH
65472: LD_EXP 75
65476: PUSH
65477: LD_VAR 0 2
65481: ARRAY
65482: PPUSH
65483: LD_INT 1
65485: PPUSH
65486: LD_INT 1
65488: NEG
65489: PPUSH
65490: LD_INT 0
65492: PPUSH
65493: CALL 18015 0 4
65497: PPUSH
65498: CALL_OW 1
65502: ST_TO_ADDR
// continue ;
65503: GO 64353
// end ; end ; end ;
65505: GO 64353
65507: POP
65508: POP
// end ;
65509: LD_VAR 0 1
65513: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65514: LD_INT 0
65516: PPUSH
65517: PPUSH
65518: PPUSH
65519: PPUSH
65520: PPUSH
65521: PPUSH
// if not mc_bases then
65522: LD_EXP 70
65526: NOT
65527: IFFALSE 65531
// exit ;
65529: GO 65958
// for i = 1 to mc_bases do
65531: LD_ADDR_VAR 0 2
65535: PUSH
65536: DOUBLE
65537: LD_INT 1
65539: DEC
65540: ST_TO_ADDR
65541: LD_EXP 70
65545: PUSH
65546: FOR_TO
65547: IFFALSE 65956
// begin tmp := mc_build_upgrade [ i ] ;
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: LD_EXP 102
65558: PUSH
65559: LD_VAR 0 2
65563: ARRAY
65564: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65565: LD_ADDR_VAR 0 6
65569: PUSH
65570: LD_EXP 103
65574: PUSH
65575: LD_VAR 0 2
65579: ARRAY
65580: PPUSH
65581: LD_INT 2
65583: PUSH
65584: LD_INT 30
65586: PUSH
65587: LD_INT 6
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 30
65596: PUSH
65597: LD_INT 7
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: EMPTY
65605: LIST
65606: LIST
65607: LIST
65608: PPUSH
65609: CALL_OW 72
65613: ST_TO_ADDR
// if not tmp and not lab then
65614: LD_VAR 0 4
65618: NOT
65619: PUSH
65620: LD_VAR 0 6
65624: NOT
65625: AND
65626: IFFALSE 65630
// continue ;
65628: GO 65546
// if tmp then
65630: LD_VAR 0 4
65634: IFFALSE 65754
// for j in tmp do
65636: LD_ADDR_VAR 0 3
65640: PUSH
65641: LD_VAR 0 4
65645: PUSH
65646: FOR_IN
65647: IFFALSE 65752
// begin if UpgradeCost ( j ) then
65649: LD_VAR 0 3
65653: PPUSH
65654: CALL 25110 0 1
65658: IFFALSE 65750
// begin ComUpgrade ( j ) ;
65660: LD_VAR 0 3
65664: PPUSH
65665: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65669: LD_ADDR_EXP 102
65673: PUSH
65674: LD_EXP 102
65678: PPUSH
65679: LD_VAR 0 2
65683: PPUSH
65684: LD_EXP 102
65688: PUSH
65689: LD_VAR 0 2
65693: ARRAY
65694: PUSH
65695: LD_VAR 0 3
65699: DIFF
65700: PPUSH
65701: CALL_OW 1
65705: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65706: LD_ADDR_EXP 77
65710: PUSH
65711: LD_EXP 77
65715: PPUSH
65716: LD_VAR 0 2
65720: PUSH
65721: LD_EXP 77
65725: PUSH
65726: LD_VAR 0 2
65730: ARRAY
65731: PUSH
65732: LD_INT 1
65734: PLUS
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PPUSH
65740: LD_VAR 0 3
65744: PPUSH
65745: CALL 18597 0 3
65749: ST_TO_ADDR
// end ; end ;
65750: GO 65646
65752: POP
65753: POP
// if not lab or not mc_lab_upgrade [ i ] then
65754: LD_VAR 0 6
65758: NOT
65759: PUSH
65760: LD_EXP 104
65764: PUSH
65765: LD_VAR 0 2
65769: ARRAY
65770: NOT
65771: OR
65772: IFFALSE 65776
// continue ;
65774: GO 65546
// for j in lab do
65776: LD_ADDR_VAR 0 3
65780: PUSH
65781: LD_VAR 0 6
65785: PUSH
65786: FOR_IN
65787: IFFALSE 65952
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65789: LD_VAR 0 3
65793: PPUSH
65794: CALL_OW 266
65798: PUSH
65799: LD_INT 6
65801: PUSH
65802: LD_INT 7
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: IN
65809: PUSH
65810: LD_VAR 0 3
65814: PPUSH
65815: CALL_OW 461
65819: PUSH
65820: LD_INT 1
65822: NONEQUAL
65823: AND
65824: IFFALSE 65950
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65826: LD_VAR 0 3
65830: PPUSH
65831: LD_EXP 104
65835: PUSH
65836: LD_VAR 0 2
65840: ARRAY
65841: PUSH
65842: LD_INT 1
65844: ARRAY
65845: PPUSH
65846: CALL 25315 0 2
65850: IFFALSE 65950
// begin ComCancel ( j ) ;
65852: LD_VAR 0 3
65856: PPUSH
65857: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65861: LD_VAR 0 3
65865: PPUSH
65866: LD_EXP 104
65870: PUSH
65871: LD_VAR 0 2
65875: ARRAY
65876: PUSH
65877: LD_INT 1
65879: ARRAY
65880: PPUSH
65881: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65885: LD_VAR 0 3
65889: PUSH
65890: LD_EXP 77
65894: PUSH
65895: LD_VAR 0 2
65899: ARRAY
65900: IN
65901: NOT
65902: IFFALSE 65948
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65904: LD_ADDR_EXP 77
65908: PUSH
65909: LD_EXP 77
65913: PPUSH
65914: LD_VAR 0 2
65918: PUSH
65919: LD_EXP 77
65923: PUSH
65924: LD_VAR 0 2
65928: ARRAY
65929: PUSH
65930: LD_INT 1
65932: PLUS
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PPUSH
65938: LD_VAR 0 3
65942: PPUSH
65943: CALL 18597 0 3
65947: ST_TO_ADDR
// break ;
65948: GO 65952
// end ; end ; end ;
65950: GO 65786
65952: POP
65953: POP
// end ;
65954: GO 65546
65956: POP
65957: POP
// end ;
65958: LD_VAR 0 1
65962: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65963: LD_INT 0
65965: PPUSH
65966: PPUSH
65967: PPUSH
65968: PPUSH
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
65973: PPUSH
// if not mc_bases then
65974: LD_EXP 70
65978: NOT
65979: IFFALSE 65983
// exit ;
65981: GO 66388
// for i = 1 to mc_bases do
65983: LD_ADDR_VAR 0 2
65987: PUSH
65988: DOUBLE
65989: LD_INT 1
65991: DEC
65992: ST_TO_ADDR
65993: LD_EXP 70
65997: PUSH
65998: FOR_TO
65999: IFFALSE 66386
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66001: LD_EXP 78
66005: PUSH
66006: LD_VAR 0 2
66010: ARRAY
66011: NOT
66012: PUSH
66013: LD_EXP 70
66017: PUSH
66018: LD_VAR 0 2
66022: ARRAY
66023: PPUSH
66024: LD_INT 30
66026: PUSH
66027: LD_INT 3
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PPUSH
66034: CALL_OW 72
66038: NOT
66039: OR
66040: IFFALSE 66044
// continue ;
66042: GO 65998
// busy := false ;
66044: LD_ADDR_VAR 0 8
66048: PUSH
66049: LD_INT 0
66051: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66052: LD_ADDR_VAR 0 4
66056: PUSH
66057: LD_EXP 70
66061: PUSH
66062: LD_VAR 0 2
66066: ARRAY
66067: PPUSH
66068: LD_INT 30
66070: PUSH
66071: LD_INT 3
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PPUSH
66078: CALL_OW 72
66082: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66083: LD_ADDR_VAR 0 6
66087: PUSH
66088: LD_EXP 78
66092: PUSH
66093: LD_VAR 0 2
66097: ARRAY
66098: PPUSH
66099: LD_INT 2
66101: PUSH
66102: LD_INT 30
66104: PUSH
66105: LD_INT 32
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 30
66114: PUSH
66115: LD_INT 33
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: LIST
66126: PPUSH
66127: CALL_OW 72
66131: ST_TO_ADDR
// if not t then
66132: LD_VAR 0 6
66136: NOT
66137: IFFALSE 66141
// continue ;
66139: GO 65998
// for j in tmp do
66141: LD_ADDR_VAR 0 3
66145: PUSH
66146: LD_VAR 0 4
66150: PUSH
66151: FOR_IN
66152: IFFALSE 66182
// if not BuildingStatus ( j ) = bs_idle then
66154: LD_VAR 0 3
66158: PPUSH
66159: CALL_OW 461
66163: PUSH
66164: LD_INT 2
66166: EQUAL
66167: NOT
66168: IFFALSE 66180
// begin busy := true ;
66170: LD_ADDR_VAR 0 8
66174: PUSH
66175: LD_INT 1
66177: ST_TO_ADDR
// break ;
66178: GO 66182
// end ;
66180: GO 66151
66182: POP
66183: POP
// if busy then
66184: LD_VAR 0 8
66188: IFFALSE 66192
// continue ;
66190: GO 65998
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66192: LD_ADDR_VAR 0 7
66196: PUSH
66197: LD_VAR 0 6
66201: PPUSH
66202: LD_INT 35
66204: PUSH
66205: LD_INT 0
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PPUSH
66212: CALL_OW 72
66216: ST_TO_ADDR
// if tw then
66217: LD_VAR 0 7
66221: IFFALSE 66298
// begin tw := tw [ 1 ] ;
66223: LD_ADDR_VAR 0 7
66227: PUSH
66228: LD_VAR 0 7
66232: PUSH
66233: LD_INT 1
66235: ARRAY
66236: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66237: LD_ADDR_VAR 0 9
66241: PUSH
66242: LD_VAR 0 7
66246: PPUSH
66247: LD_EXP 95
66251: PUSH
66252: LD_VAR 0 2
66256: ARRAY
66257: PPUSH
66258: CALL 23607 0 2
66262: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66263: LD_EXP 109
66267: PUSH
66268: LD_VAR 0 2
66272: ARRAY
66273: IFFALSE 66296
// if not weapon in mc_allowed_tower_weapons [ i ] then
66275: LD_VAR 0 9
66279: PUSH
66280: LD_EXP 109
66284: PUSH
66285: LD_VAR 0 2
66289: ARRAY
66290: IN
66291: NOT
66292: IFFALSE 66296
// continue ;
66294: GO 65998
// end else
66296: GO 66361
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66298: LD_ADDR_VAR 0 5
66302: PUSH
66303: LD_EXP 78
66307: PUSH
66308: LD_VAR 0 2
66312: ARRAY
66313: PPUSH
66314: LD_VAR 0 4
66318: PPUSH
66319: CALL 49840 0 2
66323: ST_TO_ADDR
// if not tmp2 then
66324: LD_VAR 0 5
66328: NOT
66329: IFFALSE 66333
// continue ;
66331: GO 65998
// tw := tmp2 [ 1 ] ;
66333: LD_ADDR_VAR 0 7
66337: PUSH
66338: LD_VAR 0 5
66342: PUSH
66343: LD_INT 1
66345: ARRAY
66346: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66347: LD_ADDR_VAR 0 9
66351: PUSH
66352: LD_VAR 0 5
66356: PUSH
66357: LD_INT 2
66359: ARRAY
66360: ST_TO_ADDR
// end ; if not weapon then
66361: LD_VAR 0 9
66365: NOT
66366: IFFALSE 66370
// continue ;
66368: GO 65998
// ComPlaceWeapon ( tw , weapon ) ;
66370: LD_VAR 0 7
66374: PPUSH
66375: LD_VAR 0 9
66379: PPUSH
66380: CALL_OW 148
// end ;
66384: GO 65998
66386: POP
66387: POP
// end ;
66388: LD_VAR 0 1
66392: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66393: LD_INT 0
66395: PPUSH
66396: PPUSH
66397: PPUSH
66398: PPUSH
66399: PPUSH
66400: PPUSH
66401: PPUSH
// if not mc_bases then
66402: LD_EXP 70
66406: NOT
66407: IFFALSE 66411
// exit ;
66409: GO 67179
// for i = 1 to mc_bases do
66411: LD_ADDR_VAR 0 2
66415: PUSH
66416: DOUBLE
66417: LD_INT 1
66419: DEC
66420: ST_TO_ADDR
66421: LD_EXP 70
66425: PUSH
66426: FOR_TO
66427: IFFALSE 67177
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66429: LD_EXP 83
66433: PUSH
66434: LD_VAR 0 2
66438: ARRAY
66439: NOT
66440: PUSH
66441: LD_EXP 83
66445: PUSH
66446: LD_VAR 0 2
66450: ARRAY
66451: PUSH
66452: LD_EXP 84
66456: PUSH
66457: LD_VAR 0 2
66461: ARRAY
66462: EQUAL
66463: OR
66464: PUSH
66465: LD_EXP 93
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: OR
66476: IFFALSE 66480
// continue ;
66478: GO 66426
// if mc_miners [ i ] then
66480: LD_EXP 84
66484: PUSH
66485: LD_VAR 0 2
66489: ARRAY
66490: IFFALSE 66864
// begin for j = mc_miners [ i ] downto 1 do
66492: LD_ADDR_VAR 0 3
66496: PUSH
66497: DOUBLE
66498: LD_EXP 84
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: INC
66509: ST_TO_ADDR
66510: LD_INT 1
66512: PUSH
66513: FOR_DOWNTO
66514: IFFALSE 66862
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66516: LD_EXP 84
66520: PUSH
66521: LD_VAR 0 2
66525: ARRAY
66526: PUSH
66527: LD_VAR 0 3
66531: ARRAY
66532: PPUSH
66533: CALL_OW 301
66537: PUSH
66538: LD_EXP 84
66542: PUSH
66543: LD_VAR 0 2
66547: ARRAY
66548: PUSH
66549: LD_VAR 0 3
66553: ARRAY
66554: PPUSH
66555: CALL_OW 257
66559: PUSH
66560: LD_INT 1
66562: NONEQUAL
66563: OR
66564: IFFALSE 66627
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66566: LD_ADDR_VAR 0 5
66570: PUSH
66571: LD_EXP 84
66575: PUSH
66576: LD_VAR 0 2
66580: ARRAY
66581: PUSH
66582: LD_EXP 84
66586: PUSH
66587: LD_VAR 0 2
66591: ARRAY
66592: PUSH
66593: LD_VAR 0 3
66597: ARRAY
66598: DIFF
66599: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66600: LD_ADDR_EXP 84
66604: PUSH
66605: LD_EXP 84
66609: PPUSH
66610: LD_VAR 0 2
66614: PPUSH
66615: LD_VAR 0 5
66619: PPUSH
66620: CALL_OW 1
66624: ST_TO_ADDR
// continue ;
66625: GO 66513
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66627: LD_EXP 84
66631: PUSH
66632: LD_VAR 0 2
66636: ARRAY
66637: PUSH
66638: LD_VAR 0 3
66642: ARRAY
66643: PPUSH
66644: CALL_OW 257
66648: PUSH
66649: LD_INT 1
66651: EQUAL
66652: PUSH
66653: LD_EXP 84
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: PUSH
66664: LD_VAR 0 3
66668: ARRAY
66669: PPUSH
66670: CALL_OW 459
66674: NOT
66675: AND
66676: PUSH
66677: LD_EXP 84
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: PUSH
66688: LD_VAR 0 3
66692: ARRAY
66693: PPUSH
66694: CALL_OW 314
66698: NOT
66699: AND
66700: IFFALSE 66860
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66702: LD_EXP 84
66706: PUSH
66707: LD_VAR 0 2
66711: ARRAY
66712: PUSH
66713: LD_VAR 0 3
66717: ARRAY
66718: PPUSH
66719: CALL_OW 310
66723: IFFALSE 66746
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66725: LD_EXP 84
66729: PUSH
66730: LD_VAR 0 2
66734: ARRAY
66735: PUSH
66736: LD_VAR 0 3
66740: ARRAY
66741: PPUSH
66742: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66746: LD_EXP 84
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PUSH
66757: LD_VAR 0 3
66761: ARRAY
66762: PPUSH
66763: CALL_OW 314
66767: NOT
66768: IFFALSE 66860
// begin r := rand ( 1 , mc_mines [ i ] ) ;
66770: LD_ADDR_VAR 0 7
66774: PUSH
66775: LD_INT 1
66777: PPUSH
66778: LD_EXP 83
66782: PUSH
66783: LD_VAR 0 2
66787: ARRAY
66788: PPUSH
66789: CALL_OW 12
66793: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66794: LD_EXP 84
66798: PUSH
66799: LD_VAR 0 2
66803: ARRAY
66804: PUSH
66805: LD_VAR 0 3
66809: ARRAY
66810: PPUSH
66811: LD_EXP 83
66815: PUSH
66816: LD_VAR 0 2
66820: ARRAY
66821: PUSH
66822: LD_VAR 0 7
66826: ARRAY
66827: PUSH
66828: LD_INT 1
66830: ARRAY
66831: PPUSH
66832: LD_EXP 83
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: PUSH
66843: LD_VAR 0 7
66847: ARRAY
66848: PUSH
66849: LD_INT 2
66851: ARRAY
66852: PPUSH
66853: LD_INT 0
66855: PPUSH
66856: CALL_OW 193
// end ; end ; end ;
66860: GO 66513
66862: POP
66863: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66864: LD_ADDR_VAR 0 5
66868: PUSH
66869: LD_EXP 70
66873: PUSH
66874: LD_VAR 0 2
66878: ARRAY
66879: PPUSH
66880: LD_INT 2
66882: PUSH
66883: LD_INT 30
66885: PUSH
66886: LD_INT 4
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 30
66895: PUSH
66896: LD_INT 5
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: PUSH
66903: LD_INT 30
66905: PUSH
66906: LD_INT 32
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: PPUSH
66919: CALL_OW 72
66923: ST_TO_ADDR
// if not tmp then
66924: LD_VAR 0 5
66928: NOT
66929: IFFALSE 66933
// continue ;
66931: GO 66426
// list := [ ] ;
66933: LD_ADDR_VAR 0 6
66937: PUSH
66938: EMPTY
66939: ST_TO_ADDR
// for j in tmp do
66940: LD_ADDR_VAR 0 3
66944: PUSH
66945: LD_VAR 0 5
66949: PUSH
66950: FOR_IN
66951: IFFALSE 67020
// begin for k in UnitsInside ( j ) do
66953: LD_ADDR_VAR 0 4
66957: PUSH
66958: LD_VAR 0 3
66962: PPUSH
66963: CALL_OW 313
66967: PUSH
66968: FOR_IN
66969: IFFALSE 67016
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66971: LD_VAR 0 4
66975: PPUSH
66976: CALL_OW 257
66980: PUSH
66981: LD_INT 1
66983: EQUAL
66984: PUSH
66985: LD_VAR 0 4
66989: PPUSH
66990: CALL_OW 459
66994: NOT
66995: AND
66996: IFFALSE 67014
// list := list ^ k ;
66998: LD_ADDR_VAR 0 6
67002: PUSH
67003: LD_VAR 0 6
67007: PUSH
67008: LD_VAR 0 4
67012: ADD
67013: ST_TO_ADDR
67014: GO 66968
67016: POP
67017: POP
// end ;
67018: GO 66950
67020: POP
67021: POP
// list := list diff mc_miners [ i ] ;
67022: LD_ADDR_VAR 0 6
67026: PUSH
67027: LD_VAR 0 6
67031: PUSH
67032: LD_EXP 84
67036: PUSH
67037: LD_VAR 0 2
67041: ARRAY
67042: DIFF
67043: ST_TO_ADDR
// if not list then
67044: LD_VAR 0 6
67048: NOT
67049: IFFALSE 67053
// continue ;
67051: GO 66426
// k := mc_mines [ i ] - mc_miners [ i ] ;
67053: LD_ADDR_VAR 0 4
67057: PUSH
67058: LD_EXP 83
67062: PUSH
67063: LD_VAR 0 2
67067: ARRAY
67068: PUSH
67069: LD_EXP 84
67073: PUSH
67074: LD_VAR 0 2
67078: ARRAY
67079: MINUS
67080: ST_TO_ADDR
// if k > list then
67081: LD_VAR 0 4
67085: PUSH
67086: LD_VAR 0 6
67090: GREATER
67091: IFFALSE 67103
// k := list ;
67093: LD_ADDR_VAR 0 4
67097: PUSH
67098: LD_VAR 0 6
67102: ST_TO_ADDR
// for j = 1 to k do
67103: LD_ADDR_VAR 0 3
67107: PUSH
67108: DOUBLE
67109: LD_INT 1
67111: DEC
67112: ST_TO_ADDR
67113: LD_VAR 0 4
67117: PUSH
67118: FOR_TO
67119: IFFALSE 67173
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67121: LD_ADDR_EXP 84
67125: PUSH
67126: LD_EXP 84
67130: PPUSH
67131: LD_VAR 0 2
67135: PUSH
67136: LD_EXP 84
67140: PUSH
67141: LD_VAR 0 2
67145: ARRAY
67146: PUSH
67147: LD_INT 1
67149: PLUS
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PPUSH
67155: LD_VAR 0 6
67159: PUSH
67160: LD_VAR 0 3
67164: ARRAY
67165: PPUSH
67166: CALL 18597 0 3
67170: ST_TO_ADDR
67171: GO 67118
67173: POP
67174: POP
// end ;
67175: GO 66426
67177: POP
67178: POP
// end ;
67179: LD_VAR 0 1
67183: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67184: LD_INT 0
67186: PPUSH
67187: PPUSH
67188: PPUSH
67189: PPUSH
67190: PPUSH
67191: PPUSH
67192: PPUSH
67193: PPUSH
67194: PPUSH
67195: PPUSH
67196: PPUSH
// if not mc_bases then
67197: LD_EXP 70
67201: NOT
67202: IFFALSE 67206
// exit ;
67204: GO 69029
// for i = 1 to mc_bases do
67206: LD_ADDR_VAR 0 2
67210: PUSH
67211: DOUBLE
67212: LD_INT 1
67214: DEC
67215: ST_TO_ADDR
67216: LD_EXP 70
67220: PUSH
67221: FOR_TO
67222: IFFALSE 69027
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67224: LD_EXP 70
67228: PUSH
67229: LD_VAR 0 2
67233: ARRAY
67234: NOT
67235: PUSH
67236: LD_EXP 77
67240: PUSH
67241: LD_VAR 0 2
67245: ARRAY
67246: OR
67247: IFFALSE 67251
// continue ;
67249: GO 67221
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67251: LD_EXP 86
67255: PUSH
67256: LD_VAR 0 2
67260: ARRAY
67261: NOT
67262: PUSH
67263: LD_EXP 87
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: AND
67274: IFFALSE 67312
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67276: LD_ADDR_EXP 87
67280: PUSH
67281: LD_EXP 87
67285: PPUSH
67286: LD_VAR 0 2
67290: PPUSH
67291: EMPTY
67292: PPUSH
67293: CALL_OW 1
67297: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67298: LD_VAR 0 2
67302: PPUSH
67303: LD_INT 107
67305: PPUSH
67306: CALL 58080 0 2
// continue ;
67310: GO 67221
// end ; target := [ ] ;
67312: LD_ADDR_VAR 0 7
67316: PUSH
67317: EMPTY
67318: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67319: LD_ADDR_VAR 0 6
67323: PUSH
67324: LD_EXP 70
67328: PUSH
67329: LD_VAR 0 2
67333: ARRAY
67334: PUSH
67335: LD_INT 1
67337: ARRAY
67338: PPUSH
67339: CALL_OW 255
67343: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67344: LD_ADDR_VAR 0 9
67348: PUSH
67349: LD_EXP 70
67353: PUSH
67354: LD_VAR 0 2
67358: ARRAY
67359: PPUSH
67360: LD_INT 2
67362: PUSH
67363: LD_INT 30
67365: PUSH
67366: LD_INT 0
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 30
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: EMPTY
67384: LIST
67385: LIST
67386: LIST
67387: PPUSH
67388: CALL_OW 72
67392: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67393: LD_ADDR_VAR 0 3
67397: PUSH
67398: DOUBLE
67399: LD_EXP 86
67403: PUSH
67404: LD_VAR 0 2
67408: ARRAY
67409: INC
67410: ST_TO_ADDR
67411: LD_INT 1
67413: PUSH
67414: FOR_DOWNTO
67415: IFFALSE 67660
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67417: LD_EXP 86
67421: PUSH
67422: LD_VAR 0 2
67426: ARRAY
67427: PUSH
67428: LD_VAR 0 3
67432: ARRAY
67433: PUSH
67434: LD_INT 2
67436: ARRAY
67437: PPUSH
67438: LD_EXP 86
67442: PUSH
67443: LD_VAR 0 2
67447: ARRAY
67448: PUSH
67449: LD_VAR 0 3
67453: ARRAY
67454: PUSH
67455: LD_INT 3
67457: ARRAY
67458: PPUSH
67459: CALL_OW 488
67463: PUSH
67464: LD_EXP 86
67468: PUSH
67469: LD_VAR 0 2
67473: ARRAY
67474: PUSH
67475: LD_VAR 0 3
67479: ARRAY
67480: PUSH
67481: LD_INT 2
67483: ARRAY
67484: PPUSH
67485: LD_EXP 86
67489: PUSH
67490: LD_VAR 0 2
67494: ARRAY
67495: PUSH
67496: LD_VAR 0 3
67500: ARRAY
67501: PUSH
67502: LD_INT 3
67504: ARRAY
67505: PPUSH
67506: CALL_OW 284
67510: PUSH
67511: LD_INT 0
67513: EQUAL
67514: AND
67515: IFFALSE 67570
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67517: LD_ADDR_VAR 0 5
67521: PUSH
67522: LD_EXP 86
67526: PUSH
67527: LD_VAR 0 2
67531: ARRAY
67532: PPUSH
67533: LD_VAR 0 3
67537: PPUSH
67538: CALL_OW 3
67542: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67543: LD_ADDR_EXP 86
67547: PUSH
67548: LD_EXP 86
67552: PPUSH
67553: LD_VAR 0 2
67557: PPUSH
67558: LD_VAR 0 5
67562: PPUSH
67563: CALL_OW 1
67567: ST_TO_ADDR
// continue ;
67568: GO 67414
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67570: LD_VAR 0 6
67574: PPUSH
67575: LD_EXP 86
67579: PUSH
67580: LD_VAR 0 2
67584: ARRAY
67585: PUSH
67586: LD_VAR 0 3
67590: ARRAY
67591: PUSH
67592: LD_INT 2
67594: ARRAY
67595: PPUSH
67596: LD_EXP 86
67600: PUSH
67601: LD_VAR 0 2
67605: ARRAY
67606: PUSH
67607: LD_VAR 0 3
67611: ARRAY
67612: PUSH
67613: LD_INT 3
67615: ARRAY
67616: PPUSH
67617: LD_INT 30
67619: PPUSH
67620: CALL 19493 0 4
67624: PUSH
67625: LD_INT 4
67627: ARRAY
67628: PUSH
67629: LD_INT 0
67631: EQUAL
67632: IFFALSE 67658
// begin target := mc_crates [ i ] [ j ] ;
67634: LD_ADDR_VAR 0 7
67638: PUSH
67639: LD_EXP 86
67643: PUSH
67644: LD_VAR 0 2
67648: ARRAY
67649: PUSH
67650: LD_VAR 0 3
67654: ARRAY
67655: ST_TO_ADDR
// break ;
67656: GO 67660
// end ; end ;
67658: GO 67414
67660: POP
67661: POP
// if not target then
67662: LD_VAR 0 7
67666: NOT
67667: IFFALSE 67671
// continue ;
67669: GO 67221
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67671: LD_ADDR_VAR 0 8
67675: PUSH
67676: LD_EXP 89
67680: PUSH
67681: LD_VAR 0 2
67685: ARRAY
67686: PPUSH
67687: LD_INT 2
67689: PUSH
67690: LD_INT 3
67692: PUSH
67693: LD_INT 58
67695: PUSH
67696: EMPTY
67697: LIST
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 61
67705: PUSH
67706: EMPTY
67707: LIST
67708: PUSH
67709: LD_INT 33
67711: PUSH
67712: LD_INT 5
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 33
67721: PUSH
67722: LD_INT 3
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 2
67738: PUSH
67739: LD_INT 34
67741: PUSH
67742: LD_INT 32
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 34
67751: PUSH
67752: LD_INT 51
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: LD_INT 34
67761: PUSH
67762: LD_INT 12
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: PUSH
67775: EMPTY
67776: LIST
67777: LIST
67778: PPUSH
67779: CALL_OW 72
67783: ST_TO_ADDR
// if not cargo then
67784: LD_VAR 0 8
67788: NOT
67789: IFFALSE 68495
// begin if mc_crates_collector [ i ] < 5 then
67791: LD_EXP 87
67795: PUSH
67796: LD_VAR 0 2
67800: ARRAY
67801: PUSH
67802: LD_INT 5
67804: LESS
67805: IFFALSE 68171
// begin if mc_ape [ i ] then
67807: LD_EXP 99
67811: PUSH
67812: LD_VAR 0 2
67816: ARRAY
67817: IFFALSE 67864
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67819: LD_ADDR_VAR 0 5
67823: PUSH
67824: LD_EXP 99
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: PPUSH
67835: LD_INT 25
67837: PUSH
67838: LD_INT 16
67840: PUSH
67841: EMPTY
67842: LIST
67843: LIST
67844: PUSH
67845: LD_INT 24
67847: PUSH
67848: LD_INT 750
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PPUSH
67859: CALL_OW 72
67863: ST_TO_ADDR
// if not tmp then
67864: LD_VAR 0 5
67868: NOT
67869: IFFALSE 67916
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67871: LD_ADDR_VAR 0 5
67875: PUSH
67876: LD_EXP 70
67880: PUSH
67881: LD_VAR 0 2
67885: ARRAY
67886: PPUSH
67887: LD_INT 25
67889: PUSH
67890: LD_INT 2
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 24
67899: PUSH
67900: LD_INT 750
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PPUSH
67911: CALL_OW 72
67915: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67916: LD_EXP 99
67920: PUSH
67921: LD_VAR 0 2
67925: ARRAY
67926: PUSH
67927: LD_EXP 70
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: PPUSH
67938: LD_INT 25
67940: PUSH
67941: LD_INT 2
67943: PUSH
67944: EMPTY
67945: LIST
67946: LIST
67947: PUSH
67948: LD_INT 24
67950: PUSH
67951: LD_INT 750
67953: PUSH
67954: EMPTY
67955: LIST
67956: LIST
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PPUSH
67962: CALL_OW 72
67966: AND
67967: PUSH
67968: LD_VAR 0 5
67972: PUSH
67973: LD_INT 5
67975: LESS
67976: AND
67977: IFFALSE 68059
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67979: LD_ADDR_VAR 0 3
67983: PUSH
67984: LD_EXP 70
67988: PUSH
67989: LD_VAR 0 2
67993: ARRAY
67994: PPUSH
67995: LD_INT 25
67997: PUSH
67998: LD_INT 2
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 24
68007: PUSH
68008: LD_INT 750
68010: PUSH
68011: EMPTY
68012: LIST
68013: LIST
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PPUSH
68019: CALL_OW 72
68023: PUSH
68024: FOR_IN
68025: IFFALSE 68057
// begin tmp := tmp union j ;
68027: LD_ADDR_VAR 0 5
68031: PUSH
68032: LD_VAR 0 5
68036: PUSH
68037: LD_VAR 0 3
68041: UNION
68042: ST_TO_ADDR
// if tmp >= 5 then
68043: LD_VAR 0 5
68047: PUSH
68048: LD_INT 5
68050: GREATEREQUAL
68051: IFFALSE 68055
// break ;
68053: GO 68057
// end ;
68055: GO 68024
68057: POP
68058: POP
// end ; if not tmp then
68059: LD_VAR 0 5
68063: NOT
68064: IFFALSE 68068
// continue ;
68066: GO 67221
// for j in tmp do
68068: LD_ADDR_VAR 0 3
68072: PUSH
68073: LD_VAR 0 5
68077: PUSH
68078: FOR_IN
68079: IFFALSE 68169
// if not GetTag ( j ) then
68081: LD_VAR 0 3
68085: PPUSH
68086: CALL_OW 110
68090: NOT
68091: IFFALSE 68167
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68093: LD_ADDR_EXP 87
68097: PUSH
68098: LD_EXP 87
68102: PPUSH
68103: LD_VAR 0 2
68107: PUSH
68108: LD_EXP 87
68112: PUSH
68113: LD_VAR 0 2
68117: ARRAY
68118: PUSH
68119: LD_INT 1
68121: PLUS
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PPUSH
68127: LD_VAR 0 3
68131: PPUSH
68132: CALL 18597 0 3
68136: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68137: LD_VAR 0 3
68141: PPUSH
68142: LD_INT 107
68144: PPUSH
68145: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68149: LD_EXP 87
68153: PUSH
68154: LD_VAR 0 2
68158: ARRAY
68159: PUSH
68160: LD_INT 5
68162: GREATEREQUAL
68163: IFFALSE 68167
// break ;
68165: GO 68169
// end ;
68167: GO 68078
68169: POP
68170: POP
// end ; if mc_crates_collector [ i ] and target then
68171: LD_EXP 87
68175: PUSH
68176: LD_VAR 0 2
68180: ARRAY
68181: PUSH
68182: LD_VAR 0 7
68186: AND
68187: IFFALSE 68493
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68189: LD_EXP 87
68193: PUSH
68194: LD_VAR 0 2
68198: ARRAY
68199: PUSH
68200: LD_VAR 0 7
68204: PUSH
68205: LD_INT 1
68207: ARRAY
68208: LESS
68209: IFFALSE 68229
// tmp := mc_crates_collector [ i ] else
68211: LD_ADDR_VAR 0 5
68215: PUSH
68216: LD_EXP 87
68220: PUSH
68221: LD_VAR 0 2
68225: ARRAY
68226: ST_TO_ADDR
68227: GO 68243
// tmp := target [ 1 ] ;
68229: LD_ADDR_VAR 0 5
68233: PUSH
68234: LD_VAR 0 7
68238: PUSH
68239: LD_INT 1
68241: ARRAY
68242: ST_TO_ADDR
// k := 0 ;
68243: LD_ADDR_VAR 0 4
68247: PUSH
68248: LD_INT 0
68250: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68251: LD_ADDR_VAR 0 3
68255: PUSH
68256: LD_EXP 87
68260: PUSH
68261: LD_VAR 0 2
68265: ARRAY
68266: PUSH
68267: FOR_IN
68268: IFFALSE 68491
// begin k := k + 1 ;
68270: LD_ADDR_VAR 0 4
68274: PUSH
68275: LD_VAR 0 4
68279: PUSH
68280: LD_INT 1
68282: PLUS
68283: ST_TO_ADDR
// if k > tmp then
68284: LD_VAR 0 4
68288: PUSH
68289: LD_VAR 0 5
68293: GREATER
68294: IFFALSE 68298
// break ;
68296: GO 68491
// if not GetClass ( j ) in [ 2 , 16 ] then
68298: LD_VAR 0 3
68302: PPUSH
68303: CALL_OW 257
68307: PUSH
68308: LD_INT 2
68310: PUSH
68311: LD_INT 16
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: IN
68318: NOT
68319: IFFALSE 68372
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68321: LD_ADDR_EXP 87
68325: PUSH
68326: LD_EXP 87
68330: PPUSH
68331: LD_VAR 0 2
68335: PPUSH
68336: LD_EXP 87
68340: PUSH
68341: LD_VAR 0 2
68345: ARRAY
68346: PUSH
68347: LD_VAR 0 3
68351: DIFF
68352: PPUSH
68353: CALL_OW 1
68357: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68358: LD_VAR 0 3
68362: PPUSH
68363: LD_INT 0
68365: PPUSH
68366: CALL_OW 109
// continue ;
68370: GO 68267
// end ; if IsInUnit ( j ) then
68372: LD_VAR 0 3
68376: PPUSH
68377: CALL_OW 310
68381: IFFALSE 68392
// ComExitBuilding ( j ) ;
68383: LD_VAR 0 3
68387: PPUSH
68388: CALL_OW 122
// wait ( 3 ) ;
68392: LD_INT 3
68394: PPUSH
68395: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68399: LD_VAR 0 3
68403: PPUSH
68404: CALL_OW 314
68408: PUSH
68409: LD_VAR 0 6
68413: PPUSH
68414: LD_VAR 0 7
68418: PUSH
68419: LD_INT 2
68421: ARRAY
68422: PPUSH
68423: LD_VAR 0 7
68427: PUSH
68428: LD_INT 3
68430: ARRAY
68431: PPUSH
68432: LD_INT 30
68434: PPUSH
68435: CALL 19493 0 4
68439: PUSH
68440: LD_INT 4
68442: ARRAY
68443: AND
68444: IFFALSE 68462
// ComStandNearbyBuilding ( j , depot ) else
68446: LD_VAR 0 3
68450: PPUSH
68451: LD_VAR 0 9
68455: PPUSH
68456: CALL 15175 0 2
68460: GO 68489
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68462: LD_VAR 0 3
68466: PPUSH
68467: LD_VAR 0 7
68471: PUSH
68472: LD_INT 2
68474: ARRAY
68475: PPUSH
68476: LD_VAR 0 7
68480: PUSH
68481: LD_INT 3
68483: ARRAY
68484: PPUSH
68485: CALL_OW 117
// end ;
68489: GO 68267
68491: POP
68492: POP
// end ; end else
68493: GO 69025
// begin for j in cargo do
68495: LD_ADDR_VAR 0 3
68499: PUSH
68500: LD_VAR 0 8
68504: PUSH
68505: FOR_IN
68506: IFFALSE 69023
// begin if GetTag ( j ) <> 0 then
68508: LD_VAR 0 3
68512: PPUSH
68513: CALL_OW 110
68517: PUSH
68518: LD_INT 0
68520: NONEQUAL
68521: IFFALSE 68525
// continue ;
68523: GO 68505
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68525: LD_VAR 0 3
68529: PPUSH
68530: CALL_OW 256
68534: PUSH
68535: LD_INT 1000
68537: LESS
68538: PUSH
68539: LD_VAR 0 3
68543: PPUSH
68544: LD_EXP 94
68548: PUSH
68549: LD_VAR 0 2
68553: ARRAY
68554: PPUSH
68555: CALL_OW 308
68559: NOT
68560: AND
68561: IFFALSE 68583
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68563: LD_VAR 0 3
68567: PPUSH
68568: LD_EXP 94
68572: PUSH
68573: LD_VAR 0 2
68577: ARRAY
68578: PPUSH
68579: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68583: LD_VAR 0 3
68587: PPUSH
68588: CALL_OW 256
68592: PUSH
68593: LD_INT 1000
68595: LESS
68596: PUSH
68597: LD_VAR 0 3
68601: PPUSH
68602: LD_EXP 94
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: PPUSH
68613: CALL_OW 308
68617: AND
68618: IFFALSE 68622
// continue ;
68620: GO 68505
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68622: LD_VAR 0 3
68626: PPUSH
68627: CALL_OW 262
68631: PUSH
68632: LD_INT 2
68634: EQUAL
68635: PUSH
68636: LD_VAR 0 3
68640: PPUSH
68641: CALL_OW 261
68645: PUSH
68646: LD_INT 15
68648: LESS
68649: AND
68650: IFFALSE 68654
// continue ;
68652: GO 68505
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68654: LD_VAR 0 3
68658: PPUSH
68659: CALL_OW 262
68663: PUSH
68664: LD_INT 1
68666: EQUAL
68667: PUSH
68668: LD_VAR 0 3
68672: PPUSH
68673: CALL_OW 261
68677: PUSH
68678: LD_INT 10
68680: LESS
68681: AND
68682: IFFALSE 68962
// begin if not depot then
68684: LD_VAR 0 9
68688: NOT
68689: IFFALSE 68693
// continue ;
68691: GO 68505
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68693: LD_VAR 0 3
68697: PPUSH
68698: LD_VAR 0 9
68702: PPUSH
68703: LD_VAR 0 3
68707: PPUSH
68708: CALL_OW 74
68712: PPUSH
68713: CALL_OW 296
68717: PUSH
68718: LD_INT 6
68720: LESS
68721: IFFALSE 68737
// SetFuel ( j , 100 ) else
68723: LD_VAR 0 3
68727: PPUSH
68728: LD_INT 100
68730: PPUSH
68731: CALL_OW 240
68735: GO 68962
// if GetFuel ( j ) = 0 then
68737: LD_VAR 0 3
68741: PPUSH
68742: CALL_OW 261
68746: PUSH
68747: LD_INT 0
68749: EQUAL
68750: IFFALSE 68962
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68752: LD_ADDR_EXP 89
68756: PUSH
68757: LD_EXP 89
68761: PPUSH
68762: LD_VAR 0 2
68766: PPUSH
68767: LD_EXP 89
68771: PUSH
68772: LD_VAR 0 2
68776: ARRAY
68777: PUSH
68778: LD_VAR 0 3
68782: DIFF
68783: PPUSH
68784: CALL_OW 1
68788: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68789: LD_VAR 0 3
68793: PPUSH
68794: CALL_OW 263
68798: PUSH
68799: LD_INT 1
68801: EQUAL
68802: IFFALSE 68818
// ComExitVehicle ( IsInUnit ( j ) ) ;
68804: LD_VAR 0 3
68808: PPUSH
68809: CALL_OW 310
68813: PPUSH
68814: CALL_OW 121
// if GetControl ( j ) = control_remote then
68818: LD_VAR 0 3
68822: PPUSH
68823: CALL_OW 263
68827: PUSH
68828: LD_INT 2
68830: EQUAL
68831: IFFALSE 68842
// ComUnlink ( j ) ;
68833: LD_VAR 0 3
68837: PPUSH
68838: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68842: LD_ADDR_VAR 0 10
68846: PUSH
68847: LD_VAR 0 2
68851: PPUSH
68852: LD_INT 3
68854: PPUSH
68855: CALL 78601 0 2
68859: ST_TO_ADDR
// if fac then
68860: LD_VAR 0 10
68864: IFFALSE 68960
// begin for k in fac do
68866: LD_ADDR_VAR 0 4
68870: PUSH
68871: LD_VAR 0 10
68875: PUSH
68876: FOR_IN
68877: IFFALSE 68958
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68879: LD_ADDR_VAR 0 11
68883: PUSH
68884: LD_VAR 0 10
68888: PPUSH
68889: LD_VAR 0 3
68893: PPUSH
68894: CALL_OW 265
68898: PPUSH
68899: LD_VAR 0 3
68903: PPUSH
68904: CALL_OW 262
68908: PPUSH
68909: LD_VAR 0 3
68913: PPUSH
68914: CALL_OW 263
68918: PPUSH
68919: LD_VAR 0 3
68923: PPUSH
68924: CALL_OW 264
68928: PPUSH
68929: CALL 16093 0 5
68933: ST_TO_ADDR
// if components then
68934: LD_VAR 0 11
68938: IFFALSE 68956
// begin MC_InsertProduceList ( i , components ) ;
68940: LD_VAR 0 2
68944: PPUSH
68945: LD_VAR 0 11
68949: PPUSH
68950: CALL 78146 0 2
// break ;
68954: GO 68958
// end ; end ;
68956: GO 68876
68958: POP
68959: POP
// end ; continue ;
68960: GO 68505
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68962: LD_VAR 0 3
68966: PPUSH
68967: LD_INT 1
68969: PPUSH
68970: CALL_OW 289
68974: PUSH
68975: LD_INT 100
68977: LESS
68978: PUSH
68979: LD_VAR 0 3
68983: PPUSH
68984: CALL_OW 314
68988: NOT
68989: AND
68990: IFFALSE 69019
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68992: LD_VAR 0 3
68996: PPUSH
68997: LD_VAR 0 7
69001: PUSH
69002: LD_INT 2
69004: ARRAY
69005: PPUSH
69006: LD_VAR 0 7
69010: PUSH
69011: LD_INT 3
69013: ARRAY
69014: PPUSH
69015: CALL_OW 117
// break ;
69019: GO 69023
// end ;
69021: GO 68505
69023: POP
69024: POP
// end ; end ;
69025: GO 67221
69027: POP
69028: POP
// end ;
69029: LD_VAR 0 1
69033: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69034: LD_INT 0
69036: PPUSH
69037: PPUSH
69038: PPUSH
69039: PPUSH
// if not mc_bases then
69040: LD_EXP 70
69044: NOT
69045: IFFALSE 69049
// exit ;
69047: GO 69210
// for i = 1 to mc_bases do
69049: LD_ADDR_VAR 0 2
69053: PUSH
69054: DOUBLE
69055: LD_INT 1
69057: DEC
69058: ST_TO_ADDR
69059: LD_EXP 70
69063: PUSH
69064: FOR_TO
69065: IFFALSE 69208
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69067: LD_ADDR_VAR 0 4
69071: PUSH
69072: LD_EXP 89
69076: PUSH
69077: LD_VAR 0 2
69081: ARRAY
69082: PUSH
69083: LD_EXP 92
69087: PUSH
69088: LD_VAR 0 2
69092: ARRAY
69093: UNION
69094: PPUSH
69095: LD_INT 33
69097: PUSH
69098: LD_INT 2
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PPUSH
69105: CALL_OW 72
69109: ST_TO_ADDR
// if tmp then
69110: LD_VAR 0 4
69114: IFFALSE 69206
// for j in tmp do
69116: LD_ADDR_VAR 0 3
69120: PUSH
69121: LD_VAR 0 4
69125: PUSH
69126: FOR_IN
69127: IFFALSE 69204
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69129: LD_VAR 0 3
69133: PPUSH
69134: CALL_OW 312
69138: NOT
69139: PUSH
69140: LD_VAR 0 3
69144: PPUSH
69145: CALL_OW 256
69149: PUSH
69150: LD_INT 250
69152: GREATEREQUAL
69153: AND
69154: IFFALSE 69167
// Connect ( j ) else
69156: LD_VAR 0 3
69160: PPUSH
69161: CALL 21568 0 1
69165: GO 69202
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69167: LD_VAR 0 3
69171: PPUSH
69172: CALL_OW 256
69176: PUSH
69177: LD_INT 250
69179: LESS
69180: PUSH
69181: LD_VAR 0 3
69185: PPUSH
69186: CALL_OW 312
69190: AND
69191: IFFALSE 69202
// ComUnlink ( j ) ;
69193: LD_VAR 0 3
69197: PPUSH
69198: CALL_OW 136
69202: GO 69126
69204: POP
69205: POP
// end ;
69206: GO 69064
69208: POP
69209: POP
// end ;
69210: LD_VAR 0 1
69214: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69215: LD_INT 0
69217: PPUSH
69218: PPUSH
69219: PPUSH
69220: PPUSH
69221: PPUSH
// if not mc_bases then
69222: LD_EXP 70
69226: NOT
69227: IFFALSE 69231
// exit ;
69229: GO 69676
// for i = 1 to mc_bases do
69231: LD_ADDR_VAR 0 2
69235: PUSH
69236: DOUBLE
69237: LD_INT 1
69239: DEC
69240: ST_TO_ADDR
69241: LD_EXP 70
69245: PUSH
69246: FOR_TO
69247: IFFALSE 69674
// begin if not mc_produce [ i ] then
69249: LD_EXP 91
69253: PUSH
69254: LD_VAR 0 2
69258: ARRAY
69259: NOT
69260: IFFALSE 69264
// continue ;
69262: GO 69246
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69264: LD_ADDR_VAR 0 5
69268: PUSH
69269: LD_EXP 70
69273: PUSH
69274: LD_VAR 0 2
69278: ARRAY
69279: PPUSH
69280: LD_INT 30
69282: PUSH
69283: LD_INT 3
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PPUSH
69290: CALL_OW 72
69294: ST_TO_ADDR
// if not fac then
69295: LD_VAR 0 5
69299: NOT
69300: IFFALSE 69304
// continue ;
69302: GO 69246
// for j in fac do
69304: LD_ADDR_VAR 0 3
69308: PUSH
69309: LD_VAR 0 5
69313: PUSH
69314: FOR_IN
69315: IFFALSE 69670
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69317: LD_VAR 0 3
69321: PPUSH
69322: CALL_OW 461
69326: PUSH
69327: LD_INT 2
69329: NONEQUAL
69330: PUSH
69331: LD_VAR 0 3
69335: PPUSH
69336: LD_INT 15
69338: PPUSH
69339: CALL 21196 0 2
69343: PUSH
69344: LD_INT 4
69346: ARRAY
69347: OR
69348: IFFALSE 69352
// continue ;
69350: GO 69314
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69352: LD_VAR 0 3
69356: PPUSH
69357: LD_EXP 91
69361: PUSH
69362: LD_VAR 0 2
69366: ARRAY
69367: PUSH
69368: LD_INT 1
69370: ARRAY
69371: PUSH
69372: LD_INT 1
69374: ARRAY
69375: PPUSH
69376: LD_EXP 91
69380: PUSH
69381: LD_VAR 0 2
69385: ARRAY
69386: PUSH
69387: LD_INT 1
69389: ARRAY
69390: PUSH
69391: LD_INT 2
69393: ARRAY
69394: PPUSH
69395: LD_EXP 91
69399: PUSH
69400: LD_VAR 0 2
69404: ARRAY
69405: PUSH
69406: LD_INT 1
69408: ARRAY
69409: PUSH
69410: LD_INT 3
69412: ARRAY
69413: PPUSH
69414: LD_EXP 91
69418: PUSH
69419: LD_VAR 0 2
69423: ARRAY
69424: PUSH
69425: LD_INT 1
69427: ARRAY
69428: PUSH
69429: LD_INT 4
69431: ARRAY
69432: PPUSH
69433: CALL_OW 448
69437: PUSH
69438: LD_VAR 0 3
69442: PPUSH
69443: LD_EXP 91
69447: PUSH
69448: LD_VAR 0 2
69452: ARRAY
69453: PUSH
69454: LD_INT 1
69456: ARRAY
69457: PUSH
69458: LD_INT 1
69460: ARRAY
69461: PUSH
69462: LD_EXP 91
69466: PUSH
69467: LD_VAR 0 2
69471: ARRAY
69472: PUSH
69473: LD_INT 1
69475: ARRAY
69476: PUSH
69477: LD_INT 2
69479: ARRAY
69480: PUSH
69481: LD_EXP 91
69485: PUSH
69486: LD_VAR 0 2
69490: ARRAY
69491: PUSH
69492: LD_INT 1
69494: ARRAY
69495: PUSH
69496: LD_INT 3
69498: ARRAY
69499: PUSH
69500: LD_EXP 91
69504: PUSH
69505: LD_VAR 0 2
69509: ARRAY
69510: PUSH
69511: LD_INT 1
69513: ARRAY
69514: PUSH
69515: LD_INT 4
69517: ARRAY
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: PPUSH
69525: CALL 24963 0 2
69529: AND
69530: IFFALSE 69668
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69532: LD_VAR 0 3
69536: PPUSH
69537: LD_EXP 91
69541: PUSH
69542: LD_VAR 0 2
69546: ARRAY
69547: PUSH
69548: LD_INT 1
69550: ARRAY
69551: PUSH
69552: LD_INT 1
69554: ARRAY
69555: PPUSH
69556: LD_EXP 91
69560: PUSH
69561: LD_VAR 0 2
69565: ARRAY
69566: PUSH
69567: LD_INT 1
69569: ARRAY
69570: PUSH
69571: LD_INT 2
69573: ARRAY
69574: PPUSH
69575: LD_EXP 91
69579: PUSH
69580: LD_VAR 0 2
69584: ARRAY
69585: PUSH
69586: LD_INT 1
69588: ARRAY
69589: PUSH
69590: LD_INT 3
69592: ARRAY
69593: PPUSH
69594: LD_EXP 91
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: PUSH
69605: LD_INT 1
69607: ARRAY
69608: PUSH
69609: LD_INT 4
69611: ARRAY
69612: PPUSH
69613: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69617: LD_ADDR_VAR 0 4
69621: PUSH
69622: LD_EXP 91
69626: PUSH
69627: LD_VAR 0 2
69631: ARRAY
69632: PPUSH
69633: LD_INT 1
69635: PPUSH
69636: CALL_OW 3
69640: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69641: LD_ADDR_EXP 91
69645: PUSH
69646: LD_EXP 91
69650: PPUSH
69651: LD_VAR 0 2
69655: PPUSH
69656: LD_VAR 0 4
69660: PPUSH
69661: CALL_OW 1
69665: ST_TO_ADDR
// break ;
69666: GO 69670
// end ; end ;
69668: GO 69314
69670: POP
69671: POP
// end ;
69672: GO 69246
69674: POP
69675: POP
// end ;
69676: LD_VAR 0 1
69680: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69681: LD_INT 0
69683: PPUSH
69684: PPUSH
69685: PPUSH
// if not mc_bases then
69686: LD_EXP 70
69690: NOT
69691: IFFALSE 69695
// exit ;
69693: GO 69784
// for i = 1 to mc_bases do
69695: LD_ADDR_VAR 0 2
69699: PUSH
69700: DOUBLE
69701: LD_INT 1
69703: DEC
69704: ST_TO_ADDR
69705: LD_EXP 70
69709: PUSH
69710: FOR_TO
69711: IFFALSE 69782
// begin if mc_attack [ i ] then
69713: LD_EXP 90
69717: PUSH
69718: LD_VAR 0 2
69722: ARRAY
69723: IFFALSE 69780
// begin tmp := mc_attack [ i ] [ 1 ] ;
69725: LD_ADDR_VAR 0 3
69729: PUSH
69730: LD_EXP 90
69734: PUSH
69735: LD_VAR 0 2
69739: ARRAY
69740: PUSH
69741: LD_INT 1
69743: ARRAY
69744: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69745: LD_ADDR_EXP 90
69749: PUSH
69750: LD_EXP 90
69754: PPUSH
69755: LD_VAR 0 2
69759: PPUSH
69760: EMPTY
69761: PPUSH
69762: CALL_OW 1
69766: ST_TO_ADDR
// Attack ( tmp ) ;
69767: LD_VAR 0 3
69771: PPUSH
69772: CALL 103526 0 1
// exit ;
69776: POP
69777: POP
69778: GO 69784
// end ; end ;
69780: GO 69710
69782: POP
69783: POP
// end ;
69784: LD_VAR 0 1
69788: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69789: LD_INT 0
69791: PPUSH
69792: PPUSH
69793: PPUSH
69794: PPUSH
69795: PPUSH
69796: PPUSH
69797: PPUSH
// if not mc_bases then
69798: LD_EXP 70
69802: NOT
69803: IFFALSE 69807
// exit ;
69805: GO 70664
// for i = 1 to mc_bases do
69807: LD_ADDR_VAR 0 2
69811: PUSH
69812: DOUBLE
69813: LD_INT 1
69815: DEC
69816: ST_TO_ADDR
69817: LD_EXP 70
69821: PUSH
69822: FOR_TO
69823: IFFALSE 70662
// begin if not mc_bases [ i ] then
69825: LD_EXP 70
69829: PUSH
69830: LD_VAR 0 2
69834: ARRAY
69835: NOT
69836: IFFALSE 69840
// continue ;
69838: GO 69822
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69840: LD_ADDR_VAR 0 7
69844: PUSH
69845: LD_EXP 70
69849: PUSH
69850: LD_VAR 0 2
69854: ARRAY
69855: PUSH
69856: LD_INT 1
69858: ARRAY
69859: PPUSH
69860: CALL 15397 0 1
69864: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69865: LD_ADDR_EXP 93
69869: PUSH
69870: LD_EXP 93
69874: PPUSH
69875: LD_VAR 0 2
69879: PPUSH
69880: LD_EXP 70
69884: PUSH
69885: LD_VAR 0 2
69889: ARRAY
69890: PUSH
69891: LD_INT 1
69893: ARRAY
69894: PPUSH
69895: CALL_OW 255
69899: PPUSH
69900: LD_EXP 95
69904: PUSH
69905: LD_VAR 0 2
69909: ARRAY
69910: PPUSH
69911: CALL 15362 0 2
69915: PPUSH
69916: CALL_OW 1
69920: ST_TO_ADDR
// if not mc_scan [ i ] then
69921: LD_EXP 93
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: NOT
69932: IFFALSE 70110
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69934: LD_ADDR_EXP 113
69938: PUSH
69939: LD_EXP 113
69943: PPUSH
69944: LD_VAR 0 2
69948: PPUSH
69949: LD_INT 0
69951: PPUSH
69952: CALL_OW 1
69956: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69957: LD_ADDR_VAR 0 4
69961: PUSH
69962: LD_EXP 70
69966: PUSH
69967: LD_VAR 0 2
69971: ARRAY
69972: PPUSH
69973: LD_INT 2
69975: PUSH
69976: LD_INT 25
69978: PUSH
69979: LD_INT 5
69981: PUSH
69982: EMPTY
69983: LIST
69984: LIST
69985: PUSH
69986: LD_INT 25
69988: PUSH
69989: LD_INT 8
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 25
69998: PUSH
69999: LD_INT 9
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: PPUSH
70012: CALL_OW 72
70016: ST_TO_ADDR
// if not tmp then
70017: LD_VAR 0 4
70021: NOT
70022: IFFALSE 70026
// continue ;
70024: GO 69822
// for j in tmp do
70026: LD_ADDR_VAR 0 3
70030: PUSH
70031: LD_VAR 0 4
70035: PUSH
70036: FOR_IN
70037: IFFALSE 70108
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70039: LD_VAR 0 3
70043: PPUSH
70044: CALL_OW 310
70048: PPUSH
70049: CALL_OW 266
70053: PUSH
70054: LD_INT 5
70056: EQUAL
70057: PUSH
70058: LD_VAR 0 3
70062: PPUSH
70063: CALL_OW 257
70067: PUSH
70068: LD_INT 1
70070: EQUAL
70071: AND
70072: PUSH
70073: LD_VAR 0 3
70077: PPUSH
70078: CALL_OW 459
70082: NOT
70083: AND
70084: PUSH
70085: LD_VAR 0 7
70089: AND
70090: IFFALSE 70106
// ComChangeProfession ( j , class ) ;
70092: LD_VAR 0 3
70096: PPUSH
70097: LD_VAR 0 7
70101: PPUSH
70102: CALL_OW 123
70106: GO 70036
70108: POP
70109: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
70110: LD_EXP 93
70114: PUSH
70115: LD_VAR 0 2
70119: ARRAY
70120: PUSH
70121: LD_EXP 113
70125: PUSH
70126: LD_VAR 0 2
70130: ARRAY
70131: NOT
70132: AND
70133: PUSH
70134: LD_EXP 92
70138: PUSH
70139: LD_VAR 0 2
70143: ARRAY
70144: NOT
70145: AND
70146: PUSH
70147: LD_EXP 70
70151: PUSH
70152: LD_VAR 0 2
70156: ARRAY
70157: PPUSH
70158: LD_INT 50
70160: PUSH
70161: EMPTY
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: PUSH
70167: LD_INT 30
70169: PUSH
70170: LD_INT 32
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 30
70179: PUSH
70180: LD_INT 33
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 30
70189: PUSH
70190: LD_INT 4
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 30
70199: PUSH
70200: LD_INT 5
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PPUSH
70218: CALL_OW 72
70222: PUSH
70223: LD_INT 4
70225: LESS
70226: PUSH
70227: LD_EXP 70
70231: PUSH
70232: LD_VAR 0 2
70236: ARRAY
70237: PPUSH
70238: LD_INT 3
70240: PUSH
70241: LD_INT 24
70243: PUSH
70244: LD_INT 1000
70246: PUSH
70247: EMPTY
70248: LIST
70249: LIST
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 30
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 1
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: LIST
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PPUSH
70287: CALL_OW 72
70291: OR
70292: AND
70293: IFFALSE 70544
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70295: LD_ADDR_EXP 113
70299: PUSH
70300: LD_EXP 113
70304: PPUSH
70305: LD_VAR 0 2
70309: PPUSH
70310: LD_INT 1
70312: PPUSH
70313: CALL_OW 1
70317: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70318: LD_ADDR_VAR 0 4
70322: PUSH
70323: LD_EXP 70
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PPUSH
70334: LD_INT 2
70336: PUSH
70337: LD_INT 25
70339: PUSH
70340: LD_INT 1
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 25
70349: PUSH
70350: LD_INT 5
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 25
70359: PUSH
70360: LD_INT 8
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 25
70369: PUSH
70370: LD_INT 9
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: PPUSH
70384: CALL_OW 72
70388: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70389: LD_ADDR_VAR 0 4
70393: PUSH
70394: LD_VAR 0 4
70398: PUSH
70399: LD_VAR 0 4
70403: PPUSH
70404: LD_INT 18
70406: PPUSH
70407: CALL 47866 0 2
70411: DIFF
70412: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70413: LD_VAR 0 4
70417: NOT
70418: PUSH
70419: LD_EXP 70
70423: PUSH
70424: LD_VAR 0 2
70428: ARRAY
70429: PPUSH
70430: LD_INT 2
70432: PUSH
70433: LD_INT 30
70435: PUSH
70436: LD_INT 4
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 30
70445: PUSH
70446: LD_INT 5
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: LIST
70457: PPUSH
70458: CALL_OW 72
70462: NOT
70463: AND
70464: IFFALSE 70526
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70466: LD_ADDR_VAR 0 4
70470: PUSH
70471: LD_EXP 70
70475: PUSH
70476: LD_VAR 0 2
70480: ARRAY
70481: PPUSH
70482: LD_INT 2
70484: PUSH
70485: LD_INT 25
70487: PUSH
70488: LD_INT 2
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 25
70497: PUSH
70498: LD_INT 3
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 25
70507: PUSH
70508: LD_INT 4
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: EMPTY
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: PPUSH
70521: CALL_OW 72
70525: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70526: LD_VAR 0 2
70530: PPUSH
70531: LD_VAR 0 4
70535: PPUSH
70536: CALL 108235 0 2
// exit ;
70540: POP
70541: POP
70542: GO 70664
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70544: LD_EXP 93
70548: PUSH
70549: LD_VAR 0 2
70553: ARRAY
70554: PUSH
70555: LD_EXP 113
70559: PUSH
70560: LD_VAR 0 2
70564: ARRAY
70565: NOT
70566: AND
70567: PUSH
70568: LD_EXP 92
70572: PUSH
70573: LD_VAR 0 2
70577: ARRAY
70578: AND
70579: IFFALSE 70660
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70581: LD_ADDR_EXP 113
70585: PUSH
70586: LD_EXP 113
70590: PPUSH
70591: LD_VAR 0 2
70595: PPUSH
70596: LD_INT 1
70598: PPUSH
70599: CALL_OW 1
70603: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70604: LD_ADDR_VAR 0 4
70608: PUSH
70609: LD_EXP 92
70613: PUSH
70614: LD_VAR 0 2
70618: ARRAY
70619: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70620: LD_ADDR_EXP 92
70624: PUSH
70625: LD_EXP 92
70629: PPUSH
70630: LD_VAR 0 2
70634: PPUSH
70635: EMPTY
70636: PPUSH
70637: CALL_OW 1
70641: ST_TO_ADDR
// Defend ( i , tmp ) ;
70642: LD_VAR 0 2
70646: PPUSH
70647: LD_VAR 0 4
70651: PPUSH
70652: CALL 108831 0 2
// exit ;
70656: POP
70657: POP
70658: GO 70664
// end ; end ;
70660: GO 69822
70662: POP
70663: POP
// end ;
70664: LD_VAR 0 1
70668: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70669: LD_INT 0
70671: PPUSH
70672: PPUSH
70673: PPUSH
70674: PPUSH
70675: PPUSH
70676: PPUSH
70677: PPUSH
70678: PPUSH
70679: PPUSH
70680: PPUSH
70681: PPUSH
// if not mc_bases then
70682: LD_EXP 70
70686: NOT
70687: IFFALSE 70691
// exit ;
70689: GO 71778
// for i = 1 to mc_bases do
70691: LD_ADDR_VAR 0 2
70695: PUSH
70696: DOUBLE
70697: LD_INT 1
70699: DEC
70700: ST_TO_ADDR
70701: LD_EXP 70
70705: PUSH
70706: FOR_TO
70707: IFFALSE 71776
// begin tmp := mc_lab [ i ] ;
70709: LD_ADDR_VAR 0 6
70713: PUSH
70714: LD_EXP 103
70718: PUSH
70719: LD_VAR 0 2
70723: ARRAY
70724: ST_TO_ADDR
// if not tmp then
70725: LD_VAR 0 6
70729: NOT
70730: IFFALSE 70734
// continue ;
70732: GO 70706
// idle_lab := 0 ;
70734: LD_ADDR_VAR 0 11
70738: PUSH
70739: LD_INT 0
70741: ST_TO_ADDR
// for j in tmp do
70742: LD_ADDR_VAR 0 3
70746: PUSH
70747: LD_VAR 0 6
70751: PUSH
70752: FOR_IN
70753: IFFALSE 71772
// begin researching := false ;
70755: LD_ADDR_VAR 0 10
70759: PUSH
70760: LD_INT 0
70762: ST_TO_ADDR
// side := GetSide ( j ) ;
70763: LD_ADDR_VAR 0 4
70767: PUSH
70768: LD_VAR 0 3
70772: PPUSH
70773: CALL_OW 255
70777: ST_TO_ADDR
// if not mc_tech [ side ] then
70778: LD_EXP 97
70782: PUSH
70783: LD_VAR 0 4
70787: ARRAY
70788: NOT
70789: IFFALSE 70793
// continue ;
70791: GO 70752
// if BuildingStatus ( j ) = bs_idle then
70793: LD_VAR 0 3
70797: PPUSH
70798: CALL_OW 461
70802: PUSH
70803: LD_INT 2
70805: EQUAL
70806: IFFALSE 70994
// begin if idle_lab and UnitsInside ( j ) < 6 then
70808: LD_VAR 0 11
70812: PUSH
70813: LD_VAR 0 3
70817: PPUSH
70818: CALL_OW 313
70822: PUSH
70823: LD_INT 6
70825: LESS
70826: AND
70827: IFFALSE 70898
// begin tmp2 := UnitsInside ( idle_lab ) ;
70829: LD_ADDR_VAR 0 9
70833: PUSH
70834: LD_VAR 0 11
70838: PPUSH
70839: CALL_OW 313
70843: ST_TO_ADDR
// if tmp2 then
70844: LD_VAR 0 9
70848: IFFALSE 70890
// for x in tmp2 do
70850: LD_ADDR_VAR 0 7
70854: PUSH
70855: LD_VAR 0 9
70859: PUSH
70860: FOR_IN
70861: IFFALSE 70888
// begin ComExitBuilding ( x ) ;
70863: LD_VAR 0 7
70867: PPUSH
70868: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70872: LD_VAR 0 7
70876: PPUSH
70877: LD_VAR 0 3
70881: PPUSH
70882: CALL_OW 180
// end ;
70886: GO 70860
70888: POP
70889: POP
// idle_lab := 0 ;
70890: LD_ADDR_VAR 0 11
70894: PUSH
70895: LD_INT 0
70897: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70898: LD_ADDR_VAR 0 5
70902: PUSH
70903: LD_EXP 97
70907: PUSH
70908: LD_VAR 0 4
70912: ARRAY
70913: PUSH
70914: FOR_IN
70915: IFFALSE 70975
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70917: LD_VAR 0 3
70921: PPUSH
70922: LD_VAR 0 5
70926: PPUSH
70927: CALL_OW 430
70931: PUSH
70932: LD_VAR 0 4
70936: PPUSH
70937: LD_VAR 0 5
70941: PPUSH
70942: CALL 14467 0 2
70946: AND
70947: IFFALSE 70973
// begin researching := true ;
70949: LD_ADDR_VAR 0 10
70953: PUSH
70954: LD_INT 1
70956: ST_TO_ADDR
// ComResearch ( j , t ) ;
70957: LD_VAR 0 3
70961: PPUSH
70962: LD_VAR 0 5
70966: PPUSH
70967: CALL_OW 124
// break ;
70971: GO 70975
// end ;
70973: GO 70914
70975: POP
70976: POP
// if not researching then
70977: LD_VAR 0 10
70981: NOT
70982: IFFALSE 70994
// idle_lab := j ;
70984: LD_ADDR_VAR 0 11
70988: PUSH
70989: LD_VAR 0 3
70993: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70994: LD_VAR 0 3
70998: PPUSH
70999: CALL_OW 461
71003: PUSH
71004: LD_INT 10
71006: EQUAL
71007: IFFALSE 71595
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71009: LD_EXP 99
71013: PUSH
71014: LD_VAR 0 2
71018: ARRAY
71019: NOT
71020: PUSH
71021: LD_EXP 100
71025: PUSH
71026: LD_VAR 0 2
71030: ARRAY
71031: NOT
71032: AND
71033: PUSH
71034: LD_EXP 97
71038: PUSH
71039: LD_VAR 0 4
71043: ARRAY
71044: PUSH
71045: LD_INT 1
71047: GREATER
71048: AND
71049: IFFALSE 71180
// begin ComCancel ( j ) ;
71051: LD_VAR 0 3
71055: PPUSH
71056: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71060: LD_ADDR_EXP 97
71064: PUSH
71065: LD_EXP 97
71069: PPUSH
71070: LD_VAR 0 4
71074: PPUSH
71075: LD_EXP 97
71079: PUSH
71080: LD_VAR 0 4
71084: ARRAY
71085: PPUSH
71086: LD_EXP 97
71090: PUSH
71091: LD_VAR 0 4
71095: ARRAY
71096: PUSH
71097: LD_INT 1
71099: MINUS
71100: PPUSH
71101: LD_EXP 97
71105: PUSH
71106: LD_VAR 0 4
71110: ARRAY
71111: PPUSH
71112: LD_INT 0
71114: PPUSH
71115: CALL 18015 0 4
71119: PPUSH
71120: CALL_OW 1
71124: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71125: LD_ADDR_EXP 97
71129: PUSH
71130: LD_EXP 97
71134: PPUSH
71135: LD_VAR 0 4
71139: PPUSH
71140: LD_EXP 97
71144: PUSH
71145: LD_VAR 0 4
71149: ARRAY
71150: PPUSH
71151: LD_EXP 97
71155: PUSH
71156: LD_VAR 0 4
71160: ARRAY
71161: PPUSH
71162: LD_INT 1
71164: PPUSH
71165: LD_INT 0
71167: PPUSH
71168: CALL 18015 0 4
71172: PPUSH
71173: CALL_OW 1
71177: ST_TO_ADDR
// continue ;
71178: GO 70752
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71180: LD_EXP 99
71184: PUSH
71185: LD_VAR 0 2
71189: ARRAY
71190: PUSH
71191: LD_EXP 100
71195: PUSH
71196: LD_VAR 0 2
71200: ARRAY
71201: NOT
71202: AND
71203: IFFALSE 71330
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71205: LD_ADDR_EXP 100
71209: PUSH
71210: LD_EXP 100
71214: PPUSH
71215: LD_VAR 0 2
71219: PUSH
71220: LD_EXP 100
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: PUSH
71231: LD_INT 1
71233: PLUS
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PPUSH
71239: LD_EXP 99
71243: PUSH
71244: LD_VAR 0 2
71248: ARRAY
71249: PUSH
71250: LD_INT 1
71252: ARRAY
71253: PPUSH
71254: CALL 18597 0 3
71258: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71259: LD_EXP 99
71263: PUSH
71264: LD_VAR 0 2
71268: ARRAY
71269: PUSH
71270: LD_INT 1
71272: ARRAY
71273: PPUSH
71274: LD_INT 112
71276: PPUSH
71277: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71281: LD_ADDR_VAR 0 9
71285: PUSH
71286: LD_EXP 99
71290: PUSH
71291: LD_VAR 0 2
71295: ARRAY
71296: PPUSH
71297: LD_INT 1
71299: PPUSH
71300: CALL_OW 3
71304: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71305: LD_ADDR_EXP 99
71309: PUSH
71310: LD_EXP 99
71314: PPUSH
71315: LD_VAR 0 2
71319: PPUSH
71320: LD_VAR 0 9
71324: PPUSH
71325: CALL_OW 1
71329: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71330: LD_EXP 99
71334: PUSH
71335: LD_VAR 0 2
71339: ARRAY
71340: PUSH
71341: LD_EXP 100
71345: PUSH
71346: LD_VAR 0 2
71350: ARRAY
71351: AND
71352: PUSH
71353: LD_EXP 100
71357: PUSH
71358: LD_VAR 0 2
71362: ARRAY
71363: PUSH
71364: LD_INT 1
71366: ARRAY
71367: PPUSH
71368: CALL_OW 310
71372: NOT
71373: AND
71374: PUSH
71375: LD_VAR 0 3
71379: PPUSH
71380: CALL_OW 313
71384: PUSH
71385: LD_INT 6
71387: EQUAL
71388: AND
71389: IFFALSE 71445
// begin tmp2 := UnitsInside ( j ) ;
71391: LD_ADDR_VAR 0 9
71395: PUSH
71396: LD_VAR 0 3
71400: PPUSH
71401: CALL_OW 313
71405: ST_TO_ADDR
// if tmp2 = 6 then
71406: LD_VAR 0 9
71410: PUSH
71411: LD_INT 6
71413: EQUAL
71414: IFFALSE 71445
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71416: LD_VAR 0 9
71420: PUSH
71421: LD_INT 1
71423: ARRAY
71424: PPUSH
71425: LD_INT 112
71427: PPUSH
71428: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71432: LD_VAR 0 9
71436: PUSH
71437: LD_INT 1
71439: ARRAY
71440: PPUSH
71441: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71445: LD_EXP 100
71449: PUSH
71450: LD_VAR 0 2
71454: ARRAY
71455: PUSH
71456: LD_EXP 100
71460: PUSH
71461: LD_VAR 0 2
71465: ARRAY
71466: PUSH
71467: LD_INT 1
71469: ARRAY
71470: PPUSH
71471: CALL_OW 314
71475: NOT
71476: AND
71477: PUSH
71478: LD_EXP 100
71482: PUSH
71483: LD_VAR 0 2
71487: ARRAY
71488: PUSH
71489: LD_INT 1
71491: ARRAY
71492: PPUSH
71493: CALL_OW 310
71497: NOT
71498: AND
71499: IFFALSE 71525
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71501: LD_EXP 100
71505: PUSH
71506: LD_VAR 0 2
71510: ARRAY
71511: PUSH
71512: LD_INT 1
71514: ARRAY
71515: PPUSH
71516: LD_VAR 0 3
71520: PPUSH
71521: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71525: LD_EXP 100
71529: PUSH
71530: LD_VAR 0 2
71534: ARRAY
71535: PUSH
71536: LD_INT 1
71538: ARRAY
71539: PPUSH
71540: CALL_OW 310
71544: PUSH
71545: LD_EXP 100
71549: PUSH
71550: LD_VAR 0 2
71554: ARRAY
71555: PUSH
71556: LD_INT 1
71558: ARRAY
71559: PPUSH
71560: CALL_OW 310
71564: PPUSH
71565: CALL_OW 461
71569: PUSH
71570: LD_INT 3
71572: NONEQUAL
71573: AND
71574: IFFALSE 71595
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71576: LD_EXP 100
71580: PUSH
71581: LD_VAR 0 2
71585: ARRAY
71586: PUSH
71587: LD_INT 1
71589: ARRAY
71590: PPUSH
71591: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71595: LD_VAR 0 3
71599: PPUSH
71600: CALL_OW 461
71604: PUSH
71605: LD_INT 6
71607: EQUAL
71608: PUSH
71609: LD_VAR 0 6
71613: PUSH
71614: LD_INT 1
71616: GREATER
71617: AND
71618: IFFALSE 71770
// begin sci := [ ] ;
71620: LD_ADDR_VAR 0 8
71624: PUSH
71625: EMPTY
71626: ST_TO_ADDR
// for x in ( tmp diff j ) do
71627: LD_ADDR_VAR 0 7
71631: PUSH
71632: LD_VAR 0 6
71636: PUSH
71637: LD_VAR 0 3
71641: DIFF
71642: PUSH
71643: FOR_IN
71644: IFFALSE 71696
// begin if sci = 6 then
71646: LD_VAR 0 8
71650: PUSH
71651: LD_INT 6
71653: EQUAL
71654: IFFALSE 71658
// break ;
71656: GO 71696
// if BuildingStatus ( x ) = bs_idle then
71658: LD_VAR 0 7
71662: PPUSH
71663: CALL_OW 461
71667: PUSH
71668: LD_INT 2
71670: EQUAL
71671: IFFALSE 71694
// sci := sci ^ UnitsInside ( x ) ;
71673: LD_ADDR_VAR 0 8
71677: PUSH
71678: LD_VAR 0 8
71682: PUSH
71683: LD_VAR 0 7
71687: PPUSH
71688: CALL_OW 313
71692: ADD
71693: ST_TO_ADDR
// end ;
71694: GO 71643
71696: POP
71697: POP
// if not sci then
71698: LD_VAR 0 8
71702: NOT
71703: IFFALSE 71707
// continue ;
71705: GO 70752
// for x in sci do
71707: LD_ADDR_VAR 0 7
71711: PUSH
71712: LD_VAR 0 8
71716: PUSH
71717: FOR_IN
71718: IFFALSE 71768
// if IsInUnit ( x ) and not HasTask ( x ) then
71720: LD_VAR 0 7
71724: PPUSH
71725: CALL_OW 310
71729: PUSH
71730: LD_VAR 0 7
71734: PPUSH
71735: CALL_OW 314
71739: NOT
71740: AND
71741: IFFALSE 71766
// begin ComExitBuilding ( x ) ;
71743: LD_VAR 0 7
71747: PPUSH
71748: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71752: LD_VAR 0 7
71756: PPUSH
71757: LD_VAR 0 3
71761: PPUSH
71762: CALL_OW 180
// end ;
71766: GO 71717
71768: POP
71769: POP
// end ; end ;
71770: GO 70752
71772: POP
71773: POP
// end ;
71774: GO 70706
71776: POP
71777: POP
// end ;
71778: LD_VAR 0 1
71782: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71783: LD_INT 0
71785: PPUSH
71786: PPUSH
// if not mc_bases then
71787: LD_EXP 70
71791: NOT
71792: IFFALSE 71796
// exit ;
71794: GO 71877
// for i = 1 to mc_bases do
71796: LD_ADDR_VAR 0 2
71800: PUSH
71801: DOUBLE
71802: LD_INT 1
71804: DEC
71805: ST_TO_ADDR
71806: LD_EXP 70
71810: PUSH
71811: FOR_TO
71812: IFFALSE 71875
// if mc_mines [ i ] and mc_miners [ i ] then
71814: LD_EXP 83
71818: PUSH
71819: LD_VAR 0 2
71823: ARRAY
71824: PUSH
71825: LD_EXP 84
71829: PUSH
71830: LD_VAR 0 2
71834: ARRAY
71835: AND
71836: IFFALSE 71873
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71838: LD_EXP 84
71842: PUSH
71843: LD_VAR 0 2
71847: ARRAY
71848: PUSH
71849: LD_INT 1
71851: ARRAY
71852: PPUSH
71853: CALL_OW 255
71857: PPUSH
71858: LD_EXP 83
71862: PUSH
71863: LD_VAR 0 2
71867: ARRAY
71868: PPUSH
71869: CALL 15550 0 2
71873: GO 71811
71875: POP
71876: POP
// end ;
71877: LD_VAR 0 1
71881: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71882: LD_INT 0
71884: PPUSH
71885: PPUSH
71886: PPUSH
71887: PPUSH
71888: PPUSH
71889: PPUSH
71890: PPUSH
71891: PPUSH
// if not mc_bases or not mc_parking then
71892: LD_EXP 70
71896: NOT
71897: PUSH
71898: LD_EXP 94
71902: NOT
71903: OR
71904: IFFALSE 71908
// exit ;
71906: GO 72618
// for i = 1 to mc_bases do
71908: LD_ADDR_VAR 0 2
71912: PUSH
71913: DOUBLE
71914: LD_INT 1
71916: DEC
71917: ST_TO_ADDR
71918: LD_EXP 70
71922: PUSH
71923: FOR_TO
71924: IFFALSE 72616
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71926: LD_EXP 70
71930: PUSH
71931: LD_VAR 0 2
71935: ARRAY
71936: NOT
71937: PUSH
71938: LD_EXP 94
71942: PUSH
71943: LD_VAR 0 2
71947: ARRAY
71948: NOT
71949: OR
71950: IFFALSE 71954
// continue ;
71952: GO 71923
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71954: LD_ADDR_VAR 0 5
71958: PUSH
71959: LD_EXP 70
71963: PUSH
71964: LD_VAR 0 2
71968: ARRAY
71969: PUSH
71970: LD_INT 1
71972: ARRAY
71973: PPUSH
71974: CALL_OW 255
71978: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71979: LD_ADDR_VAR 0 6
71983: PUSH
71984: LD_EXP 70
71988: PUSH
71989: LD_VAR 0 2
71993: ARRAY
71994: PPUSH
71995: LD_INT 30
71997: PUSH
71998: LD_INT 3
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PPUSH
72005: CALL_OW 72
72009: ST_TO_ADDR
// if not fac then
72010: LD_VAR 0 6
72014: NOT
72015: IFFALSE 72066
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72017: LD_ADDR_VAR 0 6
72021: PUSH
72022: LD_EXP 70
72026: PUSH
72027: LD_VAR 0 2
72031: ARRAY
72032: PPUSH
72033: LD_INT 2
72035: PUSH
72036: LD_INT 30
72038: PUSH
72039: LD_INT 0
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 30
72048: PUSH
72049: LD_INT 1
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: EMPTY
72057: LIST
72058: LIST
72059: LIST
72060: PPUSH
72061: CALL_OW 72
72065: ST_TO_ADDR
// if not fac then
72066: LD_VAR 0 6
72070: NOT
72071: IFFALSE 72075
// continue ;
72073: GO 71923
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72075: LD_ADDR_VAR 0 7
72079: PUSH
72080: LD_EXP 94
72084: PUSH
72085: LD_VAR 0 2
72089: ARRAY
72090: PPUSH
72091: LD_INT 22
72093: PUSH
72094: LD_VAR 0 5
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 21
72105: PUSH
72106: LD_INT 2
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: PUSH
72113: LD_INT 3
72115: PUSH
72116: LD_INT 24
72118: PUSH
72119: LD_INT 1000
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: LIST
72134: PPUSH
72135: CALL_OW 70
72139: ST_TO_ADDR
// for j in fac do
72140: LD_ADDR_VAR 0 3
72144: PUSH
72145: LD_VAR 0 6
72149: PUSH
72150: FOR_IN
72151: IFFALSE 72232
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72153: LD_ADDR_VAR 0 7
72157: PUSH
72158: LD_VAR 0 7
72162: PUSH
72163: LD_INT 22
72165: PUSH
72166: LD_VAR 0 5
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 91
72177: PUSH
72178: LD_VAR 0 3
72182: PUSH
72183: LD_INT 15
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 21
72193: PUSH
72194: LD_INT 2
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PUSH
72201: LD_INT 3
72203: PUSH
72204: LD_INT 24
72206: PUSH
72207: LD_INT 1000
72209: PUSH
72210: EMPTY
72211: LIST
72212: LIST
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: LIST
72222: LIST
72223: PPUSH
72224: CALL_OW 69
72228: UNION
72229: ST_TO_ADDR
72230: GO 72150
72232: POP
72233: POP
// if not vehs then
72234: LD_VAR 0 7
72238: NOT
72239: IFFALSE 72265
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72241: LD_ADDR_EXP 82
72245: PUSH
72246: LD_EXP 82
72250: PPUSH
72251: LD_VAR 0 2
72255: PPUSH
72256: EMPTY
72257: PPUSH
72258: CALL_OW 1
72262: ST_TO_ADDR
// continue ;
72263: GO 71923
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72265: LD_ADDR_VAR 0 8
72269: PUSH
72270: LD_EXP 70
72274: PUSH
72275: LD_VAR 0 2
72279: ARRAY
72280: PPUSH
72281: LD_INT 30
72283: PUSH
72284: LD_INT 3
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PPUSH
72291: CALL_OW 72
72295: ST_TO_ADDR
// if tmp then
72296: LD_VAR 0 8
72300: IFFALSE 72403
// begin for j in tmp do
72302: LD_ADDR_VAR 0 3
72306: PUSH
72307: LD_VAR 0 8
72311: PUSH
72312: FOR_IN
72313: IFFALSE 72401
// for k in UnitsInside ( j ) do
72315: LD_ADDR_VAR 0 4
72319: PUSH
72320: LD_VAR 0 3
72324: PPUSH
72325: CALL_OW 313
72329: PUSH
72330: FOR_IN
72331: IFFALSE 72397
// if k then
72333: LD_VAR 0 4
72337: IFFALSE 72395
// if not k in mc_repair_vehicle [ i ] then
72339: LD_VAR 0 4
72343: PUSH
72344: LD_EXP 82
72348: PUSH
72349: LD_VAR 0 2
72353: ARRAY
72354: IN
72355: NOT
72356: IFFALSE 72395
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72358: LD_ADDR_EXP 82
72362: PUSH
72363: LD_EXP 82
72367: PPUSH
72368: LD_VAR 0 2
72372: PPUSH
72373: LD_EXP 82
72377: PUSH
72378: LD_VAR 0 2
72382: ARRAY
72383: PUSH
72384: LD_VAR 0 4
72388: UNION
72389: PPUSH
72390: CALL_OW 1
72394: ST_TO_ADDR
72395: GO 72330
72397: POP
72398: POP
72399: GO 72312
72401: POP
72402: POP
// end ; if not mc_repair_vehicle [ i ] then
72403: LD_EXP 82
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: NOT
72414: IFFALSE 72418
// continue ;
72416: GO 71923
// for j in mc_repair_vehicle [ i ] do
72418: LD_ADDR_VAR 0 3
72422: PUSH
72423: LD_EXP 82
72427: PUSH
72428: LD_VAR 0 2
72432: ARRAY
72433: PUSH
72434: FOR_IN
72435: IFFALSE 72612
// begin if GetClass ( j ) <> 3 then
72437: LD_VAR 0 3
72441: PPUSH
72442: CALL_OW 257
72446: PUSH
72447: LD_INT 3
72449: NONEQUAL
72450: IFFALSE 72491
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72452: LD_ADDR_EXP 82
72456: PUSH
72457: LD_EXP 82
72461: PPUSH
72462: LD_VAR 0 2
72466: PPUSH
72467: LD_EXP 82
72471: PUSH
72472: LD_VAR 0 2
72476: ARRAY
72477: PUSH
72478: LD_VAR 0 3
72482: DIFF
72483: PPUSH
72484: CALL_OW 1
72488: ST_TO_ADDR
// continue ;
72489: GO 72434
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72491: LD_VAR 0 3
72495: PPUSH
72496: CALL_OW 311
72500: NOT
72501: PUSH
72502: LD_VAR 0 3
72506: PUSH
72507: LD_EXP 73
72511: PUSH
72512: LD_VAR 0 2
72516: ARRAY
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: IN
72522: NOT
72523: AND
72524: PUSH
72525: LD_VAR 0 3
72529: PUSH
72530: LD_EXP 73
72534: PUSH
72535: LD_VAR 0 2
72539: ARRAY
72540: PUSH
72541: LD_INT 2
72543: ARRAY
72544: IN
72545: NOT
72546: AND
72547: IFFALSE 72610
// begin if IsInUnit ( j ) then
72549: LD_VAR 0 3
72553: PPUSH
72554: CALL_OW 310
72558: IFFALSE 72571
// ComExitBuilding ( j ) else
72560: LD_VAR 0 3
72564: PPUSH
72565: CALL_OW 122
72569: GO 72610
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72571: LD_VAR 0 3
72575: PPUSH
72576: LD_VAR 0 7
72580: PUSH
72581: LD_INT 1
72583: ARRAY
72584: PPUSH
72585: CALL 52349 0 2
72589: NOT
72590: IFFALSE 72610
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72592: LD_VAR 0 3
72596: PPUSH
72597: LD_VAR 0 7
72601: PUSH
72602: LD_INT 1
72604: ARRAY
72605: PPUSH
72606: CALL_OW 129
// end ; end ;
72610: GO 72434
72612: POP
72613: POP
// end ;
72614: GO 71923
72616: POP
72617: POP
// end ;
72618: LD_VAR 0 1
72622: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72623: LD_INT 0
72625: PPUSH
72626: PPUSH
72627: PPUSH
72628: PPUSH
72629: PPUSH
72630: PPUSH
72631: PPUSH
72632: PPUSH
72633: PPUSH
72634: PPUSH
72635: PPUSH
// if not mc_bases then
72636: LD_EXP 70
72640: NOT
72641: IFFALSE 72645
// exit ;
72643: GO 73447
// for i = 1 to mc_bases do
72645: LD_ADDR_VAR 0 2
72649: PUSH
72650: DOUBLE
72651: LD_INT 1
72653: DEC
72654: ST_TO_ADDR
72655: LD_EXP 70
72659: PUSH
72660: FOR_TO
72661: IFFALSE 73445
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72663: LD_EXP 98
72667: PUSH
72668: LD_VAR 0 2
72672: ARRAY
72673: NOT
72674: PUSH
72675: LD_EXP 73
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: PUSH
72686: LD_INT 1
72688: ARRAY
72689: OR
72690: PUSH
72691: LD_EXP 73
72695: PUSH
72696: LD_VAR 0 2
72700: ARRAY
72701: PUSH
72702: LD_INT 2
72704: ARRAY
72705: OR
72706: PUSH
72707: LD_EXP 96
72711: PUSH
72712: LD_VAR 0 2
72716: ARRAY
72717: PPUSH
72718: LD_INT 1
72720: PPUSH
72721: CALL_OW 325
72725: NOT
72726: OR
72727: PUSH
72728: LD_EXP 93
72732: PUSH
72733: LD_VAR 0 2
72737: ARRAY
72738: OR
72739: IFFALSE 72743
// continue ;
72741: GO 72660
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72743: LD_ADDR_VAR 0 8
72747: PUSH
72748: LD_EXP 70
72752: PUSH
72753: LD_VAR 0 2
72757: ARRAY
72758: PPUSH
72759: LD_INT 25
72761: PUSH
72762: LD_INT 4
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 50
72771: PUSH
72772: EMPTY
72773: LIST
72774: PUSH
72775: LD_INT 3
72777: PUSH
72778: LD_INT 60
72780: PUSH
72781: EMPTY
72782: LIST
72783: PUSH
72784: EMPTY
72785: LIST
72786: LIST
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: LIST
72792: PPUSH
72793: CALL_OW 72
72797: PUSH
72798: LD_EXP 74
72802: PUSH
72803: LD_VAR 0 2
72807: ARRAY
72808: DIFF
72809: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72810: LD_ADDR_VAR 0 9
72814: PUSH
72815: LD_EXP 70
72819: PUSH
72820: LD_VAR 0 2
72824: ARRAY
72825: PPUSH
72826: LD_INT 2
72828: PUSH
72829: LD_INT 30
72831: PUSH
72832: LD_INT 0
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 30
72841: PUSH
72842: LD_INT 1
72844: PUSH
72845: EMPTY
72846: LIST
72847: LIST
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: LIST
72853: PPUSH
72854: CALL_OW 72
72858: ST_TO_ADDR
// if not tmp or not dep then
72859: LD_VAR 0 8
72863: NOT
72864: PUSH
72865: LD_VAR 0 9
72869: NOT
72870: OR
72871: IFFALSE 72875
// continue ;
72873: GO 72660
// side := GetSide ( tmp [ 1 ] ) ;
72875: LD_ADDR_VAR 0 11
72879: PUSH
72880: LD_VAR 0 8
72884: PUSH
72885: LD_INT 1
72887: ARRAY
72888: PPUSH
72889: CALL_OW 255
72893: ST_TO_ADDR
// dep := dep [ 1 ] ;
72894: LD_ADDR_VAR 0 9
72898: PUSH
72899: LD_VAR 0 9
72903: PUSH
72904: LD_INT 1
72906: ARRAY
72907: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72908: LD_ADDR_VAR 0 7
72912: PUSH
72913: LD_EXP 98
72917: PUSH
72918: LD_VAR 0 2
72922: ARRAY
72923: PPUSH
72924: LD_INT 22
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 25
72936: PUSH
72937: LD_INT 12
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PPUSH
72948: CALL_OW 70
72952: PUSH
72953: LD_INT 22
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 25
72965: PUSH
72966: LD_INT 12
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 91
72975: PUSH
72976: LD_VAR 0 9
72980: PUSH
72981: LD_INT 20
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: LIST
72993: PPUSH
72994: CALL_OW 69
72998: UNION
72999: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73000: LD_ADDR_VAR 0 10
73004: PUSH
73005: LD_EXP 98
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: PPUSH
73016: LD_INT 81
73018: PUSH
73019: LD_VAR 0 11
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PPUSH
73028: CALL_OW 70
73032: ST_TO_ADDR
// if not apes or danger_at_area then
73033: LD_VAR 0 7
73037: NOT
73038: PUSH
73039: LD_VAR 0 10
73043: OR
73044: IFFALSE 73094
// begin if mc_taming [ i ] then
73046: LD_EXP 101
73050: PUSH
73051: LD_VAR 0 2
73055: ARRAY
73056: IFFALSE 73092
// begin MC_Reset ( i , 121 ) ;
73058: LD_VAR 0 2
73062: PPUSH
73063: LD_INT 121
73065: PPUSH
73066: CALL 58080 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73070: LD_ADDR_EXP 101
73074: PUSH
73075: LD_EXP 101
73079: PPUSH
73080: LD_VAR 0 2
73084: PPUSH
73085: EMPTY
73086: PPUSH
73087: CALL_OW 1
73091: ST_TO_ADDR
// end ; continue ;
73092: GO 72660
// end ; for j in tmp do
73094: LD_ADDR_VAR 0 3
73098: PUSH
73099: LD_VAR 0 8
73103: PUSH
73104: FOR_IN
73105: IFFALSE 73441
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73107: LD_VAR 0 3
73111: PUSH
73112: LD_EXP 101
73116: PUSH
73117: LD_VAR 0 2
73121: ARRAY
73122: IN
73123: NOT
73124: PUSH
73125: LD_EXP 101
73129: PUSH
73130: LD_VAR 0 2
73134: ARRAY
73135: PUSH
73136: LD_INT 3
73138: LESS
73139: AND
73140: IFFALSE 73198
// begin SetTag ( j , 121 ) ;
73142: LD_VAR 0 3
73146: PPUSH
73147: LD_INT 121
73149: PPUSH
73150: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73154: LD_ADDR_EXP 101
73158: PUSH
73159: LD_EXP 101
73163: PPUSH
73164: LD_VAR 0 2
73168: PUSH
73169: LD_EXP 101
73173: PUSH
73174: LD_VAR 0 2
73178: ARRAY
73179: PUSH
73180: LD_INT 1
73182: PLUS
73183: PUSH
73184: EMPTY
73185: LIST
73186: LIST
73187: PPUSH
73188: LD_VAR 0 3
73192: PPUSH
73193: CALL 18597 0 3
73197: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73198: LD_VAR 0 3
73202: PUSH
73203: LD_EXP 101
73207: PUSH
73208: LD_VAR 0 2
73212: ARRAY
73213: IN
73214: IFFALSE 73439
// begin if GetClass ( j ) <> 4 then
73216: LD_VAR 0 3
73220: PPUSH
73221: CALL_OW 257
73225: PUSH
73226: LD_INT 4
73228: NONEQUAL
73229: IFFALSE 73282
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73231: LD_ADDR_EXP 101
73235: PUSH
73236: LD_EXP 101
73240: PPUSH
73241: LD_VAR 0 2
73245: PPUSH
73246: LD_EXP 101
73250: PUSH
73251: LD_VAR 0 2
73255: ARRAY
73256: PUSH
73257: LD_VAR 0 3
73261: DIFF
73262: PPUSH
73263: CALL_OW 1
73267: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73268: LD_VAR 0 3
73272: PPUSH
73273: LD_INT 0
73275: PPUSH
73276: CALL_OW 109
// continue ;
73280: GO 73104
// end ; if IsInUnit ( j ) then
73282: LD_VAR 0 3
73286: PPUSH
73287: CALL_OW 310
73291: IFFALSE 73302
// ComExitBuilding ( j ) ;
73293: LD_VAR 0 3
73297: PPUSH
73298: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73302: LD_ADDR_VAR 0 6
73306: PUSH
73307: LD_VAR 0 7
73311: PPUSH
73312: LD_VAR 0 3
73316: PPUSH
73317: CALL_OW 74
73321: ST_TO_ADDR
// if not ape then
73322: LD_VAR 0 6
73326: NOT
73327: IFFALSE 73331
// break ;
73329: GO 73441
// x := GetX ( ape ) ;
73331: LD_ADDR_VAR 0 4
73335: PUSH
73336: LD_VAR 0 6
73340: PPUSH
73341: CALL_OW 250
73345: ST_TO_ADDR
// y := GetY ( ape ) ;
73346: LD_ADDR_VAR 0 5
73350: PUSH
73351: LD_VAR 0 6
73355: PPUSH
73356: CALL_OW 251
73360: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73361: LD_VAR 0 4
73365: PPUSH
73366: LD_VAR 0 5
73370: PPUSH
73371: CALL_OW 488
73375: NOT
73376: PUSH
73377: LD_VAR 0 11
73381: PPUSH
73382: LD_VAR 0 4
73386: PPUSH
73387: LD_VAR 0 5
73391: PPUSH
73392: LD_INT 20
73394: PPUSH
73395: CALL 19493 0 4
73399: PUSH
73400: LD_INT 4
73402: ARRAY
73403: OR
73404: IFFALSE 73408
// break ;
73406: GO 73441
// if not HasTask ( j ) then
73408: LD_VAR 0 3
73412: PPUSH
73413: CALL_OW 314
73417: NOT
73418: IFFALSE 73439
// ComTameXY ( j , x , y ) ;
73420: LD_VAR 0 3
73424: PPUSH
73425: LD_VAR 0 4
73429: PPUSH
73430: LD_VAR 0 5
73434: PPUSH
73435: CALL_OW 131
// end ; end ;
73439: GO 73104
73441: POP
73442: POP
// end ;
73443: GO 72660
73445: POP
73446: POP
// end ;
73447: LD_VAR 0 1
73451: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73452: LD_INT 0
73454: PPUSH
73455: PPUSH
73456: PPUSH
73457: PPUSH
73458: PPUSH
73459: PPUSH
73460: PPUSH
73461: PPUSH
// if not mc_bases then
73462: LD_EXP 70
73466: NOT
73467: IFFALSE 73471
// exit ;
73469: GO 74097
// for i = 1 to mc_bases do
73471: LD_ADDR_VAR 0 2
73475: PUSH
73476: DOUBLE
73477: LD_INT 1
73479: DEC
73480: ST_TO_ADDR
73481: LD_EXP 70
73485: PUSH
73486: FOR_TO
73487: IFFALSE 74095
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73489: LD_EXP 99
73493: PUSH
73494: LD_VAR 0 2
73498: ARRAY
73499: NOT
73500: PUSH
73501: LD_EXP 99
73505: PUSH
73506: LD_VAR 0 2
73510: ARRAY
73511: PPUSH
73512: LD_INT 25
73514: PUSH
73515: LD_INT 12
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PPUSH
73522: CALL_OW 72
73526: NOT
73527: OR
73528: IFFALSE 73532
// continue ;
73530: GO 73486
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73532: LD_ADDR_VAR 0 5
73536: PUSH
73537: LD_EXP 99
73541: PUSH
73542: LD_VAR 0 2
73546: ARRAY
73547: PUSH
73548: LD_INT 1
73550: ARRAY
73551: PPUSH
73552: CALL_OW 255
73556: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73557: LD_VAR 0 5
73561: PPUSH
73562: LD_INT 2
73564: PPUSH
73565: CALL_OW 325
73569: IFFALSE 73822
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73571: LD_ADDR_VAR 0 4
73575: PUSH
73576: LD_EXP 99
73580: PUSH
73581: LD_VAR 0 2
73585: ARRAY
73586: PPUSH
73587: LD_INT 25
73589: PUSH
73590: LD_INT 16
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PPUSH
73597: CALL_OW 72
73601: ST_TO_ADDR
// if tmp < 6 then
73602: LD_VAR 0 4
73606: PUSH
73607: LD_INT 6
73609: LESS
73610: IFFALSE 73822
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73612: LD_ADDR_VAR 0 6
73616: PUSH
73617: LD_EXP 70
73621: PUSH
73622: LD_VAR 0 2
73626: ARRAY
73627: PPUSH
73628: LD_INT 2
73630: PUSH
73631: LD_INT 30
73633: PUSH
73634: LD_INT 0
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 30
73643: PUSH
73644: LD_INT 1
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: LIST
73655: PPUSH
73656: CALL_OW 72
73660: ST_TO_ADDR
// if depot then
73661: LD_VAR 0 6
73665: IFFALSE 73822
// begin selected := 0 ;
73667: LD_ADDR_VAR 0 7
73671: PUSH
73672: LD_INT 0
73674: ST_TO_ADDR
// for j in depot do
73675: LD_ADDR_VAR 0 3
73679: PUSH
73680: LD_VAR 0 6
73684: PUSH
73685: FOR_IN
73686: IFFALSE 73717
// begin if UnitsInside ( j ) < 6 then
73688: LD_VAR 0 3
73692: PPUSH
73693: CALL_OW 313
73697: PUSH
73698: LD_INT 6
73700: LESS
73701: IFFALSE 73715
// begin selected := j ;
73703: LD_ADDR_VAR 0 7
73707: PUSH
73708: LD_VAR 0 3
73712: ST_TO_ADDR
// break ;
73713: GO 73717
// end ; end ;
73715: GO 73685
73717: POP
73718: POP
// if selected then
73719: LD_VAR 0 7
73723: IFFALSE 73822
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73725: LD_ADDR_VAR 0 3
73729: PUSH
73730: LD_EXP 99
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: PPUSH
73741: LD_INT 25
73743: PUSH
73744: LD_INT 12
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PPUSH
73751: CALL_OW 72
73755: PUSH
73756: FOR_IN
73757: IFFALSE 73820
// if not HasTask ( j ) then
73759: LD_VAR 0 3
73763: PPUSH
73764: CALL_OW 314
73768: NOT
73769: IFFALSE 73818
// begin if not IsInUnit ( j ) then
73771: LD_VAR 0 3
73775: PPUSH
73776: CALL_OW 310
73780: NOT
73781: IFFALSE 73797
// ComEnterUnit ( j , selected ) ;
73783: LD_VAR 0 3
73787: PPUSH
73788: LD_VAR 0 7
73792: PPUSH
73793: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73797: LD_VAR 0 3
73801: PPUSH
73802: LD_INT 16
73804: PPUSH
73805: CALL_OW 183
// AddComExitBuilding ( j ) ;
73809: LD_VAR 0 3
73813: PPUSH
73814: CALL_OW 182
// end ;
73818: GO 73756
73820: POP
73821: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73822: LD_VAR 0 5
73826: PPUSH
73827: LD_INT 11
73829: PPUSH
73830: CALL_OW 325
73834: IFFALSE 74093
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73836: LD_ADDR_VAR 0 4
73840: PUSH
73841: LD_EXP 99
73845: PUSH
73846: LD_VAR 0 2
73850: ARRAY
73851: PPUSH
73852: LD_INT 25
73854: PUSH
73855: LD_INT 16
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PPUSH
73862: CALL_OW 72
73866: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73867: LD_VAR 0 4
73871: PUSH
73872: LD_INT 6
73874: GREATEREQUAL
73875: PUSH
73876: LD_VAR 0 5
73880: PPUSH
73881: LD_INT 2
73883: PPUSH
73884: CALL_OW 325
73888: NOT
73889: OR
73890: IFFALSE 74093
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73892: LD_ADDR_VAR 0 8
73896: PUSH
73897: LD_EXP 70
73901: PUSH
73902: LD_VAR 0 2
73906: ARRAY
73907: PPUSH
73908: LD_INT 2
73910: PUSH
73911: LD_INT 30
73913: PUSH
73914: LD_INT 4
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 30
73923: PUSH
73924: LD_INT 5
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PPUSH
73936: CALL_OW 72
73940: ST_TO_ADDR
// if barracks then
73941: LD_VAR 0 8
73945: IFFALSE 74093
// begin selected := 0 ;
73947: LD_ADDR_VAR 0 7
73951: PUSH
73952: LD_INT 0
73954: ST_TO_ADDR
// for j in barracks do
73955: LD_ADDR_VAR 0 3
73959: PUSH
73960: LD_VAR 0 8
73964: PUSH
73965: FOR_IN
73966: IFFALSE 73997
// begin if UnitsInside ( j ) < 6 then
73968: LD_VAR 0 3
73972: PPUSH
73973: CALL_OW 313
73977: PUSH
73978: LD_INT 6
73980: LESS
73981: IFFALSE 73995
// begin selected := j ;
73983: LD_ADDR_VAR 0 7
73987: PUSH
73988: LD_VAR 0 3
73992: ST_TO_ADDR
// break ;
73993: GO 73997
// end ; end ;
73995: GO 73965
73997: POP
73998: POP
// if selected then
73999: LD_VAR 0 7
74003: IFFALSE 74093
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74005: LD_ADDR_VAR 0 3
74009: PUSH
74010: LD_EXP 99
74014: PUSH
74015: LD_VAR 0 2
74019: ARRAY
74020: PPUSH
74021: LD_INT 25
74023: PUSH
74024: LD_INT 12
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PPUSH
74031: CALL_OW 72
74035: PUSH
74036: FOR_IN
74037: IFFALSE 74091
// if not IsInUnit ( j ) and not HasTask ( j ) then
74039: LD_VAR 0 3
74043: PPUSH
74044: CALL_OW 310
74048: NOT
74049: PUSH
74050: LD_VAR 0 3
74054: PPUSH
74055: CALL_OW 314
74059: NOT
74060: AND
74061: IFFALSE 74089
// begin ComEnterUnit ( j , selected ) ;
74063: LD_VAR 0 3
74067: PPUSH
74068: LD_VAR 0 7
74072: PPUSH
74073: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74077: LD_VAR 0 3
74081: PPUSH
74082: LD_INT 15
74084: PPUSH
74085: CALL_OW 183
// end ;
74089: GO 74036
74091: POP
74092: POP
// end ; end ; end ; end ; end ;
74093: GO 73486
74095: POP
74096: POP
// end ;
74097: LD_VAR 0 1
74101: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74102: LD_INT 0
74104: PPUSH
74105: PPUSH
74106: PPUSH
74107: PPUSH
// if not mc_bases then
74108: LD_EXP 70
74112: NOT
74113: IFFALSE 74117
// exit ;
74115: GO 74295
// for i = 1 to mc_bases do
74117: LD_ADDR_VAR 0 2
74121: PUSH
74122: DOUBLE
74123: LD_INT 1
74125: DEC
74126: ST_TO_ADDR
74127: LD_EXP 70
74131: PUSH
74132: FOR_TO
74133: IFFALSE 74293
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74135: LD_ADDR_VAR 0 4
74139: PUSH
74140: LD_EXP 70
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: PPUSH
74151: LD_INT 25
74153: PUSH
74154: LD_INT 9
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PPUSH
74161: CALL_OW 72
74165: ST_TO_ADDR
// if not tmp then
74166: LD_VAR 0 4
74170: NOT
74171: IFFALSE 74175
// continue ;
74173: GO 74132
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74175: LD_EXP 96
74179: PUSH
74180: LD_VAR 0 2
74184: ARRAY
74185: PPUSH
74186: LD_INT 29
74188: PPUSH
74189: CALL_OW 325
74193: NOT
74194: PUSH
74195: LD_EXP 96
74199: PUSH
74200: LD_VAR 0 2
74204: ARRAY
74205: PPUSH
74206: LD_INT 28
74208: PPUSH
74209: CALL_OW 325
74213: NOT
74214: AND
74215: IFFALSE 74219
// continue ;
74217: GO 74132
// for j in tmp do
74219: LD_ADDR_VAR 0 3
74223: PUSH
74224: LD_VAR 0 4
74228: PUSH
74229: FOR_IN
74230: IFFALSE 74289
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74232: LD_VAR 0 3
74236: PUSH
74237: LD_EXP 73
74241: PUSH
74242: LD_VAR 0 2
74246: ARRAY
74247: PUSH
74248: LD_INT 1
74250: ARRAY
74251: IN
74252: NOT
74253: PUSH
74254: LD_VAR 0 3
74258: PUSH
74259: LD_EXP 73
74263: PUSH
74264: LD_VAR 0 2
74268: ARRAY
74269: PUSH
74270: LD_INT 2
74272: ARRAY
74273: IN
74274: NOT
74275: AND
74276: IFFALSE 74287
// ComSpaceTimeShoot ( j ) ;
74278: LD_VAR 0 3
74282: PPUSH
74283: CALL 14558 0 1
74287: GO 74229
74289: POP
74290: POP
// end ;
74291: GO 74132
74293: POP
74294: POP
// end ;
74295: LD_VAR 0 1
74299: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74300: LD_INT 0
74302: PPUSH
74303: PPUSH
74304: PPUSH
74305: PPUSH
74306: PPUSH
74307: PPUSH
74308: PPUSH
74309: PPUSH
74310: PPUSH
// if not mc_bases then
74311: LD_EXP 70
74315: NOT
74316: IFFALSE 74320
// exit ;
74318: GO 74942
// for i = 1 to mc_bases do
74320: LD_ADDR_VAR 0 2
74324: PUSH
74325: DOUBLE
74326: LD_INT 1
74328: DEC
74329: ST_TO_ADDR
74330: LD_EXP 70
74334: PUSH
74335: FOR_TO
74336: IFFALSE 74940
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74338: LD_EXP 105
74342: PUSH
74343: LD_VAR 0 2
74347: ARRAY
74348: NOT
74349: PUSH
74350: LD_INT 38
74352: PPUSH
74353: LD_EXP 96
74357: PUSH
74358: LD_VAR 0 2
74362: ARRAY
74363: PPUSH
74364: CALL_OW 321
74368: PUSH
74369: LD_INT 2
74371: NONEQUAL
74372: OR
74373: IFFALSE 74377
// continue ;
74375: GO 74335
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74377: LD_ADDR_VAR 0 8
74381: PUSH
74382: LD_EXP 70
74386: PUSH
74387: LD_VAR 0 2
74391: ARRAY
74392: PPUSH
74393: LD_INT 30
74395: PUSH
74396: LD_INT 34
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PPUSH
74403: CALL_OW 72
74407: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74408: LD_ADDR_VAR 0 9
74412: PUSH
74413: LD_EXP 70
74417: PUSH
74418: LD_VAR 0 2
74422: ARRAY
74423: PPUSH
74424: LD_INT 25
74426: PUSH
74427: LD_INT 4
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PPUSH
74434: CALL_OW 72
74438: PPUSH
74439: LD_INT 0
74441: PPUSH
74442: CALL 47866 0 2
74446: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74447: LD_VAR 0 9
74451: NOT
74452: PUSH
74453: LD_VAR 0 8
74457: NOT
74458: OR
74459: PUSH
74460: LD_EXP 70
74464: PUSH
74465: LD_VAR 0 2
74469: ARRAY
74470: PPUSH
74471: LD_INT 124
74473: PPUSH
74474: CALL 47866 0 2
74478: OR
74479: IFFALSE 74483
// continue ;
74481: GO 74335
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74483: LD_EXP 106
74487: PUSH
74488: LD_VAR 0 2
74492: ARRAY
74493: PUSH
74494: LD_EXP 105
74498: PUSH
74499: LD_VAR 0 2
74503: ARRAY
74504: LESS
74505: PUSH
74506: LD_EXP 106
74510: PUSH
74511: LD_VAR 0 2
74515: ARRAY
74516: PUSH
74517: LD_VAR 0 8
74521: LESS
74522: AND
74523: IFFALSE 74938
// begin tmp := sci [ 1 ] ;
74525: LD_ADDR_VAR 0 7
74529: PUSH
74530: LD_VAR 0 9
74534: PUSH
74535: LD_INT 1
74537: ARRAY
74538: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74539: LD_VAR 0 7
74543: PPUSH
74544: LD_INT 124
74546: PPUSH
74547: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74551: LD_ADDR_VAR 0 3
74555: PUSH
74556: DOUBLE
74557: LD_EXP 105
74561: PUSH
74562: LD_VAR 0 2
74566: ARRAY
74567: INC
74568: ST_TO_ADDR
74569: LD_EXP 105
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: PUSH
74580: FOR_DOWNTO
74581: IFFALSE 74924
// begin if IsInUnit ( tmp ) then
74583: LD_VAR 0 7
74587: PPUSH
74588: CALL_OW 310
74592: IFFALSE 74603
// ComExitBuilding ( tmp ) ;
74594: LD_VAR 0 7
74598: PPUSH
74599: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74603: LD_INT 35
74605: PPUSH
74606: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74610: LD_VAR 0 7
74614: PPUSH
74615: CALL_OW 310
74619: NOT
74620: PUSH
74621: LD_VAR 0 7
74625: PPUSH
74626: CALL_OW 314
74630: NOT
74631: AND
74632: IFFALSE 74603
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74634: LD_ADDR_VAR 0 6
74638: PUSH
74639: LD_VAR 0 7
74643: PPUSH
74644: CALL_OW 250
74648: PUSH
74649: LD_VAR 0 7
74653: PPUSH
74654: CALL_OW 251
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74663: LD_INT 35
74665: PPUSH
74666: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74670: LD_ADDR_VAR 0 4
74674: PUSH
74675: LD_EXP 105
74679: PUSH
74680: LD_VAR 0 2
74684: ARRAY
74685: PUSH
74686: LD_VAR 0 3
74690: ARRAY
74691: PUSH
74692: LD_INT 1
74694: ARRAY
74695: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74696: LD_ADDR_VAR 0 5
74700: PUSH
74701: LD_EXP 105
74705: PUSH
74706: LD_VAR 0 2
74710: ARRAY
74711: PUSH
74712: LD_VAR 0 3
74716: ARRAY
74717: PUSH
74718: LD_INT 2
74720: ARRAY
74721: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74722: LD_VAR 0 7
74726: PPUSH
74727: LD_INT 10
74729: PPUSH
74730: CALL 21196 0 2
74734: PUSH
74735: LD_INT 4
74737: ARRAY
74738: IFFALSE 74776
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74740: LD_VAR 0 7
74744: PPUSH
74745: LD_VAR 0 6
74749: PUSH
74750: LD_INT 1
74752: ARRAY
74753: PPUSH
74754: LD_VAR 0 6
74758: PUSH
74759: LD_INT 2
74761: ARRAY
74762: PPUSH
74763: CALL_OW 111
// wait ( 0 0$10 ) ;
74767: LD_INT 350
74769: PPUSH
74770: CALL_OW 67
// end else
74774: GO 74802
// begin ComMoveXY ( tmp , x , y ) ;
74776: LD_VAR 0 7
74780: PPUSH
74781: LD_VAR 0 4
74785: PPUSH
74786: LD_VAR 0 5
74790: PPUSH
74791: CALL_OW 111
// wait ( 0 0$3 ) ;
74795: LD_INT 105
74797: PPUSH
74798: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74802: LD_VAR 0 7
74806: PPUSH
74807: LD_VAR 0 4
74811: PPUSH
74812: LD_VAR 0 5
74816: PPUSH
74817: CALL_OW 307
74821: IFFALSE 74663
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74823: LD_VAR 0 7
74827: PPUSH
74828: LD_VAR 0 4
74832: PPUSH
74833: LD_VAR 0 5
74837: PPUSH
74838: LD_VAR 0 8
74842: PUSH
74843: LD_VAR 0 3
74847: ARRAY
74848: PPUSH
74849: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74853: LD_INT 35
74855: PPUSH
74856: CALL_OW 67
// until not HasTask ( tmp ) ;
74860: LD_VAR 0 7
74864: PPUSH
74865: CALL_OW 314
74869: NOT
74870: IFFALSE 74853
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74872: LD_ADDR_EXP 106
74876: PUSH
74877: LD_EXP 106
74881: PPUSH
74882: LD_VAR 0 2
74886: PUSH
74887: LD_EXP 106
74891: PUSH
74892: LD_VAR 0 2
74896: ARRAY
74897: PUSH
74898: LD_INT 1
74900: PLUS
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PPUSH
74906: LD_VAR 0 8
74910: PUSH
74911: LD_VAR 0 3
74915: ARRAY
74916: PPUSH
74917: CALL 18597 0 3
74921: ST_TO_ADDR
// end ;
74922: GO 74580
74924: POP
74925: POP
// MC_Reset ( i , 124 ) ;
74926: LD_VAR 0 2
74930: PPUSH
74931: LD_INT 124
74933: PPUSH
74934: CALL 58080 0 2
// end ; end ;
74938: GO 74335
74940: POP
74941: POP
// end ;
74942: LD_VAR 0 1
74946: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74947: LD_INT 0
74949: PPUSH
74950: PPUSH
74951: PPUSH
// if not mc_bases then
74952: LD_EXP 70
74956: NOT
74957: IFFALSE 74961
// exit ;
74959: GO 75567
// for i = 1 to mc_bases do
74961: LD_ADDR_VAR 0 2
74965: PUSH
74966: DOUBLE
74967: LD_INT 1
74969: DEC
74970: ST_TO_ADDR
74971: LD_EXP 70
74975: PUSH
74976: FOR_TO
74977: IFFALSE 75565
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74979: LD_ADDR_VAR 0 3
74983: PUSH
74984: LD_EXP 70
74988: PUSH
74989: LD_VAR 0 2
74993: ARRAY
74994: PPUSH
74995: LD_INT 25
74997: PUSH
74998: LD_INT 4
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PPUSH
75005: CALL_OW 72
75009: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75010: LD_VAR 0 3
75014: NOT
75015: PUSH
75016: LD_EXP 107
75020: PUSH
75021: LD_VAR 0 2
75025: ARRAY
75026: NOT
75027: OR
75028: PUSH
75029: LD_EXP 70
75033: PUSH
75034: LD_VAR 0 2
75038: ARRAY
75039: PPUSH
75040: LD_INT 2
75042: PUSH
75043: LD_INT 30
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 30
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: LIST
75067: PPUSH
75068: CALL_OW 72
75072: NOT
75073: OR
75074: IFFALSE 75124
// begin if mc_deposits_finder [ i ] then
75076: LD_EXP 108
75080: PUSH
75081: LD_VAR 0 2
75085: ARRAY
75086: IFFALSE 75122
// begin MC_Reset ( i , 125 ) ;
75088: LD_VAR 0 2
75092: PPUSH
75093: LD_INT 125
75095: PPUSH
75096: CALL 58080 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75100: LD_ADDR_EXP 108
75104: PUSH
75105: LD_EXP 108
75109: PPUSH
75110: LD_VAR 0 2
75114: PPUSH
75115: EMPTY
75116: PPUSH
75117: CALL_OW 1
75121: ST_TO_ADDR
// end ; continue ;
75122: GO 74976
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75124: LD_EXP 107
75128: PUSH
75129: LD_VAR 0 2
75133: ARRAY
75134: PUSH
75135: LD_INT 1
75137: ARRAY
75138: PUSH
75139: LD_INT 3
75141: ARRAY
75142: PUSH
75143: LD_INT 1
75145: EQUAL
75146: PUSH
75147: LD_INT 20
75149: PPUSH
75150: LD_EXP 96
75154: PUSH
75155: LD_VAR 0 2
75159: ARRAY
75160: PPUSH
75161: CALL_OW 321
75165: PUSH
75166: LD_INT 2
75168: NONEQUAL
75169: AND
75170: IFFALSE 75220
// begin if mc_deposits_finder [ i ] then
75172: LD_EXP 108
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: IFFALSE 75218
// begin MC_Reset ( i , 125 ) ;
75184: LD_VAR 0 2
75188: PPUSH
75189: LD_INT 125
75191: PPUSH
75192: CALL 58080 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75196: LD_ADDR_EXP 108
75200: PUSH
75201: LD_EXP 108
75205: PPUSH
75206: LD_VAR 0 2
75210: PPUSH
75211: EMPTY
75212: PPUSH
75213: CALL_OW 1
75217: ST_TO_ADDR
// end ; continue ;
75218: GO 74976
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75220: LD_EXP 107
75224: PUSH
75225: LD_VAR 0 2
75229: ARRAY
75230: PUSH
75231: LD_INT 1
75233: ARRAY
75234: PUSH
75235: LD_INT 1
75237: ARRAY
75238: PPUSH
75239: LD_EXP 107
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PUSH
75250: LD_INT 1
75252: ARRAY
75253: PUSH
75254: LD_INT 2
75256: ARRAY
75257: PPUSH
75258: LD_EXP 96
75262: PUSH
75263: LD_VAR 0 2
75267: ARRAY
75268: PPUSH
75269: CALL_OW 440
75273: IFFALSE 75316
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75275: LD_ADDR_EXP 107
75279: PUSH
75280: LD_EXP 107
75284: PPUSH
75285: LD_VAR 0 2
75289: PPUSH
75290: LD_EXP 107
75294: PUSH
75295: LD_VAR 0 2
75299: ARRAY
75300: PPUSH
75301: LD_INT 1
75303: PPUSH
75304: CALL_OW 3
75308: PPUSH
75309: CALL_OW 1
75313: ST_TO_ADDR
75314: GO 75563
// begin if not mc_deposits_finder [ i ] then
75316: LD_EXP 108
75320: PUSH
75321: LD_VAR 0 2
75325: ARRAY
75326: NOT
75327: IFFALSE 75379
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75329: LD_ADDR_EXP 108
75333: PUSH
75334: LD_EXP 108
75338: PPUSH
75339: LD_VAR 0 2
75343: PPUSH
75344: LD_VAR 0 3
75348: PUSH
75349: LD_INT 1
75351: ARRAY
75352: PUSH
75353: EMPTY
75354: LIST
75355: PPUSH
75356: CALL_OW 1
75360: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75361: LD_VAR 0 3
75365: PUSH
75366: LD_INT 1
75368: ARRAY
75369: PPUSH
75370: LD_INT 125
75372: PPUSH
75373: CALL_OW 109
// end else
75377: GO 75563
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75379: LD_EXP 108
75383: PUSH
75384: LD_VAR 0 2
75388: ARRAY
75389: PUSH
75390: LD_INT 1
75392: ARRAY
75393: PPUSH
75394: CALL_OW 310
75398: IFFALSE 75421
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75400: LD_EXP 108
75404: PUSH
75405: LD_VAR 0 2
75409: ARRAY
75410: PUSH
75411: LD_INT 1
75413: ARRAY
75414: PPUSH
75415: CALL_OW 122
75419: GO 75563
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75421: LD_EXP 108
75425: PUSH
75426: LD_VAR 0 2
75430: ARRAY
75431: PUSH
75432: LD_INT 1
75434: ARRAY
75435: PPUSH
75436: CALL_OW 314
75440: NOT
75441: PUSH
75442: LD_EXP 108
75446: PUSH
75447: LD_VAR 0 2
75451: ARRAY
75452: PUSH
75453: LD_INT 1
75455: ARRAY
75456: PPUSH
75457: LD_EXP 107
75461: PUSH
75462: LD_VAR 0 2
75466: ARRAY
75467: PUSH
75468: LD_INT 1
75470: ARRAY
75471: PUSH
75472: LD_INT 1
75474: ARRAY
75475: PPUSH
75476: LD_EXP 107
75480: PUSH
75481: LD_VAR 0 2
75485: ARRAY
75486: PUSH
75487: LD_INT 1
75489: ARRAY
75490: PUSH
75491: LD_INT 2
75493: ARRAY
75494: PPUSH
75495: CALL_OW 297
75499: PUSH
75500: LD_INT 6
75502: GREATER
75503: AND
75504: IFFALSE 75563
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75506: LD_EXP 108
75510: PUSH
75511: LD_VAR 0 2
75515: ARRAY
75516: PUSH
75517: LD_INT 1
75519: ARRAY
75520: PPUSH
75521: LD_EXP 107
75525: PUSH
75526: LD_VAR 0 2
75530: ARRAY
75531: PUSH
75532: LD_INT 1
75534: ARRAY
75535: PUSH
75536: LD_INT 1
75538: ARRAY
75539: PPUSH
75540: LD_EXP 107
75544: PUSH
75545: LD_VAR 0 2
75549: ARRAY
75550: PUSH
75551: LD_INT 1
75553: ARRAY
75554: PUSH
75555: LD_INT 2
75557: ARRAY
75558: PPUSH
75559: CALL_OW 111
// end ; end ; end ;
75563: GO 74976
75565: POP
75566: POP
// end ;
75567: LD_VAR 0 1
75571: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75572: LD_INT 0
75574: PPUSH
75575: PPUSH
75576: PPUSH
75577: PPUSH
75578: PPUSH
75579: PPUSH
75580: PPUSH
75581: PPUSH
75582: PPUSH
75583: PPUSH
75584: PPUSH
// if not mc_bases then
75585: LD_EXP 70
75589: NOT
75590: IFFALSE 75594
// exit ;
75592: GO 76534
// for i = 1 to mc_bases do
75594: LD_ADDR_VAR 0 2
75598: PUSH
75599: DOUBLE
75600: LD_INT 1
75602: DEC
75603: ST_TO_ADDR
75604: LD_EXP 70
75608: PUSH
75609: FOR_TO
75610: IFFALSE 76532
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75612: LD_EXP 70
75616: PUSH
75617: LD_VAR 0 2
75621: ARRAY
75622: NOT
75623: PUSH
75624: LD_EXP 93
75628: PUSH
75629: LD_VAR 0 2
75633: ARRAY
75634: OR
75635: IFFALSE 75639
// continue ;
75637: GO 75609
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75639: LD_ADDR_VAR 0 7
75643: PUSH
75644: LD_EXP 70
75648: PUSH
75649: LD_VAR 0 2
75653: ARRAY
75654: PUSH
75655: LD_INT 1
75657: ARRAY
75658: PPUSH
75659: CALL_OW 248
75663: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75664: LD_VAR 0 7
75668: PUSH
75669: LD_INT 3
75671: EQUAL
75672: PUSH
75673: LD_EXP 89
75677: PUSH
75678: LD_VAR 0 2
75682: ARRAY
75683: PUSH
75684: LD_EXP 92
75688: PUSH
75689: LD_VAR 0 2
75693: ARRAY
75694: UNION
75695: PPUSH
75696: LD_INT 33
75698: PUSH
75699: LD_INT 2
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PPUSH
75706: CALL_OW 72
75710: NOT
75711: OR
75712: IFFALSE 75716
// continue ;
75714: GO 75609
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75716: LD_ADDR_VAR 0 9
75720: PUSH
75721: LD_EXP 70
75725: PUSH
75726: LD_VAR 0 2
75730: ARRAY
75731: PPUSH
75732: LD_INT 30
75734: PUSH
75735: LD_INT 36
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PPUSH
75742: CALL_OW 72
75746: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75747: LD_ADDR_VAR 0 10
75751: PUSH
75752: LD_EXP 89
75756: PUSH
75757: LD_VAR 0 2
75761: ARRAY
75762: PPUSH
75763: LD_INT 34
75765: PUSH
75766: LD_INT 31
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PPUSH
75773: CALL_OW 72
75777: ST_TO_ADDR
// if not cts and not mcts then
75778: LD_VAR 0 9
75782: NOT
75783: PUSH
75784: LD_VAR 0 10
75788: NOT
75789: AND
75790: IFFALSE 75794
// continue ;
75792: GO 75609
// x := cts ;
75794: LD_ADDR_VAR 0 11
75798: PUSH
75799: LD_VAR 0 9
75803: ST_TO_ADDR
// if not x then
75804: LD_VAR 0 11
75808: NOT
75809: IFFALSE 75821
// x := mcts ;
75811: LD_ADDR_VAR 0 11
75815: PUSH
75816: LD_VAR 0 10
75820: ST_TO_ADDR
// if not x then
75821: LD_VAR 0 11
75825: NOT
75826: IFFALSE 75830
// continue ;
75828: GO 75609
// if mc_remote_driver [ i ] then
75830: LD_EXP 110
75834: PUSH
75835: LD_VAR 0 2
75839: ARRAY
75840: IFFALSE 76227
// for j in mc_remote_driver [ i ] do
75842: LD_ADDR_VAR 0 3
75846: PUSH
75847: LD_EXP 110
75851: PUSH
75852: LD_VAR 0 2
75856: ARRAY
75857: PUSH
75858: FOR_IN
75859: IFFALSE 76225
// begin if GetClass ( j ) <> 3 then
75861: LD_VAR 0 3
75865: PPUSH
75866: CALL_OW 257
75870: PUSH
75871: LD_INT 3
75873: NONEQUAL
75874: IFFALSE 75927
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75876: LD_ADDR_EXP 110
75880: PUSH
75881: LD_EXP 110
75885: PPUSH
75886: LD_VAR 0 2
75890: PPUSH
75891: LD_EXP 110
75895: PUSH
75896: LD_VAR 0 2
75900: ARRAY
75901: PUSH
75902: LD_VAR 0 3
75906: DIFF
75907: PPUSH
75908: CALL_OW 1
75912: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75913: LD_VAR 0 3
75917: PPUSH
75918: LD_INT 0
75920: PPUSH
75921: CALL_OW 109
// continue ;
75925: GO 75858
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75927: LD_EXP 89
75931: PUSH
75932: LD_VAR 0 2
75936: ARRAY
75937: PPUSH
75938: LD_INT 34
75940: PUSH
75941: LD_INT 31
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 58
75950: PUSH
75951: EMPTY
75952: LIST
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PPUSH
75958: CALL_OW 72
75962: PUSH
75963: LD_VAR 0 3
75967: PPUSH
75968: CALL 47901 0 1
75972: NOT
75973: AND
75974: IFFALSE 76045
// begin if IsInUnit ( j ) then
75976: LD_VAR 0 3
75980: PPUSH
75981: CALL_OW 310
75985: IFFALSE 75996
// ComExitBuilding ( j ) ;
75987: LD_VAR 0 3
75991: PPUSH
75992: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
75996: LD_VAR 0 3
76000: PPUSH
76001: LD_EXP 89
76005: PUSH
76006: LD_VAR 0 2
76010: ARRAY
76011: PPUSH
76012: LD_INT 34
76014: PUSH
76015: LD_INT 31
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 58
76024: PUSH
76025: EMPTY
76026: LIST
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PPUSH
76032: CALL_OW 72
76036: PUSH
76037: LD_INT 1
76039: ARRAY
76040: PPUSH
76041: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76045: LD_VAR 0 3
76049: PPUSH
76050: CALL_OW 310
76054: NOT
76055: PUSH
76056: LD_VAR 0 3
76060: PPUSH
76061: CALL_OW 310
76065: PPUSH
76066: CALL_OW 266
76070: PUSH
76071: LD_INT 36
76073: NONEQUAL
76074: PUSH
76075: LD_VAR 0 3
76079: PPUSH
76080: CALL 47901 0 1
76084: NOT
76085: AND
76086: OR
76087: IFFALSE 76223
// begin if IsInUnit ( j ) then
76089: LD_VAR 0 3
76093: PPUSH
76094: CALL_OW 310
76098: IFFALSE 76109
// ComExitBuilding ( j ) ;
76100: LD_VAR 0 3
76104: PPUSH
76105: CALL_OW 122
// ct := 0 ;
76109: LD_ADDR_VAR 0 8
76113: PUSH
76114: LD_INT 0
76116: ST_TO_ADDR
// for k in x do
76117: LD_ADDR_VAR 0 4
76121: PUSH
76122: LD_VAR 0 11
76126: PUSH
76127: FOR_IN
76128: IFFALSE 76201
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76130: LD_VAR 0 4
76134: PPUSH
76135: CALL_OW 264
76139: PUSH
76140: LD_INT 31
76142: EQUAL
76143: PUSH
76144: LD_VAR 0 4
76148: PPUSH
76149: CALL_OW 311
76153: NOT
76154: AND
76155: PUSH
76156: LD_VAR 0 4
76160: PPUSH
76161: CALL_OW 266
76165: PUSH
76166: LD_INT 36
76168: EQUAL
76169: PUSH
76170: LD_VAR 0 4
76174: PPUSH
76175: CALL_OW 313
76179: PUSH
76180: LD_INT 3
76182: LESS
76183: AND
76184: OR
76185: IFFALSE 76199
// begin ct := k ;
76187: LD_ADDR_VAR 0 8
76191: PUSH
76192: LD_VAR 0 4
76196: ST_TO_ADDR
// break ;
76197: GO 76201
// end ;
76199: GO 76127
76201: POP
76202: POP
// if ct then
76203: LD_VAR 0 8
76207: IFFALSE 76223
// ComEnterUnit ( j , ct ) ;
76209: LD_VAR 0 3
76213: PPUSH
76214: LD_VAR 0 8
76218: PPUSH
76219: CALL_OW 120
// end ; end ;
76223: GO 75858
76225: POP
76226: POP
// places := 0 ;
76227: LD_ADDR_VAR 0 5
76231: PUSH
76232: LD_INT 0
76234: ST_TO_ADDR
// for j = 1 to x do
76235: LD_ADDR_VAR 0 3
76239: PUSH
76240: DOUBLE
76241: LD_INT 1
76243: DEC
76244: ST_TO_ADDR
76245: LD_VAR 0 11
76249: PUSH
76250: FOR_TO
76251: IFFALSE 76327
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76253: LD_VAR 0 11
76257: PUSH
76258: LD_VAR 0 3
76262: ARRAY
76263: PPUSH
76264: CALL_OW 264
76268: PUSH
76269: LD_INT 31
76271: EQUAL
76272: IFFALSE 76290
// places := places + 1 else
76274: LD_ADDR_VAR 0 5
76278: PUSH
76279: LD_VAR 0 5
76283: PUSH
76284: LD_INT 1
76286: PLUS
76287: ST_TO_ADDR
76288: GO 76325
// if GetBType ( x [ j ] ) = b_control_tower then
76290: LD_VAR 0 11
76294: PUSH
76295: LD_VAR 0 3
76299: ARRAY
76300: PPUSH
76301: CALL_OW 266
76305: PUSH
76306: LD_INT 36
76308: EQUAL
76309: IFFALSE 76325
// places := places + 3 ;
76311: LD_ADDR_VAR 0 5
76315: PUSH
76316: LD_VAR 0 5
76320: PUSH
76321: LD_INT 3
76323: PLUS
76324: ST_TO_ADDR
76325: GO 76250
76327: POP
76328: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76329: LD_VAR 0 5
76333: PUSH
76334: LD_INT 0
76336: EQUAL
76337: PUSH
76338: LD_VAR 0 5
76342: PUSH
76343: LD_EXP 110
76347: PUSH
76348: LD_VAR 0 2
76352: ARRAY
76353: LESSEQUAL
76354: OR
76355: IFFALSE 76359
// continue ;
76357: GO 75609
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76359: LD_ADDR_VAR 0 6
76363: PUSH
76364: LD_EXP 70
76368: PUSH
76369: LD_VAR 0 2
76373: ARRAY
76374: PPUSH
76375: LD_INT 25
76377: PUSH
76378: LD_INT 3
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PPUSH
76385: CALL_OW 72
76389: PUSH
76390: LD_EXP 110
76394: PUSH
76395: LD_VAR 0 2
76399: ARRAY
76400: DIFF
76401: PPUSH
76402: LD_INT 3
76404: PPUSH
76405: CALL 48801 0 2
76409: ST_TO_ADDR
// for j in tmp do
76410: LD_ADDR_VAR 0 3
76414: PUSH
76415: LD_VAR 0 6
76419: PUSH
76420: FOR_IN
76421: IFFALSE 76456
// if GetTag ( j ) > 0 then
76423: LD_VAR 0 3
76427: PPUSH
76428: CALL_OW 110
76432: PUSH
76433: LD_INT 0
76435: GREATER
76436: IFFALSE 76454
// tmp := tmp diff j ;
76438: LD_ADDR_VAR 0 6
76442: PUSH
76443: LD_VAR 0 6
76447: PUSH
76448: LD_VAR 0 3
76452: DIFF
76453: ST_TO_ADDR
76454: GO 76420
76456: POP
76457: POP
// if not tmp then
76458: LD_VAR 0 6
76462: NOT
76463: IFFALSE 76467
// continue ;
76465: GO 75609
// if places then
76467: LD_VAR 0 5
76471: IFFALSE 76530
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76473: LD_ADDR_EXP 110
76477: PUSH
76478: LD_EXP 110
76482: PPUSH
76483: LD_VAR 0 2
76487: PPUSH
76488: LD_EXP 110
76492: PUSH
76493: LD_VAR 0 2
76497: ARRAY
76498: PUSH
76499: LD_VAR 0 6
76503: PUSH
76504: LD_INT 1
76506: ARRAY
76507: UNION
76508: PPUSH
76509: CALL_OW 1
76513: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76514: LD_VAR 0 6
76518: PUSH
76519: LD_INT 1
76521: ARRAY
76522: PPUSH
76523: LD_INT 126
76525: PPUSH
76526: CALL_OW 109
// end ; end ;
76530: GO 75609
76532: POP
76533: POP
// end ;
76534: LD_VAR 0 1
76538: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76539: LD_INT 0
76541: PPUSH
76542: PPUSH
76543: PPUSH
76544: PPUSH
76545: PPUSH
76546: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76547: LD_VAR 0 1
76551: NOT
76552: PUSH
76553: LD_VAR 0 2
76557: NOT
76558: OR
76559: PUSH
76560: LD_VAR 0 3
76564: NOT
76565: OR
76566: PUSH
76567: LD_VAR 0 4
76571: PUSH
76572: LD_INT 1
76574: PUSH
76575: LD_INT 2
76577: PUSH
76578: LD_INT 3
76580: PUSH
76581: LD_INT 4
76583: PUSH
76584: LD_INT 5
76586: PUSH
76587: LD_INT 8
76589: PUSH
76590: LD_INT 9
76592: PUSH
76593: LD_INT 15
76595: PUSH
76596: LD_INT 16
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: IN
76610: NOT
76611: OR
76612: IFFALSE 76616
// exit ;
76614: GO 77516
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76616: LD_ADDR_VAR 0 2
76620: PUSH
76621: LD_VAR 0 2
76625: PPUSH
76626: LD_INT 21
76628: PUSH
76629: LD_INT 3
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 24
76638: PUSH
76639: LD_INT 250
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PPUSH
76650: CALL_OW 72
76654: ST_TO_ADDR
// case class of 1 , 15 :
76655: LD_VAR 0 4
76659: PUSH
76660: LD_INT 1
76662: DOUBLE
76663: EQUAL
76664: IFTRUE 76674
76666: LD_INT 15
76668: DOUBLE
76669: EQUAL
76670: IFTRUE 76674
76672: GO 76759
76674: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76675: LD_ADDR_VAR 0 8
76679: PUSH
76680: LD_VAR 0 2
76684: PPUSH
76685: LD_INT 2
76687: PUSH
76688: LD_INT 30
76690: PUSH
76691: LD_INT 32
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PUSH
76698: LD_INT 30
76700: PUSH
76701: LD_INT 31
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: LIST
76712: PPUSH
76713: CALL_OW 72
76717: PUSH
76718: LD_VAR 0 2
76722: PPUSH
76723: LD_INT 2
76725: PUSH
76726: LD_INT 30
76728: PUSH
76729: LD_INT 4
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 30
76738: PUSH
76739: LD_INT 5
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: PPUSH
76751: CALL_OW 72
76755: ADD
76756: ST_TO_ADDR
76757: GO 77005
76759: LD_INT 2
76761: DOUBLE
76762: EQUAL
76763: IFTRUE 76773
76765: LD_INT 16
76767: DOUBLE
76768: EQUAL
76769: IFTRUE 76773
76771: GO 76819
76773: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76774: LD_ADDR_VAR 0 8
76778: PUSH
76779: LD_VAR 0 2
76783: PPUSH
76784: LD_INT 2
76786: PUSH
76787: LD_INT 30
76789: PUSH
76790: LD_INT 0
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 30
76799: PUSH
76800: LD_INT 1
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: LIST
76811: PPUSH
76812: CALL_OW 72
76816: ST_TO_ADDR
76817: GO 77005
76819: LD_INT 3
76821: DOUBLE
76822: EQUAL
76823: IFTRUE 76827
76825: GO 76873
76827: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76828: LD_ADDR_VAR 0 8
76832: PUSH
76833: LD_VAR 0 2
76837: PPUSH
76838: LD_INT 2
76840: PUSH
76841: LD_INT 30
76843: PUSH
76844: LD_INT 2
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 30
76853: PUSH
76854: LD_INT 3
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: LIST
76865: PPUSH
76866: CALL_OW 72
76870: ST_TO_ADDR
76871: GO 77005
76873: LD_INT 4
76875: DOUBLE
76876: EQUAL
76877: IFTRUE 76881
76879: GO 76938
76881: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76882: LD_ADDR_VAR 0 8
76886: PUSH
76887: LD_VAR 0 2
76891: PPUSH
76892: LD_INT 2
76894: PUSH
76895: LD_INT 30
76897: PUSH
76898: LD_INT 6
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 30
76907: PUSH
76908: LD_INT 7
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 30
76917: PUSH
76918: LD_INT 8
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: LIST
76929: LIST
76930: PPUSH
76931: CALL_OW 72
76935: ST_TO_ADDR
76936: GO 77005
76938: LD_INT 5
76940: DOUBLE
76941: EQUAL
76942: IFTRUE 76958
76944: LD_INT 8
76946: DOUBLE
76947: EQUAL
76948: IFTRUE 76958
76950: LD_INT 9
76952: DOUBLE
76953: EQUAL
76954: IFTRUE 76958
76956: GO 77004
76958: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76959: LD_ADDR_VAR 0 8
76963: PUSH
76964: LD_VAR 0 2
76968: PPUSH
76969: LD_INT 2
76971: PUSH
76972: LD_INT 30
76974: PUSH
76975: LD_INT 4
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 30
76984: PUSH
76985: LD_INT 5
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: LIST
76996: PPUSH
76997: CALL_OW 72
77001: ST_TO_ADDR
77002: GO 77005
77004: POP
// if not tmp then
77005: LD_VAR 0 8
77009: NOT
77010: IFFALSE 77014
// exit ;
77012: GO 77516
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77014: LD_VAR 0 4
77018: PUSH
77019: LD_INT 1
77021: PUSH
77022: LD_INT 15
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: IN
77029: PUSH
77030: LD_EXP 79
77034: PUSH
77035: LD_VAR 0 1
77039: ARRAY
77040: AND
77041: IFFALSE 77197
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77043: LD_ADDR_VAR 0 9
77047: PUSH
77048: LD_EXP 79
77052: PUSH
77053: LD_VAR 0 1
77057: ARRAY
77058: PUSH
77059: LD_INT 1
77061: ARRAY
77062: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77063: LD_VAR 0 9
77067: PUSH
77068: LD_EXP 80
77072: PUSH
77073: LD_VAR 0 1
77077: ARRAY
77078: IN
77079: NOT
77080: IFFALSE 77195
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77082: LD_ADDR_EXP 80
77086: PUSH
77087: LD_EXP 80
77091: PPUSH
77092: LD_VAR 0 1
77096: PUSH
77097: LD_EXP 80
77101: PUSH
77102: LD_VAR 0 1
77106: ARRAY
77107: PUSH
77108: LD_INT 1
77110: PLUS
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PPUSH
77116: LD_VAR 0 9
77120: PPUSH
77121: CALL 18597 0 3
77125: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77126: LD_ADDR_EXP 79
77130: PUSH
77131: LD_EXP 79
77135: PPUSH
77136: LD_VAR 0 1
77140: PPUSH
77141: LD_EXP 79
77145: PUSH
77146: LD_VAR 0 1
77150: ARRAY
77151: PUSH
77152: LD_VAR 0 9
77156: DIFF
77157: PPUSH
77158: CALL_OW 1
77162: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77163: LD_VAR 0 3
77167: PPUSH
77168: LD_EXP 80
77172: PUSH
77173: LD_VAR 0 1
77177: ARRAY
77178: PUSH
77179: LD_EXP 80
77183: PUSH
77184: LD_VAR 0 1
77188: ARRAY
77189: ARRAY
77190: PPUSH
77191: CALL_OW 120
// end ; exit ;
77195: GO 77516
// end ; if tmp > 1 then
77197: LD_VAR 0 8
77201: PUSH
77202: LD_INT 1
77204: GREATER
77205: IFFALSE 77309
// for i = 2 to tmp do
77207: LD_ADDR_VAR 0 6
77211: PUSH
77212: DOUBLE
77213: LD_INT 2
77215: DEC
77216: ST_TO_ADDR
77217: LD_VAR 0 8
77221: PUSH
77222: FOR_TO
77223: IFFALSE 77307
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77225: LD_VAR 0 8
77229: PUSH
77230: LD_VAR 0 6
77234: ARRAY
77235: PPUSH
77236: CALL_OW 461
77240: PUSH
77241: LD_INT 6
77243: EQUAL
77244: IFFALSE 77305
// begin x := tmp [ i ] ;
77246: LD_ADDR_VAR 0 9
77250: PUSH
77251: LD_VAR 0 8
77255: PUSH
77256: LD_VAR 0 6
77260: ARRAY
77261: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77262: LD_ADDR_VAR 0 8
77266: PUSH
77267: LD_VAR 0 8
77271: PPUSH
77272: LD_VAR 0 6
77276: PPUSH
77277: CALL_OW 3
77281: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77282: LD_ADDR_VAR 0 8
77286: PUSH
77287: LD_VAR 0 8
77291: PPUSH
77292: LD_INT 1
77294: PPUSH
77295: LD_VAR 0 9
77299: PPUSH
77300: CALL_OW 2
77304: ST_TO_ADDR
// end ;
77305: GO 77222
77307: POP
77308: POP
// for i in tmp do
77309: LD_ADDR_VAR 0 6
77313: PUSH
77314: LD_VAR 0 8
77318: PUSH
77319: FOR_IN
77320: IFFALSE 77389
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77322: LD_VAR 0 6
77326: PPUSH
77327: CALL_OW 313
77331: PUSH
77332: LD_INT 6
77334: LESS
77335: PUSH
77336: LD_VAR 0 6
77340: PPUSH
77341: CALL_OW 266
77345: PUSH
77346: LD_INT 31
77348: PUSH
77349: LD_INT 32
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: IN
77356: NOT
77357: AND
77358: PUSH
77359: LD_VAR 0 6
77363: PPUSH
77364: CALL_OW 313
77368: PUSH
77369: LD_INT 0
77371: EQUAL
77372: OR
77373: IFFALSE 77387
// begin j := i ;
77375: LD_ADDR_VAR 0 7
77379: PUSH
77380: LD_VAR 0 6
77384: ST_TO_ADDR
// break ;
77385: GO 77389
// end ; end ;
77387: GO 77319
77389: POP
77390: POP
// if j then
77391: LD_VAR 0 7
77395: IFFALSE 77413
// ComEnterUnit ( unit , j ) else
77397: LD_VAR 0 3
77401: PPUSH
77402: LD_VAR 0 7
77406: PPUSH
77407: CALL_OW 120
77411: GO 77516
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77413: LD_ADDR_VAR 0 10
77417: PUSH
77418: LD_VAR 0 2
77422: PPUSH
77423: LD_INT 2
77425: PUSH
77426: LD_INT 30
77428: PUSH
77429: LD_INT 0
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 30
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: LIST
77450: PPUSH
77451: CALL_OW 72
77455: ST_TO_ADDR
// if depot then
77456: LD_VAR 0 10
77460: IFFALSE 77516
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77462: LD_ADDR_VAR 0 10
77466: PUSH
77467: LD_VAR 0 10
77471: PPUSH
77472: LD_VAR 0 3
77476: PPUSH
77477: CALL_OW 74
77481: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77482: LD_VAR 0 3
77486: PPUSH
77487: LD_VAR 0 10
77491: PPUSH
77492: CALL_OW 296
77496: PUSH
77497: LD_INT 10
77499: GREATER
77500: IFFALSE 77516
// ComStandNearbyBuilding ( unit , depot ) ;
77502: LD_VAR 0 3
77506: PPUSH
77507: LD_VAR 0 10
77511: PPUSH
77512: CALL 15175 0 2
// end ; end ; end ;
77516: LD_VAR 0 5
77520: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77521: LD_INT 0
77523: PPUSH
77524: PPUSH
77525: PPUSH
77526: PPUSH
// if not mc_bases then
77527: LD_EXP 70
77531: NOT
77532: IFFALSE 77536
// exit ;
77534: GO 77775
// for i = 1 to mc_bases do
77536: LD_ADDR_VAR 0 2
77540: PUSH
77541: DOUBLE
77542: LD_INT 1
77544: DEC
77545: ST_TO_ADDR
77546: LD_EXP 70
77550: PUSH
77551: FOR_TO
77552: IFFALSE 77773
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77554: LD_ADDR_VAR 0 4
77558: PUSH
77559: LD_EXP 70
77563: PUSH
77564: LD_VAR 0 2
77568: ARRAY
77569: PPUSH
77570: LD_INT 21
77572: PUSH
77573: LD_INT 1
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PPUSH
77580: CALL_OW 72
77584: PUSH
77585: LD_EXP 99
77589: PUSH
77590: LD_VAR 0 2
77594: ARRAY
77595: UNION
77596: ST_TO_ADDR
// if not tmp then
77597: LD_VAR 0 4
77601: NOT
77602: IFFALSE 77606
// continue ;
77604: GO 77551
// for j in tmp do
77606: LD_ADDR_VAR 0 3
77610: PUSH
77611: LD_VAR 0 4
77615: PUSH
77616: FOR_IN
77617: IFFALSE 77769
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77619: LD_VAR 0 3
77623: PPUSH
77624: CALL_OW 110
77628: NOT
77629: PUSH
77630: LD_VAR 0 3
77634: PPUSH
77635: CALL_OW 314
77639: NOT
77640: AND
77641: PUSH
77642: LD_VAR 0 3
77646: PPUSH
77647: CALL_OW 311
77651: NOT
77652: AND
77653: PUSH
77654: LD_VAR 0 3
77658: PPUSH
77659: CALL_OW 310
77663: NOT
77664: AND
77665: PUSH
77666: LD_VAR 0 3
77670: PUSH
77671: LD_EXP 73
77675: PUSH
77676: LD_VAR 0 2
77680: ARRAY
77681: PUSH
77682: LD_INT 1
77684: ARRAY
77685: IN
77686: NOT
77687: AND
77688: PUSH
77689: LD_VAR 0 3
77693: PUSH
77694: LD_EXP 73
77698: PUSH
77699: LD_VAR 0 2
77703: ARRAY
77704: PUSH
77705: LD_INT 2
77707: ARRAY
77708: IN
77709: NOT
77710: AND
77711: PUSH
77712: LD_VAR 0 3
77716: PUSH
77717: LD_EXP 82
77721: PUSH
77722: LD_VAR 0 2
77726: ARRAY
77727: IN
77728: NOT
77729: AND
77730: IFFALSE 77767
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77732: LD_VAR 0 2
77736: PPUSH
77737: LD_EXP 70
77741: PUSH
77742: LD_VAR 0 2
77746: ARRAY
77747: PPUSH
77748: LD_VAR 0 3
77752: PPUSH
77753: LD_VAR 0 3
77757: PPUSH
77758: CALL_OW 257
77762: PPUSH
77763: CALL 76539 0 4
// end ;
77767: GO 77616
77769: POP
77770: POP
// end ;
77771: GO 77551
77773: POP
77774: POP
// end ;
77775: LD_VAR 0 1
77779: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77780: LD_INT 0
77782: PPUSH
77783: PPUSH
77784: PPUSH
77785: PPUSH
77786: PPUSH
77787: PPUSH
// if not mc_bases [ base ] then
77788: LD_EXP 70
77792: PUSH
77793: LD_VAR 0 1
77797: ARRAY
77798: NOT
77799: IFFALSE 77803
// exit ;
77801: GO 77985
// tmp := [ ] ;
77803: LD_ADDR_VAR 0 6
77807: PUSH
77808: EMPTY
77809: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77810: LD_ADDR_VAR 0 7
77814: PUSH
77815: LD_VAR 0 3
77819: PPUSH
77820: LD_INT 0
77822: PPUSH
77823: CALL_OW 517
77827: ST_TO_ADDR
// if not list then
77828: LD_VAR 0 7
77832: NOT
77833: IFFALSE 77837
// exit ;
77835: GO 77985
// for i = 1 to amount do
77837: LD_ADDR_VAR 0 5
77841: PUSH
77842: DOUBLE
77843: LD_INT 1
77845: DEC
77846: ST_TO_ADDR
77847: LD_VAR 0 2
77851: PUSH
77852: FOR_TO
77853: IFFALSE 77933
// begin x := rand ( 1 , list [ 1 ] ) ;
77855: LD_ADDR_VAR 0 8
77859: PUSH
77860: LD_INT 1
77862: PPUSH
77863: LD_VAR 0 7
77867: PUSH
77868: LD_INT 1
77870: ARRAY
77871: PPUSH
77872: CALL_OW 12
77876: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77877: LD_ADDR_VAR 0 6
77881: PUSH
77882: LD_VAR 0 6
77886: PPUSH
77887: LD_VAR 0 5
77891: PPUSH
77892: LD_VAR 0 7
77896: PUSH
77897: LD_INT 1
77899: ARRAY
77900: PUSH
77901: LD_VAR 0 8
77905: ARRAY
77906: PUSH
77907: LD_VAR 0 7
77911: PUSH
77912: LD_INT 2
77914: ARRAY
77915: PUSH
77916: LD_VAR 0 8
77920: ARRAY
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: PPUSH
77926: CALL_OW 1
77930: ST_TO_ADDR
// end ;
77931: GO 77852
77933: POP
77934: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77935: LD_ADDR_EXP 83
77939: PUSH
77940: LD_EXP 83
77944: PPUSH
77945: LD_VAR 0 1
77949: PPUSH
77950: LD_VAR 0 6
77954: PPUSH
77955: CALL_OW 1
77959: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77960: LD_ADDR_EXP 85
77964: PUSH
77965: LD_EXP 85
77969: PPUSH
77970: LD_VAR 0 1
77974: PPUSH
77975: LD_VAR 0 3
77979: PPUSH
77980: CALL_OW 1
77984: ST_TO_ADDR
// end ;
77985: LD_VAR 0 4
77989: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77990: LD_INT 0
77992: PPUSH
// if not mc_bases [ base ] then
77993: LD_EXP 70
77997: PUSH
77998: LD_VAR 0 1
78002: ARRAY
78003: NOT
78004: IFFALSE 78008
// exit ;
78006: GO 78033
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78008: LD_ADDR_EXP 75
78012: PUSH
78013: LD_EXP 75
78017: PPUSH
78018: LD_VAR 0 1
78022: PPUSH
78023: LD_VAR 0 2
78027: PPUSH
78028: CALL_OW 1
78032: ST_TO_ADDR
// end ;
78033: LD_VAR 0 3
78037: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78038: LD_INT 0
78040: PPUSH
// if not mc_bases [ base ] then
78041: LD_EXP 70
78045: PUSH
78046: LD_VAR 0 1
78050: ARRAY
78051: NOT
78052: IFFALSE 78056
// exit ;
78054: GO 78093
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78056: LD_ADDR_EXP 75
78060: PUSH
78061: LD_EXP 75
78065: PPUSH
78066: LD_VAR 0 1
78070: PPUSH
78071: LD_EXP 75
78075: PUSH
78076: LD_VAR 0 1
78080: ARRAY
78081: PUSH
78082: LD_VAR 0 2
78086: UNION
78087: PPUSH
78088: CALL_OW 1
78092: ST_TO_ADDR
// end ;
78093: LD_VAR 0 3
78097: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78098: LD_INT 0
78100: PPUSH
// if not mc_bases [ base ] then
78101: LD_EXP 70
78105: PUSH
78106: LD_VAR 0 1
78110: ARRAY
78111: NOT
78112: IFFALSE 78116
// exit ;
78114: GO 78141
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78116: LD_ADDR_EXP 91
78120: PUSH
78121: LD_EXP 91
78125: PPUSH
78126: LD_VAR 0 1
78130: PPUSH
78131: LD_VAR 0 2
78135: PPUSH
78136: CALL_OW 1
78140: ST_TO_ADDR
// end ;
78141: LD_VAR 0 3
78145: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78146: LD_INT 0
78148: PPUSH
// if not mc_bases [ base ] then
78149: LD_EXP 70
78153: PUSH
78154: LD_VAR 0 1
78158: ARRAY
78159: NOT
78160: IFFALSE 78164
// exit ;
78162: GO 78201
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78164: LD_ADDR_EXP 91
78168: PUSH
78169: LD_EXP 91
78173: PPUSH
78174: LD_VAR 0 1
78178: PPUSH
78179: LD_EXP 91
78183: PUSH
78184: LD_VAR 0 1
78188: ARRAY
78189: PUSH
78190: LD_VAR 0 2
78194: ADD
78195: PPUSH
78196: CALL_OW 1
78200: ST_TO_ADDR
// end ;
78201: LD_VAR 0 3
78205: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78206: LD_INT 0
78208: PPUSH
// if not mc_bases [ base ] then
78209: LD_EXP 70
78213: PUSH
78214: LD_VAR 0 1
78218: ARRAY
78219: NOT
78220: IFFALSE 78224
// exit ;
78222: GO 78278
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78224: LD_ADDR_EXP 92
78228: PUSH
78229: LD_EXP 92
78233: PPUSH
78234: LD_VAR 0 1
78238: PPUSH
78239: LD_VAR 0 2
78243: PPUSH
78244: CALL_OW 1
78248: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78249: LD_ADDR_EXP 81
78253: PUSH
78254: LD_EXP 81
78258: PPUSH
78259: LD_VAR 0 1
78263: PPUSH
78264: LD_VAR 0 2
78268: PUSH
78269: LD_INT 0
78271: PLUS
78272: PPUSH
78273: CALL_OW 1
78277: ST_TO_ADDR
// end ;
78278: LD_VAR 0 3
78282: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78283: LD_INT 0
78285: PPUSH
// if not mc_bases [ base ] then
78286: LD_EXP 70
78290: PUSH
78291: LD_VAR 0 1
78295: ARRAY
78296: NOT
78297: IFFALSE 78301
// exit ;
78299: GO 78326
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78301: LD_ADDR_EXP 81
78305: PUSH
78306: LD_EXP 81
78310: PPUSH
78311: LD_VAR 0 1
78315: PPUSH
78316: LD_VAR 0 2
78320: PPUSH
78321: CALL_OW 1
78325: ST_TO_ADDR
// end ;
78326: LD_VAR 0 3
78330: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78331: LD_INT 0
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
// if not mc_bases [ base ] then
78337: LD_EXP 70
78341: PUSH
78342: LD_VAR 0 1
78346: ARRAY
78347: NOT
78348: IFFALSE 78352
// exit ;
78350: GO 78417
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78352: LD_ADDR_EXP 90
78356: PUSH
78357: LD_EXP 90
78361: PPUSH
78362: LD_VAR 0 1
78366: PUSH
78367: LD_EXP 90
78371: PUSH
78372: LD_VAR 0 1
78376: ARRAY
78377: PUSH
78378: LD_INT 1
78380: PLUS
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PPUSH
78386: LD_VAR 0 1
78390: PUSH
78391: LD_VAR 0 2
78395: PUSH
78396: LD_VAR 0 3
78400: PUSH
78401: LD_VAR 0 4
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: PPUSH
78412: CALL 18597 0 3
78416: ST_TO_ADDR
// end ;
78417: LD_VAR 0 5
78421: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78422: LD_INT 0
78424: PPUSH
// if not mc_bases [ base ] then
78425: LD_EXP 70
78429: PUSH
78430: LD_VAR 0 1
78434: ARRAY
78435: NOT
78436: IFFALSE 78440
// exit ;
78438: GO 78465
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78440: LD_ADDR_EXP 107
78444: PUSH
78445: LD_EXP 107
78449: PPUSH
78450: LD_VAR 0 1
78454: PPUSH
78455: LD_VAR 0 2
78459: PPUSH
78460: CALL_OW 1
78464: ST_TO_ADDR
// end ;
78465: LD_VAR 0 3
78469: RET
// export function MC_GetMinesField ( base ) ; begin
78470: LD_INT 0
78472: PPUSH
// result := mc_mines [ base ] ;
78473: LD_ADDR_VAR 0 2
78477: PUSH
78478: LD_EXP 83
78482: PUSH
78483: LD_VAR 0 1
78487: ARRAY
78488: ST_TO_ADDR
// end ;
78489: LD_VAR 0 2
78493: RET
// export function MC_GetProduceList ( base ) ; begin
78494: LD_INT 0
78496: PPUSH
// result := mc_produce [ base ] ;
78497: LD_ADDR_VAR 0 2
78501: PUSH
78502: LD_EXP 91
78506: PUSH
78507: LD_VAR 0 1
78511: ARRAY
78512: ST_TO_ADDR
// end ;
78513: LD_VAR 0 2
78517: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78518: LD_INT 0
78520: PPUSH
78521: PPUSH
// if not mc_bases then
78522: LD_EXP 70
78526: NOT
78527: IFFALSE 78531
// exit ;
78529: GO 78596
// if mc_bases [ base ] then
78531: LD_EXP 70
78535: PUSH
78536: LD_VAR 0 1
78540: ARRAY
78541: IFFALSE 78596
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78543: LD_ADDR_VAR 0 3
78547: PUSH
78548: LD_EXP 70
78552: PUSH
78553: LD_VAR 0 1
78557: ARRAY
78558: PPUSH
78559: LD_INT 30
78561: PUSH
78562: LD_VAR 0 2
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: PPUSH
78571: CALL_OW 72
78575: ST_TO_ADDR
// if result then
78576: LD_VAR 0 3
78580: IFFALSE 78596
// result := result [ 1 ] ;
78582: LD_ADDR_VAR 0 3
78586: PUSH
78587: LD_VAR 0 3
78591: PUSH
78592: LD_INT 1
78594: ARRAY
78595: ST_TO_ADDR
// end ; end ;
78596: LD_VAR 0 3
78600: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
// if not mc_bases then
78605: LD_EXP 70
78609: NOT
78610: IFFALSE 78614
// exit ;
78612: GO 78659
// if mc_bases [ base ] then
78614: LD_EXP 70
78618: PUSH
78619: LD_VAR 0 1
78623: ARRAY
78624: IFFALSE 78659
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78626: LD_ADDR_VAR 0 3
78630: PUSH
78631: LD_EXP 70
78635: PUSH
78636: LD_VAR 0 1
78640: ARRAY
78641: PPUSH
78642: LD_INT 30
78644: PUSH
78645: LD_VAR 0 2
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PPUSH
78654: CALL_OW 72
78658: ST_TO_ADDR
// end ;
78659: LD_VAR 0 3
78663: RET
// export function MC_SetTame ( base , area ) ; begin
78664: LD_INT 0
78666: PPUSH
// if not mc_bases or not base then
78667: LD_EXP 70
78671: NOT
78672: PUSH
78673: LD_VAR 0 1
78677: NOT
78678: OR
78679: IFFALSE 78683
// exit ;
78681: GO 78708
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78683: LD_ADDR_EXP 98
78687: PUSH
78688: LD_EXP 98
78692: PPUSH
78693: LD_VAR 0 1
78697: PPUSH
78698: LD_VAR 0 2
78702: PPUSH
78703: CALL_OW 1
78707: ST_TO_ADDR
// end ;
78708: LD_VAR 0 3
78712: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78713: LD_INT 0
78715: PPUSH
78716: PPUSH
// if not mc_bases or not base then
78717: LD_EXP 70
78721: NOT
78722: PUSH
78723: LD_VAR 0 1
78727: NOT
78728: OR
78729: IFFALSE 78733
// exit ;
78731: GO 78835
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78733: LD_ADDR_VAR 0 4
78737: PUSH
78738: LD_EXP 70
78742: PUSH
78743: LD_VAR 0 1
78747: ARRAY
78748: PPUSH
78749: LD_INT 30
78751: PUSH
78752: LD_VAR 0 2
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PPUSH
78761: CALL_OW 72
78765: ST_TO_ADDR
// if not tmp then
78766: LD_VAR 0 4
78770: NOT
78771: IFFALSE 78775
// exit ;
78773: GO 78835
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78775: LD_ADDR_EXP 102
78779: PUSH
78780: LD_EXP 102
78784: PPUSH
78785: LD_VAR 0 1
78789: PPUSH
78790: LD_EXP 102
78794: PUSH
78795: LD_VAR 0 1
78799: ARRAY
78800: PPUSH
78801: LD_EXP 102
78805: PUSH
78806: LD_VAR 0 1
78810: ARRAY
78811: PUSH
78812: LD_INT 1
78814: PLUS
78815: PPUSH
78816: LD_VAR 0 4
78820: PUSH
78821: LD_INT 1
78823: ARRAY
78824: PPUSH
78825: CALL_OW 2
78829: PPUSH
78830: CALL_OW 1
78834: ST_TO_ADDR
// end ;
78835: LD_VAR 0 3
78839: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78840: LD_INT 0
78842: PPUSH
78843: PPUSH
// if not mc_bases or not base or not kinds then
78844: LD_EXP 70
78848: NOT
78849: PUSH
78850: LD_VAR 0 1
78854: NOT
78855: OR
78856: PUSH
78857: LD_VAR 0 2
78861: NOT
78862: OR
78863: IFFALSE 78867
// exit ;
78865: GO 78928
// for i in kinds do
78867: LD_ADDR_VAR 0 4
78871: PUSH
78872: LD_VAR 0 2
78876: PUSH
78877: FOR_IN
78878: IFFALSE 78926
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78880: LD_ADDR_EXP 104
78884: PUSH
78885: LD_EXP 104
78889: PPUSH
78890: LD_VAR 0 1
78894: PUSH
78895: LD_EXP 104
78899: PUSH
78900: LD_VAR 0 1
78904: ARRAY
78905: PUSH
78906: LD_INT 1
78908: PLUS
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PPUSH
78914: LD_VAR 0 4
78918: PPUSH
78919: CALL 18597 0 3
78923: ST_TO_ADDR
78924: GO 78877
78926: POP
78927: POP
// end ;
78928: LD_VAR 0 3
78932: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78933: LD_INT 0
78935: PPUSH
// if not mc_bases or not base or not areas then
78936: LD_EXP 70
78940: NOT
78941: PUSH
78942: LD_VAR 0 1
78946: NOT
78947: OR
78948: PUSH
78949: LD_VAR 0 2
78953: NOT
78954: OR
78955: IFFALSE 78959
// exit ;
78957: GO 78984
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78959: LD_ADDR_EXP 88
78963: PUSH
78964: LD_EXP 88
78968: PPUSH
78969: LD_VAR 0 1
78973: PPUSH
78974: LD_VAR 0 2
78978: PPUSH
78979: CALL_OW 1
78983: ST_TO_ADDR
// end ;
78984: LD_VAR 0 3
78988: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78989: LD_INT 0
78991: PPUSH
// if not mc_bases or not base or not teleports_exit then
78992: LD_EXP 70
78996: NOT
78997: PUSH
78998: LD_VAR 0 1
79002: NOT
79003: OR
79004: PUSH
79005: LD_VAR 0 2
79009: NOT
79010: OR
79011: IFFALSE 79015
// exit ;
79013: GO 79040
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79015: LD_ADDR_EXP 105
79019: PUSH
79020: LD_EXP 105
79024: PPUSH
79025: LD_VAR 0 1
79029: PPUSH
79030: LD_VAR 0 2
79034: PPUSH
79035: CALL_OW 1
79039: ST_TO_ADDR
// end ;
79040: LD_VAR 0 3
79044: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79045: LD_INT 0
79047: PPUSH
79048: PPUSH
79049: PPUSH
// if not mc_bases or not base or not ext_list then
79050: LD_EXP 70
79054: NOT
79055: PUSH
79056: LD_VAR 0 1
79060: NOT
79061: OR
79062: PUSH
79063: LD_VAR 0 5
79067: NOT
79068: OR
79069: IFFALSE 79073
// exit ;
79071: GO 79246
// tmp := GetFacExtXYD ( x , y , d ) ;
79073: LD_ADDR_VAR 0 8
79077: PUSH
79078: LD_VAR 0 2
79082: PPUSH
79083: LD_VAR 0 3
79087: PPUSH
79088: LD_VAR 0 4
79092: PPUSH
79093: CALL 47931 0 3
79097: ST_TO_ADDR
// if not tmp then
79098: LD_VAR 0 8
79102: NOT
79103: IFFALSE 79107
// exit ;
79105: GO 79246
// for i in tmp do
79107: LD_ADDR_VAR 0 7
79111: PUSH
79112: LD_VAR 0 8
79116: PUSH
79117: FOR_IN
79118: IFFALSE 79244
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79120: LD_ADDR_EXP 75
79124: PUSH
79125: LD_EXP 75
79129: PPUSH
79130: LD_VAR 0 1
79134: PPUSH
79135: LD_EXP 75
79139: PUSH
79140: LD_VAR 0 1
79144: ARRAY
79145: PPUSH
79146: LD_EXP 75
79150: PUSH
79151: LD_VAR 0 1
79155: ARRAY
79156: PUSH
79157: LD_INT 1
79159: PLUS
79160: PPUSH
79161: LD_VAR 0 5
79165: PUSH
79166: LD_INT 1
79168: ARRAY
79169: PUSH
79170: LD_VAR 0 7
79174: PUSH
79175: LD_INT 1
79177: ARRAY
79178: PUSH
79179: LD_VAR 0 7
79183: PUSH
79184: LD_INT 2
79186: ARRAY
79187: PUSH
79188: LD_VAR 0 7
79192: PUSH
79193: LD_INT 3
79195: ARRAY
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: PPUSH
79203: CALL_OW 2
79207: PPUSH
79208: CALL_OW 1
79212: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79213: LD_ADDR_VAR 0 5
79217: PUSH
79218: LD_VAR 0 5
79222: PPUSH
79223: LD_INT 1
79225: PPUSH
79226: CALL_OW 3
79230: ST_TO_ADDR
// if not ext_list then
79231: LD_VAR 0 5
79235: NOT
79236: IFFALSE 79242
// exit ;
79238: POP
79239: POP
79240: GO 79246
// end ;
79242: GO 79117
79244: POP
79245: POP
// end ;
79246: LD_VAR 0 6
79250: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79251: LD_INT 0
79253: PPUSH
// if not mc_bases or not base or not weapon_list then
79254: LD_EXP 70
79258: NOT
79259: PUSH
79260: LD_VAR 0 1
79264: NOT
79265: OR
79266: PUSH
79267: LD_VAR 0 2
79271: NOT
79272: OR
79273: IFFALSE 79277
// exit ;
79275: GO 79302
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79277: LD_ADDR_EXP 109
79281: PUSH
79282: LD_EXP 109
79286: PPUSH
79287: LD_VAR 0 1
79291: PPUSH
79292: LD_VAR 0 2
79296: PPUSH
79297: CALL_OW 1
79301: ST_TO_ADDR
// end ;
79302: LD_VAR 0 3
79306: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79307: LD_INT 0
79309: PPUSH
// if not mc_bases or not base or not tech_list then
79310: LD_EXP 70
79314: NOT
79315: PUSH
79316: LD_VAR 0 1
79320: NOT
79321: OR
79322: PUSH
79323: LD_VAR 0 2
79327: NOT
79328: OR
79329: IFFALSE 79333
// exit ;
79331: GO 79358
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79333: LD_ADDR_EXP 97
79337: PUSH
79338: LD_EXP 97
79342: PPUSH
79343: LD_VAR 0 1
79347: PPUSH
79348: LD_VAR 0 2
79352: PPUSH
79353: CALL_OW 1
79357: ST_TO_ADDR
// end ;
79358: LD_VAR 0 3
79362: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79363: LD_INT 0
79365: PPUSH
// if not mc_bases or not parking_area or not base then
79366: LD_EXP 70
79370: NOT
79371: PUSH
79372: LD_VAR 0 2
79376: NOT
79377: OR
79378: PUSH
79379: LD_VAR 0 1
79383: NOT
79384: OR
79385: IFFALSE 79389
// exit ;
79387: GO 79414
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79389: LD_ADDR_EXP 94
79393: PUSH
79394: LD_EXP 94
79398: PPUSH
79399: LD_VAR 0 1
79403: PPUSH
79404: LD_VAR 0 2
79408: PPUSH
79409: CALL_OW 1
79413: ST_TO_ADDR
// end ;
79414: LD_VAR 0 3
79418: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79419: LD_INT 0
79421: PPUSH
// if not mc_bases or not base or not scan_area then
79422: LD_EXP 70
79426: NOT
79427: PUSH
79428: LD_VAR 0 1
79432: NOT
79433: OR
79434: PUSH
79435: LD_VAR 0 2
79439: NOT
79440: OR
79441: IFFALSE 79445
// exit ;
79443: GO 79470
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79445: LD_ADDR_EXP 95
79449: PUSH
79450: LD_EXP 95
79454: PPUSH
79455: LD_VAR 0 1
79459: PPUSH
79460: LD_VAR 0 2
79464: PPUSH
79465: CALL_OW 1
79469: ST_TO_ADDR
// end ;
79470: LD_VAR 0 3
79474: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79475: LD_INT 0
79477: PPUSH
79478: PPUSH
// if not mc_bases or not base then
79479: LD_EXP 70
79483: NOT
79484: PUSH
79485: LD_VAR 0 1
79489: NOT
79490: OR
79491: IFFALSE 79495
// exit ;
79493: GO 79559
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79495: LD_ADDR_VAR 0 3
79499: PUSH
79500: LD_INT 1
79502: PUSH
79503: LD_INT 2
79505: PUSH
79506: LD_INT 3
79508: PUSH
79509: LD_INT 4
79511: PUSH
79512: LD_INT 11
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79522: LD_ADDR_EXP 97
79526: PUSH
79527: LD_EXP 97
79531: PPUSH
79532: LD_VAR 0 1
79536: PPUSH
79537: LD_EXP 97
79541: PUSH
79542: LD_VAR 0 1
79546: ARRAY
79547: PUSH
79548: LD_VAR 0 3
79552: DIFF
79553: PPUSH
79554: CALL_OW 1
79558: ST_TO_ADDR
// end ;
79559: LD_VAR 0 2
79563: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79564: LD_INT 0
79566: PPUSH
// result := mc_vehicles [ base ] ;
79567: LD_ADDR_VAR 0 3
79571: PUSH
79572: LD_EXP 89
79576: PUSH
79577: LD_VAR 0 1
79581: ARRAY
79582: ST_TO_ADDR
// if onlyCombat then
79583: LD_VAR 0 2
79587: IFFALSE 79765
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79589: LD_ADDR_VAR 0 3
79593: PUSH
79594: LD_VAR 0 3
79598: PUSH
79599: LD_VAR 0 3
79603: PPUSH
79604: LD_INT 2
79606: PUSH
79607: LD_INT 34
79609: PUSH
79610: LD_INT 12
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 34
79619: PUSH
79620: LD_INT 51
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 34
79629: PUSH
79630: LD_EXP 49
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 34
79641: PUSH
79642: LD_INT 32
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 34
79651: PUSH
79652: LD_INT 13
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 34
79661: PUSH
79662: LD_INT 52
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 34
79671: PUSH
79672: LD_EXP 54
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 34
79683: PUSH
79684: LD_INT 14
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 34
79693: PUSH
79694: LD_INT 53
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 34
79703: PUSH
79704: LD_EXP 48
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 34
79715: PUSH
79716: LD_INT 31
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 34
79725: PUSH
79726: LD_INT 48
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 34
79735: PUSH
79736: LD_INT 8
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: PPUSH
79759: CALL_OW 72
79763: DIFF
79764: ST_TO_ADDR
// end ; end_of_file
79765: LD_VAR 0 3
79769: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79770: LD_INT 0
79772: PPUSH
79773: PPUSH
79774: PPUSH
// if not mc_bases or not skirmish then
79775: LD_EXP 70
79779: NOT
79780: PUSH
79781: LD_EXP 68
79785: NOT
79786: OR
79787: IFFALSE 79791
// exit ;
79789: GO 79956
// for i = 1 to mc_bases do
79791: LD_ADDR_VAR 0 4
79795: PUSH
79796: DOUBLE
79797: LD_INT 1
79799: DEC
79800: ST_TO_ADDR
79801: LD_EXP 70
79805: PUSH
79806: FOR_TO
79807: IFFALSE 79954
// begin if sci in mc_bases [ i ] then
79809: LD_VAR 0 2
79813: PUSH
79814: LD_EXP 70
79818: PUSH
79819: LD_VAR 0 4
79823: ARRAY
79824: IN
79825: IFFALSE 79952
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79827: LD_ADDR_EXP 99
79831: PUSH
79832: LD_EXP 99
79836: PPUSH
79837: LD_VAR 0 4
79841: PUSH
79842: LD_EXP 99
79846: PUSH
79847: LD_VAR 0 4
79851: ARRAY
79852: PUSH
79853: LD_INT 1
79855: PLUS
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PPUSH
79861: LD_VAR 0 1
79865: PPUSH
79866: CALL 18597 0 3
79870: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79871: LD_ADDR_VAR 0 5
79875: PUSH
79876: LD_EXP 70
79880: PUSH
79881: LD_VAR 0 4
79885: ARRAY
79886: PPUSH
79887: LD_INT 2
79889: PUSH
79890: LD_INT 30
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 30
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: LIST
79914: PPUSH
79915: CALL_OW 72
79919: PPUSH
79920: LD_VAR 0 1
79924: PPUSH
79925: CALL_OW 74
79929: ST_TO_ADDR
// if tmp then
79930: LD_VAR 0 5
79934: IFFALSE 79950
// ComStandNearbyBuilding ( ape , tmp ) ;
79936: LD_VAR 0 1
79940: PPUSH
79941: LD_VAR 0 5
79945: PPUSH
79946: CALL 15175 0 2
// break ;
79950: GO 79954
// end ; end ;
79952: GO 79806
79954: POP
79955: POP
// end ;
79956: LD_VAR 0 3
79960: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79961: LD_INT 0
79963: PPUSH
79964: PPUSH
79965: PPUSH
// if not mc_bases or not skirmish then
79966: LD_EXP 70
79970: NOT
79971: PUSH
79972: LD_EXP 68
79976: NOT
79977: OR
79978: IFFALSE 79982
// exit ;
79980: GO 80071
// for i = 1 to mc_bases do
79982: LD_ADDR_VAR 0 4
79986: PUSH
79987: DOUBLE
79988: LD_INT 1
79990: DEC
79991: ST_TO_ADDR
79992: LD_EXP 70
79996: PUSH
79997: FOR_TO
79998: IFFALSE 80069
// begin if building in mc_busy_turret_list [ i ] then
80000: LD_VAR 0 1
80004: PUSH
80005: LD_EXP 80
80009: PUSH
80010: LD_VAR 0 4
80014: ARRAY
80015: IN
80016: IFFALSE 80067
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80018: LD_ADDR_VAR 0 5
80022: PUSH
80023: LD_EXP 80
80027: PUSH
80028: LD_VAR 0 4
80032: ARRAY
80033: PUSH
80034: LD_VAR 0 1
80038: DIFF
80039: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80040: LD_ADDR_EXP 80
80044: PUSH
80045: LD_EXP 80
80049: PPUSH
80050: LD_VAR 0 4
80054: PPUSH
80055: LD_VAR 0 5
80059: PPUSH
80060: CALL_OW 1
80064: ST_TO_ADDR
// break ;
80065: GO 80069
// end ; end ;
80067: GO 79997
80069: POP
80070: POP
// end ;
80071: LD_VAR 0 3
80075: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80076: LD_INT 0
80078: PPUSH
80079: PPUSH
80080: PPUSH
// if not mc_bases or not skirmish then
80081: LD_EXP 70
80085: NOT
80086: PUSH
80087: LD_EXP 68
80091: NOT
80092: OR
80093: IFFALSE 80097
// exit ;
80095: GO 80296
// for i = 1 to mc_bases do
80097: LD_ADDR_VAR 0 5
80101: PUSH
80102: DOUBLE
80103: LD_INT 1
80105: DEC
80106: ST_TO_ADDR
80107: LD_EXP 70
80111: PUSH
80112: FOR_TO
80113: IFFALSE 80294
// if building in mc_bases [ i ] then
80115: LD_VAR 0 1
80119: PUSH
80120: LD_EXP 70
80124: PUSH
80125: LD_VAR 0 5
80129: ARRAY
80130: IN
80131: IFFALSE 80292
// begin tmp := mc_bases [ i ] diff building ;
80133: LD_ADDR_VAR 0 6
80137: PUSH
80138: LD_EXP 70
80142: PUSH
80143: LD_VAR 0 5
80147: ARRAY
80148: PUSH
80149: LD_VAR 0 1
80153: DIFF
80154: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80155: LD_ADDR_EXP 70
80159: PUSH
80160: LD_EXP 70
80164: PPUSH
80165: LD_VAR 0 5
80169: PPUSH
80170: LD_VAR 0 6
80174: PPUSH
80175: CALL_OW 1
80179: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80180: LD_VAR 0 1
80184: PUSH
80185: LD_EXP 78
80189: PUSH
80190: LD_VAR 0 5
80194: ARRAY
80195: IN
80196: IFFALSE 80235
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80198: LD_ADDR_EXP 78
80202: PUSH
80203: LD_EXP 78
80207: PPUSH
80208: LD_VAR 0 5
80212: PPUSH
80213: LD_EXP 78
80217: PUSH
80218: LD_VAR 0 5
80222: ARRAY
80223: PUSH
80224: LD_VAR 0 1
80228: DIFF
80229: PPUSH
80230: CALL_OW 1
80234: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80235: LD_VAR 0 1
80239: PUSH
80240: LD_EXP 79
80244: PUSH
80245: LD_VAR 0 5
80249: ARRAY
80250: IN
80251: IFFALSE 80290
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80253: LD_ADDR_EXP 79
80257: PUSH
80258: LD_EXP 79
80262: PPUSH
80263: LD_VAR 0 5
80267: PPUSH
80268: LD_EXP 79
80272: PUSH
80273: LD_VAR 0 5
80277: ARRAY
80278: PUSH
80279: LD_VAR 0 1
80283: DIFF
80284: PPUSH
80285: CALL_OW 1
80289: ST_TO_ADDR
// break ;
80290: GO 80294
// end ;
80292: GO 80112
80294: POP
80295: POP
// end ;
80296: LD_VAR 0 4
80300: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80301: LD_INT 0
80303: PPUSH
80304: PPUSH
80305: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80306: LD_EXP 70
80310: NOT
80311: PUSH
80312: LD_EXP 68
80316: NOT
80317: OR
80318: PUSH
80319: LD_VAR 0 3
80323: PUSH
80324: LD_EXP 96
80328: IN
80329: NOT
80330: OR
80331: IFFALSE 80335
// exit ;
80333: GO 80458
// for i = 1 to mc_vehicles do
80335: LD_ADDR_VAR 0 6
80339: PUSH
80340: DOUBLE
80341: LD_INT 1
80343: DEC
80344: ST_TO_ADDR
80345: LD_EXP 89
80349: PUSH
80350: FOR_TO
80351: IFFALSE 80456
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80353: LD_VAR 0 2
80357: PUSH
80358: LD_EXP 89
80362: PUSH
80363: LD_VAR 0 6
80367: ARRAY
80368: IN
80369: PUSH
80370: LD_VAR 0 1
80374: PUSH
80375: LD_EXP 89
80379: PUSH
80380: LD_VAR 0 6
80384: ARRAY
80385: IN
80386: OR
80387: IFFALSE 80454
// begin tmp := mc_vehicles [ i ] diff old ;
80389: LD_ADDR_VAR 0 7
80393: PUSH
80394: LD_EXP 89
80398: PUSH
80399: LD_VAR 0 6
80403: ARRAY
80404: PUSH
80405: LD_VAR 0 2
80409: DIFF
80410: ST_TO_ADDR
// tmp := tmp diff new ;
80411: LD_ADDR_VAR 0 7
80415: PUSH
80416: LD_VAR 0 7
80420: PUSH
80421: LD_VAR 0 1
80425: DIFF
80426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80427: LD_ADDR_EXP 89
80431: PUSH
80432: LD_EXP 89
80436: PPUSH
80437: LD_VAR 0 6
80441: PPUSH
80442: LD_VAR 0 7
80446: PPUSH
80447: CALL_OW 1
80451: ST_TO_ADDR
// break ;
80452: GO 80456
// end ;
80454: GO 80350
80456: POP
80457: POP
// end ;
80458: LD_VAR 0 5
80462: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80463: LD_INT 0
80465: PPUSH
80466: PPUSH
80467: PPUSH
80468: PPUSH
// if not mc_bases or not skirmish then
80469: LD_EXP 70
80473: NOT
80474: PUSH
80475: LD_EXP 68
80479: NOT
80480: OR
80481: IFFALSE 80485
// exit ;
80483: GO 80877
// side := GetSide ( vehicle ) ;
80485: LD_ADDR_VAR 0 5
80489: PUSH
80490: LD_VAR 0 1
80494: PPUSH
80495: CALL_OW 255
80499: ST_TO_ADDR
// for i = 1 to mc_bases do
80500: LD_ADDR_VAR 0 4
80504: PUSH
80505: DOUBLE
80506: LD_INT 1
80508: DEC
80509: ST_TO_ADDR
80510: LD_EXP 70
80514: PUSH
80515: FOR_TO
80516: IFFALSE 80875
// begin if factory in mc_bases [ i ] then
80518: LD_VAR 0 2
80522: PUSH
80523: LD_EXP 70
80527: PUSH
80528: LD_VAR 0 4
80532: ARRAY
80533: IN
80534: IFFALSE 80873
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80536: LD_EXP 92
80540: PUSH
80541: LD_VAR 0 4
80545: ARRAY
80546: PUSH
80547: LD_EXP 81
80551: PUSH
80552: LD_VAR 0 4
80556: ARRAY
80557: LESS
80558: PUSH
80559: LD_VAR 0 1
80563: PPUSH
80564: CALL_OW 264
80568: PUSH
80569: LD_INT 31
80571: PUSH
80572: LD_INT 32
80574: PUSH
80575: LD_INT 51
80577: PUSH
80578: LD_EXP 49
80582: PUSH
80583: LD_INT 12
80585: PUSH
80586: LD_INT 30
80588: PUSH
80589: LD_EXP 48
80593: PUSH
80594: LD_INT 11
80596: PUSH
80597: LD_INT 53
80599: PUSH
80600: LD_INT 14
80602: PUSH
80603: LD_EXP 52
80607: PUSH
80608: LD_INT 29
80610: PUSH
80611: LD_EXP 50
80615: PUSH
80616: LD_INT 13
80618: PUSH
80619: LD_INT 52
80621: PUSH
80622: LD_EXP 54
80626: PUSH
80627: LD_INT 48
80629: PUSH
80630: LD_INT 8
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: IN
80653: NOT
80654: AND
80655: IFFALSE 80703
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80657: LD_ADDR_EXP 92
80661: PUSH
80662: LD_EXP 92
80666: PPUSH
80667: LD_VAR 0 4
80671: PUSH
80672: LD_EXP 92
80676: PUSH
80677: LD_VAR 0 4
80681: ARRAY
80682: PUSH
80683: LD_INT 1
80685: PLUS
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PPUSH
80691: LD_VAR 0 1
80695: PPUSH
80696: CALL 18597 0 3
80700: ST_TO_ADDR
80701: GO 80747
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80703: LD_ADDR_EXP 89
80707: PUSH
80708: LD_EXP 89
80712: PPUSH
80713: LD_VAR 0 4
80717: PUSH
80718: LD_EXP 89
80722: PUSH
80723: LD_VAR 0 4
80727: ARRAY
80728: PUSH
80729: LD_INT 1
80731: PLUS
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PPUSH
80737: LD_VAR 0 1
80741: PPUSH
80742: CALL 18597 0 3
80746: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80747: LD_VAR 0 1
80751: PPUSH
80752: CALL_OW 263
80756: PUSH
80757: LD_INT 2
80759: EQUAL
80760: IFFALSE 80789
// begin repeat wait ( 0 0$3 ) ;
80762: LD_INT 105
80764: PPUSH
80765: CALL_OW 67
// Connect ( vehicle ) ;
80769: LD_VAR 0 1
80773: PPUSH
80774: CALL 21568 0 1
// until IsControledBy ( vehicle ) ;
80778: LD_VAR 0 1
80782: PPUSH
80783: CALL_OW 312
80787: IFFALSE 80762
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80789: LD_VAR 0 1
80793: PPUSH
80794: LD_EXP 94
80798: PUSH
80799: LD_VAR 0 4
80803: ARRAY
80804: PPUSH
80805: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80809: LD_VAR 0 1
80813: PPUSH
80814: CALL_OW 263
80818: PUSH
80819: LD_INT 1
80821: NONEQUAL
80822: IFFALSE 80826
// break ;
80824: GO 80875
// repeat wait ( 0 0$1 ) ;
80826: LD_INT 35
80828: PPUSH
80829: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80833: LD_VAR 0 1
80837: PPUSH
80838: LD_EXP 94
80842: PUSH
80843: LD_VAR 0 4
80847: ARRAY
80848: PPUSH
80849: CALL_OW 308
80853: IFFALSE 80826
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80855: LD_VAR 0 1
80859: PPUSH
80860: CALL_OW 311
80864: PPUSH
80865: CALL_OW 121
// exit ;
80869: POP
80870: POP
80871: GO 80877
// end ; end ;
80873: GO 80515
80875: POP
80876: POP
// end ;
80877: LD_VAR 0 3
80881: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80882: LD_INT 0
80884: PPUSH
80885: PPUSH
80886: PPUSH
80887: PPUSH
// if not mc_bases or not skirmish then
80888: LD_EXP 70
80892: NOT
80893: PUSH
80894: LD_EXP 68
80898: NOT
80899: OR
80900: IFFALSE 80904
// exit ;
80902: GO 81257
// repeat wait ( 0 0$1 ) ;
80904: LD_INT 35
80906: PPUSH
80907: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80911: LD_VAR 0 2
80915: PPUSH
80916: LD_VAR 0 3
80920: PPUSH
80921: CALL_OW 284
80925: IFFALSE 80904
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80927: LD_VAR 0 2
80931: PPUSH
80932: LD_VAR 0 3
80936: PPUSH
80937: CALL_OW 283
80941: PUSH
80942: LD_INT 4
80944: EQUAL
80945: IFFALSE 80949
// exit ;
80947: GO 81257
// for i = 1 to mc_bases do
80949: LD_ADDR_VAR 0 7
80953: PUSH
80954: DOUBLE
80955: LD_INT 1
80957: DEC
80958: ST_TO_ADDR
80959: LD_EXP 70
80963: PUSH
80964: FOR_TO
80965: IFFALSE 81255
// begin if mc_crates_area [ i ] then
80967: LD_EXP 88
80971: PUSH
80972: LD_VAR 0 7
80976: ARRAY
80977: IFFALSE 81088
// for j in mc_crates_area [ i ] do
80979: LD_ADDR_VAR 0 8
80983: PUSH
80984: LD_EXP 88
80988: PUSH
80989: LD_VAR 0 7
80993: ARRAY
80994: PUSH
80995: FOR_IN
80996: IFFALSE 81086
// if InArea ( x , y , j ) then
80998: LD_VAR 0 2
81002: PPUSH
81003: LD_VAR 0 3
81007: PPUSH
81008: LD_VAR 0 8
81012: PPUSH
81013: CALL_OW 309
81017: IFFALSE 81084
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81019: LD_ADDR_EXP 86
81023: PUSH
81024: LD_EXP 86
81028: PPUSH
81029: LD_VAR 0 7
81033: PUSH
81034: LD_EXP 86
81038: PUSH
81039: LD_VAR 0 7
81043: ARRAY
81044: PUSH
81045: LD_INT 1
81047: PLUS
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PPUSH
81053: LD_VAR 0 4
81057: PUSH
81058: LD_VAR 0 2
81062: PUSH
81063: LD_VAR 0 3
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: LIST
81072: PPUSH
81073: CALL 18597 0 3
81077: ST_TO_ADDR
// exit ;
81078: POP
81079: POP
81080: POP
81081: POP
81082: GO 81257
// end ;
81084: GO 80995
81086: POP
81087: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81088: LD_ADDR_VAR 0 9
81092: PUSH
81093: LD_EXP 70
81097: PUSH
81098: LD_VAR 0 7
81102: ARRAY
81103: PPUSH
81104: LD_INT 2
81106: PUSH
81107: LD_INT 30
81109: PUSH
81110: LD_INT 0
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 30
81119: PUSH
81120: LD_INT 1
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: LIST
81131: PPUSH
81132: CALL_OW 72
81136: ST_TO_ADDR
// if not depot then
81137: LD_VAR 0 9
81141: NOT
81142: IFFALSE 81146
// continue ;
81144: GO 80964
// for j in depot do
81146: LD_ADDR_VAR 0 8
81150: PUSH
81151: LD_VAR 0 9
81155: PUSH
81156: FOR_IN
81157: IFFALSE 81251
// if GetDistUnitXY ( j , x , y ) < 30 then
81159: LD_VAR 0 8
81163: PPUSH
81164: LD_VAR 0 2
81168: PPUSH
81169: LD_VAR 0 3
81173: PPUSH
81174: CALL_OW 297
81178: PUSH
81179: LD_INT 30
81181: LESS
81182: IFFALSE 81249
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81184: LD_ADDR_EXP 86
81188: PUSH
81189: LD_EXP 86
81193: PPUSH
81194: LD_VAR 0 7
81198: PUSH
81199: LD_EXP 86
81203: PUSH
81204: LD_VAR 0 7
81208: ARRAY
81209: PUSH
81210: LD_INT 1
81212: PLUS
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PPUSH
81218: LD_VAR 0 4
81222: PUSH
81223: LD_VAR 0 2
81227: PUSH
81228: LD_VAR 0 3
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: LIST
81237: PPUSH
81238: CALL 18597 0 3
81242: ST_TO_ADDR
// exit ;
81243: POP
81244: POP
81245: POP
81246: POP
81247: GO 81257
// end ;
81249: GO 81156
81251: POP
81252: POP
// end ;
81253: GO 80964
81255: POP
81256: POP
// end ;
81257: LD_VAR 0 6
81261: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81262: LD_INT 0
81264: PPUSH
81265: PPUSH
81266: PPUSH
81267: PPUSH
// if not mc_bases or not skirmish then
81268: LD_EXP 70
81272: NOT
81273: PUSH
81274: LD_EXP 68
81278: NOT
81279: OR
81280: IFFALSE 81284
// exit ;
81282: GO 81561
// side := GetSide ( lab ) ;
81284: LD_ADDR_VAR 0 4
81288: PUSH
81289: LD_VAR 0 2
81293: PPUSH
81294: CALL_OW 255
81298: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81299: LD_VAR 0 4
81303: PUSH
81304: LD_EXP 96
81308: IN
81309: NOT
81310: PUSH
81311: LD_EXP 97
81315: NOT
81316: OR
81317: PUSH
81318: LD_EXP 70
81322: NOT
81323: OR
81324: IFFALSE 81328
// exit ;
81326: GO 81561
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81328: LD_ADDR_EXP 97
81332: PUSH
81333: LD_EXP 97
81337: PPUSH
81338: LD_VAR 0 4
81342: PPUSH
81343: LD_EXP 97
81347: PUSH
81348: LD_VAR 0 4
81352: ARRAY
81353: PUSH
81354: LD_VAR 0 1
81358: DIFF
81359: PPUSH
81360: CALL_OW 1
81364: ST_TO_ADDR
// for i = 1 to mc_bases do
81365: LD_ADDR_VAR 0 5
81369: PUSH
81370: DOUBLE
81371: LD_INT 1
81373: DEC
81374: ST_TO_ADDR
81375: LD_EXP 70
81379: PUSH
81380: FOR_TO
81381: IFFALSE 81559
// begin if lab in mc_bases [ i ] then
81383: LD_VAR 0 2
81387: PUSH
81388: LD_EXP 70
81392: PUSH
81393: LD_VAR 0 5
81397: ARRAY
81398: IN
81399: IFFALSE 81557
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81401: LD_VAR 0 1
81405: PUSH
81406: LD_INT 11
81408: PUSH
81409: LD_INT 4
81411: PUSH
81412: LD_INT 3
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: IN
81424: PUSH
81425: LD_EXP 100
81429: PUSH
81430: LD_VAR 0 5
81434: ARRAY
81435: AND
81436: IFFALSE 81557
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81438: LD_ADDR_VAR 0 6
81442: PUSH
81443: LD_EXP 100
81447: PUSH
81448: LD_VAR 0 5
81452: ARRAY
81453: PUSH
81454: LD_INT 1
81456: ARRAY
81457: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81458: LD_ADDR_EXP 100
81462: PUSH
81463: LD_EXP 100
81467: PPUSH
81468: LD_VAR 0 5
81472: PPUSH
81473: EMPTY
81474: PPUSH
81475: CALL_OW 1
81479: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81480: LD_VAR 0 6
81484: PPUSH
81485: LD_INT 0
81487: PPUSH
81488: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81492: LD_VAR 0 6
81496: PPUSH
81497: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81501: LD_ADDR_EXP 99
81505: PUSH
81506: LD_EXP 99
81510: PPUSH
81511: LD_VAR 0 5
81515: PPUSH
81516: LD_EXP 99
81520: PUSH
81521: LD_VAR 0 5
81525: ARRAY
81526: PPUSH
81527: LD_INT 1
81529: PPUSH
81530: LD_VAR 0 6
81534: PPUSH
81535: CALL_OW 2
81539: PPUSH
81540: CALL_OW 1
81544: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81545: LD_VAR 0 5
81549: PPUSH
81550: LD_INT 112
81552: PPUSH
81553: CALL 58080 0 2
// end ; end ; end ;
81557: GO 81380
81559: POP
81560: POP
// end ;
81561: LD_VAR 0 3
81565: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81566: LD_INT 0
81568: PPUSH
81569: PPUSH
81570: PPUSH
81571: PPUSH
81572: PPUSH
81573: PPUSH
81574: PPUSH
81575: PPUSH
// if not mc_bases or not skirmish then
81576: LD_EXP 70
81580: NOT
81581: PUSH
81582: LD_EXP 68
81586: NOT
81587: OR
81588: IFFALSE 81592
// exit ;
81590: GO 82963
// for i = 1 to mc_bases do
81592: LD_ADDR_VAR 0 3
81596: PUSH
81597: DOUBLE
81598: LD_INT 1
81600: DEC
81601: ST_TO_ADDR
81602: LD_EXP 70
81606: PUSH
81607: FOR_TO
81608: IFFALSE 82961
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81610: LD_VAR 0 1
81614: PUSH
81615: LD_EXP 70
81619: PUSH
81620: LD_VAR 0 3
81624: ARRAY
81625: IN
81626: PUSH
81627: LD_VAR 0 1
81631: PUSH
81632: LD_EXP 77
81636: PUSH
81637: LD_VAR 0 3
81641: ARRAY
81642: IN
81643: OR
81644: PUSH
81645: LD_VAR 0 1
81649: PUSH
81650: LD_EXP 92
81654: PUSH
81655: LD_VAR 0 3
81659: ARRAY
81660: IN
81661: OR
81662: PUSH
81663: LD_VAR 0 1
81667: PUSH
81668: LD_EXP 89
81672: PUSH
81673: LD_VAR 0 3
81677: ARRAY
81678: IN
81679: OR
81680: PUSH
81681: LD_VAR 0 1
81685: PUSH
81686: LD_EXP 99
81690: PUSH
81691: LD_VAR 0 3
81695: ARRAY
81696: IN
81697: OR
81698: PUSH
81699: LD_VAR 0 1
81703: PUSH
81704: LD_EXP 100
81708: PUSH
81709: LD_VAR 0 3
81713: ARRAY
81714: IN
81715: OR
81716: IFFALSE 82959
// begin if un in mc_ape [ i ] then
81718: LD_VAR 0 1
81722: PUSH
81723: LD_EXP 99
81727: PUSH
81728: LD_VAR 0 3
81732: ARRAY
81733: IN
81734: IFFALSE 81773
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81736: LD_ADDR_EXP 99
81740: PUSH
81741: LD_EXP 99
81745: PPUSH
81746: LD_VAR 0 3
81750: PPUSH
81751: LD_EXP 99
81755: PUSH
81756: LD_VAR 0 3
81760: ARRAY
81761: PUSH
81762: LD_VAR 0 1
81766: DIFF
81767: PPUSH
81768: CALL_OW 1
81772: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81773: LD_VAR 0 1
81777: PUSH
81778: LD_EXP 100
81782: PUSH
81783: LD_VAR 0 3
81787: ARRAY
81788: IN
81789: IFFALSE 81813
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81791: LD_ADDR_EXP 100
81795: PUSH
81796: LD_EXP 100
81800: PPUSH
81801: LD_VAR 0 3
81805: PPUSH
81806: EMPTY
81807: PPUSH
81808: CALL_OW 1
81812: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81813: LD_VAR 0 1
81817: PPUSH
81818: CALL_OW 247
81822: PUSH
81823: LD_INT 2
81825: EQUAL
81826: PUSH
81827: LD_VAR 0 1
81831: PPUSH
81832: CALL_OW 110
81836: PUSH
81837: LD_INT 20
81839: EQUAL
81840: PUSH
81841: LD_VAR 0 1
81845: PUSH
81846: LD_EXP 92
81850: PUSH
81851: LD_VAR 0 3
81855: ARRAY
81856: IN
81857: OR
81858: PUSH
81859: LD_VAR 0 1
81863: PPUSH
81864: CALL_OW 264
81868: PUSH
81869: LD_INT 12
81871: PUSH
81872: LD_INT 51
81874: PUSH
81875: LD_EXP 49
81879: PUSH
81880: LD_INT 32
81882: PUSH
81883: LD_INT 13
81885: PUSH
81886: LD_INT 52
81888: PUSH
81889: LD_INT 31
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: LIST
81898: LIST
81899: LIST
81900: IN
81901: OR
81902: AND
81903: IFFALSE 82211
// begin if un in mc_defender [ i ] then
81905: LD_VAR 0 1
81909: PUSH
81910: LD_EXP 92
81914: PUSH
81915: LD_VAR 0 3
81919: ARRAY
81920: IN
81921: IFFALSE 81960
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81923: LD_ADDR_EXP 92
81927: PUSH
81928: LD_EXP 92
81932: PPUSH
81933: LD_VAR 0 3
81937: PPUSH
81938: LD_EXP 92
81942: PUSH
81943: LD_VAR 0 3
81947: ARRAY
81948: PUSH
81949: LD_VAR 0 1
81953: DIFF
81954: PPUSH
81955: CALL_OW 1
81959: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81960: LD_ADDR_VAR 0 8
81964: PUSH
81965: LD_VAR 0 3
81969: PPUSH
81970: LD_INT 3
81972: PPUSH
81973: CALL 78601 0 2
81977: ST_TO_ADDR
// if fac then
81978: LD_VAR 0 8
81982: IFFALSE 82211
// begin for j in fac do
81984: LD_ADDR_VAR 0 4
81988: PUSH
81989: LD_VAR 0 8
81993: PUSH
81994: FOR_IN
81995: IFFALSE 82209
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81997: LD_ADDR_VAR 0 9
82001: PUSH
82002: LD_VAR 0 8
82006: PPUSH
82007: LD_VAR 0 1
82011: PPUSH
82012: CALL_OW 265
82016: PPUSH
82017: LD_VAR 0 1
82021: PPUSH
82022: CALL_OW 262
82026: PPUSH
82027: LD_VAR 0 1
82031: PPUSH
82032: CALL_OW 263
82036: PPUSH
82037: LD_VAR 0 1
82041: PPUSH
82042: CALL_OW 264
82046: PPUSH
82047: CALL 16093 0 5
82051: ST_TO_ADDR
// if components then
82052: LD_VAR 0 9
82056: IFFALSE 82207
// begin if GetWeapon ( un ) = ar_control_tower then
82058: LD_VAR 0 1
82062: PPUSH
82063: CALL_OW 264
82067: PUSH
82068: LD_INT 31
82070: EQUAL
82071: IFFALSE 82188
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82073: LD_VAR 0 1
82077: PPUSH
82078: CALL_OW 311
82082: PPUSH
82083: LD_INT 0
82085: PPUSH
82086: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82090: LD_ADDR_EXP 110
82094: PUSH
82095: LD_EXP 110
82099: PPUSH
82100: LD_VAR 0 3
82104: PPUSH
82105: LD_EXP 110
82109: PUSH
82110: LD_VAR 0 3
82114: ARRAY
82115: PUSH
82116: LD_VAR 0 1
82120: PPUSH
82121: CALL_OW 311
82125: DIFF
82126: PPUSH
82127: CALL_OW 1
82131: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82132: LD_ADDR_VAR 0 7
82136: PUSH
82137: LD_EXP 91
82141: PUSH
82142: LD_VAR 0 3
82146: ARRAY
82147: PPUSH
82148: LD_INT 1
82150: PPUSH
82151: LD_VAR 0 9
82155: PPUSH
82156: CALL_OW 2
82160: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82161: LD_ADDR_EXP 91
82165: PUSH
82166: LD_EXP 91
82170: PPUSH
82171: LD_VAR 0 3
82175: PPUSH
82176: LD_VAR 0 7
82180: PPUSH
82181: CALL_OW 1
82185: ST_TO_ADDR
// end else
82186: GO 82205
// MC_InsertProduceList ( i , [ components ] ) ;
82188: LD_VAR 0 3
82192: PPUSH
82193: LD_VAR 0 9
82197: PUSH
82198: EMPTY
82199: LIST
82200: PPUSH
82201: CALL 78146 0 2
// break ;
82205: GO 82209
// end ; end ;
82207: GO 81994
82209: POP
82210: POP
// end ; end ; if GetType ( un ) = unit_building then
82211: LD_VAR 0 1
82215: PPUSH
82216: CALL_OW 247
82220: PUSH
82221: LD_INT 3
82223: EQUAL
82224: IFFALSE 82627
// begin btype := GetBType ( un ) ;
82226: LD_ADDR_VAR 0 5
82230: PUSH
82231: LD_VAR 0 1
82235: PPUSH
82236: CALL_OW 266
82240: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82241: LD_VAR 0 5
82245: PUSH
82246: LD_INT 29
82248: PUSH
82249: LD_INT 30
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: IN
82256: IFFALSE 82329
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82258: LD_VAR 0 1
82262: PPUSH
82263: CALL_OW 250
82267: PPUSH
82268: LD_VAR 0 1
82272: PPUSH
82273: CALL_OW 251
82277: PPUSH
82278: LD_VAR 0 1
82282: PPUSH
82283: CALL_OW 255
82287: PPUSH
82288: CALL_OW 440
82292: NOT
82293: IFFALSE 82329
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82295: LD_VAR 0 1
82299: PPUSH
82300: CALL_OW 250
82304: PPUSH
82305: LD_VAR 0 1
82309: PPUSH
82310: CALL_OW 251
82314: PPUSH
82315: LD_VAR 0 1
82319: PPUSH
82320: CALL_OW 255
82324: PPUSH
82325: CALL_OW 441
// end ; if btype = b_warehouse then
82329: LD_VAR 0 5
82333: PUSH
82334: LD_INT 1
82336: EQUAL
82337: IFFALSE 82355
// begin btype := b_depot ;
82339: LD_ADDR_VAR 0 5
82343: PUSH
82344: LD_INT 0
82346: ST_TO_ADDR
// pos := 1 ;
82347: LD_ADDR_VAR 0 6
82351: PUSH
82352: LD_INT 1
82354: ST_TO_ADDR
// end ; if btype = b_factory then
82355: LD_VAR 0 5
82359: PUSH
82360: LD_INT 3
82362: EQUAL
82363: IFFALSE 82381
// begin btype := b_workshop ;
82365: LD_ADDR_VAR 0 5
82369: PUSH
82370: LD_INT 2
82372: ST_TO_ADDR
// pos := 1 ;
82373: LD_ADDR_VAR 0 6
82377: PUSH
82378: LD_INT 1
82380: ST_TO_ADDR
// end ; if btype = b_barracks then
82381: LD_VAR 0 5
82385: PUSH
82386: LD_INT 5
82388: EQUAL
82389: IFFALSE 82399
// btype := b_armoury ;
82391: LD_ADDR_VAR 0 5
82395: PUSH
82396: LD_INT 4
82398: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82399: LD_VAR 0 5
82403: PUSH
82404: LD_INT 7
82406: PUSH
82407: LD_INT 8
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: IN
82414: IFFALSE 82424
// btype := b_lab ;
82416: LD_ADDR_VAR 0 5
82420: PUSH
82421: LD_INT 6
82423: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82424: LD_ADDR_EXP 75
82428: PUSH
82429: LD_EXP 75
82433: PPUSH
82434: LD_VAR 0 3
82438: PUSH
82439: LD_EXP 75
82443: PUSH
82444: LD_VAR 0 3
82448: ARRAY
82449: PUSH
82450: LD_INT 1
82452: PLUS
82453: PUSH
82454: EMPTY
82455: LIST
82456: LIST
82457: PPUSH
82458: LD_VAR 0 5
82462: PUSH
82463: LD_VAR 0 1
82467: PPUSH
82468: CALL_OW 250
82472: PUSH
82473: LD_VAR 0 1
82477: PPUSH
82478: CALL_OW 251
82482: PUSH
82483: LD_VAR 0 1
82487: PPUSH
82488: CALL_OW 254
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: PPUSH
82499: CALL 18597 0 3
82503: ST_TO_ADDR
// if pos = 1 then
82504: LD_VAR 0 6
82508: PUSH
82509: LD_INT 1
82511: EQUAL
82512: IFFALSE 82627
// begin tmp := mc_build_list [ i ] ;
82514: LD_ADDR_VAR 0 7
82518: PUSH
82519: LD_EXP 75
82523: PUSH
82524: LD_VAR 0 3
82528: ARRAY
82529: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82530: LD_VAR 0 7
82534: PPUSH
82535: LD_INT 2
82537: PUSH
82538: LD_INT 30
82540: PUSH
82541: LD_INT 0
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 30
82550: PUSH
82551: LD_INT 1
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: LIST
82562: PPUSH
82563: CALL_OW 72
82567: IFFALSE 82577
// pos := 2 ;
82569: LD_ADDR_VAR 0 6
82573: PUSH
82574: LD_INT 2
82576: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82577: LD_ADDR_VAR 0 7
82581: PUSH
82582: LD_VAR 0 7
82586: PPUSH
82587: LD_VAR 0 6
82591: PPUSH
82592: LD_VAR 0 7
82596: PPUSH
82597: CALL 18923 0 3
82601: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82602: LD_ADDR_EXP 75
82606: PUSH
82607: LD_EXP 75
82611: PPUSH
82612: LD_VAR 0 3
82616: PPUSH
82617: LD_VAR 0 7
82621: PPUSH
82622: CALL_OW 1
82626: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82627: LD_VAR 0 1
82631: PUSH
82632: LD_EXP 70
82636: PUSH
82637: LD_VAR 0 3
82641: ARRAY
82642: IN
82643: IFFALSE 82682
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82645: LD_ADDR_EXP 70
82649: PUSH
82650: LD_EXP 70
82654: PPUSH
82655: LD_VAR 0 3
82659: PPUSH
82660: LD_EXP 70
82664: PUSH
82665: LD_VAR 0 3
82669: ARRAY
82670: PUSH
82671: LD_VAR 0 1
82675: DIFF
82676: PPUSH
82677: CALL_OW 1
82681: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82682: LD_VAR 0 1
82686: PUSH
82687: LD_EXP 77
82691: PUSH
82692: LD_VAR 0 3
82696: ARRAY
82697: IN
82698: IFFALSE 82737
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82700: LD_ADDR_EXP 77
82704: PUSH
82705: LD_EXP 77
82709: PPUSH
82710: LD_VAR 0 3
82714: PPUSH
82715: LD_EXP 77
82719: PUSH
82720: LD_VAR 0 3
82724: ARRAY
82725: PUSH
82726: LD_VAR 0 1
82730: DIFF
82731: PPUSH
82732: CALL_OW 1
82736: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82737: LD_VAR 0 1
82741: PUSH
82742: LD_EXP 89
82746: PUSH
82747: LD_VAR 0 3
82751: ARRAY
82752: IN
82753: IFFALSE 82792
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82755: LD_ADDR_EXP 89
82759: PUSH
82760: LD_EXP 89
82764: PPUSH
82765: LD_VAR 0 3
82769: PPUSH
82770: LD_EXP 89
82774: PUSH
82775: LD_VAR 0 3
82779: ARRAY
82780: PUSH
82781: LD_VAR 0 1
82785: DIFF
82786: PPUSH
82787: CALL_OW 1
82791: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82792: LD_VAR 0 1
82796: PUSH
82797: LD_EXP 92
82801: PUSH
82802: LD_VAR 0 3
82806: ARRAY
82807: IN
82808: IFFALSE 82847
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82810: LD_ADDR_EXP 92
82814: PUSH
82815: LD_EXP 92
82819: PPUSH
82820: LD_VAR 0 3
82824: PPUSH
82825: LD_EXP 92
82829: PUSH
82830: LD_VAR 0 3
82834: ARRAY
82835: PUSH
82836: LD_VAR 0 1
82840: DIFF
82841: PPUSH
82842: CALL_OW 1
82846: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82847: LD_VAR 0 1
82851: PUSH
82852: LD_EXP 79
82856: PUSH
82857: LD_VAR 0 3
82861: ARRAY
82862: IN
82863: IFFALSE 82902
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82865: LD_ADDR_EXP 79
82869: PUSH
82870: LD_EXP 79
82874: PPUSH
82875: LD_VAR 0 3
82879: PPUSH
82880: LD_EXP 79
82884: PUSH
82885: LD_VAR 0 3
82889: ARRAY
82890: PUSH
82891: LD_VAR 0 1
82895: DIFF
82896: PPUSH
82897: CALL_OW 1
82901: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82902: LD_VAR 0 1
82906: PUSH
82907: LD_EXP 78
82911: PUSH
82912: LD_VAR 0 3
82916: ARRAY
82917: IN
82918: IFFALSE 82957
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82920: LD_ADDR_EXP 78
82924: PUSH
82925: LD_EXP 78
82929: PPUSH
82930: LD_VAR 0 3
82934: PPUSH
82935: LD_EXP 78
82939: PUSH
82940: LD_VAR 0 3
82944: ARRAY
82945: PUSH
82946: LD_VAR 0 1
82950: DIFF
82951: PPUSH
82952: CALL_OW 1
82956: ST_TO_ADDR
// end ; break ;
82957: GO 82961
// end ;
82959: GO 81607
82961: POP
82962: POP
// end ;
82963: LD_VAR 0 2
82967: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82968: LD_INT 0
82970: PPUSH
82971: PPUSH
82972: PPUSH
// if not mc_bases or not skirmish then
82973: LD_EXP 70
82977: NOT
82978: PUSH
82979: LD_EXP 68
82983: NOT
82984: OR
82985: IFFALSE 82989
// exit ;
82987: GO 83204
// for i = 1 to mc_bases do
82989: LD_ADDR_VAR 0 3
82993: PUSH
82994: DOUBLE
82995: LD_INT 1
82997: DEC
82998: ST_TO_ADDR
82999: LD_EXP 70
83003: PUSH
83004: FOR_TO
83005: IFFALSE 83202
// begin if building in mc_construct_list [ i ] then
83007: LD_VAR 0 1
83011: PUSH
83012: LD_EXP 77
83016: PUSH
83017: LD_VAR 0 3
83021: ARRAY
83022: IN
83023: IFFALSE 83200
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83025: LD_ADDR_EXP 77
83029: PUSH
83030: LD_EXP 77
83034: PPUSH
83035: LD_VAR 0 3
83039: PPUSH
83040: LD_EXP 77
83044: PUSH
83045: LD_VAR 0 3
83049: ARRAY
83050: PUSH
83051: LD_VAR 0 1
83055: DIFF
83056: PPUSH
83057: CALL_OW 1
83061: ST_TO_ADDR
// if building in mc_lab [ i ] then
83062: LD_VAR 0 1
83066: PUSH
83067: LD_EXP 103
83071: PUSH
83072: LD_VAR 0 3
83076: ARRAY
83077: IN
83078: IFFALSE 83133
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83080: LD_ADDR_EXP 104
83084: PUSH
83085: LD_EXP 104
83089: PPUSH
83090: LD_VAR 0 3
83094: PPUSH
83095: LD_EXP 104
83099: PUSH
83100: LD_VAR 0 3
83104: ARRAY
83105: PPUSH
83106: LD_INT 1
83108: PPUSH
83109: LD_EXP 104
83113: PUSH
83114: LD_VAR 0 3
83118: ARRAY
83119: PPUSH
83120: LD_INT 0
83122: PPUSH
83123: CALL 18015 0 4
83127: PPUSH
83128: CALL_OW 1
83132: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83133: LD_VAR 0 1
83137: PUSH
83138: LD_EXP 70
83142: PUSH
83143: LD_VAR 0 3
83147: ARRAY
83148: IN
83149: NOT
83150: IFFALSE 83196
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83152: LD_ADDR_EXP 70
83156: PUSH
83157: LD_EXP 70
83161: PPUSH
83162: LD_VAR 0 3
83166: PUSH
83167: LD_EXP 70
83171: PUSH
83172: LD_VAR 0 3
83176: ARRAY
83177: PUSH
83178: LD_INT 1
83180: PLUS
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PPUSH
83186: LD_VAR 0 1
83190: PPUSH
83191: CALL 18597 0 3
83195: ST_TO_ADDR
// exit ;
83196: POP
83197: POP
83198: GO 83204
// end ; end ;
83200: GO 83004
83202: POP
83203: POP
// end ;
83204: LD_VAR 0 2
83208: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83209: LD_INT 0
83211: PPUSH
83212: PPUSH
83213: PPUSH
83214: PPUSH
83215: PPUSH
83216: PPUSH
83217: PPUSH
// if not mc_bases or not skirmish then
83218: LD_EXP 70
83222: NOT
83223: PUSH
83224: LD_EXP 68
83228: NOT
83229: OR
83230: IFFALSE 83234
// exit ;
83232: GO 83895
// for i = 1 to mc_bases do
83234: LD_ADDR_VAR 0 3
83238: PUSH
83239: DOUBLE
83240: LD_INT 1
83242: DEC
83243: ST_TO_ADDR
83244: LD_EXP 70
83248: PUSH
83249: FOR_TO
83250: IFFALSE 83893
// begin if building in mc_construct_list [ i ] then
83252: LD_VAR 0 1
83256: PUSH
83257: LD_EXP 77
83261: PUSH
83262: LD_VAR 0 3
83266: ARRAY
83267: IN
83268: IFFALSE 83891
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83270: LD_ADDR_EXP 77
83274: PUSH
83275: LD_EXP 77
83279: PPUSH
83280: LD_VAR 0 3
83284: PPUSH
83285: LD_EXP 77
83289: PUSH
83290: LD_VAR 0 3
83294: ARRAY
83295: PUSH
83296: LD_VAR 0 1
83300: DIFF
83301: PPUSH
83302: CALL_OW 1
83306: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83307: LD_ADDR_EXP 70
83311: PUSH
83312: LD_EXP 70
83316: PPUSH
83317: LD_VAR 0 3
83321: PUSH
83322: LD_EXP 70
83326: PUSH
83327: LD_VAR 0 3
83331: ARRAY
83332: PUSH
83333: LD_INT 1
83335: PLUS
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PPUSH
83341: LD_VAR 0 1
83345: PPUSH
83346: CALL 18597 0 3
83350: ST_TO_ADDR
// btype := GetBType ( building ) ;
83351: LD_ADDR_VAR 0 5
83355: PUSH
83356: LD_VAR 0 1
83360: PPUSH
83361: CALL_OW 266
83365: ST_TO_ADDR
// side := GetSide ( building ) ;
83366: LD_ADDR_VAR 0 8
83370: PUSH
83371: LD_VAR 0 1
83375: PPUSH
83376: CALL_OW 255
83380: ST_TO_ADDR
// if btype = b_lab then
83381: LD_VAR 0 5
83385: PUSH
83386: LD_INT 6
83388: EQUAL
83389: IFFALSE 83439
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83391: LD_ADDR_EXP 103
83395: PUSH
83396: LD_EXP 103
83400: PPUSH
83401: LD_VAR 0 3
83405: PUSH
83406: LD_EXP 103
83410: PUSH
83411: LD_VAR 0 3
83415: ARRAY
83416: PUSH
83417: LD_INT 1
83419: PLUS
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PPUSH
83425: LD_VAR 0 1
83429: PPUSH
83430: CALL 18597 0 3
83434: ST_TO_ADDR
// exit ;
83435: POP
83436: POP
83437: GO 83895
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83439: LD_VAR 0 5
83443: PUSH
83444: LD_INT 0
83446: PUSH
83447: LD_INT 2
83449: PUSH
83450: LD_INT 4
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: LIST
83457: IN
83458: IFFALSE 83582
// begin if btype = b_armoury then
83460: LD_VAR 0 5
83464: PUSH
83465: LD_INT 4
83467: EQUAL
83468: IFFALSE 83478
// btype := b_barracks ;
83470: LD_ADDR_VAR 0 5
83474: PUSH
83475: LD_INT 5
83477: ST_TO_ADDR
// if btype = b_depot then
83478: LD_VAR 0 5
83482: PUSH
83483: LD_INT 0
83485: EQUAL
83486: IFFALSE 83496
// btype := b_warehouse ;
83488: LD_ADDR_VAR 0 5
83492: PUSH
83493: LD_INT 1
83495: ST_TO_ADDR
// if btype = b_workshop then
83496: LD_VAR 0 5
83500: PUSH
83501: LD_INT 2
83503: EQUAL
83504: IFFALSE 83514
// btype := b_factory ;
83506: LD_ADDR_VAR 0 5
83510: PUSH
83511: LD_INT 3
83513: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83514: LD_VAR 0 5
83518: PPUSH
83519: LD_VAR 0 8
83523: PPUSH
83524: CALL_OW 323
83528: PUSH
83529: LD_INT 1
83531: EQUAL
83532: IFFALSE 83578
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83534: LD_ADDR_EXP 102
83538: PUSH
83539: LD_EXP 102
83543: PPUSH
83544: LD_VAR 0 3
83548: PUSH
83549: LD_EXP 102
83553: PUSH
83554: LD_VAR 0 3
83558: ARRAY
83559: PUSH
83560: LD_INT 1
83562: PLUS
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PPUSH
83568: LD_VAR 0 1
83572: PPUSH
83573: CALL 18597 0 3
83577: ST_TO_ADDR
// exit ;
83578: POP
83579: POP
83580: GO 83895
// end ; if btype in [ b_bunker , b_turret ] then
83582: LD_VAR 0 5
83586: PUSH
83587: LD_INT 32
83589: PUSH
83590: LD_INT 33
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: IN
83597: IFFALSE 83887
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83599: LD_ADDR_EXP 78
83603: PUSH
83604: LD_EXP 78
83608: PPUSH
83609: LD_VAR 0 3
83613: PUSH
83614: LD_EXP 78
83618: PUSH
83619: LD_VAR 0 3
83623: ARRAY
83624: PUSH
83625: LD_INT 1
83627: PLUS
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PPUSH
83633: LD_VAR 0 1
83637: PPUSH
83638: CALL 18597 0 3
83642: ST_TO_ADDR
// if btype = b_bunker then
83643: LD_VAR 0 5
83647: PUSH
83648: LD_INT 32
83650: EQUAL
83651: IFFALSE 83887
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83653: LD_ADDR_EXP 79
83657: PUSH
83658: LD_EXP 79
83662: PPUSH
83663: LD_VAR 0 3
83667: PUSH
83668: LD_EXP 79
83672: PUSH
83673: LD_VAR 0 3
83677: ARRAY
83678: PUSH
83679: LD_INT 1
83681: PLUS
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PPUSH
83687: LD_VAR 0 1
83691: PPUSH
83692: CALL 18597 0 3
83696: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83697: LD_ADDR_VAR 0 6
83701: PUSH
83702: LD_EXP 70
83706: PUSH
83707: LD_VAR 0 3
83711: ARRAY
83712: PPUSH
83713: LD_INT 25
83715: PUSH
83716: LD_INT 1
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 3
83725: PUSH
83726: LD_INT 54
83728: PUSH
83729: EMPTY
83730: LIST
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PPUSH
83740: CALL_OW 72
83744: ST_TO_ADDR
// if tmp then
83745: LD_VAR 0 6
83749: IFFALSE 83755
// exit ;
83751: POP
83752: POP
83753: GO 83895
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83755: LD_ADDR_VAR 0 6
83759: PUSH
83760: LD_EXP 70
83764: PUSH
83765: LD_VAR 0 3
83769: ARRAY
83770: PPUSH
83771: LD_INT 2
83773: PUSH
83774: LD_INT 30
83776: PUSH
83777: LD_INT 4
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 30
83786: PUSH
83787: LD_INT 5
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: LIST
83798: PPUSH
83799: CALL_OW 72
83803: ST_TO_ADDR
// if not tmp then
83804: LD_VAR 0 6
83808: NOT
83809: IFFALSE 83815
// exit ;
83811: POP
83812: POP
83813: GO 83895
// for j in tmp do
83815: LD_ADDR_VAR 0 4
83819: PUSH
83820: LD_VAR 0 6
83824: PUSH
83825: FOR_IN
83826: IFFALSE 83885
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83828: LD_ADDR_VAR 0 7
83832: PUSH
83833: LD_VAR 0 4
83837: PPUSH
83838: CALL_OW 313
83842: PPUSH
83843: LD_INT 25
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PPUSH
83853: CALL_OW 72
83857: ST_TO_ADDR
// if units then
83858: LD_VAR 0 7
83862: IFFALSE 83883
// begin ComExitBuilding ( units [ 1 ] ) ;
83864: LD_VAR 0 7
83868: PUSH
83869: LD_INT 1
83871: ARRAY
83872: PPUSH
83873: CALL_OW 122
// exit ;
83877: POP
83878: POP
83879: POP
83880: POP
83881: GO 83895
// end ; end ;
83883: GO 83825
83885: POP
83886: POP
// end ; end ; exit ;
83887: POP
83888: POP
83889: GO 83895
// end ; end ;
83891: GO 83249
83893: POP
83894: POP
// end ;
83895: LD_VAR 0 2
83899: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83900: LD_INT 0
83902: PPUSH
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
83907: PPUSH
83908: PPUSH
// if not mc_bases or not skirmish then
83909: LD_EXP 70
83913: NOT
83914: PUSH
83915: LD_EXP 68
83919: NOT
83920: OR
83921: IFFALSE 83925
// exit ;
83923: GO 84190
// btype := GetBType ( building ) ;
83925: LD_ADDR_VAR 0 6
83929: PUSH
83930: LD_VAR 0 1
83934: PPUSH
83935: CALL_OW 266
83939: ST_TO_ADDR
// x := GetX ( building ) ;
83940: LD_ADDR_VAR 0 7
83944: PUSH
83945: LD_VAR 0 1
83949: PPUSH
83950: CALL_OW 250
83954: ST_TO_ADDR
// y := GetY ( building ) ;
83955: LD_ADDR_VAR 0 8
83959: PUSH
83960: LD_VAR 0 1
83964: PPUSH
83965: CALL_OW 251
83969: ST_TO_ADDR
// d := GetDir ( building ) ;
83970: LD_ADDR_VAR 0 9
83974: PUSH
83975: LD_VAR 0 1
83979: PPUSH
83980: CALL_OW 254
83984: ST_TO_ADDR
// for i = 1 to mc_bases do
83985: LD_ADDR_VAR 0 4
83989: PUSH
83990: DOUBLE
83991: LD_INT 1
83993: DEC
83994: ST_TO_ADDR
83995: LD_EXP 70
83999: PUSH
84000: FOR_TO
84001: IFFALSE 84188
// begin if not mc_build_list [ i ] then
84003: LD_EXP 75
84007: PUSH
84008: LD_VAR 0 4
84012: ARRAY
84013: NOT
84014: IFFALSE 84018
// continue ;
84016: GO 84000
// for j := 1 to mc_build_list [ i ] do
84018: LD_ADDR_VAR 0 5
84022: PUSH
84023: DOUBLE
84024: LD_INT 1
84026: DEC
84027: ST_TO_ADDR
84028: LD_EXP 75
84032: PUSH
84033: LD_VAR 0 4
84037: ARRAY
84038: PUSH
84039: FOR_TO
84040: IFFALSE 84184
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
84042: LD_VAR 0 6
84046: PUSH
84047: LD_VAR 0 7
84051: PUSH
84052: LD_VAR 0 8
84056: PUSH
84057: LD_VAR 0 9
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: PPUSH
84068: LD_EXP 75
84072: PUSH
84073: LD_VAR 0 4
84077: ARRAY
84078: PUSH
84079: LD_VAR 0 5
84083: ARRAY
84084: PPUSH
84085: CALL 24779 0 2
84089: IFFALSE 84182
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84091: LD_ADDR_EXP 75
84095: PUSH
84096: LD_EXP 75
84100: PPUSH
84101: LD_VAR 0 4
84105: PPUSH
84106: LD_EXP 75
84110: PUSH
84111: LD_VAR 0 4
84115: ARRAY
84116: PPUSH
84117: LD_VAR 0 5
84121: PPUSH
84122: CALL_OW 3
84126: PPUSH
84127: CALL_OW 1
84131: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84132: LD_ADDR_EXP 77
84136: PUSH
84137: LD_EXP 77
84141: PPUSH
84142: LD_VAR 0 4
84146: PUSH
84147: LD_EXP 77
84151: PUSH
84152: LD_VAR 0 4
84156: ARRAY
84157: PUSH
84158: LD_INT 1
84160: PLUS
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PPUSH
84166: LD_VAR 0 1
84170: PPUSH
84171: CALL 18597 0 3
84175: ST_TO_ADDR
// exit ;
84176: POP
84177: POP
84178: POP
84179: POP
84180: GO 84190
// end ;
84182: GO 84039
84184: POP
84185: POP
// end ;
84186: GO 84000
84188: POP
84189: POP
// end ;
84190: LD_VAR 0 3
84194: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84195: LD_INT 0
84197: PPUSH
84198: PPUSH
84199: PPUSH
// if not mc_bases or not skirmish then
84200: LD_EXP 70
84204: NOT
84205: PUSH
84206: LD_EXP 68
84210: NOT
84211: OR
84212: IFFALSE 84216
// exit ;
84214: GO 84406
// for i = 1 to mc_bases do
84216: LD_ADDR_VAR 0 4
84220: PUSH
84221: DOUBLE
84222: LD_INT 1
84224: DEC
84225: ST_TO_ADDR
84226: LD_EXP 70
84230: PUSH
84231: FOR_TO
84232: IFFALSE 84319
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84234: LD_VAR 0 1
84238: PUSH
84239: LD_EXP 78
84243: PUSH
84244: LD_VAR 0 4
84248: ARRAY
84249: IN
84250: PUSH
84251: LD_VAR 0 1
84255: PUSH
84256: LD_EXP 79
84260: PUSH
84261: LD_VAR 0 4
84265: ARRAY
84266: IN
84267: NOT
84268: AND
84269: IFFALSE 84317
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84271: LD_ADDR_EXP 79
84275: PUSH
84276: LD_EXP 79
84280: PPUSH
84281: LD_VAR 0 4
84285: PUSH
84286: LD_EXP 79
84290: PUSH
84291: LD_VAR 0 4
84295: ARRAY
84296: PUSH
84297: LD_INT 1
84299: PLUS
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PPUSH
84305: LD_VAR 0 1
84309: PPUSH
84310: CALL 18597 0 3
84314: ST_TO_ADDR
// break ;
84315: GO 84319
// end ; end ;
84317: GO 84231
84319: POP
84320: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84321: LD_VAR 0 1
84325: PPUSH
84326: CALL_OW 257
84330: PUSH
84331: LD_EXP 96
84335: IN
84336: PUSH
84337: LD_VAR 0 1
84341: PPUSH
84342: CALL_OW 266
84346: PUSH
84347: LD_INT 5
84349: EQUAL
84350: AND
84351: PUSH
84352: LD_VAR 0 2
84356: PPUSH
84357: CALL_OW 110
84361: PUSH
84362: LD_INT 18
84364: NONEQUAL
84365: AND
84366: IFFALSE 84406
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84368: LD_VAR 0 2
84372: PPUSH
84373: CALL_OW 257
84377: PUSH
84378: LD_INT 5
84380: PUSH
84381: LD_INT 8
84383: PUSH
84384: LD_INT 9
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: LIST
84391: IN
84392: IFFALSE 84406
// SetClass ( unit , 1 ) ;
84394: LD_VAR 0 2
84398: PPUSH
84399: LD_INT 1
84401: PPUSH
84402: CALL_OW 336
// end ;
84406: LD_VAR 0 3
84410: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84411: LD_INT 0
84413: PPUSH
84414: PPUSH
// if not mc_bases or not skirmish then
84415: LD_EXP 70
84419: NOT
84420: PUSH
84421: LD_EXP 68
84425: NOT
84426: OR
84427: IFFALSE 84431
// exit ;
84429: GO 84547
// if GetLives ( abandoned_vehicle ) > 250 then
84431: LD_VAR 0 2
84435: PPUSH
84436: CALL_OW 256
84440: PUSH
84441: LD_INT 250
84443: GREATER
84444: IFFALSE 84448
// exit ;
84446: GO 84547
// for i = 1 to mc_bases do
84448: LD_ADDR_VAR 0 6
84452: PUSH
84453: DOUBLE
84454: LD_INT 1
84456: DEC
84457: ST_TO_ADDR
84458: LD_EXP 70
84462: PUSH
84463: FOR_TO
84464: IFFALSE 84545
// begin if driver in mc_bases [ i ] then
84466: LD_VAR 0 1
84470: PUSH
84471: LD_EXP 70
84475: PUSH
84476: LD_VAR 0 6
84480: ARRAY
84481: IN
84482: IFFALSE 84543
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84484: LD_VAR 0 1
84488: PPUSH
84489: LD_EXP 70
84493: PUSH
84494: LD_VAR 0 6
84498: ARRAY
84499: PPUSH
84500: LD_INT 2
84502: PUSH
84503: LD_INT 30
84505: PUSH
84506: LD_INT 0
84508: PUSH
84509: EMPTY
84510: LIST
84511: LIST
84512: PUSH
84513: LD_INT 30
84515: PUSH
84516: LD_INT 1
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: PPUSH
84528: CALL_OW 72
84532: PUSH
84533: LD_INT 1
84535: ARRAY
84536: PPUSH
84537: CALL 51159 0 2
// break ;
84541: GO 84545
// end ; end ;
84543: GO 84463
84545: POP
84546: POP
// end ; end_of_file end_of_file
84547: LD_VAR 0 5
84551: RET
// every 0 0$1 do
84552: GO 84554
84554: DISABLE
// begin enable ;
84555: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
84556: LD_STRING updateTimer(
84558: PUSH
84559: LD_OWVAR 1
84563: STR
84564: PUSH
84565: LD_STRING );
84567: STR
84568: PPUSH
84569: CALL_OW 559
// end ;
84573: END
// export function SOS_MapStart ( ) ; begin
84574: LD_INT 0
84576: PPUSH
// if streamModeActive then
84577: LD_EXP 114
84581: IFFALSE 84590
// DefineStreamItems ( true ) ;
84583: LD_INT 1
84585: PPUSH
84586: CALL 86240 0 1
// UpdateFactoryWaypoints ( ) ;
84590: CALL 99824 0 0
// end ;
84594: LD_VAR 0 1
84598: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
84599: LD_INT 0
84601: PPUSH
// if p2 = 100 then
84602: LD_VAR 0 2
84606: PUSH
84607: LD_INT 100
84609: EQUAL
84610: IFFALSE 85613
// begin if not StreamModeActive then
84612: LD_EXP 114
84616: NOT
84617: IFFALSE 84627
// StreamModeActive := true ;
84619: LD_ADDR_EXP 114
84623: PUSH
84624: LD_INT 1
84626: ST_TO_ADDR
// if p3 = 0 then
84627: LD_VAR 0 3
84631: PUSH
84632: LD_INT 0
84634: EQUAL
84635: IFFALSE 84641
// InitStreamMode ;
84637: CALL 85776 0 0
// if p3 = 1 then
84641: LD_VAR 0 3
84645: PUSH
84646: LD_INT 1
84648: EQUAL
84649: IFFALSE 84659
// sRocket := true ;
84651: LD_ADDR_EXP 119
84655: PUSH
84656: LD_INT 1
84658: ST_TO_ADDR
// if p3 = 2 then
84659: LD_VAR 0 3
84663: PUSH
84664: LD_INT 2
84666: EQUAL
84667: IFFALSE 84677
// sSpeed := true ;
84669: LD_ADDR_EXP 118
84673: PUSH
84674: LD_INT 1
84676: ST_TO_ADDR
// if p3 = 3 then
84677: LD_VAR 0 3
84681: PUSH
84682: LD_INT 3
84684: EQUAL
84685: IFFALSE 84695
// sEngine := true ;
84687: LD_ADDR_EXP 120
84691: PUSH
84692: LD_INT 1
84694: ST_TO_ADDR
// if p3 = 4 then
84695: LD_VAR 0 3
84699: PUSH
84700: LD_INT 4
84702: EQUAL
84703: IFFALSE 84713
// sSpec := true ;
84705: LD_ADDR_EXP 117
84709: PUSH
84710: LD_INT 1
84712: ST_TO_ADDR
// if p3 = 5 then
84713: LD_VAR 0 3
84717: PUSH
84718: LD_INT 5
84720: EQUAL
84721: IFFALSE 84731
// sLevel := true ;
84723: LD_ADDR_EXP 121
84727: PUSH
84728: LD_INT 1
84730: ST_TO_ADDR
// if p3 = 6 then
84731: LD_VAR 0 3
84735: PUSH
84736: LD_INT 6
84738: EQUAL
84739: IFFALSE 84749
// sArmoury := true ;
84741: LD_ADDR_EXP 122
84745: PUSH
84746: LD_INT 1
84748: ST_TO_ADDR
// if p3 = 7 then
84749: LD_VAR 0 3
84753: PUSH
84754: LD_INT 7
84756: EQUAL
84757: IFFALSE 84767
// sRadar := true ;
84759: LD_ADDR_EXP 123
84763: PUSH
84764: LD_INT 1
84766: ST_TO_ADDR
// if p3 = 8 then
84767: LD_VAR 0 3
84771: PUSH
84772: LD_INT 8
84774: EQUAL
84775: IFFALSE 84785
// sBunker := true ;
84777: LD_ADDR_EXP 124
84781: PUSH
84782: LD_INT 1
84784: ST_TO_ADDR
// if p3 = 9 then
84785: LD_VAR 0 3
84789: PUSH
84790: LD_INT 9
84792: EQUAL
84793: IFFALSE 84803
// sHack := true ;
84795: LD_ADDR_EXP 125
84799: PUSH
84800: LD_INT 1
84802: ST_TO_ADDR
// if p3 = 10 then
84803: LD_VAR 0 3
84807: PUSH
84808: LD_INT 10
84810: EQUAL
84811: IFFALSE 84821
// sFire := true ;
84813: LD_ADDR_EXP 126
84817: PUSH
84818: LD_INT 1
84820: ST_TO_ADDR
// if p3 = 11 then
84821: LD_VAR 0 3
84825: PUSH
84826: LD_INT 11
84828: EQUAL
84829: IFFALSE 84839
// sRefresh := true ;
84831: LD_ADDR_EXP 127
84835: PUSH
84836: LD_INT 1
84838: ST_TO_ADDR
// if p3 = 12 then
84839: LD_VAR 0 3
84843: PUSH
84844: LD_INT 12
84846: EQUAL
84847: IFFALSE 84857
// sExp := true ;
84849: LD_ADDR_EXP 128
84853: PUSH
84854: LD_INT 1
84856: ST_TO_ADDR
// if p3 = 13 then
84857: LD_VAR 0 3
84861: PUSH
84862: LD_INT 13
84864: EQUAL
84865: IFFALSE 84875
// sDepot := true ;
84867: LD_ADDR_EXP 129
84871: PUSH
84872: LD_INT 1
84874: ST_TO_ADDR
// if p3 = 14 then
84875: LD_VAR 0 3
84879: PUSH
84880: LD_INT 14
84882: EQUAL
84883: IFFALSE 84893
// sFlag := true ;
84885: LD_ADDR_EXP 130
84889: PUSH
84890: LD_INT 1
84892: ST_TO_ADDR
// if p3 = 15 then
84893: LD_VAR 0 3
84897: PUSH
84898: LD_INT 15
84900: EQUAL
84901: IFFALSE 84911
// sKamikadze := true ;
84903: LD_ADDR_EXP 138
84907: PUSH
84908: LD_INT 1
84910: ST_TO_ADDR
// if p3 = 16 then
84911: LD_VAR 0 3
84915: PUSH
84916: LD_INT 16
84918: EQUAL
84919: IFFALSE 84929
// sTroll := true ;
84921: LD_ADDR_EXP 139
84925: PUSH
84926: LD_INT 1
84928: ST_TO_ADDR
// if p3 = 17 then
84929: LD_VAR 0 3
84933: PUSH
84934: LD_INT 17
84936: EQUAL
84937: IFFALSE 84947
// sSlow := true ;
84939: LD_ADDR_EXP 140
84943: PUSH
84944: LD_INT 1
84946: ST_TO_ADDR
// if p3 = 18 then
84947: LD_VAR 0 3
84951: PUSH
84952: LD_INT 18
84954: EQUAL
84955: IFFALSE 84965
// sLack := true ;
84957: LD_ADDR_EXP 141
84961: PUSH
84962: LD_INT 1
84964: ST_TO_ADDR
// if p3 = 19 then
84965: LD_VAR 0 3
84969: PUSH
84970: LD_INT 19
84972: EQUAL
84973: IFFALSE 84983
// sTank := true ;
84975: LD_ADDR_EXP 143
84979: PUSH
84980: LD_INT 1
84982: ST_TO_ADDR
// if p3 = 20 then
84983: LD_VAR 0 3
84987: PUSH
84988: LD_INT 20
84990: EQUAL
84991: IFFALSE 85001
// sRemote := true ;
84993: LD_ADDR_EXP 144
84997: PUSH
84998: LD_INT 1
85000: ST_TO_ADDR
// if p3 = 21 then
85001: LD_VAR 0 3
85005: PUSH
85006: LD_INT 21
85008: EQUAL
85009: IFFALSE 85019
// sPowell := true ;
85011: LD_ADDR_EXP 145
85015: PUSH
85016: LD_INT 1
85018: ST_TO_ADDR
// if p3 = 22 then
85019: LD_VAR 0 3
85023: PUSH
85024: LD_INT 22
85026: EQUAL
85027: IFFALSE 85037
// sTeleport := true ;
85029: LD_ADDR_EXP 148
85033: PUSH
85034: LD_INT 1
85036: ST_TO_ADDR
// if p3 = 23 then
85037: LD_VAR 0 3
85041: PUSH
85042: LD_INT 23
85044: EQUAL
85045: IFFALSE 85055
// sOilTower := true ;
85047: LD_ADDR_EXP 150
85051: PUSH
85052: LD_INT 1
85054: ST_TO_ADDR
// if p3 = 24 then
85055: LD_VAR 0 3
85059: PUSH
85060: LD_INT 24
85062: EQUAL
85063: IFFALSE 85073
// sShovel := true ;
85065: LD_ADDR_EXP 151
85069: PUSH
85070: LD_INT 1
85072: ST_TO_ADDR
// if p3 = 25 then
85073: LD_VAR 0 3
85077: PUSH
85078: LD_INT 25
85080: EQUAL
85081: IFFALSE 85091
// sSheik := true ;
85083: LD_ADDR_EXP 152
85087: PUSH
85088: LD_INT 1
85090: ST_TO_ADDR
// if p3 = 26 then
85091: LD_VAR 0 3
85095: PUSH
85096: LD_INT 26
85098: EQUAL
85099: IFFALSE 85109
// sEarthquake := true ;
85101: LD_ADDR_EXP 154
85105: PUSH
85106: LD_INT 1
85108: ST_TO_ADDR
// if p3 = 27 then
85109: LD_VAR 0 3
85113: PUSH
85114: LD_INT 27
85116: EQUAL
85117: IFFALSE 85127
// sAI := true ;
85119: LD_ADDR_EXP 155
85123: PUSH
85124: LD_INT 1
85126: ST_TO_ADDR
// if p3 = 28 then
85127: LD_VAR 0 3
85131: PUSH
85132: LD_INT 28
85134: EQUAL
85135: IFFALSE 85145
// sCargo := true ;
85137: LD_ADDR_EXP 158
85141: PUSH
85142: LD_INT 1
85144: ST_TO_ADDR
// if p3 = 29 then
85145: LD_VAR 0 3
85149: PUSH
85150: LD_INT 29
85152: EQUAL
85153: IFFALSE 85163
// sDLaser := true ;
85155: LD_ADDR_EXP 159
85159: PUSH
85160: LD_INT 1
85162: ST_TO_ADDR
// if p3 = 30 then
85163: LD_VAR 0 3
85167: PUSH
85168: LD_INT 30
85170: EQUAL
85171: IFFALSE 85181
// sExchange := true ;
85173: LD_ADDR_EXP 160
85177: PUSH
85178: LD_INT 1
85180: ST_TO_ADDR
// if p3 = 31 then
85181: LD_VAR 0 3
85185: PUSH
85186: LD_INT 31
85188: EQUAL
85189: IFFALSE 85199
// sFac := true ;
85191: LD_ADDR_EXP 161
85195: PUSH
85196: LD_INT 1
85198: ST_TO_ADDR
// if p3 = 32 then
85199: LD_VAR 0 3
85203: PUSH
85204: LD_INT 32
85206: EQUAL
85207: IFFALSE 85217
// sPower := true ;
85209: LD_ADDR_EXP 162
85213: PUSH
85214: LD_INT 1
85216: ST_TO_ADDR
// if p3 = 33 then
85217: LD_VAR 0 3
85221: PUSH
85222: LD_INT 33
85224: EQUAL
85225: IFFALSE 85235
// sRandom := true ;
85227: LD_ADDR_EXP 163
85231: PUSH
85232: LD_INT 1
85234: ST_TO_ADDR
// if p3 = 34 then
85235: LD_VAR 0 3
85239: PUSH
85240: LD_INT 34
85242: EQUAL
85243: IFFALSE 85253
// sShield := true ;
85245: LD_ADDR_EXP 164
85249: PUSH
85250: LD_INT 1
85252: ST_TO_ADDR
// if p3 = 35 then
85253: LD_VAR 0 3
85257: PUSH
85258: LD_INT 35
85260: EQUAL
85261: IFFALSE 85271
// sTime := true ;
85263: LD_ADDR_EXP 165
85267: PUSH
85268: LD_INT 1
85270: ST_TO_ADDR
// if p3 = 36 then
85271: LD_VAR 0 3
85275: PUSH
85276: LD_INT 36
85278: EQUAL
85279: IFFALSE 85289
// sTools := true ;
85281: LD_ADDR_EXP 166
85285: PUSH
85286: LD_INT 1
85288: ST_TO_ADDR
// if p3 = 101 then
85289: LD_VAR 0 3
85293: PUSH
85294: LD_INT 101
85296: EQUAL
85297: IFFALSE 85307
// sSold := true ;
85299: LD_ADDR_EXP 131
85303: PUSH
85304: LD_INT 1
85306: ST_TO_ADDR
// if p3 = 102 then
85307: LD_VAR 0 3
85311: PUSH
85312: LD_INT 102
85314: EQUAL
85315: IFFALSE 85325
// sDiff := true ;
85317: LD_ADDR_EXP 132
85321: PUSH
85322: LD_INT 1
85324: ST_TO_ADDR
// if p3 = 103 then
85325: LD_VAR 0 3
85329: PUSH
85330: LD_INT 103
85332: EQUAL
85333: IFFALSE 85343
// sFog := true ;
85335: LD_ADDR_EXP 135
85339: PUSH
85340: LD_INT 1
85342: ST_TO_ADDR
// if p3 = 104 then
85343: LD_VAR 0 3
85347: PUSH
85348: LD_INT 104
85350: EQUAL
85351: IFFALSE 85361
// sReset := true ;
85353: LD_ADDR_EXP 136
85357: PUSH
85358: LD_INT 1
85360: ST_TO_ADDR
// if p3 = 105 then
85361: LD_VAR 0 3
85365: PUSH
85366: LD_INT 105
85368: EQUAL
85369: IFFALSE 85379
// sSun := true ;
85371: LD_ADDR_EXP 137
85375: PUSH
85376: LD_INT 1
85378: ST_TO_ADDR
// if p3 = 106 then
85379: LD_VAR 0 3
85383: PUSH
85384: LD_INT 106
85386: EQUAL
85387: IFFALSE 85397
// sTiger := true ;
85389: LD_ADDR_EXP 133
85393: PUSH
85394: LD_INT 1
85396: ST_TO_ADDR
// if p3 = 107 then
85397: LD_VAR 0 3
85401: PUSH
85402: LD_INT 107
85404: EQUAL
85405: IFFALSE 85415
// sBomb := true ;
85407: LD_ADDR_EXP 134
85411: PUSH
85412: LD_INT 1
85414: ST_TO_ADDR
// if p3 = 108 then
85415: LD_VAR 0 3
85419: PUSH
85420: LD_INT 108
85422: EQUAL
85423: IFFALSE 85433
// sWound := true ;
85425: LD_ADDR_EXP 142
85429: PUSH
85430: LD_INT 1
85432: ST_TO_ADDR
// if p3 = 109 then
85433: LD_VAR 0 3
85437: PUSH
85438: LD_INT 109
85440: EQUAL
85441: IFFALSE 85451
// sBetray := true ;
85443: LD_ADDR_EXP 146
85447: PUSH
85448: LD_INT 1
85450: ST_TO_ADDR
// if p3 = 110 then
85451: LD_VAR 0 3
85455: PUSH
85456: LD_INT 110
85458: EQUAL
85459: IFFALSE 85469
// sContamin := true ;
85461: LD_ADDR_EXP 147
85465: PUSH
85466: LD_INT 1
85468: ST_TO_ADDR
// if p3 = 111 then
85469: LD_VAR 0 3
85473: PUSH
85474: LD_INT 111
85476: EQUAL
85477: IFFALSE 85487
// sOil := true ;
85479: LD_ADDR_EXP 149
85483: PUSH
85484: LD_INT 1
85486: ST_TO_ADDR
// if p3 = 112 then
85487: LD_VAR 0 3
85491: PUSH
85492: LD_INT 112
85494: EQUAL
85495: IFFALSE 85505
// sStu := true ;
85497: LD_ADDR_EXP 153
85501: PUSH
85502: LD_INT 1
85504: ST_TO_ADDR
// if p3 = 113 then
85505: LD_VAR 0 3
85509: PUSH
85510: LD_INT 113
85512: EQUAL
85513: IFFALSE 85523
// sBazooka := true ;
85515: LD_ADDR_EXP 156
85519: PUSH
85520: LD_INT 1
85522: ST_TO_ADDR
// if p3 = 114 then
85523: LD_VAR 0 3
85527: PUSH
85528: LD_INT 114
85530: EQUAL
85531: IFFALSE 85541
// sMortar := true ;
85533: LD_ADDR_EXP 157
85537: PUSH
85538: LD_INT 1
85540: ST_TO_ADDR
// if p3 = 115 then
85541: LD_VAR 0 3
85545: PUSH
85546: LD_INT 115
85548: EQUAL
85549: IFFALSE 85559
// sRanger := true ;
85551: LD_ADDR_EXP 167
85555: PUSH
85556: LD_INT 1
85558: ST_TO_ADDR
// if p3 = 116 then
85559: LD_VAR 0 3
85563: PUSH
85564: LD_INT 116
85566: EQUAL
85567: IFFALSE 85577
// sComputer := true ;
85569: LD_ADDR_EXP 168
85573: PUSH
85574: LD_INT 1
85576: ST_TO_ADDR
// if p3 = 117 then
85577: LD_VAR 0 3
85581: PUSH
85582: LD_INT 117
85584: EQUAL
85585: IFFALSE 85595
// s30 := true ;
85587: LD_ADDR_EXP 169
85591: PUSH
85592: LD_INT 1
85594: ST_TO_ADDR
// if p3 = 118 then
85595: LD_VAR 0 3
85599: PUSH
85600: LD_INT 118
85602: EQUAL
85603: IFFALSE 85613
// s60 := true ;
85605: LD_ADDR_EXP 170
85609: PUSH
85610: LD_INT 1
85612: ST_TO_ADDR
// end ; if p2 = 101 then
85613: LD_VAR 0 2
85617: PUSH
85618: LD_INT 101
85620: EQUAL
85621: IFFALSE 85749
// begin case p3 of 1 :
85623: LD_VAR 0 3
85627: PUSH
85628: LD_INT 1
85630: DOUBLE
85631: EQUAL
85632: IFTRUE 85636
85634: GO 85643
85636: POP
// hHackUnlimitedResources ; 2 :
85637: CALL 97847 0 0
85641: GO 85749
85643: LD_INT 2
85645: DOUBLE
85646: EQUAL
85647: IFTRUE 85651
85649: GO 85658
85651: POP
// hHackSetLevel10 ; 3 :
85652: CALL 97980 0 0
85656: GO 85749
85658: LD_INT 3
85660: DOUBLE
85661: EQUAL
85662: IFTRUE 85666
85664: GO 85673
85666: POP
// hHackSetLevel10YourUnits ; 4 :
85667: CALL 98065 0 0
85671: GO 85749
85673: LD_INT 4
85675: DOUBLE
85676: EQUAL
85677: IFTRUE 85681
85679: GO 85688
85681: POP
// hHackInvincible ; 5 :
85682: CALL 98513 0 0
85686: GO 85749
85688: LD_INT 5
85690: DOUBLE
85691: EQUAL
85692: IFTRUE 85696
85694: GO 85703
85696: POP
// hHackInvisible ; 6 :
85697: CALL 98624 0 0
85701: GO 85749
85703: LD_INT 6
85705: DOUBLE
85706: EQUAL
85707: IFTRUE 85711
85709: GO 85718
85711: POP
// hHackChangeYourSide ; 7 :
85712: CALL 98681 0 0
85716: GO 85749
85718: LD_INT 7
85720: DOUBLE
85721: EQUAL
85722: IFTRUE 85726
85724: GO 85733
85726: POP
// hHackChangeUnitSide ; 8 :
85727: CALL 98723 0 0
85731: GO 85749
85733: LD_INT 8
85735: DOUBLE
85736: EQUAL
85737: IFTRUE 85741
85739: GO 85748
85741: POP
// hHackFog ; end ;
85742: CALL 98824 0 0
85746: GO 85749
85748: POP
// end ; end ;
85749: LD_VAR 0 7
85753: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
85754: GO 85756
85756: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85757: LD_STRING initStreamRollete();
85759: PPUSH
85760: CALL_OW 559
// InitStreamMode ;
85764: CALL 85776 0 0
// DefineStreamItems ( false ) ;
85768: LD_INT 0
85770: PPUSH
85771: CALL 86240 0 1
// end ;
85775: END
// function InitStreamMode ; begin
85776: LD_INT 0
85778: PPUSH
// streamModeActive := false ;
85779: LD_ADDR_EXP 114
85783: PUSH
85784: LD_INT 0
85786: ST_TO_ADDR
// normalCounter := 36 ;
85787: LD_ADDR_EXP 115
85791: PUSH
85792: LD_INT 36
85794: ST_TO_ADDR
// hardcoreCounter := 18 ;
85795: LD_ADDR_EXP 116
85799: PUSH
85800: LD_INT 18
85802: ST_TO_ADDR
// sRocket := false ;
85803: LD_ADDR_EXP 119
85807: PUSH
85808: LD_INT 0
85810: ST_TO_ADDR
// sSpeed := false ;
85811: LD_ADDR_EXP 118
85815: PUSH
85816: LD_INT 0
85818: ST_TO_ADDR
// sEngine := false ;
85819: LD_ADDR_EXP 120
85823: PUSH
85824: LD_INT 0
85826: ST_TO_ADDR
// sSpec := false ;
85827: LD_ADDR_EXP 117
85831: PUSH
85832: LD_INT 0
85834: ST_TO_ADDR
// sLevel := false ;
85835: LD_ADDR_EXP 121
85839: PUSH
85840: LD_INT 0
85842: ST_TO_ADDR
// sArmoury := false ;
85843: LD_ADDR_EXP 122
85847: PUSH
85848: LD_INT 0
85850: ST_TO_ADDR
// sRadar := false ;
85851: LD_ADDR_EXP 123
85855: PUSH
85856: LD_INT 0
85858: ST_TO_ADDR
// sBunker := false ;
85859: LD_ADDR_EXP 124
85863: PUSH
85864: LD_INT 0
85866: ST_TO_ADDR
// sHack := false ;
85867: LD_ADDR_EXP 125
85871: PUSH
85872: LD_INT 0
85874: ST_TO_ADDR
// sFire := false ;
85875: LD_ADDR_EXP 126
85879: PUSH
85880: LD_INT 0
85882: ST_TO_ADDR
// sRefresh := false ;
85883: LD_ADDR_EXP 127
85887: PUSH
85888: LD_INT 0
85890: ST_TO_ADDR
// sExp := false ;
85891: LD_ADDR_EXP 128
85895: PUSH
85896: LD_INT 0
85898: ST_TO_ADDR
// sDepot := false ;
85899: LD_ADDR_EXP 129
85903: PUSH
85904: LD_INT 0
85906: ST_TO_ADDR
// sFlag := false ;
85907: LD_ADDR_EXP 130
85911: PUSH
85912: LD_INT 0
85914: ST_TO_ADDR
// sKamikadze := false ;
85915: LD_ADDR_EXP 138
85919: PUSH
85920: LD_INT 0
85922: ST_TO_ADDR
// sTroll := false ;
85923: LD_ADDR_EXP 139
85927: PUSH
85928: LD_INT 0
85930: ST_TO_ADDR
// sSlow := false ;
85931: LD_ADDR_EXP 140
85935: PUSH
85936: LD_INT 0
85938: ST_TO_ADDR
// sLack := false ;
85939: LD_ADDR_EXP 141
85943: PUSH
85944: LD_INT 0
85946: ST_TO_ADDR
// sTank := false ;
85947: LD_ADDR_EXP 143
85951: PUSH
85952: LD_INT 0
85954: ST_TO_ADDR
// sRemote := false ;
85955: LD_ADDR_EXP 144
85959: PUSH
85960: LD_INT 0
85962: ST_TO_ADDR
// sPowell := false ;
85963: LD_ADDR_EXP 145
85967: PUSH
85968: LD_INT 0
85970: ST_TO_ADDR
// sTeleport := false ;
85971: LD_ADDR_EXP 148
85975: PUSH
85976: LD_INT 0
85978: ST_TO_ADDR
// sOilTower := false ;
85979: LD_ADDR_EXP 150
85983: PUSH
85984: LD_INT 0
85986: ST_TO_ADDR
// sShovel := false ;
85987: LD_ADDR_EXP 151
85991: PUSH
85992: LD_INT 0
85994: ST_TO_ADDR
// sSheik := false ;
85995: LD_ADDR_EXP 152
85999: PUSH
86000: LD_INT 0
86002: ST_TO_ADDR
// sEarthquake := false ;
86003: LD_ADDR_EXP 154
86007: PUSH
86008: LD_INT 0
86010: ST_TO_ADDR
// sAI := false ;
86011: LD_ADDR_EXP 155
86015: PUSH
86016: LD_INT 0
86018: ST_TO_ADDR
// sCargo := false ;
86019: LD_ADDR_EXP 158
86023: PUSH
86024: LD_INT 0
86026: ST_TO_ADDR
// sDLaser := false ;
86027: LD_ADDR_EXP 159
86031: PUSH
86032: LD_INT 0
86034: ST_TO_ADDR
// sExchange := false ;
86035: LD_ADDR_EXP 160
86039: PUSH
86040: LD_INT 0
86042: ST_TO_ADDR
// sFac := false ;
86043: LD_ADDR_EXP 161
86047: PUSH
86048: LD_INT 0
86050: ST_TO_ADDR
// sPower := false ;
86051: LD_ADDR_EXP 162
86055: PUSH
86056: LD_INT 0
86058: ST_TO_ADDR
// sRandom := false ;
86059: LD_ADDR_EXP 163
86063: PUSH
86064: LD_INT 0
86066: ST_TO_ADDR
// sShield := false ;
86067: LD_ADDR_EXP 164
86071: PUSH
86072: LD_INT 0
86074: ST_TO_ADDR
// sTime := false ;
86075: LD_ADDR_EXP 165
86079: PUSH
86080: LD_INT 0
86082: ST_TO_ADDR
// sTools := false ;
86083: LD_ADDR_EXP 166
86087: PUSH
86088: LD_INT 0
86090: ST_TO_ADDR
// sSold := false ;
86091: LD_ADDR_EXP 131
86095: PUSH
86096: LD_INT 0
86098: ST_TO_ADDR
// sDiff := false ;
86099: LD_ADDR_EXP 132
86103: PUSH
86104: LD_INT 0
86106: ST_TO_ADDR
// sFog := false ;
86107: LD_ADDR_EXP 135
86111: PUSH
86112: LD_INT 0
86114: ST_TO_ADDR
// sReset := false ;
86115: LD_ADDR_EXP 136
86119: PUSH
86120: LD_INT 0
86122: ST_TO_ADDR
// sSun := false ;
86123: LD_ADDR_EXP 137
86127: PUSH
86128: LD_INT 0
86130: ST_TO_ADDR
// sTiger := false ;
86131: LD_ADDR_EXP 133
86135: PUSH
86136: LD_INT 0
86138: ST_TO_ADDR
// sBomb := false ;
86139: LD_ADDR_EXP 134
86143: PUSH
86144: LD_INT 0
86146: ST_TO_ADDR
// sWound := false ;
86147: LD_ADDR_EXP 142
86151: PUSH
86152: LD_INT 0
86154: ST_TO_ADDR
// sBetray := false ;
86155: LD_ADDR_EXP 146
86159: PUSH
86160: LD_INT 0
86162: ST_TO_ADDR
// sContamin := false ;
86163: LD_ADDR_EXP 147
86167: PUSH
86168: LD_INT 0
86170: ST_TO_ADDR
// sOil := false ;
86171: LD_ADDR_EXP 149
86175: PUSH
86176: LD_INT 0
86178: ST_TO_ADDR
// sStu := false ;
86179: LD_ADDR_EXP 153
86183: PUSH
86184: LD_INT 0
86186: ST_TO_ADDR
// sBazooka := false ;
86187: LD_ADDR_EXP 156
86191: PUSH
86192: LD_INT 0
86194: ST_TO_ADDR
// sMortar := false ;
86195: LD_ADDR_EXP 157
86199: PUSH
86200: LD_INT 0
86202: ST_TO_ADDR
// sRanger := false ;
86203: LD_ADDR_EXP 167
86207: PUSH
86208: LD_INT 0
86210: ST_TO_ADDR
// sComputer := false ;
86211: LD_ADDR_EXP 168
86215: PUSH
86216: LD_INT 0
86218: ST_TO_ADDR
// s30 := false ;
86219: LD_ADDR_EXP 169
86223: PUSH
86224: LD_INT 0
86226: ST_TO_ADDR
// s60 := false ;
86227: LD_ADDR_EXP 170
86231: PUSH
86232: LD_INT 0
86234: ST_TO_ADDR
// end ;
86235: LD_VAR 0 1
86239: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
86240: LD_INT 0
86242: PPUSH
86243: PPUSH
86244: PPUSH
86245: PPUSH
86246: PPUSH
86247: PPUSH
86248: PPUSH
// result := [ ] ;
86249: LD_ADDR_VAR 0 2
86253: PUSH
86254: EMPTY
86255: ST_TO_ADDR
// if campaign_id = 1 then
86256: LD_OWVAR 69
86260: PUSH
86261: LD_INT 1
86263: EQUAL
86264: IFFALSE 89430
// begin case mission_number of 1 :
86266: LD_OWVAR 70
86270: PUSH
86271: LD_INT 1
86273: DOUBLE
86274: EQUAL
86275: IFTRUE 86279
86277: GO 86355
86279: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
86280: LD_ADDR_VAR 0 2
86284: PUSH
86285: LD_INT 2
86287: PUSH
86288: LD_INT 4
86290: PUSH
86291: LD_INT 11
86293: PUSH
86294: LD_INT 12
86296: PUSH
86297: LD_INT 15
86299: PUSH
86300: LD_INT 16
86302: PUSH
86303: LD_INT 22
86305: PUSH
86306: LD_INT 23
86308: PUSH
86309: LD_INT 26
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 101
86325: PUSH
86326: LD_INT 102
86328: PUSH
86329: LD_INT 106
86331: PUSH
86332: LD_INT 116
86334: PUSH
86335: LD_INT 117
86337: PUSH
86338: LD_INT 118
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: ST_TO_ADDR
86353: GO 89428
86355: LD_INT 2
86357: DOUBLE
86358: EQUAL
86359: IFTRUE 86363
86361: GO 86447
86363: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
86364: LD_ADDR_VAR 0 2
86368: PUSH
86369: LD_INT 2
86371: PUSH
86372: LD_INT 4
86374: PUSH
86375: LD_INT 11
86377: PUSH
86378: LD_INT 12
86380: PUSH
86381: LD_INT 15
86383: PUSH
86384: LD_INT 16
86386: PUSH
86387: LD_INT 22
86389: PUSH
86390: LD_INT 23
86392: PUSH
86393: LD_INT 26
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: PUSH
86407: LD_INT 101
86409: PUSH
86410: LD_INT 102
86412: PUSH
86413: LD_INT 105
86415: PUSH
86416: LD_INT 106
86418: PUSH
86419: LD_INT 108
86421: PUSH
86422: LD_INT 116
86424: PUSH
86425: LD_INT 117
86427: PUSH
86428: LD_INT 118
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: ST_TO_ADDR
86445: GO 89428
86447: LD_INT 3
86449: DOUBLE
86450: EQUAL
86451: IFTRUE 86455
86453: GO 86543
86455: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
86456: LD_ADDR_VAR 0 2
86460: PUSH
86461: LD_INT 2
86463: PUSH
86464: LD_INT 4
86466: PUSH
86467: LD_INT 5
86469: PUSH
86470: LD_INT 11
86472: PUSH
86473: LD_INT 12
86475: PUSH
86476: LD_INT 15
86478: PUSH
86479: LD_INT 16
86481: PUSH
86482: LD_INT 22
86484: PUSH
86485: LD_INT 26
86487: PUSH
86488: LD_INT 36
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: PUSH
86503: LD_INT 101
86505: PUSH
86506: LD_INT 102
86508: PUSH
86509: LD_INT 105
86511: PUSH
86512: LD_INT 106
86514: PUSH
86515: LD_INT 108
86517: PUSH
86518: LD_INT 116
86520: PUSH
86521: LD_INT 117
86523: PUSH
86524: LD_INT 118
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: ST_TO_ADDR
86541: GO 89428
86543: LD_INT 4
86545: DOUBLE
86546: EQUAL
86547: IFTRUE 86551
86549: GO 86647
86551: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
86552: LD_ADDR_VAR 0 2
86556: PUSH
86557: LD_INT 2
86559: PUSH
86560: LD_INT 4
86562: PUSH
86563: LD_INT 5
86565: PUSH
86566: LD_INT 8
86568: PUSH
86569: LD_INT 11
86571: PUSH
86572: LD_INT 12
86574: PUSH
86575: LD_INT 15
86577: PUSH
86578: LD_INT 16
86580: PUSH
86581: LD_INT 22
86583: PUSH
86584: LD_INT 23
86586: PUSH
86587: LD_INT 26
86589: PUSH
86590: LD_INT 36
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 101
86609: PUSH
86610: LD_INT 102
86612: PUSH
86613: LD_INT 105
86615: PUSH
86616: LD_INT 106
86618: PUSH
86619: LD_INT 108
86621: PUSH
86622: LD_INT 116
86624: PUSH
86625: LD_INT 117
86627: PUSH
86628: LD_INT 118
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: ST_TO_ADDR
86645: GO 89428
86647: LD_INT 5
86649: DOUBLE
86650: EQUAL
86651: IFTRUE 86655
86653: GO 86767
86655: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
86656: LD_ADDR_VAR 0 2
86660: PUSH
86661: LD_INT 2
86663: PUSH
86664: LD_INT 4
86666: PUSH
86667: LD_INT 5
86669: PUSH
86670: LD_INT 6
86672: PUSH
86673: LD_INT 8
86675: PUSH
86676: LD_INT 11
86678: PUSH
86679: LD_INT 12
86681: PUSH
86682: LD_INT 15
86684: PUSH
86685: LD_INT 16
86687: PUSH
86688: LD_INT 22
86690: PUSH
86691: LD_INT 23
86693: PUSH
86694: LD_INT 25
86696: PUSH
86697: LD_INT 26
86699: PUSH
86700: LD_INT 36
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: LIST
86707: LIST
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 101
86721: PUSH
86722: LD_INT 102
86724: PUSH
86725: LD_INT 105
86727: PUSH
86728: LD_INT 106
86730: PUSH
86731: LD_INT 108
86733: PUSH
86734: LD_INT 109
86736: PUSH
86737: LD_INT 112
86739: PUSH
86740: LD_INT 116
86742: PUSH
86743: LD_INT 117
86745: PUSH
86746: LD_INT 118
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: LIST
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: ST_TO_ADDR
86765: GO 89428
86767: LD_INT 6
86769: DOUBLE
86770: EQUAL
86771: IFTRUE 86775
86773: GO 86907
86775: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
86776: LD_ADDR_VAR 0 2
86780: PUSH
86781: LD_INT 2
86783: PUSH
86784: LD_INT 4
86786: PUSH
86787: LD_INT 5
86789: PUSH
86790: LD_INT 6
86792: PUSH
86793: LD_INT 8
86795: PUSH
86796: LD_INT 11
86798: PUSH
86799: LD_INT 12
86801: PUSH
86802: LD_INT 15
86804: PUSH
86805: LD_INT 16
86807: PUSH
86808: LD_INT 20
86810: PUSH
86811: LD_INT 21
86813: PUSH
86814: LD_INT 22
86816: PUSH
86817: LD_INT 23
86819: PUSH
86820: LD_INT 25
86822: PUSH
86823: LD_INT 26
86825: PUSH
86826: LD_INT 30
86828: PUSH
86829: LD_INT 31
86831: PUSH
86832: LD_INT 32
86834: PUSH
86835: LD_INT 36
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: LIST
86845: LIST
86846: LIST
86847: LIST
86848: LIST
86849: LIST
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 101
86861: PUSH
86862: LD_INT 102
86864: PUSH
86865: LD_INT 105
86867: PUSH
86868: LD_INT 106
86870: PUSH
86871: LD_INT 108
86873: PUSH
86874: LD_INT 109
86876: PUSH
86877: LD_INT 112
86879: PUSH
86880: LD_INT 116
86882: PUSH
86883: LD_INT 117
86885: PUSH
86886: LD_INT 118
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: ST_TO_ADDR
86905: GO 89428
86907: LD_INT 7
86909: DOUBLE
86910: EQUAL
86911: IFTRUE 86915
86913: GO 87027
86915: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
86916: LD_ADDR_VAR 0 2
86920: PUSH
86921: LD_INT 2
86923: PUSH
86924: LD_INT 4
86926: PUSH
86927: LD_INT 5
86929: PUSH
86930: LD_INT 7
86932: PUSH
86933: LD_INT 11
86935: PUSH
86936: LD_INT 12
86938: PUSH
86939: LD_INT 15
86941: PUSH
86942: LD_INT 16
86944: PUSH
86945: LD_INT 20
86947: PUSH
86948: LD_INT 21
86950: PUSH
86951: LD_INT 22
86953: PUSH
86954: LD_INT 23
86956: PUSH
86957: LD_INT 25
86959: PUSH
86960: LD_INT 26
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 101
86981: PUSH
86982: LD_INT 102
86984: PUSH
86985: LD_INT 103
86987: PUSH
86988: LD_INT 105
86990: PUSH
86991: LD_INT 106
86993: PUSH
86994: LD_INT 108
86996: PUSH
86997: LD_INT 112
86999: PUSH
87000: LD_INT 116
87002: PUSH
87003: LD_INT 117
87005: PUSH
87006: LD_INT 118
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: ST_TO_ADDR
87025: GO 89428
87027: LD_INT 8
87029: DOUBLE
87030: EQUAL
87031: IFTRUE 87035
87033: GO 87175
87035: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
87036: LD_ADDR_VAR 0 2
87040: PUSH
87041: LD_INT 2
87043: PUSH
87044: LD_INT 4
87046: PUSH
87047: LD_INT 5
87049: PUSH
87050: LD_INT 6
87052: PUSH
87053: LD_INT 7
87055: PUSH
87056: LD_INT 8
87058: PUSH
87059: LD_INT 11
87061: PUSH
87062: LD_INT 12
87064: PUSH
87065: LD_INT 15
87067: PUSH
87068: LD_INT 16
87070: PUSH
87071: LD_INT 20
87073: PUSH
87074: LD_INT 21
87076: PUSH
87077: LD_INT 22
87079: PUSH
87080: LD_INT 23
87082: PUSH
87083: LD_INT 25
87085: PUSH
87086: LD_INT 26
87088: PUSH
87089: LD_INT 30
87091: PUSH
87092: LD_INT 31
87094: PUSH
87095: LD_INT 32
87097: PUSH
87098: LD_INT 36
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 101
87125: PUSH
87126: LD_INT 102
87128: PUSH
87129: LD_INT 103
87131: PUSH
87132: LD_INT 105
87134: PUSH
87135: LD_INT 106
87137: PUSH
87138: LD_INT 108
87140: PUSH
87141: LD_INT 109
87143: PUSH
87144: LD_INT 112
87146: PUSH
87147: LD_INT 116
87149: PUSH
87150: LD_INT 117
87152: PUSH
87153: LD_INT 118
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: ST_TO_ADDR
87173: GO 89428
87175: LD_INT 9
87177: DOUBLE
87178: EQUAL
87179: IFTRUE 87183
87181: GO 87331
87183: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
87184: LD_ADDR_VAR 0 2
87188: PUSH
87189: LD_INT 2
87191: PUSH
87192: LD_INT 4
87194: PUSH
87195: LD_INT 5
87197: PUSH
87198: LD_INT 6
87200: PUSH
87201: LD_INT 7
87203: PUSH
87204: LD_INT 8
87206: PUSH
87207: LD_INT 11
87209: PUSH
87210: LD_INT 12
87212: PUSH
87213: LD_INT 15
87215: PUSH
87216: LD_INT 16
87218: PUSH
87219: LD_INT 20
87221: PUSH
87222: LD_INT 21
87224: PUSH
87225: LD_INT 22
87227: PUSH
87228: LD_INT 23
87230: PUSH
87231: LD_INT 25
87233: PUSH
87234: LD_INT 26
87236: PUSH
87237: LD_INT 28
87239: PUSH
87240: LD_INT 30
87242: PUSH
87243: LD_INT 31
87245: PUSH
87246: LD_INT 32
87248: PUSH
87249: LD_INT 36
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 101
87277: PUSH
87278: LD_INT 102
87280: PUSH
87281: LD_INT 103
87283: PUSH
87284: LD_INT 105
87286: PUSH
87287: LD_INT 106
87289: PUSH
87290: LD_INT 108
87292: PUSH
87293: LD_INT 109
87295: PUSH
87296: LD_INT 112
87298: PUSH
87299: LD_INT 114
87301: PUSH
87302: LD_INT 116
87304: PUSH
87305: LD_INT 117
87307: PUSH
87308: LD_INT 118
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: ST_TO_ADDR
87329: GO 89428
87331: LD_INT 10
87333: DOUBLE
87334: EQUAL
87335: IFTRUE 87339
87337: GO 87535
87339: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
87340: LD_ADDR_VAR 0 2
87344: PUSH
87345: LD_INT 2
87347: PUSH
87348: LD_INT 4
87350: PUSH
87351: LD_INT 5
87353: PUSH
87354: LD_INT 6
87356: PUSH
87357: LD_INT 7
87359: PUSH
87360: LD_INT 8
87362: PUSH
87363: LD_INT 9
87365: PUSH
87366: LD_INT 10
87368: PUSH
87369: LD_INT 11
87371: PUSH
87372: LD_INT 12
87374: PUSH
87375: LD_INT 13
87377: PUSH
87378: LD_INT 14
87380: PUSH
87381: LD_INT 15
87383: PUSH
87384: LD_INT 16
87386: PUSH
87387: LD_INT 17
87389: PUSH
87390: LD_INT 18
87392: PUSH
87393: LD_INT 19
87395: PUSH
87396: LD_INT 20
87398: PUSH
87399: LD_INT 21
87401: PUSH
87402: LD_INT 22
87404: PUSH
87405: LD_INT 23
87407: PUSH
87408: LD_INT 24
87410: PUSH
87411: LD_INT 25
87413: PUSH
87414: LD_INT 26
87416: PUSH
87417: LD_INT 28
87419: PUSH
87420: LD_INT 30
87422: PUSH
87423: LD_INT 31
87425: PUSH
87426: LD_INT 32
87428: PUSH
87429: LD_INT 36
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: PUSH
87463: LD_INT 101
87465: PUSH
87466: LD_INT 102
87468: PUSH
87469: LD_INT 103
87471: PUSH
87472: LD_INT 104
87474: PUSH
87475: LD_INT 105
87477: PUSH
87478: LD_INT 106
87480: PUSH
87481: LD_INT 107
87483: PUSH
87484: LD_INT 108
87486: PUSH
87487: LD_INT 109
87489: PUSH
87490: LD_INT 110
87492: PUSH
87493: LD_INT 111
87495: PUSH
87496: LD_INT 112
87498: PUSH
87499: LD_INT 114
87501: PUSH
87502: LD_INT 116
87504: PUSH
87505: LD_INT 117
87507: PUSH
87508: LD_INT 118
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: ST_TO_ADDR
87533: GO 89428
87535: LD_INT 11
87537: DOUBLE
87538: EQUAL
87539: IFTRUE 87543
87541: GO 87747
87543: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
87544: LD_ADDR_VAR 0 2
87548: PUSH
87549: LD_INT 2
87551: PUSH
87552: LD_INT 3
87554: PUSH
87555: LD_INT 4
87557: PUSH
87558: LD_INT 5
87560: PUSH
87561: LD_INT 6
87563: PUSH
87564: LD_INT 7
87566: PUSH
87567: LD_INT 8
87569: PUSH
87570: LD_INT 9
87572: PUSH
87573: LD_INT 10
87575: PUSH
87576: LD_INT 11
87578: PUSH
87579: LD_INT 12
87581: PUSH
87582: LD_INT 13
87584: PUSH
87585: LD_INT 14
87587: PUSH
87588: LD_INT 15
87590: PUSH
87591: LD_INT 16
87593: PUSH
87594: LD_INT 17
87596: PUSH
87597: LD_INT 18
87599: PUSH
87600: LD_INT 19
87602: PUSH
87603: LD_INT 20
87605: PUSH
87606: LD_INT 21
87608: PUSH
87609: LD_INT 22
87611: PUSH
87612: LD_INT 23
87614: PUSH
87615: LD_INT 24
87617: PUSH
87618: LD_INT 25
87620: PUSH
87621: LD_INT 26
87623: PUSH
87624: LD_INT 28
87626: PUSH
87627: LD_INT 30
87629: PUSH
87630: LD_INT 31
87632: PUSH
87633: LD_INT 32
87635: PUSH
87636: LD_INT 34
87638: PUSH
87639: LD_INT 36
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: LIST
87649: LIST
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 101
87677: PUSH
87678: LD_INT 102
87680: PUSH
87681: LD_INT 103
87683: PUSH
87684: LD_INT 104
87686: PUSH
87687: LD_INT 105
87689: PUSH
87690: LD_INT 106
87692: PUSH
87693: LD_INT 107
87695: PUSH
87696: LD_INT 108
87698: PUSH
87699: LD_INT 109
87701: PUSH
87702: LD_INT 110
87704: PUSH
87705: LD_INT 111
87707: PUSH
87708: LD_INT 112
87710: PUSH
87711: LD_INT 114
87713: PUSH
87714: LD_INT 116
87716: PUSH
87717: LD_INT 117
87719: PUSH
87720: LD_INT 118
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: ST_TO_ADDR
87745: GO 89428
87747: LD_INT 12
87749: DOUBLE
87750: EQUAL
87751: IFTRUE 87755
87753: GO 87975
87755: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
87756: LD_ADDR_VAR 0 2
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: LD_INT 2
87766: PUSH
87767: LD_INT 3
87769: PUSH
87770: LD_INT 4
87772: PUSH
87773: LD_INT 5
87775: PUSH
87776: LD_INT 6
87778: PUSH
87779: LD_INT 7
87781: PUSH
87782: LD_INT 8
87784: PUSH
87785: LD_INT 9
87787: PUSH
87788: LD_INT 10
87790: PUSH
87791: LD_INT 11
87793: PUSH
87794: LD_INT 12
87796: PUSH
87797: LD_INT 13
87799: PUSH
87800: LD_INT 14
87802: PUSH
87803: LD_INT 15
87805: PUSH
87806: LD_INT 16
87808: PUSH
87809: LD_INT 17
87811: PUSH
87812: LD_INT 18
87814: PUSH
87815: LD_INT 19
87817: PUSH
87818: LD_INT 20
87820: PUSH
87821: LD_INT 21
87823: PUSH
87824: LD_INT 22
87826: PUSH
87827: LD_INT 23
87829: PUSH
87830: LD_INT 24
87832: PUSH
87833: LD_INT 25
87835: PUSH
87836: LD_INT 26
87838: PUSH
87839: LD_INT 27
87841: PUSH
87842: LD_INT 28
87844: PUSH
87845: LD_INT 30
87847: PUSH
87848: LD_INT 31
87850: PUSH
87851: LD_INT 32
87853: PUSH
87854: LD_INT 33
87856: PUSH
87857: LD_INT 34
87859: PUSH
87860: LD_INT 36
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 101
87901: PUSH
87902: LD_INT 102
87904: PUSH
87905: LD_INT 103
87907: PUSH
87908: LD_INT 104
87910: PUSH
87911: LD_INT 105
87913: PUSH
87914: LD_INT 106
87916: PUSH
87917: LD_INT 107
87919: PUSH
87920: LD_INT 108
87922: PUSH
87923: LD_INT 109
87925: PUSH
87926: LD_INT 110
87928: PUSH
87929: LD_INT 111
87931: PUSH
87932: LD_INT 112
87934: PUSH
87935: LD_INT 113
87937: PUSH
87938: LD_INT 114
87940: PUSH
87941: LD_INT 116
87943: PUSH
87944: LD_INT 117
87946: PUSH
87947: LD_INT 118
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: ST_TO_ADDR
87973: GO 89428
87975: LD_INT 13
87977: DOUBLE
87978: EQUAL
87979: IFTRUE 87983
87981: GO 88191
87983: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
87984: LD_ADDR_VAR 0 2
87988: PUSH
87989: LD_INT 1
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: LD_INT 3
87997: PUSH
87998: LD_INT 4
88000: PUSH
88001: LD_INT 5
88003: PUSH
88004: LD_INT 8
88006: PUSH
88007: LD_INT 9
88009: PUSH
88010: LD_INT 10
88012: PUSH
88013: LD_INT 11
88015: PUSH
88016: LD_INT 12
88018: PUSH
88019: LD_INT 14
88021: PUSH
88022: LD_INT 15
88024: PUSH
88025: LD_INT 16
88027: PUSH
88028: LD_INT 17
88030: PUSH
88031: LD_INT 18
88033: PUSH
88034: LD_INT 19
88036: PUSH
88037: LD_INT 20
88039: PUSH
88040: LD_INT 21
88042: PUSH
88043: LD_INT 22
88045: PUSH
88046: LD_INT 23
88048: PUSH
88049: LD_INT 24
88051: PUSH
88052: LD_INT 25
88054: PUSH
88055: LD_INT 26
88057: PUSH
88058: LD_INT 27
88060: PUSH
88061: LD_INT 28
88063: PUSH
88064: LD_INT 30
88066: PUSH
88067: LD_INT 31
88069: PUSH
88070: LD_INT 32
88072: PUSH
88073: LD_INT 33
88075: PUSH
88076: LD_INT 34
88078: PUSH
88079: LD_INT 36
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 101
88117: PUSH
88118: LD_INT 102
88120: PUSH
88121: LD_INT 103
88123: PUSH
88124: LD_INT 104
88126: PUSH
88127: LD_INT 105
88129: PUSH
88130: LD_INT 106
88132: PUSH
88133: LD_INT 107
88135: PUSH
88136: LD_INT 108
88138: PUSH
88139: LD_INT 109
88141: PUSH
88142: LD_INT 110
88144: PUSH
88145: LD_INT 111
88147: PUSH
88148: LD_INT 112
88150: PUSH
88151: LD_INT 113
88153: PUSH
88154: LD_INT 114
88156: PUSH
88157: LD_INT 116
88159: PUSH
88160: LD_INT 117
88162: PUSH
88163: LD_INT 118
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: ST_TO_ADDR
88189: GO 89428
88191: LD_INT 14
88193: DOUBLE
88194: EQUAL
88195: IFTRUE 88199
88197: GO 88423
88199: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
88200: LD_ADDR_VAR 0 2
88204: PUSH
88205: LD_INT 1
88207: PUSH
88208: LD_INT 2
88210: PUSH
88211: LD_INT 3
88213: PUSH
88214: LD_INT 4
88216: PUSH
88217: LD_INT 5
88219: PUSH
88220: LD_INT 6
88222: PUSH
88223: LD_INT 7
88225: PUSH
88226: LD_INT 8
88228: PUSH
88229: LD_INT 9
88231: PUSH
88232: LD_INT 10
88234: PUSH
88235: LD_INT 11
88237: PUSH
88238: LD_INT 12
88240: PUSH
88241: LD_INT 13
88243: PUSH
88244: LD_INT 14
88246: PUSH
88247: LD_INT 15
88249: PUSH
88250: LD_INT 16
88252: PUSH
88253: LD_INT 17
88255: PUSH
88256: LD_INT 18
88258: PUSH
88259: LD_INT 19
88261: PUSH
88262: LD_INT 20
88264: PUSH
88265: LD_INT 21
88267: PUSH
88268: LD_INT 22
88270: PUSH
88271: LD_INT 23
88273: PUSH
88274: LD_INT 24
88276: PUSH
88277: LD_INT 25
88279: PUSH
88280: LD_INT 26
88282: PUSH
88283: LD_INT 27
88285: PUSH
88286: LD_INT 28
88288: PUSH
88289: LD_INT 29
88291: PUSH
88292: LD_INT 30
88294: PUSH
88295: LD_INT 31
88297: PUSH
88298: LD_INT 32
88300: PUSH
88301: LD_INT 33
88303: PUSH
88304: LD_INT 34
88306: PUSH
88307: LD_INT 36
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 101
88349: PUSH
88350: LD_INT 102
88352: PUSH
88353: LD_INT 103
88355: PUSH
88356: LD_INT 104
88358: PUSH
88359: LD_INT 105
88361: PUSH
88362: LD_INT 106
88364: PUSH
88365: LD_INT 107
88367: PUSH
88368: LD_INT 108
88370: PUSH
88371: LD_INT 109
88373: PUSH
88374: LD_INT 110
88376: PUSH
88377: LD_INT 111
88379: PUSH
88380: LD_INT 112
88382: PUSH
88383: LD_INT 113
88385: PUSH
88386: LD_INT 114
88388: PUSH
88389: LD_INT 116
88391: PUSH
88392: LD_INT 117
88394: PUSH
88395: LD_INT 118
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: ST_TO_ADDR
88421: GO 89428
88423: LD_INT 15
88425: DOUBLE
88426: EQUAL
88427: IFTRUE 88431
88429: GO 88655
88431: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
88432: LD_ADDR_VAR 0 2
88436: PUSH
88437: LD_INT 1
88439: PUSH
88440: LD_INT 2
88442: PUSH
88443: LD_INT 3
88445: PUSH
88446: LD_INT 4
88448: PUSH
88449: LD_INT 5
88451: PUSH
88452: LD_INT 6
88454: PUSH
88455: LD_INT 7
88457: PUSH
88458: LD_INT 8
88460: PUSH
88461: LD_INT 9
88463: PUSH
88464: LD_INT 10
88466: PUSH
88467: LD_INT 11
88469: PUSH
88470: LD_INT 12
88472: PUSH
88473: LD_INT 13
88475: PUSH
88476: LD_INT 14
88478: PUSH
88479: LD_INT 15
88481: PUSH
88482: LD_INT 16
88484: PUSH
88485: LD_INT 17
88487: PUSH
88488: LD_INT 18
88490: PUSH
88491: LD_INT 19
88493: PUSH
88494: LD_INT 20
88496: PUSH
88497: LD_INT 21
88499: PUSH
88500: LD_INT 22
88502: PUSH
88503: LD_INT 23
88505: PUSH
88506: LD_INT 24
88508: PUSH
88509: LD_INT 25
88511: PUSH
88512: LD_INT 26
88514: PUSH
88515: LD_INT 27
88517: PUSH
88518: LD_INT 28
88520: PUSH
88521: LD_INT 29
88523: PUSH
88524: LD_INT 30
88526: PUSH
88527: LD_INT 31
88529: PUSH
88530: LD_INT 32
88532: PUSH
88533: LD_INT 33
88535: PUSH
88536: LD_INT 34
88538: PUSH
88539: LD_INT 36
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 101
88581: PUSH
88582: LD_INT 102
88584: PUSH
88585: LD_INT 103
88587: PUSH
88588: LD_INT 104
88590: PUSH
88591: LD_INT 105
88593: PUSH
88594: LD_INT 106
88596: PUSH
88597: LD_INT 107
88599: PUSH
88600: LD_INT 108
88602: PUSH
88603: LD_INT 109
88605: PUSH
88606: LD_INT 110
88608: PUSH
88609: LD_INT 111
88611: PUSH
88612: LD_INT 112
88614: PUSH
88615: LD_INT 113
88617: PUSH
88618: LD_INT 114
88620: PUSH
88621: LD_INT 116
88623: PUSH
88624: LD_INT 117
88626: PUSH
88627: LD_INT 118
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: ST_TO_ADDR
88653: GO 89428
88655: LD_INT 16
88657: DOUBLE
88658: EQUAL
88659: IFTRUE 88663
88661: GO 88799
88663: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
88664: LD_ADDR_VAR 0 2
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: LD_INT 4
88674: PUSH
88675: LD_INT 5
88677: PUSH
88678: LD_INT 7
88680: PUSH
88681: LD_INT 11
88683: PUSH
88684: LD_INT 12
88686: PUSH
88687: LD_INT 15
88689: PUSH
88690: LD_INT 16
88692: PUSH
88693: LD_INT 20
88695: PUSH
88696: LD_INT 21
88698: PUSH
88699: LD_INT 22
88701: PUSH
88702: LD_INT 23
88704: PUSH
88705: LD_INT 25
88707: PUSH
88708: LD_INT 26
88710: PUSH
88711: LD_INT 30
88713: PUSH
88714: LD_INT 31
88716: PUSH
88717: LD_INT 32
88719: PUSH
88720: LD_INT 33
88722: PUSH
88723: LD_INT 34
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 101
88749: PUSH
88750: LD_INT 102
88752: PUSH
88753: LD_INT 103
88755: PUSH
88756: LD_INT 106
88758: PUSH
88759: LD_INT 108
88761: PUSH
88762: LD_INT 112
88764: PUSH
88765: LD_INT 113
88767: PUSH
88768: LD_INT 114
88770: PUSH
88771: LD_INT 116
88773: PUSH
88774: LD_INT 117
88776: PUSH
88777: LD_INT 118
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: ST_TO_ADDR
88797: GO 89428
88799: LD_INT 17
88801: DOUBLE
88802: EQUAL
88803: IFTRUE 88807
88805: GO 89031
88807: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
88808: LD_ADDR_VAR 0 2
88812: PUSH
88813: LD_INT 1
88815: PUSH
88816: LD_INT 2
88818: PUSH
88819: LD_INT 3
88821: PUSH
88822: LD_INT 4
88824: PUSH
88825: LD_INT 5
88827: PUSH
88828: LD_INT 6
88830: PUSH
88831: LD_INT 7
88833: PUSH
88834: LD_INT 8
88836: PUSH
88837: LD_INT 9
88839: PUSH
88840: LD_INT 10
88842: PUSH
88843: LD_INT 11
88845: PUSH
88846: LD_INT 12
88848: PUSH
88849: LD_INT 13
88851: PUSH
88852: LD_INT 14
88854: PUSH
88855: LD_INT 15
88857: PUSH
88858: LD_INT 16
88860: PUSH
88861: LD_INT 17
88863: PUSH
88864: LD_INT 18
88866: PUSH
88867: LD_INT 19
88869: PUSH
88870: LD_INT 20
88872: PUSH
88873: LD_INT 21
88875: PUSH
88876: LD_INT 22
88878: PUSH
88879: LD_INT 23
88881: PUSH
88882: LD_INT 24
88884: PUSH
88885: LD_INT 25
88887: PUSH
88888: LD_INT 26
88890: PUSH
88891: LD_INT 27
88893: PUSH
88894: LD_INT 28
88896: PUSH
88897: LD_INT 29
88899: PUSH
88900: LD_INT 30
88902: PUSH
88903: LD_INT 31
88905: PUSH
88906: LD_INT 32
88908: PUSH
88909: LD_INT 33
88911: PUSH
88912: LD_INT 34
88914: PUSH
88915: LD_INT 36
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 101
88957: PUSH
88958: LD_INT 102
88960: PUSH
88961: LD_INT 103
88963: PUSH
88964: LD_INT 104
88966: PUSH
88967: LD_INT 105
88969: PUSH
88970: LD_INT 106
88972: PUSH
88973: LD_INT 107
88975: PUSH
88976: LD_INT 108
88978: PUSH
88979: LD_INT 109
88981: PUSH
88982: LD_INT 110
88984: PUSH
88985: LD_INT 111
88987: PUSH
88988: LD_INT 112
88990: PUSH
88991: LD_INT 113
88993: PUSH
88994: LD_INT 114
88996: PUSH
88997: LD_INT 116
88999: PUSH
89000: LD_INT 117
89002: PUSH
89003: LD_INT 118
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: ST_TO_ADDR
89029: GO 89428
89031: LD_INT 18
89033: DOUBLE
89034: EQUAL
89035: IFTRUE 89039
89037: GO 89187
89039: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
89040: LD_ADDR_VAR 0 2
89044: PUSH
89045: LD_INT 2
89047: PUSH
89048: LD_INT 4
89050: PUSH
89051: LD_INT 5
89053: PUSH
89054: LD_INT 7
89056: PUSH
89057: LD_INT 11
89059: PUSH
89060: LD_INT 12
89062: PUSH
89063: LD_INT 15
89065: PUSH
89066: LD_INT 16
89068: PUSH
89069: LD_INT 20
89071: PUSH
89072: LD_INT 21
89074: PUSH
89075: LD_INT 22
89077: PUSH
89078: LD_INT 23
89080: PUSH
89081: LD_INT 25
89083: PUSH
89084: LD_INT 26
89086: PUSH
89087: LD_INT 30
89089: PUSH
89090: LD_INT 31
89092: PUSH
89093: LD_INT 32
89095: PUSH
89096: LD_INT 33
89098: PUSH
89099: LD_INT 34
89101: PUSH
89102: LD_INT 35
89104: PUSH
89105: LD_INT 36
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 101
89133: PUSH
89134: LD_INT 102
89136: PUSH
89137: LD_INT 103
89139: PUSH
89140: LD_INT 106
89142: PUSH
89143: LD_INT 108
89145: PUSH
89146: LD_INT 112
89148: PUSH
89149: LD_INT 113
89151: PUSH
89152: LD_INT 114
89154: PUSH
89155: LD_INT 115
89157: PUSH
89158: LD_INT 116
89160: PUSH
89161: LD_INT 117
89163: PUSH
89164: LD_INT 118
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: ST_TO_ADDR
89185: GO 89428
89187: LD_INT 19
89189: DOUBLE
89190: EQUAL
89191: IFTRUE 89195
89193: GO 89427
89195: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
89196: LD_ADDR_VAR 0 2
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: LD_INT 2
89206: PUSH
89207: LD_INT 3
89209: PUSH
89210: LD_INT 4
89212: PUSH
89213: LD_INT 5
89215: PUSH
89216: LD_INT 6
89218: PUSH
89219: LD_INT 7
89221: PUSH
89222: LD_INT 8
89224: PUSH
89225: LD_INT 9
89227: PUSH
89228: LD_INT 10
89230: PUSH
89231: LD_INT 11
89233: PUSH
89234: LD_INT 12
89236: PUSH
89237: LD_INT 13
89239: PUSH
89240: LD_INT 14
89242: PUSH
89243: LD_INT 15
89245: PUSH
89246: LD_INT 16
89248: PUSH
89249: LD_INT 17
89251: PUSH
89252: LD_INT 18
89254: PUSH
89255: LD_INT 19
89257: PUSH
89258: LD_INT 20
89260: PUSH
89261: LD_INT 21
89263: PUSH
89264: LD_INT 22
89266: PUSH
89267: LD_INT 23
89269: PUSH
89270: LD_INT 24
89272: PUSH
89273: LD_INT 25
89275: PUSH
89276: LD_INT 26
89278: PUSH
89279: LD_INT 27
89281: PUSH
89282: LD_INT 28
89284: PUSH
89285: LD_INT 29
89287: PUSH
89288: LD_INT 30
89290: PUSH
89291: LD_INT 31
89293: PUSH
89294: LD_INT 32
89296: PUSH
89297: LD_INT 33
89299: PUSH
89300: LD_INT 34
89302: PUSH
89303: LD_INT 35
89305: PUSH
89306: LD_INT 36
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 101
89349: PUSH
89350: LD_INT 102
89352: PUSH
89353: LD_INT 103
89355: PUSH
89356: LD_INT 104
89358: PUSH
89359: LD_INT 105
89361: PUSH
89362: LD_INT 106
89364: PUSH
89365: LD_INT 107
89367: PUSH
89368: LD_INT 108
89370: PUSH
89371: LD_INT 109
89373: PUSH
89374: LD_INT 110
89376: PUSH
89377: LD_INT 111
89379: PUSH
89380: LD_INT 112
89382: PUSH
89383: LD_INT 113
89385: PUSH
89386: LD_INT 114
89388: PUSH
89389: LD_INT 115
89391: PUSH
89392: LD_INT 116
89394: PUSH
89395: LD_INT 117
89397: PUSH
89398: LD_INT 118
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: ST_TO_ADDR
89425: GO 89428
89427: POP
// end else
89428: GO 89659
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
89430: LD_ADDR_VAR 0 2
89434: PUSH
89435: LD_INT 1
89437: PUSH
89438: LD_INT 2
89440: PUSH
89441: LD_INT 3
89443: PUSH
89444: LD_INT 4
89446: PUSH
89447: LD_INT 5
89449: PUSH
89450: LD_INT 6
89452: PUSH
89453: LD_INT 7
89455: PUSH
89456: LD_INT 8
89458: PUSH
89459: LD_INT 9
89461: PUSH
89462: LD_INT 10
89464: PUSH
89465: LD_INT 11
89467: PUSH
89468: LD_INT 12
89470: PUSH
89471: LD_INT 13
89473: PUSH
89474: LD_INT 14
89476: PUSH
89477: LD_INT 15
89479: PUSH
89480: LD_INT 16
89482: PUSH
89483: LD_INT 17
89485: PUSH
89486: LD_INT 18
89488: PUSH
89489: LD_INT 19
89491: PUSH
89492: LD_INT 20
89494: PUSH
89495: LD_INT 21
89497: PUSH
89498: LD_INT 22
89500: PUSH
89501: LD_INT 23
89503: PUSH
89504: LD_INT 24
89506: PUSH
89507: LD_INT 25
89509: PUSH
89510: LD_INT 26
89512: PUSH
89513: LD_INT 27
89515: PUSH
89516: LD_INT 28
89518: PUSH
89519: LD_INT 29
89521: PUSH
89522: LD_INT 30
89524: PUSH
89525: LD_INT 31
89527: PUSH
89528: LD_INT 32
89530: PUSH
89531: LD_INT 33
89533: PUSH
89534: LD_INT 34
89536: PUSH
89537: LD_INT 35
89539: PUSH
89540: LD_INT 36
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 101
89583: PUSH
89584: LD_INT 102
89586: PUSH
89587: LD_INT 103
89589: PUSH
89590: LD_INT 104
89592: PUSH
89593: LD_INT 105
89595: PUSH
89596: LD_INT 106
89598: PUSH
89599: LD_INT 107
89601: PUSH
89602: LD_INT 108
89604: PUSH
89605: LD_INT 109
89607: PUSH
89608: LD_INT 110
89610: PUSH
89611: LD_INT 111
89613: PUSH
89614: LD_INT 112
89616: PUSH
89617: LD_INT 113
89619: PUSH
89620: LD_INT 114
89622: PUSH
89623: LD_INT 115
89625: PUSH
89626: LD_INT 116
89628: PUSH
89629: LD_INT 117
89631: PUSH
89632: LD_INT 118
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: ST_TO_ADDR
// if result then
89659: LD_VAR 0 2
89663: IFFALSE 90449
// begin normal :=  ;
89665: LD_ADDR_VAR 0 5
89669: PUSH
89670: LD_STRING 
89672: ST_TO_ADDR
// hardcore :=  ;
89673: LD_ADDR_VAR 0 6
89677: PUSH
89678: LD_STRING 
89680: ST_TO_ADDR
// active :=  ;
89681: LD_ADDR_VAR 0 7
89685: PUSH
89686: LD_STRING 
89688: ST_TO_ADDR
// for i = 1 to normalCounter do
89689: LD_ADDR_VAR 0 8
89693: PUSH
89694: DOUBLE
89695: LD_INT 1
89697: DEC
89698: ST_TO_ADDR
89699: LD_EXP 115
89703: PUSH
89704: FOR_TO
89705: IFFALSE 89806
// begin tmp := 0 ;
89707: LD_ADDR_VAR 0 3
89711: PUSH
89712: LD_STRING 0
89714: ST_TO_ADDR
// if result [ 1 ] then
89715: LD_VAR 0 2
89719: PUSH
89720: LD_INT 1
89722: ARRAY
89723: IFFALSE 89788
// if result [ 1 ] [ 1 ] = i then
89725: LD_VAR 0 2
89729: PUSH
89730: LD_INT 1
89732: ARRAY
89733: PUSH
89734: LD_INT 1
89736: ARRAY
89737: PUSH
89738: LD_VAR 0 8
89742: EQUAL
89743: IFFALSE 89788
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89745: LD_ADDR_VAR 0 2
89749: PUSH
89750: LD_VAR 0 2
89754: PPUSH
89755: LD_INT 1
89757: PPUSH
89758: LD_VAR 0 2
89762: PUSH
89763: LD_INT 1
89765: ARRAY
89766: PPUSH
89767: LD_INT 1
89769: PPUSH
89770: CALL_OW 3
89774: PPUSH
89775: CALL_OW 1
89779: ST_TO_ADDR
// tmp := 1 ;
89780: LD_ADDR_VAR 0 3
89784: PUSH
89785: LD_STRING 1
89787: ST_TO_ADDR
// end ; normal := normal & tmp ;
89788: LD_ADDR_VAR 0 5
89792: PUSH
89793: LD_VAR 0 5
89797: PUSH
89798: LD_VAR 0 3
89802: STR
89803: ST_TO_ADDR
// end ;
89804: GO 89704
89806: POP
89807: POP
// for i = 1 to hardcoreCounter do
89808: LD_ADDR_VAR 0 8
89812: PUSH
89813: DOUBLE
89814: LD_INT 1
89816: DEC
89817: ST_TO_ADDR
89818: LD_EXP 116
89822: PUSH
89823: FOR_TO
89824: IFFALSE 89929
// begin tmp := 0 ;
89826: LD_ADDR_VAR 0 3
89830: PUSH
89831: LD_STRING 0
89833: ST_TO_ADDR
// if result [ 2 ] then
89834: LD_VAR 0 2
89838: PUSH
89839: LD_INT 2
89841: ARRAY
89842: IFFALSE 89911
// if result [ 2 ] [ 1 ] = 100 + i then
89844: LD_VAR 0 2
89848: PUSH
89849: LD_INT 2
89851: ARRAY
89852: PUSH
89853: LD_INT 1
89855: ARRAY
89856: PUSH
89857: LD_INT 100
89859: PUSH
89860: LD_VAR 0 8
89864: PLUS
89865: EQUAL
89866: IFFALSE 89911
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89868: LD_ADDR_VAR 0 2
89872: PUSH
89873: LD_VAR 0 2
89877: PPUSH
89878: LD_INT 2
89880: PPUSH
89881: LD_VAR 0 2
89885: PUSH
89886: LD_INT 2
89888: ARRAY
89889: PPUSH
89890: LD_INT 1
89892: PPUSH
89893: CALL_OW 3
89897: PPUSH
89898: CALL_OW 1
89902: ST_TO_ADDR
// tmp := 1 ;
89903: LD_ADDR_VAR 0 3
89907: PUSH
89908: LD_STRING 1
89910: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89911: LD_ADDR_VAR 0 6
89915: PUSH
89916: LD_VAR 0 6
89920: PUSH
89921: LD_VAR 0 3
89925: STR
89926: ST_TO_ADDR
// end ;
89927: GO 89823
89929: POP
89930: POP
// if isGameLoad then
89931: LD_VAR 0 1
89935: IFFALSE 90410
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
89937: LD_ADDR_VAR 0 4
89941: PUSH
89942: LD_EXP 119
89946: PUSH
89947: LD_EXP 118
89951: PUSH
89952: LD_EXP 120
89956: PUSH
89957: LD_EXP 117
89961: PUSH
89962: LD_EXP 121
89966: PUSH
89967: LD_EXP 122
89971: PUSH
89972: LD_EXP 123
89976: PUSH
89977: LD_EXP 124
89981: PUSH
89982: LD_EXP 125
89986: PUSH
89987: LD_EXP 126
89991: PUSH
89992: LD_EXP 127
89996: PUSH
89997: LD_EXP 128
90001: PUSH
90002: LD_EXP 129
90006: PUSH
90007: LD_EXP 130
90011: PUSH
90012: LD_EXP 138
90016: PUSH
90017: LD_EXP 139
90021: PUSH
90022: LD_EXP 140
90026: PUSH
90027: LD_EXP 141
90031: PUSH
90032: LD_EXP 143
90036: PUSH
90037: LD_EXP 144
90041: PUSH
90042: LD_EXP 145
90046: PUSH
90047: LD_EXP 148
90051: PUSH
90052: LD_EXP 150
90056: PUSH
90057: LD_EXP 151
90061: PUSH
90062: LD_EXP 152
90066: PUSH
90067: LD_EXP 154
90071: PUSH
90072: LD_EXP 155
90076: PUSH
90077: LD_EXP 158
90081: PUSH
90082: LD_EXP 159
90086: PUSH
90087: LD_EXP 160
90091: PUSH
90092: LD_EXP 161
90096: PUSH
90097: LD_EXP 162
90101: PUSH
90102: LD_EXP 163
90106: PUSH
90107: LD_EXP 164
90111: PUSH
90112: LD_EXP 165
90116: PUSH
90117: LD_EXP 166
90121: PUSH
90122: LD_EXP 131
90126: PUSH
90127: LD_EXP 132
90131: PUSH
90132: LD_EXP 135
90136: PUSH
90137: LD_EXP 136
90141: PUSH
90142: LD_EXP 137
90146: PUSH
90147: LD_EXP 133
90151: PUSH
90152: LD_EXP 134
90156: PUSH
90157: LD_EXP 142
90161: PUSH
90162: LD_EXP 146
90166: PUSH
90167: LD_EXP 147
90171: PUSH
90172: LD_EXP 149
90176: PUSH
90177: LD_EXP 153
90181: PUSH
90182: LD_EXP 156
90186: PUSH
90187: LD_EXP 157
90191: PUSH
90192: LD_EXP 167
90196: PUSH
90197: LD_EXP 168
90201: PUSH
90202: LD_EXP 169
90206: PUSH
90207: LD_EXP 170
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: ST_TO_ADDR
// tmp :=  ;
90268: LD_ADDR_VAR 0 3
90272: PUSH
90273: LD_STRING 
90275: ST_TO_ADDR
// for i = 1 to normalCounter do
90276: LD_ADDR_VAR 0 8
90280: PUSH
90281: DOUBLE
90282: LD_INT 1
90284: DEC
90285: ST_TO_ADDR
90286: LD_EXP 115
90290: PUSH
90291: FOR_TO
90292: IFFALSE 90328
// begin if flags [ i ] then
90294: LD_VAR 0 4
90298: PUSH
90299: LD_VAR 0 8
90303: ARRAY
90304: IFFALSE 90326
// tmp := tmp & i & ; ;
90306: LD_ADDR_VAR 0 3
90310: PUSH
90311: LD_VAR 0 3
90315: PUSH
90316: LD_VAR 0 8
90320: STR
90321: PUSH
90322: LD_STRING ;
90324: STR
90325: ST_TO_ADDR
// end ;
90326: GO 90291
90328: POP
90329: POP
// for i = 1 to hardcoreCounter do
90330: LD_ADDR_VAR 0 8
90334: PUSH
90335: DOUBLE
90336: LD_INT 1
90338: DEC
90339: ST_TO_ADDR
90340: LD_EXP 116
90344: PUSH
90345: FOR_TO
90346: IFFALSE 90392
// begin if flags [ normalCounter + i ] then
90348: LD_VAR 0 4
90352: PUSH
90353: LD_EXP 115
90357: PUSH
90358: LD_VAR 0 8
90362: PLUS
90363: ARRAY
90364: IFFALSE 90390
// tmp := tmp & ( 100 + i ) & ; ;
90366: LD_ADDR_VAR 0 3
90370: PUSH
90371: LD_VAR 0 3
90375: PUSH
90376: LD_INT 100
90378: PUSH
90379: LD_VAR 0 8
90383: PLUS
90384: STR
90385: PUSH
90386: LD_STRING ;
90388: STR
90389: ST_TO_ADDR
// end ;
90390: GO 90345
90392: POP
90393: POP
// if tmp then
90394: LD_VAR 0 3
90398: IFFALSE 90410
// active := tmp ;
90400: LD_ADDR_VAR 0 7
90404: PUSH
90405: LD_VAR 0 3
90409: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
90410: LD_STRING getStreamItemsFromMission("
90412: PUSH
90413: LD_VAR 0 5
90417: STR
90418: PUSH
90419: LD_STRING ","
90421: STR
90422: PUSH
90423: LD_VAR 0 6
90427: STR
90428: PUSH
90429: LD_STRING ","
90431: STR
90432: PUSH
90433: LD_VAR 0 7
90437: STR
90438: PUSH
90439: LD_STRING ")
90441: STR
90442: PPUSH
90443: CALL_OW 559
// end else
90447: GO 90456
// ToLua ( getStreamItemsFromMission("","","") ) ;
90449: LD_STRING getStreamItemsFromMission("","","")
90451: PPUSH
90452: CALL_OW 559
// end ;
90456: LD_VAR 0 2
90460: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90461: LD_EXP 114
90465: PUSH
90466: LD_EXP 119
90470: AND
90471: IFFALSE 90595
90473: GO 90475
90475: DISABLE
90476: LD_INT 0
90478: PPUSH
90479: PPUSH
// begin enable ;
90480: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90481: LD_ADDR_VAR 0 2
90485: PUSH
90486: LD_INT 22
90488: PUSH
90489: LD_OWVAR 2
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 2
90500: PUSH
90501: LD_INT 34
90503: PUSH
90504: LD_INT 7
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 34
90513: PUSH
90514: LD_INT 45
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 34
90523: PUSH
90524: LD_INT 28
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 34
90533: PUSH
90534: LD_INT 47
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PPUSH
90552: CALL_OW 69
90556: ST_TO_ADDR
// if not tmp then
90557: LD_VAR 0 2
90561: NOT
90562: IFFALSE 90566
// exit ;
90564: GO 90595
// for i in tmp do
90566: LD_ADDR_VAR 0 1
90570: PUSH
90571: LD_VAR 0 2
90575: PUSH
90576: FOR_IN
90577: IFFALSE 90593
// begin SetLives ( i , 0 ) ;
90579: LD_VAR 0 1
90583: PPUSH
90584: LD_INT 0
90586: PPUSH
90587: CALL_OW 234
// end ;
90591: GO 90576
90593: POP
90594: POP
// end ;
90595: PPOPN 2
90597: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90598: LD_EXP 114
90602: PUSH
90603: LD_EXP 120
90607: AND
90608: IFFALSE 90692
90610: GO 90612
90612: DISABLE
90613: LD_INT 0
90615: PPUSH
90616: PPUSH
// begin enable ;
90617: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90618: LD_ADDR_VAR 0 2
90622: PUSH
90623: LD_INT 22
90625: PUSH
90626: LD_OWVAR 2
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 32
90637: PUSH
90638: LD_INT 3
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PPUSH
90649: CALL_OW 69
90653: ST_TO_ADDR
// if not tmp then
90654: LD_VAR 0 2
90658: NOT
90659: IFFALSE 90663
// exit ;
90661: GO 90692
// for i in tmp do
90663: LD_ADDR_VAR 0 1
90667: PUSH
90668: LD_VAR 0 2
90672: PUSH
90673: FOR_IN
90674: IFFALSE 90690
// begin SetLives ( i , 0 ) ;
90676: LD_VAR 0 1
90680: PPUSH
90681: LD_INT 0
90683: PPUSH
90684: CALL_OW 234
// end ;
90688: GO 90673
90690: POP
90691: POP
// end ;
90692: PPOPN 2
90694: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90695: LD_EXP 114
90699: PUSH
90700: LD_EXP 117
90704: AND
90705: IFFALSE 90798
90707: GO 90709
90709: DISABLE
90710: LD_INT 0
90712: PPUSH
// begin enable ;
90713: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90714: LD_ADDR_VAR 0 1
90718: PUSH
90719: LD_INT 22
90721: PUSH
90722: LD_OWVAR 2
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: PUSH
90734: LD_INT 25
90736: PUSH
90737: LD_INT 5
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 25
90746: PUSH
90747: LD_INT 9
90749: PUSH
90750: EMPTY
90751: LIST
90752: LIST
90753: PUSH
90754: LD_INT 25
90756: PUSH
90757: LD_INT 8
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PPUSH
90774: CALL_OW 69
90778: PUSH
90779: FOR_IN
90780: IFFALSE 90796
// begin SetClass ( i , 1 ) ;
90782: LD_VAR 0 1
90786: PPUSH
90787: LD_INT 1
90789: PPUSH
90790: CALL_OW 336
// end ;
90794: GO 90779
90796: POP
90797: POP
// end ;
90798: PPOPN 1
90800: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90801: LD_EXP 114
90805: PUSH
90806: LD_EXP 118
90810: AND
90811: PUSH
90812: LD_OWVAR 65
90816: PUSH
90817: LD_INT 7
90819: LESS
90820: AND
90821: IFFALSE 90835
90823: GO 90825
90825: DISABLE
// begin enable ;
90826: ENABLE
// game_speed := 7 ;
90827: LD_ADDR_OWVAR 65
90831: PUSH
90832: LD_INT 7
90834: ST_TO_ADDR
// end ;
90835: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90836: LD_EXP 114
90840: PUSH
90841: LD_EXP 121
90845: AND
90846: IFFALSE 91048
90848: GO 90850
90850: DISABLE
90851: LD_INT 0
90853: PPUSH
90854: PPUSH
90855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90856: LD_ADDR_VAR 0 3
90860: PUSH
90861: LD_INT 81
90863: PUSH
90864: LD_OWVAR 2
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: LD_INT 21
90875: PUSH
90876: LD_INT 1
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PPUSH
90887: CALL_OW 69
90891: ST_TO_ADDR
// if not tmp then
90892: LD_VAR 0 3
90896: NOT
90897: IFFALSE 90901
// exit ;
90899: GO 91048
// if tmp > 5 then
90901: LD_VAR 0 3
90905: PUSH
90906: LD_INT 5
90908: GREATER
90909: IFFALSE 90921
// k := 5 else
90911: LD_ADDR_VAR 0 2
90915: PUSH
90916: LD_INT 5
90918: ST_TO_ADDR
90919: GO 90931
// k := tmp ;
90921: LD_ADDR_VAR 0 2
90925: PUSH
90926: LD_VAR 0 3
90930: ST_TO_ADDR
// for i := 1 to k do
90931: LD_ADDR_VAR 0 1
90935: PUSH
90936: DOUBLE
90937: LD_INT 1
90939: DEC
90940: ST_TO_ADDR
90941: LD_VAR 0 2
90945: PUSH
90946: FOR_TO
90947: IFFALSE 91046
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90949: LD_VAR 0 3
90953: PUSH
90954: LD_VAR 0 1
90958: ARRAY
90959: PPUSH
90960: LD_VAR 0 1
90964: PUSH
90965: LD_INT 4
90967: MOD
90968: PUSH
90969: LD_INT 1
90971: PLUS
90972: PPUSH
90973: CALL_OW 259
90977: PUSH
90978: LD_INT 10
90980: LESS
90981: IFFALSE 91044
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90983: LD_VAR 0 3
90987: PUSH
90988: LD_VAR 0 1
90992: ARRAY
90993: PPUSH
90994: LD_VAR 0 1
90998: PUSH
90999: LD_INT 4
91001: MOD
91002: PUSH
91003: LD_INT 1
91005: PLUS
91006: PPUSH
91007: LD_VAR 0 3
91011: PUSH
91012: LD_VAR 0 1
91016: ARRAY
91017: PPUSH
91018: LD_VAR 0 1
91022: PUSH
91023: LD_INT 4
91025: MOD
91026: PUSH
91027: LD_INT 1
91029: PLUS
91030: PPUSH
91031: CALL_OW 259
91035: PUSH
91036: LD_INT 1
91038: PLUS
91039: PPUSH
91040: CALL_OW 237
91044: GO 90946
91046: POP
91047: POP
// end ;
91048: PPOPN 3
91050: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
91051: LD_EXP 114
91055: PUSH
91056: LD_EXP 122
91060: AND
91061: IFFALSE 91081
91063: GO 91065
91065: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
91066: LD_INT 4
91068: PPUSH
91069: LD_OWVAR 2
91073: PPUSH
91074: LD_INT 0
91076: PPUSH
91077: CALL_OW 324
91081: END
// every 0 0$1 trigger StreamModeActive and sShovel do
91082: LD_EXP 114
91086: PUSH
91087: LD_EXP 151
91091: AND
91092: IFFALSE 91112
91094: GO 91096
91096: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
91097: LD_INT 19
91099: PPUSH
91100: LD_OWVAR 2
91104: PPUSH
91105: LD_INT 0
91107: PPUSH
91108: CALL_OW 324
91112: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91113: LD_EXP 114
91117: PUSH
91118: LD_EXP 123
91122: AND
91123: IFFALSE 91225
91125: GO 91127
91127: DISABLE
91128: LD_INT 0
91130: PPUSH
91131: PPUSH
// begin enable ;
91132: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91133: LD_ADDR_VAR 0 2
91137: PUSH
91138: LD_INT 22
91140: PUSH
91141: LD_OWVAR 2
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: LD_INT 2
91152: PUSH
91153: LD_INT 34
91155: PUSH
91156: LD_INT 11
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 34
91165: PUSH
91166: LD_INT 30
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: LIST
91177: PUSH
91178: EMPTY
91179: LIST
91180: LIST
91181: PPUSH
91182: CALL_OW 69
91186: ST_TO_ADDR
// if not tmp then
91187: LD_VAR 0 2
91191: NOT
91192: IFFALSE 91196
// exit ;
91194: GO 91225
// for i in tmp do
91196: LD_ADDR_VAR 0 1
91200: PUSH
91201: LD_VAR 0 2
91205: PUSH
91206: FOR_IN
91207: IFFALSE 91223
// begin SetLives ( i , 0 ) ;
91209: LD_VAR 0 1
91213: PPUSH
91214: LD_INT 0
91216: PPUSH
91217: CALL_OW 234
// end ;
91221: GO 91206
91223: POP
91224: POP
// end ;
91225: PPOPN 2
91227: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91228: LD_EXP 114
91232: PUSH
91233: LD_EXP 124
91237: AND
91238: IFFALSE 91258
91240: GO 91242
91242: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91243: LD_INT 32
91245: PPUSH
91246: LD_OWVAR 2
91250: PPUSH
91251: LD_INT 0
91253: PPUSH
91254: CALL_OW 324
91258: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
91259: LD_EXP 114
91263: PUSH
91264: LD_EXP 125
91268: AND
91269: IFFALSE 91450
91271: GO 91273
91273: DISABLE
91274: LD_INT 0
91276: PPUSH
91277: PPUSH
91278: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
91279: LD_ADDR_VAR 0 2
91283: PUSH
91284: LD_INT 22
91286: PUSH
91287: LD_OWVAR 2
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 33
91298: PUSH
91299: LD_INT 3
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PPUSH
91310: CALL_OW 69
91314: ST_TO_ADDR
// if not tmp then
91315: LD_VAR 0 2
91319: NOT
91320: IFFALSE 91324
// exit ;
91322: GO 91450
// side := 0 ;
91324: LD_ADDR_VAR 0 3
91328: PUSH
91329: LD_INT 0
91331: ST_TO_ADDR
// for i := 1 to 8 do
91332: LD_ADDR_VAR 0 1
91336: PUSH
91337: DOUBLE
91338: LD_INT 1
91340: DEC
91341: ST_TO_ADDR
91342: LD_INT 8
91344: PUSH
91345: FOR_TO
91346: IFFALSE 91394
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91348: LD_OWVAR 2
91352: PUSH
91353: LD_VAR 0 1
91357: NONEQUAL
91358: PUSH
91359: LD_OWVAR 2
91363: PPUSH
91364: LD_VAR 0 1
91368: PPUSH
91369: CALL_OW 81
91373: PUSH
91374: LD_INT 2
91376: EQUAL
91377: AND
91378: IFFALSE 91392
// begin side := i ;
91380: LD_ADDR_VAR 0 3
91384: PUSH
91385: LD_VAR 0 1
91389: ST_TO_ADDR
// break ;
91390: GO 91394
// end ;
91392: GO 91345
91394: POP
91395: POP
// if not side then
91396: LD_VAR 0 3
91400: NOT
91401: IFFALSE 91405
// exit ;
91403: GO 91450
// for i := 1 to tmp do
91405: LD_ADDR_VAR 0 1
91409: PUSH
91410: DOUBLE
91411: LD_INT 1
91413: DEC
91414: ST_TO_ADDR
91415: LD_VAR 0 2
91419: PUSH
91420: FOR_TO
91421: IFFALSE 91448
// if Prob ( 60 ) then
91423: LD_INT 60
91425: PPUSH
91426: CALL_OW 13
91430: IFFALSE 91446
// SetSide ( i , side ) ;
91432: LD_VAR 0 1
91436: PPUSH
91437: LD_VAR 0 3
91441: PPUSH
91442: CALL_OW 235
91446: GO 91420
91448: POP
91449: POP
// end ;
91450: PPOPN 3
91452: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91453: LD_EXP 114
91457: PUSH
91458: LD_EXP 127
91462: AND
91463: IFFALSE 91582
91465: GO 91467
91467: DISABLE
91468: LD_INT 0
91470: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91471: LD_ADDR_VAR 0 1
91475: PUSH
91476: LD_INT 22
91478: PUSH
91479: LD_OWVAR 2
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 21
91490: PUSH
91491: LD_INT 1
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 3
91500: PUSH
91501: LD_INT 23
91503: PUSH
91504: LD_INT 0
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: LIST
91519: PPUSH
91520: CALL_OW 69
91524: PUSH
91525: FOR_IN
91526: IFFALSE 91580
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91528: LD_VAR 0 1
91532: PPUSH
91533: CALL_OW 257
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: LD_INT 2
91543: PUSH
91544: LD_INT 3
91546: PUSH
91547: LD_INT 4
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: IN
91556: IFFALSE 91578
// SetClass ( un , rand ( 1 , 4 ) ) ;
91558: LD_VAR 0 1
91562: PPUSH
91563: LD_INT 1
91565: PPUSH
91566: LD_INT 4
91568: PPUSH
91569: CALL_OW 12
91573: PPUSH
91574: CALL_OW 336
91578: GO 91525
91580: POP
91581: POP
// end ;
91582: PPOPN 1
91584: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91585: LD_EXP 114
91589: PUSH
91590: LD_EXP 126
91594: AND
91595: IFFALSE 91674
91597: GO 91599
91599: DISABLE
91600: LD_INT 0
91602: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91603: LD_ADDR_VAR 0 1
91607: PUSH
91608: LD_INT 22
91610: PUSH
91611: LD_OWVAR 2
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 21
91622: PUSH
91623: LD_INT 3
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PPUSH
91634: CALL_OW 69
91638: ST_TO_ADDR
// if not tmp then
91639: LD_VAR 0 1
91643: NOT
91644: IFFALSE 91648
// exit ;
91646: GO 91674
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91648: LD_VAR 0 1
91652: PUSH
91653: LD_INT 1
91655: PPUSH
91656: LD_VAR 0 1
91660: PPUSH
91661: CALL_OW 12
91665: ARRAY
91666: PPUSH
91667: LD_INT 100
91669: PPUSH
91670: CALL_OW 234
// end ;
91674: PPOPN 1
91676: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91677: LD_EXP 114
91681: PUSH
91682: LD_EXP 128
91686: AND
91687: IFFALSE 91785
91689: GO 91691
91691: DISABLE
91692: LD_INT 0
91694: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91695: LD_ADDR_VAR 0 1
91699: PUSH
91700: LD_INT 22
91702: PUSH
91703: LD_OWVAR 2
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 21
91714: PUSH
91715: LD_INT 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: PPUSH
91726: CALL_OW 69
91730: ST_TO_ADDR
// if not tmp then
91731: LD_VAR 0 1
91735: NOT
91736: IFFALSE 91740
// exit ;
91738: GO 91785
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91740: LD_VAR 0 1
91744: PUSH
91745: LD_INT 1
91747: PPUSH
91748: LD_VAR 0 1
91752: PPUSH
91753: CALL_OW 12
91757: ARRAY
91758: PPUSH
91759: LD_INT 1
91761: PPUSH
91762: LD_INT 4
91764: PPUSH
91765: CALL_OW 12
91769: PPUSH
91770: LD_INT 3000
91772: PPUSH
91773: LD_INT 9000
91775: PPUSH
91776: CALL_OW 12
91780: PPUSH
91781: CALL_OW 492
// end ;
91785: PPOPN 1
91787: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91788: LD_EXP 114
91792: PUSH
91793: LD_EXP 129
91797: AND
91798: IFFALSE 91818
91800: GO 91802
91802: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91803: LD_INT 1
91805: PPUSH
91806: LD_OWVAR 2
91810: PPUSH
91811: LD_INT 0
91813: PPUSH
91814: CALL_OW 324
91818: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91819: LD_EXP 114
91823: PUSH
91824: LD_EXP 130
91828: AND
91829: IFFALSE 91912
91831: GO 91833
91833: DISABLE
91834: LD_INT 0
91836: PPUSH
91837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91838: LD_ADDR_VAR 0 2
91842: PUSH
91843: LD_INT 22
91845: PUSH
91846: LD_OWVAR 2
91850: PUSH
91851: EMPTY
91852: LIST
91853: LIST
91854: PUSH
91855: LD_INT 21
91857: PUSH
91858: LD_INT 3
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PPUSH
91869: CALL_OW 69
91873: ST_TO_ADDR
// if not tmp then
91874: LD_VAR 0 2
91878: NOT
91879: IFFALSE 91883
// exit ;
91881: GO 91912
// for i in tmp do
91883: LD_ADDR_VAR 0 1
91887: PUSH
91888: LD_VAR 0 2
91892: PUSH
91893: FOR_IN
91894: IFFALSE 91910
// SetBLevel ( i , 10 ) ;
91896: LD_VAR 0 1
91900: PPUSH
91901: LD_INT 10
91903: PPUSH
91904: CALL_OW 241
91908: GO 91893
91910: POP
91911: POP
// end ;
91912: PPOPN 2
91914: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91915: LD_EXP 114
91919: PUSH
91920: LD_EXP 131
91924: AND
91925: IFFALSE 92036
91927: GO 91929
91929: DISABLE
91930: LD_INT 0
91932: PPUSH
91933: PPUSH
91934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91935: LD_ADDR_VAR 0 3
91939: PUSH
91940: LD_INT 22
91942: PUSH
91943: LD_OWVAR 2
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 25
91954: PUSH
91955: LD_INT 1
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PPUSH
91966: CALL_OW 69
91970: ST_TO_ADDR
// if not tmp then
91971: LD_VAR 0 3
91975: NOT
91976: IFFALSE 91980
// exit ;
91978: GO 92036
// un := tmp [ rand ( 1 , tmp ) ] ;
91980: LD_ADDR_VAR 0 2
91984: PUSH
91985: LD_VAR 0 3
91989: PUSH
91990: LD_INT 1
91992: PPUSH
91993: LD_VAR 0 3
91997: PPUSH
91998: CALL_OW 12
92002: ARRAY
92003: ST_TO_ADDR
// if Crawls ( un ) then
92004: LD_VAR 0 2
92008: PPUSH
92009: CALL_OW 318
92013: IFFALSE 92024
// ComWalk ( un ) ;
92015: LD_VAR 0 2
92019: PPUSH
92020: CALL_OW 138
// SetClass ( un , class_sniper ) ;
92024: LD_VAR 0 2
92028: PPUSH
92029: LD_INT 5
92031: PPUSH
92032: CALL_OW 336
// end ;
92036: PPOPN 3
92038: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
92039: LD_EXP 114
92043: PUSH
92044: LD_EXP 132
92048: AND
92049: PUSH
92050: LD_OWVAR 67
92054: PUSH
92055: LD_INT 4
92057: LESS
92058: AND
92059: IFFALSE 92078
92061: GO 92063
92063: DISABLE
// begin Difficulty := Difficulty + 1 ;
92064: LD_ADDR_OWVAR 67
92068: PUSH
92069: LD_OWVAR 67
92073: PUSH
92074: LD_INT 1
92076: PLUS
92077: ST_TO_ADDR
// end ;
92078: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92079: LD_EXP 114
92083: PUSH
92084: LD_EXP 133
92088: AND
92089: IFFALSE 92192
92091: GO 92093
92093: DISABLE
92094: LD_INT 0
92096: PPUSH
// begin for i := 1 to 5 do
92097: LD_ADDR_VAR 0 1
92101: PUSH
92102: DOUBLE
92103: LD_INT 1
92105: DEC
92106: ST_TO_ADDR
92107: LD_INT 5
92109: PUSH
92110: FOR_TO
92111: IFFALSE 92190
// begin uc_nation := nation_nature ;
92113: LD_ADDR_OWVAR 21
92117: PUSH
92118: LD_INT 0
92120: ST_TO_ADDR
// uc_side := 0 ;
92121: LD_ADDR_OWVAR 20
92125: PUSH
92126: LD_INT 0
92128: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92129: LD_ADDR_OWVAR 29
92133: PUSH
92134: LD_INT 12
92136: PUSH
92137: LD_INT 12
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: ST_TO_ADDR
// hc_agressivity := 20 ;
92144: LD_ADDR_OWVAR 35
92148: PUSH
92149: LD_INT 20
92151: ST_TO_ADDR
// hc_class := class_tiger ;
92152: LD_ADDR_OWVAR 28
92156: PUSH
92157: LD_INT 14
92159: ST_TO_ADDR
// hc_gallery :=  ;
92160: LD_ADDR_OWVAR 33
92164: PUSH
92165: LD_STRING 
92167: ST_TO_ADDR
// hc_name :=  ;
92168: LD_ADDR_OWVAR 26
92172: PUSH
92173: LD_STRING 
92175: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92176: CALL_OW 44
92180: PPUSH
92181: LD_INT 0
92183: PPUSH
92184: CALL_OW 51
// end ;
92188: GO 92110
92190: POP
92191: POP
// end ;
92192: PPOPN 1
92194: END
// every 0 0$1 trigger StreamModeActive and sBomb do
92195: LD_EXP 114
92199: PUSH
92200: LD_EXP 134
92204: AND
92205: IFFALSE 92214
92207: GO 92209
92209: DISABLE
// StreamSibBomb ;
92210: CALL 92215 0 0
92214: END
// export function StreamSibBomb ; var i , x , y ; begin
92215: LD_INT 0
92217: PPUSH
92218: PPUSH
92219: PPUSH
92220: PPUSH
// result := false ;
92221: LD_ADDR_VAR 0 1
92225: PUSH
92226: LD_INT 0
92228: ST_TO_ADDR
// for i := 1 to 16 do
92229: LD_ADDR_VAR 0 2
92233: PUSH
92234: DOUBLE
92235: LD_INT 1
92237: DEC
92238: ST_TO_ADDR
92239: LD_INT 16
92241: PUSH
92242: FOR_TO
92243: IFFALSE 92442
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92245: LD_ADDR_VAR 0 3
92249: PUSH
92250: LD_INT 10
92252: PUSH
92253: LD_INT 20
92255: PUSH
92256: LD_INT 30
92258: PUSH
92259: LD_INT 40
92261: PUSH
92262: LD_INT 50
92264: PUSH
92265: LD_INT 60
92267: PUSH
92268: LD_INT 70
92270: PUSH
92271: LD_INT 80
92273: PUSH
92274: LD_INT 90
92276: PUSH
92277: LD_INT 100
92279: PUSH
92280: LD_INT 110
92282: PUSH
92283: LD_INT 120
92285: PUSH
92286: LD_INT 130
92288: PUSH
92289: LD_INT 140
92291: PUSH
92292: LD_INT 150
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 1
92314: PPUSH
92315: LD_INT 15
92317: PPUSH
92318: CALL_OW 12
92322: ARRAY
92323: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92324: LD_ADDR_VAR 0 4
92328: PUSH
92329: LD_INT 10
92331: PUSH
92332: LD_INT 20
92334: PUSH
92335: LD_INT 30
92337: PUSH
92338: LD_INT 40
92340: PUSH
92341: LD_INT 50
92343: PUSH
92344: LD_INT 60
92346: PUSH
92347: LD_INT 70
92349: PUSH
92350: LD_INT 80
92352: PUSH
92353: LD_INT 90
92355: PUSH
92356: LD_INT 100
92358: PUSH
92359: LD_INT 110
92361: PUSH
92362: LD_INT 120
92364: PUSH
92365: LD_INT 130
92367: PUSH
92368: LD_INT 140
92370: PUSH
92371: LD_INT 150
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 1
92393: PPUSH
92394: LD_INT 15
92396: PPUSH
92397: CALL_OW 12
92401: ARRAY
92402: ST_TO_ADDR
// if ValidHex ( x , y ) then
92403: LD_VAR 0 3
92407: PPUSH
92408: LD_VAR 0 4
92412: PPUSH
92413: CALL_OW 488
92417: IFFALSE 92440
// begin result := [ x , y ] ;
92419: LD_ADDR_VAR 0 1
92423: PUSH
92424: LD_VAR 0 3
92428: PUSH
92429: LD_VAR 0 4
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: ST_TO_ADDR
// break ;
92438: GO 92442
// end ; end ;
92440: GO 92242
92442: POP
92443: POP
// if result then
92444: LD_VAR 0 1
92448: IFFALSE 92508
// begin ToLua ( playSibBomb() ) ;
92450: LD_STRING playSibBomb()
92452: PPUSH
92453: CALL_OW 559
// wait ( 0 0$14 ) ;
92457: LD_INT 490
92459: PPUSH
92460: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92464: LD_VAR 0 1
92468: PUSH
92469: LD_INT 1
92471: ARRAY
92472: PPUSH
92473: LD_VAR 0 1
92477: PUSH
92478: LD_INT 2
92480: ARRAY
92481: PPUSH
92482: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92486: LD_VAR 0 1
92490: PUSH
92491: LD_INT 1
92493: ARRAY
92494: PPUSH
92495: LD_VAR 0 1
92499: PUSH
92500: LD_INT 2
92502: ARRAY
92503: PPUSH
92504: CALL_OW 429
// end ; end ;
92508: LD_VAR 0 1
92512: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92513: LD_EXP 114
92517: PUSH
92518: LD_EXP 136
92522: AND
92523: IFFALSE 92535
92525: GO 92527
92527: DISABLE
// YouLost (  ) ;
92528: LD_STRING 
92530: PPUSH
92531: CALL_OW 104
92535: END
// every 0 0$1 trigger StreamModeActive and sFog do
92536: LD_EXP 114
92540: PUSH
92541: LD_EXP 135
92545: AND
92546: IFFALSE 92560
92548: GO 92550
92550: DISABLE
// FogOff ( your_side ) ;
92551: LD_OWVAR 2
92555: PPUSH
92556: CALL_OW 344
92560: END
// every 0 0$1 trigger StreamModeActive and sSun do
92561: LD_EXP 114
92565: PUSH
92566: LD_EXP 137
92570: AND
92571: IFFALSE 92599
92573: GO 92575
92575: DISABLE
// begin solar_recharge_percent := 0 ;
92576: LD_ADDR_OWVAR 79
92580: PUSH
92581: LD_INT 0
92583: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92584: LD_INT 10500
92586: PPUSH
92587: CALL_OW 67
// solar_recharge_percent := 100 ;
92591: LD_ADDR_OWVAR 79
92595: PUSH
92596: LD_INT 100
92598: ST_TO_ADDR
// end ;
92599: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92600: LD_EXP 114
92604: PUSH
92605: LD_EXP 138
92609: AND
92610: IFFALSE 92849
92612: GO 92614
92614: DISABLE
92615: LD_INT 0
92617: PPUSH
92618: PPUSH
92619: PPUSH
// begin tmp := [ ] ;
92620: LD_ADDR_VAR 0 3
92624: PUSH
92625: EMPTY
92626: ST_TO_ADDR
// for i := 1 to 6 do
92627: LD_ADDR_VAR 0 1
92631: PUSH
92632: DOUBLE
92633: LD_INT 1
92635: DEC
92636: ST_TO_ADDR
92637: LD_INT 6
92639: PUSH
92640: FOR_TO
92641: IFFALSE 92746
// begin uc_nation := nation_nature ;
92643: LD_ADDR_OWVAR 21
92647: PUSH
92648: LD_INT 0
92650: ST_TO_ADDR
// uc_side := 0 ;
92651: LD_ADDR_OWVAR 20
92655: PUSH
92656: LD_INT 0
92658: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92659: LD_ADDR_OWVAR 29
92663: PUSH
92664: LD_INT 12
92666: PUSH
92667: LD_INT 12
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: ST_TO_ADDR
// hc_agressivity := 20 ;
92674: LD_ADDR_OWVAR 35
92678: PUSH
92679: LD_INT 20
92681: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92682: LD_ADDR_OWVAR 28
92686: PUSH
92687: LD_INT 17
92689: ST_TO_ADDR
// hc_gallery :=  ;
92690: LD_ADDR_OWVAR 33
92694: PUSH
92695: LD_STRING 
92697: ST_TO_ADDR
// hc_name :=  ;
92698: LD_ADDR_OWVAR 26
92702: PUSH
92703: LD_STRING 
92705: ST_TO_ADDR
// un := CreateHuman ;
92706: LD_ADDR_VAR 0 2
92710: PUSH
92711: CALL_OW 44
92715: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92716: LD_VAR 0 2
92720: PPUSH
92721: LD_INT 1
92723: PPUSH
92724: CALL_OW 51
// tmp := tmp ^ un ;
92728: LD_ADDR_VAR 0 3
92732: PUSH
92733: LD_VAR 0 3
92737: PUSH
92738: LD_VAR 0 2
92742: ADD
92743: ST_TO_ADDR
// end ;
92744: GO 92640
92746: POP
92747: POP
// repeat wait ( 0 0$1 ) ;
92748: LD_INT 35
92750: PPUSH
92751: CALL_OW 67
// for un in tmp do
92755: LD_ADDR_VAR 0 2
92759: PUSH
92760: LD_VAR 0 3
92764: PUSH
92765: FOR_IN
92766: IFFALSE 92840
// begin if IsDead ( un ) then
92768: LD_VAR 0 2
92772: PPUSH
92773: CALL_OW 301
92777: IFFALSE 92797
// begin tmp := tmp diff un ;
92779: LD_ADDR_VAR 0 3
92783: PUSH
92784: LD_VAR 0 3
92788: PUSH
92789: LD_VAR 0 2
92793: DIFF
92794: ST_TO_ADDR
// continue ;
92795: GO 92765
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92797: LD_VAR 0 2
92801: PPUSH
92802: LD_INT 3
92804: PUSH
92805: LD_INT 22
92807: PUSH
92808: LD_INT 0
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PPUSH
92819: CALL_OW 69
92823: PPUSH
92824: LD_VAR 0 2
92828: PPUSH
92829: CALL_OW 74
92833: PPUSH
92834: CALL_OW 115
// end ;
92838: GO 92765
92840: POP
92841: POP
// until not tmp ;
92842: LD_VAR 0 3
92846: NOT
92847: IFFALSE 92748
// end ;
92849: PPOPN 3
92851: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92852: LD_EXP 114
92856: PUSH
92857: LD_EXP 139
92861: AND
92862: IFFALSE 92916
92864: GO 92866
92866: DISABLE
// begin ToLua ( displayTroll(); ) ;
92867: LD_STRING displayTroll();
92869: PPUSH
92870: CALL_OW 559
// wait ( 3 3$00 ) ;
92874: LD_INT 6300
92876: PPUSH
92877: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92881: LD_STRING hideTroll();
92883: PPUSH
92884: CALL_OW 559
// wait ( 1 1$00 ) ;
92888: LD_INT 2100
92890: PPUSH
92891: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92895: LD_STRING displayTroll();
92897: PPUSH
92898: CALL_OW 559
// wait ( 1 1$00 ) ;
92902: LD_INT 2100
92904: PPUSH
92905: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92909: LD_STRING hideTroll();
92911: PPUSH
92912: CALL_OW 559
// end ;
92916: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92917: LD_EXP 114
92921: PUSH
92922: LD_EXP 140
92926: AND
92927: IFFALSE 92990
92929: GO 92931
92931: DISABLE
92932: LD_INT 0
92934: PPUSH
// begin p := 0 ;
92935: LD_ADDR_VAR 0 1
92939: PUSH
92940: LD_INT 0
92942: ST_TO_ADDR
// repeat game_speed := 1 ;
92943: LD_ADDR_OWVAR 65
92947: PUSH
92948: LD_INT 1
92950: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92951: LD_INT 35
92953: PPUSH
92954: CALL_OW 67
// p := p + 1 ;
92958: LD_ADDR_VAR 0 1
92962: PUSH
92963: LD_VAR 0 1
92967: PUSH
92968: LD_INT 1
92970: PLUS
92971: ST_TO_ADDR
// until p >= 60 ;
92972: LD_VAR 0 1
92976: PUSH
92977: LD_INT 60
92979: GREATEREQUAL
92980: IFFALSE 92943
// game_speed := 4 ;
92982: LD_ADDR_OWVAR 65
92986: PUSH
92987: LD_INT 4
92989: ST_TO_ADDR
// end ;
92990: PPOPN 1
92992: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92993: LD_EXP 114
92997: PUSH
92998: LD_EXP 141
93002: AND
93003: IFFALSE 93149
93005: GO 93007
93007: DISABLE
93008: LD_INT 0
93010: PPUSH
93011: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93012: LD_ADDR_VAR 0 1
93016: PUSH
93017: LD_INT 22
93019: PUSH
93020: LD_OWVAR 2
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 2
93031: PUSH
93032: LD_INT 30
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 30
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: LIST
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PPUSH
93061: CALL_OW 69
93065: ST_TO_ADDR
// if not depot then
93066: LD_VAR 0 1
93070: NOT
93071: IFFALSE 93075
// exit ;
93073: GO 93149
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
93075: LD_ADDR_VAR 0 2
93079: PUSH
93080: LD_VAR 0 1
93084: PUSH
93085: LD_INT 1
93087: PPUSH
93088: LD_VAR 0 1
93092: PPUSH
93093: CALL_OW 12
93097: ARRAY
93098: PPUSH
93099: CALL_OW 274
93103: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
93104: LD_VAR 0 2
93108: PPUSH
93109: LD_INT 1
93111: PPUSH
93112: LD_INT 0
93114: PPUSH
93115: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
93119: LD_VAR 0 2
93123: PPUSH
93124: LD_INT 2
93126: PPUSH
93127: LD_INT 0
93129: PPUSH
93130: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
93134: LD_VAR 0 2
93138: PPUSH
93139: LD_INT 3
93141: PPUSH
93142: LD_INT 0
93144: PPUSH
93145: CALL_OW 277
// end ;
93149: PPOPN 2
93151: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
93152: LD_EXP 114
93156: PUSH
93157: LD_EXP 142
93161: AND
93162: IFFALSE 93259
93164: GO 93166
93166: DISABLE
93167: LD_INT 0
93169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93170: LD_ADDR_VAR 0 1
93174: PUSH
93175: LD_INT 22
93177: PUSH
93178: LD_OWVAR 2
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 21
93189: PUSH
93190: LD_INT 1
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 3
93199: PUSH
93200: LD_INT 23
93202: PUSH
93203: LD_INT 0
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: LIST
93218: PPUSH
93219: CALL_OW 69
93223: ST_TO_ADDR
// if not tmp then
93224: LD_VAR 0 1
93228: NOT
93229: IFFALSE 93233
// exit ;
93231: GO 93259
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
93233: LD_VAR 0 1
93237: PUSH
93238: LD_INT 1
93240: PPUSH
93241: LD_VAR 0 1
93245: PPUSH
93246: CALL_OW 12
93250: ARRAY
93251: PPUSH
93252: LD_INT 200
93254: PPUSH
93255: CALL_OW 234
// end ;
93259: PPOPN 1
93261: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
93262: LD_EXP 114
93266: PUSH
93267: LD_EXP 143
93271: AND
93272: IFFALSE 93351
93274: GO 93276
93276: DISABLE
93277: LD_INT 0
93279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
93280: LD_ADDR_VAR 0 1
93284: PUSH
93285: LD_INT 22
93287: PUSH
93288: LD_OWVAR 2
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 21
93299: PUSH
93300: LD_INT 2
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PPUSH
93311: CALL_OW 69
93315: ST_TO_ADDR
// if not tmp then
93316: LD_VAR 0 1
93320: NOT
93321: IFFALSE 93325
// exit ;
93323: GO 93351
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
93325: LD_VAR 0 1
93329: PUSH
93330: LD_INT 1
93332: PPUSH
93333: LD_VAR 0 1
93337: PPUSH
93338: CALL_OW 12
93342: ARRAY
93343: PPUSH
93344: LD_INT 60
93346: PPUSH
93347: CALL_OW 234
// end ;
93351: PPOPN 1
93353: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93354: LD_EXP 114
93358: PUSH
93359: LD_EXP 144
93363: AND
93364: IFFALSE 93463
93366: GO 93368
93368: DISABLE
93369: LD_INT 0
93371: PPUSH
93372: PPUSH
// begin enable ;
93373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93374: LD_ADDR_VAR 0 1
93378: PUSH
93379: LD_INT 22
93381: PUSH
93382: LD_OWVAR 2
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 61
93393: PUSH
93394: EMPTY
93395: LIST
93396: PUSH
93397: LD_INT 33
93399: PUSH
93400: LD_INT 2
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: LIST
93411: PPUSH
93412: CALL_OW 69
93416: ST_TO_ADDR
// if not tmp then
93417: LD_VAR 0 1
93421: NOT
93422: IFFALSE 93426
// exit ;
93424: GO 93463
// for i in tmp do
93426: LD_ADDR_VAR 0 2
93430: PUSH
93431: LD_VAR 0 1
93435: PUSH
93436: FOR_IN
93437: IFFALSE 93461
// if IsControledBy ( i ) then
93439: LD_VAR 0 2
93443: PPUSH
93444: CALL_OW 312
93448: IFFALSE 93459
// ComUnlink ( i ) ;
93450: LD_VAR 0 2
93454: PPUSH
93455: CALL_OW 136
93459: GO 93436
93461: POP
93462: POP
// end ;
93463: PPOPN 2
93465: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93466: LD_EXP 114
93470: PUSH
93471: LD_EXP 145
93475: AND
93476: IFFALSE 93616
93478: GO 93480
93480: DISABLE
93481: LD_INT 0
93483: PPUSH
93484: PPUSH
// begin ToLua ( displayPowell(); ) ;
93485: LD_STRING displayPowell();
93487: PPUSH
93488: CALL_OW 559
// uc_side := 0 ;
93492: LD_ADDR_OWVAR 20
93496: PUSH
93497: LD_INT 0
93499: ST_TO_ADDR
// uc_nation := 2 ;
93500: LD_ADDR_OWVAR 21
93504: PUSH
93505: LD_INT 2
93507: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93508: LD_ADDR_OWVAR 37
93512: PUSH
93513: LD_INT 14
93515: ST_TO_ADDR
// vc_engine := engine_siberite ;
93516: LD_ADDR_OWVAR 39
93520: PUSH
93521: LD_INT 3
93523: ST_TO_ADDR
// vc_control := control_apeman ;
93524: LD_ADDR_OWVAR 38
93528: PUSH
93529: LD_INT 5
93531: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93532: LD_ADDR_OWVAR 40
93536: PUSH
93537: LD_INT 29
93539: ST_TO_ADDR
// un := CreateVehicle ;
93540: LD_ADDR_VAR 0 2
93544: PUSH
93545: CALL_OW 45
93549: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93550: LD_VAR 0 2
93554: PPUSH
93555: LD_INT 1
93557: PPUSH
93558: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93562: LD_INT 35
93564: PPUSH
93565: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93569: LD_VAR 0 2
93573: PPUSH
93574: LD_INT 22
93576: PUSH
93577: LD_OWVAR 2
93581: PUSH
93582: EMPTY
93583: LIST
93584: LIST
93585: PPUSH
93586: CALL_OW 69
93590: PPUSH
93591: LD_VAR 0 2
93595: PPUSH
93596: CALL_OW 74
93600: PPUSH
93601: CALL_OW 115
// until IsDead ( un ) ;
93605: LD_VAR 0 2
93609: PPUSH
93610: CALL_OW 301
93614: IFFALSE 93562
// end ;
93616: PPOPN 2
93618: END
// every 0 0$1 trigger StreamModeActive and sStu do
93619: LD_EXP 114
93623: PUSH
93624: LD_EXP 153
93628: AND
93629: IFFALSE 93645
93631: GO 93633
93633: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93634: LD_STRING displayStucuk();
93636: PPUSH
93637: CALL_OW 559
// ResetFog ;
93641: CALL_OW 335
// end ;
93645: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93646: LD_EXP 114
93650: PUSH
93651: LD_EXP 146
93655: AND
93656: IFFALSE 93797
93658: GO 93660
93660: DISABLE
93661: LD_INT 0
93663: PPUSH
93664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93665: LD_ADDR_VAR 0 2
93669: PUSH
93670: LD_INT 22
93672: PUSH
93673: LD_OWVAR 2
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: LD_INT 21
93684: PUSH
93685: LD_INT 1
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PPUSH
93696: CALL_OW 69
93700: ST_TO_ADDR
// if not tmp then
93701: LD_VAR 0 2
93705: NOT
93706: IFFALSE 93710
// exit ;
93708: GO 93797
// un := tmp [ rand ( 1 , tmp ) ] ;
93710: LD_ADDR_VAR 0 1
93714: PUSH
93715: LD_VAR 0 2
93719: PUSH
93720: LD_INT 1
93722: PPUSH
93723: LD_VAR 0 2
93727: PPUSH
93728: CALL_OW 12
93732: ARRAY
93733: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93734: LD_VAR 0 1
93738: PPUSH
93739: LD_INT 0
93741: PPUSH
93742: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93746: LD_VAR 0 1
93750: PPUSH
93751: LD_OWVAR 3
93755: PUSH
93756: LD_VAR 0 1
93760: DIFF
93761: PPUSH
93762: LD_VAR 0 1
93766: PPUSH
93767: CALL_OW 74
93771: PPUSH
93772: CALL_OW 115
// wait ( 0 0$20 ) ;
93776: LD_INT 700
93778: PPUSH
93779: CALL_OW 67
// SetSide ( un , your_side ) ;
93783: LD_VAR 0 1
93787: PPUSH
93788: LD_OWVAR 2
93792: PPUSH
93793: CALL_OW 235
// end ;
93797: PPOPN 2
93799: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93800: LD_EXP 114
93804: PUSH
93805: LD_EXP 147
93809: AND
93810: IFFALSE 93916
93812: GO 93814
93814: DISABLE
93815: LD_INT 0
93817: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93818: LD_ADDR_VAR 0 1
93822: PUSH
93823: LD_INT 22
93825: PUSH
93826: LD_OWVAR 2
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 2
93837: PUSH
93838: LD_INT 30
93840: PUSH
93841: LD_INT 0
93843: PUSH
93844: EMPTY
93845: LIST
93846: LIST
93847: PUSH
93848: LD_INT 30
93850: PUSH
93851: LD_INT 1
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: LIST
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PPUSH
93867: CALL_OW 69
93871: ST_TO_ADDR
// if not depot then
93872: LD_VAR 0 1
93876: NOT
93877: IFFALSE 93881
// exit ;
93879: GO 93916
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93881: LD_VAR 0 1
93885: PUSH
93886: LD_INT 1
93888: ARRAY
93889: PPUSH
93890: CALL_OW 250
93894: PPUSH
93895: LD_VAR 0 1
93899: PUSH
93900: LD_INT 1
93902: ARRAY
93903: PPUSH
93904: CALL_OW 251
93908: PPUSH
93909: LD_INT 70
93911: PPUSH
93912: CALL_OW 495
// end ;
93916: PPOPN 1
93918: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93919: LD_EXP 114
93923: PUSH
93924: LD_EXP 148
93928: AND
93929: IFFALSE 94140
93931: GO 93933
93933: DISABLE
93934: LD_INT 0
93936: PPUSH
93937: PPUSH
93938: PPUSH
93939: PPUSH
93940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93941: LD_ADDR_VAR 0 5
93945: PUSH
93946: LD_INT 22
93948: PUSH
93949: LD_OWVAR 2
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 21
93960: PUSH
93961: LD_INT 1
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PPUSH
93972: CALL_OW 69
93976: ST_TO_ADDR
// if not tmp then
93977: LD_VAR 0 5
93981: NOT
93982: IFFALSE 93986
// exit ;
93984: GO 94140
// for i in tmp do
93986: LD_ADDR_VAR 0 1
93990: PUSH
93991: LD_VAR 0 5
93995: PUSH
93996: FOR_IN
93997: IFFALSE 94138
// begin d := rand ( 0 , 5 ) ;
93999: LD_ADDR_VAR 0 4
94003: PUSH
94004: LD_INT 0
94006: PPUSH
94007: LD_INT 5
94009: PPUSH
94010: CALL_OW 12
94014: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
94015: LD_ADDR_VAR 0 2
94019: PUSH
94020: LD_VAR 0 1
94024: PPUSH
94025: CALL_OW 250
94029: PPUSH
94030: LD_VAR 0 4
94034: PPUSH
94035: LD_INT 3
94037: PPUSH
94038: LD_INT 12
94040: PPUSH
94041: CALL_OW 12
94045: PPUSH
94046: CALL_OW 272
94050: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
94051: LD_ADDR_VAR 0 3
94055: PUSH
94056: LD_VAR 0 1
94060: PPUSH
94061: CALL_OW 251
94065: PPUSH
94066: LD_VAR 0 4
94070: PPUSH
94071: LD_INT 3
94073: PPUSH
94074: LD_INT 12
94076: PPUSH
94077: CALL_OW 12
94081: PPUSH
94082: CALL_OW 273
94086: ST_TO_ADDR
// if ValidHex ( x , y ) then
94087: LD_VAR 0 2
94091: PPUSH
94092: LD_VAR 0 3
94096: PPUSH
94097: CALL_OW 488
94101: IFFALSE 94136
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
94103: LD_VAR 0 1
94107: PPUSH
94108: LD_VAR 0 2
94112: PPUSH
94113: LD_VAR 0 3
94117: PPUSH
94118: LD_INT 3
94120: PPUSH
94121: LD_INT 6
94123: PPUSH
94124: CALL_OW 12
94128: PPUSH
94129: LD_INT 1
94131: PPUSH
94132: CALL_OW 483
// end ;
94136: GO 93996
94138: POP
94139: POP
// end ;
94140: PPOPN 5
94142: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
94143: LD_EXP 114
94147: PUSH
94148: LD_EXP 149
94152: AND
94153: IFFALSE 94247
94155: GO 94157
94157: DISABLE
94158: LD_INT 0
94160: PPUSH
94161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
94162: LD_ADDR_VAR 0 2
94166: PUSH
94167: LD_INT 22
94169: PUSH
94170: LD_OWVAR 2
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 32
94181: PUSH
94182: LD_INT 1
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 21
94191: PUSH
94192: LD_INT 2
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: LIST
94203: PPUSH
94204: CALL_OW 69
94208: ST_TO_ADDR
// if not tmp then
94209: LD_VAR 0 2
94213: NOT
94214: IFFALSE 94218
// exit ;
94216: GO 94247
// for i in tmp do
94218: LD_ADDR_VAR 0 1
94222: PUSH
94223: LD_VAR 0 2
94227: PUSH
94228: FOR_IN
94229: IFFALSE 94245
// SetFuel ( i , 0 ) ;
94231: LD_VAR 0 1
94235: PPUSH
94236: LD_INT 0
94238: PPUSH
94239: CALL_OW 240
94243: GO 94228
94245: POP
94246: POP
// end ;
94247: PPOPN 2
94249: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
94250: LD_EXP 114
94254: PUSH
94255: LD_EXP 150
94259: AND
94260: IFFALSE 94326
94262: GO 94264
94264: DISABLE
94265: LD_INT 0
94267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94268: LD_ADDR_VAR 0 1
94272: PUSH
94273: LD_INT 22
94275: PUSH
94276: LD_OWVAR 2
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 30
94287: PUSH
94288: LD_INT 29
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PPUSH
94299: CALL_OW 69
94303: ST_TO_ADDR
// if not tmp then
94304: LD_VAR 0 1
94308: NOT
94309: IFFALSE 94313
// exit ;
94311: GO 94326
// DestroyUnit ( tmp [ 1 ] ) ;
94313: LD_VAR 0 1
94317: PUSH
94318: LD_INT 1
94320: ARRAY
94321: PPUSH
94322: CALL_OW 65
// end ;
94326: PPOPN 1
94328: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
94329: LD_EXP 114
94333: PUSH
94334: LD_EXP 152
94338: AND
94339: IFFALSE 94468
94341: GO 94343
94343: DISABLE
94344: LD_INT 0
94346: PPUSH
// begin uc_side := 0 ;
94347: LD_ADDR_OWVAR 20
94351: PUSH
94352: LD_INT 0
94354: ST_TO_ADDR
// uc_nation := nation_arabian ;
94355: LD_ADDR_OWVAR 21
94359: PUSH
94360: LD_INT 2
94362: ST_TO_ADDR
// hc_gallery :=  ;
94363: LD_ADDR_OWVAR 33
94367: PUSH
94368: LD_STRING 
94370: ST_TO_ADDR
// hc_name :=  ;
94371: LD_ADDR_OWVAR 26
94375: PUSH
94376: LD_STRING 
94378: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94379: LD_INT 1
94381: PPUSH
94382: LD_INT 11
94384: PPUSH
94385: LD_INT 10
94387: PPUSH
94388: CALL_OW 380
// un := CreateHuman ;
94392: LD_ADDR_VAR 0 1
94396: PUSH
94397: CALL_OW 44
94401: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94402: LD_VAR 0 1
94406: PPUSH
94407: LD_INT 1
94409: PPUSH
94410: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94414: LD_INT 35
94416: PPUSH
94417: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94421: LD_VAR 0 1
94425: PPUSH
94426: LD_INT 22
94428: PUSH
94429: LD_OWVAR 2
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PPUSH
94438: CALL_OW 69
94442: PPUSH
94443: LD_VAR 0 1
94447: PPUSH
94448: CALL_OW 74
94452: PPUSH
94453: CALL_OW 115
// until IsDead ( un ) ;
94457: LD_VAR 0 1
94461: PPUSH
94462: CALL_OW 301
94466: IFFALSE 94414
// end ;
94468: PPOPN 1
94470: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94471: LD_EXP 114
94475: PUSH
94476: LD_EXP 154
94480: AND
94481: IFFALSE 94493
94483: GO 94485
94485: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94486: LD_STRING earthquake(getX(game), 0, 32)
94488: PPUSH
94489: CALL_OW 559
94493: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94494: LD_EXP 114
94498: PUSH
94499: LD_EXP 155
94503: AND
94504: IFFALSE 94595
94506: GO 94508
94508: DISABLE
94509: LD_INT 0
94511: PPUSH
// begin enable ;
94512: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94513: LD_ADDR_VAR 0 1
94517: PUSH
94518: LD_INT 22
94520: PUSH
94521: LD_OWVAR 2
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: LD_INT 21
94532: PUSH
94533: LD_INT 2
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 33
94542: PUSH
94543: LD_INT 3
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: LIST
94554: PPUSH
94555: CALL_OW 69
94559: ST_TO_ADDR
// if not tmp then
94560: LD_VAR 0 1
94564: NOT
94565: IFFALSE 94569
// exit ;
94567: GO 94595
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94569: LD_VAR 0 1
94573: PUSH
94574: LD_INT 1
94576: PPUSH
94577: LD_VAR 0 1
94581: PPUSH
94582: CALL_OW 12
94586: ARRAY
94587: PPUSH
94588: LD_INT 1
94590: PPUSH
94591: CALL_OW 234
// end ;
94595: PPOPN 1
94597: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94598: LD_EXP 114
94602: PUSH
94603: LD_EXP 156
94607: AND
94608: IFFALSE 94749
94610: GO 94612
94612: DISABLE
94613: LD_INT 0
94615: PPUSH
94616: PPUSH
94617: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94618: LD_ADDR_VAR 0 3
94622: PUSH
94623: LD_INT 22
94625: PUSH
94626: LD_OWVAR 2
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 25
94637: PUSH
94638: LD_INT 1
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: EMPTY
94646: LIST
94647: LIST
94648: PPUSH
94649: CALL_OW 69
94653: ST_TO_ADDR
// if not tmp then
94654: LD_VAR 0 3
94658: NOT
94659: IFFALSE 94663
// exit ;
94661: GO 94749
// un := tmp [ rand ( 1 , tmp ) ] ;
94663: LD_ADDR_VAR 0 2
94667: PUSH
94668: LD_VAR 0 3
94672: PUSH
94673: LD_INT 1
94675: PPUSH
94676: LD_VAR 0 3
94680: PPUSH
94681: CALL_OW 12
94685: ARRAY
94686: ST_TO_ADDR
// if Crawls ( un ) then
94687: LD_VAR 0 2
94691: PPUSH
94692: CALL_OW 318
94696: IFFALSE 94707
// ComWalk ( un ) ;
94698: LD_VAR 0 2
94702: PPUSH
94703: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94707: LD_VAR 0 2
94711: PPUSH
94712: LD_INT 9
94714: PPUSH
94715: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94719: LD_INT 28
94721: PPUSH
94722: LD_OWVAR 2
94726: PPUSH
94727: LD_INT 2
94729: PPUSH
94730: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94734: LD_INT 29
94736: PPUSH
94737: LD_OWVAR 2
94741: PPUSH
94742: LD_INT 2
94744: PPUSH
94745: CALL_OW 322
// end ;
94749: PPOPN 3
94751: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94752: LD_EXP 114
94756: PUSH
94757: LD_EXP 157
94761: AND
94762: IFFALSE 94873
94764: GO 94766
94766: DISABLE
94767: LD_INT 0
94769: PPUSH
94770: PPUSH
94771: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94772: LD_ADDR_VAR 0 3
94776: PUSH
94777: LD_INT 22
94779: PUSH
94780: LD_OWVAR 2
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 25
94791: PUSH
94792: LD_INT 1
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PPUSH
94803: CALL_OW 69
94807: ST_TO_ADDR
// if not tmp then
94808: LD_VAR 0 3
94812: NOT
94813: IFFALSE 94817
// exit ;
94815: GO 94873
// un := tmp [ rand ( 1 , tmp ) ] ;
94817: LD_ADDR_VAR 0 2
94821: PUSH
94822: LD_VAR 0 3
94826: PUSH
94827: LD_INT 1
94829: PPUSH
94830: LD_VAR 0 3
94834: PPUSH
94835: CALL_OW 12
94839: ARRAY
94840: ST_TO_ADDR
// if Crawls ( un ) then
94841: LD_VAR 0 2
94845: PPUSH
94846: CALL_OW 318
94850: IFFALSE 94861
// ComWalk ( un ) ;
94852: LD_VAR 0 2
94856: PPUSH
94857: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94861: LD_VAR 0 2
94865: PPUSH
94866: LD_INT 8
94868: PPUSH
94869: CALL_OW 336
// end ;
94873: PPOPN 3
94875: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94876: LD_EXP 114
94880: PUSH
94881: LD_EXP 158
94885: AND
94886: IFFALSE 95030
94888: GO 94890
94890: DISABLE
94891: LD_INT 0
94893: PPUSH
94894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94895: LD_ADDR_VAR 0 2
94899: PUSH
94900: LD_INT 22
94902: PUSH
94903: LD_OWVAR 2
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 21
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 2
94924: PUSH
94925: LD_INT 34
94927: PUSH
94928: LD_INT 12
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: LD_INT 34
94937: PUSH
94938: LD_INT 51
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 34
94947: PUSH
94948: LD_INT 32
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: EMPTY
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: LIST
94965: PPUSH
94966: CALL_OW 69
94970: ST_TO_ADDR
// if not tmp then
94971: LD_VAR 0 2
94975: NOT
94976: IFFALSE 94980
// exit ;
94978: GO 95030
// for i in tmp do
94980: LD_ADDR_VAR 0 1
94984: PUSH
94985: LD_VAR 0 2
94989: PUSH
94990: FOR_IN
94991: IFFALSE 95028
// if GetCargo ( i , mat_artifact ) = 0 then
94993: LD_VAR 0 1
94997: PPUSH
94998: LD_INT 4
95000: PPUSH
95001: CALL_OW 289
95005: PUSH
95006: LD_INT 0
95008: EQUAL
95009: IFFALSE 95026
// SetCargo ( i , mat_siberit , 100 ) ;
95011: LD_VAR 0 1
95015: PPUSH
95016: LD_INT 3
95018: PPUSH
95019: LD_INT 100
95021: PPUSH
95022: CALL_OW 290
95026: GO 94990
95028: POP
95029: POP
// end ;
95030: PPOPN 2
95032: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
95033: LD_EXP 114
95037: PUSH
95038: LD_EXP 159
95042: AND
95043: IFFALSE 95226
95045: GO 95047
95047: DISABLE
95048: LD_INT 0
95050: PPUSH
95051: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95052: LD_ADDR_VAR 0 2
95056: PUSH
95057: LD_INT 22
95059: PUSH
95060: LD_OWVAR 2
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PPUSH
95069: CALL_OW 69
95073: ST_TO_ADDR
// if not tmp then
95074: LD_VAR 0 2
95078: NOT
95079: IFFALSE 95083
// exit ;
95081: GO 95226
// for i := 1 to 2 do
95083: LD_ADDR_VAR 0 1
95087: PUSH
95088: DOUBLE
95089: LD_INT 1
95091: DEC
95092: ST_TO_ADDR
95093: LD_INT 2
95095: PUSH
95096: FOR_TO
95097: IFFALSE 95224
// begin uc_side := your_side ;
95099: LD_ADDR_OWVAR 20
95103: PUSH
95104: LD_OWVAR 2
95108: ST_TO_ADDR
// uc_nation := nation_american ;
95109: LD_ADDR_OWVAR 21
95113: PUSH
95114: LD_INT 1
95116: ST_TO_ADDR
// vc_chassis := us_morphling ;
95117: LD_ADDR_OWVAR 37
95121: PUSH
95122: LD_INT 5
95124: ST_TO_ADDR
// vc_engine := engine_siberite ;
95125: LD_ADDR_OWVAR 39
95129: PUSH
95130: LD_INT 3
95132: ST_TO_ADDR
// vc_control := control_computer ;
95133: LD_ADDR_OWVAR 38
95137: PUSH
95138: LD_INT 3
95140: ST_TO_ADDR
// vc_weapon := us_double_laser ;
95141: LD_ADDR_OWVAR 40
95145: PUSH
95146: LD_INT 10
95148: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
95149: LD_VAR 0 2
95153: PUSH
95154: LD_INT 1
95156: ARRAY
95157: PPUSH
95158: CALL_OW 310
95162: NOT
95163: IFFALSE 95210
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
95165: CALL_OW 45
95169: PPUSH
95170: LD_VAR 0 2
95174: PUSH
95175: LD_INT 1
95177: ARRAY
95178: PPUSH
95179: CALL_OW 250
95183: PPUSH
95184: LD_VAR 0 2
95188: PUSH
95189: LD_INT 1
95191: ARRAY
95192: PPUSH
95193: CALL_OW 251
95197: PPUSH
95198: LD_INT 12
95200: PPUSH
95201: LD_INT 1
95203: PPUSH
95204: CALL_OW 50
95208: GO 95222
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95210: CALL_OW 45
95214: PPUSH
95215: LD_INT 1
95217: PPUSH
95218: CALL_OW 51
// end ;
95222: GO 95096
95224: POP
95225: POP
// end ;
95226: PPOPN 2
95228: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
95229: LD_EXP 114
95233: PUSH
95234: LD_EXP 160
95238: AND
95239: IFFALSE 95461
95241: GO 95243
95243: DISABLE
95244: LD_INT 0
95246: PPUSH
95247: PPUSH
95248: PPUSH
95249: PPUSH
95250: PPUSH
95251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95252: LD_ADDR_VAR 0 6
95256: PUSH
95257: LD_INT 22
95259: PUSH
95260: LD_OWVAR 2
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 21
95271: PUSH
95272: LD_INT 1
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 3
95281: PUSH
95282: LD_INT 23
95284: PUSH
95285: LD_INT 0
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: EMPTY
95297: LIST
95298: LIST
95299: LIST
95300: PPUSH
95301: CALL_OW 69
95305: ST_TO_ADDR
// if not tmp then
95306: LD_VAR 0 6
95310: NOT
95311: IFFALSE 95315
// exit ;
95313: GO 95461
// s1 := rand ( 1 , 4 ) ;
95315: LD_ADDR_VAR 0 2
95319: PUSH
95320: LD_INT 1
95322: PPUSH
95323: LD_INT 4
95325: PPUSH
95326: CALL_OW 12
95330: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
95331: LD_ADDR_VAR 0 4
95335: PUSH
95336: LD_VAR 0 6
95340: PUSH
95341: LD_INT 1
95343: ARRAY
95344: PPUSH
95345: LD_VAR 0 2
95349: PPUSH
95350: CALL_OW 259
95354: ST_TO_ADDR
// if s1 = 1 then
95355: LD_VAR 0 2
95359: PUSH
95360: LD_INT 1
95362: EQUAL
95363: IFFALSE 95383
// s2 := rand ( 2 , 4 ) else
95365: LD_ADDR_VAR 0 3
95369: PUSH
95370: LD_INT 2
95372: PPUSH
95373: LD_INT 4
95375: PPUSH
95376: CALL_OW 12
95380: ST_TO_ADDR
95381: GO 95391
// s2 := 1 ;
95383: LD_ADDR_VAR 0 3
95387: PUSH
95388: LD_INT 1
95390: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95391: LD_ADDR_VAR 0 5
95395: PUSH
95396: LD_VAR 0 6
95400: PUSH
95401: LD_INT 1
95403: ARRAY
95404: PPUSH
95405: LD_VAR 0 3
95409: PPUSH
95410: CALL_OW 259
95414: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95415: LD_VAR 0 6
95419: PUSH
95420: LD_INT 1
95422: ARRAY
95423: PPUSH
95424: LD_VAR 0 2
95428: PPUSH
95429: LD_VAR 0 5
95433: PPUSH
95434: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95438: LD_VAR 0 6
95442: PUSH
95443: LD_INT 1
95445: ARRAY
95446: PPUSH
95447: LD_VAR 0 3
95451: PPUSH
95452: LD_VAR 0 4
95456: PPUSH
95457: CALL_OW 237
// end ;
95461: PPOPN 6
95463: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95464: LD_EXP 114
95468: PUSH
95469: LD_EXP 161
95473: AND
95474: IFFALSE 95553
95476: GO 95478
95478: DISABLE
95479: LD_INT 0
95481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95482: LD_ADDR_VAR 0 1
95486: PUSH
95487: LD_INT 22
95489: PUSH
95490: LD_OWVAR 2
95494: PUSH
95495: EMPTY
95496: LIST
95497: LIST
95498: PUSH
95499: LD_INT 30
95501: PUSH
95502: LD_INT 3
95504: PUSH
95505: EMPTY
95506: LIST
95507: LIST
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PPUSH
95513: CALL_OW 69
95517: ST_TO_ADDR
// if not tmp then
95518: LD_VAR 0 1
95522: NOT
95523: IFFALSE 95527
// exit ;
95525: GO 95553
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95527: LD_VAR 0 1
95531: PUSH
95532: LD_INT 1
95534: PPUSH
95535: LD_VAR 0 1
95539: PPUSH
95540: CALL_OW 12
95544: ARRAY
95545: PPUSH
95546: LD_INT 1
95548: PPUSH
95549: CALL_OW 234
// end ;
95553: PPOPN 1
95555: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95556: LD_EXP 114
95560: PUSH
95561: LD_EXP 162
95565: AND
95566: IFFALSE 95678
95568: GO 95570
95570: DISABLE
95571: LD_INT 0
95573: PPUSH
95574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95575: LD_ADDR_VAR 0 2
95579: PUSH
95580: LD_INT 22
95582: PUSH
95583: LD_OWVAR 2
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 2
95594: PUSH
95595: LD_INT 30
95597: PUSH
95598: LD_INT 27
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 30
95607: PUSH
95608: LD_INT 26
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: LD_INT 30
95617: PUSH
95618: LD_INT 28
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PPUSH
95635: CALL_OW 69
95639: ST_TO_ADDR
// if not tmp then
95640: LD_VAR 0 2
95644: NOT
95645: IFFALSE 95649
// exit ;
95647: GO 95678
// for i in tmp do
95649: LD_ADDR_VAR 0 1
95653: PUSH
95654: LD_VAR 0 2
95658: PUSH
95659: FOR_IN
95660: IFFALSE 95676
// SetLives ( i , 1 ) ;
95662: LD_VAR 0 1
95666: PPUSH
95667: LD_INT 1
95669: PPUSH
95670: CALL_OW 234
95674: GO 95659
95676: POP
95677: POP
// end ;
95678: PPOPN 2
95680: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95681: LD_EXP 114
95685: PUSH
95686: LD_EXP 163
95690: AND
95691: IFFALSE 95978
95693: GO 95695
95695: DISABLE
95696: LD_INT 0
95698: PPUSH
95699: PPUSH
95700: PPUSH
// begin i := rand ( 1 , 7 ) ;
95701: LD_ADDR_VAR 0 1
95705: PUSH
95706: LD_INT 1
95708: PPUSH
95709: LD_INT 7
95711: PPUSH
95712: CALL_OW 12
95716: ST_TO_ADDR
// case i of 1 :
95717: LD_VAR 0 1
95721: PUSH
95722: LD_INT 1
95724: DOUBLE
95725: EQUAL
95726: IFTRUE 95730
95728: GO 95740
95730: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95731: LD_STRING earthquake(getX(game), 0, 32)
95733: PPUSH
95734: CALL_OW 559
95738: GO 95978
95740: LD_INT 2
95742: DOUBLE
95743: EQUAL
95744: IFTRUE 95748
95746: GO 95762
95748: POP
// begin ToLua ( displayStucuk(); ) ;
95749: LD_STRING displayStucuk();
95751: PPUSH
95752: CALL_OW 559
// ResetFog ;
95756: CALL_OW 335
// end ; 3 :
95760: GO 95978
95762: LD_INT 3
95764: DOUBLE
95765: EQUAL
95766: IFTRUE 95770
95768: GO 95874
95770: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95771: LD_ADDR_VAR 0 2
95775: PUSH
95776: LD_INT 22
95778: PUSH
95779: LD_OWVAR 2
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 25
95790: PUSH
95791: LD_INT 1
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PPUSH
95802: CALL_OW 69
95806: ST_TO_ADDR
// if not tmp then
95807: LD_VAR 0 2
95811: NOT
95812: IFFALSE 95816
// exit ;
95814: GO 95978
// un := tmp [ rand ( 1 , tmp ) ] ;
95816: LD_ADDR_VAR 0 3
95820: PUSH
95821: LD_VAR 0 2
95825: PUSH
95826: LD_INT 1
95828: PPUSH
95829: LD_VAR 0 2
95833: PPUSH
95834: CALL_OW 12
95838: ARRAY
95839: ST_TO_ADDR
// if Crawls ( un ) then
95840: LD_VAR 0 3
95844: PPUSH
95845: CALL_OW 318
95849: IFFALSE 95860
// ComWalk ( un ) ;
95851: LD_VAR 0 3
95855: PPUSH
95856: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95860: LD_VAR 0 3
95864: PPUSH
95865: LD_INT 8
95867: PPUSH
95868: CALL_OW 336
// end ; 4 :
95872: GO 95978
95874: LD_INT 4
95876: DOUBLE
95877: EQUAL
95878: IFTRUE 95882
95880: GO 95956
95882: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95883: LD_ADDR_VAR 0 2
95887: PUSH
95888: LD_INT 22
95890: PUSH
95891: LD_OWVAR 2
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: PUSH
95900: LD_INT 30
95902: PUSH
95903: LD_INT 29
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PPUSH
95914: CALL_OW 69
95918: ST_TO_ADDR
// if not tmp then
95919: LD_VAR 0 2
95923: NOT
95924: IFFALSE 95928
// exit ;
95926: GO 95978
// CenterNowOnUnits ( tmp [ 1 ] ) ;
95928: LD_VAR 0 2
95932: PUSH
95933: LD_INT 1
95935: ARRAY
95936: PPUSH
95937: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
95941: LD_VAR 0 2
95945: PUSH
95946: LD_INT 1
95948: ARRAY
95949: PPUSH
95950: CALL_OW 65
// end ; 5 .. 7 :
95954: GO 95978
95956: LD_INT 5
95958: DOUBLE
95959: GREATEREQUAL
95960: IFFALSE 95968
95962: LD_INT 7
95964: DOUBLE
95965: LESSEQUAL
95966: IFTRUE 95970
95968: GO 95977
95970: POP
// StreamSibBomb ; end ;
95971: CALL 92215 0 0
95975: GO 95978
95977: POP
// end ;
95978: PPOPN 3
95980: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95981: LD_EXP 114
95985: PUSH
95986: LD_EXP 164
95990: AND
95991: IFFALSE 96147
95993: GO 95995
95995: DISABLE
95996: LD_INT 0
95998: PPUSH
95999: PPUSH
96000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
96001: LD_ADDR_VAR 0 2
96005: PUSH
96006: LD_INT 81
96008: PUSH
96009: LD_OWVAR 2
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 2
96020: PUSH
96021: LD_INT 21
96023: PUSH
96024: LD_INT 1
96026: PUSH
96027: EMPTY
96028: LIST
96029: LIST
96030: PUSH
96031: LD_INT 21
96033: PUSH
96034: LD_INT 2
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: EMPTY
96042: LIST
96043: LIST
96044: LIST
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PPUSH
96050: CALL_OW 69
96054: ST_TO_ADDR
// if not tmp then
96055: LD_VAR 0 2
96059: NOT
96060: IFFALSE 96064
// exit ;
96062: GO 96147
// p := 0 ;
96064: LD_ADDR_VAR 0 3
96068: PUSH
96069: LD_INT 0
96071: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96072: LD_INT 35
96074: PPUSH
96075: CALL_OW 67
// p := p + 1 ;
96079: LD_ADDR_VAR 0 3
96083: PUSH
96084: LD_VAR 0 3
96088: PUSH
96089: LD_INT 1
96091: PLUS
96092: ST_TO_ADDR
// for i in tmp do
96093: LD_ADDR_VAR 0 1
96097: PUSH
96098: LD_VAR 0 2
96102: PUSH
96103: FOR_IN
96104: IFFALSE 96135
// if GetLives ( i ) < 1000 then
96106: LD_VAR 0 1
96110: PPUSH
96111: CALL_OW 256
96115: PUSH
96116: LD_INT 1000
96118: LESS
96119: IFFALSE 96133
// SetLives ( i , 1000 ) ;
96121: LD_VAR 0 1
96125: PPUSH
96126: LD_INT 1000
96128: PPUSH
96129: CALL_OW 234
96133: GO 96103
96135: POP
96136: POP
// until p > 20 ;
96137: LD_VAR 0 3
96141: PUSH
96142: LD_INT 20
96144: GREATER
96145: IFFALSE 96072
// end ;
96147: PPOPN 3
96149: END
// every 0 0$1 trigger StreamModeActive and sTime do
96150: LD_EXP 114
96154: PUSH
96155: LD_EXP 165
96159: AND
96160: IFFALSE 96195
96162: GO 96164
96164: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
96165: LD_INT 28
96167: PPUSH
96168: LD_OWVAR 2
96172: PPUSH
96173: LD_INT 2
96175: PPUSH
96176: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
96180: LD_INT 30
96182: PPUSH
96183: LD_OWVAR 2
96187: PPUSH
96188: LD_INT 2
96190: PPUSH
96191: CALL_OW 322
// end ;
96195: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
96196: LD_EXP 114
96200: PUSH
96201: LD_EXP 166
96205: AND
96206: IFFALSE 96327
96208: GO 96210
96210: DISABLE
96211: LD_INT 0
96213: PPUSH
96214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96215: LD_ADDR_VAR 0 2
96219: PUSH
96220: LD_INT 22
96222: PUSH
96223: LD_OWVAR 2
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 21
96234: PUSH
96235: LD_INT 1
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 3
96244: PUSH
96245: LD_INT 23
96247: PUSH
96248: LD_INT 0
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: EMPTY
96260: LIST
96261: LIST
96262: LIST
96263: PPUSH
96264: CALL_OW 69
96268: ST_TO_ADDR
// if not tmp then
96269: LD_VAR 0 2
96273: NOT
96274: IFFALSE 96278
// exit ;
96276: GO 96327
// for i in tmp do
96278: LD_ADDR_VAR 0 1
96282: PUSH
96283: LD_VAR 0 2
96287: PUSH
96288: FOR_IN
96289: IFFALSE 96325
// begin if Crawls ( i ) then
96291: LD_VAR 0 1
96295: PPUSH
96296: CALL_OW 318
96300: IFFALSE 96311
// ComWalk ( i ) ;
96302: LD_VAR 0 1
96306: PPUSH
96307: CALL_OW 138
// SetClass ( i , 2 ) ;
96311: LD_VAR 0 1
96315: PPUSH
96316: LD_INT 2
96318: PPUSH
96319: CALL_OW 336
// end ;
96323: GO 96288
96325: POP
96326: POP
// end ;
96327: PPOPN 2
96329: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
96330: LD_EXP 114
96334: PUSH
96335: LD_EXP 167
96339: AND
96340: IFFALSE 96628
96342: GO 96344
96344: DISABLE
96345: LD_INT 0
96347: PPUSH
96348: PPUSH
96349: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96350: LD_OWVAR 2
96354: PPUSH
96355: LD_INT 9
96357: PPUSH
96358: LD_INT 1
96360: PPUSH
96361: LD_INT 1
96363: PPUSH
96364: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96368: LD_INT 9
96370: PPUSH
96371: LD_OWVAR 2
96375: PPUSH
96376: CALL_OW 343
// uc_side := 9 ;
96380: LD_ADDR_OWVAR 20
96384: PUSH
96385: LD_INT 9
96387: ST_TO_ADDR
// uc_nation := 2 ;
96388: LD_ADDR_OWVAR 21
96392: PUSH
96393: LD_INT 2
96395: ST_TO_ADDR
// hc_name := Dark Warrior ;
96396: LD_ADDR_OWVAR 26
96400: PUSH
96401: LD_STRING Dark Warrior
96403: ST_TO_ADDR
// hc_gallery :=  ;
96404: LD_ADDR_OWVAR 33
96408: PUSH
96409: LD_STRING 
96411: ST_TO_ADDR
// hc_noskilllimit := true ;
96412: LD_ADDR_OWVAR 76
96416: PUSH
96417: LD_INT 1
96419: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96420: LD_ADDR_OWVAR 31
96424: PUSH
96425: LD_INT 30
96427: PUSH
96428: LD_INT 30
96430: PUSH
96431: LD_INT 30
96433: PUSH
96434: LD_INT 30
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: ST_TO_ADDR
// un := CreateHuman ;
96443: LD_ADDR_VAR 0 3
96447: PUSH
96448: CALL_OW 44
96452: ST_TO_ADDR
// hc_noskilllimit := false ;
96453: LD_ADDR_OWVAR 76
96457: PUSH
96458: LD_INT 0
96460: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96461: LD_VAR 0 3
96465: PPUSH
96466: LD_INT 1
96468: PPUSH
96469: CALL_OW 51
// ToLua ( playRanger() ) ;
96473: LD_STRING playRanger()
96475: PPUSH
96476: CALL_OW 559
// p := 0 ;
96480: LD_ADDR_VAR 0 2
96484: PUSH
96485: LD_INT 0
96487: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96488: LD_INT 35
96490: PPUSH
96491: CALL_OW 67
// p := p + 1 ;
96495: LD_ADDR_VAR 0 2
96499: PUSH
96500: LD_VAR 0 2
96504: PUSH
96505: LD_INT 1
96507: PLUS
96508: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96509: LD_VAR 0 3
96513: PPUSH
96514: CALL_OW 256
96518: PUSH
96519: LD_INT 1000
96521: LESS
96522: IFFALSE 96536
// SetLives ( un , 1000 ) ;
96524: LD_VAR 0 3
96528: PPUSH
96529: LD_INT 1000
96531: PPUSH
96532: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96536: LD_VAR 0 3
96540: PPUSH
96541: LD_INT 81
96543: PUSH
96544: LD_OWVAR 2
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 91
96555: PUSH
96556: LD_VAR 0 3
96560: PUSH
96561: LD_INT 30
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: LIST
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PPUSH
96573: CALL_OW 69
96577: PPUSH
96578: LD_VAR 0 3
96582: PPUSH
96583: CALL_OW 74
96587: PPUSH
96588: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
96592: LD_VAR 0 2
96596: PUSH
96597: LD_INT 80
96599: GREATER
96600: PUSH
96601: LD_VAR 0 3
96605: PPUSH
96606: CALL_OW 301
96610: OR
96611: IFFALSE 96488
// if un then
96613: LD_VAR 0 3
96617: IFFALSE 96628
// RemoveUnit ( un ) ;
96619: LD_VAR 0 3
96623: PPUSH
96624: CALL_OW 64
// end ;
96628: PPOPN 3
96630: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
96631: LD_EXP 168
96635: IFFALSE 96751
96637: GO 96639
96639: DISABLE
96640: LD_INT 0
96642: PPUSH
96643: PPUSH
96644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96645: LD_ADDR_VAR 0 2
96649: PUSH
96650: LD_INT 81
96652: PUSH
96653: LD_OWVAR 2
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 21
96664: PUSH
96665: LD_INT 1
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PPUSH
96676: CALL_OW 69
96680: ST_TO_ADDR
// ToLua ( playComputer() ) ;
96681: LD_STRING playComputer()
96683: PPUSH
96684: CALL_OW 559
// if not tmp then
96688: LD_VAR 0 2
96692: NOT
96693: IFFALSE 96697
// exit ;
96695: GO 96751
// for i in tmp do
96697: LD_ADDR_VAR 0 1
96701: PUSH
96702: LD_VAR 0 2
96706: PUSH
96707: FOR_IN
96708: IFFALSE 96749
// for j := 1 to 4 do
96710: LD_ADDR_VAR 0 3
96714: PUSH
96715: DOUBLE
96716: LD_INT 1
96718: DEC
96719: ST_TO_ADDR
96720: LD_INT 4
96722: PUSH
96723: FOR_TO
96724: IFFALSE 96745
// SetSkill ( i , j , 10 ) ;
96726: LD_VAR 0 1
96730: PPUSH
96731: LD_VAR 0 3
96735: PPUSH
96736: LD_INT 10
96738: PPUSH
96739: CALL_OW 237
96743: GO 96723
96745: POP
96746: POP
96747: GO 96707
96749: POP
96750: POP
// end ;
96751: PPOPN 3
96753: END
// every 0 0$1 trigger s30 do var i , tmp ;
96754: LD_EXP 169
96758: IFFALSE 96827
96760: GO 96762
96762: DISABLE
96763: LD_INT 0
96765: PPUSH
96766: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96767: LD_ADDR_VAR 0 2
96771: PUSH
96772: LD_INT 22
96774: PUSH
96775: LD_OWVAR 2
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PPUSH
96784: CALL_OW 69
96788: ST_TO_ADDR
// if not tmp then
96789: LD_VAR 0 2
96793: NOT
96794: IFFALSE 96798
// exit ;
96796: GO 96827
// for i in tmp do
96798: LD_ADDR_VAR 0 1
96802: PUSH
96803: LD_VAR 0 2
96807: PUSH
96808: FOR_IN
96809: IFFALSE 96825
// SetLives ( i , 300 ) ;
96811: LD_VAR 0 1
96815: PPUSH
96816: LD_INT 300
96818: PPUSH
96819: CALL_OW 234
96823: GO 96808
96825: POP
96826: POP
// end ;
96827: PPOPN 2
96829: END
// every 0 0$1 trigger s60 do var i , tmp ;
96830: LD_EXP 170
96834: IFFALSE 96903
96836: GO 96838
96838: DISABLE
96839: LD_INT 0
96841: PPUSH
96842: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96843: LD_ADDR_VAR 0 2
96847: PUSH
96848: LD_INT 22
96850: PUSH
96851: LD_OWVAR 2
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: PPUSH
96860: CALL_OW 69
96864: ST_TO_ADDR
// if not tmp then
96865: LD_VAR 0 2
96869: NOT
96870: IFFALSE 96874
// exit ;
96872: GO 96903
// for i in tmp do
96874: LD_ADDR_VAR 0 1
96878: PUSH
96879: LD_VAR 0 2
96883: PUSH
96884: FOR_IN
96885: IFFALSE 96901
// SetLives ( i , 600 ) ;
96887: LD_VAR 0 1
96891: PPUSH
96892: LD_INT 600
96894: PPUSH
96895: CALL_OW 234
96899: GO 96884
96901: POP
96902: POP
// end ;
96903: PPOPN 2
96905: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96906: LD_INT 0
96908: PPUSH
// case cmd of 301 :
96909: LD_VAR 0 1
96913: PUSH
96914: LD_INT 301
96916: DOUBLE
96917: EQUAL
96918: IFTRUE 96922
96920: GO 96954
96922: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96923: LD_VAR 0 6
96927: PPUSH
96928: LD_VAR 0 7
96932: PPUSH
96933: LD_VAR 0 8
96937: PPUSH
96938: LD_VAR 0 4
96942: PPUSH
96943: LD_VAR 0 5
96947: PPUSH
96948: CALL 98155 0 5
96952: GO 97075
96954: LD_INT 302
96956: DOUBLE
96957: EQUAL
96958: IFTRUE 96962
96960: GO 96999
96962: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96963: LD_VAR 0 6
96967: PPUSH
96968: LD_VAR 0 7
96972: PPUSH
96973: LD_VAR 0 8
96977: PPUSH
96978: LD_VAR 0 9
96982: PPUSH
96983: LD_VAR 0 4
96987: PPUSH
96988: LD_VAR 0 5
96992: PPUSH
96993: CALL 98246 0 6
96997: GO 97075
96999: LD_INT 303
97001: DOUBLE
97002: EQUAL
97003: IFTRUE 97007
97005: GO 97044
97007: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
97008: LD_VAR 0 6
97012: PPUSH
97013: LD_VAR 0 7
97017: PPUSH
97018: LD_VAR 0 8
97022: PPUSH
97023: LD_VAR 0 9
97027: PPUSH
97028: LD_VAR 0 4
97032: PPUSH
97033: LD_VAR 0 5
97037: PPUSH
97038: CALL 97080 0 6
97042: GO 97075
97044: LD_INT 304
97046: DOUBLE
97047: EQUAL
97048: IFTRUE 97052
97050: GO 97074
97052: POP
// hHackTeleport ( unit , x , y ) ; end ;
97053: LD_VAR 0 2
97057: PPUSH
97058: LD_VAR 0 4
97062: PPUSH
97063: LD_VAR 0 5
97067: PPUSH
97068: CALL 98839 0 3
97072: GO 97075
97074: POP
// end ;
97075: LD_VAR 0 12
97079: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
97080: LD_INT 0
97082: PPUSH
97083: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
97084: LD_VAR 0 1
97088: PUSH
97089: LD_INT 1
97091: LESS
97092: PUSH
97093: LD_VAR 0 1
97097: PUSH
97098: LD_INT 3
97100: GREATER
97101: OR
97102: PUSH
97103: LD_VAR 0 5
97107: PPUSH
97108: LD_VAR 0 6
97112: PPUSH
97113: CALL_OW 428
97117: OR
97118: IFFALSE 97122
// exit ;
97120: GO 97842
// uc_side := your_side ;
97122: LD_ADDR_OWVAR 20
97126: PUSH
97127: LD_OWVAR 2
97131: ST_TO_ADDR
// uc_nation := nation ;
97132: LD_ADDR_OWVAR 21
97136: PUSH
97137: LD_VAR 0 1
97141: ST_TO_ADDR
// bc_level = 1 ;
97142: LD_ADDR_OWVAR 43
97146: PUSH
97147: LD_INT 1
97149: ST_TO_ADDR
// case btype of 1 :
97150: LD_VAR 0 2
97154: PUSH
97155: LD_INT 1
97157: DOUBLE
97158: EQUAL
97159: IFTRUE 97163
97161: GO 97174
97163: POP
// bc_type := b_depot ; 2 :
97164: LD_ADDR_OWVAR 42
97168: PUSH
97169: LD_INT 0
97171: ST_TO_ADDR
97172: GO 97786
97174: LD_INT 2
97176: DOUBLE
97177: EQUAL
97178: IFTRUE 97182
97180: GO 97193
97182: POP
// bc_type := b_warehouse ; 3 :
97183: LD_ADDR_OWVAR 42
97187: PUSH
97188: LD_INT 1
97190: ST_TO_ADDR
97191: GO 97786
97193: LD_INT 3
97195: DOUBLE
97196: EQUAL
97197: IFTRUE 97201
97199: GO 97212
97201: POP
// bc_type := b_lab ; 4 .. 9 :
97202: LD_ADDR_OWVAR 42
97206: PUSH
97207: LD_INT 6
97209: ST_TO_ADDR
97210: GO 97786
97212: LD_INT 4
97214: DOUBLE
97215: GREATEREQUAL
97216: IFFALSE 97224
97218: LD_INT 9
97220: DOUBLE
97221: LESSEQUAL
97222: IFTRUE 97226
97224: GO 97278
97226: POP
// begin bc_type := b_lab_half ;
97227: LD_ADDR_OWVAR 42
97231: PUSH
97232: LD_INT 7
97234: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
97235: LD_ADDR_OWVAR 44
97239: PUSH
97240: LD_INT 10
97242: PUSH
97243: LD_INT 11
97245: PUSH
97246: LD_INT 12
97248: PUSH
97249: LD_INT 15
97251: PUSH
97252: LD_INT 14
97254: PUSH
97255: LD_INT 13
97257: PUSH
97258: EMPTY
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: PUSH
97266: LD_VAR 0 2
97270: PUSH
97271: LD_INT 3
97273: MINUS
97274: ARRAY
97275: ST_TO_ADDR
// end ; 10 .. 13 :
97276: GO 97786
97278: LD_INT 10
97280: DOUBLE
97281: GREATEREQUAL
97282: IFFALSE 97290
97284: LD_INT 13
97286: DOUBLE
97287: LESSEQUAL
97288: IFTRUE 97292
97290: GO 97369
97292: POP
// begin bc_type := b_lab_full ;
97293: LD_ADDR_OWVAR 42
97297: PUSH
97298: LD_INT 8
97300: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
97301: LD_ADDR_OWVAR 44
97305: PUSH
97306: LD_INT 10
97308: PUSH
97309: LD_INT 12
97311: PUSH
97312: LD_INT 14
97314: PUSH
97315: LD_INT 13
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: PUSH
97324: LD_VAR 0 2
97328: PUSH
97329: LD_INT 9
97331: MINUS
97332: ARRAY
97333: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
97334: LD_ADDR_OWVAR 45
97338: PUSH
97339: LD_INT 11
97341: PUSH
97342: LD_INT 15
97344: PUSH
97345: LD_INT 12
97347: PUSH
97348: LD_INT 15
97350: PUSH
97351: EMPTY
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: PUSH
97357: LD_VAR 0 2
97361: PUSH
97362: LD_INT 9
97364: MINUS
97365: ARRAY
97366: ST_TO_ADDR
// end ; 14 :
97367: GO 97786
97369: LD_INT 14
97371: DOUBLE
97372: EQUAL
97373: IFTRUE 97377
97375: GO 97388
97377: POP
// bc_type := b_workshop ; 15 :
97378: LD_ADDR_OWVAR 42
97382: PUSH
97383: LD_INT 2
97385: ST_TO_ADDR
97386: GO 97786
97388: LD_INT 15
97390: DOUBLE
97391: EQUAL
97392: IFTRUE 97396
97394: GO 97407
97396: POP
// bc_type := b_factory ; 16 :
97397: LD_ADDR_OWVAR 42
97401: PUSH
97402: LD_INT 3
97404: ST_TO_ADDR
97405: GO 97786
97407: LD_INT 16
97409: DOUBLE
97410: EQUAL
97411: IFTRUE 97415
97413: GO 97426
97415: POP
// bc_type := b_ext_gun ; 17 :
97416: LD_ADDR_OWVAR 42
97420: PUSH
97421: LD_INT 17
97423: ST_TO_ADDR
97424: GO 97786
97426: LD_INT 17
97428: DOUBLE
97429: EQUAL
97430: IFTRUE 97434
97432: GO 97462
97434: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
97435: LD_ADDR_OWVAR 42
97439: PUSH
97440: LD_INT 19
97442: PUSH
97443: LD_INT 23
97445: PUSH
97446: LD_INT 19
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: LIST
97453: PUSH
97454: LD_VAR 0 1
97458: ARRAY
97459: ST_TO_ADDR
97460: GO 97786
97462: LD_INT 18
97464: DOUBLE
97465: EQUAL
97466: IFTRUE 97470
97468: GO 97481
97470: POP
// bc_type := b_ext_radar ; 19 :
97471: LD_ADDR_OWVAR 42
97475: PUSH
97476: LD_INT 20
97478: ST_TO_ADDR
97479: GO 97786
97481: LD_INT 19
97483: DOUBLE
97484: EQUAL
97485: IFTRUE 97489
97487: GO 97500
97489: POP
// bc_type := b_ext_radio ; 20 :
97490: LD_ADDR_OWVAR 42
97494: PUSH
97495: LD_INT 22
97497: ST_TO_ADDR
97498: GO 97786
97500: LD_INT 20
97502: DOUBLE
97503: EQUAL
97504: IFTRUE 97508
97506: GO 97519
97508: POP
// bc_type := b_ext_siberium ; 21 :
97509: LD_ADDR_OWVAR 42
97513: PUSH
97514: LD_INT 21
97516: ST_TO_ADDR
97517: GO 97786
97519: LD_INT 21
97521: DOUBLE
97522: EQUAL
97523: IFTRUE 97527
97525: GO 97538
97527: POP
// bc_type := b_ext_computer ; 22 :
97528: LD_ADDR_OWVAR 42
97532: PUSH
97533: LD_INT 24
97535: ST_TO_ADDR
97536: GO 97786
97538: LD_INT 22
97540: DOUBLE
97541: EQUAL
97542: IFTRUE 97546
97544: GO 97557
97546: POP
// bc_type := b_ext_track ; 23 :
97547: LD_ADDR_OWVAR 42
97551: PUSH
97552: LD_INT 16
97554: ST_TO_ADDR
97555: GO 97786
97557: LD_INT 23
97559: DOUBLE
97560: EQUAL
97561: IFTRUE 97565
97563: GO 97576
97565: POP
// bc_type := b_ext_laser ; 24 :
97566: LD_ADDR_OWVAR 42
97570: PUSH
97571: LD_INT 25
97573: ST_TO_ADDR
97574: GO 97786
97576: LD_INT 24
97578: DOUBLE
97579: EQUAL
97580: IFTRUE 97584
97582: GO 97595
97584: POP
// bc_type := b_control_tower ; 25 :
97585: LD_ADDR_OWVAR 42
97589: PUSH
97590: LD_INT 36
97592: ST_TO_ADDR
97593: GO 97786
97595: LD_INT 25
97597: DOUBLE
97598: EQUAL
97599: IFTRUE 97603
97601: GO 97614
97603: POP
// bc_type := b_breastwork ; 26 :
97604: LD_ADDR_OWVAR 42
97608: PUSH
97609: LD_INT 31
97611: ST_TO_ADDR
97612: GO 97786
97614: LD_INT 26
97616: DOUBLE
97617: EQUAL
97618: IFTRUE 97622
97620: GO 97633
97622: POP
// bc_type := b_bunker ; 27 :
97623: LD_ADDR_OWVAR 42
97627: PUSH
97628: LD_INT 32
97630: ST_TO_ADDR
97631: GO 97786
97633: LD_INT 27
97635: DOUBLE
97636: EQUAL
97637: IFTRUE 97641
97639: GO 97652
97641: POP
// bc_type := b_turret ; 28 :
97642: LD_ADDR_OWVAR 42
97646: PUSH
97647: LD_INT 33
97649: ST_TO_ADDR
97650: GO 97786
97652: LD_INT 28
97654: DOUBLE
97655: EQUAL
97656: IFTRUE 97660
97658: GO 97671
97660: POP
// bc_type := b_armoury ; 29 :
97661: LD_ADDR_OWVAR 42
97665: PUSH
97666: LD_INT 4
97668: ST_TO_ADDR
97669: GO 97786
97671: LD_INT 29
97673: DOUBLE
97674: EQUAL
97675: IFTRUE 97679
97677: GO 97690
97679: POP
// bc_type := b_barracks ; 30 :
97680: LD_ADDR_OWVAR 42
97684: PUSH
97685: LD_INT 5
97687: ST_TO_ADDR
97688: GO 97786
97690: LD_INT 30
97692: DOUBLE
97693: EQUAL
97694: IFTRUE 97698
97696: GO 97709
97698: POP
// bc_type := b_solar_power ; 31 :
97699: LD_ADDR_OWVAR 42
97703: PUSH
97704: LD_INT 27
97706: ST_TO_ADDR
97707: GO 97786
97709: LD_INT 31
97711: DOUBLE
97712: EQUAL
97713: IFTRUE 97717
97715: GO 97728
97717: POP
// bc_type := b_oil_power ; 32 :
97718: LD_ADDR_OWVAR 42
97722: PUSH
97723: LD_INT 26
97725: ST_TO_ADDR
97726: GO 97786
97728: LD_INT 32
97730: DOUBLE
97731: EQUAL
97732: IFTRUE 97736
97734: GO 97747
97736: POP
// bc_type := b_siberite_power ; 33 :
97737: LD_ADDR_OWVAR 42
97741: PUSH
97742: LD_INT 28
97744: ST_TO_ADDR
97745: GO 97786
97747: LD_INT 33
97749: DOUBLE
97750: EQUAL
97751: IFTRUE 97755
97753: GO 97766
97755: POP
// bc_type := b_oil_mine ; 34 :
97756: LD_ADDR_OWVAR 42
97760: PUSH
97761: LD_INT 29
97763: ST_TO_ADDR
97764: GO 97786
97766: LD_INT 34
97768: DOUBLE
97769: EQUAL
97770: IFTRUE 97774
97772: GO 97785
97774: POP
// bc_type := b_siberite_mine ; end ;
97775: LD_ADDR_OWVAR 42
97779: PUSH
97780: LD_INT 30
97782: ST_TO_ADDR
97783: GO 97786
97785: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97786: LD_ADDR_VAR 0 8
97790: PUSH
97791: LD_VAR 0 5
97795: PPUSH
97796: LD_VAR 0 6
97800: PPUSH
97801: LD_VAR 0 3
97805: PPUSH
97806: CALL_OW 47
97810: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97811: LD_OWVAR 42
97815: PUSH
97816: LD_INT 32
97818: PUSH
97819: LD_INT 33
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: IN
97826: IFFALSE 97842
// PlaceWeaponTurret ( b , weapon ) ;
97828: LD_VAR 0 8
97832: PPUSH
97833: LD_VAR 0 4
97837: PPUSH
97838: CALL_OW 431
// end ;
97842: LD_VAR 0 7
97846: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97847: LD_INT 0
97849: PPUSH
97850: PPUSH
97851: PPUSH
97852: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97853: LD_ADDR_VAR 0 4
97857: PUSH
97858: LD_INT 22
97860: PUSH
97861: LD_OWVAR 2
97865: PUSH
97866: EMPTY
97867: LIST
97868: LIST
97869: PUSH
97870: LD_INT 2
97872: PUSH
97873: LD_INT 30
97875: PUSH
97876: LD_INT 0
97878: PUSH
97879: EMPTY
97880: LIST
97881: LIST
97882: PUSH
97883: LD_INT 30
97885: PUSH
97886: LD_INT 1
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: PUSH
97893: EMPTY
97894: LIST
97895: LIST
97896: LIST
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PPUSH
97902: CALL_OW 69
97906: ST_TO_ADDR
// if not tmp then
97907: LD_VAR 0 4
97911: NOT
97912: IFFALSE 97916
// exit ;
97914: GO 97975
// for i in tmp do
97916: LD_ADDR_VAR 0 2
97920: PUSH
97921: LD_VAR 0 4
97925: PUSH
97926: FOR_IN
97927: IFFALSE 97973
// for j = 1 to 3 do
97929: LD_ADDR_VAR 0 3
97933: PUSH
97934: DOUBLE
97935: LD_INT 1
97937: DEC
97938: ST_TO_ADDR
97939: LD_INT 3
97941: PUSH
97942: FOR_TO
97943: IFFALSE 97969
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97945: LD_VAR 0 2
97949: PPUSH
97950: CALL_OW 274
97954: PPUSH
97955: LD_VAR 0 3
97959: PPUSH
97960: LD_INT 99999
97962: PPUSH
97963: CALL_OW 277
97967: GO 97942
97969: POP
97970: POP
97971: GO 97926
97973: POP
97974: POP
// end ;
97975: LD_VAR 0 1
97979: RET
// export function hHackSetLevel10 ; var i , j ; begin
97980: LD_INT 0
97982: PPUSH
97983: PPUSH
97984: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97985: LD_ADDR_VAR 0 2
97989: PUSH
97990: LD_INT 21
97992: PUSH
97993: LD_INT 1
97995: PUSH
97996: EMPTY
97997: LIST
97998: LIST
97999: PPUSH
98000: CALL_OW 69
98004: PUSH
98005: FOR_IN
98006: IFFALSE 98058
// if IsSelected ( i ) then
98008: LD_VAR 0 2
98012: PPUSH
98013: CALL_OW 306
98017: IFFALSE 98056
// begin for j := 1 to 4 do
98019: LD_ADDR_VAR 0 3
98023: PUSH
98024: DOUBLE
98025: LD_INT 1
98027: DEC
98028: ST_TO_ADDR
98029: LD_INT 4
98031: PUSH
98032: FOR_TO
98033: IFFALSE 98054
// SetSkill ( i , j , 10 ) ;
98035: LD_VAR 0 2
98039: PPUSH
98040: LD_VAR 0 3
98044: PPUSH
98045: LD_INT 10
98047: PPUSH
98048: CALL_OW 237
98052: GO 98032
98054: POP
98055: POP
// end ;
98056: GO 98005
98058: POP
98059: POP
// end ;
98060: LD_VAR 0 1
98064: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98065: LD_INT 0
98067: PPUSH
98068: PPUSH
98069: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98070: LD_ADDR_VAR 0 2
98074: PUSH
98075: LD_INT 22
98077: PUSH
98078: LD_OWVAR 2
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: PUSH
98087: LD_INT 21
98089: PUSH
98090: LD_INT 1
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PPUSH
98101: CALL_OW 69
98105: PUSH
98106: FOR_IN
98107: IFFALSE 98148
// begin for j := 1 to 4 do
98109: LD_ADDR_VAR 0 3
98113: PUSH
98114: DOUBLE
98115: LD_INT 1
98117: DEC
98118: ST_TO_ADDR
98119: LD_INT 4
98121: PUSH
98122: FOR_TO
98123: IFFALSE 98144
// SetSkill ( i , j , 10 ) ;
98125: LD_VAR 0 2
98129: PPUSH
98130: LD_VAR 0 3
98134: PPUSH
98135: LD_INT 10
98137: PPUSH
98138: CALL_OW 237
98142: GO 98122
98144: POP
98145: POP
// end ;
98146: GO 98106
98148: POP
98149: POP
// end ;
98150: LD_VAR 0 1
98154: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
98155: LD_INT 0
98157: PPUSH
// uc_side := your_side ;
98158: LD_ADDR_OWVAR 20
98162: PUSH
98163: LD_OWVAR 2
98167: ST_TO_ADDR
// uc_nation := nation ;
98168: LD_ADDR_OWVAR 21
98172: PUSH
98173: LD_VAR 0 1
98177: ST_TO_ADDR
// InitHc ;
98178: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98182: LD_INT 0
98184: PPUSH
98185: LD_VAR 0 2
98189: PPUSH
98190: LD_VAR 0 3
98194: PPUSH
98195: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
98199: LD_VAR 0 4
98203: PPUSH
98204: LD_VAR 0 5
98208: PPUSH
98209: CALL_OW 428
98213: PUSH
98214: LD_INT 0
98216: EQUAL
98217: IFFALSE 98241
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
98219: CALL_OW 44
98223: PPUSH
98224: LD_VAR 0 4
98228: PPUSH
98229: LD_VAR 0 5
98233: PPUSH
98234: LD_INT 1
98236: PPUSH
98237: CALL_OW 48
// end ;
98241: LD_VAR 0 6
98245: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
98246: LD_INT 0
98248: PPUSH
98249: PPUSH
// uc_side := your_side ;
98250: LD_ADDR_OWVAR 20
98254: PUSH
98255: LD_OWVAR 2
98259: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
98260: LD_VAR 0 1
98264: PUSH
98265: LD_INT 1
98267: PUSH
98268: LD_INT 2
98270: PUSH
98271: LD_INT 3
98273: PUSH
98274: LD_INT 4
98276: PUSH
98277: LD_INT 5
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: IN
98287: IFFALSE 98299
// uc_nation := nation_american else
98289: LD_ADDR_OWVAR 21
98293: PUSH
98294: LD_INT 1
98296: ST_TO_ADDR
98297: GO 98342
// if chassis in [ 11 , 12 , 13 , 14 ] then
98299: LD_VAR 0 1
98303: PUSH
98304: LD_INT 11
98306: PUSH
98307: LD_INT 12
98309: PUSH
98310: LD_INT 13
98312: PUSH
98313: LD_INT 14
98315: PUSH
98316: EMPTY
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: IN
98322: IFFALSE 98334
// uc_nation := nation_arabian else
98324: LD_ADDR_OWVAR 21
98328: PUSH
98329: LD_INT 2
98331: ST_TO_ADDR
98332: GO 98342
// uc_nation := nation_russian ;
98334: LD_ADDR_OWVAR 21
98338: PUSH
98339: LD_INT 3
98341: ST_TO_ADDR
// vc_chassis := chassis ;
98342: LD_ADDR_OWVAR 37
98346: PUSH
98347: LD_VAR 0 1
98351: ST_TO_ADDR
// vc_engine := engine ;
98352: LD_ADDR_OWVAR 39
98356: PUSH
98357: LD_VAR 0 2
98361: ST_TO_ADDR
// vc_control := control ;
98362: LD_ADDR_OWVAR 38
98366: PUSH
98367: LD_VAR 0 3
98371: ST_TO_ADDR
// vc_weapon := weapon ;
98372: LD_ADDR_OWVAR 40
98376: PUSH
98377: LD_VAR 0 4
98381: ST_TO_ADDR
// un := CreateVehicle ;
98382: LD_ADDR_VAR 0 8
98386: PUSH
98387: CALL_OW 45
98391: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
98392: LD_VAR 0 8
98396: PPUSH
98397: LD_INT 0
98399: PPUSH
98400: LD_INT 5
98402: PPUSH
98403: CALL_OW 12
98407: PPUSH
98408: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
98412: LD_VAR 0 8
98416: PPUSH
98417: LD_VAR 0 5
98421: PPUSH
98422: LD_VAR 0 6
98426: PPUSH
98427: LD_INT 1
98429: PPUSH
98430: CALL_OW 48
// end ;
98434: LD_VAR 0 7
98438: RET
// export hInvincible ; every 1 do
98439: GO 98441
98441: DISABLE
// hInvincible := [ ] ;
98442: LD_ADDR_EXP 171
98446: PUSH
98447: EMPTY
98448: ST_TO_ADDR
98449: END
// every 10 do var i ;
98450: GO 98452
98452: DISABLE
98453: LD_INT 0
98455: PPUSH
// begin enable ;
98456: ENABLE
// if not hInvincible then
98457: LD_EXP 171
98461: NOT
98462: IFFALSE 98466
// exit ;
98464: GO 98510
// for i in hInvincible do
98466: LD_ADDR_VAR 0 1
98470: PUSH
98471: LD_EXP 171
98475: PUSH
98476: FOR_IN
98477: IFFALSE 98508
// if GetLives ( i ) < 1000 then
98479: LD_VAR 0 1
98483: PPUSH
98484: CALL_OW 256
98488: PUSH
98489: LD_INT 1000
98491: LESS
98492: IFFALSE 98506
// SetLives ( i , 1000 ) ;
98494: LD_VAR 0 1
98498: PPUSH
98499: LD_INT 1000
98501: PPUSH
98502: CALL_OW 234
98506: GO 98476
98508: POP
98509: POP
// end ;
98510: PPOPN 1
98512: END
// export function hHackInvincible ; var i ; begin
98513: LD_INT 0
98515: PPUSH
98516: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
98517: LD_ADDR_VAR 0 2
98521: PUSH
98522: LD_INT 2
98524: PUSH
98525: LD_INT 21
98527: PUSH
98528: LD_INT 1
98530: PUSH
98531: EMPTY
98532: LIST
98533: LIST
98534: PUSH
98535: LD_INT 21
98537: PUSH
98538: LD_INT 2
98540: PUSH
98541: EMPTY
98542: LIST
98543: LIST
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: LIST
98549: PPUSH
98550: CALL_OW 69
98554: PUSH
98555: FOR_IN
98556: IFFALSE 98617
// if IsSelected ( i ) then
98558: LD_VAR 0 2
98562: PPUSH
98563: CALL_OW 306
98567: IFFALSE 98615
// begin if i in hInvincible then
98569: LD_VAR 0 2
98573: PUSH
98574: LD_EXP 171
98578: IN
98579: IFFALSE 98599
// hInvincible := hInvincible diff i else
98581: LD_ADDR_EXP 171
98585: PUSH
98586: LD_EXP 171
98590: PUSH
98591: LD_VAR 0 2
98595: DIFF
98596: ST_TO_ADDR
98597: GO 98615
// hInvincible := hInvincible union i ;
98599: LD_ADDR_EXP 171
98603: PUSH
98604: LD_EXP 171
98608: PUSH
98609: LD_VAR 0 2
98613: UNION
98614: ST_TO_ADDR
// end ;
98615: GO 98555
98617: POP
98618: POP
// end ;
98619: LD_VAR 0 1
98623: RET
// export function hHackInvisible ; var i , j ; begin
98624: LD_INT 0
98626: PPUSH
98627: PPUSH
98628: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98629: LD_ADDR_VAR 0 2
98633: PUSH
98634: LD_INT 21
98636: PUSH
98637: LD_INT 1
98639: PUSH
98640: EMPTY
98641: LIST
98642: LIST
98643: PPUSH
98644: CALL_OW 69
98648: PUSH
98649: FOR_IN
98650: IFFALSE 98674
// if IsSelected ( i ) then
98652: LD_VAR 0 2
98656: PPUSH
98657: CALL_OW 306
98661: IFFALSE 98672
// ComForceInvisible ( i ) ;
98663: LD_VAR 0 2
98667: PPUSH
98668: CALL_OW 496
98672: GO 98649
98674: POP
98675: POP
// end ;
98676: LD_VAR 0 1
98680: RET
// export function hHackChangeYourSide ; begin
98681: LD_INT 0
98683: PPUSH
// if your_side = 8 then
98684: LD_OWVAR 2
98688: PUSH
98689: LD_INT 8
98691: EQUAL
98692: IFFALSE 98704
// your_side := 0 else
98694: LD_ADDR_OWVAR 2
98698: PUSH
98699: LD_INT 0
98701: ST_TO_ADDR
98702: GO 98718
// your_side := your_side + 1 ;
98704: LD_ADDR_OWVAR 2
98708: PUSH
98709: LD_OWVAR 2
98713: PUSH
98714: LD_INT 1
98716: PLUS
98717: ST_TO_ADDR
// end ;
98718: LD_VAR 0 1
98722: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98723: LD_INT 0
98725: PPUSH
98726: PPUSH
98727: PPUSH
// for i in all_units do
98728: LD_ADDR_VAR 0 2
98732: PUSH
98733: LD_OWVAR 3
98737: PUSH
98738: FOR_IN
98739: IFFALSE 98817
// if IsSelected ( i ) then
98741: LD_VAR 0 2
98745: PPUSH
98746: CALL_OW 306
98750: IFFALSE 98815
// begin j := GetSide ( i ) ;
98752: LD_ADDR_VAR 0 3
98756: PUSH
98757: LD_VAR 0 2
98761: PPUSH
98762: CALL_OW 255
98766: ST_TO_ADDR
// if j = 8 then
98767: LD_VAR 0 3
98771: PUSH
98772: LD_INT 8
98774: EQUAL
98775: IFFALSE 98787
// j := 0 else
98777: LD_ADDR_VAR 0 3
98781: PUSH
98782: LD_INT 0
98784: ST_TO_ADDR
98785: GO 98801
// j := j + 1 ;
98787: LD_ADDR_VAR 0 3
98791: PUSH
98792: LD_VAR 0 3
98796: PUSH
98797: LD_INT 1
98799: PLUS
98800: ST_TO_ADDR
// SetSide ( i , j ) ;
98801: LD_VAR 0 2
98805: PPUSH
98806: LD_VAR 0 3
98810: PPUSH
98811: CALL_OW 235
// end ;
98815: GO 98738
98817: POP
98818: POP
// end ;
98819: LD_VAR 0 1
98823: RET
// export function hHackFog ; begin
98824: LD_INT 0
98826: PPUSH
// FogOff ( true ) ;
98827: LD_INT 1
98829: PPUSH
98830: CALL_OW 344
// end ;
98834: LD_VAR 0 1
98838: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98839: LD_INT 0
98841: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98842: LD_VAR 0 1
98846: PPUSH
98847: LD_VAR 0 2
98851: PPUSH
98852: LD_VAR 0 3
98856: PPUSH
98857: LD_INT 1
98859: PPUSH
98860: LD_INT 1
98862: PPUSH
98863: CALL_OW 483
// CenterOnXY ( x , y ) ;
98867: LD_VAR 0 2
98871: PPUSH
98872: LD_VAR 0 3
98876: PPUSH
98877: CALL_OW 84
// end ; end_of_file
98881: LD_VAR 0 4
98885: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98886: LD_INT 0
98888: PPUSH
98889: PPUSH
98890: PPUSH
98891: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98892: LD_VAR 0 1
98896: PPUSH
98897: CALL_OW 264
98901: PUSH
98902: LD_EXP 52
98906: EQUAL
98907: IFFALSE 98979
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98909: LD_INT 68
98911: PPUSH
98912: LD_VAR 0 1
98916: PPUSH
98917: CALL_OW 255
98921: PPUSH
98922: CALL_OW 321
98926: PUSH
98927: LD_INT 2
98929: EQUAL
98930: IFFALSE 98942
// eff := 70 else
98932: LD_ADDR_VAR 0 4
98936: PUSH
98937: LD_INT 70
98939: ST_TO_ADDR
98940: GO 98950
// eff := 30 ;
98942: LD_ADDR_VAR 0 4
98946: PUSH
98947: LD_INT 30
98949: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98950: LD_VAR 0 1
98954: PPUSH
98955: CALL_OW 250
98959: PPUSH
98960: LD_VAR 0 1
98964: PPUSH
98965: CALL_OW 251
98969: PPUSH
98970: LD_VAR 0 4
98974: PPUSH
98975: CALL_OW 495
// end ; end ;
98979: LD_VAR 0 2
98983: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98984: LD_INT 0
98986: PPUSH
// end ;
98987: LD_VAR 0 4
98991: RET
// export function SOS_Command ( cmd ) ; begin
98992: LD_INT 0
98994: PPUSH
// end ;
98995: LD_VAR 0 2
98999: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
99000: LD_INT 0
99002: PPUSH
// end ;
99003: LD_VAR 0 6
99007: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
99008: LD_INT 0
99010: PPUSH
99011: PPUSH
// if not vehicle or not factory then
99012: LD_VAR 0 1
99016: NOT
99017: PUSH
99018: LD_VAR 0 2
99022: NOT
99023: OR
99024: IFFALSE 99028
// exit ;
99026: GO 99259
// if factoryWaypoints >= factory then
99028: LD_EXP 172
99032: PUSH
99033: LD_VAR 0 2
99037: GREATEREQUAL
99038: IFFALSE 99259
// if factoryWaypoints [ factory ] then
99040: LD_EXP 172
99044: PUSH
99045: LD_VAR 0 2
99049: ARRAY
99050: IFFALSE 99259
// begin if GetControl ( vehicle ) = control_manual then
99052: LD_VAR 0 1
99056: PPUSH
99057: CALL_OW 263
99061: PUSH
99062: LD_INT 1
99064: EQUAL
99065: IFFALSE 99146
// begin driver := IsDrivenBy ( vehicle ) ;
99067: LD_ADDR_VAR 0 4
99071: PUSH
99072: LD_VAR 0 1
99076: PPUSH
99077: CALL_OW 311
99081: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
99082: LD_VAR 0 4
99086: PPUSH
99087: LD_EXP 172
99091: PUSH
99092: LD_VAR 0 2
99096: ARRAY
99097: PUSH
99098: LD_INT 3
99100: ARRAY
99101: PPUSH
99102: LD_EXP 172
99106: PUSH
99107: LD_VAR 0 2
99111: ARRAY
99112: PUSH
99113: LD_INT 4
99115: ARRAY
99116: PPUSH
99117: CALL_OW 171
// AddComExitVehicle ( driver ) ;
99121: LD_VAR 0 4
99125: PPUSH
99126: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
99130: LD_VAR 0 4
99134: PPUSH
99135: LD_VAR 0 2
99139: PPUSH
99140: CALL_OW 180
// end else
99144: GO 99259
// if GetControl ( vehicle ) = control_remote then
99146: LD_VAR 0 1
99150: PPUSH
99151: CALL_OW 263
99155: PUSH
99156: LD_INT 2
99158: EQUAL
99159: IFFALSE 99220
// begin wait ( 0 0$2 ) ;
99161: LD_INT 70
99163: PPUSH
99164: CALL_OW 67
// if Connect ( vehicle ) then
99168: LD_VAR 0 1
99172: PPUSH
99173: CALL 21568 0 1
99177: IFFALSE 99218
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
99179: LD_VAR 0 1
99183: PPUSH
99184: LD_EXP 172
99188: PUSH
99189: LD_VAR 0 2
99193: ARRAY
99194: PUSH
99195: LD_INT 3
99197: ARRAY
99198: PPUSH
99199: LD_EXP 172
99203: PUSH
99204: LD_VAR 0 2
99208: ARRAY
99209: PUSH
99210: LD_INT 4
99212: ARRAY
99213: PPUSH
99214: CALL_OW 171
// end else
99218: GO 99259
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
99220: LD_VAR 0 1
99224: PPUSH
99225: LD_EXP 172
99229: PUSH
99230: LD_VAR 0 2
99234: ARRAY
99235: PUSH
99236: LD_INT 3
99238: ARRAY
99239: PPUSH
99240: LD_EXP 172
99244: PUSH
99245: LD_VAR 0 2
99249: ARRAY
99250: PUSH
99251: LD_INT 4
99253: ARRAY
99254: PPUSH
99255: CALL_OW 171
// end ; end ;
99259: LD_VAR 0 3
99263: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99264: LD_INT 0
99266: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
99267: LD_VAR 0 1
99271: PUSH
99272: LD_INT 250
99274: EQUAL
99275: PUSH
99276: LD_VAR 0 2
99280: PPUSH
99281: CALL_OW 264
99285: PUSH
99286: LD_EXP 55
99290: EQUAL
99291: AND
99292: IFFALSE 99313
// MinerPlaceMine ( unit , x , y ) ;
99294: LD_VAR 0 2
99298: PPUSH
99299: LD_VAR 0 4
99303: PPUSH
99304: LD_VAR 0 5
99308: PPUSH
99309: CALL 102041 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
99313: LD_VAR 0 1
99317: PUSH
99318: LD_INT 251
99320: EQUAL
99321: PUSH
99322: LD_VAR 0 2
99326: PPUSH
99327: CALL_OW 264
99331: PUSH
99332: LD_EXP 55
99336: EQUAL
99337: AND
99338: IFFALSE 99359
// MinerDetonateMine ( unit , x , y ) ;
99340: LD_VAR 0 2
99344: PPUSH
99345: LD_VAR 0 4
99349: PPUSH
99350: LD_VAR 0 5
99354: PPUSH
99355: CALL 102318 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
99359: LD_VAR 0 1
99363: PUSH
99364: LD_INT 252
99366: EQUAL
99367: PUSH
99368: LD_VAR 0 2
99372: PPUSH
99373: CALL_OW 264
99377: PUSH
99378: LD_EXP 55
99382: EQUAL
99383: AND
99384: IFFALSE 99405
// MinerCreateMinefield ( unit , x , y ) ;
99386: LD_VAR 0 2
99390: PPUSH
99391: LD_VAR 0 4
99395: PPUSH
99396: LD_VAR 0 5
99400: PPUSH
99401: CALL 102735 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
99405: LD_VAR 0 1
99409: PUSH
99410: LD_INT 253
99412: EQUAL
99413: PUSH
99414: LD_VAR 0 2
99418: PPUSH
99419: CALL_OW 257
99423: PUSH
99424: LD_INT 5
99426: EQUAL
99427: AND
99428: IFFALSE 99449
// ComBinocular ( unit , x , y ) ;
99430: LD_VAR 0 2
99434: PPUSH
99435: LD_VAR 0 4
99439: PPUSH
99440: LD_VAR 0 5
99444: PPUSH
99445: CALL 103106 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99449: LD_VAR 0 1
99453: PUSH
99454: LD_INT 254
99456: EQUAL
99457: PUSH
99458: LD_VAR 0 2
99462: PPUSH
99463: CALL_OW 264
99467: PUSH
99468: LD_EXP 50
99472: EQUAL
99473: AND
99474: PUSH
99475: LD_VAR 0 3
99479: PPUSH
99480: CALL_OW 263
99484: PUSH
99485: LD_INT 3
99487: EQUAL
99488: AND
99489: IFFALSE 99505
// HackDestroyVehicle ( unit , selectedUnit ) ;
99491: LD_VAR 0 2
99495: PPUSH
99496: LD_VAR 0 3
99500: PPUSH
99501: CALL 101401 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99505: LD_VAR 0 1
99509: PUSH
99510: LD_INT 255
99512: EQUAL
99513: PUSH
99514: LD_VAR 0 2
99518: PPUSH
99519: CALL_OW 264
99523: PUSH
99524: LD_INT 14
99526: PUSH
99527: LD_INT 53
99529: PUSH
99530: EMPTY
99531: LIST
99532: LIST
99533: IN
99534: AND
99535: PUSH
99536: LD_VAR 0 4
99540: PPUSH
99541: LD_VAR 0 5
99545: PPUSH
99546: CALL_OW 488
99550: AND
99551: IFFALSE 99575
// CutTreeXYR ( unit , x , y , 12 ) ;
99553: LD_VAR 0 2
99557: PPUSH
99558: LD_VAR 0 4
99562: PPUSH
99563: LD_VAR 0 5
99567: PPUSH
99568: LD_INT 12
99570: PPUSH
99571: CALL 99967 0 4
// if cmd = 256 then
99575: LD_VAR 0 1
99579: PUSH
99580: LD_INT 256
99582: EQUAL
99583: IFFALSE 99604
// SetFactoryWaypoint ( unit , x , y ) ;
99585: LD_VAR 0 2
99589: PPUSH
99590: LD_VAR 0 4
99594: PPUSH
99595: LD_VAR 0 5
99599: PPUSH
99600: CALL 99609 0 3
// end ;
99604: LD_VAR 0 6
99608: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
99609: LD_INT 0
99611: PPUSH
99612: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
99613: LD_VAR 0 1
99617: NOT
99618: PUSH
99619: LD_VAR 0 2
99623: PPUSH
99624: LD_VAR 0 3
99628: PPUSH
99629: CALL_OW 488
99633: NOT
99634: OR
99635: PUSH
99636: LD_VAR 0 1
99640: PPUSH
99641: CALL_OW 266
99645: PUSH
99646: LD_INT 3
99648: NONEQUAL
99649: PUSH
99650: LD_VAR 0 1
99654: PPUSH
99655: CALL_OW 247
99659: PUSH
99660: LD_INT 1
99662: EQUAL
99663: NOT
99664: AND
99665: OR
99666: IFFALSE 99670
// exit ;
99668: GO 99819
// if GetType ( factory ) = unit_human then
99670: LD_VAR 0 1
99674: PPUSH
99675: CALL_OW 247
99679: PUSH
99680: LD_INT 1
99682: EQUAL
99683: IFFALSE 99700
// factory := IsInUnit ( factory ) ;
99685: LD_ADDR_VAR 0 1
99689: PUSH
99690: LD_VAR 0 1
99694: PPUSH
99695: CALL_OW 310
99699: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
99700: LD_VAR 0 1
99704: PPUSH
99705: CALL_OW 266
99709: PUSH
99710: LD_INT 3
99712: NONEQUAL
99713: IFFALSE 99717
// exit ;
99715: GO 99819
// if HexInfo ( x , y ) = factory then
99717: LD_VAR 0 2
99721: PPUSH
99722: LD_VAR 0 3
99726: PPUSH
99727: CALL_OW 428
99731: PUSH
99732: LD_VAR 0 1
99736: EQUAL
99737: IFFALSE 99764
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
99739: LD_ADDR_EXP 172
99743: PUSH
99744: LD_EXP 172
99748: PPUSH
99749: LD_VAR 0 1
99753: PPUSH
99754: LD_INT 0
99756: PPUSH
99757: CALL_OW 1
99761: ST_TO_ADDR
99762: GO 99815
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
99764: LD_ADDR_EXP 172
99768: PUSH
99769: LD_EXP 172
99773: PPUSH
99774: LD_VAR 0 1
99778: PPUSH
99779: LD_VAR 0 1
99783: PPUSH
99784: CALL_OW 255
99788: PUSH
99789: LD_VAR 0 1
99793: PUSH
99794: LD_VAR 0 2
99798: PUSH
99799: LD_VAR 0 3
99803: PUSH
99804: EMPTY
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: PPUSH
99810: CALL_OW 1
99814: ST_TO_ADDR
// UpdateFactoryWaypoints ;
99815: CALL 99824 0 0
// end ;
99819: LD_VAR 0 4
99823: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
99824: LD_INT 0
99826: PPUSH
99827: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
99828: LD_STRING resetFactoryWaypoint();
99830: PPUSH
99831: CALL_OW 559
// if factoryWaypoints then
99835: LD_EXP 172
99839: IFFALSE 99962
// begin for i := 1 to factoryWaypoints do
99841: LD_ADDR_VAR 0 2
99845: PUSH
99846: DOUBLE
99847: LD_INT 1
99849: DEC
99850: ST_TO_ADDR
99851: LD_EXP 172
99855: PUSH
99856: FOR_TO
99857: IFFALSE 99960
// if factoryWaypoints [ i ] then
99859: LD_EXP 172
99863: PUSH
99864: LD_VAR 0 2
99868: ARRAY
99869: IFFALSE 99958
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
99871: LD_STRING setFactoryWaypointXY(
99873: PUSH
99874: LD_EXP 172
99878: PUSH
99879: LD_VAR 0 2
99883: ARRAY
99884: PUSH
99885: LD_INT 1
99887: ARRAY
99888: STR
99889: PUSH
99890: LD_STRING ,
99892: STR
99893: PUSH
99894: LD_EXP 172
99898: PUSH
99899: LD_VAR 0 2
99903: ARRAY
99904: PUSH
99905: LD_INT 2
99907: ARRAY
99908: STR
99909: PUSH
99910: LD_STRING ,
99912: STR
99913: PUSH
99914: LD_EXP 172
99918: PUSH
99919: LD_VAR 0 2
99923: ARRAY
99924: PUSH
99925: LD_INT 3
99927: ARRAY
99928: STR
99929: PUSH
99930: LD_STRING ,
99932: STR
99933: PUSH
99934: LD_EXP 172
99938: PUSH
99939: LD_VAR 0 2
99943: ARRAY
99944: PUSH
99945: LD_INT 4
99947: ARRAY
99948: STR
99949: PUSH
99950: LD_STRING )
99952: STR
99953: PPUSH
99954: CALL_OW 559
99958: GO 99856
99960: POP
99961: POP
// end ; end ;
99962: LD_VAR 0 1
99966: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99967: LD_INT 0
99969: PPUSH
99970: PPUSH
99971: PPUSH
99972: PPUSH
99973: PPUSH
99974: PPUSH
99975: PPUSH
99976: PPUSH
99977: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99978: LD_VAR 0 1
99982: NOT
99983: PUSH
99984: LD_VAR 0 2
99988: PPUSH
99989: LD_VAR 0 3
99993: PPUSH
99994: CALL_OW 488
99998: NOT
99999: OR
100000: PUSH
100001: LD_VAR 0 4
100005: NOT
100006: OR
100007: IFFALSE 100011
// exit ;
100009: GO 100351
// list := [ ] ;
100011: LD_ADDR_VAR 0 13
100015: PUSH
100016: EMPTY
100017: ST_TO_ADDR
// if x - r < 0 then
100018: LD_VAR 0 2
100022: PUSH
100023: LD_VAR 0 4
100027: MINUS
100028: PUSH
100029: LD_INT 0
100031: LESS
100032: IFFALSE 100044
// min_x := 0 else
100034: LD_ADDR_VAR 0 7
100038: PUSH
100039: LD_INT 0
100041: ST_TO_ADDR
100042: GO 100060
// min_x := x - r ;
100044: LD_ADDR_VAR 0 7
100048: PUSH
100049: LD_VAR 0 2
100053: PUSH
100054: LD_VAR 0 4
100058: MINUS
100059: ST_TO_ADDR
// if y - r < 0 then
100060: LD_VAR 0 3
100064: PUSH
100065: LD_VAR 0 4
100069: MINUS
100070: PUSH
100071: LD_INT 0
100073: LESS
100074: IFFALSE 100086
// min_y := 0 else
100076: LD_ADDR_VAR 0 8
100080: PUSH
100081: LD_INT 0
100083: ST_TO_ADDR
100084: GO 100102
// min_y := y - r ;
100086: LD_ADDR_VAR 0 8
100090: PUSH
100091: LD_VAR 0 3
100095: PUSH
100096: LD_VAR 0 4
100100: MINUS
100101: ST_TO_ADDR
// max_x := x + r ;
100102: LD_ADDR_VAR 0 9
100106: PUSH
100107: LD_VAR 0 2
100111: PUSH
100112: LD_VAR 0 4
100116: PLUS
100117: ST_TO_ADDR
// max_y := y + r ;
100118: LD_ADDR_VAR 0 10
100122: PUSH
100123: LD_VAR 0 3
100127: PUSH
100128: LD_VAR 0 4
100132: PLUS
100133: ST_TO_ADDR
// for _x = min_x to max_x do
100134: LD_ADDR_VAR 0 11
100138: PUSH
100139: DOUBLE
100140: LD_VAR 0 7
100144: DEC
100145: ST_TO_ADDR
100146: LD_VAR 0 9
100150: PUSH
100151: FOR_TO
100152: IFFALSE 100269
// for _y = min_y to max_y do
100154: LD_ADDR_VAR 0 12
100158: PUSH
100159: DOUBLE
100160: LD_VAR 0 8
100164: DEC
100165: ST_TO_ADDR
100166: LD_VAR 0 10
100170: PUSH
100171: FOR_TO
100172: IFFALSE 100265
// begin if not ValidHex ( _x , _y ) then
100174: LD_VAR 0 11
100178: PPUSH
100179: LD_VAR 0 12
100183: PPUSH
100184: CALL_OW 488
100188: NOT
100189: IFFALSE 100193
// continue ;
100191: GO 100171
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
100193: LD_VAR 0 11
100197: PPUSH
100198: LD_VAR 0 12
100202: PPUSH
100203: CALL_OW 351
100207: PUSH
100208: LD_VAR 0 11
100212: PPUSH
100213: LD_VAR 0 12
100217: PPUSH
100218: CALL_OW 554
100222: AND
100223: IFFALSE 100263
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
100225: LD_ADDR_VAR 0 13
100229: PUSH
100230: LD_VAR 0 13
100234: PPUSH
100235: LD_VAR 0 13
100239: PUSH
100240: LD_INT 1
100242: PLUS
100243: PPUSH
100244: LD_VAR 0 11
100248: PUSH
100249: LD_VAR 0 12
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PPUSH
100258: CALL_OW 2
100262: ST_TO_ADDR
// end ;
100263: GO 100171
100265: POP
100266: POP
100267: GO 100151
100269: POP
100270: POP
// if not list then
100271: LD_VAR 0 13
100275: NOT
100276: IFFALSE 100280
// exit ;
100278: GO 100351
// for i in list do
100280: LD_ADDR_VAR 0 6
100284: PUSH
100285: LD_VAR 0 13
100289: PUSH
100290: FOR_IN
100291: IFFALSE 100349
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
100293: LD_VAR 0 1
100297: PPUSH
100298: LD_STRING M
100300: PUSH
100301: LD_VAR 0 6
100305: PUSH
100306: LD_INT 1
100308: ARRAY
100309: PUSH
100310: LD_VAR 0 6
100314: PUSH
100315: LD_INT 2
100317: ARRAY
100318: PUSH
100319: LD_INT 0
100321: PUSH
100322: LD_INT 0
100324: PUSH
100325: LD_INT 0
100327: PUSH
100328: LD_INT 0
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: LIST
100337: LIST
100338: LIST
100339: PUSH
100340: EMPTY
100341: LIST
100342: PPUSH
100343: CALL_OW 447
100347: GO 100290
100349: POP
100350: POP
// end ;
100351: LD_VAR 0 5
100355: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
100356: LD_EXP 173
100360: NOT
100361: IFFALSE 100411
100363: GO 100365
100365: DISABLE
// begin initHack := true ;
100366: LD_ADDR_EXP 173
100370: PUSH
100371: LD_INT 1
100373: ST_TO_ADDR
// hackTanks := [ ] ;
100374: LD_ADDR_EXP 174
100378: PUSH
100379: EMPTY
100380: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
100381: LD_ADDR_EXP 175
100385: PUSH
100386: EMPTY
100387: ST_TO_ADDR
// hackLimit := 3 ;
100388: LD_ADDR_EXP 176
100392: PUSH
100393: LD_INT 3
100395: ST_TO_ADDR
// hackDist := 12 ;
100396: LD_ADDR_EXP 177
100400: PUSH
100401: LD_INT 12
100403: ST_TO_ADDR
// hackCounter := [ ] ;
100404: LD_ADDR_EXP 178
100408: PUSH
100409: EMPTY
100410: ST_TO_ADDR
// end ;
100411: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
100412: LD_EXP 173
100416: PUSH
100417: LD_INT 34
100419: PUSH
100420: LD_EXP 50
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PPUSH
100429: CALL_OW 69
100433: AND
100434: IFFALSE 100689
100436: GO 100438
100438: DISABLE
100439: LD_INT 0
100441: PPUSH
100442: PPUSH
// begin enable ;
100443: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100444: LD_ADDR_VAR 0 1
100448: PUSH
100449: LD_INT 34
100451: PUSH
100452: LD_EXP 50
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: PPUSH
100461: CALL_OW 69
100465: PUSH
100466: FOR_IN
100467: IFFALSE 100687
// begin if not i in hackTanks then
100469: LD_VAR 0 1
100473: PUSH
100474: LD_EXP 174
100478: IN
100479: NOT
100480: IFFALSE 100563
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100482: LD_ADDR_EXP 174
100486: PUSH
100487: LD_EXP 174
100491: PPUSH
100492: LD_EXP 174
100496: PUSH
100497: LD_INT 1
100499: PLUS
100500: PPUSH
100501: LD_VAR 0 1
100505: PPUSH
100506: CALL_OW 1
100510: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100511: LD_ADDR_EXP 175
100515: PUSH
100516: LD_EXP 175
100520: PPUSH
100521: LD_EXP 175
100525: PUSH
100526: LD_INT 1
100528: PLUS
100529: PPUSH
100530: EMPTY
100531: PPUSH
100532: CALL_OW 1
100536: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
100537: LD_ADDR_EXP 178
100541: PUSH
100542: LD_EXP 178
100546: PPUSH
100547: LD_EXP 178
100551: PUSH
100552: LD_INT 1
100554: PLUS
100555: PPUSH
100556: EMPTY
100557: PPUSH
100558: CALL_OW 1
100562: ST_TO_ADDR
// end ; if not IsOk ( i ) then
100563: LD_VAR 0 1
100567: PPUSH
100568: CALL_OW 302
100572: NOT
100573: IFFALSE 100586
// begin HackUnlinkAll ( i ) ;
100575: LD_VAR 0 1
100579: PPUSH
100580: CALL 100692 0 1
// continue ;
100584: GO 100466
// end ; HackCheckCapturedStatus ( i ) ;
100586: LD_VAR 0 1
100590: PPUSH
100591: CALL 101135 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100595: LD_ADDR_VAR 0 2
100599: PUSH
100600: LD_INT 81
100602: PUSH
100603: LD_VAR 0 1
100607: PPUSH
100608: CALL_OW 255
100612: PUSH
100613: EMPTY
100614: LIST
100615: LIST
100616: PUSH
100617: LD_INT 33
100619: PUSH
100620: LD_INT 3
100622: PUSH
100623: EMPTY
100624: LIST
100625: LIST
100626: PUSH
100627: LD_INT 91
100629: PUSH
100630: LD_VAR 0 1
100634: PUSH
100635: LD_EXP 177
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: LIST
100644: PUSH
100645: LD_INT 50
100647: PUSH
100648: EMPTY
100649: LIST
100650: PUSH
100651: EMPTY
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: PPUSH
100657: CALL_OW 69
100661: ST_TO_ADDR
// if not tmp then
100662: LD_VAR 0 2
100666: NOT
100667: IFFALSE 100671
// continue ;
100669: GO 100466
// HackLink ( i , tmp ) ;
100671: LD_VAR 0 1
100675: PPUSH
100676: LD_VAR 0 2
100680: PPUSH
100681: CALL 100828 0 2
// end ;
100685: GO 100466
100687: POP
100688: POP
// end ;
100689: PPOPN 2
100691: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100692: LD_INT 0
100694: PPUSH
100695: PPUSH
100696: PPUSH
// if not hack in hackTanks then
100697: LD_VAR 0 1
100701: PUSH
100702: LD_EXP 174
100706: IN
100707: NOT
100708: IFFALSE 100712
// exit ;
100710: GO 100823
// index := GetElementIndex ( hackTanks , hack ) ;
100712: LD_ADDR_VAR 0 4
100716: PUSH
100717: LD_EXP 174
100721: PPUSH
100722: LD_VAR 0 1
100726: PPUSH
100727: CALL 18382 0 2
100731: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100732: LD_EXP 175
100736: PUSH
100737: LD_VAR 0 4
100741: ARRAY
100742: IFFALSE 100823
// begin for i in hackTanksCaptured [ index ] do
100744: LD_ADDR_VAR 0 3
100748: PUSH
100749: LD_EXP 175
100753: PUSH
100754: LD_VAR 0 4
100758: ARRAY
100759: PUSH
100760: FOR_IN
100761: IFFALSE 100787
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100763: LD_VAR 0 3
100767: PUSH
100768: LD_INT 1
100770: ARRAY
100771: PPUSH
100772: LD_VAR 0 3
100776: PUSH
100777: LD_INT 2
100779: ARRAY
100780: PPUSH
100781: CALL_OW 235
100785: GO 100760
100787: POP
100788: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100789: LD_ADDR_EXP 175
100793: PUSH
100794: LD_EXP 175
100798: PPUSH
100799: LD_VAR 0 4
100803: PPUSH
100804: EMPTY
100805: PPUSH
100806: CALL_OW 1
100810: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100811: LD_VAR 0 1
100815: PPUSH
100816: LD_INT 0
100818: PPUSH
100819: CALL_OW 505
// end ; end ;
100823: LD_VAR 0 2
100827: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100828: LD_INT 0
100830: PPUSH
100831: PPUSH
100832: PPUSH
// if not hack in hackTanks or not vehicles then
100833: LD_VAR 0 1
100837: PUSH
100838: LD_EXP 174
100842: IN
100843: NOT
100844: PUSH
100845: LD_VAR 0 2
100849: NOT
100850: OR
100851: IFFALSE 100855
// exit ;
100853: GO 101130
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100855: LD_ADDR_VAR 0 2
100859: PUSH
100860: LD_VAR 0 1
100864: PPUSH
100865: LD_VAR 0 2
100869: PPUSH
100870: LD_INT 1
100872: PPUSH
100873: LD_INT 1
100875: PPUSH
100876: CALL 19032 0 4
100880: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100881: LD_ADDR_VAR 0 5
100885: PUSH
100886: LD_EXP 174
100890: PPUSH
100891: LD_VAR 0 1
100895: PPUSH
100896: CALL 18382 0 2
100900: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100901: LD_EXP 175
100905: PUSH
100906: LD_VAR 0 5
100910: ARRAY
100911: PUSH
100912: LD_EXP 176
100916: LESS
100917: IFFALSE 101106
// begin for i := 1 to vehicles do
100919: LD_ADDR_VAR 0 4
100923: PUSH
100924: DOUBLE
100925: LD_INT 1
100927: DEC
100928: ST_TO_ADDR
100929: LD_VAR 0 2
100933: PUSH
100934: FOR_TO
100935: IFFALSE 101104
// begin if hackTanksCaptured [ index ] = hackLimit then
100937: LD_EXP 175
100941: PUSH
100942: LD_VAR 0 5
100946: ARRAY
100947: PUSH
100948: LD_EXP 176
100952: EQUAL
100953: IFFALSE 100957
// break ;
100955: GO 101104
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100957: LD_ADDR_EXP 178
100961: PUSH
100962: LD_EXP 178
100966: PPUSH
100967: LD_VAR 0 5
100971: PPUSH
100972: LD_EXP 178
100976: PUSH
100977: LD_VAR 0 5
100981: ARRAY
100982: PUSH
100983: LD_INT 1
100985: PLUS
100986: PPUSH
100987: CALL_OW 1
100991: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100992: LD_ADDR_EXP 175
100996: PUSH
100997: LD_EXP 175
101001: PPUSH
101002: LD_VAR 0 5
101006: PUSH
101007: LD_EXP 175
101011: PUSH
101012: LD_VAR 0 5
101016: ARRAY
101017: PUSH
101018: LD_INT 1
101020: PLUS
101021: PUSH
101022: EMPTY
101023: LIST
101024: LIST
101025: PPUSH
101026: LD_VAR 0 2
101030: PUSH
101031: LD_VAR 0 4
101035: ARRAY
101036: PUSH
101037: LD_VAR 0 2
101041: PUSH
101042: LD_VAR 0 4
101046: ARRAY
101047: PPUSH
101048: CALL_OW 255
101052: PUSH
101053: EMPTY
101054: LIST
101055: LIST
101056: PPUSH
101057: CALL 18597 0 3
101061: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
101062: LD_VAR 0 2
101066: PUSH
101067: LD_VAR 0 4
101071: ARRAY
101072: PPUSH
101073: LD_VAR 0 1
101077: PPUSH
101078: CALL_OW 255
101082: PPUSH
101083: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
101087: LD_VAR 0 2
101091: PUSH
101092: LD_VAR 0 4
101096: ARRAY
101097: PPUSH
101098: CALL_OW 141
// end ;
101102: GO 100934
101104: POP
101105: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101106: LD_VAR 0 1
101110: PPUSH
101111: LD_EXP 175
101115: PUSH
101116: LD_VAR 0 5
101120: ARRAY
101121: PUSH
101122: LD_INT 0
101124: PLUS
101125: PPUSH
101126: CALL_OW 505
// end ;
101130: LD_VAR 0 3
101134: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
101135: LD_INT 0
101137: PPUSH
101138: PPUSH
101139: PPUSH
101140: PPUSH
// if not hack in hackTanks then
101141: LD_VAR 0 1
101145: PUSH
101146: LD_EXP 174
101150: IN
101151: NOT
101152: IFFALSE 101156
// exit ;
101154: GO 101396
// index := GetElementIndex ( hackTanks , hack ) ;
101156: LD_ADDR_VAR 0 4
101160: PUSH
101161: LD_EXP 174
101165: PPUSH
101166: LD_VAR 0 1
101170: PPUSH
101171: CALL 18382 0 2
101175: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
101176: LD_ADDR_VAR 0 3
101180: PUSH
101181: DOUBLE
101182: LD_EXP 175
101186: PUSH
101187: LD_VAR 0 4
101191: ARRAY
101192: INC
101193: ST_TO_ADDR
101194: LD_INT 1
101196: PUSH
101197: FOR_DOWNTO
101198: IFFALSE 101370
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
101200: LD_ADDR_VAR 0 5
101204: PUSH
101205: LD_EXP 175
101209: PUSH
101210: LD_VAR 0 4
101214: ARRAY
101215: PUSH
101216: LD_VAR 0 3
101220: ARRAY
101221: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
101222: LD_VAR 0 5
101226: PUSH
101227: LD_INT 1
101229: ARRAY
101230: PPUSH
101231: CALL_OW 302
101235: NOT
101236: PUSH
101237: LD_VAR 0 5
101241: PUSH
101242: LD_INT 1
101244: ARRAY
101245: PPUSH
101246: CALL_OW 255
101250: PUSH
101251: LD_VAR 0 1
101255: PPUSH
101256: CALL_OW 255
101260: NONEQUAL
101261: OR
101262: IFFALSE 101368
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
101264: LD_VAR 0 5
101268: PUSH
101269: LD_INT 1
101271: ARRAY
101272: PPUSH
101273: CALL_OW 305
101277: PUSH
101278: LD_VAR 0 5
101282: PUSH
101283: LD_INT 1
101285: ARRAY
101286: PPUSH
101287: CALL_OW 255
101291: PUSH
101292: LD_VAR 0 1
101296: PPUSH
101297: CALL_OW 255
101301: EQUAL
101302: AND
101303: IFFALSE 101327
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
101305: LD_VAR 0 5
101309: PUSH
101310: LD_INT 1
101312: ARRAY
101313: PPUSH
101314: LD_VAR 0 5
101318: PUSH
101319: LD_INT 2
101321: ARRAY
101322: PPUSH
101323: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
101327: LD_ADDR_EXP 175
101331: PUSH
101332: LD_EXP 175
101336: PPUSH
101337: LD_VAR 0 4
101341: PPUSH
101342: LD_EXP 175
101346: PUSH
101347: LD_VAR 0 4
101351: ARRAY
101352: PPUSH
101353: LD_VAR 0 3
101357: PPUSH
101358: CALL_OW 3
101362: PPUSH
101363: CALL_OW 1
101367: ST_TO_ADDR
// end ; end ;
101368: GO 101197
101370: POP
101371: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101372: LD_VAR 0 1
101376: PPUSH
101377: LD_EXP 175
101381: PUSH
101382: LD_VAR 0 4
101386: ARRAY
101387: PUSH
101388: LD_INT 0
101390: PLUS
101391: PPUSH
101392: CALL_OW 505
// end ;
101396: LD_VAR 0 2
101400: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
101401: LD_INT 0
101403: PPUSH
101404: PPUSH
101405: PPUSH
101406: PPUSH
// if not hack in hackTanks then
101407: LD_VAR 0 1
101411: PUSH
101412: LD_EXP 174
101416: IN
101417: NOT
101418: IFFALSE 101422
// exit ;
101420: GO 101507
// index := GetElementIndex ( hackTanks , hack ) ;
101422: LD_ADDR_VAR 0 5
101426: PUSH
101427: LD_EXP 174
101431: PPUSH
101432: LD_VAR 0 1
101436: PPUSH
101437: CALL 18382 0 2
101441: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101442: LD_ADDR_VAR 0 4
101446: PUSH
101447: DOUBLE
101448: LD_INT 1
101450: DEC
101451: ST_TO_ADDR
101452: LD_EXP 175
101456: PUSH
101457: LD_VAR 0 5
101461: ARRAY
101462: PUSH
101463: FOR_TO
101464: IFFALSE 101505
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101466: LD_EXP 175
101470: PUSH
101471: LD_VAR 0 5
101475: ARRAY
101476: PUSH
101477: LD_VAR 0 4
101481: ARRAY
101482: PUSH
101483: LD_INT 1
101485: ARRAY
101486: PUSH
101487: LD_VAR 0 2
101491: EQUAL
101492: IFFALSE 101503
// KillUnit ( vehicle ) ;
101494: LD_VAR 0 2
101498: PPUSH
101499: CALL_OW 66
101503: GO 101463
101505: POP
101506: POP
// end ;
101507: LD_VAR 0 3
101511: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
101512: LD_EXP 179
101516: NOT
101517: IFFALSE 101552
101519: GO 101521
101521: DISABLE
// begin initMiner := true ;
101522: LD_ADDR_EXP 179
101526: PUSH
101527: LD_INT 1
101529: ST_TO_ADDR
// minersList := [ ] ;
101530: LD_ADDR_EXP 180
101534: PUSH
101535: EMPTY
101536: ST_TO_ADDR
// minerMinesList := [ ] ;
101537: LD_ADDR_EXP 181
101541: PUSH
101542: EMPTY
101543: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
101544: LD_ADDR_EXP 182
101548: PUSH
101549: LD_INT 5
101551: ST_TO_ADDR
// end ;
101552: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
101553: LD_EXP 179
101557: PUSH
101558: LD_INT 34
101560: PUSH
101561: LD_EXP 55
101565: PUSH
101566: EMPTY
101567: LIST
101568: LIST
101569: PPUSH
101570: CALL_OW 69
101574: AND
101575: IFFALSE 102038
101577: GO 101579
101579: DISABLE
101580: LD_INT 0
101582: PPUSH
101583: PPUSH
101584: PPUSH
101585: PPUSH
// begin enable ;
101586: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
101587: LD_ADDR_VAR 0 1
101591: PUSH
101592: LD_INT 34
101594: PUSH
101595: LD_EXP 55
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: PPUSH
101604: CALL_OW 69
101608: PUSH
101609: FOR_IN
101610: IFFALSE 101682
// begin if not i in minersList then
101612: LD_VAR 0 1
101616: PUSH
101617: LD_EXP 180
101621: IN
101622: NOT
101623: IFFALSE 101680
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
101625: LD_ADDR_EXP 180
101629: PUSH
101630: LD_EXP 180
101634: PPUSH
101635: LD_EXP 180
101639: PUSH
101640: LD_INT 1
101642: PLUS
101643: PPUSH
101644: LD_VAR 0 1
101648: PPUSH
101649: CALL_OW 1
101653: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
101654: LD_ADDR_EXP 181
101658: PUSH
101659: LD_EXP 181
101663: PPUSH
101664: LD_EXP 181
101668: PUSH
101669: LD_INT 1
101671: PLUS
101672: PPUSH
101673: EMPTY
101674: PPUSH
101675: CALL_OW 1
101679: ST_TO_ADDR
// end end ;
101680: GO 101609
101682: POP
101683: POP
// for i := minerMinesList downto 1 do
101684: LD_ADDR_VAR 0 1
101688: PUSH
101689: DOUBLE
101690: LD_EXP 181
101694: INC
101695: ST_TO_ADDR
101696: LD_INT 1
101698: PUSH
101699: FOR_DOWNTO
101700: IFFALSE 102036
// begin if IsLive ( minersList [ i ] ) then
101702: LD_EXP 180
101706: PUSH
101707: LD_VAR 0 1
101711: ARRAY
101712: PPUSH
101713: CALL_OW 300
101717: IFFALSE 101745
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
101719: LD_EXP 180
101723: PUSH
101724: LD_VAR 0 1
101728: ARRAY
101729: PPUSH
101730: LD_EXP 181
101734: PUSH
101735: LD_VAR 0 1
101739: ARRAY
101740: PPUSH
101741: CALL_OW 505
// if not minerMinesList [ i ] then
101745: LD_EXP 181
101749: PUSH
101750: LD_VAR 0 1
101754: ARRAY
101755: NOT
101756: IFFALSE 101760
// continue ;
101758: GO 101699
// for j := minerMinesList [ i ] downto 1 do
101760: LD_ADDR_VAR 0 2
101764: PUSH
101765: DOUBLE
101766: LD_EXP 181
101770: PUSH
101771: LD_VAR 0 1
101775: ARRAY
101776: INC
101777: ST_TO_ADDR
101778: LD_INT 1
101780: PUSH
101781: FOR_DOWNTO
101782: IFFALSE 102032
// begin side := GetSide ( minersList [ i ] ) ;
101784: LD_ADDR_VAR 0 3
101788: PUSH
101789: LD_EXP 180
101793: PUSH
101794: LD_VAR 0 1
101798: ARRAY
101799: PPUSH
101800: CALL_OW 255
101804: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
101805: LD_ADDR_VAR 0 4
101809: PUSH
101810: LD_EXP 181
101814: PUSH
101815: LD_VAR 0 1
101819: ARRAY
101820: PUSH
101821: LD_VAR 0 2
101825: ARRAY
101826: PUSH
101827: LD_INT 1
101829: ARRAY
101830: PPUSH
101831: LD_EXP 181
101835: PUSH
101836: LD_VAR 0 1
101840: ARRAY
101841: PUSH
101842: LD_VAR 0 2
101846: ARRAY
101847: PUSH
101848: LD_INT 2
101850: ARRAY
101851: PPUSH
101852: CALL_OW 428
101856: ST_TO_ADDR
// if not tmp then
101857: LD_VAR 0 4
101861: NOT
101862: IFFALSE 101866
// continue ;
101864: GO 101781
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
101866: LD_VAR 0 4
101870: PUSH
101871: LD_INT 81
101873: PUSH
101874: LD_VAR 0 3
101878: PUSH
101879: EMPTY
101880: LIST
101881: LIST
101882: PPUSH
101883: CALL_OW 69
101887: IN
101888: PUSH
101889: LD_EXP 181
101893: PUSH
101894: LD_VAR 0 1
101898: ARRAY
101899: PUSH
101900: LD_VAR 0 2
101904: ARRAY
101905: PUSH
101906: LD_INT 1
101908: ARRAY
101909: PPUSH
101910: LD_EXP 181
101914: PUSH
101915: LD_VAR 0 1
101919: ARRAY
101920: PUSH
101921: LD_VAR 0 2
101925: ARRAY
101926: PUSH
101927: LD_INT 2
101929: ARRAY
101930: PPUSH
101931: CALL_OW 458
101935: AND
101936: IFFALSE 102030
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
101938: LD_EXP 181
101942: PUSH
101943: LD_VAR 0 1
101947: ARRAY
101948: PUSH
101949: LD_VAR 0 2
101953: ARRAY
101954: PUSH
101955: LD_INT 1
101957: ARRAY
101958: PPUSH
101959: LD_EXP 181
101963: PUSH
101964: LD_VAR 0 1
101968: ARRAY
101969: PUSH
101970: LD_VAR 0 2
101974: ARRAY
101975: PUSH
101976: LD_INT 2
101978: ARRAY
101979: PPUSH
101980: LD_VAR 0 3
101984: PPUSH
101985: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
101989: LD_ADDR_EXP 181
101993: PUSH
101994: LD_EXP 181
101998: PPUSH
101999: LD_VAR 0 1
102003: PPUSH
102004: LD_EXP 181
102008: PUSH
102009: LD_VAR 0 1
102013: ARRAY
102014: PPUSH
102015: LD_VAR 0 2
102019: PPUSH
102020: CALL_OW 3
102024: PPUSH
102025: CALL_OW 1
102029: ST_TO_ADDR
// end ; end ;
102030: GO 101781
102032: POP
102033: POP
// end ;
102034: GO 101699
102036: POP
102037: POP
// end ;
102038: PPOPN 4
102040: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
102041: LD_INT 0
102043: PPUSH
102044: PPUSH
// result := false ;
102045: LD_ADDR_VAR 0 4
102049: PUSH
102050: LD_INT 0
102052: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
102053: LD_VAR 0 1
102057: PPUSH
102058: CALL_OW 264
102062: PUSH
102063: LD_EXP 55
102067: EQUAL
102068: NOT
102069: IFFALSE 102073
// exit ;
102071: GO 102313
// index := GetElementIndex ( minersList , unit ) ;
102073: LD_ADDR_VAR 0 5
102077: PUSH
102078: LD_EXP 180
102082: PPUSH
102083: LD_VAR 0 1
102087: PPUSH
102088: CALL 18382 0 2
102092: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
102093: LD_EXP 181
102097: PUSH
102098: LD_VAR 0 5
102102: ARRAY
102103: PUSH
102104: LD_EXP 182
102108: GREATEREQUAL
102109: IFFALSE 102113
// exit ;
102111: GO 102313
// ComMoveXY ( unit , x , y ) ;
102113: LD_VAR 0 1
102117: PPUSH
102118: LD_VAR 0 2
102122: PPUSH
102123: LD_VAR 0 3
102127: PPUSH
102128: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102132: LD_INT 35
102134: PPUSH
102135: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
102139: LD_VAR 0 1
102143: PPUSH
102144: LD_VAR 0 2
102148: PPUSH
102149: LD_VAR 0 3
102153: PPUSH
102154: CALL 49101 0 3
102158: NOT
102159: PUSH
102160: LD_VAR 0 1
102164: PPUSH
102165: CALL_OW 314
102169: AND
102170: IFFALSE 102174
// exit ;
102172: GO 102313
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
102174: LD_VAR 0 2
102178: PPUSH
102179: LD_VAR 0 3
102183: PPUSH
102184: CALL_OW 428
102188: PUSH
102189: LD_VAR 0 1
102193: EQUAL
102194: PUSH
102195: LD_VAR 0 1
102199: PPUSH
102200: CALL_OW 314
102204: NOT
102205: AND
102206: IFFALSE 102132
// PlaySoundXY ( x , y , PlantMine ) ;
102208: LD_VAR 0 2
102212: PPUSH
102213: LD_VAR 0 3
102217: PPUSH
102218: LD_STRING PlantMine
102220: PPUSH
102221: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
102225: LD_VAR 0 2
102229: PPUSH
102230: LD_VAR 0 3
102234: PPUSH
102235: LD_VAR 0 1
102239: PPUSH
102240: CALL_OW 255
102244: PPUSH
102245: LD_INT 0
102247: PPUSH
102248: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
102252: LD_ADDR_EXP 181
102256: PUSH
102257: LD_EXP 181
102261: PPUSH
102262: LD_VAR 0 5
102266: PUSH
102267: LD_EXP 181
102271: PUSH
102272: LD_VAR 0 5
102276: ARRAY
102277: PUSH
102278: LD_INT 1
102280: PLUS
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: PPUSH
102286: LD_VAR 0 2
102290: PUSH
102291: LD_VAR 0 3
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: PPUSH
102300: CALL 18597 0 3
102304: ST_TO_ADDR
// result := true ;
102305: LD_ADDR_VAR 0 4
102309: PUSH
102310: LD_INT 1
102312: ST_TO_ADDR
// end ;
102313: LD_VAR 0 4
102317: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
102318: LD_INT 0
102320: PPUSH
102321: PPUSH
102322: PPUSH
// if not unit in minersList then
102323: LD_VAR 0 1
102327: PUSH
102328: LD_EXP 180
102332: IN
102333: NOT
102334: IFFALSE 102338
// exit ;
102336: GO 102730
// index := GetElementIndex ( minersList , unit ) ;
102338: LD_ADDR_VAR 0 6
102342: PUSH
102343: LD_EXP 180
102347: PPUSH
102348: LD_VAR 0 1
102352: PPUSH
102353: CALL 18382 0 2
102357: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
102358: LD_ADDR_VAR 0 5
102362: PUSH
102363: DOUBLE
102364: LD_EXP 181
102368: PUSH
102369: LD_VAR 0 6
102373: ARRAY
102374: INC
102375: ST_TO_ADDR
102376: LD_INT 1
102378: PUSH
102379: FOR_DOWNTO
102380: IFFALSE 102541
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
102382: LD_EXP 181
102386: PUSH
102387: LD_VAR 0 6
102391: ARRAY
102392: PUSH
102393: LD_VAR 0 5
102397: ARRAY
102398: PUSH
102399: LD_INT 1
102401: ARRAY
102402: PUSH
102403: LD_VAR 0 2
102407: EQUAL
102408: PUSH
102409: LD_EXP 181
102413: PUSH
102414: LD_VAR 0 6
102418: ARRAY
102419: PUSH
102420: LD_VAR 0 5
102424: ARRAY
102425: PUSH
102426: LD_INT 2
102428: ARRAY
102429: PUSH
102430: LD_VAR 0 3
102434: EQUAL
102435: AND
102436: IFFALSE 102539
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102438: LD_EXP 181
102442: PUSH
102443: LD_VAR 0 6
102447: ARRAY
102448: PUSH
102449: LD_VAR 0 5
102453: ARRAY
102454: PUSH
102455: LD_INT 1
102457: ARRAY
102458: PPUSH
102459: LD_EXP 181
102463: PUSH
102464: LD_VAR 0 6
102468: ARRAY
102469: PUSH
102470: LD_VAR 0 5
102474: ARRAY
102475: PUSH
102476: LD_INT 2
102478: ARRAY
102479: PPUSH
102480: LD_VAR 0 1
102484: PPUSH
102485: CALL_OW 255
102489: PPUSH
102490: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102494: LD_ADDR_EXP 181
102498: PUSH
102499: LD_EXP 181
102503: PPUSH
102504: LD_VAR 0 6
102508: PPUSH
102509: LD_EXP 181
102513: PUSH
102514: LD_VAR 0 6
102518: ARRAY
102519: PPUSH
102520: LD_VAR 0 5
102524: PPUSH
102525: CALL_OW 3
102529: PPUSH
102530: CALL_OW 1
102534: ST_TO_ADDR
// exit ;
102535: POP
102536: POP
102537: GO 102730
// end ; end ;
102539: GO 102379
102541: POP
102542: POP
// for i := minerMinesList [ index ] downto 1 do
102543: LD_ADDR_VAR 0 5
102547: PUSH
102548: DOUBLE
102549: LD_EXP 181
102553: PUSH
102554: LD_VAR 0 6
102558: ARRAY
102559: INC
102560: ST_TO_ADDR
102561: LD_INT 1
102563: PUSH
102564: FOR_DOWNTO
102565: IFFALSE 102728
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
102567: LD_EXP 181
102571: PUSH
102572: LD_VAR 0 6
102576: ARRAY
102577: PUSH
102578: LD_VAR 0 5
102582: ARRAY
102583: PUSH
102584: LD_INT 1
102586: ARRAY
102587: PPUSH
102588: LD_EXP 181
102592: PUSH
102593: LD_VAR 0 6
102597: ARRAY
102598: PUSH
102599: LD_VAR 0 5
102603: ARRAY
102604: PUSH
102605: LD_INT 2
102607: ARRAY
102608: PPUSH
102609: LD_VAR 0 2
102613: PPUSH
102614: LD_VAR 0 3
102618: PPUSH
102619: CALL_OW 298
102623: PUSH
102624: LD_INT 6
102626: LESS
102627: IFFALSE 102726
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102629: LD_EXP 181
102633: PUSH
102634: LD_VAR 0 6
102638: ARRAY
102639: PUSH
102640: LD_VAR 0 5
102644: ARRAY
102645: PUSH
102646: LD_INT 1
102648: ARRAY
102649: PPUSH
102650: LD_EXP 181
102654: PUSH
102655: LD_VAR 0 6
102659: ARRAY
102660: PUSH
102661: LD_VAR 0 5
102665: ARRAY
102666: PUSH
102667: LD_INT 2
102669: ARRAY
102670: PPUSH
102671: LD_VAR 0 1
102675: PPUSH
102676: CALL_OW 255
102680: PPUSH
102681: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102685: LD_ADDR_EXP 181
102689: PUSH
102690: LD_EXP 181
102694: PPUSH
102695: LD_VAR 0 6
102699: PPUSH
102700: LD_EXP 181
102704: PUSH
102705: LD_VAR 0 6
102709: ARRAY
102710: PPUSH
102711: LD_VAR 0 5
102715: PPUSH
102716: CALL_OW 3
102720: PPUSH
102721: CALL_OW 1
102725: ST_TO_ADDR
// end ; end ;
102726: GO 102564
102728: POP
102729: POP
// end ;
102730: LD_VAR 0 4
102734: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
102735: LD_INT 0
102737: PPUSH
102738: PPUSH
102739: PPUSH
102740: PPUSH
102741: PPUSH
102742: PPUSH
102743: PPUSH
102744: PPUSH
102745: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
102746: LD_VAR 0 1
102750: PPUSH
102751: CALL_OW 264
102755: PUSH
102756: LD_EXP 55
102760: EQUAL
102761: NOT
102762: PUSH
102763: LD_VAR 0 1
102767: PUSH
102768: LD_EXP 180
102772: IN
102773: NOT
102774: OR
102775: IFFALSE 102779
// exit ;
102777: GO 103101
// index := GetElementIndex ( minersList , unit ) ;
102779: LD_ADDR_VAR 0 6
102783: PUSH
102784: LD_EXP 180
102788: PPUSH
102789: LD_VAR 0 1
102793: PPUSH
102794: CALL 18382 0 2
102798: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
102799: LD_ADDR_VAR 0 8
102803: PUSH
102804: LD_EXP 182
102808: PUSH
102809: LD_EXP 181
102813: PUSH
102814: LD_VAR 0 6
102818: ARRAY
102819: MINUS
102820: ST_TO_ADDR
// if not minesFreeAmount then
102821: LD_VAR 0 8
102825: NOT
102826: IFFALSE 102830
// exit ;
102828: GO 103101
// tmp := [ ] ;
102830: LD_ADDR_VAR 0 7
102834: PUSH
102835: EMPTY
102836: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
102837: LD_ADDR_VAR 0 5
102841: PUSH
102842: DOUBLE
102843: LD_INT 1
102845: DEC
102846: ST_TO_ADDR
102847: LD_VAR 0 8
102851: PUSH
102852: FOR_TO
102853: IFFALSE 103048
// begin _d := rand ( 0 , 5 ) ;
102855: LD_ADDR_VAR 0 11
102859: PUSH
102860: LD_INT 0
102862: PPUSH
102863: LD_INT 5
102865: PPUSH
102866: CALL_OW 12
102870: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
102871: LD_ADDR_VAR 0 12
102875: PUSH
102876: LD_INT 2
102878: PPUSH
102879: LD_INT 6
102881: PPUSH
102882: CALL_OW 12
102886: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
102887: LD_ADDR_VAR 0 9
102891: PUSH
102892: LD_VAR 0 2
102896: PPUSH
102897: LD_VAR 0 11
102901: PPUSH
102902: LD_VAR 0 12
102906: PPUSH
102907: CALL_OW 272
102911: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
102912: LD_ADDR_VAR 0 10
102916: PUSH
102917: LD_VAR 0 3
102921: PPUSH
102922: LD_VAR 0 11
102926: PPUSH
102927: LD_VAR 0 12
102931: PPUSH
102932: CALL_OW 273
102936: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
102937: LD_VAR 0 9
102941: PPUSH
102942: LD_VAR 0 10
102946: PPUSH
102947: CALL_OW 488
102951: PUSH
102952: LD_VAR 0 9
102956: PUSH
102957: LD_VAR 0 10
102961: PUSH
102962: EMPTY
102963: LIST
102964: LIST
102965: PUSH
102966: LD_VAR 0 7
102970: IN
102971: NOT
102972: AND
102973: PUSH
102974: LD_VAR 0 9
102978: PPUSH
102979: LD_VAR 0 10
102983: PPUSH
102984: CALL_OW 458
102988: NOT
102989: AND
102990: IFFALSE 103032
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
102992: LD_ADDR_VAR 0 7
102996: PUSH
102997: LD_VAR 0 7
103001: PPUSH
103002: LD_VAR 0 7
103006: PUSH
103007: LD_INT 1
103009: PLUS
103010: PPUSH
103011: LD_VAR 0 9
103015: PUSH
103016: LD_VAR 0 10
103020: PUSH
103021: EMPTY
103022: LIST
103023: LIST
103024: PPUSH
103025: CALL_OW 1
103029: ST_TO_ADDR
103030: GO 103046
// i := i - 1 ;
103032: LD_ADDR_VAR 0 5
103036: PUSH
103037: LD_VAR 0 5
103041: PUSH
103042: LD_INT 1
103044: MINUS
103045: ST_TO_ADDR
// end ;
103046: GO 102852
103048: POP
103049: POP
// for i in tmp do
103050: LD_ADDR_VAR 0 5
103054: PUSH
103055: LD_VAR 0 7
103059: PUSH
103060: FOR_IN
103061: IFFALSE 103099
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
103063: LD_VAR 0 1
103067: PPUSH
103068: LD_VAR 0 5
103072: PUSH
103073: LD_INT 1
103075: ARRAY
103076: PPUSH
103077: LD_VAR 0 5
103081: PUSH
103082: LD_INT 2
103084: ARRAY
103085: PPUSH
103086: CALL 102041 0 3
103090: NOT
103091: IFFALSE 103097
// exit ;
103093: POP
103094: POP
103095: GO 103101
103097: GO 103060
103099: POP
103100: POP
// end ;
103101: LD_VAR 0 4
103105: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
103106: LD_INT 0
103108: PPUSH
103109: PPUSH
103110: PPUSH
103111: PPUSH
103112: PPUSH
103113: PPUSH
103114: PPUSH
// if not GetClass ( unit ) = class_sniper then
103115: LD_VAR 0 1
103119: PPUSH
103120: CALL_OW 257
103124: PUSH
103125: LD_INT 5
103127: EQUAL
103128: NOT
103129: IFFALSE 103133
// exit ;
103131: GO 103521
// dist := 8 ;
103133: LD_ADDR_VAR 0 5
103137: PUSH
103138: LD_INT 8
103140: ST_TO_ADDR
// viewRange := 12 ;
103141: LD_ADDR_VAR 0 7
103145: PUSH
103146: LD_INT 12
103148: ST_TO_ADDR
// side := GetSide ( unit ) ;
103149: LD_ADDR_VAR 0 6
103153: PUSH
103154: LD_VAR 0 1
103158: PPUSH
103159: CALL_OW 255
103163: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
103164: LD_INT 61
103166: PPUSH
103167: LD_VAR 0 6
103171: PPUSH
103172: CALL_OW 321
103176: PUSH
103177: LD_INT 2
103179: EQUAL
103180: IFFALSE 103190
// viewRange := 16 ;
103182: LD_ADDR_VAR 0 7
103186: PUSH
103187: LD_INT 16
103189: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
103190: LD_VAR 0 1
103194: PPUSH
103195: LD_VAR 0 2
103199: PPUSH
103200: LD_VAR 0 3
103204: PPUSH
103205: CALL_OW 297
103209: PUSH
103210: LD_VAR 0 5
103214: GREATER
103215: IFFALSE 103294
// begin ComMoveXY ( unit , x , y ) ;
103217: LD_VAR 0 1
103221: PPUSH
103222: LD_VAR 0 2
103226: PPUSH
103227: LD_VAR 0 3
103231: PPUSH
103232: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103236: LD_INT 35
103238: PPUSH
103239: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
103243: LD_VAR 0 1
103247: PPUSH
103248: LD_VAR 0 2
103252: PPUSH
103253: LD_VAR 0 3
103257: PPUSH
103258: CALL 49101 0 3
103262: NOT
103263: IFFALSE 103267
// exit ;
103265: GO 103521
// until GetDistUnitXY ( unit , x , y ) < dist ;
103267: LD_VAR 0 1
103271: PPUSH
103272: LD_VAR 0 2
103276: PPUSH
103277: LD_VAR 0 3
103281: PPUSH
103282: CALL_OW 297
103286: PUSH
103287: LD_VAR 0 5
103291: LESS
103292: IFFALSE 103236
// end ; ComTurnXY ( unit , x , y ) ;
103294: LD_VAR 0 1
103298: PPUSH
103299: LD_VAR 0 2
103303: PPUSH
103304: LD_VAR 0 3
103308: PPUSH
103309: CALL_OW 118
// wait ( 5 ) ;
103313: LD_INT 5
103315: PPUSH
103316: CALL_OW 67
// _d := GetDir ( unit ) ;
103320: LD_ADDR_VAR 0 10
103324: PUSH
103325: LD_VAR 0 1
103329: PPUSH
103330: CALL_OW 254
103334: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
103335: LD_ADDR_VAR 0 8
103339: PUSH
103340: LD_VAR 0 1
103344: PPUSH
103345: CALL_OW 250
103349: PPUSH
103350: LD_VAR 0 10
103354: PPUSH
103355: LD_VAR 0 5
103359: PPUSH
103360: CALL_OW 272
103364: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
103365: LD_ADDR_VAR 0 9
103369: PUSH
103370: LD_VAR 0 1
103374: PPUSH
103375: CALL_OW 251
103379: PPUSH
103380: LD_VAR 0 10
103384: PPUSH
103385: LD_VAR 0 5
103389: PPUSH
103390: CALL_OW 273
103394: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
103395: LD_VAR 0 8
103399: PPUSH
103400: LD_VAR 0 9
103404: PPUSH
103405: CALL_OW 488
103409: NOT
103410: IFFALSE 103414
// exit ;
103412: GO 103521
// ComAnimCustom ( unit , 1 ) ;
103414: LD_VAR 0 1
103418: PPUSH
103419: LD_INT 1
103421: PPUSH
103422: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
103426: LD_VAR 0 8
103430: PPUSH
103431: LD_VAR 0 9
103435: PPUSH
103436: LD_VAR 0 6
103440: PPUSH
103441: LD_VAR 0 7
103445: PPUSH
103446: CALL_OW 330
// repeat wait ( 1 ) ;
103450: LD_INT 1
103452: PPUSH
103453: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
103457: LD_VAR 0 1
103461: PPUSH
103462: CALL_OW 316
103466: PUSH
103467: LD_VAR 0 1
103471: PPUSH
103472: CALL_OW 314
103476: OR
103477: PUSH
103478: LD_VAR 0 1
103482: PPUSH
103483: CALL_OW 302
103487: NOT
103488: OR
103489: PUSH
103490: LD_VAR 0 1
103494: PPUSH
103495: CALL_OW 301
103499: OR
103500: IFFALSE 103450
// RemoveSeeing ( _x , _y , side ) ;
103502: LD_VAR 0 8
103506: PPUSH
103507: LD_VAR 0 9
103511: PPUSH
103512: LD_VAR 0 6
103516: PPUSH
103517: CALL_OW 331
// end ; end_of_file
103521: LD_VAR 0 4
103525: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
103526: LD_INT 0
103528: PPUSH
103529: PPUSH
103530: PPUSH
103531: PPUSH
103532: PPUSH
103533: PPUSH
103534: PPUSH
103535: PPUSH
103536: PPUSH
103537: PPUSH
103538: PPUSH
103539: PPUSH
103540: PPUSH
103541: PPUSH
103542: PPUSH
103543: PPUSH
103544: PPUSH
103545: PPUSH
103546: PPUSH
103547: PPUSH
103548: PPUSH
103549: PPUSH
103550: PPUSH
103551: PPUSH
103552: PPUSH
103553: PPUSH
103554: PPUSH
103555: PPUSH
103556: PPUSH
103557: PPUSH
103558: PPUSH
103559: PPUSH
103560: PPUSH
103561: PPUSH
// if not list then
103562: LD_VAR 0 1
103566: NOT
103567: IFFALSE 103571
// exit ;
103569: GO 108230
// base := list [ 1 ] ;
103571: LD_ADDR_VAR 0 3
103575: PUSH
103576: LD_VAR 0 1
103580: PUSH
103581: LD_INT 1
103583: ARRAY
103584: ST_TO_ADDR
// group := list [ 2 ] ;
103585: LD_ADDR_VAR 0 4
103589: PUSH
103590: LD_VAR 0 1
103594: PUSH
103595: LD_INT 2
103597: ARRAY
103598: ST_TO_ADDR
// path := list [ 3 ] ;
103599: LD_ADDR_VAR 0 5
103603: PUSH
103604: LD_VAR 0 1
103608: PUSH
103609: LD_INT 3
103611: ARRAY
103612: ST_TO_ADDR
// flags := list [ 4 ] ;
103613: LD_ADDR_VAR 0 6
103617: PUSH
103618: LD_VAR 0 1
103622: PUSH
103623: LD_INT 4
103625: ARRAY
103626: ST_TO_ADDR
// mined := [ ] ;
103627: LD_ADDR_VAR 0 27
103631: PUSH
103632: EMPTY
103633: ST_TO_ADDR
// bombed := [ ] ;
103634: LD_ADDR_VAR 0 28
103638: PUSH
103639: EMPTY
103640: ST_TO_ADDR
// healers := [ ] ;
103641: LD_ADDR_VAR 0 31
103645: PUSH
103646: EMPTY
103647: ST_TO_ADDR
// to_heal := [ ] ;
103648: LD_ADDR_VAR 0 30
103652: PUSH
103653: EMPTY
103654: ST_TO_ADDR
// repairs := [ ] ;
103655: LD_ADDR_VAR 0 33
103659: PUSH
103660: EMPTY
103661: ST_TO_ADDR
// to_repair := [ ] ;
103662: LD_ADDR_VAR 0 32
103666: PUSH
103667: EMPTY
103668: ST_TO_ADDR
// if not group or not path then
103669: LD_VAR 0 4
103673: NOT
103674: PUSH
103675: LD_VAR 0 5
103679: NOT
103680: OR
103681: IFFALSE 103685
// exit ;
103683: GO 108230
// side := GetSide ( group [ 1 ] ) ;
103685: LD_ADDR_VAR 0 35
103689: PUSH
103690: LD_VAR 0 4
103694: PUSH
103695: LD_INT 1
103697: ARRAY
103698: PPUSH
103699: CALL_OW 255
103703: ST_TO_ADDR
// if flags then
103704: LD_VAR 0 6
103708: IFFALSE 103852
// begin f_ignore_area := flags [ 1 ] ;
103710: LD_ADDR_VAR 0 17
103714: PUSH
103715: LD_VAR 0 6
103719: PUSH
103720: LD_INT 1
103722: ARRAY
103723: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
103724: LD_ADDR_VAR 0 18
103728: PUSH
103729: LD_VAR 0 6
103733: PUSH
103734: LD_INT 2
103736: ARRAY
103737: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
103738: LD_ADDR_VAR 0 19
103742: PUSH
103743: LD_VAR 0 6
103747: PUSH
103748: LD_INT 3
103750: ARRAY
103751: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
103752: LD_ADDR_VAR 0 20
103756: PUSH
103757: LD_VAR 0 6
103761: PUSH
103762: LD_INT 4
103764: ARRAY
103765: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
103766: LD_ADDR_VAR 0 21
103770: PUSH
103771: LD_VAR 0 6
103775: PUSH
103776: LD_INT 5
103778: ARRAY
103779: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
103780: LD_ADDR_VAR 0 22
103784: PUSH
103785: LD_VAR 0 6
103789: PUSH
103790: LD_INT 6
103792: ARRAY
103793: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
103794: LD_ADDR_VAR 0 23
103798: PUSH
103799: LD_VAR 0 6
103803: PUSH
103804: LD_INT 7
103806: ARRAY
103807: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
103808: LD_ADDR_VAR 0 24
103812: PUSH
103813: LD_VAR 0 6
103817: PUSH
103818: LD_INT 8
103820: ARRAY
103821: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
103822: LD_ADDR_VAR 0 25
103826: PUSH
103827: LD_VAR 0 6
103831: PUSH
103832: LD_INT 9
103834: ARRAY
103835: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
103836: LD_ADDR_VAR 0 26
103840: PUSH
103841: LD_VAR 0 6
103845: PUSH
103846: LD_INT 10
103848: ARRAY
103849: ST_TO_ADDR
// end else
103850: GO 103932
// begin f_ignore_area := false ;
103852: LD_ADDR_VAR 0 17
103856: PUSH
103857: LD_INT 0
103859: ST_TO_ADDR
// f_capture := false ;
103860: LD_ADDR_VAR 0 18
103864: PUSH
103865: LD_INT 0
103867: ST_TO_ADDR
// f_ignore_civ := false ;
103868: LD_ADDR_VAR 0 19
103872: PUSH
103873: LD_INT 0
103875: ST_TO_ADDR
// f_murder := false ;
103876: LD_ADDR_VAR 0 20
103880: PUSH
103881: LD_INT 0
103883: ST_TO_ADDR
// f_mines := false ;
103884: LD_ADDR_VAR 0 21
103888: PUSH
103889: LD_INT 0
103891: ST_TO_ADDR
// f_repair := false ;
103892: LD_ADDR_VAR 0 22
103896: PUSH
103897: LD_INT 0
103899: ST_TO_ADDR
// f_heal := false ;
103900: LD_ADDR_VAR 0 23
103904: PUSH
103905: LD_INT 0
103907: ST_TO_ADDR
// f_spacetime := false ;
103908: LD_ADDR_VAR 0 24
103912: PUSH
103913: LD_INT 0
103915: ST_TO_ADDR
// f_attack_depot := false ;
103916: LD_ADDR_VAR 0 25
103920: PUSH
103921: LD_INT 0
103923: ST_TO_ADDR
// f_crawl := false ;
103924: LD_ADDR_VAR 0 26
103928: PUSH
103929: LD_INT 0
103931: ST_TO_ADDR
// end ; if f_heal then
103932: LD_VAR 0 23
103936: IFFALSE 103963
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
103938: LD_ADDR_VAR 0 31
103942: PUSH
103943: LD_VAR 0 4
103947: PPUSH
103948: LD_INT 25
103950: PUSH
103951: LD_INT 4
103953: PUSH
103954: EMPTY
103955: LIST
103956: LIST
103957: PPUSH
103958: CALL_OW 72
103962: ST_TO_ADDR
// if f_repair then
103963: LD_VAR 0 22
103967: IFFALSE 103994
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
103969: LD_ADDR_VAR 0 33
103973: PUSH
103974: LD_VAR 0 4
103978: PPUSH
103979: LD_INT 25
103981: PUSH
103982: LD_INT 3
103984: PUSH
103985: EMPTY
103986: LIST
103987: LIST
103988: PPUSH
103989: CALL_OW 72
103993: ST_TO_ADDR
// units_path := [ ] ;
103994: LD_ADDR_VAR 0 16
103998: PUSH
103999: EMPTY
104000: ST_TO_ADDR
// for i = 1 to group do
104001: LD_ADDR_VAR 0 7
104005: PUSH
104006: DOUBLE
104007: LD_INT 1
104009: DEC
104010: ST_TO_ADDR
104011: LD_VAR 0 4
104015: PUSH
104016: FOR_TO
104017: IFFALSE 104046
// units_path := Replace ( units_path , i , path ) ;
104019: LD_ADDR_VAR 0 16
104023: PUSH
104024: LD_VAR 0 16
104028: PPUSH
104029: LD_VAR 0 7
104033: PPUSH
104034: LD_VAR 0 5
104038: PPUSH
104039: CALL_OW 1
104043: ST_TO_ADDR
104044: GO 104016
104046: POP
104047: POP
// repeat for i = group downto 1 do
104048: LD_ADDR_VAR 0 7
104052: PUSH
104053: DOUBLE
104054: LD_VAR 0 4
104058: INC
104059: ST_TO_ADDR
104060: LD_INT 1
104062: PUSH
104063: FOR_DOWNTO
104064: IFFALSE 108186
// begin wait ( 5 ) ;
104066: LD_INT 5
104068: PPUSH
104069: CALL_OW 67
// tmp := [ ] ;
104073: LD_ADDR_VAR 0 14
104077: PUSH
104078: EMPTY
104079: ST_TO_ADDR
// attacking := false ;
104080: LD_ADDR_VAR 0 29
104084: PUSH
104085: LD_INT 0
104087: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
104088: LD_VAR 0 4
104092: PUSH
104093: LD_VAR 0 7
104097: ARRAY
104098: PPUSH
104099: CALL_OW 301
104103: PUSH
104104: LD_VAR 0 4
104108: PUSH
104109: LD_VAR 0 7
104113: ARRAY
104114: NOT
104115: OR
104116: IFFALSE 104225
// begin if GetType ( group [ i ] ) = unit_human then
104118: LD_VAR 0 4
104122: PUSH
104123: LD_VAR 0 7
104127: ARRAY
104128: PPUSH
104129: CALL_OW 247
104133: PUSH
104134: LD_INT 1
104136: EQUAL
104137: IFFALSE 104183
// begin to_heal := to_heal diff group [ i ] ;
104139: LD_ADDR_VAR 0 30
104143: PUSH
104144: LD_VAR 0 30
104148: PUSH
104149: LD_VAR 0 4
104153: PUSH
104154: LD_VAR 0 7
104158: ARRAY
104159: DIFF
104160: ST_TO_ADDR
// healers := healers diff group [ i ] ;
104161: LD_ADDR_VAR 0 31
104165: PUSH
104166: LD_VAR 0 31
104170: PUSH
104171: LD_VAR 0 4
104175: PUSH
104176: LD_VAR 0 7
104180: ARRAY
104181: DIFF
104182: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
104183: LD_ADDR_VAR 0 4
104187: PUSH
104188: LD_VAR 0 4
104192: PPUSH
104193: LD_VAR 0 7
104197: PPUSH
104198: CALL_OW 3
104202: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
104203: LD_ADDR_VAR 0 16
104207: PUSH
104208: LD_VAR 0 16
104212: PPUSH
104213: LD_VAR 0 7
104217: PPUSH
104218: CALL_OW 3
104222: ST_TO_ADDR
// continue ;
104223: GO 104063
// end ; if f_repair then
104225: LD_VAR 0 22
104229: IFFALSE 104718
// begin if GetType ( group [ i ] ) = unit_vehicle then
104231: LD_VAR 0 4
104235: PUSH
104236: LD_VAR 0 7
104240: ARRAY
104241: PPUSH
104242: CALL_OW 247
104246: PUSH
104247: LD_INT 2
104249: EQUAL
104250: IFFALSE 104440
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
104252: LD_VAR 0 4
104256: PUSH
104257: LD_VAR 0 7
104261: ARRAY
104262: PPUSH
104263: CALL_OW 256
104267: PUSH
104268: LD_INT 700
104270: LESS
104271: PUSH
104272: LD_VAR 0 4
104276: PUSH
104277: LD_VAR 0 7
104281: ARRAY
104282: PUSH
104283: LD_VAR 0 32
104287: IN
104288: NOT
104289: AND
104290: IFFALSE 104314
// to_repair := to_repair union group [ i ] ;
104292: LD_ADDR_VAR 0 32
104296: PUSH
104297: LD_VAR 0 32
104301: PUSH
104302: LD_VAR 0 4
104306: PUSH
104307: LD_VAR 0 7
104311: ARRAY
104312: UNION
104313: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
104314: LD_VAR 0 4
104318: PUSH
104319: LD_VAR 0 7
104323: ARRAY
104324: PPUSH
104325: CALL_OW 256
104329: PUSH
104330: LD_INT 1000
104332: EQUAL
104333: PUSH
104334: LD_VAR 0 4
104338: PUSH
104339: LD_VAR 0 7
104343: ARRAY
104344: PUSH
104345: LD_VAR 0 32
104349: IN
104350: AND
104351: IFFALSE 104375
// to_repair := to_repair diff group [ i ] ;
104353: LD_ADDR_VAR 0 32
104357: PUSH
104358: LD_VAR 0 32
104362: PUSH
104363: LD_VAR 0 4
104367: PUSH
104368: LD_VAR 0 7
104372: ARRAY
104373: DIFF
104374: ST_TO_ADDR
// if group [ i ] in to_repair then
104375: LD_VAR 0 4
104379: PUSH
104380: LD_VAR 0 7
104384: ARRAY
104385: PUSH
104386: LD_VAR 0 32
104390: IN
104391: IFFALSE 104438
// begin if not IsInArea ( group [ i ] , f_repair ) then
104393: LD_VAR 0 4
104397: PUSH
104398: LD_VAR 0 7
104402: ARRAY
104403: PPUSH
104404: LD_VAR 0 22
104408: PPUSH
104409: CALL_OW 308
104413: NOT
104414: IFFALSE 104436
// ComMoveToArea ( group [ i ] , f_repair ) ;
104416: LD_VAR 0 4
104420: PUSH
104421: LD_VAR 0 7
104425: ARRAY
104426: PPUSH
104427: LD_VAR 0 22
104431: PPUSH
104432: CALL_OW 113
// continue ;
104436: GO 104063
// end ; end else
104438: GO 104718
// if group [ i ] in repairs then
104440: LD_VAR 0 4
104444: PUSH
104445: LD_VAR 0 7
104449: ARRAY
104450: PUSH
104451: LD_VAR 0 33
104455: IN
104456: IFFALSE 104718
// begin if IsInUnit ( group [ i ] ) then
104458: LD_VAR 0 4
104462: PUSH
104463: LD_VAR 0 7
104467: ARRAY
104468: PPUSH
104469: CALL_OW 310
104473: IFFALSE 104541
// begin z := IsInUnit ( group [ i ] ) ;
104475: LD_ADDR_VAR 0 13
104479: PUSH
104480: LD_VAR 0 4
104484: PUSH
104485: LD_VAR 0 7
104489: ARRAY
104490: PPUSH
104491: CALL_OW 310
104495: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
104496: LD_VAR 0 13
104500: PUSH
104501: LD_VAR 0 32
104505: IN
104506: PUSH
104507: LD_VAR 0 13
104511: PPUSH
104512: LD_VAR 0 22
104516: PPUSH
104517: CALL_OW 308
104521: AND
104522: IFFALSE 104539
// ComExitVehicle ( group [ i ] ) ;
104524: LD_VAR 0 4
104528: PUSH
104529: LD_VAR 0 7
104533: ARRAY
104534: PPUSH
104535: CALL_OW 121
// end else
104539: GO 104718
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
104541: LD_ADDR_VAR 0 13
104545: PUSH
104546: LD_VAR 0 4
104550: PPUSH
104551: LD_INT 95
104553: PUSH
104554: LD_VAR 0 22
104558: PUSH
104559: EMPTY
104560: LIST
104561: LIST
104562: PUSH
104563: LD_INT 58
104565: PUSH
104566: EMPTY
104567: LIST
104568: PUSH
104569: EMPTY
104570: LIST
104571: LIST
104572: PPUSH
104573: CALL_OW 72
104577: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
104578: LD_VAR 0 4
104582: PUSH
104583: LD_VAR 0 7
104587: ARRAY
104588: PPUSH
104589: CALL_OW 314
104593: NOT
104594: IFFALSE 104716
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
104596: LD_ADDR_VAR 0 10
104600: PUSH
104601: LD_VAR 0 13
104605: PPUSH
104606: LD_VAR 0 4
104610: PUSH
104611: LD_VAR 0 7
104615: ARRAY
104616: PPUSH
104617: CALL_OW 74
104621: ST_TO_ADDR
// if not x then
104622: LD_VAR 0 10
104626: NOT
104627: IFFALSE 104631
// continue ;
104629: GO 104063
// if GetLives ( x ) < 1000 then
104631: LD_VAR 0 10
104635: PPUSH
104636: CALL_OW 256
104640: PUSH
104641: LD_INT 1000
104643: LESS
104644: IFFALSE 104668
// ComRepairVehicle ( group [ i ] , x ) else
104646: LD_VAR 0 4
104650: PUSH
104651: LD_VAR 0 7
104655: ARRAY
104656: PPUSH
104657: LD_VAR 0 10
104661: PPUSH
104662: CALL_OW 129
104666: GO 104716
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
104668: LD_VAR 0 23
104672: PUSH
104673: LD_VAR 0 4
104677: PUSH
104678: LD_VAR 0 7
104682: ARRAY
104683: PPUSH
104684: CALL_OW 256
104688: PUSH
104689: LD_INT 1000
104691: LESS
104692: AND
104693: NOT
104694: IFFALSE 104716
// ComEnterUnit ( group [ i ] , x ) ;
104696: LD_VAR 0 4
104700: PUSH
104701: LD_VAR 0 7
104705: ARRAY
104706: PPUSH
104707: LD_VAR 0 10
104711: PPUSH
104712: CALL_OW 120
// end ; continue ;
104716: GO 104063
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
104718: LD_VAR 0 23
104722: PUSH
104723: LD_VAR 0 4
104727: PUSH
104728: LD_VAR 0 7
104732: ARRAY
104733: PPUSH
104734: CALL_OW 247
104738: PUSH
104739: LD_INT 1
104741: EQUAL
104742: AND
104743: IFFALSE 105221
// begin if group [ i ] in healers then
104745: LD_VAR 0 4
104749: PUSH
104750: LD_VAR 0 7
104754: ARRAY
104755: PUSH
104756: LD_VAR 0 31
104760: IN
104761: IFFALSE 105034
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
104763: LD_VAR 0 4
104767: PUSH
104768: LD_VAR 0 7
104772: ARRAY
104773: PPUSH
104774: LD_VAR 0 23
104778: PPUSH
104779: CALL_OW 308
104783: NOT
104784: PUSH
104785: LD_VAR 0 4
104789: PUSH
104790: LD_VAR 0 7
104794: ARRAY
104795: PPUSH
104796: CALL_OW 314
104800: NOT
104801: AND
104802: IFFALSE 104826
// ComMoveToArea ( group [ i ] , f_heal ) else
104804: LD_VAR 0 4
104808: PUSH
104809: LD_VAR 0 7
104813: ARRAY
104814: PPUSH
104815: LD_VAR 0 23
104819: PPUSH
104820: CALL_OW 113
104824: GO 105032
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
104826: LD_VAR 0 4
104830: PUSH
104831: LD_VAR 0 7
104835: ARRAY
104836: PPUSH
104837: CALL 47677 0 1
104841: PPUSH
104842: CALL_OW 256
104846: PUSH
104847: LD_INT 1000
104849: EQUAL
104850: IFFALSE 104869
// ComStop ( group [ i ] ) else
104852: LD_VAR 0 4
104856: PUSH
104857: LD_VAR 0 7
104861: ARRAY
104862: PPUSH
104863: CALL_OW 141
104867: GO 105032
// if not HasTask ( group [ i ] ) and to_heal then
104869: LD_VAR 0 4
104873: PUSH
104874: LD_VAR 0 7
104878: ARRAY
104879: PPUSH
104880: CALL_OW 314
104884: NOT
104885: PUSH
104886: LD_VAR 0 30
104890: AND
104891: IFFALSE 105032
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
104893: LD_ADDR_VAR 0 13
104897: PUSH
104898: LD_VAR 0 30
104902: PPUSH
104903: LD_INT 3
104905: PUSH
104906: LD_INT 54
104908: PUSH
104909: EMPTY
104910: LIST
104911: PUSH
104912: EMPTY
104913: LIST
104914: LIST
104915: PPUSH
104916: CALL_OW 72
104920: PPUSH
104921: LD_VAR 0 4
104925: PUSH
104926: LD_VAR 0 7
104930: ARRAY
104931: PPUSH
104932: CALL_OW 74
104936: ST_TO_ADDR
// if z then
104937: LD_VAR 0 13
104941: IFFALSE 105032
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
104943: LD_INT 91
104945: PUSH
104946: LD_VAR 0 13
104950: PUSH
104951: LD_INT 10
104953: PUSH
104954: EMPTY
104955: LIST
104956: LIST
104957: LIST
104958: PUSH
104959: LD_INT 81
104961: PUSH
104962: LD_VAR 0 13
104966: PPUSH
104967: CALL_OW 255
104971: PUSH
104972: EMPTY
104973: LIST
104974: LIST
104975: PUSH
104976: EMPTY
104977: LIST
104978: LIST
104979: PPUSH
104980: CALL_OW 69
104984: PUSH
104985: LD_INT 0
104987: EQUAL
104988: IFFALSE 105012
// ComHeal ( group [ i ] , z ) else
104990: LD_VAR 0 4
104994: PUSH
104995: LD_VAR 0 7
104999: ARRAY
105000: PPUSH
105001: LD_VAR 0 13
105005: PPUSH
105006: CALL_OW 128
105010: GO 105032
// ComMoveToArea ( group [ i ] , f_heal ) ;
105012: LD_VAR 0 4
105016: PUSH
105017: LD_VAR 0 7
105021: ARRAY
105022: PPUSH
105023: LD_VAR 0 23
105027: PPUSH
105028: CALL_OW 113
// end ; continue ;
105032: GO 104063
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
105034: LD_VAR 0 4
105038: PUSH
105039: LD_VAR 0 7
105043: ARRAY
105044: PPUSH
105045: CALL_OW 256
105049: PUSH
105050: LD_INT 700
105052: LESS
105053: PUSH
105054: LD_VAR 0 4
105058: PUSH
105059: LD_VAR 0 7
105063: ARRAY
105064: PUSH
105065: LD_VAR 0 30
105069: IN
105070: NOT
105071: AND
105072: IFFALSE 105096
// to_heal := to_heal union group [ i ] ;
105074: LD_ADDR_VAR 0 30
105078: PUSH
105079: LD_VAR 0 30
105083: PUSH
105084: LD_VAR 0 4
105088: PUSH
105089: LD_VAR 0 7
105093: ARRAY
105094: UNION
105095: ST_TO_ADDR
// if group [ i ] in to_heal then
105096: LD_VAR 0 4
105100: PUSH
105101: LD_VAR 0 7
105105: ARRAY
105106: PUSH
105107: LD_VAR 0 30
105111: IN
105112: IFFALSE 105221
// begin if GetLives ( group [ i ] ) = 1000 then
105114: LD_VAR 0 4
105118: PUSH
105119: LD_VAR 0 7
105123: ARRAY
105124: PPUSH
105125: CALL_OW 256
105129: PUSH
105130: LD_INT 1000
105132: EQUAL
105133: IFFALSE 105159
// to_heal := to_heal diff group [ i ] else
105135: LD_ADDR_VAR 0 30
105139: PUSH
105140: LD_VAR 0 30
105144: PUSH
105145: LD_VAR 0 4
105149: PUSH
105150: LD_VAR 0 7
105154: ARRAY
105155: DIFF
105156: ST_TO_ADDR
105157: GO 105221
// begin if not IsInArea ( group [ i ] , to_heal ) then
105159: LD_VAR 0 4
105163: PUSH
105164: LD_VAR 0 7
105168: ARRAY
105169: PPUSH
105170: LD_VAR 0 30
105174: PPUSH
105175: CALL_OW 308
105179: NOT
105180: IFFALSE 105204
// ComMoveToArea ( group [ i ] , f_heal ) else
105182: LD_VAR 0 4
105186: PUSH
105187: LD_VAR 0 7
105191: ARRAY
105192: PPUSH
105193: LD_VAR 0 23
105197: PPUSH
105198: CALL_OW 113
105202: GO 105219
// ComHold ( group [ i ] ) ;
105204: LD_VAR 0 4
105208: PUSH
105209: LD_VAR 0 7
105213: ARRAY
105214: PPUSH
105215: CALL_OW 140
// continue ;
105219: GO 104063
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
105221: LD_VAR 0 4
105225: PUSH
105226: LD_VAR 0 7
105230: ARRAY
105231: PPUSH
105232: LD_INT 10
105234: PPUSH
105235: CALL 46097 0 2
105239: NOT
105240: PUSH
105241: LD_VAR 0 16
105245: PUSH
105246: LD_VAR 0 7
105250: ARRAY
105251: PUSH
105252: EMPTY
105253: EQUAL
105254: NOT
105255: AND
105256: IFFALSE 105522
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
105258: LD_VAR 0 4
105262: PUSH
105263: LD_VAR 0 7
105267: ARRAY
105268: PPUSH
105269: CALL_OW 262
105273: PUSH
105274: LD_INT 1
105276: PUSH
105277: LD_INT 2
105279: PUSH
105280: EMPTY
105281: LIST
105282: LIST
105283: IN
105284: IFFALSE 105325
// if GetFuel ( group [ i ] ) < 10 then
105286: LD_VAR 0 4
105290: PUSH
105291: LD_VAR 0 7
105295: ARRAY
105296: PPUSH
105297: CALL_OW 261
105301: PUSH
105302: LD_INT 10
105304: LESS
105305: IFFALSE 105325
// SetFuel ( group [ i ] , 12 ) ;
105307: LD_VAR 0 4
105311: PUSH
105312: LD_VAR 0 7
105316: ARRAY
105317: PPUSH
105318: LD_INT 12
105320: PPUSH
105321: CALL_OW 240
// if units_path [ i ] then
105325: LD_VAR 0 16
105329: PUSH
105330: LD_VAR 0 7
105334: ARRAY
105335: IFFALSE 105520
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
105337: LD_VAR 0 4
105341: PUSH
105342: LD_VAR 0 7
105346: ARRAY
105347: PPUSH
105348: LD_VAR 0 16
105352: PUSH
105353: LD_VAR 0 7
105357: ARRAY
105358: PUSH
105359: LD_INT 1
105361: ARRAY
105362: PUSH
105363: LD_INT 1
105365: ARRAY
105366: PPUSH
105367: LD_VAR 0 16
105371: PUSH
105372: LD_VAR 0 7
105376: ARRAY
105377: PUSH
105378: LD_INT 1
105380: ARRAY
105381: PUSH
105382: LD_INT 2
105384: ARRAY
105385: PPUSH
105386: CALL_OW 297
105390: PUSH
105391: LD_INT 6
105393: GREATER
105394: IFFALSE 105469
// begin if not HasTask ( group [ i ] ) then
105396: LD_VAR 0 4
105400: PUSH
105401: LD_VAR 0 7
105405: ARRAY
105406: PPUSH
105407: CALL_OW 314
105411: NOT
105412: IFFALSE 105467
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
105414: LD_VAR 0 4
105418: PUSH
105419: LD_VAR 0 7
105423: ARRAY
105424: PPUSH
105425: LD_VAR 0 16
105429: PUSH
105430: LD_VAR 0 7
105434: ARRAY
105435: PUSH
105436: LD_INT 1
105438: ARRAY
105439: PUSH
105440: LD_INT 1
105442: ARRAY
105443: PPUSH
105444: LD_VAR 0 16
105448: PUSH
105449: LD_VAR 0 7
105453: ARRAY
105454: PUSH
105455: LD_INT 1
105457: ARRAY
105458: PUSH
105459: LD_INT 2
105461: ARRAY
105462: PPUSH
105463: CALL_OW 114
// end else
105467: GO 105520
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
105469: LD_ADDR_VAR 0 15
105473: PUSH
105474: LD_VAR 0 16
105478: PUSH
105479: LD_VAR 0 7
105483: ARRAY
105484: PPUSH
105485: LD_INT 1
105487: PPUSH
105488: CALL_OW 3
105492: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
105493: LD_ADDR_VAR 0 16
105497: PUSH
105498: LD_VAR 0 16
105502: PPUSH
105503: LD_VAR 0 7
105507: PPUSH
105508: LD_VAR 0 15
105512: PPUSH
105513: CALL_OW 1
105517: ST_TO_ADDR
// continue ;
105518: GO 104063
// end ; end ; end else
105520: GO 108184
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
105522: LD_ADDR_VAR 0 14
105526: PUSH
105527: LD_INT 81
105529: PUSH
105530: LD_VAR 0 4
105534: PUSH
105535: LD_VAR 0 7
105539: ARRAY
105540: PPUSH
105541: CALL_OW 255
105545: PUSH
105546: EMPTY
105547: LIST
105548: LIST
105549: PPUSH
105550: CALL_OW 69
105554: ST_TO_ADDR
// if not tmp then
105555: LD_VAR 0 14
105559: NOT
105560: IFFALSE 105564
// continue ;
105562: GO 104063
// if f_ignore_area then
105564: LD_VAR 0 17
105568: IFFALSE 105656
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
105570: LD_ADDR_VAR 0 15
105574: PUSH
105575: LD_VAR 0 14
105579: PPUSH
105580: LD_INT 3
105582: PUSH
105583: LD_INT 92
105585: PUSH
105586: LD_VAR 0 17
105590: PUSH
105591: LD_INT 1
105593: ARRAY
105594: PUSH
105595: LD_VAR 0 17
105599: PUSH
105600: LD_INT 2
105602: ARRAY
105603: PUSH
105604: LD_VAR 0 17
105608: PUSH
105609: LD_INT 3
105611: ARRAY
105612: PUSH
105613: EMPTY
105614: LIST
105615: LIST
105616: LIST
105617: LIST
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: PPUSH
105623: CALL_OW 72
105627: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105628: LD_VAR 0 14
105632: PUSH
105633: LD_VAR 0 15
105637: DIFF
105638: IFFALSE 105656
// tmp := tmp diff tmp2 ;
105640: LD_ADDR_VAR 0 14
105644: PUSH
105645: LD_VAR 0 14
105649: PUSH
105650: LD_VAR 0 15
105654: DIFF
105655: ST_TO_ADDR
// end ; if not f_murder then
105656: LD_VAR 0 20
105660: NOT
105661: IFFALSE 105719
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
105663: LD_ADDR_VAR 0 15
105667: PUSH
105668: LD_VAR 0 14
105672: PPUSH
105673: LD_INT 3
105675: PUSH
105676: LD_INT 50
105678: PUSH
105679: EMPTY
105680: LIST
105681: PUSH
105682: EMPTY
105683: LIST
105684: LIST
105685: PPUSH
105686: CALL_OW 72
105690: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105691: LD_VAR 0 14
105695: PUSH
105696: LD_VAR 0 15
105700: DIFF
105701: IFFALSE 105719
// tmp := tmp diff tmp2 ;
105703: LD_ADDR_VAR 0 14
105707: PUSH
105708: LD_VAR 0 14
105712: PUSH
105713: LD_VAR 0 15
105717: DIFF
105718: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
105719: LD_ADDR_VAR 0 14
105723: PUSH
105724: LD_VAR 0 4
105728: PUSH
105729: LD_VAR 0 7
105733: ARRAY
105734: PPUSH
105735: LD_VAR 0 14
105739: PPUSH
105740: LD_INT 1
105742: PPUSH
105743: LD_INT 1
105745: PPUSH
105746: CALL 19032 0 4
105750: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
105751: LD_VAR 0 4
105755: PUSH
105756: LD_VAR 0 7
105760: ARRAY
105761: PPUSH
105762: CALL_OW 257
105766: PUSH
105767: LD_INT 1
105769: EQUAL
105770: IFFALSE 106218
// begin if WantPlant ( group [ i ] ) then
105772: LD_VAR 0 4
105776: PUSH
105777: LD_VAR 0 7
105781: ARRAY
105782: PPUSH
105783: CALL 18533 0 1
105787: IFFALSE 105791
// continue ;
105789: GO 104063
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
105791: LD_VAR 0 18
105795: PUSH
105796: LD_VAR 0 4
105800: PUSH
105801: LD_VAR 0 7
105805: ARRAY
105806: PPUSH
105807: CALL_OW 310
105811: NOT
105812: AND
105813: PUSH
105814: LD_VAR 0 14
105818: PUSH
105819: LD_INT 1
105821: ARRAY
105822: PUSH
105823: LD_VAR 0 14
105827: PPUSH
105828: LD_INT 21
105830: PUSH
105831: LD_INT 2
105833: PUSH
105834: EMPTY
105835: LIST
105836: LIST
105837: PUSH
105838: LD_INT 58
105840: PUSH
105841: EMPTY
105842: LIST
105843: PUSH
105844: EMPTY
105845: LIST
105846: LIST
105847: PPUSH
105848: CALL_OW 72
105852: IN
105853: AND
105854: IFFALSE 105890
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
105856: LD_VAR 0 4
105860: PUSH
105861: LD_VAR 0 7
105865: ARRAY
105866: PPUSH
105867: LD_VAR 0 14
105871: PUSH
105872: LD_INT 1
105874: ARRAY
105875: PPUSH
105876: CALL_OW 120
// attacking := true ;
105880: LD_ADDR_VAR 0 29
105884: PUSH
105885: LD_INT 1
105887: ST_TO_ADDR
// continue ;
105888: GO 104063
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
105890: LD_VAR 0 26
105894: PUSH
105895: LD_VAR 0 4
105899: PUSH
105900: LD_VAR 0 7
105904: ARRAY
105905: PPUSH
105906: CALL_OW 257
105910: PUSH
105911: LD_INT 1
105913: EQUAL
105914: AND
105915: PUSH
105916: LD_VAR 0 4
105920: PUSH
105921: LD_VAR 0 7
105925: ARRAY
105926: PPUSH
105927: CALL_OW 256
105931: PUSH
105932: LD_INT 800
105934: LESS
105935: AND
105936: PUSH
105937: LD_VAR 0 4
105941: PUSH
105942: LD_VAR 0 7
105946: ARRAY
105947: PPUSH
105948: CALL_OW 318
105952: NOT
105953: AND
105954: IFFALSE 105971
// ComCrawl ( group [ i ] ) ;
105956: LD_VAR 0 4
105960: PUSH
105961: LD_VAR 0 7
105965: ARRAY
105966: PPUSH
105967: CALL_OW 137
// if f_mines then
105971: LD_VAR 0 21
105975: IFFALSE 106218
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
105977: LD_VAR 0 14
105981: PUSH
105982: LD_INT 1
105984: ARRAY
105985: PPUSH
105986: CALL_OW 247
105990: PUSH
105991: LD_INT 3
105993: EQUAL
105994: PUSH
105995: LD_VAR 0 14
105999: PUSH
106000: LD_INT 1
106002: ARRAY
106003: PUSH
106004: LD_VAR 0 27
106008: IN
106009: NOT
106010: AND
106011: IFFALSE 106218
// begin x := GetX ( tmp [ 1 ] ) ;
106013: LD_ADDR_VAR 0 10
106017: PUSH
106018: LD_VAR 0 14
106022: PUSH
106023: LD_INT 1
106025: ARRAY
106026: PPUSH
106027: CALL_OW 250
106031: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
106032: LD_ADDR_VAR 0 11
106036: PUSH
106037: LD_VAR 0 14
106041: PUSH
106042: LD_INT 1
106044: ARRAY
106045: PPUSH
106046: CALL_OW 251
106050: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
106051: LD_ADDR_VAR 0 12
106055: PUSH
106056: LD_VAR 0 4
106060: PUSH
106061: LD_VAR 0 7
106065: ARRAY
106066: PPUSH
106067: CALL 46182 0 1
106071: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
106072: LD_VAR 0 4
106076: PUSH
106077: LD_VAR 0 7
106081: ARRAY
106082: PPUSH
106083: LD_VAR 0 10
106087: PPUSH
106088: LD_VAR 0 11
106092: PPUSH
106093: LD_VAR 0 14
106097: PUSH
106098: LD_INT 1
106100: ARRAY
106101: PPUSH
106102: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
106106: LD_VAR 0 4
106110: PUSH
106111: LD_VAR 0 7
106115: ARRAY
106116: PPUSH
106117: LD_VAR 0 10
106121: PPUSH
106122: LD_VAR 0 12
106126: PPUSH
106127: LD_INT 7
106129: PPUSH
106130: CALL_OW 272
106134: PPUSH
106135: LD_VAR 0 11
106139: PPUSH
106140: LD_VAR 0 12
106144: PPUSH
106145: LD_INT 7
106147: PPUSH
106148: CALL_OW 273
106152: PPUSH
106153: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
106157: LD_VAR 0 4
106161: PUSH
106162: LD_VAR 0 7
106166: ARRAY
106167: PPUSH
106168: LD_INT 71
106170: PPUSH
106171: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
106175: LD_ADDR_VAR 0 27
106179: PUSH
106180: LD_VAR 0 27
106184: PPUSH
106185: LD_VAR 0 27
106189: PUSH
106190: LD_INT 1
106192: PLUS
106193: PPUSH
106194: LD_VAR 0 14
106198: PUSH
106199: LD_INT 1
106201: ARRAY
106202: PPUSH
106203: CALL_OW 1
106207: ST_TO_ADDR
// attacking := true ;
106208: LD_ADDR_VAR 0 29
106212: PUSH
106213: LD_INT 1
106215: ST_TO_ADDR
// continue ;
106216: GO 104063
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
106218: LD_VAR 0 4
106222: PUSH
106223: LD_VAR 0 7
106227: ARRAY
106228: PPUSH
106229: CALL_OW 257
106233: PUSH
106234: LD_INT 17
106236: EQUAL
106237: PUSH
106238: LD_VAR 0 4
106242: PUSH
106243: LD_VAR 0 7
106247: ARRAY
106248: PPUSH
106249: CALL_OW 110
106253: PUSH
106254: LD_INT 71
106256: EQUAL
106257: NOT
106258: AND
106259: IFFALSE 106405
// begin attacking := false ;
106261: LD_ADDR_VAR 0 29
106265: PUSH
106266: LD_INT 0
106268: ST_TO_ADDR
// k := 5 ;
106269: LD_ADDR_VAR 0 9
106273: PUSH
106274: LD_INT 5
106276: ST_TO_ADDR
// if tmp < k then
106277: LD_VAR 0 14
106281: PUSH
106282: LD_VAR 0 9
106286: LESS
106287: IFFALSE 106299
// k := tmp ;
106289: LD_ADDR_VAR 0 9
106293: PUSH
106294: LD_VAR 0 14
106298: ST_TO_ADDR
// for j = 1 to k do
106299: LD_ADDR_VAR 0 8
106303: PUSH
106304: DOUBLE
106305: LD_INT 1
106307: DEC
106308: ST_TO_ADDR
106309: LD_VAR 0 9
106313: PUSH
106314: FOR_TO
106315: IFFALSE 106403
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
106317: LD_VAR 0 14
106321: PUSH
106322: LD_VAR 0 8
106326: ARRAY
106327: PUSH
106328: LD_VAR 0 14
106332: PPUSH
106333: LD_INT 58
106335: PUSH
106336: EMPTY
106337: LIST
106338: PPUSH
106339: CALL_OW 72
106343: IN
106344: NOT
106345: IFFALSE 106401
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106347: LD_VAR 0 4
106351: PUSH
106352: LD_VAR 0 7
106356: ARRAY
106357: PPUSH
106358: LD_VAR 0 14
106362: PUSH
106363: LD_VAR 0 8
106367: ARRAY
106368: PPUSH
106369: CALL_OW 115
// attacking := true ;
106373: LD_ADDR_VAR 0 29
106377: PUSH
106378: LD_INT 1
106380: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
106381: LD_VAR 0 4
106385: PUSH
106386: LD_VAR 0 7
106390: ARRAY
106391: PPUSH
106392: LD_INT 71
106394: PPUSH
106395: CALL_OW 109
// continue ;
106399: GO 106314
// end ; end ;
106401: GO 106314
106403: POP
106404: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
106405: LD_VAR 0 4
106409: PUSH
106410: LD_VAR 0 7
106414: ARRAY
106415: PPUSH
106416: CALL_OW 257
106420: PUSH
106421: LD_INT 8
106423: EQUAL
106424: PUSH
106425: LD_VAR 0 4
106429: PUSH
106430: LD_VAR 0 7
106434: ARRAY
106435: PPUSH
106436: CALL_OW 264
106440: PUSH
106441: LD_INT 28
106443: PUSH
106444: LD_INT 45
106446: PUSH
106447: LD_INT 7
106449: PUSH
106450: LD_INT 47
106452: PUSH
106453: EMPTY
106454: LIST
106455: LIST
106456: LIST
106457: LIST
106458: IN
106459: OR
106460: IFFALSE 106716
// begin attacking := false ;
106462: LD_ADDR_VAR 0 29
106466: PUSH
106467: LD_INT 0
106469: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
106470: LD_VAR 0 14
106474: PUSH
106475: LD_INT 1
106477: ARRAY
106478: PPUSH
106479: CALL_OW 266
106483: PUSH
106484: LD_INT 32
106486: PUSH
106487: LD_INT 31
106489: PUSH
106490: LD_INT 33
106492: PUSH
106493: LD_INT 4
106495: PUSH
106496: LD_INT 5
106498: PUSH
106499: EMPTY
106500: LIST
106501: LIST
106502: LIST
106503: LIST
106504: LIST
106505: IN
106506: IFFALSE 106692
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
106508: LD_ADDR_VAR 0 9
106512: PUSH
106513: LD_VAR 0 14
106517: PUSH
106518: LD_INT 1
106520: ARRAY
106521: PPUSH
106522: CALL_OW 266
106526: PPUSH
106527: LD_VAR 0 14
106531: PUSH
106532: LD_INT 1
106534: ARRAY
106535: PPUSH
106536: CALL_OW 250
106540: PPUSH
106541: LD_VAR 0 14
106545: PUSH
106546: LD_INT 1
106548: ARRAY
106549: PPUSH
106550: CALL_OW 251
106554: PPUSH
106555: LD_VAR 0 14
106559: PUSH
106560: LD_INT 1
106562: ARRAY
106563: PPUSH
106564: CALL_OW 254
106568: PPUSH
106569: LD_VAR 0 14
106573: PUSH
106574: LD_INT 1
106576: ARRAY
106577: PPUSH
106578: CALL_OW 248
106582: PPUSH
106583: LD_INT 0
106585: PPUSH
106586: CALL 27552 0 6
106590: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
106591: LD_ADDR_VAR 0 8
106595: PUSH
106596: LD_VAR 0 4
106600: PUSH
106601: LD_VAR 0 7
106605: ARRAY
106606: PPUSH
106607: LD_VAR 0 9
106611: PPUSH
106612: CALL 46222 0 2
106616: ST_TO_ADDR
// if j then
106617: LD_VAR 0 8
106621: IFFALSE 106690
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
106623: LD_VAR 0 8
106627: PUSH
106628: LD_INT 1
106630: ARRAY
106631: PPUSH
106632: LD_VAR 0 8
106636: PUSH
106637: LD_INT 2
106639: ARRAY
106640: PPUSH
106641: CALL_OW 488
106645: IFFALSE 106690
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
106647: LD_VAR 0 4
106651: PUSH
106652: LD_VAR 0 7
106656: ARRAY
106657: PPUSH
106658: LD_VAR 0 8
106662: PUSH
106663: LD_INT 1
106665: ARRAY
106666: PPUSH
106667: LD_VAR 0 8
106671: PUSH
106672: LD_INT 2
106674: ARRAY
106675: PPUSH
106676: CALL_OW 116
// attacking := true ;
106680: LD_ADDR_VAR 0 29
106684: PUSH
106685: LD_INT 1
106687: ST_TO_ADDR
// continue ;
106688: GO 104063
// end ; end else
106690: GO 106716
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106692: LD_VAR 0 4
106696: PUSH
106697: LD_VAR 0 7
106701: ARRAY
106702: PPUSH
106703: LD_VAR 0 14
106707: PUSH
106708: LD_INT 1
106710: ARRAY
106711: PPUSH
106712: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
106716: LD_VAR 0 4
106720: PUSH
106721: LD_VAR 0 7
106725: ARRAY
106726: PPUSH
106727: CALL_OW 265
106731: PUSH
106732: LD_INT 11
106734: EQUAL
106735: IFFALSE 107013
// begin k := 10 ;
106737: LD_ADDR_VAR 0 9
106741: PUSH
106742: LD_INT 10
106744: ST_TO_ADDR
// x := 0 ;
106745: LD_ADDR_VAR 0 10
106749: PUSH
106750: LD_INT 0
106752: ST_TO_ADDR
// if tmp < k then
106753: LD_VAR 0 14
106757: PUSH
106758: LD_VAR 0 9
106762: LESS
106763: IFFALSE 106775
// k := tmp ;
106765: LD_ADDR_VAR 0 9
106769: PUSH
106770: LD_VAR 0 14
106774: ST_TO_ADDR
// for j = k downto 1 do
106775: LD_ADDR_VAR 0 8
106779: PUSH
106780: DOUBLE
106781: LD_VAR 0 9
106785: INC
106786: ST_TO_ADDR
106787: LD_INT 1
106789: PUSH
106790: FOR_DOWNTO
106791: IFFALSE 106866
// begin if GetType ( tmp [ j ] ) = unit_human then
106793: LD_VAR 0 14
106797: PUSH
106798: LD_VAR 0 8
106802: ARRAY
106803: PPUSH
106804: CALL_OW 247
106808: PUSH
106809: LD_INT 1
106811: EQUAL
106812: IFFALSE 106864
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
106814: LD_VAR 0 4
106818: PUSH
106819: LD_VAR 0 7
106823: ARRAY
106824: PPUSH
106825: LD_VAR 0 14
106829: PUSH
106830: LD_VAR 0 8
106834: ARRAY
106835: PPUSH
106836: CALL 46493 0 2
// x := tmp [ j ] ;
106840: LD_ADDR_VAR 0 10
106844: PUSH
106845: LD_VAR 0 14
106849: PUSH
106850: LD_VAR 0 8
106854: ARRAY
106855: ST_TO_ADDR
// attacking := true ;
106856: LD_ADDR_VAR 0 29
106860: PUSH
106861: LD_INT 1
106863: ST_TO_ADDR
// end ; end ;
106864: GO 106790
106866: POP
106867: POP
// if not x then
106868: LD_VAR 0 10
106872: NOT
106873: IFFALSE 107013
// begin attacking := true ;
106875: LD_ADDR_VAR 0 29
106879: PUSH
106880: LD_INT 1
106882: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
106883: LD_VAR 0 4
106887: PUSH
106888: LD_VAR 0 7
106892: ARRAY
106893: PPUSH
106894: CALL_OW 250
106898: PPUSH
106899: LD_VAR 0 4
106903: PUSH
106904: LD_VAR 0 7
106908: ARRAY
106909: PPUSH
106910: CALL_OW 251
106914: PPUSH
106915: CALL_OW 546
106919: PUSH
106920: LD_INT 2
106922: ARRAY
106923: PUSH
106924: LD_VAR 0 14
106928: PUSH
106929: LD_INT 1
106931: ARRAY
106932: PPUSH
106933: CALL_OW 250
106937: PPUSH
106938: LD_VAR 0 14
106942: PUSH
106943: LD_INT 1
106945: ARRAY
106946: PPUSH
106947: CALL_OW 251
106951: PPUSH
106952: CALL_OW 546
106956: PUSH
106957: LD_INT 2
106959: ARRAY
106960: EQUAL
106961: IFFALSE 106989
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
106963: LD_VAR 0 4
106967: PUSH
106968: LD_VAR 0 7
106972: ARRAY
106973: PPUSH
106974: LD_VAR 0 14
106978: PUSH
106979: LD_INT 1
106981: ARRAY
106982: PPUSH
106983: CALL 46493 0 2
106987: GO 107013
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106989: LD_VAR 0 4
106993: PUSH
106994: LD_VAR 0 7
106998: ARRAY
106999: PPUSH
107000: LD_VAR 0 14
107004: PUSH
107005: LD_INT 1
107007: ARRAY
107008: PPUSH
107009: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
107013: LD_VAR 0 4
107017: PUSH
107018: LD_VAR 0 7
107022: ARRAY
107023: PPUSH
107024: CALL_OW 264
107028: PUSH
107029: LD_INT 29
107031: EQUAL
107032: IFFALSE 107398
// begin if WantsToAttack ( group [ i ] ) in bombed then
107034: LD_VAR 0 4
107038: PUSH
107039: LD_VAR 0 7
107043: ARRAY
107044: PPUSH
107045: CALL_OW 319
107049: PUSH
107050: LD_VAR 0 28
107054: IN
107055: IFFALSE 107059
// continue ;
107057: GO 104063
// k := 8 ;
107059: LD_ADDR_VAR 0 9
107063: PUSH
107064: LD_INT 8
107066: ST_TO_ADDR
// x := 0 ;
107067: LD_ADDR_VAR 0 10
107071: PUSH
107072: LD_INT 0
107074: ST_TO_ADDR
// if tmp < k then
107075: LD_VAR 0 14
107079: PUSH
107080: LD_VAR 0 9
107084: LESS
107085: IFFALSE 107097
// k := tmp ;
107087: LD_ADDR_VAR 0 9
107091: PUSH
107092: LD_VAR 0 14
107096: ST_TO_ADDR
// for j = 1 to k do
107097: LD_ADDR_VAR 0 8
107101: PUSH
107102: DOUBLE
107103: LD_INT 1
107105: DEC
107106: ST_TO_ADDR
107107: LD_VAR 0 9
107111: PUSH
107112: FOR_TO
107113: IFFALSE 107245
// begin if GetType ( tmp [ j ] ) = unit_building then
107115: LD_VAR 0 14
107119: PUSH
107120: LD_VAR 0 8
107124: ARRAY
107125: PPUSH
107126: CALL_OW 247
107130: PUSH
107131: LD_INT 3
107133: EQUAL
107134: IFFALSE 107243
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
107136: LD_VAR 0 14
107140: PUSH
107141: LD_VAR 0 8
107145: ARRAY
107146: PUSH
107147: LD_VAR 0 28
107151: IN
107152: NOT
107153: PUSH
107154: LD_VAR 0 14
107158: PUSH
107159: LD_VAR 0 8
107163: ARRAY
107164: PPUSH
107165: CALL_OW 313
107169: AND
107170: IFFALSE 107243
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107172: LD_VAR 0 4
107176: PUSH
107177: LD_VAR 0 7
107181: ARRAY
107182: PPUSH
107183: LD_VAR 0 14
107187: PUSH
107188: LD_VAR 0 8
107192: ARRAY
107193: PPUSH
107194: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
107198: LD_ADDR_VAR 0 28
107202: PUSH
107203: LD_VAR 0 28
107207: PPUSH
107208: LD_VAR 0 28
107212: PUSH
107213: LD_INT 1
107215: PLUS
107216: PPUSH
107217: LD_VAR 0 14
107221: PUSH
107222: LD_VAR 0 8
107226: ARRAY
107227: PPUSH
107228: CALL_OW 1
107232: ST_TO_ADDR
// attacking := true ;
107233: LD_ADDR_VAR 0 29
107237: PUSH
107238: LD_INT 1
107240: ST_TO_ADDR
// break ;
107241: GO 107245
// end ; end ;
107243: GO 107112
107245: POP
107246: POP
// if not attacking and f_attack_depot then
107247: LD_VAR 0 29
107251: NOT
107252: PUSH
107253: LD_VAR 0 25
107257: AND
107258: IFFALSE 107353
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107260: LD_ADDR_VAR 0 13
107264: PUSH
107265: LD_VAR 0 14
107269: PPUSH
107270: LD_INT 2
107272: PUSH
107273: LD_INT 30
107275: PUSH
107276: LD_INT 0
107278: PUSH
107279: EMPTY
107280: LIST
107281: LIST
107282: PUSH
107283: LD_INT 30
107285: PUSH
107286: LD_INT 1
107288: PUSH
107289: EMPTY
107290: LIST
107291: LIST
107292: PUSH
107293: EMPTY
107294: LIST
107295: LIST
107296: LIST
107297: PPUSH
107298: CALL_OW 72
107302: ST_TO_ADDR
// if z then
107303: LD_VAR 0 13
107307: IFFALSE 107353
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
107309: LD_VAR 0 4
107313: PUSH
107314: LD_VAR 0 7
107318: ARRAY
107319: PPUSH
107320: LD_VAR 0 13
107324: PPUSH
107325: LD_VAR 0 4
107329: PUSH
107330: LD_VAR 0 7
107334: ARRAY
107335: PPUSH
107336: CALL_OW 74
107340: PPUSH
107341: CALL_OW 115
// attacking := true ;
107345: LD_ADDR_VAR 0 29
107349: PUSH
107350: LD_INT 1
107352: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
107353: LD_VAR 0 4
107357: PUSH
107358: LD_VAR 0 7
107362: ARRAY
107363: PPUSH
107364: CALL_OW 256
107368: PUSH
107369: LD_INT 500
107371: LESS
107372: IFFALSE 107398
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107374: LD_VAR 0 4
107378: PUSH
107379: LD_VAR 0 7
107383: ARRAY
107384: PPUSH
107385: LD_VAR 0 14
107389: PUSH
107390: LD_INT 1
107392: ARRAY
107393: PPUSH
107394: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
107398: LD_VAR 0 4
107402: PUSH
107403: LD_VAR 0 7
107407: ARRAY
107408: PPUSH
107409: CALL_OW 264
107413: PUSH
107414: LD_INT 49
107416: EQUAL
107417: IFFALSE 107538
// begin if not HasTask ( group [ i ] ) then
107419: LD_VAR 0 4
107423: PUSH
107424: LD_VAR 0 7
107428: ARRAY
107429: PPUSH
107430: CALL_OW 314
107434: NOT
107435: IFFALSE 107538
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
107437: LD_ADDR_VAR 0 9
107441: PUSH
107442: LD_INT 81
107444: PUSH
107445: LD_VAR 0 4
107449: PUSH
107450: LD_VAR 0 7
107454: ARRAY
107455: PPUSH
107456: CALL_OW 255
107460: PUSH
107461: EMPTY
107462: LIST
107463: LIST
107464: PPUSH
107465: CALL_OW 69
107469: PPUSH
107470: LD_VAR 0 4
107474: PUSH
107475: LD_VAR 0 7
107479: ARRAY
107480: PPUSH
107481: CALL_OW 74
107485: ST_TO_ADDR
// if k then
107486: LD_VAR 0 9
107490: IFFALSE 107538
// if GetDistUnits ( group [ i ] , k ) > 10 then
107492: LD_VAR 0 4
107496: PUSH
107497: LD_VAR 0 7
107501: ARRAY
107502: PPUSH
107503: LD_VAR 0 9
107507: PPUSH
107508: CALL_OW 296
107512: PUSH
107513: LD_INT 10
107515: GREATER
107516: IFFALSE 107538
// ComMoveUnit ( group [ i ] , k ) ;
107518: LD_VAR 0 4
107522: PUSH
107523: LD_VAR 0 7
107527: ARRAY
107528: PPUSH
107529: LD_VAR 0 9
107533: PPUSH
107534: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
107538: LD_VAR 0 4
107542: PUSH
107543: LD_VAR 0 7
107547: ARRAY
107548: PPUSH
107549: CALL_OW 256
107553: PUSH
107554: LD_INT 250
107556: LESS
107557: PUSH
107558: LD_VAR 0 4
107562: PUSH
107563: LD_VAR 0 7
107567: ARRAY
107568: PUSH
107569: LD_INT 21
107571: PUSH
107572: LD_INT 2
107574: PUSH
107575: EMPTY
107576: LIST
107577: LIST
107578: PUSH
107579: LD_INT 23
107581: PUSH
107582: LD_INT 2
107584: PUSH
107585: EMPTY
107586: LIST
107587: LIST
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: PPUSH
107593: CALL_OW 69
107597: IN
107598: AND
107599: IFFALSE 107724
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
107601: LD_ADDR_VAR 0 9
107605: PUSH
107606: LD_OWVAR 3
107610: PUSH
107611: LD_VAR 0 4
107615: PUSH
107616: LD_VAR 0 7
107620: ARRAY
107621: DIFF
107622: PPUSH
107623: LD_VAR 0 4
107627: PUSH
107628: LD_VAR 0 7
107632: ARRAY
107633: PPUSH
107634: CALL_OW 74
107638: ST_TO_ADDR
// if not k then
107639: LD_VAR 0 9
107643: NOT
107644: IFFALSE 107648
// continue ;
107646: GO 104063
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
107648: LD_VAR 0 9
107652: PUSH
107653: LD_INT 81
107655: PUSH
107656: LD_VAR 0 4
107660: PUSH
107661: LD_VAR 0 7
107665: ARRAY
107666: PPUSH
107667: CALL_OW 255
107671: PUSH
107672: EMPTY
107673: LIST
107674: LIST
107675: PPUSH
107676: CALL_OW 69
107680: IN
107681: PUSH
107682: LD_VAR 0 9
107686: PPUSH
107687: LD_VAR 0 4
107691: PUSH
107692: LD_VAR 0 7
107696: ARRAY
107697: PPUSH
107698: CALL_OW 296
107702: PUSH
107703: LD_INT 5
107705: LESS
107706: AND
107707: IFFALSE 107724
// ComAutodestruct ( group [ i ] ) ;
107709: LD_VAR 0 4
107713: PUSH
107714: LD_VAR 0 7
107718: ARRAY
107719: PPUSH
107720: CALL 46391 0 1
// end ; if f_attack_depot then
107724: LD_VAR 0 25
107728: IFFALSE 107840
// begin k := 6 ;
107730: LD_ADDR_VAR 0 9
107734: PUSH
107735: LD_INT 6
107737: ST_TO_ADDR
// if tmp < k then
107738: LD_VAR 0 14
107742: PUSH
107743: LD_VAR 0 9
107747: LESS
107748: IFFALSE 107760
// k := tmp ;
107750: LD_ADDR_VAR 0 9
107754: PUSH
107755: LD_VAR 0 14
107759: ST_TO_ADDR
// for j = 1 to k do
107760: LD_ADDR_VAR 0 8
107764: PUSH
107765: DOUBLE
107766: LD_INT 1
107768: DEC
107769: ST_TO_ADDR
107770: LD_VAR 0 9
107774: PUSH
107775: FOR_TO
107776: IFFALSE 107838
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
107778: LD_VAR 0 8
107782: PPUSH
107783: CALL_OW 266
107787: PUSH
107788: LD_INT 0
107790: PUSH
107791: LD_INT 1
107793: PUSH
107794: EMPTY
107795: LIST
107796: LIST
107797: IN
107798: IFFALSE 107836
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107800: LD_VAR 0 4
107804: PUSH
107805: LD_VAR 0 7
107809: ARRAY
107810: PPUSH
107811: LD_VAR 0 14
107815: PUSH
107816: LD_VAR 0 8
107820: ARRAY
107821: PPUSH
107822: CALL_OW 115
// attacking := true ;
107826: LD_ADDR_VAR 0 29
107830: PUSH
107831: LD_INT 1
107833: ST_TO_ADDR
// break ;
107834: GO 107838
// end ;
107836: GO 107775
107838: POP
107839: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
107840: LD_VAR 0 4
107844: PUSH
107845: LD_VAR 0 7
107849: ARRAY
107850: PPUSH
107851: CALL_OW 302
107855: PUSH
107856: LD_VAR 0 29
107860: NOT
107861: AND
107862: IFFALSE 108184
// begin if GetTag ( group [ i ] ) = 71 then
107864: LD_VAR 0 4
107868: PUSH
107869: LD_VAR 0 7
107873: ARRAY
107874: PPUSH
107875: CALL_OW 110
107879: PUSH
107880: LD_INT 71
107882: EQUAL
107883: IFFALSE 107924
// begin if HasTask ( group [ i ] ) then
107885: LD_VAR 0 4
107889: PUSH
107890: LD_VAR 0 7
107894: ARRAY
107895: PPUSH
107896: CALL_OW 314
107900: IFFALSE 107906
// continue else
107902: GO 104063
107904: GO 107924
// SetTag ( group [ i ] , 0 ) ;
107906: LD_VAR 0 4
107910: PUSH
107911: LD_VAR 0 7
107915: ARRAY
107916: PPUSH
107917: LD_INT 0
107919: PPUSH
107920: CALL_OW 109
// end ; k := 8 ;
107924: LD_ADDR_VAR 0 9
107928: PUSH
107929: LD_INT 8
107931: ST_TO_ADDR
// x := 0 ;
107932: LD_ADDR_VAR 0 10
107936: PUSH
107937: LD_INT 0
107939: ST_TO_ADDR
// if tmp < k then
107940: LD_VAR 0 14
107944: PUSH
107945: LD_VAR 0 9
107949: LESS
107950: IFFALSE 107962
// k := tmp ;
107952: LD_ADDR_VAR 0 9
107956: PUSH
107957: LD_VAR 0 14
107961: ST_TO_ADDR
// for j = 1 to k do
107962: LD_ADDR_VAR 0 8
107966: PUSH
107967: DOUBLE
107968: LD_INT 1
107970: DEC
107971: ST_TO_ADDR
107972: LD_VAR 0 9
107976: PUSH
107977: FOR_TO
107978: IFFALSE 108076
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
107980: LD_VAR 0 14
107984: PUSH
107985: LD_VAR 0 8
107989: ARRAY
107990: PPUSH
107991: CALL_OW 247
107995: PUSH
107996: LD_INT 1
107998: EQUAL
107999: PUSH
108000: LD_VAR 0 14
108004: PUSH
108005: LD_VAR 0 8
108009: ARRAY
108010: PPUSH
108011: CALL_OW 256
108015: PUSH
108016: LD_INT 250
108018: LESS
108019: PUSH
108020: LD_VAR 0 20
108024: AND
108025: PUSH
108026: LD_VAR 0 20
108030: NOT
108031: PUSH
108032: LD_VAR 0 14
108036: PUSH
108037: LD_VAR 0 8
108041: ARRAY
108042: PPUSH
108043: CALL_OW 256
108047: PUSH
108048: LD_INT 250
108050: GREATEREQUAL
108051: AND
108052: OR
108053: AND
108054: IFFALSE 108074
// begin x := tmp [ j ] ;
108056: LD_ADDR_VAR 0 10
108060: PUSH
108061: LD_VAR 0 14
108065: PUSH
108066: LD_VAR 0 8
108070: ARRAY
108071: ST_TO_ADDR
// break ;
108072: GO 108076
// end ;
108074: GO 107977
108076: POP
108077: POP
// if x then
108078: LD_VAR 0 10
108082: IFFALSE 108106
// ComAttackUnit ( group [ i ] , x ) else
108084: LD_VAR 0 4
108088: PUSH
108089: LD_VAR 0 7
108093: ARRAY
108094: PPUSH
108095: LD_VAR 0 10
108099: PPUSH
108100: CALL_OW 115
108104: GO 108130
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108106: LD_VAR 0 4
108110: PUSH
108111: LD_VAR 0 7
108115: ARRAY
108116: PPUSH
108117: LD_VAR 0 14
108121: PUSH
108122: LD_INT 1
108124: ARRAY
108125: PPUSH
108126: CALL_OW 115
// if not HasTask ( group [ i ] ) then
108130: LD_VAR 0 4
108134: PUSH
108135: LD_VAR 0 7
108139: ARRAY
108140: PPUSH
108141: CALL_OW 314
108145: NOT
108146: IFFALSE 108184
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
108148: LD_VAR 0 4
108152: PUSH
108153: LD_VAR 0 7
108157: ARRAY
108158: PPUSH
108159: LD_VAR 0 14
108163: PPUSH
108164: LD_VAR 0 4
108168: PUSH
108169: LD_VAR 0 7
108173: ARRAY
108174: PPUSH
108175: CALL_OW 74
108179: PPUSH
108180: CALL_OW 115
// end ; end ; end ;
108184: GO 104063
108186: POP
108187: POP
// wait ( 0 0$2 ) ;
108188: LD_INT 70
108190: PPUSH
108191: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
108195: LD_VAR 0 4
108199: NOT
108200: PUSH
108201: LD_VAR 0 4
108205: PUSH
108206: EMPTY
108207: EQUAL
108208: OR
108209: PUSH
108210: LD_INT 81
108212: PUSH
108213: LD_VAR 0 35
108217: PUSH
108218: EMPTY
108219: LIST
108220: LIST
108221: PPUSH
108222: CALL_OW 69
108226: NOT
108227: OR
108228: IFFALSE 104048
// end ;
108230: LD_VAR 0 2
108234: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
108235: LD_INT 0
108237: PPUSH
108238: PPUSH
108239: PPUSH
108240: PPUSH
108241: PPUSH
108242: PPUSH
// if not base or not mc_bases [ base ] or not solds then
108243: LD_VAR 0 1
108247: NOT
108248: PUSH
108249: LD_EXP 70
108253: PUSH
108254: LD_VAR 0 1
108258: ARRAY
108259: NOT
108260: OR
108261: PUSH
108262: LD_VAR 0 2
108266: NOT
108267: OR
108268: IFFALSE 108272
// exit ;
108270: GO 108826
// side := mc_sides [ base ] ;
108272: LD_ADDR_VAR 0 6
108276: PUSH
108277: LD_EXP 96
108281: PUSH
108282: LD_VAR 0 1
108286: ARRAY
108287: ST_TO_ADDR
// if not side then
108288: LD_VAR 0 6
108292: NOT
108293: IFFALSE 108297
// exit ;
108295: GO 108826
// for i in solds do
108297: LD_ADDR_VAR 0 7
108301: PUSH
108302: LD_VAR 0 2
108306: PUSH
108307: FOR_IN
108308: IFFALSE 108369
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
108310: LD_VAR 0 7
108314: PPUSH
108315: CALL_OW 310
108319: PPUSH
108320: CALL_OW 266
108324: PUSH
108325: LD_INT 32
108327: PUSH
108328: LD_INT 31
108330: PUSH
108331: EMPTY
108332: LIST
108333: LIST
108334: IN
108335: IFFALSE 108355
// solds := solds diff i else
108337: LD_ADDR_VAR 0 2
108341: PUSH
108342: LD_VAR 0 2
108346: PUSH
108347: LD_VAR 0 7
108351: DIFF
108352: ST_TO_ADDR
108353: GO 108367
// SetTag ( i , 18 ) ;
108355: LD_VAR 0 7
108359: PPUSH
108360: LD_INT 18
108362: PPUSH
108363: CALL_OW 109
108367: GO 108307
108369: POP
108370: POP
// if not solds then
108371: LD_VAR 0 2
108375: NOT
108376: IFFALSE 108380
// exit ;
108378: GO 108826
// repeat wait ( 0 0$2 ) ;
108380: LD_INT 70
108382: PPUSH
108383: CALL_OW 67
// enemy := mc_scan [ base ] ;
108387: LD_ADDR_VAR 0 4
108391: PUSH
108392: LD_EXP 93
108396: PUSH
108397: LD_VAR 0 1
108401: ARRAY
108402: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108403: LD_EXP 70
108407: PUSH
108408: LD_VAR 0 1
108412: ARRAY
108413: NOT
108414: PUSH
108415: LD_EXP 70
108419: PUSH
108420: LD_VAR 0 1
108424: ARRAY
108425: PUSH
108426: EMPTY
108427: EQUAL
108428: OR
108429: IFFALSE 108466
// begin for i in solds do
108431: LD_ADDR_VAR 0 7
108435: PUSH
108436: LD_VAR 0 2
108440: PUSH
108441: FOR_IN
108442: IFFALSE 108455
// ComStop ( i ) ;
108444: LD_VAR 0 7
108448: PPUSH
108449: CALL_OW 141
108453: GO 108441
108455: POP
108456: POP
// solds := [ ] ;
108457: LD_ADDR_VAR 0 2
108461: PUSH
108462: EMPTY
108463: ST_TO_ADDR
// exit ;
108464: GO 108826
// end ; for i in solds do
108466: LD_ADDR_VAR 0 7
108470: PUSH
108471: LD_VAR 0 2
108475: PUSH
108476: FOR_IN
108477: IFFALSE 108798
// begin if IsInUnit ( i ) then
108479: LD_VAR 0 7
108483: PPUSH
108484: CALL_OW 310
108488: IFFALSE 108499
// ComExitBuilding ( i ) ;
108490: LD_VAR 0 7
108494: PPUSH
108495: CALL_OW 122
// if GetLives ( i ) > 500 then
108499: LD_VAR 0 7
108503: PPUSH
108504: CALL_OW 256
108508: PUSH
108509: LD_INT 500
108511: GREATER
108512: IFFALSE 108565
// begin e := NearestUnitToUnit ( enemy , i ) ;
108514: LD_ADDR_VAR 0 5
108518: PUSH
108519: LD_VAR 0 4
108523: PPUSH
108524: LD_VAR 0 7
108528: PPUSH
108529: CALL_OW 74
108533: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
108534: LD_VAR 0 7
108538: PPUSH
108539: LD_VAR 0 5
108543: PPUSH
108544: CALL_OW 250
108548: PPUSH
108549: LD_VAR 0 5
108553: PPUSH
108554: CALL_OW 251
108558: PPUSH
108559: CALL_OW 114
// end else
108563: GO 108796
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
108565: LD_VAR 0 7
108569: PPUSH
108570: LD_EXP 70
108574: PUSH
108575: LD_VAR 0 1
108579: ARRAY
108580: PPUSH
108581: LD_INT 2
108583: PUSH
108584: LD_INT 30
108586: PUSH
108587: LD_INT 0
108589: PUSH
108590: EMPTY
108591: LIST
108592: LIST
108593: PUSH
108594: LD_INT 30
108596: PUSH
108597: LD_INT 1
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: PUSH
108604: LD_INT 30
108606: PUSH
108607: LD_INT 6
108609: PUSH
108610: EMPTY
108611: LIST
108612: LIST
108613: PUSH
108614: EMPTY
108615: LIST
108616: LIST
108617: LIST
108618: LIST
108619: PPUSH
108620: CALL_OW 72
108624: PPUSH
108625: LD_VAR 0 7
108629: PPUSH
108630: CALL_OW 74
108634: PPUSH
108635: CALL_OW 296
108639: PUSH
108640: LD_INT 10
108642: GREATER
108643: IFFALSE 108796
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
108645: LD_ADDR_VAR 0 8
108649: PUSH
108650: LD_EXP 70
108654: PUSH
108655: LD_VAR 0 1
108659: ARRAY
108660: PPUSH
108661: LD_INT 2
108663: PUSH
108664: LD_INT 30
108666: PUSH
108667: LD_INT 0
108669: PUSH
108670: EMPTY
108671: LIST
108672: LIST
108673: PUSH
108674: LD_INT 30
108676: PUSH
108677: LD_INT 1
108679: PUSH
108680: EMPTY
108681: LIST
108682: LIST
108683: PUSH
108684: LD_INT 30
108686: PUSH
108687: LD_INT 6
108689: PUSH
108690: EMPTY
108691: LIST
108692: LIST
108693: PUSH
108694: EMPTY
108695: LIST
108696: LIST
108697: LIST
108698: LIST
108699: PPUSH
108700: CALL_OW 72
108704: PPUSH
108705: LD_VAR 0 7
108709: PPUSH
108710: CALL_OW 74
108714: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
108715: LD_VAR 0 7
108719: PPUSH
108720: LD_VAR 0 8
108724: PPUSH
108725: CALL_OW 250
108729: PPUSH
108730: LD_INT 3
108732: PPUSH
108733: LD_INT 5
108735: PPUSH
108736: CALL_OW 272
108740: PPUSH
108741: LD_VAR 0 8
108745: PPUSH
108746: CALL_OW 251
108750: PPUSH
108751: LD_INT 3
108753: PPUSH
108754: LD_INT 5
108756: PPUSH
108757: CALL_OW 273
108761: PPUSH
108762: CALL_OW 111
// SetTag ( i , 0 ) ;
108766: LD_VAR 0 7
108770: PPUSH
108771: LD_INT 0
108773: PPUSH
108774: CALL_OW 109
// solds := solds diff i ;
108778: LD_ADDR_VAR 0 2
108782: PUSH
108783: LD_VAR 0 2
108787: PUSH
108788: LD_VAR 0 7
108792: DIFF
108793: ST_TO_ADDR
// continue ;
108794: GO 108476
// end ; end ;
108796: GO 108476
108798: POP
108799: POP
// until not solds or not enemy ;
108800: LD_VAR 0 2
108804: NOT
108805: PUSH
108806: LD_VAR 0 4
108810: NOT
108811: OR
108812: IFFALSE 108380
// MC_Reset ( base , 18 ) ;
108814: LD_VAR 0 1
108818: PPUSH
108819: LD_INT 18
108821: PPUSH
108822: CALL 58080 0 2
// end ;
108826: LD_VAR 0 3
108830: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
108831: LD_INT 0
108833: PPUSH
108834: PPUSH
108835: PPUSH
108836: PPUSH
108837: PPUSH
108838: PPUSH
108839: PPUSH
108840: PPUSH
108841: PPUSH
108842: PPUSH
108843: PPUSH
108844: PPUSH
108845: PPUSH
108846: PPUSH
108847: PPUSH
108848: PPUSH
108849: PPUSH
108850: PPUSH
108851: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
108852: LD_ADDR_VAR 0 12
108856: PUSH
108857: LD_EXP 70
108861: PUSH
108862: LD_VAR 0 1
108866: ARRAY
108867: PPUSH
108868: LD_INT 25
108870: PUSH
108871: LD_INT 3
108873: PUSH
108874: EMPTY
108875: LIST
108876: LIST
108877: PPUSH
108878: CALL_OW 72
108882: ST_TO_ADDR
// if mc_remote_driver [ base ] then
108883: LD_EXP 110
108887: PUSH
108888: LD_VAR 0 1
108892: ARRAY
108893: IFFALSE 108917
// mechs := mechs diff mc_remote_driver [ base ] ;
108895: LD_ADDR_VAR 0 12
108899: PUSH
108900: LD_VAR 0 12
108904: PUSH
108905: LD_EXP 110
108909: PUSH
108910: LD_VAR 0 1
108914: ARRAY
108915: DIFF
108916: ST_TO_ADDR
// for i in mechs do
108917: LD_ADDR_VAR 0 4
108921: PUSH
108922: LD_VAR 0 12
108926: PUSH
108927: FOR_IN
108928: IFFALSE 108963
// if GetTag ( i ) > 0 then
108930: LD_VAR 0 4
108934: PPUSH
108935: CALL_OW 110
108939: PUSH
108940: LD_INT 0
108942: GREATER
108943: IFFALSE 108961
// mechs := mechs diff i ;
108945: LD_ADDR_VAR 0 12
108949: PUSH
108950: LD_VAR 0 12
108954: PUSH
108955: LD_VAR 0 4
108959: DIFF
108960: ST_TO_ADDR
108961: GO 108927
108963: POP
108964: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108965: LD_ADDR_VAR 0 8
108969: PUSH
108970: LD_EXP 70
108974: PUSH
108975: LD_VAR 0 1
108979: ARRAY
108980: PPUSH
108981: LD_INT 2
108983: PUSH
108984: LD_INT 25
108986: PUSH
108987: LD_INT 1
108989: PUSH
108990: EMPTY
108991: LIST
108992: LIST
108993: PUSH
108994: LD_INT 25
108996: PUSH
108997: LD_INT 5
108999: PUSH
109000: EMPTY
109001: LIST
109002: LIST
109003: PUSH
109004: LD_INT 25
109006: PUSH
109007: LD_INT 8
109009: PUSH
109010: EMPTY
109011: LIST
109012: LIST
109013: PUSH
109014: LD_INT 25
109016: PUSH
109017: LD_INT 9
109019: PUSH
109020: EMPTY
109021: LIST
109022: LIST
109023: PUSH
109024: EMPTY
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: LIST
109030: PPUSH
109031: CALL_OW 72
109035: ST_TO_ADDR
// if not defenders and not solds then
109036: LD_VAR 0 2
109040: NOT
109041: PUSH
109042: LD_VAR 0 8
109046: NOT
109047: AND
109048: IFFALSE 109052
// exit ;
109050: GO 110822
// depot_under_attack := false ;
109052: LD_ADDR_VAR 0 16
109056: PUSH
109057: LD_INT 0
109059: ST_TO_ADDR
// sold_defenders := [ ] ;
109060: LD_ADDR_VAR 0 17
109064: PUSH
109065: EMPTY
109066: ST_TO_ADDR
// if mechs then
109067: LD_VAR 0 12
109071: IFFALSE 109224
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
109073: LD_ADDR_VAR 0 4
109077: PUSH
109078: LD_VAR 0 2
109082: PPUSH
109083: LD_INT 21
109085: PUSH
109086: LD_INT 2
109088: PUSH
109089: EMPTY
109090: LIST
109091: LIST
109092: PPUSH
109093: CALL_OW 72
109097: PUSH
109098: FOR_IN
109099: IFFALSE 109222
// begin if GetTag ( i ) <> 20 then
109101: LD_VAR 0 4
109105: PPUSH
109106: CALL_OW 110
109110: PUSH
109111: LD_INT 20
109113: NONEQUAL
109114: IFFALSE 109128
// SetTag ( i , 20 ) ;
109116: LD_VAR 0 4
109120: PPUSH
109121: LD_INT 20
109123: PPUSH
109124: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
109128: LD_VAR 0 4
109132: PPUSH
109133: CALL_OW 263
109137: PUSH
109138: LD_INT 1
109140: EQUAL
109141: PUSH
109142: LD_VAR 0 4
109146: PPUSH
109147: CALL_OW 311
109151: NOT
109152: AND
109153: IFFALSE 109220
// begin un := mechs [ 1 ] ;
109155: LD_ADDR_VAR 0 10
109159: PUSH
109160: LD_VAR 0 12
109164: PUSH
109165: LD_INT 1
109167: ARRAY
109168: ST_TO_ADDR
// ComExit ( un ) ;
109169: LD_VAR 0 10
109173: PPUSH
109174: CALL 50680 0 1
// AddComEnterUnit ( un , i ) ;
109178: LD_VAR 0 10
109182: PPUSH
109183: LD_VAR 0 4
109187: PPUSH
109188: CALL_OW 180
// SetTag ( un , 19 ) ;
109192: LD_VAR 0 10
109196: PPUSH
109197: LD_INT 19
109199: PPUSH
109200: CALL_OW 109
// mechs := mechs diff un ;
109204: LD_ADDR_VAR 0 12
109208: PUSH
109209: LD_VAR 0 12
109213: PUSH
109214: LD_VAR 0 10
109218: DIFF
109219: ST_TO_ADDR
// end ; end ;
109220: GO 109098
109222: POP
109223: POP
// if solds then
109224: LD_VAR 0 8
109228: IFFALSE 109287
// for i in solds do
109230: LD_ADDR_VAR 0 4
109234: PUSH
109235: LD_VAR 0 8
109239: PUSH
109240: FOR_IN
109241: IFFALSE 109285
// if not GetTag ( i ) then
109243: LD_VAR 0 4
109247: PPUSH
109248: CALL_OW 110
109252: NOT
109253: IFFALSE 109283
// begin defenders := defenders union i ;
109255: LD_ADDR_VAR 0 2
109259: PUSH
109260: LD_VAR 0 2
109264: PUSH
109265: LD_VAR 0 4
109269: UNION
109270: ST_TO_ADDR
// SetTag ( i , 18 ) ;
109271: LD_VAR 0 4
109275: PPUSH
109276: LD_INT 18
109278: PPUSH
109279: CALL_OW 109
// end ;
109283: GO 109240
109285: POP
109286: POP
// repeat wait ( 0 0$2 ) ;
109287: LD_INT 70
109289: PPUSH
109290: CALL_OW 67
// enemy := mc_scan [ base ] ;
109294: LD_ADDR_VAR 0 21
109298: PUSH
109299: LD_EXP 93
109303: PUSH
109304: LD_VAR 0 1
109308: ARRAY
109309: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109310: LD_EXP 70
109314: PUSH
109315: LD_VAR 0 1
109319: ARRAY
109320: NOT
109321: PUSH
109322: LD_EXP 70
109326: PUSH
109327: LD_VAR 0 1
109331: ARRAY
109332: PUSH
109333: EMPTY
109334: EQUAL
109335: OR
109336: IFFALSE 109373
// begin for i in defenders do
109338: LD_ADDR_VAR 0 4
109342: PUSH
109343: LD_VAR 0 2
109347: PUSH
109348: FOR_IN
109349: IFFALSE 109362
// ComStop ( i ) ;
109351: LD_VAR 0 4
109355: PPUSH
109356: CALL_OW 141
109360: GO 109348
109362: POP
109363: POP
// defenders := [ ] ;
109364: LD_ADDR_VAR 0 2
109368: PUSH
109369: EMPTY
109370: ST_TO_ADDR
// exit ;
109371: GO 110822
// end ; for i in defenders do
109373: LD_ADDR_VAR 0 4
109377: PUSH
109378: LD_VAR 0 2
109382: PUSH
109383: FOR_IN
109384: IFFALSE 110282
// begin e := NearestUnitToUnit ( enemy , i ) ;
109386: LD_ADDR_VAR 0 13
109390: PUSH
109391: LD_VAR 0 21
109395: PPUSH
109396: LD_VAR 0 4
109400: PPUSH
109401: CALL_OW 74
109405: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109406: LD_ADDR_VAR 0 7
109410: PUSH
109411: LD_EXP 70
109415: PUSH
109416: LD_VAR 0 1
109420: ARRAY
109421: PPUSH
109422: LD_INT 2
109424: PUSH
109425: LD_INT 30
109427: PUSH
109428: LD_INT 0
109430: PUSH
109431: EMPTY
109432: LIST
109433: LIST
109434: PUSH
109435: LD_INT 30
109437: PUSH
109438: LD_INT 1
109440: PUSH
109441: EMPTY
109442: LIST
109443: LIST
109444: PUSH
109445: EMPTY
109446: LIST
109447: LIST
109448: LIST
109449: PPUSH
109450: CALL_OW 72
109454: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
109455: LD_ADDR_VAR 0 16
109459: PUSH
109460: LD_VAR 0 7
109464: NOT
109465: PUSH
109466: LD_VAR 0 7
109470: PPUSH
109471: LD_INT 3
109473: PUSH
109474: LD_INT 24
109476: PUSH
109477: LD_INT 600
109479: PUSH
109480: EMPTY
109481: LIST
109482: LIST
109483: PUSH
109484: EMPTY
109485: LIST
109486: LIST
109487: PPUSH
109488: CALL_OW 72
109492: OR
109493: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
109494: LD_VAR 0 4
109498: PPUSH
109499: CALL_OW 247
109503: PUSH
109504: LD_INT 2
109506: DOUBLE
109507: EQUAL
109508: IFTRUE 109512
109510: GO 109908
109512: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
109513: LD_VAR 0 4
109517: PPUSH
109518: CALL_OW 256
109522: PUSH
109523: LD_INT 1000
109525: EQUAL
109526: PUSH
109527: LD_VAR 0 4
109531: PPUSH
109532: LD_VAR 0 13
109536: PPUSH
109537: CALL_OW 296
109541: PUSH
109542: LD_INT 40
109544: LESS
109545: PUSH
109546: LD_VAR 0 13
109550: PPUSH
109551: LD_EXP 95
109555: PUSH
109556: LD_VAR 0 1
109560: ARRAY
109561: PPUSH
109562: CALL_OW 308
109566: OR
109567: AND
109568: IFFALSE 109690
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
109570: LD_VAR 0 4
109574: PPUSH
109575: CALL_OW 262
109579: PUSH
109580: LD_INT 1
109582: EQUAL
109583: PUSH
109584: LD_VAR 0 4
109588: PPUSH
109589: CALL_OW 261
109593: PUSH
109594: LD_INT 30
109596: LESS
109597: AND
109598: PUSH
109599: LD_VAR 0 7
109603: AND
109604: IFFALSE 109674
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
109606: LD_VAR 0 4
109610: PPUSH
109611: LD_VAR 0 7
109615: PPUSH
109616: LD_VAR 0 4
109620: PPUSH
109621: CALL_OW 74
109625: PPUSH
109626: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
109630: LD_VAR 0 4
109634: PPUSH
109635: LD_VAR 0 7
109639: PPUSH
109640: LD_VAR 0 4
109644: PPUSH
109645: CALL_OW 74
109649: PPUSH
109650: CALL_OW 296
109654: PUSH
109655: LD_INT 6
109657: LESS
109658: IFFALSE 109672
// SetFuel ( i , 100 ) ;
109660: LD_VAR 0 4
109664: PPUSH
109665: LD_INT 100
109667: PPUSH
109668: CALL_OW 240
// end else
109672: GO 109688
// ComAttackUnit ( i , e ) ;
109674: LD_VAR 0 4
109678: PPUSH
109679: LD_VAR 0 13
109683: PPUSH
109684: CALL_OW 115
// end else
109688: GO 109791
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
109690: LD_VAR 0 13
109694: PPUSH
109695: LD_EXP 95
109699: PUSH
109700: LD_VAR 0 1
109704: ARRAY
109705: PPUSH
109706: CALL_OW 308
109710: NOT
109711: PUSH
109712: LD_VAR 0 4
109716: PPUSH
109717: LD_VAR 0 13
109721: PPUSH
109722: CALL_OW 296
109726: PUSH
109727: LD_INT 40
109729: GREATEREQUAL
109730: AND
109731: PUSH
109732: LD_VAR 0 4
109736: PPUSH
109737: CALL_OW 256
109741: PUSH
109742: LD_INT 650
109744: LESSEQUAL
109745: OR
109746: PUSH
109747: LD_VAR 0 4
109751: PPUSH
109752: LD_EXP 94
109756: PUSH
109757: LD_VAR 0 1
109761: ARRAY
109762: PPUSH
109763: CALL_OW 308
109767: NOT
109768: AND
109769: IFFALSE 109791
// ComMoveToArea ( i , mc_parking [ base ] ) ;
109771: LD_VAR 0 4
109775: PPUSH
109776: LD_EXP 94
109780: PUSH
109781: LD_VAR 0 1
109785: ARRAY
109786: PPUSH
109787: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
109791: LD_VAR 0 4
109795: PPUSH
109796: CALL_OW 256
109800: PUSH
109801: LD_INT 1000
109803: LESS
109804: PUSH
109805: LD_VAR 0 4
109809: PPUSH
109810: CALL_OW 263
109814: PUSH
109815: LD_INT 1
109817: EQUAL
109818: AND
109819: PUSH
109820: LD_VAR 0 4
109824: PPUSH
109825: CALL_OW 311
109829: AND
109830: PUSH
109831: LD_VAR 0 4
109835: PPUSH
109836: LD_EXP 94
109840: PUSH
109841: LD_VAR 0 1
109845: ARRAY
109846: PPUSH
109847: CALL_OW 308
109851: AND
109852: IFFALSE 109906
// begin mech := IsDrivenBy ( i ) ;
109854: LD_ADDR_VAR 0 9
109858: PUSH
109859: LD_VAR 0 4
109863: PPUSH
109864: CALL_OW 311
109868: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
109869: LD_VAR 0 9
109873: PPUSH
109874: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
109878: LD_VAR 0 9
109882: PPUSH
109883: LD_VAR 0 4
109887: PPUSH
109888: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
109892: LD_VAR 0 9
109896: PPUSH
109897: LD_VAR 0 4
109901: PPUSH
109902: CALL_OW 180
// end ; end ; unit_human :
109906: GO 110253
109908: LD_INT 1
109910: DOUBLE
109911: EQUAL
109912: IFTRUE 109916
109914: GO 110252
109916: POP
// begin b := IsInUnit ( i ) ;
109917: LD_ADDR_VAR 0 18
109921: PUSH
109922: LD_VAR 0 4
109926: PPUSH
109927: CALL_OW 310
109931: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
109932: LD_ADDR_VAR 0 19
109936: PUSH
109937: LD_VAR 0 18
109941: NOT
109942: PUSH
109943: LD_VAR 0 18
109947: PPUSH
109948: CALL_OW 266
109952: PUSH
109953: LD_INT 32
109955: PUSH
109956: LD_INT 31
109958: PUSH
109959: EMPTY
109960: LIST
109961: LIST
109962: IN
109963: OR
109964: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
109965: LD_VAR 0 18
109969: PPUSH
109970: CALL_OW 266
109974: PUSH
109975: LD_INT 5
109977: EQUAL
109978: PUSH
109979: LD_VAR 0 4
109983: PPUSH
109984: CALL_OW 257
109988: PUSH
109989: LD_INT 1
109991: PUSH
109992: LD_INT 2
109994: PUSH
109995: LD_INT 3
109997: PUSH
109998: LD_INT 4
110000: PUSH
110001: EMPTY
110002: LIST
110003: LIST
110004: LIST
110005: LIST
110006: IN
110007: AND
110008: IFFALSE 110045
// begin class := AllowSpecClass ( i ) ;
110010: LD_ADDR_VAR 0 20
110014: PUSH
110015: LD_VAR 0 4
110019: PPUSH
110020: CALL 15397 0 1
110024: ST_TO_ADDR
// if class then
110025: LD_VAR 0 20
110029: IFFALSE 110045
// ComChangeProfession ( i , class ) ;
110031: LD_VAR 0 4
110035: PPUSH
110036: LD_VAR 0 20
110040: PPUSH
110041: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
110045: LD_VAR 0 16
110049: PUSH
110050: LD_VAR 0 2
110054: PPUSH
110055: LD_INT 21
110057: PUSH
110058: LD_INT 2
110060: PUSH
110061: EMPTY
110062: LIST
110063: LIST
110064: PPUSH
110065: CALL_OW 72
110069: PUSH
110070: LD_INT 1
110072: LESSEQUAL
110073: OR
110074: PUSH
110075: LD_VAR 0 19
110079: AND
110080: PUSH
110081: LD_VAR 0 4
110085: PUSH
110086: LD_VAR 0 17
110090: IN
110091: NOT
110092: AND
110093: IFFALSE 110186
// begin if b then
110095: LD_VAR 0 18
110099: IFFALSE 110148
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
110101: LD_VAR 0 18
110105: PPUSH
110106: LD_VAR 0 21
110110: PPUSH
110111: LD_VAR 0 18
110115: PPUSH
110116: CALL_OW 74
110120: PPUSH
110121: CALL_OW 296
110125: PUSH
110126: LD_INT 10
110128: LESS
110129: PUSH
110130: LD_VAR 0 18
110134: PPUSH
110135: CALL_OW 461
110139: PUSH
110140: LD_INT 7
110142: NONEQUAL
110143: AND
110144: IFFALSE 110148
// continue ;
110146: GO 109383
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
110148: LD_ADDR_VAR 0 17
110152: PUSH
110153: LD_VAR 0 17
110157: PPUSH
110158: LD_VAR 0 17
110162: PUSH
110163: LD_INT 1
110165: PLUS
110166: PPUSH
110167: LD_VAR 0 4
110171: PPUSH
110172: CALL_OW 1
110176: ST_TO_ADDR
// ComExitBuilding ( i ) ;
110177: LD_VAR 0 4
110181: PPUSH
110182: CALL_OW 122
// end ; if sold_defenders then
110186: LD_VAR 0 17
110190: IFFALSE 110250
// if i in sold_defenders then
110192: LD_VAR 0 4
110196: PUSH
110197: LD_VAR 0 17
110201: IN
110202: IFFALSE 110250
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
110204: LD_VAR 0 4
110208: PPUSH
110209: CALL_OW 314
110213: NOT
110214: PUSH
110215: LD_VAR 0 4
110219: PPUSH
110220: LD_VAR 0 13
110224: PPUSH
110225: CALL_OW 296
110229: PUSH
110230: LD_INT 30
110232: LESS
110233: AND
110234: IFFALSE 110250
// ComAttackUnit ( i , e ) ;
110236: LD_VAR 0 4
110240: PPUSH
110241: LD_VAR 0 13
110245: PPUSH
110246: CALL_OW 115
// end ; end ; end ;
110250: GO 110253
110252: POP
// if IsDead ( i ) then
110253: LD_VAR 0 4
110257: PPUSH
110258: CALL_OW 301
110262: IFFALSE 110280
// defenders := defenders diff i ;
110264: LD_ADDR_VAR 0 2
110268: PUSH
110269: LD_VAR 0 2
110273: PUSH
110274: LD_VAR 0 4
110278: DIFF
110279: ST_TO_ADDR
// end ;
110280: GO 109383
110282: POP
110283: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
110284: LD_VAR 0 21
110288: NOT
110289: PUSH
110290: LD_VAR 0 2
110294: NOT
110295: OR
110296: PUSH
110297: LD_EXP 70
110301: PUSH
110302: LD_VAR 0 1
110306: ARRAY
110307: NOT
110308: OR
110309: IFFALSE 109287
// MC_Reset ( base , 18 ) ;
110311: LD_VAR 0 1
110315: PPUSH
110316: LD_INT 18
110318: PPUSH
110319: CALL 58080 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110323: LD_ADDR_VAR 0 2
110327: PUSH
110328: LD_VAR 0 2
110332: PUSH
110333: LD_VAR 0 2
110337: PPUSH
110338: LD_INT 2
110340: PUSH
110341: LD_INT 25
110343: PUSH
110344: LD_INT 1
110346: PUSH
110347: EMPTY
110348: LIST
110349: LIST
110350: PUSH
110351: LD_INT 25
110353: PUSH
110354: LD_INT 5
110356: PUSH
110357: EMPTY
110358: LIST
110359: LIST
110360: PUSH
110361: LD_INT 25
110363: PUSH
110364: LD_INT 8
110366: PUSH
110367: EMPTY
110368: LIST
110369: LIST
110370: PUSH
110371: LD_INT 25
110373: PUSH
110374: LD_INT 9
110376: PUSH
110377: EMPTY
110378: LIST
110379: LIST
110380: PUSH
110381: EMPTY
110382: LIST
110383: LIST
110384: LIST
110385: LIST
110386: LIST
110387: PPUSH
110388: CALL_OW 72
110392: DIFF
110393: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
110394: LD_VAR 0 21
110398: NOT
110399: PUSH
110400: LD_VAR 0 2
110404: PPUSH
110405: LD_INT 21
110407: PUSH
110408: LD_INT 2
110410: PUSH
110411: EMPTY
110412: LIST
110413: LIST
110414: PPUSH
110415: CALL_OW 72
110419: AND
110420: IFFALSE 110758
// begin tmp := FilterByTag ( defenders , 19 ) ;
110422: LD_ADDR_VAR 0 11
110426: PUSH
110427: LD_VAR 0 2
110431: PPUSH
110432: LD_INT 19
110434: PPUSH
110435: CALL 47866 0 2
110439: ST_TO_ADDR
// if tmp then
110440: LD_VAR 0 11
110444: IFFALSE 110514
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
110446: LD_ADDR_VAR 0 11
110450: PUSH
110451: LD_VAR 0 11
110455: PPUSH
110456: LD_INT 25
110458: PUSH
110459: LD_INT 3
110461: PUSH
110462: EMPTY
110463: LIST
110464: LIST
110465: PPUSH
110466: CALL_OW 72
110470: ST_TO_ADDR
// if tmp then
110471: LD_VAR 0 11
110475: IFFALSE 110514
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
110477: LD_ADDR_EXP 82
110481: PUSH
110482: LD_EXP 82
110486: PPUSH
110487: LD_VAR 0 1
110491: PPUSH
110492: LD_EXP 82
110496: PUSH
110497: LD_VAR 0 1
110501: ARRAY
110502: PUSH
110503: LD_VAR 0 11
110507: UNION
110508: PPUSH
110509: CALL_OW 1
110513: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
110514: LD_VAR 0 1
110518: PPUSH
110519: LD_INT 19
110521: PPUSH
110522: CALL 58080 0 2
// repeat wait ( 0 0$1 ) ;
110526: LD_INT 35
110528: PPUSH
110529: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110533: LD_EXP 70
110537: PUSH
110538: LD_VAR 0 1
110542: ARRAY
110543: NOT
110544: PUSH
110545: LD_EXP 70
110549: PUSH
110550: LD_VAR 0 1
110554: ARRAY
110555: PUSH
110556: EMPTY
110557: EQUAL
110558: OR
110559: IFFALSE 110596
// begin for i in defenders do
110561: LD_ADDR_VAR 0 4
110565: PUSH
110566: LD_VAR 0 2
110570: PUSH
110571: FOR_IN
110572: IFFALSE 110585
// ComStop ( i ) ;
110574: LD_VAR 0 4
110578: PPUSH
110579: CALL_OW 141
110583: GO 110571
110585: POP
110586: POP
// defenders := [ ] ;
110587: LD_ADDR_VAR 0 2
110591: PUSH
110592: EMPTY
110593: ST_TO_ADDR
// exit ;
110594: GO 110822
// end ; for i in defenders do
110596: LD_ADDR_VAR 0 4
110600: PUSH
110601: LD_VAR 0 2
110605: PUSH
110606: FOR_IN
110607: IFFALSE 110696
// begin if not IsInArea ( i , mc_parking [ base ] ) then
110609: LD_VAR 0 4
110613: PPUSH
110614: LD_EXP 94
110618: PUSH
110619: LD_VAR 0 1
110623: ARRAY
110624: PPUSH
110625: CALL_OW 308
110629: NOT
110630: IFFALSE 110654
// ComMoveToArea ( i , mc_parking [ base ] ) else
110632: LD_VAR 0 4
110636: PPUSH
110637: LD_EXP 94
110641: PUSH
110642: LD_VAR 0 1
110646: ARRAY
110647: PPUSH
110648: CALL_OW 113
110652: GO 110694
// if GetControl ( i ) = control_manual then
110654: LD_VAR 0 4
110658: PPUSH
110659: CALL_OW 263
110663: PUSH
110664: LD_INT 1
110666: EQUAL
110667: IFFALSE 110694
// if IsDrivenBy ( i ) then
110669: LD_VAR 0 4
110673: PPUSH
110674: CALL_OW 311
110678: IFFALSE 110694
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
110680: LD_VAR 0 4
110684: PPUSH
110685: CALL_OW 311
110689: PPUSH
110690: CALL_OW 121
// end ;
110694: GO 110606
110696: POP
110697: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
110698: LD_VAR 0 2
110702: PPUSH
110703: LD_INT 95
110705: PUSH
110706: LD_EXP 94
110710: PUSH
110711: LD_VAR 0 1
110715: ARRAY
110716: PUSH
110717: EMPTY
110718: LIST
110719: LIST
110720: PPUSH
110721: CALL_OW 72
110725: PUSH
110726: LD_VAR 0 2
110730: EQUAL
110731: PUSH
110732: LD_EXP 93
110736: PUSH
110737: LD_VAR 0 1
110741: ARRAY
110742: OR
110743: PUSH
110744: LD_EXP 70
110748: PUSH
110749: LD_VAR 0 1
110753: ARRAY
110754: NOT
110755: OR
110756: IFFALSE 110526
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
110758: LD_ADDR_EXP 92
110762: PUSH
110763: LD_EXP 92
110767: PPUSH
110768: LD_VAR 0 1
110772: PPUSH
110773: LD_VAR 0 2
110777: PPUSH
110778: LD_INT 21
110780: PUSH
110781: LD_INT 2
110783: PUSH
110784: EMPTY
110785: LIST
110786: LIST
110787: PPUSH
110788: CALL_OW 72
110792: PPUSH
110793: CALL_OW 1
110797: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
110798: LD_VAR 0 1
110802: PPUSH
110803: LD_INT 19
110805: PPUSH
110806: CALL 58080 0 2
// MC_Reset ( base , 20 ) ;
110810: LD_VAR 0 1
110814: PPUSH
110815: LD_INT 20
110817: PPUSH
110818: CALL 58080 0 2
// end ; end_of_file
110822: LD_VAR 0 3
110826: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
110827: LD_VAR 0 1
110831: PUSH
110832: LD_INT 200
110834: DOUBLE
110835: GREATEREQUAL
110836: IFFALSE 110844
110838: LD_INT 299
110840: DOUBLE
110841: LESSEQUAL
110842: IFTRUE 110846
110844: GO 110878
110846: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
110847: LD_VAR 0 1
110851: PPUSH
110852: LD_VAR 0 2
110856: PPUSH
110857: LD_VAR 0 3
110861: PPUSH
110862: LD_VAR 0 4
110866: PPUSH
110867: LD_VAR 0 5
110871: PPUSH
110872: CALL 99264 0 5
110876: GO 110955
110878: LD_INT 300
110880: DOUBLE
110881: GREATEREQUAL
110882: IFFALSE 110890
110884: LD_INT 399
110886: DOUBLE
110887: LESSEQUAL
110888: IFTRUE 110892
110890: GO 110954
110892: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
110893: LD_VAR 0 1
110897: PPUSH
110898: LD_VAR 0 2
110902: PPUSH
110903: LD_VAR 0 3
110907: PPUSH
110908: LD_VAR 0 4
110912: PPUSH
110913: LD_VAR 0 5
110917: PPUSH
110918: LD_VAR 0 6
110922: PPUSH
110923: LD_VAR 0 7
110927: PPUSH
110928: LD_VAR 0 8
110932: PPUSH
110933: LD_VAR 0 9
110937: PPUSH
110938: LD_VAR 0 10
110942: PPUSH
110943: LD_VAR 0 11
110947: PPUSH
110948: CALL 96906 0 11
110952: GO 110955
110954: POP
// end ;
110955: PPOPN 11
110957: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
110958: LD_VAR 0 1
110962: PPUSH
110963: LD_VAR 0 2
110967: PPUSH
110968: LD_VAR 0 3
110972: PPUSH
110973: LD_VAR 0 4
110977: PPUSH
110978: LD_VAR 0 5
110982: PPUSH
110983: CALL 99000 0 5
// end ; end_of_file
110987: PPOPN 5
110989: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110990: LD_VAR 0 1
110994: PPUSH
110995: LD_VAR 0 2
110999: PPUSH
111000: LD_VAR 0 3
111004: PPUSH
111005: LD_VAR 0 4
111009: PPUSH
111010: LD_VAR 0 5
111014: PPUSH
111015: LD_VAR 0 6
111019: PPUSH
111020: CALL 84599 0 6
// end ;
111024: PPOPN 6
111026: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
111027: CALL 84574 0 0
// end ;
111031: PPOPN 1
111033: END
