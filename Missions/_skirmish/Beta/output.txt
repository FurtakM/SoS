// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12724 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 50
 744: PUSH
 745: LD_EXP 50
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 50
 777: PUSH
 778: LD_EXP 50
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 57204 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12581 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12581 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 50
1974: PUSH
1975: LD_EXP 50
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18626 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18626 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18626 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18626 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18626 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 80581 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 80525 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 79584 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 80413 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 80095 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 79826 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 79445 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 79260 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 79152 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 80002 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 80207 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 80581 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 80525 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 79584 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 80413 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 80095 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 79826 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 79445 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 79260 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 79152 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 80002 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 80207 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 79308 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 79308 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 79308 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 79656 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 69
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 72
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 69
7660: PUSH
7661: LD_EXP 69
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 69
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 50
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 79308 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 79308 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 79308 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 80726 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 69
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 72
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 69
8875: PUSH
8876: LD_EXP 69
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 69
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 50
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18626 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18626 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18626 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18626 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18626 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18626 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL 101490 0 1
// if un = Brighton then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_EXP 9
11276: EQUAL
11277: IFFALSE 11293
// begin wait ( 0 0$1 ) ;
11279: LD_INT 35
11281: PPUSH
11282: CALL_OW 67
// YouLost ( Brighton ) ;
11286: LD_STRING Brighton
11288: PPUSH
11289: CALL_OW 104
// end ; if un = JMM then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_EXP 37
11302: EQUAL
11303: IFFALSE 11319
// begin wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// YouLost ( JMM ) ;
11312: LD_STRING JMM
11314: PPUSH
11315: CALL_OW 104
// end ; if un = Megan then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_EXP 11
11328: EQUAL
11329: IFFALSE 11343
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11331: LD_EXP 9
11335: PPUSH
11336: LD_STRING DBrighton-MeganDeath
11338: PPUSH
11339: CALL_OW 88
// end ; if un = Palmer then
11343: LD_VAR 0 1
11347: PUSH
11348: LD_EXP 10
11352: EQUAL
11353: IFFALSE 11367
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING DBrighton-PalmerDeath
11362: PPUSH
11363: CALL_OW 88
// end ; if un = Burlak then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11409
// begin if JMM_Arrived then
11379: LD_EXP 6
11383: IFFALSE 11397
// Say ( JMM , DJMM-BurlakDead ) ;
11385: LD_EXP 37
11389: PPUSH
11390: LD_STRING DJMM-BurlakDead
11392: PPUSH
11393: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11397: LD_EXP 10
11401: PPUSH
11402: LD_STRING DSol-BurlakDead
11404: PPUSH
11405: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 1
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_INT 3
11425: EQUAL
11426: OR
11427: IFFALSE 11443
// begin wait ( 0 0$1 ) ;
11429: LD_INT 35
11431: PPUSH
11432: CALL_OW 67
// YouLost ( Depot ) ;
11436: LD_STRING Depot
11438: PPUSH
11439: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 255
11452: PUSH
11453: LD_INT 1
11455: EQUAL
11456: PUSH
11457: LD_VAR 0 1
11461: PPUSH
11462: CALL_OW 247
11466: PUSH
11467: LD_INT 1
11469: EQUAL
11470: AND
11471: IFFALSE 11487
// Losses := Losses + 1 ;
11473: LD_ADDR_EXP 45
11477: PUSH
11478: LD_EXP 45
11482: PUSH
11483: LD_INT 1
11485: PLUS
11486: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: CALL 82712 0 1
// end ;
11496: PPOPN 1
11498: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11499: LD_VAR 0 1
11503: PPUSH
11504: CALL_OW 247
11508: PUSH
11509: LD_INT 2
11511: EQUAL
11512: PUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_EXP 17
11522: IN
11523: AND
11524: IFFALSE 11538
// SetLives ( un , 0 ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: LD_INT 0
11533: PPUSH
11534: CALL_OW 234
// if un = Yashin then
11538: LD_VAR 0 1
11542: PUSH
11543: LD_EXP 13
11547: EQUAL
11548: IFFALSE 11562
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11550: LD_EXP 13
11554: PPUSH
11555: LD_STRING DDeath-Yas-3
11557: PPUSH
11558: CALL_OW 91
// if un = Popov then
11562: LD_VAR 0 1
11566: PUSH
11567: LD_EXP 14
11571: EQUAL
11572: IFFALSE 11586
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11574: LD_EXP 14
11578: PPUSH
11579: LD_STRING DDeath-Pop-3
11581: PPUSH
11582: CALL_OW 91
// if un = Gaydar then
11586: LD_VAR 0 1
11590: PUSH
11591: LD_EXP 15
11595: EQUAL
11596: IFFALSE 11610
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11598: LD_EXP 15
11602: PPUSH
11603: LD_STRING DDeath-Gay-3
11605: PPUSH
11606: CALL_OW 91
// if un = Sevi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 16
11619: EQUAL
11620: IFFALSE 11634
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11622: LD_EXP 16
11626: PPUSH
11627: LD_STRING DDeath-Vse-3
11629: PPUSH
11630: CALL_OW 91
// end ;
11634: PPOPN 1
11636: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11637: LD_VAR 0 1
11641: PUSH
11642: LD_INT 10
11644: EQUAL
11645: IFFALSE 11683
// begin Say ( Brighton , DBrighton-C1 ) ;
11647: LD_EXP 9
11651: PPUSH
11652: LD_STRING DBrighton-C1
11654: PPUSH
11655: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_STRING DMegan-C1
11666: PPUSH
11667: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11671: LD_EXP 9
11675: PPUSH
11676: LD_STRING DBrighton-C2
11678: PPUSH
11679: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: CALL 82408 0 2
// end ;
11697: PPOPN 2
11699: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_VAR 0 2
11709: PPUSH
11710: CALL 85044 0 2
// end ;
11714: PPOPN 2
11716: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11717: LD_VAR 0 1
11721: PPUSH
11722: CALL 84112 0 1
// end ;
11726: PPOPN 1
11728: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 266
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 1
11747: PPUSH
11748: CALL_OW 255
11752: PUSH
11753: LD_INT 3
11755: EQUAL
11756: AND
11757: IFFALSE 11819
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 274
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 10000
11774: PPUSH
11775: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 274
11788: PPUSH
11789: LD_INT 2
11791: PPUSH
11792: LD_INT 250
11794: PPUSH
11795: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 274
11808: PPUSH
11809: LD_INT 3
11811: PPUSH
11812: LD_INT 100
11814: PPUSH
11815: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL 84353 0 1
// end ;
11828: PPOPN 1
11830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_VAR 0 2
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: LD_VAR 0 5
11855: PPUSH
11856: CALL 82028 0 5
// end ;
11860: PPOPN 5
11862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11863: LD_VAR 0 1
11867: PPUSH
11868: LD_VAR 0 2
11872: PPUSH
11873: CALL 81619 0 2
// end ;
11877: PPOPN 2
11879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL 81457 0 4
// end ;
11904: PPOPN 4
11906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_VAR 0 2
11916: PPUSH
11917: LD_VAR 0 3
11921: PPUSH
11922: CALL 81232 0 3
// end ;
11926: PPOPN 3
11928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: CALL 81117 0 2
// end ;
11943: PPOPN 2
11945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_VAR 0 2
11955: PPUSH
11956: CALL 85339 0 2
// end ;
11960: PPOPN 2
11962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 255
11972: PUSH
11973: LD_INT 6
11975: EQUAL
11976: IFFALSE 12106
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_EXP 13
11987: PUSH
11988: LD_EXP 16
11992: PUSH
11993: LD_EXP 15
11997: PUSH
11998: LD_EXP 14
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: IN
12009: IFFALSE 12013
// exit ;
12011: GO 12130
// if AssaultStarted then
12013: LD_EXP 8
12017: IFFALSE 12091
// case Rand ( 1 , 4 ) of 1 .. 3 :
12019: LD_INT 1
12021: PPUSH
12022: LD_INT 4
12024: PPUSH
12025: CALL_OW 12
12029: PUSH
12030: LD_INT 1
12032: DOUBLE
12033: GREATEREQUAL
12034: IFFALSE 12042
12036: LD_INT 3
12038: DOUBLE
12039: LESSEQUAL
12040: IFTRUE 12044
12042: GO 12062
12044: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 67
12052: PPUSH
12053: LD_INT 37
12055: PPUSH
12056: CALL_OW 114
12060: GO 12089
12062: LD_INT 4
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12088
12070: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_INT 120
12078: PPUSH
12079: LD_INT 131
12081: PPUSH
12082: CALL_OW 111
12086: GO 12089
12088: POP
12089: GO 12106
// ComMoveXY ( driver , 120 , 131 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 120
12098: PPUSH
12099: LD_INT 131
12101: PPUSH
12102: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12106: LD_VAR 0 1
12110: PPUSH
12111: LD_VAR 0 2
12115: PPUSH
12116: LD_VAR 0 3
12120: PPUSH
12121: LD_VAR 0 4
12125: PPUSH
12126: CALL 85555 0 4
// end ;
12130: PPOPN 4
12132: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12133: LD_VAR 0 1
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 80926 0 2
// end ;
12147: PPOPN 2
12149: END
// on Command ( cmd ) do var i ;
12150: LD_INT 0
12152: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12153: LD_VAR 0 1
12157: PUSH
12158: LD_INT 77
12160: EQUAL
12161: PUSH
12162: LD_EXP 2
12166: AND
12167: IFFALSE 12243
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12169: LD_ADDR_VAR 0 2
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_INT 1
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 2
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 21
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PPUSH
12216: CALL_OW 69
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12241
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 20
12231: PPUSH
12232: LD_INT 19
12234: PPUSH
12235: CALL 51743 0 3
12239: GO 12221
12241: POP
12242: POP
// end ; SOS_Command ( cmd ) ;
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL 101594 0 1
// end ;
12252: PPOPN 2
12254: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12255: LD_EXP 2
12259: PUSH
12260: LD_INT 16
12262: PPUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 1
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 1
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 21
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 70
12309: AND
12310: IFFALSE 12396
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin enable ;
12318: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 16
12326: PPUSH
12327: LD_INT 22
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 2
12339: PUSH
12340: LD_INT 21
12342: PUSH
12343: LD_INT 1
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 2
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PPUSH
12369: CALL_OW 70
12373: PUSH
12374: FOR_IN
12375: IFFALSE 12394
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12377: LD_VAR 0 1
12381: PPUSH
12382: LD_INT 18
12384: PPUSH
12385: LD_INT 19
12387: PPUSH
12388: CALL 51743 0 3
12392: GO 12374
12394: POP
12395: POP
// end ; end_of_file
12396: PPOPN 1
12398: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12399: LD_EXP 6
12403: PUSH
12404: LD_EXP 44
12408: AND
12409: IFFALSE 12580
12411: GO 12413
12413: DISABLE
// begin wait ( 0 0$2 ) ;
12414: LD_INT 70
12416: PPUSH
12417: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12421: LD_EXP 9
12425: PPUSH
12426: LD_STRING DBrighton-G1
12428: PPUSH
12429: CALL_OW 88
// if Losses < 1 then
12433: LD_EXP 45
12437: PUSH
12438: LD_INT 1
12440: LESS
12441: IFFALSE 12455
// AddMedal ( Losses , 1 ) else
12443: LD_STRING Losses
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: CALL_OW 101
12453: GO 12488
// if Losses < 5 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 5
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 2 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 2
12470: PPUSH
12471: CALL_OW 101
12475: GO 12488
// AddMedal ( Losses , - 1 ) ;
12477: LD_STRING Losses
12479: PPUSH
12480: LD_INT 1
12482: NEG
12483: PPUSH
12484: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12488: LD_EXP 7
12492: PUSH
12493: LD_INT 10
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 321
12503: PUSH
12504: LD_INT 2
12506: EQUAL
12507: AND
12508: IFFALSE 12522
// AddMedal ( Laser , 1 ) else
12510: LD_STRING Laser
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 101
12520: GO 12569
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12522: LD_EXP 7
12526: NOT
12527: PUSH
12528: LD_INT 10
12530: PPUSH
12531: LD_INT 1
12533: PPUSH
12534: CALL_OW 321
12538: PUSH
12539: LD_INT 2
12541: EQUAL
12542: AND
12543: IFFALSE 12558
// AddMedal ( Laser , - 1 ) else
12545: LD_STRING Laser
12547: PPUSH
12548: LD_INT 1
12550: NEG
12551: PPUSH
12552: CALL_OW 101
12556: GO 12569
// AddMedal ( Laser , - 2 ) ;
12558: LD_STRING Laser
12560: PPUSH
12561: LD_INT 2
12563: NEG
12564: PPUSH
12565: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12569: LD_STRING BaseMain
12571: PPUSH
12572: CALL_OW 102
// YouWin ;
12576: CALL_OW 103
// end ; end_of_file
12580: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12581: LD_INT 0
12583: PPUSH
12584: PPUSH
// area = ListEnvironmentArea ( area ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: CALL_OW 353
12599: ST_TO_ADDR
// if bulldozer > 0 then
12600: LD_VAR 0 1
12604: PUSH
12605: LD_INT 0
12607: GREATER
12608: IFFALSE 12719
// for i = area downto 1 do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: DOUBLE
12616: LD_VAR 0 2
12620: INC
12621: ST_TO_ADDR
12622: LD_INT 1
12624: PUSH
12625: FOR_DOWNTO
12626: IFFALSE 12717
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 351
12662: IFFALSE 12715
// if not HasTask ( bulldozer ) then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 314
12673: NOT
12674: IFFALSE 12715
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PUSH
12692: LD_INT 1
12694: ARRAY
12695: PPUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PUSH
12707: LD_INT 2
12709: ARRAY
12710: PPUSH
12711: CALL_OW 171
12715: GO 12625
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
12732: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12733: LD_ADDR_VAR 0 8
12737: PUSH
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_INT 22
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 21
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: PPUSH
12778: CALL_OW 72
12782: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12783: LD_ADDR_VAR 0 9
12787: PUSH
12788: LD_VAR 0 1
12792: PPUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 21
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 3
12815: PUSH
12816: LD_INT 25
12818: PUSH
12819: LD_INT 1
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 72
12839: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12840: LD_ADDR_EXP 47
12844: PUSH
12845: LD_VAR 0 8
12849: PPUSH
12850: LD_VAR 0 9
12854: PPUSH
12855: CALL 13248 0 2
12859: ST_TO_ADDR
// offset = 0 ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// for i := 1 to sold_team do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 8
12882: PUSH
12883: FOR_TO
12884: IFFALSE 13015
// begin if IsInUnit ( sold_team [ i ] ) then
12886: LD_VAR 0 8
12890: PUSH
12891: LD_VAR 0 4
12895: ARRAY
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12918
// ComExitBuilding ( sold_team [ i ] ) ;
12903: LD_VAR 0 8
12907: PUSH
12908: LD_VAR 0 4
12912: ARRAY
12913: PPUSH
12914: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12918: LD_VAR 0 8
12922: PUSH
12923: LD_VAR 0 4
12927: ARRAY
12928: PPUSH
12929: LD_EXP 47
12933: PUSH
12934: LD_INT 1
12936: ARRAY
12937: PUSH
12938: LD_VAR 0 4
12942: PUSH
12943: LD_VAR 0 7
12947: PLUS
12948: ARRAY
12949: PPUSH
12950: LD_EXP 47
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: PUSH
12959: LD_VAR 0 4
12963: PUSH
12964: LD_INT 1
12966: PLUS
12967: PUSH
12968: LD_VAR 0 7
12972: PLUS
12973: ARRAY
12974: PPUSH
12975: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12979: LD_VAR 0 8
12983: PUSH
12984: LD_VAR 0 4
12988: ARRAY
12989: PPUSH
12990: LD_EXP 9
12994: PPUSH
12995: CALL_OW 179
// offset = offset + 1 ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 7
13008: PUSH
13009: LD_INT 1
13011: PLUS
13012: ST_TO_ADDR
// end ;
13013: GO 12883
13015: POP
13016: POP
// offset = 0 ;
13017: LD_ADDR_VAR 0 7
13021: PUSH
13022: LD_INT 0
13024: ST_TO_ADDR
// tmp = 1 ;
13025: LD_ADDR_VAR 0 6
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// for i := 2 to rows do
13033: LD_ADDR_VAR 0 4
13037: PUSH
13038: DOUBLE
13039: LD_INT 2
13041: DEC
13042: ST_TO_ADDR
13043: LD_EXP 47
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13241
// begin for x := 1 to sold_team do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13229
// begin if IsInUnit ( civil_team [ tmp ] ) then
13069: LD_VAR 0 9
13073: PUSH
13074: LD_VAR 0 6
13078: ARRAY
13079: PPUSH
13080: CALL_OW 310
13084: IFFALSE 13101
// ComExitBuilding ( civil_team [ tmp ] ) ;
13086: LD_VAR 0 9
13090: PUSH
13091: LD_VAR 0 6
13095: ARRAY
13096: PPUSH
13097: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13101: LD_VAR 0 9
13105: PUSH
13106: LD_VAR 0 6
13110: ARRAY
13111: PPUSH
13112: LD_EXP 47
13116: PUSH
13117: LD_VAR 0 4
13121: ARRAY
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: PLUS
13133: ARRAY
13134: PPUSH
13135: LD_EXP 47
13139: PUSH
13140: LD_VAR 0 4
13144: ARRAY
13145: PUSH
13146: LD_VAR 0 5
13150: PUSH
13151: LD_INT 1
13153: PLUS
13154: PUSH
13155: LD_VAR 0 7
13159: PLUS
13160: ARRAY
13161: PPUSH
13162: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13166: LD_VAR 0 9
13170: PUSH
13171: LD_VAR 0 6
13175: ARRAY
13176: PPUSH
13177: LD_EXP 9
13181: PPUSH
13182: CALL_OW 179
// offset = offset + 1 ;
13186: LD_ADDR_VAR 0 7
13190: PUSH
13191: LD_VAR 0 7
13195: PUSH
13196: LD_INT 1
13198: PLUS
13199: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13200: LD_VAR 0 6
13204: PUSH
13205: LD_VAR 0 9
13209: EQUAL
13210: NOT
13211: IFFALSE 13227
// tmp = tmp + 1 ;
13213: LD_ADDR_VAR 0 6
13217: PUSH
13218: LD_VAR 0 6
13222: PUSH
13223: LD_INT 1
13225: PLUS
13226: ST_TO_ADDR
// end ;
13227: GO 13066
13229: POP
13230: POP
// offset = 0 ;
13231: LD_ADDR_VAR 0 7
13235: PUSH
13236: LD_INT 0
13238: ST_TO_ADDR
// end ;
13239: GO 13048
13241: POP
13242: POP
// end ;
13243: LD_VAR 0 3
13247: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
// start_pos = [ 65 , 34 ] ;
13260: LD_ADDR_VAR 0 6
13264: PUSH
13265: LD_INT 65
13267: PUSH
13268: LD_INT 34
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
// row_size = 0 ;
13275: LD_ADDR_VAR 0 7
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// result_rows = [ ] ;
13283: LD_ADDR_VAR 0 9
13287: PUSH
13288: EMPTY
13289: ST_TO_ADDR
// new_row = [ ] ;
13290: LD_ADDR_VAR 0 8
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// for i := 1 to sold_team do
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: DOUBLE
13303: LD_INT 1
13305: DEC
13306: ST_TO_ADDR
13307: LD_VAR 0 1
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13367
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_VAR 0 8
13324: PUSH
13325: LD_VAR 0 6
13329: PUSH
13330: LD_INT 1
13332: ARRAY
13333: ADD
13334: PUSH
13335: LD_VAR 0 6
13339: PUSH
13340: LD_INT 2
13342: ARRAY
13343: PUSH
13344: LD_VAR 0 4
13348: PLUS
13349: ADD
13350: ST_TO_ADDR
// row_size = row_size + 1 ;
13351: LD_ADDR_VAR 0 7
13355: PUSH
13356: LD_VAR 0 7
13360: PUSH
13361: LD_INT 1
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13312
13367: POP
13368: POP
// result_rows = result_rows ^ [ new_row ] ;
13369: LD_ADDR_VAR 0 9
13373: PUSH
13374: LD_VAR 0 9
13378: PUSH
13379: LD_VAR 0 8
13383: PUSH
13384: EMPTY
13385: LIST
13386: ADD
13387: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13388: LD_ADDR_VAR 0 10
13392: PUSH
13393: LD_VAR 0 2
13397: PUSH
13398: LD_VAR 0 1
13402: DIV
13403: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13404: LD_VAR 0 10
13408: PUSH
13409: LD_VAR 0 1
13413: MOD
13414: PUSH
13415: LD_INT 0
13417: GREATER
13418: IFFALSE 13434
// civil_rows = civil_rows + 1 ;
13420: LD_ADDR_VAR 0 10
13424: PUSH
13425: LD_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ST_TO_ADDR
// offsetX = 2 ;
13434: LD_ADDR_VAR 0 11
13438: PUSH
13439: LD_INT 2
13441: ST_TO_ADDR
// offsetY = 1 ;
13442: LD_ADDR_VAR 0 12
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// for i := 1 to civil_rows do
13450: LD_ADDR_VAR 0 4
13454: PUSH
13455: DOUBLE
13456: LD_INT 1
13458: DEC
13459: ST_TO_ADDR
13460: LD_VAR 0 10
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13594
// begin new_row = [ ] ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: EMPTY
13474: ST_TO_ADDR
// for x := 1 to row_size do
13475: LD_ADDR_VAR 0 5
13479: PUSH
13480: DOUBLE
13481: LD_INT 1
13483: DEC
13484: ST_TO_ADDR
13485: LD_VAR 0 7
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13543
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13493: LD_ADDR_VAR 0 8
13497: PUSH
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 6
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_VAR 0 11
13516: PLUS
13517: ADD
13518: PUSH
13519: LD_VAR 0 6
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: PUSH
13528: LD_VAR 0 12
13532: PLUS
13533: PUSH
13534: LD_VAR 0 5
13538: PLUS
13539: ADD
13540: ST_TO_ADDR
// end ;
13541: GO 13490
13543: POP
13544: POP
// result_rows = result_rows ^ [ new_row ] ;
13545: LD_ADDR_VAR 0 9
13549: PUSH
13550: LD_VAR 0 9
13554: PUSH
13555: LD_VAR 0 8
13559: PUSH
13560: EMPTY
13561: LIST
13562: ADD
13563: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13564: LD_ADDR_VAR 0 11
13568: PUSH
13569: LD_VAR 0 11
13573: PUSH
13574: LD_INT 2
13576: PLUS
13577: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13578: LD_ADDR_VAR 0 12
13582: PUSH
13583: LD_VAR 0 12
13587: PUSH
13588: LD_INT 1
13590: PLUS
13591: ST_TO_ADDR
// end ;
13592: GO 13465
13594: POP
13595: POP
// result = result_rows ;
13596: LD_ADDR_VAR 0 3
13600: PUSH
13601: LD_VAR 0 9
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 3
13610: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
// if exist_mode then
13615: LD_VAR 0 2
13619: IFFALSE 13644
// unit := CreateCharacter ( prefix & ident ) else
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_VAR 0 3
13630: PUSH
13631: LD_VAR 0 1
13635: STR
13636: PPUSH
13637: CALL_OW 34
13641: ST_TO_ADDR
13642: GO 13659
// unit := NewCharacter ( ident ) ;
13644: LD_ADDR_VAR 0 5
13648: PUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 25
13658: ST_TO_ADDR
// result := unit ;
13659: LD_ADDR_VAR 0 4
13663: PUSH
13664: LD_VAR 0 5
13668: ST_TO_ADDR
// end ;
13669: LD_VAR 0 4
13673: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13674: LD_INT 0
13676: PPUSH
13677: PPUSH
// if not side or not nation then
13678: LD_VAR 0 1
13682: NOT
13683: PUSH
13684: LD_VAR 0 2
13688: NOT
13689: OR
13690: IFFALSE 13694
// exit ;
13692: GO 14462
// case nation of nation_american :
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 1
13701: DOUBLE
13702: EQUAL
13703: IFTRUE 13707
13705: GO 13921
13707: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13708: LD_ADDR_VAR 0 4
13712: PUSH
13713: LD_INT 35
13715: PUSH
13716: LD_INT 45
13718: PUSH
13719: LD_INT 46
13721: PUSH
13722: LD_INT 47
13724: PUSH
13725: LD_INT 82
13727: PUSH
13728: LD_INT 83
13730: PUSH
13731: LD_INT 84
13733: PUSH
13734: LD_INT 85
13736: PUSH
13737: LD_INT 86
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: LD_INT 2
13745: PUSH
13746: LD_INT 6
13748: PUSH
13749: LD_INT 15
13751: PUSH
13752: LD_INT 16
13754: PUSH
13755: LD_INT 7
13757: PUSH
13758: LD_INT 12
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: LD_INT 20
13772: PUSH
13773: LD_INT 21
13775: PUSH
13776: LD_INT 22
13778: PUSH
13779: LD_INT 25
13781: PUSH
13782: LD_INT 32
13784: PUSH
13785: LD_INT 27
13787: PUSH
13788: LD_INT 36
13790: PUSH
13791: LD_INT 69
13793: PUSH
13794: LD_INT 39
13796: PUSH
13797: LD_INT 34
13799: PUSH
13800: LD_INT 40
13802: PUSH
13803: LD_INT 48
13805: PUSH
13806: LD_INT 49
13808: PUSH
13809: LD_INT 50
13811: PUSH
13812: LD_INT 51
13814: PUSH
13815: LD_INT 52
13817: PUSH
13818: LD_INT 53
13820: PUSH
13821: LD_INT 54
13823: PUSH
13824: LD_INT 55
13826: PUSH
13827: LD_INT 56
13829: PUSH
13830: LD_INT 57
13832: PUSH
13833: LD_INT 58
13835: PUSH
13836: LD_INT 59
13838: PUSH
13839: LD_INT 60
13841: PUSH
13842: LD_INT 61
13844: PUSH
13845: LD_INT 62
13847: PUSH
13848: LD_INT 80
13850: PUSH
13851: LD_INT 82
13853: PUSH
13854: LD_INT 83
13856: PUSH
13857: LD_INT 84
13859: PUSH
13860: LD_INT 85
13862: PUSH
13863: LD_INT 86
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: ST_TO_ADDR
13919: GO 14386
13921: LD_INT 2
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 14155
13929: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_INT 35
13937: PUSH
13938: LD_INT 45
13940: PUSH
13941: LD_INT 46
13943: PUSH
13944: LD_INT 47
13946: PUSH
13947: LD_INT 82
13949: PUSH
13950: LD_INT 83
13952: PUSH
13953: LD_INT 84
13955: PUSH
13956: LD_INT 85
13958: PUSH
13959: LD_INT 87
13961: PUSH
13962: LD_INT 70
13964: PUSH
13965: LD_INT 1
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: LD_INT 5
13979: PUSH
13980: LD_INT 6
13982: PUSH
13983: LD_INT 15
13985: PUSH
13986: LD_INT 18
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: LD_INT 17
13994: PUSH
13995: LD_INT 8
13997: PUSH
13998: LD_INT 20
14000: PUSH
14001: LD_INT 21
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 72
14009: PUSH
14010: LD_INT 26
14012: PUSH
14013: LD_INT 69
14015: PUSH
14016: LD_INT 39
14018: PUSH
14019: LD_INT 40
14021: PUSH
14022: LD_INT 41
14024: PUSH
14025: LD_INT 42
14027: PUSH
14028: LD_INT 43
14030: PUSH
14031: LD_INT 48
14033: PUSH
14034: LD_INT 49
14036: PUSH
14037: LD_INT 50
14039: PUSH
14040: LD_INT 51
14042: PUSH
14043: LD_INT 52
14045: PUSH
14046: LD_INT 53
14048: PUSH
14049: LD_INT 54
14051: PUSH
14052: LD_INT 55
14054: PUSH
14055: LD_INT 56
14057: PUSH
14058: LD_INT 60
14060: PUSH
14061: LD_INT 61
14063: PUSH
14064: LD_INT 62
14066: PUSH
14067: LD_INT 66
14069: PUSH
14070: LD_INT 67
14072: PUSH
14073: LD_INT 68
14075: PUSH
14076: LD_INT 81
14078: PUSH
14079: LD_INT 82
14081: PUSH
14082: LD_INT 83
14084: PUSH
14085: LD_INT 84
14087: PUSH
14088: LD_INT 85
14090: PUSH
14091: LD_INT 87
14093: PUSH
14094: LD_INT 88
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14386
14155: LD_INT 3
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14385
14163: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14164: LD_ADDR_VAR 0 4
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: LD_INT 47
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 82
14183: PUSH
14184: LD_INT 83
14186: PUSH
14187: LD_INT 84
14189: PUSH
14190: LD_INT 85
14192: PUSH
14193: LD_INT 86
14195: PUSH
14196: LD_INT 11
14198: PUSH
14199: LD_INT 9
14201: PUSH
14202: LD_INT 20
14204: PUSH
14205: LD_INT 19
14207: PUSH
14208: LD_INT 21
14210: PUSH
14211: LD_INT 24
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 25
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: LD_INT 37
14234: PUSH
14235: LD_INT 38
14237: PUSH
14238: LD_INT 32
14240: PUSH
14241: LD_INT 27
14243: PUSH
14244: LD_INT 33
14246: PUSH
14247: LD_INT 69
14249: PUSH
14250: LD_INT 39
14252: PUSH
14253: LD_INT 34
14255: PUSH
14256: LD_INT 40
14258: PUSH
14259: LD_INT 71
14261: PUSH
14262: LD_INT 23
14264: PUSH
14265: LD_INT 44
14267: PUSH
14268: LD_INT 48
14270: PUSH
14271: LD_INT 49
14273: PUSH
14274: LD_INT 50
14276: PUSH
14277: LD_INT 51
14279: PUSH
14280: LD_INT 52
14282: PUSH
14283: LD_INT 53
14285: PUSH
14286: LD_INT 54
14288: PUSH
14289: LD_INT 55
14291: PUSH
14292: LD_INT 56
14294: PUSH
14295: LD_INT 57
14297: PUSH
14298: LD_INT 58
14300: PUSH
14301: LD_INT 59
14303: PUSH
14304: LD_INT 63
14306: PUSH
14307: LD_INT 64
14309: PUSH
14310: LD_INT 65
14312: PUSH
14313: LD_INT 82
14315: PUSH
14316: LD_INT 83
14318: PUSH
14319: LD_INT 84
14321: PUSH
14322: LD_INT 85
14324: PUSH
14325: LD_INT 86
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: ST_TO_ADDR
14383: GO 14386
14385: POP
// if state > - 1 and state < 3 then
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: NEG
14394: GREATER
14395: PUSH
14396: LD_VAR 0 3
14400: PUSH
14401: LD_INT 3
14403: LESS
14404: AND
14405: IFFALSE 14462
// for i in result do
14407: LD_ADDR_VAR 0 5
14411: PUSH
14412: LD_VAR 0 4
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14460
// if GetTech ( i , side ) <> state then
14420: LD_VAR 0 5
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 321
14434: PUSH
14435: LD_VAR 0 3
14439: NONEQUAL
14440: IFFALSE 14458
// result := result diff i ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: DIFF
14457: ST_TO_ADDR
14458: GO 14417
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// result := true ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: LD_INT 1
14479: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: LD_VAR 0 2
14489: PPUSH
14490: CALL_OW 480
14494: ST_TO_ADDR
// if not tmp then
14495: LD_VAR 0 5
14499: NOT
14500: IFFALSE 14504
// exit ;
14502: GO 14553
// for i in tmp do
14504: LD_ADDR_VAR 0 4
14508: PUSH
14509: LD_VAR 0 5
14513: PUSH
14514: FOR_IN
14515: IFFALSE 14551
// if GetTech ( i , side ) <> state_researched then
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 321
14531: PUSH
14532: LD_INT 2
14534: NONEQUAL
14535: IFFALSE 14549
// begin result := false ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 0
14544: ST_TO_ADDR
// exit ;
14545: POP
14546: POP
14547: GO 14553
// end ;
14549: GO 14514
14551: POP
14552: POP
// end ;
14553: LD_VAR 0 3
14557: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
14572: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14573: LD_VAR 0 1
14577: NOT
14578: PUSH
14579: LD_VAR 0 1
14583: PPUSH
14584: CALL_OW 257
14588: PUSH
14589: LD_INT 9
14591: NONEQUAL
14592: OR
14593: IFFALSE 14597
// exit ;
14595: GO 15170
// side := GetSide ( unit ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 255
14611: ST_TO_ADDR
// tech_space := tech_spacanom ;
14612: LD_ADDR_VAR 0 12
14616: PUSH
14617: LD_INT 29
14619: ST_TO_ADDR
// tech_time := tech_taurad ;
14620: LD_ADDR_VAR 0 13
14624: PUSH
14625: LD_INT 28
14627: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14628: LD_ADDR_VAR 0 11
14632: PUSH
14633: LD_VAR 0 1
14637: PPUSH
14638: CALL_OW 310
14642: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14643: LD_VAR 0 11
14647: PPUSH
14648: CALL_OW 247
14652: PUSH
14653: LD_INT 2
14655: EQUAL
14656: IFFALSE 14660
// exit ;
14658: GO 15170
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_INT 81
14667: PUSH
14668: LD_VAR 0 9
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: ST_TO_ADDR
// if not tmp then
14703: LD_VAR 0 8
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15170
// if in_unit then
14712: LD_VAR 0 11
14716: IFFALSE 14740
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14718: LD_ADDR_VAR 0 10
14722: PUSH
14723: LD_VAR 0 8
14727: PPUSH
14728: LD_VAR 0 11
14732: PPUSH
14733: CALL_OW 74
14737: ST_TO_ADDR
14738: GO 14760
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14740: LD_ADDR_VAR 0 10
14744: PUSH
14745: LD_VAR 0 8
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: ST_TO_ADDR
// if not enemy then
14760: LD_VAR 0 10
14764: NOT
14765: IFFALSE 14769
// exit ;
14767: GO 15170
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14769: LD_VAR 0 11
14773: PUSH
14774: LD_VAR 0 11
14778: PPUSH
14779: LD_VAR 0 10
14783: PPUSH
14784: CALL_OW 296
14788: PUSH
14789: LD_INT 13
14791: GREATER
14792: AND
14793: PUSH
14794: LD_VAR 0 1
14798: PPUSH
14799: LD_VAR 0 10
14803: PPUSH
14804: CALL_OW 296
14808: PUSH
14809: LD_INT 12
14811: GREATER
14812: OR
14813: IFFALSE 14817
// exit ;
14815: GO 15170
// missile := [ 1 ] ;
14817: LD_ADDR_VAR 0 14
14821: PUSH
14822: LD_INT 1
14824: PUSH
14825: EMPTY
14826: LIST
14827: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14828: LD_VAR 0 9
14832: PPUSH
14833: LD_VAR 0 12
14837: PPUSH
14838: CALL_OW 325
14842: IFFALSE 14871
// missile := Replace ( missile , missile + 1 , 2 ) ;
14844: LD_ADDR_VAR 0 14
14848: PUSH
14849: LD_VAR 0 14
14853: PPUSH
14854: LD_VAR 0 14
14858: PUSH
14859: LD_INT 1
14861: PLUS
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 1
14870: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 13
14880: PPUSH
14881: CALL_OW 325
14885: PUSH
14886: LD_VAR 0 10
14890: PPUSH
14891: CALL_OW 255
14895: PPUSH
14896: LD_VAR 0 13
14900: PPUSH
14901: CALL_OW 325
14905: NOT
14906: AND
14907: IFFALSE 14936
// missile := Replace ( missile , missile + 1 , 3 ) ;
14909: LD_ADDR_VAR 0 14
14913: PUSH
14914: LD_VAR 0 14
14918: PPUSH
14919: LD_VAR 0 14
14923: PUSH
14924: LD_INT 1
14926: PLUS
14927: PPUSH
14928: LD_INT 3
14930: PPUSH
14931: CALL_OW 1
14935: ST_TO_ADDR
// if missile < 2 then
14936: LD_VAR 0 14
14940: PUSH
14941: LD_INT 2
14943: LESS
14944: IFFALSE 14948
// exit ;
14946: GO 15170
// x := GetX ( enemy ) ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 250
14962: ST_TO_ADDR
// y := GetY ( enemy ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 10
14972: PPUSH
14973: CALL_OW 251
14977: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: NEG
14991: PPUSH
14992: LD_INT 1
14994: PPUSH
14995: CALL_OW 12
14999: PLUS
15000: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15001: LD_ADDR_VAR 0 7
15005: PUSH
15006: LD_VAR 0 5
15010: PUSH
15011: LD_INT 1
15013: NEG
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 12
15022: PLUS
15023: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15024: LD_VAR 0 6
15028: PPUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: CALL_OW 488
15038: NOT
15039: IFFALSE 15061
// begin _x := x ;
15041: LD_ADDR_VAR 0 6
15045: PUSH
15046: LD_VAR 0 4
15050: ST_TO_ADDR
// _y := y ;
15051: LD_ADDR_VAR 0 7
15055: PUSH
15056: LD_VAR 0 5
15060: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 1
15068: PPUSH
15069: LD_VAR 0 14
15073: PPUSH
15074: CALL_OW 12
15078: ST_TO_ADDR
// case i of 1 :
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: DOUBLE
15087: EQUAL
15088: IFTRUE 15092
15090: GO 15109
15092: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15093: LD_VAR 0 1
15097: PPUSH
15098: LD_VAR 0 10
15102: PPUSH
15103: CALL_OW 115
15107: GO 15170
15109: LD_INT 2
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15139
15117: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15118: LD_VAR 0 1
15122: PPUSH
15123: LD_VAR 0 6
15127: PPUSH
15128: LD_VAR 0 7
15132: PPUSH
15133: CALL_OW 153
15137: GO 15170
15139: LD_INT 3
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15169
15147: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 6
15157: PPUSH
15158: LD_VAR 0 7
15162: PPUSH
15163: CALL_OW 154
15167: GO 15170
15169: POP
// end ;
15170: LD_VAR 0 2
15174: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
// if not unit or not building then
15183: LD_VAR 0 1
15187: NOT
15188: PUSH
15189: LD_VAR 0 2
15193: NOT
15194: OR
15195: IFFALSE 15199
// exit ;
15197: GO 15357
// x := GetX ( building ) ;
15199: LD_ADDR_VAR 0 5
15203: PUSH
15204: LD_VAR 0 2
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// y := GetY ( building ) ;
15214: LD_ADDR_VAR 0 6
15218: PUSH
15219: LD_VAR 0 2
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// for i = 0 to 5 do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 0
15237: DEC
15238: ST_TO_ADDR
15239: LD_INT 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15355
// begin _x := ShiftX ( x , i , 3 ) ;
15245: LD_ADDR_VAR 0 7
15249: PUSH
15250: LD_VAR 0 5
15254: PPUSH
15255: LD_VAR 0 4
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 272
15267: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15268: LD_ADDR_VAR 0 8
15272: PUSH
15273: LD_VAR 0 6
15277: PPUSH
15278: LD_VAR 0 4
15282: PPUSH
15283: LD_INT 3
15285: PPUSH
15286: CALL_OW 273
15290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15291: LD_VAR 0 7
15295: PPUSH
15296: LD_VAR 0 8
15300: PPUSH
15301: CALL_OW 488
15305: NOT
15306: IFFALSE 15310
// continue ;
15308: GO 15242
// if HexInfo ( _x , _y ) = 0 then
15310: LD_VAR 0 7
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 428
15324: PUSH
15325: LD_INT 0
15327: EQUAL
15328: IFFALSE 15353
// begin ComMoveXY ( unit , _x , _y ) ;
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 7
15339: PPUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: CALL_OW 111
// exit ;
15349: POP
15350: POP
15351: GO 15357
// end ; end ;
15353: GO 15242
15355: POP
15356: POP
// end ;
15357: LD_VAR 0 3
15361: RET
// export function ScanBase ( side , base_area ) ; begin
15362: LD_INT 0
15364: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15365: LD_ADDR_VAR 0 3
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_INT 81
15377: PUSH
15378: LD_VAR 0 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 70
15391: ST_TO_ADDR
// end ;
15392: LD_VAR 0 3
15396: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15397: LD_INT 0
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// result := false ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// side := GetSide ( unit ) ;
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 255
15425: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15426: LD_ADDR_VAR 0 4
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 248
15440: ST_TO_ADDR
// case nat of 1 :
15441: LD_VAR 0 4
15445: PUSH
15446: LD_INT 1
15448: DOUBLE
15449: EQUAL
15450: IFTRUE 15454
15452: GO 15465
15454: POP
// tech := tech_lassight ; 2 :
15455: LD_ADDR_VAR 0 5
15459: PUSH
15460: LD_INT 12
15462: ST_TO_ADDR
15463: GO 15504
15465: LD_INT 2
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15484
15473: POP
// tech := tech_mortar ; 3 :
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_INT 41
15481: ST_TO_ADDR
15482: GO 15504
15484: LD_INT 3
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15503
15492: POP
// tech := tech_bazooka ; end ;
15493: LD_ADDR_VAR 0 5
15497: PUSH
15498: LD_INT 44
15500: ST_TO_ADDR
15501: GO 15504
15503: POP
// if Researched ( side , tech ) then
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_VAR 0 5
15513: PPUSH
15514: CALL_OW 325
15518: IFFALSE 15545
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15520: LD_ADDR_VAR 0 2
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 8
15530: PUSH
15531: LD_INT 9
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: PUSH
15539: LD_VAR 0 4
15543: ARRAY
15544: ST_TO_ADDR
// end ;
15545: LD_VAR 0 2
15549: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15550: LD_INT 0
15552: PPUSH
15553: PPUSH
15554: PPUSH
// if not mines then
15555: LD_VAR 0 2
15559: NOT
15560: IFFALSE 15564
// exit ;
15562: GO 15708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_INT 81
15571: PUSH
15572: LD_VAR 0 1
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 3
15583: PUSH
15584: LD_INT 21
15586: PUSH
15587: LD_INT 3
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: ST_TO_ADDR
// for i in mines do
15607: LD_ADDR_VAR 0 4
15611: PUSH
15612: LD_VAR 0 2
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15706
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: CALL_OW 458
15642: NOT
15643: IFFALSE 15647
// continue ;
15645: GO 15617
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: PPUSH
15656: LD_VAR 0 4
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: CALL_OW 428
15669: PUSH
15670: LD_VAR 0 5
15674: IN
15675: IFFALSE 15704
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 4
15690: PUSH
15691: LD_INT 2
15693: ARRAY
15694: PPUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 456
// end ;
15704: GO 15617
15706: POP
15707: POP
// end ;
15708: LD_VAR 0 3
15712: RET
// export function Count ( array ) ; var i ; begin
15713: LD_INT 0
15715: PPUSH
15716: PPUSH
// result := 0 ;
15717: LD_ADDR_VAR 0 2
15721: PUSH
15722: LD_INT 0
15724: ST_TO_ADDR
// for i in array do
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_VAR 0 1
15734: PUSH
15735: FOR_IN
15736: IFFALSE 15760
// if i then
15738: LD_VAR 0 3
15742: IFFALSE 15758
// result := result + 1 ;
15744: LD_ADDR_VAR 0 2
15748: PUSH
15749: LD_VAR 0 2
15753: PUSH
15754: LD_INT 1
15756: PLUS
15757: ST_TO_ADDR
15758: GO 15735
15760: POP
15761: POP
// end ;
15762: LD_VAR 0 2
15766: RET
// export function IsEmpty ( building ) ; begin
15767: LD_INT 0
15769: PPUSH
// if not building then
15770: LD_VAR 0 1
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 15822
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15779: LD_ADDR_VAR 0 2
15783: PUSH
15784: LD_VAR 0 1
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_VAR 0 1
15796: PPUSH
15797: CALL_OW 255
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 58
15808: PUSH
15809: EMPTY
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: IN
15821: ST_TO_ADDR
// end ;
15822: LD_VAR 0 2
15826: RET
// export function IsNotFull ( building ) ; var places ; begin
15827: LD_INT 0
15829: PPUSH
15830: PPUSH
// if not building then
15831: LD_VAR 0 1
15835: NOT
15836: IFFALSE 15840
// exit ;
15838: GO 16011
// result := false ;
15840: LD_ADDR_VAR 0 2
15844: PUSH
15845: LD_INT 0
15847: ST_TO_ADDR
// places := 0 ;
15848: LD_ADDR_VAR 0 3
15852: PUSH
15853: LD_INT 0
15855: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
15856: LD_VAR 0 1
15860: PPUSH
15861: CALL_OW 266
15865: PUSH
15866: LD_INT 0
15868: DOUBLE
15869: EQUAL
15870: IFTRUE 15928
15872: LD_INT 1
15874: DOUBLE
15875: EQUAL
15876: IFTRUE 15928
15878: LD_INT 6
15880: DOUBLE
15881: EQUAL
15882: IFTRUE 15928
15884: LD_INT 7
15886: DOUBLE
15887: EQUAL
15888: IFTRUE 15928
15890: LD_INT 8
15892: DOUBLE
15893: EQUAL
15894: IFTRUE 15928
15896: LD_INT 4
15898: DOUBLE
15899: EQUAL
15900: IFTRUE 15928
15902: LD_INT 5
15904: DOUBLE
15905: EQUAL
15906: IFTRUE 15928
15908: LD_INT 2
15910: DOUBLE
15911: EQUAL
15912: IFTRUE 15928
15914: LD_INT 3
15916: DOUBLE
15917: EQUAL
15918: IFTRUE 15928
15920: LD_INT 35
15922: DOUBLE
15923: EQUAL
15924: IFTRUE 15928
15926: GO 15939
15928: POP
// places := 6 ; b_bunker , b_breastwork :
15929: LD_ADDR_VAR 0 3
15933: PUSH
15934: LD_INT 6
15936: ST_TO_ADDR
15937: GO 15984
15939: LD_INT 32
15941: DOUBLE
15942: EQUAL
15943: IFTRUE 15953
15945: LD_INT 31
15947: DOUBLE
15948: EQUAL
15949: IFTRUE 15953
15951: GO 15964
15953: POP
// places := 1 ; b_control_tower :
15954: LD_ADDR_VAR 0 3
15958: PUSH
15959: LD_INT 1
15961: ST_TO_ADDR
15962: GO 15984
15964: LD_INT 36
15966: DOUBLE
15967: EQUAL
15968: IFTRUE 15972
15970: GO 15983
15972: POP
// places := 3 ; end ;
15973: LD_ADDR_VAR 0 3
15977: PUSH
15978: LD_INT 3
15980: ST_TO_ADDR
15981: GO 15984
15983: POP
// if places then
15984: LD_VAR 0 3
15988: IFFALSE 16011
// result := UnitsInside ( building ) < places ;
15990: LD_ADDR_VAR 0 2
15994: PUSH
15995: LD_VAR 0 1
15999: PPUSH
16000: CALL_OW 313
16004: PUSH
16005: LD_VAR 0 3
16009: LESS
16010: ST_TO_ADDR
// end ;
16011: LD_VAR 0 2
16015: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
16020: PPUSH
16021: PPUSH
// tmp := [ ] ;
16022: LD_ADDR_VAR 0 3
16026: PUSH
16027: EMPTY
16028: ST_TO_ADDR
// list := [ ] ;
16029: LD_ADDR_VAR 0 5
16033: PUSH
16034: EMPTY
16035: ST_TO_ADDR
// for i = 16 to 25 do
16036: LD_ADDR_VAR 0 4
16040: PUSH
16041: DOUBLE
16042: LD_INT 16
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 25
16048: PUSH
16049: FOR_TO
16050: IFFALSE 16123
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16052: LD_ADDR_VAR 0 3
16056: PUSH
16057: LD_VAR 0 3
16061: PUSH
16062: LD_INT 22
16064: PUSH
16065: LD_VAR 0 1
16069: PPUSH
16070: CALL_OW 255
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 91
16081: PUSH
16082: LD_VAR 0 1
16086: PUSH
16087: LD_INT 6
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: LIST
16094: PUSH
16095: LD_INT 30
16097: PUSH
16098: LD_VAR 0 4
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: EMPTY
16113: LIST
16114: PPUSH
16115: CALL_OW 69
16119: ADD
16120: ST_TO_ADDR
16121: GO 16049
16123: POP
16124: POP
// for i = 1 to tmp do
16125: LD_ADDR_VAR 0 4
16129: PUSH
16130: DOUBLE
16131: LD_INT 1
16133: DEC
16134: ST_TO_ADDR
16135: LD_VAR 0 3
16139: PUSH
16140: FOR_TO
16141: IFFALSE 16229
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16143: LD_ADDR_VAR 0 5
16147: PUSH
16148: LD_VAR 0 5
16152: PUSH
16153: LD_VAR 0 3
16157: PUSH
16158: LD_VAR 0 4
16162: ARRAY
16163: PPUSH
16164: CALL_OW 266
16168: PUSH
16169: LD_VAR 0 3
16173: PUSH
16174: LD_VAR 0 4
16178: ARRAY
16179: PPUSH
16180: CALL_OW 250
16184: PUSH
16185: LD_VAR 0 3
16189: PUSH
16190: LD_VAR 0 4
16194: ARRAY
16195: PPUSH
16196: CALL_OW 251
16200: PUSH
16201: LD_VAR 0 3
16205: PUSH
16206: LD_VAR 0 4
16210: ARRAY
16211: PPUSH
16212: CALL_OW 254
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: ADD
16226: ST_TO_ADDR
16227: GO 16140
16229: POP
16230: POP
// result := list ;
16231: LD_ADDR_VAR 0 2
16235: PUSH
16236: LD_VAR 0 5
16240: ST_TO_ADDR
// end ;
16241: LD_VAR 0 2
16245: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16246: LD_INT 0
16248: PPUSH
16249: PPUSH
16250: PPUSH
16251: PPUSH
16252: PPUSH
16253: PPUSH
16254: PPUSH
// if not factory then
16255: LD_VAR 0 1
16259: NOT
16260: IFFALSE 16264
// exit ;
16262: GO 16857
// if control = control_apeman then
16264: LD_VAR 0 4
16268: PUSH
16269: LD_INT 5
16271: EQUAL
16272: IFFALSE 16381
// begin tmp := UnitsInside ( factory ) ;
16274: LD_ADDR_VAR 0 8
16278: PUSH
16279: LD_VAR 0 1
16283: PPUSH
16284: CALL_OW 313
16288: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16289: LD_VAR 0 8
16293: PPUSH
16294: LD_INT 25
16296: PUSH
16297: LD_INT 12
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 72
16308: NOT
16309: IFFALSE 16319
// control := control_manual ;
16311: LD_ADDR_VAR 0 4
16315: PUSH
16316: LD_INT 1
16318: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16319: LD_ADDR_VAR 0 8
16323: PUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: CALL 16016 0 1
16333: ST_TO_ADDR
// if tmp then
16334: LD_VAR 0 8
16338: IFFALSE 16381
// begin for i in tmp do
16340: LD_ADDR_VAR 0 7
16344: PUSH
16345: LD_VAR 0 8
16349: PUSH
16350: FOR_IN
16351: IFFALSE 16379
// if i [ 1 ] = b_ext_radio then
16353: LD_VAR 0 7
16357: PUSH
16358: LD_INT 1
16360: ARRAY
16361: PUSH
16362: LD_INT 22
16364: EQUAL
16365: IFFALSE 16377
// begin control := control_remote ;
16367: LD_ADDR_VAR 0 4
16371: PUSH
16372: LD_INT 2
16374: ST_TO_ADDR
// break ;
16375: GO 16379
// end ;
16377: GO 16350
16379: POP
16380: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16381: LD_VAR 0 1
16385: PPUSH
16386: LD_VAR 0 2
16390: PPUSH
16391: LD_VAR 0 3
16395: PPUSH
16396: LD_VAR 0 4
16400: PPUSH
16401: LD_VAR 0 5
16405: PPUSH
16406: CALL_OW 448
16410: IFFALSE 16445
// begin result := [ chassis , engine , control , weapon ] ;
16412: LD_ADDR_VAR 0 6
16416: PUSH
16417: LD_VAR 0 2
16421: PUSH
16422: LD_VAR 0 3
16426: PUSH
16427: LD_VAR 0 4
16431: PUSH
16432: LD_VAR 0 5
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: ST_TO_ADDR
// exit ;
16443: GO 16857
// end ; _chassis := AvailableChassisList ( factory ) ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 1
16454: PPUSH
16455: CALL_OW 475
16459: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16460: LD_ADDR_VAR 0 11
16464: PUSH
16465: LD_VAR 0 1
16469: PPUSH
16470: CALL_OW 476
16474: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16475: LD_ADDR_VAR 0 12
16479: PUSH
16480: LD_VAR 0 1
16484: PPUSH
16485: CALL_OW 477
16489: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16490: LD_ADDR_VAR 0 10
16494: PUSH
16495: LD_VAR 0 1
16499: PPUSH
16500: CALL_OW 478
16504: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16505: LD_VAR 0 9
16509: NOT
16510: PUSH
16511: LD_VAR 0 11
16515: NOT
16516: OR
16517: PUSH
16518: LD_VAR 0 12
16522: NOT
16523: OR
16524: PUSH
16525: LD_VAR 0 10
16529: NOT
16530: OR
16531: IFFALSE 16566
// begin result := [ chassis , engine , control , weapon ] ;
16533: LD_ADDR_VAR 0 6
16537: PUSH
16538: LD_VAR 0 2
16542: PUSH
16543: LD_VAR 0 3
16547: PUSH
16548: LD_VAR 0 4
16552: PUSH
16553: LD_VAR 0 5
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: ST_TO_ADDR
// exit ;
16564: GO 16857
// end ; if not chassis in _chassis then
16566: LD_VAR 0 2
16570: PUSH
16571: LD_VAR 0 9
16575: IN
16576: NOT
16577: IFFALSE 16603
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16579: LD_ADDR_VAR 0 2
16583: PUSH
16584: LD_VAR 0 9
16588: PUSH
16589: LD_INT 1
16591: PPUSH
16592: LD_VAR 0 9
16596: PPUSH
16597: CALL_OW 12
16601: ARRAY
16602: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16603: LD_VAR 0 2
16607: PPUSH
16608: LD_VAR 0 3
16612: PPUSH
16613: CALL 16862 0 2
16617: NOT
16618: IFFALSE 16677
// repeat engine := _engine [ 1 ] ;
16620: LD_ADDR_VAR 0 3
16624: PUSH
16625: LD_VAR 0 11
16629: PUSH
16630: LD_INT 1
16632: ARRAY
16633: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16634: LD_ADDR_VAR 0 11
16638: PUSH
16639: LD_VAR 0 11
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: CALL_OW 3
16651: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16652: LD_VAR 0 2
16656: PPUSH
16657: LD_VAR 0 3
16661: PPUSH
16662: CALL 16862 0 2
16666: PUSH
16667: LD_VAR 0 11
16671: PUSH
16672: EMPTY
16673: EQUAL
16674: OR
16675: IFFALSE 16620
// if not control in _control then
16677: LD_VAR 0 4
16681: PUSH
16682: LD_VAR 0 12
16686: IN
16687: NOT
16688: IFFALSE 16714
// control := _control [ rand ( 1 , _control ) ] ;
16690: LD_ADDR_VAR 0 4
16694: PUSH
16695: LD_VAR 0 12
16699: PUSH
16700: LD_INT 1
16702: PPUSH
16703: LD_VAR 0 12
16707: PPUSH
16708: CALL_OW 12
16712: ARRAY
16713: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16714: LD_VAR 0 2
16718: PPUSH
16719: LD_VAR 0 5
16723: PPUSH
16724: CALL 17082 0 2
16728: NOT
16729: IFFALSE 16788
// repeat weapon := _weapon [ 1 ] ;
16731: LD_ADDR_VAR 0 5
16735: PUSH
16736: LD_VAR 0 10
16740: PUSH
16741: LD_INT 1
16743: ARRAY
16744: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16745: LD_ADDR_VAR 0 10
16749: PUSH
16750: LD_VAR 0 10
16754: PPUSH
16755: LD_INT 1
16757: PPUSH
16758: CALL_OW 3
16762: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16763: LD_VAR 0 2
16767: PPUSH
16768: LD_VAR 0 5
16772: PPUSH
16773: CALL 17082 0 2
16777: PUSH
16778: LD_VAR 0 10
16782: PUSH
16783: EMPTY
16784: EQUAL
16785: OR
16786: IFFALSE 16731
// result := [ ] ;
16788: LD_ADDR_VAR 0 6
16792: PUSH
16793: EMPTY
16794: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16795: LD_VAR 0 1
16799: PPUSH
16800: LD_VAR 0 2
16804: PPUSH
16805: LD_VAR 0 3
16809: PPUSH
16810: LD_VAR 0 4
16814: PPUSH
16815: LD_VAR 0 5
16819: PPUSH
16820: CALL_OW 448
16824: IFFALSE 16857
// result := [ chassis , engine , control , weapon ] ;
16826: LD_ADDR_VAR 0 6
16830: PUSH
16831: LD_VAR 0 2
16835: PUSH
16836: LD_VAR 0 3
16840: PUSH
16841: LD_VAR 0 4
16845: PUSH
16846: LD_VAR 0 5
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: ST_TO_ADDR
// end ;
16857: LD_VAR 0 6
16861: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16862: LD_INT 0
16864: PPUSH
// if not chassis or not engine then
16865: LD_VAR 0 1
16869: NOT
16870: PUSH
16871: LD_VAR 0 2
16875: NOT
16876: OR
16877: IFFALSE 16881
// exit ;
16879: GO 17077
// case engine of engine_solar :
16881: LD_VAR 0 2
16885: PUSH
16886: LD_INT 2
16888: DOUBLE
16889: EQUAL
16890: IFTRUE 16894
16892: GO 16932
16894: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_INT 11
16902: PUSH
16903: LD_INT 12
16905: PUSH
16906: LD_INT 13
16908: PUSH
16909: LD_INT 14
16911: PUSH
16912: LD_INT 1
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: ST_TO_ADDR
16930: GO 17061
16932: LD_INT 1
16934: DOUBLE
16935: EQUAL
16936: IFTRUE 16940
16938: GO 17002
16940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16941: LD_ADDR_VAR 0 3
16945: PUSH
16946: LD_INT 11
16948: PUSH
16949: LD_INT 12
16951: PUSH
16952: LD_INT 13
16954: PUSH
16955: LD_INT 14
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: LD_INT 21
16975: PUSH
16976: LD_INT 23
16978: PUSH
16979: LD_INT 22
16981: PUSH
16982: LD_INT 24
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: ST_TO_ADDR
17000: GO 17061
17002: LD_INT 3
17004: DOUBLE
17005: EQUAL
17006: IFTRUE 17010
17008: GO 17060
17010: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17011: LD_ADDR_VAR 0 3
17015: PUSH
17016: LD_INT 13
17018: PUSH
17019: LD_INT 14
17021: PUSH
17022: LD_INT 2
17024: PUSH
17025: LD_INT 3
17027: PUSH
17028: LD_INT 4
17030: PUSH
17031: LD_INT 5
17033: PUSH
17034: LD_INT 21
17036: PUSH
17037: LD_INT 22
17039: PUSH
17040: LD_INT 23
17042: PUSH
17043: LD_INT 24
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: ST_TO_ADDR
17058: GO 17061
17060: POP
// result := ( chassis in result ) ;
17061: LD_ADDR_VAR 0 3
17065: PUSH
17066: LD_VAR 0 1
17070: PUSH
17071: LD_VAR 0 3
17075: IN
17076: ST_TO_ADDR
// end ;
17077: LD_VAR 0 3
17081: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17082: LD_INT 0
17084: PPUSH
// if not chassis or not weapon then
17085: LD_VAR 0 1
17089: NOT
17090: PUSH
17091: LD_VAR 0 2
17095: NOT
17096: OR
17097: IFFALSE 17101
// exit ;
17099: GO 18161
// case weapon of us_machine_gun :
17101: LD_VAR 0 2
17105: PUSH
17106: LD_INT 2
17108: DOUBLE
17109: EQUAL
17110: IFTRUE 17114
17112: GO 17144
17114: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17115: LD_ADDR_VAR 0 3
17119: PUSH
17120: LD_INT 1
17122: PUSH
17123: LD_INT 2
17125: PUSH
17126: LD_INT 3
17128: PUSH
17129: LD_INT 4
17131: PUSH
17132: LD_INT 5
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: ST_TO_ADDR
17142: GO 18145
17144: LD_INT 3
17146: DOUBLE
17147: EQUAL
17148: IFTRUE 17152
17150: GO 17182
17152: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17153: LD_ADDR_VAR 0 3
17157: PUSH
17158: LD_INT 1
17160: PUSH
17161: LD_INT 2
17163: PUSH
17164: LD_INT 3
17166: PUSH
17167: LD_INT 4
17169: PUSH
17170: LD_INT 5
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: ST_TO_ADDR
17180: GO 18145
17182: LD_INT 11
17184: DOUBLE
17185: EQUAL
17186: IFTRUE 17190
17188: GO 17220
17190: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17191: LD_ADDR_VAR 0 3
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: LD_INT 2
17201: PUSH
17202: LD_INT 3
17204: PUSH
17205: LD_INT 4
17207: PUSH
17208: LD_INT 5
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: ST_TO_ADDR
17218: GO 18145
17220: LD_INT 4
17222: DOUBLE
17223: EQUAL
17224: IFTRUE 17228
17226: GO 17254
17228: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17229: LD_ADDR_VAR 0 3
17233: PUSH
17234: LD_INT 2
17236: PUSH
17237: LD_INT 3
17239: PUSH
17240: LD_INT 4
17242: PUSH
17243: LD_INT 5
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: ST_TO_ADDR
17252: GO 18145
17254: LD_INT 5
17256: DOUBLE
17257: EQUAL
17258: IFTRUE 17262
17260: GO 17288
17262: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17263: LD_ADDR_VAR 0 3
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 3
17273: PUSH
17274: LD_INT 4
17276: PUSH
17277: LD_INT 5
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 18145
17288: LD_INT 9
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17322
17296: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 2
17304: PUSH
17305: LD_INT 3
17307: PUSH
17308: LD_INT 4
17310: PUSH
17311: LD_INT 5
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: ST_TO_ADDR
17320: GO 18145
17322: LD_INT 7
17324: DOUBLE
17325: EQUAL
17326: IFTRUE 17330
17328: GO 17356
17330: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17331: LD_ADDR_VAR 0 3
17335: PUSH
17336: LD_INT 2
17338: PUSH
17339: LD_INT 3
17341: PUSH
17342: LD_INT 4
17344: PUSH
17345: LD_INT 5
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: LIST
17352: LIST
17353: ST_TO_ADDR
17354: GO 18145
17356: LD_INT 12
17358: DOUBLE
17359: EQUAL
17360: IFTRUE 17364
17362: GO 17390
17364: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_INT 2
17372: PUSH
17373: LD_INT 3
17375: PUSH
17376: LD_INT 4
17378: PUSH
17379: LD_INT 5
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: ST_TO_ADDR
17388: GO 18145
17390: LD_INT 13
17392: DOUBLE
17393: EQUAL
17394: IFTRUE 17398
17396: GO 17424
17398: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17399: LD_ADDR_VAR 0 3
17403: PUSH
17404: LD_INT 2
17406: PUSH
17407: LD_INT 3
17409: PUSH
17410: LD_INT 4
17412: PUSH
17413: LD_INT 5
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: ST_TO_ADDR
17422: GO 18145
17424: LD_INT 14
17426: DOUBLE
17427: EQUAL
17428: IFTRUE 17432
17430: GO 17450
17432: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17433: LD_ADDR_VAR 0 3
17437: PUSH
17438: LD_INT 4
17440: PUSH
17441: LD_INT 5
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: ST_TO_ADDR
17448: GO 18145
17450: LD_INT 6
17452: DOUBLE
17453: EQUAL
17454: IFTRUE 17458
17456: GO 17476
17458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17459: LD_ADDR_VAR 0 3
17463: PUSH
17464: LD_INT 4
17466: PUSH
17467: LD_INT 5
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 18145
17476: LD_INT 10
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 4
17492: PUSH
17493: LD_INT 5
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 18145
17502: LD_INT 22
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17536
17510: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 11
17518: PUSH
17519: LD_INT 12
17521: PUSH
17522: LD_INT 13
17524: PUSH
17525: LD_INT 14
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: ST_TO_ADDR
17534: GO 18145
17536: LD_INT 23
17538: DOUBLE
17539: EQUAL
17540: IFTRUE 17544
17542: GO 17570
17544: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17545: LD_ADDR_VAR 0 3
17549: PUSH
17550: LD_INT 11
17552: PUSH
17553: LD_INT 12
17555: PUSH
17556: LD_INT 13
17558: PUSH
17559: LD_INT 14
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: ST_TO_ADDR
17568: GO 18145
17570: LD_INT 24
17572: DOUBLE
17573: EQUAL
17574: IFTRUE 17578
17576: GO 17604
17578: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17579: LD_ADDR_VAR 0 3
17583: PUSH
17584: LD_INT 11
17586: PUSH
17587: LD_INT 12
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: ST_TO_ADDR
17602: GO 18145
17604: LD_INT 30
17606: DOUBLE
17607: EQUAL
17608: IFTRUE 17612
17610: GO 17638
17612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17613: LD_ADDR_VAR 0 3
17617: PUSH
17618: LD_INT 11
17620: PUSH
17621: LD_INT 12
17623: PUSH
17624: LD_INT 13
17626: PUSH
17627: LD_INT 14
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: LIST
17634: LIST
17635: ST_TO_ADDR
17636: GO 18145
17638: LD_INT 25
17640: DOUBLE
17641: EQUAL
17642: IFTRUE 17646
17644: GO 17664
17646: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17647: LD_ADDR_VAR 0 3
17651: PUSH
17652: LD_INT 13
17654: PUSH
17655: LD_INT 14
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: ST_TO_ADDR
17662: GO 18145
17664: LD_INT 27
17666: DOUBLE
17667: EQUAL
17668: IFTRUE 17672
17670: GO 17690
17672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17673: LD_ADDR_VAR 0 3
17677: PUSH
17678: LD_INT 13
17680: PUSH
17681: LD_INT 14
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: ST_TO_ADDR
17688: GO 18145
17690: LD_INT 92
17692: DOUBLE
17693: EQUAL
17694: IFTRUE 17698
17696: GO 17724
17698: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17699: LD_ADDR_VAR 0 3
17703: PUSH
17704: LD_INT 11
17706: PUSH
17707: LD_INT 12
17709: PUSH
17710: LD_INT 13
17712: PUSH
17713: LD_INT 14
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: ST_TO_ADDR
17722: GO 18145
17724: LD_INT 28
17726: DOUBLE
17727: EQUAL
17728: IFTRUE 17732
17730: GO 17750
17732: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17733: LD_ADDR_VAR 0 3
17737: PUSH
17738: LD_INT 13
17740: PUSH
17741: LD_INT 14
17743: PUSH
17744: EMPTY
17745: LIST
17746: LIST
17747: ST_TO_ADDR
17748: GO 18145
17750: LD_INT 29
17752: DOUBLE
17753: EQUAL
17754: IFTRUE 17758
17756: GO 17776
17758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17759: LD_ADDR_VAR 0 3
17763: PUSH
17764: LD_INT 13
17766: PUSH
17767: LD_INT 14
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: ST_TO_ADDR
17774: GO 18145
17776: LD_INT 31
17778: DOUBLE
17779: EQUAL
17780: IFTRUE 17784
17782: GO 17802
17784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17785: LD_ADDR_VAR 0 3
17789: PUSH
17790: LD_INT 13
17792: PUSH
17793: LD_INT 14
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: ST_TO_ADDR
17800: GO 18145
17802: LD_INT 26
17804: DOUBLE
17805: EQUAL
17806: IFTRUE 17810
17808: GO 17828
17810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17811: LD_ADDR_VAR 0 3
17815: PUSH
17816: LD_INT 13
17818: PUSH
17819: LD_INT 14
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: ST_TO_ADDR
17826: GO 18145
17828: LD_INT 42
17830: DOUBLE
17831: EQUAL
17832: IFTRUE 17836
17834: GO 17862
17836: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17837: LD_ADDR_VAR 0 3
17841: PUSH
17842: LD_INT 21
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: LD_INT 23
17850: PUSH
17851: LD_INT 24
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: LIST
17858: LIST
17859: ST_TO_ADDR
17860: GO 18145
17862: LD_INT 43
17864: DOUBLE
17865: EQUAL
17866: IFTRUE 17870
17868: GO 17896
17870: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17871: LD_ADDR_VAR 0 3
17875: PUSH
17876: LD_INT 21
17878: PUSH
17879: LD_INT 22
17881: PUSH
17882: LD_INT 23
17884: PUSH
17885: LD_INT 24
17887: PUSH
17888: EMPTY
17889: LIST
17890: LIST
17891: LIST
17892: LIST
17893: ST_TO_ADDR
17894: GO 18145
17896: LD_INT 44
17898: DOUBLE
17899: EQUAL
17900: IFTRUE 17904
17902: GO 17930
17904: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17905: LD_ADDR_VAR 0 3
17909: PUSH
17910: LD_INT 21
17912: PUSH
17913: LD_INT 22
17915: PUSH
17916: LD_INT 23
17918: PUSH
17919: LD_INT 24
17921: PUSH
17922: EMPTY
17923: LIST
17924: LIST
17925: LIST
17926: LIST
17927: ST_TO_ADDR
17928: GO 18145
17930: LD_INT 45
17932: DOUBLE
17933: EQUAL
17934: IFTRUE 17938
17936: GO 17964
17938: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17939: LD_ADDR_VAR 0 3
17943: PUSH
17944: LD_INT 21
17946: PUSH
17947: LD_INT 22
17949: PUSH
17950: LD_INT 23
17952: PUSH
17953: LD_INT 24
17955: PUSH
17956: EMPTY
17957: LIST
17958: LIST
17959: LIST
17960: LIST
17961: ST_TO_ADDR
17962: GO 18145
17964: LD_INT 49
17966: DOUBLE
17967: EQUAL
17968: IFTRUE 17972
17970: GO 17998
17972: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17973: LD_ADDR_VAR 0 3
17977: PUSH
17978: LD_INT 21
17980: PUSH
17981: LD_INT 22
17983: PUSH
17984: LD_INT 23
17986: PUSH
17987: LD_INT 24
17989: PUSH
17990: EMPTY
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: ST_TO_ADDR
17996: GO 18145
17998: LD_INT 51
18000: DOUBLE
18001: EQUAL
18002: IFTRUE 18006
18004: GO 18032
18006: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18007: LD_ADDR_VAR 0 3
18011: PUSH
18012: LD_INT 21
18014: PUSH
18015: LD_INT 22
18017: PUSH
18018: LD_INT 23
18020: PUSH
18021: LD_INT 24
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: ST_TO_ADDR
18030: GO 18145
18032: LD_INT 52
18034: DOUBLE
18035: EQUAL
18036: IFTRUE 18040
18038: GO 18066
18040: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: LD_INT 21
18048: PUSH
18049: LD_INT 22
18051: PUSH
18052: LD_INT 23
18054: PUSH
18055: LD_INT 24
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: LIST
18062: LIST
18063: ST_TO_ADDR
18064: GO 18145
18066: LD_INT 53
18068: DOUBLE
18069: EQUAL
18070: IFTRUE 18074
18072: GO 18092
18074: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18075: LD_ADDR_VAR 0 3
18079: PUSH
18080: LD_INT 23
18082: PUSH
18083: LD_INT 24
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: ST_TO_ADDR
18090: GO 18145
18092: LD_INT 46
18094: DOUBLE
18095: EQUAL
18096: IFTRUE 18100
18098: GO 18118
18100: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18101: LD_ADDR_VAR 0 3
18105: PUSH
18106: LD_INT 23
18108: PUSH
18109: LD_INT 24
18111: PUSH
18112: EMPTY
18113: LIST
18114: LIST
18115: ST_TO_ADDR
18116: GO 18145
18118: LD_INT 47
18120: DOUBLE
18121: EQUAL
18122: IFTRUE 18126
18124: GO 18144
18126: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18127: LD_ADDR_VAR 0 3
18131: PUSH
18132: LD_INT 23
18134: PUSH
18135: LD_INT 24
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: ST_TO_ADDR
18142: GO 18145
18144: POP
// result := ( chassis in result ) ;
18145: LD_ADDR_VAR 0 3
18149: PUSH
18150: LD_VAR 0 1
18154: PUSH
18155: LD_VAR 0 3
18159: IN
18160: ST_TO_ADDR
// end ;
18161: LD_VAR 0 3
18165: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18166: LD_INT 0
18168: PPUSH
18169: PPUSH
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
// result := array ;
18175: LD_ADDR_VAR 0 5
18179: PUSH
18180: LD_VAR 0 1
18184: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18185: LD_VAR 0 1
18189: NOT
18190: PUSH
18191: LD_VAR 0 2
18195: NOT
18196: OR
18197: PUSH
18198: LD_VAR 0 3
18202: NOT
18203: OR
18204: PUSH
18205: LD_VAR 0 2
18209: PUSH
18210: LD_VAR 0 1
18214: GREATER
18215: OR
18216: PUSH
18217: LD_VAR 0 3
18221: PUSH
18222: LD_VAR 0 1
18226: GREATER
18227: OR
18228: IFFALSE 18232
// exit ;
18230: GO 18528
// if direction then
18232: LD_VAR 0 4
18236: IFFALSE 18300
// begin d := 1 ;
18238: LD_ADDR_VAR 0 9
18242: PUSH
18243: LD_INT 1
18245: ST_TO_ADDR
// if i_from > i_to then
18246: LD_VAR 0 2
18250: PUSH
18251: LD_VAR 0 3
18255: GREATER
18256: IFFALSE 18282
// length := ( array - i_from ) + i_to else
18258: LD_ADDR_VAR 0 11
18262: PUSH
18263: LD_VAR 0 1
18267: PUSH
18268: LD_VAR 0 2
18272: MINUS
18273: PUSH
18274: LD_VAR 0 3
18278: PLUS
18279: ST_TO_ADDR
18280: GO 18298
// length := i_to - i_from ;
18282: LD_ADDR_VAR 0 11
18286: PUSH
18287: LD_VAR 0 3
18291: PUSH
18292: LD_VAR 0 2
18296: MINUS
18297: ST_TO_ADDR
// end else
18298: GO 18361
// begin d := - 1 ;
18300: LD_ADDR_VAR 0 9
18304: PUSH
18305: LD_INT 1
18307: NEG
18308: ST_TO_ADDR
// if i_from > i_to then
18309: LD_VAR 0 2
18313: PUSH
18314: LD_VAR 0 3
18318: GREATER
18319: IFFALSE 18339
// length := i_from - i_to else
18321: LD_ADDR_VAR 0 11
18325: PUSH
18326: LD_VAR 0 2
18330: PUSH
18331: LD_VAR 0 3
18335: MINUS
18336: ST_TO_ADDR
18337: GO 18361
// length := ( array - i_to ) + i_from ;
18339: LD_ADDR_VAR 0 11
18343: PUSH
18344: LD_VAR 0 1
18348: PUSH
18349: LD_VAR 0 3
18353: MINUS
18354: PUSH
18355: LD_VAR 0 2
18359: PLUS
18360: ST_TO_ADDR
// end ; if not length then
18361: LD_VAR 0 11
18365: NOT
18366: IFFALSE 18370
// exit ;
18368: GO 18528
// tmp := array ;
18370: LD_ADDR_VAR 0 10
18374: PUSH
18375: LD_VAR 0 1
18379: ST_TO_ADDR
// for i = 1 to length do
18380: LD_ADDR_VAR 0 6
18384: PUSH
18385: DOUBLE
18386: LD_INT 1
18388: DEC
18389: ST_TO_ADDR
18390: LD_VAR 0 11
18394: PUSH
18395: FOR_TO
18396: IFFALSE 18516
// begin for j = 1 to array do
18398: LD_ADDR_VAR 0 7
18402: PUSH
18403: DOUBLE
18404: LD_INT 1
18406: DEC
18407: ST_TO_ADDR
18408: LD_VAR 0 1
18412: PUSH
18413: FOR_TO
18414: IFFALSE 18502
// begin k := j + d ;
18416: LD_ADDR_VAR 0 8
18420: PUSH
18421: LD_VAR 0 7
18425: PUSH
18426: LD_VAR 0 9
18430: PLUS
18431: ST_TO_ADDR
// if k > array then
18432: LD_VAR 0 8
18436: PUSH
18437: LD_VAR 0 1
18441: GREATER
18442: IFFALSE 18452
// k := 1 ;
18444: LD_ADDR_VAR 0 8
18448: PUSH
18449: LD_INT 1
18451: ST_TO_ADDR
// if not k then
18452: LD_VAR 0 8
18456: NOT
18457: IFFALSE 18469
// k := array ;
18459: LD_ADDR_VAR 0 8
18463: PUSH
18464: LD_VAR 0 1
18468: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18469: LD_ADDR_VAR 0 10
18473: PUSH
18474: LD_VAR 0 10
18478: PPUSH
18479: LD_VAR 0 8
18483: PPUSH
18484: LD_VAR 0 1
18488: PUSH
18489: LD_VAR 0 7
18493: ARRAY
18494: PPUSH
18495: CALL_OW 1
18499: ST_TO_ADDR
// end ;
18500: GO 18413
18502: POP
18503: POP
// array := tmp ;
18504: LD_ADDR_VAR 0 1
18508: PUSH
18509: LD_VAR 0 10
18513: ST_TO_ADDR
// end ;
18514: GO 18395
18516: POP
18517: POP
// result := array ;
18518: LD_ADDR_VAR 0 5
18522: PUSH
18523: LD_VAR 0 1
18527: ST_TO_ADDR
// end ;
18528: LD_VAR 0 5
18532: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18533: LD_INT 0
18535: PPUSH
18536: PPUSH
// result := 0 ;
18537: LD_ADDR_VAR 0 3
18541: PUSH
18542: LD_INT 0
18544: ST_TO_ADDR
// if not array or not value in array then
18545: LD_VAR 0 1
18549: NOT
18550: PUSH
18551: LD_VAR 0 2
18555: PUSH
18556: LD_VAR 0 1
18560: IN
18561: NOT
18562: OR
18563: IFFALSE 18567
// exit ;
18565: GO 18621
// for i = 1 to array do
18567: LD_ADDR_VAR 0 4
18571: PUSH
18572: DOUBLE
18573: LD_INT 1
18575: DEC
18576: ST_TO_ADDR
18577: LD_VAR 0 1
18581: PUSH
18582: FOR_TO
18583: IFFALSE 18619
// if value = array [ i ] then
18585: LD_VAR 0 2
18589: PUSH
18590: LD_VAR 0 1
18594: PUSH
18595: LD_VAR 0 4
18599: ARRAY
18600: EQUAL
18601: IFFALSE 18617
// begin result := i ;
18603: LD_ADDR_VAR 0 3
18607: PUSH
18608: LD_VAR 0 4
18612: ST_TO_ADDR
// exit ;
18613: POP
18614: POP
18615: GO 18621
// end ;
18617: GO 18582
18619: POP
18620: POP
// end ;
18621: LD_VAR 0 3
18625: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18626: LD_INT 0
18628: PPUSH
// vc_chassis := chassis ;
18629: LD_ADDR_OWVAR 37
18633: PUSH
18634: LD_VAR 0 1
18638: ST_TO_ADDR
// vc_engine := engine ;
18639: LD_ADDR_OWVAR 39
18643: PUSH
18644: LD_VAR 0 2
18648: ST_TO_ADDR
// vc_control := control ;
18649: LD_ADDR_OWVAR 38
18653: PUSH
18654: LD_VAR 0 3
18658: ST_TO_ADDR
// vc_weapon := weapon ;
18659: LD_ADDR_OWVAR 40
18663: PUSH
18664: LD_VAR 0 4
18668: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18669: LD_ADDR_OWVAR 41
18673: PUSH
18674: LD_VAR 0 5
18678: ST_TO_ADDR
// end ;
18679: LD_VAR 0 6
18683: RET
// export function WantPlant ( unit ) ; var task ; begin
18684: LD_INT 0
18686: PPUSH
18687: PPUSH
// result := false ;
18688: LD_ADDR_VAR 0 2
18692: PUSH
18693: LD_INT 0
18695: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18696: LD_ADDR_VAR 0 3
18700: PUSH
18701: LD_VAR 0 1
18705: PPUSH
18706: CALL_OW 437
18710: ST_TO_ADDR
// if task then
18711: LD_VAR 0 3
18715: IFFALSE 18743
// if task [ 1 ] [ 1 ] = p then
18717: LD_VAR 0 3
18721: PUSH
18722: LD_INT 1
18724: ARRAY
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PUSH
18730: LD_STRING p
18732: EQUAL
18733: IFFALSE 18743
// result := true ;
18735: LD_ADDR_VAR 0 2
18739: PUSH
18740: LD_INT 1
18742: ST_TO_ADDR
// end ;
18743: LD_VAR 0 2
18747: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18748: LD_INT 0
18750: PPUSH
18751: PPUSH
18752: PPUSH
18753: PPUSH
// if pos < 1 then
18754: LD_VAR 0 2
18758: PUSH
18759: LD_INT 1
18761: LESS
18762: IFFALSE 18766
// exit ;
18764: GO 19069
// if pos = 1 then
18766: LD_VAR 0 2
18770: PUSH
18771: LD_INT 1
18773: EQUAL
18774: IFFALSE 18807
// result := Replace ( arr , pos [ 1 ] , value ) else
18776: LD_ADDR_VAR 0 4
18780: PUSH
18781: LD_VAR 0 1
18785: PPUSH
18786: LD_VAR 0 2
18790: PUSH
18791: LD_INT 1
18793: ARRAY
18794: PPUSH
18795: LD_VAR 0 3
18799: PPUSH
18800: CALL_OW 1
18804: ST_TO_ADDR
18805: GO 19069
// begin tmp := arr ;
18807: LD_ADDR_VAR 0 6
18811: PUSH
18812: LD_VAR 0 1
18816: ST_TO_ADDR
// s_arr := [ tmp ] ;
18817: LD_ADDR_VAR 0 7
18821: PUSH
18822: LD_VAR 0 6
18826: PUSH
18827: EMPTY
18828: LIST
18829: ST_TO_ADDR
// for i = 1 to pos - 1 do
18830: LD_ADDR_VAR 0 5
18834: PUSH
18835: DOUBLE
18836: LD_INT 1
18838: DEC
18839: ST_TO_ADDR
18840: LD_VAR 0 2
18844: PUSH
18845: LD_INT 1
18847: MINUS
18848: PUSH
18849: FOR_TO
18850: IFFALSE 18895
// begin tmp := tmp [ pos [ i ] ] ;
18852: LD_ADDR_VAR 0 6
18856: PUSH
18857: LD_VAR 0 6
18861: PUSH
18862: LD_VAR 0 2
18866: PUSH
18867: LD_VAR 0 5
18871: ARRAY
18872: ARRAY
18873: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18874: LD_ADDR_VAR 0 7
18878: PUSH
18879: LD_VAR 0 7
18883: PUSH
18884: LD_VAR 0 6
18888: PUSH
18889: EMPTY
18890: LIST
18891: ADD
18892: ST_TO_ADDR
// end ;
18893: GO 18849
18895: POP
18896: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18897: LD_ADDR_VAR 0 6
18901: PUSH
18902: LD_VAR 0 6
18906: PPUSH
18907: LD_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: ARRAY
18917: PPUSH
18918: LD_VAR 0 3
18922: PPUSH
18923: CALL_OW 1
18927: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18928: LD_ADDR_VAR 0 7
18932: PUSH
18933: LD_VAR 0 7
18937: PPUSH
18938: LD_VAR 0 7
18942: PPUSH
18943: LD_VAR 0 6
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// for i = s_arr downto 2 do
18953: LD_ADDR_VAR 0 5
18957: PUSH
18958: DOUBLE
18959: LD_VAR 0 7
18963: INC
18964: ST_TO_ADDR
18965: LD_INT 2
18967: PUSH
18968: FOR_DOWNTO
18969: IFFALSE 19053
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18971: LD_ADDR_VAR 0 6
18975: PUSH
18976: LD_VAR 0 7
18980: PUSH
18981: LD_VAR 0 5
18985: PUSH
18986: LD_INT 1
18988: MINUS
18989: ARRAY
18990: PPUSH
18991: LD_VAR 0 2
18995: PUSH
18996: LD_VAR 0 5
19000: PUSH
19001: LD_INT 1
19003: MINUS
19004: ARRAY
19005: PPUSH
19006: LD_VAR 0 7
19010: PUSH
19011: LD_VAR 0 5
19015: ARRAY
19016: PPUSH
19017: CALL_OW 1
19021: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19022: LD_ADDR_VAR 0 7
19026: PUSH
19027: LD_VAR 0 7
19031: PPUSH
19032: LD_VAR 0 5
19036: PUSH
19037: LD_INT 1
19039: MINUS
19040: PPUSH
19041: LD_VAR 0 6
19045: PPUSH
19046: CALL_OW 1
19050: ST_TO_ADDR
// end ;
19051: GO 18968
19053: POP
19054: POP
// result := s_arr [ 1 ] ;
19055: LD_ADDR_VAR 0 4
19059: PUSH
19060: LD_VAR 0 7
19064: PUSH
19065: LD_INT 1
19067: ARRAY
19068: ST_TO_ADDR
// end ; end ;
19069: LD_VAR 0 4
19073: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19074: LD_INT 0
19076: PPUSH
19077: PPUSH
// if not list then
19078: LD_VAR 0 1
19082: NOT
19083: IFFALSE 19087
// exit ;
19085: GO 19178
// i := list [ pos1 ] ;
19087: LD_ADDR_VAR 0 5
19091: PUSH
19092: LD_VAR 0 1
19096: PUSH
19097: LD_VAR 0 2
19101: ARRAY
19102: ST_TO_ADDR
// if not i then
19103: LD_VAR 0 5
19107: NOT
19108: IFFALSE 19112
// exit ;
19110: GO 19178
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19112: LD_ADDR_VAR 0 1
19116: PUSH
19117: LD_VAR 0 1
19121: PPUSH
19122: LD_VAR 0 2
19126: PPUSH
19127: LD_VAR 0 1
19131: PUSH
19132: LD_VAR 0 3
19136: ARRAY
19137: PPUSH
19138: CALL_OW 1
19142: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19143: LD_ADDR_VAR 0 1
19147: PUSH
19148: LD_VAR 0 1
19152: PPUSH
19153: LD_VAR 0 3
19157: PPUSH
19158: LD_VAR 0 5
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
// result := list ;
19168: LD_ADDR_VAR 0 4
19172: PUSH
19173: LD_VAR 0 1
19177: ST_TO_ADDR
// end ;
19178: LD_VAR 0 4
19182: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19183: LD_INT 0
19185: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19186: LD_ADDR_VAR 0 5
19190: PUSH
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 250
19200: PPUSH
19201: LD_VAR 0 1
19205: PPUSH
19206: CALL_OW 251
19210: PPUSH
19211: LD_VAR 0 2
19215: PPUSH
19216: LD_VAR 0 3
19220: PPUSH
19221: LD_VAR 0 4
19225: PPUSH
19226: CALL 19236 0 5
19230: ST_TO_ADDR
// end ;
19231: LD_VAR 0 5
19235: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19236: LD_INT 0
19238: PPUSH
19239: PPUSH
19240: PPUSH
19241: PPUSH
// if not list then
19242: LD_VAR 0 3
19246: NOT
19247: IFFALSE 19251
// exit ;
19249: GO 19639
// result := [ ] ;
19251: LD_ADDR_VAR 0 6
19255: PUSH
19256: EMPTY
19257: ST_TO_ADDR
// for i in list do
19258: LD_ADDR_VAR 0 7
19262: PUSH
19263: LD_VAR 0 3
19267: PUSH
19268: FOR_IN
19269: IFFALSE 19471
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19271: LD_ADDR_VAR 0 9
19275: PUSH
19276: LD_VAR 0 7
19280: PPUSH
19281: LD_VAR 0 1
19285: PPUSH
19286: LD_VAR 0 2
19290: PPUSH
19291: CALL_OW 297
19295: ST_TO_ADDR
// if not result then
19296: LD_VAR 0 6
19300: NOT
19301: IFFALSE 19327
// result := [ [ i , tmp ] ] else
19303: LD_ADDR_VAR 0 6
19307: PUSH
19308: LD_VAR 0 7
19312: PUSH
19313: LD_VAR 0 9
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: PUSH
19322: EMPTY
19323: LIST
19324: ST_TO_ADDR
19325: GO 19469
// begin if result [ result ] [ 2 ] < tmp then
19327: LD_VAR 0 6
19331: PUSH
19332: LD_VAR 0 6
19336: ARRAY
19337: PUSH
19338: LD_INT 2
19340: ARRAY
19341: PUSH
19342: LD_VAR 0 9
19346: LESS
19347: IFFALSE 19389
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19349: LD_ADDR_VAR 0 6
19353: PUSH
19354: LD_VAR 0 6
19358: PPUSH
19359: LD_VAR 0 6
19363: PUSH
19364: LD_INT 1
19366: PLUS
19367: PPUSH
19368: LD_VAR 0 7
19372: PUSH
19373: LD_VAR 0 9
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PPUSH
19382: CALL_OW 2
19386: ST_TO_ADDR
19387: GO 19469
// for j = 1 to result do
19389: LD_ADDR_VAR 0 8
19393: PUSH
19394: DOUBLE
19395: LD_INT 1
19397: DEC
19398: ST_TO_ADDR
19399: LD_VAR 0 6
19403: PUSH
19404: FOR_TO
19405: IFFALSE 19467
// begin if tmp < result [ j ] [ 2 ] then
19407: LD_VAR 0 9
19411: PUSH
19412: LD_VAR 0 6
19416: PUSH
19417: LD_VAR 0 8
19421: ARRAY
19422: PUSH
19423: LD_INT 2
19425: ARRAY
19426: LESS
19427: IFFALSE 19465
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19429: LD_ADDR_VAR 0 6
19433: PUSH
19434: LD_VAR 0 6
19438: PPUSH
19439: LD_VAR 0 8
19443: PPUSH
19444: LD_VAR 0 7
19448: PUSH
19449: LD_VAR 0 9
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PPUSH
19458: CALL_OW 2
19462: ST_TO_ADDR
// break ;
19463: GO 19467
// end ; end ;
19465: GO 19404
19467: POP
19468: POP
// end ; end ;
19469: GO 19268
19471: POP
19472: POP
// if result and not asc then
19473: LD_VAR 0 6
19477: PUSH
19478: LD_VAR 0 4
19482: NOT
19483: AND
19484: IFFALSE 19559
// begin tmp := result ;
19486: LD_ADDR_VAR 0 9
19490: PUSH
19491: LD_VAR 0 6
19495: ST_TO_ADDR
// for i = tmp downto 1 do
19496: LD_ADDR_VAR 0 7
19500: PUSH
19501: DOUBLE
19502: LD_VAR 0 9
19506: INC
19507: ST_TO_ADDR
19508: LD_INT 1
19510: PUSH
19511: FOR_DOWNTO
19512: IFFALSE 19557
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19514: LD_ADDR_VAR 0 6
19518: PUSH
19519: LD_VAR 0 6
19523: PPUSH
19524: LD_VAR 0 9
19528: PUSH
19529: LD_VAR 0 7
19533: MINUS
19534: PUSH
19535: LD_INT 1
19537: PLUS
19538: PPUSH
19539: LD_VAR 0 9
19543: PUSH
19544: LD_VAR 0 7
19548: ARRAY
19549: PPUSH
19550: CALL_OW 1
19554: ST_TO_ADDR
19555: GO 19511
19557: POP
19558: POP
// end ; tmp := [ ] ;
19559: LD_ADDR_VAR 0 9
19563: PUSH
19564: EMPTY
19565: ST_TO_ADDR
// if mode then
19566: LD_VAR 0 5
19570: IFFALSE 19639
// begin for i = 1 to result do
19572: LD_ADDR_VAR 0 7
19576: PUSH
19577: DOUBLE
19578: LD_INT 1
19580: DEC
19581: ST_TO_ADDR
19582: LD_VAR 0 6
19586: PUSH
19587: FOR_TO
19588: IFFALSE 19627
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19590: LD_ADDR_VAR 0 9
19594: PUSH
19595: LD_VAR 0 9
19599: PPUSH
19600: LD_VAR 0 7
19604: PPUSH
19605: LD_VAR 0 6
19609: PUSH
19610: LD_VAR 0 7
19614: ARRAY
19615: PUSH
19616: LD_INT 1
19618: ARRAY
19619: PPUSH
19620: CALL_OW 1
19624: ST_TO_ADDR
19625: GO 19587
19627: POP
19628: POP
// result := tmp ;
19629: LD_ADDR_VAR 0 6
19633: PUSH
19634: LD_VAR 0 9
19638: ST_TO_ADDR
// end ; end ;
19639: LD_VAR 0 6
19643: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19644: LD_INT 0
19646: PPUSH
19647: PPUSH
19648: PPUSH
19649: PPUSH
19650: PPUSH
19651: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19652: LD_ADDR_VAR 0 5
19656: PUSH
19657: LD_INT 0
19659: PUSH
19660: LD_INT 0
19662: PUSH
19663: LD_INT 0
19665: PUSH
19666: EMPTY
19667: PUSH
19668: EMPTY
19669: LIST
19670: LIST
19671: LIST
19672: LIST
19673: ST_TO_ADDR
// if not x or not y then
19674: LD_VAR 0 2
19678: NOT
19679: PUSH
19680: LD_VAR 0 3
19684: NOT
19685: OR
19686: IFFALSE 19690
// exit ;
19688: GO 21340
// if not range then
19690: LD_VAR 0 4
19694: NOT
19695: IFFALSE 19705
// range := 10 ;
19697: LD_ADDR_VAR 0 4
19701: PUSH
19702: LD_INT 10
19704: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19705: LD_ADDR_VAR 0 8
19709: PUSH
19710: LD_INT 81
19712: PUSH
19713: LD_VAR 0 1
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: LD_INT 92
19724: PUSH
19725: LD_VAR 0 2
19729: PUSH
19730: LD_VAR 0 3
19734: PUSH
19735: LD_VAR 0 4
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 3
19748: PUSH
19749: LD_INT 21
19751: PUSH
19752: LD_INT 3
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: LIST
19767: PPUSH
19768: CALL_OW 69
19772: ST_TO_ADDR
// if not tmp then
19773: LD_VAR 0 8
19777: NOT
19778: IFFALSE 19782
// exit ;
19780: GO 21340
// for i in tmp do
19782: LD_ADDR_VAR 0 6
19786: PUSH
19787: LD_VAR 0 8
19791: PUSH
19792: FOR_IN
19793: IFFALSE 21315
// begin points := [ 0 , 0 , 0 ] ;
19795: LD_ADDR_VAR 0 9
19799: PUSH
19800: LD_INT 0
19802: PUSH
19803: LD_INT 0
19805: PUSH
19806: LD_INT 0
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: LIST
19813: ST_TO_ADDR
// bpoints := 1 ;
19814: LD_ADDR_VAR 0 10
19818: PUSH
19819: LD_INT 1
19821: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19822: LD_VAR 0 6
19826: PPUSH
19827: CALL_OW 247
19831: PUSH
19832: LD_INT 1
19834: DOUBLE
19835: EQUAL
19836: IFTRUE 19840
19838: GO 20418
19840: POP
// begin if GetClass ( i ) = 1 then
19841: LD_VAR 0 6
19845: PPUSH
19846: CALL_OW 257
19850: PUSH
19851: LD_INT 1
19853: EQUAL
19854: IFFALSE 19875
// points := [ 10 , 5 , 3 ] ;
19856: LD_ADDR_VAR 0 9
19860: PUSH
19861: LD_INT 10
19863: PUSH
19864: LD_INT 5
19866: PUSH
19867: LD_INT 3
19869: PUSH
19870: EMPTY
19871: LIST
19872: LIST
19873: LIST
19874: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19875: LD_VAR 0 6
19879: PPUSH
19880: CALL_OW 257
19884: PUSH
19885: LD_INT 2
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 4
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: LIST
19898: IN
19899: IFFALSE 19920
// points := [ 3 , 2 , 1 ] ;
19901: LD_ADDR_VAR 0 9
19905: PUSH
19906: LD_INT 3
19908: PUSH
19909: LD_INT 2
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: LIST
19919: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19920: LD_VAR 0 6
19924: PPUSH
19925: CALL_OW 257
19929: PUSH
19930: LD_INT 5
19932: EQUAL
19933: IFFALSE 19954
// points := [ 130 , 5 , 2 ] ;
19935: LD_ADDR_VAR 0 9
19939: PUSH
19940: LD_INT 130
19942: PUSH
19943: LD_INT 5
19945: PUSH
19946: LD_INT 2
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19954: LD_VAR 0 6
19958: PPUSH
19959: CALL_OW 257
19963: PUSH
19964: LD_INT 8
19966: EQUAL
19967: IFFALSE 19988
// points := [ 35 , 35 , 30 ] ;
19969: LD_ADDR_VAR 0 9
19973: PUSH
19974: LD_INT 35
19976: PUSH
19977: LD_INT 35
19979: PUSH
19980: LD_INT 30
19982: PUSH
19983: EMPTY
19984: LIST
19985: LIST
19986: LIST
19987: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19988: LD_VAR 0 6
19992: PPUSH
19993: CALL_OW 257
19997: PUSH
19998: LD_INT 9
20000: EQUAL
20001: IFFALSE 20022
// points := [ 20 , 55 , 40 ] ;
20003: LD_ADDR_VAR 0 9
20007: PUSH
20008: LD_INT 20
20010: PUSH
20011: LD_INT 55
20013: PUSH
20014: LD_INT 40
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: LIST
20021: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20022: LD_VAR 0 6
20026: PPUSH
20027: CALL_OW 257
20031: PUSH
20032: LD_INT 12
20034: PUSH
20035: LD_INT 16
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: IN
20042: IFFALSE 20063
// points := [ 5 , 3 , 2 ] ;
20044: LD_ADDR_VAR 0 9
20048: PUSH
20049: LD_INT 5
20051: PUSH
20052: LD_INT 3
20054: PUSH
20055: LD_INT 2
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: LIST
20062: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20063: LD_VAR 0 6
20067: PPUSH
20068: CALL_OW 257
20072: PUSH
20073: LD_INT 17
20075: EQUAL
20076: IFFALSE 20097
// points := [ 100 , 50 , 75 ] ;
20078: LD_ADDR_VAR 0 9
20082: PUSH
20083: LD_INT 100
20085: PUSH
20086: LD_INT 50
20088: PUSH
20089: LD_INT 75
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: LIST
20096: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20097: LD_VAR 0 6
20101: PPUSH
20102: CALL_OW 257
20106: PUSH
20107: LD_INT 15
20109: EQUAL
20110: IFFALSE 20131
// points := [ 10 , 5 , 3 ] ;
20112: LD_ADDR_VAR 0 9
20116: PUSH
20117: LD_INT 10
20119: PUSH
20120: LD_INT 5
20122: PUSH
20123: LD_INT 3
20125: PUSH
20126: EMPTY
20127: LIST
20128: LIST
20129: LIST
20130: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20131: LD_VAR 0 6
20135: PPUSH
20136: CALL_OW 257
20140: PUSH
20141: LD_INT 14
20143: EQUAL
20144: IFFALSE 20165
// points := [ 10 , 0 , 0 ] ;
20146: LD_ADDR_VAR 0 9
20150: PUSH
20151: LD_INT 10
20153: PUSH
20154: LD_INT 0
20156: PUSH
20157: LD_INT 0
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: LIST
20164: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20165: LD_VAR 0 6
20169: PPUSH
20170: CALL_OW 257
20174: PUSH
20175: LD_INT 11
20177: EQUAL
20178: IFFALSE 20199
// points := [ 30 , 10 , 5 ] ;
20180: LD_ADDR_VAR 0 9
20184: PUSH
20185: LD_INT 30
20187: PUSH
20188: LD_INT 10
20190: PUSH
20191: LD_INT 5
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20199: LD_VAR 0 1
20203: PPUSH
20204: LD_INT 5
20206: PPUSH
20207: CALL_OW 321
20211: PUSH
20212: LD_INT 2
20214: EQUAL
20215: IFFALSE 20232
// bpoints := bpoints * 1.8 ;
20217: LD_ADDR_VAR 0 10
20221: PUSH
20222: LD_VAR 0 10
20226: PUSH
20227: LD_REAL  1.80000000000000E+0000
20230: MUL
20231: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20232: LD_VAR 0 6
20236: PPUSH
20237: CALL_OW 257
20241: PUSH
20242: LD_INT 1
20244: PUSH
20245: LD_INT 2
20247: PUSH
20248: LD_INT 3
20250: PUSH
20251: LD_INT 4
20253: PUSH
20254: EMPTY
20255: LIST
20256: LIST
20257: LIST
20258: LIST
20259: IN
20260: PUSH
20261: LD_VAR 0 1
20265: PPUSH
20266: LD_INT 51
20268: PPUSH
20269: CALL_OW 321
20273: PUSH
20274: LD_INT 2
20276: EQUAL
20277: AND
20278: IFFALSE 20295
// bpoints := bpoints * 1.2 ;
20280: LD_ADDR_VAR 0 10
20284: PUSH
20285: LD_VAR 0 10
20289: PUSH
20290: LD_REAL  1.20000000000000E+0000
20293: MUL
20294: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20295: LD_VAR 0 6
20299: PPUSH
20300: CALL_OW 257
20304: PUSH
20305: LD_INT 5
20307: PUSH
20308: LD_INT 7
20310: PUSH
20311: LD_INT 9
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: LIST
20318: IN
20319: PUSH
20320: LD_VAR 0 1
20324: PPUSH
20325: LD_INT 52
20327: PPUSH
20328: CALL_OW 321
20332: PUSH
20333: LD_INT 2
20335: EQUAL
20336: AND
20337: IFFALSE 20354
// bpoints := bpoints * 1.5 ;
20339: LD_ADDR_VAR 0 10
20343: PUSH
20344: LD_VAR 0 10
20348: PUSH
20349: LD_REAL  1.50000000000000E+0000
20352: MUL
20353: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20354: LD_VAR 0 1
20358: PPUSH
20359: LD_INT 66
20361: PPUSH
20362: CALL_OW 321
20366: PUSH
20367: LD_INT 2
20369: EQUAL
20370: IFFALSE 20387
// bpoints := bpoints * 1.1 ;
20372: LD_ADDR_VAR 0 10
20376: PUSH
20377: LD_VAR 0 10
20381: PUSH
20382: LD_REAL  1.10000000000000E+0000
20385: MUL
20386: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20387: LD_ADDR_VAR 0 10
20391: PUSH
20392: LD_VAR 0 10
20396: PUSH
20397: LD_VAR 0 6
20401: PPUSH
20402: LD_INT 1
20404: PPUSH
20405: CALL_OW 259
20409: PUSH
20410: LD_REAL  1.15000000000000E+0000
20413: MUL
20414: MUL
20415: ST_TO_ADDR
// end ; unit_vehicle :
20416: GO 21244
20418: LD_INT 2
20420: DOUBLE
20421: EQUAL
20422: IFTRUE 20426
20424: GO 21232
20426: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20427: LD_VAR 0 6
20431: PPUSH
20432: CALL_OW 264
20436: PUSH
20437: LD_INT 2
20439: PUSH
20440: LD_INT 42
20442: PUSH
20443: LD_INT 24
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: LIST
20450: IN
20451: IFFALSE 20472
// points := [ 25 , 5 , 3 ] ;
20453: LD_ADDR_VAR 0 9
20457: PUSH
20458: LD_INT 25
20460: PUSH
20461: LD_INT 5
20463: PUSH
20464: LD_INT 3
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: LIST
20471: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20472: LD_VAR 0 6
20476: PPUSH
20477: CALL_OW 264
20481: PUSH
20482: LD_INT 4
20484: PUSH
20485: LD_INT 43
20487: PUSH
20488: LD_INT 25
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: IN
20496: IFFALSE 20517
// points := [ 40 , 15 , 5 ] ;
20498: LD_ADDR_VAR 0 9
20502: PUSH
20503: LD_INT 40
20505: PUSH
20506: LD_INT 15
20508: PUSH
20509: LD_INT 5
20511: PUSH
20512: EMPTY
20513: LIST
20514: LIST
20515: LIST
20516: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20517: LD_VAR 0 6
20521: PPUSH
20522: CALL_OW 264
20526: PUSH
20527: LD_INT 3
20529: PUSH
20530: LD_INT 23
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: IN
20537: IFFALSE 20558
// points := [ 7 , 25 , 8 ] ;
20539: LD_ADDR_VAR 0 9
20543: PUSH
20544: LD_INT 7
20546: PUSH
20547: LD_INT 25
20549: PUSH
20550: LD_INT 8
20552: PUSH
20553: EMPTY
20554: LIST
20555: LIST
20556: LIST
20557: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20558: LD_VAR 0 6
20562: PPUSH
20563: CALL_OW 264
20567: PUSH
20568: LD_INT 5
20570: PUSH
20571: LD_INT 27
20573: PUSH
20574: LD_INT 44
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: LIST
20581: IN
20582: IFFALSE 20603
// points := [ 14 , 50 , 16 ] ;
20584: LD_ADDR_VAR 0 9
20588: PUSH
20589: LD_INT 14
20591: PUSH
20592: LD_INT 50
20594: PUSH
20595: LD_INT 16
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: LIST
20602: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20603: LD_VAR 0 6
20607: PPUSH
20608: CALL_OW 264
20612: PUSH
20613: LD_INT 6
20615: PUSH
20616: LD_INT 46
20618: PUSH
20619: EMPTY
20620: LIST
20621: LIST
20622: IN
20623: IFFALSE 20644
// points := [ 32 , 120 , 70 ] ;
20625: LD_ADDR_VAR 0 9
20629: PUSH
20630: LD_INT 32
20632: PUSH
20633: LD_INT 120
20635: PUSH
20636: LD_INT 70
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: LIST
20643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20644: LD_VAR 0 6
20648: PPUSH
20649: CALL_OW 264
20653: PUSH
20654: LD_INT 7
20656: PUSH
20657: LD_INT 28
20659: PUSH
20660: LD_INT 45
20662: PUSH
20663: LD_INT 92
20665: PUSH
20666: EMPTY
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: IN
20672: IFFALSE 20693
// points := [ 35 , 20 , 45 ] ;
20674: LD_ADDR_VAR 0 9
20678: PUSH
20679: LD_INT 35
20681: PUSH
20682: LD_INT 20
20684: PUSH
20685: LD_INT 45
20687: PUSH
20688: EMPTY
20689: LIST
20690: LIST
20691: LIST
20692: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20693: LD_VAR 0 6
20697: PPUSH
20698: CALL_OW 264
20702: PUSH
20703: LD_INT 47
20705: PUSH
20706: EMPTY
20707: LIST
20708: IN
20709: IFFALSE 20730
// points := [ 67 , 45 , 75 ] ;
20711: LD_ADDR_VAR 0 9
20715: PUSH
20716: LD_INT 67
20718: PUSH
20719: LD_INT 45
20721: PUSH
20722: LD_INT 75
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20730: LD_VAR 0 6
20734: PPUSH
20735: CALL_OW 264
20739: PUSH
20740: LD_INT 26
20742: PUSH
20743: EMPTY
20744: LIST
20745: IN
20746: IFFALSE 20767
// points := [ 120 , 30 , 80 ] ;
20748: LD_ADDR_VAR 0 9
20752: PUSH
20753: LD_INT 120
20755: PUSH
20756: LD_INT 30
20758: PUSH
20759: LD_INT 80
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: LIST
20766: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20767: LD_VAR 0 6
20771: PPUSH
20772: CALL_OW 264
20776: PUSH
20777: LD_INT 22
20779: PUSH
20780: EMPTY
20781: LIST
20782: IN
20783: IFFALSE 20804
// points := [ 40 , 1 , 1 ] ;
20785: LD_ADDR_VAR 0 9
20789: PUSH
20790: LD_INT 40
20792: PUSH
20793: LD_INT 1
20795: PUSH
20796: LD_INT 1
20798: PUSH
20799: EMPTY
20800: LIST
20801: LIST
20802: LIST
20803: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20804: LD_VAR 0 6
20808: PPUSH
20809: CALL_OW 264
20813: PUSH
20814: LD_INT 29
20816: PUSH
20817: EMPTY
20818: LIST
20819: IN
20820: IFFALSE 20841
// points := [ 70 , 200 , 400 ] ;
20822: LD_ADDR_VAR 0 9
20826: PUSH
20827: LD_INT 70
20829: PUSH
20830: LD_INT 200
20832: PUSH
20833: LD_INT 400
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: LIST
20840: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20841: LD_VAR 0 6
20845: PPUSH
20846: CALL_OW 264
20850: PUSH
20851: LD_INT 14
20853: PUSH
20854: LD_INT 53
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: IN
20861: IFFALSE 20882
// points := [ 40 , 10 , 20 ] ;
20863: LD_ADDR_VAR 0 9
20867: PUSH
20868: LD_INT 40
20870: PUSH
20871: LD_INT 10
20873: PUSH
20874: LD_INT 20
20876: PUSH
20877: EMPTY
20878: LIST
20879: LIST
20880: LIST
20881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20882: LD_VAR 0 6
20886: PPUSH
20887: CALL_OW 264
20891: PUSH
20892: LD_INT 9
20894: PUSH
20895: EMPTY
20896: LIST
20897: IN
20898: IFFALSE 20919
// points := [ 5 , 70 , 20 ] ;
20900: LD_ADDR_VAR 0 9
20904: PUSH
20905: LD_INT 5
20907: PUSH
20908: LD_INT 70
20910: PUSH
20911: LD_INT 20
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: LIST
20918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20919: LD_VAR 0 6
20923: PPUSH
20924: CALL_OW 264
20928: PUSH
20929: LD_INT 10
20931: PUSH
20932: EMPTY
20933: LIST
20934: IN
20935: IFFALSE 20956
// points := [ 35 , 110 , 70 ] ;
20937: LD_ADDR_VAR 0 9
20941: PUSH
20942: LD_INT 35
20944: PUSH
20945: LD_INT 110
20947: PUSH
20948: LD_INT 70
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: LIST
20955: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20956: LD_VAR 0 6
20960: PPUSH
20961: CALL_OW 265
20965: PUSH
20966: LD_INT 25
20968: EQUAL
20969: IFFALSE 20990
// points := [ 80 , 65 , 100 ] ;
20971: LD_ADDR_VAR 0 9
20975: PUSH
20976: LD_INT 80
20978: PUSH
20979: LD_INT 65
20981: PUSH
20982: LD_INT 100
20984: PUSH
20985: EMPTY
20986: LIST
20987: LIST
20988: LIST
20989: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20990: LD_VAR 0 6
20994: PPUSH
20995: CALL_OW 263
20999: PUSH
21000: LD_INT 1
21002: EQUAL
21003: IFFALSE 21038
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21005: LD_ADDR_VAR 0 10
21009: PUSH
21010: LD_VAR 0 10
21014: PUSH
21015: LD_VAR 0 6
21019: PPUSH
21020: CALL_OW 311
21024: PPUSH
21025: LD_INT 3
21027: PPUSH
21028: CALL_OW 259
21032: PUSH
21033: LD_INT 4
21035: MUL
21036: MUL
21037: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21038: LD_VAR 0 6
21042: PPUSH
21043: CALL_OW 263
21047: PUSH
21048: LD_INT 2
21050: EQUAL
21051: IFFALSE 21102
// begin j := IsControledBy ( i ) ;
21053: LD_ADDR_VAR 0 7
21057: PUSH
21058: LD_VAR 0 6
21062: PPUSH
21063: CALL_OW 312
21067: ST_TO_ADDR
// if j then
21068: LD_VAR 0 7
21072: IFFALSE 21102
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21074: LD_ADDR_VAR 0 10
21078: PUSH
21079: LD_VAR 0 10
21083: PUSH
21084: LD_VAR 0 7
21088: PPUSH
21089: LD_INT 3
21091: PPUSH
21092: CALL_OW 259
21096: PUSH
21097: LD_INT 3
21099: MUL
21100: MUL
21101: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21102: LD_VAR 0 6
21106: PPUSH
21107: CALL_OW 264
21111: PUSH
21112: LD_INT 5
21114: PUSH
21115: LD_INT 6
21117: PUSH
21118: LD_INT 46
21120: PUSH
21121: LD_INT 44
21123: PUSH
21124: LD_INT 47
21126: PUSH
21127: LD_INT 45
21129: PUSH
21130: LD_INT 28
21132: PUSH
21133: LD_INT 7
21135: PUSH
21136: LD_INT 27
21138: PUSH
21139: LD_INT 29
21141: PUSH
21142: EMPTY
21143: LIST
21144: LIST
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: IN
21154: PUSH
21155: LD_VAR 0 1
21159: PPUSH
21160: LD_INT 52
21162: PPUSH
21163: CALL_OW 321
21167: PUSH
21168: LD_INT 2
21170: EQUAL
21171: AND
21172: IFFALSE 21189
// bpoints := bpoints * 1.2 ;
21174: LD_ADDR_VAR 0 10
21178: PUSH
21179: LD_VAR 0 10
21183: PUSH
21184: LD_REAL  1.20000000000000E+0000
21187: MUL
21188: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21189: LD_VAR 0 6
21193: PPUSH
21194: CALL_OW 264
21198: PUSH
21199: LD_INT 6
21201: PUSH
21202: LD_INT 46
21204: PUSH
21205: LD_INT 47
21207: PUSH
21208: EMPTY
21209: LIST
21210: LIST
21211: LIST
21212: IN
21213: IFFALSE 21230
// bpoints := bpoints * 1.2 ;
21215: LD_ADDR_VAR 0 10
21219: PUSH
21220: LD_VAR 0 10
21224: PUSH
21225: LD_REAL  1.20000000000000E+0000
21228: MUL
21229: ST_TO_ADDR
// end ; unit_building :
21230: GO 21244
21232: LD_INT 3
21234: DOUBLE
21235: EQUAL
21236: IFTRUE 21240
21238: GO 21243
21240: POP
// ; end ;
21241: GO 21244
21243: POP
// for j = 1 to 3 do
21244: LD_ADDR_VAR 0 7
21248: PUSH
21249: DOUBLE
21250: LD_INT 1
21252: DEC
21253: ST_TO_ADDR
21254: LD_INT 3
21256: PUSH
21257: FOR_TO
21258: IFFALSE 21311
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21260: LD_ADDR_VAR 0 5
21264: PUSH
21265: LD_VAR 0 5
21269: PPUSH
21270: LD_VAR 0 7
21274: PPUSH
21275: LD_VAR 0 5
21279: PUSH
21280: LD_VAR 0 7
21284: ARRAY
21285: PUSH
21286: LD_VAR 0 9
21290: PUSH
21291: LD_VAR 0 7
21295: ARRAY
21296: PUSH
21297: LD_VAR 0 10
21301: MUL
21302: PLUS
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
21309: GO 21257
21311: POP
21312: POP
// end ;
21313: GO 19792
21315: POP
21316: POP
// result := Replace ( result , 4 , tmp ) ;
21317: LD_ADDR_VAR 0 5
21321: PUSH
21322: LD_VAR 0 5
21326: PPUSH
21327: LD_INT 4
21329: PPUSH
21330: LD_VAR 0 8
21334: PPUSH
21335: CALL_OW 1
21339: ST_TO_ADDR
// end ;
21340: LD_VAR 0 5
21344: RET
// export function DangerAtRange ( unit , range ) ; begin
21345: LD_INT 0
21347: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21348: LD_ADDR_VAR 0 3
21352: PUSH
21353: LD_VAR 0 1
21357: PPUSH
21358: CALL_OW 255
21362: PPUSH
21363: LD_VAR 0 1
21367: PPUSH
21368: CALL_OW 250
21372: PPUSH
21373: LD_VAR 0 1
21377: PPUSH
21378: CALL_OW 251
21382: PPUSH
21383: LD_VAR 0 2
21387: PPUSH
21388: CALL 19644 0 4
21392: ST_TO_ADDR
// end ;
21393: LD_VAR 0 3
21397: RET
// export function DangerInArea ( side , area ) ; begin
21398: LD_INT 0
21400: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21401: LD_ADDR_VAR 0 3
21405: PUSH
21406: LD_VAR 0 2
21410: PPUSH
21411: LD_INT 81
21413: PUSH
21414: LD_VAR 0 1
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PPUSH
21423: CALL_OW 70
21427: ST_TO_ADDR
// end ;
21428: LD_VAR 0 3
21432: RET
// export function IsExtension ( b ) ; begin
21433: LD_INT 0
21435: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21436: LD_ADDR_VAR 0 2
21440: PUSH
21441: LD_VAR 0 1
21445: PUSH
21446: LD_INT 23
21448: PUSH
21449: LD_INT 20
21451: PUSH
21452: LD_INT 22
21454: PUSH
21455: LD_INT 17
21457: PUSH
21458: LD_INT 24
21460: PUSH
21461: LD_INT 21
21463: PUSH
21464: LD_INT 19
21466: PUSH
21467: LD_INT 16
21469: PUSH
21470: LD_INT 25
21472: PUSH
21473: LD_INT 18
21475: PUSH
21476: EMPTY
21477: LIST
21478: LIST
21479: LIST
21480: LIST
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: LIST
21487: IN
21488: ST_TO_ADDR
// end ;
21489: LD_VAR 0 2
21493: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21494: LD_INT 0
21496: PPUSH
21497: PPUSH
21498: PPUSH
// result := [ ] ;
21499: LD_ADDR_VAR 0 4
21503: PUSH
21504: EMPTY
21505: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21506: LD_ADDR_VAR 0 5
21510: PUSH
21511: LD_VAR 0 2
21515: PPUSH
21516: LD_INT 21
21518: PUSH
21519: LD_INT 3
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PPUSH
21526: CALL_OW 70
21530: ST_TO_ADDR
// if not tmp then
21531: LD_VAR 0 5
21535: NOT
21536: IFFALSE 21540
// exit ;
21538: GO 21604
// if checkLink then
21540: LD_VAR 0 3
21544: IFFALSE 21594
// begin for i in tmp do
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 5
21555: PUSH
21556: FOR_IN
21557: IFFALSE 21592
// if GetBase ( i ) <> base then
21559: LD_VAR 0 6
21563: PPUSH
21564: CALL_OW 274
21568: PUSH
21569: LD_VAR 0 1
21573: NONEQUAL
21574: IFFALSE 21590
// ComLinkToBase ( base , i ) ;
21576: LD_VAR 0 1
21580: PPUSH
21581: LD_VAR 0 6
21585: PPUSH
21586: CALL_OW 169
21590: GO 21556
21592: POP
21593: POP
// end ; result := tmp ;
21594: LD_ADDR_VAR 0 4
21598: PUSH
21599: LD_VAR 0 5
21603: ST_TO_ADDR
// end ;
21604: LD_VAR 0 4
21608: RET
// export function ComComplete ( units , b ) ; var i ; begin
21609: LD_INT 0
21611: PPUSH
21612: PPUSH
// if not units then
21613: LD_VAR 0 1
21617: NOT
21618: IFFALSE 21622
// exit ;
21620: GO 21712
// for i in units do
21622: LD_ADDR_VAR 0 4
21626: PUSH
21627: LD_VAR 0 1
21631: PUSH
21632: FOR_IN
21633: IFFALSE 21710
// if BuildingStatus ( b ) = bs_build then
21635: LD_VAR 0 2
21639: PPUSH
21640: CALL_OW 461
21644: PUSH
21645: LD_INT 1
21647: EQUAL
21648: IFFALSE 21708
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21650: LD_VAR 0 4
21654: PPUSH
21655: LD_STRING h
21657: PUSH
21658: LD_VAR 0 2
21662: PPUSH
21663: CALL_OW 250
21667: PUSH
21668: LD_VAR 0 2
21672: PPUSH
21673: CALL_OW 251
21677: PUSH
21678: LD_VAR 0 2
21682: PUSH
21683: LD_INT 0
21685: PUSH
21686: LD_INT 0
21688: PUSH
21689: LD_INT 0
21691: PUSH
21692: EMPTY
21693: LIST
21694: LIST
21695: LIST
21696: LIST
21697: LIST
21698: LIST
21699: LIST
21700: PUSH
21701: EMPTY
21702: LIST
21703: PPUSH
21704: CALL_OW 446
21708: GO 21632
21710: POP
21711: POP
// end ;
21712: LD_VAR 0 3
21716: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21717: LD_INT 0
21719: PPUSH
21720: PPUSH
21721: PPUSH
21722: PPUSH
21723: PPUSH
21724: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21725: LD_VAR 0 1
21729: NOT
21730: PUSH
21731: LD_VAR 0 1
21735: PPUSH
21736: CALL_OW 263
21740: PUSH
21741: LD_INT 2
21743: NONEQUAL
21744: OR
21745: IFFALSE 21749
// exit ;
21747: GO 22065
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21749: LD_ADDR_VAR 0 6
21753: PUSH
21754: LD_INT 22
21756: PUSH
21757: LD_VAR 0 1
21761: PPUSH
21762: CALL_OW 255
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 2
21773: PUSH
21774: LD_INT 30
21776: PUSH
21777: LD_INT 36
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: PUSH
21784: LD_INT 34
21786: PUSH
21787: LD_INT 31
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: LIST
21798: PUSH
21799: EMPTY
21800: LIST
21801: LIST
21802: PPUSH
21803: CALL_OW 69
21807: ST_TO_ADDR
// if not tmp then
21808: LD_VAR 0 6
21812: NOT
21813: IFFALSE 21817
// exit ;
21815: GO 22065
// result := [ ] ;
21817: LD_ADDR_VAR 0 2
21821: PUSH
21822: EMPTY
21823: ST_TO_ADDR
// for i in tmp do
21824: LD_ADDR_VAR 0 3
21828: PUSH
21829: LD_VAR 0 6
21833: PUSH
21834: FOR_IN
21835: IFFALSE 21906
// begin t := UnitsInside ( i ) ;
21837: LD_ADDR_VAR 0 4
21841: PUSH
21842: LD_VAR 0 3
21846: PPUSH
21847: CALL_OW 313
21851: ST_TO_ADDR
// if t then
21852: LD_VAR 0 4
21856: IFFALSE 21904
// for j in t do
21858: LD_ADDR_VAR 0 7
21862: PUSH
21863: LD_VAR 0 4
21867: PUSH
21868: FOR_IN
21869: IFFALSE 21902
// result := Replace ( result , result + 1 , j ) ;
21871: LD_ADDR_VAR 0 2
21875: PUSH
21876: LD_VAR 0 2
21880: PPUSH
21881: LD_VAR 0 2
21885: PUSH
21886: LD_INT 1
21888: PLUS
21889: PPUSH
21890: LD_VAR 0 7
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
21900: GO 21868
21902: POP
21903: POP
// end ;
21904: GO 21834
21906: POP
21907: POP
// if not result then
21908: LD_VAR 0 2
21912: NOT
21913: IFFALSE 21917
// exit ;
21915: GO 22065
// mech := result [ 1 ] ;
21917: LD_ADDR_VAR 0 5
21921: PUSH
21922: LD_VAR 0 2
21926: PUSH
21927: LD_INT 1
21929: ARRAY
21930: ST_TO_ADDR
// if result > 1 then
21931: LD_VAR 0 2
21935: PUSH
21936: LD_INT 1
21938: GREATER
21939: IFFALSE 22051
// begin for i = 2 to result do
21941: LD_ADDR_VAR 0 3
21945: PUSH
21946: DOUBLE
21947: LD_INT 2
21949: DEC
21950: ST_TO_ADDR
21951: LD_VAR 0 2
21955: PUSH
21956: FOR_TO
21957: IFFALSE 22049
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: LD_VAR 0 2
21968: PUSH
21969: LD_VAR 0 3
21973: ARRAY
21974: PPUSH
21975: LD_INT 3
21977: PPUSH
21978: CALL_OW 259
21982: PUSH
21983: LD_VAR 0 2
21987: PUSH
21988: LD_VAR 0 3
21992: ARRAY
21993: PPUSH
21994: CALL_OW 432
21998: MINUS
21999: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22000: LD_VAR 0 4
22004: PUSH
22005: LD_VAR 0 5
22009: PPUSH
22010: LD_INT 3
22012: PPUSH
22013: CALL_OW 259
22017: PUSH
22018: LD_VAR 0 5
22022: PPUSH
22023: CALL_OW 432
22027: MINUS
22028: GREATEREQUAL
22029: IFFALSE 22047
// mech := result [ i ] ;
22031: LD_ADDR_VAR 0 5
22035: PUSH
22036: LD_VAR 0 2
22040: PUSH
22041: LD_VAR 0 3
22045: ARRAY
22046: ST_TO_ADDR
// end ;
22047: GO 21956
22049: POP
22050: POP
// end ; ComLinkTo ( vehicle , mech ) ;
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_VAR 0 5
22060: PPUSH
22061: CALL_OW 135
// end ;
22065: LD_VAR 0 2
22069: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22070: LD_INT 0
22072: PPUSH
22073: PPUSH
22074: PPUSH
22075: PPUSH
22076: PPUSH
22077: PPUSH
22078: PPUSH
22079: PPUSH
22080: PPUSH
22081: PPUSH
22082: PPUSH
22083: PPUSH
22084: PPUSH
// result := [ ] ;
22085: LD_ADDR_VAR 0 7
22089: PUSH
22090: EMPTY
22091: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22092: LD_VAR 0 1
22096: PPUSH
22097: CALL_OW 266
22101: PUSH
22102: LD_INT 0
22104: PUSH
22105: LD_INT 1
22107: PUSH
22108: EMPTY
22109: LIST
22110: LIST
22111: IN
22112: NOT
22113: IFFALSE 22117
// exit ;
22115: GO 23751
// if name then
22117: LD_VAR 0 3
22121: IFFALSE 22137
// SetBName ( base_dep , name ) ;
22123: LD_VAR 0 1
22127: PPUSH
22128: LD_VAR 0 3
22132: PPUSH
22133: CALL_OW 500
// base := GetBase ( base_dep ) ;
22137: LD_ADDR_VAR 0 15
22141: PUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: CALL_OW 274
22151: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22152: LD_ADDR_VAR 0 16
22156: PUSH
22157: LD_VAR 0 1
22161: PPUSH
22162: CALL_OW 255
22166: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22167: LD_ADDR_VAR 0 17
22171: PUSH
22172: LD_VAR 0 1
22176: PPUSH
22177: CALL_OW 248
22181: ST_TO_ADDR
// if sources then
22182: LD_VAR 0 5
22186: IFFALSE 22233
// for i = 1 to 3 do
22188: LD_ADDR_VAR 0 8
22192: PUSH
22193: DOUBLE
22194: LD_INT 1
22196: DEC
22197: ST_TO_ADDR
22198: LD_INT 3
22200: PUSH
22201: FOR_TO
22202: IFFALSE 22231
// AddResourceType ( base , i , sources [ i ] ) ;
22204: LD_VAR 0 15
22208: PPUSH
22209: LD_VAR 0 8
22213: PPUSH
22214: LD_VAR 0 5
22218: PUSH
22219: LD_VAR 0 8
22223: ARRAY
22224: PPUSH
22225: CALL_OW 276
22229: GO 22201
22231: POP
22232: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22233: LD_ADDR_VAR 0 18
22237: PUSH
22238: LD_VAR 0 15
22242: PPUSH
22243: LD_VAR 0 2
22247: PPUSH
22248: LD_INT 1
22250: PPUSH
22251: CALL 21494 0 3
22255: ST_TO_ADDR
// InitHc ;
22256: CALL_OW 19
// InitUc ;
22260: CALL_OW 18
// uc_side := side ;
22264: LD_ADDR_OWVAR 20
22268: PUSH
22269: LD_VAR 0 16
22273: ST_TO_ADDR
// uc_nation := nation ;
22274: LD_ADDR_OWVAR 21
22278: PUSH
22279: LD_VAR 0 17
22283: ST_TO_ADDR
// if buildings then
22284: LD_VAR 0 18
22288: IFFALSE 23610
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22290: LD_ADDR_VAR 0 19
22294: PUSH
22295: LD_VAR 0 18
22299: PPUSH
22300: LD_INT 2
22302: PUSH
22303: LD_INT 30
22305: PUSH
22306: LD_INT 29
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 30
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: LIST
22327: PPUSH
22328: CALL_OW 72
22332: ST_TO_ADDR
// if tmp then
22333: LD_VAR 0 19
22337: IFFALSE 22385
// for i in tmp do
22339: LD_ADDR_VAR 0 8
22343: PUSH
22344: LD_VAR 0 19
22348: PUSH
22349: FOR_IN
22350: IFFALSE 22383
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22352: LD_VAR 0 8
22356: PPUSH
22357: CALL_OW 250
22361: PPUSH
22362: LD_VAR 0 8
22366: PPUSH
22367: CALL_OW 251
22371: PPUSH
22372: LD_VAR 0 16
22376: PPUSH
22377: CALL_OW 441
22381: GO 22349
22383: POP
22384: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22385: LD_VAR 0 18
22389: PPUSH
22390: LD_INT 2
22392: PUSH
22393: LD_INT 30
22395: PUSH
22396: LD_INT 32
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 33
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: LIST
22417: PPUSH
22418: CALL_OW 72
22422: IFFALSE 22510
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22424: LD_ADDR_VAR 0 8
22428: PUSH
22429: LD_VAR 0 18
22433: PPUSH
22434: LD_INT 2
22436: PUSH
22437: LD_INT 30
22439: PUSH
22440: LD_INT 32
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 30
22449: PUSH
22450: LD_INT 33
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: LIST
22461: PPUSH
22462: CALL_OW 72
22466: PUSH
22467: FOR_IN
22468: IFFALSE 22508
// begin if not GetBWeapon ( i ) then
22470: LD_VAR 0 8
22474: PPUSH
22475: CALL_OW 269
22479: NOT
22480: IFFALSE 22506
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22482: LD_VAR 0 8
22486: PPUSH
22487: LD_VAR 0 8
22491: PPUSH
22492: LD_VAR 0 2
22496: PPUSH
22497: CALL 23756 0 2
22501: PPUSH
22502: CALL_OW 431
// end ;
22506: GO 22467
22508: POP
22509: POP
// end ; for i = 1 to personel do
22510: LD_ADDR_VAR 0 8
22514: PUSH
22515: DOUBLE
22516: LD_INT 1
22518: DEC
22519: ST_TO_ADDR
22520: LD_VAR 0 6
22524: PUSH
22525: FOR_TO
22526: IFFALSE 23590
// begin if i > 4 then
22528: LD_VAR 0 8
22532: PUSH
22533: LD_INT 4
22535: GREATER
22536: IFFALSE 22540
// break ;
22538: GO 23590
// case i of 1 :
22540: LD_VAR 0 8
22544: PUSH
22545: LD_INT 1
22547: DOUBLE
22548: EQUAL
22549: IFTRUE 22553
22551: GO 22633
22553: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22554: LD_ADDR_VAR 0 12
22558: PUSH
22559: LD_VAR 0 18
22563: PPUSH
22564: LD_INT 22
22566: PUSH
22567: LD_VAR 0 16
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 58
22578: PUSH
22579: EMPTY
22580: LIST
22581: PUSH
22582: LD_INT 2
22584: PUSH
22585: LD_INT 30
22587: PUSH
22588: LD_INT 32
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PUSH
22595: LD_INT 30
22597: PUSH
22598: LD_INT 4
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: PUSH
22605: LD_INT 30
22607: PUSH
22608: LD_INT 5
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: PUSH
22621: EMPTY
22622: LIST
22623: LIST
22624: LIST
22625: PPUSH
22626: CALL_OW 72
22630: ST_TO_ADDR
22631: GO 22855
22633: LD_INT 2
22635: DOUBLE
22636: EQUAL
22637: IFTRUE 22641
22639: GO 22703
22641: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22642: LD_ADDR_VAR 0 12
22646: PUSH
22647: LD_VAR 0 18
22651: PPUSH
22652: LD_INT 22
22654: PUSH
22655: LD_VAR 0 16
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: PUSH
22664: LD_INT 2
22666: PUSH
22667: LD_INT 30
22669: PUSH
22670: LD_INT 0
22672: PUSH
22673: EMPTY
22674: LIST
22675: LIST
22676: PUSH
22677: LD_INT 30
22679: PUSH
22680: LD_INT 1
22682: PUSH
22683: EMPTY
22684: LIST
22685: LIST
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: LIST
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PPUSH
22696: CALL_OW 72
22700: ST_TO_ADDR
22701: GO 22855
22703: LD_INT 3
22705: DOUBLE
22706: EQUAL
22707: IFTRUE 22711
22709: GO 22773
22711: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22712: LD_ADDR_VAR 0 12
22716: PUSH
22717: LD_VAR 0 18
22721: PPUSH
22722: LD_INT 22
22724: PUSH
22725: LD_VAR 0 16
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: PUSH
22734: LD_INT 2
22736: PUSH
22737: LD_INT 30
22739: PUSH
22740: LD_INT 2
22742: PUSH
22743: EMPTY
22744: LIST
22745: LIST
22746: PUSH
22747: LD_INT 30
22749: PUSH
22750: LD_INT 3
22752: PUSH
22753: EMPTY
22754: LIST
22755: LIST
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: LIST
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: PPUSH
22766: CALL_OW 72
22770: ST_TO_ADDR
22771: GO 22855
22773: LD_INT 4
22775: DOUBLE
22776: EQUAL
22777: IFTRUE 22781
22779: GO 22854
22781: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22782: LD_ADDR_VAR 0 12
22786: PUSH
22787: LD_VAR 0 18
22791: PPUSH
22792: LD_INT 22
22794: PUSH
22795: LD_VAR 0 16
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: PUSH
22804: LD_INT 2
22806: PUSH
22807: LD_INT 30
22809: PUSH
22810: LD_INT 6
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: PUSH
22817: LD_INT 30
22819: PUSH
22820: LD_INT 7
22822: PUSH
22823: EMPTY
22824: LIST
22825: LIST
22826: PUSH
22827: LD_INT 30
22829: PUSH
22830: LD_INT 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PPUSH
22847: CALL_OW 72
22851: ST_TO_ADDR
22852: GO 22855
22854: POP
// if i = 1 then
22855: LD_VAR 0 8
22859: PUSH
22860: LD_INT 1
22862: EQUAL
22863: IFFALSE 22974
// begin tmp := [ ] ;
22865: LD_ADDR_VAR 0 19
22869: PUSH
22870: EMPTY
22871: ST_TO_ADDR
// for j in f do
22872: LD_ADDR_VAR 0 9
22876: PUSH
22877: LD_VAR 0 12
22881: PUSH
22882: FOR_IN
22883: IFFALSE 22956
// if GetBType ( j ) = b_bunker then
22885: LD_VAR 0 9
22889: PPUSH
22890: CALL_OW 266
22894: PUSH
22895: LD_INT 32
22897: EQUAL
22898: IFFALSE 22925
// tmp := Insert ( tmp , 1 , j ) else
22900: LD_ADDR_VAR 0 19
22904: PUSH
22905: LD_VAR 0 19
22909: PPUSH
22910: LD_INT 1
22912: PPUSH
22913: LD_VAR 0 9
22917: PPUSH
22918: CALL_OW 2
22922: ST_TO_ADDR
22923: GO 22954
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22925: LD_ADDR_VAR 0 19
22929: PUSH
22930: LD_VAR 0 19
22934: PPUSH
22935: LD_VAR 0 19
22939: PUSH
22940: LD_INT 1
22942: PLUS
22943: PPUSH
22944: LD_VAR 0 9
22948: PPUSH
22949: CALL_OW 2
22953: ST_TO_ADDR
22954: GO 22882
22956: POP
22957: POP
// if tmp then
22958: LD_VAR 0 19
22962: IFFALSE 22974
// f := tmp ;
22964: LD_ADDR_VAR 0 12
22968: PUSH
22969: LD_VAR 0 19
22973: ST_TO_ADDR
// end ; x := personel [ i ] ;
22974: LD_ADDR_VAR 0 13
22978: PUSH
22979: LD_VAR 0 6
22983: PUSH
22984: LD_VAR 0 8
22988: ARRAY
22989: ST_TO_ADDR
// if x = - 1 then
22990: LD_VAR 0 13
22994: PUSH
22995: LD_INT 1
22997: NEG
22998: EQUAL
22999: IFFALSE 23208
// begin for j in f do
23001: LD_ADDR_VAR 0 9
23005: PUSH
23006: LD_VAR 0 12
23010: PUSH
23011: FOR_IN
23012: IFFALSE 23204
// repeat InitHc ;
23014: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23018: LD_VAR 0 9
23022: PPUSH
23023: CALL_OW 266
23027: PUSH
23028: LD_INT 5
23030: EQUAL
23031: IFFALSE 23101
// begin if UnitsInside ( j ) < 3 then
23033: LD_VAR 0 9
23037: PPUSH
23038: CALL_OW 313
23042: PUSH
23043: LD_INT 3
23045: LESS
23046: IFFALSE 23082
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23048: LD_INT 0
23050: PPUSH
23051: LD_INT 5
23053: PUSH
23054: LD_INT 8
23056: PUSH
23057: LD_INT 9
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: LIST
23064: PUSH
23065: LD_VAR 0 17
23069: ARRAY
23070: PPUSH
23071: LD_VAR 0 4
23075: PPUSH
23076: CALL_OW 380
23080: GO 23099
// PrepareHuman ( false , i , skill ) ;
23082: LD_INT 0
23084: PPUSH
23085: LD_VAR 0 8
23089: PPUSH
23090: LD_VAR 0 4
23094: PPUSH
23095: CALL_OW 380
// end else
23099: GO 23118
// PrepareHuman ( false , i , skill ) ;
23101: LD_INT 0
23103: PPUSH
23104: LD_VAR 0 8
23108: PPUSH
23109: LD_VAR 0 4
23113: PPUSH
23114: CALL_OW 380
// un := CreateHuman ;
23118: LD_ADDR_VAR 0 14
23122: PUSH
23123: CALL_OW 44
23127: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23128: LD_ADDR_VAR 0 7
23132: PUSH
23133: LD_VAR 0 7
23137: PPUSH
23138: LD_INT 1
23140: PPUSH
23141: LD_VAR 0 14
23145: PPUSH
23146: CALL_OW 2
23150: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23151: LD_VAR 0 14
23155: PPUSH
23156: LD_VAR 0 9
23160: PPUSH
23161: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23165: LD_VAR 0 9
23169: PPUSH
23170: CALL_OW 313
23174: PUSH
23175: LD_INT 6
23177: EQUAL
23178: PUSH
23179: LD_VAR 0 9
23183: PPUSH
23184: CALL_OW 266
23188: PUSH
23189: LD_INT 32
23191: PUSH
23192: LD_INT 31
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: IN
23199: OR
23200: IFFALSE 23014
23202: GO 23011
23204: POP
23205: POP
// end else
23206: GO 23588
// for j = 1 to x do
23208: LD_ADDR_VAR 0 9
23212: PUSH
23213: DOUBLE
23214: LD_INT 1
23216: DEC
23217: ST_TO_ADDR
23218: LD_VAR 0 13
23222: PUSH
23223: FOR_TO
23224: IFFALSE 23586
// begin InitHc ;
23226: CALL_OW 19
// if not f then
23230: LD_VAR 0 12
23234: NOT
23235: IFFALSE 23324
// begin PrepareHuman ( false , i , skill ) ;
23237: LD_INT 0
23239: PPUSH
23240: LD_VAR 0 8
23244: PPUSH
23245: LD_VAR 0 4
23249: PPUSH
23250: CALL_OW 380
// un := CreateHuman ;
23254: LD_ADDR_VAR 0 14
23258: PUSH
23259: CALL_OW 44
23263: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23264: LD_ADDR_VAR 0 7
23268: PUSH
23269: LD_VAR 0 7
23273: PPUSH
23274: LD_INT 1
23276: PPUSH
23277: LD_VAR 0 14
23281: PPUSH
23282: CALL_OW 2
23286: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23287: LD_VAR 0 14
23291: PPUSH
23292: LD_VAR 0 1
23296: PPUSH
23297: CALL_OW 250
23301: PPUSH
23302: LD_VAR 0 1
23306: PPUSH
23307: CALL_OW 251
23311: PPUSH
23312: LD_INT 10
23314: PPUSH
23315: LD_INT 0
23317: PPUSH
23318: CALL_OW 50
// continue ;
23322: GO 23223
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23324: LD_VAR 0 12
23328: PUSH
23329: LD_INT 1
23331: ARRAY
23332: PPUSH
23333: CALL_OW 313
23337: PUSH
23338: LD_VAR 0 12
23342: PUSH
23343: LD_INT 1
23345: ARRAY
23346: PPUSH
23347: CALL_OW 266
23351: PUSH
23352: LD_INT 32
23354: PUSH
23355: LD_INT 31
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: IN
23362: AND
23363: PUSH
23364: LD_VAR 0 12
23368: PUSH
23369: LD_INT 1
23371: ARRAY
23372: PPUSH
23373: CALL_OW 313
23377: PUSH
23378: LD_INT 6
23380: EQUAL
23381: OR
23382: IFFALSE 23402
// f := Delete ( f , 1 ) ;
23384: LD_ADDR_VAR 0 12
23388: PUSH
23389: LD_VAR 0 12
23393: PPUSH
23394: LD_INT 1
23396: PPUSH
23397: CALL_OW 3
23401: ST_TO_ADDR
// if not f then
23402: LD_VAR 0 12
23406: NOT
23407: IFFALSE 23425
// begin x := x + 2 ;
23409: LD_ADDR_VAR 0 13
23413: PUSH
23414: LD_VAR 0 13
23418: PUSH
23419: LD_INT 2
23421: PLUS
23422: ST_TO_ADDR
// continue ;
23423: GO 23223
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23425: LD_VAR 0 12
23429: PUSH
23430: LD_INT 1
23432: ARRAY
23433: PPUSH
23434: CALL_OW 266
23438: PUSH
23439: LD_INT 5
23441: EQUAL
23442: IFFALSE 23516
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23444: LD_VAR 0 12
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: CALL_OW 313
23457: PUSH
23458: LD_INT 3
23460: LESS
23461: IFFALSE 23497
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23463: LD_INT 0
23465: PPUSH
23466: LD_INT 5
23468: PUSH
23469: LD_INT 8
23471: PUSH
23472: LD_INT 9
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: LIST
23479: PUSH
23480: LD_VAR 0 17
23484: ARRAY
23485: PPUSH
23486: LD_VAR 0 4
23490: PPUSH
23491: CALL_OW 380
23495: GO 23514
// PrepareHuman ( false , i , skill ) ;
23497: LD_INT 0
23499: PPUSH
23500: LD_VAR 0 8
23504: PPUSH
23505: LD_VAR 0 4
23509: PPUSH
23510: CALL_OW 380
// end else
23514: GO 23533
// PrepareHuman ( false , i , skill ) ;
23516: LD_INT 0
23518: PPUSH
23519: LD_VAR 0 8
23523: PPUSH
23524: LD_VAR 0 4
23528: PPUSH
23529: CALL_OW 380
// un := CreateHuman ;
23533: LD_ADDR_VAR 0 14
23537: PUSH
23538: CALL_OW 44
23542: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23543: LD_ADDR_VAR 0 7
23547: PUSH
23548: LD_VAR 0 7
23552: PPUSH
23553: LD_INT 1
23555: PPUSH
23556: LD_VAR 0 14
23560: PPUSH
23561: CALL_OW 2
23565: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23566: LD_VAR 0 14
23570: PPUSH
23571: LD_VAR 0 12
23575: PUSH
23576: LD_INT 1
23578: ARRAY
23579: PPUSH
23580: CALL_OW 52
// end ;
23584: GO 23223
23586: POP
23587: POP
// end ;
23588: GO 22525
23590: POP
23591: POP
// result := result ^ buildings ;
23592: LD_ADDR_VAR 0 7
23596: PUSH
23597: LD_VAR 0 7
23601: PUSH
23602: LD_VAR 0 18
23606: ADD
23607: ST_TO_ADDR
// end else
23608: GO 23751
// begin for i = 1 to personel do
23610: LD_ADDR_VAR 0 8
23614: PUSH
23615: DOUBLE
23616: LD_INT 1
23618: DEC
23619: ST_TO_ADDR
23620: LD_VAR 0 6
23624: PUSH
23625: FOR_TO
23626: IFFALSE 23749
// begin if i > 4 then
23628: LD_VAR 0 8
23632: PUSH
23633: LD_INT 4
23635: GREATER
23636: IFFALSE 23640
// break ;
23638: GO 23749
// x := personel [ i ] ;
23640: LD_ADDR_VAR 0 13
23644: PUSH
23645: LD_VAR 0 6
23649: PUSH
23650: LD_VAR 0 8
23654: ARRAY
23655: ST_TO_ADDR
// if x = - 1 then
23656: LD_VAR 0 13
23660: PUSH
23661: LD_INT 1
23663: NEG
23664: EQUAL
23665: IFFALSE 23669
// continue ;
23667: GO 23625
// PrepareHuman ( false , i , skill ) ;
23669: LD_INT 0
23671: PPUSH
23672: LD_VAR 0 8
23676: PPUSH
23677: LD_VAR 0 4
23681: PPUSH
23682: CALL_OW 380
// un := CreateHuman ;
23686: LD_ADDR_VAR 0 14
23690: PUSH
23691: CALL_OW 44
23695: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23696: LD_VAR 0 14
23700: PPUSH
23701: LD_VAR 0 1
23705: PPUSH
23706: CALL_OW 250
23710: PPUSH
23711: LD_VAR 0 1
23715: PPUSH
23716: CALL_OW 251
23720: PPUSH
23721: LD_INT 10
23723: PPUSH
23724: LD_INT 0
23726: PPUSH
23727: CALL_OW 50
// result := result ^ un ;
23731: LD_ADDR_VAR 0 7
23735: PUSH
23736: LD_VAR 0 7
23740: PUSH
23741: LD_VAR 0 14
23745: ADD
23746: ST_TO_ADDR
// end ;
23747: GO 23625
23749: POP
23750: POP
// end ; end ;
23751: LD_VAR 0 7
23755: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23756: LD_INT 0
23758: PPUSH
23759: PPUSH
23760: PPUSH
23761: PPUSH
23762: PPUSH
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
// result := false ;
23774: LD_ADDR_VAR 0 3
23778: PUSH
23779: LD_INT 0
23781: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23782: LD_VAR 0 1
23786: NOT
23787: PUSH
23788: LD_VAR 0 1
23792: PPUSH
23793: CALL_OW 266
23797: PUSH
23798: LD_INT 32
23800: PUSH
23801: LD_INT 33
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: IN
23808: NOT
23809: OR
23810: IFFALSE 23814
// exit ;
23812: GO 24923
// nat := GetNation ( tower ) ;
23814: LD_ADDR_VAR 0 12
23818: PUSH
23819: LD_VAR 0 1
23823: PPUSH
23824: CALL_OW 248
23828: ST_TO_ADDR
// side := GetSide ( tower ) ;
23829: LD_ADDR_VAR 0 16
23833: PUSH
23834: LD_VAR 0 1
23838: PPUSH
23839: CALL_OW 255
23843: ST_TO_ADDR
// x := GetX ( tower ) ;
23844: LD_ADDR_VAR 0 10
23848: PUSH
23849: LD_VAR 0 1
23853: PPUSH
23854: CALL_OW 250
23858: ST_TO_ADDR
// y := GetY ( tower ) ;
23859: LD_ADDR_VAR 0 11
23863: PUSH
23864: LD_VAR 0 1
23868: PPUSH
23869: CALL_OW 251
23873: ST_TO_ADDR
// if not x or not y then
23874: LD_VAR 0 10
23878: NOT
23879: PUSH
23880: LD_VAR 0 11
23884: NOT
23885: OR
23886: IFFALSE 23890
// exit ;
23888: GO 24923
// weapon := 0 ;
23890: LD_ADDR_VAR 0 18
23894: PUSH
23895: LD_INT 0
23897: ST_TO_ADDR
// fac_list := [ ] ;
23898: LD_ADDR_VAR 0 17
23902: PUSH
23903: EMPTY
23904: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23905: LD_ADDR_VAR 0 6
23909: PUSH
23910: LD_VAR 0 1
23914: PPUSH
23915: CALL_OW 274
23919: PPUSH
23920: LD_VAR 0 2
23924: PPUSH
23925: LD_INT 0
23927: PPUSH
23928: CALL 21494 0 3
23932: PPUSH
23933: LD_INT 30
23935: PUSH
23936: LD_INT 3
23938: PUSH
23939: EMPTY
23940: LIST
23941: LIST
23942: PPUSH
23943: CALL_OW 72
23947: ST_TO_ADDR
// if not factories then
23948: LD_VAR 0 6
23952: NOT
23953: IFFALSE 23957
// exit ;
23955: GO 24923
// for i in factories do
23957: LD_ADDR_VAR 0 8
23961: PUSH
23962: LD_VAR 0 6
23966: PUSH
23967: FOR_IN
23968: IFFALSE 23993
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23970: LD_ADDR_VAR 0 17
23974: PUSH
23975: LD_VAR 0 17
23979: PUSH
23980: LD_VAR 0 8
23984: PPUSH
23985: CALL_OW 478
23989: UNION
23990: ST_TO_ADDR
23991: GO 23967
23993: POP
23994: POP
// if not fac_list then
23995: LD_VAR 0 17
23999: NOT
24000: IFFALSE 24004
// exit ;
24002: GO 24923
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24004: LD_ADDR_VAR 0 5
24008: PUSH
24009: LD_INT 4
24011: PUSH
24012: LD_INT 5
24014: PUSH
24015: LD_INT 9
24017: PUSH
24018: LD_INT 10
24020: PUSH
24021: LD_INT 6
24023: PUSH
24024: LD_INT 7
24026: PUSH
24027: LD_INT 11
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: LIST
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 27
24041: PUSH
24042: LD_INT 28
24044: PUSH
24045: LD_INT 26
24047: PUSH
24048: LD_INT 30
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: LIST
24055: LIST
24056: PUSH
24057: LD_INT 43
24059: PUSH
24060: LD_INT 44
24062: PUSH
24063: LD_INT 46
24065: PUSH
24066: LD_INT 45
24068: PUSH
24069: LD_INT 47
24071: PUSH
24072: LD_INT 49
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: LIST
24087: PUSH
24088: LD_VAR 0 12
24092: ARRAY
24093: ST_TO_ADDR
// list := list isect fac_list ;
24094: LD_ADDR_VAR 0 5
24098: PUSH
24099: LD_VAR 0 5
24103: PUSH
24104: LD_VAR 0 17
24108: ISECT
24109: ST_TO_ADDR
// if not list then
24110: LD_VAR 0 5
24114: NOT
24115: IFFALSE 24119
// exit ;
24117: GO 24923
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24119: LD_VAR 0 12
24123: PUSH
24124: LD_INT 3
24126: EQUAL
24127: PUSH
24128: LD_INT 49
24130: PUSH
24131: LD_VAR 0 5
24135: IN
24136: AND
24137: PUSH
24138: LD_INT 31
24140: PPUSH
24141: LD_VAR 0 16
24145: PPUSH
24146: CALL_OW 321
24150: PUSH
24151: LD_INT 2
24153: EQUAL
24154: AND
24155: IFFALSE 24215
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24157: LD_INT 22
24159: PUSH
24160: LD_VAR 0 16
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PUSH
24169: LD_INT 35
24171: PUSH
24172: LD_INT 49
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: PUSH
24179: LD_INT 91
24181: PUSH
24182: LD_VAR 0 1
24186: PUSH
24187: LD_INT 10
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: LIST
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: LIST
24199: PPUSH
24200: CALL_OW 69
24204: NOT
24205: IFFALSE 24215
// weapon := ru_time_lapser ;
24207: LD_ADDR_VAR 0 18
24211: PUSH
24212: LD_INT 49
24214: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24215: LD_VAR 0 12
24219: PUSH
24220: LD_INT 1
24222: PUSH
24223: LD_INT 2
24225: PUSH
24226: EMPTY
24227: LIST
24228: LIST
24229: IN
24230: PUSH
24231: LD_INT 11
24233: PUSH
24234: LD_VAR 0 5
24238: IN
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: LD_VAR 0 5
24247: IN
24248: OR
24249: AND
24250: PUSH
24251: LD_INT 6
24253: PPUSH
24254: LD_VAR 0 16
24258: PPUSH
24259: CALL_OW 321
24263: PUSH
24264: LD_INT 2
24266: EQUAL
24267: AND
24268: IFFALSE 24433
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24270: LD_INT 22
24272: PUSH
24273: LD_VAR 0 16
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 2
24284: PUSH
24285: LD_INT 35
24287: PUSH
24288: LD_INT 11
24290: PUSH
24291: EMPTY
24292: LIST
24293: LIST
24294: PUSH
24295: LD_INT 35
24297: PUSH
24298: LD_INT 30
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: LIST
24309: PUSH
24310: LD_INT 91
24312: PUSH
24313: LD_VAR 0 1
24317: PUSH
24318: LD_INT 18
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: LIST
24330: PPUSH
24331: CALL_OW 69
24335: NOT
24336: PUSH
24337: LD_INT 22
24339: PUSH
24340: LD_VAR 0 16
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 2
24351: PUSH
24352: LD_INT 30
24354: PUSH
24355: LD_INT 32
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 30
24364: PUSH
24365: LD_INT 33
24367: PUSH
24368: EMPTY
24369: LIST
24370: LIST
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: LIST
24376: PUSH
24377: LD_INT 91
24379: PUSH
24380: LD_VAR 0 1
24384: PUSH
24385: LD_INT 12
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: LIST
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: PUSH
24398: EMPTY
24399: LIST
24400: PPUSH
24401: CALL_OW 69
24405: PUSH
24406: LD_INT 2
24408: GREATER
24409: AND
24410: IFFALSE 24433
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24412: LD_ADDR_VAR 0 18
24416: PUSH
24417: LD_INT 11
24419: PUSH
24420: LD_INT 30
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_VAR 0 12
24431: ARRAY
24432: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24433: LD_VAR 0 18
24437: NOT
24438: PUSH
24439: LD_INT 40
24441: PPUSH
24442: LD_VAR 0 16
24446: PPUSH
24447: CALL_OW 321
24451: PUSH
24452: LD_INT 2
24454: EQUAL
24455: AND
24456: PUSH
24457: LD_INT 7
24459: PUSH
24460: LD_VAR 0 5
24464: IN
24465: PUSH
24466: LD_INT 28
24468: PUSH
24469: LD_VAR 0 5
24473: IN
24474: OR
24475: PUSH
24476: LD_INT 45
24478: PUSH
24479: LD_VAR 0 5
24483: IN
24484: OR
24485: AND
24486: IFFALSE 24740
// begin hex := GetHexInfo ( x , y ) ;
24488: LD_ADDR_VAR 0 4
24492: PUSH
24493: LD_VAR 0 10
24497: PPUSH
24498: LD_VAR 0 11
24502: PPUSH
24503: CALL_OW 546
24507: ST_TO_ADDR
// if hex [ 1 ] then
24508: LD_VAR 0 4
24512: PUSH
24513: LD_INT 1
24515: ARRAY
24516: IFFALSE 24520
// exit ;
24518: GO 24923
// height := hex [ 2 ] ;
24520: LD_ADDR_VAR 0 15
24524: PUSH
24525: LD_VAR 0 4
24529: PUSH
24530: LD_INT 2
24532: ARRAY
24533: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24534: LD_ADDR_VAR 0 14
24538: PUSH
24539: LD_INT 0
24541: PUSH
24542: LD_INT 2
24544: PUSH
24545: LD_INT 3
24547: PUSH
24548: LD_INT 5
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: ST_TO_ADDR
// for i in tmp do
24557: LD_ADDR_VAR 0 8
24561: PUSH
24562: LD_VAR 0 14
24566: PUSH
24567: FOR_IN
24568: IFFALSE 24738
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24570: LD_ADDR_VAR 0 9
24574: PUSH
24575: LD_VAR 0 10
24579: PPUSH
24580: LD_VAR 0 8
24584: PPUSH
24585: LD_INT 5
24587: PPUSH
24588: CALL_OW 272
24592: PUSH
24593: LD_VAR 0 11
24597: PPUSH
24598: LD_VAR 0 8
24602: PPUSH
24603: LD_INT 5
24605: PPUSH
24606: CALL_OW 273
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24615: LD_VAR 0 9
24619: PUSH
24620: LD_INT 1
24622: ARRAY
24623: PPUSH
24624: LD_VAR 0 9
24628: PUSH
24629: LD_INT 2
24631: ARRAY
24632: PPUSH
24633: CALL_OW 488
24637: IFFALSE 24736
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24639: LD_ADDR_VAR 0 4
24643: PUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: PPUSH
24653: LD_VAR 0 9
24657: PUSH
24658: LD_INT 2
24660: ARRAY
24661: PPUSH
24662: CALL_OW 546
24666: ST_TO_ADDR
// if hex [ 1 ] then
24667: LD_VAR 0 4
24671: PUSH
24672: LD_INT 1
24674: ARRAY
24675: IFFALSE 24679
// continue ;
24677: GO 24567
// h := hex [ 2 ] ;
24679: LD_ADDR_VAR 0 13
24683: PUSH
24684: LD_VAR 0 4
24688: PUSH
24689: LD_INT 2
24691: ARRAY
24692: ST_TO_ADDR
// if h + 7 < height then
24693: LD_VAR 0 13
24697: PUSH
24698: LD_INT 7
24700: PLUS
24701: PUSH
24702: LD_VAR 0 15
24706: LESS
24707: IFFALSE 24736
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24709: LD_ADDR_VAR 0 18
24713: PUSH
24714: LD_INT 7
24716: PUSH
24717: LD_INT 28
24719: PUSH
24720: LD_INT 45
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: LIST
24727: PUSH
24728: LD_VAR 0 12
24732: ARRAY
24733: ST_TO_ADDR
// break ;
24734: GO 24738
// end ; end ; end ;
24736: GO 24567
24738: POP
24739: POP
// end ; if not weapon then
24740: LD_VAR 0 18
24744: NOT
24745: IFFALSE 24805
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24747: LD_ADDR_VAR 0 5
24751: PUSH
24752: LD_VAR 0 5
24756: PUSH
24757: LD_INT 11
24759: PUSH
24760: LD_INT 30
24762: PUSH
24763: LD_INT 49
24765: PUSH
24766: EMPTY
24767: LIST
24768: LIST
24769: LIST
24770: DIFF
24771: ST_TO_ADDR
// if not list then
24772: LD_VAR 0 5
24776: NOT
24777: IFFALSE 24781
// exit ;
24779: GO 24923
// weapon := list [ rand ( 1 , list ) ] ;
24781: LD_ADDR_VAR 0 18
24785: PUSH
24786: LD_VAR 0 5
24790: PUSH
24791: LD_INT 1
24793: PPUSH
24794: LD_VAR 0 5
24798: PPUSH
24799: CALL_OW 12
24803: ARRAY
24804: ST_TO_ADDR
// end ; if weapon then
24805: LD_VAR 0 18
24809: IFFALSE 24923
// begin tmp := CostOfWeapon ( weapon ) ;
24811: LD_ADDR_VAR 0 14
24815: PUSH
24816: LD_VAR 0 18
24820: PPUSH
24821: CALL_OW 451
24825: ST_TO_ADDR
// j := GetBase ( tower ) ;
24826: LD_ADDR_VAR 0 9
24830: PUSH
24831: LD_VAR 0 1
24835: PPUSH
24836: CALL_OW 274
24840: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24841: LD_VAR 0 9
24845: PPUSH
24846: LD_INT 1
24848: PPUSH
24849: CALL_OW 275
24853: PUSH
24854: LD_VAR 0 14
24858: PUSH
24859: LD_INT 1
24861: ARRAY
24862: GREATEREQUAL
24863: PUSH
24864: LD_VAR 0 9
24868: PPUSH
24869: LD_INT 2
24871: PPUSH
24872: CALL_OW 275
24876: PUSH
24877: LD_VAR 0 14
24881: PUSH
24882: LD_INT 2
24884: ARRAY
24885: GREATEREQUAL
24886: AND
24887: PUSH
24888: LD_VAR 0 9
24892: PPUSH
24893: LD_INT 3
24895: PPUSH
24896: CALL_OW 275
24900: PUSH
24901: LD_VAR 0 14
24905: PUSH
24906: LD_INT 3
24908: ARRAY
24909: GREATEREQUAL
24910: AND
24911: IFFALSE 24923
// result := weapon ;
24913: LD_ADDR_VAR 0 3
24917: PUSH
24918: LD_VAR 0 18
24922: ST_TO_ADDR
// end ; end ;
24923: LD_VAR 0 3
24927: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24928: LD_INT 0
24930: PPUSH
24931: PPUSH
// result := true ;
24932: LD_ADDR_VAR 0 3
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// if array1 = array2 then
24940: LD_VAR 0 1
24944: PUSH
24945: LD_VAR 0 2
24949: EQUAL
24950: IFFALSE 25010
// begin for i = 1 to array1 do
24952: LD_ADDR_VAR 0 4
24956: PUSH
24957: DOUBLE
24958: LD_INT 1
24960: DEC
24961: ST_TO_ADDR
24962: LD_VAR 0 1
24966: PUSH
24967: FOR_TO
24968: IFFALSE 25006
// if array1 [ i ] <> array2 [ i ] then
24970: LD_VAR 0 1
24974: PUSH
24975: LD_VAR 0 4
24979: ARRAY
24980: PUSH
24981: LD_VAR 0 2
24985: PUSH
24986: LD_VAR 0 4
24990: ARRAY
24991: NONEQUAL
24992: IFFALSE 25004
// begin result := false ;
24994: LD_ADDR_VAR 0 3
24998: PUSH
24999: LD_INT 0
25001: ST_TO_ADDR
// break ;
25002: GO 25006
// end ;
25004: GO 24967
25006: POP
25007: POP
// end else
25008: GO 25018
// result := false ;
25010: LD_ADDR_VAR 0 3
25014: PUSH
25015: LD_INT 0
25017: ST_TO_ADDR
// end ;
25018: LD_VAR 0 3
25022: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25023: LD_INT 0
25025: PPUSH
25026: PPUSH
// if not array1 or not array2 then
25027: LD_VAR 0 1
25031: NOT
25032: PUSH
25033: LD_VAR 0 2
25037: NOT
25038: OR
25039: IFFALSE 25043
// exit ;
25041: GO 25107
// result := true ;
25043: LD_ADDR_VAR 0 3
25047: PUSH
25048: LD_INT 1
25050: ST_TO_ADDR
// for i = 1 to array1 do
25051: LD_ADDR_VAR 0 4
25055: PUSH
25056: DOUBLE
25057: LD_INT 1
25059: DEC
25060: ST_TO_ADDR
25061: LD_VAR 0 1
25065: PUSH
25066: FOR_TO
25067: IFFALSE 25105
// if array1 [ i ] <> array2 [ i ] then
25069: LD_VAR 0 1
25073: PUSH
25074: LD_VAR 0 4
25078: ARRAY
25079: PUSH
25080: LD_VAR 0 2
25084: PUSH
25085: LD_VAR 0 4
25089: ARRAY
25090: NONEQUAL
25091: IFFALSE 25103
// begin result := false ;
25093: LD_ADDR_VAR 0 3
25097: PUSH
25098: LD_INT 0
25100: ST_TO_ADDR
// break ;
25101: GO 25105
// end ;
25103: GO 25066
25105: POP
25106: POP
// end ;
25107: LD_VAR 0 3
25111: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25112: LD_INT 0
25114: PPUSH
25115: PPUSH
25116: PPUSH
// pom := GetBase ( fac ) ;
25117: LD_ADDR_VAR 0 5
25121: PUSH
25122: LD_VAR 0 1
25126: PPUSH
25127: CALL_OW 274
25131: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25132: LD_ADDR_VAR 0 4
25136: PUSH
25137: LD_VAR 0 2
25141: PUSH
25142: LD_INT 1
25144: ARRAY
25145: PPUSH
25146: LD_VAR 0 2
25150: PUSH
25151: LD_INT 2
25153: ARRAY
25154: PPUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_INT 3
25162: ARRAY
25163: PPUSH
25164: LD_VAR 0 2
25168: PUSH
25169: LD_INT 4
25171: ARRAY
25172: PPUSH
25173: CALL_OW 449
25177: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25178: LD_ADDR_VAR 0 3
25182: PUSH
25183: LD_VAR 0 5
25187: PPUSH
25188: LD_INT 1
25190: PPUSH
25191: CALL_OW 275
25195: PUSH
25196: LD_VAR 0 4
25200: PUSH
25201: LD_INT 1
25203: ARRAY
25204: GREATEREQUAL
25205: PUSH
25206: LD_VAR 0 5
25210: PPUSH
25211: LD_INT 2
25213: PPUSH
25214: CALL_OW 275
25218: PUSH
25219: LD_VAR 0 4
25223: PUSH
25224: LD_INT 2
25226: ARRAY
25227: GREATEREQUAL
25228: AND
25229: PUSH
25230: LD_VAR 0 5
25234: PPUSH
25235: LD_INT 3
25237: PPUSH
25238: CALL_OW 275
25242: PUSH
25243: LD_VAR 0 4
25247: PUSH
25248: LD_INT 3
25250: ARRAY
25251: GREATEREQUAL
25252: AND
25253: ST_TO_ADDR
// end ;
25254: LD_VAR 0 3
25258: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25259: LD_INT 0
25261: PPUSH
25262: PPUSH
25263: PPUSH
25264: PPUSH
// pom := GetBase ( building ) ;
25265: LD_ADDR_VAR 0 3
25269: PUSH
25270: LD_VAR 0 1
25274: PPUSH
25275: CALL_OW 274
25279: ST_TO_ADDR
// if not pom then
25280: LD_VAR 0 3
25284: NOT
25285: IFFALSE 25289
// exit ;
25287: GO 25459
// btype := GetBType ( building ) ;
25289: LD_ADDR_VAR 0 5
25293: PUSH
25294: LD_VAR 0 1
25298: PPUSH
25299: CALL_OW 266
25303: ST_TO_ADDR
// if btype = b_armoury then
25304: LD_VAR 0 5
25308: PUSH
25309: LD_INT 4
25311: EQUAL
25312: IFFALSE 25322
// btype := b_barracks ;
25314: LD_ADDR_VAR 0 5
25318: PUSH
25319: LD_INT 5
25321: ST_TO_ADDR
// if btype = b_depot then
25322: LD_VAR 0 5
25326: PUSH
25327: LD_INT 0
25329: EQUAL
25330: IFFALSE 25340
// btype := b_warehouse ;
25332: LD_ADDR_VAR 0 5
25336: PUSH
25337: LD_INT 1
25339: ST_TO_ADDR
// if btype = b_workshop then
25340: LD_VAR 0 5
25344: PUSH
25345: LD_INT 2
25347: EQUAL
25348: IFFALSE 25358
// btype := b_factory ;
25350: LD_ADDR_VAR 0 5
25354: PUSH
25355: LD_INT 3
25357: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25358: LD_ADDR_VAR 0 4
25362: PUSH
25363: LD_VAR 0 5
25367: PPUSH
25368: LD_VAR 0 1
25372: PPUSH
25373: CALL_OW 248
25377: PPUSH
25378: CALL_OW 450
25382: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25383: LD_ADDR_VAR 0 2
25387: PUSH
25388: LD_VAR 0 3
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 275
25400: PUSH
25401: LD_VAR 0 4
25405: PUSH
25406: LD_INT 1
25408: ARRAY
25409: GREATEREQUAL
25410: PUSH
25411: LD_VAR 0 3
25415: PPUSH
25416: LD_INT 2
25418: PPUSH
25419: CALL_OW 275
25423: PUSH
25424: LD_VAR 0 4
25428: PUSH
25429: LD_INT 2
25431: ARRAY
25432: GREATEREQUAL
25433: AND
25434: PUSH
25435: LD_VAR 0 3
25439: PPUSH
25440: LD_INT 3
25442: PPUSH
25443: CALL_OW 275
25447: PUSH
25448: LD_VAR 0 4
25452: PUSH
25453: LD_INT 3
25455: ARRAY
25456: GREATEREQUAL
25457: AND
25458: ST_TO_ADDR
// end ;
25459: LD_VAR 0 2
25463: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25464: LD_INT 0
25466: PPUSH
25467: PPUSH
25468: PPUSH
// pom := GetBase ( building ) ;
25469: LD_ADDR_VAR 0 4
25473: PUSH
25474: LD_VAR 0 1
25478: PPUSH
25479: CALL_OW 274
25483: ST_TO_ADDR
// if not pom then
25484: LD_VAR 0 4
25488: NOT
25489: IFFALSE 25493
// exit ;
25491: GO 25594
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25493: LD_ADDR_VAR 0 5
25497: PUSH
25498: LD_VAR 0 2
25502: PPUSH
25503: LD_VAR 0 1
25507: PPUSH
25508: CALL_OW 248
25512: PPUSH
25513: CALL_OW 450
25517: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25518: LD_ADDR_VAR 0 3
25522: PUSH
25523: LD_VAR 0 4
25527: PPUSH
25528: LD_INT 1
25530: PPUSH
25531: CALL_OW 275
25535: PUSH
25536: LD_VAR 0 5
25540: PUSH
25541: LD_INT 1
25543: ARRAY
25544: GREATEREQUAL
25545: PUSH
25546: LD_VAR 0 4
25550: PPUSH
25551: LD_INT 2
25553: PPUSH
25554: CALL_OW 275
25558: PUSH
25559: LD_VAR 0 5
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: GREATEREQUAL
25568: AND
25569: PUSH
25570: LD_VAR 0 4
25574: PPUSH
25575: LD_INT 3
25577: PPUSH
25578: CALL_OW 275
25582: PUSH
25583: LD_VAR 0 5
25587: PUSH
25588: LD_INT 3
25590: ARRAY
25591: GREATEREQUAL
25592: AND
25593: ST_TO_ADDR
// end ;
25594: LD_VAR 0 3
25598: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25599: LD_INT 0
25601: PPUSH
25602: PPUSH
25603: PPUSH
25604: PPUSH
25605: PPUSH
25606: PPUSH
25607: PPUSH
25608: PPUSH
25609: PPUSH
25610: PPUSH
25611: PPUSH
// result := false ;
25612: LD_ADDR_VAR 0 8
25616: PUSH
25617: LD_INT 0
25619: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25620: LD_VAR 0 5
25624: NOT
25625: PUSH
25626: LD_VAR 0 1
25630: NOT
25631: OR
25632: PUSH
25633: LD_VAR 0 2
25637: NOT
25638: OR
25639: PUSH
25640: LD_VAR 0 3
25644: NOT
25645: OR
25646: IFFALSE 25650
// exit ;
25648: GO 26464
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25650: LD_ADDR_VAR 0 14
25654: PUSH
25655: LD_VAR 0 1
25659: PPUSH
25660: LD_VAR 0 2
25664: PPUSH
25665: LD_VAR 0 3
25669: PPUSH
25670: LD_VAR 0 4
25674: PPUSH
25675: LD_VAR 0 5
25679: PUSH
25680: LD_INT 1
25682: ARRAY
25683: PPUSH
25684: CALL_OW 248
25688: PPUSH
25689: LD_INT 0
25691: PPUSH
25692: CALL 27697 0 6
25696: ST_TO_ADDR
// if not hexes then
25697: LD_VAR 0 14
25701: NOT
25702: IFFALSE 25706
// exit ;
25704: GO 26464
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25706: LD_ADDR_VAR 0 17
25710: PUSH
25711: LD_VAR 0 5
25715: PPUSH
25716: LD_INT 22
25718: PUSH
25719: LD_VAR 0 13
25723: PPUSH
25724: CALL_OW 255
25728: PUSH
25729: EMPTY
25730: LIST
25731: LIST
25732: PUSH
25733: LD_INT 2
25735: PUSH
25736: LD_INT 30
25738: PUSH
25739: LD_INT 0
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: PUSH
25746: LD_INT 30
25748: PUSH
25749: LD_INT 1
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: LIST
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: PPUSH
25765: CALL_OW 72
25769: ST_TO_ADDR
// for i = 1 to hexes do
25770: LD_ADDR_VAR 0 9
25774: PUSH
25775: DOUBLE
25776: LD_INT 1
25778: DEC
25779: ST_TO_ADDR
25780: LD_VAR 0 14
25784: PUSH
25785: FOR_TO
25786: IFFALSE 26462
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25788: LD_ADDR_VAR 0 13
25792: PUSH
25793: LD_VAR 0 14
25797: PUSH
25798: LD_VAR 0 9
25802: ARRAY
25803: PUSH
25804: LD_INT 1
25806: ARRAY
25807: PPUSH
25808: LD_VAR 0 14
25812: PUSH
25813: LD_VAR 0 9
25817: ARRAY
25818: PUSH
25819: LD_INT 2
25821: ARRAY
25822: PPUSH
25823: CALL_OW 428
25827: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25828: LD_VAR 0 14
25832: PUSH
25833: LD_VAR 0 9
25837: ARRAY
25838: PUSH
25839: LD_INT 1
25841: ARRAY
25842: PPUSH
25843: LD_VAR 0 14
25847: PUSH
25848: LD_VAR 0 9
25852: ARRAY
25853: PUSH
25854: LD_INT 2
25856: ARRAY
25857: PPUSH
25858: CALL_OW 351
25862: PUSH
25863: LD_VAR 0 14
25867: PUSH
25868: LD_VAR 0 9
25872: ARRAY
25873: PUSH
25874: LD_INT 1
25876: ARRAY
25877: PPUSH
25878: LD_VAR 0 14
25882: PUSH
25883: LD_VAR 0 9
25887: ARRAY
25888: PUSH
25889: LD_INT 2
25891: ARRAY
25892: PPUSH
25893: CALL_OW 488
25897: NOT
25898: OR
25899: PUSH
25900: LD_VAR 0 13
25904: PPUSH
25905: CALL_OW 247
25909: PUSH
25910: LD_INT 3
25912: EQUAL
25913: OR
25914: IFFALSE 25920
// exit ;
25916: POP
25917: POP
25918: GO 26464
// if not tmp then
25920: LD_VAR 0 13
25924: NOT
25925: IFFALSE 25929
// continue ;
25927: GO 25785
// result := true ;
25929: LD_ADDR_VAR 0 8
25933: PUSH
25934: LD_INT 1
25936: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25937: LD_VAR 0 6
25941: PUSH
25942: LD_VAR 0 13
25946: PPUSH
25947: CALL_OW 247
25951: PUSH
25952: LD_INT 2
25954: EQUAL
25955: AND
25956: PUSH
25957: LD_VAR 0 13
25961: PPUSH
25962: CALL_OW 263
25966: PUSH
25967: LD_INT 1
25969: EQUAL
25970: AND
25971: IFFALSE 26135
// begin if IsDrivenBy ( tmp ) then
25973: LD_VAR 0 13
25977: PPUSH
25978: CALL_OW 311
25982: IFFALSE 25986
// continue ;
25984: GO 25785
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25986: LD_VAR 0 6
25990: PPUSH
25991: LD_INT 3
25993: PUSH
25994: LD_INT 60
25996: PUSH
25997: EMPTY
25998: LIST
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 3
26006: PUSH
26007: LD_INT 55
26009: PUSH
26010: EMPTY
26011: LIST
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PPUSH
26021: CALL_OW 72
26025: IFFALSE 26133
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26027: LD_ADDR_VAR 0 18
26031: PUSH
26032: LD_VAR 0 6
26036: PPUSH
26037: LD_INT 3
26039: PUSH
26040: LD_INT 60
26042: PUSH
26043: EMPTY
26044: LIST
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: LD_INT 3
26052: PUSH
26053: LD_INT 55
26055: PUSH
26056: EMPTY
26057: LIST
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PPUSH
26067: CALL_OW 72
26071: PUSH
26072: LD_INT 1
26074: ARRAY
26075: ST_TO_ADDR
// if IsInUnit ( driver ) then
26076: LD_VAR 0 18
26080: PPUSH
26081: CALL_OW 310
26085: IFFALSE 26096
// ComExit ( driver ) ;
26087: LD_VAR 0 18
26091: PPUSH
26092: CALL 51477 0 1
// AddComEnterUnit ( driver , tmp ) ;
26096: LD_VAR 0 18
26100: PPUSH
26101: LD_VAR 0 13
26105: PPUSH
26106: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
26110: LD_VAR 0 18
26114: PPUSH
26115: LD_VAR 0 7
26119: PPUSH
26120: CALL_OW 173
// AddComExitVehicle ( driver ) ;
26124: LD_VAR 0 18
26128: PPUSH
26129: CALL_OW 181
// end ; continue ;
26133: GO 25785
// end ; if not cleaners or not tmp in cleaners then
26135: LD_VAR 0 6
26139: NOT
26140: PUSH
26141: LD_VAR 0 13
26145: PUSH
26146: LD_VAR 0 6
26150: IN
26151: NOT
26152: OR
26153: IFFALSE 26460
// begin if dep then
26155: LD_VAR 0 17
26159: IFFALSE 26295
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26161: LD_ADDR_VAR 0 16
26165: PUSH
26166: LD_VAR 0 17
26170: PUSH
26171: LD_INT 1
26173: ARRAY
26174: PPUSH
26175: CALL_OW 250
26179: PPUSH
26180: LD_VAR 0 17
26184: PUSH
26185: LD_INT 1
26187: ARRAY
26188: PPUSH
26189: CALL_OW 254
26193: PPUSH
26194: LD_INT 5
26196: PPUSH
26197: CALL_OW 272
26201: PUSH
26202: LD_VAR 0 17
26206: PUSH
26207: LD_INT 1
26209: ARRAY
26210: PPUSH
26211: CALL_OW 251
26215: PPUSH
26216: LD_VAR 0 17
26220: PUSH
26221: LD_INT 1
26223: ARRAY
26224: PPUSH
26225: CALL_OW 254
26229: PPUSH
26230: LD_INT 5
26232: PPUSH
26233: CALL_OW 273
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26242: LD_VAR 0 16
26246: PUSH
26247: LD_INT 1
26249: ARRAY
26250: PPUSH
26251: LD_VAR 0 16
26255: PUSH
26256: LD_INT 2
26258: ARRAY
26259: PPUSH
26260: CALL_OW 488
26264: IFFALSE 26295
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26266: LD_VAR 0 13
26270: PPUSH
26271: LD_VAR 0 16
26275: PUSH
26276: LD_INT 1
26278: ARRAY
26279: PPUSH
26280: LD_VAR 0 16
26284: PUSH
26285: LD_INT 2
26287: ARRAY
26288: PPUSH
26289: CALL_OW 111
// continue ;
26293: GO 25785
// end ; end ; r := GetDir ( tmp ) ;
26295: LD_ADDR_VAR 0 15
26299: PUSH
26300: LD_VAR 0 13
26304: PPUSH
26305: CALL_OW 254
26309: ST_TO_ADDR
// if r = 5 then
26310: LD_VAR 0 15
26314: PUSH
26315: LD_INT 5
26317: EQUAL
26318: IFFALSE 26328
// r := 0 ;
26320: LD_ADDR_VAR 0 15
26324: PUSH
26325: LD_INT 0
26327: ST_TO_ADDR
// for j = r to 5 do
26328: LD_ADDR_VAR 0 10
26332: PUSH
26333: DOUBLE
26334: LD_VAR 0 15
26338: DEC
26339: ST_TO_ADDR
26340: LD_INT 5
26342: PUSH
26343: FOR_TO
26344: IFFALSE 26458
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26346: LD_ADDR_VAR 0 11
26350: PUSH
26351: LD_VAR 0 13
26355: PPUSH
26356: CALL_OW 250
26360: PPUSH
26361: LD_VAR 0 10
26365: PPUSH
26366: LD_INT 2
26368: PPUSH
26369: CALL_OW 272
26373: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26374: LD_ADDR_VAR 0 12
26378: PUSH
26379: LD_VAR 0 13
26383: PPUSH
26384: CALL_OW 251
26388: PPUSH
26389: LD_VAR 0 10
26393: PPUSH
26394: LD_INT 2
26396: PPUSH
26397: CALL_OW 273
26401: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26402: LD_VAR 0 11
26406: PPUSH
26407: LD_VAR 0 12
26411: PPUSH
26412: CALL_OW 488
26416: PUSH
26417: LD_VAR 0 11
26421: PPUSH
26422: LD_VAR 0 12
26426: PPUSH
26427: CALL_OW 428
26431: NOT
26432: AND
26433: IFFALSE 26456
// begin ComMoveXY ( tmp , _x , _y ) ;
26435: LD_VAR 0 13
26439: PPUSH
26440: LD_VAR 0 11
26444: PPUSH
26445: LD_VAR 0 12
26449: PPUSH
26450: CALL_OW 111
// break ;
26454: GO 26458
// end ; end ;
26456: GO 26343
26458: POP
26459: POP
// end ; end ;
26460: GO 25785
26462: POP
26463: POP
// end ;
26464: LD_VAR 0 8
26468: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26469: LD_INT 0
26471: PPUSH
// result := true ;
26472: LD_ADDR_VAR 0 3
26476: PUSH
26477: LD_INT 1
26479: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26480: LD_VAR 0 2
26484: PUSH
26485: LD_INT 24
26487: DOUBLE
26488: EQUAL
26489: IFTRUE 26499
26491: LD_INT 33
26493: DOUBLE
26494: EQUAL
26495: IFTRUE 26499
26497: GO 26524
26499: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26500: LD_ADDR_VAR 0 3
26504: PUSH
26505: LD_INT 32
26507: PPUSH
26508: LD_VAR 0 1
26512: PPUSH
26513: CALL_OW 321
26517: PUSH
26518: LD_INT 2
26520: EQUAL
26521: ST_TO_ADDR
26522: GO 26840
26524: LD_INT 20
26526: DOUBLE
26527: EQUAL
26528: IFTRUE 26532
26530: GO 26557
26532: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26533: LD_ADDR_VAR 0 3
26537: PUSH
26538: LD_INT 6
26540: PPUSH
26541: LD_VAR 0 1
26545: PPUSH
26546: CALL_OW 321
26550: PUSH
26551: LD_INT 2
26553: EQUAL
26554: ST_TO_ADDR
26555: GO 26840
26557: LD_INT 22
26559: DOUBLE
26560: EQUAL
26561: IFTRUE 26571
26563: LD_INT 36
26565: DOUBLE
26566: EQUAL
26567: IFTRUE 26571
26569: GO 26596
26571: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26572: LD_ADDR_VAR 0 3
26576: PUSH
26577: LD_INT 15
26579: PPUSH
26580: LD_VAR 0 1
26584: PPUSH
26585: CALL_OW 321
26589: PUSH
26590: LD_INT 2
26592: EQUAL
26593: ST_TO_ADDR
26594: GO 26840
26596: LD_INT 30
26598: DOUBLE
26599: EQUAL
26600: IFTRUE 26604
26602: GO 26629
26604: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26605: LD_ADDR_VAR 0 3
26609: PUSH
26610: LD_INT 20
26612: PPUSH
26613: LD_VAR 0 1
26617: PPUSH
26618: CALL_OW 321
26622: PUSH
26623: LD_INT 2
26625: EQUAL
26626: ST_TO_ADDR
26627: GO 26840
26629: LD_INT 28
26631: DOUBLE
26632: EQUAL
26633: IFTRUE 26643
26635: LD_INT 21
26637: DOUBLE
26638: EQUAL
26639: IFTRUE 26643
26641: GO 26668
26643: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26644: LD_ADDR_VAR 0 3
26648: PUSH
26649: LD_INT 21
26651: PPUSH
26652: LD_VAR 0 1
26656: PPUSH
26657: CALL_OW 321
26661: PUSH
26662: LD_INT 2
26664: EQUAL
26665: ST_TO_ADDR
26666: GO 26840
26668: LD_INT 16
26670: DOUBLE
26671: EQUAL
26672: IFTRUE 26676
26674: GO 26701
26676: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26677: LD_ADDR_VAR 0 3
26681: PUSH
26682: LD_INT 84
26684: PPUSH
26685: LD_VAR 0 1
26689: PPUSH
26690: CALL_OW 321
26694: PUSH
26695: LD_INT 2
26697: EQUAL
26698: ST_TO_ADDR
26699: GO 26840
26701: LD_INT 19
26703: DOUBLE
26704: EQUAL
26705: IFTRUE 26715
26707: LD_INT 23
26709: DOUBLE
26710: EQUAL
26711: IFTRUE 26715
26713: GO 26740
26715: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26716: LD_ADDR_VAR 0 3
26720: PUSH
26721: LD_INT 83
26723: PPUSH
26724: LD_VAR 0 1
26728: PPUSH
26729: CALL_OW 321
26733: PUSH
26734: LD_INT 2
26736: EQUAL
26737: ST_TO_ADDR
26738: GO 26840
26740: LD_INT 17
26742: DOUBLE
26743: EQUAL
26744: IFTRUE 26748
26746: GO 26773
26748: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26749: LD_ADDR_VAR 0 3
26753: PUSH
26754: LD_INT 39
26756: PPUSH
26757: LD_VAR 0 1
26761: PPUSH
26762: CALL_OW 321
26766: PUSH
26767: LD_INT 2
26769: EQUAL
26770: ST_TO_ADDR
26771: GO 26840
26773: LD_INT 18
26775: DOUBLE
26776: EQUAL
26777: IFTRUE 26781
26779: GO 26806
26781: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26782: LD_ADDR_VAR 0 3
26786: PUSH
26787: LD_INT 40
26789: PPUSH
26790: LD_VAR 0 1
26794: PPUSH
26795: CALL_OW 321
26799: PUSH
26800: LD_INT 2
26802: EQUAL
26803: ST_TO_ADDR
26804: GO 26840
26806: LD_INT 27
26808: DOUBLE
26809: EQUAL
26810: IFTRUE 26814
26812: GO 26839
26814: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26815: LD_ADDR_VAR 0 3
26819: PUSH
26820: LD_INT 35
26822: PPUSH
26823: LD_VAR 0 1
26827: PPUSH
26828: CALL_OW 321
26832: PUSH
26833: LD_INT 2
26835: EQUAL
26836: ST_TO_ADDR
26837: GO 26840
26839: POP
// end ;
26840: LD_VAR 0 3
26844: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26845: LD_INT 0
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
// result := false ;
26858: LD_ADDR_VAR 0 6
26862: PUSH
26863: LD_INT 0
26865: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26866: LD_VAR 0 1
26870: NOT
26871: PUSH
26872: LD_VAR 0 1
26876: PPUSH
26877: CALL_OW 266
26881: PUSH
26882: LD_INT 0
26884: PUSH
26885: LD_INT 1
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: IN
26892: NOT
26893: OR
26894: PUSH
26895: LD_VAR 0 2
26899: NOT
26900: OR
26901: PUSH
26902: LD_VAR 0 5
26906: PUSH
26907: LD_INT 0
26909: PUSH
26910: LD_INT 1
26912: PUSH
26913: LD_INT 2
26915: PUSH
26916: LD_INT 3
26918: PUSH
26919: LD_INT 4
26921: PUSH
26922: LD_INT 5
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: IN
26933: NOT
26934: OR
26935: PUSH
26936: LD_VAR 0 3
26940: PPUSH
26941: LD_VAR 0 4
26945: PPUSH
26946: CALL_OW 488
26950: NOT
26951: OR
26952: IFFALSE 26956
// exit ;
26954: GO 27692
// side := GetSide ( depot ) ;
26956: LD_ADDR_VAR 0 9
26960: PUSH
26961: LD_VAR 0 1
26965: PPUSH
26966: CALL_OW 255
26970: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26971: LD_VAR 0 9
26975: PPUSH
26976: LD_VAR 0 2
26980: PPUSH
26981: CALL 26469 0 2
26985: NOT
26986: IFFALSE 26990
// exit ;
26988: GO 27692
// pom := GetBase ( depot ) ;
26990: LD_ADDR_VAR 0 10
26994: PUSH
26995: LD_VAR 0 1
26999: PPUSH
27000: CALL_OW 274
27004: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27005: LD_ADDR_VAR 0 11
27009: PUSH
27010: LD_VAR 0 2
27014: PPUSH
27015: LD_VAR 0 1
27019: PPUSH
27020: CALL_OW 248
27024: PPUSH
27025: CALL_OW 450
27029: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27030: LD_VAR 0 10
27034: PPUSH
27035: LD_INT 1
27037: PPUSH
27038: CALL_OW 275
27042: PUSH
27043: LD_VAR 0 11
27047: PUSH
27048: LD_INT 1
27050: ARRAY
27051: GREATEREQUAL
27052: PUSH
27053: LD_VAR 0 10
27057: PPUSH
27058: LD_INT 2
27060: PPUSH
27061: CALL_OW 275
27065: PUSH
27066: LD_VAR 0 11
27070: PUSH
27071: LD_INT 2
27073: ARRAY
27074: GREATEREQUAL
27075: AND
27076: PUSH
27077: LD_VAR 0 10
27081: PPUSH
27082: LD_INT 3
27084: PPUSH
27085: CALL_OW 275
27089: PUSH
27090: LD_VAR 0 11
27094: PUSH
27095: LD_INT 3
27097: ARRAY
27098: GREATEREQUAL
27099: AND
27100: NOT
27101: IFFALSE 27105
// exit ;
27103: GO 27692
// if GetBType ( depot ) = b_depot then
27105: LD_VAR 0 1
27109: PPUSH
27110: CALL_OW 266
27114: PUSH
27115: LD_INT 0
27117: EQUAL
27118: IFFALSE 27130
// dist := 28 else
27120: LD_ADDR_VAR 0 14
27124: PUSH
27125: LD_INT 28
27127: ST_TO_ADDR
27128: GO 27138
// dist := 36 ;
27130: LD_ADDR_VAR 0 14
27134: PUSH
27135: LD_INT 36
27137: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27138: LD_VAR 0 1
27142: PPUSH
27143: LD_VAR 0 3
27147: PPUSH
27148: LD_VAR 0 4
27152: PPUSH
27153: CALL_OW 297
27157: PUSH
27158: LD_VAR 0 14
27162: GREATER
27163: IFFALSE 27167
// exit ;
27165: GO 27692
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27167: LD_ADDR_VAR 0 12
27171: PUSH
27172: LD_VAR 0 2
27176: PPUSH
27177: LD_VAR 0 3
27181: PPUSH
27182: LD_VAR 0 4
27186: PPUSH
27187: LD_VAR 0 5
27191: PPUSH
27192: LD_VAR 0 1
27196: PPUSH
27197: CALL_OW 248
27201: PPUSH
27202: LD_INT 0
27204: PPUSH
27205: CALL 27697 0 6
27209: ST_TO_ADDR
// if not hexes then
27210: LD_VAR 0 12
27214: NOT
27215: IFFALSE 27219
// exit ;
27217: GO 27692
// hex := GetHexInfo ( x , y ) ;
27219: LD_ADDR_VAR 0 15
27223: PUSH
27224: LD_VAR 0 3
27228: PPUSH
27229: LD_VAR 0 4
27233: PPUSH
27234: CALL_OW 546
27238: ST_TO_ADDR
// if hex [ 1 ] then
27239: LD_VAR 0 15
27243: PUSH
27244: LD_INT 1
27246: ARRAY
27247: IFFALSE 27251
// exit ;
27249: GO 27692
// height := hex [ 2 ] ;
27251: LD_ADDR_VAR 0 13
27255: PUSH
27256: LD_VAR 0 15
27260: PUSH
27261: LD_INT 2
27263: ARRAY
27264: ST_TO_ADDR
// for i = 1 to hexes do
27265: LD_ADDR_VAR 0 7
27269: PUSH
27270: DOUBLE
27271: LD_INT 1
27273: DEC
27274: ST_TO_ADDR
27275: LD_VAR 0 12
27279: PUSH
27280: FOR_TO
27281: IFFALSE 27611
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27283: LD_VAR 0 12
27287: PUSH
27288: LD_VAR 0 7
27292: ARRAY
27293: PUSH
27294: LD_INT 1
27296: ARRAY
27297: PPUSH
27298: LD_VAR 0 12
27302: PUSH
27303: LD_VAR 0 7
27307: ARRAY
27308: PUSH
27309: LD_INT 2
27311: ARRAY
27312: PPUSH
27313: CALL_OW 488
27317: NOT
27318: PUSH
27319: LD_VAR 0 12
27323: PUSH
27324: LD_VAR 0 7
27328: ARRAY
27329: PUSH
27330: LD_INT 1
27332: ARRAY
27333: PPUSH
27334: LD_VAR 0 12
27338: PUSH
27339: LD_VAR 0 7
27343: ARRAY
27344: PUSH
27345: LD_INT 2
27347: ARRAY
27348: PPUSH
27349: CALL_OW 428
27353: PUSH
27354: LD_INT 0
27356: GREATER
27357: OR
27358: PUSH
27359: LD_VAR 0 12
27363: PUSH
27364: LD_VAR 0 7
27368: ARRAY
27369: PUSH
27370: LD_INT 1
27372: ARRAY
27373: PPUSH
27374: LD_VAR 0 12
27378: PUSH
27379: LD_VAR 0 7
27383: ARRAY
27384: PUSH
27385: LD_INT 2
27387: ARRAY
27388: PPUSH
27389: CALL_OW 351
27393: OR
27394: IFFALSE 27400
// exit ;
27396: POP
27397: POP
27398: GO 27692
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27400: LD_ADDR_VAR 0 8
27404: PUSH
27405: LD_VAR 0 12
27409: PUSH
27410: LD_VAR 0 7
27414: ARRAY
27415: PUSH
27416: LD_INT 1
27418: ARRAY
27419: PPUSH
27420: LD_VAR 0 12
27424: PUSH
27425: LD_VAR 0 7
27429: ARRAY
27430: PUSH
27431: LD_INT 2
27433: ARRAY
27434: PPUSH
27435: CALL_OW 546
27439: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27440: LD_VAR 0 8
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PUSH
27449: LD_VAR 0 8
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PUSH
27458: LD_VAR 0 13
27462: PUSH
27463: LD_INT 2
27465: PLUS
27466: GREATER
27467: OR
27468: PUSH
27469: LD_VAR 0 8
27473: PUSH
27474: LD_INT 2
27476: ARRAY
27477: PUSH
27478: LD_VAR 0 13
27482: PUSH
27483: LD_INT 2
27485: MINUS
27486: LESS
27487: OR
27488: PUSH
27489: LD_VAR 0 8
27493: PUSH
27494: LD_INT 3
27496: ARRAY
27497: PUSH
27498: LD_INT 0
27500: PUSH
27501: LD_INT 8
27503: PUSH
27504: LD_INT 9
27506: PUSH
27507: LD_INT 10
27509: PUSH
27510: LD_INT 11
27512: PUSH
27513: LD_INT 12
27515: PUSH
27516: LD_INT 13
27518: PUSH
27519: LD_INT 16
27521: PUSH
27522: LD_INT 17
27524: PUSH
27525: LD_INT 18
27527: PUSH
27528: LD_INT 19
27530: PUSH
27531: LD_INT 20
27533: PUSH
27534: LD_INT 21
27536: PUSH
27537: EMPTY
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: IN
27552: NOT
27553: OR
27554: PUSH
27555: LD_VAR 0 8
27559: PUSH
27560: LD_INT 5
27562: ARRAY
27563: NOT
27564: OR
27565: PUSH
27566: LD_VAR 0 8
27570: PUSH
27571: LD_INT 6
27573: ARRAY
27574: PUSH
27575: LD_INT 1
27577: PUSH
27578: LD_INT 2
27580: PUSH
27581: LD_INT 7
27583: PUSH
27584: LD_INT 9
27586: PUSH
27587: LD_INT 10
27589: PUSH
27590: LD_INT 11
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: IN
27601: NOT
27602: OR
27603: IFFALSE 27609
// exit ;
27605: POP
27606: POP
27607: GO 27692
// end ;
27609: GO 27280
27611: POP
27612: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27613: LD_VAR 0 9
27617: PPUSH
27618: LD_VAR 0 3
27622: PPUSH
27623: LD_VAR 0 4
27627: PPUSH
27628: LD_INT 20
27630: PPUSH
27631: CALL 19644 0 4
27635: PUSH
27636: LD_INT 4
27638: ARRAY
27639: IFFALSE 27643
// exit ;
27641: GO 27692
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27643: LD_VAR 0 2
27647: PUSH
27648: LD_INT 29
27650: PUSH
27651: LD_INT 30
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: IN
27658: PUSH
27659: LD_VAR 0 3
27663: PPUSH
27664: LD_VAR 0 4
27668: PPUSH
27669: LD_VAR 0 9
27673: PPUSH
27674: CALL_OW 440
27678: NOT
27679: AND
27680: IFFALSE 27684
// exit ;
27682: GO 27692
// result := true ;
27684: LD_ADDR_VAR 0 6
27688: PUSH
27689: LD_INT 1
27691: ST_TO_ADDR
// end ;
27692: LD_VAR 0 6
27696: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27697: LD_INT 0
27699: PPUSH
27700: PPUSH
27701: PPUSH
27702: PPUSH
27703: PPUSH
27704: PPUSH
27705: PPUSH
27706: PPUSH
27707: PPUSH
27708: PPUSH
27709: PPUSH
27710: PPUSH
27711: PPUSH
27712: PPUSH
27713: PPUSH
27714: PPUSH
27715: PPUSH
27716: PPUSH
27717: PPUSH
27718: PPUSH
27719: PPUSH
27720: PPUSH
27721: PPUSH
27722: PPUSH
27723: PPUSH
27724: PPUSH
27725: PPUSH
27726: PPUSH
27727: PPUSH
27728: PPUSH
27729: PPUSH
27730: PPUSH
27731: PPUSH
27732: PPUSH
27733: PPUSH
27734: PPUSH
27735: PPUSH
27736: PPUSH
27737: PPUSH
27738: PPUSH
27739: PPUSH
27740: PPUSH
27741: PPUSH
27742: PPUSH
27743: PPUSH
27744: PPUSH
27745: PPUSH
27746: PPUSH
27747: PPUSH
27748: PPUSH
27749: PPUSH
27750: PPUSH
27751: PPUSH
27752: PPUSH
27753: PPUSH
27754: PPUSH
27755: PPUSH
27756: PPUSH
// result = [ ] ;
27757: LD_ADDR_VAR 0 7
27761: PUSH
27762: EMPTY
27763: ST_TO_ADDR
// temp_list = [ ] ;
27764: LD_ADDR_VAR 0 9
27768: PUSH
27769: EMPTY
27770: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27771: LD_VAR 0 4
27775: PUSH
27776: LD_INT 0
27778: PUSH
27779: LD_INT 1
27781: PUSH
27782: LD_INT 2
27784: PUSH
27785: LD_INT 3
27787: PUSH
27788: LD_INT 4
27790: PUSH
27791: LD_INT 5
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: LIST
27798: LIST
27799: LIST
27800: LIST
27801: IN
27802: NOT
27803: PUSH
27804: LD_VAR 0 1
27808: PUSH
27809: LD_INT 0
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: IN
27819: PUSH
27820: LD_VAR 0 5
27824: PUSH
27825: LD_INT 1
27827: PUSH
27828: LD_INT 2
27830: PUSH
27831: LD_INT 3
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: LIST
27838: IN
27839: NOT
27840: AND
27841: OR
27842: IFFALSE 27846
// exit ;
27844: GO 46237
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27846: LD_VAR 0 1
27850: PUSH
27851: LD_INT 6
27853: PUSH
27854: LD_INT 7
27856: PUSH
27857: LD_INT 8
27859: PUSH
27860: LD_INT 13
27862: PUSH
27863: LD_INT 12
27865: PUSH
27866: LD_INT 15
27868: PUSH
27869: LD_INT 11
27871: PUSH
27872: LD_INT 14
27874: PUSH
27875: LD_INT 10
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: LIST
27886: LIST
27887: LIST
27888: IN
27889: IFFALSE 27899
// btype = b_lab ;
27891: LD_ADDR_VAR 0 1
27895: PUSH
27896: LD_INT 6
27898: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27899: LD_VAR 0 6
27903: PUSH
27904: LD_INT 0
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: LD_INT 2
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: LIST
27917: IN
27918: NOT
27919: PUSH
27920: LD_VAR 0 1
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: LD_INT 1
27930: PUSH
27931: LD_INT 2
27933: PUSH
27934: LD_INT 3
27936: PUSH
27937: LD_INT 6
27939: PUSH
27940: LD_INT 36
27942: PUSH
27943: LD_INT 4
27945: PUSH
27946: LD_INT 5
27948: PUSH
27949: LD_INT 31
27951: PUSH
27952: LD_INT 32
27954: PUSH
27955: LD_INT 33
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: LIST
27964: LIST
27965: LIST
27966: LIST
27967: LIST
27968: LIST
27969: LIST
27970: IN
27971: NOT
27972: PUSH
27973: LD_VAR 0 6
27977: PUSH
27978: LD_INT 1
27980: EQUAL
27981: AND
27982: OR
27983: PUSH
27984: LD_VAR 0 1
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: LD_INT 3
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: IN
27999: NOT
28000: PUSH
28001: LD_VAR 0 6
28005: PUSH
28006: LD_INT 2
28008: EQUAL
28009: AND
28010: OR
28011: IFFALSE 28021
// mode = 0 ;
28013: LD_ADDR_VAR 0 6
28017: PUSH
28018: LD_INT 0
28020: ST_TO_ADDR
// case mode of 0 :
28021: LD_VAR 0 6
28025: PUSH
28026: LD_INT 0
28028: DOUBLE
28029: EQUAL
28030: IFTRUE 28034
28032: GO 39487
28034: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28035: LD_ADDR_VAR 0 11
28039: PUSH
28040: LD_INT 0
28042: PUSH
28043: LD_INT 0
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 0
28052: PUSH
28053: LD_INT 1
28055: NEG
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 1
28063: PUSH
28064: LD_INT 0
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: PUSH
28071: LD_INT 1
28073: PUSH
28074: LD_INT 1
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: LD_INT 1
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 1
28093: NEG
28094: PUSH
28095: LD_INT 0
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: NEG
28105: PUSH
28106: LD_INT 1
28108: NEG
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: PUSH
28114: LD_INT 1
28116: NEG
28117: PUSH
28118: LD_INT 2
28120: NEG
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 0
28128: PUSH
28129: LD_INT 2
28131: NEG
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 1
28139: PUSH
28140: LD_INT 1
28142: NEG
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 1
28150: PUSH
28151: LD_INT 2
28153: PUSH
28154: EMPTY
28155: LIST
28156: LIST
28157: PUSH
28158: LD_INT 0
28160: PUSH
28161: LD_INT 2
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: LD_INT 1
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 1
28181: PUSH
28182: LD_INT 3
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 0
28191: PUSH
28192: LD_INT 3
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 1
28201: NEG
28202: PUSH
28203: LD_INT 2
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28228: LD_ADDR_VAR 0 12
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: LD_INT 0
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: LD_INT 0
28245: PUSH
28246: LD_INT 1
28248: NEG
28249: PUSH
28250: EMPTY
28251: LIST
28252: LIST
28253: PUSH
28254: LD_INT 1
28256: PUSH
28257: LD_INT 0
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: LD_INT 1
28266: PUSH
28267: LD_INT 1
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 0
28276: PUSH
28277: LD_INT 1
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 1
28286: NEG
28287: PUSH
28288: LD_INT 0
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: PUSH
28295: LD_INT 1
28297: NEG
28298: PUSH
28299: LD_INT 1
28301: NEG
28302: PUSH
28303: EMPTY
28304: LIST
28305: LIST
28306: PUSH
28307: LD_INT 1
28309: PUSH
28310: LD_INT 1
28312: NEG
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 2
28320: PUSH
28321: LD_INT 0
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 2
28330: PUSH
28331: LD_INT 1
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 1
28340: NEG
28341: PUSH
28342: LD_INT 1
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 2
28362: NEG
28363: PUSH
28364: LD_INT 1
28366: NEG
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 2
28374: NEG
28375: PUSH
28376: LD_INT 1
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PUSH
28383: LD_INT 3
28385: NEG
28386: PUSH
28387: LD_INT 0
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 3
28396: NEG
28397: PUSH
28398: LD_INT 1
28400: NEG
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: LIST
28413: LIST
28414: LIST
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28424: LD_ADDR_VAR 0 13
28428: PUSH
28429: LD_INT 0
28431: PUSH
28432: LD_INT 0
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 0
28441: PUSH
28442: LD_INT 1
28444: NEG
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: LD_INT 0
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: LD_INT 1
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: LD_INT 0
28472: PUSH
28473: LD_INT 1
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 1
28482: NEG
28483: PUSH
28484: LD_INT 0
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: NEG
28494: PUSH
28495: LD_INT 1
28497: NEG
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: LD_INT 2
28509: NEG
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 2
28517: PUSH
28518: LD_INT 1
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: LD_INT 2
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 1
28537: PUSH
28538: LD_INT 2
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 2
28547: NEG
28548: PUSH
28549: LD_INT 1
28551: NEG
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 2
28559: NEG
28560: PUSH
28561: LD_INT 2
28563: NEG
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 2
28571: NEG
28572: PUSH
28573: LD_INT 3
28575: NEG
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 3
28583: NEG
28584: PUSH
28585: LD_INT 2
28587: NEG
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: LD_INT 3
28595: NEG
28596: PUSH
28597: LD_INT 3
28599: NEG
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28623: LD_ADDR_VAR 0 14
28627: PUSH
28628: LD_INT 0
28630: PUSH
28631: LD_INT 0
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: LD_INT 0
28640: PUSH
28641: LD_INT 1
28643: NEG
28644: PUSH
28645: EMPTY
28646: LIST
28647: LIST
28648: PUSH
28649: LD_INT 1
28651: PUSH
28652: LD_INT 0
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: LD_INT 1
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 0
28671: PUSH
28672: LD_INT 1
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: PUSH
28679: LD_INT 1
28681: NEG
28682: PUSH
28683: LD_INT 0
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 1
28692: NEG
28693: PUSH
28694: LD_INT 1
28696: NEG
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 1
28704: NEG
28705: PUSH
28706: LD_INT 2
28708: NEG
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 0
28716: PUSH
28717: LD_INT 2
28719: NEG
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 1
28727: PUSH
28728: LD_INT 1
28730: NEG
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 1
28738: PUSH
28739: LD_INT 2
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 0
28748: PUSH
28749: LD_INT 2
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 1
28758: NEG
28759: PUSH
28760: LD_INT 1
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: LD_INT 1
28769: NEG
28770: PUSH
28771: LD_INT 3
28773: NEG
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: LD_INT 3
28784: NEG
28785: PUSH
28786: EMPTY
28787: LIST
28788: LIST
28789: PUSH
28790: LD_INT 1
28792: PUSH
28793: LD_INT 2
28795: NEG
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: PUSH
28801: EMPTY
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28819: LD_ADDR_VAR 0 15
28823: PUSH
28824: LD_INT 0
28826: PUSH
28827: LD_INT 0
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 0
28836: PUSH
28837: LD_INT 1
28839: NEG
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: LD_INT 0
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 1
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 0
28867: PUSH
28868: LD_INT 1
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 1
28877: NEG
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 1
28892: NEG
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 1
28900: PUSH
28901: LD_INT 1
28903: NEG
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PUSH
28909: LD_INT 2
28911: PUSH
28912: LD_INT 0
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: LD_INT 1
28924: PUSH
28925: EMPTY
28926: LIST
28927: LIST
28928: PUSH
28929: LD_INT 1
28931: NEG
28932: PUSH
28933: LD_INT 1
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 2
28942: NEG
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 2
28953: NEG
28954: PUSH
28955: LD_INT 1
28957: NEG
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: LD_INT 1
28968: NEG
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: LD_INT 3
28976: PUSH
28977: LD_INT 0
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 3
28986: PUSH
28987: LD_INT 1
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29012: LD_ADDR_VAR 0 16
29016: PUSH
29017: LD_INT 0
29019: PUSH
29020: LD_INT 0
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 1
29040: PUSH
29041: LD_INT 0
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: LD_INT 1
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 0
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 1
29070: NEG
29071: PUSH
29072: LD_INT 0
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 1
29081: NEG
29082: PUSH
29083: LD_INT 1
29085: NEG
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: LD_INT 2
29097: NEG
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PUSH
29103: LD_INT 2
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: EMPTY
29120: LIST
29121: LIST
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: EMPTY
29130: LIST
29131: LIST
29132: PUSH
29133: LD_INT 2
29135: NEG
29136: PUSH
29137: LD_INT 1
29139: NEG
29140: PUSH
29141: EMPTY
29142: LIST
29143: LIST
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: LD_INT 2
29151: NEG
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 3
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 3
29169: PUSH
29170: LD_INT 3
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 2
29179: PUSH
29180: LD_INT 3
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29205: LD_ADDR_VAR 0 17
29209: PUSH
29210: LD_INT 0
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: LD_INT 0
29222: PUSH
29223: LD_INT 1
29225: NEG
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: LD_INT 1
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 0
29253: PUSH
29254: LD_INT 1
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 1
29263: NEG
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 1
29274: NEG
29275: PUSH
29276: LD_INT 1
29278: NEG
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: LD_INT 2
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: LD_INT 2
29301: NEG
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 1
29309: PUSH
29310: LD_INT 1
29312: NEG
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 2
29320: PUSH
29321: LD_INT 0
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: LD_INT 2
29330: PUSH
29331: LD_INT 1
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 2
29340: PUSH
29341: LD_INT 2
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 1
29350: PUSH
29351: LD_INT 2
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 0
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 2
29381: NEG
29382: PUSH
29383: LD_INT 0
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: LD_INT 2
29392: NEG
29393: PUSH
29394: LD_INT 1
29396: NEG
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 2
29404: NEG
29405: PUSH
29406: LD_INT 2
29408: NEG
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: LIST
29433: LIST
29434: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29435: LD_ADDR_VAR 0 18
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 0
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 0
29452: PUSH
29453: LD_INT 1
29455: NEG
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 0
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 1
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 0
29483: PUSH
29484: LD_INT 1
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: LD_INT 1
29493: NEG
29494: PUSH
29495: LD_INT 0
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 1
29504: NEG
29505: PUSH
29506: LD_INT 1
29508: NEG
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: LD_INT 2
29520: NEG
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: LD_INT 2
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 1
29542: NEG
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 2
29550: PUSH
29551: LD_INT 0
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 2
29560: PUSH
29561: LD_INT 1
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 2
29570: PUSH
29571: LD_INT 2
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 1
29580: PUSH
29581: LD_INT 2
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 0
29590: PUSH
29591: LD_INT 2
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: PUSH
29605: EMPTY
29606: LIST
29607: LIST
29608: PUSH
29609: LD_INT 2
29611: NEG
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 2
29622: NEG
29623: PUSH
29624: LD_INT 1
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 2
29634: NEG
29635: PUSH
29636: LD_INT 2
29638: NEG
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29665: LD_ADDR_VAR 0 19
29669: PUSH
29670: LD_INT 0
29672: PUSH
29673: LD_INT 0
29675: PUSH
29676: EMPTY
29677: LIST
29678: LIST
29679: PUSH
29680: LD_INT 0
29682: PUSH
29683: LD_INT 1
29685: NEG
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PUSH
29691: LD_INT 1
29693: PUSH
29694: LD_INT 0
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: LD_INT 1
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 0
29713: PUSH
29714: LD_INT 1
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 1
29723: NEG
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: LD_INT 1
29738: NEG
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: LD_INT 2
29750: NEG
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: LD_INT 2
29761: NEG
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 1
29769: PUSH
29770: LD_INT 1
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 2
29780: PUSH
29781: LD_INT 0
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 2
29790: PUSH
29791: LD_INT 1
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 2
29800: PUSH
29801: LD_INT 2
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: LD_INT 2
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 2
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: LD_INT 1
29830: NEG
29831: PUSH
29832: LD_INT 1
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 2
29841: NEG
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 2
29852: NEG
29853: PUSH
29854: LD_INT 1
29856: NEG
29857: PUSH
29858: EMPTY
29859: LIST
29860: LIST
29861: PUSH
29862: LD_INT 2
29864: NEG
29865: PUSH
29866: LD_INT 2
29868: NEG
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29895: LD_ADDR_VAR 0 20
29899: PUSH
29900: LD_INT 0
29902: PUSH
29903: LD_INT 0
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 0
29912: PUSH
29913: LD_INT 1
29915: NEG
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 1
29923: PUSH
29924: LD_INT 0
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: LD_INT 1
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 0
29943: PUSH
29944: LD_INT 1
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 1
29953: NEG
29954: PUSH
29955: LD_INT 0
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 1
29964: NEG
29965: PUSH
29966: LD_INT 1
29968: NEG
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 0
29988: PUSH
29989: LD_INT 2
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 1
30002: NEG
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 2
30010: PUSH
30011: LD_INT 0
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 2
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 2
30030: PUSH
30031: LD_INT 2
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: PUSH
30041: LD_INT 2
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 0
30050: PUSH
30051: LD_INT 2
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: NEG
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: NEG
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: EMPTY
30077: LIST
30078: LIST
30079: PUSH
30080: LD_INT 2
30082: NEG
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 2
30094: NEG
30095: PUSH
30096: LD_INT 2
30098: NEG
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: LIST
30110: LIST
30111: LIST
30112: LIST
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30125: LD_ADDR_VAR 0 21
30129: PUSH
30130: LD_INT 0
30132: PUSH
30133: LD_INT 0
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: LD_INT 1
30145: NEG
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 1
30153: PUSH
30154: LD_INT 0
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 1
30163: PUSH
30164: LD_INT 1
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 0
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 1
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: LD_INT 2
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: LD_INT 1
30232: NEG
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 2
30240: PUSH
30241: LD_INT 0
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: PUSH
30248: LD_INT 2
30250: PUSH
30251: LD_INT 1
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 2
30260: PUSH
30261: LD_INT 2
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 1
30270: PUSH
30271: LD_INT 2
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: LD_INT 2
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 2
30301: NEG
30302: PUSH
30303: LD_INT 0
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 2
30312: NEG
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 2
30324: NEG
30325: PUSH
30326: LD_INT 2
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30355: LD_ADDR_VAR 0 22
30359: PUSH
30360: LD_INT 0
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 0
30372: PUSH
30373: LD_INT 1
30375: NEG
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 1
30383: PUSH
30384: LD_INT 0
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: LD_INT 1
30393: PUSH
30394: LD_INT 1
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 0
30403: PUSH
30404: LD_INT 1
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 1
30424: NEG
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: LD_INT 2
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 1
30462: NEG
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 2
30470: PUSH
30471: LD_INT 0
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 2
30480: PUSH
30481: LD_INT 1
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 2
30490: PUSH
30491: LD_INT 2
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 1
30500: PUSH
30501: LD_INT 2
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: LD_INT 2
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 1
30520: NEG
30521: PUSH
30522: LD_INT 1
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 2
30531: NEG
30532: PUSH
30533: LD_INT 0
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 2
30542: NEG
30543: PUSH
30544: LD_INT 1
30546: NEG
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 2
30554: NEG
30555: PUSH
30556: LD_INT 2
30558: NEG
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30585: LD_ADDR_VAR 0 23
30589: PUSH
30590: LD_INT 0
30592: PUSH
30593: LD_INT 0
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 0
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 1
30613: PUSH
30614: LD_INT 0
30616: PUSH
30617: EMPTY
30618: LIST
30619: LIST
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: LD_INT 1
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 0
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 1
30643: NEG
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: NEG
30655: PUSH
30656: LD_INT 1
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 1
30666: NEG
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 0
30678: PUSH
30679: LD_INT 2
30681: NEG
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 1
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 2
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 2
30710: PUSH
30711: LD_INT 1
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 2
30720: PUSH
30721: LD_INT 2
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 2
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 2
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 1
30750: NEG
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 2
30761: NEG
30762: PUSH
30763: LD_INT 0
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 2
30772: NEG
30773: PUSH
30774: LD_INT 1
30776: NEG
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 2
30784: NEG
30785: PUSH
30786: LD_INT 2
30788: NEG
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: LD_INT 3
30800: NEG
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 1
30808: NEG
30809: PUSH
30810: LD_INT 3
30812: NEG
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 1
30820: PUSH
30821: LD_INT 2
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: PUSH
30832: LD_INT 1
30834: NEG
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30865: LD_ADDR_VAR 0 24
30869: PUSH
30870: LD_INT 0
30872: PUSH
30873: LD_INT 0
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 0
30882: PUSH
30883: LD_INT 1
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: LD_INT 0
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: LD_INT 1
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 0
30913: PUSH
30914: LD_INT 1
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 1
30923: NEG
30924: PUSH
30925: LD_INT 0
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 1
30934: NEG
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: LD_INT 2
30950: NEG
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: LD_INT 0
30958: PUSH
30959: LD_INT 2
30961: NEG
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 1
30969: PUSH
30970: LD_INT 1
30972: NEG
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 2
30980: PUSH
30981: LD_INT 0
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: LD_INT 2
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: LD_INT 2
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: PUSH
31011: LD_INT 2
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: LD_INT 2
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: NEG
31031: PUSH
31032: LD_INT 1
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: NEG
31042: PUSH
31043: LD_INT 0
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 2
31052: NEG
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: NEG
31065: PUSH
31066: LD_INT 2
31068: NEG
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: PUSH
31077: LD_INT 2
31079: NEG
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: LD_INT 1
31090: NEG
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 3
31098: PUSH
31099: LD_INT 1
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 3
31108: PUSH
31109: LD_INT 2
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: LIST
31122: LIST
31123: LIST
31124: LIST
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31141: LD_ADDR_VAR 0 25
31145: PUSH
31146: LD_INT 0
31148: PUSH
31149: LD_INT 0
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 1
31179: PUSH
31180: LD_INT 1
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 0
31189: PUSH
31190: LD_INT 1
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 1
31199: NEG
31200: PUSH
31201: LD_INT 0
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 1
31210: NEG
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 1
31222: NEG
31223: PUSH
31224: LD_INT 2
31226: NEG
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: LD_INT 2
31237: NEG
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: LD_INT 1
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 2
31256: PUSH
31257: LD_INT 0
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 2
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 2
31276: PUSH
31277: LD_INT 2
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: PUSH
31287: LD_INT 2
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 2
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: LD_INT 1
31306: NEG
31307: PUSH
31308: LD_INT 1
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: LD_INT 2
31317: NEG
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: NEG
31329: PUSH
31330: LD_INT 1
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 2
31340: NEG
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 3
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 3
31362: PUSH
31363: LD_INT 2
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: PUSH
31373: LD_INT 3
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: LD_INT 3
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31415: LD_ADDR_VAR 0 26
31419: PUSH
31420: LD_INT 0
31422: PUSH
31423: LD_INT 0
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: LD_INT 1
31435: NEG
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: LD_INT 0
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 1
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 0
31463: PUSH
31464: LD_INT 1
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: LD_INT 1
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: NEG
31497: PUSH
31498: LD_INT 2
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 0
31508: PUSH
31509: LD_INT 2
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 1
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: LD_INT 0
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: LD_INT 1
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 2
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: LD_INT 2
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 0
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: LD_INT 1
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 2
31591: NEG
31592: PUSH
31593: LD_INT 0
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 2
31602: NEG
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: NEG
31615: PUSH
31616: LD_INT 2
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: LD_INT 3
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 1
31636: PUSH
31637: LD_INT 3
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: NEG
31647: PUSH
31648: LD_INT 2
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 2
31657: NEG
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31691: LD_ADDR_VAR 0 27
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 0
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 1
31719: PUSH
31720: LD_INT 0
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PUSH
31727: LD_INT 1
31729: PUSH
31730: LD_INT 1
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: LD_INT 1
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 1
31749: NEG
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: LD_INT 2
31776: NEG
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 2
31787: NEG
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 2
31806: PUSH
31807: LD_INT 0
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 2
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 2
31826: PUSH
31827: LD_INT 2
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: LD_INT 1
31836: PUSH
31837: LD_INT 2
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 0
31846: PUSH
31847: LD_INT 2
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: NEG
31857: PUSH
31858: LD_INT 1
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 2
31867: NEG
31868: PUSH
31869: LD_INT 0
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: LD_INT 1
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 2
31890: NEG
31891: PUSH
31892: LD_INT 2
31894: NEG
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 1
31902: NEG
31903: PUSH
31904: LD_INT 2
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 2
31913: NEG
31914: PUSH
31915: LD_INT 1
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 3
31924: NEG
31925: PUSH
31926: LD_INT 1
31928: NEG
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 3
31936: NEG
31937: PUSH
31938: LD_INT 2
31940: NEG
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31971: LD_ADDR_VAR 0 28
31975: PUSH
31976: LD_INT 0
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 0
31988: PUSH
31989: LD_INT 1
31991: NEG
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 1
31999: PUSH
32000: LD_INT 0
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 1
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 0
32019: PUSH
32020: LD_INT 1
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: LD_INT 0
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 1
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 1
32052: NEG
32053: PUSH
32054: LD_INT 2
32056: NEG
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 0
32064: PUSH
32065: LD_INT 2
32067: NEG
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 1
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 2
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 2
32096: PUSH
32097: LD_INT 1
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 2
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: PUSH
32117: LD_INT 2
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 0
32126: PUSH
32127: LD_INT 2
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 1
32136: NEG
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: LD_INT 0
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: LD_INT 1
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 2
32170: NEG
32171: PUSH
32172: LD_INT 2
32174: NEG
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 2
32182: NEG
32183: PUSH
32184: LD_INT 3
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: NEG
32195: PUSH
32196: LD_INT 3
32198: NEG
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: LD_INT 1
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 3
32218: NEG
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32253: LD_ADDR_VAR 0 29
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: LD_INT 0
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 0
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: PUSH
32282: LD_INT 0
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: PUSH
32292: LD_INT 1
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 0
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: LD_INT 0
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 1
32326: NEG
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: NEG
32335: PUSH
32336: LD_INT 2
32338: NEG
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 0
32346: PUSH
32347: LD_INT 2
32349: NEG
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 1
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 2
32378: PUSH
32379: LD_INT 1
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 1
32388: PUSH
32389: LD_INT 2
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 0
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: LD_INT 1
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 2
32419: NEG
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: NEG
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 2
32443: NEG
32444: PUSH
32445: LD_INT 3
32447: NEG
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 1
32476: PUSH
32477: LD_INT 3
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 1
32486: NEG
32487: PUSH
32488: LD_INT 2
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 3
32497: NEG
32498: PUSH
32499: LD_INT 2
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32532: LD_ADDR_VAR 0 30
32536: PUSH
32537: LD_INT 0
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 0
32549: PUSH
32550: LD_INT 1
32552: NEG
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: PUSH
32558: LD_INT 1
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 1
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PUSH
32578: LD_INT 0
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 1
32590: NEG
32591: PUSH
32592: LD_INT 0
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 1
32601: NEG
32602: PUSH
32603: LD_INT 1
32605: NEG
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 0
32625: PUSH
32626: LD_INT 2
32628: NEG
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: LD_INT 0
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 2
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: PUSH
32678: LD_INT 2
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 1
32687: NEG
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PUSH
32696: LD_INT 2
32698: NEG
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 2
32709: NEG
32710: PUSH
32711: LD_INT 1
32713: NEG
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: LD_INT 3
32725: NEG
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: PUSH
32734: LD_INT 2
32736: NEG
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 3
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 2
32754: PUSH
32755: LD_INT 3
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 2
32764: NEG
32765: PUSH
32766: LD_INT 1
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 3
32775: NEG
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32810: LD_ADDR_VAR 0 31
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: LD_INT 0
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 0
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: LD_INT 0
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: LD_INT 1
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 0
32858: PUSH
32859: LD_INT 1
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 1
32868: NEG
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 1
32879: NEG
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 1
32891: NEG
32892: PUSH
32893: LD_INT 2
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: LD_INT 1
32906: NEG
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 2
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: LD_INT 2
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: LD_INT 2
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 0
32954: PUSH
32955: LD_INT 2
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: LD_INT 1
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: NEG
32976: PUSH
32977: LD_INT 1
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: LD_INT 2
32991: NEG
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 2
32999: NEG
33000: PUSH
33001: LD_INT 3
33003: NEG
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 2
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 3
33022: PUSH
33023: LD_INT 1
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 1
33032: PUSH
33033: LD_INT 3
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: NEG
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 3
33053: NEG
33054: PUSH
33055: LD_INT 2
33057: NEG
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33088: LD_ADDR_VAR 0 32
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: LD_INT 0
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: LD_INT 0
33105: PUSH
33106: LD_INT 1
33108: NEG
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 1
33116: PUSH
33117: LD_INT 0
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: PUSH
33127: LD_INT 1
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 0
33136: PUSH
33137: LD_INT 1
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 1
33146: NEG
33147: PUSH
33148: LD_INT 0
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: LD_INT 2
33173: NEG
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: LD_INT 2
33184: NEG
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 2
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 2
33213: PUSH
33214: LD_INT 2
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: PUSH
33224: LD_INT 2
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: LD_INT 2
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 1
33243: NEG
33244: PUSH
33245: LD_INT 1
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 2
33254: NEG
33255: PUSH
33256: LD_INT 0
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 2
33265: NEG
33266: PUSH
33267: LD_INT 1
33269: NEG
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: NEG
33278: PUSH
33279: LD_INT 3
33281: NEG
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: PUSH
33290: LD_INT 2
33292: NEG
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 3
33300: PUSH
33301: LD_INT 2
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: LD_INT 3
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 2
33320: NEG
33321: PUSH
33322: LD_INT 1
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 3
33331: NEG
33332: PUSH
33333: LD_INT 1
33335: NEG
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33366: LD_ADDR_VAR 0 33
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 0
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: PUSH
33381: LD_INT 0
33383: PUSH
33384: LD_INT 1
33386: NEG
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 0
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 1
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 0
33414: PUSH
33415: LD_INT 1
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 1
33424: NEG
33425: PUSH
33426: LD_INT 0
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: LD_INT 1
33439: NEG
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: LD_INT 2
33451: NEG
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 1
33459: PUSH
33460: LD_INT 1
33462: NEG
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: LD_INT 2
33470: PUSH
33471: LD_INT 0
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 2
33480: PUSH
33481: LD_INT 1
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: LD_INT 2
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 0
33500: PUSH
33501: LD_INT 2
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 1
33510: NEG
33511: PUSH
33512: LD_INT 1
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: NEG
33522: PUSH
33523: LD_INT 0
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 2
33532: NEG
33533: PUSH
33534: LD_INT 1
33536: NEG
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: LD_INT 2
33548: NEG
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 2
33556: NEG
33557: PUSH
33558: LD_INT 3
33560: NEG
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 2
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 3
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 1
33589: PUSH
33590: LD_INT 3
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: NEG
33600: PUSH
33601: LD_INT 2
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 3
33610: NEG
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33645: LD_ADDR_VAR 0 34
33649: PUSH
33650: LD_INT 0
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: LD_INT 1
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 1
33703: NEG
33704: PUSH
33705: LD_INT 0
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 1
33714: NEG
33715: PUSH
33716: LD_INT 1
33718: NEG
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 1
33726: NEG
33727: PUSH
33728: LD_INT 2
33730: NEG
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 1
33749: PUSH
33750: LD_INT 1
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 2
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: PUSH
33771: LD_INT 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: LD_INT 2
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: LD_INT 1
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 0
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 2
33812: NEG
33813: PUSH
33814: LD_INT 1
33816: NEG
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 2
33824: NEG
33825: PUSH
33826: LD_INT 2
33828: NEG
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: LD_INT 3
33840: NEG
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 1
33848: PUSH
33849: LD_INT 2
33851: NEG
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 3
33859: PUSH
33860: LD_INT 2
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 2
33869: PUSH
33870: LD_INT 3
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 2
33879: NEG
33880: PUSH
33881: LD_INT 1
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 3
33890: NEG
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33925: LD_ADDR_VAR 0 35
33929: PUSH
33930: LD_INT 0
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: LD_INT 1
33945: NEG
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: LD_INT 0
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 1
33963: PUSH
33964: LD_INT 1
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: LD_INT 0
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: LD_INT 1
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 2
34006: PUSH
34007: LD_INT 1
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 2
34016: NEG
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34037: LD_ADDR_VAR 0 36
34041: PUSH
34042: LD_INT 0
34044: PUSH
34045: LD_INT 0
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: LD_INT 0
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 1
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 0
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 1
34106: NEG
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34149: LD_ADDR_VAR 0 37
34153: PUSH
34154: LD_INT 0
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 0
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: EMPTY
34192: LIST
34193: LIST
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: LD_INT 0
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: LD_INT 1
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: LD_INT 1
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: LD_INT 1
34245: PUSH
34246: EMPTY
34247: LIST
34248: LIST
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34261: LD_ADDR_VAR 0 38
34265: PUSH
34266: LD_INT 0
34268: PUSH
34269: LD_INT 0
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 0
34278: PUSH
34279: LD_INT 1
34281: NEG
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 1
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 1
34299: PUSH
34300: LD_INT 1
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 0
34309: PUSH
34310: LD_INT 1
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 1
34319: NEG
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: LD_INT 1
34330: NEG
34331: PUSH
34332: LD_INT 1
34334: NEG
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 2
34342: PUSH
34343: LD_INT 1
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 2
34352: NEG
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34373: LD_ADDR_VAR 0 39
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: LD_INT 0
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: LD_INT 1
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: LD_INT 0
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: LD_INT 1
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 0
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: NEG
34443: PUSH
34444: LD_INT 1
34446: NEG
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: LIST
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34485: LD_ADDR_VAR 0 40
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 1
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 0
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 1
34543: NEG
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: LD_INT 1
34558: NEG
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 1
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34597: LD_ADDR_VAR 0 41
34601: PUSH
34602: LD_INT 0
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 0
34614: PUSH
34615: LD_INT 1
34617: NEG
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: PUSH
34626: LD_INT 0
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 1
34635: PUSH
34636: LD_INT 1
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 0
34645: PUSH
34646: LD_INT 1
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 1
34655: NEG
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: LD_INT 1
34670: NEG
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: LD_INT 2
34682: NEG
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 1
34690: PUSH
34691: LD_INT 1
34693: NEG
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 2
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 2
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 2
34721: PUSH
34722: LD_INT 2
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: LD_INT 2
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 2
34752: NEG
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 2
34763: NEG
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 2
34775: NEG
34776: PUSH
34777: LD_INT 2
34779: NEG
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 2
34787: NEG
34788: PUSH
34789: LD_INT 3
34791: NEG
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 2
34799: PUSH
34800: LD_INT 1
34802: NEG
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 3
34810: PUSH
34811: LD_INT 0
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 3
34820: PUSH
34821: LD_INT 1
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 3
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 3
34840: PUSH
34841: LD_INT 3
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 3
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 3
34871: NEG
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 3
34882: NEG
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 3
34894: NEG
34895: PUSH
34896: LD_INT 2
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 3
34906: NEG
34907: PUSH
34908: LD_INT 3
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: LIST
34920: LIST
34921: LIST
34922: LIST
34923: LIST
34924: LIST
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34947: LD_ADDR_VAR 0 42
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 0
34964: PUSH
34965: LD_INT 1
34967: NEG
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 1
34975: PUSH
34976: LD_INT 0
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 1
34985: PUSH
34986: LD_INT 1
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 0
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: NEG
35006: PUSH
35007: LD_INT 0
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: LD_INT 2
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 0
35040: PUSH
35041: LD_INT 2
35043: NEG
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 1
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 2
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 2
35072: PUSH
35073: LD_INT 2
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: PUSH
35083: LD_INT 2
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 2
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: NEG
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: LD_INT 1
35117: NEG
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 2
35125: NEG
35126: PUSH
35127: LD_INT 2
35129: NEG
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: PUSH
35135: LD_INT 2
35137: NEG
35138: PUSH
35139: LD_INT 3
35141: NEG
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: LD_INT 3
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: LD_INT 3
35164: NEG
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 1
35172: PUSH
35173: LD_INT 2
35175: NEG
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 3
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 3
35193: PUSH
35194: LD_INT 3
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 3
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: LD_INT 3
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: LD_INT 3
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 2
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 3
35244: NEG
35245: PUSH
35246: LD_INT 2
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 3
35256: NEG
35257: PUSH
35258: LD_INT 3
35260: NEG
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35297: LD_ADDR_VAR 0 43
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 0
35314: PUSH
35315: LD_INT 1
35317: NEG
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: LD_INT 1
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: LD_INT 0
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 1
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: LD_INT 2
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 2
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 2
35422: PUSH
35423: LD_INT 1
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: LD_INT 2
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: LD_INT 2
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: LD_INT 1
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 2
35463: NEG
35464: PUSH
35465: LD_INT 0
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 2
35474: NEG
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: LD_INT 3
35490: NEG
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 0
35498: PUSH
35499: LD_INT 3
35501: NEG
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: LD_INT 2
35512: NEG
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 2
35520: PUSH
35521: LD_INT 1
35523: NEG
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 3
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 3
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: LD_INT 3
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: LD_INT 3
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: NEG
35572: PUSH
35573: LD_INT 2
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: NEG
35583: PUSH
35584: LD_INT 1
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 3
35593: NEG
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 3
35604: NEG
35605: PUSH
35606: LD_INT 1
35608: NEG
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35645: LD_ADDR_VAR 0 44
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: LD_INT 2
35730: NEG
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 1
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 2
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 2
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: PUSH
35770: LD_INT 2
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 2
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 1
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: NEG
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 2
35811: NEG
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: NEG
35824: PUSH
35825: LD_INT 2
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 2
35835: NEG
35836: PUSH
35837: LD_INT 3
35839: NEG
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 2
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 3
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 3
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 3
35878: PUSH
35879: LD_INT 2
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 3
35888: PUSH
35889: LD_INT 3
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 3
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: LD_INT 1
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: NEG
35920: PUSH
35921: LD_INT 0
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: NEG
35931: PUSH
35932: LD_INT 1
35934: NEG
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 3
35942: NEG
35943: PUSH
35944: LD_INT 2
35946: NEG
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 3
35954: NEG
35955: PUSH
35956: LD_INT 3
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35995: LD_ADDR_VAR 0 45
35999: PUSH
36000: LD_INT 0
36002: PUSH
36003: LD_INT 0
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 0
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: PUSH
36024: LD_INT 0
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 0
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: NEG
36054: PUSH
36055: LD_INT 0
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 1
36064: NEG
36065: PUSH
36066: LD_INT 1
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: LD_INT 2
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 0
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 1
36099: PUSH
36100: LD_INT 1
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 2
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 2
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 1
36150: NEG
36151: PUSH
36152: LD_INT 1
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 2
36161: NEG
36162: PUSH
36163: LD_INT 1
36165: NEG
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 2
36173: NEG
36174: PUSH
36175: LD_INT 2
36177: NEG
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: LD_INT 3
36189: NEG
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: LD_INT 3
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: LD_INT 3
36212: NEG
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: PUSH
36221: LD_INT 2
36223: NEG
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 3
36231: PUSH
36232: LD_INT 2
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 3
36241: PUSH
36242: LD_INT 3
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 2
36251: PUSH
36252: LD_INT 3
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 3
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 3
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: LD_INT 2
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 3
36304: NEG
36305: PUSH
36306: LD_INT 3
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36345: LD_ADDR_VAR 0 46
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 1
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 0
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 0
36393: PUSH
36394: LD_INT 1
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: NEG
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: LD_INT 2
36430: NEG
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: LD_INT 2
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: LD_INT 1
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 2
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 2
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: LD_INT 2
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 0
36490: PUSH
36491: LD_INT 2
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 1
36500: NEG
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 2
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 2
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 3
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 3
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 2
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: LD_INT 1
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 3
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 3
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: LD_INT 3
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 0
36609: PUSH
36610: LD_INT 3
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 1
36619: NEG
36620: PUSH
36621: LD_INT 2
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 2
36630: NEG
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 3
36641: NEG
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 3
36652: NEG
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36693: LD_ADDR_VAR 0 47
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 1
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 0
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 2
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 2
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: LD_INT 2
36824: NEG
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36844: LD_ADDR_VAR 0 48
36848: PUSH
36849: LD_INT 0
36851: PUSH
36852: LD_INT 0
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: LD_INT 1
36864: NEG
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 1
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 0
36892: PUSH
36893: LD_INT 1
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 1
36902: NEG
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PUSH
36911: LD_INT 1
36913: NEG
36914: PUSH
36915: LD_INT 1
36917: NEG
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: LD_INT 2
36929: NEG
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 0
36937: PUSH
36938: LD_INT 2
36940: NEG
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: LD_INT 1
36948: PUSH
36949: LD_INT 1
36951: NEG
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 2
36959: PUSH
36960: LD_INT 0
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: LD_INT 2
36969: PUSH
36970: LD_INT 1
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36991: LD_ADDR_VAR 0 49
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: LD_INT 1
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 1
37019: PUSH
37020: LD_INT 0
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 1
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 0
37039: PUSH
37040: LD_INT 1
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: NEG
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: NEG
37061: PUSH
37062: LD_INT 1
37064: NEG
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: LD_INT 1
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 2
37083: PUSH
37084: LD_INT 0
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 2
37093: PUSH
37094: LD_INT 1
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 2
37103: PUSH
37104: LD_INT 2
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 1
37113: PUSH
37114: LD_INT 2
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37135: LD_ADDR_VAR 0 50
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 1
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: LD_INT 1
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 2
37216: PUSH
37217: LD_INT 1
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 2
37226: PUSH
37227: LD_INT 2
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 1
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: LD_INT 2
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: LIST
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37279: LD_ADDR_VAR 0 51
37283: PUSH
37284: LD_INT 0
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 0
37296: PUSH
37297: LD_INT 1
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: LD_INT 1
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 0
37327: PUSH
37328: LD_INT 1
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: LD_INT 0
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 1
37348: NEG
37349: PUSH
37350: LD_INT 1
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 1
37360: PUSH
37361: LD_INT 2
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 0
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PUSH
37378: LD_INT 1
37380: NEG
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 2
37391: NEG
37392: PUSH
37393: LD_INT 0
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 2
37402: NEG
37403: PUSH
37404: LD_INT 1
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37426: LD_ADDR_VAR 0 52
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 0
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 1
37454: PUSH
37455: LD_INT 0
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: LD_INT 1
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 0
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 1
37484: NEG
37485: PUSH
37486: LD_INT 0
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: NEG
37496: PUSH
37497: LD_INT 1
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: LD_INT 2
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 2
37530: NEG
37531: PUSH
37532: LD_INT 0
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 1
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: LIST
37567: LIST
37568: LIST
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37577: LD_ADDR_VAR 0 53
37581: PUSH
37582: LD_INT 0
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 1
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 1
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: LD_INT 1
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 0
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 1
37635: NEG
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: LD_INT 1
37650: NEG
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: LD_INT 2
37662: NEG
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 0
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: NEG
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 2
37692: PUSH
37693: LD_INT 0
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: PUSH
37700: LD_INT 2
37702: PUSH
37703: LD_INT 1
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 2
37712: PUSH
37713: LD_INT 2
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 1
37722: PUSH
37723: LD_INT 2
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 0
37732: PUSH
37733: LD_INT 2
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: LD_INT 1
37742: NEG
37743: PUSH
37744: LD_INT 1
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 2
37753: NEG
37754: PUSH
37755: LD_INT 0
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 2
37764: NEG
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 2
37776: NEG
37777: PUSH
37778: LD_INT 2
37780: NEG
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: LIST
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37807: LD_ADDR_VAR 0 54
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 1
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 1
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 1
37865: NEG
37866: PUSH
37867: LD_INT 0
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: LD_INT 2
37892: NEG
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: LD_INT 2
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 1
37914: NEG
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 2
37922: PUSH
37923: LD_INT 0
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 2
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 2
37942: PUSH
37943: LD_INT 2
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 1
37952: PUSH
37953: LD_INT 2
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 0
37962: PUSH
37963: LD_INT 2
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 2
37983: NEG
37984: PUSH
37985: LD_INT 0
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 2
37994: NEG
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 2
38006: NEG
38007: PUSH
38008: LD_INT 2
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: LIST
38024: LIST
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38037: LD_ADDR_VAR 0 55
38041: PUSH
38042: LD_INT 0
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 0
38054: PUSH
38055: LD_INT 1
38057: NEG
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 1
38065: PUSH
38066: LD_INT 0
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 1
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: LD_INT 0
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 1
38095: NEG
38096: PUSH
38097: LD_INT 0
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 1
38106: NEG
38107: PUSH
38108: LD_INT 1
38110: NEG
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 1
38118: NEG
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 2
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 1
38141: PUSH
38142: LD_INT 1
38144: NEG
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 2
38152: PUSH
38153: LD_INT 0
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 1
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 2
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: NEG
38203: PUSH
38204: LD_INT 1
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 2
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: NEG
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 2
38236: NEG
38237: PUSH
38238: LD_INT 2
38240: NEG
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38267: LD_ADDR_VAR 0 56
38271: PUSH
38272: LD_INT 0
38274: PUSH
38275: LD_INT 0
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: LD_INT 1
38287: NEG
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: LD_INT 0
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: LD_INT 1
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 0
38315: PUSH
38316: LD_INT 1
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: LD_INT 1
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: LD_INT 2
38352: NEG
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: PUSH
38372: LD_INT 1
38374: NEG
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 1
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 1
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: LD_INT 0
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 2
38454: NEG
38455: PUSH
38456: LD_INT 1
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 2
38466: NEG
38467: PUSH
38468: LD_INT 2
38470: NEG
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: LIST
38484: LIST
38485: LIST
38486: LIST
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38497: LD_ADDR_VAR 0 57
38501: PUSH
38502: LD_INT 0
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: LD_INT 0
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 1
38535: PUSH
38536: LD_INT 1
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 0
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: NEG
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: LD_INT 2
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 2
38622: PUSH
38623: LD_INT 1
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: LD_INT 2
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 1
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 0
38652: PUSH
38653: LD_INT 2
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 1
38662: NEG
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 0
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 2
38684: NEG
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 2
38696: NEG
38697: PUSH
38698: LD_INT 2
38700: NEG
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: LIST
38710: LIST
38711: LIST
38712: LIST
38713: LIST
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38727: LD_ADDR_VAR 0 58
38731: PUSH
38732: LD_INT 0
38734: PUSH
38735: LD_INT 0
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 0
38744: PUSH
38745: LD_INT 1
38747: NEG
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PUSH
38753: LD_INT 1
38755: PUSH
38756: LD_INT 0
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 1
38765: PUSH
38766: LD_INT 1
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 0
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 1
38785: NEG
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: NEG
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: LD_INT 2
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: LD_INT 1
38834: NEG
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 2
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 2
38852: PUSH
38853: LD_INT 1
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 2
38862: PUSH
38863: LD_INT 2
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 1
38872: PUSH
38873: LD_INT 2
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 0
38882: PUSH
38883: LD_INT 2
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 1
38892: NEG
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 2
38903: NEG
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 2
38914: NEG
38915: PUSH
38916: LD_INT 1
38918: NEG
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 2
38926: NEG
38927: PUSH
38928: LD_INT 2
38930: NEG
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: LIST
38940: LIST
38941: LIST
38942: LIST
38943: LIST
38944: LIST
38945: LIST
38946: LIST
38947: LIST
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38957: LD_ADDR_VAR 0 59
38961: PUSH
38962: LD_INT 0
38964: PUSH
38965: LD_INT 0
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 0
38974: PUSH
38975: LD_INT 1
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 1
38985: PUSH
38986: LD_INT 0
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 1
38995: PUSH
38996: LD_INT 1
38998: PUSH
38999: EMPTY
39000: LIST
39001: LIST
39002: PUSH
39003: LD_INT 0
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 1
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39045: LD_ADDR_VAR 0 60
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: LD_INT 0
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 0
39062: PUSH
39063: LD_INT 1
39065: NEG
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 1
39083: PUSH
39084: LD_INT 1
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 1
39114: NEG
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: LIST
39131: LIST
39132: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39133: LD_ADDR_VAR 0 61
39137: PUSH
39138: LD_INT 0
39140: PUSH
39141: LD_INT 0
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: LD_INT 1
39153: NEG
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: LD_INT 0
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 1
39171: PUSH
39172: LD_INT 1
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 0
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: NEG
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39221: LD_ADDR_VAR 0 62
39225: PUSH
39226: LD_INT 0
39228: PUSH
39229: LD_INT 0
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 0
39238: PUSH
39239: LD_INT 1
39241: NEG
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 1
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 1
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 0
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 1
39290: NEG
39291: PUSH
39292: LD_INT 1
39294: NEG
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: LIST
39307: LIST
39308: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39309: LD_ADDR_VAR 0 63
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 0
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 0
39326: PUSH
39327: LD_INT 1
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: LD_INT 0
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 1
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 1
39367: NEG
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 1
39378: NEG
39379: PUSH
39380: LD_INT 1
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39397: LD_ADDR_VAR 0 64
39401: PUSH
39402: LD_INT 0
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 1
39435: PUSH
39436: LD_INT 1
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: LD_INT 1
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 1
39455: NEG
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: LD_INT 1
39470: NEG
39471: PUSH
39472: EMPTY
39473: LIST
39474: LIST
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: LIST
39480: LIST
39481: LIST
39482: LIST
39483: LIST
39484: ST_TO_ADDR
// end ; 1 :
39485: GO 45382
39487: LD_INT 1
39489: DOUBLE
39490: EQUAL
39491: IFTRUE 39495
39493: GO 42118
39495: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39496: LD_ADDR_VAR 0 11
39500: PUSH
39501: LD_INT 1
39503: NEG
39504: PUSH
39505: LD_INT 3
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: LD_INT 3
39518: NEG
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: LD_INT 2
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39540: LD_ADDR_VAR 0 12
39544: PUSH
39545: LD_INT 2
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 3
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 3
39568: PUSH
39569: LD_INT 1
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: LIST
39580: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39581: LD_ADDR_VAR 0 13
39585: PUSH
39586: LD_INT 3
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 3
39598: PUSH
39599: LD_INT 3
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 2
39608: PUSH
39609: LD_INT 3
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: LIST
39620: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39621: LD_ADDR_VAR 0 14
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: LD_INT 3
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: LD_INT 3
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 1
39648: NEG
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: LIST
39661: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39662: LD_ADDR_VAR 0 15
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 3
39680: NEG
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 3
39691: NEG
39692: PUSH
39693: LD_INT 1
39695: NEG
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39706: LD_ADDR_VAR 0 16
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 3
39717: NEG
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 3
39725: NEG
39726: PUSH
39727: LD_INT 2
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 3
39737: NEG
39738: PUSH
39739: LD_INT 3
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: LIST
39751: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39752: LD_ADDR_VAR 0 17
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 3
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: LD_INT 3
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: PUSH
39783: LD_INT 2
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39796: LD_ADDR_VAR 0 18
39800: PUSH
39801: LD_INT 2
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 3
39814: PUSH
39815: LD_INT 0
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 3
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: LIST
39836: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39837: LD_ADDR_VAR 0 19
39841: PUSH
39842: LD_INT 3
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 3
39854: PUSH
39855: LD_INT 3
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 2
39864: PUSH
39865: LD_INT 3
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: LIST
39876: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39877: LD_ADDR_VAR 0 20
39881: PUSH
39882: LD_INT 1
39884: PUSH
39885: LD_INT 3
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: LD_INT 3
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: LD_INT 1
39904: NEG
39905: PUSH
39906: LD_INT 2
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: LIST
39917: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39918: LD_ADDR_VAR 0 21
39922: PUSH
39923: LD_INT 2
39925: NEG
39926: PUSH
39927: LD_INT 1
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 3
39936: NEG
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 3
39947: NEG
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39962: LD_ADDR_VAR 0 22
39966: PUSH
39967: LD_INT 2
39969: NEG
39970: PUSH
39971: LD_INT 3
39973: NEG
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 3
39981: NEG
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 3
39993: NEG
39994: PUSH
39995: LD_INT 3
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: LIST
40007: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40008: LD_ADDR_VAR 0 23
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: LD_INT 3
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: NEG
40027: PUSH
40028: LD_INT 4
40030: NEG
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 1
40038: PUSH
40039: LD_INT 3
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40052: LD_ADDR_VAR 0 24
40056: PUSH
40057: LD_INT 3
40059: PUSH
40060: LD_INT 0
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 3
40069: PUSH
40070: LD_INT 1
40072: NEG
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 4
40080: PUSH
40081: LD_INT 1
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: LIST
40092: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40093: LD_ADDR_VAR 0 25
40097: PUSH
40098: LD_INT 3
40100: PUSH
40101: LD_INT 3
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 4
40110: PUSH
40111: LD_INT 3
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 3
40120: PUSH
40121: LD_INT 4
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: LIST
40132: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40133: LD_ADDR_VAR 0 26
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: LD_INT 3
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 1
40160: NEG
40161: PUSH
40162: LD_INT 3
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: LIST
40173: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40174: LD_ADDR_VAR 0 27
40178: PUSH
40179: LD_INT 3
40181: NEG
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 3
40192: NEG
40193: PUSH
40194: LD_INT 1
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 4
40203: NEG
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40218: LD_ADDR_VAR 0 28
40222: PUSH
40223: LD_INT 3
40225: NEG
40226: PUSH
40227: LD_INT 3
40229: NEG
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 3
40237: NEG
40238: PUSH
40239: LD_INT 4
40241: NEG
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 4
40249: NEG
40250: PUSH
40251: LD_INT 3
40253: NEG
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: LIST
40263: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40264: LD_ADDR_VAR 0 29
40268: PUSH
40269: LD_INT 1
40271: NEG
40272: PUSH
40273: LD_INT 3
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: LD_INT 3
40286: NEG
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: LD_INT 2
40297: NEG
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 4
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 4
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 3
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 1
40339: NEG
40340: PUSH
40341: LD_INT 5
40343: NEG
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: LD_INT 5
40354: NEG
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: PUSH
40363: LD_INT 4
40365: NEG
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 1
40373: NEG
40374: PUSH
40375: LD_INT 6
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: LD_INT 6
40388: NEG
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: PUSH
40397: LD_INT 5
40399: NEG
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40419: LD_ADDR_VAR 0 30
40423: PUSH
40424: LD_INT 2
40426: PUSH
40427: LD_INT 1
40429: NEG
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 3
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: PUSH
40448: LD_INT 1
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 3
40457: PUSH
40458: LD_INT 1
40460: NEG
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 4
40468: PUSH
40469: LD_INT 0
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 4
40478: PUSH
40479: LD_INT 1
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 4
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 5
40499: PUSH
40500: LD_INT 0
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 5
40509: PUSH
40510: LD_INT 1
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 5
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 6
40530: PUSH
40531: LD_INT 0
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 6
40540: PUSH
40541: LD_INT 1
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40562: LD_ADDR_VAR 0 31
40566: PUSH
40567: LD_INT 3
40569: PUSH
40570: LD_INT 2
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: PUSH
40577: LD_INT 3
40579: PUSH
40580: LD_INT 3
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 2
40589: PUSH
40590: LD_INT 3
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 4
40599: PUSH
40600: LD_INT 3
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 4
40609: PUSH
40610: LD_INT 4
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 3
40619: PUSH
40620: LD_INT 4
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 5
40629: PUSH
40630: LD_INT 4
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 5
40639: PUSH
40640: LD_INT 5
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 4
40649: PUSH
40650: LD_INT 5
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 6
40659: PUSH
40660: LD_INT 5
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 6
40669: PUSH
40670: LD_INT 6
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 5
40679: PUSH
40680: LD_INT 6
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40701: LD_ADDR_VAR 0 32
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: LD_INT 3
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 0
40718: PUSH
40719: LD_INT 3
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 1
40728: NEG
40729: PUSH
40730: LD_INT 2
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 4
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 0
40749: PUSH
40750: LD_INT 4
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 1
40759: NEG
40760: PUSH
40761: LD_INT 3
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 1
40770: PUSH
40771: LD_INT 5
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: LD_INT 5
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 1
40790: NEG
40791: PUSH
40792: LD_INT 4
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: PUSH
40799: LD_INT 1
40801: PUSH
40802: LD_INT 6
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 0
40811: PUSH
40812: LD_INT 6
40814: PUSH
40815: EMPTY
40816: LIST
40817: LIST
40818: PUSH
40819: LD_INT 1
40821: NEG
40822: PUSH
40823: LD_INT 5
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: LIST
40834: LIST
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40844: LD_ADDR_VAR 0 33
40848: PUSH
40849: LD_INT 2
40851: NEG
40852: PUSH
40853: LD_INT 1
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 3
40862: NEG
40863: PUSH
40864: LD_INT 0
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: LD_INT 1
40877: NEG
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 3
40885: NEG
40886: PUSH
40887: LD_INT 1
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 4
40896: NEG
40897: PUSH
40898: LD_INT 0
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 4
40907: NEG
40908: PUSH
40909: LD_INT 1
40911: NEG
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 4
40919: NEG
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 5
40930: NEG
40931: PUSH
40932: LD_INT 0
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 5
40941: NEG
40942: PUSH
40943: LD_INT 1
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 5
40953: NEG
40954: PUSH
40955: LD_INT 1
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 6
40964: NEG
40965: PUSH
40966: LD_INT 0
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 6
40975: NEG
40976: PUSH
40977: LD_INT 1
40979: NEG
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40999: LD_ADDR_VAR 0 34
41003: PUSH
41004: LD_INT 2
41006: NEG
41007: PUSH
41008: LD_INT 3
41010: NEG
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 3
41018: NEG
41019: PUSH
41020: LD_INT 2
41022: NEG
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: LD_INT 3
41030: NEG
41031: PUSH
41032: LD_INT 3
41034: NEG
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 3
41042: NEG
41043: PUSH
41044: LD_INT 4
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 4
41054: NEG
41055: PUSH
41056: LD_INT 3
41058: NEG
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 4
41066: NEG
41067: PUSH
41068: LD_INT 4
41070: NEG
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 4
41078: NEG
41079: PUSH
41080: LD_INT 5
41082: NEG
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: LD_INT 5
41090: NEG
41091: PUSH
41092: LD_INT 4
41094: NEG
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 5
41102: NEG
41103: PUSH
41104: LD_INT 5
41106: NEG
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 5
41114: NEG
41115: PUSH
41116: LD_INT 6
41118: NEG
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 6
41126: NEG
41127: PUSH
41128: LD_INT 5
41130: NEG
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 6
41138: NEG
41139: PUSH
41140: LD_INT 6
41142: NEG
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41162: LD_ADDR_VAR 0 41
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: LD_INT 2
41172: NEG
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: LD_INT 1
41180: NEG
41181: PUSH
41182: LD_INT 3
41184: NEG
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 1
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41206: LD_ADDR_VAR 0 42
41210: PUSH
41211: LD_INT 2
41213: PUSH
41214: LD_INT 0
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 2
41223: PUSH
41224: LD_INT 1
41226: NEG
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 3
41234: PUSH
41235: LD_INT 1
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: LIST
41246: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41247: LD_ADDR_VAR 0 43
41251: PUSH
41252: LD_INT 2
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 3
41264: PUSH
41265: LD_INT 2
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 2
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: LIST
41286: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41287: LD_ADDR_VAR 0 44
41291: PUSH
41292: LD_INT 0
41294: PUSH
41295: LD_INT 2
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 1
41304: PUSH
41305: LD_INT 3
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 1
41314: NEG
41315: PUSH
41316: LD_INT 2
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41328: LD_ADDR_VAR 0 45
41332: PUSH
41333: LD_INT 2
41335: NEG
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: LD_INT 1
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 3
41357: NEG
41358: PUSH
41359: LD_INT 1
41361: NEG
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: LIST
41371: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41372: LD_ADDR_VAR 0 46
41376: PUSH
41377: LD_INT 2
41379: NEG
41380: PUSH
41381: LD_INT 2
41383: NEG
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 2
41391: NEG
41392: PUSH
41393: LD_INT 3
41395: NEG
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: LD_INT 2
41407: NEG
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: LIST
41417: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41418: LD_ADDR_VAR 0 47
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: LD_INT 3
41429: NEG
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 1
41437: NEG
41438: PUSH
41439: LD_INT 3
41441: NEG
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41451: LD_ADDR_VAR 0 48
41455: PUSH
41456: LD_INT 1
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 2
41469: PUSH
41470: LD_INT 1
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41482: LD_ADDR_VAR 0 49
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 3
41499: PUSH
41500: LD_INT 2
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41511: LD_ADDR_VAR 0 50
41515: PUSH
41516: LD_INT 2
41518: PUSH
41519: LD_INT 3
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 1
41528: PUSH
41529: LD_INT 3
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41540: LD_ADDR_VAR 0 51
41544: PUSH
41545: LD_INT 1
41547: NEG
41548: PUSH
41549: LD_INT 2
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 2
41558: NEG
41559: PUSH
41560: LD_INT 1
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41571: LD_ADDR_VAR 0 52
41575: PUSH
41576: LD_INT 3
41578: NEG
41579: PUSH
41580: LD_INT 1
41582: NEG
41583: PUSH
41584: EMPTY
41585: LIST
41586: LIST
41587: PUSH
41588: LD_INT 3
41590: NEG
41591: PUSH
41592: LD_INT 2
41594: NEG
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41604: LD_ADDR_VAR 0 53
41608: PUSH
41609: LD_INT 1
41611: NEG
41612: PUSH
41613: LD_INT 3
41615: NEG
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 0
41623: PUSH
41624: LD_INT 3
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 1
41634: PUSH
41635: LD_INT 2
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41648: LD_ADDR_VAR 0 54
41652: PUSH
41653: LD_INT 2
41655: PUSH
41656: LD_INT 1
41658: NEG
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 3
41666: PUSH
41667: LD_INT 0
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: LD_INT 3
41676: PUSH
41677: LD_INT 1
41679: PUSH
41680: EMPTY
41681: LIST
41682: LIST
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: LIST
41688: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41689: LD_ADDR_VAR 0 55
41693: PUSH
41694: LD_INT 3
41696: PUSH
41697: LD_INT 2
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 3
41706: PUSH
41707: LD_INT 3
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 2
41716: PUSH
41717: LD_INT 3
41719: PUSH
41720: EMPTY
41721: LIST
41722: LIST
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: LIST
41728: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41729: LD_ADDR_VAR 0 56
41733: PUSH
41734: LD_INT 1
41736: PUSH
41737: LD_INT 3
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 0
41746: PUSH
41747: LD_INT 3
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 1
41756: NEG
41757: PUSH
41758: LD_INT 2
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: LIST
41769: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41770: LD_ADDR_VAR 0 57
41774: PUSH
41775: LD_INT 2
41777: NEG
41778: PUSH
41779: LD_INT 1
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 3
41788: NEG
41789: PUSH
41790: LD_INT 0
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 3
41799: NEG
41800: PUSH
41801: LD_INT 1
41803: NEG
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41814: LD_ADDR_VAR 0 58
41818: PUSH
41819: LD_INT 2
41821: NEG
41822: PUSH
41823: LD_INT 3
41825: NEG
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: LD_INT 2
41837: NEG
41838: PUSH
41839: EMPTY
41840: LIST
41841: LIST
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: LD_INT 3
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: LIST
41859: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41860: LD_ADDR_VAR 0 59
41864: PUSH
41865: LD_INT 1
41867: NEG
41868: PUSH
41869: LD_INT 2
41871: NEG
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 0
41879: PUSH
41880: LD_INT 2
41882: NEG
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: LD_INT 1
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41904: LD_ADDR_VAR 0 60
41908: PUSH
41909: LD_INT 1
41911: PUSH
41912: LD_INT 1
41914: NEG
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 2
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 2
41932: PUSH
41933: LD_INT 1
41935: PUSH
41936: EMPTY
41937: LIST
41938: LIST
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: LIST
41944: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41945: LD_ADDR_VAR 0 61
41949: PUSH
41950: LD_INT 2
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: LD_INT 2
41962: PUSH
41963: LD_INT 2
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 1
41972: PUSH
41973: LD_INT 2
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: LIST
41984: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41985: LD_ADDR_VAR 0 62
41989: PUSH
41990: LD_INT 1
41992: PUSH
41993: LD_INT 2
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 0
42002: PUSH
42003: LD_INT 2
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 1
42012: NEG
42013: PUSH
42014: LD_INT 1
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: LIST
42025: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42026: LD_ADDR_VAR 0 63
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: LD_INT 1
42037: PUSH
42038: EMPTY
42039: LIST
42040: LIST
42041: PUSH
42042: LD_INT 2
42044: NEG
42045: PUSH
42046: LD_INT 0
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: LD_INT 1
42059: NEG
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: LIST
42069: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42070: LD_ADDR_VAR 0 64
42074: PUSH
42075: LD_INT 1
42077: NEG
42078: PUSH
42079: LD_INT 2
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 2
42089: NEG
42090: PUSH
42091: LD_INT 1
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 2
42101: NEG
42102: PUSH
42103: LD_INT 2
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: LIST
42115: ST_TO_ADDR
// end ; 2 :
42116: GO 45382
42118: LD_INT 2
42120: DOUBLE
42121: EQUAL
42122: IFTRUE 42126
42124: GO 45381
42126: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42127: LD_ADDR_VAR 0 29
42131: PUSH
42132: LD_INT 4
42134: PUSH
42135: LD_INT 0
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 4
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 5
42155: PUSH
42156: LD_INT 0
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 5
42165: PUSH
42166: LD_INT 1
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: LD_INT 4
42175: PUSH
42176: LD_INT 1
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 3
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 3
42195: PUSH
42196: LD_INT 1
42198: NEG
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_INT 3
42206: PUSH
42207: LD_INT 2
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 5
42217: PUSH
42218: LD_INT 2
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: PUSH
42228: LD_INT 3
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 3
42237: PUSH
42238: LD_INT 2
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 4
42247: PUSH
42248: LD_INT 3
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 4
42257: PUSH
42258: LD_INT 4
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 3
42267: PUSH
42268: LD_INT 4
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 2
42277: PUSH
42278: LD_INT 3
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 2
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: PUSH
42298: LD_INT 2
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 2
42307: PUSH
42308: LD_INT 4
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 0
42327: PUSH
42328: LD_INT 3
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 1
42337: PUSH
42338: LD_INT 4
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: LD_INT 5
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 0
42357: PUSH
42358: LD_INT 5
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 1
42367: NEG
42368: PUSH
42369: LD_INT 4
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 1
42378: NEG
42379: PUSH
42380: LD_INT 3
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 2
42389: PUSH
42390: LD_INT 5
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: LD_INT 3
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 3
42410: NEG
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 3
42421: NEG
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: LD_INT 0
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: LD_INT 2
42444: NEG
42445: PUSH
42446: LD_INT 1
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 3
42455: NEG
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 4
42466: NEG
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 4
42477: NEG
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 4
42489: NEG
42490: PUSH
42491: LD_INT 2
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: LD_INT 2
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: PUSH
42510: LD_INT 4
42512: NEG
42513: PUSH
42514: LD_INT 4
42516: NEG
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 4
42524: NEG
42525: PUSH
42526: LD_INT 5
42528: NEG
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 3
42536: NEG
42537: PUSH
42538: LD_INT 4
42540: NEG
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 3
42548: NEG
42549: PUSH
42550: LD_INT 3
42552: NEG
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 4
42560: NEG
42561: PUSH
42562: LD_INT 3
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 5
42572: NEG
42573: PUSH
42574: LD_INT 4
42576: NEG
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 5
42584: NEG
42585: PUSH
42586: LD_INT 5
42588: NEG
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 3
42596: NEG
42597: PUSH
42598: LD_INT 5
42600: NEG
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: PUSH
42606: LD_INT 5
42608: NEG
42609: PUSH
42610: LD_INT 3
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: LIST
42648: LIST
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: LIST
42654: LIST
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42665: LD_ADDR_VAR 0 30
42669: PUSH
42670: LD_INT 4
42672: PUSH
42673: LD_INT 4
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 4
42682: PUSH
42683: LD_INT 3
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 5
42692: PUSH
42693: LD_INT 4
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 5
42702: PUSH
42703: LD_INT 5
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 4
42712: PUSH
42713: LD_INT 5
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 3
42722: PUSH
42723: LD_INT 4
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 3
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 5
42742: PUSH
42743: LD_INT 3
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 3
42752: PUSH
42753: LD_INT 5
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 0
42762: PUSH
42763: LD_INT 3
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: LD_INT 0
42772: PUSH
42773: LD_INT 2
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: LD_INT 1
42782: PUSH
42783: LD_INT 3
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 1
42792: PUSH
42793: LD_INT 4
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 0
42802: PUSH
42803: LD_INT 4
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 1
42812: NEG
42813: PUSH
42814: LD_INT 3
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 1
42823: NEG
42824: PUSH
42825: LD_INT 2
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 2
42834: PUSH
42835: LD_INT 4
42837: PUSH
42838: EMPTY
42839: LIST
42840: LIST
42841: PUSH
42842: LD_INT 2
42844: NEG
42845: PUSH
42846: LD_INT 2
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 4
42855: NEG
42856: PUSH
42857: LD_INT 0
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: PUSH
42864: LD_INT 4
42866: NEG
42867: PUSH
42868: LD_INT 1
42870: NEG
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 3
42878: NEG
42879: PUSH
42880: LD_INT 0
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 3
42889: NEG
42890: PUSH
42891: LD_INT 1
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 4
42900: NEG
42901: PUSH
42902: LD_INT 1
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 5
42911: NEG
42912: PUSH
42913: LD_INT 0
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 5
42922: NEG
42923: PUSH
42924: LD_INT 1
42926: NEG
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: PUSH
42932: LD_INT 5
42934: NEG
42935: PUSH
42936: LD_INT 2
42938: NEG
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 3
42946: NEG
42947: PUSH
42948: LD_INT 2
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 3
42957: NEG
42958: PUSH
42959: LD_INT 3
42961: NEG
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 3
42969: NEG
42970: PUSH
42971: LD_INT 4
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 2
42981: NEG
42982: PUSH
42983: LD_INT 3
42985: NEG
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 2
42993: NEG
42994: PUSH
42995: LD_INT 2
42997: NEG
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PUSH
43003: LD_INT 3
43005: NEG
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 4
43017: NEG
43018: PUSH
43019: LD_INT 3
43021: NEG
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 4
43029: NEG
43030: PUSH
43031: LD_INT 4
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: LD_INT 4
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: LD_INT 4
43053: NEG
43054: PUSH
43055: LD_INT 2
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 0
43065: PUSH
43066: LD_INT 4
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: LD_INT 5
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: LD_INT 4
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: LD_INT 1
43098: PUSH
43099: LD_INT 3
43101: NEG
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: LD_INT 3
43112: NEG
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_INT 1
43120: NEG
43121: PUSH
43122: LD_INT 4
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: NEG
43133: PUSH
43134: LD_INT 5
43136: NEG
43137: PUSH
43138: EMPTY
43139: LIST
43140: LIST
43141: PUSH
43142: LD_INT 2
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 2
43155: NEG
43156: PUSH
43157: LD_INT 5
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: LIST
43210: LIST
43211: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43212: LD_ADDR_VAR 0 31
43216: PUSH
43217: LD_INT 0
43219: PUSH
43220: LD_INT 4
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 0
43229: PUSH
43230: LD_INT 3
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 1
43239: PUSH
43240: LD_INT 4
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 1
43249: PUSH
43250: LD_INT 5
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 0
43259: PUSH
43260: LD_INT 5
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: LD_INT 1
43269: NEG
43270: PUSH
43271: LD_INT 4
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: PUSH
43278: LD_INT 1
43280: NEG
43281: PUSH
43282: LD_INT 3
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 2
43291: PUSH
43292: LD_INT 5
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 2
43301: NEG
43302: PUSH
43303: LD_INT 3
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 3
43312: NEG
43313: PUSH
43314: LD_INT 0
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 3
43323: NEG
43324: PUSH
43325: LD_INT 1
43327: NEG
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 2
43335: NEG
43336: PUSH
43337: LD_INT 0
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: LD_INT 1
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 3
43357: NEG
43358: PUSH
43359: LD_INT 1
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 4
43368: NEG
43369: PUSH
43370: LD_INT 0
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 4
43379: NEG
43380: PUSH
43381: LD_INT 1
43383: NEG
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 4
43391: NEG
43392: PUSH
43393: LD_INT 2
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 2
43403: NEG
43404: PUSH
43405: LD_INT 2
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 4
43414: NEG
43415: PUSH
43416: LD_INT 4
43418: NEG
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 4
43426: NEG
43427: PUSH
43428: LD_INT 5
43430: NEG
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: LD_INT 3
43438: NEG
43439: PUSH
43440: LD_INT 4
43442: NEG
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 3
43450: NEG
43451: PUSH
43452: LD_INT 3
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 4
43462: NEG
43463: PUSH
43464: LD_INT 3
43466: NEG
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 5
43474: NEG
43475: PUSH
43476: LD_INT 4
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 5
43486: NEG
43487: PUSH
43488: LD_INT 5
43490: NEG
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: NEG
43499: PUSH
43500: LD_INT 5
43502: NEG
43503: PUSH
43504: EMPTY
43505: LIST
43506: LIST
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: LD_INT 3
43514: NEG
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: LD_INT 3
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 0
43533: PUSH
43534: LD_INT 4
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 3
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: LD_INT 2
43558: NEG
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: LD_INT 2
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 1
43577: NEG
43578: PUSH
43579: LD_INT 3
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 1
43589: NEG
43590: PUSH
43591: LD_INT 4
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 2
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: LD_INT 4
43616: NEG
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 4
43624: PUSH
43625: LD_INT 0
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 4
43634: PUSH
43635: LD_INT 1
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 5
43645: PUSH
43646: LD_INT 0
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 5
43655: PUSH
43656: LD_INT 1
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: LD_INT 1
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 0
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 3
43685: PUSH
43686: LD_INT 1
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 5
43707: PUSH
43708: LD_INT 2
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43762: LD_ADDR_VAR 0 32
43766: PUSH
43767: LD_INT 4
43769: NEG
43770: PUSH
43771: LD_INT 0
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 4
43780: NEG
43781: PUSH
43782: LD_INT 1
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 3
43792: NEG
43793: PUSH
43794: LD_INT 0
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 3
43803: NEG
43804: PUSH
43805: LD_INT 1
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 4
43814: NEG
43815: PUSH
43816: LD_INT 1
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 5
43825: NEG
43826: PUSH
43827: LD_INT 0
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 5
43836: NEG
43837: PUSH
43838: LD_INT 1
43840: NEG
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 5
43848: NEG
43849: PUSH
43850: LD_INT 2
43852: NEG
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 3
43860: NEG
43861: PUSH
43862: LD_INT 2
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 3
43871: NEG
43872: PUSH
43873: LD_INT 3
43875: NEG
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 3
43883: NEG
43884: PUSH
43885: LD_INT 4
43887: NEG
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 2
43895: NEG
43896: PUSH
43897: LD_INT 3
43899: NEG
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 2
43907: NEG
43908: PUSH
43909: LD_INT 2
43911: NEG
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: NEG
43920: PUSH
43921: LD_INT 2
43923: NEG
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 4
43931: NEG
43932: PUSH
43933: LD_INT 3
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 4
43943: NEG
43944: PUSH
43945: LD_INT 4
43947: NEG
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 2
43955: NEG
43956: PUSH
43957: LD_INT 4
43959: NEG
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 4
43967: NEG
43968: PUSH
43969: LD_INT 2
43971: NEG
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 0
43979: PUSH
43980: LD_INT 4
43982: NEG
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PUSH
43988: LD_INT 0
43990: PUSH
43991: LD_INT 5
43993: NEG
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 1
44001: PUSH
44002: LD_INT 4
44004: NEG
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 1
44012: PUSH
44013: LD_INT 3
44015: NEG
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 0
44023: PUSH
44024: LD_INT 3
44026: NEG
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 1
44034: NEG
44035: PUSH
44036: LD_INT 4
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 1
44046: NEG
44047: PUSH
44048: LD_INT 5
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 2
44058: PUSH
44059: LD_INT 3
44061: NEG
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: PUSH
44067: LD_INT 2
44069: NEG
44070: PUSH
44071: LD_INT 5
44073: NEG
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 3
44081: PUSH
44082: LD_INT 0
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: LD_INT 1
44094: NEG
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 4
44102: PUSH
44103: LD_INT 0
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: PUSH
44113: LD_INT 1
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 3
44122: PUSH
44123: LD_INT 1
44125: PUSH
44126: EMPTY
44127: LIST
44128: LIST
44129: PUSH
44130: LD_INT 2
44132: PUSH
44133: LD_INT 0
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 2
44142: PUSH
44143: LD_INT 1
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 2
44153: PUSH
44154: LD_INT 2
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 4
44164: PUSH
44165: LD_INT 2
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 4
44174: PUSH
44175: LD_INT 4
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 4
44184: PUSH
44185: LD_INT 3
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 5
44194: PUSH
44195: LD_INT 4
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: LD_INT 5
44204: PUSH
44205: LD_INT 5
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 4
44214: PUSH
44215: LD_INT 5
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 3
44224: PUSH
44225: LD_INT 4
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 3
44234: PUSH
44235: LD_INT 3
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 5
44244: PUSH
44245: LD_INT 3
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 3
44254: PUSH
44255: LD_INT 5
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44309: LD_ADDR_VAR 0 33
44313: PUSH
44314: LD_INT 4
44316: NEG
44317: PUSH
44318: LD_INT 4
44320: NEG
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 4
44328: NEG
44329: PUSH
44330: LD_INT 5
44332: NEG
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 3
44340: NEG
44341: PUSH
44342: LD_INT 4
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 3
44352: NEG
44353: PUSH
44354: LD_INT 3
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 4
44364: NEG
44365: PUSH
44366: LD_INT 3
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 5
44376: NEG
44377: PUSH
44378: LD_INT 4
44380: NEG
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 5
44388: NEG
44389: PUSH
44390: LD_INT 5
44392: NEG
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 3
44400: NEG
44401: PUSH
44402: LD_INT 5
44404: NEG
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 5
44412: NEG
44413: PUSH
44414: LD_INT 3
44416: NEG
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 0
44424: PUSH
44425: LD_INT 3
44427: NEG
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 0
44435: PUSH
44436: LD_INT 4
44438: NEG
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: LD_INT 3
44449: NEG
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 1
44457: PUSH
44458: LD_INT 2
44460: NEG
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: LD_INT 0
44468: PUSH
44469: LD_INT 2
44471: NEG
44472: PUSH
44473: EMPTY
44474: LIST
44475: LIST
44476: PUSH
44477: LD_INT 1
44479: NEG
44480: PUSH
44481: LD_INT 3
44483: NEG
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PUSH
44489: LD_INT 1
44491: NEG
44492: PUSH
44493: LD_INT 4
44495: NEG
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 2
44503: PUSH
44504: LD_INT 2
44506: NEG
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 2
44514: NEG
44515: PUSH
44516: LD_INT 4
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 4
44526: PUSH
44527: LD_INT 0
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 4
44536: PUSH
44537: LD_INT 1
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 5
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 5
44557: PUSH
44558: LD_INT 1
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 4
44567: PUSH
44568: LD_INT 1
44570: PUSH
44571: EMPTY
44572: LIST
44573: LIST
44574: PUSH
44575: LD_INT 3
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: EMPTY
44582: LIST
44583: LIST
44584: PUSH
44585: LD_INT 3
44587: PUSH
44588: LD_INT 1
44590: NEG
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 3
44598: PUSH
44599: LD_INT 2
44601: NEG
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 5
44609: PUSH
44610: LD_INT 2
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 3
44619: PUSH
44620: LD_INT 3
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 3
44629: PUSH
44630: LD_INT 2
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 4
44639: PUSH
44640: LD_INT 3
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 4
44649: PUSH
44650: LD_INT 4
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 3
44659: PUSH
44660: LD_INT 4
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 2
44669: PUSH
44670: LD_INT 3
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 2
44679: PUSH
44680: LD_INT 2
44682: PUSH
44683: EMPTY
44684: LIST
44685: LIST
44686: PUSH
44687: LD_INT 4
44689: PUSH
44690: LD_INT 2
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 2
44699: PUSH
44700: LD_INT 4
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 0
44709: PUSH
44710: LD_INT 4
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: EMPTY
44724: LIST
44725: LIST
44726: PUSH
44727: LD_INT 1
44729: PUSH
44730: LD_INT 4
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: LD_INT 1
44739: PUSH
44740: LD_INT 5
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 0
44749: PUSH
44750: LD_INT 5
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 1
44759: NEG
44760: PUSH
44761: LD_INT 4
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 1
44770: NEG
44771: PUSH
44772: LD_INT 3
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 2
44781: PUSH
44782: LD_INT 5
44784: PUSH
44785: EMPTY
44786: LIST
44787: LIST
44788: PUSH
44789: LD_INT 2
44791: NEG
44792: PUSH
44793: LD_INT 3
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44847: LD_ADDR_VAR 0 34
44851: PUSH
44852: LD_INT 0
44854: PUSH
44855: LD_INT 4
44857: NEG
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 0
44865: PUSH
44866: LD_INT 5
44868: NEG
44869: PUSH
44870: EMPTY
44871: LIST
44872: LIST
44873: PUSH
44874: LD_INT 1
44876: PUSH
44877: LD_INT 4
44879: NEG
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 1
44887: PUSH
44888: LD_INT 3
44890: NEG
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PUSH
44896: LD_INT 0
44898: PUSH
44899: LD_INT 3
44901: NEG
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 1
44909: NEG
44910: PUSH
44911: LD_INT 4
44913: NEG
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: LD_INT 1
44921: NEG
44922: PUSH
44923: LD_INT 5
44925: NEG
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 2
44933: PUSH
44934: LD_INT 3
44936: NEG
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 2
44944: NEG
44945: PUSH
44946: LD_INT 5
44948: NEG
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 3
44956: PUSH
44957: LD_INT 0
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 3
44966: PUSH
44967: LD_INT 1
44969: NEG
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 4
44977: PUSH
44978: LD_INT 0
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 4
44987: PUSH
44988: LD_INT 1
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 3
44997: PUSH
44998: LD_INT 1
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 2
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: PUSH
45015: LD_INT 2
45017: PUSH
45018: LD_INT 1
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 2
45028: PUSH
45029: LD_INT 2
45031: NEG
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: LD_INT 4
45039: PUSH
45040: LD_INT 2
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 4
45049: PUSH
45050: LD_INT 4
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 4
45059: PUSH
45060: LD_INT 3
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 5
45069: PUSH
45070: LD_INT 4
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 5
45079: PUSH
45080: LD_INT 5
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: PUSH
45087: LD_INT 4
45089: PUSH
45090: LD_INT 5
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: LD_INT 4
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 3
45109: PUSH
45110: LD_INT 3
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 5
45119: PUSH
45120: LD_INT 3
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 3
45129: PUSH
45130: LD_INT 5
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 0
45139: PUSH
45140: LD_INT 3
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 0
45149: PUSH
45150: LD_INT 2
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 1
45159: PUSH
45160: LD_INT 3
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: LD_INT 4
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 0
45179: PUSH
45180: LD_INT 4
45182: PUSH
45183: EMPTY
45184: LIST
45185: LIST
45186: PUSH
45187: LD_INT 1
45189: NEG
45190: PUSH
45191: LD_INT 3
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 1
45200: NEG
45201: PUSH
45202: LD_INT 2
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 2
45211: PUSH
45212: LD_INT 4
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 2
45221: NEG
45222: PUSH
45223: LD_INT 2
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PUSH
45230: LD_INT 4
45232: NEG
45233: PUSH
45234: LD_INT 0
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 4
45243: NEG
45244: PUSH
45245: LD_INT 1
45247: NEG
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 3
45255: NEG
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 3
45266: NEG
45267: PUSH
45268: LD_INT 1
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 4
45277: NEG
45278: PUSH
45279: LD_INT 1
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 5
45288: NEG
45289: PUSH
45290: LD_INT 0
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 5
45299: NEG
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: LD_INT 5
45311: NEG
45312: PUSH
45313: LD_INT 2
45315: NEG
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 3
45323: NEG
45324: PUSH
45325: LD_INT 2
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: ST_TO_ADDR
// end ; end ;
45379: GO 45382
45381: POP
// case btype of b_depot , b_warehouse :
45382: LD_VAR 0 1
45386: PUSH
45387: LD_INT 0
45389: DOUBLE
45390: EQUAL
45391: IFTRUE 45401
45393: LD_INT 1
45395: DOUBLE
45396: EQUAL
45397: IFTRUE 45401
45399: GO 45602
45401: POP
// case nation of nation_american :
45402: LD_VAR 0 5
45406: PUSH
45407: LD_INT 1
45409: DOUBLE
45410: EQUAL
45411: IFTRUE 45415
45413: GO 45471
45415: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45416: LD_ADDR_VAR 0 9
45420: PUSH
45421: LD_VAR 0 11
45425: PUSH
45426: LD_VAR 0 12
45430: PUSH
45431: LD_VAR 0 13
45435: PUSH
45436: LD_VAR 0 14
45440: PUSH
45441: LD_VAR 0 15
45445: PUSH
45446: LD_VAR 0 16
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: PUSH
45459: LD_VAR 0 4
45463: PUSH
45464: LD_INT 1
45466: PLUS
45467: ARRAY
45468: ST_TO_ADDR
45469: GO 45600
45471: LD_INT 2
45473: DOUBLE
45474: EQUAL
45475: IFTRUE 45479
45477: GO 45535
45479: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45480: LD_ADDR_VAR 0 9
45484: PUSH
45485: LD_VAR 0 17
45489: PUSH
45490: LD_VAR 0 18
45494: PUSH
45495: LD_VAR 0 19
45499: PUSH
45500: LD_VAR 0 20
45504: PUSH
45505: LD_VAR 0 21
45509: PUSH
45510: LD_VAR 0 22
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: PUSH
45523: LD_VAR 0 4
45527: PUSH
45528: LD_INT 1
45530: PLUS
45531: ARRAY
45532: ST_TO_ADDR
45533: GO 45600
45535: LD_INT 3
45537: DOUBLE
45538: EQUAL
45539: IFTRUE 45543
45541: GO 45599
45543: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45544: LD_ADDR_VAR 0 9
45548: PUSH
45549: LD_VAR 0 23
45553: PUSH
45554: LD_VAR 0 24
45558: PUSH
45559: LD_VAR 0 25
45563: PUSH
45564: LD_VAR 0 26
45568: PUSH
45569: LD_VAR 0 27
45573: PUSH
45574: LD_VAR 0 28
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: PUSH
45587: LD_VAR 0 4
45591: PUSH
45592: LD_INT 1
45594: PLUS
45595: ARRAY
45596: ST_TO_ADDR
45597: GO 45600
45599: POP
45600: GO 46155
45602: LD_INT 2
45604: DOUBLE
45605: EQUAL
45606: IFTRUE 45616
45608: LD_INT 3
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45616
45614: GO 45672
45616: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45617: LD_ADDR_VAR 0 9
45621: PUSH
45622: LD_VAR 0 29
45626: PUSH
45627: LD_VAR 0 30
45631: PUSH
45632: LD_VAR 0 31
45636: PUSH
45637: LD_VAR 0 32
45641: PUSH
45642: LD_VAR 0 33
45646: PUSH
45647: LD_VAR 0 34
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: PUSH
45660: LD_VAR 0 4
45664: PUSH
45665: LD_INT 1
45667: PLUS
45668: ARRAY
45669: ST_TO_ADDR
45670: GO 46155
45672: LD_INT 16
45674: DOUBLE
45675: EQUAL
45676: IFTRUE 45734
45678: LD_INT 17
45680: DOUBLE
45681: EQUAL
45682: IFTRUE 45734
45684: LD_INT 18
45686: DOUBLE
45687: EQUAL
45688: IFTRUE 45734
45690: LD_INT 19
45692: DOUBLE
45693: EQUAL
45694: IFTRUE 45734
45696: LD_INT 22
45698: DOUBLE
45699: EQUAL
45700: IFTRUE 45734
45702: LD_INT 20
45704: DOUBLE
45705: EQUAL
45706: IFTRUE 45734
45708: LD_INT 21
45710: DOUBLE
45711: EQUAL
45712: IFTRUE 45734
45714: LD_INT 23
45716: DOUBLE
45717: EQUAL
45718: IFTRUE 45734
45720: LD_INT 24
45722: DOUBLE
45723: EQUAL
45724: IFTRUE 45734
45726: LD_INT 25
45728: DOUBLE
45729: EQUAL
45730: IFTRUE 45734
45732: GO 45790
45734: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45735: LD_ADDR_VAR 0 9
45739: PUSH
45740: LD_VAR 0 35
45744: PUSH
45745: LD_VAR 0 36
45749: PUSH
45750: LD_VAR 0 37
45754: PUSH
45755: LD_VAR 0 38
45759: PUSH
45760: LD_VAR 0 39
45764: PUSH
45765: LD_VAR 0 40
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: PUSH
45778: LD_VAR 0 4
45782: PUSH
45783: LD_INT 1
45785: PLUS
45786: ARRAY
45787: ST_TO_ADDR
45788: GO 46155
45790: LD_INT 6
45792: DOUBLE
45793: EQUAL
45794: IFTRUE 45846
45796: LD_INT 7
45798: DOUBLE
45799: EQUAL
45800: IFTRUE 45846
45802: LD_INT 8
45804: DOUBLE
45805: EQUAL
45806: IFTRUE 45846
45808: LD_INT 13
45810: DOUBLE
45811: EQUAL
45812: IFTRUE 45846
45814: LD_INT 12
45816: DOUBLE
45817: EQUAL
45818: IFTRUE 45846
45820: LD_INT 15
45822: DOUBLE
45823: EQUAL
45824: IFTRUE 45846
45826: LD_INT 11
45828: DOUBLE
45829: EQUAL
45830: IFTRUE 45846
45832: LD_INT 14
45834: DOUBLE
45835: EQUAL
45836: IFTRUE 45846
45838: LD_INT 10
45840: DOUBLE
45841: EQUAL
45842: IFTRUE 45846
45844: GO 45902
45846: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45847: LD_ADDR_VAR 0 9
45851: PUSH
45852: LD_VAR 0 41
45856: PUSH
45857: LD_VAR 0 42
45861: PUSH
45862: LD_VAR 0 43
45866: PUSH
45867: LD_VAR 0 44
45871: PUSH
45872: LD_VAR 0 45
45876: PUSH
45877: LD_VAR 0 46
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: PUSH
45890: LD_VAR 0 4
45894: PUSH
45895: LD_INT 1
45897: PLUS
45898: ARRAY
45899: ST_TO_ADDR
45900: GO 46155
45902: LD_INT 36
45904: DOUBLE
45905: EQUAL
45906: IFTRUE 45910
45908: GO 45966
45910: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45911: LD_ADDR_VAR 0 9
45915: PUSH
45916: LD_VAR 0 47
45920: PUSH
45921: LD_VAR 0 48
45925: PUSH
45926: LD_VAR 0 49
45930: PUSH
45931: LD_VAR 0 50
45935: PUSH
45936: LD_VAR 0 51
45940: PUSH
45941: LD_VAR 0 52
45945: PUSH
45946: EMPTY
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: PUSH
45954: LD_VAR 0 4
45958: PUSH
45959: LD_INT 1
45961: PLUS
45962: ARRAY
45963: ST_TO_ADDR
45964: GO 46155
45966: LD_INT 4
45968: DOUBLE
45969: EQUAL
45970: IFTRUE 45992
45972: LD_INT 5
45974: DOUBLE
45975: EQUAL
45976: IFTRUE 45992
45978: LD_INT 34
45980: DOUBLE
45981: EQUAL
45982: IFTRUE 45992
45984: LD_INT 37
45986: DOUBLE
45987: EQUAL
45988: IFTRUE 45992
45990: GO 46048
45992: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45993: LD_ADDR_VAR 0 9
45997: PUSH
45998: LD_VAR 0 53
46002: PUSH
46003: LD_VAR 0 54
46007: PUSH
46008: LD_VAR 0 55
46012: PUSH
46013: LD_VAR 0 56
46017: PUSH
46018: LD_VAR 0 57
46022: PUSH
46023: LD_VAR 0 58
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: PUSH
46036: LD_VAR 0 4
46040: PUSH
46041: LD_INT 1
46043: PLUS
46044: ARRAY
46045: ST_TO_ADDR
46046: GO 46155
46048: LD_INT 31
46050: DOUBLE
46051: EQUAL
46052: IFTRUE 46098
46054: LD_INT 32
46056: DOUBLE
46057: EQUAL
46058: IFTRUE 46098
46060: LD_INT 33
46062: DOUBLE
46063: EQUAL
46064: IFTRUE 46098
46066: LD_INT 27
46068: DOUBLE
46069: EQUAL
46070: IFTRUE 46098
46072: LD_INT 26
46074: DOUBLE
46075: EQUAL
46076: IFTRUE 46098
46078: LD_INT 28
46080: DOUBLE
46081: EQUAL
46082: IFTRUE 46098
46084: LD_INT 29
46086: DOUBLE
46087: EQUAL
46088: IFTRUE 46098
46090: LD_INT 30
46092: DOUBLE
46093: EQUAL
46094: IFTRUE 46098
46096: GO 46154
46098: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46099: LD_ADDR_VAR 0 9
46103: PUSH
46104: LD_VAR 0 59
46108: PUSH
46109: LD_VAR 0 60
46113: PUSH
46114: LD_VAR 0 61
46118: PUSH
46119: LD_VAR 0 62
46123: PUSH
46124: LD_VAR 0 63
46128: PUSH
46129: LD_VAR 0 64
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: PUSH
46142: LD_VAR 0 4
46146: PUSH
46147: LD_INT 1
46149: PLUS
46150: ARRAY
46151: ST_TO_ADDR
46152: GO 46155
46154: POP
// temp_list2 = [ ] ;
46155: LD_ADDR_VAR 0 10
46159: PUSH
46160: EMPTY
46161: ST_TO_ADDR
// for i in temp_list do
46162: LD_ADDR_VAR 0 8
46166: PUSH
46167: LD_VAR 0 9
46171: PUSH
46172: FOR_IN
46173: IFFALSE 46225
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46175: LD_ADDR_VAR 0 10
46179: PUSH
46180: LD_VAR 0 10
46184: PUSH
46185: LD_VAR 0 8
46189: PUSH
46190: LD_INT 1
46192: ARRAY
46193: PUSH
46194: LD_VAR 0 2
46198: PLUS
46199: PUSH
46200: LD_VAR 0 8
46204: PUSH
46205: LD_INT 2
46207: ARRAY
46208: PUSH
46209: LD_VAR 0 3
46213: PLUS
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: EMPTY
46220: LIST
46221: ADD
46222: ST_TO_ADDR
46223: GO 46172
46225: POP
46226: POP
// result = temp_list2 ;
46227: LD_ADDR_VAR 0 7
46231: PUSH
46232: LD_VAR 0 10
46236: ST_TO_ADDR
// end ;
46237: LD_VAR 0 7
46241: RET
// export function EnemyInRange ( unit , dist ) ; begin
46242: LD_INT 0
46244: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46245: LD_ADDR_VAR 0 3
46249: PUSH
46250: LD_VAR 0 1
46254: PPUSH
46255: CALL_OW 255
46259: PPUSH
46260: LD_VAR 0 1
46264: PPUSH
46265: CALL_OW 250
46269: PPUSH
46270: LD_VAR 0 1
46274: PPUSH
46275: CALL_OW 251
46279: PPUSH
46280: LD_VAR 0 2
46284: PPUSH
46285: CALL 19644 0 4
46289: PUSH
46290: LD_INT 4
46292: ARRAY
46293: ST_TO_ADDR
// end ;
46294: LD_VAR 0 3
46298: RET
// export function PlayerSeeMe ( unit ) ; begin
46299: LD_INT 0
46301: PPUSH
// result := See ( your_side , unit ) ;
46302: LD_ADDR_VAR 0 2
46306: PUSH
46307: LD_OWVAR 2
46311: PPUSH
46312: LD_VAR 0 1
46316: PPUSH
46317: CALL_OW 292
46321: ST_TO_ADDR
// end ;
46322: LD_VAR 0 2
46326: RET
// export function ReverseDir ( unit ) ; begin
46327: LD_INT 0
46329: PPUSH
// if not unit then
46330: LD_VAR 0 1
46334: NOT
46335: IFFALSE 46339
// exit ;
46337: GO 46362
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46339: LD_ADDR_VAR 0 2
46343: PUSH
46344: LD_VAR 0 1
46348: PPUSH
46349: CALL_OW 254
46353: PUSH
46354: LD_INT 3
46356: PLUS
46357: PUSH
46358: LD_INT 6
46360: MOD
46361: ST_TO_ADDR
// end ;
46362: LD_VAR 0 2
46366: RET
// export function ReverseArray ( array ) ; var i ; begin
46367: LD_INT 0
46369: PPUSH
46370: PPUSH
// if not array then
46371: LD_VAR 0 1
46375: NOT
46376: IFFALSE 46380
// exit ;
46378: GO 46435
// result := [ ] ;
46380: LD_ADDR_VAR 0 2
46384: PUSH
46385: EMPTY
46386: ST_TO_ADDR
// for i := array downto 1 do
46387: LD_ADDR_VAR 0 3
46391: PUSH
46392: DOUBLE
46393: LD_VAR 0 1
46397: INC
46398: ST_TO_ADDR
46399: LD_INT 1
46401: PUSH
46402: FOR_DOWNTO
46403: IFFALSE 46433
// result := Join ( result , array [ i ] ) ;
46405: LD_ADDR_VAR 0 2
46409: PUSH
46410: LD_VAR 0 2
46414: PPUSH
46415: LD_VAR 0 1
46419: PUSH
46420: LD_VAR 0 3
46424: ARRAY
46425: PPUSH
46426: CALL 51079 0 2
46430: ST_TO_ADDR
46431: GO 46402
46433: POP
46434: POP
// end ;
46435: LD_VAR 0 2
46439: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
46440: LD_INT 0
46442: PPUSH
46443: PPUSH
46444: PPUSH
46445: PPUSH
46446: PPUSH
46447: PPUSH
// if not unit or not hexes then
46448: LD_VAR 0 1
46452: NOT
46453: PUSH
46454: LD_VAR 0 2
46458: NOT
46459: OR
46460: IFFALSE 46464
// exit ;
46462: GO 46587
// dist := 9999 ;
46464: LD_ADDR_VAR 0 5
46468: PUSH
46469: LD_INT 9999
46471: ST_TO_ADDR
// for i = 1 to hexes do
46472: LD_ADDR_VAR 0 4
46476: PUSH
46477: DOUBLE
46478: LD_INT 1
46480: DEC
46481: ST_TO_ADDR
46482: LD_VAR 0 2
46486: PUSH
46487: FOR_TO
46488: IFFALSE 46575
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46490: LD_ADDR_VAR 0 6
46494: PUSH
46495: LD_VAR 0 1
46499: PPUSH
46500: LD_VAR 0 2
46504: PUSH
46505: LD_VAR 0 4
46509: ARRAY
46510: PUSH
46511: LD_INT 1
46513: ARRAY
46514: PPUSH
46515: LD_VAR 0 2
46519: PUSH
46520: LD_VAR 0 4
46524: ARRAY
46525: PUSH
46526: LD_INT 2
46528: ARRAY
46529: PPUSH
46530: CALL_OW 297
46534: ST_TO_ADDR
// if tdist < dist then
46535: LD_VAR 0 6
46539: PUSH
46540: LD_VAR 0 5
46544: LESS
46545: IFFALSE 46573
// begin hex := hexes [ i ] ;
46547: LD_ADDR_VAR 0 8
46551: PUSH
46552: LD_VAR 0 2
46556: PUSH
46557: LD_VAR 0 4
46561: ARRAY
46562: ST_TO_ADDR
// dist := tdist ;
46563: LD_ADDR_VAR 0 5
46567: PUSH
46568: LD_VAR 0 6
46572: ST_TO_ADDR
// end ; end ;
46573: GO 46487
46575: POP
46576: POP
// result := hex ;
46577: LD_ADDR_VAR 0 3
46581: PUSH
46582: LD_VAR 0 8
46586: ST_TO_ADDR
// end ;
46587: LD_VAR 0 3
46591: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46592: LD_INT 0
46594: PPUSH
46595: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46596: LD_VAR 0 1
46600: NOT
46601: PUSH
46602: LD_VAR 0 1
46606: PUSH
46607: LD_INT 21
46609: PUSH
46610: LD_INT 2
46612: PUSH
46613: EMPTY
46614: LIST
46615: LIST
46616: PUSH
46617: LD_INT 23
46619: PUSH
46620: LD_INT 2
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PPUSH
46631: CALL_OW 69
46635: IN
46636: NOT
46637: OR
46638: IFFALSE 46642
// exit ;
46640: GO 46689
// for i = 1 to 3 do
46642: LD_ADDR_VAR 0 3
46646: PUSH
46647: DOUBLE
46648: LD_INT 1
46650: DEC
46651: ST_TO_ADDR
46652: LD_INT 3
46654: PUSH
46655: FOR_TO
46656: IFFALSE 46687
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46658: LD_VAR 0 1
46662: PPUSH
46663: CALL_OW 250
46667: PPUSH
46668: LD_VAR 0 1
46672: PPUSH
46673: CALL_OW 251
46677: PPUSH
46678: LD_INT 1
46680: PPUSH
46681: CALL_OW 453
46685: GO 46655
46687: POP
46688: POP
// end ;
46689: LD_VAR 0 2
46693: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46694: LD_INT 0
46696: PPUSH
46697: PPUSH
46698: PPUSH
46699: PPUSH
46700: PPUSH
46701: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46702: LD_VAR 0 1
46706: NOT
46707: PUSH
46708: LD_VAR 0 2
46712: NOT
46713: OR
46714: PUSH
46715: LD_VAR 0 1
46719: PPUSH
46720: CALL_OW 314
46724: OR
46725: IFFALSE 46729
// exit ;
46727: GO 47196
// if GetLives ( i ) < 250 then
46729: LD_VAR 0 4
46733: PPUSH
46734: CALL_OW 256
46738: PUSH
46739: LD_INT 250
46741: LESS
46742: IFFALSE 46755
// begin ComAutodestruct ( i ) ;
46744: LD_VAR 0 4
46748: PPUSH
46749: CALL 46592 0 1
// exit ;
46753: GO 47196
// end ; x := GetX ( enemy_unit ) ;
46755: LD_ADDR_VAR 0 7
46759: PUSH
46760: LD_VAR 0 2
46764: PPUSH
46765: CALL_OW 250
46769: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46770: LD_ADDR_VAR 0 8
46774: PUSH
46775: LD_VAR 0 2
46779: PPUSH
46780: CALL_OW 251
46784: ST_TO_ADDR
// if not x or not y then
46785: LD_VAR 0 7
46789: NOT
46790: PUSH
46791: LD_VAR 0 8
46795: NOT
46796: OR
46797: IFFALSE 46801
// exit ;
46799: GO 47196
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46801: LD_ADDR_VAR 0 6
46805: PUSH
46806: LD_VAR 0 7
46810: PPUSH
46811: LD_INT 0
46813: PPUSH
46814: LD_INT 4
46816: PPUSH
46817: CALL_OW 272
46821: PUSH
46822: LD_VAR 0 8
46826: PPUSH
46827: LD_INT 0
46829: PPUSH
46830: LD_INT 4
46832: PPUSH
46833: CALL_OW 273
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_VAR 0 7
46846: PPUSH
46847: LD_INT 1
46849: PPUSH
46850: LD_INT 4
46852: PPUSH
46853: CALL_OW 272
46857: PUSH
46858: LD_VAR 0 8
46862: PPUSH
46863: LD_INT 1
46865: PPUSH
46866: LD_INT 4
46868: PPUSH
46869: CALL_OW 273
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_VAR 0 7
46882: PPUSH
46883: LD_INT 2
46885: PPUSH
46886: LD_INT 4
46888: PPUSH
46889: CALL_OW 272
46893: PUSH
46894: LD_VAR 0 8
46898: PPUSH
46899: LD_INT 2
46901: PPUSH
46902: LD_INT 4
46904: PPUSH
46905: CALL_OW 273
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: LD_VAR 0 7
46918: PPUSH
46919: LD_INT 3
46921: PPUSH
46922: LD_INT 4
46924: PPUSH
46925: CALL_OW 272
46929: PUSH
46930: LD_VAR 0 8
46934: PPUSH
46935: LD_INT 3
46937: PPUSH
46938: LD_INT 4
46940: PPUSH
46941: CALL_OW 273
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_VAR 0 7
46954: PPUSH
46955: LD_INT 4
46957: PPUSH
46958: LD_INT 4
46960: PPUSH
46961: CALL_OW 272
46965: PUSH
46966: LD_VAR 0 8
46970: PPUSH
46971: LD_INT 4
46973: PPUSH
46974: LD_INT 4
46976: PPUSH
46977: CALL_OW 273
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_VAR 0 7
46990: PPUSH
46991: LD_INT 5
46993: PPUSH
46994: LD_INT 4
46996: PPUSH
46997: CALL_OW 272
47001: PUSH
47002: LD_VAR 0 8
47006: PPUSH
47007: LD_INT 5
47009: PPUSH
47010: LD_INT 4
47012: PPUSH
47013: CALL_OW 273
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: ST_TO_ADDR
// for i = tmp downto 1 do
47030: LD_ADDR_VAR 0 4
47034: PUSH
47035: DOUBLE
47036: LD_VAR 0 6
47040: INC
47041: ST_TO_ADDR
47042: LD_INT 1
47044: PUSH
47045: FOR_DOWNTO
47046: IFFALSE 47147
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47048: LD_VAR 0 6
47052: PUSH
47053: LD_VAR 0 4
47057: ARRAY
47058: PUSH
47059: LD_INT 1
47061: ARRAY
47062: PPUSH
47063: LD_VAR 0 6
47067: PUSH
47068: LD_VAR 0 4
47072: ARRAY
47073: PUSH
47074: LD_INT 2
47076: ARRAY
47077: PPUSH
47078: CALL_OW 488
47082: NOT
47083: PUSH
47084: LD_VAR 0 6
47088: PUSH
47089: LD_VAR 0 4
47093: ARRAY
47094: PUSH
47095: LD_INT 1
47097: ARRAY
47098: PPUSH
47099: LD_VAR 0 6
47103: PUSH
47104: LD_VAR 0 4
47108: ARRAY
47109: PUSH
47110: LD_INT 2
47112: ARRAY
47113: PPUSH
47114: CALL_OW 428
47118: PUSH
47119: LD_INT 0
47121: NONEQUAL
47122: OR
47123: IFFALSE 47145
// tmp := Delete ( tmp , i ) ;
47125: LD_ADDR_VAR 0 6
47129: PUSH
47130: LD_VAR 0 6
47134: PPUSH
47135: LD_VAR 0 4
47139: PPUSH
47140: CALL_OW 3
47144: ST_TO_ADDR
47145: GO 47045
47147: POP
47148: POP
// j := GetClosestHex ( unit , tmp ) ;
47149: LD_ADDR_VAR 0 5
47153: PUSH
47154: LD_VAR 0 1
47158: PPUSH
47159: LD_VAR 0 6
47163: PPUSH
47164: CALL 46440 0 2
47168: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47169: LD_VAR 0 1
47173: PPUSH
47174: LD_VAR 0 5
47178: PUSH
47179: LD_INT 1
47181: ARRAY
47182: PPUSH
47183: LD_VAR 0 5
47187: PUSH
47188: LD_INT 2
47190: ARRAY
47191: PPUSH
47192: CALL_OW 111
// end ;
47196: LD_VAR 0 3
47200: RET
// export function PrepareApemanSoldier ( ) ; begin
47201: LD_INT 0
47203: PPUSH
// uc_nation := 0 ;
47204: LD_ADDR_OWVAR 21
47208: PUSH
47209: LD_INT 0
47211: ST_TO_ADDR
// hc_sex := sex_male ;
47212: LD_ADDR_OWVAR 27
47216: PUSH
47217: LD_INT 1
47219: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
47220: LD_ADDR_OWVAR 28
47224: PUSH
47225: LD_INT 15
47227: ST_TO_ADDR
// hc_gallery :=  ;
47228: LD_ADDR_OWVAR 33
47232: PUSH
47233: LD_STRING 
47235: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47236: LD_ADDR_OWVAR 31
47240: PUSH
47241: LD_INT 0
47243: PPUSH
47244: LD_INT 3
47246: PPUSH
47247: CALL_OW 12
47251: PUSH
47252: LD_INT 0
47254: PPUSH
47255: LD_INT 3
47257: PPUSH
47258: CALL_OW 12
47262: PUSH
47263: LD_INT 0
47265: PUSH
47266: LD_INT 0
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: ST_TO_ADDR
// end ;
47275: LD_VAR 0 1
47279: RET
// export function PrepareApemanEngineer ( ) ; begin
47280: LD_INT 0
47282: PPUSH
// uc_nation := 0 ;
47283: LD_ADDR_OWVAR 21
47287: PUSH
47288: LD_INT 0
47290: ST_TO_ADDR
// hc_sex := sex_male ;
47291: LD_ADDR_OWVAR 27
47295: PUSH
47296: LD_INT 1
47298: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
47299: LD_ADDR_OWVAR 28
47303: PUSH
47304: LD_INT 16
47306: ST_TO_ADDR
// hc_gallery :=  ;
47307: LD_ADDR_OWVAR 33
47311: PUSH
47312: LD_STRING 
47314: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47315: LD_ADDR_OWVAR 31
47319: PUSH
47320: LD_INT 0
47322: PPUSH
47323: LD_INT 3
47325: PPUSH
47326: CALL_OW 12
47330: PUSH
47331: LD_INT 0
47333: PPUSH
47334: LD_INT 3
47336: PPUSH
47337: CALL_OW 12
47341: PUSH
47342: LD_INT 0
47344: PUSH
47345: LD_INT 0
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: ST_TO_ADDR
// end ;
47354: LD_VAR 0 1
47358: RET
// export function PrepareApeman ( agressivity ) ; begin
47359: LD_INT 0
47361: PPUSH
// uc_side := 0 ;
47362: LD_ADDR_OWVAR 20
47366: PUSH
47367: LD_INT 0
47369: ST_TO_ADDR
// uc_nation := 0 ;
47370: LD_ADDR_OWVAR 21
47374: PUSH
47375: LD_INT 0
47377: ST_TO_ADDR
// hc_sex := sex_male ;
47378: LD_ADDR_OWVAR 27
47382: PUSH
47383: LD_INT 1
47385: ST_TO_ADDR
// hc_class := class_apeman ;
47386: LD_ADDR_OWVAR 28
47390: PUSH
47391: LD_INT 12
47393: ST_TO_ADDR
// hc_gallery :=  ;
47394: LD_ADDR_OWVAR 33
47398: PUSH
47399: LD_STRING 
47401: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47402: LD_ADDR_OWVAR 35
47406: PUSH
47407: LD_VAR 0 1
47411: NEG
47412: PPUSH
47413: LD_VAR 0 1
47417: PPUSH
47418: CALL_OW 12
47422: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47423: LD_ADDR_OWVAR 31
47427: PUSH
47428: LD_INT 0
47430: PPUSH
47431: LD_INT 3
47433: PPUSH
47434: CALL_OW 12
47438: PUSH
47439: LD_INT 0
47441: PPUSH
47442: LD_INT 3
47444: PPUSH
47445: CALL_OW 12
47449: PUSH
47450: LD_INT 0
47452: PUSH
47453: LD_INT 0
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: ST_TO_ADDR
// end ;
47462: LD_VAR 0 2
47466: RET
// export function PrepareTiger ( agressivity ) ; begin
47467: LD_INT 0
47469: PPUSH
// uc_side := 0 ;
47470: LD_ADDR_OWVAR 20
47474: PUSH
47475: LD_INT 0
47477: ST_TO_ADDR
// uc_nation := 0 ;
47478: LD_ADDR_OWVAR 21
47482: PUSH
47483: LD_INT 0
47485: ST_TO_ADDR
// hc_class := class_tiger ;
47486: LD_ADDR_OWVAR 28
47490: PUSH
47491: LD_INT 14
47493: ST_TO_ADDR
// hc_gallery :=  ;
47494: LD_ADDR_OWVAR 33
47498: PUSH
47499: LD_STRING 
47501: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47502: LD_ADDR_OWVAR 35
47506: PUSH
47507: LD_VAR 0 1
47511: NEG
47512: PPUSH
47513: LD_VAR 0 1
47517: PPUSH
47518: CALL_OW 12
47522: ST_TO_ADDR
// end ;
47523: LD_VAR 0 2
47527: RET
// export function PrepareEnchidna ( ) ; begin
47528: LD_INT 0
47530: PPUSH
// uc_side := 0 ;
47531: LD_ADDR_OWVAR 20
47535: PUSH
47536: LD_INT 0
47538: ST_TO_ADDR
// uc_nation := 0 ;
47539: LD_ADDR_OWVAR 21
47543: PUSH
47544: LD_INT 0
47546: ST_TO_ADDR
// hc_class := class_baggie ;
47547: LD_ADDR_OWVAR 28
47551: PUSH
47552: LD_INT 13
47554: ST_TO_ADDR
// hc_gallery :=  ;
47555: LD_ADDR_OWVAR 33
47559: PUSH
47560: LD_STRING 
47562: ST_TO_ADDR
// end ;
47563: LD_VAR 0 1
47567: RET
// export function PrepareFrog ( ) ; begin
47568: LD_INT 0
47570: PPUSH
// uc_side := 0 ;
47571: LD_ADDR_OWVAR 20
47575: PUSH
47576: LD_INT 0
47578: ST_TO_ADDR
// uc_nation := 0 ;
47579: LD_ADDR_OWVAR 21
47583: PUSH
47584: LD_INT 0
47586: ST_TO_ADDR
// hc_class := class_frog ;
47587: LD_ADDR_OWVAR 28
47591: PUSH
47592: LD_INT 19
47594: ST_TO_ADDR
// hc_gallery :=  ;
47595: LD_ADDR_OWVAR 33
47599: PUSH
47600: LD_STRING 
47602: ST_TO_ADDR
// end ;
47603: LD_VAR 0 1
47607: RET
// export function PrepareFish ( ) ; begin
47608: LD_INT 0
47610: PPUSH
// uc_side := 0 ;
47611: LD_ADDR_OWVAR 20
47615: PUSH
47616: LD_INT 0
47618: ST_TO_ADDR
// uc_nation := 0 ;
47619: LD_ADDR_OWVAR 21
47623: PUSH
47624: LD_INT 0
47626: ST_TO_ADDR
// hc_class := class_fish ;
47627: LD_ADDR_OWVAR 28
47631: PUSH
47632: LD_INT 20
47634: ST_TO_ADDR
// hc_gallery :=  ;
47635: LD_ADDR_OWVAR 33
47639: PUSH
47640: LD_STRING 
47642: ST_TO_ADDR
// end ;
47643: LD_VAR 0 1
47647: RET
// export function PrepareBird ( ) ; begin
47648: LD_INT 0
47650: PPUSH
// uc_side := 0 ;
47651: LD_ADDR_OWVAR 20
47655: PUSH
47656: LD_INT 0
47658: ST_TO_ADDR
// uc_nation := 0 ;
47659: LD_ADDR_OWVAR 21
47663: PUSH
47664: LD_INT 0
47666: ST_TO_ADDR
// hc_class := class_phororhacos ;
47667: LD_ADDR_OWVAR 28
47671: PUSH
47672: LD_INT 18
47674: ST_TO_ADDR
// hc_gallery :=  ;
47675: LD_ADDR_OWVAR 33
47679: PUSH
47680: LD_STRING 
47682: ST_TO_ADDR
// end ;
47683: LD_VAR 0 1
47687: RET
// export function PrepareHorse ( ) ; begin
47688: LD_INT 0
47690: PPUSH
// uc_side := 0 ;
47691: LD_ADDR_OWVAR 20
47695: PUSH
47696: LD_INT 0
47698: ST_TO_ADDR
// uc_nation := 0 ;
47699: LD_ADDR_OWVAR 21
47703: PUSH
47704: LD_INT 0
47706: ST_TO_ADDR
// hc_class := class_horse ;
47707: LD_ADDR_OWVAR 28
47711: PUSH
47712: LD_INT 21
47714: ST_TO_ADDR
// hc_gallery :=  ;
47715: LD_ADDR_OWVAR 33
47719: PUSH
47720: LD_STRING 
47722: ST_TO_ADDR
// end ;
47723: LD_VAR 0 1
47727: RET
// export function PrepareMastodont ( ) ; begin
47728: LD_INT 0
47730: PPUSH
// uc_side := 0 ;
47731: LD_ADDR_OWVAR 20
47735: PUSH
47736: LD_INT 0
47738: ST_TO_ADDR
// uc_nation := 0 ;
47739: LD_ADDR_OWVAR 21
47743: PUSH
47744: LD_INT 0
47746: ST_TO_ADDR
// vc_chassis := class_mastodont ;
47747: LD_ADDR_OWVAR 37
47751: PUSH
47752: LD_INT 31
47754: ST_TO_ADDR
// vc_control := control_rider ;
47755: LD_ADDR_OWVAR 38
47759: PUSH
47760: LD_INT 4
47762: ST_TO_ADDR
// end ;
47763: LD_VAR 0 1
47767: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47768: LD_INT 0
47770: PPUSH
47771: PPUSH
47772: PPUSH
// uc_side = 0 ;
47773: LD_ADDR_OWVAR 20
47777: PUSH
47778: LD_INT 0
47780: ST_TO_ADDR
// uc_nation = 0 ;
47781: LD_ADDR_OWVAR 21
47785: PUSH
47786: LD_INT 0
47788: ST_TO_ADDR
// InitHc_All ( ) ;
47789: CALL_OW 584
// InitVc ;
47793: CALL_OW 20
// if mastodonts then
47797: LD_VAR 0 6
47801: IFFALSE 47868
// for i = 1 to mastodonts do
47803: LD_ADDR_VAR 0 11
47807: PUSH
47808: DOUBLE
47809: LD_INT 1
47811: DEC
47812: ST_TO_ADDR
47813: LD_VAR 0 6
47817: PUSH
47818: FOR_TO
47819: IFFALSE 47866
// begin vc_chassis := 31 ;
47821: LD_ADDR_OWVAR 37
47825: PUSH
47826: LD_INT 31
47828: ST_TO_ADDR
// vc_control := control_rider ;
47829: LD_ADDR_OWVAR 38
47833: PUSH
47834: LD_INT 4
47836: ST_TO_ADDR
// animal := CreateVehicle ;
47837: LD_ADDR_VAR 0 12
47841: PUSH
47842: CALL_OW 45
47846: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47847: LD_VAR 0 12
47851: PPUSH
47852: LD_VAR 0 8
47856: PPUSH
47857: LD_INT 0
47859: PPUSH
47860: CALL 49996 0 3
// end ;
47864: GO 47818
47866: POP
47867: POP
// if horses then
47868: LD_VAR 0 5
47872: IFFALSE 47939
// for i = 1 to horses do
47874: LD_ADDR_VAR 0 11
47878: PUSH
47879: DOUBLE
47880: LD_INT 1
47882: DEC
47883: ST_TO_ADDR
47884: LD_VAR 0 5
47888: PUSH
47889: FOR_TO
47890: IFFALSE 47937
// begin hc_class := 21 ;
47892: LD_ADDR_OWVAR 28
47896: PUSH
47897: LD_INT 21
47899: ST_TO_ADDR
// hc_gallery :=  ;
47900: LD_ADDR_OWVAR 33
47904: PUSH
47905: LD_STRING 
47907: ST_TO_ADDR
// animal := CreateHuman ;
47908: LD_ADDR_VAR 0 12
47912: PUSH
47913: CALL_OW 44
47917: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47918: LD_VAR 0 12
47922: PPUSH
47923: LD_VAR 0 8
47927: PPUSH
47928: LD_INT 0
47930: PPUSH
47931: CALL 49996 0 3
// end ;
47935: GO 47889
47937: POP
47938: POP
// if birds then
47939: LD_VAR 0 1
47943: IFFALSE 48010
// for i = 1 to birds do
47945: LD_ADDR_VAR 0 11
47949: PUSH
47950: DOUBLE
47951: LD_INT 1
47953: DEC
47954: ST_TO_ADDR
47955: LD_VAR 0 1
47959: PUSH
47960: FOR_TO
47961: IFFALSE 48008
// begin hc_class = 18 ;
47963: LD_ADDR_OWVAR 28
47967: PUSH
47968: LD_INT 18
47970: ST_TO_ADDR
// hc_gallery =  ;
47971: LD_ADDR_OWVAR 33
47975: PUSH
47976: LD_STRING 
47978: ST_TO_ADDR
// animal := CreateHuman ;
47979: LD_ADDR_VAR 0 12
47983: PUSH
47984: CALL_OW 44
47988: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47989: LD_VAR 0 12
47993: PPUSH
47994: LD_VAR 0 8
47998: PPUSH
47999: LD_INT 0
48001: PPUSH
48002: CALL 49996 0 3
// end ;
48006: GO 47960
48008: POP
48009: POP
// if tigers then
48010: LD_VAR 0 2
48014: IFFALSE 48098
// for i = 1 to tigers do
48016: LD_ADDR_VAR 0 11
48020: PUSH
48021: DOUBLE
48022: LD_INT 1
48024: DEC
48025: ST_TO_ADDR
48026: LD_VAR 0 2
48030: PUSH
48031: FOR_TO
48032: IFFALSE 48096
// begin hc_class = class_tiger ;
48034: LD_ADDR_OWVAR 28
48038: PUSH
48039: LD_INT 14
48041: ST_TO_ADDR
// hc_gallery =  ;
48042: LD_ADDR_OWVAR 33
48046: PUSH
48047: LD_STRING 
48049: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48050: LD_ADDR_OWVAR 35
48054: PUSH
48055: LD_INT 7
48057: NEG
48058: PPUSH
48059: LD_INT 7
48061: PPUSH
48062: CALL_OW 12
48066: ST_TO_ADDR
// animal := CreateHuman ;
48067: LD_ADDR_VAR 0 12
48071: PUSH
48072: CALL_OW 44
48076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48077: LD_VAR 0 12
48081: PPUSH
48082: LD_VAR 0 8
48086: PPUSH
48087: LD_INT 0
48089: PPUSH
48090: CALL 49996 0 3
// end ;
48094: GO 48031
48096: POP
48097: POP
// if apemans then
48098: LD_VAR 0 3
48102: IFFALSE 48225
// for i = 1 to apemans do
48104: LD_ADDR_VAR 0 11
48108: PUSH
48109: DOUBLE
48110: LD_INT 1
48112: DEC
48113: ST_TO_ADDR
48114: LD_VAR 0 3
48118: PUSH
48119: FOR_TO
48120: IFFALSE 48223
// begin hc_class = class_apeman ;
48122: LD_ADDR_OWVAR 28
48126: PUSH
48127: LD_INT 12
48129: ST_TO_ADDR
// hc_gallery =  ;
48130: LD_ADDR_OWVAR 33
48134: PUSH
48135: LD_STRING 
48137: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48138: LD_ADDR_OWVAR 35
48142: PUSH
48143: LD_INT 2
48145: NEG
48146: PPUSH
48147: LD_INT 2
48149: PPUSH
48150: CALL_OW 12
48154: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48155: LD_ADDR_OWVAR 31
48159: PUSH
48160: LD_INT 1
48162: PPUSH
48163: LD_INT 3
48165: PPUSH
48166: CALL_OW 12
48170: PUSH
48171: LD_INT 1
48173: PPUSH
48174: LD_INT 3
48176: PPUSH
48177: CALL_OW 12
48181: PUSH
48182: LD_INT 0
48184: PUSH
48185: LD_INT 0
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: ST_TO_ADDR
// animal := CreateHuman ;
48194: LD_ADDR_VAR 0 12
48198: PUSH
48199: CALL_OW 44
48203: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48204: LD_VAR 0 12
48208: PPUSH
48209: LD_VAR 0 8
48213: PPUSH
48214: LD_INT 0
48216: PPUSH
48217: CALL 49996 0 3
// end ;
48221: GO 48119
48223: POP
48224: POP
// if enchidnas then
48225: LD_VAR 0 4
48229: IFFALSE 48296
// for i = 1 to enchidnas do
48231: LD_ADDR_VAR 0 11
48235: PUSH
48236: DOUBLE
48237: LD_INT 1
48239: DEC
48240: ST_TO_ADDR
48241: LD_VAR 0 4
48245: PUSH
48246: FOR_TO
48247: IFFALSE 48294
// begin hc_class = 13 ;
48249: LD_ADDR_OWVAR 28
48253: PUSH
48254: LD_INT 13
48256: ST_TO_ADDR
// hc_gallery =  ;
48257: LD_ADDR_OWVAR 33
48261: PUSH
48262: LD_STRING 
48264: ST_TO_ADDR
// animal := CreateHuman ;
48265: LD_ADDR_VAR 0 12
48269: PUSH
48270: CALL_OW 44
48274: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48275: LD_VAR 0 12
48279: PPUSH
48280: LD_VAR 0 8
48284: PPUSH
48285: LD_INT 0
48287: PPUSH
48288: CALL 49996 0 3
// end ;
48292: GO 48246
48294: POP
48295: POP
// if fishes then
48296: LD_VAR 0 7
48300: IFFALSE 48367
// for i = 1 to fishes do
48302: LD_ADDR_VAR 0 11
48306: PUSH
48307: DOUBLE
48308: LD_INT 1
48310: DEC
48311: ST_TO_ADDR
48312: LD_VAR 0 7
48316: PUSH
48317: FOR_TO
48318: IFFALSE 48365
// begin hc_class = 20 ;
48320: LD_ADDR_OWVAR 28
48324: PUSH
48325: LD_INT 20
48327: ST_TO_ADDR
// hc_gallery =  ;
48328: LD_ADDR_OWVAR 33
48332: PUSH
48333: LD_STRING 
48335: ST_TO_ADDR
// animal := CreateHuman ;
48336: LD_ADDR_VAR 0 12
48340: PUSH
48341: CALL_OW 44
48345: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48346: LD_VAR 0 12
48350: PPUSH
48351: LD_VAR 0 9
48355: PPUSH
48356: LD_INT 0
48358: PPUSH
48359: CALL 49996 0 3
// end ;
48363: GO 48317
48365: POP
48366: POP
// end ;
48367: LD_VAR 0 10
48371: RET
// export function WantHeal ( sci , unit ) ; begin
48372: LD_INT 0
48374: PPUSH
// if GetTaskList ( sci ) > 0 then
48375: LD_VAR 0 1
48379: PPUSH
48380: CALL_OW 437
48384: PUSH
48385: LD_INT 0
48387: GREATER
48388: IFFALSE 48458
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48390: LD_VAR 0 1
48394: PPUSH
48395: CALL_OW 437
48399: PUSH
48400: LD_INT 1
48402: ARRAY
48403: PUSH
48404: LD_INT 1
48406: ARRAY
48407: PUSH
48408: LD_STRING l
48410: EQUAL
48411: PUSH
48412: LD_VAR 0 1
48416: PPUSH
48417: CALL_OW 437
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PUSH
48426: LD_INT 4
48428: ARRAY
48429: PUSH
48430: LD_VAR 0 2
48434: EQUAL
48435: AND
48436: IFFALSE 48448
// result := true else
48438: LD_ADDR_VAR 0 3
48442: PUSH
48443: LD_INT 1
48445: ST_TO_ADDR
48446: GO 48456
// result := false ;
48448: LD_ADDR_VAR 0 3
48452: PUSH
48453: LD_INT 0
48455: ST_TO_ADDR
// end else
48456: GO 48466
// result := false ;
48458: LD_ADDR_VAR 0 3
48462: PUSH
48463: LD_INT 0
48465: ST_TO_ADDR
// end ;
48466: LD_VAR 0 3
48470: RET
// export function HealTarget ( sci ) ; begin
48471: LD_INT 0
48473: PPUSH
// if not sci then
48474: LD_VAR 0 1
48478: NOT
48479: IFFALSE 48483
// exit ;
48481: GO 48548
// result := 0 ;
48483: LD_ADDR_VAR 0 2
48487: PUSH
48488: LD_INT 0
48490: ST_TO_ADDR
// if GetTaskList ( sci ) then
48491: LD_VAR 0 1
48495: PPUSH
48496: CALL_OW 437
48500: IFFALSE 48548
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48502: LD_VAR 0 1
48506: PPUSH
48507: CALL_OW 437
48511: PUSH
48512: LD_INT 1
48514: ARRAY
48515: PUSH
48516: LD_INT 1
48518: ARRAY
48519: PUSH
48520: LD_STRING l
48522: EQUAL
48523: IFFALSE 48548
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48525: LD_ADDR_VAR 0 2
48529: PUSH
48530: LD_VAR 0 1
48534: PPUSH
48535: CALL_OW 437
48539: PUSH
48540: LD_INT 1
48542: ARRAY
48543: PUSH
48544: LD_INT 4
48546: ARRAY
48547: ST_TO_ADDR
// end ;
48548: LD_VAR 0 2
48552: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48553: LD_INT 0
48555: PPUSH
48556: PPUSH
48557: PPUSH
48558: PPUSH
// if not base_units then
48559: LD_VAR 0 1
48563: NOT
48564: IFFALSE 48568
// exit ;
48566: GO 48655
// result := false ;
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: LD_INT 0
48575: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48576: LD_ADDR_VAR 0 5
48580: PUSH
48581: LD_VAR 0 1
48585: PPUSH
48586: LD_INT 21
48588: PUSH
48589: LD_INT 3
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PPUSH
48596: CALL_OW 72
48600: ST_TO_ADDR
// if not tmp then
48601: LD_VAR 0 5
48605: NOT
48606: IFFALSE 48610
// exit ;
48608: GO 48655
// for i in tmp do
48610: LD_ADDR_VAR 0 3
48614: PUSH
48615: LD_VAR 0 5
48619: PUSH
48620: FOR_IN
48621: IFFALSE 48653
// begin result := EnemyInRange ( i , 22 ) ;
48623: LD_ADDR_VAR 0 2
48627: PUSH
48628: LD_VAR 0 3
48632: PPUSH
48633: LD_INT 22
48635: PPUSH
48636: CALL 46242 0 2
48640: ST_TO_ADDR
// if result then
48641: LD_VAR 0 2
48645: IFFALSE 48651
// exit ;
48647: POP
48648: POP
48649: GO 48655
// end ;
48651: GO 48620
48653: POP
48654: POP
// end ;
48655: LD_VAR 0 2
48659: RET
// export function FilterByTag ( units , tag ) ; begin
48660: LD_INT 0
48662: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
48663: LD_ADDR_VAR 0 3
48667: PUSH
48668: LD_VAR 0 1
48672: PPUSH
48673: LD_INT 120
48675: PUSH
48676: LD_VAR 0 2
48680: PUSH
48681: EMPTY
48682: LIST
48683: LIST
48684: PPUSH
48685: CALL_OW 72
48689: ST_TO_ADDR
// end ;
48690: LD_VAR 0 3
48694: RET
// export function IsDriver ( un ) ; begin
48695: LD_INT 0
48697: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48698: LD_ADDR_VAR 0 2
48702: PUSH
48703: LD_VAR 0 1
48707: PUSH
48708: LD_INT 55
48710: PUSH
48711: EMPTY
48712: LIST
48713: PPUSH
48714: CALL_OW 69
48718: IN
48719: ST_TO_ADDR
// end ;
48720: LD_VAR 0 2
48724: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48725: LD_INT 0
48727: PPUSH
48728: PPUSH
// list := [ ] ;
48729: LD_ADDR_VAR 0 5
48733: PUSH
48734: EMPTY
48735: ST_TO_ADDR
// case d of 0 :
48736: LD_VAR 0 3
48740: PUSH
48741: LD_INT 0
48743: DOUBLE
48744: EQUAL
48745: IFTRUE 48749
48747: GO 48882
48749: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48750: LD_ADDR_VAR 0 5
48754: PUSH
48755: LD_VAR 0 1
48759: PUSH
48760: LD_INT 4
48762: MINUS
48763: PUSH
48764: LD_VAR 0 2
48768: PUSH
48769: LD_INT 4
48771: MINUS
48772: PUSH
48773: LD_INT 2
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: LIST
48780: PUSH
48781: LD_VAR 0 1
48785: PUSH
48786: LD_INT 3
48788: MINUS
48789: PUSH
48790: LD_VAR 0 2
48794: PUSH
48795: LD_INT 1
48797: PUSH
48798: EMPTY
48799: LIST
48800: LIST
48801: LIST
48802: PUSH
48803: LD_VAR 0 1
48807: PUSH
48808: LD_INT 4
48810: PLUS
48811: PUSH
48812: LD_VAR 0 2
48816: PUSH
48817: LD_INT 4
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: LIST
48824: PUSH
48825: LD_VAR 0 1
48829: PUSH
48830: LD_INT 3
48832: PLUS
48833: PUSH
48834: LD_VAR 0 2
48838: PUSH
48839: LD_INT 3
48841: PLUS
48842: PUSH
48843: LD_INT 5
48845: PUSH
48846: EMPTY
48847: LIST
48848: LIST
48849: LIST
48850: PUSH
48851: LD_VAR 0 1
48855: PUSH
48856: LD_VAR 0 2
48860: PUSH
48861: LD_INT 4
48863: PLUS
48864: PUSH
48865: LD_INT 0
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: LIST
48872: PUSH
48873: EMPTY
48874: LIST
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: ST_TO_ADDR
// end ; 1 :
48880: GO 49580
48882: LD_INT 1
48884: DOUBLE
48885: EQUAL
48886: IFTRUE 48890
48888: GO 49023
48890: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48891: LD_ADDR_VAR 0 5
48895: PUSH
48896: LD_VAR 0 1
48900: PUSH
48901: LD_VAR 0 2
48905: PUSH
48906: LD_INT 4
48908: MINUS
48909: PUSH
48910: LD_INT 3
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: LIST
48917: PUSH
48918: LD_VAR 0 1
48922: PUSH
48923: LD_INT 3
48925: MINUS
48926: PUSH
48927: LD_VAR 0 2
48931: PUSH
48932: LD_INT 3
48934: MINUS
48935: PUSH
48936: LD_INT 2
48938: PUSH
48939: EMPTY
48940: LIST
48941: LIST
48942: LIST
48943: PUSH
48944: LD_VAR 0 1
48948: PUSH
48949: LD_INT 4
48951: MINUS
48952: PUSH
48953: LD_VAR 0 2
48957: PUSH
48958: LD_INT 1
48960: PUSH
48961: EMPTY
48962: LIST
48963: LIST
48964: LIST
48965: PUSH
48966: LD_VAR 0 1
48970: PUSH
48971: LD_VAR 0 2
48975: PUSH
48976: LD_INT 3
48978: PLUS
48979: PUSH
48980: LD_INT 0
48982: PUSH
48983: EMPTY
48984: LIST
48985: LIST
48986: LIST
48987: PUSH
48988: LD_VAR 0 1
48992: PUSH
48993: LD_INT 4
48995: PLUS
48996: PUSH
48997: LD_VAR 0 2
49001: PUSH
49002: LD_INT 4
49004: PLUS
49005: PUSH
49006: LD_INT 5
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: LIST
49013: PUSH
49014: EMPTY
49015: LIST
49016: LIST
49017: LIST
49018: LIST
49019: LIST
49020: ST_TO_ADDR
// end ; 2 :
49021: GO 49580
49023: LD_INT 2
49025: DOUBLE
49026: EQUAL
49027: IFTRUE 49031
49029: GO 49160
49031: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49032: LD_ADDR_VAR 0 5
49036: PUSH
49037: LD_VAR 0 1
49041: PUSH
49042: LD_VAR 0 2
49046: PUSH
49047: LD_INT 3
49049: MINUS
49050: PUSH
49051: LD_INT 3
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: LIST
49058: PUSH
49059: LD_VAR 0 1
49063: PUSH
49064: LD_INT 4
49066: PLUS
49067: PUSH
49068: LD_VAR 0 2
49072: PUSH
49073: LD_INT 4
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: LIST
49080: PUSH
49081: LD_VAR 0 1
49085: PUSH
49086: LD_VAR 0 2
49090: PUSH
49091: LD_INT 4
49093: PLUS
49094: PUSH
49095: LD_INT 0
49097: PUSH
49098: EMPTY
49099: LIST
49100: LIST
49101: LIST
49102: PUSH
49103: LD_VAR 0 1
49107: PUSH
49108: LD_INT 3
49110: MINUS
49111: PUSH
49112: LD_VAR 0 2
49116: PUSH
49117: LD_INT 1
49119: PUSH
49120: EMPTY
49121: LIST
49122: LIST
49123: LIST
49124: PUSH
49125: LD_VAR 0 1
49129: PUSH
49130: LD_INT 4
49132: MINUS
49133: PUSH
49134: LD_VAR 0 2
49138: PUSH
49139: LD_INT 4
49141: MINUS
49142: PUSH
49143: LD_INT 2
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: LIST
49150: PUSH
49151: EMPTY
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: ST_TO_ADDR
// end ; 3 :
49158: GO 49580
49160: LD_INT 3
49162: DOUBLE
49163: EQUAL
49164: IFTRUE 49168
49166: GO 49301
49168: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49169: LD_ADDR_VAR 0 5
49173: PUSH
49174: LD_VAR 0 1
49178: PUSH
49179: LD_INT 3
49181: PLUS
49182: PUSH
49183: LD_VAR 0 2
49187: PUSH
49188: LD_INT 4
49190: PUSH
49191: EMPTY
49192: LIST
49193: LIST
49194: LIST
49195: PUSH
49196: LD_VAR 0 1
49200: PUSH
49201: LD_INT 4
49203: PLUS
49204: PUSH
49205: LD_VAR 0 2
49209: PUSH
49210: LD_INT 4
49212: PLUS
49213: PUSH
49214: LD_INT 5
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: LIST
49221: PUSH
49222: LD_VAR 0 1
49226: PUSH
49227: LD_INT 4
49229: MINUS
49230: PUSH
49231: LD_VAR 0 2
49235: PUSH
49236: LD_INT 1
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: LIST
49243: PUSH
49244: LD_VAR 0 1
49248: PUSH
49249: LD_VAR 0 2
49253: PUSH
49254: LD_INT 4
49256: MINUS
49257: PUSH
49258: LD_INT 3
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: LIST
49265: PUSH
49266: LD_VAR 0 1
49270: PUSH
49271: LD_INT 3
49273: MINUS
49274: PUSH
49275: LD_VAR 0 2
49279: PUSH
49280: LD_INT 3
49282: MINUS
49283: PUSH
49284: LD_INT 2
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: LIST
49291: PUSH
49292: EMPTY
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: ST_TO_ADDR
// end ; 4 :
49299: GO 49580
49301: LD_INT 4
49303: DOUBLE
49304: EQUAL
49305: IFTRUE 49309
49307: GO 49442
49309: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49310: LD_ADDR_VAR 0 5
49314: PUSH
49315: LD_VAR 0 1
49319: PUSH
49320: LD_VAR 0 2
49324: PUSH
49325: LD_INT 4
49327: PLUS
49328: PUSH
49329: LD_INT 0
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: LIST
49336: PUSH
49337: LD_VAR 0 1
49341: PUSH
49342: LD_INT 3
49344: PLUS
49345: PUSH
49346: LD_VAR 0 2
49350: PUSH
49351: LD_INT 3
49353: PLUS
49354: PUSH
49355: LD_INT 5
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: LIST
49362: PUSH
49363: LD_VAR 0 1
49367: PUSH
49368: LD_INT 4
49370: PLUS
49371: PUSH
49372: LD_VAR 0 2
49376: PUSH
49377: LD_INT 4
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: LIST
49384: PUSH
49385: LD_VAR 0 1
49389: PUSH
49390: LD_VAR 0 2
49394: PUSH
49395: LD_INT 3
49397: MINUS
49398: PUSH
49399: LD_INT 3
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: PUSH
49407: LD_VAR 0 1
49411: PUSH
49412: LD_INT 4
49414: MINUS
49415: PUSH
49416: LD_VAR 0 2
49420: PUSH
49421: LD_INT 4
49423: MINUS
49424: PUSH
49425: LD_INT 2
49427: PUSH
49428: EMPTY
49429: LIST
49430: LIST
49431: LIST
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: LIST
49437: LIST
49438: LIST
49439: ST_TO_ADDR
// end ; 5 :
49440: GO 49580
49442: LD_INT 5
49444: DOUBLE
49445: EQUAL
49446: IFTRUE 49450
49448: GO 49579
49450: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49451: LD_ADDR_VAR 0 5
49455: PUSH
49456: LD_VAR 0 1
49460: PUSH
49461: LD_INT 4
49463: MINUS
49464: PUSH
49465: LD_VAR 0 2
49469: PUSH
49470: LD_INT 1
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: LIST
49477: PUSH
49478: LD_VAR 0 1
49482: PUSH
49483: LD_VAR 0 2
49487: PUSH
49488: LD_INT 4
49490: MINUS
49491: PUSH
49492: LD_INT 3
49494: PUSH
49495: EMPTY
49496: LIST
49497: LIST
49498: LIST
49499: PUSH
49500: LD_VAR 0 1
49504: PUSH
49505: LD_INT 4
49507: PLUS
49508: PUSH
49509: LD_VAR 0 2
49513: PUSH
49514: LD_INT 4
49516: PLUS
49517: PUSH
49518: LD_INT 5
49520: PUSH
49521: EMPTY
49522: LIST
49523: LIST
49524: LIST
49525: PUSH
49526: LD_VAR 0 1
49530: PUSH
49531: LD_INT 3
49533: PLUS
49534: PUSH
49535: LD_VAR 0 2
49539: PUSH
49540: LD_INT 4
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: LIST
49547: PUSH
49548: LD_VAR 0 1
49552: PUSH
49553: LD_VAR 0 2
49557: PUSH
49558: LD_INT 3
49560: PLUS
49561: PUSH
49562: LD_INT 0
49564: PUSH
49565: EMPTY
49566: LIST
49567: LIST
49568: LIST
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: LIST
49574: LIST
49575: LIST
49576: ST_TO_ADDR
// end ; end ;
49577: GO 49580
49579: POP
// result := list ;
49580: LD_ADDR_VAR 0 4
49584: PUSH
49585: LD_VAR 0 5
49589: ST_TO_ADDR
// end ;
49590: LD_VAR 0 4
49594: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49595: LD_INT 0
49597: PPUSH
49598: PPUSH
49599: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49600: LD_VAR 0 1
49604: NOT
49605: PUSH
49606: LD_VAR 0 2
49610: PUSH
49611: LD_INT 1
49613: PUSH
49614: LD_INT 2
49616: PUSH
49617: LD_INT 3
49619: PUSH
49620: LD_INT 4
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: IN
49629: NOT
49630: OR
49631: IFFALSE 49635
// exit ;
49633: GO 49718
// tmp := [ ] ;
49635: LD_ADDR_VAR 0 5
49639: PUSH
49640: EMPTY
49641: ST_TO_ADDR
// for i in units do
49642: LD_ADDR_VAR 0 4
49646: PUSH
49647: LD_VAR 0 1
49651: PUSH
49652: FOR_IN
49653: IFFALSE 49687
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
49655: LD_ADDR_VAR 0 5
49659: PUSH
49660: LD_VAR 0 5
49664: PPUSH
49665: LD_VAR 0 4
49669: PPUSH
49670: LD_VAR 0 2
49674: PPUSH
49675: CALL_OW 259
49679: PPUSH
49680: CALL 51079 0 2
49684: ST_TO_ADDR
49685: GO 49652
49687: POP
49688: POP
// if not tmp then
49689: LD_VAR 0 5
49693: NOT
49694: IFFALSE 49698
// exit ;
49696: GO 49718
// result := SortListByListDesc ( units , tmp ) ;
49698: LD_ADDR_VAR 0 3
49702: PUSH
49703: LD_VAR 0 1
49707: PPUSH
49708: LD_VAR 0 5
49712: PPUSH
49713: CALL_OW 77
49717: ST_TO_ADDR
// end ;
49718: LD_VAR 0 3
49722: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49723: LD_INT 0
49725: PPUSH
49726: PPUSH
49727: PPUSH
// result := false ;
49728: LD_ADDR_VAR 0 3
49732: PUSH
49733: LD_INT 0
49735: ST_TO_ADDR
// if not building then
49736: LD_VAR 0 2
49740: NOT
49741: IFFALSE 49745
// exit ;
49743: GO 49883
// x := GetX ( building ) ;
49745: LD_ADDR_VAR 0 4
49749: PUSH
49750: LD_VAR 0 2
49754: PPUSH
49755: CALL_OW 250
49759: ST_TO_ADDR
// y := GetY ( building ) ;
49760: LD_ADDR_VAR 0 5
49764: PUSH
49765: LD_VAR 0 2
49769: PPUSH
49770: CALL_OW 251
49774: ST_TO_ADDR
// if not x or not y then
49775: LD_VAR 0 4
49779: NOT
49780: PUSH
49781: LD_VAR 0 5
49785: NOT
49786: OR
49787: IFFALSE 49791
// exit ;
49789: GO 49883
// if GetTaskList ( unit ) then
49791: LD_VAR 0 1
49795: PPUSH
49796: CALL_OW 437
49800: IFFALSE 49883
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49802: LD_STRING e
49804: PUSH
49805: LD_VAR 0 1
49809: PPUSH
49810: CALL_OW 437
49814: PUSH
49815: LD_INT 1
49817: ARRAY
49818: PUSH
49819: LD_INT 1
49821: ARRAY
49822: EQUAL
49823: PUSH
49824: LD_VAR 0 4
49828: PUSH
49829: LD_VAR 0 1
49833: PPUSH
49834: CALL_OW 437
49838: PUSH
49839: LD_INT 1
49841: ARRAY
49842: PUSH
49843: LD_INT 2
49845: ARRAY
49846: EQUAL
49847: AND
49848: PUSH
49849: LD_VAR 0 5
49853: PUSH
49854: LD_VAR 0 1
49858: PPUSH
49859: CALL_OW 437
49863: PUSH
49864: LD_INT 1
49866: ARRAY
49867: PUSH
49868: LD_INT 3
49870: ARRAY
49871: EQUAL
49872: AND
49873: IFFALSE 49883
// result := true end ;
49875: LD_ADDR_VAR 0 3
49879: PUSH
49880: LD_INT 1
49882: ST_TO_ADDR
// end ;
49883: LD_VAR 0 3
49887: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49888: LD_INT 0
49890: PPUSH
// result := false ;
49891: LD_ADDR_VAR 0 4
49895: PUSH
49896: LD_INT 0
49898: ST_TO_ADDR
// if GetTaskList ( unit ) then
49899: LD_VAR 0 1
49903: PPUSH
49904: CALL_OW 437
49908: IFFALSE 49991
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49910: LD_STRING M
49912: PUSH
49913: LD_VAR 0 1
49917: PPUSH
49918: CALL_OW 437
49922: PUSH
49923: LD_INT 1
49925: ARRAY
49926: PUSH
49927: LD_INT 1
49929: ARRAY
49930: EQUAL
49931: PUSH
49932: LD_VAR 0 2
49936: PUSH
49937: LD_VAR 0 1
49941: PPUSH
49942: CALL_OW 437
49946: PUSH
49947: LD_INT 1
49949: ARRAY
49950: PUSH
49951: LD_INT 2
49953: ARRAY
49954: EQUAL
49955: AND
49956: PUSH
49957: LD_VAR 0 3
49961: PUSH
49962: LD_VAR 0 1
49966: PPUSH
49967: CALL_OW 437
49971: PUSH
49972: LD_INT 1
49974: ARRAY
49975: PUSH
49976: LD_INT 3
49978: ARRAY
49979: EQUAL
49980: AND
49981: IFFALSE 49991
// result := true ;
49983: LD_ADDR_VAR 0 4
49987: PUSH
49988: LD_INT 1
49990: ST_TO_ADDR
// end ; end ;
49991: LD_VAR 0 4
49995: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49996: LD_INT 0
49998: PPUSH
49999: PPUSH
50000: PPUSH
50001: PPUSH
// if not unit or not area then
50002: LD_VAR 0 1
50006: NOT
50007: PUSH
50008: LD_VAR 0 2
50012: NOT
50013: OR
50014: IFFALSE 50018
// exit ;
50016: GO 50182
// tmp := AreaToList ( area , i ) ;
50018: LD_ADDR_VAR 0 6
50022: PUSH
50023: LD_VAR 0 2
50027: PPUSH
50028: LD_VAR 0 5
50032: PPUSH
50033: CALL_OW 517
50037: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50038: LD_ADDR_VAR 0 5
50042: PUSH
50043: DOUBLE
50044: LD_INT 1
50046: DEC
50047: ST_TO_ADDR
50048: LD_VAR 0 6
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: PUSH
50057: FOR_TO
50058: IFFALSE 50180
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50060: LD_ADDR_VAR 0 7
50064: PUSH
50065: LD_VAR 0 6
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PUSH
50074: LD_VAR 0 5
50078: ARRAY
50079: PUSH
50080: LD_VAR 0 6
50084: PUSH
50085: LD_INT 2
50087: ARRAY
50088: PUSH
50089: LD_VAR 0 5
50093: ARRAY
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50099: LD_VAR 0 7
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PPUSH
50108: LD_VAR 0 7
50112: PUSH
50113: LD_INT 2
50115: ARRAY
50116: PPUSH
50117: CALL_OW 428
50121: PUSH
50122: LD_INT 0
50124: EQUAL
50125: IFFALSE 50178
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50127: LD_VAR 0 1
50131: PPUSH
50132: LD_VAR 0 7
50136: PUSH
50137: LD_INT 1
50139: ARRAY
50140: PPUSH
50141: LD_VAR 0 7
50145: PUSH
50146: LD_INT 2
50148: ARRAY
50149: PPUSH
50150: LD_VAR 0 3
50154: PPUSH
50155: CALL_OW 48
// result := IsPlaced ( unit ) ;
50159: LD_ADDR_VAR 0 4
50163: PUSH
50164: LD_VAR 0 1
50168: PPUSH
50169: CALL_OW 305
50173: ST_TO_ADDR
// exit ;
50174: POP
50175: POP
50176: GO 50182
// end ; end ;
50178: GO 50057
50180: POP
50181: POP
// end ;
50182: LD_VAR 0 4
50186: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50187: LD_INT 0
50189: PPUSH
50190: PPUSH
50191: PPUSH
// if not side or side > 8 then
50192: LD_VAR 0 1
50196: NOT
50197: PUSH
50198: LD_VAR 0 1
50202: PUSH
50203: LD_INT 8
50205: GREATER
50206: OR
50207: IFFALSE 50211
// exit ;
50209: GO 50398
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50211: LD_ADDR_VAR 0 4
50215: PUSH
50216: LD_INT 22
50218: PUSH
50219: LD_VAR 0 1
50223: PUSH
50224: EMPTY
50225: LIST
50226: LIST
50227: PUSH
50228: LD_INT 21
50230: PUSH
50231: LD_INT 3
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: EMPTY
50239: LIST
50240: LIST
50241: PPUSH
50242: CALL_OW 69
50246: ST_TO_ADDR
// if not tmp then
50247: LD_VAR 0 4
50251: NOT
50252: IFFALSE 50256
// exit ;
50254: GO 50398
// enable_addtolog := true ;
50256: LD_ADDR_OWVAR 81
50260: PUSH
50261: LD_INT 1
50263: ST_TO_ADDR
// AddToLog ( [ ) ;
50264: LD_STRING [
50266: PPUSH
50267: CALL_OW 561
// for i in tmp do
50271: LD_ADDR_VAR 0 3
50275: PUSH
50276: LD_VAR 0 4
50280: PUSH
50281: FOR_IN
50282: IFFALSE 50389
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50284: LD_STRING [
50286: PUSH
50287: LD_VAR 0 3
50291: PPUSH
50292: CALL_OW 266
50296: STR
50297: PUSH
50298: LD_STRING , 
50300: STR
50301: PUSH
50302: LD_VAR 0 3
50306: PPUSH
50307: CALL_OW 250
50311: STR
50312: PUSH
50313: LD_STRING , 
50315: STR
50316: PUSH
50317: LD_VAR 0 3
50321: PPUSH
50322: CALL_OW 251
50326: STR
50327: PUSH
50328: LD_STRING , 
50330: STR
50331: PUSH
50332: LD_VAR 0 3
50336: PPUSH
50337: CALL_OW 254
50341: STR
50342: PUSH
50343: LD_STRING , 
50345: STR
50346: PUSH
50347: LD_VAR 0 3
50351: PPUSH
50352: LD_INT 1
50354: PPUSH
50355: CALL_OW 268
50359: STR
50360: PUSH
50361: LD_STRING , 
50363: STR
50364: PUSH
50365: LD_VAR 0 3
50369: PPUSH
50370: LD_INT 2
50372: PPUSH
50373: CALL_OW 268
50377: STR
50378: PUSH
50379: LD_STRING ],
50381: STR
50382: PPUSH
50383: CALL_OW 561
// end ;
50387: GO 50281
50389: POP
50390: POP
// AddToLog ( ]; ) ;
50391: LD_STRING ];
50393: PPUSH
50394: CALL_OW 561
// end ;
50398: LD_VAR 0 2
50402: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50403: LD_INT 0
50405: PPUSH
50406: PPUSH
50407: PPUSH
50408: PPUSH
50409: PPUSH
// if not area or not rate or not max then
50410: LD_VAR 0 1
50414: NOT
50415: PUSH
50416: LD_VAR 0 2
50420: NOT
50421: OR
50422: PUSH
50423: LD_VAR 0 4
50427: NOT
50428: OR
50429: IFFALSE 50433
// exit ;
50431: GO 50622
// while 1 do
50433: LD_INT 1
50435: IFFALSE 50622
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50437: LD_ADDR_VAR 0 9
50441: PUSH
50442: LD_VAR 0 1
50446: PPUSH
50447: LD_INT 1
50449: PPUSH
50450: CALL_OW 287
50454: PUSH
50455: LD_INT 10
50457: MUL
50458: ST_TO_ADDR
// r := rate / 10 ;
50459: LD_ADDR_VAR 0 7
50463: PUSH
50464: LD_VAR 0 2
50468: PUSH
50469: LD_INT 10
50471: DIVREAL
50472: ST_TO_ADDR
// time := 1 1$00 ;
50473: LD_ADDR_VAR 0 8
50477: PUSH
50478: LD_INT 2100
50480: ST_TO_ADDR
// if amount < min then
50481: LD_VAR 0 9
50485: PUSH
50486: LD_VAR 0 3
50490: LESS
50491: IFFALSE 50509
// r := r * 2 else
50493: LD_ADDR_VAR 0 7
50497: PUSH
50498: LD_VAR 0 7
50502: PUSH
50503: LD_INT 2
50505: MUL
50506: ST_TO_ADDR
50507: GO 50535
// if amount > max then
50509: LD_VAR 0 9
50513: PUSH
50514: LD_VAR 0 4
50518: GREATER
50519: IFFALSE 50535
// r := r / 2 ;
50521: LD_ADDR_VAR 0 7
50525: PUSH
50526: LD_VAR 0 7
50530: PUSH
50531: LD_INT 2
50533: DIVREAL
50534: ST_TO_ADDR
// time := time / r ;
50535: LD_ADDR_VAR 0 8
50539: PUSH
50540: LD_VAR 0 8
50544: PUSH
50545: LD_VAR 0 7
50549: DIVREAL
50550: ST_TO_ADDR
// if time < 0 then
50551: LD_VAR 0 8
50555: PUSH
50556: LD_INT 0
50558: LESS
50559: IFFALSE 50576
// time := time * - 1 ;
50561: LD_ADDR_VAR 0 8
50565: PUSH
50566: LD_VAR 0 8
50570: PUSH
50571: LD_INT 1
50573: NEG
50574: MUL
50575: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
50576: LD_VAR 0 8
50580: PUSH
50581: LD_INT 35
50583: PPUSH
50584: LD_INT 875
50586: PPUSH
50587: CALL_OW 12
50591: PLUS
50592: PPUSH
50593: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50597: LD_INT 1
50599: PPUSH
50600: LD_INT 5
50602: PPUSH
50603: CALL_OW 12
50607: PPUSH
50608: LD_VAR 0 1
50612: PPUSH
50613: LD_INT 1
50615: PPUSH
50616: CALL_OW 55
// end ;
50620: GO 50433
// end ;
50622: LD_VAR 0 5
50626: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50627: LD_INT 0
50629: PPUSH
50630: PPUSH
50631: PPUSH
50632: PPUSH
50633: PPUSH
50634: PPUSH
50635: PPUSH
50636: PPUSH
// if not turrets or not factories then
50637: LD_VAR 0 1
50641: NOT
50642: PUSH
50643: LD_VAR 0 2
50647: NOT
50648: OR
50649: IFFALSE 50653
// exit ;
50651: GO 50960
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50653: LD_ADDR_VAR 0 10
50657: PUSH
50658: LD_INT 5
50660: PUSH
50661: LD_INT 6
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 2
50670: PUSH
50671: LD_INT 4
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PUSH
50678: LD_INT 3
50680: PUSH
50681: LD_INT 5
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: PUSH
50688: EMPTY
50689: LIST
50690: LIST
50691: LIST
50692: PUSH
50693: LD_INT 24
50695: PUSH
50696: LD_INT 25
50698: PUSH
50699: EMPTY
50700: LIST
50701: LIST
50702: PUSH
50703: LD_INT 23
50705: PUSH
50706: LD_INT 27
50708: PUSH
50709: EMPTY
50710: LIST
50711: LIST
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PUSH
50717: LD_INT 42
50719: PUSH
50720: LD_INT 43
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PUSH
50727: LD_INT 44
50729: PUSH
50730: LD_INT 46
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 45
50739: PUSH
50740: LD_INT 47
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: LIST
50751: PUSH
50752: EMPTY
50753: LIST
50754: LIST
50755: LIST
50756: ST_TO_ADDR
// result := [ ] ;
50757: LD_ADDR_VAR 0 3
50761: PUSH
50762: EMPTY
50763: ST_TO_ADDR
// for i in turrets do
50764: LD_ADDR_VAR 0 4
50768: PUSH
50769: LD_VAR 0 1
50773: PUSH
50774: FOR_IN
50775: IFFALSE 50958
// begin nat := GetNation ( i ) ;
50777: LD_ADDR_VAR 0 7
50781: PUSH
50782: LD_VAR 0 4
50786: PPUSH
50787: CALL_OW 248
50791: ST_TO_ADDR
// weapon := 0 ;
50792: LD_ADDR_VAR 0 8
50796: PUSH
50797: LD_INT 0
50799: ST_TO_ADDR
// if not nat then
50800: LD_VAR 0 7
50804: NOT
50805: IFFALSE 50809
// continue ;
50807: GO 50774
// for j in list [ nat ] do
50809: LD_ADDR_VAR 0 5
50813: PUSH
50814: LD_VAR 0 10
50818: PUSH
50819: LD_VAR 0 7
50823: ARRAY
50824: PUSH
50825: FOR_IN
50826: IFFALSE 50867
// if GetBWeapon ( i ) = j [ 1 ] then
50828: LD_VAR 0 4
50832: PPUSH
50833: CALL_OW 269
50837: PUSH
50838: LD_VAR 0 5
50842: PUSH
50843: LD_INT 1
50845: ARRAY
50846: EQUAL
50847: IFFALSE 50865
// begin weapon := j [ 2 ] ;
50849: LD_ADDR_VAR 0 8
50853: PUSH
50854: LD_VAR 0 5
50858: PUSH
50859: LD_INT 2
50861: ARRAY
50862: ST_TO_ADDR
// break ;
50863: GO 50867
// end ;
50865: GO 50825
50867: POP
50868: POP
// if not weapon then
50869: LD_VAR 0 8
50873: NOT
50874: IFFALSE 50878
// continue ;
50876: GO 50774
// for k in factories do
50878: LD_ADDR_VAR 0 6
50882: PUSH
50883: LD_VAR 0 2
50887: PUSH
50888: FOR_IN
50889: IFFALSE 50954
// begin weapons := AvailableWeaponList ( k ) ;
50891: LD_ADDR_VAR 0 9
50895: PUSH
50896: LD_VAR 0 6
50900: PPUSH
50901: CALL_OW 478
50905: ST_TO_ADDR
// if not weapons then
50906: LD_VAR 0 9
50910: NOT
50911: IFFALSE 50915
// continue ;
50913: GO 50888
// if weapon in weapons then
50915: LD_VAR 0 8
50919: PUSH
50920: LD_VAR 0 9
50924: IN
50925: IFFALSE 50952
// begin result := [ i , weapon ] ;
50927: LD_ADDR_VAR 0 3
50931: PUSH
50932: LD_VAR 0 4
50936: PUSH
50937: LD_VAR 0 8
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: ST_TO_ADDR
// exit ;
50946: POP
50947: POP
50948: POP
50949: POP
50950: GO 50960
// end ; end ;
50952: GO 50888
50954: POP
50955: POP
// end ;
50956: GO 50774
50958: POP
50959: POP
// end ;
50960: LD_VAR 0 3
50964: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50965: LD_INT 0
50967: PPUSH
// if not side or side > 8 then
50968: LD_VAR 0 3
50972: NOT
50973: PUSH
50974: LD_VAR 0 3
50978: PUSH
50979: LD_INT 8
50981: GREATER
50982: OR
50983: IFFALSE 50987
// exit ;
50985: GO 51046
// if not range then
50987: LD_VAR 0 4
50991: NOT
50992: IFFALSE 51003
// range := - 12 ;
50994: LD_ADDR_VAR 0 4
50998: PUSH
50999: LD_INT 12
51001: NEG
51002: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51003: LD_VAR 0 1
51007: PPUSH
51008: LD_VAR 0 2
51012: PPUSH
51013: LD_VAR 0 3
51017: PPUSH
51018: LD_VAR 0 4
51022: PPUSH
51023: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51027: LD_VAR 0 1
51031: PPUSH
51032: LD_VAR 0 2
51036: PPUSH
51037: LD_VAR 0 3
51041: PPUSH
51042: CALL_OW 331
// end ;
51046: LD_VAR 0 5
51050: RET
// export function Video ( mode ) ; begin
51051: LD_INT 0
51053: PPUSH
// ingame_video = mode ;
51054: LD_ADDR_OWVAR 52
51058: PUSH
51059: LD_VAR 0 1
51063: ST_TO_ADDR
// interface_hidden = mode ;
51064: LD_ADDR_OWVAR 54
51068: PUSH
51069: LD_VAR 0 1
51073: ST_TO_ADDR
// end ;
51074: LD_VAR 0 2
51078: RET
// export function Join ( array , element ) ; begin
51079: LD_INT 0
51081: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51082: LD_ADDR_VAR 0 3
51086: PUSH
51087: LD_VAR 0 1
51091: PPUSH
51092: LD_VAR 0 1
51096: PUSH
51097: LD_INT 1
51099: PLUS
51100: PPUSH
51101: LD_VAR 0 2
51105: PPUSH
51106: CALL_OW 1
51110: ST_TO_ADDR
// end ;
51111: LD_VAR 0 3
51115: RET
// export function JoinUnion ( array , element ) ; begin
51116: LD_INT 0
51118: PPUSH
// result := array union element ;
51119: LD_ADDR_VAR 0 3
51123: PUSH
51124: LD_VAR 0 1
51128: PUSH
51129: LD_VAR 0 2
51133: UNION
51134: ST_TO_ADDR
// end ;
51135: LD_VAR 0 3
51139: RET
// export function GetBehemoths ( side ) ; begin
51140: LD_INT 0
51142: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
51143: LD_ADDR_VAR 0 2
51147: PUSH
51148: LD_INT 22
51150: PUSH
51151: LD_VAR 0 1
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: PUSH
51160: LD_INT 31
51162: PUSH
51163: LD_INT 25
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PPUSH
51174: CALL_OW 69
51178: ST_TO_ADDR
// end ;
51179: LD_VAR 0 2
51183: RET
// export function Shuffle ( array ) ; var i , index ; begin
51184: LD_INT 0
51186: PPUSH
51187: PPUSH
51188: PPUSH
// result := [ ] ;
51189: LD_ADDR_VAR 0 2
51193: PUSH
51194: EMPTY
51195: ST_TO_ADDR
// if not array then
51196: LD_VAR 0 1
51200: NOT
51201: IFFALSE 51205
// exit ;
51203: GO 51304
// Randomize ;
51205: CALL_OW 10
// for i = array downto 1 do
51209: LD_ADDR_VAR 0 3
51213: PUSH
51214: DOUBLE
51215: LD_VAR 0 1
51219: INC
51220: ST_TO_ADDR
51221: LD_INT 1
51223: PUSH
51224: FOR_DOWNTO
51225: IFFALSE 51302
// begin index := rand ( 1 , array ) ;
51227: LD_ADDR_VAR 0 4
51231: PUSH
51232: LD_INT 1
51234: PPUSH
51235: LD_VAR 0 1
51239: PPUSH
51240: CALL_OW 12
51244: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51245: LD_ADDR_VAR 0 2
51249: PUSH
51250: LD_VAR 0 2
51254: PPUSH
51255: LD_VAR 0 2
51259: PUSH
51260: LD_INT 1
51262: PLUS
51263: PPUSH
51264: LD_VAR 0 1
51268: PUSH
51269: LD_VAR 0 4
51273: ARRAY
51274: PPUSH
51275: CALL_OW 2
51279: ST_TO_ADDR
// array := Delete ( array , index ) ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_VAR 0 1
51289: PPUSH
51290: LD_VAR 0 4
51294: PPUSH
51295: CALL_OW 3
51299: ST_TO_ADDR
// end ;
51300: GO 51224
51302: POP
51303: POP
// end ;
51304: LD_VAR 0 2
51308: RET
// export function GetBaseMaterials ( base ) ; begin
51309: LD_INT 0
51311: PPUSH
// result := [ 0 , 0 , 0 ] ;
51312: LD_ADDR_VAR 0 2
51316: PUSH
51317: LD_INT 0
51319: PUSH
51320: LD_INT 0
51322: PUSH
51323: LD_INT 0
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: LIST
51330: ST_TO_ADDR
// if not base then
51331: LD_VAR 0 1
51335: NOT
51336: IFFALSE 51340
// exit ;
51338: GO 51389
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51340: LD_ADDR_VAR 0 2
51344: PUSH
51345: LD_VAR 0 1
51349: PPUSH
51350: LD_INT 1
51352: PPUSH
51353: CALL_OW 275
51357: PUSH
51358: LD_VAR 0 1
51362: PPUSH
51363: LD_INT 2
51365: PPUSH
51366: CALL_OW 275
51370: PUSH
51371: LD_VAR 0 1
51375: PPUSH
51376: LD_INT 3
51378: PPUSH
51379: CALL_OW 275
51383: PUSH
51384: EMPTY
51385: LIST
51386: LIST
51387: LIST
51388: ST_TO_ADDR
// end ;
51389: LD_VAR 0 2
51393: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51394: LD_INT 0
51396: PPUSH
51397: PPUSH
// result := array ;
51398: LD_ADDR_VAR 0 3
51402: PUSH
51403: LD_VAR 0 1
51407: ST_TO_ADDR
// if size >= result then
51408: LD_VAR 0 2
51412: PUSH
51413: LD_VAR 0 3
51417: GREATEREQUAL
51418: IFFALSE 51422
// exit ;
51420: GO 51472
// if size then
51422: LD_VAR 0 2
51426: IFFALSE 51472
// for i := array downto size do
51428: LD_ADDR_VAR 0 4
51432: PUSH
51433: DOUBLE
51434: LD_VAR 0 1
51438: INC
51439: ST_TO_ADDR
51440: LD_VAR 0 2
51444: PUSH
51445: FOR_DOWNTO
51446: IFFALSE 51470
// result := Delete ( result , result ) ;
51448: LD_ADDR_VAR 0 3
51452: PUSH
51453: LD_VAR 0 3
51457: PPUSH
51458: LD_VAR 0 3
51462: PPUSH
51463: CALL_OW 3
51467: ST_TO_ADDR
51468: GO 51445
51470: POP
51471: POP
// end ;
51472: LD_VAR 0 3
51476: RET
// export function ComExit ( unit ) ; var tmp ; begin
51477: LD_INT 0
51479: PPUSH
51480: PPUSH
// if not IsInUnit ( unit ) then
51481: LD_VAR 0 1
51485: PPUSH
51486: CALL_OW 310
51490: NOT
51491: IFFALSE 51495
// exit ;
51493: GO 51555
// tmp := IsInUnit ( unit ) ;
51495: LD_ADDR_VAR 0 3
51499: PUSH
51500: LD_VAR 0 1
51504: PPUSH
51505: CALL_OW 310
51509: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51510: LD_VAR 0 3
51514: PPUSH
51515: CALL_OW 247
51519: PUSH
51520: LD_INT 2
51522: EQUAL
51523: IFFALSE 51536
// ComExitVehicle ( unit ) else
51525: LD_VAR 0 1
51529: PPUSH
51530: CALL_OW 121
51534: GO 51545
// ComExitBuilding ( unit ) ;
51536: LD_VAR 0 1
51540: PPUSH
51541: CALL_OW 122
// result := tmp ;
51545: LD_ADDR_VAR 0 2
51549: PUSH
51550: LD_VAR 0 3
51554: ST_TO_ADDR
// end ;
51555: LD_VAR 0 2
51559: RET
// export function ComExitAll ( units ) ; var i ; begin
51560: LD_INT 0
51562: PPUSH
51563: PPUSH
// if not units then
51564: LD_VAR 0 1
51568: NOT
51569: IFFALSE 51573
// exit ;
51571: GO 51599
// for i in units do
51573: LD_ADDR_VAR 0 3
51577: PUSH
51578: LD_VAR 0 1
51582: PUSH
51583: FOR_IN
51584: IFFALSE 51597
// ComExit ( i ) ;
51586: LD_VAR 0 3
51590: PPUSH
51591: CALL 51477 0 1
51595: GO 51583
51597: POP
51598: POP
// end ;
51599: LD_VAR 0 2
51603: RET
// export function ResetHc ; begin
51604: LD_INT 0
51606: PPUSH
// InitHc ;
51607: CALL_OW 19
// hc_importance := 0 ;
51611: LD_ADDR_OWVAR 32
51615: PUSH
51616: LD_INT 0
51618: ST_TO_ADDR
// end ;
51619: LD_VAR 0 1
51623: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51624: LD_INT 0
51626: PPUSH
51627: PPUSH
51628: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51629: LD_ADDR_VAR 0 6
51633: PUSH
51634: LD_VAR 0 1
51638: PUSH
51639: LD_VAR 0 3
51643: PLUS
51644: PUSH
51645: LD_INT 2
51647: DIV
51648: ST_TO_ADDR
// if _x < 0 then
51649: LD_VAR 0 6
51653: PUSH
51654: LD_INT 0
51656: LESS
51657: IFFALSE 51674
// _x := _x * - 1 ;
51659: LD_ADDR_VAR 0 6
51663: PUSH
51664: LD_VAR 0 6
51668: PUSH
51669: LD_INT 1
51671: NEG
51672: MUL
51673: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51674: LD_ADDR_VAR 0 7
51678: PUSH
51679: LD_VAR 0 2
51683: PUSH
51684: LD_VAR 0 4
51688: PLUS
51689: PUSH
51690: LD_INT 2
51692: DIV
51693: ST_TO_ADDR
// if _y < 0 then
51694: LD_VAR 0 7
51698: PUSH
51699: LD_INT 0
51701: LESS
51702: IFFALSE 51719
// _y := _y * - 1 ;
51704: LD_ADDR_VAR 0 7
51708: PUSH
51709: LD_VAR 0 7
51713: PUSH
51714: LD_INT 1
51716: NEG
51717: MUL
51718: ST_TO_ADDR
// result := [ _x , _y ] ;
51719: LD_ADDR_VAR 0 5
51723: PUSH
51724: LD_VAR 0 6
51728: PUSH
51729: LD_VAR 0 7
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: ST_TO_ADDR
// end ;
51738: LD_VAR 0 5
51742: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51743: LD_INT 0
51745: PPUSH
51746: PPUSH
51747: PPUSH
51748: PPUSH
// task := GetTaskList ( unit ) ;
51749: LD_ADDR_VAR 0 7
51753: PUSH
51754: LD_VAR 0 1
51758: PPUSH
51759: CALL_OW 437
51763: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51764: LD_VAR 0 7
51768: NOT
51769: PUSH
51770: LD_VAR 0 1
51774: PPUSH
51775: LD_VAR 0 2
51779: PPUSH
51780: CALL_OW 308
51784: NOT
51785: AND
51786: IFFALSE 51790
// exit ;
51788: GO 51908
// if IsInArea ( unit , area ) then
51790: LD_VAR 0 1
51794: PPUSH
51795: LD_VAR 0 2
51799: PPUSH
51800: CALL_OW 308
51804: IFFALSE 51822
// begin ComMoveToArea ( unit , goAway ) ;
51806: LD_VAR 0 1
51810: PPUSH
51811: LD_VAR 0 3
51815: PPUSH
51816: CALL_OW 113
// exit ;
51820: GO 51908
// end ; if task [ 1 ] [ 1 ] <> M then
51822: LD_VAR 0 7
51826: PUSH
51827: LD_INT 1
51829: ARRAY
51830: PUSH
51831: LD_INT 1
51833: ARRAY
51834: PUSH
51835: LD_STRING M
51837: NONEQUAL
51838: IFFALSE 51842
// exit ;
51840: GO 51908
// x := task [ 1 ] [ 2 ] ;
51842: LD_ADDR_VAR 0 5
51846: PUSH
51847: LD_VAR 0 7
51851: PUSH
51852: LD_INT 1
51854: ARRAY
51855: PUSH
51856: LD_INT 2
51858: ARRAY
51859: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51860: LD_ADDR_VAR 0 6
51864: PUSH
51865: LD_VAR 0 7
51869: PUSH
51870: LD_INT 1
51872: ARRAY
51873: PUSH
51874: LD_INT 3
51876: ARRAY
51877: ST_TO_ADDR
// if InArea ( x , y , area ) then
51878: LD_VAR 0 5
51882: PPUSH
51883: LD_VAR 0 6
51887: PPUSH
51888: LD_VAR 0 2
51892: PPUSH
51893: CALL_OW 309
51897: IFFALSE 51908
// ComStop ( unit ) ;
51899: LD_VAR 0 1
51903: PPUSH
51904: CALL_OW 141
// end ;
51908: LD_VAR 0 4
51912: RET
// export function Abs ( value ) ; begin
51913: LD_INT 0
51915: PPUSH
// result := value ;
51916: LD_ADDR_VAR 0 2
51920: PUSH
51921: LD_VAR 0 1
51925: ST_TO_ADDR
// if value < 0 then
51926: LD_VAR 0 1
51930: PUSH
51931: LD_INT 0
51933: LESS
51934: IFFALSE 51951
// result := value * - 1 ;
51936: LD_ADDR_VAR 0 2
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_INT 1
51948: NEG
51949: MUL
51950: ST_TO_ADDR
// end ;
51951: LD_VAR 0 2
51955: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51956: LD_INT 0
51958: PPUSH
51959: PPUSH
51960: PPUSH
51961: PPUSH
51962: PPUSH
51963: PPUSH
51964: PPUSH
51965: PPUSH
// if not unit or not building then
51966: LD_VAR 0 1
51970: NOT
51971: PUSH
51972: LD_VAR 0 2
51976: NOT
51977: OR
51978: IFFALSE 51982
// exit ;
51980: GO 52208
// x := GetX ( building ) ;
51982: LD_ADDR_VAR 0 4
51986: PUSH
51987: LD_VAR 0 2
51991: PPUSH
51992: CALL_OW 250
51996: ST_TO_ADDR
// y := GetY ( building ) ;
51997: LD_ADDR_VAR 0 6
52001: PUSH
52002: LD_VAR 0 2
52006: PPUSH
52007: CALL_OW 251
52011: ST_TO_ADDR
// d := GetDir ( building ) ;
52012: LD_ADDR_VAR 0 8
52016: PUSH
52017: LD_VAR 0 2
52021: PPUSH
52022: CALL_OW 254
52026: ST_TO_ADDR
// r := 4 ;
52027: LD_ADDR_VAR 0 9
52031: PUSH
52032: LD_INT 4
52034: ST_TO_ADDR
// for i := 1 to 5 do
52035: LD_ADDR_VAR 0 10
52039: PUSH
52040: DOUBLE
52041: LD_INT 1
52043: DEC
52044: ST_TO_ADDR
52045: LD_INT 5
52047: PUSH
52048: FOR_TO
52049: IFFALSE 52206
// begin _x := ShiftX ( x , d , r + i ) ;
52051: LD_ADDR_VAR 0 5
52055: PUSH
52056: LD_VAR 0 4
52060: PPUSH
52061: LD_VAR 0 8
52065: PPUSH
52066: LD_VAR 0 9
52070: PUSH
52071: LD_VAR 0 10
52075: PLUS
52076: PPUSH
52077: CALL_OW 272
52081: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52082: LD_ADDR_VAR 0 7
52086: PUSH
52087: LD_VAR 0 6
52091: PPUSH
52092: LD_VAR 0 8
52096: PPUSH
52097: LD_VAR 0 9
52101: PUSH
52102: LD_VAR 0 10
52106: PLUS
52107: PPUSH
52108: CALL_OW 273
52112: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52113: LD_VAR 0 5
52117: PPUSH
52118: LD_VAR 0 7
52122: PPUSH
52123: CALL_OW 488
52127: PUSH
52128: LD_VAR 0 5
52132: PPUSH
52133: LD_VAR 0 7
52137: PPUSH
52138: CALL_OW 428
52142: PPUSH
52143: CALL_OW 247
52147: PUSH
52148: LD_INT 3
52150: PUSH
52151: LD_INT 2
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: IN
52158: NOT
52159: AND
52160: IFFALSE 52204
// begin ComMoveXY ( unit , _x , _y ) ;
52162: LD_VAR 0 1
52166: PPUSH
52167: LD_VAR 0 5
52171: PPUSH
52172: LD_VAR 0 7
52176: PPUSH
52177: CALL_OW 111
// result := [ _x , _y ] ;
52181: LD_ADDR_VAR 0 3
52185: PUSH
52186: LD_VAR 0 5
52190: PUSH
52191: LD_VAR 0 7
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: ST_TO_ADDR
// exit ;
52200: POP
52201: POP
52202: GO 52208
// end ; end ;
52204: GO 52048
52206: POP
52207: POP
// end ;
52208: LD_VAR 0 3
52212: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52213: LD_INT 0
52215: PPUSH
52216: PPUSH
52217: PPUSH
// result := 0 ;
52218: LD_ADDR_VAR 0 3
52222: PUSH
52223: LD_INT 0
52225: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52226: LD_VAR 0 1
52230: PUSH
52231: LD_INT 0
52233: LESS
52234: PUSH
52235: LD_VAR 0 1
52239: PUSH
52240: LD_INT 8
52242: GREATER
52243: OR
52244: PUSH
52245: LD_VAR 0 2
52249: PUSH
52250: LD_INT 0
52252: LESS
52253: OR
52254: PUSH
52255: LD_VAR 0 2
52259: PUSH
52260: LD_INT 8
52262: GREATER
52263: OR
52264: IFFALSE 52268
// exit ;
52266: GO 52343
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52268: LD_ADDR_VAR 0 4
52272: PUSH
52273: LD_INT 22
52275: PUSH
52276: LD_VAR 0 2
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PPUSH
52285: CALL_OW 69
52289: PUSH
52290: FOR_IN
52291: IFFALSE 52341
// begin un := UnitShoot ( i ) ;
52293: LD_ADDR_VAR 0 5
52297: PUSH
52298: LD_VAR 0 4
52302: PPUSH
52303: CALL_OW 504
52307: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52308: LD_VAR 0 5
52312: PPUSH
52313: CALL_OW 255
52317: PUSH
52318: LD_VAR 0 1
52322: EQUAL
52323: IFFALSE 52339
// begin result := un ;
52325: LD_ADDR_VAR 0 3
52329: PUSH
52330: LD_VAR 0 5
52334: ST_TO_ADDR
// exit ;
52335: POP
52336: POP
52337: GO 52343
// end ; end ;
52339: GO 52290
52341: POP
52342: POP
// end ;
52343: LD_VAR 0 3
52347: RET
// export function GetCargoBay ( units ) ; begin
52348: LD_INT 0
52350: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52351: LD_ADDR_VAR 0 2
52355: PUSH
52356: LD_VAR 0 1
52360: PPUSH
52361: LD_INT 2
52363: PUSH
52364: LD_INT 34
52366: PUSH
52367: LD_INT 12
52369: PUSH
52370: EMPTY
52371: LIST
52372: LIST
52373: PUSH
52374: LD_INT 34
52376: PUSH
52377: LD_INT 51
52379: PUSH
52380: EMPTY
52381: LIST
52382: LIST
52383: PUSH
52384: LD_INT 34
52386: PUSH
52387: LD_INT 32
52389: PUSH
52390: EMPTY
52391: LIST
52392: LIST
52393: PUSH
52394: LD_INT 34
52396: PUSH
52397: LD_INT 89
52399: PUSH
52400: EMPTY
52401: LIST
52402: LIST
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: LIST
52408: LIST
52409: LIST
52410: PPUSH
52411: CALL_OW 72
52415: ST_TO_ADDR
// end ;
52416: LD_VAR 0 2
52420: RET
// export function Negate ( value ) ; begin
52421: LD_INT 0
52423: PPUSH
// result := not value ;
52424: LD_ADDR_VAR 0 2
52428: PUSH
52429: LD_VAR 0 1
52433: NOT
52434: ST_TO_ADDR
// end ;
52435: LD_VAR 0 2
52439: RET
// export function Inc ( value ) ; begin
52440: LD_INT 0
52442: PPUSH
// result := value + 1 ;
52443: LD_ADDR_VAR 0 2
52447: PUSH
52448: LD_VAR 0 1
52452: PUSH
52453: LD_INT 1
52455: PLUS
52456: ST_TO_ADDR
// end ;
52457: LD_VAR 0 2
52461: RET
// export function Dec ( value ) ; begin
52462: LD_INT 0
52464: PPUSH
// result := value - 1 ;
52465: LD_ADDR_VAR 0 2
52469: PUSH
52470: LD_VAR 0 1
52474: PUSH
52475: LD_INT 1
52477: MINUS
52478: ST_TO_ADDR
// end ;
52479: LD_VAR 0 2
52483: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52484: LD_INT 0
52486: PPUSH
52487: PPUSH
52488: PPUSH
52489: PPUSH
52490: PPUSH
52491: PPUSH
52492: PPUSH
52493: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52494: LD_VAR 0 1
52498: PPUSH
52499: LD_VAR 0 2
52503: PPUSH
52504: CALL_OW 488
52508: NOT
52509: PUSH
52510: LD_VAR 0 3
52514: PPUSH
52515: LD_VAR 0 4
52519: PPUSH
52520: CALL_OW 488
52524: NOT
52525: OR
52526: IFFALSE 52539
// begin result := - 1 ;
52528: LD_ADDR_VAR 0 5
52532: PUSH
52533: LD_INT 1
52535: NEG
52536: ST_TO_ADDR
// exit ;
52537: GO 52774
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
52539: LD_ADDR_VAR 0 12
52543: PUSH
52544: LD_VAR 0 1
52548: PPUSH
52549: LD_VAR 0 2
52553: PPUSH
52554: LD_VAR 0 3
52558: PPUSH
52559: LD_VAR 0 4
52563: PPUSH
52564: CALL 51624 0 4
52568: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
52569: LD_ADDR_VAR 0 11
52573: PUSH
52574: LD_VAR 0 1
52578: PPUSH
52579: LD_VAR 0 2
52583: PPUSH
52584: LD_VAR 0 12
52588: PUSH
52589: LD_INT 1
52591: ARRAY
52592: PPUSH
52593: LD_VAR 0 12
52597: PUSH
52598: LD_INT 2
52600: ARRAY
52601: PPUSH
52602: CALL_OW 298
52606: ST_TO_ADDR
// distance := 9999 ;
52607: LD_ADDR_VAR 0 10
52611: PUSH
52612: LD_INT 9999
52614: ST_TO_ADDR
// for i := 0 to 5 do
52615: LD_ADDR_VAR 0 6
52619: PUSH
52620: DOUBLE
52621: LD_INT 0
52623: DEC
52624: ST_TO_ADDR
52625: LD_INT 5
52627: PUSH
52628: FOR_TO
52629: IFFALSE 52772
// begin _x := ShiftX ( x1 , i , centerDist ) ;
52631: LD_ADDR_VAR 0 7
52635: PUSH
52636: LD_VAR 0 1
52640: PPUSH
52641: LD_VAR 0 6
52645: PPUSH
52646: LD_VAR 0 11
52650: PPUSH
52651: CALL_OW 272
52655: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
52656: LD_ADDR_VAR 0 8
52660: PUSH
52661: LD_VAR 0 2
52665: PPUSH
52666: LD_VAR 0 6
52670: PPUSH
52671: LD_VAR 0 11
52675: PPUSH
52676: CALL_OW 273
52680: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52681: LD_VAR 0 7
52685: PPUSH
52686: LD_VAR 0 8
52690: PPUSH
52691: CALL_OW 488
52695: NOT
52696: IFFALSE 52700
// continue ;
52698: GO 52628
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
52700: LD_ADDR_VAR 0 9
52704: PUSH
52705: LD_VAR 0 12
52709: PUSH
52710: LD_INT 1
52712: ARRAY
52713: PPUSH
52714: LD_VAR 0 12
52718: PUSH
52719: LD_INT 2
52721: ARRAY
52722: PPUSH
52723: LD_VAR 0 7
52727: PPUSH
52728: LD_VAR 0 8
52732: PPUSH
52733: CALL_OW 298
52737: ST_TO_ADDR
// if tmp < distance then
52738: LD_VAR 0 9
52742: PUSH
52743: LD_VAR 0 10
52747: LESS
52748: IFFALSE 52770
// begin result := i ;
52750: LD_ADDR_VAR 0 5
52754: PUSH
52755: LD_VAR 0 6
52759: ST_TO_ADDR
// distance := tmp ;
52760: LD_ADDR_VAR 0 10
52764: PUSH
52765: LD_VAR 0 9
52769: ST_TO_ADDR
// end ; end ;
52770: GO 52628
52772: POP
52773: POP
// end ;
52774: LD_VAR 0 5
52778: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52779: LD_INT 0
52781: PPUSH
52782: PPUSH
// if not driver or not IsInUnit ( driver ) then
52783: LD_VAR 0 1
52787: NOT
52788: PUSH
52789: LD_VAR 0 1
52793: PPUSH
52794: CALL_OW 310
52798: NOT
52799: OR
52800: IFFALSE 52804
// exit ;
52802: GO 52894
// vehicle := IsInUnit ( driver ) ;
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_VAR 0 1
52813: PPUSH
52814: CALL_OW 310
52818: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52819: LD_VAR 0 1
52823: PPUSH
52824: LD_STRING \
52826: PUSH
52827: LD_INT 0
52829: PUSH
52830: LD_INT 0
52832: PUSH
52833: LD_INT 0
52835: PUSH
52836: LD_INT 0
52838: PUSH
52839: LD_INT 0
52841: PUSH
52842: LD_INT 0
52844: PUSH
52845: EMPTY
52846: LIST
52847: LIST
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: LIST
52853: PUSH
52854: LD_STRING E
52856: PUSH
52857: LD_INT 0
52859: PUSH
52860: LD_INT 0
52862: PUSH
52863: LD_VAR 0 3
52867: PUSH
52868: LD_INT 0
52870: PUSH
52871: LD_INT 0
52873: PUSH
52874: LD_INT 0
52876: PUSH
52877: EMPTY
52878: LIST
52879: LIST
52880: LIST
52881: LIST
52882: LIST
52883: LIST
52884: LIST
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PPUSH
52890: CALL_OW 446
// end ;
52894: LD_VAR 0 2
52898: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52899: LD_INT 0
52901: PPUSH
52902: PPUSH
// if not driver or not IsInUnit ( driver ) then
52903: LD_VAR 0 1
52907: NOT
52908: PUSH
52909: LD_VAR 0 1
52913: PPUSH
52914: CALL_OW 310
52918: NOT
52919: OR
52920: IFFALSE 52924
// exit ;
52922: GO 53014
// vehicle := IsInUnit ( driver ) ;
52924: LD_ADDR_VAR 0 3
52928: PUSH
52929: LD_VAR 0 1
52933: PPUSH
52934: CALL_OW 310
52938: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52939: LD_VAR 0 1
52943: PPUSH
52944: LD_STRING \
52946: PUSH
52947: LD_INT 0
52949: PUSH
52950: LD_INT 0
52952: PUSH
52953: LD_INT 0
52955: PUSH
52956: LD_INT 0
52958: PUSH
52959: LD_INT 0
52961: PUSH
52962: LD_INT 0
52964: PUSH
52965: EMPTY
52966: LIST
52967: LIST
52968: LIST
52969: LIST
52970: LIST
52971: LIST
52972: LIST
52973: PUSH
52974: LD_STRING E
52976: PUSH
52977: LD_INT 0
52979: PUSH
52980: LD_INT 0
52982: PUSH
52983: LD_VAR 0 3
52987: PUSH
52988: LD_INT 0
52990: PUSH
52991: LD_INT 0
52993: PUSH
52994: LD_INT 0
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: LIST
53001: LIST
53002: LIST
53003: LIST
53004: LIST
53005: PUSH
53006: EMPTY
53007: LIST
53008: LIST
53009: PPUSH
53010: CALL_OW 447
// end ;
53014: LD_VAR 0 2
53018: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53019: LD_INT 0
53021: PPUSH
53022: PPUSH
53023: PPUSH
// tmp := [ ] ;
53024: LD_ADDR_VAR 0 5
53028: PUSH
53029: EMPTY
53030: ST_TO_ADDR
// for i in units do
53031: LD_ADDR_VAR 0 4
53035: PUSH
53036: LD_VAR 0 1
53040: PUSH
53041: FOR_IN
53042: IFFALSE 53080
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53044: LD_ADDR_VAR 0 5
53048: PUSH
53049: LD_VAR 0 5
53053: PPUSH
53054: LD_VAR 0 5
53058: PUSH
53059: LD_INT 1
53061: PLUS
53062: PPUSH
53063: LD_VAR 0 4
53067: PPUSH
53068: CALL_OW 256
53072: PPUSH
53073: CALL_OW 2
53077: ST_TO_ADDR
53078: GO 53041
53080: POP
53081: POP
// if not tmp then
53082: LD_VAR 0 5
53086: NOT
53087: IFFALSE 53091
// exit ;
53089: GO 53139
// if asc then
53091: LD_VAR 0 2
53095: IFFALSE 53119
// result := SortListByListAsc ( units , tmp ) else
53097: LD_ADDR_VAR 0 3
53101: PUSH
53102: LD_VAR 0 1
53106: PPUSH
53107: LD_VAR 0 5
53111: PPUSH
53112: CALL_OW 76
53116: ST_TO_ADDR
53117: GO 53139
// result := SortListByListDesc ( units , tmp ) ;
53119: LD_ADDR_VAR 0 3
53123: PUSH
53124: LD_VAR 0 1
53128: PPUSH
53129: LD_VAR 0 5
53133: PPUSH
53134: CALL_OW 77
53138: ST_TO_ADDR
// end ;
53139: LD_VAR 0 3
53143: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53144: LD_INT 0
53146: PPUSH
53147: PPUSH
// task := GetTaskList ( mech ) ;
53148: LD_ADDR_VAR 0 4
53152: PUSH
53153: LD_VAR 0 1
53157: PPUSH
53158: CALL_OW 437
53162: ST_TO_ADDR
// if not task then
53163: LD_VAR 0 4
53167: NOT
53168: IFFALSE 53172
// exit ;
53170: GO 53214
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53172: LD_ADDR_VAR 0 3
53176: PUSH
53177: LD_VAR 0 4
53181: PUSH
53182: LD_INT 1
53184: ARRAY
53185: PUSH
53186: LD_INT 1
53188: ARRAY
53189: PUSH
53190: LD_STRING r
53192: EQUAL
53193: PUSH
53194: LD_VAR 0 4
53198: PUSH
53199: LD_INT 1
53201: ARRAY
53202: PUSH
53203: LD_INT 4
53205: ARRAY
53206: PUSH
53207: LD_VAR 0 2
53211: EQUAL
53212: AND
53213: ST_TO_ADDR
// end ;
53214: LD_VAR 0 3
53218: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53219: LD_INT 0
53221: PPUSH
// SetDir ( unit , d ) ;
53222: LD_VAR 0 1
53226: PPUSH
53227: LD_VAR 0 4
53231: PPUSH
53232: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53236: LD_VAR 0 1
53240: PPUSH
53241: LD_VAR 0 2
53245: PPUSH
53246: LD_VAR 0 3
53250: PPUSH
53251: LD_VAR 0 5
53255: PPUSH
53256: CALL_OW 48
// end ;
53260: LD_VAR 0 6
53264: RET
// export function ToNaturalNumber ( number ) ; begin
53265: LD_INT 0
53267: PPUSH
// result := number div 1 ;
53268: LD_ADDR_VAR 0 2
53272: PUSH
53273: LD_VAR 0 1
53277: PUSH
53278: LD_INT 1
53280: DIV
53281: ST_TO_ADDR
// if number < 0 then
53282: LD_VAR 0 1
53286: PUSH
53287: LD_INT 0
53289: LESS
53290: IFFALSE 53300
// result := 0 ;
53292: LD_ADDR_VAR 0 2
53296: PUSH
53297: LD_INT 0
53299: ST_TO_ADDR
// end ;
53300: LD_VAR 0 2
53304: RET
// export function SortByClass ( units , class ) ; var un ; begin
53305: LD_INT 0
53307: PPUSH
53308: PPUSH
// if not units or not class then
53309: LD_VAR 0 1
53313: NOT
53314: PUSH
53315: LD_VAR 0 2
53319: NOT
53320: OR
53321: IFFALSE 53325
// exit ;
53323: GO 53420
// result := [ ] ;
53325: LD_ADDR_VAR 0 3
53329: PUSH
53330: EMPTY
53331: ST_TO_ADDR
// for un in units do
53332: LD_ADDR_VAR 0 4
53336: PUSH
53337: LD_VAR 0 1
53341: PUSH
53342: FOR_IN
53343: IFFALSE 53418
// if GetClass ( un ) = class then
53345: LD_VAR 0 4
53349: PPUSH
53350: CALL_OW 257
53354: PUSH
53355: LD_VAR 0 2
53359: EQUAL
53360: IFFALSE 53387
// result := Insert ( result , 1 , un ) else
53362: LD_ADDR_VAR 0 3
53366: PUSH
53367: LD_VAR 0 3
53371: PPUSH
53372: LD_INT 1
53374: PPUSH
53375: LD_VAR 0 4
53379: PPUSH
53380: CALL_OW 2
53384: ST_TO_ADDR
53385: GO 53416
// result := Replace ( result , result + 1 , un ) ;
53387: LD_ADDR_VAR 0 3
53391: PUSH
53392: LD_VAR 0 3
53396: PPUSH
53397: LD_VAR 0 3
53401: PUSH
53402: LD_INT 1
53404: PLUS
53405: PPUSH
53406: LD_VAR 0 4
53410: PPUSH
53411: CALL_OW 1
53415: ST_TO_ADDR
53416: GO 53342
53418: POP
53419: POP
// end ;
53420: LD_VAR 0 3
53424: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53425: LD_INT 0
53427: PPUSH
53428: PPUSH
53429: PPUSH
53430: PPUSH
53431: PPUSH
53432: PPUSH
53433: PPUSH
// result := [ ] ;
53434: LD_ADDR_VAR 0 4
53438: PUSH
53439: EMPTY
53440: ST_TO_ADDR
// if x - r < 0 then
53441: LD_VAR 0 1
53445: PUSH
53446: LD_VAR 0 3
53450: MINUS
53451: PUSH
53452: LD_INT 0
53454: LESS
53455: IFFALSE 53467
// min_x := 0 else
53457: LD_ADDR_VAR 0 8
53461: PUSH
53462: LD_INT 0
53464: ST_TO_ADDR
53465: GO 53483
// min_x := x - r ;
53467: LD_ADDR_VAR 0 8
53471: PUSH
53472: LD_VAR 0 1
53476: PUSH
53477: LD_VAR 0 3
53481: MINUS
53482: ST_TO_ADDR
// if y - r < 0 then
53483: LD_VAR 0 2
53487: PUSH
53488: LD_VAR 0 3
53492: MINUS
53493: PUSH
53494: LD_INT 0
53496: LESS
53497: IFFALSE 53509
// min_y := 0 else
53499: LD_ADDR_VAR 0 7
53503: PUSH
53504: LD_INT 0
53506: ST_TO_ADDR
53507: GO 53525
// min_y := y - r ;
53509: LD_ADDR_VAR 0 7
53513: PUSH
53514: LD_VAR 0 2
53518: PUSH
53519: LD_VAR 0 3
53523: MINUS
53524: ST_TO_ADDR
// max_x := x + r ;
53525: LD_ADDR_VAR 0 9
53529: PUSH
53530: LD_VAR 0 1
53534: PUSH
53535: LD_VAR 0 3
53539: PLUS
53540: ST_TO_ADDR
// max_y := y + r ;
53541: LD_ADDR_VAR 0 10
53545: PUSH
53546: LD_VAR 0 2
53550: PUSH
53551: LD_VAR 0 3
53555: PLUS
53556: ST_TO_ADDR
// for _x = min_x to max_x do
53557: LD_ADDR_VAR 0 5
53561: PUSH
53562: DOUBLE
53563: LD_VAR 0 8
53567: DEC
53568: ST_TO_ADDR
53569: LD_VAR 0 9
53573: PUSH
53574: FOR_TO
53575: IFFALSE 53676
// for _y = min_y to max_y do
53577: LD_ADDR_VAR 0 6
53581: PUSH
53582: DOUBLE
53583: LD_VAR 0 7
53587: DEC
53588: ST_TO_ADDR
53589: LD_VAR 0 10
53593: PUSH
53594: FOR_TO
53595: IFFALSE 53672
// begin if not ValidHex ( _x , _y ) then
53597: LD_VAR 0 5
53601: PPUSH
53602: LD_VAR 0 6
53606: PPUSH
53607: CALL_OW 488
53611: NOT
53612: IFFALSE 53616
// continue ;
53614: GO 53594
// if GetResourceTypeXY ( _x , _y ) then
53616: LD_VAR 0 5
53620: PPUSH
53621: LD_VAR 0 6
53625: PPUSH
53626: CALL_OW 283
53630: IFFALSE 53670
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53632: LD_ADDR_VAR 0 4
53636: PUSH
53637: LD_VAR 0 4
53641: PPUSH
53642: LD_VAR 0 4
53646: PUSH
53647: LD_INT 1
53649: PLUS
53650: PPUSH
53651: LD_VAR 0 5
53655: PUSH
53656: LD_VAR 0 6
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PPUSH
53665: CALL_OW 1
53669: ST_TO_ADDR
// end ;
53670: GO 53594
53672: POP
53673: POP
53674: GO 53574
53676: POP
53677: POP
// end ;
53678: LD_VAR 0 4
53682: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
53683: LD_INT 0
53685: PPUSH
53686: PPUSH
53687: PPUSH
53688: PPUSH
53689: PPUSH
53690: PPUSH
53691: PPUSH
53692: PPUSH
// if not units then
53693: LD_VAR 0 1
53697: NOT
53698: IFFALSE 53702
// exit ;
53700: GO 54226
// result := UnitFilter ( units , [ f_ok ] ) ;
53702: LD_ADDR_VAR 0 3
53706: PUSH
53707: LD_VAR 0 1
53711: PPUSH
53712: LD_INT 50
53714: PUSH
53715: EMPTY
53716: LIST
53717: PPUSH
53718: CALL_OW 72
53722: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53723: LD_ADDR_VAR 0 8
53727: PUSH
53728: LD_VAR 0 1
53732: PUSH
53733: LD_INT 1
53735: ARRAY
53736: PPUSH
53737: CALL_OW 255
53741: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
53742: LD_ADDR_VAR 0 10
53746: PUSH
53747: LD_INT 29
53749: PUSH
53750: LD_INT 91
53752: PUSH
53753: LD_INT 49
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: LIST
53760: ST_TO_ADDR
// if not result then
53761: LD_VAR 0 3
53765: NOT
53766: IFFALSE 53770
// exit ;
53768: GO 54226
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53770: LD_ADDR_VAR 0 5
53774: PUSH
53775: LD_INT 81
53777: PUSH
53778: LD_VAR 0 8
53782: PUSH
53783: EMPTY
53784: LIST
53785: LIST
53786: PPUSH
53787: CALL_OW 69
53791: ST_TO_ADDR
// for i in result do
53792: LD_ADDR_VAR 0 4
53796: PUSH
53797: LD_VAR 0 3
53801: PUSH
53802: FOR_IN
53803: IFFALSE 54224
// begin tag := GetTag ( i ) + 1 ;
53805: LD_ADDR_VAR 0 9
53809: PUSH
53810: LD_VAR 0 4
53814: PPUSH
53815: CALL_OW 110
53819: PUSH
53820: LD_INT 1
53822: PLUS
53823: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: CALL_OW 250
53838: PPUSH
53839: LD_VAR 0 4
53843: PPUSH
53844: CALL_OW 251
53848: PPUSH
53849: LD_INT 6
53851: PPUSH
53852: CALL 53425 0 3
53856: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53857: LD_VAR 0 4
53861: PPUSH
53862: CALL_OW 247
53866: PUSH
53867: LD_INT 2
53869: EQUAL
53870: PUSH
53871: LD_VAR 0 7
53875: AND
53876: PUSH
53877: LD_VAR 0 4
53881: PPUSH
53882: CALL_OW 264
53886: PUSH
53887: LD_VAR 0 10
53891: IN
53892: NOT
53893: AND
53894: IFFALSE 53933
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53896: LD_VAR 0 4
53900: PPUSH
53901: LD_VAR 0 7
53905: PUSH
53906: LD_INT 1
53908: ARRAY
53909: PUSH
53910: LD_INT 1
53912: ARRAY
53913: PPUSH
53914: LD_VAR 0 7
53918: PUSH
53919: LD_INT 1
53921: ARRAY
53922: PUSH
53923: LD_INT 2
53925: ARRAY
53926: PPUSH
53927: CALL_OW 116
53931: GO 54222
// if path > tag then
53933: LD_VAR 0 2
53937: PUSH
53938: LD_VAR 0 9
53942: GREATER
53943: IFFALSE 54151
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
53945: LD_ADDR_VAR 0 6
53949: PUSH
53950: LD_VAR 0 5
53954: PPUSH
53955: LD_INT 91
53957: PUSH
53958: LD_VAR 0 4
53962: PUSH
53963: LD_INT 8
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: LIST
53970: PPUSH
53971: CALL_OW 72
53975: ST_TO_ADDR
// if nearEnemy then
53976: LD_VAR 0 6
53980: IFFALSE 54049
// begin if GetWeapon ( i ) = ru_time_lapser then
53982: LD_VAR 0 4
53986: PPUSH
53987: CALL_OW 264
53991: PUSH
53992: LD_INT 49
53994: EQUAL
53995: IFFALSE 54023
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53997: LD_VAR 0 4
54001: PPUSH
54002: LD_VAR 0 6
54006: PPUSH
54007: LD_VAR 0 4
54011: PPUSH
54012: CALL_OW 74
54016: PPUSH
54017: CALL_OW 112
54021: GO 54047
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
54023: LD_VAR 0 4
54027: PPUSH
54028: LD_VAR 0 6
54032: PPUSH
54033: LD_VAR 0 4
54037: PPUSH
54038: CALL_OW 74
54042: PPUSH
54043: CALL_OW 115
// end else
54047: GO 54149
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54049: LD_VAR 0 4
54053: PPUSH
54054: LD_VAR 0 2
54058: PUSH
54059: LD_VAR 0 9
54063: ARRAY
54064: PUSH
54065: LD_INT 1
54067: ARRAY
54068: PPUSH
54069: LD_VAR 0 2
54073: PUSH
54074: LD_VAR 0 9
54078: ARRAY
54079: PUSH
54080: LD_INT 2
54082: ARRAY
54083: PPUSH
54084: CALL_OW 297
54088: PUSH
54089: LD_INT 6
54091: GREATER
54092: IFFALSE 54135
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54094: LD_VAR 0 4
54098: PPUSH
54099: LD_VAR 0 2
54103: PUSH
54104: LD_VAR 0 9
54108: ARRAY
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PPUSH
54114: LD_VAR 0 2
54118: PUSH
54119: LD_VAR 0 9
54123: ARRAY
54124: PUSH
54125: LD_INT 2
54127: ARRAY
54128: PPUSH
54129: CALL_OW 114
54133: GO 54149
// SetTag ( i , tag ) ;
54135: LD_VAR 0 4
54139: PPUSH
54140: LD_VAR 0 9
54144: PPUSH
54145: CALL_OW 109
// end else
54149: GO 54222
// if enemy then
54151: LD_VAR 0 5
54155: IFFALSE 54222
// begin if GetWeapon ( i ) = ru_time_lapser then
54157: LD_VAR 0 4
54161: PPUSH
54162: CALL_OW 264
54166: PUSH
54167: LD_INT 49
54169: EQUAL
54170: IFFALSE 54198
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54172: LD_VAR 0 4
54176: PPUSH
54177: LD_VAR 0 5
54181: PPUSH
54182: LD_VAR 0 4
54186: PPUSH
54187: CALL_OW 74
54191: PPUSH
54192: CALL_OW 112
54196: GO 54222
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54198: LD_VAR 0 4
54202: PPUSH
54203: LD_VAR 0 5
54207: PPUSH
54208: LD_VAR 0 4
54212: PPUSH
54213: CALL_OW 74
54217: PPUSH
54218: CALL_OW 115
// end ; end ;
54222: GO 53802
54224: POP
54225: POP
// end ;
54226: LD_VAR 0 3
54230: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54231: LD_INT 0
54233: PPUSH
54234: PPUSH
54235: PPUSH
// if not unit or IsInUnit ( unit ) then
54236: LD_VAR 0 1
54240: NOT
54241: PUSH
54242: LD_VAR 0 1
54246: PPUSH
54247: CALL_OW 310
54251: OR
54252: IFFALSE 54256
// exit ;
54254: GO 54347
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54256: LD_ADDR_VAR 0 4
54260: PUSH
54261: LD_VAR 0 1
54265: PPUSH
54266: CALL_OW 250
54270: PPUSH
54271: LD_VAR 0 2
54275: PPUSH
54276: LD_INT 1
54278: PPUSH
54279: CALL_OW 272
54283: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54284: LD_ADDR_VAR 0 5
54288: PUSH
54289: LD_VAR 0 1
54293: PPUSH
54294: CALL_OW 251
54298: PPUSH
54299: LD_VAR 0 2
54303: PPUSH
54304: LD_INT 1
54306: PPUSH
54307: CALL_OW 273
54311: ST_TO_ADDR
// if ValidHex ( x , y ) then
54312: LD_VAR 0 4
54316: PPUSH
54317: LD_VAR 0 5
54321: PPUSH
54322: CALL_OW 488
54326: IFFALSE 54347
// ComTurnXY ( unit , x , y ) ;
54328: LD_VAR 0 1
54332: PPUSH
54333: LD_VAR 0 4
54337: PPUSH
54338: LD_VAR 0 5
54342: PPUSH
54343: CALL_OW 118
// end ;
54347: LD_VAR 0 3
54351: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54352: LD_INT 0
54354: PPUSH
54355: PPUSH
// result := false ;
54356: LD_ADDR_VAR 0 3
54360: PUSH
54361: LD_INT 0
54363: ST_TO_ADDR
// if not units then
54364: LD_VAR 0 2
54368: NOT
54369: IFFALSE 54373
// exit ;
54371: GO 54418
// for i in units do
54373: LD_ADDR_VAR 0 4
54377: PUSH
54378: LD_VAR 0 2
54382: PUSH
54383: FOR_IN
54384: IFFALSE 54416
// if See ( side , i ) then
54386: LD_VAR 0 1
54390: PPUSH
54391: LD_VAR 0 4
54395: PPUSH
54396: CALL_OW 292
54400: IFFALSE 54414
// begin result := true ;
54402: LD_ADDR_VAR 0 3
54406: PUSH
54407: LD_INT 1
54409: ST_TO_ADDR
// exit ;
54410: POP
54411: POP
54412: GO 54418
// end ;
54414: GO 54383
54416: POP
54417: POP
// end ;
54418: LD_VAR 0 3
54422: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54423: LD_INT 0
54425: PPUSH
54426: PPUSH
54427: PPUSH
54428: PPUSH
// if not unit or not points then
54429: LD_VAR 0 1
54433: NOT
54434: PUSH
54435: LD_VAR 0 2
54439: NOT
54440: OR
54441: IFFALSE 54445
// exit ;
54443: GO 54535
// dist := 99999 ;
54445: LD_ADDR_VAR 0 5
54449: PUSH
54450: LD_INT 99999
54452: ST_TO_ADDR
// for i in points do
54453: LD_ADDR_VAR 0 4
54457: PUSH
54458: LD_VAR 0 2
54462: PUSH
54463: FOR_IN
54464: IFFALSE 54533
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54466: LD_ADDR_VAR 0 6
54470: PUSH
54471: LD_VAR 0 1
54475: PPUSH
54476: LD_VAR 0 4
54480: PUSH
54481: LD_INT 1
54483: ARRAY
54484: PPUSH
54485: LD_VAR 0 4
54489: PUSH
54490: LD_INT 2
54492: ARRAY
54493: PPUSH
54494: CALL_OW 297
54498: ST_TO_ADDR
// if tmpDist < dist then
54499: LD_VAR 0 6
54503: PUSH
54504: LD_VAR 0 5
54508: LESS
54509: IFFALSE 54531
// begin result := i ;
54511: LD_ADDR_VAR 0 3
54515: PUSH
54516: LD_VAR 0 4
54520: ST_TO_ADDR
// dist := tmpDist ;
54521: LD_ADDR_VAR 0 5
54525: PUSH
54526: LD_VAR 0 6
54530: ST_TO_ADDR
// end ; end ;
54531: GO 54463
54533: POP
54534: POP
// end ;
54535: LD_VAR 0 3
54539: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
54540: LD_INT 0
54542: PPUSH
// uc_side := side ;
54543: LD_ADDR_OWVAR 20
54547: PUSH
54548: LD_VAR 0 1
54552: ST_TO_ADDR
// uc_nation := 3 ;
54553: LD_ADDR_OWVAR 21
54557: PUSH
54558: LD_INT 3
54560: ST_TO_ADDR
// vc_chassis := 25 ;
54561: LD_ADDR_OWVAR 37
54565: PUSH
54566: LD_INT 25
54568: ST_TO_ADDR
// vc_engine := engine_siberite ;
54569: LD_ADDR_OWVAR 39
54573: PUSH
54574: LD_INT 3
54576: ST_TO_ADDR
// vc_control := control_computer ;
54577: LD_ADDR_OWVAR 38
54581: PUSH
54582: LD_INT 3
54584: ST_TO_ADDR
// vc_weapon := 59 ;
54585: LD_ADDR_OWVAR 40
54589: PUSH
54590: LD_INT 59
54592: ST_TO_ADDR
// result := CreateVehicle ;
54593: LD_ADDR_VAR 0 5
54597: PUSH
54598: CALL_OW 45
54602: ST_TO_ADDR
// SetDir ( result , d ) ;
54603: LD_VAR 0 5
54607: PPUSH
54608: LD_VAR 0 4
54612: PPUSH
54613: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
54617: LD_VAR 0 5
54621: PPUSH
54622: LD_VAR 0 2
54626: PPUSH
54627: LD_VAR 0 3
54631: PPUSH
54632: LD_INT 0
54634: PPUSH
54635: CALL_OW 48
// end ;
54639: LD_VAR 0 5
54643: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
54644: LD_INT 0
54646: PPUSH
54647: PPUSH
54648: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
54649: LD_ADDR_VAR 0 2
54653: PUSH
54654: LD_INT 0
54656: PUSH
54657: LD_INT 0
54659: PUSH
54660: LD_INT 0
54662: PUSH
54663: LD_INT 0
54665: PUSH
54666: EMPTY
54667: LIST
54668: LIST
54669: LIST
54670: LIST
54671: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
54672: LD_VAR 0 1
54676: NOT
54677: PUSH
54678: LD_VAR 0 1
54682: PPUSH
54683: CALL_OW 264
54687: PUSH
54688: LD_INT 12
54690: PUSH
54691: LD_INT 51
54693: PUSH
54694: LD_INT 32
54696: PUSH
54697: LD_INT 89
54699: PUSH
54700: EMPTY
54701: LIST
54702: LIST
54703: LIST
54704: LIST
54705: IN
54706: NOT
54707: OR
54708: IFFALSE 54712
// exit ;
54710: GO 54810
// for i := 1 to 3 do
54712: LD_ADDR_VAR 0 3
54716: PUSH
54717: DOUBLE
54718: LD_INT 1
54720: DEC
54721: ST_TO_ADDR
54722: LD_INT 3
54724: PUSH
54725: FOR_TO
54726: IFFALSE 54808
// begin tmp := GetCargo ( cargo , i ) ;
54728: LD_ADDR_VAR 0 4
54732: PUSH
54733: LD_VAR 0 1
54737: PPUSH
54738: LD_VAR 0 3
54742: PPUSH
54743: CALL_OW 289
54747: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
54748: LD_ADDR_VAR 0 2
54752: PUSH
54753: LD_VAR 0 2
54757: PPUSH
54758: LD_VAR 0 3
54762: PPUSH
54763: LD_VAR 0 4
54767: PPUSH
54768: CALL_OW 1
54772: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
54773: LD_ADDR_VAR 0 2
54777: PUSH
54778: LD_VAR 0 2
54782: PPUSH
54783: LD_INT 4
54785: PPUSH
54786: LD_VAR 0 2
54790: PUSH
54791: LD_INT 4
54793: ARRAY
54794: PUSH
54795: LD_VAR 0 4
54799: PLUS
54800: PPUSH
54801: CALL_OW 1
54805: ST_TO_ADDR
// end ;
54806: GO 54725
54808: POP
54809: POP
// end ;
54810: LD_VAR 0 2
54814: RET
// export function Length ( array ) ; begin
54815: LD_INT 0
54817: PPUSH
// result := array + 0 ;
54818: LD_ADDR_VAR 0 2
54822: PUSH
54823: LD_VAR 0 1
54827: PUSH
54828: LD_INT 0
54830: PLUS
54831: ST_TO_ADDR
// end ;
54832: LD_VAR 0 2
54836: RET
// export function PrepareArray ( array ) ; begin
54837: LD_INT 0
54839: PPUSH
// result := array diff 0 ;
54840: LD_ADDR_VAR 0 2
54844: PUSH
54845: LD_VAR 0 1
54849: PUSH
54850: LD_INT 0
54852: DIFF
54853: ST_TO_ADDR
// if not result [ 1 ] then
54854: LD_VAR 0 2
54858: PUSH
54859: LD_INT 1
54861: ARRAY
54862: NOT
54863: IFFALSE 54883
// result := Delete ( result , 1 ) ;
54865: LD_ADDR_VAR 0 2
54869: PUSH
54870: LD_VAR 0 2
54874: PPUSH
54875: LD_INT 1
54877: PPUSH
54878: CALL_OW 3
54882: ST_TO_ADDR
// end ;
54883: LD_VAR 0 2
54887: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
54888: LD_INT 0
54890: PPUSH
54891: PPUSH
54892: PPUSH
54893: PPUSH
// sibRocketRange := 25 ;
54894: LD_ADDR_VAR 0 6
54898: PUSH
54899: LD_INT 25
54901: ST_TO_ADDR
// result := false ;
54902: LD_ADDR_VAR 0 4
54906: PUSH
54907: LD_INT 0
54909: ST_TO_ADDR
// for i := 0 to 5 do
54910: LD_ADDR_VAR 0 5
54914: PUSH
54915: DOUBLE
54916: LD_INT 0
54918: DEC
54919: ST_TO_ADDR
54920: LD_INT 5
54922: PUSH
54923: FOR_TO
54924: IFFALSE 54991
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
54926: LD_VAR 0 1
54930: PPUSH
54931: LD_VAR 0 5
54935: PPUSH
54936: LD_VAR 0 6
54940: PPUSH
54941: CALL_OW 272
54945: PPUSH
54946: LD_VAR 0 2
54950: PPUSH
54951: LD_VAR 0 5
54955: PPUSH
54956: LD_VAR 0 6
54960: PPUSH
54961: CALL_OW 273
54965: PPUSH
54966: LD_VAR 0 3
54970: PPUSH
54971: CALL_OW 309
54975: IFFALSE 54989
// begin result := true ;
54977: LD_ADDR_VAR 0 4
54981: PUSH
54982: LD_INT 1
54984: ST_TO_ADDR
// exit ;
54985: POP
54986: POP
54987: GO 54993
// end ;
54989: GO 54923
54991: POP
54992: POP
// end ;
54993: LD_VAR 0 4
54997: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
54998: LD_INT 0
55000: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
55001: LD_VAR 0 1
55005: PPUSH
55006: LD_VAR 0 2
55010: PPUSH
55011: LD_INT 0
55013: PPUSH
55014: LD_INT 0
55016: PPUSH
55017: LD_INT 1
55019: PPUSH
55020: LD_INT 0
55022: PPUSH
55023: CALL_OW 587
// end ; end_of_file
55027: LD_VAR 0 3
55031: RET
// export ru_radar export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
55032: LD_INT 0
55034: PPUSH
55035: PPUSH
// skirmish := false ;
55036: LD_ADDR_EXP 48
55040: PUSH
55041: LD_INT 0
55043: ST_TO_ADDR
// debug_mc := false ;
55044: LD_ADDR_EXP 49
55048: PUSH
55049: LD_INT 0
55051: ST_TO_ADDR
// mc_bases := [ ] ;
55052: LD_ADDR_EXP 50
55056: PUSH
55057: EMPTY
55058: ST_TO_ADDR
// mc_sides := [ ] ;
55059: LD_ADDR_EXP 76
55063: PUSH
55064: EMPTY
55065: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55066: LD_ADDR_EXP 51
55070: PUSH
55071: EMPTY
55072: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55073: LD_ADDR_EXP 52
55077: PUSH
55078: EMPTY
55079: ST_TO_ADDR
// mc_need_heal := [ ] ;
55080: LD_ADDR_EXP 53
55084: PUSH
55085: EMPTY
55086: ST_TO_ADDR
// mc_healers := [ ] ;
55087: LD_ADDR_EXP 54
55091: PUSH
55092: EMPTY
55093: ST_TO_ADDR
// mc_build_list := [ ] ;
55094: LD_ADDR_EXP 55
55098: PUSH
55099: EMPTY
55100: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55101: LD_ADDR_EXP 82
55105: PUSH
55106: EMPTY
55107: ST_TO_ADDR
// mc_builders := [ ] ;
55108: LD_ADDR_EXP 56
55112: PUSH
55113: EMPTY
55114: ST_TO_ADDR
// mc_construct_list := [ ] ;
55115: LD_ADDR_EXP 57
55119: PUSH
55120: EMPTY
55121: ST_TO_ADDR
// mc_turret_list := [ ] ;
55122: LD_ADDR_EXP 58
55126: PUSH
55127: EMPTY
55128: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55129: LD_ADDR_EXP 59
55133: PUSH
55134: EMPTY
55135: ST_TO_ADDR
// mc_miners := [ ] ;
55136: LD_ADDR_EXP 64
55140: PUSH
55141: EMPTY
55142: ST_TO_ADDR
// mc_mines := [ ] ;
55143: LD_ADDR_EXP 63
55147: PUSH
55148: EMPTY
55149: ST_TO_ADDR
// mc_minefields := [ ] ;
55150: LD_ADDR_EXP 65
55154: PUSH
55155: EMPTY
55156: ST_TO_ADDR
// mc_crates := [ ] ;
55157: LD_ADDR_EXP 66
55161: PUSH
55162: EMPTY
55163: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55164: LD_ADDR_EXP 67
55168: PUSH
55169: EMPTY
55170: ST_TO_ADDR
// mc_crates_area := [ ] ;
55171: LD_ADDR_EXP 68
55175: PUSH
55176: EMPTY
55177: ST_TO_ADDR
// mc_vehicles := [ ] ;
55178: LD_ADDR_EXP 69
55182: PUSH
55183: EMPTY
55184: ST_TO_ADDR
// mc_attack := [ ] ;
55185: LD_ADDR_EXP 70
55189: PUSH
55190: EMPTY
55191: ST_TO_ADDR
// mc_produce := [ ] ;
55192: LD_ADDR_EXP 71
55196: PUSH
55197: EMPTY
55198: ST_TO_ADDR
// mc_defender := [ ] ;
55199: LD_ADDR_EXP 72
55203: PUSH
55204: EMPTY
55205: ST_TO_ADDR
// mc_parking := [ ] ;
55206: LD_ADDR_EXP 74
55210: PUSH
55211: EMPTY
55212: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55213: LD_ADDR_EXP 60
55217: PUSH
55218: EMPTY
55219: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55220: LD_ADDR_EXP 62
55224: PUSH
55225: EMPTY
55226: ST_TO_ADDR
// mc_scan := [ ] ;
55227: LD_ADDR_EXP 73
55231: PUSH
55232: EMPTY
55233: ST_TO_ADDR
// mc_scan_area := [ ] ;
55234: LD_ADDR_EXP 75
55238: PUSH
55239: EMPTY
55240: ST_TO_ADDR
// mc_tech := [ ] ;
55241: LD_ADDR_EXP 77
55245: PUSH
55246: EMPTY
55247: ST_TO_ADDR
// mc_class := [ ] ;
55248: LD_ADDR_EXP 91
55252: PUSH
55253: EMPTY
55254: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55255: LD_ADDR_EXP 92
55259: PUSH
55260: EMPTY
55261: ST_TO_ADDR
// mc_is_defending := [ ] ;
55262: LD_ADDR_EXP 93
55266: PUSH
55267: EMPTY
55268: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
55269: LD_ADDR_EXP 84
55273: PUSH
55274: EMPTY
55275: ST_TO_ADDR
// end ;
55276: LD_VAR 0 1
55280: RET
// export function MC_Kill ( base ) ; begin
55281: LD_INT 0
55283: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55284: LD_ADDR_EXP 50
55288: PUSH
55289: LD_EXP 50
55293: PPUSH
55294: LD_VAR 0 1
55298: PPUSH
55299: EMPTY
55300: PPUSH
55301: CALL_OW 1
55305: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55306: LD_ADDR_EXP 51
55310: PUSH
55311: LD_EXP 51
55315: PPUSH
55316: LD_VAR 0 1
55320: PPUSH
55321: EMPTY
55322: PPUSH
55323: CALL_OW 1
55327: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55328: LD_ADDR_EXP 52
55332: PUSH
55333: LD_EXP 52
55337: PPUSH
55338: LD_VAR 0 1
55342: PPUSH
55343: EMPTY
55344: PPUSH
55345: CALL_OW 1
55349: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55350: LD_ADDR_EXP 53
55354: PUSH
55355: LD_EXP 53
55359: PPUSH
55360: LD_VAR 0 1
55364: PPUSH
55365: EMPTY
55366: PPUSH
55367: CALL_OW 1
55371: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55372: LD_ADDR_EXP 54
55376: PUSH
55377: LD_EXP 54
55381: PPUSH
55382: LD_VAR 0 1
55386: PPUSH
55387: EMPTY
55388: PPUSH
55389: CALL_OW 1
55393: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55394: LD_ADDR_EXP 55
55398: PUSH
55399: LD_EXP 55
55403: PPUSH
55404: LD_VAR 0 1
55408: PPUSH
55409: EMPTY
55410: PPUSH
55411: CALL_OW 1
55415: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55416: LD_ADDR_EXP 56
55420: PUSH
55421: LD_EXP 56
55425: PPUSH
55426: LD_VAR 0 1
55430: PPUSH
55431: EMPTY
55432: PPUSH
55433: CALL_OW 1
55437: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55438: LD_ADDR_EXP 57
55442: PUSH
55443: LD_EXP 57
55447: PPUSH
55448: LD_VAR 0 1
55452: PPUSH
55453: EMPTY
55454: PPUSH
55455: CALL_OW 1
55459: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55460: LD_ADDR_EXP 58
55464: PUSH
55465: LD_EXP 58
55469: PPUSH
55470: LD_VAR 0 1
55474: PPUSH
55475: EMPTY
55476: PPUSH
55477: CALL_OW 1
55481: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55482: LD_ADDR_EXP 59
55486: PUSH
55487: LD_EXP 59
55491: PPUSH
55492: LD_VAR 0 1
55496: PPUSH
55497: EMPTY
55498: PPUSH
55499: CALL_OW 1
55503: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55504: LD_ADDR_EXP 60
55508: PUSH
55509: LD_EXP 60
55513: PPUSH
55514: LD_VAR 0 1
55518: PPUSH
55519: EMPTY
55520: PPUSH
55521: CALL_OW 1
55525: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55526: LD_ADDR_EXP 61
55530: PUSH
55531: LD_EXP 61
55535: PPUSH
55536: LD_VAR 0 1
55540: PPUSH
55541: LD_INT 0
55543: PPUSH
55544: CALL_OW 1
55548: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55549: LD_ADDR_EXP 62
55553: PUSH
55554: LD_EXP 62
55558: PPUSH
55559: LD_VAR 0 1
55563: PPUSH
55564: EMPTY
55565: PPUSH
55566: CALL_OW 1
55570: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55571: LD_ADDR_EXP 63
55575: PUSH
55576: LD_EXP 63
55580: PPUSH
55581: LD_VAR 0 1
55585: PPUSH
55586: EMPTY
55587: PPUSH
55588: CALL_OW 1
55592: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55593: LD_ADDR_EXP 64
55597: PUSH
55598: LD_EXP 64
55602: PPUSH
55603: LD_VAR 0 1
55607: PPUSH
55608: EMPTY
55609: PPUSH
55610: CALL_OW 1
55614: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55615: LD_ADDR_EXP 65
55619: PUSH
55620: LD_EXP 65
55624: PPUSH
55625: LD_VAR 0 1
55629: PPUSH
55630: EMPTY
55631: PPUSH
55632: CALL_OW 1
55636: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55637: LD_ADDR_EXP 66
55641: PUSH
55642: LD_EXP 66
55646: PPUSH
55647: LD_VAR 0 1
55651: PPUSH
55652: EMPTY
55653: PPUSH
55654: CALL_OW 1
55658: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55659: LD_ADDR_EXP 67
55663: PUSH
55664: LD_EXP 67
55668: PPUSH
55669: LD_VAR 0 1
55673: PPUSH
55674: EMPTY
55675: PPUSH
55676: CALL_OW 1
55680: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55681: LD_ADDR_EXP 68
55685: PUSH
55686: LD_EXP 68
55690: PPUSH
55691: LD_VAR 0 1
55695: PPUSH
55696: EMPTY
55697: PPUSH
55698: CALL_OW 1
55702: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55703: LD_ADDR_EXP 69
55707: PUSH
55708: LD_EXP 69
55712: PPUSH
55713: LD_VAR 0 1
55717: PPUSH
55718: EMPTY
55719: PPUSH
55720: CALL_OW 1
55724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55725: LD_ADDR_EXP 70
55729: PUSH
55730: LD_EXP 70
55734: PPUSH
55735: LD_VAR 0 1
55739: PPUSH
55740: EMPTY
55741: PPUSH
55742: CALL_OW 1
55746: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55747: LD_ADDR_EXP 71
55751: PUSH
55752: LD_EXP 71
55756: PPUSH
55757: LD_VAR 0 1
55761: PPUSH
55762: EMPTY
55763: PPUSH
55764: CALL_OW 1
55768: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55769: LD_ADDR_EXP 72
55773: PUSH
55774: LD_EXP 72
55778: PPUSH
55779: LD_VAR 0 1
55783: PPUSH
55784: EMPTY
55785: PPUSH
55786: CALL_OW 1
55790: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55791: LD_ADDR_EXP 73
55795: PUSH
55796: LD_EXP 73
55800: PPUSH
55801: LD_VAR 0 1
55805: PPUSH
55806: EMPTY
55807: PPUSH
55808: CALL_OW 1
55812: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55813: LD_ADDR_EXP 74
55817: PUSH
55818: LD_EXP 74
55822: PPUSH
55823: LD_VAR 0 1
55827: PPUSH
55828: EMPTY
55829: PPUSH
55830: CALL_OW 1
55834: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55835: LD_ADDR_EXP 75
55839: PUSH
55840: LD_EXP 75
55844: PPUSH
55845: LD_VAR 0 1
55849: PPUSH
55850: EMPTY
55851: PPUSH
55852: CALL_OW 1
55856: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55857: LD_ADDR_EXP 77
55861: PUSH
55862: LD_EXP 77
55866: PPUSH
55867: LD_VAR 0 1
55871: PPUSH
55872: EMPTY
55873: PPUSH
55874: CALL_OW 1
55878: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55879: LD_ADDR_EXP 79
55883: PUSH
55884: LD_EXP 79
55888: PPUSH
55889: LD_VAR 0 1
55893: PPUSH
55894: EMPTY
55895: PPUSH
55896: CALL_OW 1
55900: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55901: LD_ADDR_EXP 80
55905: PUSH
55906: LD_EXP 80
55910: PPUSH
55911: LD_VAR 0 1
55915: PPUSH
55916: EMPTY
55917: PPUSH
55918: CALL_OW 1
55922: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55923: LD_ADDR_EXP 81
55927: PUSH
55928: LD_EXP 81
55932: PPUSH
55933: LD_VAR 0 1
55937: PPUSH
55938: EMPTY
55939: PPUSH
55940: CALL_OW 1
55944: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55945: LD_ADDR_EXP 82
55949: PUSH
55950: LD_EXP 82
55954: PPUSH
55955: LD_VAR 0 1
55959: PPUSH
55960: EMPTY
55961: PPUSH
55962: CALL_OW 1
55966: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55967: LD_ADDR_EXP 83
55971: PUSH
55972: LD_EXP 83
55976: PPUSH
55977: LD_VAR 0 1
55981: PPUSH
55982: EMPTY
55983: PPUSH
55984: CALL_OW 1
55988: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55989: LD_ADDR_EXP 84
55993: PUSH
55994: LD_EXP 84
55998: PPUSH
55999: LD_VAR 0 1
56003: PPUSH
56004: EMPTY
56005: PPUSH
56006: CALL_OW 1
56010: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56011: LD_ADDR_EXP 85
56015: PUSH
56016: LD_EXP 85
56020: PPUSH
56021: LD_VAR 0 1
56025: PPUSH
56026: EMPTY
56027: PPUSH
56028: CALL_OW 1
56032: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56033: LD_ADDR_EXP 86
56037: PUSH
56038: LD_EXP 86
56042: PPUSH
56043: LD_VAR 0 1
56047: PPUSH
56048: EMPTY
56049: PPUSH
56050: CALL_OW 1
56054: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56055: LD_ADDR_EXP 87
56059: PUSH
56060: LD_EXP 87
56064: PPUSH
56065: LD_VAR 0 1
56069: PPUSH
56070: EMPTY
56071: PPUSH
56072: CALL_OW 1
56076: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56077: LD_ADDR_EXP 88
56081: PUSH
56082: LD_EXP 88
56086: PPUSH
56087: LD_VAR 0 1
56091: PPUSH
56092: EMPTY
56093: PPUSH
56094: CALL_OW 1
56098: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56099: LD_ADDR_EXP 89
56103: PUSH
56104: LD_EXP 89
56108: PPUSH
56109: LD_VAR 0 1
56113: PPUSH
56114: EMPTY
56115: PPUSH
56116: CALL_OW 1
56120: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56121: LD_ADDR_EXP 90
56125: PUSH
56126: LD_EXP 90
56130: PPUSH
56131: LD_VAR 0 1
56135: PPUSH
56136: EMPTY
56137: PPUSH
56138: CALL_OW 1
56142: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56143: LD_ADDR_EXP 91
56147: PUSH
56148: LD_EXP 91
56152: PPUSH
56153: LD_VAR 0 1
56157: PPUSH
56158: EMPTY
56159: PPUSH
56160: CALL_OW 1
56164: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56165: LD_ADDR_EXP 92
56169: PUSH
56170: LD_EXP 92
56174: PPUSH
56175: LD_VAR 0 1
56179: PPUSH
56180: LD_INT 0
56182: PPUSH
56183: CALL_OW 1
56187: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56188: LD_ADDR_EXP 93
56192: PUSH
56193: LD_EXP 93
56197: PPUSH
56198: LD_VAR 0 1
56202: PPUSH
56203: LD_INT 0
56205: PPUSH
56206: CALL_OW 1
56210: ST_TO_ADDR
// end ;
56211: LD_VAR 0 2
56215: RET
// export function MC_Add ( side , units ) ; var base ; begin
56216: LD_INT 0
56218: PPUSH
56219: PPUSH
// base := mc_bases + 1 ;
56220: LD_ADDR_VAR 0 4
56224: PUSH
56225: LD_EXP 50
56229: PUSH
56230: LD_INT 1
56232: PLUS
56233: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56234: LD_ADDR_EXP 76
56238: PUSH
56239: LD_EXP 76
56243: PPUSH
56244: LD_VAR 0 4
56248: PPUSH
56249: LD_VAR 0 1
56253: PPUSH
56254: CALL_OW 1
56258: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56259: LD_ADDR_EXP 50
56263: PUSH
56264: LD_EXP 50
56268: PPUSH
56269: LD_VAR 0 4
56273: PPUSH
56274: LD_VAR 0 2
56278: PPUSH
56279: CALL_OW 1
56283: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56284: LD_ADDR_EXP 51
56288: PUSH
56289: LD_EXP 51
56293: PPUSH
56294: LD_VAR 0 4
56298: PPUSH
56299: EMPTY
56300: PPUSH
56301: CALL_OW 1
56305: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56306: LD_ADDR_EXP 52
56310: PUSH
56311: LD_EXP 52
56315: PPUSH
56316: LD_VAR 0 4
56320: PPUSH
56321: EMPTY
56322: PPUSH
56323: CALL_OW 1
56327: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56328: LD_ADDR_EXP 53
56332: PUSH
56333: LD_EXP 53
56337: PPUSH
56338: LD_VAR 0 4
56342: PPUSH
56343: EMPTY
56344: PPUSH
56345: CALL_OW 1
56349: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56350: LD_ADDR_EXP 54
56354: PUSH
56355: LD_EXP 54
56359: PPUSH
56360: LD_VAR 0 4
56364: PPUSH
56365: EMPTY
56366: PPUSH
56367: CALL_OW 1
56371: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56372: LD_ADDR_EXP 55
56376: PUSH
56377: LD_EXP 55
56381: PPUSH
56382: LD_VAR 0 4
56386: PPUSH
56387: EMPTY
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56394: LD_ADDR_EXP 56
56398: PUSH
56399: LD_EXP 56
56403: PPUSH
56404: LD_VAR 0 4
56408: PPUSH
56409: EMPTY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56416: LD_ADDR_EXP 57
56420: PUSH
56421: LD_EXP 57
56425: PPUSH
56426: LD_VAR 0 4
56430: PPUSH
56431: EMPTY
56432: PPUSH
56433: CALL_OW 1
56437: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56438: LD_ADDR_EXP 58
56442: PUSH
56443: LD_EXP 58
56447: PPUSH
56448: LD_VAR 0 4
56452: PPUSH
56453: EMPTY
56454: PPUSH
56455: CALL_OW 1
56459: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56460: LD_ADDR_EXP 59
56464: PUSH
56465: LD_EXP 59
56469: PPUSH
56470: LD_VAR 0 4
56474: PPUSH
56475: EMPTY
56476: PPUSH
56477: CALL_OW 1
56481: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56482: LD_ADDR_EXP 60
56486: PUSH
56487: LD_EXP 60
56491: PPUSH
56492: LD_VAR 0 4
56496: PPUSH
56497: EMPTY
56498: PPUSH
56499: CALL_OW 1
56503: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56504: LD_ADDR_EXP 61
56508: PUSH
56509: LD_EXP 61
56513: PPUSH
56514: LD_VAR 0 4
56518: PPUSH
56519: LD_INT 0
56521: PPUSH
56522: CALL_OW 1
56526: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56527: LD_ADDR_EXP 62
56531: PUSH
56532: LD_EXP 62
56536: PPUSH
56537: LD_VAR 0 4
56541: PPUSH
56542: EMPTY
56543: PPUSH
56544: CALL_OW 1
56548: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56549: LD_ADDR_EXP 63
56553: PUSH
56554: LD_EXP 63
56558: PPUSH
56559: LD_VAR 0 4
56563: PPUSH
56564: EMPTY
56565: PPUSH
56566: CALL_OW 1
56570: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56571: LD_ADDR_EXP 64
56575: PUSH
56576: LD_EXP 64
56580: PPUSH
56581: LD_VAR 0 4
56585: PPUSH
56586: EMPTY
56587: PPUSH
56588: CALL_OW 1
56592: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56593: LD_ADDR_EXP 65
56597: PUSH
56598: LD_EXP 65
56602: PPUSH
56603: LD_VAR 0 4
56607: PPUSH
56608: EMPTY
56609: PPUSH
56610: CALL_OW 1
56614: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56615: LD_ADDR_EXP 66
56619: PUSH
56620: LD_EXP 66
56624: PPUSH
56625: LD_VAR 0 4
56629: PPUSH
56630: EMPTY
56631: PPUSH
56632: CALL_OW 1
56636: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56637: LD_ADDR_EXP 67
56641: PUSH
56642: LD_EXP 67
56646: PPUSH
56647: LD_VAR 0 4
56651: PPUSH
56652: EMPTY
56653: PPUSH
56654: CALL_OW 1
56658: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56659: LD_ADDR_EXP 68
56663: PUSH
56664: LD_EXP 68
56668: PPUSH
56669: LD_VAR 0 4
56673: PPUSH
56674: EMPTY
56675: PPUSH
56676: CALL_OW 1
56680: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56681: LD_ADDR_EXP 69
56685: PUSH
56686: LD_EXP 69
56690: PPUSH
56691: LD_VAR 0 4
56695: PPUSH
56696: EMPTY
56697: PPUSH
56698: CALL_OW 1
56702: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56703: LD_ADDR_EXP 70
56707: PUSH
56708: LD_EXP 70
56712: PPUSH
56713: LD_VAR 0 4
56717: PPUSH
56718: EMPTY
56719: PPUSH
56720: CALL_OW 1
56724: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56725: LD_ADDR_EXP 71
56729: PUSH
56730: LD_EXP 71
56734: PPUSH
56735: LD_VAR 0 4
56739: PPUSH
56740: EMPTY
56741: PPUSH
56742: CALL_OW 1
56746: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56747: LD_ADDR_EXP 72
56751: PUSH
56752: LD_EXP 72
56756: PPUSH
56757: LD_VAR 0 4
56761: PPUSH
56762: EMPTY
56763: PPUSH
56764: CALL_OW 1
56768: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56769: LD_ADDR_EXP 73
56773: PUSH
56774: LD_EXP 73
56778: PPUSH
56779: LD_VAR 0 4
56783: PPUSH
56784: EMPTY
56785: PPUSH
56786: CALL_OW 1
56790: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56791: LD_ADDR_EXP 74
56795: PUSH
56796: LD_EXP 74
56800: PPUSH
56801: LD_VAR 0 4
56805: PPUSH
56806: EMPTY
56807: PPUSH
56808: CALL_OW 1
56812: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56813: LD_ADDR_EXP 75
56817: PUSH
56818: LD_EXP 75
56822: PPUSH
56823: LD_VAR 0 4
56827: PPUSH
56828: EMPTY
56829: PPUSH
56830: CALL_OW 1
56834: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56835: LD_ADDR_EXP 77
56839: PUSH
56840: LD_EXP 77
56844: PPUSH
56845: LD_VAR 0 4
56849: PPUSH
56850: EMPTY
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56857: LD_ADDR_EXP 79
56861: PUSH
56862: LD_EXP 79
56866: PPUSH
56867: LD_VAR 0 4
56871: PPUSH
56872: EMPTY
56873: PPUSH
56874: CALL_OW 1
56878: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56879: LD_ADDR_EXP 80
56883: PUSH
56884: LD_EXP 80
56888: PPUSH
56889: LD_VAR 0 4
56893: PPUSH
56894: EMPTY
56895: PPUSH
56896: CALL_OW 1
56900: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56901: LD_ADDR_EXP 81
56905: PUSH
56906: LD_EXP 81
56910: PPUSH
56911: LD_VAR 0 4
56915: PPUSH
56916: EMPTY
56917: PPUSH
56918: CALL_OW 1
56922: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56923: LD_ADDR_EXP 82
56927: PUSH
56928: LD_EXP 82
56932: PPUSH
56933: LD_VAR 0 4
56937: PPUSH
56938: EMPTY
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56945: LD_ADDR_EXP 83
56949: PUSH
56950: LD_EXP 83
56954: PPUSH
56955: LD_VAR 0 4
56959: PPUSH
56960: EMPTY
56961: PPUSH
56962: CALL_OW 1
56966: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56967: LD_ADDR_EXP 84
56971: PUSH
56972: LD_EXP 84
56976: PPUSH
56977: LD_VAR 0 4
56981: PPUSH
56982: EMPTY
56983: PPUSH
56984: CALL_OW 1
56988: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56989: LD_ADDR_EXP 85
56993: PUSH
56994: LD_EXP 85
56998: PPUSH
56999: LD_VAR 0 4
57003: PPUSH
57004: EMPTY
57005: PPUSH
57006: CALL_OW 1
57010: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57011: LD_ADDR_EXP 86
57015: PUSH
57016: LD_EXP 86
57020: PPUSH
57021: LD_VAR 0 4
57025: PPUSH
57026: EMPTY
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57033: LD_ADDR_EXP 87
57037: PUSH
57038: LD_EXP 87
57042: PPUSH
57043: LD_VAR 0 4
57047: PPUSH
57048: EMPTY
57049: PPUSH
57050: CALL_OW 1
57054: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57055: LD_ADDR_EXP 88
57059: PUSH
57060: LD_EXP 88
57064: PPUSH
57065: LD_VAR 0 4
57069: PPUSH
57070: EMPTY
57071: PPUSH
57072: CALL_OW 1
57076: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57077: LD_ADDR_EXP 89
57081: PUSH
57082: LD_EXP 89
57086: PPUSH
57087: LD_VAR 0 4
57091: PPUSH
57092: EMPTY
57093: PPUSH
57094: CALL_OW 1
57098: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57099: LD_ADDR_EXP 90
57103: PUSH
57104: LD_EXP 90
57108: PPUSH
57109: LD_VAR 0 4
57113: PPUSH
57114: EMPTY
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57121: LD_ADDR_EXP 91
57125: PUSH
57126: LD_EXP 91
57130: PPUSH
57131: LD_VAR 0 4
57135: PPUSH
57136: EMPTY
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57143: LD_ADDR_EXP 92
57147: PUSH
57148: LD_EXP 92
57152: PPUSH
57153: LD_VAR 0 4
57157: PPUSH
57158: LD_INT 0
57160: PPUSH
57161: CALL_OW 1
57165: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57166: LD_ADDR_EXP 93
57170: PUSH
57171: LD_EXP 93
57175: PPUSH
57176: LD_VAR 0 4
57180: PPUSH
57181: LD_INT 0
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// result := base ;
57189: LD_ADDR_VAR 0 3
57193: PUSH
57194: LD_VAR 0 4
57198: ST_TO_ADDR
// end ;
57199: LD_VAR 0 3
57203: RET
// export function MC_Start ( ) ; var i ; begin
57204: LD_INT 0
57206: PPUSH
57207: PPUSH
// for i = 1 to mc_bases do
57208: LD_ADDR_VAR 0 2
57212: PUSH
57213: DOUBLE
57214: LD_INT 1
57216: DEC
57217: ST_TO_ADDR
57218: LD_EXP 50
57222: PUSH
57223: FOR_TO
57224: IFFALSE 58324
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57226: LD_ADDR_EXP 50
57230: PUSH
57231: LD_EXP 50
57235: PPUSH
57236: LD_VAR 0 2
57240: PPUSH
57241: LD_EXP 50
57245: PUSH
57246: LD_VAR 0 2
57250: ARRAY
57251: PUSH
57252: LD_INT 0
57254: DIFF
57255: PPUSH
57256: CALL_OW 1
57260: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57261: LD_ADDR_EXP 51
57265: PUSH
57266: LD_EXP 51
57270: PPUSH
57271: LD_VAR 0 2
57275: PPUSH
57276: EMPTY
57277: PPUSH
57278: CALL_OW 1
57282: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57283: LD_ADDR_EXP 52
57287: PUSH
57288: LD_EXP 52
57292: PPUSH
57293: LD_VAR 0 2
57297: PPUSH
57298: EMPTY
57299: PPUSH
57300: CALL_OW 1
57304: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57305: LD_ADDR_EXP 53
57309: PUSH
57310: LD_EXP 53
57314: PPUSH
57315: LD_VAR 0 2
57319: PPUSH
57320: EMPTY
57321: PPUSH
57322: CALL_OW 1
57326: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57327: LD_ADDR_EXP 54
57331: PUSH
57332: LD_EXP 54
57336: PPUSH
57337: LD_VAR 0 2
57341: PPUSH
57342: EMPTY
57343: PUSH
57344: EMPTY
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PPUSH
57350: CALL_OW 1
57354: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57355: LD_ADDR_EXP 55
57359: PUSH
57360: LD_EXP 55
57364: PPUSH
57365: LD_VAR 0 2
57369: PPUSH
57370: EMPTY
57371: PPUSH
57372: CALL_OW 1
57376: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57377: LD_ADDR_EXP 82
57381: PUSH
57382: LD_EXP 82
57386: PPUSH
57387: LD_VAR 0 2
57391: PPUSH
57392: EMPTY
57393: PPUSH
57394: CALL_OW 1
57398: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57399: LD_ADDR_EXP 56
57403: PUSH
57404: LD_EXP 56
57408: PPUSH
57409: LD_VAR 0 2
57413: PPUSH
57414: EMPTY
57415: PPUSH
57416: CALL_OW 1
57420: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57421: LD_ADDR_EXP 57
57425: PUSH
57426: LD_EXP 57
57430: PPUSH
57431: LD_VAR 0 2
57435: PPUSH
57436: EMPTY
57437: PPUSH
57438: CALL_OW 1
57442: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57443: LD_ADDR_EXP 58
57447: PUSH
57448: LD_EXP 58
57452: PPUSH
57453: LD_VAR 0 2
57457: PPUSH
57458: LD_EXP 50
57462: PUSH
57463: LD_VAR 0 2
57467: ARRAY
57468: PPUSH
57469: LD_INT 2
57471: PUSH
57472: LD_INT 30
57474: PUSH
57475: LD_INT 32
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: LD_INT 30
57484: PUSH
57485: LD_INT 33
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: LIST
57496: PPUSH
57497: CALL_OW 72
57501: PPUSH
57502: CALL_OW 1
57506: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57507: LD_ADDR_EXP 59
57511: PUSH
57512: LD_EXP 59
57516: PPUSH
57517: LD_VAR 0 2
57521: PPUSH
57522: LD_EXP 50
57526: PUSH
57527: LD_VAR 0 2
57531: ARRAY
57532: PPUSH
57533: LD_INT 2
57535: PUSH
57536: LD_INT 30
57538: PUSH
57539: LD_INT 32
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: PUSH
57546: LD_INT 30
57548: PUSH
57549: LD_INT 31
57551: PUSH
57552: EMPTY
57553: LIST
57554: LIST
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: LIST
57560: PUSH
57561: LD_INT 58
57563: PUSH
57564: EMPTY
57565: LIST
57566: PUSH
57567: EMPTY
57568: LIST
57569: LIST
57570: PPUSH
57571: CALL_OW 72
57575: PPUSH
57576: CALL_OW 1
57580: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57581: LD_ADDR_EXP 60
57585: PUSH
57586: LD_EXP 60
57590: PPUSH
57591: LD_VAR 0 2
57595: PPUSH
57596: EMPTY
57597: PPUSH
57598: CALL_OW 1
57602: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57603: LD_ADDR_EXP 64
57607: PUSH
57608: LD_EXP 64
57612: PPUSH
57613: LD_VAR 0 2
57617: PPUSH
57618: EMPTY
57619: PPUSH
57620: CALL_OW 1
57624: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57625: LD_ADDR_EXP 63
57629: PUSH
57630: LD_EXP 63
57634: PPUSH
57635: LD_VAR 0 2
57639: PPUSH
57640: EMPTY
57641: PPUSH
57642: CALL_OW 1
57646: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57647: LD_ADDR_EXP 65
57651: PUSH
57652: LD_EXP 65
57656: PPUSH
57657: LD_VAR 0 2
57661: PPUSH
57662: EMPTY
57663: PPUSH
57664: CALL_OW 1
57668: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57669: LD_ADDR_EXP 66
57673: PUSH
57674: LD_EXP 66
57678: PPUSH
57679: LD_VAR 0 2
57683: PPUSH
57684: EMPTY
57685: PPUSH
57686: CALL_OW 1
57690: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57691: LD_ADDR_EXP 67
57695: PUSH
57696: LD_EXP 67
57700: PPUSH
57701: LD_VAR 0 2
57705: PPUSH
57706: EMPTY
57707: PPUSH
57708: CALL_OW 1
57712: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57713: LD_ADDR_EXP 68
57717: PUSH
57718: LD_EXP 68
57722: PPUSH
57723: LD_VAR 0 2
57727: PPUSH
57728: EMPTY
57729: PPUSH
57730: CALL_OW 1
57734: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57735: LD_ADDR_EXP 69
57739: PUSH
57740: LD_EXP 69
57744: PPUSH
57745: LD_VAR 0 2
57749: PPUSH
57750: EMPTY
57751: PPUSH
57752: CALL_OW 1
57756: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57757: LD_ADDR_EXP 70
57761: PUSH
57762: LD_EXP 70
57766: PPUSH
57767: LD_VAR 0 2
57771: PPUSH
57772: EMPTY
57773: PPUSH
57774: CALL_OW 1
57778: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57779: LD_ADDR_EXP 71
57783: PUSH
57784: LD_EXP 71
57788: PPUSH
57789: LD_VAR 0 2
57793: PPUSH
57794: EMPTY
57795: PPUSH
57796: CALL_OW 1
57800: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57801: LD_ADDR_EXP 72
57805: PUSH
57806: LD_EXP 72
57810: PPUSH
57811: LD_VAR 0 2
57815: PPUSH
57816: EMPTY
57817: PPUSH
57818: CALL_OW 1
57822: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57823: LD_ADDR_EXP 61
57827: PUSH
57828: LD_EXP 61
57832: PPUSH
57833: LD_VAR 0 2
57837: PPUSH
57838: LD_INT 0
57840: PPUSH
57841: CALL_OW 1
57845: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57846: LD_ADDR_EXP 74
57850: PUSH
57851: LD_EXP 74
57855: PPUSH
57856: LD_VAR 0 2
57860: PPUSH
57861: LD_INT 0
57863: PPUSH
57864: CALL_OW 1
57868: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57869: LD_ADDR_EXP 62
57873: PUSH
57874: LD_EXP 62
57878: PPUSH
57879: LD_VAR 0 2
57883: PPUSH
57884: EMPTY
57885: PPUSH
57886: CALL_OW 1
57890: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57891: LD_ADDR_EXP 73
57895: PUSH
57896: LD_EXP 73
57900: PPUSH
57901: LD_VAR 0 2
57905: PPUSH
57906: LD_INT 0
57908: PPUSH
57909: CALL_OW 1
57913: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57914: LD_ADDR_EXP 75
57918: PUSH
57919: LD_EXP 75
57923: PPUSH
57924: LD_VAR 0 2
57928: PPUSH
57929: EMPTY
57930: PPUSH
57931: CALL_OW 1
57935: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57936: LD_ADDR_EXP 78
57940: PUSH
57941: LD_EXP 78
57945: PPUSH
57946: LD_VAR 0 2
57950: PPUSH
57951: LD_INT 0
57953: PPUSH
57954: CALL_OW 1
57958: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57959: LD_ADDR_EXP 79
57963: PUSH
57964: LD_EXP 79
57968: PPUSH
57969: LD_VAR 0 2
57973: PPUSH
57974: EMPTY
57975: PPUSH
57976: CALL_OW 1
57980: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57981: LD_ADDR_EXP 80
57985: PUSH
57986: LD_EXP 80
57990: PPUSH
57991: LD_VAR 0 2
57995: PPUSH
57996: EMPTY
57997: PPUSH
57998: CALL_OW 1
58002: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58003: LD_ADDR_EXP 81
58007: PUSH
58008: LD_EXP 81
58012: PPUSH
58013: LD_VAR 0 2
58017: PPUSH
58018: EMPTY
58019: PPUSH
58020: CALL_OW 1
58024: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58025: LD_ADDR_EXP 83
58029: PUSH
58030: LD_EXP 83
58034: PPUSH
58035: LD_VAR 0 2
58039: PPUSH
58040: LD_EXP 50
58044: PUSH
58045: LD_VAR 0 2
58049: ARRAY
58050: PPUSH
58051: LD_INT 2
58053: PUSH
58054: LD_INT 30
58056: PUSH
58057: LD_INT 6
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: PUSH
58064: LD_INT 30
58066: PUSH
58067: LD_INT 7
58069: PUSH
58070: EMPTY
58071: LIST
58072: LIST
58073: PUSH
58074: LD_INT 30
58076: PUSH
58077: LD_INT 8
58079: PUSH
58080: EMPTY
58081: LIST
58082: LIST
58083: PUSH
58084: EMPTY
58085: LIST
58086: LIST
58087: LIST
58088: LIST
58089: PPUSH
58090: CALL_OW 72
58094: PPUSH
58095: CALL_OW 1
58099: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58100: LD_ADDR_EXP 84
58104: PUSH
58105: LD_EXP 84
58109: PPUSH
58110: LD_VAR 0 2
58114: PPUSH
58115: EMPTY
58116: PPUSH
58117: CALL_OW 1
58121: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58122: LD_ADDR_EXP 85
58126: PUSH
58127: LD_EXP 85
58131: PPUSH
58132: LD_VAR 0 2
58136: PPUSH
58137: EMPTY
58138: PPUSH
58139: CALL_OW 1
58143: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58144: LD_ADDR_EXP 86
58148: PUSH
58149: LD_EXP 86
58153: PPUSH
58154: LD_VAR 0 2
58158: PPUSH
58159: EMPTY
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58166: LD_ADDR_EXP 87
58170: PUSH
58171: LD_EXP 87
58175: PPUSH
58176: LD_VAR 0 2
58180: PPUSH
58181: EMPTY
58182: PPUSH
58183: CALL_OW 1
58187: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58188: LD_ADDR_EXP 88
58192: PUSH
58193: LD_EXP 88
58197: PPUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: EMPTY
58204: PPUSH
58205: CALL_OW 1
58209: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58210: LD_ADDR_EXP 89
58214: PUSH
58215: LD_EXP 89
58219: PPUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: EMPTY
58226: PPUSH
58227: CALL_OW 1
58231: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58232: LD_ADDR_EXP 90
58236: PUSH
58237: LD_EXP 90
58241: PPUSH
58242: LD_VAR 0 2
58246: PPUSH
58247: EMPTY
58248: PPUSH
58249: CALL_OW 1
58253: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58254: LD_ADDR_EXP 91
58258: PUSH
58259: LD_EXP 91
58263: PPUSH
58264: LD_VAR 0 2
58268: PPUSH
58269: EMPTY
58270: PPUSH
58271: CALL_OW 1
58275: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58276: LD_ADDR_EXP 92
58280: PUSH
58281: LD_EXP 92
58285: PPUSH
58286: LD_VAR 0 2
58290: PPUSH
58291: LD_INT 0
58293: PPUSH
58294: CALL_OW 1
58298: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58299: LD_ADDR_EXP 93
58303: PUSH
58304: LD_EXP 93
58308: PPUSH
58309: LD_VAR 0 2
58313: PPUSH
58314: LD_INT 0
58316: PPUSH
58317: CALL_OW 1
58321: ST_TO_ADDR
// end ;
58322: GO 57223
58324: POP
58325: POP
// MC_InitSides ( ) ;
58326: CALL 58612 0 0
// MC_InitResearch ( ) ;
58330: CALL 58351 0 0
// CustomInitMacro ( ) ;
58334: CALL 5753 0 0
// skirmish := true ;
58338: LD_ADDR_EXP 48
58342: PUSH
58343: LD_INT 1
58345: ST_TO_ADDR
// end ;
58346: LD_VAR 0 1
58350: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58351: LD_INT 0
58353: PPUSH
58354: PPUSH
58355: PPUSH
58356: PPUSH
58357: PPUSH
58358: PPUSH
// if not mc_bases then
58359: LD_EXP 50
58363: NOT
58364: IFFALSE 58368
// exit ;
58366: GO 58607
// for i = 1 to 8 do
58368: LD_ADDR_VAR 0 2
58372: PUSH
58373: DOUBLE
58374: LD_INT 1
58376: DEC
58377: ST_TO_ADDR
58378: LD_INT 8
58380: PUSH
58381: FOR_TO
58382: IFFALSE 58408
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58384: LD_ADDR_EXP 77
58388: PUSH
58389: LD_EXP 77
58393: PPUSH
58394: LD_VAR 0 2
58398: PPUSH
58399: EMPTY
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
58406: GO 58381
58408: POP
58409: POP
// tmp := [ ] ;
58410: LD_ADDR_VAR 0 5
58414: PUSH
58415: EMPTY
58416: ST_TO_ADDR
// for i = 1 to mc_sides do
58417: LD_ADDR_VAR 0 2
58421: PUSH
58422: DOUBLE
58423: LD_INT 1
58425: DEC
58426: ST_TO_ADDR
58427: LD_EXP 76
58431: PUSH
58432: FOR_TO
58433: IFFALSE 58491
// if not mc_sides [ i ] in tmp then
58435: LD_EXP 76
58439: PUSH
58440: LD_VAR 0 2
58444: ARRAY
58445: PUSH
58446: LD_VAR 0 5
58450: IN
58451: NOT
58452: IFFALSE 58489
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58454: LD_ADDR_VAR 0 5
58458: PUSH
58459: LD_VAR 0 5
58463: PPUSH
58464: LD_VAR 0 5
58468: PUSH
58469: LD_INT 1
58471: PLUS
58472: PPUSH
58473: LD_EXP 76
58477: PUSH
58478: LD_VAR 0 2
58482: ARRAY
58483: PPUSH
58484: CALL_OW 2
58488: ST_TO_ADDR
58489: GO 58432
58491: POP
58492: POP
// if not tmp then
58493: LD_VAR 0 5
58497: NOT
58498: IFFALSE 58502
// exit ;
58500: GO 58607
// for j in tmp do
58502: LD_ADDR_VAR 0 3
58506: PUSH
58507: LD_VAR 0 5
58511: PUSH
58512: FOR_IN
58513: IFFALSE 58605
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58515: LD_ADDR_VAR 0 6
58519: PUSH
58520: LD_INT 22
58522: PUSH
58523: LD_VAR 0 3
58527: PUSH
58528: EMPTY
58529: LIST
58530: LIST
58531: PPUSH
58532: CALL_OW 69
58536: ST_TO_ADDR
// if not un then
58537: LD_VAR 0 6
58541: NOT
58542: IFFALSE 58546
// continue ;
58544: GO 58512
// nation := GetNation ( un [ 1 ] ) ;
58546: LD_ADDR_VAR 0 4
58550: PUSH
58551: LD_VAR 0 6
58555: PUSH
58556: LD_INT 1
58558: ARRAY
58559: PPUSH
58560: CALL_OW 248
58564: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58565: LD_ADDR_EXP 77
58569: PUSH
58570: LD_EXP 77
58574: PPUSH
58575: LD_VAR 0 3
58579: PPUSH
58580: LD_VAR 0 3
58584: PPUSH
58585: LD_VAR 0 4
58589: PPUSH
58590: LD_INT 1
58592: PPUSH
58593: CALL 13674 0 3
58597: PPUSH
58598: CALL_OW 1
58602: ST_TO_ADDR
// end ;
58603: GO 58512
58605: POP
58606: POP
// end ;
58607: LD_VAR 0 1
58611: RET
// export function MC_InitSides ( ) ; var i ; begin
58612: LD_INT 0
58614: PPUSH
58615: PPUSH
// if not mc_bases then
58616: LD_EXP 50
58620: NOT
58621: IFFALSE 58625
// exit ;
58623: GO 58699
// for i = 1 to mc_bases do
58625: LD_ADDR_VAR 0 2
58629: PUSH
58630: DOUBLE
58631: LD_INT 1
58633: DEC
58634: ST_TO_ADDR
58635: LD_EXP 50
58639: PUSH
58640: FOR_TO
58641: IFFALSE 58697
// if mc_bases [ i ] then
58643: LD_EXP 50
58647: PUSH
58648: LD_VAR 0 2
58652: ARRAY
58653: IFFALSE 58695
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58655: LD_ADDR_EXP 76
58659: PUSH
58660: LD_EXP 76
58664: PPUSH
58665: LD_VAR 0 2
58669: PPUSH
58670: LD_EXP 50
58674: PUSH
58675: LD_VAR 0 2
58679: ARRAY
58680: PUSH
58681: LD_INT 1
58683: ARRAY
58684: PPUSH
58685: CALL_OW 255
58689: PPUSH
58690: CALL_OW 1
58694: ST_TO_ADDR
58695: GO 58640
58697: POP
58698: POP
// end ;
58699: LD_VAR 0 1
58703: RET
// every 0 0$03 trigger skirmish do
58704: LD_EXP 48
58708: IFFALSE 58862
58710: GO 58712
58712: DISABLE
// begin enable ;
58713: ENABLE
// MC_CheckBuildings ( ) ;
58714: CALL 63360 0 0
// MC_CheckPeopleLife ( ) ;
58718: CALL 63521 0 0
// RaiseSailEvent ( 100 ) ;
58722: LD_INT 100
58724: PPUSH
58725: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58729: LD_INT 103
58731: PPUSH
58732: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58736: LD_INT 104
58738: PPUSH
58739: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58743: LD_INT 105
58745: PPUSH
58746: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58750: LD_INT 106
58752: PPUSH
58753: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58757: LD_INT 107
58759: PPUSH
58760: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58764: LD_INT 108
58766: PPUSH
58767: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58771: LD_INT 109
58773: PPUSH
58774: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58778: LD_INT 110
58780: PPUSH
58781: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58785: LD_INT 111
58787: PPUSH
58788: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58792: LD_INT 112
58794: PPUSH
58795: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58799: LD_INT 113
58801: PPUSH
58802: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58806: LD_INT 120
58808: PPUSH
58809: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58813: LD_INT 121
58815: PPUSH
58816: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58820: LD_INT 122
58822: PPUSH
58823: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58827: LD_INT 123
58829: PPUSH
58830: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58834: LD_INT 124
58836: PPUSH
58837: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58841: LD_INT 125
58843: PPUSH
58844: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58848: LD_INT 126
58850: PPUSH
58851: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58855: LD_INT 200
58857: PPUSH
58858: CALL_OW 427
// end ;
58862: END
// on SailEvent ( event ) do begin if event < 100 then
58863: LD_VAR 0 1
58867: PUSH
58868: LD_INT 100
58870: LESS
58871: IFFALSE 58882
// CustomEvent ( event ) ;
58873: LD_VAR 0 1
58877: PPUSH
58878: CALL 5745 0 1
// if event = 100 then
58882: LD_VAR 0 1
58886: PUSH
58887: LD_INT 100
58889: EQUAL
58890: IFFALSE 58896
// MC_ClassManager ( ) ;
58892: CALL 59288 0 0
// if event = 101 then
58896: LD_VAR 0 1
58900: PUSH
58901: LD_INT 101
58903: EQUAL
58904: IFFALSE 58910
// MC_RepairBuildings ( ) ;
58906: CALL 64106 0 0
// if event = 102 then
58910: LD_VAR 0 1
58914: PUSH
58915: LD_INT 102
58917: EQUAL
58918: IFFALSE 58924
// MC_Heal ( ) ;
58920: CALL 65041 0 0
// if event = 103 then
58924: LD_VAR 0 1
58928: PUSH
58929: LD_INT 103
58931: EQUAL
58932: IFFALSE 58938
// MC_Build ( ) ;
58934: CALL 65463 0 0
// if event = 104 then
58938: LD_VAR 0 1
58942: PUSH
58943: LD_INT 104
58945: EQUAL
58946: IFFALSE 58952
// MC_TurretWeapon ( ) ;
58948: CALL 67097 0 0
// if event = 105 then
58952: LD_VAR 0 1
58956: PUSH
58957: LD_INT 105
58959: EQUAL
58960: IFFALSE 58966
// MC_BuildUpgrade ( ) ;
58962: CALL 66648 0 0
// if event = 106 then
58966: LD_VAR 0 1
58970: PUSH
58971: LD_INT 106
58973: EQUAL
58974: IFFALSE 58980
// MC_PlantMines ( ) ;
58976: CALL 67527 0 0
// if event = 107 then
58980: LD_VAR 0 1
58984: PUSH
58985: LD_INT 107
58987: EQUAL
58988: IFFALSE 58994
// MC_CollectCrates ( ) ;
58990: CALL 68318 0 0
// if event = 108 then
58994: LD_VAR 0 1
58998: PUSH
58999: LD_INT 108
59001: EQUAL
59002: IFFALSE 59008
// MC_LinkRemoteControl ( ) ;
59004: CALL 70168 0 0
// if event = 109 then
59008: LD_VAR 0 1
59012: PUSH
59013: LD_INT 109
59015: EQUAL
59016: IFFALSE 59022
// MC_ProduceVehicle ( ) ;
59018: CALL 70349 0 0
// if event = 110 then
59022: LD_VAR 0 1
59026: PUSH
59027: LD_INT 110
59029: EQUAL
59030: IFFALSE 59036
// MC_SendAttack ( ) ;
59032: CALL 70815 0 0
// if event = 111 then
59036: LD_VAR 0 1
59040: PUSH
59041: LD_INT 111
59043: EQUAL
59044: IFFALSE 59050
// MC_Defend ( ) ;
59046: CALL 70923 0 0
// if event = 112 then
59050: LD_VAR 0 1
59054: PUSH
59055: LD_INT 112
59057: EQUAL
59058: IFFALSE 59064
// MC_Research ( ) ;
59060: CALL 71803 0 0
// if event = 113 then
59064: LD_VAR 0 1
59068: PUSH
59069: LD_INT 113
59071: EQUAL
59072: IFFALSE 59078
// MC_MinesTrigger ( ) ;
59074: CALL 72917 0 0
// if event = 120 then
59078: LD_VAR 0 1
59082: PUSH
59083: LD_INT 120
59085: EQUAL
59086: IFFALSE 59092
// MC_RepairVehicle ( ) ;
59088: CALL 73016 0 0
// if event = 121 then
59092: LD_VAR 0 1
59096: PUSH
59097: LD_INT 121
59099: EQUAL
59100: IFFALSE 59106
// MC_TameApe ( ) ;
59102: CALL 73785 0 0
// if event = 122 then
59106: LD_VAR 0 1
59110: PUSH
59111: LD_INT 122
59113: EQUAL
59114: IFFALSE 59120
// MC_ChangeApeClass ( ) ;
59116: CALL 74614 0 0
// if event = 123 then
59120: LD_VAR 0 1
59124: PUSH
59125: LD_INT 123
59127: EQUAL
59128: IFFALSE 59134
// MC_Bazooka ( ) ;
59130: CALL 75264 0 0
// if event = 124 then
59134: LD_VAR 0 1
59138: PUSH
59139: LD_INT 124
59141: EQUAL
59142: IFFALSE 59148
// MC_TeleportExit ( ) ;
59144: CALL 75462 0 0
// if event = 125 then
59148: LD_VAR 0 1
59152: PUSH
59153: LD_INT 125
59155: EQUAL
59156: IFFALSE 59162
// MC_Deposits ( ) ;
59158: CALL 76109 0 0
// if event = 126 then
59162: LD_VAR 0 1
59166: PUSH
59167: LD_INT 126
59169: EQUAL
59170: IFFALSE 59176
// MC_RemoteDriver ( ) ;
59172: CALL 76734 0 0
// if event = 200 then
59176: LD_VAR 0 1
59180: PUSH
59181: LD_INT 200
59183: EQUAL
59184: IFFALSE 59190
// MC_Idle ( ) ;
59186: CALL 78683 0 0
// end ;
59190: PPOPN 1
59192: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59193: LD_INT 0
59195: PPUSH
59196: PPUSH
// if not mc_bases [ base ] or not tag then
59197: LD_EXP 50
59201: PUSH
59202: LD_VAR 0 1
59206: ARRAY
59207: NOT
59208: PUSH
59209: LD_VAR 0 2
59213: NOT
59214: OR
59215: IFFALSE 59219
// exit ;
59217: GO 59283
// for i in mc_bases [ base ] union mc_ape [ base ] do
59219: LD_ADDR_VAR 0 4
59223: PUSH
59224: LD_EXP 50
59228: PUSH
59229: LD_VAR 0 1
59233: ARRAY
59234: PUSH
59235: LD_EXP 79
59239: PUSH
59240: LD_VAR 0 1
59244: ARRAY
59245: UNION
59246: PUSH
59247: FOR_IN
59248: IFFALSE 59281
// if GetTag ( i ) = tag then
59250: LD_VAR 0 4
59254: PPUSH
59255: CALL_OW 110
59259: PUSH
59260: LD_VAR 0 2
59264: EQUAL
59265: IFFALSE 59279
// SetTag ( i , 0 ) ;
59267: LD_VAR 0 4
59271: PPUSH
59272: LD_INT 0
59274: PPUSH
59275: CALL_OW 109
59279: GO 59247
59281: POP
59282: POP
// end ;
59283: LD_VAR 0 3
59287: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59288: LD_INT 0
59290: PPUSH
59291: PPUSH
59292: PPUSH
59293: PPUSH
59294: PPUSH
59295: PPUSH
59296: PPUSH
59297: PPUSH
// if not mc_bases then
59298: LD_EXP 50
59302: NOT
59303: IFFALSE 59307
// exit ;
59305: GO 59765
// for i = 1 to mc_bases do
59307: LD_ADDR_VAR 0 2
59311: PUSH
59312: DOUBLE
59313: LD_INT 1
59315: DEC
59316: ST_TO_ADDR
59317: LD_EXP 50
59321: PUSH
59322: FOR_TO
59323: IFFALSE 59763
// begin tmp := MC_ClassCheckReq ( i ) ;
59325: LD_ADDR_VAR 0 4
59329: PUSH
59330: LD_VAR 0 2
59334: PPUSH
59335: CALL 59770 0 1
59339: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59340: LD_ADDR_EXP 91
59344: PUSH
59345: LD_EXP 91
59349: PPUSH
59350: LD_VAR 0 2
59354: PPUSH
59355: LD_VAR 0 4
59359: PPUSH
59360: CALL_OW 1
59364: ST_TO_ADDR
// if not tmp then
59365: LD_VAR 0 4
59369: NOT
59370: IFFALSE 59374
// continue ;
59372: GO 59322
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59374: LD_ADDR_VAR 0 6
59378: PUSH
59379: LD_EXP 50
59383: PUSH
59384: LD_VAR 0 2
59388: ARRAY
59389: PPUSH
59390: LD_INT 2
59392: PUSH
59393: LD_INT 30
59395: PUSH
59396: LD_INT 4
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: LD_INT 30
59405: PUSH
59406: LD_INT 5
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: PPUSH
59418: CALL_OW 72
59422: PUSH
59423: LD_EXP 50
59427: PUSH
59428: LD_VAR 0 2
59432: ARRAY
59433: PPUSH
59434: LD_INT 2
59436: PUSH
59437: LD_INT 30
59439: PUSH
59440: LD_INT 0
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: LD_INT 30
59449: PUSH
59450: LD_INT 1
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: EMPTY
59458: LIST
59459: LIST
59460: LIST
59461: PPUSH
59462: CALL_OW 72
59466: PUSH
59467: LD_EXP 50
59471: PUSH
59472: LD_VAR 0 2
59476: ARRAY
59477: PPUSH
59478: LD_INT 30
59480: PUSH
59481: LD_INT 3
59483: PUSH
59484: EMPTY
59485: LIST
59486: LIST
59487: PPUSH
59488: CALL_OW 72
59492: PUSH
59493: LD_EXP 50
59497: PUSH
59498: LD_VAR 0 2
59502: ARRAY
59503: PPUSH
59504: LD_INT 2
59506: PUSH
59507: LD_INT 30
59509: PUSH
59510: LD_INT 6
59512: PUSH
59513: EMPTY
59514: LIST
59515: LIST
59516: PUSH
59517: LD_INT 30
59519: PUSH
59520: LD_INT 7
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: PUSH
59527: LD_INT 30
59529: PUSH
59530: LD_INT 8
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: LIST
59541: LIST
59542: PPUSH
59543: CALL_OW 72
59547: PUSH
59548: EMPTY
59549: LIST
59550: LIST
59551: LIST
59552: LIST
59553: ST_TO_ADDR
// for j = 1 to 4 do
59554: LD_ADDR_VAR 0 3
59558: PUSH
59559: DOUBLE
59560: LD_INT 1
59562: DEC
59563: ST_TO_ADDR
59564: LD_INT 4
59566: PUSH
59567: FOR_TO
59568: IFFALSE 59759
// begin if not tmp [ j ] then
59570: LD_VAR 0 4
59574: PUSH
59575: LD_VAR 0 3
59579: ARRAY
59580: NOT
59581: IFFALSE 59585
// continue ;
59583: GO 59567
// for p in tmp [ j ] do
59585: LD_ADDR_VAR 0 5
59589: PUSH
59590: LD_VAR 0 4
59594: PUSH
59595: LD_VAR 0 3
59599: ARRAY
59600: PUSH
59601: FOR_IN
59602: IFFALSE 59755
// begin if not b [ j ] then
59604: LD_VAR 0 6
59608: PUSH
59609: LD_VAR 0 3
59613: ARRAY
59614: NOT
59615: IFFALSE 59619
// break ;
59617: GO 59755
// e := 0 ;
59619: LD_ADDR_VAR 0 7
59623: PUSH
59624: LD_INT 0
59626: ST_TO_ADDR
// for k in b [ j ] do
59627: LD_ADDR_VAR 0 8
59631: PUSH
59632: LD_VAR 0 6
59636: PUSH
59637: LD_VAR 0 3
59641: ARRAY
59642: PUSH
59643: FOR_IN
59644: IFFALSE 59671
// if IsNotFull ( k ) then
59646: LD_VAR 0 8
59650: PPUSH
59651: CALL 15827 0 1
59655: IFFALSE 59669
// begin e := k ;
59657: LD_ADDR_VAR 0 7
59661: PUSH
59662: LD_VAR 0 8
59666: ST_TO_ADDR
// break ;
59667: GO 59671
// end ;
59669: GO 59643
59671: POP
59672: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59673: LD_VAR 0 7
59677: PUSH
59678: LD_VAR 0 5
59682: PPUSH
59683: LD_VAR 0 7
59687: PPUSH
59688: CALL 49723 0 2
59692: NOT
59693: AND
59694: IFFALSE 59753
// begin if IsInUnit ( p ) then
59696: LD_VAR 0 5
59700: PPUSH
59701: CALL_OW 310
59705: IFFALSE 59716
// ComExitBuilding ( p ) ;
59707: LD_VAR 0 5
59711: PPUSH
59712: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59716: LD_VAR 0 5
59720: PPUSH
59721: LD_VAR 0 7
59725: PPUSH
59726: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59730: LD_VAR 0 5
59734: PPUSH
59735: LD_VAR 0 3
59739: PPUSH
59740: CALL_OW 183
// AddComExitBuilding ( p ) ;
59744: LD_VAR 0 5
59748: PPUSH
59749: CALL_OW 182
// end ; end ;
59753: GO 59601
59755: POP
59756: POP
// end ;
59757: GO 59567
59759: POP
59760: POP
// end ;
59761: GO 59322
59763: POP
59764: POP
// end ;
59765: LD_VAR 0 1
59769: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59770: LD_INT 0
59772: PPUSH
59773: PPUSH
59774: PPUSH
59775: PPUSH
59776: PPUSH
59777: PPUSH
59778: PPUSH
59779: PPUSH
59780: PPUSH
59781: PPUSH
59782: PPUSH
59783: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59784: LD_VAR 0 1
59788: NOT
59789: PUSH
59790: LD_EXP 50
59794: PUSH
59795: LD_VAR 0 1
59799: ARRAY
59800: NOT
59801: OR
59802: PUSH
59803: LD_EXP 50
59807: PUSH
59808: LD_VAR 0 1
59812: ARRAY
59813: PPUSH
59814: LD_INT 2
59816: PUSH
59817: LD_INT 30
59819: PUSH
59820: LD_INT 0
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: PUSH
59827: LD_INT 30
59829: PUSH
59830: LD_INT 1
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: PUSH
59837: EMPTY
59838: LIST
59839: LIST
59840: LIST
59841: PPUSH
59842: CALL_OW 72
59846: NOT
59847: OR
59848: IFFALSE 59852
// exit ;
59850: GO 63355
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59852: LD_ADDR_VAR 0 4
59856: PUSH
59857: LD_EXP 50
59861: PUSH
59862: LD_VAR 0 1
59866: ARRAY
59867: PPUSH
59868: LD_INT 2
59870: PUSH
59871: LD_INT 25
59873: PUSH
59874: LD_INT 1
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 25
59883: PUSH
59884: LD_INT 2
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 25
59893: PUSH
59894: LD_INT 3
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 25
59903: PUSH
59904: LD_INT 4
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: LD_INT 25
59913: PUSH
59914: LD_INT 5
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PUSH
59921: LD_INT 25
59923: PUSH
59924: LD_INT 8
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: LD_INT 25
59933: PUSH
59934: LD_INT 9
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: LIST
59945: LIST
59946: LIST
59947: LIST
59948: LIST
59949: LIST
59950: PPUSH
59951: CALL_OW 72
59955: ST_TO_ADDR
// if not tmp then
59956: LD_VAR 0 4
59960: NOT
59961: IFFALSE 59965
// exit ;
59963: GO 63355
// for i in tmp do
59965: LD_ADDR_VAR 0 3
59969: PUSH
59970: LD_VAR 0 4
59974: PUSH
59975: FOR_IN
59976: IFFALSE 60007
// if GetTag ( i ) then
59978: LD_VAR 0 3
59982: PPUSH
59983: CALL_OW 110
59987: IFFALSE 60005
// tmp := tmp diff i ;
59989: LD_ADDR_VAR 0 4
59993: PUSH
59994: LD_VAR 0 4
59998: PUSH
59999: LD_VAR 0 3
60003: DIFF
60004: ST_TO_ADDR
60005: GO 59975
60007: POP
60008: POP
// if not tmp then
60009: LD_VAR 0 4
60013: NOT
60014: IFFALSE 60018
// exit ;
60016: GO 63355
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60018: LD_ADDR_VAR 0 5
60022: PUSH
60023: LD_EXP 50
60027: PUSH
60028: LD_VAR 0 1
60032: ARRAY
60033: PPUSH
60034: LD_INT 2
60036: PUSH
60037: LD_INT 25
60039: PUSH
60040: LD_INT 1
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: PUSH
60047: LD_INT 25
60049: PUSH
60050: LD_INT 5
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: PUSH
60057: LD_INT 25
60059: PUSH
60060: LD_INT 8
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: LD_INT 25
60069: PUSH
60070: LD_INT 9
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: PUSH
60077: EMPTY
60078: LIST
60079: LIST
60080: LIST
60081: LIST
60082: LIST
60083: PPUSH
60084: CALL_OW 72
60088: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60089: LD_ADDR_VAR 0 6
60093: PUSH
60094: LD_EXP 50
60098: PUSH
60099: LD_VAR 0 1
60103: ARRAY
60104: PPUSH
60105: LD_INT 25
60107: PUSH
60108: LD_INT 2
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PPUSH
60115: CALL_OW 72
60119: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60120: LD_ADDR_VAR 0 7
60124: PUSH
60125: LD_EXP 50
60129: PUSH
60130: LD_VAR 0 1
60134: ARRAY
60135: PPUSH
60136: LD_INT 25
60138: PUSH
60139: LD_INT 3
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PPUSH
60146: CALL_OW 72
60150: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60151: LD_ADDR_VAR 0 8
60155: PUSH
60156: LD_EXP 50
60160: PUSH
60161: LD_VAR 0 1
60165: ARRAY
60166: PPUSH
60167: LD_INT 25
60169: PUSH
60170: LD_INT 4
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: PUSH
60177: LD_INT 24
60179: PUSH
60180: LD_INT 251
60182: PUSH
60183: EMPTY
60184: LIST
60185: LIST
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PPUSH
60191: CALL_OW 72
60195: ST_TO_ADDR
// if mc_is_defending [ base ] then
60196: LD_EXP 93
60200: PUSH
60201: LD_VAR 0 1
60205: ARRAY
60206: IFFALSE 60667
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60208: LD_ADDR_EXP 92
60212: PUSH
60213: LD_EXP 92
60217: PPUSH
60218: LD_VAR 0 1
60222: PPUSH
60223: LD_INT 4
60225: PPUSH
60226: CALL_OW 1
60230: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60231: LD_ADDR_VAR 0 12
60235: PUSH
60236: LD_EXP 50
60240: PUSH
60241: LD_VAR 0 1
60245: ARRAY
60246: PPUSH
60247: LD_INT 2
60249: PUSH
60250: LD_INT 30
60252: PUSH
60253: LD_INT 4
60255: PUSH
60256: EMPTY
60257: LIST
60258: LIST
60259: PUSH
60260: LD_INT 30
60262: PUSH
60263: LD_INT 5
60265: PUSH
60266: EMPTY
60267: LIST
60268: LIST
60269: PUSH
60270: EMPTY
60271: LIST
60272: LIST
60273: LIST
60274: PPUSH
60275: CALL_OW 72
60279: ST_TO_ADDR
// if not b then
60280: LD_VAR 0 12
60284: NOT
60285: IFFALSE 60289
// exit ;
60287: GO 63355
// p := [ ] ;
60289: LD_ADDR_VAR 0 11
60293: PUSH
60294: EMPTY
60295: ST_TO_ADDR
// if sci >= 2 then
60296: LD_VAR 0 8
60300: PUSH
60301: LD_INT 2
60303: GREATEREQUAL
60304: IFFALSE 60335
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60306: LD_ADDR_VAR 0 8
60310: PUSH
60311: LD_VAR 0 8
60315: PUSH
60316: LD_INT 1
60318: ARRAY
60319: PUSH
60320: LD_VAR 0 8
60324: PUSH
60325: LD_INT 2
60327: ARRAY
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: ST_TO_ADDR
60333: GO 60396
// if sci = 1 then
60335: LD_VAR 0 8
60339: PUSH
60340: LD_INT 1
60342: EQUAL
60343: IFFALSE 60364
// sci := [ sci [ 1 ] ] else
60345: LD_ADDR_VAR 0 8
60349: PUSH
60350: LD_VAR 0 8
60354: PUSH
60355: LD_INT 1
60357: ARRAY
60358: PUSH
60359: EMPTY
60360: LIST
60361: ST_TO_ADDR
60362: GO 60396
// if sci = 0 then
60364: LD_VAR 0 8
60368: PUSH
60369: LD_INT 0
60371: EQUAL
60372: IFFALSE 60396
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60374: LD_ADDR_VAR 0 11
60378: PUSH
60379: LD_VAR 0 4
60383: PPUSH
60384: LD_INT 4
60386: PPUSH
60387: CALL 49595 0 2
60391: PUSH
60392: LD_INT 1
60394: ARRAY
60395: ST_TO_ADDR
// if eng > 4 then
60396: LD_VAR 0 6
60400: PUSH
60401: LD_INT 4
60403: GREATER
60404: IFFALSE 60450
// for i = eng downto 4 do
60406: LD_ADDR_VAR 0 3
60410: PUSH
60411: DOUBLE
60412: LD_VAR 0 6
60416: INC
60417: ST_TO_ADDR
60418: LD_INT 4
60420: PUSH
60421: FOR_DOWNTO
60422: IFFALSE 60448
// eng := eng diff eng [ i ] ;
60424: LD_ADDR_VAR 0 6
60428: PUSH
60429: LD_VAR 0 6
60433: PUSH
60434: LD_VAR 0 6
60438: PUSH
60439: LD_VAR 0 3
60443: ARRAY
60444: DIFF
60445: ST_TO_ADDR
60446: GO 60421
60448: POP
60449: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60450: LD_ADDR_VAR 0 4
60454: PUSH
60455: LD_VAR 0 4
60459: PUSH
60460: LD_VAR 0 5
60464: PUSH
60465: LD_VAR 0 6
60469: UNION
60470: PUSH
60471: LD_VAR 0 7
60475: UNION
60476: PUSH
60477: LD_VAR 0 8
60481: UNION
60482: DIFF
60483: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60484: LD_ADDR_VAR 0 13
60488: PUSH
60489: LD_EXP 50
60493: PUSH
60494: LD_VAR 0 1
60498: ARRAY
60499: PPUSH
60500: LD_INT 2
60502: PUSH
60503: LD_INT 30
60505: PUSH
60506: LD_INT 32
60508: PUSH
60509: EMPTY
60510: LIST
60511: LIST
60512: PUSH
60513: LD_INT 30
60515: PUSH
60516: LD_INT 31
60518: PUSH
60519: EMPTY
60520: LIST
60521: LIST
60522: PUSH
60523: EMPTY
60524: LIST
60525: LIST
60526: LIST
60527: PPUSH
60528: CALL_OW 72
60532: PUSH
60533: LD_EXP 50
60537: PUSH
60538: LD_VAR 0 1
60542: ARRAY
60543: PPUSH
60544: LD_INT 2
60546: PUSH
60547: LD_INT 30
60549: PUSH
60550: LD_INT 4
60552: PUSH
60553: EMPTY
60554: LIST
60555: LIST
60556: PUSH
60557: LD_INT 30
60559: PUSH
60560: LD_INT 5
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PUSH
60567: EMPTY
60568: LIST
60569: LIST
60570: LIST
60571: PPUSH
60572: CALL_OW 72
60576: PUSH
60577: LD_INT 6
60579: MUL
60580: PLUS
60581: ST_TO_ADDR
// if bcount < tmp then
60582: LD_VAR 0 13
60586: PUSH
60587: LD_VAR 0 4
60591: LESS
60592: IFFALSE 60638
// for i = tmp downto bcount do
60594: LD_ADDR_VAR 0 3
60598: PUSH
60599: DOUBLE
60600: LD_VAR 0 4
60604: INC
60605: ST_TO_ADDR
60606: LD_VAR 0 13
60610: PUSH
60611: FOR_DOWNTO
60612: IFFALSE 60636
// tmp := Delete ( tmp , tmp ) ;
60614: LD_ADDR_VAR 0 4
60618: PUSH
60619: LD_VAR 0 4
60623: PPUSH
60624: LD_VAR 0 4
60628: PPUSH
60629: CALL_OW 3
60633: ST_TO_ADDR
60634: GO 60611
60636: POP
60637: POP
// result := [ tmp , 0 , 0 , p ] ;
60638: LD_ADDR_VAR 0 2
60642: PUSH
60643: LD_VAR 0 4
60647: PUSH
60648: LD_INT 0
60650: PUSH
60651: LD_INT 0
60653: PUSH
60654: LD_VAR 0 11
60658: PUSH
60659: EMPTY
60660: LIST
60661: LIST
60662: LIST
60663: LIST
60664: ST_TO_ADDR
// exit ;
60665: GO 63355
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60667: LD_EXP 50
60671: PUSH
60672: LD_VAR 0 1
60676: ARRAY
60677: PPUSH
60678: LD_INT 2
60680: PUSH
60681: LD_INT 30
60683: PUSH
60684: LD_INT 6
60686: PUSH
60687: EMPTY
60688: LIST
60689: LIST
60690: PUSH
60691: LD_INT 30
60693: PUSH
60694: LD_INT 7
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: PUSH
60701: LD_INT 30
60703: PUSH
60704: LD_INT 8
60706: PUSH
60707: EMPTY
60708: LIST
60709: LIST
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: LIST
60715: LIST
60716: PPUSH
60717: CALL_OW 72
60721: NOT
60722: PUSH
60723: LD_EXP 50
60727: PUSH
60728: LD_VAR 0 1
60732: ARRAY
60733: PPUSH
60734: LD_INT 30
60736: PUSH
60737: LD_INT 3
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PPUSH
60744: CALL_OW 72
60748: NOT
60749: AND
60750: IFFALSE 60822
// begin if eng = tmp then
60752: LD_VAR 0 6
60756: PUSH
60757: LD_VAR 0 4
60761: EQUAL
60762: IFFALSE 60766
// exit ;
60764: GO 63355
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60766: LD_ADDR_EXP 92
60770: PUSH
60771: LD_EXP 92
60775: PPUSH
60776: LD_VAR 0 1
60780: PPUSH
60781: LD_INT 1
60783: PPUSH
60784: CALL_OW 1
60788: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60789: LD_ADDR_VAR 0 2
60793: PUSH
60794: LD_INT 0
60796: PUSH
60797: LD_VAR 0 4
60801: PUSH
60802: LD_VAR 0 6
60806: DIFF
60807: PUSH
60808: LD_INT 0
60810: PUSH
60811: LD_INT 0
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: LIST
60818: LIST
60819: ST_TO_ADDR
// exit ;
60820: GO 63355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60822: LD_EXP 77
60826: PUSH
60827: LD_EXP 76
60831: PUSH
60832: LD_VAR 0 1
60836: ARRAY
60837: ARRAY
60838: PUSH
60839: LD_EXP 50
60843: PUSH
60844: LD_VAR 0 1
60848: ARRAY
60849: PPUSH
60850: LD_INT 2
60852: PUSH
60853: LD_INT 30
60855: PUSH
60856: LD_INT 6
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PUSH
60863: LD_INT 30
60865: PUSH
60866: LD_INT 7
60868: PUSH
60869: EMPTY
60870: LIST
60871: LIST
60872: PUSH
60873: LD_INT 30
60875: PUSH
60876: LD_INT 8
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: PPUSH
60889: CALL_OW 72
60893: AND
60894: PUSH
60895: LD_EXP 50
60899: PUSH
60900: LD_VAR 0 1
60904: ARRAY
60905: PPUSH
60906: LD_INT 30
60908: PUSH
60909: LD_INT 3
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: PPUSH
60916: CALL_OW 72
60920: NOT
60921: AND
60922: IFFALSE 61136
// begin if sci >= 6 then
60924: LD_VAR 0 8
60928: PUSH
60929: LD_INT 6
60931: GREATEREQUAL
60932: IFFALSE 60936
// exit ;
60934: GO 63355
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60936: LD_ADDR_EXP 92
60940: PUSH
60941: LD_EXP 92
60945: PPUSH
60946: LD_VAR 0 1
60950: PPUSH
60951: LD_INT 2
60953: PPUSH
60954: CALL_OW 1
60958: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60959: LD_ADDR_VAR 0 9
60963: PUSH
60964: LD_VAR 0 4
60968: PUSH
60969: LD_VAR 0 8
60973: DIFF
60974: PPUSH
60975: LD_INT 4
60977: PPUSH
60978: CALL 49595 0 2
60982: ST_TO_ADDR
// p := [ ] ;
60983: LD_ADDR_VAR 0 11
60987: PUSH
60988: EMPTY
60989: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60990: LD_VAR 0 8
60994: PUSH
60995: LD_INT 6
60997: LESS
60998: PUSH
60999: LD_VAR 0 9
61003: PUSH
61004: LD_INT 6
61006: GREATER
61007: AND
61008: IFFALSE 61089
// begin for i = 1 to 6 - sci do
61010: LD_ADDR_VAR 0 3
61014: PUSH
61015: DOUBLE
61016: LD_INT 1
61018: DEC
61019: ST_TO_ADDR
61020: LD_INT 6
61022: PUSH
61023: LD_VAR 0 8
61027: MINUS
61028: PUSH
61029: FOR_TO
61030: IFFALSE 61085
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61032: LD_ADDR_VAR 0 11
61036: PUSH
61037: LD_VAR 0 11
61041: PPUSH
61042: LD_VAR 0 11
61046: PUSH
61047: LD_INT 1
61049: PLUS
61050: PPUSH
61051: LD_VAR 0 9
61055: PUSH
61056: LD_INT 1
61058: ARRAY
61059: PPUSH
61060: CALL_OW 2
61064: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61065: LD_ADDR_VAR 0 9
61069: PUSH
61070: LD_VAR 0 9
61074: PPUSH
61075: LD_INT 1
61077: PPUSH
61078: CALL_OW 3
61082: ST_TO_ADDR
// end ;
61083: GO 61029
61085: POP
61086: POP
// end else
61087: GO 61109
// if sort then
61089: LD_VAR 0 9
61093: IFFALSE 61109
// p := sort [ 1 ] ;
61095: LD_ADDR_VAR 0 11
61099: PUSH
61100: LD_VAR 0 9
61104: PUSH
61105: LD_INT 1
61107: ARRAY
61108: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61109: LD_ADDR_VAR 0 2
61113: PUSH
61114: LD_INT 0
61116: PUSH
61117: LD_INT 0
61119: PUSH
61120: LD_INT 0
61122: PUSH
61123: LD_VAR 0 11
61127: PUSH
61128: EMPTY
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: ST_TO_ADDR
// exit ;
61134: GO 63355
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61136: LD_EXP 77
61140: PUSH
61141: LD_EXP 76
61145: PUSH
61146: LD_VAR 0 1
61150: ARRAY
61151: ARRAY
61152: PUSH
61153: LD_EXP 50
61157: PUSH
61158: LD_VAR 0 1
61162: ARRAY
61163: PPUSH
61164: LD_INT 2
61166: PUSH
61167: LD_INT 30
61169: PUSH
61170: LD_INT 6
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: PUSH
61177: LD_INT 30
61179: PUSH
61180: LD_INT 7
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PUSH
61187: LD_INT 30
61189: PUSH
61190: LD_INT 8
61192: PUSH
61193: EMPTY
61194: LIST
61195: LIST
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: PPUSH
61203: CALL_OW 72
61207: AND
61208: PUSH
61209: LD_EXP 50
61213: PUSH
61214: LD_VAR 0 1
61218: ARRAY
61219: PPUSH
61220: LD_INT 30
61222: PUSH
61223: LD_INT 3
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PPUSH
61230: CALL_OW 72
61234: AND
61235: IFFALSE 61969
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61237: LD_ADDR_EXP 92
61241: PUSH
61242: LD_EXP 92
61246: PPUSH
61247: LD_VAR 0 1
61251: PPUSH
61252: LD_INT 3
61254: PPUSH
61255: CALL_OW 1
61259: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61260: LD_ADDR_VAR 0 2
61264: PUSH
61265: LD_INT 0
61267: PUSH
61268: LD_INT 0
61270: PUSH
61271: LD_INT 0
61273: PUSH
61274: LD_INT 0
61276: PUSH
61277: EMPTY
61278: LIST
61279: LIST
61280: LIST
61281: LIST
61282: ST_TO_ADDR
// if not eng then
61283: LD_VAR 0 6
61287: NOT
61288: IFFALSE 61351
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61290: LD_ADDR_VAR 0 11
61294: PUSH
61295: LD_VAR 0 4
61299: PPUSH
61300: LD_INT 2
61302: PPUSH
61303: CALL 49595 0 2
61307: PUSH
61308: LD_INT 1
61310: ARRAY
61311: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61312: LD_ADDR_VAR 0 2
61316: PUSH
61317: LD_VAR 0 2
61321: PPUSH
61322: LD_INT 2
61324: PPUSH
61325: LD_VAR 0 11
61329: PPUSH
61330: CALL_OW 1
61334: ST_TO_ADDR
// tmp := tmp diff p ;
61335: LD_ADDR_VAR 0 4
61339: PUSH
61340: LD_VAR 0 4
61344: PUSH
61345: LD_VAR 0 11
61349: DIFF
61350: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61351: LD_VAR 0 4
61355: PUSH
61356: LD_VAR 0 8
61360: PUSH
61361: LD_INT 6
61363: LESS
61364: AND
61365: IFFALSE 61553
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61367: LD_ADDR_VAR 0 9
61371: PUSH
61372: LD_VAR 0 4
61376: PUSH
61377: LD_VAR 0 8
61381: PUSH
61382: LD_VAR 0 7
61386: UNION
61387: DIFF
61388: PPUSH
61389: LD_INT 4
61391: PPUSH
61392: CALL 49595 0 2
61396: ST_TO_ADDR
// p := [ ] ;
61397: LD_ADDR_VAR 0 11
61401: PUSH
61402: EMPTY
61403: ST_TO_ADDR
// if sort then
61404: LD_VAR 0 9
61408: IFFALSE 61524
// for i = 1 to 6 - sci do
61410: LD_ADDR_VAR 0 3
61414: PUSH
61415: DOUBLE
61416: LD_INT 1
61418: DEC
61419: ST_TO_ADDR
61420: LD_INT 6
61422: PUSH
61423: LD_VAR 0 8
61427: MINUS
61428: PUSH
61429: FOR_TO
61430: IFFALSE 61522
// begin if i = sort then
61432: LD_VAR 0 3
61436: PUSH
61437: LD_VAR 0 9
61441: EQUAL
61442: IFFALSE 61446
// break ;
61444: GO 61522
// if GetClass ( i ) = 4 then
61446: LD_VAR 0 3
61450: PPUSH
61451: CALL_OW 257
61455: PUSH
61456: LD_INT 4
61458: EQUAL
61459: IFFALSE 61463
// continue ;
61461: GO 61429
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61463: LD_ADDR_VAR 0 11
61467: PUSH
61468: LD_VAR 0 11
61472: PPUSH
61473: LD_VAR 0 11
61477: PUSH
61478: LD_INT 1
61480: PLUS
61481: PPUSH
61482: LD_VAR 0 9
61486: PUSH
61487: LD_VAR 0 3
61491: ARRAY
61492: PPUSH
61493: CALL_OW 2
61497: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61498: LD_ADDR_VAR 0 4
61502: PUSH
61503: LD_VAR 0 4
61507: PUSH
61508: LD_VAR 0 9
61512: PUSH
61513: LD_VAR 0 3
61517: ARRAY
61518: DIFF
61519: ST_TO_ADDR
// end ;
61520: GO 61429
61522: POP
61523: POP
// if p then
61524: LD_VAR 0 11
61528: IFFALSE 61553
// result := Replace ( result , 4 , p ) ;
61530: LD_ADDR_VAR 0 2
61534: PUSH
61535: LD_VAR 0 2
61539: PPUSH
61540: LD_INT 4
61542: PPUSH
61543: LD_VAR 0 11
61547: PPUSH
61548: CALL_OW 1
61552: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61553: LD_VAR 0 4
61557: PUSH
61558: LD_VAR 0 7
61562: PUSH
61563: LD_INT 6
61565: LESS
61566: AND
61567: IFFALSE 61755
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61569: LD_ADDR_VAR 0 9
61573: PUSH
61574: LD_VAR 0 4
61578: PUSH
61579: LD_VAR 0 8
61583: PUSH
61584: LD_VAR 0 7
61588: UNION
61589: DIFF
61590: PPUSH
61591: LD_INT 3
61593: PPUSH
61594: CALL 49595 0 2
61598: ST_TO_ADDR
// p := [ ] ;
61599: LD_ADDR_VAR 0 11
61603: PUSH
61604: EMPTY
61605: ST_TO_ADDR
// if sort then
61606: LD_VAR 0 9
61610: IFFALSE 61726
// for i = 1 to 6 - mech do
61612: LD_ADDR_VAR 0 3
61616: PUSH
61617: DOUBLE
61618: LD_INT 1
61620: DEC
61621: ST_TO_ADDR
61622: LD_INT 6
61624: PUSH
61625: LD_VAR 0 7
61629: MINUS
61630: PUSH
61631: FOR_TO
61632: IFFALSE 61724
// begin if i = sort then
61634: LD_VAR 0 3
61638: PUSH
61639: LD_VAR 0 9
61643: EQUAL
61644: IFFALSE 61648
// break ;
61646: GO 61724
// if GetClass ( i ) = 3 then
61648: LD_VAR 0 3
61652: PPUSH
61653: CALL_OW 257
61657: PUSH
61658: LD_INT 3
61660: EQUAL
61661: IFFALSE 61665
// continue ;
61663: GO 61631
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61665: LD_ADDR_VAR 0 11
61669: PUSH
61670: LD_VAR 0 11
61674: PPUSH
61675: LD_VAR 0 11
61679: PUSH
61680: LD_INT 1
61682: PLUS
61683: PPUSH
61684: LD_VAR 0 9
61688: PUSH
61689: LD_VAR 0 3
61693: ARRAY
61694: PPUSH
61695: CALL_OW 2
61699: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61700: LD_ADDR_VAR 0 4
61704: PUSH
61705: LD_VAR 0 4
61709: PUSH
61710: LD_VAR 0 9
61714: PUSH
61715: LD_VAR 0 3
61719: ARRAY
61720: DIFF
61721: ST_TO_ADDR
// end ;
61722: GO 61631
61724: POP
61725: POP
// if p then
61726: LD_VAR 0 11
61730: IFFALSE 61755
// result := Replace ( result , 3 , p ) ;
61732: LD_ADDR_VAR 0 2
61736: PUSH
61737: LD_VAR 0 2
61741: PPUSH
61742: LD_INT 3
61744: PPUSH
61745: LD_VAR 0 11
61749: PPUSH
61750: CALL_OW 1
61754: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61755: LD_VAR 0 4
61759: PUSH
61760: LD_INT 6
61762: GREATER
61763: PUSH
61764: LD_VAR 0 6
61768: PUSH
61769: LD_INT 6
61771: LESS
61772: AND
61773: IFFALSE 61967
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61775: LD_ADDR_VAR 0 9
61779: PUSH
61780: LD_VAR 0 4
61784: PUSH
61785: LD_VAR 0 8
61789: PUSH
61790: LD_VAR 0 7
61794: UNION
61795: PUSH
61796: LD_VAR 0 6
61800: UNION
61801: DIFF
61802: PPUSH
61803: LD_INT 2
61805: PPUSH
61806: CALL 49595 0 2
61810: ST_TO_ADDR
// p := [ ] ;
61811: LD_ADDR_VAR 0 11
61815: PUSH
61816: EMPTY
61817: ST_TO_ADDR
// if sort then
61818: LD_VAR 0 9
61822: IFFALSE 61938
// for i = 1 to 6 - eng do
61824: LD_ADDR_VAR 0 3
61828: PUSH
61829: DOUBLE
61830: LD_INT 1
61832: DEC
61833: ST_TO_ADDR
61834: LD_INT 6
61836: PUSH
61837: LD_VAR 0 6
61841: MINUS
61842: PUSH
61843: FOR_TO
61844: IFFALSE 61936
// begin if i = sort then
61846: LD_VAR 0 3
61850: PUSH
61851: LD_VAR 0 9
61855: EQUAL
61856: IFFALSE 61860
// break ;
61858: GO 61936
// if GetClass ( i ) = 2 then
61860: LD_VAR 0 3
61864: PPUSH
61865: CALL_OW 257
61869: PUSH
61870: LD_INT 2
61872: EQUAL
61873: IFFALSE 61877
// continue ;
61875: GO 61843
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61877: LD_ADDR_VAR 0 11
61881: PUSH
61882: LD_VAR 0 11
61886: PPUSH
61887: LD_VAR 0 11
61891: PUSH
61892: LD_INT 1
61894: PLUS
61895: PPUSH
61896: LD_VAR 0 9
61900: PUSH
61901: LD_VAR 0 3
61905: ARRAY
61906: PPUSH
61907: CALL_OW 2
61911: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61912: LD_ADDR_VAR 0 4
61916: PUSH
61917: LD_VAR 0 4
61921: PUSH
61922: LD_VAR 0 9
61926: PUSH
61927: LD_VAR 0 3
61931: ARRAY
61932: DIFF
61933: ST_TO_ADDR
// end ;
61934: GO 61843
61936: POP
61937: POP
// if p then
61938: LD_VAR 0 11
61942: IFFALSE 61967
// result := Replace ( result , 2 , p ) ;
61944: LD_ADDR_VAR 0 2
61948: PUSH
61949: LD_VAR 0 2
61953: PPUSH
61954: LD_INT 2
61956: PPUSH
61957: LD_VAR 0 11
61961: PPUSH
61962: CALL_OW 1
61966: ST_TO_ADDR
// end ; exit ;
61967: GO 63355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61969: LD_EXP 77
61973: PUSH
61974: LD_EXP 76
61978: PUSH
61979: LD_VAR 0 1
61983: ARRAY
61984: ARRAY
61985: NOT
61986: PUSH
61987: LD_EXP 50
61991: PUSH
61992: LD_VAR 0 1
61996: ARRAY
61997: PPUSH
61998: LD_INT 30
62000: PUSH
62001: LD_INT 3
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PPUSH
62008: CALL_OW 72
62012: AND
62013: PUSH
62014: LD_EXP 55
62018: PUSH
62019: LD_VAR 0 1
62023: ARRAY
62024: AND
62025: IFFALSE 62633
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62027: LD_ADDR_EXP 92
62031: PUSH
62032: LD_EXP 92
62036: PPUSH
62037: LD_VAR 0 1
62041: PPUSH
62042: LD_INT 5
62044: PPUSH
62045: CALL_OW 1
62049: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62050: LD_ADDR_VAR 0 2
62054: PUSH
62055: LD_INT 0
62057: PUSH
62058: LD_INT 0
62060: PUSH
62061: LD_INT 0
62063: PUSH
62064: LD_INT 0
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: LIST
62071: LIST
62072: ST_TO_ADDR
// if sci > 1 then
62073: LD_VAR 0 8
62077: PUSH
62078: LD_INT 1
62080: GREATER
62081: IFFALSE 62109
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62083: LD_ADDR_VAR 0 4
62087: PUSH
62088: LD_VAR 0 4
62092: PUSH
62093: LD_VAR 0 8
62097: PUSH
62098: LD_VAR 0 8
62102: PUSH
62103: LD_INT 1
62105: ARRAY
62106: DIFF
62107: DIFF
62108: ST_TO_ADDR
// if tmp and not sci then
62109: LD_VAR 0 4
62113: PUSH
62114: LD_VAR 0 8
62118: NOT
62119: AND
62120: IFFALSE 62189
// begin sort := SortBySkill ( tmp , 4 ) ;
62122: LD_ADDR_VAR 0 9
62126: PUSH
62127: LD_VAR 0 4
62131: PPUSH
62132: LD_INT 4
62134: PPUSH
62135: CALL 49595 0 2
62139: ST_TO_ADDR
// if sort then
62140: LD_VAR 0 9
62144: IFFALSE 62160
// p := sort [ 1 ] ;
62146: LD_ADDR_VAR 0 11
62150: PUSH
62151: LD_VAR 0 9
62155: PUSH
62156: LD_INT 1
62158: ARRAY
62159: ST_TO_ADDR
// if p then
62160: LD_VAR 0 11
62164: IFFALSE 62189
// result := Replace ( result , 4 , p ) ;
62166: LD_ADDR_VAR 0 2
62170: PUSH
62171: LD_VAR 0 2
62175: PPUSH
62176: LD_INT 4
62178: PPUSH
62179: LD_VAR 0 11
62183: PPUSH
62184: CALL_OW 1
62188: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62189: LD_ADDR_VAR 0 4
62193: PUSH
62194: LD_VAR 0 4
62198: PUSH
62199: LD_VAR 0 7
62203: DIFF
62204: ST_TO_ADDR
// if tmp and mech < 6 then
62205: LD_VAR 0 4
62209: PUSH
62210: LD_VAR 0 7
62214: PUSH
62215: LD_INT 6
62217: LESS
62218: AND
62219: IFFALSE 62407
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62221: LD_ADDR_VAR 0 9
62225: PUSH
62226: LD_VAR 0 4
62230: PUSH
62231: LD_VAR 0 8
62235: PUSH
62236: LD_VAR 0 7
62240: UNION
62241: DIFF
62242: PPUSH
62243: LD_INT 3
62245: PPUSH
62246: CALL 49595 0 2
62250: ST_TO_ADDR
// p := [ ] ;
62251: LD_ADDR_VAR 0 11
62255: PUSH
62256: EMPTY
62257: ST_TO_ADDR
// if sort then
62258: LD_VAR 0 9
62262: IFFALSE 62378
// for i = 1 to 6 - mech do
62264: LD_ADDR_VAR 0 3
62268: PUSH
62269: DOUBLE
62270: LD_INT 1
62272: DEC
62273: ST_TO_ADDR
62274: LD_INT 6
62276: PUSH
62277: LD_VAR 0 7
62281: MINUS
62282: PUSH
62283: FOR_TO
62284: IFFALSE 62376
// begin if i = sort then
62286: LD_VAR 0 3
62290: PUSH
62291: LD_VAR 0 9
62295: EQUAL
62296: IFFALSE 62300
// break ;
62298: GO 62376
// if GetClass ( i ) = 3 then
62300: LD_VAR 0 3
62304: PPUSH
62305: CALL_OW 257
62309: PUSH
62310: LD_INT 3
62312: EQUAL
62313: IFFALSE 62317
// continue ;
62315: GO 62283
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62317: LD_ADDR_VAR 0 11
62321: PUSH
62322: LD_VAR 0 11
62326: PPUSH
62327: LD_VAR 0 11
62331: PUSH
62332: LD_INT 1
62334: PLUS
62335: PPUSH
62336: LD_VAR 0 9
62340: PUSH
62341: LD_VAR 0 3
62345: ARRAY
62346: PPUSH
62347: CALL_OW 2
62351: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62352: LD_ADDR_VAR 0 4
62356: PUSH
62357: LD_VAR 0 4
62361: PUSH
62362: LD_VAR 0 9
62366: PUSH
62367: LD_VAR 0 3
62371: ARRAY
62372: DIFF
62373: ST_TO_ADDR
// end ;
62374: GO 62283
62376: POP
62377: POP
// if p then
62378: LD_VAR 0 11
62382: IFFALSE 62407
// result := Replace ( result , 3 , p ) ;
62384: LD_ADDR_VAR 0 2
62388: PUSH
62389: LD_VAR 0 2
62393: PPUSH
62394: LD_INT 3
62396: PPUSH
62397: LD_VAR 0 11
62401: PPUSH
62402: CALL_OW 1
62406: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62407: LD_ADDR_VAR 0 4
62411: PUSH
62412: LD_VAR 0 4
62416: PUSH
62417: LD_VAR 0 6
62421: DIFF
62422: ST_TO_ADDR
// if tmp and eng < 6 then
62423: LD_VAR 0 4
62427: PUSH
62428: LD_VAR 0 6
62432: PUSH
62433: LD_INT 6
62435: LESS
62436: AND
62437: IFFALSE 62631
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62439: LD_ADDR_VAR 0 9
62443: PUSH
62444: LD_VAR 0 4
62448: PUSH
62449: LD_VAR 0 8
62453: PUSH
62454: LD_VAR 0 7
62458: UNION
62459: PUSH
62460: LD_VAR 0 6
62464: UNION
62465: DIFF
62466: PPUSH
62467: LD_INT 2
62469: PPUSH
62470: CALL 49595 0 2
62474: ST_TO_ADDR
// p := [ ] ;
62475: LD_ADDR_VAR 0 11
62479: PUSH
62480: EMPTY
62481: ST_TO_ADDR
// if sort then
62482: LD_VAR 0 9
62486: IFFALSE 62602
// for i = 1 to 6 - eng do
62488: LD_ADDR_VAR 0 3
62492: PUSH
62493: DOUBLE
62494: LD_INT 1
62496: DEC
62497: ST_TO_ADDR
62498: LD_INT 6
62500: PUSH
62501: LD_VAR 0 6
62505: MINUS
62506: PUSH
62507: FOR_TO
62508: IFFALSE 62600
// begin if i = sort then
62510: LD_VAR 0 3
62514: PUSH
62515: LD_VAR 0 9
62519: EQUAL
62520: IFFALSE 62524
// break ;
62522: GO 62600
// if GetClass ( i ) = 2 then
62524: LD_VAR 0 3
62528: PPUSH
62529: CALL_OW 257
62533: PUSH
62534: LD_INT 2
62536: EQUAL
62537: IFFALSE 62541
// continue ;
62539: GO 62507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62541: LD_ADDR_VAR 0 11
62545: PUSH
62546: LD_VAR 0 11
62550: PPUSH
62551: LD_VAR 0 11
62555: PUSH
62556: LD_INT 1
62558: PLUS
62559: PPUSH
62560: LD_VAR 0 9
62564: PUSH
62565: LD_VAR 0 3
62569: ARRAY
62570: PPUSH
62571: CALL_OW 2
62575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62576: LD_ADDR_VAR 0 4
62580: PUSH
62581: LD_VAR 0 4
62585: PUSH
62586: LD_VAR 0 9
62590: PUSH
62591: LD_VAR 0 3
62595: ARRAY
62596: DIFF
62597: ST_TO_ADDR
// end ;
62598: GO 62507
62600: POP
62601: POP
// if p then
62602: LD_VAR 0 11
62606: IFFALSE 62631
// result := Replace ( result , 2 , p ) ;
62608: LD_ADDR_VAR 0 2
62612: PUSH
62613: LD_VAR 0 2
62617: PPUSH
62618: LD_INT 2
62620: PPUSH
62621: LD_VAR 0 11
62625: PPUSH
62626: CALL_OW 1
62630: ST_TO_ADDR
// end ; exit ;
62631: GO 63355
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62633: LD_EXP 77
62637: PUSH
62638: LD_EXP 76
62642: PUSH
62643: LD_VAR 0 1
62647: ARRAY
62648: ARRAY
62649: NOT
62650: PUSH
62651: LD_EXP 50
62655: PUSH
62656: LD_VAR 0 1
62660: ARRAY
62661: PPUSH
62662: LD_INT 30
62664: PUSH
62665: LD_INT 3
62667: PUSH
62668: EMPTY
62669: LIST
62670: LIST
62671: PPUSH
62672: CALL_OW 72
62676: AND
62677: PUSH
62678: LD_EXP 55
62682: PUSH
62683: LD_VAR 0 1
62687: ARRAY
62688: NOT
62689: AND
62690: IFFALSE 63355
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62692: LD_ADDR_EXP 92
62696: PUSH
62697: LD_EXP 92
62701: PPUSH
62702: LD_VAR 0 1
62706: PPUSH
62707: LD_INT 6
62709: PPUSH
62710: CALL_OW 1
62714: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62715: LD_ADDR_VAR 0 2
62719: PUSH
62720: LD_INT 0
62722: PUSH
62723: LD_INT 0
62725: PUSH
62726: LD_INT 0
62728: PUSH
62729: LD_INT 0
62731: PUSH
62732: EMPTY
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: ST_TO_ADDR
// if sci >= 1 then
62738: LD_VAR 0 8
62742: PUSH
62743: LD_INT 1
62745: GREATEREQUAL
62746: IFFALSE 62768
// tmp := tmp diff sci [ 1 ] ;
62748: LD_ADDR_VAR 0 4
62752: PUSH
62753: LD_VAR 0 4
62757: PUSH
62758: LD_VAR 0 8
62762: PUSH
62763: LD_INT 1
62765: ARRAY
62766: DIFF
62767: ST_TO_ADDR
// if tmp and not sci then
62768: LD_VAR 0 4
62772: PUSH
62773: LD_VAR 0 8
62777: NOT
62778: AND
62779: IFFALSE 62848
// begin sort := SortBySkill ( tmp , 4 ) ;
62781: LD_ADDR_VAR 0 9
62785: PUSH
62786: LD_VAR 0 4
62790: PPUSH
62791: LD_INT 4
62793: PPUSH
62794: CALL 49595 0 2
62798: ST_TO_ADDR
// if sort then
62799: LD_VAR 0 9
62803: IFFALSE 62819
// p := sort [ 1 ] ;
62805: LD_ADDR_VAR 0 11
62809: PUSH
62810: LD_VAR 0 9
62814: PUSH
62815: LD_INT 1
62817: ARRAY
62818: ST_TO_ADDR
// if p then
62819: LD_VAR 0 11
62823: IFFALSE 62848
// result := Replace ( result , 4 , p ) ;
62825: LD_ADDR_VAR 0 2
62829: PUSH
62830: LD_VAR 0 2
62834: PPUSH
62835: LD_INT 4
62837: PPUSH
62838: LD_VAR 0 11
62842: PPUSH
62843: CALL_OW 1
62847: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62848: LD_ADDR_VAR 0 4
62852: PUSH
62853: LD_VAR 0 4
62857: PUSH
62858: LD_VAR 0 7
62862: DIFF
62863: ST_TO_ADDR
// if tmp and mech < 6 then
62864: LD_VAR 0 4
62868: PUSH
62869: LD_VAR 0 7
62873: PUSH
62874: LD_INT 6
62876: LESS
62877: AND
62878: IFFALSE 63060
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62880: LD_ADDR_VAR 0 9
62884: PUSH
62885: LD_VAR 0 4
62889: PUSH
62890: LD_VAR 0 7
62894: DIFF
62895: PPUSH
62896: LD_INT 3
62898: PPUSH
62899: CALL 49595 0 2
62903: ST_TO_ADDR
// p := [ ] ;
62904: LD_ADDR_VAR 0 11
62908: PUSH
62909: EMPTY
62910: ST_TO_ADDR
// if sort then
62911: LD_VAR 0 9
62915: IFFALSE 63031
// for i = 1 to 6 - mech do
62917: LD_ADDR_VAR 0 3
62921: PUSH
62922: DOUBLE
62923: LD_INT 1
62925: DEC
62926: ST_TO_ADDR
62927: LD_INT 6
62929: PUSH
62930: LD_VAR 0 7
62934: MINUS
62935: PUSH
62936: FOR_TO
62937: IFFALSE 63029
// begin if i = sort then
62939: LD_VAR 0 3
62943: PUSH
62944: LD_VAR 0 9
62948: EQUAL
62949: IFFALSE 62953
// break ;
62951: GO 63029
// if GetClass ( i ) = 3 then
62953: LD_VAR 0 3
62957: PPUSH
62958: CALL_OW 257
62962: PUSH
62963: LD_INT 3
62965: EQUAL
62966: IFFALSE 62970
// continue ;
62968: GO 62936
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62970: LD_ADDR_VAR 0 11
62974: PUSH
62975: LD_VAR 0 11
62979: PPUSH
62980: LD_VAR 0 11
62984: PUSH
62985: LD_INT 1
62987: PLUS
62988: PPUSH
62989: LD_VAR 0 9
62993: PUSH
62994: LD_VAR 0 3
62998: ARRAY
62999: PPUSH
63000: CALL_OW 2
63004: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63005: LD_ADDR_VAR 0 4
63009: PUSH
63010: LD_VAR 0 4
63014: PUSH
63015: LD_VAR 0 9
63019: PUSH
63020: LD_VAR 0 3
63024: ARRAY
63025: DIFF
63026: ST_TO_ADDR
// end ;
63027: GO 62936
63029: POP
63030: POP
// if p then
63031: LD_VAR 0 11
63035: IFFALSE 63060
// result := Replace ( result , 3 , p ) ;
63037: LD_ADDR_VAR 0 2
63041: PUSH
63042: LD_VAR 0 2
63046: PPUSH
63047: LD_INT 3
63049: PPUSH
63050: LD_VAR 0 11
63054: PPUSH
63055: CALL_OW 1
63059: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63060: LD_ADDR_VAR 0 4
63064: PUSH
63065: LD_VAR 0 4
63069: PUSH
63070: LD_VAR 0 6
63074: DIFF
63075: ST_TO_ADDR
// if tmp and eng < 4 then
63076: LD_VAR 0 4
63080: PUSH
63081: LD_VAR 0 6
63085: PUSH
63086: LD_INT 4
63088: LESS
63089: AND
63090: IFFALSE 63280
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63092: LD_ADDR_VAR 0 9
63096: PUSH
63097: LD_VAR 0 4
63101: PUSH
63102: LD_VAR 0 7
63106: PUSH
63107: LD_VAR 0 6
63111: UNION
63112: DIFF
63113: PPUSH
63114: LD_INT 2
63116: PPUSH
63117: CALL 49595 0 2
63121: ST_TO_ADDR
// p := [ ] ;
63122: LD_ADDR_VAR 0 11
63126: PUSH
63127: EMPTY
63128: ST_TO_ADDR
// if sort then
63129: LD_VAR 0 9
63133: IFFALSE 63249
// for i = 1 to 4 - eng do
63135: LD_ADDR_VAR 0 3
63139: PUSH
63140: DOUBLE
63141: LD_INT 1
63143: DEC
63144: ST_TO_ADDR
63145: LD_INT 4
63147: PUSH
63148: LD_VAR 0 6
63152: MINUS
63153: PUSH
63154: FOR_TO
63155: IFFALSE 63247
// begin if i = sort then
63157: LD_VAR 0 3
63161: PUSH
63162: LD_VAR 0 9
63166: EQUAL
63167: IFFALSE 63171
// break ;
63169: GO 63247
// if GetClass ( i ) = 2 then
63171: LD_VAR 0 3
63175: PPUSH
63176: CALL_OW 257
63180: PUSH
63181: LD_INT 2
63183: EQUAL
63184: IFFALSE 63188
// continue ;
63186: GO 63154
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63188: LD_ADDR_VAR 0 11
63192: PUSH
63193: LD_VAR 0 11
63197: PPUSH
63198: LD_VAR 0 11
63202: PUSH
63203: LD_INT 1
63205: PLUS
63206: PPUSH
63207: LD_VAR 0 9
63211: PUSH
63212: LD_VAR 0 3
63216: ARRAY
63217: PPUSH
63218: CALL_OW 2
63222: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63223: LD_ADDR_VAR 0 4
63227: PUSH
63228: LD_VAR 0 4
63232: PUSH
63233: LD_VAR 0 9
63237: PUSH
63238: LD_VAR 0 3
63242: ARRAY
63243: DIFF
63244: ST_TO_ADDR
// end ;
63245: GO 63154
63247: POP
63248: POP
// if p then
63249: LD_VAR 0 11
63253: IFFALSE 63278
// result := Replace ( result , 2 , p ) ;
63255: LD_ADDR_VAR 0 2
63259: PUSH
63260: LD_VAR 0 2
63264: PPUSH
63265: LD_INT 2
63267: PPUSH
63268: LD_VAR 0 11
63272: PPUSH
63273: CALL_OW 1
63277: ST_TO_ADDR
// end else
63278: GO 63324
// for i = eng downto 5 do
63280: LD_ADDR_VAR 0 3
63284: PUSH
63285: DOUBLE
63286: LD_VAR 0 6
63290: INC
63291: ST_TO_ADDR
63292: LD_INT 5
63294: PUSH
63295: FOR_DOWNTO
63296: IFFALSE 63322
// tmp := tmp union eng [ i ] ;
63298: LD_ADDR_VAR 0 4
63302: PUSH
63303: LD_VAR 0 4
63307: PUSH
63308: LD_VAR 0 6
63312: PUSH
63313: LD_VAR 0 3
63317: ARRAY
63318: UNION
63319: ST_TO_ADDR
63320: GO 63295
63322: POP
63323: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63324: LD_ADDR_VAR 0 2
63328: PUSH
63329: LD_VAR 0 2
63333: PPUSH
63334: LD_INT 1
63336: PPUSH
63337: LD_VAR 0 4
63341: PUSH
63342: LD_VAR 0 5
63346: DIFF
63347: PPUSH
63348: CALL_OW 1
63352: ST_TO_ADDR
// exit ;
63353: GO 63355
// end ; end ;
63355: LD_VAR 0 2
63359: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63360: LD_INT 0
63362: PPUSH
63363: PPUSH
63364: PPUSH
// if not mc_bases then
63365: LD_EXP 50
63369: NOT
63370: IFFALSE 63374
// exit ;
63372: GO 63516
// for i = 1 to mc_bases do
63374: LD_ADDR_VAR 0 2
63378: PUSH
63379: DOUBLE
63380: LD_INT 1
63382: DEC
63383: ST_TO_ADDR
63384: LD_EXP 50
63388: PUSH
63389: FOR_TO
63390: IFFALSE 63507
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63392: LD_ADDR_VAR 0 3
63396: PUSH
63397: LD_EXP 50
63401: PUSH
63402: LD_VAR 0 2
63406: ARRAY
63407: PPUSH
63408: LD_INT 21
63410: PUSH
63411: LD_INT 3
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: PUSH
63418: LD_INT 3
63420: PUSH
63421: LD_INT 2
63423: PUSH
63424: LD_INT 30
63426: PUSH
63427: LD_INT 29
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: LD_INT 30
63436: PUSH
63437: LD_INT 30
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: LIST
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PUSH
63453: LD_INT 3
63455: PUSH
63456: LD_INT 24
63458: PUSH
63459: LD_INT 1000
63461: PUSH
63462: EMPTY
63463: LIST
63464: LIST
63465: PUSH
63466: EMPTY
63467: LIST
63468: LIST
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: LIST
63474: PPUSH
63475: CALL_OW 72
63479: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63480: LD_ADDR_EXP 51
63484: PUSH
63485: LD_EXP 51
63489: PPUSH
63490: LD_VAR 0 2
63494: PPUSH
63495: LD_VAR 0 3
63499: PPUSH
63500: CALL_OW 1
63504: ST_TO_ADDR
// end ;
63505: GO 63389
63507: POP
63508: POP
// RaiseSailEvent ( 101 ) ;
63509: LD_INT 101
63511: PPUSH
63512: CALL_OW 427
// end ;
63516: LD_VAR 0 1
63520: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63521: LD_INT 0
63523: PPUSH
63524: PPUSH
63525: PPUSH
63526: PPUSH
63527: PPUSH
63528: PPUSH
63529: PPUSH
// if not mc_bases then
63530: LD_EXP 50
63534: NOT
63535: IFFALSE 63539
// exit ;
63537: GO 64101
// for i = 1 to mc_bases do
63539: LD_ADDR_VAR 0 2
63543: PUSH
63544: DOUBLE
63545: LD_INT 1
63547: DEC
63548: ST_TO_ADDR
63549: LD_EXP 50
63553: PUSH
63554: FOR_TO
63555: IFFALSE 64092
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63557: LD_ADDR_VAR 0 5
63561: PUSH
63562: LD_EXP 50
63566: PUSH
63567: LD_VAR 0 2
63571: ARRAY
63572: PUSH
63573: LD_EXP 79
63577: PUSH
63578: LD_VAR 0 2
63582: ARRAY
63583: UNION
63584: PPUSH
63585: LD_INT 21
63587: PUSH
63588: LD_INT 1
63590: PUSH
63591: EMPTY
63592: LIST
63593: LIST
63594: PUSH
63595: LD_INT 1
63597: PUSH
63598: LD_INT 3
63600: PUSH
63601: LD_INT 54
63603: PUSH
63604: EMPTY
63605: LIST
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: PUSH
63611: LD_INT 3
63613: PUSH
63614: LD_INT 24
63616: PUSH
63617: LD_INT 1000
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: LIST
63632: PUSH
63633: EMPTY
63634: LIST
63635: LIST
63636: PPUSH
63637: CALL_OW 72
63641: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63642: LD_ADDR_VAR 0 6
63646: PUSH
63647: LD_EXP 50
63651: PUSH
63652: LD_VAR 0 2
63656: ARRAY
63657: PPUSH
63658: LD_INT 21
63660: PUSH
63661: LD_INT 1
63663: PUSH
63664: EMPTY
63665: LIST
63666: LIST
63667: PUSH
63668: LD_INT 1
63670: PUSH
63671: LD_INT 3
63673: PUSH
63674: LD_INT 54
63676: PUSH
63677: EMPTY
63678: LIST
63679: PUSH
63680: EMPTY
63681: LIST
63682: LIST
63683: PUSH
63684: LD_INT 3
63686: PUSH
63687: LD_INT 24
63689: PUSH
63690: LD_INT 250
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PUSH
63701: EMPTY
63702: LIST
63703: LIST
63704: LIST
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PPUSH
63710: CALL_OW 72
63714: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63715: LD_ADDR_VAR 0 7
63719: PUSH
63720: LD_VAR 0 5
63724: PUSH
63725: LD_VAR 0 6
63729: DIFF
63730: ST_TO_ADDR
// if not need_heal_1 then
63731: LD_VAR 0 6
63735: NOT
63736: IFFALSE 63769
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63738: LD_ADDR_EXP 53
63742: PUSH
63743: LD_EXP 53
63747: PPUSH
63748: LD_VAR 0 2
63752: PUSH
63753: LD_INT 1
63755: PUSH
63756: EMPTY
63757: LIST
63758: LIST
63759: PPUSH
63760: EMPTY
63761: PPUSH
63762: CALL 18748 0 3
63766: ST_TO_ADDR
63767: GO 63839
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63769: LD_ADDR_EXP 53
63773: PUSH
63774: LD_EXP 53
63778: PPUSH
63779: LD_VAR 0 2
63783: PUSH
63784: LD_INT 1
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PPUSH
63791: LD_EXP 53
63795: PUSH
63796: LD_VAR 0 2
63800: ARRAY
63801: PUSH
63802: LD_INT 1
63804: ARRAY
63805: PPUSH
63806: LD_INT 3
63808: PUSH
63809: LD_INT 24
63811: PUSH
63812: LD_INT 1000
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PPUSH
63823: CALL_OW 72
63827: PUSH
63828: LD_VAR 0 6
63832: UNION
63833: PPUSH
63834: CALL 18748 0 3
63838: ST_TO_ADDR
// if not need_heal_2 then
63839: LD_VAR 0 7
63843: NOT
63844: IFFALSE 63877
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63846: LD_ADDR_EXP 53
63850: PUSH
63851: LD_EXP 53
63855: PPUSH
63856: LD_VAR 0 2
63860: PUSH
63861: LD_INT 2
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PPUSH
63868: EMPTY
63869: PPUSH
63870: CALL 18748 0 3
63874: ST_TO_ADDR
63875: GO 63909
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63877: LD_ADDR_EXP 53
63881: PUSH
63882: LD_EXP 53
63886: PPUSH
63887: LD_VAR 0 2
63891: PUSH
63892: LD_INT 2
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PPUSH
63899: LD_VAR 0 7
63903: PPUSH
63904: CALL 18748 0 3
63908: ST_TO_ADDR
// if need_heal_2 then
63909: LD_VAR 0 7
63913: IFFALSE 64074
// for j in need_heal_2 do
63915: LD_ADDR_VAR 0 3
63919: PUSH
63920: LD_VAR 0 7
63924: PUSH
63925: FOR_IN
63926: IFFALSE 64072
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63928: LD_ADDR_VAR 0 5
63932: PUSH
63933: LD_EXP 50
63937: PUSH
63938: LD_VAR 0 2
63942: ARRAY
63943: PPUSH
63944: LD_INT 2
63946: PUSH
63947: LD_INT 30
63949: PUSH
63950: LD_INT 6
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: PUSH
63957: LD_INT 30
63959: PUSH
63960: LD_INT 7
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PUSH
63967: LD_INT 30
63969: PUSH
63970: LD_INT 8
63972: PUSH
63973: EMPTY
63974: LIST
63975: LIST
63976: PUSH
63977: LD_INT 30
63979: PUSH
63980: LD_INT 0
63982: PUSH
63983: EMPTY
63984: LIST
63985: LIST
63986: PUSH
63987: LD_INT 30
63989: PUSH
63990: LD_INT 1
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PUSH
63997: EMPTY
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: LIST
64004: PPUSH
64005: CALL_OW 72
64009: ST_TO_ADDR
// if tmp then
64010: LD_VAR 0 5
64014: IFFALSE 64070
// begin k := NearestUnitToUnit ( tmp , j ) ;
64016: LD_ADDR_VAR 0 4
64020: PUSH
64021: LD_VAR 0 5
64025: PPUSH
64026: LD_VAR 0 3
64030: PPUSH
64031: CALL_OW 74
64035: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
64036: LD_VAR 0 3
64040: PPUSH
64041: LD_VAR 0 4
64045: PPUSH
64046: CALL_OW 296
64050: PUSH
64051: LD_INT 5
64053: GREATER
64054: IFFALSE 64070
// ComMoveToNearbyEntrance ( j , k ) ;
64056: LD_VAR 0 3
64060: PPUSH
64061: LD_VAR 0 4
64065: PPUSH
64066: CALL 51956 0 2
// end ; end ;
64070: GO 63925
64072: POP
64073: POP
// if not need_heal_1 and not need_heal_2 then
64074: LD_VAR 0 6
64078: NOT
64079: PUSH
64080: LD_VAR 0 7
64084: NOT
64085: AND
64086: IFFALSE 64090
// continue ;
64088: GO 63554
// end ;
64090: GO 63554
64092: POP
64093: POP
// RaiseSailEvent ( 102 ) ;
64094: LD_INT 102
64096: PPUSH
64097: CALL_OW 427
// end ;
64101: LD_VAR 0 1
64105: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
64106: LD_INT 0
64108: PPUSH
64109: PPUSH
64110: PPUSH
64111: PPUSH
64112: PPUSH
64113: PPUSH
64114: PPUSH
64115: PPUSH
// if not mc_bases then
64116: LD_EXP 50
64120: NOT
64121: IFFALSE 64125
// exit ;
64123: GO 65036
// for i = 1 to mc_bases do
64125: LD_ADDR_VAR 0 2
64129: PUSH
64130: DOUBLE
64131: LD_INT 1
64133: DEC
64134: ST_TO_ADDR
64135: LD_EXP 50
64139: PUSH
64140: FOR_TO
64141: IFFALSE 65034
// begin if not mc_building_need_repair [ i ] then
64143: LD_EXP 51
64147: PUSH
64148: LD_VAR 0 2
64152: ARRAY
64153: NOT
64154: IFFALSE 64339
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64156: LD_ADDR_VAR 0 6
64160: PUSH
64161: LD_EXP 69
64165: PUSH
64166: LD_VAR 0 2
64170: ARRAY
64171: PPUSH
64172: LD_INT 3
64174: PUSH
64175: LD_INT 24
64177: PUSH
64178: LD_INT 1000
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 2
64191: PUSH
64192: LD_INT 34
64194: PUSH
64195: LD_INT 13
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: LD_INT 34
64204: PUSH
64205: LD_INT 52
64207: PUSH
64208: EMPTY
64209: LIST
64210: LIST
64211: PUSH
64212: LD_INT 34
64214: PUSH
64215: LD_INT 88
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PUSH
64222: EMPTY
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: PPUSH
64232: CALL_OW 72
64236: ST_TO_ADDR
// if cranes then
64237: LD_VAR 0 6
64241: IFFALSE 64303
// for j in cranes do
64243: LD_ADDR_VAR 0 3
64247: PUSH
64248: LD_VAR 0 6
64252: PUSH
64253: FOR_IN
64254: IFFALSE 64301
// if not IsInArea ( j , mc_parking [ i ] ) then
64256: LD_VAR 0 3
64260: PPUSH
64261: LD_EXP 74
64265: PUSH
64266: LD_VAR 0 2
64270: ARRAY
64271: PPUSH
64272: CALL_OW 308
64276: NOT
64277: IFFALSE 64299
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64279: LD_VAR 0 3
64283: PPUSH
64284: LD_EXP 74
64288: PUSH
64289: LD_VAR 0 2
64293: ARRAY
64294: PPUSH
64295: CALL_OW 113
64299: GO 64253
64301: POP
64302: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64303: LD_ADDR_EXP 52
64307: PUSH
64308: LD_EXP 52
64312: PPUSH
64313: LD_VAR 0 2
64317: PPUSH
64318: EMPTY
64319: PPUSH
64320: CALL_OW 1
64324: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64325: LD_VAR 0 2
64329: PPUSH
64330: LD_INT 101
64332: PPUSH
64333: CALL 59193 0 2
// continue ;
64337: GO 64140
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64339: LD_ADDR_EXP 56
64343: PUSH
64344: LD_EXP 56
64348: PPUSH
64349: LD_VAR 0 2
64353: PPUSH
64354: EMPTY
64355: PPUSH
64356: CALL_OW 1
64360: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64361: LD_VAR 0 2
64365: PPUSH
64366: LD_INT 103
64368: PPUSH
64369: CALL 59193 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64373: LD_ADDR_VAR 0 5
64377: PUSH
64378: LD_EXP 50
64382: PUSH
64383: LD_VAR 0 2
64387: ARRAY
64388: PUSH
64389: LD_EXP 79
64393: PUSH
64394: LD_VAR 0 2
64398: ARRAY
64399: UNION
64400: PPUSH
64401: LD_INT 2
64403: PUSH
64404: LD_INT 25
64406: PUSH
64407: LD_INT 2
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: PUSH
64414: LD_INT 25
64416: PUSH
64417: LD_INT 16
64419: PUSH
64420: EMPTY
64421: LIST
64422: LIST
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: LIST
64428: PUSH
64429: EMPTY
64430: LIST
64431: PPUSH
64432: CALL_OW 72
64436: ST_TO_ADDR
// if mc_need_heal [ i ] then
64437: LD_EXP 53
64441: PUSH
64442: LD_VAR 0 2
64446: ARRAY
64447: IFFALSE 64491
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64449: LD_ADDR_VAR 0 5
64453: PUSH
64454: LD_VAR 0 5
64458: PUSH
64459: LD_EXP 53
64463: PUSH
64464: LD_VAR 0 2
64468: ARRAY
64469: PUSH
64470: LD_INT 1
64472: ARRAY
64473: PUSH
64474: LD_EXP 53
64478: PUSH
64479: LD_VAR 0 2
64483: ARRAY
64484: PUSH
64485: LD_INT 2
64487: ARRAY
64488: UNION
64489: DIFF
64490: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64491: LD_ADDR_VAR 0 6
64495: PUSH
64496: LD_EXP 69
64500: PUSH
64501: LD_VAR 0 2
64505: ARRAY
64506: PPUSH
64507: LD_INT 2
64509: PUSH
64510: LD_INT 34
64512: PUSH
64513: LD_INT 13
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 34
64522: PUSH
64523: LD_INT 52
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 34
64532: PUSH
64533: LD_INT 88
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: PPUSH
64546: CALL_OW 72
64550: ST_TO_ADDR
// if cranes then
64551: LD_VAR 0 6
64555: IFFALSE 64723
// begin for j in cranes do
64557: LD_ADDR_VAR 0 3
64561: PUSH
64562: LD_VAR 0 6
64566: PUSH
64567: FOR_IN
64568: IFFALSE 64721
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64570: LD_VAR 0 3
64574: PPUSH
64575: CALL_OW 256
64579: PUSH
64580: LD_INT 1000
64582: EQUAL
64583: PUSH
64584: LD_VAR 0 3
64588: PPUSH
64589: CALL_OW 314
64593: NOT
64594: AND
64595: IFFALSE 64661
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
64597: LD_ADDR_VAR 0 8
64601: PUSH
64602: LD_EXP 51
64606: PUSH
64607: LD_VAR 0 2
64611: ARRAY
64612: PPUSH
64613: LD_VAR 0 3
64617: PPUSH
64618: CALL_OW 74
64622: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64623: LD_VAR 0 8
64627: PPUSH
64628: LD_INT 16
64630: PPUSH
64631: CALL 21345 0 2
64635: PUSH
64636: LD_INT 4
64638: ARRAY
64639: PUSH
64640: LD_INT 10
64642: LESS
64643: IFFALSE 64659
// ComRepairBuilding ( j , to_repair ) ;
64645: LD_VAR 0 3
64649: PPUSH
64650: LD_VAR 0 8
64654: PPUSH
64655: CALL_OW 130
// end else
64659: GO 64719
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64661: LD_VAR 0 3
64665: PPUSH
64666: CALL_OW 256
64670: PUSH
64671: LD_INT 500
64673: LESS
64674: PUSH
64675: LD_VAR 0 3
64679: PPUSH
64680: LD_EXP 74
64684: PUSH
64685: LD_VAR 0 2
64689: ARRAY
64690: PPUSH
64691: CALL_OW 308
64695: NOT
64696: AND
64697: IFFALSE 64719
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64699: LD_VAR 0 3
64703: PPUSH
64704: LD_EXP 74
64708: PUSH
64709: LD_VAR 0 2
64713: ARRAY
64714: PPUSH
64715: CALL_OW 113
// end ;
64719: GO 64567
64721: POP
64722: POP
// end ; if tmp > 3 then
64723: LD_VAR 0 5
64727: PUSH
64728: LD_INT 3
64730: GREATER
64731: IFFALSE 64751
// tmp := ShrinkArray ( tmp , 4 ) ;
64733: LD_ADDR_VAR 0 5
64737: PUSH
64738: LD_VAR 0 5
64742: PPUSH
64743: LD_INT 4
64745: PPUSH
64746: CALL 51394 0 2
64750: ST_TO_ADDR
// if not tmp then
64751: LD_VAR 0 5
64755: NOT
64756: IFFALSE 64760
// continue ;
64758: GO 64140
// for j in tmp do
64760: LD_ADDR_VAR 0 3
64764: PUSH
64765: LD_VAR 0 5
64769: PUSH
64770: FOR_IN
64771: IFFALSE 65030
// begin if IsInUnit ( j ) then
64773: LD_VAR 0 3
64777: PPUSH
64778: CALL_OW 310
64782: IFFALSE 64793
// ComExitBuilding ( j ) ;
64784: LD_VAR 0 3
64788: PPUSH
64789: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64793: LD_VAR 0 3
64797: PUSH
64798: LD_EXP 52
64802: PUSH
64803: LD_VAR 0 2
64807: ARRAY
64808: IN
64809: NOT
64810: IFFALSE 64868
// begin SetTag ( j , 101 ) ;
64812: LD_VAR 0 3
64816: PPUSH
64817: LD_INT 101
64819: PPUSH
64820: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64824: LD_ADDR_EXP 52
64828: PUSH
64829: LD_EXP 52
64833: PPUSH
64834: LD_VAR 0 2
64838: PUSH
64839: LD_EXP 52
64843: PUSH
64844: LD_VAR 0 2
64848: ARRAY
64849: PUSH
64850: LD_INT 1
64852: PLUS
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PPUSH
64858: LD_VAR 0 3
64862: PPUSH
64863: CALL 18748 0 3
64867: ST_TO_ADDR
// end ; wait ( 1 ) ;
64868: LD_INT 1
64870: PPUSH
64871: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64875: LD_ADDR_VAR 0 7
64879: PUSH
64880: LD_EXP 51
64884: PUSH
64885: LD_VAR 0 2
64889: ARRAY
64890: ST_TO_ADDR
// if mc_scan [ i ] then
64891: LD_EXP 73
64895: PUSH
64896: LD_VAR 0 2
64900: ARRAY
64901: IFFALSE 64963
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64903: LD_ADDR_VAR 0 7
64907: PUSH
64908: LD_EXP 51
64912: PUSH
64913: LD_VAR 0 2
64917: ARRAY
64918: PPUSH
64919: LD_INT 3
64921: PUSH
64922: LD_INT 30
64924: PUSH
64925: LD_INT 32
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PUSH
64932: LD_INT 30
64934: PUSH
64935: LD_INT 33
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 30
64944: PUSH
64945: LD_INT 31
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: LIST
64956: LIST
64957: PPUSH
64958: CALL_OW 72
64962: ST_TO_ADDR
// if not to_repair_tmp then
64963: LD_VAR 0 7
64967: NOT
64968: IFFALSE 64972
// continue ;
64970: GO 64770
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64972: LD_ADDR_VAR 0 8
64976: PUSH
64977: LD_VAR 0 7
64981: PPUSH
64982: LD_VAR 0 3
64986: PPUSH
64987: CALL_OW 74
64991: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
64992: LD_VAR 0 8
64996: PPUSH
64997: LD_INT 16
64999: PPUSH
65000: CALL 21345 0 2
65004: PUSH
65005: LD_INT 4
65007: ARRAY
65008: PUSH
65009: LD_INT 14
65011: LESS
65012: IFFALSE 65028
// ComRepairBuilding ( j , to_repair ) ;
65014: LD_VAR 0 3
65018: PPUSH
65019: LD_VAR 0 8
65023: PPUSH
65024: CALL_OW 130
// end ;
65028: GO 64770
65030: POP
65031: POP
// end ;
65032: GO 64140
65034: POP
65035: POP
// end ;
65036: LD_VAR 0 1
65040: RET
// export function MC_Heal ; var i , j , tmp ; begin
65041: LD_INT 0
65043: PPUSH
65044: PPUSH
65045: PPUSH
65046: PPUSH
// if not mc_bases then
65047: LD_EXP 50
65051: NOT
65052: IFFALSE 65056
// exit ;
65054: GO 65458
// for i = 1 to mc_bases do
65056: LD_ADDR_VAR 0 2
65060: PUSH
65061: DOUBLE
65062: LD_INT 1
65064: DEC
65065: ST_TO_ADDR
65066: LD_EXP 50
65070: PUSH
65071: FOR_TO
65072: IFFALSE 65456
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65074: LD_EXP 53
65078: PUSH
65079: LD_VAR 0 2
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: ARRAY
65088: NOT
65089: PUSH
65090: LD_EXP 53
65094: PUSH
65095: LD_VAR 0 2
65099: ARRAY
65100: PUSH
65101: LD_INT 2
65103: ARRAY
65104: NOT
65105: AND
65106: IFFALSE 65144
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65108: LD_ADDR_EXP 54
65112: PUSH
65113: LD_EXP 54
65117: PPUSH
65118: LD_VAR 0 2
65122: PPUSH
65123: EMPTY
65124: PPUSH
65125: CALL_OW 1
65129: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65130: LD_VAR 0 2
65134: PPUSH
65135: LD_INT 102
65137: PPUSH
65138: CALL 59193 0 2
// continue ;
65142: GO 65071
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65144: LD_ADDR_VAR 0 4
65148: PUSH
65149: LD_EXP 50
65153: PUSH
65154: LD_VAR 0 2
65158: ARRAY
65159: PPUSH
65160: LD_INT 25
65162: PUSH
65163: LD_INT 4
65165: PUSH
65166: EMPTY
65167: LIST
65168: LIST
65169: PPUSH
65170: CALL_OW 72
65174: ST_TO_ADDR
// if not tmp then
65175: LD_VAR 0 4
65179: NOT
65180: IFFALSE 65184
// continue ;
65182: GO 65071
// if mc_taming [ i ] then
65184: LD_EXP 81
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: IFFALSE 65218
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65196: LD_ADDR_EXP 81
65200: PUSH
65201: LD_EXP 81
65205: PPUSH
65206: LD_VAR 0 2
65210: PPUSH
65211: EMPTY
65212: PPUSH
65213: CALL_OW 1
65217: ST_TO_ADDR
// for j in tmp do
65218: LD_ADDR_VAR 0 3
65222: PUSH
65223: LD_VAR 0 4
65227: PUSH
65228: FOR_IN
65229: IFFALSE 65452
// begin if IsInUnit ( j ) then
65231: LD_VAR 0 3
65235: PPUSH
65236: CALL_OW 310
65240: IFFALSE 65251
// ComExitBuilding ( j ) ;
65242: LD_VAR 0 3
65246: PPUSH
65247: CALL_OW 122
// if not j in mc_healers [ i ] then
65251: LD_VAR 0 3
65255: PUSH
65256: LD_EXP 54
65260: PUSH
65261: LD_VAR 0 2
65265: ARRAY
65266: IN
65267: NOT
65268: IFFALSE 65314
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65270: LD_ADDR_EXP 54
65274: PUSH
65275: LD_EXP 54
65279: PPUSH
65280: LD_VAR 0 2
65284: PUSH
65285: LD_EXP 54
65289: PUSH
65290: LD_VAR 0 2
65294: ARRAY
65295: PUSH
65296: LD_INT 1
65298: PLUS
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: PPUSH
65304: LD_VAR 0 3
65308: PPUSH
65309: CALL 18748 0 3
65313: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65314: LD_VAR 0 3
65318: PPUSH
65319: CALL_OW 110
65323: PUSH
65324: LD_INT 102
65326: NONEQUAL
65327: IFFALSE 65341
// SetTag ( j , 102 ) ;
65329: LD_VAR 0 3
65333: PPUSH
65334: LD_INT 102
65336: PPUSH
65337: CALL_OW 109
// Wait ( 3 ) ;
65341: LD_INT 3
65343: PPUSH
65344: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65348: LD_EXP 53
65352: PUSH
65353: LD_VAR 0 2
65357: ARRAY
65358: PUSH
65359: LD_INT 1
65361: ARRAY
65362: IFFALSE 65394
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65364: LD_VAR 0 3
65368: PPUSH
65369: LD_EXP 53
65373: PUSH
65374: LD_VAR 0 2
65378: ARRAY
65379: PUSH
65380: LD_INT 1
65382: ARRAY
65383: PUSH
65384: LD_INT 1
65386: ARRAY
65387: PPUSH
65388: CALL_OW 128
65392: GO 65450
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65394: LD_VAR 0 3
65398: PPUSH
65399: CALL_OW 314
65403: NOT
65404: PUSH
65405: LD_EXP 53
65409: PUSH
65410: LD_VAR 0 2
65414: ARRAY
65415: PUSH
65416: LD_INT 2
65418: ARRAY
65419: AND
65420: IFFALSE 65450
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65422: LD_VAR 0 3
65426: PPUSH
65427: LD_EXP 53
65431: PUSH
65432: LD_VAR 0 2
65436: ARRAY
65437: PUSH
65438: LD_INT 2
65440: ARRAY
65441: PUSH
65442: LD_INT 1
65444: ARRAY
65445: PPUSH
65446: CALL_OW 128
// end ;
65450: GO 65228
65452: POP
65453: POP
// end ;
65454: GO 65071
65456: POP
65457: POP
// end ;
65458: LD_VAR 0 1
65462: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
65463: LD_INT 0
65465: PPUSH
65466: PPUSH
65467: PPUSH
65468: PPUSH
65469: PPUSH
65470: PPUSH
// if not mc_bases then
65471: LD_EXP 50
65475: NOT
65476: IFFALSE 65480
// exit ;
65478: GO 66643
// for i = 1 to mc_bases do
65480: LD_ADDR_VAR 0 2
65484: PUSH
65485: DOUBLE
65486: LD_INT 1
65488: DEC
65489: ST_TO_ADDR
65490: LD_EXP 50
65494: PUSH
65495: FOR_TO
65496: IFFALSE 66641
// begin if mc_scan [ i ] then
65498: LD_EXP 73
65502: PUSH
65503: LD_VAR 0 2
65507: ARRAY
65508: IFFALSE 65512
// continue ;
65510: GO 65495
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65512: LD_EXP 55
65516: PUSH
65517: LD_VAR 0 2
65521: ARRAY
65522: NOT
65523: PUSH
65524: LD_EXP 57
65528: PUSH
65529: LD_VAR 0 2
65533: ARRAY
65534: NOT
65535: AND
65536: PUSH
65537: LD_EXP 56
65541: PUSH
65542: LD_VAR 0 2
65546: ARRAY
65547: AND
65548: IFFALSE 65586
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65550: LD_ADDR_EXP 56
65554: PUSH
65555: LD_EXP 56
65559: PPUSH
65560: LD_VAR 0 2
65564: PPUSH
65565: EMPTY
65566: PPUSH
65567: CALL_OW 1
65571: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65572: LD_VAR 0 2
65576: PPUSH
65577: LD_INT 103
65579: PPUSH
65580: CALL 59193 0 2
// continue ;
65584: GO 65495
// end ; if mc_construct_list [ i ] then
65586: LD_EXP 57
65590: PUSH
65591: LD_VAR 0 2
65595: ARRAY
65596: IFFALSE 65816
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65598: LD_ADDR_VAR 0 5
65602: PUSH
65603: LD_EXP 50
65607: PUSH
65608: LD_VAR 0 2
65612: ARRAY
65613: PPUSH
65614: LD_INT 25
65616: PUSH
65617: LD_INT 2
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PPUSH
65624: CALL_OW 72
65628: PUSH
65629: LD_EXP 52
65633: PUSH
65634: LD_VAR 0 2
65638: ARRAY
65639: DIFF
65640: ST_TO_ADDR
// if not tmp then
65641: LD_VAR 0 5
65645: NOT
65646: IFFALSE 65650
// continue ;
65648: GO 65495
// for j in tmp do
65650: LD_ADDR_VAR 0 3
65654: PUSH
65655: LD_VAR 0 5
65659: PUSH
65660: FOR_IN
65661: IFFALSE 65812
// begin if not mc_builders [ i ] then
65663: LD_EXP 56
65667: PUSH
65668: LD_VAR 0 2
65672: ARRAY
65673: NOT
65674: IFFALSE 65732
// begin SetTag ( j , 103 ) ;
65676: LD_VAR 0 3
65680: PPUSH
65681: LD_INT 103
65683: PPUSH
65684: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65688: LD_ADDR_EXP 56
65692: PUSH
65693: LD_EXP 56
65697: PPUSH
65698: LD_VAR 0 2
65702: PUSH
65703: LD_EXP 56
65707: PUSH
65708: LD_VAR 0 2
65712: ARRAY
65713: PUSH
65714: LD_INT 1
65716: PLUS
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PPUSH
65722: LD_VAR 0 3
65726: PPUSH
65727: CALL 18748 0 3
65731: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65732: LD_VAR 0 3
65736: PPUSH
65737: CALL_OW 310
65741: IFFALSE 65752
// ComExitBuilding ( j ) ;
65743: LD_VAR 0 3
65747: PPUSH
65748: CALL_OW 122
// wait ( 3 ) ;
65752: LD_INT 3
65754: PPUSH
65755: CALL_OW 67
// if not mc_construct_list [ i ] then
65759: LD_EXP 57
65763: PUSH
65764: LD_VAR 0 2
65768: ARRAY
65769: NOT
65770: IFFALSE 65774
// break ;
65772: GO 65812
// if not HasTask ( j ) then
65774: LD_VAR 0 3
65778: PPUSH
65779: CALL_OW 314
65783: NOT
65784: IFFALSE 65810
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65786: LD_VAR 0 3
65790: PPUSH
65791: LD_EXP 57
65795: PUSH
65796: LD_VAR 0 2
65800: ARRAY
65801: PUSH
65802: LD_INT 1
65804: ARRAY
65805: PPUSH
65806: CALL 21609 0 2
// end ;
65810: GO 65660
65812: POP
65813: POP
// end else
65814: GO 66639
// if mc_build_list [ i ] then
65816: LD_EXP 55
65820: PUSH
65821: LD_VAR 0 2
65825: ARRAY
65826: IFFALSE 66639
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65828: LD_EXP 55
65832: PUSH
65833: LD_VAR 0 2
65837: ARRAY
65838: PUSH
65839: LD_INT 1
65841: ARRAY
65842: PUSH
65843: LD_INT 1
65845: ARRAY
65846: PPUSH
65847: CALL 21433 0 1
65851: PUSH
65852: LD_EXP 50
65856: PUSH
65857: LD_VAR 0 2
65861: ARRAY
65862: PPUSH
65863: LD_INT 2
65865: PUSH
65866: LD_INT 30
65868: PUSH
65869: LD_INT 2
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 30
65878: PUSH
65879: LD_INT 3
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: EMPTY
65887: LIST
65888: LIST
65889: LIST
65890: PPUSH
65891: CALL_OW 72
65895: NOT
65896: AND
65897: IFFALSE 66002
// begin for j = 1 to mc_build_list [ i ] do
65899: LD_ADDR_VAR 0 3
65903: PUSH
65904: DOUBLE
65905: LD_INT 1
65907: DEC
65908: ST_TO_ADDR
65909: LD_EXP 55
65913: PUSH
65914: LD_VAR 0 2
65918: ARRAY
65919: PUSH
65920: FOR_TO
65921: IFFALSE 66000
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65923: LD_EXP 55
65927: PUSH
65928: LD_VAR 0 2
65932: ARRAY
65933: PUSH
65934: LD_VAR 0 3
65938: ARRAY
65939: PUSH
65940: LD_INT 1
65942: ARRAY
65943: PUSH
65944: LD_INT 2
65946: EQUAL
65947: IFFALSE 65998
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65949: LD_ADDR_EXP 55
65953: PUSH
65954: LD_EXP 55
65958: PPUSH
65959: LD_VAR 0 2
65963: PPUSH
65964: LD_EXP 55
65968: PUSH
65969: LD_VAR 0 2
65973: ARRAY
65974: PPUSH
65975: LD_VAR 0 3
65979: PPUSH
65980: LD_INT 1
65982: PPUSH
65983: LD_INT 0
65985: PPUSH
65986: CALL 18166 0 4
65990: PPUSH
65991: CALL_OW 1
65995: ST_TO_ADDR
// break ;
65996: GO 66000
// end ;
65998: GO 65920
66000: POP
66001: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66002: LD_ADDR_VAR 0 6
66006: PUSH
66007: LD_EXP 50
66011: PUSH
66012: LD_VAR 0 2
66016: ARRAY
66017: PPUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 30
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 30
66033: PUSH
66034: LD_INT 1
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: PPUSH
66046: CALL_OW 72
66050: ST_TO_ADDR
// for k := 1 to depot do
66051: LD_ADDR_VAR 0 4
66055: PUSH
66056: DOUBLE
66057: LD_INT 1
66059: DEC
66060: ST_TO_ADDR
66061: LD_VAR 0 6
66065: PUSH
66066: FOR_TO
66067: IFFALSE 66637
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66069: LD_EXP 55
66073: PUSH
66074: LD_VAR 0 2
66078: ARRAY
66079: PUSH
66080: LD_INT 1
66082: ARRAY
66083: PUSH
66084: LD_INT 1
66086: ARRAY
66087: PUSH
66088: LD_INT 0
66090: EQUAL
66091: PUSH
66092: LD_VAR 0 6
66096: PUSH
66097: LD_VAR 0 4
66101: ARRAY
66102: PPUSH
66103: LD_EXP 55
66107: PUSH
66108: LD_VAR 0 2
66112: ARRAY
66113: PUSH
66114: LD_INT 1
66116: ARRAY
66117: PUSH
66118: LD_INT 1
66120: ARRAY
66121: PPUSH
66122: LD_EXP 55
66126: PUSH
66127: LD_VAR 0 2
66131: ARRAY
66132: PUSH
66133: LD_INT 1
66135: ARRAY
66136: PUSH
66137: LD_INT 2
66139: ARRAY
66140: PPUSH
66141: LD_EXP 55
66145: PUSH
66146: LD_VAR 0 2
66150: ARRAY
66151: PUSH
66152: LD_INT 1
66154: ARRAY
66155: PUSH
66156: LD_INT 3
66158: ARRAY
66159: PPUSH
66160: LD_EXP 55
66164: PUSH
66165: LD_VAR 0 2
66169: ARRAY
66170: PUSH
66171: LD_INT 1
66173: ARRAY
66174: PUSH
66175: LD_INT 4
66177: ARRAY
66178: PPUSH
66179: CALL 26845 0 5
66183: OR
66184: IFFALSE 66465
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66186: LD_ADDR_VAR 0 5
66190: PUSH
66191: LD_EXP 50
66195: PUSH
66196: LD_VAR 0 2
66200: ARRAY
66201: PPUSH
66202: LD_INT 25
66204: PUSH
66205: LD_INT 2
66207: PUSH
66208: EMPTY
66209: LIST
66210: LIST
66211: PPUSH
66212: CALL_OW 72
66216: PUSH
66217: LD_EXP 52
66221: PUSH
66222: LD_VAR 0 2
66226: ARRAY
66227: DIFF
66228: ST_TO_ADDR
// if not tmp then
66229: LD_VAR 0 5
66233: NOT
66234: IFFALSE 66238
// continue ;
66236: GO 66066
// for j in tmp do
66238: LD_ADDR_VAR 0 3
66242: PUSH
66243: LD_VAR 0 5
66247: PUSH
66248: FOR_IN
66249: IFFALSE 66461
// begin if not mc_builders [ i ] then
66251: LD_EXP 56
66255: PUSH
66256: LD_VAR 0 2
66260: ARRAY
66261: NOT
66262: IFFALSE 66320
// begin SetTag ( j , 103 ) ;
66264: LD_VAR 0 3
66268: PPUSH
66269: LD_INT 103
66271: PPUSH
66272: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66276: LD_ADDR_EXP 56
66280: PUSH
66281: LD_EXP 56
66285: PPUSH
66286: LD_VAR 0 2
66290: PUSH
66291: LD_EXP 56
66295: PUSH
66296: LD_VAR 0 2
66300: ARRAY
66301: PUSH
66302: LD_INT 1
66304: PLUS
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PPUSH
66310: LD_VAR 0 3
66314: PPUSH
66315: CALL 18748 0 3
66319: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66320: LD_VAR 0 3
66324: PPUSH
66325: CALL_OW 310
66329: IFFALSE 66340
// ComExitBuilding ( j ) ;
66331: LD_VAR 0 3
66335: PPUSH
66336: CALL_OW 122
// wait ( 3 ) ;
66340: LD_INT 3
66342: PPUSH
66343: CALL_OW 67
// if not mc_build_list [ i ] then
66347: LD_EXP 55
66351: PUSH
66352: LD_VAR 0 2
66356: ARRAY
66357: NOT
66358: IFFALSE 66362
// break ;
66360: GO 66461
// if not HasTask ( j ) then
66362: LD_VAR 0 3
66366: PPUSH
66367: CALL_OW 314
66371: NOT
66372: IFFALSE 66459
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66374: LD_VAR 0 3
66378: PPUSH
66379: LD_EXP 55
66383: PUSH
66384: LD_VAR 0 2
66388: ARRAY
66389: PUSH
66390: LD_INT 1
66392: ARRAY
66393: PUSH
66394: LD_INT 1
66396: ARRAY
66397: PPUSH
66398: LD_EXP 55
66402: PUSH
66403: LD_VAR 0 2
66407: ARRAY
66408: PUSH
66409: LD_INT 1
66411: ARRAY
66412: PUSH
66413: LD_INT 2
66415: ARRAY
66416: PPUSH
66417: LD_EXP 55
66421: PUSH
66422: LD_VAR 0 2
66426: ARRAY
66427: PUSH
66428: LD_INT 1
66430: ARRAY
66431: PUSH
66432: LD_INT 3
66434: ARRAY
66435: PPUSH
66436: LD_EXP 55
66440: PUSH
66441: LD_VAR 0 2
66445: ARRAY
66446: PUSH
66447: LD_INT 1
66449: ARRAY
66450: PUSH
66451: LD_INT 4
66453: ARRAY
66454: PPUSH
66455: CALL_OW 145
// end ;
66459: GO 66248
66461: POP
66462: POP
// end else
66463: GO 66635
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66465: LD_EXP 50
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: PPUSH
66476: LD_EXP 55
66480: PUSH
66481: LD_VAR 0 2
66485: ARRAY
66486: PUSH
66487: LD_INT 1
66489: ARRAY
66490: PUSH
66491: LD_INT 1
66493: ARRAY
66494: PPUSH
66495: LD_EXP 55
66499: PUSH
66500: LD_VAR 0 2
66504: ARRAY
66505: PUSH
66506: LD_INT 1
66508: ARRAY
66509: PUSH
66510: LD_INT 2
66512: ARRAY
66513: PPUSH
66514: LD_EXP 55
66518: PUSH
66519: LD_VAR 0 2
66523: ARRAY
66524: PUSH
66525: LD_INT 1
66527: ARRAY
66528: PUSH
66529: LD_INT 3
66531: ARRAY
66532: PPUSH
66533: LD_EXP 55
66537: PUSH
66538: LD_VAR 0 2
66542: ARRAY
66543: PUSH
66544: LD_INT 1
66546: ARRAY
66547: PUSH
66548: LD_INT 4
66550: ARRAY
66551: PPUSH
66552: LD_EXP 50
66556: PUSH
66557: LD_VAR 0 2
66561: ARRAY
66562: PPUSH
66563: LD_INT 21
66565: PUSH
66566: LD_INT 3
66568: PUSH
66569: EMPTY
66570: LIST
66571: LIST
66572: PPUSH
66573: CALL_OW 72
66577: PPUSH
66578: EMPTY
66579: PPUSH
66580: CALL 25599 0 7
66584: NOT
66585: IFFALSE 66635
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66587: LD_ADDR_EXP 55
66591: PUSH
66592: LD_EXP 55
66596: PPUSH
66597: LD_VAR 0 2
66601: PPUSH
66602: LD_EXP 55
66606: PUSH
66607: LD_VAR 0 2
66611: ARRAY
66612: PPUSH
66613: LD_INT 1
66615: PPUSH
66616: LD_INT 1
66618: NEG
66619: PPUSH
66620: LD_INT 0
66622: PPUSH
66623: CALL 18166 0 4
66627: PPUSH
66628: CALL_OW 1
66632: ST_TO_ADDR
// continue ;
66633: GO 66066
// end ; end ;
66635: GO 66066
66637: POP
66638: POP
// end ; end ;
66639: GO 65495
66641: POP
66642: POP
// end ;
66643: LD_VAR 0 1
66647: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66648: LD_INT 0
66650: PPUSH
66651: PPUSH
66652: PPUSH
66653: PPUSH
66654: PPUSH
66655: PPUSH
// if not mc_bases then
66656: LD_EXP 50
66660: NOT
66661: IFFALSE 66665
// exit ;
66663: GO 67092
// for i = 1 to mc_bases do
66665: LD_ADDR_VAR 0 2
66669: PUSH
66670: DOUBLE
66671: LD_INT 1
66673: DEC
66674: ST_TO_ADDR
66675: LD_EXP 50
66679: PUSH
66680: FOR_TO
66681: IFFALSE 67090
// begin tmp := mc_build_upgrade [ i ] ;
66683: LD_ADDR_VAR 0 4
66687: PUSH
66688: LD_EXP 82
66692: PUSH
66693: LD_VAR 0 2
66697: ARRAY
66698: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66699: LD_ADDR_VAR 0 6
66703: PUSH
66704: LD_EXP 83
66708: PUSH
66709: LD_VAR 0 2
66713: ARRAY
66714: PPUSH
66715: LD_INT 2
66717: PUSH
66718: LD_INT 30
66720: PUSH
66721: LD_INT 6
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 30
66730: PUSH
66731: LD_INT 7
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: LIST
66742: PPUSH
66743: CALL_OW 72
66747: ST_TO_ADDR
// if not tmp and not lab then
66748: LD_VAR 0 4
66752: NOT
66753: PUSH
66754: LD_VAR 0 6
66758: NOT
66759: AND
66760: IFFALSE 66764
// continue ;
66762: GO 66680
// if tmp then
66764: LD_VAR 0 4
66768: IFFALSE 66888
// for j in tmp do
66770: LD_ADDR_VAR 0 3
66774: PUSH
66775: LD_VAR 0 4
66779: PUSH
66780: FOR_IN
66781: IFFALSE 66886
// begin if UpgradeCost ( j ) then
66783: LD_VAR 0 3
66787: PPUSH
66788: CALL 25259 0 1
66792: IFFALSE 66884
// begin ComUpgrade ( j ) ;
66794: LD_VAR 0 3
66798: PPUSH
66799: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66803: LD_ADDR_EXP 82
66807: PUSH
66808: LD_EXP 82
66812: PPUSH
66813: LD_VAR 0 2
66817: PPUSH
66818: LD_EXP 82
66822: PUSH
66823: LD_VAR 0 2
66827: ARRAY
66828: PUSH
66829: LD_VAR 0 3
66833: DIFF
66834: PPUSH
66835: CALL_OW 1
66839: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66840: LD_ADDR_EXP 57
66844: PUSH
66845: LD_EXP 57
66849: PPUSH
66850: LD_VAR 0 2
66854: PUSH
66855: LD_EXP 57
66859: PUSH
66860: LD_VAR 0 2
66864: ARRAY
66865: PUSH
66866: LD_INT 1
66868: PLUS
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PPUSH
66874: LD_VAR 0 3
66878: PPUSH
66879: CALL 18748 0 3
66883: ST_TO_ADDR
// end ; end ;
66884: GO 66780
66886: POP
66887: POP
// if not lab or not mc_lab_upgrade [ i ] then
66888: LD_VAR 0 6
66892: NOT
66893: PUSH
66894: LD_EXP 84
66898: PUSH
66899: LD_VAR 0 2
66903: ARRAY
66904: NOT
66905: OR
66906: IFFALSE 66910
// continue ;
66908: GO 66680
// for j in lab do
66910: LD_ADDR_VAR 0 3
66914: PUSH
66915: LD_VAR 0 6
66919: PUSH
66920: FOR_IN
66921: IFFALSE 67086
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66923: LD_VAR 0 3
66927: PPUSH
66928: CALL_OW 266
66932: PUSH
66933: LD_INT 6
66935: PUSH
66936: LD_INT 7
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: IN
66943: PUSH
66944: LD_VAR 0 3
66948: PPUSH
66949: CALL_OW 461
66953: PUSH
66954: LD_INT 1
66956: NONEQUAL
66957: AND
66958: IFFALSE 67084
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66960: LD_VAR 0 3
66964: PPUSH
66965: LD_EXP 84
66969: PUSH
66970: LD_VAR 0 2
66974: ARRAY
66975: PUSH
66976: LD_INT 1
66978: ARRAY
66979: PPUSH
66980: CALL 25464 0 2
66984: IFFALSE 67084
// begin ComCancel ( j ) ;
66986: LD_VAR 0 3
66990: PPUSH
66991: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66995: LD_VAR 0 3
66999: PPUSH
67000: LD_EXP 84
67004: PUSH
67005: LD_VAR 0 2
67009: ARRAY
67010: PUSH
67011: LD_INT 1
67013: ARRAY
67014: PPUSH
67015: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67019: LD_VAR 0 3
67023: PUSH
67024: LD_EXP 57
67028: PUSH
67029: LD_VAR 0 2
67033: ARRAY
67034: IN
67035: NOT
67036: IFFALSE 67082
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67038: LD_ADDR_EXP 57
67042: PUSH
67043: LD_EXP 57
67047: PPUSH
67048: LD_VAR 0 2
67052: PUSH
67053: LD_EXP 57
67057: PUSH
67058: LD_VAR 0 2
67062: ARRAY
67063: PUSH
67064: LD_INT 1
67066: PLUS
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PPUSH
67072: LD_VAR 0 3
67076: PPUSH
67077: CALL 18748 0 3
67081: ST_TO_ADDR
// break ;
67082: GO 67086
// end ; end ; end ;
67084: GO 66920
67086: POP
67087: POP
// end ;
67088: GO 66680
67090: POP
67091: POP
// end ;
67092: LD_VAR 0 1
67096: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67097: LD_INT 0
67099: PPUSH
67100: PPUSH
67101: PPUSH
67102: PPUSH
67103: PPUSH
67104: PPUSH
67105: PPUSH
67106: PPUSH
67107: PPUSH
// if not mc_bases then
67108: LD_EXP 50
67112: NOT
67113: IFFALSE 67117
// exit ;
67115: GO 67522
// for i = 1 to mc_bases do
67117: LD_ADDR_VAR 0 2
67121: PUSH
67122: DOUBLE
67123: LD_INT 1
67125: DEC
67126: ST_TO_ADDR
67127: LD_EXP 50
67131: PUSH
67132: FOR_TO
67133: IFFALSE 67520
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67135: LD_EXP 58
67139: PUSH
67140: LD_VAR 0 2
67144: ARRAY
67145: NOT
67146: PUSH
67147: LD_EXP 50
67151: PUSH
67152: LD_VAR 0 2
67156: ARRAY
67157: PPUSH
67158: LD_INT 30
67160: PUSH
67161: LD_INT 3
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PPUSH
67168: CALL_OW 72
67172: NOT
67173: OR
67174: IFFALSE 67178
// continue ;
67176: GO 67132
// busy := false ;
67178: LD_ADDR_VAR 0 8
67182: PUSH
67183: LD_INT 0
67185: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67186: LD_ADDR_VAR 0 4
67190: PUSH
67191: LD_EXP 50
67195: PUSH
67196: LD_VAR 0 2
67200: ARRAY
67201: PPUSH
67202: LD_INT 30
67204: PUSH
67205: LD_INT 3
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PPUSH
67212: CALL_OW 72
67216: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67217: LD_ADDR_VAR 0 6
67221: PUSH
67222: LD_EXP 58
67226: PUSH
67227: LD_VAR 0 2
67231: ARRAY
67232: PPUSH
67233: LD_INT 2
67235: PUSH
67236: LD_INT 30
67238: PUSH
67239: LD_INT 32
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 30
67248: PUSH
67249: LD_INT 33
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: LIST
67260: PPUSH
67261: CALL_OW 72
67265: ST_TO_ADDR
// if not t then
67266: LD_VAR 0 6
67270: NOT
67271: IFFALSE 67275
// continue ;
67273: GO 67132
// for j in tmp do
67275: LD_ADDR_VAR 0 3
67279: PUSH
67280: LD_VAR 0 4
67284: PUSH
67285: FOR_IN
67286: IFFALSE 67316
// if not BuildingStatus ( j ) = bs_idle then
67288: LD_VAR 0 3
67292: PPUSH
67293: CALL_OW 461
67297: PUSH
67298: LD_INT 2
67300: EQUAL
67301: NOT
67302: IFFALSE 67314
// begin busy := true ;
67304: LD_ADDR_VAR 0 8
67308: PUSH
67309: LD_INT 1
67311: ST_TO_ADDR
// break ;
67312: GO 67316
// end ;
67314: GO 67285
67316: POP
67317: POP
// if busy then
67318: LD_VAR 0 8
67322: IFFALSE 67326
// continue ;
67324: GO 67132
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67326: LD_ADDR_VAR 0 7
67330: PUSH
67331: LD_VAR 0 6
67335: PPUSH
67336: LD_INT 35
67338: PUSH
67339: LD_INT 0
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PPUSH
67346: CALL_OW 72
67350: ST_TO_ADDR
// if tw then
67351: LD_VAR 0 7
67355: IFFALSE 67432
// begin tw := tw [ 1 ] ;
67357: LD_ADDR_VAR 0 7
67361: PUSH
67362: LD_VAR 0 7
67366: PUSH
67367: LD_INT 1
67369: ARRAY
67370: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67371: LD_ADDR_VAR 0 9
67375: PUSH
67376: LD_VAR 0 7
67380: PPUSH
67381: LD_EXP 75
67385: PUSH
67386: LD_VAR 0 2
67390: ARRAY
67391: PPUSH
67392: CALL 23756 0 2
67396: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67397: LD_EXP 89
67401: PUSH
67402: LD_VAR 0 2
67406: ARRAY
67407: IFFALSE 67430
// if not weapon in mc_allowed_tower_weapons [ i ] then
67409: LD_VAR 0 9
67413: PUSH
67414: LD_EXP 89
67418: PUSH
67419: LD_VAR 0 2
67423: ARRAY
67424: IN
67425: NOT
67426: IFFALSE 67430
// continue ;
67428: GO 67132
// end else
67430: GO 67495
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67432: LD_ADDR_VAR 0 5
67436: PUSH
67437: LD_EXP 58
67441: PUSH
67442: LD_VAR 0 2
67446: ARRAY
67447: PPUSH
67448: LD_VAR 0 4
67452: PPUSH
67453: CALL 50627 0 2
67457: ST_TO_ADDR
// if not tmp2 then
67458: LD_VAR 0 5
67462: NOT
67463: IFFALSE 67467
// continue ;
67465: GO 67132
// tw := tmp2 [ 1 ] ;
67467: LD_ADDR_VAR 0 7
67471: PUSH
67472: LD_VAR 0 5
67476: PUSH
67477: LD_INT 1
67479: ARRAY
67480: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67481: LD_ADDR_VAR 0 9
67485: PUSH
67486: LD_VAR 0 5
67490: PUSH
67491: LD_INT 2
67493: ARRAY
67494: ST_TO_ADDR
// end ; if not weapon then
67495: LD_VAR 0 9
67499: NOT
67500: IFFALSE 67504
// continue ;
67502: GO 67132
// ComPlaceWeapon ( tw , weapon ) ;
67504: LD_VAR 0 7
67508: PPUSH
67509: LD_VAR 0 9
67513: PPUSH
67514: CALL_OW 148
// end ;
67518: GO 67132
67520: POP
67521: POP
// end ;
67522: LD_VAR 0 1
67526: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67527: LD_INT 0
67529: PPUSH
67530: PPUSH
67531: PPUSH
67532: PPUSH
67533: PPUSH
67534: PPUSH
67535: PPUSH
// if not mc_bases then
67536: LD_EXP 50
67540: NOT
67541: IFFALSE 67545
// exit ;
67543: GO 68313
// for i = 1 to mc_bases do
67545: LD_ADDR_VAR 0 2
67549: PUSH
67550: DOUBLE
67551: LD_INT 1
67553: DEC
67554: ST_TO_ADDR
67555: LD_EXP 50
67559: PUSH
67560: FOR_TO
67561: IFFALSE 68311
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67563: LD_EXP 63
67567: PUSH
67568: LD_VAR 0 2
67572: ARRAY
67573: NOT
67574: PUSH
67575: LD_EXP 63
67579: PUSH
67580: LD_VAR 0 2
67584: ARRAY
67585: PUSH
67586: LD_EXP 64
67590: PUSH
67591: LD_VAR 0 2
67595: ARRAY
67596: EQUAL
67597: OR
67598: PUSH
67599: LD_EXP 73
67603: PUSH
67604: LD_VAR 0 2
67608: ARRAY
67609: OR
67610: IFFALSE 67614
// continue ;
67612: GO 67560
// if mc_miners [ i ] then
67614: LD_EXP 64
67618: PUSH
67619: LD_VAR 0 2
67623: ARRAY
67624: IFFALSE 67998
// begin for j = mc_miners [ i ] downto 1 do
67626: LD_ADDR_VAR 0 3
67630: PUSH
67631: DOUBLE
67632: LD_EXP 64
67636: PUSH
67637: LD_VAR 0 2
67641: ARRAY
67642: INC
67643: ST_TO_ADDR
67644: LD_INT 1
67646: PUSH
67647: FOR_DOWNTO
67648: IFFALSE 67996
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67650: LD_EXP 64
67654: PUSH
67655: LD_VAR 0 2
67659: ARRAY
67660: PUSH
67661: LD_VAR 0 3
67665: ARRAY
67666: PPUSH
67667: CALL_OW 301
67671: PUSH
67672: LD_EXP 64
67676: PUSH
67677: LD_VAR 0 2
67681: ARRAY
67682: PUSH
67683: LD_VAR 0 3
67687: ARRAY
67688: PPUSH
67689: CALL_OW 257
67693: PUSH
67694: LD_INT 1
67696: NONEQUAL
67697: OR
67698: IFFALSE 67761
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67700: LD_ADDR_VAR 0 5
67704: PUSH
67705: LD_EXP 64
67709: PUSH
67710: LD_VAR 0 2
67714: ARRAY
67715: PUSH
67716: LD_EXP 64
67720: PUSH
67721: LD_VAR 0 2
67725: ARRAY
67726: PUSH
67727: LD_VAR 0 3
67731: ARRAY
67732: DIFF
67733: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67734: LD_ADDR_EXP 64
67738: PUSH
67739: LD_EXP 64
67743: PPUSH
67744: LD_VAR 0 2
67748: PPUSH
67749: LD_VAR 0 5
67753: PPUSH
67754: CALL_OW 1
67758: ST_TO_ADDR
// continue ;
67759: GO 67647
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67761: LD_EXP 64
67765: PUSH
67766: LD_VAR 0 2
67770: ARRAY
67771: PUSH
67772: LD_VAR 0 3
67776: ARRAY
67777: PPUSH
67778: CALL_OW 257
67782: PUSH
67783: LD_INT 1
67785: EQUAL
67786: PUSH
67787: LD_EXP 64
67791: PUSH
67792: LD_VAR 0 2
67796: ARRAY
67797: PUSH
67798: LD_VAR 0 3
67802: ARRAY
67803: PPUSH
67804: CALL_OW 459
67808: NOT
67809: AND
67810: PUSH
67811: LD_EXP 64
67815: PUSH
67816: LD_VAR 0 2
67820: ARRAY
67821: PUSH
67822: LD_VAR 0 3
67826: ARRAY
67827: PPUSH
67828: CALL_OW 314
67832: NOT
67833: AND
67834: IFFALSE 67994
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67836: LD_EXP 64
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PUSH
67847: LD_VAR 0 3
67851: ARRAY
67852: PPUSH
67853: CALL_OW 310
67857: IFFALSE 67880
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67859: LD_EXP 64
67863: PUSH
67864: LD_VAR 0 2
67868: ARRAY
67869: PUSH
67870: LD_VAR 0 3
67874: ARRAY
67875: PPUSH
67876: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67880: LD_EXP 64
67884: PUSH
67885: LD_VAR 0 2
67889: ARRAY
67890: PUSH
67891: LD_VAR 0 3
67895: ARRAY
67896: PPUSH
67897: CALL_OW 314
67901: NOT
67902: IFFALSE 67994
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67904: LD_ADDR_VAR 0 7
67908: PUSH
67909: LD_INT 1
67911: PPUSH
67912: LD_EXP 63
67916: PUSH
67917: LD_VAR 0 2
67921: ARRAY
67922: PPUSH
67923: CALL_OW 12
67927: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67928: LD_EXP 64
67932: PUSH
67933: LD_VAR 0 2
67937: ARRAY
67938: PUSH
67939: LD_VAR 0 3
67943: ARRAY
67944: PPUSH
67945: LD_EXP 63
67949: PUSH
67950: LD_VAR 0 2
67954: ARRAY
67955: PUSH
67956: LD_VAR 0 7
67960: ARRAY
67961: PUSH
67962: LD_INT 1
67964: ARRAY
67965: PPUSH
67966: LD_EXP 63
67970: PUSH
67971: LD_VAR 0 2
67975: ARRAY
67976: PUSH
67977: LD_VAR 0 7
67981: ARRAY
67982: PUSH
67983: LD_INT 2
67985: ARRAY
67986: PPUSH
67987: LD_INT 0
67989: PPUSH
67990: CALL_OW 193
// end ; end ; end ;
67994: GO 67647
67996: POP
67997: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67998: LD_ADDR_VAR 0 5
68002: PUSH
68003: LD_EXP 50
68007: PUSH
68008: LD_VAR 0 2
68012: ARRAY
68013: PPUSH
68014: LD_INT 2
68016: PUSH
68017: LD_INT 30
68019: PUSH
68020: LD_INT 4
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PUSH
68027: LD_INT 30
68029: PUSH
68030: LD_INT 5
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 30
68039: PUSH
68040: LD_INT 32
68042: PUSH
68043: EMPTY
68044: LIST
68045: LIST
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: PPUSH
68053: CALL_OW 72
68057: ST_TO_ADDR
// if not tmp then
68058: LD_VAR 0 5
68062: NOT
68063: IFFALSE 68067
// continue ;
68065: GO 67560
// list := [ ] ;
68067: LD_ADDR_VAR 0 6
68071: PUSH
68072: EMPTY
68073: ST_TO_ADDR
// for j in tmp do
68074: LD_ADDR_VAR 0 3
68078: PUSH
68079: LD_VAR 0 5
68083: PUSH
68084: FOR_IN
68085: IFFALSE 68154
// begin for k in UnitsInside ( j ) do
68087: LD_ADDR_VAR 0 4
68091: PUSH
68092: LD_VAR 0 3
68096: PPUSH
68097: CALL_OW 313
68101: PUSH
68102: FOR_IN
68103: IFFALSE 68150
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68105: LD_VAR 0 4
68109: PPUSH
68110: CALL_OW 257
68114: PUSH
68115: LD_INT 1
68117: EQUAL
68118: PUSH
68119: LD_VAR 0 4
68123: PPUSH
68124: CALL_OW 459
68128: NOT
68129: AND
68130: IFFALSE 68148
// list := list ^ k ;
68132: LD_ADDR_VAR 0 6
68136: PUSH
68137: LD_VAR 0 6
68141: PUSH
68142: LD_VAR 0 4
68146: ADD
68147: ST_TO_ADDR
68148: GO 68102
68150: POP
68151: POP
// end ;
68152: GO 68084
68154: POP
68155: POP
// list := list diff mc_miners [ i ] ;
68156: LD_ADDR_VAR 0 6
68160: PUSH
68161: LD_VAR 0 6
68165: PUSH
68166: LD_EXP 64
68170: PUSH
68171: LD_VAR 0 2
68175: ARRAY
68176: DIFF
68177: ST_TO_ADDR
// if not list then
68178: LD_VAR 0 6
68182: NOT
68183: IFFALSE 68187
// continue ;
68185: GO 67560
// k := mc_mines [ i ] - mc_miners [ i ] ;
68187: LD_ADDR_VAR 0 4
68191: PUSH
68192: LD_EXP 63
68196: PUSH
68197: LD_VAR 0 2
68201: ARRAY
68202: PUSH
68203: LD_EXP 64
68207: PUSH
68208: LD_VAR 0 2
68212: ARRAY
68213: MINUS
68214: ST_TO_ADDR
// if k > list then
68215: LD_VAR 0 4
68219: PUSH
68220: LD_VAR 0 6
68224: GREATER
68225: IFFALSE 68237
// k := list ;
68227: LD_ADDR_VAR 0 4
68231: PUSH
68232: LD_VAR 0 6
68236: ST_TO_ADDR
// for j = 1 to k do
68237: LD_ADDR_VAR 0 3
68241: PUSH
68242: DOUBLE
68243: LD_INT 1
68245: DEC
68246: ST_TO_ADDR
68247: LD_VAR 0 4
68251: PUSH
68252: FOR_TO
68253: IFFALSE 68307
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68255: LD_ADDR_EXP 64
68259: PUSH
68260: LD_EXP 64
68264: PPUSH
68265: LD_VAR 0 2
68269: PUSH
68270: LD_EXP 64
68274: PUSH
68275: LD_VAR 0 2
68279: ARRAY
68280: PUSH
68281: LD_INT 1
68283: PLUS
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PPUSH
68289: LD_VAR 0 6
68293: PUSH
68294: LD_VAR 0 3
68298: ARRAY
68299: PPUSH
68300: CALL 18748 0 3
68304: ST_TO_ADDR
68305: GO 68252
68307: POP
68308: POP
// end ;
68309: GO 67560
68311: POP
68312: POP
// end ;
68313: LD_VAR 0 1
68317: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68318: LD_INT 0
68320: PPUSH
68321: PPUSH
68322: PPUSH
68323: PPUSH
68324: PPUSH
68325: PPUSH
68326: PPUSH
68327: PPUSH
68328: PPUSH
68329: PPUSH
68330: PPUSH
// if not mc_bases then
68331: LD_EXP 50
68335: NOT
68336: IFFALSE 68340
// exit ;
68338: GO 70163
// for i = 1 to mc_bases do
68340: LD_ADDR_VAR 0 2
68344: PUSH
68345: DOUBLE
68346: LD_INT 1
68348: DEC
68349: ST_TO_ADDR
68350: LD_EXP 50
68354: PUSH
68355: FOR_TO
68356: IFFALSE 70161
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68358: LD_EXP 50
68362: PUSH
68363: LD_VAR 0 2
68367: ARRAY
68368: NOT
68369: PUSH
68370: LD_EXP 57
68374: PUSH
68375: LD_VAR 0 2
68379: ARRAY
68380: OR
68381: IFFALSE 68385
// continue ;
68383: GO 68355
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68385: LD_EXP 66
68389: PUSH
68390: LD_VAR 0 2
68394: ARRAY
68395: NOT
68396: PUSH
68397: LD_EXP 67
68401: PUSH
68402: LD_VAR 0 2
68406: ARRAY
68407: AND
68408: IFFALSE 68446
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68410: LD_ADDR_EXP 67
68414: PUSH
68415: LD_EXP 67
68419: PPUSH
68420: LD_VAR 0 2
68424: PPUSH
68425: EMPTY
68426: PPUSH
68427: CALL_OW 1
68431: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68432: LD_VAR 0 2
68436: PPUSH
68437: LD_INT 107
68439: PPUSH
68440: CALL 59193 0 2
// continue ;
68444: GO 68355
// end ; target := [ ] ;
68446: LD_ADDR_VAR 0 7
68450: PUSH
68451: EMPTY
68452: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68453: LD_ADDR_VAR 0 6
68457: PUSH
68458: LD_EXP 50
68462: PUSH
68463: LD_VAR 0 2
68467: ARRAY
68468: PUSH
68469: LD_INT 1
68471: ARRAY
68472: PPUSH
68473: CALL_OW 255
68477: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68478: LD_ADDR_VAR 0 9
68482: PUSH
68483: LD_EXP 50
68487: PUSH
68488: LD_VAR 0 2
68492: ARRAY
68493: PPUSH
68494: LD_INT 2
68496: PUSH
68497: LD_INT 30
68499: PUSH
68500: LD_INT 0
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: PUSH
68507: LD_INT 30
68509: PUSH
68510: LD_INT 1
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: LIST
68521: PPUSH
68522: CALL_OW 72
68526: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68527: LD_ADDR_VAR 0 3
68531: PUSH
68532: DOUBLE
68533: LD_EXP 66
68537: PUSH
68538: LD_VAR 0 2
68542: ARRAY
68543: INC
68544: ST_TO_ADDR
68545: LD_INT 1
68547: PUSH
68548: FOR_DOWNTO
68549: IFFALSE 68794
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68551: LD_EXP 66
68555: PUSH
68556: LD_VAR 0 2
68560: ARRAY
68561: PUSH
68562: LD_VAR 0 3
68566: ARRAY
68567: PUSH
68568: LD_INT 2
68570: ARRAY
68571: PPUSH
68572: LD_EXP 66
68576: PUSH
68577: LD_VAR 0 2
68581: ARRAY
68582: PUSH
68583: LD_VAR 0 3
68587: ARRAY
68588: PUSH
68589: LD_INT 3
68591: ARRAY
68592: PPUSH
68593: CALL_OW 488
68597: PUSH
68598: LD_EXP 66
68602: PUSH
68603: LD_VAR 0 2
68607: ARRAY
68608: PUSH
68609: LD_VAR 0 3
68613: ARRAY
68614: PUSH
68615: LD_INT 2
68617: ARRAY
68618: PPUSH
68619: LD_EXP 66
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: PUSH
68630: LD_VAR 0 3
68634: ARRAY
68635: PUSH
68636: LD_INT 3
68638: ARRAY
68639: PPUSH
68640: CALL_OW 284
68644: PUSH
68645: LD_INT 0
68647: EQUAL
68648: AND
68649: IFFALSE 68704
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68651: LD_ADDR_VAR 0 5
68655: PUSH
68656: LD_EXP 66
68660: PUSH
68661: LD_VAR 0 2
68665: ARRAY
68666: PPUSH
68667: LD_VAR 0 3
68671: PPUSH
68672: CALL_OW 3
68676: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68677: LD_ADDR_EXP 66
68681: PUSH
68682: LD_EXP 66
68686: PPUSH
68687: LD_VAR 0 2
68691: PPUSH
68692: LD_VAR 0 5
68696: PPUSH
68697: CALL_OW 1
68701: ST_TO_ADDR
// continue ;
68702: GO 68548
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68704: LD_VAR 0 6
68708: PPUSH
68709: LD_EXP 66
68713: PUSH
68714: LD_VAR 0 2
68718: ARRAY
68719: PUSH
68720: LD_VAR 0 3
68724: ARRAY
68725: PUSH
68726: LD_INT 2
68728: ARRAY
68729: PPUSH
68730: LD_EXP 66
68734: PUSH
68735: LD_VAR 0 2
68739: ARRAY
68740: PUSH
68741: LD_VAR 0 3
68745: ARRAY
68746: PUSH
68747: LD_INT 3
68749: ARRAY
68750: PPUSH
68751: LD_INT 30
68753: PPUSH
68754: CALL 19644 0 4
68758: PUSH
68759: LD_INT 4
68761: ARRAY
68762: PUSH
68763: LD_INT 0
68765: EQUAL
68766: IFFALSE 68792
// begin target := mc_crates [ i ] [ j ] ;
68768: LD_ADDR_VAR 0 7
68772: PUSH
68773: LD_EXP 66
68777: PUSH
68778: LD_VAR 0 2
68782: ARRAY
68783: PUSH
68784: LD_VAR 0 3
68788: ARRAY
68789: ST_TO_ADDR
// break ;
68790: GO 68794
// end ; end ;
68792: GO 68548
68794: POP
68795: POP
// if not target then
68796: LD_VAR 0 7
68800: NOT
68801: IFFALSE 68805
// continue ;
68803: GO 68355
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68805: LD_ADDR_VAR 0 8
68809: PUSH
68810: LD_EXP 69
68814: PUSH
68815: LD_VAR 0 2
68819: ARRAY
68820: PPUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 3
68826: PUSH
68827: LD_INT 58
68829: PUSH
68830: EMPTY
68831: LIST
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 61
68839: PUSH
68840: EMPTY
68841: LIST
68842: PUSH
68843: LD_INT 33
68845: PUSH
68846: LD_INT 5
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 33
68855: PUSH
68856: LD_INT 3
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 2
68872: PUSH
68873: LD_INT 34
68875: PUSH
68876: LD_INT 32
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 34
68885: PUSH
68886: LD_INT 51
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 34
68895: PUSH
68896: LD_INT 12
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PPUSH
68913: CALL_OW 72
68917: ST_TO_ADDR
// if not cargo then
68918: LD_VAR 0 8
68922: NOT
68923: IFFALSE 69629
// begin if mc_crates_collector [ i ] < 5 then
68925: LD_EXP 67
68929: PUSH
68930: LD_VAR 0 2
68934: ARRAY
68935: PUSH
68936: LD_INT 5
68938: LESS
68939: IFFALSE 69305
// begin if mc_ape [ i ] then
68941: LD_EXP 79
68945: PUSH
68946: LD_VAR 0 2
68950: ARRAY
68951: IFFALSE 68998
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68953: LD_ADDR_VAR 0 5
68957: PUSH
68958: LD_EXP 79
68962: PUSH
68963: LD_VAR 0 2
68967: ARRAY
68968: PPUSH
68969: LD_INT 25
68971: PUSH
68972: LD_INT 16
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 24
68981: PUSH
68982: LD_INT 750
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PPUSH
68993: CALL_OW 72
68997: ST_TO_ADDR
// if not tmp then
68998: LD_VAR 0 5
69002: NOT
69003: IFFALSE 69050
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69005: LD_ADDR_VAR 0 5
69009: PUSH
69010: LD_EXP 50
69014: PUSH
69015: LD_VAR 0 2
69019: ARRAY
69020: PPUSH
69021: LD_INT 25
69023: PUSH
69024: LD_INT 2
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 24
69033: PUSH
69034: LD_INT 750
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PPUSH
69045: CALL_OW 72
69049: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
69050: LD_EXP 79
69054: PUSH
69055: LD_VAR 0 2
69059: ARRAY
69060: PUSH
69061: LD_EXP 50
69065: PUSH
69066: LD_VAR 0 2
69070: ARRAY
69071: PPUSH
69072: LD_INT 25
69074: PUSH
69075: LD_INT 2
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: LD_INT 24
69084: PUSH
69085: LD_INT 750
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PPUSH
69096: CALL_OW 72
69100: AND
69101: PUSH
69102: LD_VAR 0 5
69106: PUSH
69107: LD_INT 5
69109: LESS
69110: AND
69111: IFFALSE 69193
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69113: LD_ADDR_VAR 0 3
69117: PUSH
69118: LD_EXP 50
69122: PUSH
69123: LD_VAR 0 2
69127: ARRAY
69128: PPUSH
69129: LD_INT 25
69131: PUSH
69132: LD_INT 2
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 24
69141: PUSH
69142: LD_INT 750
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PPUSH
69153: CALL_OW 72
69157: PUSH
69158: FOR_IN
69159: IFFALSE 69191
// begin tmp := tmp union j ;
69161: LD_ADDR_VAR 0 5
69165: PUSH
69166: LD_VAR 0 5
69170: PUSH
69171: LD_VAR 0 3
69175: UNION
69176: ST_TO_ADDR
// if tmp >= 5 then
69177: LD_VAR 0 5
69181: PUSH
69182: LD_INT 5
69184: GREATEREQUAL
69185: IFFALSE 69189
// break ;
69187: GO 69191
// end ;
69189: GO 69158
69191: POP
69192: POP
// end ; if not tmp then
69193: LD_VAR 0 5
69197: NOT
69198: IFFALSE 69202
// continue ;
69200: GO 68355
// for j in tmp do
69202: LD_ADDR_VAR 0 3
69206: PUSH
69207: LD_VAR 0 5
69211: PUSH
69212: FOR_IN
69213: IFFALSE 69303
// if not GetTag ( j ) then
69215: LD_VAR 0 3
69219: PPUSH
69220: CALL_OW 110
69224: NOT
69225: IFFALSE 69301
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69227: LD_ADDR_EXP 67
69231: PUSH
69232: LD_EXP 67
69236: PPUSH
69237: LD_VAR 0 2
69241: PUSH
69242: LD_EXP 67
69246: PUSH
69247: LD_VAR 0 2
69251: ARRAY
69252: PUSH
69253: LD_INT 1
69255: PLUS
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PPUSH
69261: LD_VAR 0 3
69265: PPUSH
69266: CALL 18748 0 3
69270: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69271: LD_VAR 0 3
69275: PPUSH
69276: LD_INT 107
69278: PPUSH
69279: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69283: LD_EXP 67
69287: PUSH
69288: LD_VAR 0 2
69292: ARRAY
69293: PUSH
69294: LD_INT 5
69296: GREATEREQUAL
69297: IFFALSE 69301
// break ;
69299: GO 69303
// end ;
69301: GO 69212
69303: POP
69304: POP
// end ; if mc_crates_collector [ i ] and target then
69305: LD_EXP 67
69309: PUSH
69310: LD_VAR 0 2
69314: ARRAY
69315: PUSH
69316: LD_VAR 0 7
69320: AND
69321: IFFALSE 69627
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69323: LD_EXP 67
69327: PUSH
69328: LD_VAR 0 2
69332: ARRAY
69333: PUSH
69334: LD_VAR 0 7
69338: PUSH
69339: LD_INT 1
69341: ARRAY
69342: LESS
69343: IFFALSE 69363
// tmp := mc_crates_collector [ i ] else
69345: LD_ADDR_VAR 0 5
69349: PUSH
69350: LD_EXP 67
69354: PUSH
69355: LD_VAR 0 2
69359: ARRAY
69360: ST_TO_ADDR
69361: GO 69377
// tmp := target [ 1 ] ;
69363: LD_ADDR_VAR 0 5
69367: PUSH
69368: LD_VAR 0 7
69372: PUSH
69373: LD_INT 1
69375: ARRAY
69376: ST_TO_ADDR
// k := 0 ;
69377: LD_ADDR_VAR 0 4
69381: PUSH
69382: LD_INT 0
69384: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69385: LD_ADDR_VAR 0 3
69389: PUSH
69390: LD_EXP 67
69394: PUSH
69395: LD_VAR 0 2
69399: ARRAY
69400: PUSH
69401: FOR_IN
69402: IFFALSE 69625
// begin k := k + 1 ;
69404: LD_ADDR_VAR 0 4
69408: PUSH
69409: LD_VAR 0 4
69413: PUSH
69414: LD_INT 1
69416: PLUS
69417: ST_TO_ADDR
// if k > tmp then
69418: LD_VAR 0 4
69422: PUSH
69423: LD_VAR 0 5
69427: GREATER
69428: IFFALSE 69432
// break ;
69430: GO 69625
// if not GetClass ( j ) in [ 2 , 16 ] then
69432: LD_VAR 0 3
69436: PPUSH
69437: CALL_OW 257
69441: PUSH
69442: LD_INT 2
69444: PUSH
69445: LD_INT 16
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: IN
69452: NOT
69453: IFFALSE 69506
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69455: LD_ADDR_EXP 67
69459: PUSH
69460: LD_EXP 67
69464: PPUSH
69465: LD_VAR 0 2
69469: PPUSH
69470: LD_EXP 67
69474: PUSH
69475: LD_VAR 0 2
69479: ARRAY
69480: PUSH
69481: LD_VAR 0 3
69485: DIFF
69486: PPUSH
69487: CALL_OW 1
69491: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69492: LD_VAR 0 3
69496: PPUSH
69497: LD_INT 0
69499: PPUSH
69500: CALL_OW 109
// continue ;
69504: GO 69401
// end ; if IsInUnit ( j ) then
69506: LD_VAR 0 3
69510: PPUSH
69511: CALL_OW 310
69515: IFFALSE 69526
// ComExitBuilding ( j ) ;
69517: LD_VAR 0 3
69521: PPUSH
69522: CALL_OW 122
// wait ( 3 ) ;
69526: LD_INT 3
69528: PPUSH
69529: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69533: LD_VAR 0 3
69537: PPUSH
69538: CALL_OW 314
69542: PUSH
69543: LD_VAR 0 6
69547: PPUSH
69548: LD_VAR 0 7
69552: PUSH
69553: LD_INT 2
69555: ARRAY
69556: PPUSH
69557: LD_VAR 0 7
69561: PUSH
69562: LD_INT 3
69564: ARRAY
69565: PPUSH
69566: LD_INT 30
69568: PPUSH
69569: CALL 19644 0 4
69573: PUSH
69574: LD_INT 4
69576: ARRAY
69577: AND
69578: IFFALSE 69596
// ComStandNearbyBuilding ( j , depot ) else
69580: LD_VAR 0 3
69584: PPUSH
69585: LD_VAR 0 9
69589: PPUSH
69590: CALL 15175 0 2
69594: GO 69623
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69596: LD_VAR 0 3
69600: PPUSH
69601: LD_VAR 0 7
69605: PUSH
69606: LD_INT 2
69608: ARRAY
69609: PPUSH
69610: LD_VAR 0 7
69614: PUSH
69615: LD_INT 3
69617: ARRAY
69618: PPUSH
69619: CALL_OW 117
// end ;
69623: GO 69401
69625: POP
69626: POP
// end ; end else
69627: GO 70159
// begin for j in cargo do
69629: LD_ADDR_VAR 0 3
69633: PUSH
69634: LD_VAR 0 8
69638: PUSH
69639: FOR_IN
69640: IFFALSE 70157
// begin if GetTag ( j ) <> 0 then
69642: LD_VAR 0 3
69646: PPUSH
69647: CALL_OW 110
69651: PUSH
69652: LD_INT 0
69654: NONEQUAL
69655: IFFALSE 69659
// continue ;
69657: GO 69639
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69659: LD_VAR 0 3
69663: PPUSH
69664: CALL_OW 256
69668: PUSH
69669: LD_INT 1000
69671: LESS
69672: PUSH
69673: LD_VAR 0 3
69677: PPUSH
69678: LD_EXP 74
69682: PUSH
69683: LD_VAR 0 2
69687: ARRAY
69688: PPUSH
69689: CALL_OW 308
69693: NOT
69694: AND
69695: IFFALSE 69717
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69697: LD_VAR 0 3
69701: PPUSH
69702: LD_EXP 74
69706: PUSH
69707: LD_VAR 0 2
69711: ARRAY
69712: PPUSH
69713: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69717: LD_VAR 0 3
69721: PPUSH
69722: CALL_OW 256
69726: PUSH
69727: LD_INT 1000
69729: LESS
69730: PUSH
69731: LD_VAR 0 3
69735: PPUSH
69736: LD_EXP 74
69740: PUSH
69741: LD_VAR 0 2
69745: ARRAY
69746: PPUSH
69747: CALL_OW 308
69751: AND
69752: IFFALSE 69756
// continue ;
69754: GO 69639
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69756: LD_VAR 0 3
69760: PPUSH
69761: CALL_OW 262
69765: PUSH
69766: LD_INT 2
69768: EQUAL
69769: PUSH
69770: LD_VAR 0 3
69774: PPUSH
69775: CALL_OW 261
69779: PUSH
69780: LD_INT 15
69782: LESS
69783: AND
69784: IFFALSE 69788
// continue ;
69786: GO 69639
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69788: LD_VAR 0 3
69792: PPUSH
69793: CALL_OW 262
69797: PUSH
69798: LD_INT 1
69800: EQUAL
69801: PUSH
69802: LD_VAR 0 3
69806: PPUSH
69807: CALL_OW 261
69811: PUSH
69812: LD_INT 10
69814: LESS
69815: AND
69816: IFFALSE 70096
// begin if not depot then
69818: LD_VAR 0 9
69822: NOT
69823: IFFALSE 69827
// continue ;
69825: GO 69639
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69827: LD_VAR 0 3
69831: PPUSH
69832: LD_VAR 0 9
69836: PPUSH
69837: LD_VAR 0 3
69841: PPUSH
69842: CALL_OW 74
69846: PPUSH
69847: CALL_OW 296
69851: PUSH
69852: LD_INT 6
69854: LESS
69855: IFFALSE 69871
// SetFuel ( j , 100 ) else
69857: LD_VAR 0 3
69861: PPUSH
69862: LD_INT 100
69864: PPUSH
69865: CALL_OW 240
69869: GO 70096
// if GetFuel ( j ) = 0 then
69871: LD_VAR 0 3
69875: PPUSH
69876: CALL_OW 261
69880: PUSH
69881: LD_INT 0
69883: EQUAL
69884: IFFALSE 70096
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69886: LD_ADDR_EXP 69
69890: PUSH
69891: LD_EXP 69
69895: PPUSH
69896: LD_VAR 0 2
69900: PPUSH
69901: LD_EXP 69
69905: PUSH
69906: LD_VAR 0 2
69910: ARRAY
69911: PUSH
69912: LD_VAR 0 3
69916: DIFF
69917: PPUSH
69918: CALL_OW 1
69922: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69923: LD_VAR 0 3
69927: PPUSH
69928: CALL_OW 263
69932: PUSH
69933: LD_INT 1
69935: EQUAL
69936: IFFALSE 69952
// ComExitVehicle ( IsInUnit ( j ) ) ;
69938: LD_VAR 0 3
69942: PPUSH
69943: CALL_OW 310
69947: PPUSH
69948: CALL_OW 121
// if GetControl ( j ) = control_remote then
69952: LD_VAR 0 3
69956: PPUSH
69957: CALL_OW 263
69961: PUSH
69962: LD_INT 2
69964: EQUAL
69965: IFFALSE 69976
// ComUnlink ( j ) ;
69967: LD_VAR 0 3
69971: PPUSH
69972: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69976: LD_ADDR_VAR 0 10
69980: PUSH
69981: LD_VAR 0 2
69985: PPUSH
69986: LD_INT 3
69988: PPUSH
69989: CALL 79763 0 2
69993: ST_TO_ADDR
// if fac then
69994: LD_VAR 0 10
69998: IFFALSE 70094
// begin for k in fac do
70000: LD_ADDR_VAR 0 4
70004: PUSH
70005: LD_VAR 0 10
70009: PUSH
70010: FOR_IN
70011: IFFALSE 70092
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70013: LD_ADDR_VAR 0 11
70017: PUSH
70018: LD_VAR 0 10
70022: PPUSH
70023: LD_VAR 0 3
70027: PPUSH
70028: CALL_OW 265
70032: PPUSH
70033: LD_VAR 0 3
70037: PPUSH
70038: CALL_OW 262
70042: PPUSH
70043: LD_VAR 0 3
70047: PPUSH
70048: CALL_OW 263
70052: PPUSH
70053: LD_VAR 0 3
70057: PPUSH
70058: CALL_OW 264
70062: PPUSH
70063: CALL 16246 0 5
70067: ST_TO_ADDR
// if components then
70068: LD_VAR 0 11
70072: IFFALSE 70090
// begin MC_InsertProduceList ( i , components ) ;
70074: LD_VAR 0 2
70078: PPUSH
70079: LD_VAR 0 11
70083: PPUSH
70084: CALL 79308 0 2
// break ;
70088: GO 70092
// end ; end ;
70090: GO 70010
70092: POP
70093: POP
// end ; continue ;
70094: GO 69639
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70096: LD_VAR 0 3
70100: PPUSH
70101: LD_INT 1
70103: PPUSH
70104: CALL_OW 289
70108: PUSH
70109: LD_INT 100
70111: LESS
70112: PUSH
70113: LD_VAR 0 3
70117: PPUSH
70118: CALL_OW 314
70122: NOT
70123: AND
70124: IFFALSE 70153
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70126: LD_VAR 0 3
70130: PPUSH
70131: LD_VAR 0 7
70135: PUSH
70136: LD_INT 2
70138: ARRAY
70139: PPUSH
70140: LD_VAR 0 7
70144: PUSH
70145: LD_INT 3
70147: ARRAY
70148: PPUSH
70149: CALL_OW 117
// break ;
70153: GO 70157
// end ;
70155: GO 69639
70157: POP
70158: POP
// end ; end ;
70159: GO 68355
70161: POP
70162: POP
// end ;
70163: LD_VAR 0 1
70167: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70168: LD_INT 0
70170: PPUSH
70171: PPUSH
70172: PPUSH
70173: PPUSH
// if not mc_bases then
70174: LD_EXP 50
70178: NOT
70179: IFFALSE 70183
// exit ;
70181: GO 70344
// for i = 1 to mc_bases do
70183: LD_ADDR_VAR 0 2
70187: PUSH
70188: DOUBLE
70189: LD_INT 1
70191: DEC
70192: ST_TO_ADDR
70193: LD_EXP 50
70197: PUSH
70198: FOR_TO
70199: IFFALSE 70342
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70201: LD_ADDR_VAR 0 4
70205: PUSH
70206: LD_EXP 69
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: PUSH
70217: LD_EXP 72
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: UNION
70228: PPUSH
70229: LD_INT 33
70231: PUSH
70232: LD_INT 2
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PPUSH
70239: CALL_OW 72
70243: ST_TO_ADDR
// if tmp then
70244: LD_VAR 0 4
70248: IFFALSE 70340
// for j in tmp do
70250: LD_ADDR_VAR 0 3
70254: PUSH
70255: LD_VAR 0 4
70259: PUSH
70260: FOR_IN
70261: IFFALSE 70338
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70263: LD_VAR 0 3
70267: PPUSH
70268: CALL_OW 312
70272: NOT
70273: PUSH
70274: LD_VAR 0 3
70278: PPUSH
70279: CALL_OW 256
70283: PUSH
70284: LD_INT 250
70286: GREATEREQUAL
70287: AND
70288: IFFALSE 70301
// Connect ( j ) else
70290: LD_VAR 0 3
70294: PPUSH
70295: CALL 21717 0 1
70299: GO 70336
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70301: LD_VAR 0 3
70305: PPUSH
70306: CALL_OW 256
70310: PUSH
70311: LD_INT 250
70313: LESS
70314: PUSH
70315: LD_VAR 0 3
70319: PPUSH
70320: CALL_OW 312
70324: AND
70325: IFFALSE 70336
// ComUnlink ( j ) ;
70327: LD_VAR 0 3
70331: PPUSH
70332: CALL_OW 136
70336: GO 70260
70338: POP
70339: POP
// end ;
70340: GO 70198
70342: POP
70343: POP
// end ;
70344: LD_VAR 0 1
70348: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70349: LD_INT 0
70351: PPUSH
70352: PPUSH
70353: PPUSH
70354: PPUSH
70355: PPUSH
// if not mc_bases then
70356: LD_EXP 50
70360: NOT
70361: IFFALSE 70365
// exit ;
70363: GO 70810
// for i = 1 to mc_bases do
70365: LD_ADDR_VAR 0 2
70369: PUSH
70370: DOUBLE
70371: LD_INT 1
70373: DEC
70374: ST_TO_ADDR
70375: LD_EXP 50
70379: PUSH
70380: FOR_TO
70381: IFFALSE 70808
// begin if not mc_produce [ i ] then
70383: LD_EXP 71
70387: PUSH
70388: LD_VAR 0 2
70392: ARRAY
70393: NOT
70394: IFFALSE 70398
// continue ;
70396: GO 70380
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70398: LD_ADDR_VAR 0 5
70402: PUSH
70403: LD_EXP 50
70407: PUSH
70408: LD_VAR 0 2
70412: ARRAY
70413: PPUSH
70414: LD_INT 30
70416: PUSH
70417: LD_INT 3
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: PPUSH
70424: CALL_OW 72
70428: ST_TO_ADDR
// if not fac then
70429: LD_VAR 0 5
70433: NOT
70434: IFFALSE 70438
// continue ;
70436: GO 70380
// for j in fac do
70438: LD_ADDR_VAR 0 3
70442: PUSH
70443: LD_VAR 0 5
70447: PUSH
70448: FOR_IN
70449: IFFALSE 70804
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70451: LD_VAR 0 3
70455: PPUSH
70456: CALL_OW 461
70460: PUSH
70461: LD_INT 2
70463: NONEQUAL
70464: PUSH
70465: LD_VAR 0 3
70469: PPUSH
70470: LD_INT 15
70472: PPUSH
70473: CALL 21345 0 2
70477: PUSH
70478: LD_INT 4
70480: ARRAY
70481: OR
70482: IFFALSE 70486
// continue ;
70484: GO 70448
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70486: LD_VAR 0 3
70490: PPUSH
70491: LD_EXP 71
70495: PUSH
70496: LD_VAR 0 2
70500: ARRAY
70501: PUSH
70502: LD_INT 1
70504: ARRAY
70505: PUSH
70506: LD_INT 1
70508: ARRAY
70509: PPUSH
70510: LD_EXP 71
70514: PUSH
70515: LD_VAR 0 2
70519: ARRAY
70520: PUSH
70521: LD_INT 1
70523: ARRAY
70524: PUSH
70525: LD_INT 2
70527: ARRAY
70528: PPUSH
70529: LD_EXP 71
70533: PUSH
70534: LD_VAR 0 2
70538: ARRAY
70539: PUSH
70540: LD_INT 1
70542: ARRAY
70543: PUSH
70544: LD_INT 3
70546: ARRAY
70547: PPUSH
70548: LD_EXP 71
70552: PUSH
70553: LD_VAR 0 2
70557: ARRAY
70558: PUSH
70559: LD_INT 1
70561: ARRAY
70562: PUSH
70563: LD_INT 4
70565: ARRAY
70566: PPUSH
70567: CALL_OW 448
70571: PUSH
70572: LD_VAR 0 3
70576: PPUSH
70577: LD_EXP 71
70581: PUSH
70582: LD_VAR 0 2
70586: ARRAY
70587: PUSH
70588: LD_INT 1
70590: ARRAY
70591: PUSH
70592: LD_INT 1
70594: ARRAY
70595: PUSH
70596: LD_EXP 71
70600: PUSH
70601: LD_VAR 0 2
70605: ARRAY
70606: PUSH
70607: LD_INT 1
70609: ARRAY
70610: PUSH
70611: LD_INT 2
70613: ARRAY
70614: PUSH
70615: LD_EXP 71
70619: PUSH
70620: LD_VAR 0 2
70624: ARRAY
70625: PUSH
70626: LD_INT 1
70628: ARRAY
70629: PUSH
70630: LD_INT 3
70632: ARRAY
70633: PUSH
70634: LD_EXP 71
70638: PUSH
70639: LD_VAR 0 2
70643: ARRAY
70644: PUSH
70645: LD_INT 1
70647: ARRAY
70648: PUSH
70649: LD_INT 4
70651: ARRAY
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: PPUSH
70659: CALL 25112 0 2
70663: AND
70664: IFFALSE 70802
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70666: LD_VAR 0 3
70670: PPUSH
70671: LD_EXP 71
70675: PUSH
70676: LD_VAR 0 2
70680: ARRAY
70681: PUSH
70682: LD_INT 1
70684: ARRAY
70685: PUSH
70686: LD_INT 1
70688: ARRAY
70689: PPUSH
70690: LD_EXP 71
70694: PUSH
70695: LD_VAR 0 2
70699: ARRAY
70700: PUSH
70701: LD_INT 1
70703: ARRAY
70704: PUSH
70705: LD_INT 2
70707: ARRAY
70708: PPUSH
70709: LD_EXP 71
70713: PUSH
70714: LD_VAR 0 2
70718: ARRAY
70719: PUSH
70720: LD_INT 1
70722: ARRAY
70723: PUSH
70724: LD_INT 3
70726: ARRAY
70727: PPUSH
70728: LD_EXP 71
70732: PUSH
70733: LD_VAR 0 2
70737: ARRAY
70738: PUSH
70739: LD_INT 1
70741: ARRAY
70742: PUSH
70743: LD_INT 4
70745: ARRAY
70746: PPUSH
70747: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70751: LD_ADDR_VAR 0 4
70755: PUSH
70756: LD_EXP 71
70760: PUSH
70761: LD_VAR 0 2
70765: ARRAY
70766: PPUSH
70767: LD_INT 1
70769: PPUSH
70770: CALL_OW 3
70774: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70775: LD_ADDR_EXP 71
70779: PUSH
70780: LD_EXP 71
70784: PPUSH
70785: LD_VAR 0 2
70789: PPUSH
70790: LD_VAR 0 4
70794: PPUSH
70795: CALL_OW 1
70799: ST_TO_ADDR
// break ;
70800: GO 70804
// end ; end ;
70802: GO 70448
70804: POP
70805: POP
// end ;
70806: GO 70380
70808: POP
70809: POP
// end ;
70810: LD_VAR 0 1
70814: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70815: LD_INT 0
70817: PPUSH
70818: PPUSH
70819: PPUSH
// if not mc_bases then
70820: LD_EXP 50
70824: NOT
70825: IFFALSE 70829
// exit ;
70827: GO 70918
// for i = 1 to mc_bases do
70829: LD_ADDR_VAR 0 2
70833: PUSH
70834: DOUBLE
70835: LD_INT 1
70837: DEC
70838: ST_TO_ADDR
70839: LD_EXP 50
70843: PUSH
70844: FOR_TO
70845: IFFALSE 70916
// begin if mc_attack [ i ] then
70847: LD_EXP 70
70851: PUSH
70852: LD_VAR 0 2
70856: ARRAY
70857: IFFALSE 70914
// begin tmp := mc_attack [ i ] [ 1 ] ;
70859: LD_ADDR_VAR 0 3
70863: PUSH
70864: LD_EXP 70
70868: PUSH
70869: LD_VAR 0 2
70873: ARRAY
70874: PUSH
70875: LD_INT 1
70877: ARRAY
70878: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70879: LD_ADDR_EXP 70
70883: PUSH
70884: LD_EXP 70
70888: PPUSH
70889: LD_VAR 0 2
70893: PPUSH
70894: EMPTY
70895: PPUSH
70896: CALL_OW 1
70900: ST_TO_ADDR
// Attack ( tmp ) ;
70901: LD_VAR 0 3
70905: PPUSH
70906: CALL 105779 0 1
// exit ;
70910: POP
70911: POP
70912: GO 70918
// end ; end ;
70914: GO 70844
70916: POP
70917: POP
// end ;
70918: LD_VAR 0 1
70922: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70923: LD_INT 0
70925: PPUSH
70926: PPUSH
70927: PPUSH
70928: PPUSH
70929: PPUSH
70930: PPUSH
70931: PPUSH
// if not mc_bases then
70932: LD_EXP 50
70936: NOT
70937: IFFALSE 70941
// exit ;
70939: GO 71798
// for i = 1 to mc_bases do
70941: LD_ADDR_VAR 0 2
70945: PUSH
70946: DOUBLE
70947: LD_INT 1
70949: DEC
70950: ST_TO_ADDR
70951: LD_EXP 50
70955: PUSH
70956: FOR_TO
70957: IFFALSE 71796
// begin if not mc_bases [ i ] then
70959: LD_EXP 50
70963: PUSH
70964: LD_VAR 0 2
70968: ARRAY
70969: NOT
70970: IFFALSE 70974
// continue ;
70972: GO 70956
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70974: LD_ADDR_VAR 0 7
70978: PUSH
70979: LD_EXP 50
70983: PUSH
70984: LD_VAR 0 2
70988: ARRAY
70989: PUSH
70990: LD_INT 1
70992: ARRAY
70993: PPUSH
70994: CALL 15397 0 1
70998: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70999: LD_ADDR_EXP 73
71003: PUSH
71004: LD_EXP 73
71008: PPUSH
71009: LD_VAR 0 2
71013: PPUSH
71014: LD_EXP 50
71018: PUSH
71019: LD_VAR 0 2
71023: ARRAY
71024: PUSH
71025: LD_INT 1
71027: ARRAY
71028: PPUSH
71029: CALL_OW 255
71033: PPUSH
71034: LD_EXP 75
71038: PUSH
71039: LD_VAR 0 2
71043: ARRAY
71044: PPUSH
71045: CALL 15362 0 2
71049: PPUSH
71050: CALL_OW 1
71054: ST_TO_ADDR
// if not mc_scan [ i ] then
71055: LD_EXP 73
71059: PUSH
71060: LD_VAR 0 2
71064: ARRAY
71065: NOT
71066: IFFALSE 71244
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
71068: LD_ADDR_EXP 93
71072: PUSH
71073: LD_EXP 93
71077: PPUSH
71078: LD_VAR 0 2
71082: PPUSH
71083: LD_INT 0
71085: PPUSH
71086: CALL_OW 1
71090: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71091: LD_ADDR_VAR 0 4
71095: PUSH
71096: LD_EXP 50
71100: PUSH
71101: LD_VAR 0 2
71105: ARRAY
71106: PPUSH
71107: LD_INT 2
71109: PUSH
71110: LD_INT 25
71112: PUSH
71113: LD_INT 5
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 25
71122: PUSH
71123: LD_INT 8
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 25
71132: PUSH
71133: LD_INT 9
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: PUSH
71140: EMPTY
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: PPUSH
71146: CALL_OW 72
71150: ST_TO_ADDR
// if not tmp then
71151: LD_VAR 0 4
71155: NOT
71156: IFFALSE 71160
// continue ;
71158: GO 70956
// for j in tmp do
71160: LD_ADDR_VAR 0 3
71164: PUSH
71165: LD_VAR 0 4
71169: PUSH
71170: FOR_IN
71171: IFFALSE 71242
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71173: LD_VAR 0 3
71177: PPUSH
71178: CALL_OW 310
71182: PPUSH
71183: CALL_OW 266
71187: PUSH
71188: LD_INT 5
71190: EQUAL
71191: PUSH
71192: LD_VAR 0 3
71196: PPUSH
71197: CALL_OW 257
71201: PUSH
71202: LD_INT 1
71204: EQUAL
71205: AND
71206: PUSH
71207: LD_VAR 0 3
71211: PPUSH
71212: CALL_OW 459
71216: NOT
71217: AND
71218: PUSH
71219: LD_VAR 0 7
71223: AND
71224: IFFALSE 71240
// ComChangeProfession ( j , class ) ;
71226: LD_VAR 0 3
71230: PPUSH
71231: LD_VAR 0 7
71235: PPUSH
71236: CALL_OW 123
71240: GO 71170
71242: POP
71243: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71244: LD_EXP 73
71248: PUSH
71249: LD_VAR 0 2
71253: ARRAY
71254: PUSH
71255: LD_EXP 93
71259: PUSH
71260: LD_VAR 0 2
71264: ARRAY
71265: NOT
71266: AND
71267: PUSH
71268: LD_EXP 72
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: NOT
71279: AND
71280: PUSH
71281: LD_EXP 50
71285: PUSH
71286: LD_VAR 0 2
71290: ARRAY
71291: PPUSH
71292: LD_INT 50
71294: PUSH
71295: EMPTY
71296: LIST
71297: PUSH
71298: LD_INT 2
71300: PUSH
71301: LD_INT 30
71303: PUSH
71304: LD_INT 32
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 30
71313: PUSH
71314: LD_INT 33
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 30
71323: PUSH
71324: LD_INT 4
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 30
71333: PUSH
71334: LD_INT 5
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: PPUSH
71352: CALL_OW 72
71356: PUSH
71357: LD_INT 4
71359: LESS
71360: PUSH
71361: LD_EXP 50
71365: PUSH
71366: LD_VAR 0 2
71370: ARRAY
71371: PPUSH
71372: LD_INT 3
71374: PUSH
71375: LD_INT 24
71377: PUSH
71378: LD_INT 1000
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 2
71391: PUSH
71392: LD_INT 30
71394: PUSH
71395: LD_INT 0
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: LD_INT 30
71404: PUSH
71405: LD_INT 1
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: LIST
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PPUSH
71421: CALL_OW 72
71425: OR
71426: AND
71427: IFFALSE 71678
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71429: LD_ADDR_EXP 93
71433: PUSH
71434: LD_EXP 93
71438: PPUSH
71439: LD_VAR 0 2
71443: PPUSH
71444: LD_INT 1
71446: PPUSH
71447: CALL_OW 1
71451: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71452: LD_ADDR_VAR 0 4
71456: PUSH
71457: LD_EXP 50
71461: PUSH
71462: LD_VAR 0 2
71466: ARRAY
71467: PPUSH
71468: LD_INT 2
71470: PUSH
71471: LD_INT 25
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 25
71483: PUSH
71484: LD_INT 5
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 25
71493: PUSH
71494: LD_INT 8
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 25
71503: PUSH
71504: LD_INT 9
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: LIST
71517: PPUSH
71518: CALL_OW 72
71522: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71523: LD_ADDR_VAR 0 4
71527: PUSH
71528: LD_VAR 0 4
71532: PUSH
71533: LD_VAR 0 4
71537: PPUSH
71538: LD_INT 18
71540: PPUSH
71541: CALL 48660 0 2
71545: DIFF
71546: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71547: LD_VAR 0 4
71551: NOT
71552: PUSH
71553: LD_EXP 50
71557: PUSH
71558: LD_VAR 0 2
71562: ARRAY
71563: PPUSH
71564: LD_INT 2
71566: PUSH
71567: LD_INT 30
71569: PUSH
71570: LD_INT 4
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 30
71579: PUSH
71580: LD_INT 5
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: LIST
71591: PPUSH
71592: CALL_OW 72
71596: NOT
71597: AND
71598: IFFALSE 71660
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71600: LD_ADDR_VAR 0 4
71604: PUSH
71605: LD_EXP 50
71609: PUSH
71610: LD_VAR 0 2
71614: ARRAY
71615: PPUSH
71616: LD_INT 2
71618: PUSH
71619: LD_INT 25
71621: PUSH
71622: LD_INT 2
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 25
71631: PUSH
71632: LD_INT 3
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 25
71641: PUSH
71642: LD_INT 4
71644: PUSH
71645: EMPTY
71646: LIST
71647: LIST
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: PPUSH
71655: CALL_OW 72
71659: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71660: LD_VAR 0 2
71664: PPUSH
71665: LD_VAR 0 4
71669: PPUSH
71670: CALL 110488 0 2
// exit ;
71674: POP
71675: POP
71676: GO 71798
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71678: LD_EXP 73
71682: PUSH
71683: LD_VAR 0 2
71687: ARRAY
71688: PUSH
71689: LD_EXP 93
71693: PUSH
71694: LD_VAR 0 2
71698: ARRAY
71699: NOT
71700: AND
71701: PUSH
71702: LD_EXP 72
71706: PUSH
71707: LD_VAR 0 2
71711: ARRAY
71712: AND
71713: IFFALSE 71794
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71715: LD_ADDR_EXP 93
71719: PUSH
71720: LD_EXP 93
71724: PPUSH
71725: LD_VAR 0 2
71729: PPUSH
71730: LD_INT 1
71732: PPUSH
71733: CALL_OW 1
71737: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71738: LD_ADDR_VAR 0 4
71742: PUSH
71743: LD_EXP 72
71747: PUSH
71748: LD_VAR 0 2
71752: ARRAY
71753: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71754: LD_ADDR_EXP 72
71758: PUSH
71759: LD_EXP 72
71763: PPUSH
71764: LD_VAR 0 2
71768: PPUSH
71769: EMPTY
71770: PPUSH
71771: CALL_OW 1
71775: ST_TO_ADDR
// Defend ( i , tmp ) ;
71776: LD_VAR 0 2
71780: PPUSH
71781: LD_VAR 0 4
71785: PPUSH
71786: CALL 111084 0 2
// exit ;
71790: POP
71791: POP
71792: GO 71798
// end ; end ;
71794: GO 70956
71796: POP
71797: POP
// end ;
71798: LD_VAR 0 1
71802: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71803: LD_INT 0
71805: PPUSH
71806: PPUSH
71807: PPUSH
71808: PPUSH
71809: PPUSH
71810: PPUSH
71811: PPUSH
71812: PPUSH
71813: PPUSH
71814: PPUSH
71815: PPUSH
// if not mc_bases then
71816: LD_EXP 50
71820: NOT
71821: IFFALSE 71825
// exit ;
71823: GO 72912
// for i = 1 to mc_bases do
71825: LD_ADDR_VAR 0 2
71829: PUSH
71830: DOUBLE
71831: LD_INT 1
71833: DEC
71834: ST_TO_ADDR
71835: LD_EXP 50
71839: PUSH
71840: FOR_TO
71841: IFFALSE 72910
// begin tmp := mc_lab [ i ] ;
71843: LD_ADDR_VAR 0 6
71847: PUSH
71848: LD_EXP 83
71852: PUSH
71853: LD_VAR 0 2
71857: ARRAY
71858: ST_TO_ADDR
// if not tmp then
71859: LD_VAR 0 6
71863: NOT
71864: IFFALSE 71868
// continue ;
71866: GO 71840
// idle_lab := 0 ;
71868: LD_ADDR_VAR 0 11
71872: PUSH
71873: LD_INT 0
71875: ST_TO_ADDR
// for j in tmp do
71876: LD_ADDR_VAR 0 3
71880: PUSH
71881: LD_VAR 0 6
71885: PUSH
71886: FOR_IN
71887: IFFALSE 72906
// begin researching := false ;
71889: LD_ADDR_VAR 0 10
71893: PUSH
71894: LD_INT 0
71896: ST_TO_ADDR
// side := GetSide ( j ) ;
71897: LD_ADDR_VAR 0 4
71901: PUSH
71902: LD_VAR 0 3
71906: PPUSH
71907: CALL_OW 255
71911: ST_TO_ADDR
// if not mc_tech [ side ] then
71912: LD_EXP 77
71916: PUSH
71917: LD_VAR 0 4
71921: ARRAY
71922: NOT
71923: IFFALSE 71927
// continue ;
71925: GO 71886
// if BuildingStatus ( j ) = bs_idle then
71927: LD_VAR 0 3
71931: PPUSH
71932: CALL_OW 461
71936: PUSH
71937: LD_INT 2
71939: EQUAL
71940: IFFALSE 72128
// begin if idle_lab and UnitsInside ( j ) < 6 then
71942: LD_VAR 0 11
71946: PUSH
71947: LD_VAR 0 3
71951: PPUSH
71952: CALL_OW 313
71956: PUSH
71957: LD_INT 6
71959: LESS
71960: AND
71961: IFFALSE 72032
// begin tmp2 := UnitsInside ( idle_lab ) ;
71963: LD_ADDR_VAR 0 9
71967: PUSH
71968: LD_VAR 0 11
71972: PPUSH
71973: CALL_OW 313
71977: ST_TO_ADDR
// if tmp2 then
71978: LD_VAR 0 9
71982: IFFALSE 72024
// for x in tmp2 do
71984: LD_ADDR_VAR 0 7
71988: PUSH
71989: LD_VAR 0 9
71993: PUSH
71994: FOR_IN
71995: IFFALSE 72022
// begin ComExitBuilding ( x ) ;
71997: LD_VAR 0 7
72001: PPUSH
72002: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72006: LD_VAR 0 7
72010: PPUSH
72011: LD_VAR 0 3
72015: PPUSH
72016: CALL_OW 180
// end ;
72020: GO 71994
72022: POP
72023: POP
// idle_lab := 0 ;
72024: LD_ADDR_VAR 0 11
72028: PUSH
72029: LD_INT 0
72031: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72032: LD_ADDR_VAR 0 5
72036: PUSH
72037: LD_EXP 77
72041: PUSH
72042: LD_VAR 0 4
72046: ARRAY
72047: PUSH
72048: FOR_IN
72049: IFFALSE 72109
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72051: LD_VAR 0 3
72055: PPUSH
72056: LD_VAR 0 5
72060: PPUSH
72061: CALL_OW 430
72065: PUSH
72066: LD_VAR 0 4
72070: PPUSH
72071: LD_VAR 0 5
72075: PPUSH
72076: CALL 14467 0 2
72080: AND
72081: IFFALSE 72107
// begin researching := true ;
72083: LD_ADDR_VAR 0 10
72087: PUSH
72088: LD_INT 1
72090: ST_TO_ADDR
// ComResearch ( j , t ) ;
72091: LD_VAR 0 3
72095: PPUSH
72096: LD_VAR 0 5
72100: PPUSH
72101: CALL_OW 124
// break ;
72105: GO 72109
// end ;
72107: GO 72048
72109: POP
72110: POP
// if not researching then
72111: LD_VAR 0 10
72115: NOT
72116: IFFALSE 72128
// idle_lab := j ;
72118: LD_ADDR_VAR 0 11
72122: PUSH
72123: LD_VAR 0 3
72127: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72128: LD_VAR 0 3
72132: PPUSH
72133: CALL_OW 461
72137: PUSH
72138: LD_INT 10
72140: EQUAL
72141: IFFALSE 72729
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72143: LD_EXP 79
72147: PUSH
72148: LD_VAR 0 2
72152: ARRAY
72153: NOT
72154: PUSH
72155: LD_EXP 80
72159: PUSH
72160: LD_VAR 0 2
72164: ARRAY
72165: NOT
72166: AND
72167: PUSH
72168: LD_EXP 77
72172: PUSH
72173: LD_VAR 0 4
72177: ARRAY
72178: PUSH
72179: LD_INT 1
72181: GREATER
72182: AND
72183: IFFALSE 72314
// begin ComCancel ( j ) ;
72185: LD_VAR 0 3
72189: PPUSH
72190: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72194: LD_ADDR_EXP 77
72198: PUSH
72199: LD_EXP 77
72203: PPUSH
72204: LD_VAR 0 4
72208: PPUSH
72209: LD_EXP 77
72213: PUSH
72214: LD_VAR 0 4
72218: ARRAY
72219: PPUSH
72220: LD_EXP 77
72224: PUSH
72225: LD_VAR 0 4
72229: ARRAY
72230: PUSH
72231: LD_INT 1
72233: MINUS
72234: PPUSH
72235: LD_EXP 77
72239: PUSH
72240: LD_VAR 0 4
72244: ARRAY
72245: PPUSH
72246: LD_INT 0
72248: PPUSH
72249: CALL 18166 0 4
72253: PPUSH
72254: CALL_OW 1
72258: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72259: LD_ADDR_EXP 77
72263: PUSH
72264: LD_EXP 77
72268: PPUSH
72269: LD_VAR 0 4
72273: PPUSH
72274: LD_EXP 77
72278: PUSH
72279: LD_VAR 0 4
72283: ARRAY
72284: PPUSH
72285: LD_EXP 77
72289: PUSH
72290: LD_VAR 0 4
72294: ARRAY
72295: PPUSH
72296: LD_INT 1
72298: PPUSH
72299: LD_INT 0
72301: PPUSH
72302: CALL 18166 0 4
72306: PPUSH
72307: CALL_OW 1
72311: ST_TO_ADDR
// continue ;
72312: GO 71886
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72314: LD_EXP 79
72318: PUSH
72319: LD_VAR 0 2
72323: ARRAY
72324: PUSH
72325: LD_EXP 80
72329: PUSH
72330: LD_VAR 0 2
72334: ARRAY
72335: NOT
72336: AND
72337: IFFALSE 72464
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72339: LD_ADDR_EXP 80
72343: PUSH
72344: LD_EXP 80
72348: PPUSH
72349: LD_VAR 0 2
72353: PUSH
72354: LD_EXP 80
72358: PUSH
72359: LD_VAR 0 2
72363: ARRAY
72364: PUSH
72365: LD_INT 1
72367: PLUS
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PPUSH
72373: LD_EXP 79
72377: PUSH
72378: LD_VAR 0 2
72382: ARRAY
72383: PUSH
72384: LD_INT 1
72386: ARRAY
72387: PPUSH
72388: CALL 18748 0 3
72392: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72393: LD_EXP 79
72397: PUSH
72398: LD_VAR 0 2
72402: ARRAY
72403: PUSH
72404: LD_INT 1
72406: ARRAY
72407: PPUSH
72408: LD_INT 112
72410: PPUSH
72411: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72415: LD_ADDR_VAR 0 9
72419: PUSH
72420: LD_EXP 79
72424: PUSH
72425: LD_VAR 0 2
72429: ARRAY
72430: PPUSH
72431: LD_INT 1
72433: PPUSH
72434: CALL_OW 3
72438: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72439: LD_ADDR_EXP 79
72443: PUSH
72444: LD_EXP 79
72448: PPUSH
72449: LD_VAR 0 2
72453: PPUSH
72454: LD_VAR 0 9
72458: PPUSH
72459: CALL_OW 1
72463: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72464: LD_EXP 79
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: PUSH
72475: LD_EXP 80
72479: PUSH
72480: LD_VAR 0 2
72484: ARRAY
72485: AND
72486: PUSH
72487: LD_EXP 80
72491: PUSH
72492: LD_VAR 0 2
72496: ARRAY
72497: PUSH
72498: LD_INT 1
72500: ARRAY
72501: PPUSH
72502: CALL_OW 310
72506: NOT
72507: AND
72508: PUSH
72509: LD_VAR 0 3
72513: PPUSH
72514: CALL_OW 313
72518: PUSH
72519: LD_INT 6
72521: EQUAL
72522: AND
72523: IFFALSE 72579
// begin tmp2 := UnitsInside ( j ) ;
72525: LD_ADDR_VAR 0 9
72529: PUSH
72530: LD_VAR 0 3
72534: PPUSH
72535: CALL_OW 313
72539: ST_TO_ADDR
// if tmp2 = 6 then
72540: LD_VAR 0 9
72544: PUSH
72545: LD_INT 6
72547: EQUAL
72548: IFFALSE 72579
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72550: LD_VAR 0 9
72554: PUSH
72555: LD_INT 1
72557: ARRAY
72558: PPUSH
72559: LD_INT 112
72561: PPUSH
72562: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72566: LD_VAR 0 9
72570: PUSH
72571: LD_INT 1
72573: ARRAY
72574: PPUSH
72575: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72579: LD_EXP 80
72583: PUSH
72584: LD_VAR 0 2
72588: ARRAY
72589: PUSH
72590: LD_EXP 80
72594: PUSH
72595: LD_VAR 0 2
72599: ARRAY
72600: PUSH
72601: LD_INT 1
72603: ARRAY
72604: PPUSH
72605: CALL_OW 314
72609: NOT
72610: AND
72611: PUSH
72612: LD_EXP 80
72616: PUSH
72617: LD_VAR 0 2
72621: ARRAY
72622: PUSH
72623: LD_INT 1
72625: ARRAY
72626: PPUSH
72627: CALL_OW 310
72631: NOT
72632: AND
72633: IFFALSE 72659
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72635: LD_EXP 80
72639: PUSH
72640: LD_VAR 0 2
72644: ARRAY
72645: PUSH
72646: LD_INT 1
72648: ARRAY
72649: PPUSH
72650: LD_VAR 0 3
72654: PPUSH
72655: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72659: LD_EXP 80
72663: PUSH
72664: LD_VAR 0 2
72668: ARRAY
72669: PUSH
72670: LD_INT 1
72672: ARRAY
72673: PPUSH
72674: CALL_OW 310
72678: PUSH
72679: LD_EXP 80
72683: PUSH
72684: LD_VAR 0 2
72688: ARRAY
72689: PUSH
72690: LD_INT 1
72692: ARRAY
72693: PPUSH
72694: CALL_OW 310
72698: PPUSH
72699: CALL_OW 461
72703: PUSH
72704: LD_INT 3
72706: NONEQUAL
72707: AND
72708: IFFALSE 72729
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72710: LD_EXP 80
72714: PUSH
72715: LD_VAR 0 2
72719: ARRAY
72720: PUSH
72721: LD_INT 1
72723: ARRAY
72724: PPUSH
72725: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72729: LD_VAR 0 3
72733: PPUSH
72734: CALL_OW 461
72738: PUSH
72739: LD_INT 6
72741: EQUAL
72742: PUSH
72743: LD_VAR 0 6
72747: PUSH
72748: LD_INT 1
72750: GREATER
72751: AND
72752: IFFALSE 72904
// begin sci := [ ] ;
72754: LD_ADDR_VAR 0 8
72758: PUSH
72759: EMPTY
72760: ST_TO_ADDR
// for x in ( tmp diff j ) do
72761: LD_ADDR_VAR 0 7
72765: PUSH
72766: LD_VAR 0 6
72770: PUSH
72771: LD_VAR 0 3
72775: DIFF
72776: PUSH
72777: FOR_IN
72778: IFFALSE 72830
// begin if sci = 6 then
72780: LD_VAR 0 8
72784: PUSH
72785: LD_INT 6
72787: EQUAL
72788: IFFALSE 72792
// break ;
72790: GO 72830
// if BuildingStatus ( x ) = bs_idle then
72792: LD_VAR 0 7
72796: PPUSH
72797: CALL_OW 461
72801: PUSH
72802: LD_INT 2
72804: EQUAL
72805: IFFALSE 72828
// sci := sci ^ UnitsInside ( x ) ;
72807: LD_ADDR_VAR 0 8
72811: PUSH
72812: LD_VAR 0 8
72816: PUSH
72817: LD_VAR 0 7
72821: PPUSH
72822: CALL_OW 313
72826: ADD
72827: ST_TO_ADDR
// end ;
72828: GO 72777
72830: POP
72831: POP
// if not sci then
72832: LD_VAR 0 8
72836: NOT
72837: IFFALSE 72841
// continue ;
72839: GO 71886
// for x in sci do
72841: LD_ADDR_VAR 0 7
72845: PUSH
72846: LD_VAR 0 8
72850: PUSH
72851: FOR_IN
72852: IFFALSE 72902
// if IsInUnit ( x ) and not HasTask ( x ) then
72854: LD_VAR 0 7
72858: PPUSH
72859: CALL_OW 310
72863: PUSH
72864: LD_VAR 0 7
72868: PPUSH
72869: CALL_OW 314
72873: NOT
72874: AND
72875: IFFALSE 72900
// begin ComExitBuilding ( x ) ;
72877: LD_VAR 0 7
72881: PPUSH
72882: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72886: LD_VAR 0 7
72890: PPUSH
72891: LD_VAR 0 3
72895: PPUSH
72896: CALL_OW 180
// end ;
72900: GO 72851
72902: POP
72903: POP
// end ; end ;
72904: GO 71886
72906: POP
72907: POP
// end ;
72908: GO 71840
72910: POP
72911: POP
// end ;
72912: LD_VAR 0 1
72916: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72917: LD_INT 0
72919: PPUSH
72920: PPUSH
// if not mc_bases then
72921: LD_EXP 50
72925: NOT
72926: IFFALSE 72930
// exit ;
72928: GO 73011
// for i = 1 to mc_bases do
72930: LD_ADDR_VAR 0 2
72934: PUSH
72935: DOUBLE
72936: LD_INT 1
72938: DEC
72939: ST_TO_ADDR
72940: LD_EXP 50
72944: PUSH
72945: FOR_TO
72946: IFFALSE 73009
// if mc_mines [ i ] and mc_miners [ i ] then
72948: LD_EXP 63
72952: PUSH
72953: LD_VAR 0 2
72957: ARRAY
72958: PUSH
72959: LD_EXP 64
72963: PUSH
72964: LD_VAR 0 2
72968: ARRAY
72969: AND
72970: IFFALSE 73007
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72972: LD_EXP 64
72976: PUSH
72977: LD_VAR 0 2
72981: ARRAY
72982: PUSH
72983: LD_INT 1
72985: ARRAY
72986: PPUSH
72987: CALL_OW 255
72991: PPUSH
72992: LD_EXP 63
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: PPUSH
73003: CALL 15550 0 2
73007: GO 72945
73009: POP
73010: POP
// end ;
73011: LD_VAR 0 1
73015: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73016: LD_INT 0
73018: PPUSH
73019: PPUSH
73020: PPUSH
73021: PPUSH
73022: PPUSH
73023: PPUSH
73024: PPUSH
73025: PPUSH
// if not mc_bases or not mc_parking then
73026: LD_EXP 50
73030: NOT
73031: PUSH
73032: LD_EXP 74
73036: NOT
73037: OR
73038: IFFALSE 73042
// exit ;
73040: GO 73780
// for i = 1 to mc_bases do
73042: LD_ADDR_VAR 0 2
73046: PUSH
73047: DOUBLE
73048: LD_INT 1
73050: DEC
73051: ST_TO_ADDR
73052: LD_EXP 50
73056: PUSH
73057: FOR_TO
73058: IFFALSE 73778
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73060: LD_EXP 50
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: NOT
73071: PUSH
73072: LD_EXP 74
73076: PUSH
73077: LD_VAR 0 2
73081: ARRAY
73082: NOT
73083: OR
73084: IFFALSE 73088
// continue ;
73086: GO 73057
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73088: LD_ADDR_VAR 0 5
73092: PUSH
73093: LD_EXP 50
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PUSH
73104: LD_INT 1
73106: ARRAY
73107: PPUSH
73108: CALL_OW 255
73112: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73113: LD_ADDR_VAR 0 6
73117: PUSH
73118: LD_EXP 50
73122: PUSH
73123: LD_VAR 0 2
73127: ARRAY
73128: PPUSH
73129: LD_INT 30
73131: PUSH
73132: LD_INT 3
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PPUSH
73139: CALL_OW 72
73143: ST_TO_ADDR
// if not fac then
73144: LD_VAR 0 6
73148: NOT
73149: IFFALSE 73200
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73151: LD_ADDR_VAR 0 6
73155: PUSH
73156: LD_EXP 50
73160: PUSH
73161: LD_VAR 0 2
73165: ARRAY
73166: PPUSH
73167: LD_INT 2
73169: PUSH
73170: LD_INT 30
73172: PUSH
73173: LD_INT 0
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 30
73182: PUSH
73183: LD_INT 1
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: LIST
73194: PPUSH
73195: CALL_OW 72
73199: ST_TO_ADDR
// if not fac then
73200: LD_VAR 0 6
73204: NOT
73205: IFFALSE 73209
// continue ;
73207: GO 73057
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73209: LD_ADDR_VAR 0 7
73213: PUSH
73214: LD_EXP 74
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: PPUSH
73225: LD_INT 22
73227: PUSH
73228: LD_VAR 0 5
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 21
73239: PUSH
73240: LD_INT 2
73242: PUSH
73243: EMPTY
73244: LIST
73245: LIST
73246: PUSH
73247: LD_INT 3
73249: PUSH
73250: LD_INT 60
73252: PUSH
73253: EMPTY
73254: LIST
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 3
73262: PUSH
73263: LD_INT 24
73265: PUSH
73266: LD_INT 1000
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: PPUSH
73283: CALL_OW 70
73287: ST_TO_ADDR
// for j in fac do
73288: LD_ADDR_VAR 0 3
73292: PUSH
73293: LD_VAR 0 6
73297: PUSH
73298: FOR_IN
73299: IFFALSE 73394
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73301: LD_ADDR_VAR 0 7
73305: PUSH
73306: LD_VAR 0 7
73310: PUSH
73311: LD_INT 22
73313: PUSH
73314: LD_VAR 0 5
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 91
73325: PUSH
73326: LD_VAR 0 3
73330: PUSH
73331: LD_INT 15
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: LIST
73338: PUSH
73339: LD_INT 21
73341: PUSH
73342: LD_INT 2
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 3
73351: PUSH
73352: LD_INT 60
73354: PUSH
73355: EMPTY
73356: LIST
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 3
73364: PUSH
73365: LD_INT 24
73367: PUSH
73368: LD_INT 1000
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: LIST
73385: PPUSH
73386: CALL_OW 69
73390: UNION
73391: ST_TO_ADDR
73392: GO 73298
73394: POP
73395: POP
// if not vehs then
73396: LD_VAR 0 7
73400: NOT
73401: IFFALSE 73427
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73403: LD_ADDR_EXP 62
73407: PUSH
73408: LD_EXP 62
73412: PPUSH
73413: LD_VAR 0 2
73417: PPUSH
73418: EMPTY
73419: PPUSH
73420: CALL_OW 1
73424: ST_TO_ADDR
// continue ;
73425: GO 73057
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73427: LD_ADDR_VAR 0 8
73431: PUSH
73432: LD_EXP 50
73436: PUSH
73437: LD_VAR 0 2
73441: ARRAY
73442: PPUSH
73443: LD_INT 30
73445: PUSH
73446: LD_INT 3
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PPUSH
73453: CALL_OW 72
73457: ST_TO_ADDR
// if tmp then
73458: LD_VAR 0 8
73462: IFFALSE 73565
// begin for j in tmp do
73464: LD_ADDR_VAR 0 3
73468: PUSH
73469: LD_VAR 0 8
73473: PUSH
73474: FOR_IN
73475: IFFALSE 73563
// for k in UnitsInside ( j ) do
73477: LD_ADDR_VAR 0 4
73481: PUSH
73482: LD_VAR 0 3
73486: PPUSH
73487: CALL_OW 313
73491: PUSH
73492: FOR_IN
73493: IFFALSE 73559
// if k then
73495: LD_VAR 0 4
73499: IFFALSE 73557
// if not k in mc_repair_vehicle [ i ] then
73501: LD_VAR 0 4
73505: PUSH
73506: LD_EXP 62
73510: PUSH
73511: LD_VAR 0 2
73515: ARRAY
73516: IN
73517: NOT
73518: IFFALSE 73557
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73520: LD_ADDR_EXP 62
73524: PUSH
73525: LD_EXP 62
73529: PPUSH
73530: LD_VAR 0 2
73534: PPUSH
73535: LD_EXP 62
73539: PUSH
73540: LD_VAR 0 2
73544: ARRAY
73545: PUSH
73546: LD_VAR 0 4
73550: UNION
73551: PPUSH
73552: CALL_OW 1
73556: ST_TO_ADDR
73557: GO 73492
73559: POP
73560: POP
73561: GO 73474
73563: POP
73564: POP
// end ; if not mc_repair_vehicle [ i ] then
73565: LD_EXP 62
73569: PUSH
73570: LD_VAR 0 2
73574: ARRAY
73575: NOT
73576: IFFALSE 73580
// continue ;
73578: GO 73057
// for j in mc_repair_vehicle [ i ] do
73580: LD_ADDR_VAR 0 3
73584: PUSH
73585: LD_EXP 62
73589: PUSH
73590: LD_VAR 0 2
73594: ARRAY
73595: PUSH
73596: FOR_IN
73597: IFFALSE 73774
// begin if GetClass ( j ) <> 3 then
73599: LD_VAR 0 3
73603: PPUSH
73604: CALL_OW 257
73608: PUSH
73609: LD_INT 3
73611: NONEQUAL
73612: IFFALSE 73653
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73614: LD_ADDR_EXP 62
73618: PUSH
73619: LD_EXP 62
73623: PPUSH
73624: LD_VAR 0 2
73628: PPUSH
73629: LD_EXP 62
73633: PUSH
73634: LD_VAR 0 2
73638: ARRAY
73639: PUSH
73640: LD_VAR 0 3
73644: DIFF
73645: PPUSH
73646: CALL_OW 1
73650: ST_TO_ADDR
// continue ;
73651: GO 73596
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73653: LD_VAR 0 3
73657: PPUSH
73658: CALL_OW 311
73662: NOT
73663: PUSH
73664: LD_VAR 0 3
73668: PUSH
73669: LD_EXP 53
73673: PUSH
73674: LD_VAR 0 2
73678: ARRAY
73679: PUSH
73680: LD_INT 1
73682: ARRAY
73683: IN
73684: NOT
73685: AND
73686: PUSH
73687: LD_VAR 0 3
73691: PUSH
73692: LD_EXP 53
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: PUSH
73703: LD_INT 2
73705: ARRAY
73706: IN
73707: NOT
73708: AND
73709: IFFALSE 73772
// begin if IsInUnit ( j ) then
73711: LD_VAR 0 3
73715: PPUSH
73716: CALL_OW 310
73720: IFFALSE 73733
// ComExitBuilding ( j ) else
73722: LD_VAR 0 3
73726: PPUSH
73727: CALL_OW 122
73731: GO 73772
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73733: LD_VAR 0 3
73737: PPUSH
73738: LD_VAR 0 7
73742: PUSH
73743: LD_INT 1
73745: ARRAY
73746: PPUSH
73747: CALL 53144 0 2
73751: NOT
73752: IFFALSE 73772
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73754: LD_VAR 0 3
73758: PPUSH
73759: LD_VAR 0 7
73763: PUSH
73764: LD_INT 1
73766: ARRAY
73767: PPUSH
73768: CALL_OW 129
// end ; end ;
73772: GO 73596
73774: POP
73775: POP
// end ;
73776: GO 73057
73778: POP
73779: POP
// end ;
73780: LD_VAR 0 1
73784: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73785: LD_INT 0
73787: PPUSH
73788: PPUSH
73789: PPUSH
73790: PPUSH
73791: PPUSH
73792: PPUSH
73793: PPUSH
73794: PPUSH
73795: PPUSH
73796: PPUSH
73797: PPUSH
// if not mc_bases then
73798: LD_EXP 50
73802: NOT
73803: IFFALSE 73807
// exit ;
73805: GO 74609
// for i = 1 to mc_bases do
73807: LD_ADDR_VAR 0 2
73811: PUSH
73812: DOUBLE
73813: LD_INT 1
73815: DEC
73816: ST_TO_ADDR
73817: LD_EXP 50
73821: PUSH
73822: FOR_TO
73823: IFFALSE 74607
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73825: LD_EXP 78
73829: PUSH
73830: LD_VAR 0 2
73834: ARRAY
73835: NOT
73836: PUSH
73837: LD_EXP 53
73841: PUSH
73842: LD_VAR 0 2
73846: ARRAY
73847: PUSH
73848: LD_INT 1
73850: ARRAY
73851: OR
73852: PUSH
73853: LD_EXP 53
73857: PUSH
73858: LD_VAR 0 2
73862: ARRAY
73863: PUSH
73864: LD_INT 2
73866: ARRAY
73867: OR
73868: PUSH
73869: LD_EXP 76
73873: PUSH
73874: LD_VAR 0 2
73878: ARRAY
73879: PPUSH
73880: LD_INT 1
73882: PPUSH
73883: CALL_OW 325
73887: NOT
73888: OR
73889: PUSH
73890: LD_EXP 73
73894: PUSH
73895: LD_VAR 0 2
73899: ARRAY
73900: OR
73901: IFFALSE 73905
// continue ;
73903: GO 73822
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73905: LD_ADDR_VAR 0 8
73909: PUSH
73910: LD_EXP 50
73914: PUSH
73915: LD_VAR 0 2
73919: ARRAY
73920: PPUSH
73921: LD_INT 25
73923: PUSH
73924: LD_INT 4
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 50
73933: PUSH
73934: EMPTY
73935: LIST
73936: PUSH
73937: LD_INT 3
73939: PUSH
73940: LD_INT 60
73942: PUSH
73943: EMPTY
73944: LIST
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: LIST
73954: PPUSH
73955: CALL_OW 72
73959: PUSH
73960: LD_EXP 54
73964: PUSH
73965: LD_VAR 0 2
73969: ARRAY
73970: DIFF
73971: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73972: LD_ADDR_VAR 0 9
73976: PUSH
73977: LD_EXP 50
73981: PUSH
73982: LD_VAR 0 2
73986: ARRAY
73987: PPUSH
73988: LD_INT 2
73990: PUSH
73991: LD_INT 30
73993: PUSH
73994: LD_INT 0
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 30
74003: PUSH
74004: LD_INT 1
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: LIST
74015: PPUSH
74016: CALL_OW 72
74020: ST_TO_ADDR
// if not tmp or not dep then
74021: LD_VAR 0 8
74025: NOT
74026: PUSH
74027: LD_VAR 0 9
74031: NOT
74032: OR
74033: IFFALSE 74037
// continue ;
74035: GO 73822
// side := GetSide ( tmp [ 1 ] ) ;
74037: LD_ADDR_VAR 0 11
74041: PUSH
74042: LD_VAR 0 8
74046: PUSH
74047: LD_INT 1
74049: ARRAY
74050: PPUSH
74051: CALL_OW 255
74055: ST_TO_ADDR
// dep := dep [ 1 ] ;
74056: LD_ADDR_VAR 0 9
74060: PUSH
74061: LD_VAR 0 9
74065: PUSH
74066: LD_INT 1
74068: ARRAY
74069: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74070: LD_ADDR_VAR 0 7
74074: PUSH
74075: LD_EXP 78
74079: PUSH
74080: LD_VAR 0 2
74084: ARRAY
74085: PPUSH
74086: LD_INT 22
74088: PUSH
74089: LD_INT 0
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 25
74098: PUSH
74099: LD_INT 12
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PPUSH
74110: CALL_OW 70
74114: PUSH
74115: LD_INT 22
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: PUSH
74125: LD_INT 25
74127: PUSH
74128: LD_INT 12
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: PUSH
74135: LD_INT 91
74137: PUSH
74138: LD_VAR 0 9
74142: PUSH
74143: LD_INT 20
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: LIST
74150: PUSH
74151: EMPTY
74152: LIST
74153: LIST
74154: LIST
74155: PPUSH
74156: CALL_OW 69
74160: UNION
74161: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74162: LD_ADDR_VAR 0 10
74166: PUSH
74167: LD_EXP 78
74171: PUSH
74172: LD_VAR 0 2
74176: ARRAY
74177: PPUSH
74178: LD_INT 81
74180: PUSH
74181: LD_VAR 0 11
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PPUSH
74190: CALL_OW 70
74194: ST_TO_ADDR
// if not apes or danger_at_area then
74195: LD_VAR 0 7
74199: NOT
74200: PUSH
74201: LD_VAR 0 10
74205: OR
74206: IFFALSE 74256
// begin if mc_taming [ i ] then
74208: LD_EXP 81
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: IFFALSE 74254
// begin MC_Reset ( i , 121 ) ;
74220: LD_VAR 0 2
74224: PPUSH
74225: LD_INT 121
74227: PPUSH
74228: CALL 59193 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74232: LD_ADDR_EXP 81
74236: PUSH
74237: LD_EXP 81
74241: PPUSH
74242: LD_VAR 0 2
74246: PPUSH
74247: EMPTY
74248: PPUSH
74249: CALL_OW 1
74253: ST_TO_ADDR
// end ; continue ;
74254: GO 73822
// end ; for j in tmp do
74256: LD_ADDR_VAR 0 3
74260: PUSH
74261: LD_VAR 0 8
74265: PUSH
74266: FOR_IN
74267: IFFALSE 74603
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74269: LD_VAR 0 3
74273: PUSH
74274: LD_EXP 81
74278: PUSH
74279: LD_VAR 0 2
74283: ARRAY
74284: IN
74285: NOT
74286: PUSH
74287: LD_EXP 81
74291: PUSH
74292: LD_VAR 0 2
74296: ARRAY
74297: PUSH
74298: LD_INT 3
74300: LESS
74301: AND
74302: IFFALSE 74360
// begin SetTag ( j , 121 ) ;
74304: LD_VAR 0 3
74308: PPUSH
74309: LD_INT 121
74311: PPUSH
74312: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74316: LD_ADDR_EXP 81
74320: PUSH
74321: LD_EXP 81
74325: PPUSH
74326: LD_VAR 0 2
74330: PUSH
74331: LD_EXP 81
74335: PUSH
74336: LD_VAR 0 2
74340: ARRAY
74341: PUSH
74342: LD_INT 1
74344: PLUS
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: PPUSH
74350: LD_VAR 0 3
74354: PPUSH
74355: CALL 18748 0 3
74359: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74360: LD_VAR 0 3
74364: PUSH
74365: LD_EXP 81
74369: PUSH
74370: LD_VAR 0 2
74374: ARRAY
74375: IN
74376: IFFALSE 74601
// begin if GetClass ( j ) <> 4 then
74378: LD_VAR 0 3
74382: PPUSH
74383: CALL_OW 257
74387: PUSH
74388: LD_INT 4
74390: NONEQUAL
74391: IFFALSE 74444
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74393: LD_ADDR_EXP 81
74397: PUSH
74398: LD_EXP 81
74402: PPUSH
74403: LD_VAR 0 2
74407: PPUSH
74408: LD_EXP 81
74412: PUSH
74413: LD_VAR 0 2
74417: ARRAY
74418: PUSH
74419: LD_VAR 0 3
74423: DIFF
74424: PPUSH
74425: CALL_OW 1
74429: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74430: LD_VAR 0 3
74434: PPUSH
74435: LD_INT 0
74437: PPUSH
74438: CALL_OW 109
// continue ;
74442: GO 74266
// end ; if IsInUnit ( j ) then
74444: LD_VAR 0 3
74448: PPUSH
74449: CALL_OW 310
74453: IFFALSE 74464
// ComExitBuilding ( j ) ;
74455: LD_VAR 0 3
74459: PPUSH
74460: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74464: LD_ADDR_VAR 0 6
74468: PUSH
74469: LD_VAR 0 7
74473: PPUSH
74474: LD_VAR 0 3
74478: PPUSH
74479: CALL_OW 74
74483: ST_TO_ADDR
// if not ape then
74484: LD_VAR 0 6
74488: NOT
74489: IFFALSE 74493
// break ;
74491: GO 74603
// x := GetX ( ape ) ;
74493: LD_ADDR_VAR 0 4
74497: PUSH
74498: LD_VAR 0 6
74502: PPUSH
74503: CALL_OW 250
74507: ST_TO_ADDR
// y := GetY ( ape ) ;
74508: LD_ADDR_VAR 0 5
74512: PUSH
74513: LD_VAR 0 6
74517: PPUSH
74518: CALL_OW 251
74522: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74523: LD_VAR 0 4
74527: PPUSH
74528: LD_VAR 0 5
74532: PPUSH
74533: CALL_OW 488
74537: NOT
74538: PUSH
74539: LD_VAR 0 11
74543: PPUSH
74544: LD_VAR 0 4
74548: PPUSH
74549: LD_VAR 0 5
74553: PPUSH
74554: LD_INT 20
74556: PPUSH
74557: CALL 19644 0 4
74561: PUSH
74562: LD_INT 4
74564: ARRAY
74565: OR
74566: IFFALSE 74570
// break ;
74568: GO 74603
// if not HasTask ( j ) then
74570: LD_VAR 0 3
74574: PPUSH
74575: CALL_OW 314
74579: NOT
74580: IFFALSE 74601
// ComTameXY ( j , x , y ) ;
74582: LD_VAR 0 3
74586: PPUSH
74587: LD_VAR 0 4
74591: PPUSH
74592: LD_VAR 0 5
74596: PPUSH
74597: CALL_OW 131
// end ; end ;
74601: GO 74266
74603: POP
74604: POP
// end ;
74605: GO 73822
74607: POP
74608: POP
// end ;
74609: LD_VAR 0 1
74613: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74614: LD_INT 0
74616: PPUSH
74617: PPUSH
74618: PPUSH
74619: PPUSH
74620: PPUSH
74621: PPUSH
74622: PPUSH
74623: PPUSH
// if not mc_bases then
74624: LD_EXP 50
74628: NOT
74629: IFFALSE 74633
// exit ;
74631: GO 75259
// for i = 1 to mc_bases do
74633: LD_ADDR_VAR 0 2
74637: PUSH
74638: DOUBLE
74639: LD_INT 1
74641: DEC
74642: ST_TO_ADDR
74643: LD_EXP 50
74647: PUSH
74648: FOR_TO
74649: IFFALSE 75257
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74651: LD_EXP 79
74655: PUSH
74656: LD_VAR 0 2
74660: ARRAY
74661: NOT
74662: PUSH
74663: LD_EXP 79
74667: PUSH
74668: LD_VAR 0 2
74672: ARRAY
74673: PPUSH
74674: LD_INT 25
74676: PUSH
74677: LD_INT 12
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PPUSH
74684: CALL_OW 72
74688: NOT
74689: OR
74690: IFFALSE 74694
// continue ;
74692: GO 74648
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74694: LD_ADDR_VAR 0 5
74698: PUSH
74699: LD_EXP 79
74703: PUSH
74704: LD_VAR 0 2
74708: ARRAY
74709: PUSH
74710: LD_INT 1
74712: ARRAY
74713: PPUSH
74714: CALL_OW 255
74718: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74719: LD_VAR 0 5
74723: PPUSH
74724: LD_INT 2
74726: PPUSH
74727: CALL_OW 325
74731: IFFALSE 74984
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74733: LD_ADDR_VAR 0 4
74737: PUSH
74738: LD_EXP 79
74742: PUSH
74743: LD_VAR 0 2
74747: ARRAY
74748: PPUSH
74749: LD_INT 25
74751: PUSH
74752: LD_INT 16
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PPUSH
74759: CALL_OW 72
74763: ST_TO_ADDR
// if tmp < 6 then
74764: LD_VAR 0 4
74768: PUSH
74769: LD_INT 6
74771: LESS
74772: IFFALSE 74984
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74774: LD_ADDR_VAR 0 6
74778: PUSH
74779: LD_EXP 50
74783: PUSH
74784: LD_VAR 0 2
74788: ARRAY
74789: PPUSH
74790: LD_INT 2
74792: PUSH
74793: LD_INT 30
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PUSH
74803: LD_INT 30
74805: PUSH
74806: LD_INT 1
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: LIST
74817: PPUSH
74818: CALL_OW 72
74822: ST_TO_ADDR
// if depot then
74823: LD_VAR 0 6
74827: IFFALSE 74984
// begin selected := 0 ;
74829: LD_ADDR_VAR 0 7
74833: PUSH
74834: LD_INT 0
74836: ST_TO_ADDR
// for j in depot do
74837: LD_ADDR_VAR 0 3
74841: PUSH
74842: LD_VAR 0 6
74846: PUSH
74847: FOR_IN
74848: IFFALSE 74879
// begin if UnitsInside ( j ) < 6 then
74850: LD_VAR 0 3
74854: PPUSH
74855: CALL_OW 313
74859: PUSH
74860: LD_INT 6
74862: LESS
74863: IFFALSE 74877
// begin selected := j ;
74865: LD_ADDR_VAR 0 7
74869: PUSH
74870: LD_VAR 0 3
74874: ST_TO_ADDR
// break ;
74875: GO 74879
// end ; end ;
74877: GO 74847
74879: POP
74880: POP
// if selected then
74881: LD_VAR 0 7
74885: IFFALSE 74984
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74887: LD_ADDR_VAR 0 3
74891: PUSH
74892: LD_EXP 79
74896: PUSH
74897: LD_VAR 0 2
74901: ARRAY
74902: PPUSH
74903: LD_INT 25
74905: PUSH
74906: LD_INT 12
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PPUSH
74913: CALL_OW 72
74917: PUSH
74918: FOR_IN
74919: IFFALSE 74982
// if not HasTask ( j ) then
74921: LD_VAR 0 3
74925: PPUSH
74926: CALL_OW 314
74930: NOT
74931: IFFALSE 74980
// begin if not IsInUnit ( j ) then
74933: LD_VAR 0 3
74937: PPUSH
74938: CALL_OW 310
74942: NOT
74943: IFFALSE 74959
// ComEnterUnit ( j , selected ) ;
74945: LD_VAR 0 3
74949: PPUSH
74950: LD_VAR 0 7
74954: PPUSH
74955: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74959: LD_VAR 0 3
74963: PPUSH
74964: LD_INT 16
74966: PPUSH
74967: CALL_OW 183
// AddComExitBuilding ( j ) ;
74971: LD_VAR 0 3
74975: PPUSH
74976: CALL_OW 182
// end ;
74980: GO 74918
74982: POP
74983: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74984: LD_VAR 0 5
74988: PPUSH
74989: LD_INT 11
74991: PPUSH
74992: CALL_OW 325
74996: IFFALSE 75255
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74998: LD_ADDR_VAR 0 4
75002: PUSH
75003: LD_EXP 79
75007: PUSH
75008: LD_VAR 0 2
75012: ARRAY
75013: PPUSH
75014: LD_INT 25
75016: PUSH
75017: LD_INT 16
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PPUSH
75024: CALL_OW 72
75028: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75029: LD_VAR 0 4
75033: PUSH
75034: LD_INT 6
75036: GREATEREQUAL
75037: PUSH
75038: LD_VAR 0 5
75042: PPUSH
75043: LD_INT 2
75045: PPUSH
75046: CALL_OW 325
75050: NOT
75051: OR
75052: IFFALSE 75255
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75054: LD_ADDR_VAR 0 8
75058: PUSH
75059: LD_EXP 50
75063: PUSH
75064: LD_VAR 0 2
75068: ARRAY
75069: PPUSH
75070: LD_INT 2
75072: PUSH
75073: LD_INT 30
75075: PUSH
75076: LD_INT 4
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 30
75085: PUSH
75086: LD_INT 5
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: LIST
75097: PPUSH
75098: CALL_OW 72
75102: ST_TO_ADDR
// if barracks then
75103: LD_VAR 0 8
75107: IFFALSE 75255
// begin selected := 0 ;
75109: LD_ADDR_VAR 0 7
75113: PUSH
75114: LD_INT 0
75116: ST_TO_ADDR
// for j in barracks do
75117: LD_ADDR_VAR 0 3
75121: PUSH
75122: LD_VAR 0 8
75126: PUSH
75127: FOR_IN
75128: IFFALSE 75159
// begin if UnitsInside ( j ) < 6 then
75130: LD_VAR 0 3
75134: PPUSH
75135: CALL_OW 313
75139: PUSH
75140: LD_INT 6
75142: LESS
75143: IFFALSE 75157
// begin selected := j ;
75145: LD_ADDR_VAR 0 7
75149: PUSH
75150: LD_VAR 0 3
75154: ST_TO_ADDR
// break ;
75155: GO 75159
// end ; end ;
75157: GO 75127
75159: POP
75160: POP
// if selected then
75161: LD_VAR 0 7
75165: IFFALSE 75255
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75167: LD_ADDR_VAR 0 3
75171: PUSH
75172: LD_EXP 79
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: PPUSH
75183: LD_INT 25
75185: PUSH
75186: LD_INT 12
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PPUSH
75193: CALL_OW 72
75197: PUSH
75198: FOR_IN
75199: IFFALSE 75253
// if not IsInUnit ( j ) and not HasTask ( j ) then
75201: LD_VAR 0 3
75205: PPUSH
75206: CALL_OW 310
75210: NOT
75211: PUSH
75212: LD_VAR 0 3
75216: PPUSH
75217: CALL_OW 314
75221: NOT
75222: AND
75223: IFFALSE 75251
// begin ComEnterUnit ( j , selected ) ;
75225: LD_VAR 0 3
75229: PPUSH
75230: LD_VAR 0 7
75234: PPUSH
75235: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75239: LD_VAR 0 3
75243: PPUSH
75244: LD_INT 15
75246: PPUSH
75247: CALL_OW 183
// end ;
75251: GO 75198
75253: POP
75254: POP
// end ; end ; end ; end ; end ;
75255: GO 74648
75257: POP
75258: POP
// end ;
75259: LD_VAR 0 1
75263: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75264: LD_INT 0
75266: PPUSH
75267: PPUSH
75268: PPUSH
75269: PPUSH
// if not mc_bases then
75270: LD_EXP 50
75274: NOT
75275: IFFALSE 75279
// exit ;
75277: GO 75457
// for i = 1 to mc_bases do
75279: LD_ADDR_VAR 0 2
75283: PUSH
75284: DOUBLE
75285: LD_INT 1
75287: DEC
75288: ST_TO_ADDR
75289: LD_EXP 50
75293: PUSH
75294: FOR_TO
75295: IFFALSE 75455
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75297: LD_ADDR_VAR 0 4
75301: PUSH
75302: LD_EXP 50
75306: PUSH
75307: LD_VAR 0 2
75311: ARRAY
75312: PPUSH
75313: LD_INT 25
75315: PUSH
75316: LD_INT 9
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PPUSH
75323: CALL_OW 72
75327: ST_TO_ADDR
// if not tmp then
75328: LD_VAR 0 4
75332: NOT
75333: IFFALSE 75337
// continue ;
75335: GO 75294
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75337: LD_EXP 76
75341: PUSH
75342: LD_VAR 0 2
75346: ARRAY
75347: PPUSH
75348: LD_INT 29
75350: PPUSH
75351: CALL_OW 325
75355: NOT
75356: PUSH
75357: LD_EXP 76
75361: PUSH
75362: LD_VAR 0 2
75366: ARRAY
75367: PPUSH
75368: LD_INT 28
75370: PPUSH
75371: CALL_OW 325
75375: NOT
75376: AND
75377: IFFALSE 75381
// continue ;
75379: GO 75294
// for j in tmp do
75381: LD_ADDR_VAR 0 3
75385: PUSH
75386: LD_VAR 0 4
75390: PUSH
75391: FOR_IN
75392: IFFALSE 75451
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75394: LD_VAR 0 3
75398: PUSH
75399: LD_EXP 53
75403: PUSH
75404: LD_VAR 0 2
75408: ARRAY
75409: PUSH
75410: LD_INT 1
75412: ARRAY
75413: IN
75414: NOT
75415: PUSH
75416: LD_VAR 0 3
75420: PUSH
75421: LD_EXP 53
75425: PUSH
75426: LD_VAR 0 2
75430: ARRAY
75431: PUSH
75432: LD_INT 2
75434: ARRAY
75435: IN
75436: NOT
75437: AND
75438: IFFALSE 75449
// ComSpaceTimeShoot ( j ) ;
75440: LD_VAR 0 3
75444: PPUSH
75445: CALL 14558 0 1
75449: GO 75391
75451: POP
75452: POP
// end ;
75453: GO 75294
75455: POP
75456: POP
// end ;
75457: LD_VAR 0 1
75461: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75462: LD_INT 0
75464: PPUSH
75465: PPUSH
75466: PPUSH
75467: PPUSH
75468: PPUSH
75469: PPUSH
75470: PPUSH
75471: PPUSH
75472: PPUSH
// if not mc_bases then
75473: LD_EXP 50
75477: NOT
75478: IFFALSE 75482
// exit ;
75480: GO 76104
// for i = 1 to mc_bases do
75482: LD_ADDR_VAR 0 2
75486: PUSH
75487: DOUBLE
75488: LD_INT 1
75490: DEC
75491: ST_TO_ADDR
75492: LD_EXP 50
75496: PUSH
75497: FOR_TO
75498: IFFALSE 76102
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75500: LD_EXP 85
75504: PUSH
75505: LD_VAR 0 2
75509: ARRAY
75510: NOT
75511: PUSH
75512: LD_INT 38
75514: PPUSH
75515: LD_EXP 76
75519: PUSH
75520: LD_VAR 0 2
75524: ARRAY
75525: PPUSH
75526: CALL_OW 321
75530: PUSH
75531: LD_INT 2
75533: NONEQUAL
75534: OR
75535: IFFALSE 75539
// continue ;
75537: GO 75497
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75539: LD_ADDR_VAR 0 8
75543: PUSH
75544: LD_EXP 50
75548: PUSH
75549: LD_VAR 0 2
75553: ARRAY
75554: PPUSH
75555: LD_INT 30
75557: PUSH
75558: LD_INT 34
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PPUSH
75565: CALL_OW 72
75569: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75570: LD_ADDR_VAR 0 9
75574: PUSH
75575: LD_EXP 50
75579: PUSH
75580: LD_VAR 0 2
75584: ARRAY
75585: PPUSH
75586: LD_INT 25
75588: PUSH
75589: LD_INT 4
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PPUSH
75596: CALL_OW 72
75600: PPUSH
75601: LD_INT 0
75603: PPUSH
75604: CALL 48660 0 2
75608: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75609: LD_VAR 0 9
75613: NOT
75614: PUSH
75615: LD_VAR 0 8
75619: NOT
75620: OR
75621: PUSH
75622: LD_EXP 50
75626: PUSH
75627: LD_VAR 0 2
75631: ARRAY
75632: PPUSH
75633: LD_INT 124
75635: PPUSH
75636: CALL 48660 0 2
75640: OR
75641: IFFALSE 75645
// continue ;
75643: GO 75497
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75645: LD_EXP 86
75649: PUSH
75650: LD_VAR 0 2
75654: ARRAY
75655: PUSH
75656: LD_EXP 85
75660: PUSH
75661: LD_VAR 0 2
75665: ARRAY
75666: LESS
75667: PUSH
75668: LD_EXP 86
75672: PUSH
75673: LD_VAR 0 2
75677: ARRAY
75678: PUSH
75679: LD_VAR 0 8
75683: LESS
75684: AND
75685: IFFALSE 76100
// begin tmp := sci [ 1 ] ;
75687: LD_ADDR_VAR 0 7
75691: PUSH
75692: LD_VAR 0 9
75696: PUSH
75697: LD_INT 1
75699: ARRAY
75700: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75701: LD_VAR 0 7
75705: PPUSH
75706: LD_INT 124
75708: PPUSH
75709: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75713: LD_ADDR_VAR 0 3
75717: PUSH
75718: DOUBLE
75719: LD_EXP 85
75723: PUSH
75724: LD_VAR 0 2
75728: ARRAY
75729: INC
75730: ST_TO_ADDR
75731: LD_EXP 85
75735: PUSH
75736: LD_VAR 0 2
75740: ARRAY
75741: PUSH
75742: FOR_DOWNTO
75743: IFFALSE 76086
// begin if IsInUnit ( tmp ) then
75745: LD_VAR 0 7
75749: PPUSH
75750: CALL_OW 310
75754: IFFALSE 75765
// ComExitBuilding ( tmp ) ;
75756: LD_VAR 0 7
75760: PPUSH
75761: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75765: LD_INT 35
75767: PPUSH
75768: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75772: LD_VAR 0 7
75776: PPUSH
75777: CALL_OW 310
75781: NOT
75782: PUSH
75783: LD_VAR 0 7
75787: PPUSH
75788: CALL_OW 314
75792: NOT
75793: AND
75794: IFFALSE 75765
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75796: LD_ADDR_VAR 0 6
75800: PUSH
75801: LD_VAR 0 7
75805: PPUSH
75806: CALL_OW 250
75810: PUSH
75811: LD_VAR 0 7
75815: PPUSH
75816: CALL_OW 251
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75825: LD_INT 35
75827: PPUSH
75828: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75832: LD_ADDR_VAR 0 4
75836: PUSH
75837: LD_EXP 85
75841: PUSH
75842: LD_VAR 0 2
75846: ARRAY
75847: PUSH
75848: LD_VAR 0 3
75852: ARRAY
75853: PUSH
75854: LD_INT 1
75856: ARRAY
75857: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75858: LD_ADDR_VAR 0 5
75862: PUSH
75863: LD_EXP 85
75867: PUSH
75868: LD_VAR 0 2
75872: ARRAY
75873: PUSH
75874: LD_VAR 0 3
75878: ARRAY
75879: PUSH
75880: LD_INT 2
75882: ARRAY
75883: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75884: LD_VAR 0 7
75888: PPUSH
75889: LD_INT 10
75891: PPUSH
75892: CALL 21345 0 2
75896: PUSH
75897: LD_INT 4
75899: ARRAY
75900: IFFALSE 75938
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75902: LD_VAR 0 7
75906: PPUSH
75907: LD_VAR 0 6
75911: PUSH
75912: LD_INT 1
75914: ARRAY
75915: PPUSH
75916: LD_VAR 0 6
75920: PUSH
75921: LD_INT 2
75923: ARRAY
75924: PPUSH
75925: CALL_OW 111
// wait ( 0 0$10 ) ;
75929: LD_INT 350
75931: PPUSH
75932: CALL_OW 67
// end else
75936: GO 75964
// begin ComMoveXY ( tmp , x , y ) ;
75938: LD_VAR 0 7
75942: PPUSH
75943: LD_VAR 0 4
75947: PPUSH
75948: LD_VAR 0 5
75952: PPUSH
75953: CALL_OW 111
// wait ( 0 0$3 ) ;
75957: LD_INT 105
75959: PPUSH
75960: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75964: LD_VAR 0 7
75968: PPUSH
75969: LD_VAR 0 4
75973: PPUSH
75974: LD_VAR 0 5
75978: PPUSH
75979: CALL_OW 307
75983: IFFALSE 75825
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75985: LD_VAR 0 7
75989: PPUSH
75990: LD_VAR 0 4
75994: PPUSH
75995: LD_VAR 0 5
75999: PPUSH
76000: LD_VAR 0 8
76004: PUSH
76005: LD_VAR 0 3
76009: ARRAY
76010: PPUSH
76011: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76015: LD_INT 35
76017: PPUSH
76018: CALL_OW 67
// until not HasTask ( tmp ) ;
76022: LD_VAR 0 7
76026: PPUSH
76027: CALL_OW 314
76031: NOT
76032: IFFALSE 76015
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76034: LD_ADDR_EXP 86
76038: PUSH
76039: LD_EXP 86
76043: PPUSH
76044: LD_VAR 0 2
76048: PUSH
76049: LD_EXP 86
76053: PUSH
76054: LD_VAR 0 2
76058: ARRAY
76059: PUSH
76060: LD_INT 1
76062: PLUS
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PPUSH
76068: LD_VAR 0 8
76072: PUSH
76073: LD_VAR 0 3
76077: ARRAY
76078: PPUSH
76079: CALL 18748 0 3
76083: ST_TO_ADDR
// end ;
76084: GO 75742
76086: POP
76087: POP
// MC_Reset ( i , 124 ) ;
76088: LD_VAR 0 2
76092: PPUSH
76093: LD_INT 124
76095: PPUSH
76096: CALL 59193 0 2
// end ; end ;
76100: GO 75497
76102: POP
76103: POP
// end ;
76104: LD_VAR 0 1
76108: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76109: LD_INT 0
76111: PPUSH
76112: PPUSH
76113: PPUSH
// if not mc_bases then
76114: LD_EXP 50
76118: NOT
76119: IFFALSE 76123
// exit ;
76121: GO 76729
// for i = 1 to mc_bases do
76123: LD_ADDR_VAR 0 2
76127: PUSH
76128: DOUBLE
76129: LD_INT 1
76131: DEC
76132: ST_TO_ADDR
76133: LD_EXP 50
76137: PUSH
76138: FOR_TO
76139: IFFALSE 76727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76141: LD_ADDR_VAR 0 3
76145: PUSH
76146: LD_EXP 50
76150: PUSH
76151: LD_VAR 0 2
76155: ARRAY
76156: PPUSH
76157: LD_INT 25
76159: PUSH
76160: LD_INT 4
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PPUSH
76167: CALL_OW 72
76171: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76172: LD_VAR 0 3
76176: NOT
76177: PUSH
76178: LD_EXP 87
76182: PUSH
76183: LD_VAR 0 2
76187: ARRAY
76188: NOT
76189: OR
76190: PUSH
76191: LD_EXP 50
76195: PUSH
76196: LD_VAR 0 2
76200: ARRAY
76201: PPUSH
76202: LD_INT 2
76204: PUSH
76205: LD_INT 30
76207: PUSH
76208: LD_INT 0
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 30
76217: PUSH
76218: LD_INT 1
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: LIST
76229: PPUSH
76230: CALL_OW 72
76234: NOT
76235: OR
76236: IFFALSE 76286
// begin if mc_deposits_finder [ i ] then
76238: LD_EXP 88
76242: PUSH
76243: LD_VAR 0 2
76247: ARRAY
76248: IFFALSE 76284
// begin MC_Reset ( i , 125 ) ;
76250: LD_VAR 0 2
76254: PPUSH
76255: LD_INT 125
76257: PPUSH
76258: CALL 59193 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76262: LD_ADDR_EXP 88
76266: PUSH
76267: LD_EXP 88
76271: PPUSH
76272: LD_VAR 0 2
76276: PPUSH
76277: EMPTY
76278: PPUSH
76279: CALL_OW 1
76283: ST_TO_ADDR
// end ; continue ;
76284: GO 76138
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76286: LD_EXP 87
76290: PUSH
76291: LD_VAR 0 2
76295: ARRAY
76296: PUSH
76297: LD_INT 1
76299: ARRAY
76300: PUSH
76301: LD_INT 3
76303: ARRAY
76304: PUSH
76305: LD_INT 1
76307: EQUAL
76308: PUSH
76309: LD_INT 20
76311: PPUSH
76312: LD_EXP 76
76316: PUSH
76317: LD_VAR 0 2
76321: ARRAY
76322: PPUSH
76323: CALL_OW 321
76327: PUSH
76328: LD_INT 2
76330: NONEQUAL
76331: AND
76332: IFFALSE 76382
// begin if mc_deposits_finder [ i ] then
76334: LD_EXP 88
76338: PUSH
76339: LD_VAR 0 2
76343: ARRAY
76344: IFFALSE 76380
// begin MC_Reset ( i , 125 ) ;
76346: LD_VAR 0 2
76350: PPUSH
76351: LD_INT 125
76353: PPUSH
76354: CALL 59193 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76358: LD_ADDR_EXP 88
76362: PUSH
76363: LD_EXP 88
76367: PPUSH
76368: LD_VAR 0 2
76372: PPUSH
76373: EMPTY
76374: PPUSH
76375: CALL_OW 1
76379: ST_TO_ADDR
// end ; continue ;
76380: GO 76138
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76382: LD_EXP 87
76386: PUSH
76387: LD_VAR 0 2
76391: ARRAY
76392: PUSH
76393: LD_INT 1
76395: ARRAY
76396: PUSH
76397: LD_INT 1
76399: ARRAY
76400: PPUSH
76401: LD_EXP 87
76405: PUSH
76406: LD_VAR 0 2
76410: ARRAY
76411: PUSH
76412: LD_INT 1
76414: ARRAY
76415: PUSH
76416: LD_INT 2
76418: ARRAY
76419: PPUSH
76420: LD_EXP 76
76424: PUSH
76425: LD_VAR 0 2
76429: ARRAY
76430: PPUSH
76431: CALL_OW 440
76435: IFFALSE 76478
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76437: LD_ADDR_EXP 87
76441: PUSH
76442: LD_EXP 87
76446: PPUSH
76447: LD_VAR 0 2
76451: PPUSH
76452: LD_EXP 87
76456: PUSH
76457: LD_VAR 0 2
76461: ARRAY
76462: PPUSH
76463: LD_INT 1
76465: PPUSH
76466: CALL_OW 3
76470: PPUSH
76471: CALL_OW 1
76475: ST_TO_ADDR
76476: GO 76725
// begin if not mc_deposits_finder [ i ] then
76478: LD_EXP 88
76482: PUSH
76483: LD_VAR 0 2
76487: ARRAY
76488: NOT
76489: IFFALSE 76541
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76491: LD_ADDR_EXP 88
76495: PUSH
76496: LD_EXP 88
76500: PPUSH
76501: LD_VAR 0 2
76505: PPUSH
76506: LD_VAR 0 3
76510: PUSH
76511: LD_INT 1
76513: ARRAY
76514: PUSH
76515: EMPTY
76516: LIST
76517: PPUSH
76518: CALL_OW 1
76522: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76523: LD_VAR 0 3
76527: PUSH
76528: LD_INT 1
76530: ARRAY
76531: PPUSH
76532: LD_INT 125
76534: PPUSH
76535: CALL_OW 109
// end else
76539: GO 76725
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76541: LD_EXP 88
76545: PUSH
76546: LD_VAR 0 2
76550: ARRAY
76551: PUSH
76552: LD_INT 1
76554: ARRAY
76555: PPUSH
76556: CALL_OW 310
76560: IFFALSE 76583
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76562: LD_EXP 88
76566: PUSH
76567: LD_VAR 0 2
76571: ARRAY
76572: PUSH
76573: LD_INT 1
76575: ARRAY
76576: PPUSH
76577: CALL_OW 122
76581: GO 76725
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76583: LD_EXP 88
76587: PUSH
76588: LD_VAR 0 2
76592: ARRAY
76593: PUSH
76594: LD_INT 1
76596: ARRAY
76597: PPUSH
76598: CALL_OW 314
76602: NOT
76603: PUSH
76604: LD_EXP 88
76608: PUSH
76609: LD_VAR 0 2
76613: ARRAY
76614: PUSH
76615: LD_INT 1
76617: ARRAY
76618: PPUSH
76619: LD_EXP 87
76623: PUSH
76624: LD_VAR 0 2
76628: ARRAY
76629: PUSH
76630: LD_INT 1
76632: ARRAY
76633: PUSH
76634: LD_INT 1
76636: ARRAY
76637: PPUSH
76638: LD_EXP 87
76642: PUSH
76643: LD_VAR 0 2
76647: ARRAY
76648: PUSH
76649: LD_INT 1
76651: ARRAY
76652: PUSH
76653: LD_INT 2
76655: ARRAY
76656: PPUSH
76657: CALL_OW 297
76661: PUSH
76662: LD_INT 6
76664: GREATER
76665: AND
76666: IFFALSE 76725
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76668: LD_EXP 88
76672: PUSH
76673: LD_VAR 0 2
76677: ARRAY
76678: PUSH
76679: LD_INT 1
76681: ARRAY
76682: PPUSH
76683: LD_EXP 87
76687: PUSH
76688: LD_VAR 0 2
76692: ARRAY
76693: PUSH
76694: LD_INT 1
76696: ARRAY
76697: PUSH
76698: LD_INT 1
76700: ARRAY
76701: PPUSH
76702: LD_EXP 87
76706: PUSH
76707: LD_VAR 0 2
76711: ARRAY
76712: PUSH
76713: LD_INT 1
76715: ARRAY
76716: PUSH
76717: LD_INT 2
76719: ARRAY
76720: PPUSH
76721: CALL_OW 111
// end ; end ; end ;
76725: GO 76138
76727: POP
76728: POP
// end ;
76729: LD_VAR 0 1
76733: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76734: LD_INT 0
76736: PPUSH
76737: PPUSH
76738: PPUSH
76739: PPUSH
76740: PPUSH
76741: PPUSH
76742: PPUSH
76743: PPUSH
76744: PPUSH
76745: PPUSH
76746: PPUSH
// if not mc_bases then
76747: LD_EXP 50
76751: NOT
76752: IFFALSE 76756
// exit ;
76754: GO 77696
// for i = 1 to mc_bases do
76756: LD_ADDR_VAR 0 2
76760: PUSH
76761: DOUBLE
76762: LD_INT 1
76764: DEC
76765: ST_TO_ADDR
76766: LD_EXP 50
76770: PUSH
76771: FOR_TO
76772: IFFALSE 77694
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76774: LD_EXP 50
76778: PUSH
76779: LD_VAR 0 2
76783: ARRAY
76784: NOT
76785: PUSH
76786: LD_EXP 73
76790: PUSH
76791: LD_VAR 0 2
76795: ARRAY
76796: OR
76797: IFFALSE 76801
// continue ;
76799: GO 76771
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76801: LD_ADDR_VAR 0 7
76805: PUSH
76806: LD_EXP 50
76810: PUSH
76811: LD_VAR 0 2
76815: ARRAY
76816: PUSH
76817: LD_INT 1
76819: ARRAY
76820: PPUSH
76821: CALL_OW 248
76825: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76826: LD_VAR 0 7
76830: PUSH
76831: LD_INT 3
76833: EQUAL
76834: PUSH
76835: LD_EXP 69
76839: PUSH
76840: LD_VAR 0 2
76844: ARRAY
76845: PUSH
76846: LD_EXP 72
76850: PUSH
76851: LD_VAR 0 2
76855: ARRAY
76856: UNION
76857: PPUSH
76858: LD_INT 33
76860: PUSH
76861: LD_INT 2
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PPUSH
76868: CALL_OW 72
76872: NOT
76873: OR
76874: IFFALSE 76878
// continue ;
76876: GO 76771
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76878: LD_ADDR_VAR 0 9
76882: PUSH
76883: LD_EXP 50
76887: PUSH
76888: LD_VAR 0 2
76892: ARRAY
76893: PPUSH
76894: LD_INT 30
76896: PUSH
76897: LD_INT 36
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PPUSH
76904: CALL_OW 72
76908: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76909: LD_ADDR_VAR 0 10
76913: PUSH
76914: LD_EXP 69
76918: PUSH
76919: LD_VAR 0 2
76923: ARRAY
76924: PPUSH
76925: LD_INT 34
76927: PUSH
76928: LD_INT 31
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PPUSH
76935: CALL_OW 72
76939: ST_TO_ADDR
// if not cts and not mcts then
76940: LD_VAR 0 9
76944: NOT
76945: PUSH
76946: LD_VAR 0 10
76950: NOT
76951: AND
76952: IFFALSE 76956
// continue ;
76954: GO 76771
// x := cts ;
76956: LD_ADDR_VAR 0 11
76960: PUSH
76961: LD_VAR 0 9
76965: ST_TO_ADDR
// if not x then
76966: LD_VAR 0 11
76970: NOT
76971: IFFALSE 76983
// x := mcts ;
76973: LD_ADDR_VAR 0 11
76977: PUSH
76978: LD_VAR 0 10
76982: ST_TO_ADDR
// if not x then
76983: LD_VAR 0 11
76987: NOT
76988: IFFALSE 76992
// continue ;
76990: GO 76771
// if mc_remote_driver [ i ] then
76992: LD_EXP 90
76996: PUSH
76997: LD_VAR 0 2
77001: ARRAY
77002: IFFALSE 77389
// for j in mc_remote_driver [ i ] do
77004: LD_ADDR_VAR 0 3
77008: PUSH
77009: LD_EXP 90
77013: PUSH
77014: LD_VAR 0 2
77018: ARRAY
77019: PUSH
77020: FOR_IN
77021: IFFALSE 77387
// begin if GetClass ( j ) <> 3 then
77023: LD_VAR 0 3
77027: PPUSH
77028: CALL_OW 257
77032: PUSH
77033: LD_INT 3
77035: NONEQUAL
77036: IFFALSE 77089
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77038: LD_ADDR_EXP 90
77042: PUSH
77043: LD_EXP 90
77047: PPUSH
77048: LD_VAR 0 2
77052: PPUSH
77053: LD_EXP 90
77057: PUSH
77058: LD_VAR 0 2
77062: ARRAY
77063: PUSH
77064: LD_VAR 0 3
77068: DIFF
77069: PPUSH
77070: CALL_OW 1
77074: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77075: LD_VAR 0 3
77079: PPUSH
77080: LD_INT 0
77082: PPUSH
77083: CALL_OW 109
// continue ;
77087: GO 77020
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
77089: LD_EXP 69
77093: PUSH
77094: LD_VAR 0 2
77098: ARRAY
77099: PPUSH
77100: LD_INT 34
77102: PUSH
77103: LD_INT 31
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 58
77112: PUSH
77113: EMPTY
77114: LIST
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PPUSH
77120: CALL_OW 72
77124: PUSH
77125: LD_VAR 0 3
77129: PPUSH
77130: CALL 48695 0 1
77134: NOT
77135: AND
77136: IFFALSE 77207
// begin if IsInUnit ( j ) then
77138: LD_VAR 0 3
77142: PPUSH
77143: CALL_OW 310
77147: IFFALSE 77158
// ComExitBuilding ( j ) ;
77149: LD_VAR 0 3
77153: PPUSH
77154: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77158: LD_VAR 0 3
77162: PPUSH
77163: LD_EXP 69
77167: PUSH
77168: LD_VAR 0 2
77172: ARRAY
77173: PPUSH
77174: LD_INT 34
77176: PUSH
77177: LD_INT 31
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: LD_INT 58
77186: PUSH
77187: EMPTY
77188: LIST
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PPUSH
77194: CALL_OW 72
77198: PUSH
77199: LD_INT 1
77201: ARRAY
77202: PPUSH
77203: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77207: LD_VAR 0 3
77211: PPUSH
77212: CALL_OW 310
77216: NOT
77217: PUSH
77218: LD_VAR 0 3
77222: PPUSH
77223: CALL_OW 310
77227: PPUSH
77228: CALL_OW 266
77232: PUSH
77233: LD_INT 36
77235: NONEQUAL
77236: PUSH
77237: LD_VAR 0 3
77241: PPUSH
77242: CALL 48695 0 1
77246: NOT
77247: AND
77248: OR
77249: IFFALSE 77385
// begin if IsInUnit ( j ) then
77251: LD_VAR 0 3
77255: PPUSH
77256: CALL_OW 310
77260: IFFALSE 77271
// ComExitBuilding ( j ) ;
77262: LD_VAR 0 3
77266: PPUSH
77267: CALL_OW 122
// ct := 0 ;
77271: LD_ADDR_VAR 0 8
77275: PUSH
77276: LD_INT 0
77278: ST_TO_ADDR
// for k in x do
77279: LD_ADDR_VAR 0 4
77283: PUSH
77284: LD_VAR 0 11
77288: PUSH
77289: FOR_IN
77290: IFFALSE 77363
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77292: LD_VAR 0 4
77296: PPUSH
77297: CALL_OW 264
77301: PUSH
77302: LD_INT 31
77304: EQUAL
77305: PUSH
77306: LD_VAR 0 4
77310: PPUSH
77311: CALL_OW 311
77315: NOT
77316: AND
77317: PUSH
77318: LD_VAR 0 4
77322: PPUSH
77323: CALL_OW 266
77327: PUSH
77328: LD_INT 36
77330: EQUAL
77331: PUSH
77332: LD_VAR 0 4
77336: PPUSH
77337: CALL_OW 313
77341: PUSH
77342: LD_INT 3
77344: LESS
77345: AND
77346: OR
77347: IFFALSE 77361
// begin ct := k ;
77349: LD_ADDR_VAR 0 8
77353: PUSH
77354: LD_VAR 0 4
77358: ST_TO_ADDR
// break ;
77359: GO 77363
// end ;
77361: GO 77289
77363: POP
77364: POP
// if ct then
77365: LD_VAR 0 8
77369: IFFALSE 77385
// ComEnterUnit ( j , ct ) ;
77371: LD_VAR 0 3
77375: PPUSH
77376: LD_VAR 0 8
77380: PPUSH
77381: CALL_OW 120
// end ; end ;
77385: GO 77020
77387: POP
77388: POP
// places := 0 ;
77389: LD_ADDR_VAR 0 5
77393: PUSH
77394: LD_INT 0
77396: ST_TO_ADDR
// for j = 1 to x do
77397: LD_ADDR_VAR 0 3
77401: PUSH
77402: DOUBLE
77403: LD_INT 1
77405: DEC
77406: ST_TO_ADDR
77407: LD_VAR 0 11
77411: PUSH
77412: FOR_TO
77413: IFFALSE 77489
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77415: LD_VAR 0 11
77419: PUSH
77420: LD_VAR 0 3
77424: ARRAY
77425: PPUSH
77426: CALL_OW 264
77430: PUSH
77431: LD_INT 31
77433: EQUAL
77434: IFFALSE 77452
// places := places + 1 else
77436: LD_ADDR_VAR 0 5
77440: PUSH
77441: LD_VAR 0 5
77445: PUSH
77446: LD_INT 1
77448: PLUS
77449: ST_TO_ADDR
77450: GO 77487
// if GetBType ( x [ j ] ) = b_control_tower then
77452: LD_VAR 0 11
77456: PUSH
77457: LD_VAR 0 3
77461: ARRAY
77462: PPUSH
77463: CALL_OW 266
77467: PUSH
77468: LD_INT 36
77470: EQUAL
77471: IFFALSE 77487
// places := places + 3 ;
77473: LD_ADDR_VAR 0 5
77477: PUSH
77478: LD_VAR 0 5
77482: PUSH
77483: LD_INT 3
77485: PLUS
77486: ST_TO_ADDR
77487: GO 77412
77489: POP
77490: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77491: LD_VAR 0 5
77495: PUSH
77496: LD_INT 0
77498: EQUAL
77499: PUSH
77500: LD_VAR 0 5
77504: PUSH
77505: LD_EXP 90
77509: PUSH
77510: LD_VAR 0 2
77514: ARRAY
77515: LESSEQUAL
77516: OR
77517: IFFALSE 77521
// continue ;
77519: GO 76771
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77521: LD_ADDR_VAR 0 6
77525: PUSH
77526: LD_EXP 50
77530: PUSH
77531: LD_VAR 0 2
77535: ARRAY
77536: PPUSH
77537: LD_INT 25
77539: PUSH
77540: LD_INT 3
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PPUSH
77547: CALL_OW 72
77551: PUSH
77552: LD_EXP 90
77556: PUSH
77557: LD_VAR 0 2
77561: ARRAY
77562: DIFF
77563: PPUSH
77564: LD_INT 3
77566: PPUSH
77567: CALL 49595 0 2
77571: ST_TO_ADDR
// for j in tmp do
77572: LD_ADDR_VAR 0 3
77576: PUSH
77577: LD_VAR 0 6
77581: PUSH
77582: FOR_IN
77583: IFFALSE 77618
// if GetTag ( j ) > 0 then
77585: LD_VAR 0 3
77589: PPUSH
77590: CALL_OW 110
77594: PUSH
77595: LD_INT 0
77597: GREATER
77598: IFFALSE 77616
// tmp := tmp diff j ;
77600: LD_ADDR_VAR 0 6
77604: PUSH
77605: LD_VAR 0 6
77609: PUSH
77610: LD_VAR 0 3
77614: DIFF
77615: ST_TO_ADDR
77616: GO 77582
77618: POP
77619: POP
// if not tmp then
77620: LD_VAR 0 6
77624: NOT
77625: IFFALSE 77629
// continue ;
77627: GO 76771
// if places then
77629: LD_VAR 0 5
77633: IFFALSE 77692
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77635: LD_ADDR_EXP 90
77639: PUSH
77640: LD_EXP 90
77644: PPUSH
77645: LD_VAR 0 2
77649: PPUSH
77650: LD_EXP 90
77654: PUSH
77655: LD_VAR 0 2
77659: ARRAY
77660: PUSH
77661: LD_VAR 0 6
77665: PUSH
77666: LD_INT 1
77668: ARRAY
77669: UNION
77670: PPUSH
77671: CALL_OW 1
77675: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77676: LD_VAR 0 6
77680: PUSH
77681: LD_INT 1
77683: ARRAY
77684: PPUSH
77685: LD_INT 126
77687: PPUSH
77688: CALL_OW 109
// end ; end ;
77692: GO 76771
77694: POP
77695: POP
// end ;
77696: LD_VAR 0 1
77700: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77701: LD_INT 0
77703: PPUSH
77704: PPUSH
77705: PPUSH
77706: PPUSH
77707: PPUSH
77708: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77709: LD_VAR 0 1
77713: NOT
77714: PUSH
77715: LD_VAR 0 2
77719: NOT
77720: OR
77721: PUSH
77722: LD_VAR 0 3
77726: NOT
77727: OR
77728: PUSH
77729: LD_VAR 0 4
77733: PUSH
77734: LD_INT 1
77736: PUSH
77737: LD_INT 2
77739: PUSH
77740: LD_INT 3
77742: PUSH
77743: LD_INT 4
77745: PUSH
77746: LD_INT 5
77748: PUSH
77749: LD_INT 8
77751: PUSH
77752: LD_INT 9
77754: PUSH
77755: LD_INT 15
77757: PUSH
77758: LD_INT 16
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: IN
77772: NOT
77773: OR
77774: IFFALSE 77778
// exit ;
77776: GO 78678
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77778: LD_ADDR_VAR 0 2
77782: PUSH
77783: LD_VAR 0 2
77787: PPUSH
77788: LD_INT 21
77790: PUSH
77791: LD_INT 3
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: PUSH
77798: LD_INT 24
77800: PUSH
77801: LD_INT 250
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PPUSH
77812: CALL_OW 72
77816: ST_TO_ADDR
// case class of 1 , 15 :
77817: LD_VAR 0 4
77821: PUSH
77822: LD_INT 1
77824: DOUBLE
77825: EQUAL
77826: IFTRUE 77836
77828: LD_INT 15
77830: DOUBLE
77831: EQUAL
77832: IFTRUE 77836
77834: GO 77921
77836: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77837: LD_ADDR_VAR 0 8
77841: PUSH
77842: LD_VAR 0 2
77846: PPUSH
77847: LD_INT 2
77849: PUSH
77850: LD_INT 30
77852: PUSH
77853: LD_INT 32
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 30
77862: PUSH
77863: LD_INT 31
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: LIST
77874: PPUSH
77875: CALL_OW 72
77879: PUSH
77880: LD_VAR 0 2
77884: PPUSH
77885: LD_INT 2
77887: PUSH
77888: LD_INT 30
77890: PUSH
77891: LD_INT 4
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 30
77900: PUSH
77901: LD_INT 5
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: LIST
77912: PPUSH
77913: CALL_OW 72
77917: ADD
77918: ST_TO_ADDR
77919: GO 78167
77921: LD_INT 2
77923: DOUBLE
77924: EQUAL
77925: IFTRUE 77935
77927: LD_INT 16
77929: DOUBLE
77930: EQUAL
77931: IFTRUE 77935
77933: GO 77981
77935: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77936: LD_ADDR_VAR 0 8
77940: PUSH
77941: LD_VAR 0 2
77945: PPUSH
77946: LD_INT 2
77948: PUSH
77949: LD_INT 30
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 30
77961: PUSH
77962: LD_INT 1
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: LIST
77973: PPUSH
77974: CALL_OW 72
77978: ST_TO_ADDR
77979: GO 78167
77981: LD_INT 3
77983: DOUBLE
77984: EQUAL
77985: IFTRUE 77989
77987: GO 78035
77989: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77990: LD_ADDR_VAR 0 8
77994: PUSH
77995: LD_VAR 0 2
77999: PPUSH
78000: LD_INT 2
78002: PUSH
78003: LD_INT 30
78005: PUSH
78006: LD_INT 2
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 30
78015: PUSH
78016: LD_INT 3
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: LIST
78027: PPUSH
78028: CALL_OW 72
78032: ST_TO_ADDR
78033: GO 78167
78035: LD_INT 4
78037: DOUBLE
78038: EQUAL
78039: IFTRUE 78043
78041: GO 78100
78043: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78044: LD_ADDR_VAR 0 8
78048: PUSH
78049: LD_VAR 0 2
78053: PPUSH
78054: LD_INT 2
78056: PUSH
78057: LD_INT 30
78059: PUSH
78060: LD_INT 6
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 30
78069: PUSH
78070: LD_INT 7
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 30
78079: PUSH
78080: LD_INT 8
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: LIST
78091: LIST
78092: PPUSH
78093: CALL_OW 72
78097: ST_TO_ADDR
78098: GO 78167
78100: LD_INT 5
78102: DOUBLE
78103: EQUAL
78104: IFTRUE 78120
78106: LD_INT 8
78108: DOUBLE
78109: EQUAL
78110: IFTRUE 78120
78112: LD_INT 9
78114: DOUBLE
78115: EQUAL
78116: IFTRUE 78120
78118: GO 78166
78120: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78121: LD_ADDR_VAR 0 8
78125: PUSH
78126: LD_VAR 0 2
78130: PPUSH
78131: LD_INT 2
78133: PUSH
78134: LD_INT 30
78136: PUSH
78137: LD_INT 4
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 30
78146: PUSH
78147: LD_INT 5
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: LIST
78158: PPUSH
78159: CALL_OW 72
78163: ST_TO_ADDR
78164: GO 78167
78166: POP
// if not tmp then
78167: LD_VAR 0 8
78171: NOT
78172: IFFALSE 78176
// exit ;
78174: GO 78678
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78176: LD_VAR 0 4
78180: PUSH
78181: LD_INT 1
78183: PUSH
78184: LD_INT 15
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: IN
78191: PUSH
78192: LD_EXP 59
78196: PUSH
78197: LD_VAR 0 1
78201: ARRAY
78202: AND
78203: IFFALSE 78359
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78205: LD_ADDR_VAR 0 9
78209: PUSH
78210: LD_EXP 59
78214: PUSH
78215: LD_VAR 0 1
78219: ARRAY
78220: PUSH
78221: LD_INT 1
78223: ARRAY
78224: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78225: LD_VAR 0 9
78229: PUSH
78230: LD_EXP 60
78234: PUSH
78235: LD_VAR 0 1
78239: ARRAY
78240: IN
78241: NOT
78242: IFFALSE 78357
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78244: LD_ADDR_EXP 60
78248: PUSH
78249: LD_EXP 60
78253: PPUSH
78254: LD_VAR 0 1
78258: PUSH
78259: LD_EXP 60
78263: PUSH
78264: LD_VAR 0 1
78268: ARRAY
78269: PUSH
78270: LD_INT 1
78272: PLUS
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PPUSH
78278: LD_VAR 0 9
78282: PPUSH
78283: CALL 18748 0 3
78287: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78288: LD_ADDR_EXP 59
78292: PUSH
78293: LD_EXP 59
78297: PPUSH
78298: LD_VAR 0 1
78302: PPUSH
78303: LD_EXP 59
78307: PUSH
78308: LD_VAR 0 1
78312: ARRAY
78313: PUSH
78314: LD_VAR 0 9
78318: DIFF
78319: PPUSH
78320: CALL_OW 1
78324: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78325: LD_VAR 0 3
78329: PPUSH
78330: LD_EXP 60
78334: PUSH
78335: LD_VAR 0 1
78339: ARRAY
78340: PUSH
78341: LD_EXP 60
78345: PUSH
78346: LD_VAR 0 1
78350: ARRAY
78351: ARRAY
78352: PPUSH
78353: CALL_OW 120
// end ; exit ;
78357: GO 78678
// end ; if tmp > 1 then
78359: LD_VAR 0 8
78363: PUSH
78364: LD_INT 1
78366: GREATER
78367: IFFALSE 78471
// for i = 2 to tmp do
78369: LD_ADDR_VAR 0 6
78373: PUSH
78374: DOUBLE
78375: LD_INT 2
78377: DEC
78378: ST_TO_ADDR
78379: LD_VAR 0 8
78383: PUSH
78384: FOR_TO
78385: IFFALSE 78469
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78387: LD_VAR 0 8
78391: PUSH
78392: LD_VAR 0 6
78396: ARRAY
78397: PPUSH
78398: CALL_OW 461
78402: PUSH
78403: LD_INT 6
78405: EQUAL
78406: IFFALSE 78467
// begin x := tmp [ i ] ;
78408: LD_ADDR_VAR 0 9
78412: PUSH
78413: LD_VAR 0 8
78417: PUSH
78418: LD_VAR 0 6
78422: ARRAY
78423: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78424: LD_ADDR_VAR 0 8
78428: PUSH
78429: LD_VAR 0 8
78433: PPUSH
78434: LD_VAR 0 6
78438: PPUSH
78439: CALL_OW 3
78443: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78444: LD_ADDR_VAR 0 8
78448: PUSH
78449: LD_VAR 0 8
78453: PPUSH
78454: LD_INT 1
78456: PPUSH
78457: LD_VAR 0 9
78461: PPUSH
78462: CALL_OW 2
78466: ST_TO_ADDR
// end ;
78467: GO 78384
78469: POP
78470: POP
// for i in tmp do
78471: LD_ADDR_VAR 0 6
78475: PUSH
78476: LD_VAR 0 8
78480: PUSH
78481: FOR_IN
78482: IFFALSE 78551
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78484: LD_VAR 0 6
78488: PPUSH
78489: CALL_OW 313
78493: PUSH
78494: LD_INT 6
78496: LESS
78497: PUSH
78498: LD_VAR 0 6
78502: PPUSH
78503: CALL_OW 266
78507: PUSH
78508: LD_INT 31
78510: PUSH
78511: LD_INT 32
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: IN
78518: NOT
78519: AND
78520: PUSH
78521: LD_VAR 0 6
78525: PPUSH
78526: CALL_OW 313
78530: PUSH
78531: LD_INT 0
78533: EQUAL
78534: OR
78535: IFFALSE 78549
// begin j := i ;
78537: LD_ADDR_VAR 0 7
78541: PUSH
78542: LD_VAR 0 6
78546: ST_TO_ADDR
// break ;
78547: GO 78551
// end ; end ;
78549: GO 78481
78551: POP
78552: POP
// if j then
78553: LD_VAR 0 7
78557: IFFALSE 78575
// ComEnterUnit ( unit , j ) else
78559: LD_VAR 0 3
78563: PPUSH
78564: LD_VAR 0 7
78568: PPUSH
78569: CALL_OW 120
78573: GO 78678
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78575: LD_ADDR_VAR 0 10
78579: PUSH
78580: LD_VAR 0 2
78584: PPUSH
78585: LD_INT 2
78587: PUSH
78588: LD_INT 30
78590: PUSH
78591: LD_INT 0
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PUSH
78598: LD_INT 30
78600: PUSH
78601: LD_INT 1
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: LIST
78612: PPUSH
78613: CALL_OW 72
78617: ST_TO_ADDR
// if depot then
78618: LD_VAR 0 10
78622: IFFALSE 78678
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78624: LD_ADDR_VAR 0 10
78628: PUSH
78629: LD_VAR 0 10
78633: PPUSH
78634: LD_VAR 0 3
78638: PPUSH
78639: CALL_OW 74
78643: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78644: LD_VAR 0 3
78648: PPUSH
78649: LD_VAR 0 10
78653: PPUSH
78654: CALL_OW 296
78658: PUSH
78659: LD_INT 10
78661: GREATER
78662: IFFALSE 78678
// ComStandNearbyBuilding ( unit , depot ) ;
78664: LD_VAR 0 3
78668: PPUSH
78669: LD_VAR 0 10
78673: PPUSH
78674: CALL 15175 0 2
// end ; end ; end ;
78678: LD_VAR 0 5
78682: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78683: LD_INT 0
78685: PPUSH
78686: PPUSH
78687: PPUSH
78688: PPUSH
// if not mc_bases then
78689: LD_EXP 50
78693: NOT
78694: IFFALSE 78698
// exit ;
78696: GO 78937
// for i = 1 to mc_bases do
78698: LD_ADDR_VAR 0 2
78702: PUSH
78703: DOUBLE
78704: LD_INT 1
78706: DEC
78707: ST_TO_ADDR
78708: LD_EXP 50
78712: PUSH
78713: FOR_TO
78714: IFFALSE 78935
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78716: LD_ADDR_VAR 0 4
78720: PUSH
78721: LD_EXP 50
78725: PUSH
78726: LD_VAR 0 2
78730: ARRAY
78731: PPUSH
78732: LD_INT 21
78734: PUSH
78735: LD_INT 1
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PPUSH
78742: CALL_OW 72
78746: PUSH
78747: LD_EXP 79
78751: PUSH
78752: LD_VAR 0 2
78756: ARRAY
78757: UNION
78758: ST_TO_ADDR
// if not tmp then
78759: LD_VAR 0 4
78763: NOT
78764: IFFALSE 78768
// continue ;
78766: GO 78713
// for j in tmp do
78768: LD_ADDR_VAR 0 3
78772: PUSH
78773: LD_VAR 0 4
78777: PUSH
78778: FOR_IN
78779: IFFALSE 78931
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78781: LD_VAR 0 3
78785: PPUSH
78786: CALL_OW 110
78790: NOT
78791: PUSH
78792: LD_VAR 0 3
78796: PPUSH
78797: CALL_OW 314
78801: NOT
78802: AND
78803: PUSH
78804: LD_VAR 0 3
78808: PPUSH
78809: CALL_OW 311
78813: NOT
78814: AND
78815: PUSH
78816: LD_VAR 0 3
78820: PPUSH
78821: CALL_OW 310
78825: NOT
78826: AND
78827: PUSH
78828: LD_VAR 0 3
78832: PUSH
78833: LD_EXP 53
78837: PUSH
78838: LD_VAR 0 2
78842: ARRAY
78843: PUSH
78844: LD_INT 1
78846: ARRAY
78847: IN
78848: NOT
78849: AND
78850: PUSH
78851: LD_VAR 0 3
78855: PUSH
78856: LD_EXP 53
78860: PUSH
78861: LD_VAR 0 2
78865: ARRAY
78866: PUSH
78867: LD_INT 2
78869: ARRAY
78870: IN
78871: NOT
78872: AND
78873: PUSH
78874: LD_VAR 0 3
78878: PUSH
78879: LD_EXP 62
78883: PUSH
78884: LD_VAR 0 2
78888: ARRAY
78889: IN
78890: NOT
78891: AND
78892: IFFALSE 78929
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78894: LD_VAR 0 2
78898: PPUSH
78899: LD_EXP 50
78903: PUSH
78904: LD_VAR 0 2
78908: ARRAY
78909: PPUSH
78910: LD_VAR 0 3
78914: PPUSH
78915: LD_VAR 0 3
78919: PPUSH
78920: CALL_OW 257
78924: PPUSH
78925: CALL 77701 0 4
// end ;
78929: GO 78778
78931: POP
78932: POP
// end ;
78933: GO 78713
78935: POP
78936: POP
// end ;
78937: LD_VAR 0 1
78941: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78942: LD_INT 0
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
// if not mc_bases [ base ] then
78950: LD_EXP 50
78954: PUSH
78955: LD_VAR 0 1
78959: ARRAY
78960: NOT
78961: IFFALSE 78965
// exit ;
78963: GO 79147
// tmp := [ ] ;
78965: LD_ADDR_VAR 0 6
78969: PUSH
78970: EMPTY
78971: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78972: LD_ADDR_VAR 0 7
78976: PUSH
78977: LD_VAR 0 3
78981: PPUSH
78982: LD_INT 0
78984: PPUSH
78985: CALL_OW 517
78989: ST_TO_ADDR
// if not list then
78990: LD_VAR 0 7
78994: NOT
78995: IFFALSE 78999
// exit ;
78997: GO 79147
// for i = 1 to amount do
78999: LD_ADDR_VAR 0 5
79003: PUSH
79004: DOUBLE
79005: LD_INT 1
79007: DEC
79008: ST_TO_ADDR
79009: LD_VAR 0 2
79013: PUSH
79014: FOR_TO
79015: IFFALSE 79095
// begin x := rand ( 1 , list [ 1 ] ) ;
79017: LD_ADDR_VAR 0 8
79021: PUSH
79022: LD_INT 1
79024: PPUSH
79025: LD_VAR 0 7
79029: PUSH
79030: LD_INT 1
79032: ARRAY
79033: PPUSH
79034: CALL_OW 12
79038: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79039: LD_ADDR_VAR 0 6
79043: PUSH
79044: LD_VAR 0 6
79048: PPUSH
79049: LD_VAR 0 5
79053: PPUSH
79054: LD_VAR 0 7
79058: PUSH
79059: LD_INT 1
79061: ARRAY
79062: PUSH
79063: LD_VAR 0 8
79067: ARRAY
79068: PUSH
79069: LD_VAR 0 7
79073: PUSH
79074: LD_INT 2
79076: ARRAY
79077: PUSH
79078: LD_VAR 0 8
79082: ARRAY
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PPUSH
79088: CALL_OW 1
79092: ST_TO_ADDR
// end ;
79093: GO 79014
79095: POP
79096: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79097: LD_ADDR_EXP 63
79101: PUSH
79102: LD_EXP 63
79106: PPUSH
79107: LD_VAR 0 1
79111: PPUSH
79112: LD_VAR 0 6
79116: PPUSH
79117: CALL_OW 1
79121: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79122: LD_ADDR_EXP 65
79126: PUSH
79127: LD_EXP 65
79131: PPUSH
79132: LD_VAR 0 1
79136: PPUSH
79137: LD_VAR 0 3
79141: PPUSH
79142: CALL_OW 1
79146: ST_TO_ADDR
// end ;
79147: LD_VAR 0 4
79151: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79152: LD_INT 0
79154: PPUSH
// if not mc_bases [ base ] then
79155: LD_EXP 50
79159: PUSH
79160: LD_VAR 0 1
79164: ARRAY
79165: NOT
79166: IFFALSE 79170
// exit ;
79168: GO 79195
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79170: LD_ADDR_EXP 55
79174: PUSH
79175: LD_EXP 55
79179: PPUSH
79180: LD_VAR 0 1
79184: PPUSH
79185: LD_VAR 0 2
79189: PPUSH
79190: CALL_OW 1
79194: ST_TO_ADDR
// end ;
79195: LD_VAR 0 3
79199: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79200: LD_INT 0
79202: PPUSH
// if not mc_bases [ base ] then
79203: LD_EXP 50
79207: PUSH
79208: LD_VAR 0 1
79212: ARRAY
79213: NOT
79214: IFFALSE 79218
// exit ;
79216: GO 79255
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79218: LD_ADDR_EXP 55
79222: PUSH
79223: LD_EXP 55
79227: PPUSH
79228: LD_VAR 0 1
79232: PPUSH
79233: LD_EXP 55
79237: PUSH
79238: LD_VAR 0 1
79242: ARRAY
79243: PUSH
79244: LD_VAR 0 2
79248: UNION
79249: PPUSH
79250: CALL_OW 1
79254: ST_TO_ADDR
// end ;
79255: LD_VAR 0 3
79259: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79260: LD_INT 0
79262: PPUSH
// if not mc_bases [ base ] then
79263: LD_EXP 50
79267: PUSH
79268: LD_VAR 0 1
79272: ARRAY
79273: NOT
79274: IFFALSE 79278
// exit ;
79276: GO 79303
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79278: LD_ADDR_EXP 71
79282: PUSH
79283: LD_EXP 71
79287: PPUSH
79288: LD_VAR 0 1
79292: PPUSH
79293: LD_VAR 0 2
79297: PPUSH
79298: CALL_OW 1
79302: ST_TO_ADDR
// end ;
79303: LD_VAR 0 3
79307: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79308: LD_INT 0
79310: PPUSH
// if not mc_bases [ base ] then
79311: LD_EXP 50
79315: PUSH
79316: LD_VAR 0 1
79320: ARRAY
79321: NOT
79322: IFFALSE 79326
// exit ;
79324: GO 79363
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79326: LD_ADDR_EXP 71
79330: PUSH
79331: LD_EXP 71
79335: PPUSH
79336: LD_VAR 0 1
79340: PPUSH
79341: LD_EXP 71
79345: PUSH
79346: LD_VAR 0 1
79350: ARRAY
79351: PUSH
79352: LD_VAR 0 2
79356: ADD
79357: PPUSH
79358: CALL_OW 1
79362: ST_TO_ADDR
// end ;
79363: LD_VAR 0 3
79367: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79368: LD_INT 0
79370: PPUSH
// if not mc_bases [ base ] then
79371: LD_EXP 50
79375: PUSH
79376: LD_VAR 0 1
79380: ARRAY
79381: NOT
79382: IFFALSE 79386
// exit ;
79384: GO 79440
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79386: LD_ADDR_EXP 72
79390: PUSH
79391: LD_EXP 72
79395: PPUSH
79396: LD_VAR 0 1
79400: PPUSH
79401: LD_VAR 0 2
79405: PPUSH
79406: CALL_OW 1
79410: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79411: LD_ADDR_EXP 61
79415: PUSH
79416: LD_EXP 61
79420: PPUSH
79421: LD_VAR 0 1
79425: PPUSH
79426: LD_VAR 0 2
79430: PUSH
79431: LD_INT 0
79433: PLUS
79434: PPUSH
79435: CALL_OW 1
79439: ST_TO_ADDR
// end ;
79440: LD_VAR 0 3
79444: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79445: LD_INT 0
79447: PPUSH
// if not mc_bases [ base ] then
79448: LD_EXP 50
79452: PUSH
79453: LD_VAR 0 1
79457: ARRAY
79458: NOT
79459: IFFALSE 79463
// exit ;
79461: GO 79488
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79463: LD_ADDR_EXP 61
79467: PUSH
79468: LD_EXP 61
79472: PPUSH
79473: LD_VAR 0 1
79477: PPUSH
79478: LD_VAR 0 2
79482: PPUSH
79483: CALL_OW 1
79487: ST_TO_ADDR
// end ;
79488: LD_VAR 0 3
79492: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79493: LD_INT 0
79495: PPUSH
79496: PPUSH
79497: PPUSH
79498: PPUSH
// if not mc_bases [ base ] then
79499: LD_EXP 50
79503: PUSH
79504: LD_VAR 0 1
79508: ARRAY
79509: NOT
79510: IFFALSE 79514
// exit ;
79512: GO 79579
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79514: LD_ADDR_EXP 70
79518: PUSH
79519: LD_EXP 70
79523: PPUSH
79524: LD_VAR 0 1
79528: PUSH
79529: LD_EXP 70
79533: PUSH
79534: LD_VAR 0 1
79538: ARRAY
79539: PUSH
79540: LD_INT 1
79542: PLUS
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PPUSH
79548: LD_VAR 0 1
79552: PUSH
79553: LD_VAR 0 2
79557: PUSH
79558: LD_VAR 0 3
79562: PUSH
79563: LD_VAR 0 4
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: PPUSH
79574: CALL 18748 0 3
79578: ST_TO_ADDR
// end ;
79579: LD_VAR 0 5
79583: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79584: LD_INT 0
79586: PPUSH
// if not mc_bases [ base ] then
79587: LD_EXP 50
79591: PUSH
79592: LD_VAR 0 1
79596: ARRAY
79597: NOT
79598: IFFALSE 79602
// exit ;
79600: GO 79627
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79602: LD_ADDR_EXP 87
79606: PUSH
79607: LD_EXP 87
79611: PPUSH
79612: LD_VAR 0 1
79616: PPUSH
79617: LD_VAR 0 2
79621: PPUSH
79622: CALL_OW 1
79626: ST_TO_ADDR
// end ;
79627: LD_VAR 0 3
79631: RET
// export function MC_GetMinesField ( base ) ; begin
79632: LD_INT 0
79634: PPUSH
// result := mc_mines [ base ] ;
79635: LD_ADDR_VAR 0 2
79639: PUSH
79640: LD_EXP 63
79644: PUSH
79645: LD_VAR 0 1
79649: ARRAY
79650: ST_TO_ADDR
// end ;
79651: LD_VAR 0 2
79655: RET
// export function MC_GetProduceList ( base ) ; begin
79656: LD_INT 0
79658: PPUSH
// result := mc_produce [ base ] ;
79659: LD_ADDR_VAR 0 2
79663: PUSH
79664: LD_EXP 71
79668: PUSH
79669: LD_VAR 0 1
79673: ARRAY
79674: ST_TO_ADDR
// end ;
79675: LD_VAR 0 2
79679: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79680: LD_INT 0
79682: PPUSH
79683: PPUSH
// if not mc_bases then
79684: LD_EXP 50
79688: NOT
79689: IFFALSE 79693
// exit ;
79691: GO 79758
// if mc_bases [ base ] then
79693: LD_EXP 50
79697: PUSH
79698: LD_VAR 0 1
79702: ARRAY
79703: IFFALSE 79758
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79705: LD_ADDR_VAR 0 3
79709: PUSH
79710: LD_EXP 50
79714: PUSH
79715: LD_VAR 0 1
79719: ARRAY
79720: PPUSH
79721: LD_INT 30
79723: PUSH
79724: LD_VAR 0 2
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PPUSH
79733: CALL_OW 72
79737: ST_TO_ADDR
// if result then
79738: LD_VAR 0 3
79742: IFFALSE 79758
// result := result [ 1 ] ;
79744: LD_ADDR_VAR 0 3
79748: PUSH
79749: LD_VAR 0 3
79753: PUSH
79754: LD_INT 1
79756: ARRAY
79757: ST_TO_ADDR
// end ; end ;
79758: LD_VAR 0 3
79762: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79763: LD_INT 0
79765: PPUSH
79766: PPUSH
// if not mc_bases then
79767: LD_EXP 50
79771: NOT
79772: IFFALSE 79776
// exit ;
79774: GO 79821
// if mc_bases [ base ] then
79776: LD_EXP 50
79780: PUSH
79781: LD_VAR 0 1
79785: ARRAY
79786: IFFALSE 79821
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79788: LD_ADDR_VAR 0 3
79792: PUSH
79793: LD_EXP 50
79797: PUSH
79798: LD_VAR 0 1
79802: ARRAY
79803: PPUSH
79804: LD_INT 30
79806: PUSH
79807: LD_VAR 0 2
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PPUSH
79816: CALL_OW 72
79820: ST_TO_ADDR
// end ;
79821: LD_VAR 0 3
79825: RET
// export function MC_SetTame ( base , area ) ; begin
79826: LD_INT 0
79828: PPUSH
// if not mc_bases or not base then
79829: LD_EXP 50
79833: NOT
79834: PUSH
79835: LD_VAR 0 1
79839: NOT
79840: OR
79841: IFFALSE 79845
// exit ;
79843: GO 79870
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79845: LD_ADDR_EXP 78
79849: PUSH
79850: LD_EXP 78
79854: PPUSH
79855: LD_VAR 0 1
79859: PPUSH
79860: LD_VAR 0 2
79864: PPUSH
79865: CALL_OW 1
79869: ST_TO_ADDR
// end ;
79870: LD_VAR 0 3
79874: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79875: LD_INT 0
79877: PPUSH
79878: PPUSH
// if not mc_bases or not base then
79879: LD_EXP 50
79883: NOT
79884: PUSH
79885: LD_VAR 0 1
79889: NOT
79890: OR
79891: IFFALSE 79895
// exit ;
79893: GO 79997
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79895: LD_ADDR_VAR 0 4
79899: PUSH
79900: LD_EXP 50
79904: PUSH
79905: LD_VAR 0 1
79909: ARRAY
79910: PPUSH
79911: LD_INT 30
79913: PUSH
79914: LD_VAR 0 2
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PPUSH
79923: CALL_OW 72
79927: ST_TO_ADDR
// if not tmp then
79928: LD_VAR 0 4
79932: NOT
79933: IFFALSE 79937
// exit ;
79935: GO 79997
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79937: LD_ADDR_EXP 82
79941: PUSH
79942: LD_EXP 82
79946: PPUSH
79947: LD_VAR 0 1
79951: PPUSH
79952: LD_EXP 82
79956: PUSH
79957: LD_VAR 0 1
79961: ARRAY
79962: PPUSH
79963: LD_EXP 82
79967: PUSH
79968: LD_VAR 0 1
79972: ARRAY
79973: PUSH
79974: LD_INT 1
79976: PLUS
79977: PPUSH
79978: LD_VAR 0 4
79982: PUSH
79983: LD_INT 1
79985: ARRAY
79986: PPUSH
79987: CALL_OW 2
79991: PPUSH
79992: CALL_OW 1
79996: ST_TO_ADDR
// end ;
79997: LD_VAR 0 3
80001: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80002: LD_INT 0
80004: PPUSH
80005: PPUSH
// if not mc_bases or not base or not kinds then
80006: LD_EXP 50
80010: NOT
80011: PUSH
80012: LD_VAR 0 1
80016: NOT
80017: OR
80018: PUSH
80019: LD_VAR 0 2
80023: NOT
80024: OR
80025: IFFALSE 80029
// exit ;
80027: GO 80090
// for i in kinds do
80029: LD_ADDR_VAR 0 4
80033: PUSH
80034: LD_VAR 0 2
80038: PUSH
80039: FOR_IN
80040: IFFALSE 80088
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80042: LD_ADDR_EXP 84
80046: PUSH
80047: LD_EXP 84
80051: PPUSH
80052: LD_VAR 0 1
80056: PUSH
80057: LD_EXP 84
80061: PUSH
80062: LD_VAR 0 1
80066: ARRAY
80067: PUSH
80068: LD_INT 1
80070: PLUS
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PPUSH
80076: LD_VAR 0 4
80080: PPUSH
80081: CALL 18748 0 3
80085: ST_TO_ADDR
80086: GO 80039
80088: POP
80089: POP
// end ;
80090: LD_VAR 0 3
80094: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80095: LD_INT 0
80097: PPUSH
// if not mc_bases or not base or not areas then
80098: LD_EXP 50
80102: NOT
80103: PUSH
80104: LD_VAR 0 1
80108: NOT
80109: OR
80110: PUSH
80111: LD_VAR 0 2
80115: NOT
80116: OR
80117: IFFALSE 80121
// exit ;
80119: GO 80146
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80121: LD_ADDR_EXP 68
80125: PUSH
80126: LD_EXP 68
80130: PPUSH
80131: LD_VAR 0 1
80135: PPUSH
80136: LD_VAR 0 2
80140: PPUSH
80141: CALL_OW 1
80145: ST_TO_ADDR
// end ;
80146: LD_VAR 0 3
80150: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80151: LD_INT 0
80153: PPUSH
// if not mc_bases or not base or not teleports_exit then
80154: LD_EXP 50
80158: NOT
80159: PUSH
80160: LD_VAR 0 1
80164: NOT
80165: OR
80166: PUSH
80167: LD_VAR 0 2
80171: NOT
80172: OR
80173: IFFALSE 80177
// exit ;
80175: GO 80202
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80177: LD_ADDR_EXP 85
80181: PUSH
80182: LD_EXP 85
80186: PPUSH
80187: LD_VAR 0 1
80191: PPUSH
80192: LD_VAR 0 2
80196: PPUSH
80197: CALL_OW 1
80201: ST_TO_ADDR
// end ;
80202: LD_VAR 0 3
80206: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80207: LD_INT 0
80209: PPUSH
80210: PPUSH
80211: PPUSH
// if not mc_bases or not base or not ext_list then
80212: LD_EXP 50
80216: NOT
80217: PUSH
80218: LD_VAR 0 1
80222: NOT
80223: OR
80224: PUSH
80225: LD_VAR 0 5
80229: NOT
80230: OR
80231: IFFALSE 80235
// exit ;
80233: GO 80408
// tmp := GetFacExtXYD ( x , y , d ) ;
80235: LD_ADDR_VAR 0 8
80239: PUSH
80240: LD_VAR 0 2
80244: PPUSH
80245: LD_VAR 0 3
80249: PPUSH
80250: LD_VAR 0 4
80254: PPUSH
80255: CALL 48725 0 3
80259: ST_TO_ADDR
// if not tmp then
80260: LD_VAR 0 8
80264: NOT
80265: IFFALSE 80269
// exit ;
80267: GO 80408
// for i in tmp do
80269: LD_ADDR_VAR 0 7
80273: PUSH
80274: LD_VAR 0 8
80278: PUSH
80279: FOR_IN
80280: IFFALSE 80406
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80282: LD_ADDR_EXP 55
80286: PUSH
80287: LD_EXP 55
80291: PPUSH
80292: LD_VAR 0 1
80296: PPUSH
80297: LD_EXP 55
80301: PUSH
80302: LD_VAR 0 1
80306: ARRAY
80307: PPUSH
80308: LD_EXP 55
80312: PUSH
80313: LD_VAR 0 1
80317: ARRAY
80318: PUSH
80319: LD_INT 1
80321: PLUS
80322: PPUSH
80323: LD_VAR 0 5
80327: PUSH
80328: LD_INT 1
80330: ARRAY
80331: PUSH
80332: LD_VAR 0 7
80336: PUSH
80337: LD_INT 1
80339: ARRAY
80340: PUSH
80341: LD_VAR 0 7
80345: PUSH
80346: LD_INT 2
80348: ARRAY
80349: PUSH
80350: LD_VAR 0 7
80354: PUSH
80355: LD_INT 3
80357: ARRAY
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: LIST
80363: LIST
80364: PPUSH
80365: CALL_OW 2
80369: PPUSH
80370: CALL_OW 1
80374: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80375: LD_ADDR_VAR 0 5
80379: PUSH
80380: LD_VAR 0 5
80384: PPUSH
80385: LD_INT 1
80387: PPUSH
80388: CALL_OW 3
80392: ST_TO_ADDR
// if not ext_list then
80393: LD_VAR 0 5
80397: NOT
80398: IFFALSE 80404
// exit ;
80400: POP
80401: POP
80402: GO 80408
// end ;
80404: GO 80279
80406: POP
80407: POP
// end ;
80408: LD_VAR 0 6
80412: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80413: LD_INT 0
80415: PPUSH
// if not mc_bases or not base or not weapon_list then
80416: LD_EXP 50
80420: NOT
80421: PUSH
80422: LD_VAR 0 1
80426: NOT
80427: OR
80428: PUSH
80429: LD_VAR 0 2
80433: NOT
80434: OR
80435: IFFALSE 80439
// exit ;
80437: GO 80464
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80439: LD_ADDR_EXP 89
80443: PUSH
80444: LD_EXP 89
80448: PPUSH
80449: LD_VAR 0 1
80453: PPUSH
80454: LD_VAR 0 2
80458: PPUSH
80459: CALL_OW 1
80463: ST_TO_ADDR
// end ;
80464: LD_VAR 0 3
80468: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80469: LD_INT 0
80471: PPUSH
// if not mc_bases or not base or not tech_list then
80472: LD_EXP 50
80476: NOT
80477: PUSH
80478: LD_VAR 0 1
80482: NOT
80483: OR
80484: PUSH
80485: LD_VAR 0 2
80489: NOT
80490: OR
80491: IFFALSE 80495
// exit ;
80493: GO 80520
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80495: LD_ADDR_EXP 77
80499: PUSH
80500: LD_EXP 77
80504: PPUSH
80505: LD_VAR 0 1
80509: PPUSH
80510: LD_VAR 0 2
80514: PPUSH
80515: CALL_OW 1
80519: ST_TO_ADDR
// end ;
80520: LD_VAR 0 3
80524: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80525: LD_INT 0
80527: PPUSH
// if not mc_bases or not parking_area or not base then
80528: LD_EXP 50
80532: NOT
80533: PUSH
80534: LD_VAR 0 2
80538: NOT
80539: OR
80540: PUSH
80541: LD_VAR 0 1
80545: NOT
80546: OR
80547: IFFALSE 80551
// exit ;
80549: GO 80576
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80551: LD_ADDR_EXP 74
80555: PUSH
80556: LD_EXP 74
80560: PPUSH
80561: LD_VAR 0 1
80565: PPUSH
80566: LD_VAR 0 2
80570: PPUSH
80571: CALL_OW 1
80575: ST_TO_ADDR
// end ;
80576: LD_VAR 0 3
80580: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80581: LD_INT 0
80583: PPUSH
// if not mc_bases or not base or not scan_area then
80584: LD_EXP 50
80588: NOT
80589: PUSH
80590: LD_VAR 0 1
80594: NOT
80595: OR
80596: PUSH
80597: LD_VAR 0 2
80601: NOT
80602: OR
80603: IFFALSE 80607
// exit ;
80605: GO 80632
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80607: LD_ADDR_EXP 75
80611: PUSH
80612: LD_EXP 75
80616: PPUSH
80617: LD_VAR 0 1
80621: PPUSH
80622: LD_VAR 0 2
80626: PPUSH
80627: CALL_OW 1
80631: ST_TO_ADDR
// end ;
80632: LD_VAR 0 3
80636: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80637: LD_INT 0
80639: PPUSH
80640: PPUSH
// if not mc_bases or not base then
80641: LD_EXP 50
80645: NOT
80646: PUSH
80647: LD_VAR 0 1
80651: NOT
80652: OR
80653: IFFALSE 80657
// exit ;
80655: GO 80721
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80657: LD_ADDR_VAR 0 3
80661: PUSH
80662: LD_INT 1
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 3
80670: PUSH
80671: LD_INT 4
80673: PUSH
80674: LD_INT 11
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80684: LD_ADDR_EXP 77
80688: PUSH
80689: LD_EXP 77
80693: PPUSH
80694: LD_VAR 0 1
80698: PPUSH
80699: LD_EXP 77
80703: PUSH
80704: LD_VAR 0 1
80708: ARRAY
80709: PUSH
80710: LD_VAR 0 3
80714: DIFF
80715: PPUSH
80716: CALL_OW 1
80720: ST_TO_ADDR
// end ;
80721: LD_VAR 0 2
80725: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80726: LD_INT 0
80728: PPUSH
// result := mc_vehicles [ base ] ;
80729: LD_ADDR_VAR 0 3
80733: PUSH
80734: LD_EXP 69
80738: PUSH
80739: LD_VAR 0 1
80743: ARRAY
80744: ST_TO_ADDR
// if onlyCombat then
80745: LD_VAR 0 2
80749: IFFALSE 80921
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80751: LD_ADDR_VAR 0 3
80755: PUSH
80756: LD_VAR 0 3
80760: PUSH
80761: LD_VAR 0 3
80765: PPUSH
80766: LD_INT 2
80768: PUSH
80769: LD_INT 34
80771: PUSH
80772: LD_INT 12
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 34
80781: PUSH
80782: LD_INT 51
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 34
80791: PUSH
80792: LD_INT 89
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 34
80801: PUSH
80802: LD_INT 32
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 34
80811: PUSH
80812: LD_INT 13
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 34
80821: PUSH
80822: LD_INT 52
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 34
80831: PUSH
80832: LD_INT 88
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 34
80841: PUSH
80842: LD_INT 14
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 34
80851: PUSH
80852: LD_INT 53
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 34
80861: PUSH
80862: LD_INT 98
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 34
80871: PUSH
80872: LD_INT 31
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 34
80881: PUSH
80882: LD_INT 48
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 34
80891: PUSH
80892: LD_INT 8
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: PPUSH
80915: CALL_OW 72
80919: DIFF
80920: ST_TO_ADDR
// end ; end_of_file
80921: LD_VAR 0 3
80925: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80926: LD_INT 0
80928: PPUSH
80929: PPUSH
80930: PPUSH
// if not mc_bases or not skirmish then
80931: LD_EXP 50
80935: NOT
80936: PUSH
80937: LD_EXP 48
80941: NOT
80942: OR
80943: IFFALSE 80947
// exit ;
80945: GO 81112
// for i = 1 to mc_bases do
80947: LD_ADDR_VAR 0 4
80951: PUSH
80952: DOUBLE
80953: LD_INT 1
80955: DEC
80956: ST_TO_ADDR
80957: LD_EXP 50
80961: PUSH
80962: FOR_TO
80963: IFFALSE 81110
// begin if sci in mc_bases [ i ] then
80965: LD_VAR 0 2
80969: PUSH
80970: LD_EXP 50
80974: PUSH
80975: LD_VAR 0 4
80979: ARRAY
80980: IN
80981: IFFALSE 81108
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80983: LD_ADDR_EXP 79
80987: PUSH
80988: LD_EXP 79
80992: PPUSH
80993: LD_VAR 0 4
80997: PUSH
80998: LD_EXP 79
81002: PUSH
81003: LD_VAR 0 4
81007: ARRAY
81008: PUSH
81009: LD_INT 1
81011: PLUS
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PPUSH
81017: LD_VAR 0 1
81021: PPUSH
81022: CALL 18748 0 3
81026: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81027: LD_ADDR_VAR 0 5
81031: PUSH
81032: LD_EXP 50
81036: PUSH
81037: LD_VAR 0 4
81041: ARRAY
81042: PPUSH
81043: LD_INT 2
81045: PUSH
81046: LD_INT 30
81048: PUSH
81049: LD_INT 0
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 30
81058: PUSH
81059: LD_INT 1
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: LIST
81070: PPUSH
81071: CALL_OW 72
81075: PPUSH
81076: LD_VAR 0 1
81080: PPUSH
81081: CALL_OW 74
81085: ST_TO_ADDR
// if tmp then
81086: LD_VAR 0 5
81090: IFFALSE 81106
// ComStandNearbyBuilding ( ape , tmp ) ;
81092: LD_VAR 0 1
81096: PPUSH
81097: LD_VAR 0 5
81101: PPUSH
81102: CALL 15175 0 2
// break ;
81106: GO 81110
// end ; end ;
81108: GO 80962
81110: POP
81111: POP
// end ;
81112: LD_VAR 0 3
81116: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81117: LD_INT 0
81119: PPUSH
81120: PPUSH
81121: PPUSH
// if not mc_bases or not skirmish then
81122: LD_EXP 50
81126: NOT
81127: PUSH
81128: LD_EXP 48
81132: NOT
81133: OR
81134: IFFALSE 81138
// exit ;
81136: GO 81227
// for i = 1 to mc_bases do
81138: LD_ADDR_VAR 0 4
81142: PUSH
81143: DOUBLE
81144: LD_INT 1
81146: DEC
81147: ST_TO_ADDR
81148: LD_EXP 50
81152: PUSH
81153: FOR_TO
81154: IFFALSE 81225
// begin if building in mc_busy_turret_list [ i ] then
81156: LD_VAR 0 1
81160: PUSH
81161: LD_EXP 60
81165: PUSH
81166: LD_VAR 0 4
81170: ARRAY
81171: IN
81172: IFFALSE 81223
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81174: LD_ADDR_VAR 0 5
81178: PUSH
81179: LD_EXP 60
81183: PUSH
81184: LD_VAR 0 4
81188: ARRAY
81189: PUSH
81190: LD_VAR 0 1
81194: DIFF
81195: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81196: LD_ADDR_EXP 60
81200: PUSH
81201: LD_EXP 60
81205: PPUSH
81206: LD_VAR 0 4
81210: PPUSH
81211: LD_VAR 0 5
81215: PPUSH
81216: CALL_OW 1
81220: ST_TO_ADDR
// break ;
81221: GO 81225
// end ; end ;
81223: GO 81153
81225: POP
81226: POP
// end ;
81227: LD_VAR 0 3
81231: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81232: LD_INT 0
81234: PPUSH
81235: PPUSH
81236: PPUSH
// if not mc_bases or not skirmish then
81237: LD_EXP 50
81241: NOT
81242: PUSH
81243: LD_EXP 48
81247: NOT
81248: OR
81249: IFFALSE 81253
// exit ;
81251: GO 81452
// for i = 1 to mc_bases do
81253: LD_ADDR_VAR 0 5
81257: PUSH
81258: DOUBLE
81259: LD_INT 1
81261: DEC
81262: ST_TO_ADDR
81263: LD_EXP 50
81267: PUSH
81268: FOR_TO
81269: IFFALSE 81450
// if building in mc_bases [ i ] then
81271: LD_VAR 0 1
81275: PUSH
81276: LD_EXP 50
81280: PUSH
81281: LD_VAR 0 5
81285: ARRAY
81286: IN
81287: IFFALSE 81448
// begin tmp := mc_bases [ i ] diff building ;
81289: LD_ADDR_VAR 0 6
81293: PUSH
81294: LD_EXP 50
81298: PUSH
81299: LD_VAR 0 5
81303: ARRAY
81304: PUSH
81305: LD_VAR 0 1
81309: DIFF
81310: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81311: LD_ADDR_EXP 50
81315: PUSH
81316: LD_EXP 50
81320: PPUSH
81321: LD_VAR 0 5
81325: PPUSH
81326: LD_VAR 0 6
81330: PPUSH
81331: CALL_OW 1
81335: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81336: LD_VAR 0 1
81340: PUSH
81341: LD_EXP 58
81345: PUSH
81346: LD_VAR 0 5
81350: ARRAY
81351: IN
81352: IFFALSE 81391
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81354: LD_ADDR_EXP 58
81358: PUSH
81359: LD_EXP 58
81363: PPUSH
81364: LD_VAR 0 5
81368: PPUSH
81369: LD_EXP 58
81373: PUSH
81374: LD_VAR 0 5
81378: ARRAY
81379: PUSH
81380: LD_VAR 0 1
81384: DIFF
81385: PPUSH
81386: CALL_OW 1
81390: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81391: LD_VAR 0 1
81395: PUSH
81396: LD_EXP 59
81400: PUSH
81401: LD_VAR 0 5
81405: ARRAY
81406: IN
81407: IFFALSE 81446
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81409: LD_ADDR_EXP 59
81413: PUSH
81414: LD_EXP 59
81418: PPUSH
81419: LD_VAR 0 5
81423: PPUSH
81424: LD_EXP 59
81428: PUSH
81429: LD_VAR 0 5
81433: ARRAY
81434: PUSH
81435: LD_VAR 0 1
81439: DIFF
81440: PPUSH
81441: CALL_OW 1
81445: ST_TO_ADDR
// break ;
81446: GO 81450
// end ;
81448: GO 81268
81450: POP
81451: POP
// end ;
81452: LD_VAR 0 4
81456: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81457: LD_INT 0
81459: PPUSH
81460: PPUSH
81461: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81462: LD_EXP 50
81466: NOT
81467: PUSH
81468: LD_EXP 48
81472: NOT
81473: OR
81474: PUSH
81475: LD_VAR 0 3
81479: PUSH
81480: LD_EXP 76
81484: IN
81485: NOT
81486: OR
81487: IFFALSE 81491
// exit ;
81489: GO 81614
// for i = 1 to mc_vehicles do
81491: LD_ADDR_VAR 0 6
81495: PUSH
81496: DOUBLE
81497: LD_INT 1
81499: DEC
81500: ST_TO_ADDR
81501: LD_EXP 69
81505: PUSH
81506: FOR_TO
81507: IFFALSE 81612
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81509: LD_VAR 0 2
81513: PUSH
81514: LD_EXP 69
81518: PUSH
81519: LD_VAR 0 6
81523: ARRAY
81524: IN
81525: PUSH
81526: LD_VAR 0 1
81530: PUSH
81531: LD_EXP 69
81535: PUSH
81536: LD_VAR 0 6
81540: ARRAY
81541: IN
81542: OR
81543: IFFALSE 81610
// begin tmp := mc_vehicles [ i ] diff old ;
81545: LD_ADDR_VAR 0 7
81549: PUSH
81550: LD_EXP 69
81554: PUSH
81555: LD_VAR 0 6
81559: ARRAY
81560: PUSH
81561: LD_VAR 0 2
81565: DIFF
81566: ST_TO_ADDR
// tmp := tmp diff new ;
81567: LD_ADDR_VAR 0 7
81571: PUSH
81572: LD_VAR 0 7
81576: PUSH
81577: LD_VAR 0 1
81581: DIFF
81582: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81583: LD_ADDR_EXP 69
81587: PUSH
81588: LD_EXP 69
81592: PPUSH
81593: LD_VAR 0 6
81597: PPUSH
81598: LD_VAR 0 7
81602: PPUSH
81603: CALL_OW 1
81607: ST_TO_ADDR
// break ;
81608: GO 81612
// end ;
81610: GO 81506
81612: POP
81613: POP
// end ;
81614: LD_VAR 0 5
81618: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81619: LD_INT 0
81621: PPUSH
81622: PPUSH
81623: PPUSH
81624: PPUSH
// if not mc_bases or not skirmish then
81625: LD_EXP 50
81629: NOT
81630: PUSH
81631: LD_EXP 48
81635: NOT
81636: OR
81637: IFFALSE 81641
// exit ;
81639: GO 82023
// side := GetSide ( vehicle ) ;
81641: LD_ADDR_VAR 0 5
81645: PUSH
81646: LD_VAR 0 1
81650: PPUSH
81651: CALL_OW 255
81655: ST_TO_ADDR
// for i = 1 to mc_bases do
81656: LD_ADDR_VAR 0 4
81660: PUSH
81661: DOUBLE
81662: LD_INT 1
81664: DEC
81665: ST_TO_ADDR
81666: LD_EXP 50
81670: PUSH
81671: FOR_TO
81672: IFFALSE 82021
// begin if factory in mc_bases [ i ] then
81674: LD_VAR 0 2
81678: PUSH
81679: LD_EXP 50
81683: PUSH
81684: LD_VAR 0 4
81688: ARRAY
81689: IN
81690: IFFALSE 82019
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81692: LD_EXP 72
81696: PUSH
81697: LD_VAR 0 4
81701: ARRAY
81702: PUSH
81703: LD_EXP 61
81707: PUSH
81708: LD_VAR 0 4
81712: ARRAY
81713: LESS
81714: PUSH
81715: LD_VAR 0 1
81719: PPUSH
81720: CALL_OW 264
81724: PUSH
81725: LD_INT 31
81727: PUSH
81728: LD_INT 32
81730: PUSH
81731: LD_INT 51
81733: PUSH
81734: LD_INT 89
81736: PUSH
81737: LD_INT 12
81739: PUSH
81740: LD_INT 30
81742: PUSH
81743: LD_INT 98
81745: PUSH
81746: LD_INT 11
81748: PUSH
81749: LD_INT 53
81751: PUSH
81752: LD_INT 14
81754: PUSH
81755: LD_INT 91
81757: PUSH
81758: LD_INT 29
81760: PUSH
81761: LD_INT 99
81763: PUSH
81764: LD_INT 13
81766: PUSH
81767: LD_INT 52
81769: PUSH
81770: LD_INT 88
81772: PUSH
81773: LD_INT 48
81775: PUSH
81776: LD_INT 8
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: IN
81799: NOT
81800: AND
81801: IFFALSE 81849
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81803: LD_ADDR_EXP 72
81807: PUSH
81808: LD_EXP 72
81812: PPUSH
81813: LD_VAR 0 4
81817: PUSH
81818: LD_EXP 72
81822: PUSH
81823: LD_VAR 0 4
81827: ARRAY
81828: PUSH
81829: LD_INT 1
81831: PLUS
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PPUSH
81837: LD_VAR 0 1
81841: PPUSH
81842: CALL 18748 0 3
81846: ST_TO_ADDR
81847: GO 81893
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81849: LD_ADDR_EXP 69
81853: PUSH
81854: LD_EXP 69
81858: PPUSH
81859: LD_VAR 0 4
81863: PUSH
81864: LD_EXP 69
81868: PUSH
81869: LD_VAR 0 4
81873: ARRAY
81874: PUSH
81875: LD_INT 1
81877: PLUS
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PPUSH
81883: LD_VAR 0 1
81887: PPUSH
81888: CALL 18748 0 3
81892: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81893: LD_VAR 0 1
81897: PPUSH
81898: CALL_OW 263
81902: PUSH
81903: LD_INT 2
81905: EQUAL
81906: IFFALSE 81935
// begin repeat wait ( 0 0$3 ) ;
81908: LD_INT 105
81910: PPUSH
81911: CALL_OW 67
// Connect ( vehicle ) ;
81915: LD_VAR 0 1
81919: PPUSH
81920: CALL 21717 0 1
// until IsControledBy ( vehicle ) ;
81924: LD_VAR 0 1
81928: PPUSH
81929: CALL_OW 312
81933: IFFALSE 81908
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81935: LD_VAR 0 1
81939: PPUSH
81940: LD_EXP 74
81944: PUSH
81945: LD_VAR 0 4
81949: ARRAY
81950: PPUSH
81951: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81955: LD_VAR 0 1
81959: PPUSH
81960: CALL_OW 263
81964: PUSH
81965: LD_INT 1
81967: NONEQUAL
81968: IFFALSE 81972
// break ;
81970: GO 82021
// repeat wait ( 0 0$1 ) ;
81972: LD_INT 35
81974: PPUSH
81975: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81979: LD_VAR 0 1
81983: PPUSH
81984: LD_EXP 74
81988: PUSH
81989: LD_VAR 0 4
81993: ARRAY
81994: PPUSH
81995: CALL_OW 308
81999: IFFALSE 81972
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82001: LD_VAR 0 1
82005: PPUSH
82006: CALL_OW 311
82010: PPUSH
82011: CALL_OW 121
// exit ;
82015: POP
82016: POP
82017: GO 82023
// end ; end ;
82019: GO 81671
82021: POP
82022: POP
// end ;
82023: LD_VAR 0 3
82027: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82028: LD_INT 0
82030: PPUSH
82031: PPUSH
82032: PPUSH
82033: PPUSH
// if not mc_bases or not skirmish then
82034: LD_EXP 50
82038: NOT
82039: PUSH
82040: LD_EXP 48
82044: NOT
82045: OR
82046: IFFALSE 82050
// exit ;
82048: GO 82403
// repeat wait ( 0 0$1 ) ;
82050: LD_INT 35
82052: PPUSH
82053: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82057: LD_VAR 0 2
82061: PPUSH
82062: LD_VAR 0 3
82066: PPUSH
82067: CALL_OW 284
82071: IFFALSE 82050
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82073: LD_VAR 0 2
82077: PPUSH
82078: LD_VAR 0 3
82082: PPUSH
82083: CALL_OW 283
82087: PUSH
82088: LD_INT 4
82090: EQUAL
82091: IFFALSE 82095
// exit ;
82093: GO 82403
// for i = 1 to mc_bases do
82095: LD_ADDR_VAR 0 7
82099: PUSH
82100: DOUBLE
82101: LD_INT 1
82103: DEC
82104: ST_TO_ADDR
82105: LD_EXP 50
82109: PUSH
82110: FOR_TO
82111: IFFALSE 82401
// begin if mc_crates_area [ i ] then
82113: LD_EXP 68
82117: PUSH
82118: LD_VAR 0 7
82122: ARRAY
82123: IFFALSE 82234
// for j in mc_crates_area [ i ] do
82125: LD_ADDR_VAR 0 8
82129: PUSH
82130: LD_EXP 68
82134: PUSH
82135: LD_VAR 0 7
82139: ARRAY
82140: PUSH
82141: FOR_IN
82142: IFFALSE 82232
// if InArea ( x , y , j ) then
82144: LD_VAR 0 2
82148: PPUSH
82149: LD_VAR 0 3
82153: PPUSH
82154: LD_VAR 0 8
82158: PPUSH
82159: CALL_OW 309
82163: IFFALSE 82230
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82165: LD_ADDR_EXP 66
82169: PUSH
82170: LD_EXP 66
82174: PPUSH
82175: LD_VAR 0 7
82179: PUSH
82180: LD_EXP 66
82184: PUSH
82185: LD_VAR 0 7
82189: ARRAY
82190: PUSH
82191: LD_INT 1
82193: PLUS
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PPUSH
82199: LD_VAR 0 4
82203: PUSH
82204: LD_VAR 0 2
82208: PUSH
82209: LD_VAR 0 3
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: LIST
82218: PPUSH
82219: CALL 18748 0 3
82223: ST_TO_ADDR
// exit ;
82224: POP
82225: POP
82226: POP
82227: POP
82228: GO 82403
// end ;
82230: GO 82141
82232: POP
82233: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82234: LD_ADDR_VAR 0 9
82238: PUSH
82239: LD_EXP 50
82243: PUSH
82244: LD_VAR 0 7
82248: ARRAY
82249: PPUSH
82250: LD_INT 2
82252: PUSH
82253: LD_INT 30
82255: PUSH
82256: LD_INT 0
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 30
82265: PUSH
82266: LD_INT 1
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: LIST
82277: PPUSH
82278: CALL_OW 72
82282: ST_TO_ADDR
// if not depot then
82283: LD_VAR 0 9
82287: NOT
82288: IFFALSE 82292
// continue ;
82290: GO 82110
// for j in depot do
82292: LD_ADDR_VAR 0 8
82296: PUSH
82297: LD_VAR 0 9
82301: PUSH
82302: FOR_IN
82303: IFFALSE 82397
// if GetDistUnitXY ( j , x , y ) < 30 then
82305: LD_VAR 0 8
82309: PPUSH
82310: LD_VAR 0 2
82314: PPUSH
82315: LD_VAR 0 3
82319: PPUSH
82320: CALL_OW 297
82324: PUSH
82325: LD_INT 30
82327: LESS
82328: IFFALSE 82395
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82330: LD_ADDR_EXP 66
82334: PUSH
82335: LD_EXP 66
82339: PPUSH
82340: LD_VAR 0 7
82344: PUSH
82345: LD_EXP 66
82349: PUSH
82350: LD_VAR 0 7
82354: ARRAY
82355: PUSH
82356: LD_INT 1
82358: PLUS
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PPUSH
82364: LD_VAR 0 4
82368: PUSH
82369: LD_VAR 0 2
82373: PUSH
82374: LD_VAR 0 3
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: LIST
82383: PPUSH
82384: CALL 18748 0 3
82388: ST_TO_ADDR
// exit ;
82389: POP
82390: POP
82391: POP
82392: POP
82393: GO 82403
// end ;
82395: GO 82302
82397: POP
82398: POP
// end ;
82399: GO 82110
82401: POP
82402: POP
// end ;
82403: LD_VAR 0 6
82407: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82408: LD_INT 0
82410: PPUSH
82411: PPUSH
82412: PPUSH
82413: PPUSH
// if not mc_bases or not skirmish then
82414: LD_EXP 50
82418: NOT
82419: PUSH
82420: LD_EXP 48
82424: NOT
82425: OR
82426: IFFALSE 82430
// exit ;
82428: GO 82707
// side := GetSide ( lab ) ;
82430: LD_ADDR_VAR 0 4
82434: PUSH
82435: LD_VAR 0 2
82439: PPUSH
82440: CALL_OW 255
82444: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82445: LD_VAR 0 4
82449: PUSH
82450: LD_EXP 76
82454: IN
82455: NOT
82456: PUSH
82457: LD_EXP 77
82461: NOT
82462: OR
82463: PUSH
82464: LD_EXP 50
82468: NOT
82469: OR
82470: IFFALSE 82474
// exit ;
82472: GO 82707
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82474: LD_ADDR_EXP 77
82478: PUSH
82479: LD_EXP 77
82483: PPUSH
82484: LD_VAR 0 4
82488: PPUSH
82489: LD_EXP 77
82493: PUSH
82494: LD_VAR 0 4
82498: ARRAY
82499: PUSH
82500: LD_VAR 0 1
82504: DIFF
82505: PPUSH
82506: CALL_OW 1
82510: ST_TO_ADDR
// for i = 1 to mc_bases do
82511: LD_ADDR_VAR 0 5
82515: PUSH
82516: DOUBLE
82517: LD_INT 1
82519: DEC
82520: ST_TO_ADDR
82521: LD_EXP 50
82525: PUSH
82526: FOR_TO
82527: IFFALSE 82705
// begin if lab in mc_bases [ i ] then
82529: LD_VAR 0 2
82533: PUSH
82534: LD_EXP 50
82538: PUSH
82539: LD_VAR 0 5
82543: ARRAY
82544: IN
82545: IFFALSE 82703
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82547: LD_VAR 0 1
82551: PUSH
82552: LD_INT 11
82554: PUSH
82555: LD_INT 4
82557: PUSH
82558: LD_INT 3
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: IN
82570: PUSH
82571: LD_EXP 80
82575: PUSH
82576: LD_VAR 0 5
82580: ARRAY
82581: AND
82582: IFFALSE 82703
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82584: LD_ADDR_VAR 0 6
82588: PUSH
82589: LD_EXP 80
82593: PUSH
82594: LD_VAR 0 5
82598: ARRAY
82599: PUSH
82600: LD_INT 1
82602: ARRAY
82603: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82604: LD_ADDR_EXP 80
82608: PUSH
82609: LD_EXP 80
82613: PPUSH
82614: LD_VAR 0 5
82618: PPUSH
82619: EMPTY
82620: PPUSH
82621: CALL_OW 1
82625: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82626: LD_VAR 0 6
82630: PPUSH
82631: LD_INT 0
82633: PPUSH
82634: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82638: LD_VAR 0 6
82642: PPUSH
82643: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82647: LD_ADDR_EXP 79
82651: PUSH
82652: LD_EXP 79
82656: PPUSH
82657: LD_VAR 0 5
82661: PPUSH
82662: LD_EXP 79
82666: PUSH
82667: LD_VAR 0 5
82671: ARRAY
82672: PPUSH
82673: LD_INT 1
82675: PPUSH
82676: LD_VAR 0 6
82680: PPUSH
82681: CALL_OW 2
82685: PPUSH
82686: CALL_OW 1
82690: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82691: LD_VAR 0 5
82695: PPUSH
82696: LD_INT 112
82698: PPUSH
82699: CALL 59193 0 2
// end ; end ; end ;
82703: GO 82526
82705: POP
82706: POP
// end ;
82707: LD_VAR 0 3
82711: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82712: LD_INT 0
82714: PPUSH
82715: PPUSH
82716: PPUSH
82717: PPUSH
82718: PPUSH
82719: PPUSH
82720: PPUSH
82721: PPUSH
// if not mc_bases or not skirmish then
82722: LD_EXP 50
82726: NOT
82727: PUSH
82728: LD_EXP 48
82732: NOT
82733: OR
82734: IFFALSE 82738
// exit ;
82736: GO 84107
// for i = 1 to mc_bases do
82738: LD_ADDR_VAR 0 3
82742: PUSH
82743: DOUBLE
82744: LD_INT 1
82746: DEC
82747: ST_TO_ADDR
82748: LD_EXP 50
82752: PUSH
82753: FOR_TO
82754: IFFALSE 84105
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82756: LD_VAR 0 1
82760: PUSH
82761: LD_EXP 50
82765: PUSH
82766: LD_VAR 0 3
82770: ARRAY
82771: IN
82772: PUSH
82773: LD_VAR 0 1
82777: PUSH
82778: LD_EXP 57
82782: PUSH
82783: LD_VAR 0 3
82787: ARRAY
82788: IN
82789: OR
82790: PUSH
82791: LD_VAR 0 1
82795: PUSH
82796: LD_EXP 72
82800: PUSH
82801: LD_VAR 0 3
82805: ARRAY
82806: IN
82807: OR
82808: PUSH
82809: LD_VAR 0 1
82813: PUSH
82814: LD_EXP 69
82818: PUSH
82819: LD_VAR 0 3
82823: ARRAY
82824: IN
82825: OR
82826: PUSH
82827: LD_VAR 0 1
82831: PUSH
82832: LD_EXP 79
82836: PUSH
82837: LD_VAR 0 3
82841: ARRAY
82842: IN
82843: OR
82844: PUSH
82845: LD_VAR 0 1
82849: PUSH
82850: LD_EXP 80
82854: PUSH
82855: LD_VAR 0 3
82859: ARRAY
82860: IN
82861: OR
82862: IFFALSE 84103
// begin if un in mc_ape [ i ] then
82864: LD_VAR 0 1
82868: PUSH
82869: LD_EXP 79
82873: PUSH
82874: LD_VAR 0 3
82878: ARRAY
82879: IN
82880: IFFALSE 82919
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82882: LD_ADDR_EXP 79
82886: PUSH
82887: LD_EXP 79
82891: PPUSH
82892: LD_VAR 0 3
82896: PPUSH
82897: LD_EXP 79
82901: PUSH
82902: LD_VAR 0 3
82906: ARRAY
82907: PUSH
82908: LD_VAR 0 1
82912: DIFF
82913: PPUSH
82914: CALL_OW 1
82918: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82919: LD_VAR 0 1
82923: PUSH
82924: LD_EXP 80
82928: PUSH
82929: LD_VAR 0 3
82933: ARRAY
82934: IN
82935: IFFALSE 82959
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82937: LD_ADDR_EXP 80
82941: PUSH
82942: LD_EXP 80
82946: PPUSH
82947: LD_VAR 0 3
82951: PPUSH
82952: EMPTY
82953: PPUSH
82954: CALL_OW 1
82958: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82959: LD_VAR 0 1
82963: PPUSH
82964: CALL_OW 247
82968: PUSH
82969: LD_INT 2
82971: EQUAL
82972: PUSH
82973: LD_VAR 0 1
82977: PPUSH
82978: CALL_OW 110
82982: PUSH
82983: LD_INT 20
82985: EQUAL
82986: PUSH
82987: LD_VAR 0 1
82991: PUSH
82992: LD_EXP 72
82996: PUSH
82997: LD_VAR 0 3
83001: ARRAY
83002: IN
83003: OR
83004: PUSH
83005: LD_VAR 0 1
83009: PPUSH
83010: CALL_OW 264
83014: PUSH
83015: LD_INT 12
83017: PUSH
83018: LD_INT 51
83020: PUSH
83021: LD_INT 89
83023: PUSH
83024: LD_INT 32
83026: PUSH
83027: LD_INT 13
83029: PUSH
83030: LD_INT 52
83032: PUSH
83033: LD_INT 31
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: IN
83045: OR
83046: AND
83047: IFFALSE 83355
// begin if un in mc_defender [ i ] then
83049: LD_VAR 0 1
83053: PUSH
83054: LD_EXP 72
83058: PUSH
83059: LD_VAR 0 3
83063: ARRAY
83064: IN
83065: IFFALSE 83104
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83067: LD_ADDR_EXP 72
83071: PUSH
83072: LD_EXP 72
83076: PPUSH
83077: LD_VAR 0 3
83081: PPUSH
83082: LD_EXP 72
83086: PUSH
83087: LD_VAR 0 3
83091: ARRAY
83092: PUSH
83093: LD_VAR 0 1
83097: DIFF
83098: PPUSH
83099: CALL_OW 1
83103: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83104: LD_ADDR_VAR 0 8
83108: PUSH
83109: LD_VAR 0 3
83113: PPUSH
83114: LD_INT 3
83116: PPUSH
83117: CALL 79763 0 2
83121: ST_TO_ADDR
// if fac then
83122: LD_VAR 0 8
83126: IFFALSE 83355
// begin for j in fac do
83128: LD_ADDR_VAR 0 4
83132: PUSH
83133: LD_VAR 0 8
83137: PUSH
83138: FOR_IN
83139: IFFALSE 83353
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83141: LD_ADDR_VAR 0 9
83145: PUSH
83146: LD_VAR 0 8
83150: PPUSH
83151: LD_VAR 0 1
83155: PPUSH
83156: CALL_OW 265
83160: PPUSH
83161: LD_VAR 0 1
83165: PPUSH
83166: CALL_OW 262
83170: PPUSH
83171: LD_VAR 0 1
83175: PPUSH
83176: CALL_OW 263
83180: PPUSH
83181: LD_VAR 0 1
83185: PPUSH
83186: CALL_OW 264
83190: PPUSH
83191: CALL 16246 0 5
83195: ST_TO_ADDR
// if components then
83196: LD_VAR 0 9
83200: IFFALSE 83351
// begin if GetWeapon ( un ) = ar_control_tower then
83202: LD_VAR 0 1
83206: PPUSH
83207: CALL_OW 264
83211: PUSH
83212: LD_INT 31
83214: EQUAL
83215: IFFALSE 83332
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83217: LD_VAR 0 1
83221: PPUSH
83222: CALL_OW 311
83226: PPUSH
83227: LD_INT 0
83229: PPUSH
83230: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83234: LD_ADDR_EXP 90
83238: PUSH
83239: LD_EXP 90
83243: PPUSH
83244: LD_VAR 0 3
83248: PPUSH
83249: LD_EXP 90
83253: PUSH
83254: LD_VAR 0 3
83258: ARRAY
83259: PUSH
83260: LD_VAR 0 1
83264: PPUSH
83265: CALL_OW 311
83269: DIFF
83270: PPUSH
83271: CALL_OW 1
83275: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83276: LD_ADDR_VAR 0 7
83280: PUSH
83281: LD_EXP 71
83285: PUSH
83286: LD_VAR 0 3
83290: ARRAY
83291: PPUSH
83292: LD_INT 1
83294: PPUSH
83295: LD_VAR 0 9
83299: PPUSH
83300: CALL_OW 2
83304: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83305: LD_ADDR_EXP 71
83309: PUSH
83310: LD_EXP 71
83314: PPUSH
83315: LD_VAR 0 3
83319: PPUSH
83320: LD_VAR 0 7
83324: PPUSH
83325: CALL_OW 1
83329: ST_TO_ADDR
// end else
83330: GO 83349
// MC_InsertProduceList ( i , [ components ] ) ;
83332: LD_VAR 0 3
83336: PPUSH
83337: LD_VAR 0 9
83341: PUSH
83342: EMPTY
83343: LIST
83344: PPUSH
83345: CALL 79308 0 2
// break ;
83349: GO 83353
// end ; end ;
83351: GO 83138
83353: POP
83354: POP
// end ; end ; if GetType ( un ) = unit_building then
83355: LD_VAR 0 1
83359: PPUSH
83360: CALL_OW 247
83364: PUSH
83365: LD_INT 3
83367: EQUAL
83368: IFFALSE 83771
// begin btype := GetBType ( un ) ;
83370: LD_ADDR_VAR 0 5
83374: PUSH
83375: LD_VAR 0 1
83379: PPUSH
83380: CALL_OW 266
83384: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83385: LD_VAR 0 5
83389: PUSH
83390: LD_INT 29
83392: PUSH
83393: LD_INT 30
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: IN
83400: IFFALSE 83473
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83402: LD_VAR 0 1
83406: PPUSH
83407: CALL_OW 250
83411: PPUSH
83412: LD_VAR 0 1
83416: PPUSH
83417: CALL_OW 251
83421: PPUSH
83422: LD_VAR 0 1
83426: PPUSH
83427: CALL_OW 255
83431: PPUSH
83432: CALL_OW 440
83436: NOT
83437: IFFALSE 83473
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83439: LD_VAR 0 1
83443: PPUSH
83444: CALL_OW 250
83448: PPUSH
83449: LD_VAR 0 1
83453: PPUSH
83454: CALL_OW 251
83458: PPUSH
83459: LD_VAR 0 1
83463: PPUSH
83464: CALL_OW 255
83468: PPUSH
83469: CALL_OW 441
// end ; if btype = b_warehouse then
83473: LD_VAR 0 5
83477: PUSH
83478: LD_INT 1
83480: EQUAL
83481: IFFALSE 83499
// begin btype := b_depot ;
83483: LD_ADDR_VAR 0 5
83487: PUSH
83488: LD_INT 0
83490: ST_TO_ADDR
// pos := 1 ;
83491: LD_ADDR_VAR 0 6
83495: PUSH
83496: LD_INT 1
83498: ST_TO_ADDR
// end ; if btype = b_factory then
83499: LD_VAR 0 5
83503: PUSH
83504: LD_INT 3
83506: EQUAL
83507: IFFALSE 83525
// begin btype := b_workshop ;
83509: LD_ADDR_VAR 0 5
83513: PUSH
83514: LD_INT 2
83516: ST_TO_ADDR
// pos := 1 ;
83517: LD_ADDR_VAR 0 6
83521: PUSH
83522: LD_INT 1
83524: ST_TO_ADDR
// end ; if btype = b_barracks then
83525: LD_VAR 0 5
83529: PUSH
83530: LD_INT 5
83532: EQUAL
83533: IFFALSE 83543
// btype := b_armoury ;
83535: LD_ADDR_VAR 0 5
83539: PUSH
83540: LD_INT 4
83542: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83543: LD_VAR 0 5
83547: PUSH
83548: LD_INT 7
83550: PUSH
83551: LD_INT 8
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: IN
83558: IFFALSE 83568
// btype := b_lab ;
83560: LD_ADDR_VAR 0 5
83564: PUSH
83565: LD_INT 6
83567: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83568: LD_ADDR_EXP 55
83572: PUSH
83573: LD_EXP 55
83577: PPUSH
83578: LD_VAR 0 3
83582: PUSH
83583: LD_EXP 55
83587: PUSH
83588: LD_VAR 0 3
83592: ARRAY
83593: PUSH
83594: LD_INT 1
83596: PLUS
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PPUSH
83602: LD_VAR 0 5
83606: PUSH
83607: LD_VAR 0 1
83611: PPUSH
83612: CALL_OW 250
83616: PUSH
83617: LD_VAR 0 1
83621: PPUSH
83622: CALL_OW 251
83626: PUSH
83627: LD_VAR 0 1
83631: PPUSH
83632: CALL_OW 254
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: PPUSH
83643: CALL 18748 0 3
83647: ST_TO_ADDR
// if pos = 1 then
83648: LD_VAR 0 6
83652: PUSH
83653: LD_INT 1
83655: EQUAL
83656: IFFALSE 83771
// begin tmp := mc_build_list [ i ] ;
83658: LD_ADDR_VAR 0 7
83662: PUSH
83663: LD_EXP 55
83667: PUSH
83668: LD_VAR 0 3
83672: ARRAY
83673: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83674: LD_VAR 0 7
83678: PPUSH
83679: LD_INT 2
83681: PUSH
83682: LD_INT 30
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 30
83694: PUSH
83695: LD_INT 1
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: LIST
83706: PPUSH
83707: CALL_OW 72
83711: IFFALSE 83721
// pos := 2 ;
83713: LD_ADDR_VAR 0 6
83717: PUSH
83718: LD_INT 2
83720: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83721: LD_ADDR_VAR 0 7
83725: PUSH
83726: LD_VAR 0 7
83730: PPUSH
83731: LD_VAR 0 6
83735: PPUSH
83736: LD_VAR 0 7
83740: PPUSH
83741: CALL 19074 0 3
83745: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83746: LD_ADDR_EXP 55
83750: PUSH
83751: LD_EXP 55
83755: PPUSH
83756: LD_VAR 0 3
83760: PPUSH
83761: LD_VAR 0 7
83765: PPUSH
83766: CALL_OW 1
83770: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83771: LD_VAR 0 1
83775: PUSH
83776: LD_EXP 50
83780: PUSH
83781: LD_VAR 0 3
83785: ARRAY
83786: IN
83787: IFFALSE 83826
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83789: LD_ADDR_EXP 50
83793: PUSH
83794: LD_EXP 50
83798: PPUSH
83799: LD_VAR 0 3
83803: PPUSH
83804: LD_EXP 50
83808: PUSH
83809: LD_VAR 0 3
83813: ARRAY
83814: PUSH
83815: LD_VAR 0 1
83819: DIFF
83820: PPUSH
83821: CALL_OW 1
83825: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83826: LD_VAR 0 1
83830: PUSH
83831: LD_EXP 57
83835: PUSH
83836: LD_VAR 0 3
83840: ARRAY
83841: IN
83842: IFFALSE 83881
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83844: LD_ADDR_EXP 57
83848: PUSH
83849: LD_EXP 57
83853: PPUSH
83854: LD_VAR 0 3
83858: PPUSH
83859: LD_EXP 57
83863: PUSH
83864: LD_VAR 0 3
83868: ARRAY
83869: PUSH
83870: LD_VAR 0 1
83874: DIFF
83875: PPUSH
83876: CALL_OW 1
83880: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83881: LD_VAR 0 1
83885: PUSH
83886: LD_EXP 69
83890: PUSH
83891: LD_VAR 0 3
83895: ARRAY
83896: IN
83897: IFFALSE 83936
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83899: LD_ADDR_EXP 69
83903: PUSH
83904: LD_EXP 69
83908: PPUSH
83909: LD_VAR 0 3
83913: PPUSH
83914: LD_EXP 69
83918: PUSH
83919: LD_VAR 0 3
83923: ARRAY
83924: PUSH
83925: LD_VAR 0 1
83929: DIFF
83930: PPUSH
83931: CALL_OW 1
83935: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83936: LD_VAR 0 1
83940: PUSH
83941: LD_EXP 72
83945: PUSH
83946: LD_VAR 0 3
83950: ARRAY
83951: IN
83952: IFFALSE 83991
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83954: LD_ADDR_EXP 72
83958: PUSH
83959: LD_EXP 72
83963: PPUSH
83964: LD_VAR 0 3
83968: PPUSH
83969: LD_EXP 72
83973: PUSH
83974: LD_VAR 0 3
83978: ARRAY
83979: PUSH
83980: LD_VAR 0 1
83984: DIFF
83985: PPUSH
83986: CALL_OW 1
83990: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83991: LD_VAR 0 1
83995: PUSH
83996: LD_EXP 59
84000: PUSH
84001: LD_VAR 0 3
84005: ARRAY
84006: IN
84007: IFFALSE 84046
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84009: LD_ADDR_EXP 59
84013: PUSH
84014: LD_EXP 59
84018: PPUSH
84019: LD_VAR 0 3
84023: PPUSH
84024: LD_EXP 59
84028: PUSH
84029: LD_VAR 0 3
84033: ARRAY
84034: PUSH
84035: LD_VAR 0 1
84039: DIFF
84040: PPUSH
84041: CALL_OW 1
84045: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84046: LD_VAR 0 1
84050: PUSH
84051: LD_EXP 58
84055: PUSH
84056: LD_VAR 0 3
84060: ARRAY
84061: IN
84062: IFFALSE 84101
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84064: LD_ADDR_EXP 58
84068: PUSH
84069: LD_EXP 58
84073: PPUSH
84074: LD_VAR 0 3
84078: PPUSH
84079: LD_EXP 58
84083: PUSH
84084: LD_VAR 0 3
84088: ARRAY
84089: PUSH
84090: LD_VAR 0 1
84094: DIFF
84095: PPUSH
84096: CALL_OW 1
84100: ST_TO_ADDR
// end ; break ;
84101: GO 84105
// end ;
84103: GO 82753
84105: POP
84106: POP
// end ;
84107: LD_VAR 0 2
84111: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84112: LD_INT 0
84114: PPUSH
84115: PPUSH
84116: PPUSH
// if not mc_bases or not skirmish then
84117: LD_EXP 50
84121: NOT
84122: PUSH
84123: LD_EXP 48
84127: NOT
84128: OR
84129: IFFALSE 84133
// exit ;
84131: GO 84348
// for i = 1 to mc_bases do
84133: LD_ADDR_VAR 0 3
84137: PUSH
84138: DOUBLE
84139: LD_INT 1
84141: DEC
84142: ST_TO_ADDR
84143: LD_EXP 50
84147: PUSH
84148: FOR_TO
84149: IFFALSE 84346
// begin if building in mc_construct_list [ i ] then
84151: LD_VAR 0 1
84155: PUSH
84156: LD_EXP 57
84160: PUSH
84161: LD_VAR 0 3
84165: ARRAY
84166: IN
84167: IFFALSE 84344
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84169: LD_ADDR_EXP 57
84173: PUSH
84174: LD_EXP 57
84178: PPUSH
84179: LD_VAR 0 3
84183: PPUSH
84184: LD_EXP 57
84188: PUSH
84189: LD_VAR 0 3
84193: ARRAY
84194: PUSH
84195: LD_VAR 0 1
84199: DIFF
84200: PPUSH
84201: CALL_OW 1
84205: ST_TO_ADDR
// if building in mc_lab [ i ] then
84206: LD_VAR 0 1
84210: PUSH
84211: LD_EXP 83
84215: PUSH
84216: LD_VAR 0 3
84220: ARRAY
84221: IN
84222: IFFALSE 84277
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84224: LD_ADDR_EXP 84
84228: PUSH
84229: LD_EXP 84
84233: PPUSH
84234: LD_VAR 0 3
84238: PPUSH
84239: LD_EXP 84
84243: PUSH
84244: LD_VAR 0 3
84248: ARRAY
84249: PPUSH
84250: LD_INT 1
84252: PPUSH
84253: LD_EXP 84
84257: PUSH
84258: LD_VAR 0 3
84262: ARRAY
84263: PPUSH
84264: LD_INT 0
84266: PPUSH
84267: CALL 18166 0 4
84271: PPUSH
84272: CALL_OW 1
84276: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84277: LD_VAR 0 1
84281: PUSH
84282: LD_EXP 50
84286: PUSH
84287: LD_VAR 0 3
84291: ARRAY
84292: IN
84293: NOT
84294: IFFALSE 84340
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84296: LD_ADDR_EXP 50
84300: PUSH
84301: LD_EXP 50
84305: PPUSH
84306: LD_VAR 0 3
84310: PUSH
84311: LD_EXP 50
84315: PUSH
84316: LD_VAR 0 3
84320: ARRAY
84321: PUSH
84322: LD_INT 1
84324: PLUS
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PPUSH
84330: LD_VAR 0 1
84334: PPUSH
84335: CALL 18748 0 3
84339: ST_TO_ADDR
// exit ;
84340: POP
84341: POP
84342: GO 84348
// end ; end ;
84344: GO 84148
84346: POP
84347: POP
// end ;
84348: LD_VAR 0 2
84352: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84353: LD_INT 0
84355: PPUSH
84356: PPUSH
84357: PPUSH
84358: PPUSH
84359: PPUSH
84360: PPUSH
84361: PPUSH
// if not mc_bases or not skirmish then
84362: LD_EXP 50
84366: NOT
84367: PUSH
84368: LD_EXP 48
84372: NOT
84373: OR
84374: IFFALSE 84378
// exit ;
84376: GO 85039
// for i = 1 to mc_bases do
84378: LD_ADDR_VAR 0 3
84382: PUSH
84383: DOUBLE
84384: LD_INT 1
84386: DEC
84387: ST_TO_ADDR
84388: LD_EXP 50
84392: PUSH
84393: FOR_TO
84394: IFFALSE 85037
// begin if building in mc_construct_list [ i ] then
84396: LD_VAR 0 1
84400: PUSH
84401: LD_EXP 57
84405: PUSH
84406: LD_VAR 0 3
84410: ARRAY
84411: IN
84412: IFFALSE 85035
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84414: LD_ADDR_EXP 57
84418: PUSH
84419: LD_EXP 57
84423: PPUSH
84424: LD_VAR 0 3
84428: PPUSH
84429: LD_EXP 57
84433: PUSH
84434: LD_VAR 0 3
84438: ARRAY
84439: PUSH
84440: LD_VAR 0 1
84444: DIFF
84445: PPUSH
84446: CALL_OW 1
84450: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84451: LD_ADDR_EXP 50
84455: PUSH
84456: LD_EXP 50
84460: PPUSH
84461: LD_VAR 0 3
84465: PUSH
84466: LD_EXP 50
84470: PUSH
84471: LD_VAR 0 3
84475: ARRAY
84476: PUSH
84477: LD_INT 1
84479: PLUS
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PPUSH
84485: LD_VAR 0 1
84489: PPUSH
84490: CALL 18748 0 3
84494: ST_TO_ADDR
// btype := GetBType ( building ) ;
84495: LD_ADDR_VAR 0 5
84499: PUSH
84500: LD_VAR 0 1
84504: PPUSH
84505: CALL_OW 266
84509: ST_TO_ADDR
// side := GetSide ( building ) ;
84510: LD_ADDR_VAR 0 8
84514: PUSH
84515: LD_VAR 0 1
84519: PPUSH
84520: CALL_OW 255
84524: ST_TO_ADDR
// if btype = b_lab then
84525: LD_VAR 0 5
84529: PUSH
84530: LD_INT 6
84532: EQUAL
84533: IFFALSE 84583
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84535: LD_ADDR_EXP 83
84539: PUSH
84540: LD_EXP 83
84544: PPUSH
84545: LD_VAR 0 3
84549: PUSH
84550: LD_EXP 83
84554: PUSH
84555: LD_VAR 0 3
84559: ARRAY
84560: PUSH
84561: LD_INT 1
84563: PLUS
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PPUSH
84569: LD_VAR 0 1
84573: PPUSH
84574: CALL 18748 0 3
84578: ST_TO_ADDR
// exit ;
84579: POP
84580: POP
84581: GO 85039
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84583: LD_VAR 0 5
84587: PUSH
84588: LD_INT 0
84590: PUSH
84591: LD_INT 2
84593: PUSH
84594: LD_INT 4
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: LIST
84601: IN
84602: IFFALSE 84726
// begin if btype = b_armoury then
84604: LD_VAR 0 5
84608: PUSH
84609: LD_INT 4
84611: EQUAL
84612: IFFALSE 84622
// btype := b_barracks ;
84614: LD_ADDR_VAR 0 5
84618: PUSH
84619: LD_INT 5
84621: ST_TO_ADDR
// if btype = b_depot then
84622: LD_VAR 0 5
84626: PUSH
84627: LD_INT 0
84629: EQUAL
84630: IFFALSE 84640
// btype := b_warehouse ;
84632: LD_ADDR_VAR 0 5
84636: PUSH
84637: LD_INT 1
84639: ST_TO_ADDR
// if btype = b_workshop then
84640: LD_VAR 0 5
84644: PUSH
84645: LD_INT 2
84647: EQUAL
84648: IFFALSE 84658
// btype := b_factory ;
84650: LD_ADDR_VAR 0 5
84654: PUSH
84655: LD_INT 3
84657: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84658: LD_VAR 0 5
84662: PPUSH
84663: LD_VAR 0 8
84667: PPUSH
84668: CALL_OW 323
84672: PUSH
84673: LD_INT 1
84675: EQUAL
84676: IFFALSE 84722
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84678: LD_ADDR_EXP 82
84682: PUSH
84683: LD_EXP 82
84687: PPUSH
84688: LD_VAR 0 3
84692: PUSH
84693: LD_EXP 82
84697: PUSH
84698: LD_VAR 0 3
84702: ARRAY
84703: PUSH
84704: LD_INT 1
84706: PLUS
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PPUSH
84712: LD_VAR 0 1
84716: PPUSH
84717: CALL 18748 0 3
84721: ST_TO_ADDR
// exit ;
84722: POP
84723: POP
84724: GO 85039
// end ; if btype in [ b_bunker , b_turret ] then
84726: LD_VAR 0 5
84730: PUSH
84731: LD_INT 32
84733: PUSH
84734: LD_INT 33
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: IN
84741: IFFALSE 85031
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84743: LD_ADDR_EXP 58
84747: PUSH
84748: LD_EXP 58
84752: PPUSH
84753: LD_VAR 0 3
84757: PUSH
84758: LD_EXP 58
84762: PUSH
84763: LD_VAR 0 3
84767: ARRAY
84768: PUSH
84769: LD_INT 1
84771: PLUS
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: PPUSH
84777: LD_VAR 0 1
84781: PPUSH
84782: CALL 18748 0 3
84786: ST_TO_ADDR
// if btype = b_bunker then
84787: LD_VAR 0 5
84791: PUSH
84792: LD_INT 32
84794: EQUAL
84795: IFFALSE 85031
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84797: LD_ADDR_EXP 59
84801: PUSH
84802: LD_EXP 59
84806: PPUSH
84807: LD_VAR 0 3
84811: PUSH
84812: LD_EXP 59
84816: PUSH
84817: LD_VAR 0 3
84821: ARRAY
84822: PUSH
84823: LD_INT 1
84825: PLUS
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PPUSH
84831: LD_VAR 0 1
84835: PPUSH
84836: CALL 18748 0 3
84840: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84841: LD_ADDR_VAR 0 6
84845: PUSH
84846: LD_EXP 50
84850: PUSH
84851: LD_VAR 0 3
84855: ARRAY
84856: PPUSH
84857: LD_INT 25
84859: PUSH
84860: LD_INT 1
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 3
84869: PUSH
84870: LD_INT 54
84872: PUSH
84873: EMPTY
84874: LIST
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PPUSH
84884: CALL_OW 72
84888: ST_TO_ADDR
// if tmp then
84889: LD_VAR 0 6
84893: IFFALSE 84899
// exit ;
84895: POP
84896: POP
84897: GO 85039
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84899: LD_ADDR_VAR 0 6
84903: PUSH
84904: LD_EXP 50
84908: PUSH
84909: LD_VAR 0 3
84913: ARRAY
84914: PPUSH
84915: LD_INT 2
84917: PUSH
84918: LD_INT 30
84920: PUSH
84921: LD_INT 4
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 30
84930: PUSH
84931: LD_INT 5
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: LIST
84942: PPUSH
84943: CALL_OW 72
84947: ST_TO_ADDR
// if not tmp then
84948: LD_VAR 0 6
84952: NOT
84953: IFFALSE 84959
// exit ;
84955: POP
84956: POP
84957: GO 85039
// for j in tmp do
84959: LD_ADDR_VAR 0 4
84963: PUSH
84964: LD_VAR 0 6
84968: PUSH
84969: FOR_IN
84970: IFFALSE 85029
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84972: LD_ADDR_VAR 0 7
84976: PUSH
84977: LD_VAR 0 4
84981: PPUSH
84982: CALL_OW 313
84986: PPUSH
84987: LD_INT 25
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PPUSH
84997: CALL_OW 72
85001: ST_TO_ADDR
// if units then
85002: LD_VAR 0 7
85006: IFFALSE 85027
// begin ComExitBuilding ( units [ 1 ] ) ;
85008: LD_VAR 0 7
85012: PUSH
85013: LD_INT 1
85015: ARRAY
85016: PPUSH
85017: CALL_OW 122
// exit ;
85021: POP
85022: POP
85023: POP
85024: POP
85025: GO 85039
// end ; end ;
85027: GO 84969
85029: POP
85030: POP
// end ; end ; exit ;
85031: POP
85032: POP
85033: GO 85039
// end ; end ;
85035: GO 84393
85037: POP
85038: POP
// end ;
85039: LD_VAR 0 2
85043: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85044: LD_INT 0
85046: PPUSH
85047: PPUSH
85048: PPUSH
85049: PPUSH
85050: PPUSH
85051: PPUSH
85052: PPUSH
// if not mc_bases or not skirmish then
85053: LD_EXP 50
85057: NOT
85058: PUSH
85059: LD_EXP 48
85063: NOT
85064: OR
85065: IFFALSE 85069
// exit ;
85067: GO 85334
// btype := GetBType ( building ) ;
85069: LD_ADDR_VAR 0 6
85073: PUSH
85074: LD_VAR 0 1
85078: PPUSH
85079: CALL_OW 266
85083: ST_TO_ADDR
// x := GetX ( building ) ;
85084: LD_ADDR_VAR 0 7
85088: PUSH
85089: LD_VAR 0 1
85093: PPUSH
85094: CALL_OW 250
85098: ST_TO_ADDR
// y := GetY ( building ) ;
85099: LD_ADDR_VAR 0 8
85103: PUSH
85104: LD_VAR 0 1
85108: PPUSH
85109: CALL_OW 251
85113: ST_TO_ADDR
// d := GetDir ( building ) ;
85114: LD_ADDR_VAR 0 9
85118: PUSH
85119: LD_VAR 0 1
85123: PPUSH
85124: CALL_OW 254
85128: ST_TO_ADDR
// for i = 1 to mc_bases do
85129: LD_ADDR_VAR 0 4
85133: PUSH
85134: DOUBLE
85135: LD_INT 1
85137: DEC
85138: ST_TO_ADDR
85139: LD_EXP 50
85143: PUSH
85144: FOR_TO
85145: IFFALSE 85332
// begin if not mc_build_list [ i ] then
85147: LD_EXP 55
85151: PUSH
85152: LD_VAR 0 4
85156: ARRAY
85157: NOT
85158: IFFALSE 85162
// continue ;
85160: GO 85144
// for j := 1 to mc_build_list [ i ] do
85162: LD_ADDR_VAR 0 5
85166: PUSH
85167: DOUBLE
85168: LD_INT 1
85170: DEC
85171: ST_TO_ADDR
85172: LD_EXP 55
85176: PUSH
85177: LD_VAR 0 4
85181: ARRAY
85182: PUSH
85183: FOR_TO
85184: IFFALSE 85328
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85186: LD_VAR 0 6
85190: PUSH
85191: LD_VAR 0 7
85195: PUSH
85196: LD_VAR 0 8
85200: PUSH
85201: LD_VAR 0 9
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: PPUSH
85212: LD_EXP 55
85216: PUSH
85217: LD_VAR 0 4
85221: ARRAY
85222: PUSH
85223: LD_VAR 0 5
85227: ARRAY
85228: PPUSH
85229: CALL 24928 0 2
85233: IFFALSE 85326
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85235: LD_ADDR_EXP 55
85239: PUSH
85240: LD_EXP 55
85244: PPUSH
85245: LD_VAR 0 4
85249: PPUSH
85250: LD_EXP 55
85254: PUSH
85255: LD_VAR 0 4
85259: ARRAY
85260: PPUSH
85261: LD_VAR 0 5
85265: PPUSH
85266: CALL_OW 3
85270: PPUSH
85271: CALL_OW 1
85275: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85276: LD_ADDR_EXP 57
85280: PUSH
85281: LD_EXP 57
85285: PPUSH
85286: LD_VAR 0 4
85290: PUSH
85291: LD_EXP 57
85295: PUSH
85296: LD_VAR 0 4
85300: ARRAY
85301: PUSH
85302: LD_INT 1
85304: PLUS
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PPUSH
85310: LD_VAR 0 1
85314: PPUSH
85315: CALL 18748 0 3
85319: ST_TO_ADDR
// exit ;
85320: POP
85321: POP
85322: POP
85323: POP
85324: GO 85334
// end ;
85326: GO 85183
85328: POP
85329: POP
// end ;
85330: GO 85144
85332: POP
85333: POP
// end ;
85334: LD_VAR 0 3
85338: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85339: LD_INT 0
85341: PPUSH
85342: PPUSH
85343: PPUSH
// if not mc_bases or not skirmish then
85344: LD_EXP 50
85348: NOT
85349: PUSH
85350: LD_EXP 48
85354: NOT
85355: OR
85356: IFFALSE 85360
// exit ;
85358: GO 85550
// for i = 1 to mc_bases do
85360: LD_ADDR_VAR 0 4
85364: PUSH
85365: DOUBLE
85366: LD_INT 1
85368: DEC
85369: ST_TO_ADDR
85370: LD_EXP 50
85374: PUSH
85375: FOR_TO
85376: IFFALSE 85463
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85378: LD_VAR 0 1
85382: PUSH
85383: LD_EXP 58
85387: PUSH
85388: LD_VAR 0 4
85392: ARRAY
85393: IN
85394: PUSH
85395: LD_VAR 0 1
85399: PUSH
85400: LD_EXP 59
85404: PUSH
85405: LD_VAR 0 4
85409: ARRAY
85410: IN
85411: NOT
85412: AND
85413: IFFALSE 85461
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85415: LD_ADDR_EXP 59
85419: PUSH
85420: LD_EXP 59
85424: PPUSH
85425: LD_VAR 0 4
85429: PUSH
85430: LD_EXP 59
85434: PUSH
85435: LD_VAR 0 4
85439: ARRAY
85440: PUSH
85441: LD_INT 1
85443: PLUS
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PPUSH
85449: LD_VAR 0 1
85453: PPUSH
85454: CALL 18748 0 3
85458: ST_TO_ADDR
// break ;
85459: GO 85463
// end ; end ;
85461: GO 85375
85463: POP
85464: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85465: LD_VAR 0 1
85469: PPUSH
85470: CALL_OW 257
85474: PUSH
85475: LD_EXP 76
85479: IN
85480: PUSH
85481: LD_VAR 0 1
85485: PPUSH
85486: CALL_OW 266
85490: PUSH
85491: LD_INT 5
85493: EQUAL
85494: AND
85495: PUSH
85496: LD_VAR 0 2
85500: PPUSH
85501: CALL_OW 110
85505: PUSH
85506: LD_INT 18
85508: NONEQUAL
85509: AND
85510: IFFALSE 85550
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85512: LD_VAR 0 2
85516: PPUSH
85517: CALL_OW 257
85521: PUSH
85522: LD_INT 5
85524: PUSH
85525: LD_INT 8
85527: PUSH
85528: LD_INT 9
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: LIST
85535: IN
85536: IFFALSE 85550
// SetClass ( unit , 1 ) ;
85538: LD_VAR 0 2
85542: PPUSH
85543: LD_INT 1
85545: PPUSH
85546: CALL_OW 336
// end ;
85550: LD_VAR 0 3
85554: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85555: LD_INT 0
85557: PPUSH
85558: PPUSH
// if not mc_bases or not skirmish then
85559: LD_EXP 50
85563: NOT
85564: PUSH
85565: LD_EXP 48
85569: NOT
85570: OR
85571: IFFALSE 85575
// exit ;
85573: GO 85691
// if GetLives ( abandoned_vehicle ) > 250 then
85575: LD_VAR 0 2
85579: PPUSH
85580: CALL_OW 256
85584: PUSH
85585: LD_INT 250
85587: GREATER
85588: IFFALSE 85592
// exit ;
85590: GO 85691
// for i = 1 to mc_bases do
85592: LD_ADDR_VAR 0 6
85596: PUSH
85597: DOUBLE
85598: LD_INT 1
85600: DEC
85601: ST_TO_ADDR
85602: LD_EXP 50
85606: PUSH
85607: FOR_TO
85608: IFFALSE 85689
// begin if driver in mc_bases [ i ] then
85610: LD_VAR 0 1
85614: PUSH
85615: LD_EXP 50
85619: PUSH
85620: LD_VAR 0 6
85624: ARRAY
85625: IN
85626: IFFALSE 85687
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85628: LD_VAR 0 1
85632: PPUSH
85633: LD_EXP 50
85637: PUSH
85638: LD_VAR 0 6
85642: ARRAY
85643: PPUSH
85644: LD_INT 2
85646: PUSH
85647: LD_INT 30
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 30
85659: PUSH
85660: LD_INT 1
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: LIST
85671: PPUSH
85672: CALL_OW 72
85676: PUSH
85677: LD_INT 1
85679: ARRAY
85680: PPUSH
85681: CALL 51956 0 2
// break ;
85685: GO 85689
// end ; end ;
85687: GO 85607
85689: POP
85690: POP
// end ; end_of_file end_of_file
85691: LD_VAR 0 5
85695: RET
// export globalGameSaveCounter ; every 0 0$1 do
85696: GO 85698
85698: DISABLE
// begin enable ;
85699: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85700: LD_STRING updateTimer(
85702: PUSH
85703: LD_OWVAR 1
85707: STR
85708: PUSH
85709: LD_STRING );
85711: STR
85712: PPUSH
85713: CALL_OW 559
// end ;
85717: END
// every 0 0$1 do
85718: GO 85720
85720: DISABLE
// begin globalGameSaveCounter := 0 ;
85721: LD_ADDR_EXP 94
85725: PUSH
85726: LD_INT 0
85728: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
85729: LD_STRING setGameSaveCounter(0)
85731: PPUSH
85732: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
85736: LD_STRING initStreamRollete();
85738: PPUSH
85739: CALL_OW 559
// InitStreamMode ;
85743: CALL 87069 0 0
// DefineStreamItems ( false ) ;
85747: LD_INT 0
85749: PPUSH
85750: CALL 87533 0 1
// end ;
85754: END
// export function SOS_MapStart ( ) ; begin
85755: LD_INT 0
85757: PPUSH
// if streamModeActive then
85758: LD_EXP 95
85762: IFFALSE 85771
// DefineStreamItems ( true ) ;
85764: LD_INT 1
85766: PPUSH
85767: CALL 87533 0 1
// UpdateLuaVariables ( ) ;
85771: CALL 85788 0 0
// UpdateFactoryWaypoints ( ) ;
85775: CALL 100394 0 0
// UpdateWarehouseGatheringPoints ( ) ;
85779: CALL 100651 0 0
// end ;
85783: LD_VAR 0 1
85787: RET
// function UpdateLuaVariables ( ) ; begin
85788: LD_INT 0
85790: PPUSH
// if globalGameSaveCounter then
85791: LD_EXP 94
85795: IFFALSE 85829
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
85797: LD_ADDR_EXP 94
85801: PUSH
85802: LD_EXP 94
85806: PPUSH
85807: CALL 52440 0 1
85811: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
85812: LD_STRING setGameSaveCounter(
85814: PUSH
85815: LD_EXP 94
85819: STR
85820: PUSH
85821: LD_STRING )
85823: STR
85824: PPUSH
85825: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
85829: LD_STRING setGameDifficulty(
85831: PUSH
85832: LD_OWVAR 67
85836: STR
85837: PUSH
85838: LD_STRING )
85840: STR
85841: PPUSH
85842: CALL_OW 559
// end ;
85846: LD_VAR 0 1
85850: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85851: LD_INT 0
85853: PPUSH
// if p2 = stream_mode then
85854: LD_VAR 0 2
85858: PUSH
85859: LD_INT 100
85861: EQUAL
85862: IFFALSE 86865
// begin if not StreamModeActive then
85864: LD_EXP 95
85868: NOT
85869: IFFALSE 85879
// StreamModeActive := true ;
85871: LD_ADDR_EXP 95
85875: PUSH
85876: LD_INT 1
85878: ST_TO_ADDR
// if p3 = 0 then
85879: LD_VAR 0 3
85883: PUSH
85884: LD_INT 0
85886: EQUAL
85887: IFFALSE 85893
// InitStreamMode ;
85889: CALL 87069 0 0
// if p3 = 1 then
85893: LD_VAR 0 3
85897: PUSH
85898: LD_INT 1
85900: EQUAL
85901: IFFALSE 85911
// sRocket := true ;
85903: LD_ADDR_EXP 100
85907: PUSH
85908: LD_INT 1
85910: ST_TO_ADDR
// if p3 = 2 then
85911: LD_VAR 0 3
85915: PUSH
85916: LD_INT 2
85918: EQUAL
85919: IFFALSE 85929
// sSpeed := true ;
85921: LD_ADDR_EXP 99
85925: PUSH
85926: LD_INT 1
85928: ST_TO_ADDR
// if p3 = 3 then
85929: LD_VAR 0 3
85933: PUSH
85934: LD_INT 3
85936: EQUAL
85937: IFFALSE 85947
// sEngine := true ;
85939: LD_ADDR_EXP 101
85943: PUSH
85944: LD_INT 1
85946: ST_TO_ADDR
// if p3 = 4 then
85947: LD_VAR 0 3
85951: PUSH
85952: LD_INT 4
85954: EQUAL
85955: IFFALSE 85965
// sSpec := true ;
85957: LD_ADDR_EXP 98
85961: PUSH
85962: LD_INT 1
85964: ST_TO_ADDR
// if p3 = 5 then
85965: LD_VAR 0 3
85969: PUSH
85970: LD_INT 5
85972: EQUAL
85973: IFFALSE 85983
// sLevel := true ;
85975: LD_ADDR_EXP 102
85979: PUSH
85980: LD_INT 1
85982: ST_TO_ADDR
// if p3 = 6 then
85983: LD_VAR 0 3
85987: PUSH
85988: LD_INT 6
85990: EQUAL
85991: IFFALSE 86001
// sArmoury := true ;
85993: LD_ADDR_EXP 103
85997: PUSH
85998: LD_INT 1
86000: ST_TO_ADDR
// if p3 = 7 then
86001: LD_VAR 0 3
86005: PUSH
86006: LD_INT 7
86008: EQUAL
86009: IFFALSE 86019
// sRadar := true ;
86011: LD_ADDR_EXP 104
86015: PUSH
86016: LD_INT 1
86018: ST_TO_ADDR
// if p3 = 8 then
86019: LD_VAR 0 3
86023: PUSH
86024: LD_INT 8
86026: EQUAL
86027: IFFALSE 86037
// sBunker := true ;
86029: LD_ADDR_EXP 105
86033: PUSH
86034: LD_INT 1
86036: ST_TO_ADDR
// if p3 = 9 then
86037: LD_VAR 0 3
86041: PUSH
86042: LD_INT 9
86044: EQUAL
86045: IFFALSE 86055
// sHack := true ;
86047: LD_ADDR_EXP 106
86051: PUSH
86052: LD_INT 1
86054: ST_TO_ADDR
// if p3 = 10 then
86055: LD_VAR 0 3
86059: PUSH
86060: LD_INT 10
86062: EQUAL
86063: IFFALSE 86073
// sFire := true ;
86065: LD_ADDR_EXP 107
86069: PUSH
86070: LD_INT 1
86072: ST_TO_ADDR
// if p3 = 11 then
86073: LD_VAR 0 3
86077: PUSH
86078: LD_INT 11
86080: EQUAL
86081: IFFALSE 86091
// sRefresh := true ;
86083: LD_ADDR_EXP 108
86087: PUSH
86088: LD_INT 1
86090: ST_TO_ADDR
// if p3 = 12 then
86091: LD_VAR 0 3
86095: PUSH
86096: LD_INT 12
86098: EQUAL
86099: IFFALSE 86109
// sExp := true ;
86101: LD_ADDR_EXP 109
86105: PUSH
86106: LD_INT 1
86108: ST_TO_ADDR
// if p3 = 13 then
86109: LD_VAR 0 3
86113: PUSH
86114: LD_INT 13
86116: EQUAL
86117: IFFALSE 86127
// sDepot := true ;
86119: LD_ADDR_EXP 110
86123: PUSH
86124: LD_INT 1
86126: ST_TO_ADDR
// if p3 = 14 then
86127: LD_VAR 0 3
86131: PUSH
86132: LD_INT 14
86134: EQUAL
86135: IFFALSE 86145
// sFlag := true ;
86137: LD_ADDR_EXP 111
86141: PUSH
86142: LD_INT 1
86144: ST_TO_ADDR
// if p3 = 15 then
86145: LD_VAR 0 3
86149: PUSH
86150: LD_INT 15
86152: EQUAL
86153: IFFALSE 86163
// sKamikadze := true ;
86155: LD_ADDR_EXP 119
86159: PUSH
86160: LD_INT 1
86162: ST_TO_ADDR
// if p3 = 16 then
86163: LD_VAR 0 3
86167: PUSH
86168: LD_INT 16
86170: EQUAL
86171: IFFALSE 86181
// sTroll := true ;
86173: LD_ADDR_EXP 120
86177: PUSH
86178: LD_INT 1
86180: ST_TO_ADDR
// if p3 = 17 then
86181: LD_VAR 0 3
86185: PUSH
86186: LD_INT 17
86188: EQUAL
86189: IFFALSE 86199
// sSlow := true ;
86191: LD_ADDR_EXP 121
86195: PUSH
86196: LD_INT 1
86198: ST_TO_ADDR
// if p3 = 18 then
86199: LD_VAR 0 3
86203: PUSH
86204: LD_INT 18
86206: EQUAL
86207: IFFALSE 86217
// sLack := true ;
86209: LD_ADDR_EXP 122
86213: PUSH
86214: LD_INT 1
86216: ST_TO_ADDR
// if p3 = 19 then
86217: LD_VAR 0 3
86221: PUSH
86222: LD_INT 19
86224: EQUAL
86225: IFFALSE 86235
// sTank := true ;
86227: LD_ADDR_EXP 124
86231: PUSH
86232: LD_INT 1
86234: ST_TO_ADDR
// if p3 = 20 then
86235: LD_VAR 0 3
86239: PUSH
86240: LD_INT 20
86242: EQUAL
86243: IFFALSE 86253
// sRemote := true ;
86245: LD_ADDR_EXP 125
86249: PUSH
86250: LD_INT 1
86252: ST_TO_ADDR
// if p3 = 21 then
86253: LD_VAR 0 3
86257: PUSH
86258: LD_INT 21
86260: EQUAL
86261: IFFALSE 86271
// sPowell := true ;
86263: LD_ADDR_EXP 126
86267: PUSH
86268: LD_INT 1
86270: ST_TO_ADDR
// if p3 = 22 then
86271: LD_VAR 0 3
86275: PUSH
86276: LD_INT 22
86278: EQUAL
86279: IFFALSE 86289
// sTeleport := true ;
86281: LD_ADDR_EXP 129
86285: PUSH
86286: LD_INT 1
86288: ST_TO_ADDR
// if p3 = 23 then
86289: LD_VAR 0 3
86293: PUSH
86294: LD_INT 23
86296: EQUAL
86297: IFFALSE 86307
// sOilTower := true ;
86299: LD_ADDR_EXP 131
86303: PUSH
86304: LD_INT 1
86306: ST_TO_ADDR
// if p3 = 24 then
86307: LD_VAR 0 3
86311: PUSH
86312: LD_INT 24
86314: EQUAL
86315: IFFALSE 86325
// sShovel := true ;
86317: LD_ADDR_EXP 132
86321: PUSH
86322: LD_INT 1
86324: ST_TO_ADDR
// if p3 = 25 then
86325: LD_VAR 0 3
86329: PUSH
86330: LD_INT 25
86332: EQUAL
86333: IFFALSE 86343
// sSheik := true ;
86335: LD_ADDR_EXP 133
86339: PUSH
86340: LD_INT 1
86342: ST_TO_ADDR
// if p3 = 26 then
86343: LD_VAR 0 3
86347: PUSH
86348: LD_INT 26
86350: EQUAL
86351: IFFALSE 86361
// sEarthquake := true ;
86353: LD_ADDR_EXP 135
86357: PUSH
86358: LD_INT 1
86360: ST_TO_ADDR
// if p3 = 27 then
86361: LD_VAR 0 3
86365: PUSH
86366: LD_INT 27
86368: EQUAL
86369: IFFALSE 86379
// sAI := true ;
86371: LD_ADDR_EXP 136
86375: PUSH
86376: LD_INT 1
86378: ST_TO_ADDR
// if p3 = 28 then
86379: LD_VAR 0 3
86383: PUSH
86384: LD_INT 28
86386: EQUAL
86387: IFFALSE 86397
// sCargo := true ;
86389: LD_ADDR_EXP 139
86393: PUSH
86394: LD_INT 1
86396: ST_TO_ADDR
// if p3 = 29 then
86397: LD_VAR 0 3
86401: PUSH
86402: LD_INT 29
86404: EQUAL
86405: IFFALSE 86415
// sDLaser := true ;
86407: LD_ADDR_EXP 140
86411: PUSH
86412: LD_INT 1
86414: ST_TO_ADDR
// if p3 = 30 then
86415: LD_VAR 0 3
86419: PUSH
86420: LD_INT 30
86422: EQUAL
86423: IFFALSE 86433
// sExchange := true ;
86425: LD_ADDR_EXP 141
86429: PUSH
86430: LD_INT 1
86432: ST_TO_ADDR
// if p3 = 31 then
86433: LD_VAR 0 3
86437: PUSH
86438: LD_INT 31
86440: EQUAL
86441: IFFALSE 86451
// sFac := true ;
86443: LD_ADDR_EXP 142
86447: PUSH
86448: LD_INT 1
86450: ST_TO_ADDR
// if p3 = 32 then
86451: LD_VAR 0 3
86455: PUSH
86456: LD_INT 32
86458: EQUAL
86459: IFFALSE 86469
// sPower := true ;
86461: LD_ADDR_EXP 143
86465: PUSH
86466: LD_INT 1
86468: ST_TO_ADDR
// if p3 = 33 then
86469: LD_VAR 0 3
86473: PUSH
86474: LD_INT 33
86476: EQUAL
86477: IFFALSE 86487
// sRandom := true ;
86479: LD_ADDR_EXP 144
86483: PUSH
86484: LD_INT 1
86486: ST_TO_ADDR
// if p3 = 34 then
86487: LD_VAR 0 3
86491: PUSH
86492: LD_INT 34
86494: EQUAL
86495: IFFALSE 86505
// sShield := true ;
86497: LD_ADDR_EXP 145
86501: PUSH
86502: LD_INT 1
86504: ST_TO_ADDR
// if p3 = 35 then
86505: LD_VAR 0 3
86509: PUSH
86510: LD_INT 35
86512: EQUAL
86513: IFFALSE 86523
// sTime := true ;
86515: LD_ADDR_EXP 146
86519: PUSH
86520: LD_INT 1
86522: ST_TO_ADDR
// if p3 = 36 then
86523: LD_VAR 0 3
86527: PUSH
86528: LD_INT 36
86530: EQUAL
86531: IFFALSE 86541
// sTools := true ;
86533: LD_ADDR_EXP 147
86537: PUSH
86538: LD_INT 1
86540: ST_TO_ADDR
// if p3 = 101 then
86541: LD_VAR 0 3
86545: PUSH
86546: LD_INT 101
86548: EQUAL
86549: IFFALSE 86559
// sSold := true ;
86551: LD_ADDR_EXP 112
86555: PUSH
86556: LD_INT 1
86558: ST_TO_ADDR
// if p3 = 102 then
86559: LD_VAR 0 3
86563: PUSH
86564: LD_INT 102
86566: EQUAL
86567: IFFALSE 86577
// sDiff := true ;
86569: LD_ADDR_EXP 113
86573: PUSH
86574: LD_INT 1
86576: ST_TO_ADDR
// if p3 = 103 then
86577: LD_VAR 0 3
86581: PUSH
86582: LD_INT 103
86584: EQUAL
86585: IFFALSE 86595
// sFog := true ;
86587: LD_ADDR_EXP 116
86591: PUSH
86592: LD_INT 1
86594: ST_TO_ADDR
// if p3 = 104 then
86595: LD_VAR 0 3
86599: PUSH
86600: LD_INT 104
86602: EQUAL
86603: IFFALSE 86613
// sReset := true ;
86605: LD_ADDR_EXP 117
86609: PUSH
86610: LD_INT 1
86612: ST_TO_ADDR
// if p3 = 105 then
86613: LD_VAR 0 3
86617: PUSH
86618: LD_INT 105
86620: EQUAL
86621: IFFALSE 86631
// sSun := true ;
86623: LD_ADDR_EXP 118
86627: PUSH
86628: LD_INT 1
86630: ST_TO_ADDR
// if p3 = 106 then
86631: LD_VAR 0 3
86635: PUSH
86636: LD_INT 106
86638: EQUAL
86639: IFFALSE 86649
// sTiger := true ;
86641: LD_ADDR_EXP 114
86645: PUSH
86646: LD_INT 1
86648: ST_TO_ADDR
// if p3 = 107 then
86649: LD_VAR 0 3
86653: PUSH
86654: LD_INT 107
86656: EQUAL
86657: IFFALSE 86667
// sBomb := true ;
86659: LD_ADDR_EXP 115
86663: PUSH
86664: LD_INT 1
86666: ST_TO_ADDR
// if p3 = 108 then
86667: LD_VAR 0 3
86671: PUSH
86672: LD_INT 108
86674: EQUAL
86675: IFFALSE 86685
// sWound := true ;
86677: LD_ADDR_EXP 123
86681: PUSH
86682: LD_INT 1
86684: ST_TO_ADDR
// if p3 = 109 then
86685: LD_VAR 0 3
86689: PUSH
86690: LD_INT 109
86692: EQUAL
86693: IFFALSE 86703
// sBetray := true ;
86695: LD_ADDR_EXP 127
86699: PUSH
86700: LD_INT 1
86702: ST_TO_ADDR
// if p3 = 110 then
86703: LD_VAR 0 3
86707: PUSH
86708: LD_INT 110
86710: EQUAL
86711: IFFALSE 86721
// sContamin := true ;
86713: LD_ADDR_EXP 128
86717: PUSH
86718: LD_INT 1
86720: ST_TO_ADDR
// if p3 = 111 then
86721: LD_VAR 0 3
86725: PUSH
86726: LD_INT 111
86728: EQUAL
86729: IFFALSE 86739
// sOil := true ;
86731: LD_ADDR_EXP 130
86735: PUSH
86736: LD_INT 1
86738: ST_TO_ADDR
// if p3 = 112 then
86739: LD_VAR 0 3
86743: PUSH
86744: LD_INT 112
86746: EQUAL
86747: IFFALSE 86757
// sStu := true ;
86749: LD_ADDR_EXP 134
86753: PUSH
86754: LD_INT 1
86756: ST_TO_ADDR
// if p3 = 113 then
86757: LD_VAR 0 3
86761: PUSH
86762: LD_INT 113
86764: EQUAL
86765: IFFALSE 86775
// sBazooka := true ;
86767: LD_ADDR_EXP 137
86771: PUSH
86772: LD_INT 1
86774: ST_TO_ADDR
// if p3 = 114 then
86775: LD_VAR 0 3
86779: PUSH
86780: LD_INT 114
86782: EQUAL
86783: IFFALSE 86793
// sMortar := true ;
86785: LD_ADDR_EXP 138
86789: PUSH
86790: LD_INT 1
86792: ST_TO_ADDR
// if p3 = 115 then
86793: LD_VAR 0 3
86797: PUSH
86798: LD_INT 115
86800: EQUAL
86801: IFFALSE 86811
// sRanger := true ;
86803: LD_ADDR_EXP 148
86807: PUSH
86808: LD_INT 1
86810: ST_TO_ADDR
// if p3 = 116 then
86811: LD_VAR 0 3
86815: PUSH
86816: LD_INT 116
86818: EQUAL
86819: IFFALSE 86829
// sComputer := true ;
86821: LD_ADDR_EXP 149
86825: PUSH
86826: LD_INT 1
86828: ST_TO_ADDR
// if p3 = 117 then
86829: LD_VAR 0 3
86833: PUSH
86834: LD_INT 117
86836: EQUAL
86837: IFFALSE 86847
// s30 := true ;
86839: LD_ADDR_EXP 150
86843: PUSH
86844: LD_INT 1
86846: ST_TO_ADDR
// if p3 = 118 then
86847: LD_VAR 0 3
86851: PUSH
86852: LD_INT 118
86854: EQUAL
86855: IFFALSE 86865
// s60 := true ;
86857: LD_ADDR_EXP 151
86861: PUSH
86862: LD_INT 1
86864: ST_TO_ADDR
// end ; if p2 = hack_mode then
86865: LD_VAR 0 2
86869: PUSH
86870: LD_INT 101
86872: EQUAL
86873: IFFALSE 87001
// begin case p3 of 1 :
86875: LD_VAR 0 3
86879: PUSH
86880: LD_INT 1
86882: DOUBLE
86883: EQUAL
86884: IFTRUE 86888
86886: GO 86895
86888: POP
// hHackUnlimitedResources ; 2 :
86889: CALL 99140 0 0
86893: GO 87001
86895: LD_INT 2
86897: DOUBLE
86898: EQUAL
86899: IFTRUE 86903
86901: GO 86910
86903: POP
// hHackSetLevel10 ; 3 :
86904: CALL 99273 0 0
86908: GO 87001
86910: LD_INT 3
86912: DOUBLE
86913: EQUAL
86914: IFTRUE 86918
86916: GO 86925
86918: POP
// hHackSetLevel10YourUnits ; 4 :
86919: CALL 99358 0 0
86923: GO 87001
86925: LD_INT 4
86927: DOUBLE
86928: EQUAL
86929: IFTRUE 86933
86931: GO 86940
86933: POP
// hHackInvincible ; 5 :
86934: CALL 99806 0 0
86938: GO 87001
86940: LD_INT 5
86942: DOUBLE
86943: EQUAL
86944: IFTRUE 86948
86946: GO 86955
86948: POP
// hHackInvisible ; 6 :
86949: CALL 99917 0 0
86953: GO 87001
86955: LD_INT 6
86957: DOUBLE
86958: EQUAL
86959: IFTRUE 86963
86961: GO 86970
86963: POP
// hHackChangeYourSide ; 7 :
86964: CALL 99974 0 0
86968: GO 87001
86970: LD_INT 7
86972: DOUBLE
86973: EQUAL
86974: IFTRUE 86978
86976: GO 86985
86978: POP
// hHackChangeUnitSide ; 8 :
86979: CALL 100016 0 0
86983: GO 87001
86985: LD_INT 8
86987: DOUBLE
86988: EQUAL
86989: IFTRUE 86993
86991: GO 87000
86993: POP
// hHackFog ; end ;
86994: CALL 100117 0 0
86998: GO 87001
87000: POP
// end ; if p2 = game_save_mode then
87001: LD_VAR 0 2
87005: PUSH
87006: LD_INT 102
87008: EQUAL
87009: IFFALSE 87064
// begin if p3 = 1 then
87011: LD_VAR 0 3
87015: PUSH
87016: LD_INT 1
87018: EQUAL
87019: IFFALSE 87031
// globalGameSaveCounter := p4 ;
87021: LD_ADDR_EXP 94
87025: PUSH
87026: LD_VAR 0 4
87030: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
87031: LD_VAR 0 3
87035: PUSH
87036: LD_INT 2
87038: EQUAL
87039: PUSH
87040: LD_EXP 94
87044: AND
87045: IFFALSE 87064
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87047: LD_STRING setGameSaveCounter(
87049: PUSH
87050: LD_EXP 94
87054: STR
87055: PUSH
87056: LD_STRING )
87058: STR
87059: PPUSH
87060: CALL_OW 559
// end ; end ;
87064: LD_VAR 0 7
87068: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
87069: LD_INT 0
87071: PPUSH
// streamModeActive := false ;
87072: LD_ADDR_EXP 95
87076: PUSH
87077: LD_INT 0
87079: ST_TO_ADDR
// normalCounter := 36 ;
87080: LD_ADDR_EXP 96
87084: PUSH
87085: LD_INT 36
87087: ST_TO_ADDR
// hardcoreCounter := 18 ;
87088: LD_ADDR_EXP 97
87092: PUSH
87093: LD_INT 18
87095: ST_TO_ADDR
// sRocket := false ;
87096: LD_ADDR_EXP 100
87100: PUSH
87101: LD_INT 0
87103: ST_TO_ADDR
// sSpeed := false ;
87104: LD_ADDR_EXP 99
87108: PUSH
87109: LD_INT 0
87111: ST_TO_ADDR
// sEngine := false ;
87112: LD_ADDR_EXP 101
87116: PUSH
87117: LD_INT 0
87119: ST_TO_ADDR
// sSpec := false ;
87120: LD_ADDR_EXP 98
87124: PUSH
87125: LD_INT 0
87127: ST_TO_ADDR
// sLevel := false ;
87128: LD_ADDR_EXP 102
87132: PUSH
87133: LD_INT 0
87135: ST_TO_ADDR
// sArmoury := false ;
87136: LD_ADDR_EXP 103
87140: PUSH
87141: LD_INT 0
87143: ST_TO_ADDR
// sRadar := false ;
87144: LD_ADDR_EXP 104
87148: PUSH
87149: LD_INT 0
87151: ST_TO_ADDR
// sBunker := false ;
87152: LD_ADDR_EXP 105
87156: PUSH
87157: LD_INT 0
87159: ST_TO_ADDR
// sHack := false ;
87160: LD_ADDR_EXP 106
87164: PUSH
87165: LD_INT 0
87167: ST_TO_ADDR
// sFire := false ;
87168: LD_ADDR_EXP 107
87172: PUSH
87173: LD_INT 0
87175: ST_TO_ADDR
// sRefresh := false ;
87176: LD_ADDR_EXP 108
87180: PUSH
87181: LD_INT 0
87183: ST_TO_ADDR
// sExp := false ;
87184: LD_ADDR_EXP 109
87188: PUSH
87189: LD_INT 0
87191: ST_TO_ADDR
// sDepot := false ;
87192: LD_ADDR_EXP 110
87196: PUSH
87197: LD_INT 0
87199: ST_TO_ADDR
// sFlag := false ;
87200: LD_ADDR_EXP 111
87204: PUSH
87205: LD_INT 0
87207: ST_TO_ADDR
// sKamikadze := false ;
87208: LD_ADDR_EXP 119
87212: PUSH
87213: LD_INT 0
87215: ST_TO_ADDR
// sTroll := false ;
87216: LD_ADDR_EXP 120
87220: PUSH
87221: LD_INT 0
87223: ST_TO_ADDR
// sSlow := false ;
87224: LD_ADDR_EXP 121
87228: PUSH
87229: LD_INT 0
87231: ST_TO_ADDR
// sLack := false ;
87232: LD_ADDR_EXP 122
87236: PUSH
87237: LD_INT 0
87239: ST_TO_ADDR
// sTank := false ;
87240: LD_ADDR_EXP 124
87244: PUSH
87245: LD_INT 0
87247: ST_TO_ADDR
// sRemote := false ;
87248: LD_ADDR_EXP 125
87252: PUSH
87253: LD_INT 0
87255: ST_TO_ADDR
// sPowell := false ;
87256: LD_ADDR_EXP 126
87260: PUSH
87261: LD_INT 0
87263: ST_TO_ADDR
// sTeleport := false ;
87264: LD_ADDR_EXP 129
87268: PUSH
87269: LD_INT 0
87271: ST_TO_ADDR
// sOilTower := false ;
87272: LD_ADDR_EXP 131
87276: PUSH
87277: LD_INT 0
87279: ST_TO_ADDR
// sShovel := false ;
87280: LD_ADDR_EXP 132
87284: PUSH
87285: LD_INT 0
87287: ST_TO_ADDR
// sSheik := false ;
87288: LD_ADDR_EXP 133
87292: PUSH
87293: LD_INT 0
87295: ST_TO_ADDR
// sEarthquake := false ;
87296: LD_ADDR_EXP 135
87300: PUSH
87301: LD_INT 0
87303: ST_TO_ADDR
// sAI := false ;
87304: LD_ADDR_EXP 136
87308: PUSH
87309: LD_INT 0
87311: ST_TO_ADDR
// sCargo := false ;
87312: LD_ADDR_EXP 139
87316: PUSH
87317: LD_INT 0
87319: ST_TO_ADDR
// sDLaser := false ;
87320: LD_ADDR_EXP 140
87324: PUSH
87325: LD_INT 0
87327: ST_TO_ADDR
// sExchange := false ;
87328: LD_ADDR_EXP 141
87332: PUSH
87333: LD_INT 0
87335: ST_TO_ADDR
// sFac := false ;
87336: LD_ADDR_EXP 142
87340: PUSH
87341: LD_INT 0
87343: ST_TO_ADDR
// sPower := false ;
87344: LD_ADDR_EXP 143
87348: PUSH
87349: LD_INT 0
87351: ST_TO_ADDR
// sRandom := false ;
87352: LD_ADDR_EXP 144
87356: PUSH
87357: LD_INT 0
87359: ST_TO_ADDR
// sShield := false ;
87360: LD_ADDR_EXP 145
87364: PUSH
87365: LD_INT 0
87367: ST_TO_ADDR
// sTime := false ;
87368: LD_ADDR_EXP 146
87372: PUSH
87373: LD_INT 0
87375: ST_TO_ADDR
// sTools := false ;
87376: LD_ADDR_EXP 147
87380: PUSH
87381: LD_INT 0
87383: ST_TO_ADDR
// sSold := false ;
87384: LD_ADDR_EXP 112
87388: PUSH
87389: LD_INT 0
87391: ST_TO_ADDR
// sDiff := false ;
87392: LD_ADDR_EXP 113
87396: PUSH
87397: LD_INT 0
87399: ST_TO_ADDR
// sFog := false ;
87400: LD_ADDR_EXP 116
87404: PUSH
87405: LD_INT 0
87407: ST_TO_ADDR
// sReset := false ;
87408: LD_ADDR_EXP 117
87412: PUSH
87413: LD_INT 0
87415: ST_TO_ADDR
// sSun := false ;
87416: LD_ADDR_EXP 118
87420: PUSH
87421: LD_INT 0
87423: ST_TO_ADDR
// sTiger := false ;
87424: LD_ADDR_EXP 114
87428: PUSH
87429: LD_INT 0
87431: ST_TO_ADDR
// sBomb := false ;
87432: LD_ADDR_EXP 115
87436: PUSH
87437: LD_INT 0
87439: ST_TO_ADDR
// sWound := false ;
87440: LD_ADDR_EXP 123
87444: PUSH
87445: LD_INT 0
87447: ST_TO_ADDR
// sBetray := false ;
87448: LD_ADDR_EXP 127
87452: PUSH
87453: LD_INT 0
87455: ST_TO_ADDR
// sContamin := false ;
87456: LD_ADDR_EXP 128
87460: PUSH
87461: LD_INT 0
87463: ST_TO_ADDR
// sOil := false ;
87464: LD_ADDR_EXP 130
87468: PUSH
87469: LD_INT 0
87471: ST_TO_ADDR
// sStu := false ;
87472: LD_ADDR_EXP 134
87476: PUSH
87477: LD_INT 0
87479: ST_TO_ADDR
// sBazooka := false ;
87480: LD_ADDR_EXP 137
87484: PUSH
87485: LD_INT 0
87487: ST_TO_ADDR
// sMortar := false ;
87488: LD_ADDR_EXP 138
87492: PUSH
87493: LD_INT 0
87495: ST_TO_ADDR
// sRanger := false ;
87496: LD_ADDR_EXP 148
87500: PUSH
87501: LD_INT 0
87503: ST_TO_ADDR
// sComputer := false ;
87504: LD_ADDR_EXP 149
87508: PUSH
87509: LD_INT 0
87511: ST_TO_ADDR
// s30 := false ;
87512: LD_ADDR_EXP 150
87516: PUSH
87517: LD_INT 0
87519: ST_TO_ADDR
// s60 := false ;
87520: LD_ADDR_EXP 151
87524: PUSH
87525: LD_INT 0
87527: ST_TO_ADDR
// end ;
87528: LD_VAR 0 1
87532: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87533: LD_INT 0
87535: PPUSH
87536: PPUSH
87537: PPUSH
87538: PPUSH
87539: PPUSH
87540: PPUSH
87541: PPUSH
// result := [ ] ;
87542: LD_ADDR_VAR 0 2
87546: PUSH
87547: EMPTY
87548: ST_TO_ADDR
// if campaign_id = 1 then
87549: LD_OWVAR 69
87553: PUSH
87554: LD_INT 1
87556: EQUAL
87557: IFFALSE 90723
// begin case mission_number of 1 :
87559: LD_OWVAR 70
87563: PUSH
87564: LD_INT 1
87566: DOUBLE
87567: EQUAL
87568: IFTRUE 87572
87570: GO 87648
87572: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87573: LD_ADDR_VAR 0 2
87577: PUSH
87578: LD_INT 2
87580: PUSH
87581: LD_INT 4
87583: PUSH
87584: LD_INT 11
87586: PUSH
87587: LD_INT 12
87589: PUSH
87590: LD_INT 15
87592: PUSH
87593: LD_INT 16
87595: PUSH
87596: LD_INT 22
87598: PUSH
87599: LD_INT 23
87601: PUSH
87602: LD_INT 26
87604: PUSH
87605: EMPTY
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 101
87618: PUSH
87619: LD_INT 102
87621: PUSH
87622: LD_INT 106
87624: PUSH
87625: LD_INT 116
87627: PUSH
87628: LD_INT 117
87630: PUSH
87631: LD_INT 118
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: ST_TO_ADDR
87646: GO 90721
87648: LD_INT 2
87650: DOUBLE
87651: EQUAL
87652: IFTRUE 87656
87654: GO 87740
87656: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87657: LD_ADDR_VAR 0 2
87661: PUSH
87662: LD_INT 2
87664: PUSH
87665: LD_INT 4
87667: PUSH
87668: LD_INT 11
87670: PUSH
87671: LD_INT 12
87673: PUSH
87674: LD_INT 15
87676: PUSH
87677: LD_INT 16
87679: PUSH
87680: LD_INT 22
87682: PUSH
87683: LD_INT 23
87685: PUSH
87686: LD_INT 26
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 101
87702: PUSH
87703: LD_INT 102
87705: PUSH
87706: LD_INT 105
87708: PUSH
87709: LD_INT 106
87711: PUSH
87712: LD_INT 108
87714: PUSH
87715: LD_INT 116
87717: PUSH
87718: LD_INT 117
87720: PUSH
87721: LD_INT 118
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: ST_TO_ADDR
87738: GO 90721
87740: LD_INT 3
87742: DOUBLE
87743: EQUAL
87744: IFTRUE 87748
87746: GO 87836
87748: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87749: LD_ADDR_VAR 0 2
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: LD_INT 4
87759: PUSH
87760: LD_INT 5
87762: PUSH
87763: LD_INT 11
87765: PUSH
87766: LD_INT 12
87768: PUSH
87769: LD_INT 15
87771: PUSH
87772: LD_INT 16
87774: PUSH
87775: LD_INT 22
87777: PUSH
87778: LD_INT 26
87780: PUSH
87781: LD_INT 36
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 101
87798: PUSH
87799: LD_INT 102
87801: PUSH
87802: LD_INT 105
87804: PUSH
87805: LD_INT 106
87807: PUSH
87808: LD_INT 108
87810: PUSH
87811: LD_INT 116
87813: PUSH
87814: LD_INT 117
87816: PUSH
87817: LD_INT 118
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: ST_TO_ADDR
87834: GO 90721
87836: LD_INT 4
87838: DOUBLE
87839: EQUAL
87840: IFTRUE 87844
87842: GO 87940
87844: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87845: LD_ADDR_VAR 0 2
87849: PUSH
87850: LD_INT 2
87852: PUSH
87853: LD_INT 4
87855: PUSH
87856: LD_INT 5
87858: PUSH
87859: LD_INT 8
87861: PUSH
87862: LD_INT 11
87864: PUSH
87865: LD_INT 12
87867: PUSH
87868: LD_INT 15
87870: PUSH
87871: LD_INT 16
87873: PUSH
87874: LD_INT 22
87876: PUSH
87877: LD_INT 23
87879: PUSH
87880: LD_INT 26
87882: PUSH
87883: LD_INT 36
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 101
87902: PUSH
87903: LD_INT 102
87905: PUSH
87906: LD_INT 105
87908: PUSH
87909: LD_INT 106
87911: PUSH
87912: LD_INT 108
87914: PUSH
87915: LD_INT 116
87917: PUSH
87918: LD_INT 117
87920: PUSH
87921: LD_INT 118
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: ST_TO_ADDR
87938: GO 90721
87940: LD_INT 5
87942: DOUBLE
87943: EQUAL
87944: IFTRUE 87948
87946: GO 88060
87948: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87949: LD_ADDR_VAR 0 2
87953: PUSH
87954: LD_INT 2
87956: PUSH
87957: LD_INT 4
87959: PUSH
87960: LD_INT 5
87962: PUSH
87963: LD_INT 6
87965: PUSH
87966: LD_INT 8
87968: PUSH
87969: LD_INT 11
87971: PUSH
87972: LD_INT 12
87974: PUSH
87975: LD_INT 15
87977: PUSH
87978: LD_INT 16
87980: PUSH
87981: LD_INT 22
87983: PUSH
87984: LD_INT 23
87986: PUSH
87987: LD_INT 25
87989: PUSH
87990: LD_INT 26
87992: PUSH
87993: LD_INT 36
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 101
88014: PUSH
88015: LD_INT 102
88017: PUSH
88018: LD_INT 105
88020: PUSH
88021: LD_INT 106
88023: PUSH
88024: LD_INT 108
88026: PUSH
88027: LD_INT 109
88029: PUSH
88030: LD_INT 112
88032: PUSH
88033: LD_INT 116
88035: PUSH
88036: LD_INT 117
88038: PUSH
88039: LD_INT 118
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: ST_TO_ADDR
88058: GO 90721
88060: LD_INT 6
88062: DOUBLE
88063: EQUAL
88064: IFTRUE 88068
88066: GO 88200
88068: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
88069: LD_ADDR_VAR 0 2
88073: PUSH
88074: LD_INT 2
88076: PUSH
88077: LD_INT 4
88079: PUSH
88080: LD_INT 5
88082: PUSH
88083: LD_INT 6
88085: PUSH
88086: LD_INT 8
88088: PUSH
88089: LD_INT 11
88091: PUSH
88092: LD_INT 12
88094: PUSH
88095: LD_INT 15
88097: PUSH
88098: LD_INT 16
88100: PUSH
88101: LD_INT 20
88103: PUSH
88104: LD_INT 21
88106: PUSH
88107: LD_INT 22
88109: PUSH
88110: LD_INT 23
88112: PUSH
88113: LD_INT 25
88115: PUSH
88116: LD_INT 26
88118: PUSH
88119: LD_INT 30
88121: PUSH
88122: LD_INT 31
88124: PUSH
88125: LD_INT 32
88127: PUSH
88128: LD_INT 36
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 101
88154: PUSH
88155: LD_INT 102
88157: PUSH
88158: LD_INT 105
88160: PUSH
88161: LD_INT 106
88163: PUSH
88164: LD_INT 108
88166: PUSH
88167: LD_INT 109
88169: PUSH
88170: LD_INT 112
88172: PUSH
88173: LD_INT 116
88175: PUSH
88176: LD_INT 117
88178: PUSH
88179: LD_INT 118
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: ST_TO_ADDR
88198: GO 90721
88200: LD_INT 7
88202: DOUBLE
88203: EQUAL
88204: IFTRUE 88208
88206: GO 88320
88208: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
88209: LD_ADDR_VAR 0 2
88213: PUSH
88214: LD_INT 2
88216: PUSH
88217: LD_INT 4
88219: PUSH
88220: LD_INT 5
88222: PUSH
88223: LD_INT 7
88225: PUSH
88226: LD_INT 11
88228: PUSH
88229: LD_INT 12
88231: PUSH
88232: LD_INT 15
88234: PUSH
88235: LD_INT 16
88237: PUSH
88238: LD_INT 20
88240: PUSH
88241: LD_INT 21
88243: PUSH
88244: LD_INT 22
88246: PUSH
88247: LD_INT 23
88249: PUSH
88250: LD_INT 25
88252: PUSH
88253: LD_INT 26
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 101
88274: PUSH
88275: LD_INT 102
88277: PUSH
88278: LD_INT 103
88280: PUSH
88281: LD_INT 105
88283: PUSH
88284: LD_INT 106
88286: PUSH
88287: LD_INT 108
88289: PUSH
88290: LD_INT 112
88292: PUSH
88293: LD_INT 116
88295: PUSH
88296: LD_INT 117
88298: PUSH
88299: LD_INT 118
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: ST_TO_ADDR
88318: GO 90721
88320: LD_INT 8
88322: DOUBLE
88323: EQUAL
88324: IFTRUE 88328
88326: GO 88468
88328: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88329: LD_ADDR_VAR 0 2
88333: PUSH
88334: LD_INT 2
88336: PUSH
88337: LD_INT 4
88339: PUSH
88340: LD_INT 5
88342: PUSH
88343: LD_INT 6
88345: PUSH
88346: LD_INT 7
88348: PUSH
88349: LD_INT 8
88351: PUSH
88352: LD_INT 11
88354: PUSH
88355: LD_INT 12
88357: PUSH
88358: LD_INT 15
88360: PUSH
88361: LD_INT 16
88363: PUSH
88364: LD_INT 20
88366: PUSH
88367: LD_INT 21
88369: PUSH
88370: LD_INT 22
88372: PUSH
88373: LD_INT 23
88375: PUSH
88376: LD_INT 25
88378: PUSH
88379: LD_INT 26
88381: PUSH
88382: LD_INT 30
88384: PUSH
88385: LD_INT 31
88387: PUSH
88388: LD_INT 32
88390: PUSH
88391: LD_INT 36
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 101
88418: PUSH
88419: LD_INT 102
88421: PUSH
88422: LD_INT 103
88424: PUSH
88425: LD_INT 105
88427: PUSH
88428: LD_INT 106
88430: PUSH
88431: LD_INT 108
88433: PUSH
88434: LD_INT 109
88436: PUSH
88437: LD_INT 112
88439: PUSH
88440: LD_INT 116
88442: PUSH
88443: LD_INT 117
88445: PUSH
88446: LD_INT 118
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: ST_TO_ADDR
88466: GO 90721
88468: LD_INT 9
88470: DOUBLE
88471: EQUAL
88472: IFTRUE 88476
88474: GO 88624
88476: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88477: LD_ADDR_VAR 0 2
88481: PUSH
88482: LD_INT 2
88484: PUSH
88485: LD_INT 4
88487: PUSH
88488: LD_INT 5
88490: PUSH
88491: LD_INT 6
88493: PUSH
88494: LD_INT 7
88496: PUSH
88497: LD_INT 8
88499: PUSH
88500: LD_INT 11
88502: PUSH
88503: LD_INT 12
88505: PUSH
88506: LD_INT 15
88508: PUSH
88509: LD_INT 16
88511: PUSH
88512: LD_INT 20
88514: PUSH
88515: LD_INT 21
88517: PUSH
88518: LD_INT 22
88520: PUSH
88521: LD_INT 23
88523: PUSH
88524: LD_INT 25
88526: PUSH
88527: LD_INT 26
88529: PUSH
88530: LD_INT 28
88532: PUSH
88533: LD_INT 30
88535: PUSH
88536: LD_INT 31
88538: PUSH
88539: LD_INT 32
88541: PUSH
88542: LD_INT 36
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 101
88570: PUSH
88571: LD_INT 102
88573: PUSH
88574: LD_INT 103
88576: PUSH
88577: LD_INT 105
88579: PUSH
88580: LD_INT 106
88582: PUSH
88583: LD_INT 108
88585: PUSH
88586: LD_INT 109
88588: PUSH
88589: LD_INT 112
88591: PUSH
88592: LD_INT 114
88594: PUSH
88595: LD_INT 116
88597: PUSH
88598: LD_INT 117
88600: PUSH
88601: LD_INT 118
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: ST_TO_ADDR
88622: GO 90721
88624: LD_INT 10
88626: DOUBLE
88627: EQUAL
88628: IFTRUE 88632
88630: GO 88828
88632: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88633: LD_ADDR_VAR 0 2
88637: PUSH
88638: LD_INT 2
88640: PUSH
88641: LD_INT 4
88643: PUSH
88644: LD_INT 5
88646: PUSH
88647: LD_INT 6
88649: PUSH
88650: LD_INT 7
88652: PUSH
88653: LD_INT 8
88655: PUSH
88656: LD_INT 9
88658: PUSH
88659: LD_INT 10
88661: PUSH
88662: LD_INT 11
88664: PUSH
88665: LD_INT 12
88667: PUSH
88668: LD_INT 13
88670: PUSH
88671: LD_INT 14
88673: PUSH
88674: LD_INT 15
88676: PUSH
88677: LD_INT 16
88679: PUSH
88680: LD_INT 17
88682: PUSH
88683: LD_INT 18
88685: PUSH
88686: LD_INT 19
88688: PUSH
88689: LD_INT 20
88691: PUSH
88692: LD_INT 21
88694: PUSH
88695: LD_INT 22
88697: PUSH
88698: LD_INT 23
88700: PUSH
88701: LD_INT 24
88703: PUSH
88704: LD_INT 25
88706: PUSH
88707: LD_INT 26
88709: PUSH
88710: LD_INT 28
88712: PUSH
88713: LD_INT 30
88715: PUSH
88716: LD_INT 31
88718: PUSH
88719: LD_INT 32
88721: PUSH
88722: LD_INT 36
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 101
88758: PUSH
88759: LD_INT 102
88761: PUSH
88762: LD_INT 103
88764: PUSH
88765: LD_INT 104
88767: PUSH
88768: LD_INT 105
88770: PUSH
88771: LD_INT 106
88773: PUSH
88774: LD_INT 107
88776: PUSH
88777: LD_INT 108
88779: PUSH
88780: LD_INT 109
88782: PUSH
88783: LD_INT 110
88785: PUSH
88786: LD_INT 111
88788: PUSH
88789: LD_INT 112
88791: PUSH
88792: LD_INT 114
88794: PUSH
88795: LD_INT 116
88797: PUSH
88798: LD_INT 117
88800: PUSH
88801: LD_INT 118
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: ST_TO_ADDR
88826: GO 90721
88828: LD_INT 11
88830: DOUBLE
88831: EQUAL
88832: IFTRUE 88836
88834: GO 89040
88836: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88837: LD_ADDR_VAR 0 2
88841: PUSH
88842: LD_INT 2
88844: PUSH
88845: LD_INT 3
88847: PUSH
88848: LD_INT 4
88850: PUSH
88851: LD_INT 5
88853: PUSH
88854: LD_INT 6
88856: PUSH
88857: LD_INT 7
88859: PUSH
88860: LD_INT 8
88862: PUSH
88863: LD_INT 9
88865: PUSH
88866: LD_INT 10
88868: PUSH
88869: LD_INT 11
88871: PUSH
88872: LD_INT 12
88874: PUSH
88875: LD_INT 13
88877: PUSH
88878: LD_INT 14
88880: PUSH
88881: LD_INT 15
88883: PUSH
88884: LD_INT 16
88886: PUSH
88887: LD_INT 17
88889: PUSH
88890: LD_INT 18
88892: PUSH
88893: LD_INT 19
88895: PUSH
88896: LD_INT 20
88898: PUSH
88899: LD_INT 21
88901: PUSH
88902: LD_INT 22
88904: PUSH
88905: LD_INT 23
88907: PUSH
88908: LD_INT 24
88910: PUSH
88911: LD_INT 25
88913: PUSH
88914: LD_INT 26
88916: PUSH
88917: LD_INT 28
88919: PUSH
88920: LD_INT 30
88922: PUSH
88923: LD_INT 31
88925: PUSH
88926: LD_INT 32
88928: PUSH
88929: LD_INT 34
88931: PUSH
88932: LD_INT 36
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: PUSH
88968: LD_INT 101
88970: PUSH
88971: LD_INT 102
88973: PUSH
88974: LD_INT 103
88976: PUSH
88977: LD_INT 104
88979: PUSH
88980: LD_INT 105
88982: PUSH
88983: LD_INT 106
88985: PUSH
88986: LD_INT 107
88988: PUSH
88989: LD_INT 108
88991: PUSH
88992: LD_INT 109
88994: PUSH
88995: LD_INT 110
88997: PUSH
88998: LD_INT 111
89000: PUSH
89001: LD_INT 112
89003: PUSH
89004: LD_INT 114
89006: PUSH
89007: LD_INT 116
89009: PUSH
89010: LD_INT 117
89012: PUSH
89013: LD_INT 118
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: ST_TO_ADDR
89038: GO 90721
89040: LD_INT 12
89042: DOUBLE
89043: EQUAL
89044: IFTRUE 89048
89046: GO 89268
89048: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
89049: LD_ADDR_VAR 0 2
89053: PUSH
89054: LD_INT 1
89056: PUSH
89057: LD_INT 2
89059: PUSH
89060: LD_INT 3
89062: PUSH
89063: LD_INT 4
89065: PUSH
89066: LD_INT 5
89068: PUSH
89069: LD_INT 6
89071: PUSH
89072: LD_INT 7
89074: PUSH
89075: LD_INT 8
89077: PUSH
89078: LD_INT 9
89080: PUSH
89081: LD_INT 10
89083: PUSH
89084: LD_INT 11
89086: PUSH
89087: LD_INT 12
89089: PUSH
89090: LD_INT 13
89092: PUSH
89093: LD_INT 14
89095: PUSH
89096: LD_INT 15
89098: PUSH
89099: LD_INT 16
89101: PUSH
89102: LD_INT 17
89104: PUSH
89105: LD_INT 18
89107: PUSH
89108: LD_INT 19
89110: PUSH
89111: LD_INT 20
89113: PUSH
89114: LD_INT 21
89116: PUSH
89117: LD_INT 22
89119: PUSH
89120: LD_INT 23
89122: PUSH
89123: LD_INT 24
89125: PUSH
89126: LD_INT 25
89128: PUSH
89129: LD_INT 26
89131: PUSH
89132: LD_INT 27
89134: PUSH
89135: LD_INT 28
89137: PUSH
89138: LD_INT 30
89140: PUSH
89141: LD_INT 31
89143: PUSH
89144: LD_INT 32
89146: PUSH
89147: LD_INT 33
89149: PUSH
89150: LD_INT 34
89152: PUSH
89153: LD_INT 36
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 101
89194: PUSH
89195: LD_INT 102
89197: PUSH
89198: LD_INT 103
89200: PUSH
89201: LD_INT 104
89203: PUSH
89204: LD_INT 105
89206: PUSH
89207: LD_INT 106
89209: PUSH
89210: LD_INT 107
89212: PUSH
89213: LD_INT 108
89215: PUSH
89216: LD_INT 109
89218: PUSH
89219: LD_INT 110
89221: PUSH
89222: LD_INT 111
89224: PUSH
89225: LD_INT 112
89227: PUSH
89228: LD_INT 113
89230: PUSH
89231: LD_INT 114
89233: PUSH
89234: LD_INT 116
89236: PUSH
89237: LD_INT 117
89239: PUSH
89240: LD_INT 118
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: ST_TO_ADDR
89266: GO 90721
89268: LD_INT 13
89270: DOUBLE
89271: EQUAL
89272: IFTRUE 89276
89274: GO 89484
89276: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89277: LD_ADDR_VAR 0 2
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 2
89287: PUSH
89288: LD_INT 3
89290: PUSH
89291: LD_INT 4
89293: PUSH
89294: LD_INT 5
89296: PUSH
89297: LD_INT 8
89299: PUSH
89300: LD_INT 9
89302: PUSH
89303: LD_INT 10
89305: PUSH
89306: LD_INT 11
89308: PUSH
89309: LD_INT 12
89311: PUSH
89312: LD_INT 14
89314: PUSH
89315: LD_INT 15
89317: PUSH
89318: LD_INT 16
89320: PUSH
89321: LD_INT 17
89323: PUSH
89324: LD_INT 18
89326: PUSH
89327: LD_INT 19
89329: PUSH
89330: LD_INT 20
89332: PUSH
89333: LD_INT 21
89335: PUSH
89336: LD_INT 22
89338: PUSH
89339: LD_INT 23
89341: PUSH
89342: LD_INT 24
89344: PUSH
89345: LD_INT 25
89347: PUSH
89348: LD_INT 26
89350: PUSH
89351: LD_INT 27
89353: PUSH
89354: LD_INT 28
89356: PUSH
89357: LD_INT 30
89359: PUSH
89360: LD_INT 31
89362: PUSH
89363: LD_INT 32
89365: PUSH
89366: LD_INT 33
89368: PUSH
89369: LD_INT 34
89371: PUSH
89372: LD_INT 36
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 101
89410: PUSH
89411: LD_INT 102
89413: PUSH
89414: LD_INT 103
89416: PUSH
89417: LD_INT 104
89419: PUSH
89420: LD_INT 105
89422: PUSH
89423: LD_INT 106
89425: PUSH
89426: LD_INT 107
89428: PUSH
89429: LD_INT 108
89431: PUSH
89432: LD_INT 109
89434: PUSH
89435: LD_INT 110
89437: PUSH
89438: LD_INT 111
89440: PUSH
89441: LD_INT 112
89443: PUSH
89444: LD_INT 113
89446: PUSH
89447: LD_INT 114
89449: PUSH
89450: LD_INT 116
89452: PUSH
89453: LD_INT 117
89455: PUSH
89456: LD_INT 118
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: ST_TO_ADDR
89482: GO 90721
89484: LD_INT 14
89486: DOUBLE
89487: EQUAL
89488: IFTRUE 89492
89490: GO 89716
89492: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89493: LD_ADDR_VAR 0 2
89497: PUSH
89498: LD_INT 1
89500: PUSH
89501: LD_INT 2
89503: PUSH
89504: LD_INT 3
89506: PUSH
89507: LD_INT 4
89509: PUSH
89510: LD_INT 5
89512: PUSH
89513: LD_INT 6
89515: PUSH
89516: LD_INT 7
89518: PUSH
89519: LD_INT 8
89521: PUSH
89522: LD_INT 9
89524: PUSH
89525: LD_INT 10
89527: PUSH
89528: LD_INT 11
89530: PUSH
89531: LD_INT 12
89533: PUSH
89534: LD_INT 13
89536: PUSH
89537: LD_INT 14
89539: PUSH
89540: LD_INT 15
89542: PUSH
89543: LD_INT 16
89545: PUSH
89546: LD_INT 17
89548: PUSH
89549: LD_INT 18
89551: PUSH
89552: LD_INT 19
89554: PUSH
89555: LD_INT 20
89557: PUSH
89558: LD_INT 21
89560: PUSH
89561: LD_INT 22
89563: PUSH
89564: LD_INT 23
89566: PUSH
89567: LD_INT 24
89569: PUSH
89570: LD_INT 25
89572: PUSH
89573: LD_INT 26
89575: PUSH
89576: LD_INT 27
89578: PUSH
89579: LD_INT 28
89581: PUSH
89582: LD_INT 29
89584: PUSH
89585: LD_INT 30
89587: PUSH
89588: LD_INT 31
89590: PUSH
89591: LD_INT 32
89593: PUSH
89594: LD_INT 33
89596: PUSH
89597: LD_INT 34
89599: PUSH
89600: LD_INT 36
89602: PUSH
89603: EMPTY
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 101
89642: PUSH
89643: LD_INT 102
89645: PUSH
89646: LD_INT 103
89648: PUSH
89649: LD_INT 104
89651: PUSH
89652: LD_INT 105
89654: PUSH
89655: LD_INT 106
89657: PUSH
89658: LD_INT 107
89660: PUSH
89661: LD_INT 108
89663: PUSH
89664: LD_INT 109
89666: PUSH
89667: LD_INT 110
89669: PUSH
89670: LD_INT 111
89672: PUSH
89673: LD_INT 112
89675: PUSH
89676: LD_INT 113
89678: PUSH
89679: LD_INT 114
89681: PUSH
89682: LD_INT 116
89684: PUSH
89685: LD_INT 117
89687: PUSH
89688: LD_INT 118
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: PUSH
89710: EMPTY
89711: LIST
89712: LIST
89713: ST_TO_ADDR
89714: GO 90721
89716: LD_INT 15
89718: DOUBLE
89719: EQUAL
89720: IFTRUE 89724
89722: GO 89948
89724: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89725: LD_ADDR_VAR 0 2
89729: PUSH
89730: LD_INT 1
89732: PUSH
89733: LD_INT 2
89735: PUSH
89736: LD_INT 3
89738: PUSH
89739: LD_INT 4
89741: PUSH
89742: LD_INT 5
89744: PUSH
89745: LD_INT 6
89747: PUSH
89748: LD_INT 7
89750: PUSH
89751: LD_INT 8
89753: PUSH
89754: LD_INT 9
89756: PUSH
89757: LD_INT 10
89759: PUSH
89760: LD_INT 11
89762: PUSH
89763: LD_INT 12
89765: PUSH
89766: LD_INT 13
89768: PUSH
89769: LD_INT 14
89771: PUSH
89772: LD_INT 15
89774: PUSH
89775: LD_INT 16
89777: PUSH
89778: LD_INT 17
89780: PUSH
89781: LD_INT 18
89783: PUSH
89784: LD_INT 19
89786: PUSH
89787: LD_INT 20
89789: PUSH
89790: LD_INT 21
89792: PUSH
89793: LD_INT 22
89795: PUSH
89796: LD_INT 23
89798: PUSH
89799: LD_INT 24
89801: PUSH
89802: LD_INT 25
89804: PUSH
89805: LD_INT 26
89807: PUSH
89808: LD_INT 27
89810: PUSH
89811: LD_INT 28
89813: PUSH
89814: LD_INT 29
89816: PUSH
89817: LD_INT 30
89819: PUSH
89820: LD_INT 31
89822: PUSH
89823: LD_INT 32
89825: PUSH
89826: LD_INT 33
89828: PUSH
89829: LD_INT 34
89831: PUSH
89832: LD_INT 36
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 101
89874: PUSH
89875: LD_INT 102
89877: PUSH
89878: LD_INT 103
89880: PUSH
89881: LD_INT 104
89883: PUSH
89884: LD_INT 105
89886: PUSH
89887: LD_INT 106
89889: PUSH
89890: LD_INT 107
89892: PUSH
89893: LD_INT 108
89895: PUSH
89896: LD_INT 109
89898: PUSH
89899: LD_INT 110
89901: PUSH
89902: LD_INT 111
89904: PUSH
89905: LD_INT 112
89907: PUSH
89908: LD_INT 113
89910: PUSH
89911: LD_INT 114
89913: PUSH
89914: LD_INT 116
89916: PUSH
89917: LD_INT 117
89919: PUSH
89920: LD_INT 118
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: ST_TO_ADDR
89946: GO 90721
89948: LD_INT 16
89950: DOUBLE
89951: EQUAL
89952: IFTRUE 89956
89954: GO 90092
89956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89957: LD_ADDR_VAR 0 2
89961: PUSH
89962: LD_INT 2
89964: PUSH
89965: LD_INT 4
89967: PUSH
89968: LD_INT 5
89970: PUSH
89971: LD_INT 7
89973: PUSH
89974: LD_INT 11
89976: PUSH
89977: LD_INT 12
89979: PUSH
89980: LD_INT 15
89982: PUSH
89983: LD_INT 16
89985: PUSH
89986: LD_INT 20
89988: PUSH
89989: LD_INT 21
89991: PUSH
89992: LD_INT 22
89994: PUSH
89995: LD_INT 23
89997: PUSH
89998: LD_INT 25
90000: PUSH
90001: LD_INT 26
90003: PUSH
90004: LD_INT 30
90006: PUSH
90007: LD_INT 31
90009: PUSH
90010: LD_INT 32
90012: PUSH
90013: LD_INT 33
90015: PUSH
90016: LD_INT 34
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 101
90042: PUSH
90043: LD_INT 102
90045: PUSH
90046: LD_INT 103
90048: PUSH
90049: LD_INT 106
90051: PUSH
90052: LD_INT 108
90054: PUSH
90055: LD_INT 112
90057: PUSH
90058: LD_INT 113
90060: PUSH
90061: LD_INT 114
90063: PUSH
90064: LD_INT 116
90066: PUSH
90067: LD_INT 117
90069: PUSH
90070: LD_INT 118
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: ST_TO_ADDR
90090: GO 90721
90092: LD_INT 17
90094: DOUBLE
90095: EQUAL
90096: IFTRUE 90100
90098: GO 90324
90100: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
90101: LD_ADDR_VAR 0 2
90105: PUSH
90106: LD_INT 1
90108: PUSH
90109: LD_INT 2
90111: PUSH
90112: LD_INT 3
90114: PUSH
90115: LD_INT 4
90117: PUSH
90118: LD_INT 5
90120: PUSH
90121: LD_INT 6
90123: PUSH
90124: LD_INT 7
90126: PUSH
90127: LD_INT 8
90129: PUSH
90130: LD_INT 9
90132: PUSH
90133: LD_INT 10
90135: PUSH
90136: LD_INT 11
90138: PUSH
90139: LD_INT 12
90141: PUSH
90142: LD_INT 13
90144: PUSH
90145: LD_INT 14
90147: PUSH
90148: LD_INT 15
90150: PUSH
90151: LD_INT 16
90153: PUSH
90154: LD_INT 17
90156: PUSH
90157: LD_INT 18
90159: PUSH
90160: LD_INT 19
90162: PUSH
90163: LD_INT 20
90165: PUSH
90166: LD_INT 21
90168: PUSH
90169: LD_INT 22
90171: PUSH
90172: LD_INT 23
90174: PUSH
90175: LD_INT 24
90177: PUSH
90178: LD_INT 25
90180: PUSH
90181: LD_INT 26
90183: PUSH
90184: LD_INT 27
90186: PUSH
90187: LD_INT 28
90189: PUSH
90190: LD_INT 29
90192: PUSH
90193: LD_INT 30
90195: PUSH
90196: LD_INT 31
90198: PUSH
90199: LD_INT 32
90201: PUSH
90202: LD_INT 33
90204: PUSH
90205: LD_INT 34
90207: PUSH
90208: LD_INT 36
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 101
90250: PUSH
90251: LD_INT 102
90253: PUSH
90254: LD_INT 103
90256: PUSH
90257: LD_INT 104
90259: PUSH
90260: LD_INT 105
90262: PUSH
90263: LD_INT 106
90265: PUSH
90266: LD_INT 107
90268: PUSH
90269: LD_INT 108
90271: PUSH
90272: LD_INT 109
90274: PUSH
90275: LD_INT 110
90277: PUSH
90278: LD_INT 111
90280: PUSH
90281: LD_INT 112
90283: PUSH
90284: LD_INT 113
90286: PUSH
90287: LD_INT 114
90289: PUSH
90290: LD_INT 116
90292: PUSH
90293: LD_INT 117
90295: PUSH
90296: LD_INT 118
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: ST_TO_ADDR
90322: GO 90721
90324: LD_INT 18
90326: DOUBLE
90327: EQUAL
90328: IFTRUE 90332
90330: GO 90480
90332: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90333: LD_ADDR_VAR 0 2
90337: PUSH
90338: LD_INT 2
90340: PUSH
90341: LD_INT 4
90343: PUSH
90344: LD_INT 5
90346: PUSH
90347: LD_INT 7
90349: PUSH
90350: LD_INT 11
90352: PUSH
90353: LD_INT 12
90355: PUSH
90356: LD_INT 15
90358: PUSH
90359: LD_INT 16
90361: PUSH
90362: LD_INT 20
90364: PUSH
90365: LD_INT 21
90367: PUSH
90368: LD_INT 22
90370: PUSH
90371: LD_INT 23
90373: PUSH
90374: LD_INT 25
90376: PUSH
90377: LD_INT 26
90379: PUSH
90380: LD_INT 30
90382: PUSH
90383: LD_INT 31
90385: PUSH
90386: LD_INT 32
90388: PUSH
90389: LD_INT 33
90391: PUSH
90392: LD_INT 34
90394: PUSH
90395: LD_INT 35
90397: PUSH
90398: LD_INT 36
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 101
90426: PUSH
90427: LD_INT 102
90429: PUSH
90430: LD_INT 103
90432: PUSH
90433: LD_INT 106
90435: PUSH
90436: LD_INT 108
90438: PUSH
90439: LD_INT 112
90441: PUSH
90442: LD_INT 113
90444: PUSH
90445: LD_INT 114
90447: PUSH
90448: LD_INT 115
90450: PUSH
90451: LD_INT 116
90453: PUSH
90454: LD_INT 117
90456: PUSH
90457: LD_INT 118
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: ST_TO_ADDR
90478: GO 90721
90480: LD_INT 19
90482: DOUBLE
90483: EQUAL
90484: IFTRUE 90488
90486: GO 90720
90488: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90489: LD_ADDR_VAR 0 2
90493: PUSH
90494: LD_INT 1
90496: PUSH
90497: LD_INT 2
90499: PUSH
90500: LD_INT 3
90502: PUSH
90503: LD_INT 4
90505: PUSH
90506: LD_INT 5
90508: PUSH
90509: LD_INT 6
90511: PUSH
90512: LD_INT 7
90514: PUSH
90515: LD_INT 8
90517: PUSH
90518: LD_INT 9
90520: PUSH
90521: LD_INT 10
90523: PUSH
90524: LD_INT 11
90526: PUSH
90527: LD_INT 12
90529: PUSH
90530: LD_INT 13
90532: PUSH
90533: LD_INT 14
90535: PUSH
90536: LD_INT 15
90538: PUSH
90539: LD_INT 16
90541: PUSH
90542: LD_INT 17
90544: PUSH
90545: LD_INT 18
90547: PUSH
90548: LD_INT 19
90550: PUSH
90551: LD_INT 20
90553: PUSH
90554: LD_INT 21
90556: PUSH
90557: LD_INT 22
90559: PUSH
90560: LD_INT 23
90562: PUSH
90563: LD_INT 24
90565: PUSH
90566: LD_INT 25
90568: PUSH
90569: LD_INT 26
90571: PUSH
90572: LD_INT 27
90574: PUSH
90575: LD_INT 28
90577: PUSH
90578: LD_INT 29
90580: PUSH
90581: LD_INT 30
90583: PUSH
90584: LD_INT 31
90586: PUSH
90587: LD_INT 32
90589: PUSH
90590: LD_INT 33
90592: PUSH
90593: LD_INT 34
90595: PUSH
90596: LD_INT 35
90598: PUSH
90599: LD_INT 36
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 101
90642: PUSH
90643: LD_INT 102
90645: PUSH
90646: LD_INT 103
90648: PUSH
90649: LD_INT 104
90651: PUSH
90652: LD_INT 105
90654: PUSH
90655: LD_INT 106
90657: PUSH
90658: LD_INT 107
90660: PUSH
90661: LD_INT 108
90663: PUSH
90664: LD_INT 109
90666: PUSH
90667: LD_INT 110
90669: PUSH
90670: LD_INT 111
90672: PUSH
90673: LD_INT 112
90675: PUSH
90676: LD_INT 113
90678: PUSH
90679: LD_INT 114
90681: PUSH
90682: LD_INT 115
90684: PUSH
90685: LD_INT 116
90687: PUSH
90688: LD_INT 117
90690: PUSH
90691: LD_INT 118
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: ST_TO_ADDR
90718: GO 90721
90720: POP
// end else
90721: GO 90952
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90723: LD_ADDR_VAR 0 2
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: LD_INT 2
90733: PUSH
90734: LD_INT 3
90736: PUSH
90737: LD_INT 4
90739: PUSH
90740: LD_INT 5
90742: PUSH
90743: LD_INT 6
90745: PUSH
90746: LD_INT 7
90748: PUSH
90749: LD_INT 8
90751: PUSH
90752: LD_INT 9
90754: PUSH
90755: LD_INT 10
90757: PUSH
90758: LD_INT 11
90760: PUSH
90761: LD_INT 12
90763: PUSH
90764: LD_INT 13
90766: PUSH
90767: LD_INT 14
90769: PUSH
90770: LD_INT 15
90772: PUSH
90773: LD_INT 16
90775: PUSH
90776: LD_INT 17
90778: PUSH
90779: LD_INT 18
90781: PUSH
90782: LD_INT 19
90784: PUSH
90785: LD_INT 20
90787: PUSH
90788: LD_INT 21
90790: PUSH
90791: LD_INT 22
90793: PUSH
90794: LD_INT 23
90796: PUSH
90797: LD_INT 24
90799: PUSH
90800: LD_INT 25
90802: PUSH
90803: LD_INT 26
90805: PUSH
90806: LD_INT 27
90808: PUSH
90809: LD_INT 28
90811: PUSH
90812: LD_INT 29
90814: PUSH
90815: LD_INT 30
90817: PUSH
90818: LD_INT 31
90820: PUSH
90821: LD_INT 32
90823: PUSH
90824: LD_INT 33
90826: PUSH
90827: LD_INT 34
90829: PUSH
90830: LD_INT 35
90832: PUSH
90833: LD_INT 36
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 101
90876: PUSH
90877: LD_INT 102
90879: PUSH
90880: LD_INT 103
90882: PUSH
90883: LD_INT 104
90885: PUSH
90886: LD_INT 105
90888: PUSH
90889: LD_INT 106
90891: PUSH
90892: LD_INT 107
90894: PUSH
90895: LD_INT 108
90897: PUSH
90898: LD_INT 109
90900: PUSH
90901: LD_INT 110
90903: PUSH
90904: LD_INT 111
90906: PUSH
90907: LD_INT 112
90909: PUSH
90910: LD_INT 113
90912: PUSH
90913: LD_INT 114
90915: PUSH
90916: LD_INT 115
90918: PUSH
90919: LD_INT 116
90921: PUSH
90922: LD_INT 117
90924: PUSH
90925: LD_INT 118
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: ST_TO_ADDR
// if result then
90952: LD_VAR 0 2
90956: IFFALSE 91742
// begin normal :=  ;
90958: LD_ADDR_VAR 0 5
90962: PUSH
90963: LD_STRING 
90965: ST_TO_ADDR
// hardcore :=  ;
90966: LD_ADDR_VAR 0 6
90970: PUSH
90971: LD_STRING 
90973: ST_TO_ADDR
// active :=  ;
90974: LD_ADDR_VAR 0 7
90978: PUSH
90979: LD_STRING 
90981: ST_TO_ADDR
// for i = 1 to normalCounter do
90982: LD_ADDR_VAR 0 8
90986: PUSH
90987: DOUBLE
90988: LD_INT 1
90990: DEC
90991: ST_TO_ADDR
90992: LD_EXP 96
90996: PUSH
90997: FOR_TO
90998: IFFALSE 91099
// begin tmp := 0 ;
91000: LD_ADDR_VAR 0 3
91004: PUSH
91005: LD_STRING 0
91007: ST_TO_ADDR
// if result [ 1 ] then
91008: LD_VAR 0 2
91012: PUSH
91013: LD_INT 1
91015: ARRAY
91016: IFFALSE 91081
// if result [ 1 ] [ 1 ] = i then
91018: LD_VAR 0 2
91022: PUSH
91023: LD_INT 1
91025: ARRAY
91026: PUSH
91027: LD_INT 1
91029: ARRAY
91030: PUSH
91031: LD_VAR 0 8
91035: EQUAL
91036: IFFALSE 91081
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91038: LD_ADDR_VAR 0 2
91042: PUSH
91043: LD_VAR 0 2
91047: PPUSH
91048: LD_INT 1
91050: PPUSH
91051: LD_VAR 0 2
91055: PUSH
91056: LD_INT 1
91058: ARRAY
91059: PPUSH
91060: LD_INT 1
91062: PPUSH
91063: CALL_OW 3
91067: PPUSH
91068: CALL_OW 1
91072: ST_TO_ADDR
// tmp := 1 ;
91073: LD_ADDR_VAR 0 3
91077: PUSH
91078: LD_STRING 1
91080: ST_TO_ADDR
// end ; normal := normal & tmp ;
91081: LD_ADDR_VAR 0 5
91085: PUSH
91086: LD_VAR 0 5
91090: PUSH
91091: LD_VAR 0 3
91095: STR
91096: ST_TO_ADDR
// end ;
91097: GO 90997
91099: POP
91100: POP
// for i = 1 to hardcoreCounter do
91101: LD_ADDR_VAR 0 8
91105: PUSH
91106: DOUBLE
91107: LD_INT 1
91109: DEC
91110: ST_TO_ADDR
91111: LD_EXP 97
91115: PUSH
91116: FOR_TO
91117: IFFALSE 91222
// begin tmp := 0 ;
91119: LD_ADDR_VAR 0 3
91123: PUSH
91124: LD_STRING 0
91126: ST_TO_ADDR
// if result [ 2 ] then
91127: LD_VAR 0 2
91131: PUSH
91132: LD_INT 2
91134: ARRAY
91135: IFFALSE 91204
// if result [ 2 ] [ 1 ] = 100 + i then
91137: LD_VAR 0 2
91141: PUSH
91142: LD_INT 2
91144: ARRAY
91145: PUSH
91146: LD_INT 1
91148: ARRAY
91149: PUSH
91150: LD_INT 100
91152: PUSH
91153: LD_VAR 0 8
91157: PLUS
91158: EQUAL
91159: IFFALSE 91204
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91161: LD_ADDR_VAR 0 2
91165: PUSH
91166: LD_VAR 0 2
91170: PPUSH
91171: LD_INT 2
91173: PPUSH
91174: LD_VAR 0 2
91178: PUSH
91179: LD_INT 2
91181: ARRAY
91182: PPUSH
91183: LD_INT 1
91185: PPUSH
91186: CALL_OW 3
91190: PPUSH
91191: CALL_OW 1
91195: ST_TO_ADDR
// tmp := 1 ;
91196: LD_ADDR_VAR 0 3
91200: PUSH
91201: LD_STRING 1
91203: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91204: LD_ADDR_VAR 0 6
91208: PUSH
91209: LD_VAR 0 6
91213: PUSH
91214: LD_VAR 0 3
91218: STR
91219: ST_TO_ADDR
// end ;
91220: GO 91116
91222: POP
91223: POP
// if isGameLoad then
91224: LD_VAR 0 1
91228: IFFALSE 91703
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91230: LD_ADDR_VAR 0 4
91234: PUSH
91235: LD_EXP 100
91239: PUSH
91240: LD_EXP 99
91244: PUSH
91245: LD_EXP 101
91249: PUSH
91250: LD_EXP 98
91254: PUSH
91255: LD_EXP 102
91259: PUSH
91260: LD_EXP 103
91264: PUSH
91265: LD_EXP 104
91269: PUSH
91270: LD_EXP 105
91274: PUSH
91275: LD_EXP 106
91279: PUSH
91280: LD_EXP 107
91284: PUSH
91285: LD_EXP 108
91289: PUSH
91290: LD_EXP 109
91294: PUSH
91295: LD_EXP 110
91299: PUSH
91300: LD_EXP 111
91304: PUSH
91305: LD_EXP 119
91309: PUSH
91310: LD_EXP 120
91314: PUSH
91315: LD_EXP 121
91319: PUSH
91320: LD_EXP 122
91324: PUSH
91325: LD_EXP 124
91329: PUSH
91330: LD_EXP 125
91334: PUSH
91335: LD_EXP 126
91339: PUSH
91340: LD_EXP 129
91344: PUSH
91345: LD_EXP 131
91349: PUSH
91350: LD_EXP 132
91354: PUSH
91355: LD_EXP 133
91359: PUSH
91360: LD_EXP 135
91364: PUSH
91365: LD_EXP 136
91369: PUSH
91370: LD_EXP 139
91374: PUSH
91375: LD_EXP 140
91379: PUSH
91380: LD_EXP 141
91384: PUSH
91385: LD_EXP 142
91389: PUSH
91390: LD_EXP 143
91394: PUSH
91395: LD_EXP 144
91399: PUSH
91400: LD_EXP 145
91404: PUSH
91405: LD_EXP 146
91409: PUSH
91410: LD_EXP 147
91414: PUSH
91415: LD_EXP 112
91419: PUSH
91420: LD_EXP 113
91424: PUSH
91425: LD_EXP 116
91429: PUSH
91430: LD_EXP 117
91434: PUSH
91435: LD_EXP 118
91439: PUSH
91440: LD_EXP 114
91444: PUSH
91445: LD_EXP 115
91449: PUSH
91450: LD_EXP 123
91454: PUSH
91455: LD_EXP 127
91459: PUSH
91460: LD_EXP 128
91464: PUSH
91465: LD_EXP 130
91469: PUSH
91470: LD_EXP 134
91474: PUSH
91475: LD_EXP 137
91479: PUSH
91480: LD_EXP 138
91484: PUSH
91485: LD_EXP 148
91489: PUSH
91490: LD_EXP 149
91494: PUSH
91495: LD_EXP 150
91499: PUSH
91500: LD_EXP 151
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: ST_TO_ADDR
// tmp :=  ;
91561: LD_ADDR_VAR 0 3
91565: PUSH
91566: LD_STRING 
91568: ST_TO_ADDR
// for i = 1 to normalCounter do
91569: LD_ADDR_VAR 0 8
91573: PUSH
91574: DOUBLE
91575: LD_INT 1
91577: DEC
91578: ST_TO_ADDR
91579: LD_EXP 96
91583: PUSH
91584: FOR_TO
91585: IFFALSE 91621
// begin if flags [ i ] then
91587: LD_VAR 0 4
91591: PUSH
91592: LD_VAR 0 8
91596: ARRAY
91597: IFFALSE 91619
// tmp := tmp & i & ; ;
91599: LD_ADDR_VAR 0 3
91603: PUSH
91604: LD_VAR 0 3
91608: PUSH
91609: LD_VAR 0 8
91613: STR
91614: PUSH
91615: LD_STRING ;
91617: STR
91618: ST_TO_ADDR
// end ;
91619: GO 91584
91621: POP
91622: POP
// for i = 1 to hardcoreCounter do
91623: LD_ADDR_VAR 0 8
91627: PUSH
91628: DOUBLE
91629: LD_INT 1
91631: DEC
91632: ST_TO_ADDR
91633: LD_EXP 97
91637: PUSH
91638: FOR_TO
91639: IFFALSE 91685
// begin if flags [ normalCounter + i ] then
91641: LD_VAR 0 4
91645: PUSH
91646: LD_EXP 96
91650: PUSH
91651: LD_VAR 0 8
91655: PLUS
91656: ARRAY
91657: IFFALSE 91683
// tmp := tmp & ( 100 + i ) & ; ;
91659: LD_ADDR_VAR 0 3
91663: PUSH
91664: LD_VAR 0 3
91668: PUSH
91669: LD_INT 100
91671: PUSH
91672: LD_VAR 0 8
91676: PLUS
91677: STR
91678: PUSH
91679: LD_STRING ;
91681: STR
91682: ST_TO_ADDR
// end ;
91683: GO 91638
91685: POP
91686: POP
// if tmp then
91687: LD_VAR 0 3
91691: IFFALSE 91703
// active := tmp ;
91693: LD_ADDR_VAR 0 7
91697: PUSH
91698: LD_VAR 0 3
91702: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91703: LD_STRING getStreamItemsFromMission("
91705: PUSH
91706: LD_VAR 0 5
91710: STR
91711: PUSH
91712: LD_STRING ","
91714: STR
91715: PUSH
91716: LD_VAR 0 6
91720: STR
91721: PUSH
91722: LD_STRING ","
91724: STR
91725: PUSH
91726: LD_VAR 0 7
91730: STR
91731: PUSH
91732: LD_STRING ")
91734: STR
91735: PPUSH
91736: CALL_OW 559
// end else
91740: GO 91749
// ToLua ( getStreamItemsFromMission("","","") ) ;
91742: LD_STRING getStreamItemsFromMission("","","")
91744: PPUSH
91745: CALL_OW 559
// end ;
91749: LD_VAR 0 2
91753: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91754: LD_EXP 95
91758: PUSH
91759: LD_EXP 100
91763: AND
91764: IFFALSE 91888
91766: GO 91768
91768: DISABLE
91769: LD_INT 0
91771: PPUSH
91772: PPUSH
// begin enable ;
91773: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91774: LD_ADDR_VAR 0 2
91778: PUSH
91779: LD_INT 22
91781: PUSH
91782: LD_OWVAR 2
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: PUSH
91791: LD_INT 2
91793: PUSH
91794: LD_INT 34
91796: PUSH
91797: LD_INT 7
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 34
91806: PUSH
91807: LD_INT 45
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 34
91816: PUSH
91817: LD_INT 28
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 34
91826: PUSH
91827: LD_INT 47
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PPUSH
91845: CALL_OW 69
91849: ST_TO_ADDR
// if not tmp then
91850: LD_VAR 0 2
91854: NOT
91855: IFFALSE 91859
// exit ;
91857: GO 91888
// for i in tmp do
91859: LD_ADDR_VAR 0 1
91863: PUSH
91864: LD_VAR 0 2
91868: PUSH
91869: FOR_IN
91870: IFFALSE 91886
// begin SetLives ( i , 0 ) ;
91872: LD_VAR 0 1
91876: PPUSH
91877: LD_INT 0
91879: PPUSH
91880: CALL_OW 234
// end ;
91884: GO 91869
91886: POP
91887: POP
// end ;
91888: PPOPN 2
91890: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91891: LD_EXP 95
91895: PUSH
91896: LD_EXP 101
91900: AND
91901: IFFALSE 91985
91903: GO 91905
91905: DISABLE
91906: LD_INT 0
91908: PPUSH
91909: PPUSH
// begin enable ;
91910: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91911: LD_ADDR_VAR 0 2
91915: PUSH
91916: LD_INT 22
91918: PUSH
91919: LD_OWVAR 2
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 32
91930: PUSH
91931: LD_INT 3
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PPUSH
91942: CALL_OW 69
91946: ST_TO_ADDR
// if not tmp then
91947: LD_VAR 0 2
91951: NOT
91952: IFFALSE 91956
// exit ;
91954: GO 91985
// for i in tmp do
91956: LD_ADDR_VAR 0 1
91960: PUSH
91961: LD_VAR 0 2
91965: PUSH
91966: FOR_IN
91967: IFFALSE 91983
// begin SetLives ( i , 0 ) ;
91969: LD_VAR 0 1
91973: PPUSH
91974: LD_INT 0
91976: PPUSH
91977: CALL_OW 234
// end ;
91981: GO 91966
91983: POP
91984: POP
// end ;
91985: PPOPN 2
91987: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91988: LD_EXP 95
91992: PUSH
91993: LD_EXP 98
91997: AND
91998: IFFALSE 92091
92000: GO 92002
92002: DISABLE
92003: LD_INT 0
92005: PPUSH
// begin enable ;
92006: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92007: LD_ADDR_VAR 0 1
92011: PUSH
92012: LD_INT 22
92014: PUSH
92015: LD_OWVAR 2
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 2
92026: PUSH
92027: LD_INT 25
92029: PUSH
92030: LD_INT 5
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 25
92039: PUSH
92040: LD_INT 9
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 25
92049: PUSH
92050: LD_INT 8
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: EMPTY
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PPUSH
92067: CALL_OW 69
92071: PUSH
92072: FOR_IN
92073: IFFALSE 92089
// begin SetClass ( i , 1 ) ;
92075: LD_VAR 0 1
92079: PPUSH
92080: LD_INT 1
92082: PPUSH
92083: CALL_OW 336
// end ;
92087: GO 92072
92089: POP
92090: POP
// end ;
92091: PPOPN 1
92093: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92094: LD_EXP 95
92098: PUSH
92099: LD_EXP 99
92103: AND
92104: PUSH
92105: LD_OWVAR 65
92109: PUSH
92110: LD_INT 7
92112: LESS
92113: AND
92114: IFFALSE 92128
92116: GO 92118
92118: DISABLE
// begin enable ;
92119: ENABLE
// game_speed := 7 ;
92120: LD_ADDR_OWVAR 65
92124: PUSH
92125: LD_INT 7
92127: ST_TO_ADDR
// end ;
92128: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92129: LD_EXP 95
92133: PUSH
92134: LD_EXP 102
92138: AND
92139: IFFALSE 92341
92141: GO 92143
92143: DISABLE
92144: LD_INT 0
92146: PPUSH
92147: PPUSH
92148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92149: LD_ADDR_VAR 0 3
92153: PUSH
92154: LD_INT 81
92156: PUSH
92157: LD_OWVAR 2
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PUSH
92166: LD_INT 21
92168: PUSH
92169: LD_INT 1
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PPUSH
92180: CALL_OW 69
92184: ST_TO_ADDR
// if not tmp then
92185: LD_VAR 0 3
92189: NOT
92190: IFFALSE 92194
// exit ;
92192: GO 92341
// if tmp > 5 then
92194: LD_VAR 0 3
92198: PUSH
92199: LD_INT 5
92201: GREATER
92202: IFFALSE 92214
// k := 5 else
92204: LD_ADDR_VAR 0 2
92208: PUSH
92209: LD_INT 5
92211: ST_TO_ADDR
92212: GO 92224
// k := tmp ;
92214: LD_ADDR_VAR 0 2
92218: PUSH
92219: LD_VAR 0 3
92223: ST_TO_ADDR
// for i := 1 to k do
92224: LD_ADDR_VAR 0 1
92228: PUSH
92229: DOUBLE
92230: LD_INT 1
92232: DEC
92233: ST_TO_ADDR
92234: LD_VAR 0 2
92238: PUSH
92239: FOR_TO
92240: IFFALSE 92339
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92242: LD_VAR 0 3
92246: PUSH
92247: LD_VAR 0 1
92251: ARRAY
92252: PPUSH
92253: LD_VAR 0 1
92257: PUSH
92258: LD_INT 4
92260: MOD
92261: PUSH
92262: LD_INT 1
92264: PLUS
92265: PPUSH
92266: CALL_OW 259
92270: PUSH
92271: LD_INT 10
92273: LESS
92274: IFFALSE 92337
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92276: LD_VAR 0 3
92280: PUSH
92281: LD_VAR 0 1
92285: ARRAY
92286: PPUSH
92287: LD_VAR 0 1
92291: PUSH
92292: LD_INT 4
92294: MOD
92295: PUSH
92296: LD_INT 1
92298: PLUS
92299: PPUSH
92300: LD_VAR 0 3
92304: PUSH
92305: LD_VAR 0 1
92309: ARRAY
92310: PPUSH
92311: LD_VAR 0 1
92315: PUSH
92316: LD_INT 4
92318: MOD
92319: PUSH
92320: LD_INT 1
92322: PLUS
92323: PPUSH
92324: CALL_OW 259
92328: PUSH
92329: LD_INT 1
92331: PLUS
92332: PPUSH
92333: CALL_OW 237
92337: GO 92239
92339: POP
92340: POP
// end ;
92341: PPOPN 3
92343: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92344: LD_EXP 95
92348: PUSH
92349: LD_EXP 103
92353: AND
92354: IFFALSE 92374
92356: GO 92358
92358: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92359: LD_INT 4
92361: PPUSH
92362: LD_OWVAR 2
92366: PPUSH
92367: LD_INT 0
92369: PPUSH
92370: CALL_OW 324
92374: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92375: LD_EXP 95
92379: PUSH
92380: LD_EXP 132
92384: AND
92385: IFFALSE 92405
92387: GO 92389
92389: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92390: LD_INT 19
92392: PPUSH
92393: LD_OWVAR 2
92397: PPUSH
92398: LD_INT 0
92400: PPUSH
92401: CALL_OW 324
92405: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92406: LD_EXP 95
92410: PUSH
92411: LD_EXP 104
92415: AND
92416: IFFALSE 92518
92418: GO 92420
92420: DISABLE
92421: LD_INT 0
92423: PPUSH
92424: PPUSH
// begin enable ;
92425: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92426: LD_ADDR_VAR 0 2
92430: PUSH
92431: LD_INT 22
92433: PUSH
92434: LD_OWVAR 2
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 2
92445: PUSH
92446: LD_INT 34
92448: PUSH
92449: LD_INT 11
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 34
92458: PUSH
92459: LD_INT 30
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: LIST
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PPUSH
92475: CALL_OW 69
92479: ST_TO_ADDR
// if not tmp then
92480: LD_VAR 0 2
92484: NOT
92485: IFFALSE 92489
// exit ;
92487: GO 92518
// for i in tmp do
92489: LD_ADDR_VAR 0 1
92493: PUSH
92494: LD_VAR 0 2
92498: PUSH
92499: FOR_IN
92500: IFFALSE 92516
// begin SetLives ( i , 0 ) ;
92502: LD_VAR 0 1
92506: PPUSH
92507: LD_INT 0
92509: PPUSH
92510: CALL_OW 234
// end ;
92514: GO 92499
92516: POP
92517: POP
// end ;
92518: PPOPN 2
92520: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92521: LD_EXP 95
92525: PUSH
92526: LD_EXP 105
92530: AND
92531: IFFALSE 92551
92533: GO 92535
92535: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92536: LD_INT 32
92538: PPUSH
92539: LD_OWVAR 2
92543: PPUSH
92544: LD_INT 0
92546: PPUSH
92547: CALL_OW 324
92551: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92552: LD_EXP 95
92556: PUSH
92557: LD_EXP 106
92561: AND
92562: IFFALSE 92743
92564: GO 92566
92566: DISABLE
92567: LD_INT 0
92569: PPUSH
92570: PPUSH
92571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92572: LD_ADDR_VAR 0 2
92576: PUSH
92577: LD_INT 22
92579: PUSH
92580: LD_OWVAR 2
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: LD_INT 33
92591: PUSH
92592: LD_INT 3
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PPUSH
92603: CALL_OW 69
92607: ST_TO_ADDR
// if not tmp then
92608: LD_VAR 0 2
92612: NOT
92613: IFFALSE 92617
// exit ;
92615: GO 92743
// side := 0 ;
92617: LD_ADDR_VAR 0 3
92621: PUSH
92622: LD_INT 0
92624: ST_TO_ADDR
// for i := 1 to 8 do
92625: LD_ADDR_VAR 0 1
92629: PUSH
92630: DOUBLE
92631: LD_INT 1
92633: DEC
92634: ST_TO_ADDR
92635: LD_INT 8
92637: PUSH
92638: FOR_TO
92639: IFFALSE 92687
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92641: LD_OWVAR 2
92645: PUSH
92646: LD_VAR 0 1
92650: NONEQUAL
92651: PUSH
92652: LD_OWVAR 2
92656: PPUSH
92657: LD_VAR 0 1
92661: PPUSH
92662: CALL_OW 81
92666: PUSH
92667: LD_INT 2
92669: EQUAL
92670: AND
92671: IFFALSE 92685
// begin side := i ;
92673: LD_ADDR_VAR 0 3
92677: PUSH
92678: LD_VAR 0 1
92682: ST_TO_ADDR
// break ;
92683: GO 92687
// end ;
92685: GO 92638
92687: POP
92688: POP
// if not side then
92689: LD_VAR 0 3
92693: NOT
92694: IFFALSE 92698
// exit ;
92696: GO 92743
// for i := 1 to tmp do
92698: LD_ADDR_VAR 0 1
92702: PUSH
92703: DOUBLE
92704: LD_INT 1
92706: DEC
92707: ST_TO_ADDR
92708: LD_VAR 0 2
92712: PUSH
92713: FOR_TO
92714: IFFALSE 92741
// if Prob ( 60 ) then
92716: LD_INT 60
92718: PPUSH
92719: CALL_OW 13
92723: IFFALSE 92739
// SetSide ( i , side ) ;
92725: LD_VAR 0 1
92729: PPUSH
92730: LD_VAR 0 3
92734: PPUSH
92735: CALL_OW 235
92739: GO 92713
92741: POP
92742: POP
// end ;
92743: PPOPN 3
92745: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92746: LD_EXP 95
92750: PUSH
92751: LD_EXP 108
92755: AND
92756: IFFALSE 92875
92758: GO 92760
92760: DISABLE
92761: LD_INT 0
92763: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92764: LD_ADDR_VAR 0 1
92768: PUSH
92769: LD_INT 22
92771: PUSH
92772: LD_OWVAR 2
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 21
92783: PUSH
92784: LD_INT 1
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 3
92793: PUSH
92794: LD_INT 23
92796: PUSH
92797: LD_INT 0
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: LIST
92812: PPUSH
92813: CALL_OW 69
92817: PUSH
92818: FOR_IN
92819: IFFALSE 92873
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92821: LD_VAR 0 1
92825: PPUSH
92826: CALL_OW 257
92830: PUSH
92831: LD_INT 1
92833: PUSH
92834: LD_INT 2
92836: PUSH
92837: LD_INT 3
92839: PUSH
92840: LD_INT 4
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: IN
92849: IFFALSE 92871
// SetClass ( un , rand ( 1 , 4 ) ) ;
92851: LD_VAR 0 1
92855: PPUSH
92856: LD_INT 1
92858: PPUSH
92859: LD_INT 4
92861: PPUSH
92862: CALL_OW 12
92866: PPUSH
92867: CALL_OW 336
92871: GO 92818
92873: POP
92874: POP
// end ;
92875: PPOPN 1
92877: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92878: LD_EXP 95
92882: PUSH
92883: LD_EXP 107
92887: AND
92888: IFFALSE 92967
92890: GO 92892
92892: DISABLE
92893: LD_INT 0
92895: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92896: LD_ADDR_VAR 0 1
92900: PUSH
92901: LD_INT 22
92903: PUSH
92904: LD_OWVAR 2
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 21
92915: PUSH
92916: LD_INT 3
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PPUSH
92927: CALL_OW 69
92931: ST_TO_ADDR
// if not tmp then
92932: LD_VAR 0 1
92936: NOT
92937: IFFALSE 92941
// exit ;
92939: GO 92967
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92941: LD_VAR 0 1
92945: PUSH
92946: LD_INT 1
92948: PPUSH
92949: LD_VAR 0 1
92953: PPUSH
92954: CALL_OW 12
92958: ARRAY
92959: PPUSH
92960: LD_INT 100
92962: PPUSH
92963: CALL_OW 234
// end ;
92967: PPOPN 1
92969: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92970: LD_EXP 95
92974: PUSH
92975: LD_EXP 109
92979: AND
92980: IFFALSE 93078
92982: GO 92984
92984: DISABLE
92985: LD_INT 0
92987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92988: LD_ADDR_VAR 0 1
92992: PUSH
92993: LD_INT 22
92995: PUSH
92996: LD_OWVAR 2
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 21
93007: PUSH
93008: LD_INT 1
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PPUSH
93019: CALL_OW 69
93023: ST_TO_ADDR
// if not tmp then
93024: LD_VAR 0 1
93028: NOT
93029: IFFALSE 93033
// exit ;
93031: GO 93078
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93033: LD_VAR 0 1
93037: PUSH
93038: LD_INT 1
93040: PPUSH
93041: LD_VAR 0 1
93045: PPUSH
93046: CALL_OW 12
93050: ARRAY
93051: PPUSH
93052: LD_INT 1
93054: PPUSH
93055: LD_INT 4
93057: PPUSH
93058: CALL_OW 12
93062: PPUSH
93063: LD_INT 3000
93065: PPUSH
93066: LD_INT 9000
93068: PPUSH
93069: CALL_OW 12
93073: PPUSH
93074: CALL_OW 492
// end ;
93078: PPOPN 1
93080: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93081: LD_EXP 95
93085: PUSH
93086: LD_EXP 110
93090: AND
93091: IFFALSE 93111
93093: GO 93095
93095: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93096: LD_INT 1
93098: PPUSH
93099: LD_OWVAR 2
93103: PPUSH
93104: LD_INT 0
93106: PPUSH
93107: CALL_OW 324
93111: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93112: LD_EXP 95
93116: PUSH
93117: LD_EXP 111
93121: AND
93122: IFFALSE 93205
93124: GO 93126
93126: DISABLE
93127: LD_INT 0
93129: PPUSH
93130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93131: LD_ADDR_VAR 0 2
93135: PUSH
93136: LD_INT 22
93138: PUSH
93139: LD_OWVAR 2
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 21
93150: PUSH
93151: LD_INT 3
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PPUSH
93162: CALL_OW 69
93166: ST_TO_ADDR
// if not tmp then
93167: LD_VAR 0 2
93171: NOT
93172: IFFALSE 93176
// exit ;
93174: GO 93205
// for i in tmp do
93176: LD_ADDR_VAR 0 1
93180: PUSH
93181: LD_VAR 0 2
93185: PUSH
93186: FOR_IN
93187: IFFALSE 93203
// SetBLevel ( i , 10 ) ;
93189: LD_VAR 0 1
93193: PPUSH
93194: LD_INT 10
93196: PPUSH
93197: CALL_OW 241
93201: GO 93186
93203: POP
93204: POP
// end ;
93205: PPOPN 2
93207: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93208: LD_EXP 95
93212: PUSH
93213: LD_EXP 112
93217: AND
93218: IFFALSE 93329
93220: GO 93222
93222: DISABLE
93223: LD_INT 0
93225: PPUSH
93226: PPUSH
93227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93228: LD_ADDR_VAR 0 3
93232: PUSH
93233: LD_INT 22
93235: PUSH
93236: LD_OWVAR 2
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 25
93247: PUSH
93248: LD_INT 1
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PPUSH
93259: CALL_OW 69
93263: ST_TO_ADDR
// if not tmp then
93264: LD_VAR 0 3
93268: NOT
93269: IFFALSE 93273
// exit ;
93271: GO 93329
// un := tmp [ rand ( 1 , tmp ) ] ;
93273: LD_ADDR_VAR 0 2
93277: PUSH
93278: LD_VAR 0 3
93282: PUSH
93283: LD_INT 1
93285: PPUSH
93286: LD_VAR 0 3
93290: PPUSH
93291: CALL_OW 12
93295: ARRAY
93296: ST_TO_ADDR
// if Crawls ( un ) then
93297: LD_VAR 0 2
93301: PPUSH
93302: CALL_OW 318
93306: IFFALSE 93317
// ComWalk ( un ) ;
93308: LD_VAR 0 2
93312: PPUSH
93313: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93317: LD_VAR 0 2
93321: PPUSH
93322: LD_INT 5
93324: PPUSH
93325: CALL_OW 336
// end ;
93329: PPOPN 3
93331: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93332: LD_EXP 95
93336: PUSH
93337: LD_EXP 113
93341: AND
93342: PUSH
93343: LD_OWVAR 67
93347: PUSH
93348: LD_INT 4
93350: LESS
93351: AND
93352: IFFALSE 93371
93354: GO 93356
93356: DISABLE
// begin Difficulty := Difficulty + 1 ;
93357: LD_ADDR_OWVAR 67
93361: PUSH
93362: LD_OWVAR 67
93366: PUSH
93367: LD_INT 1
93369: PLUS
93370: ST_TO_ADDR
// end ;
93371: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93372: LD_EXP 95
93376: PUSH
93377: LD_EXP 114
93381: AND
93382: IFFALSE 93485
93384: GO 93386
93386: DISABLE
93387: LD_INT 0
93389: PPUSH
// begin for i := 1 to 5 do
93390: LD_ADDR_VAR 0 1
93394: PUSH
93395: DOUBLE
93396: LD_INT 1
93398: DEC
93399: ST_TO_ADDR
93400: LD_INT 5
93402: PUSH
93403: FOR_TO
93404: IFFALSE 93483
// begin uc_nation := nation_nature ;
93406: LD_ADDR_OWVAR 21
93410: PUSH
93411: LD_INT 0
93413: ST_TO_ADDR
// uc_side := 0 ;
93414: LD_ADDR_OWVAR 20
93418: PUSH
93419: LD_INT 0
93421: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93422: LD_ADDR_OWVAR 29
93426: PUSH
93427: LD_INT 12
93429: PUSH
93430: LD_INT 12
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: ST_TO_ADDR
// hc_agressivity := 20 ;
93437: LD_ADDR_OWVAR 35
93441: PUSH
93442: LD_INT 20
93444: ST_TO_ADDR
// hc_class := class_tiger ;
93445: LD_ADDR_OWVAR 28
93449: PUSH
93450: LD_INT 14
93452: ST_TO_ADDR
// hc_gallery :=  ;
93453: LD_ADDR_OWVAR 33
93457: PUSH
93458: LD_STRING 
93460: ST_TO_ADDR
// hc_name :=  ;
93461: LD_ADDR_OWVAR 26
93465: PUSH
93466: LD_STRING 
93468: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93469: CALL_OW 44
93473: PPUSH
93474: LD_INT 0
93476: PPUSH
93477: CALL_OW 51
// end ;
93481: GO 93403
93483: POP
93484: POP
// end ;
93485: PPOPN 1
93487: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93488: LD_EXP 95
93492: PUSH
93493: LD_EXP 115
93497: AND
93498: IFFALSE 93507
93500: GO 93502
93502: DISABLE
// StreamSibBomb ;
93503: CALL 93508 0 0
93507: END
// export function StreamSibBomb ; var i , x , y ; begin
93508: LD_INT 0
93510: PPUSH
93511: PPUSH
93512: PPUSH
93513: PPUSH
// result := false ;
93514: LD_ADDR_VAR 0 1
93518: PUSH
93519: LD_INT 0
93521: ST_TO_ADDR
// for i := 1 to 16 do
93522: LD_ADDR_VAR 0 2
93526: PUSH
93527: DOUBLE
93528: LD_INT 1
93530: DEC
93531: ST_TO_ADDR
93532: LD_INT 16
93534: PUSH
93535: FOR_TO
93536: IFFALSE 93735
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93538: LD_ADDR_VAR 0 3
93542: PUSH
93543: LD_INT 10
93545: PUSH
93546: LD_INT 20
93548: PUSH
93549: LD_INT 30
93551: PUSH
93552: LD_INT 40
93554: PUSH
93555: LD_INT 50
93557: PUSH
93558: LD_INT 60
93560: PUSH
93561: LD_INT 70
93563: PUSH
93564: LD_INT 80
93566: PUSH
93567: LD_INT 90
93569: PUSH
93570: LD_INT 100
93572: PUSH
93573: LD_INT 110
93575: PUSH
93576: LD_INT 120
93578: PUSH
93579: LD_INT 130
93581: PUSH
93582: LD_INT 140
93584: PUSH
93585: LD_INT 150
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 1
93607: PPUSH
93608: LD_INT 15
93610: PPUSH
93611: CALL_OW 12
93615: ARRAY
93616: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93617: LD_ADDR_VAR 0 4
93621: PUSH
93622: LD_INT 10
93624: PUSH
93625: LD_INT 20
93627: PUSH
93628: LD_INT 30
93630: PUSH
93631: LD_INT 40
93633: PUSH
93634: LD_INT 50
93636: PUSH
93637: LD_INT 60
93639: PUSH
93640: LD_INT 70
93642: PUSH
93643: LD_INT 80
93645: PUSH
93646: LD_INT 90
93648: PUSH
93649: LD_INT 100
93651: PUSH
93652: LD_INT 110
93654: PUSH
93655: LD_INT 120
93657: PUSH
93658: LD_INT 130
93660: PUSH
93661: LD_INT 140
93663: PUSH
93664: LD_INT 150
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 1
93686: PPUSH
93687: LD_INT 15
93689: PPUSH
93690: CALL_OW 12
93694: ARRAY
93695: ST_TO_ADDR
// if ValidHex ( x , y ) then
93696: LD_VAR 0 3
93700: PPUSH
93701: LD_VAR 0 4
93705: PPUSH
93706: CALL_OW 488
93710: IFFALSE 93733
// begin result := [ x , y ] ;
93712: LD_ADDR_VAR 0 1
93716: PUSH
93717: LD_VAR 0 3
93721: PUSH
93722: LD_VAR 0 4
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: ST_TO_ADDR
// break ;
93731: GO 93735
// end ; end ;
93733: GO 93535
93735: POP
93736: POP
// if result then
93737: LD_VAR 0 1
93741: IFFALSE 93801
// begin ToLua ( playSibBomb() ) ;
93743: LD_STRING playSibBomb()
93745: PPUSH
93746: CALL_OW 559
// wait ( 0 0$14 ) ;
93750: LD_INT 490
93752: PPUSH
93753: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93757: LD_VAR 0 1
93761: PUSH
93762: LD_INT 1
93764: ARRAY
93765: PPUSH
93766: LD_VAR 0 1
93770: PUSH
93771: LD_INT 2
93773: ARRAY
93774: PPUSH
93775: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93779: LD_VAR 0 1
93783: PUSH
93784: LD_INT 1
93786: ARRAY
93787: PPUSH
93788: LD_VAR 0 1
93792: PUSH
93793: LD_INT 2
93795: ARRAY
93796: PPUSH
93797: CALL_OW 429
// end ; end ;
93801: LD_VAR 0 1
93805: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93806: LD_EXP 95
93810: PUSH
93811: LD_EXP 117
93815: AND
93816: IFFALSE 93828
93818: GO 93820
93820: DISABLE
// YouLost (  ) ;
93821: LD_STRING 
93823: PPUSH
93824: CALL_OW 104
93828: END
// every 0 0$1 trigger StreamModeActive and sFog do
93829: LD_EXP 95
93833: PUSH
93834: LD_EXP 116
93838: AND
93839: IFFALSE 93853
93841: GO 93843
93843: DISABLE
// FogOff ( your_side ) ;
93844: LD_OWVAR 2
93848: PPUSH
93849: CALL_OW 344
93853: END
// every 0 0$1 trigger StreamModeActive and sSun do
93854: LD_EXP 95
93858: PUSH
93859: LD_EXP 118
93863: AND
93864: IFFALSE 93892
93866: GO 93868
93868: DISABLE
// begin solar_recharge_percent := 0 ;
93869: LD_ADDR_OWVAR 79
93873: PUSH
93874: LD_INT 0
93876: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93877: LD_INT 10500
93879: PPUSH
93880: CALL_OW 67
// solar_recharge_percent := 100 ;
93884: LD_ADDR_OWVAR 79
93888: PUSH
93889: LD_INT 100
93891: ST_TO_ADDR
// end ;
93892: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93893: LD_EXP 95
93897: PUSH
93898: LD_EXP 119
93902: AND
93903: IFFALSE 94142
93905: GO 93907
93907: DISABLE
93908: LD_INT 0
93910: PPUSH
93911: PPUSH
93912: PPUSH
// begin tmp := [ ] ;
93913: LD_ADDR_VAR 0 3
93917: PUSH
93918: EMPTY
93919: ST_TO_ADDR
// for i := 1 to 6 do
93920: LD_ADDR_VAR 0 1
93924: PUSH
93925: DOUBLE
93926: LD_INT 1
93928: DEC
93929: ST_TO_ADDR
93930: LD_INT 6
93932: PUSH
93933: FOR_TO
93934: IFFALSE 94039
// begin uc_nation := nation_nature ;
93936: LD_ADDR_OWVAR 21
93940: PUSH
93941: LD_INT 0
93943: ST_TO_ADDR
// uc_side := 0 ;
93944: LD_ADDR_OWVAR 20
93948: PUSH
93949: LD_INT 0
93951: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93952: LD_ADDR_OWVAR 29
93956: PUSH
93957: LD_INT 12
93959: PUSH
93960: LD_INT 12
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: ST_TO_ADDR
// hc_agressivity := 20 ;
93967: LD_ADDR_OWVAR 35
93971: PUSH
93972: LD_INT 20
93974: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93975: LD_ADDR_OWVAR 28
93979: PUSH
93980: LD_INT 17
93982: ST_TO_ADDR
// hc_gallery :=  ;
93983: LD_ADDR_OWVAR 33
93987: PUSH
93988: LD_STRING 
93990: ST_TO_ADDR
// hc_name :=  ;
93991: LD_ADDR_OWVAR 26
93995: PUSH
93996: LD_STRING 
93998: ST_TO_ADDR
// un := CreateHuman ;
93999: LD_ADDR_VAR 0 2
94003: PUSH
94004: CALL_OW 44
94008: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94009: LD_VAR 0 2
94013: PPUSH
94014: LD_INT 1
94016: PPUSH
94017: CALL_OW 51
// tmp := tmp ^ un ;
94021: LD_ADDR_VAR 0 3
94025: PUSH
94026: LD_VAR 0 3
94030: PUSH
94031: LD_VAR 0 2
94035: ADD
94036: ST_TO_ADDR
// end ;
94037: GO 93933
94039: POP
94040: POP
// repeat wait ( 0 0$1 ) ;
94041: LD_INT 35
94043: PPUSH
94044: CALL_OW 67
// for un in tmp do
94048: LD_ADDR_VAR 0 2
94052: PUSH
94053: LD_VAR 0 3
94057: PUSH
94058: FOR_IN
94059: IFFALSE 94133
// begin if IsDead ( un ) then
94061: LD_VAR 0 2
94065: PPUSH
94066: CALL_OW 301
94070: IFFALSE 94090
// begin tmp := tmp diff un ;
94072: LD_ADDR_VAR 0 3
94076: PUSH
94077: LD_VAR 0 3
94081: PUSH
94082: LD_VAR 0 2
94086: DIFF
94087: ST_TO_ADDR
// continue ;
94088: GO 94058
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94090: LD_VAR 0 2
94094: PPUSH
94095: LD_INT 3
94097: PUSH
94098: LD_INT 22
94100: PUSH
94101: LD_INT 0
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PPUSH
94112: CALL_OW 69
94116: PPUSH
94117: LD_VAR 0 2
94121: PPUSH
94122: CALL_OW 74
94126: PPUSH
94127: CALL_OW 115
// end ;
94131: GO 94058
94133: POP
94134: POP
// until not tmp ;
94135: LD_VAR 0 3
94139: NOT
94140: IFFALSE 94041
// end ;
94142: PPOPN 3
94144: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94145: LD_EXP 95
94149: PUSH
94150: LD_EXP 120
94154: AND
94155: IFFALSE 94209
94157: GO 94159
94159: DISABLE
// begin ToLua ( displayTroll(); ) ;
94160: LD_STRING displayTroll();
94162: PPUSH
94163: CALL_OW 559
// wait ( 3 3$00 ) ;
94167: LD_INT 6300
94169: PPUSH
94170: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94174: LD_STRING hideTroll();
94176: PPUSH
94177: CALL_OW 559
// wait ( 1 1$00 ) ;
94181: LD_INT 2100
94183: PPUSH
94184: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94188: LD_STRING displayTroll();
94190: PPUSH
94191: CALL_OW 559
// wait ( 1 1$00 ) ;
94195: LD_INT 2100
94197: PPUSH
94198: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94202: LD_STRING hideTroll();
94204: PPUSH
94205: CALL_OW 559
// end ;
94209: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94210: LD_EXP 95
94214: PUSH
94215: LD_EXP 121
94219: AND
94220: IFFALSE 94283
94222: GO 94224
94224: DISABLE
94225: LD_INT 0
94227: PPUSH
// begin p := 0 ;
94228: LD_ADDR_VAR 0 1
94232: PUSH
94233: LD_INT 0
94235: ST_TO_ADDR
// repeat game_speed := 1 ;
94236: LD_ADDR_OWVAR 65
94240: PUSH
94241: LD_INT 1
94243: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94244: LD_INT 35
94246: PPUSH
94247: CALL_OW 67
// p := p + 1 ;
94251: LD_ADDR_VAR 0 1
94255: PUSH
94256: LD_VAR 0 1
94260: PUSH
94261: LD_INT 1
94263: PLUS
94264: ST_TO_ADDR
// until p >= 60 ;
94265: LD_VAR 0 1
94269: PUSH
94270: LD_INT 60
94272: GREATEREQUAL
94273: IFFALSE 94236
// game_speed := 4 ;
94275: LD_ADDR_OWVAR 65
94279: PUSH
94280: LD_INT 4
94282: ST_TO_ADDR
// end ;
94283: PPOPN 1
94285: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94286: LD_EXP 95
94290: PUSH
94291: LD_EXP 122
94295: AND
94296: IFFALSE 94442
94298: GO 94300
94300: DISABLE
94301: LD_INT 0
94303: PPUSH
94304: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94305: LD_ADDR_VAR 0 1
94309: PUSH
94310: LD_INT 22
94312: PUSH
94313: LD_OWVAR 2
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 2
94324: PUSH
94325: LD_INT 30
94327: PUSH
94328: LD_INT 0
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 30
94337: PUSH
94338: LD_INT 1
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: LIST
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PPUSH
94354: CALL_OW 69
94358: ST_TO_ADDR
// if not depot then
94359: LD_VAR 0 1
94363: NOT
94364: IFFALSE 94368
// exit ;
94366: GO 94442
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94368: LD_ADDR_VAR 0 2
94372: PUSH
94373: LD_VAR 0 1
94377: PUSH
94378: LD_INT 1
94380: PPUSH
94381: LD_VAR 0 1
94385: PPUSH
94386: CALL_OW 12
94390: ARRAY
94391: PPUSH
94392: CALL_OW 274
94396: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94397: LD_VAR 0 2
94401: PPUSH
94402: LD_INT 1
94404: PPUSH
94405: LD_INT 0
94407: PPUSH
94408: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94412: LD_VAR 0 2
94416: PPUSH
94417: LD_INT 2
94419: PPUSH
94420: LD_INT 0
94422: PPUSH
94423: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94427: LD_VAR 0 2
94431: PPUSH
94432: LD_INT 3
94434: PPUSH
94435: LD_INT 0
94437: PPUSH
94438: CALL_OW 277
// end ;
94442: PPOPN 2
94444: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94445: LD_EXP 95
94449: PUSH
94450: LD_EXP 123
94454: AND
94455: IFFALSE 94552
94457: GO 94459
94459: DISABLE
94460: LD_INT 0
94462: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94463: LD_ADDR_VAR 0 1
94467: PUSH
94468: LD_INT 22
94470: PUSH
94471: LD_OWVAR 2
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 21
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 3
94492: PUSH
94493: LD_INT 23
94495: PUSH
94496: LD_INT 0
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: EMPTY
94508: LIST
94509: LIST
94510: LIST
94511: PPUSH
94512: CALL_OW 69
94516: ST_TO_ADDR
// if not tmp then
94517: LD_VAR 0 1
94521: NOT
94522: IFFALSE 94526
// exit ;
94524: GO 94552
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94526: LD_VAR 0 1
94530: PUSH
94531: LD_INT 1
94533: PPUSH
94534: LD_VAR 0 1
94538: PPUSH
94539: CALL_OW 12
94543: ARRAY
94544: PPUSH
94545: LD_INT 200
94547: PPUSH
94548: CALL_OW 234
// end ;
94552: PPOPN 1
94554: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94555: LD_EXP 95
94559: PUSH
94560: LD_EXP 124
94564: AND
94565: IFFALSE 94644
94567: GO 94569
94569: DISABLE
94570: LD_INT 0
94572: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94573: LD_ADDR_VAR 0 1
94577: PUSH
94578: LD_INT 22
94580: PUSH
94581: LD_OWVAR 2
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: LD_INT 21
94592: PUSH
94593: LD_INT 2
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PPUSH
94604: CALL_OW 69
94608: ST_TO_ADDR
// if not tmp then
94609: LD_VAR 0 1
94613: NOT
94614: IFFALSE 94618
// exit ;
94616: GO 94644
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94618: LD_VAR 0 1
94622: PUSH
94623: LD_INT 1
94625: PPUSH
94626: LD_VAR 0 1
94630: PPUSH
94631: CALL_OW 12
94635: ARRAY
94636: PPUSH
94637: LD_INT 60
94639: PPUSH
94640: CALL_OW 234
// end ;
94644: PPOPN 1
94646: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94647: LD_EXP 95
94651: PUSH
94652: LD_EXP 125
94656: AND
94657: IFFALSE 94756
94659: GO 94661
94661: DISABLE
94662: LD_INT 0
94664: PPUSH
94665: PPUSH
// begin enable ;
94666: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94667: LD_ADDR_VAR 0 1
94671: PUSH
94672: LD_INT 22
94674: PUSH
94675: LD_OWVAR 2
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 61
94686: PUSH
94687: EMPTY
94688: LIST
94689: PUSH
94690: LD_INT 33
94692: PUSH
94693: LD_INT 2
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: LIST
94704: PPUSH
94705: CALL_OW 69
94709: ST_TO_ADDR
// if not tmp then
94710: LD_VAR 0 1
94714: NOT
94715: IFFALSE 94719
// exit ;
94717: GO 94756
// for i in tmp do
94719: LD_ADDR_VAR 0 2
94723: PUSH
94724: LD_VAR 0 1
94728: PUSH
94729: FOR_IN
94730: IFFALSE 94754
// if IsControledBy ( i ) then
94732: LD_VAR 0 2
94736: PPUSH
94737: CALL_OW 312
94741: IFFALSE 94752
// ComUnlink ( i ) ;
94743: LD_VAR 0 2
94747: PPUSH
94748: CALL_OW 136
94752: GO 94729
94754: POP
94755: POP
// end ;
94756: PPOPN 2
94758: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94759: LD_EXP 95
94763: PUSH
94764: LD_EXP 126
94768: AND
94769: IFFALSE 94909
94771: GO 94773
94773: DISABLE
94774: LD_INT 0
94776: PPUSH
94777: PPUSH
// begin ToLua ( displayPowell(); ) ;
94778: LD_STRING displayPowell();
94780: PPUSH
94781: CALL_OW 559
// uc_side := 0 ;
94785: LD_ADDR_OWVAR 20
94789: PUSH
94790: LD_INT 0
94792: ST_TO_ADDR
// uc_nation := 2 ;
94793: LD_ADDR_OWVAR 21
94797: PUSH
94798: LD_INT 2
94800: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94801: LD_ADDR_OWVAR 37
94805: PUSH
94806: LD_INT 14
94808: ST_TO_ADDR
// vc_engine := engine_siberite ;
94809: LD_ADDR_OWVAR 39
94813: PUSH
94814: LD_INT 3
94816: ST_TO_ADDR
// vc_control := control_apeman ;
94817: LD_ADDR_OWVAR 38
94821: PUSH
94822: LD_INT 5
94824: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94825: LD_ADDR_OWVAR 40
94829: PUSH
94830: LD_INT 29
94832: ST_TO_ADDR
// un := CreateVehicle ;
94833: LD_ADDR_VAR 0 2
94837: PUSH
94838: CALL_OW 45
94842: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94843: LD_VAR 0 2
94847: PPUSH
94848: LD_INT 1
94850: PPUSH
94851: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94855: LD_INT 35
94857: PPUSH
94858: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94862: LD_VAR 0 2
94866: PPUSH
94867: LD_INT 22
94869: PUSH
94870: LD_OWVAR 2
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PPUSH
94879: CALL_OW 69
94883: PPUSH
94884: LD_VAR 0 2
94888: PPUSH
94889: CALL_OW 74
94893: PPUSH
94894: CALL_OW 115
// until IsDead ( un ) ;
94898: LD_VAR 0 2
94902: PPUSH
94903: CALL_OW 301
94907: IFFALSE 94855
// end ;
94909: PPOPN 2
94911: END
// every 0 0$1 trigger StreamModeActive and sStu do
94912: LD_EXP 95
94916: PUSH
94917: LD_EXP 134
94921: AND
94922: IFFALSE 94938
94924: GO 94926
94926: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94927: LD_STRING displayStucuk();
94929: PPUSH
94930: CALL_OW 559
// ResetFog ;
94934: CALL_OW 335
// end ;
94938: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94939: LD_EXP 95
94943: PUSH
94944: LD_EXP 127
94948: AND
94949: IFFALSE 95090
94951: GO 94953
94953: DISABLE
94954: LD_INT 0
94956: PPUSH
94957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94958: LD_ADDR_VAR 0 2
94962: PUSH
94963: LD_INT 22
94965: PUSH
94966: LD_OWVAR 2
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 21
94977: PUSH
94978: LD_INT 1
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PPUSH
94989: CALL_OW 69
94993: ST_TO_ADDR
// if not tmp then
94994: LD_VAR 0 2
94998: NOT
94999: IFFALSE 95003
// exit ;
95001: GO 95090
// un := tmp [ rand ( 1 , tmp ) ] ;
95003: LD_ADDR_VAR 0 1
95007: PUSH
95008: LD_VAR 0 2
95012: PUSH
95013: LD_INT 1
95015: PPUSH
95016: LD_VAR 0 2
95020: PPUSH
95021: CALL_OW 12
95025: ARRAY
95026: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95027: LD_VAR 0 1
95031: PPUSH
95032: LD_INT 0
95034: PPUSH
95035: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95039: LD_VAR 0 1
95043: PPUSH
95044: LD_OWVAR 3
95048: PUSH
95049: LD_VAR 0 1
95053: DIFF
95054: PPUSH
95055: LD_VAR 0 1
95059: PPUSH
95060: CALL_OW 74
95064: PPUSH
95065: CALL_OW 115
// wait ( 0 0$20 ) ;
95069: LD_INT 700
95071: PPUSH
95072: CALL_OW 67
// SetSide ( un , your_side ) ;
95076: LD_VAR 0 1
95080: PPUSH
95081: LD_OWVAR 2
95085: PPUSH
95086: CALL_OW 235
// end ;
95090: PPOPN 2
95092: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95093: LD_EXP 95
95097: PUSH
95098: LD_EXP 128
95102: AND
95103: IFFALSE 95209
95105: GO 95107
95107: DISABLE
95108: LD_INT 0
95110: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95111: LD_ADDR_VAR 0 1
95115: PUSH
95116: LD_INT 22
95118: PUSH
95119: LD_OWVAR 2
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: PUSH
95128: LD_INT 2
95130: PUSH
95131: LD_INT 30
95133: PUSH
95134: LD_INT 0
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 30
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: LIST
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PPUSH
95160: CALL_OW 69
95164: ST_TO_ADDR
// if not depot then
95165: LD_VAR 0 1
95169: NOT
95170: IFFALSE 95174
// exit ;
95172: GO 95209
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95174: LD_VAR 0 1
95178: PUSH
95179: LD_INT 1
95181: ARRAY
95182: PPUSH
95183: CALL_OW 250
95187: PPUSH
95188: LD_VAR 0 1
95192: PUSH
95193: LD_INT 1
95195: ARRAY
95196: PPUSH
95197: CALL_OW 251
95201: PPUSH
95202: LD_INT 70
95204: PPUSH
95205: CALL_OW 495
// end ;
95209: PPOPN 1
95211: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95212: LD_EXP 95
95216: PUSH
95217: LD_EXP 129
95221: AND
95222: IFFALSE 95433
95224: GO 95226
95226: DISABLE
95227: LD_INT 0
95229: PPUSH
95230: PPUSH
95231: PPUSH
95232: PPUSH
95233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95234: LD_ADDR_VAR 0 5
95238: PUSH
95239: LD_INT 22
95241: PUSH
95242: LD_OWVAR 2
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 21
95253: PUSH
95254: LD_INT 1
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PPUSH
95265: CALL_OW 69
95269: ST_TO_ADDR
// if not tmp then
95270: LD_VAR 0 5
95274: NOT
95275: IFFALSE 95279
// exit ;
95277: GO 95433
// for i in tmp do
95279: LD_ADDR_VAR 0 1
95283: PUSH
95284: LD_VAR 0 5
95288: PUSH
95289: FOR_IN
95290: IFFALSE 95431
// begin d := rand ( 0 , 5 ) ;
95292: LD_ADDR_VAR 0 4
95296: PUSH
95297: LD_INT 0
95299: PPUSH
95300: LD_INT 5
95302: PPUSH
95303: CALL_OW 12
95307: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95308: LD_ADDR_VAR 0 2
95312: PUSH
95313: LD_VAR 0 1
95317: PPUSH
95318: CALL_OW 250
95322: PPUSH
95323: LD_VAR 0 4
95327: PPUSH
95328: LD_INT 3
95330: PPUSH
95331: LD_INT 12
95333: PPUSH
95334: CALL_OW 12
95338: PPUSH
95339: CALL_OW 272
95343: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95344: LD_ADDR_VAR 0 3
95348: PUSH
95349: LD_VAR 0 1
95353: PPUSH
95354: CALL_OW 251
95358: PPUSH
95359: LD_VAR 0 4
95363: PPUSH
95364: LD_INT 3
95366: PPUSH
95367: LD_INT 12
95369: PPUSH
95370: CALL_OW 12
95374: PPUSH
95375: CALL_OW 273
95379: ST_TO_ADDR
// if ValidHex ( x , y ) then
95380: LD_VAR 0 2
95384: PPUSH
95385: LD_VAR 0 3
95389: PPUSH
95390: CALL_OW 488
95394: IFFALSE 95429
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95396: LD_VAR 0 1
95400: PPUSH
95401: LD_VAR 0 2
95405: PPUSH
95406: LD_VAR 0 3
95410: PPUSH
95411: LD_INT 3
95413: PPUSH
95414: LD_INT 6
95416: PPUSH
95417: CALL_OW 12
95421: PPUSH
95422: LD_INT 1
95424: PPUSH
95425: CALL_OW 483
// end ;
95429: GO 95289
95431: POP
95432: POP
// end ;
95433: PPOPN 5
95435: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95436: LD_EXP 95
95440: PUSH
95441: LD_EXP 130
95445: AND
95446: IFFALSE 95540
95448: GO 95450
95450: DISABLE
95451: LD_INT 0
95453: PPUSH
95454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95455: LD_ADDR_VAR 0 2
95459: PUSH
95460: LD_INT 22
95462: PUSH
95463: LD_OWVAR 2
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 32
95474: PUSH
95475: LD_INT 1
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: LD_INT 21
95484: PUSH
95485: LD_INT 2
95487: PUSH
95488: EMPTY
95489: LIST
95490: LIST
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: LIST
95496: PPUSH
95497: CALL_OW 69
95501: ST_TO_ADDR
// if not tmp then
95502: LD_VAR 0 2
95506: NOT
95507: IFFALSE 95511
// exit ;
95509: GO 95540
// for i in tmp do
95511: LD_ADDR_VAR 0 1
95515: PUSH
95516: LD_VAR 0 2
95520: PUSH
95521: FOR_IN
95522: IFFALSE 95538
// SetFuel ( i , 0 ) ;
95524: LD_VAR 0 1
95528: PPUSH
95529: LD_INT 0
95531: PPUSH
95532: CALL_OW 240
95536: GO 95521
95538: POP
95539: POP
// end ;
95540: PPOPN 2
95542: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95543: LD_EXP 95
95547: PUSH
95548: LD_EXP 131
95552: AND
95553: IFFALSE 95619
95555: GO 95557
95557: DISABLE
95558: LD_INT 0
95560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95561: LD_ADDR_VAR 0 1
95565: PUSH
95566: LD_INT 22
95568: PUSH
95569: LD_OWVAR 2
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: LD_INT 30
95580: PUSH
95581: LD_INT 29
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PPUSH
95592: CALL_OW 69
95596: ST_TO_ADDR
// if not tmp then
95597: LD_VAR 0 1
95601: NOT
95602: IFFALSE 95606
// exit ;
95604: GO 95619
// DestroyUnit ( tmp [ 1 ] ) ;
95606: LD_VAR 0 1
95610: PUSH
95611: LD_INT 1
95613: ARRAY
95614: PPUSH
95615: CALL_OW 65
// end ;
95619: PPOPN 1
95621: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95622: LD_EXP 95
95626: PUSH
95627: LD_EXP 133
95631: AND
95632: IFFALSE 95761
95634: GO 95636
95636: DISABLE
95637: LD_INT 0
95639: PPUSH
// begin uc_side := 0 ;
95640: LD_ADDR_OWVAR 20
95644: PUSH
95645: LD_INT 0
95647: ST_TO_ADDR
// uc_nation := nation_arabian ;
95648: LD_ADDR_OWVAR 21
95652: PUSH
95653: LD_INT 2
95655: ST_TO_ADDR
// hc_gallery :=  ;
95656: LD_ADDR_OWVAR 33
95660: PUSH
95661: LD_STRING 
95663: ST_TO_ADDR
// hc_name :=  ;
95664: LD_ADDR_OWVAR 26
95668: PUSH
95669: LD_STRING 
95671: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95672: LD_INT 1
95674: PPUSH
95675: LD_INT 11
95677: PPUSH
95678: LD_INT 10
95680: PPUSH
95681: CALL_OW 380
// un := CreateHuman ;
95685: LD_ADDR_VAR 0 1
95689: PUSH
95690: CALL_OW 44
95694: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95695: LD_VAR 0 1
95699: PPUSH
95700: LD_INT 1
95702: PPUSH
95703: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95707: LD_INT 35
95709: PPUSH
95710: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95714: LD_VAR 0 1
95718: PPUSH
95719: LD_INT 22
95721: PUSH
95722: LD_OWVAR 2
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PPUSH
95731: CALL_OW 69
95735: PPUSH
95736: LD_VAR 0 1
95740: PPUSH
95741: CALL_OW 74
95745: PPUSH
95746: CALL_OW 115
// until IsDead ( un ) ;
95750: LD_VAR 0 1
95754: PPUSH
95755: CALL_OW 301
95759: IFFALSE 95707
// end ;
95761: PPOPN 1
95763: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95764: LD_EXP 95
95768: PUSH
95769: LD_EXP 135
95773: AND
95774: IFFALSE 95786
95776: GO 95778
95778: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95779: LD_STRING earthquake(getX(game), 0, 32)
95781: PPUSH
95782: CALL_OW 559
95786: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95787: LD_EXP 95
95791: PUSH
95792: LD_EXP 136
95796: AND
95797: IFFALSE 95888
95799: GO 95801
95801: DISABLE
95802: LD_INT 0
95804: PPUSH
// begin enable ;
95805: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95806: LD_ADDR_VAR 0 1
95810: PUSH
95811: LD_INT 22
95813: PUSH
95814: LD_OWVAR 2
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 21
95825: PUSH
95826: LD_INT 2
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 33
95835: PUSH
95836: LD_INT 3
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: LIST
95847: PPUSH
95848: CALL_OW 69
95852: ST_TO_ADDR
// if not tmp then
95853: LD_VAR 0 1
95857: NOT
95858: IFFALSE 95862
// exit ;
95860: GO 95888
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95862: LD_VAR 0 1
95866: PUSH
95867: LD_INT 1
95869: PPUSH
95870: LD_VAR 0 1
95874: PPUSH
95875: CALL_OW 12
95879: ARRAY
95880: PPUSH
95881: LD_INT 1
95883: PPUSH
95884: CALL_OW 234
// end ;
95888: PPOPN 1
95890: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95891: LD_EXP 95
95895: PUSH
95896: LD_EXP 137
95900: AND
95901: IFFALSE 96042
95903: GO 95905
95905: DISABLE
95906: LD_INT 0
95908: PPUSH
95909: PPUSH
95910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95911: LD_ADDR_VAR 0 3
95915: PUSH
95916: LD_INT 22
95918: PUSH
95919: LD_OWVAR 2
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 25
95930: PUSH
95931: LD_INT 1
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PPUSH
95942: CALL_OW 69
95946: ST_TO_ADDR
// if not tmp then
95947: LD_VAR 0 3
95951: NOT
95952: IFFALSE 95956
// exit ;
95954: GO 96042
// un := tmp [ rand ( 1 , tmp ) ] ;
95956: LD_ADDR_VAR 0 2
95960: PUSH
95961: LD_VAR 0 3
95965: PUSH
95966: LD_INT 1
95968: PPUSH
95969: LD_VAR 0 3
95973: PPUSH
95974: CALL_OW 12
95978: ARRAY
95979: ST_TO_ADDR
// if Crawls ( un ) then
95980: LD_VAR 0 2
95984: PPUSH
95985: CALL_OW 318
95989: IFFALSE 96000
// ComWalk ( un ) ;
95991: LD_VAR 0 2
95995: PPUSH
95996: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96000: LD_VAR 0 2
96004: PPUSH
96005: LD_INT 9
96007: PPUSH
96008: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96012: LD_INT 28
96014: PPUSH
96015: LD_OWVAR 2
96019: PPUSH
96020: LD_INT 2
96022: PPUSH
96023: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96027: LD_INT 29
96029: PPUSH
96030: LD_OWVAR 2
96034: PPUSH
96035: LD_INT 2
96037: PPUSH
96038: CALL_OW 322
// end ;
96042: PPOPN 3
96044: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96045: LD_EXP 95
96049: PUSH
96050: LD_EXP 138
96054: AND
96055: IFFALSE 96166
96057: GO 96059
96059: DISABLE
96060: LD_INT 0
96062: PPUSH
96063: PPUSH
96064: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96065: LD_ADDR_VAR 0 3
96069: PUSH
96070: LD_INT 22
96072: PUSH
96073: LD_OWVAR 2
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 25
96084: PUSH
96085: LD_INT 1
96087: PUSH
96088: EMPTY
96089: LIST
96090: LIST
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PPUSH
96096: CALL_OW 69
96100: ST_TO_ADDR
// if not tmp then
96101: LD_VAR 0 3
96105: NOT
96106: IFFALSE 96110
// exit ;
96108: GO 96166
// un := tmp [ rand ( 1 , tmp ) ] ;
96110: LD_ADDR_VAR 0 2
96114: PUSH
96115: LD_VAR 0 3
96119: PUSH
96120: LD_INT 1
96122: PPUSH
96123: LD_VAR 0 3
96127: PPUSH
96128: CALL_OW 12
96132: ARRAY
96133: ST_TO_ADDR
// if Crawls ( un ) then
96134: LD_VAR 0 2
96138: PPUSH
96139: CALL_OW 318
96143: IFFALSE 96154
// ComWalk ( un ) ;
96145: LD_VAR 0 2
96149: PPUSH
96150: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96154: LD_VAR 0 2
96158: PPUSH
96159: LD_INT 8
96161: PPUSH
96162: CALL_OW 336
// end ;
96166: PPOPN 3
96168: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96169: LD_EXP 95
96173: PUSH
96174: LD_EXP 139
96178: AND
96179: IFFALSE 96323
96181: GO 96183
96183: DISABLE
96184: LD_INT 0
96186: PPUSH
96187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96188: LD_ADDR_VAR 0 2
96192: PUSH
96193: LD_INT 22
96195: PUSH
96196: LD_OWVAR 2
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: PUSH
96205: LD_INT 21
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: EMPTY
96212: LIST
96213: LIST
96214: PUSH
96215: LD_INT 2
96217: PUSH
96218: LD_INT 34
96220: PUSH
96221: LD_INT 12
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 34
96230: PUSH
96231: LD_INT 51
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 34
96240: PUSH
96241: LD_INT 32
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: LIST
96258: PPUSH
96259: CALL_OW 69
96263: ST_TO_ADDR
// if not tmp then
96264: LD_VAR 0 2
96268: NOT
96269: IFFALSE 96273
// exit ;
96271: GO 96323
// for i in tmp do
96273: LD_ADDR_VAR 0 1
96277: PUSH
96278: LD_VAR 0 2
96282: PUSH
96283: FOR_IN
96284: IFFALSE 96321
// if GetCargo ( i , mat_artifact ) = 0 then
96286: LD_VAR 0 1
96290: PPUSH
96291: LD_INT 4
96293: PPUSH
96294: CALL_OW 289
96298: PUSH
96299: LD_INT 0
96301: EQUAL
96302: IFFALSE 96319
// SetCargo ( i , mat_siberit , 100 ) ;
96304: LD_VAR 0 1
96308: PPUSH
96309: LD_INT 3
96311: PPUSH
96312: LD_INT 100
96314: PPUSH
96315: CALL_OW 290
96319: GO 96283
96321: POP
96322: POP
// end ;
96323: PPOPN 2
96325: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96326: LD_EXP 95
96330: PUSH
96331: LD_EXP 140
96335: AND
96336: IFFALSE 96519
96338: GO 96340
96340: DISABLE
96341: LD_INT 0
96343: PPUSH
96344: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96345: LD_ADDR_VAR 0 2
96349: PUSH
96350: LD_INT 22
96352: PUSH
96353: LD_OWVAR 2
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: PPUSH
96362: CALL_OW 69
96366: ST_TO_ADDR
// if not tmp then
96367: LD_VAR 0 2
96371: NOT
96372: IFFALSE 96376
// exit ;
96374: GO 96519
// for i := 1 to 2 do
96376: LD_ADDR_VAR 0 1
96380: PUSH
96381: DOUBLE
96382: LD_INT 1
96384: DEC
96385: ST_TO_ADDR
96386: LD_INT 2
96388: PUSH
96389: FOR_TO
96390: IFFALSE 96517
// begin uc_side := your_side ;
96392: LD_ADDR_OWVAR 20
96396: PUSH
96397: LD_OWVAR 2
96401: ST_TO_ADDR
// uc_nation := nation_american ;
96402: LD_ADDR_OWVAR 21
96406: PUSH
96407: LD_INT 1
96409: ST_TO_ADDR
// vc_chassis := us_morphling ;
96410: LD_ADDR_OWVAR 37
96414: PUSH
96415: LD_INT 5
96417: ST_TO_ADDR
// vc_engine := engine_siberite ;
96418: LD_ADDR_OWVAR 39
96422: PUSH
96423: LD_INT 3
96425: ST_TO_ADDR
// vc_control := control_computer ;
96426: LD_ADDR_OWVAR 38
96430: PUSH
96431: LD_INT 3
96433: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96434: LD_ADDR_OWVAR 40
96438: PUSH
96439: LD_INT 10
96441: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96442: LD_VAR 0 2
96446: PUSH
96447: LD_INT 1
96449: ARRAY
96450: PPUSH
96451: CALL_OW 310
96455: NOT
96456: IFFALSE 96503
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96458: CALL_OW 45
96462: PPUSH
96463: LD_VAR 0 2
96467: PUSH
96468: LD_INT 1
96470: ARRAY
96471: PPUSH
96472: CALL_OW 250
96476: PPUSH
96477: LD_VAR 0 2
96481: PUSH
96482: LD_INT 1
96484: ARRAY
96485: PPUSH
96486: CALL_OW 251
96490: PPUSH
96491: LD_INT 12
96493: PPUSH
96494: LD_INT 1
96496: PPUSH
96497: CALL_OW 50
96501: GO 96515
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96503: CALL_OW 45
96507: PPUSH
96508: LD_INT 1
96510: PPUSH
96511: CALL_OW 51
// end ;
96515: GO 96389
96517: POP
96518: POP
// end ;
96519: PPOPN 2
96521: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96522: LD_EXP 95
96526: PUSH
96527: LD_EXP 141
96531: AND
96532: IFFALSE 96754
96534: GO 96536
96536: DISABLE
96537: LD_INT 0
96539: PPUSH
96540: PPUSH
96541: PPUSH
96542: PPUSH
96543: PPUSH
96544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96545: LD_ADDR_VAR 0 6
96549: PUSH
96550: LD_INT 22
96552: PUSH
96553: LD_OWVAR 2
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 21
96564: PUSH
96565: LD_INT 1
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: PUSH
96572: LD_INT 3
96574: PUSH
96575: LD_INT 23
96577: PUSH
96578: LD_INT 0
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: LIST
96593: PPUSH
96594: CALL_OW 69
96598: ST_TO_ADDR
// if not tmp then
96599: LD_VAR 0 6
96603: NOT
96604: IFFALSE 96608
// exit ;
96606: GO 96754
// s1 := rand ( 1 , 4 ) ;
96608: LD_ADDR_VAR 0 2
96612: PUSH
96613: LD_INT 1
96615: PPUSH
96616: LD_INT 4
96618: PPUSH
96619: CALL_OW 12
96623: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96624: LD_ADDR_VAR 0 4
96628: PUSH
96629: LD_VAR 0 6
96633: PUSH
96634: LD_INT 1
96636: ARRAY
96637: PPUSH
96638: LD_VAR 0 2
96642: PPUSH
96643: CALL_OW 259
96647: ST_TO_ADDR
// if s1 = 1 then
96648: LD_VAR 0 2
96652: PUSH
96653: LD_INT 1
96655: EQUAL
96656: IFFALSE 96676
// s2 := rand ( 2 , 4 ) else
96658: LD_ADDR_VAR 0 3
96662: PUSH
96663: LD_INT 2
96665: PPUSH
96666: LD_INT 4
96668: PPUSH
96669: CALL_OW 12
96673: ST_TO_ADDR
96674: GO 96684
// s2 := 1 ;
96676: LD_ADDR_VAR 0 3
96680: PUSH
96681: LD_INT 1
96683: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96684: LD_ADDR_VAR 0 5
96688: PUSH
96689: LD_VAR 0 6
96693: PUSH
96694: LD_INT 1
96696: ARRAY
96697: PPUSH
96698: LD_VAR 0 3
96702: PPUSH
96703: CALL_OW 259
96707: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96708: LD_VAR 0 6
96712: PUSH
96713: LD_INT 1
96715: ARRAY
96716: PPUSH
96717: LD_VAR 0 2
96721: PPUSH
96722: LD_VAR 0 5
96726: PPUSH
96727: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96731: LD_VAR 0 6
96735: PUSH
96736: LD_INT 1
96738: ARRAY
96739: PPUSH
96740: LD_VAR 0 3
96744: PPUSH
96745: LD_VAR 0 4
96749: PPUSH
96750: CALL_OW 237
// end ;
96754: PPOPN 6
96756: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96757: LD_EXP 95
96761: PUSH
96762: LD_EXP 142
96766: AND
96767: IFFALSE 96846
96769: GO 96771
96771: DISABLE
96772: LD_INT 0
96774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96775: LD_ADDR_VAR 0 1
96779: PUSH
96780: LD_INT 22
96782: PUSH
96783: LD_OWVAR 2
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 30
96794: PUSH
96795: LD_INT 3
96797: PUSH
96798: EMPTY
96799: LIST
96800: LIST
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PPUSH
96806: CALL_OW 69
96810: ST_TO_ADDR
// if not tmp then
96811: LD_VAR 0 1
96815: NOT
96816: IFFALSE 96820
// exit ;
96818: GO 96846
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96820: LD_VAR 0 1
96824: PUSH
96825: LD_INT 1
96827: PPUSH
96828: LD_VAR 0 1
96832: PPUSH
96833: CALL_OW 12
96837: ARRAY
96838: PPUSH
96839: LD_INT 1
96841: PPUSH
96842: CALL_OW 234
// end ;
96846: PPOPN 1
96848: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96849: LD_EXP 95
96853: PUSH
96854: LD_EXP 143
96858: AND
96859: IFFALSE 96971
96861: GO 96863
96863: DISABLE
96864: LD_INT 0
96866: PPUSH
96867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96868: LD_ADDR_VAR 0 2
96872: PUSH
96873: LD_INT 22
96875: PUSH
96876: LD_OWVAR 2
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: PUSH
96885: LD_INT 2
96887: PUSH
96888: LD_INT 30
96890: PUSH
96891: LD_INT 27
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PUSH
96898: LD_INT 30
96900: PUSH
96901: LD_INT 26
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 30
96910: PUSH
96911: LD_INT 28
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PPUSH
96928: CALL_OW 69
96932: ST_TO_ADDR
// if not tmp then
96933: LD_VAR 0 2
96937: NOT
96938: IFFALSE 96942
// exit ;
96940: GO 96971
// for i in tmp do
96942: LD_ADDR_VAR 0 1
96946: PUSH
96947: LD_VAR 0 2
96951: PUSH
96952: FOR_IN
96953: IFFALSE 96969
// SetLives ( i , 1 ) ;
96955: LD_VAR 0 1
96959: PPUSH
96960: LD_INT 1
96962: PPUSH
96963: CALL_OW 234
96967: GO 96952
96969: POP
96970: POP
// end ;
96971: PPOPN 2
96973: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96974: LD_EXP 95
96978: PUSH
96979: LD_EXP 144
96983: AND
96984: IFFALSE 97271
96986: GO 96988
96988: DISABLE
96989: LD_INT 0
96991: PPUSH
96992: PPUSH
96993: PPUSH
// begin i := rand ( 1 , 7 ) ;
96994: LD_ADDR_VAR 0 1
96998: PUSH
96999: LD_INT 1
97001: PPUSH
97002: LD_INT 7
97004: PPUSH
97005: CALL_OW 12
97009: ST_TO_ADDR
// case i of 1 :
97010: LD_VAR 0 1
97014: PUSH
97015: LD_INT 1
97017: DOUBLE
97018: EQUAL
97019: IFTRUE 97023
97021: GO 97033
97023: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97024: LD_STRING earthquake(getX(game), 0, 32)
97026: PPUSH
97027: CALL_OW 559
97031: GO 97271
97033: LD_INT 2
97035: DOUBLE
97036: EQUAL
97037: IFTRUE 97041
97039: GO 97055
97041: POP
// begin ToLua ( displayStucuk(); ) ;
97042: LD_STRING displayStucuk();
97044: PPUSH
97045: CALL_OW 559
// ResetFog ;
97049: CALL_OW 335
// end ; 3 :
97053: GO 97271
97055: LD_INT 3
97057: DOUBLE
97058: EQUAL
97059: IFTRUE 97063
97061: GO 97167
97063: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97064: LD_ADDR_VAR 0 2
97068: PUSH
97069: LD_INT 22
97071: PUSH
97072: LD_OWVAR 2
97076: PUSH
97077: EMPTY
97078: LIST
97079: LIST
97080: PUSH
97081: LD_INT 25
97083: PUSH
97084: LD_INT 1
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PPUSH
97095: CALL_OW 69
97099: ST_TO_ADDR
// if not tmp then
97100: LD_VAR 0 2
97104: NOT
97105: IFFALSE 97109
// exit ;
97107: GO 97271
// un := tmp [ rand ( 1 , tmp ) ] ;
97109: LD_ADDR_VAR 0 3
97113: PUSH
97114: LD_VAR 0 2
97118: PUSH
97119: LD_INT 1
97121: PPUSH
97122: LD_VAR 0 2
97126: PPUSH
97127: CALL_OW 12
97131: ARRAY
97132: ST_TO_ADDR
// if Crawls ( un ) then
97133: LD_VAR 0 3
97137: PPUSH
97138: CALL_OW 318
97142: IFFALSE 97153
// ComWalk ( un ) ;
97144: LD_VAR 0 3
97148: PPUSH
97149: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97153: LD_VAR 0 3
97157: PPUSH
97158: LD_INT 8
97160: PPUSH
97161: CALL_OW 336
// end ; 4 :
97165: GO 97271
97167: LD_INT 4
97169: DOUBLE
97170: EQUAL
97171: IFTRUE 97175
97173: GO 97249
97175: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97176: LD_ADDR_VAR 0 2
97180: PUSH
97181: LD_INT 22
97183: PUSH
97184: LD_OWVAR 2
97188: PUSH
97189: EMPTY
97190: LIST
97191: LIST
97192: PUSH
97193: LD_INT 30
97195: PUSH
97196: LD_INT 29
97198: PUSH
97199: EMPTY
97200: LIST
97201: LIST
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PPUSH
97207: CALL_OW 69
97211: ST_TO_ADDR
// if not tmp then
97212: LD_VAR 0 2
97216: NOT
97217: IFFALSE 97221
// exit ;
97219: GO 97271
// CenterNowOnUnits ( tmp [ 1 ] ) ;
97221: LD_VAR 0 2
97225: PUSH
97226: LD_INT 1
97228: ARRAY
97229: PPUSH
97230: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97234: LD_VAR 0 2
97238: PUSH
97239: LD_INT 1
97241: ARRAY
97242: PPUSH
97243: CALL_OW 65
// end ; 5 .. 7 :
97247: GO 97271
97249: LD_INT 5
97251: DOUBLE
97252: GREATEREQUAL
97253: IFFALSE 97261
97255: LD_INT 7
97257: DOUBLE
97258: LESSEQUAL
97259: IFTRUE 97263
97261: GO 97270
97263: POP
// StreamSibBomb ; end ;
97264: CALL 93508 0 0
97268: GO 97271
97270: POP
// end ;
97271: PPOPN 3
97273: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97274: LD_EXP 95
97278: PUSH
97279: LD_EXP 145
97283: AND
97284: IFFALSE 97440
97286: GO 97288
97288: DISABLE
97289: LD_INT 0
97291: PPUSH
97292: PPUSH
97293: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97294: LD_ADDR_VAR 0 2
97298: PUSH
97299: LD_INT 81
97301: PUSH
97302: LD_OWVAR 2
97306: PUSH
97307: EMPTY
97308: LIST
97309: LIST
97310: PUSH
97311: LD_INT 2
97313: PUSH
97314: LD_INT 21
97316: PUSH
97317: LD_INT 1
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: PUSH
97324: LD_INT 21
97326: PUSH
97327: LD_INT 2
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: LIST
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PPUSH
97343: CALL_OW 69
97347: ST_TO_ADDR
// if not tmp then
97348: LD_VAR 0 2
97352: NOT
97353: IFFALSE 97357
// exit ;
97355: GO 97440
// p := 0 ;
97357: LD_ADDR_VAR 0 3
97361: PUSH
97362: LD_INT 0
97364: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97365: LD_INT 35
97367: PPUSH
97368: CALL_OW 67
// p := p + 1 ;
97372: LD_ADDR_VAR 0 3
97376: PUSH
97377: LD_VAR 0 3
97381: PUSH
97382: LD_INT 1
97384: PLUS
97385: ST_TO_ADDR
// for i in tmp do
97386: LD_ADDR_VAR 0 1
97390: PUSH
97391: LD_VAR 0 2
97395: PUSH
97396: FOR_IN
97397: IFFALSE 97428
// if GetLives ( i ) < 1000 then
97399: LD_VAR 0 1
97403: PPUSH
97404: CALL_OW 256
97408: PUSH
97409: LD_INT 1000
97411: LESS
97412: IFFALSE 97426
// SetLives ( i , 1000 ) ;
97414: LD_VAR 0 1
97418: PPUSH
97419: LD_INT 1000
97421: PPUSH
97422: CALL_OW 234
97426: GO 97396
97428: POP
97429: POP
// until p > 20 ;
97430: LD_VAR 0 3
97434: PUSH
97435: LD_INT 20
97437: GREATER
97438: IFFALSE 97365
// end ;
97440: PPOPN 3
97442: END
// every 0 0$1 trigger StreamModeActive and sTime do
97443: LD_EXP 95
97447: PUSH
97448: LD_EXP 146
97452: AND
97453: IFFALSE 97488
97455: GO 97457
97457: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97458: LD_INT 28
97460: PPUSH
97461: LD_OWVAR 2
97465: PPUSH
97466: LD_INT 2
97468: PPUSH
97469: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97473: LD_INT 30
97475: PPUSH
97476: LD_OWVAR 2
97480: PPUSH
97481: LD_INT 2
97483: PPUSH
97484: CALL_OW 322
// end ;
97488: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97489: LD_EXP 95
97493: PUSH
97494: LD_EXP 147
97498: AND
97499: IFFALSE 97620
97501: GO 97503
97503: DISABLE
97504: LD_INT 0
97506: PPUSH
97507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97508: LD_ADDR_VAR 0 2
97512: PUSH
97513: LD_INT 22
97515: PUSH
97516: LD_OWVAR 2
97520: PUSH
97521: EMPTY
97522: LIST
97523: LIST
97524: PUSH
97525: LD_INT 21
97527: PUSH
97528: LD_INT 1
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: PUSH
97535: LD_INT 3
97537: PUSH
97538: LD_INT 23
97540: PUSH
97541: LD_INT 0
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: LIST
97556: PPUSH
97557: CALL_OW 69
97561: ST_TO_ADDR
// if not tmp then
97562: LD_VAR 0 2
97566: NOT
97567: IFFALSE 97571
// exit ;
97569: GO 97620
// for i in tmp do
97571: LD_ADDR_VAR 0 1
97575: PUSH
97576: LD_VAR 0 2
97580: PUSH
97581: FOR_IN
97582: IFFALSE 97618
// begin if Crawls ( i ) then
97584: LD_VAR 0 1
97588: PPUSH
97589: CALL_OW 318
97593: IFFALSE 97604
// ComWalk ( i ) ;
97595: LD_VAR 0 1
97599: PPUSH
97600: CALL_OW 138
// SetClass ( i , 2 ) ;
97604: LD_VAR 0 1
97608: PPUSH
97609: LD_INT 2
97611: PPUSH
97612: CALL_OW 336
// end ;
97616: GO 97581
97618: POP
97619: POP
// end ;
97620: PPOPN 2
97622: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97623: LD_EXP 95
97627: PUSH
97628: LD_EXP 148
97632: AND
97633: IFFALSE 97921
97635: GO 97637
97637: DISABLE
97638: LD_INT 0
97640: PPUSH
97641: PPUSH
97642: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97643: LD_OWVAR 2
97647: PPUSH
97648: LD_INT 9
97650: PPUSH
97651: LD_INT 1
97653: PPUSH
97654: LD_INT 1
97656: PPUSH
97657: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97661: LD_INT 9
97663: PPUSH
97664: LD_OWVAR 2
97668: PPUSH
97669: CALL_OW 343
// uc_side := 9 ;
97673: LD_ADDR_OWVAR 20
97677: PUSH
97678: LD_INT 9
97680: ST_TO_ADDR
// uc_nation := 2 ;
97681: LD_ADDR_OWVAR 21
97685: PUSH
97686: LD_INT 2
97688: ST_TO_ADDR
// hc_name := Dark Warrior ;
97689: LD_ADDR_OWVAR 26
97693: PUSH
97694: LD_STRING Dark Warrior
97696: ST_TO_ADDR
// hc_gallery :=  ;
97697: LD_ADDR_OWVAR 33
97701: PUSH
97702: LD_STRING 
97704: ST_TO_ADDR
// hc_noskilllimit := true ;
97705: LD_ADDR_OWVAR 76
97709: PUSH
97710: LD_INT 1
97712: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97713: LD_ADDR_OWVAR 31
97717: PUSH
97718: LD_INT 30
97720: PUSH
97721: LD_INT 30
97723: PUSH
97724: LD_INT 30
97726: PUSH
97727: LD_INT 30
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: ST_TO_ADDR
// un := CreateHuman ;
97736: LD_ADDR_VAR 0 3
97740: PUSH
97741: CALL_OW 44
97745: ST_TO_ADDR
// hc_noskilllimit := false ;
97746: LD_ADDR_OWVAR 76
97750: PUSH
97751: LD_INT 0
97753: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97754: LD_VAR 0 3
97758: PPUSH
97759: LD_INT 1
97761: PPUSH
97762: CALL_OW 51
// ToLua ( playRanger() ) ;
97766: LD_STRING playRanger()
97768: PPUSH
97769: CALL_OW 559
// p := 0 ;
97773: LD_ADDR_VAR 0 2
97777: PUSH
97778: LD_INT 0
97780: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97781: LD_INT 35
97783: PPUSH
97784: CALL_OW 67
// p := p + 1 ;
97788: LD_ADDR_VAR 0 2
97792: PUSH
97793: LD_VAR 0 2
97797: PUSH
97798: LD_INT 1
97800: PLUS
97801: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97802: LD_VAR 0 3
97806: PPUSH
97807: CALL_OW 256
97811: PUSH
97812: LD_INT 1000
97814: LESS
97815: IFFALSE 97829
// SetLives ( un , 1000 ) ;
97817: LD_VAR 0 3
97821: PPUSH
97822: LD_INT 1000
97824: PPUSH
97825: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97829: LD_VAR 0 3
97833: PPUSH
97834: LD_INT 81
97836: PUSH
97837: LD_OWVAR 2
97841: PUSH
97842: EMPTY
97843: LIST
97844: LIST
97845: PUSH
97846: LD_INT 91
97848: PUSH
97849: LD_VAR 0 3
97853: PUSH
97854: LD_INT 30
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: LIST
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PPUSH
97866: CALL_OW 69
97870: PPUSH
97871: LD_VAR 0 3
97875: PPUSH
97876: CALL_OW 74
97880: PPUSH
97881: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
97885: LD_VAR 0 2
97889: PUSH
97890: LD_INT 80
97892: GREATER
97893: PUSH
97894: LD_VAR 0 3
97898: PPUSH
97899: CALL_OW 301
97903: OR
97904: IFFALSE 97781
// if un then
97906: LD_VAR 0 3
97910: IFFALSE 97921
// RemoveUnit ( un ) ;
97912: LD_VAR 0 3
97916: PPUSH
97917: CALL_OW 64
// end ;
97921: PPOPN 3
97923: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
97924: LD_EXP 149
97928: IFFALSE 98044
97930: GO 97932
97932: DISABLE
97933: LD_INT 0
97935: PPUSH
97936: PPUSH
97937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97938: LD_ADDR_VAR 0 2
97942: PUSH
97943: LD_INT 81
97945: PUSH
97946: LD_OWVAR 2
97950: PUSH
97951: EMPTY
97952: LIST
97953: LIST
97954: PUSH
97955: LD_INT 21
97957: PUSH
97958: LD_INT 1
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PPUSH
97969: CALL_OW 69
97973: ST_TO_ADDR
// ToLua ( playComputer() ) ;
97974: LD_STRING playComputer()
97976: PPUSH
97977: CALL_OW 559
// if not tmp then
97981: LD_VAR 0 2
97985: NOT
97986: IFFALSE 97990
// exit ;
97988: GO 98044
// for i in tmp do
97990: LD_ADDR_VAR 0 1
97994: PUSH
97995: LD_VAR 0 2
97999: PUSH
98000: FOR_IN
98001: IFFALSE 98042
// for j := 1 to 4 do
98003: LD_ADDR_VAR 0 3
98007: PUSH
98008: DOUBLE
98009: LD_INT 1
98011: DEC
98012: ST_TO_ADDR
98013: LD_INT 4
98015: PUSH
98016: FOR_TO
98017: IFFALSE 98038
// SetSkill ( i , j , 10 ) ;
98019: LD_VAR 0 1
98023: PPUSH
98024: LD_VAR 0 3
98028: PPUSH
98029: LD_INT 10
98031: PPUSH
98032: CALL_OW 237
98036: GO 98016
98038: POP
98039: POP
98040: GO 98000
98042: POP
98043: POP
// end ;
98044: PPOPN 3
98046: END
// every 0 0$1 trigger s30 do var i , tmp ;
98047: LD_EXP 150
98051: IFFALSE 98120
98053: GO 98055
98055: DISABLE
98056: LD_INT 0
98058: PPUSH
98059: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98060: LD_ADDR_VAR 0 2
98064: PUSH
98065: LD_INT 22
98067: PUSH
98068: LD_OWVAR 2
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: PPUSH
98077: CALL_OW 69
98081: ST_TO_ADDR
// if not tmp then
98082: LD_VAR 0 2
98086: NOT
98087: IFFALSE 98091
// exit ;
98089: GO 98120
// for i in tmp do
98091: LD_ADDR_VAR 0 1
98095: PUSH
98096: LD_VAR 0 2
98100: PUSH
98101: FOR_IN
98102: IFFALSE 98118
// SetLives ( i , 300 ) ;
98104: LD_VAR 0 1
98108: PPUSH
98109: LD_INT 300
98111: PPUSH
98112: CALL_OW 234
98116: GO 98101
98118: POP
98119: POP
// end ;
98120: PPOPN 2
98122: END
// every 0 0$1 trigger s60 do var i , tmp ;
98123: LD_EXP 151
98127: IFFALSE 98196
98129: GO 98131
98131: DISABLE
98132: LD_INT 0
98134: PPUSH
98135: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98136: LD_ADDR_VAR 0 2
98140: PUSH
98141: LD_INT 22
98143: PUSH
98144: LD_OWVAR 2
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: PPUSH
98153: CALL_OW 69
98157: ST_TO_ADDR
// if not tmp then
98158: LD_VAR 0 2
98162: NOT
98163: IFFALSE 98167
// exit ;
98165: GO 98196
// for i in tmp do
98167: LD_ADDR_VAR 0 1
98171: PUSH
98172: LD_VAR 0 2
98176: PUSH
98177: FOR_IN
98178: IFFALSE 98194
// SetLives ( i , 600 ) ;
98180: LD_VAR 0 1
98184: PPUSH
98185: LD_INT 600
98187: PPUSH
98188: CALL_OW 234
98192: GO 98177
98194: POP
98195: POP
// end ;
98196: PPOPN 2
98198: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98199: LD_INT 0
98201: PPUSH
// case cmd of 301 :
98202: LD_VAR 0 1
98206: PUSH
98207: LD_INT 301
98209: DOUBLE
98210: EQUAL
98211: IFTRUE 98215
98213: GO 98247
98215: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98216: LD_VAR 0 6
98220: PPUSH
98221: LD_VAR 0 7
98225: PPUSH
98226: LD_VAR 0 8
98230: PPUSH
98231: LD_VAR 0 4
98235: PPUSH
98236: LD_VAR 0 5
98240: PPUSH
98241: CALL 99448 0 5
98245: GO 98368
98247: LD_INT 302
98249: DOUBLE
98250: EQUAL
98251: IFTRUE 98255
98253: GO 98292
98255: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98256: LD_VAR 0 6
98260: PPUSH
98261: LD_VAR 0 7
98265: PPUSH
98266: LD_VAR 0 8
98270: PPUSH
98271: LD_VAR 0 9
98275: PPUSH
98276: LD_VAR 0 4
98280: PPUSH
98281: LD_VAR 0 5
98285: PPUSH
98286: CALL 99539 0 6
98290: GO 98368
98292: LD_INT 303
98294: DOUBLE
98295: EQUAL
98296: IFTRUE 98300
98298: GO 98337
98300: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98301: LD_VAR 0 6
98305: PPUSH
98306: LD_VAR 0 7
98310: PPUSH
98311: LD_VAR 0 8
98315: PPUSH
98316: LD_VAR 0 9
98320: PPUSH
98321: LD_VAR 0 4
98325: PPUSH
98326: LD_VAR 0 5
98330: PPUSH
98331: CALL 98373 0 6
98335: GO 98368
98337: LD_INT 304
98339: DOUBLE
98340: EQUAL
98341: IFTRUE 98345
98343: GO 98367
98345: POP
// hHackTeleport ( unit , x , y ) ; end ;
98346: LD_VAR 0 2
98350: PPUSH
98351: LD_VAR 0 4
98355: PPUSH
98356: LD_VAR 0 5
98360: PPUSH
98361: CALL 100132 0 3
98365: GO 98368
98367: POP
// end ;
98368: LD_VAR 0 12
98372: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98373: LD_INT 0
98375: PPUSH
98376: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98377: LD_VAR 0 1
98381: PUSH
98382: LD_INT 1
98384: LESS
98385: PUSH
98386: LD_VAR 0 1
98390: PUSH
98391: LD_INT 3
98393: GREATER
98394: OR
98395: PUSH
98396: LD_VAR 0 5
98400: PPUSH
98401: LD_VAR 0 6
98405: PPUSH
98406: CALL_OW 428
98410: OR
98411: IFFALSE 98415
// exit ;
98413: GO 99135
// uc_side := your_side ;
98415: LD_ADDR_OWVAR 20
98419: PUSH
98420: LD_OWVAR 2
98424: ST_TO_ADDR
// uc_nation := nation ;
98425: LD_ADDR_OWVAR 21
98429: PUSH
98430: LD_VAR 0 1
98434: ST_TO_ADDR
// bc_level = 1 ;
98435: LD_ADDR_OWVAR 43
98439: PUSH
98440: LD_INT 1
98442: ST_TO_ADDR
// case btype of 1 :
98443: LD_VAR 0 2
98447: PUSH
98448: LD_INT 1
98450: DOUBLE
98451: EQUAL
98452: IFTRUE 98456
98454: GO 98467
98456: POP
// bc_type := b_depot ; 2 :
98457: LD_ADDR_OWVAR 42
98461: PUSH
98462: LD_INT 0
98464: ST_TO_ADDR
98465: GO 99079
98467: LD_INT 2
98469: DOUBLE
98470: EQUAL
98471: IFTRUE 98475
98473: GO 98486
98475: POP
// bc_type := b_warehouse ; 3 :
98476: LD_ADDR_OWVAR 42
98480: PUSH
98481: LD_INT 1
98483: ST_TO_ADDR
98484: GO 99079
98486: LD_INT 3
98488: DOUBLE
98489: EQUAL
98490: IFTRUE 98494
98492: GO 98505
98494: POP
// bc_type := b_lab ; 4 .. 9 :
98495: LD_ADDR_OWVAR 42
98499: PUSH
98500: LD_INT 6
98502: ST_TO_ADDR
98503: GO 99079
98505: LD_INT 4
98507: DOUBLE
98508: GREATEREQUAL
98509: IFFALSE 98517
98511: LD_INT 9
98513: DOUBLE
98514: LESSEQUAL
98515: IFTRUE 98519
98517: GO 98571
98519: POP
// begin bc_type := b_lab_half ;
98520: LD_ADDR_OWVAR 42
98524: PUSH
98525: LD_INT 7
98527: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98528: LD_ADDR_OWVAR 44
98532: PUSH
98533: LD_INT 10
98535: PUSH
98536: LD_INT 11
98538: PUSH
98539: LD_INT 12
98541: PUSH
98542: LD_INT 15
98544: PUSH
98545: LD_INT 14
98547: PUSH
98548: LD_INT 13
98550: PUSH
98551: EMPTY
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: PUSH
98559: LD_VAR 0 2
98563: PUSH
98564: LD_INT 3
98566: MINUS
98567: ARRAY
98568: ST_TO_ADDR
// end ; 10 .. 13 :
98569: GO 99079
98571: LD_INT 10
98573: DOUBLE
98574: GREATEREQUAL
98575: IFFALSE 98583
98577: LD_INT 13
98579: DOUBLE
98580: LESSEQUAL
98581: IFTRUE 98585
98583: GO 98662
98585: POP
// begin bc_type := b_lab_full ;
98586: LD_ADDR_OWVAR 42
98590: PUSH
98591: LD_INT 8
98593: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98594: LD_ADDR_OWVAR 44
98598: PUSH
98599: LD_INT 10
98601: PUSH
98602: LD_INT 12
98604: PUSH
98605: LD_INT 14
98607: PUSH
98608: LD_INT 13
98610: PUSH
98611: EMPTY
98612: LIST
98613: LIST
98614: LIST
98615: LIST
98616: PUSH
98617: LD_VAR 0 2
98621: PUSH
98622: LD_INT 9
98624: MINUS
98625: ARRAY
98626: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98627: LD_ADDR_OWVAR 45
98631: PUSH
98632: LD_INT 11
98634: PUSH
98635: LD_INT 15
98637: PUSH
98638: LD_INT 12
98640: PUSH
98641: LD_INT 15
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: PUSH
98650: LD_VAR 0 2
98654: PUSH
98655: LD_INT 9
98657: MINUS
98658: ARRAY
98659: ST_TO_ADDR
// end ; 14 :
98660: GO 99079
98662: LD_INT 14
98664: DOUBLE
98665: EQUAL
98666: IFTRUE 98670
98668: GO 98681
98670: POP
// bc_type := b_workshop ; 15 :
98671: LD_ADDR_OWVAR 42
98675: PUSH
98676: LD_INT 2
98678: ST_TO_ADDR
98679: GO 99079
98681: LD_INT 15
98683: DOUBLE
98684: EQUAL
98685: IFTRUE 98689
98687: GO 98700
98689: POP
// bc_type := b_factory ; 16 :
98690: LD_ADDR_OWVAR 42
98694: PUSH
98695: LD_INT 3
98697: ST_TO_ADDR
98698: GO 99079
98700: LD_INT 16
98702: DOUBLE
98703: EQUAL
98704: IFTRUE 98708
98706: GO 98719
98708: POP
// bc_type := b_ext_gun ; 17 :
98709: LD_ADDR_OWVAR 42
98713: PUSH
98714: LD_INT 17
98716: ST_TO_ADDR
98717: GO 99079
98719: LD_INT 17
98721: DOUBLE
98722: EQUAL
98723: IFTRUE 98727
98725: GO 98755
98727: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98728: LD_ADDR_OWVAR 42
98732: PUSH
98733: LD_INT 19
98735: PUSH
98736: LD_INT 23
98738: PUSH
98739: LD_INT 19
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: LIST
98746: PUSH
98747: LD_VAR 0 1
98751: ARRAY
98752: ST_TO_ADDR
98753: GO 99079
98755: LD_INT 18
98757: DOUBLE
98758: EQUAL
98759: IFTRUE 98763
98761: GO 98774
98763: POP
// bc_type := b_ext_radar ; 19 :
98764: LD_ADDR_OWVAR 42
98768: PUSH
98769: LD_INT 20
98771: ST_TO_ADDR
98772: GO 99079
98774: LD_INT 19
98776: DOUBLE
98777: EQUAL
98778: IFTRUE 98782
98780: GO 98793
98782: POP
// bc_type := b_ext_radio ; 20 :
98783: LD_ADDR_OWVAR 42
98787: PUSH
98788: LD_INT 22
98790: ST_TO_ADDR
98791: GO 99079
98793: LD_INT 20
98795: DOUBLE
98796: EQUAL
98797: IFTRUE 98801
98799: GO 98812
98801: POP
// bc_type := b_ext_siberium ; 21 :
98802: LD_ADDR_OWVAR 42
98806: PUSH
98807: LD_INT 21
98809: ST_TO_ADDR
98810: GO 99079
98812: LD_INT 21
98814: DOUBLE
98815: EQUAL
98816: IFTRUE 98820
98818: GO 98831
98820: POP
// bc_type := b_ext_computer ; 22 :
98821: LD_ADDR_OWVAR 42
98825: PUSH
98826: LD_INT 24
98828: ST_TO_ADDR
98829: GO 99079
98831: LD_INT 22
98833: DOUBLE
98834: EQUAL
98835: IFTRUE 98839
98837: GO 98850
98839: POP
// bc_type := b_ext_track ; 23 :
98840: LD_ADDR_OWVAR 42
98844: PUSH
98845: LD_INT 16
98847: ST_TO_ADDR
98848: GO 99079
98850: LD_INT 23
98852: DOUBLE
98853: EQUAL
98854: IFTRUE 98858
98856: GO 98869
98858: POP
// bc_type := b_ext_laser ; 24 :
98859: LD_ADDR_OWVAR 42
98863: PUSH
98864: LD_INT 25
98866: ST_TO_ADDR
98867: GO 99079
98869: LD_INT 24
98871: DOUBLE
98872: EQUAL
98873: IFTRUE 98877
98875: GO 98888
98877: POP
// bc_type := b_control_tower ; 25 :
98878: LD_ADDR_OWVAR 42
98882: PUSH
98883: LD_INT 36
98885: ST_TO_ADDR
98886: GO 99079
98888: LD_INT 25
98890: DOUBLE
98891: EQUAL
98892: IFTRUE 98896
98894: GO 98907
98896: POP
// bc_type := b_breastwork ; 26 :
98897: LD_ADDR_OWVAR 42
98901: PUSH
98902: LD_INT 31
98904: ST_TO_ADDR
98905: GO 99079
98907: LD_INT 26
98909: DOUBLE
98910: EQUAL
98911: IFTRUE 98915
98913: GO 98926
98915: POP
// bc_type := b_bunker ; 27 :
98916: LD_ADDR_OWVAR 42
98920: PUSH
98921: LD_INT 32
98923: ST_TO_ADDR
98924: GO 99079
98926: LD_INT 27
98928: DOUBLE
98929: EQUAL
98930: IFTRUE 98934
98932: GO 98945
98934: POP
// bc_type := b_turret ; 28 :
98935: LD_ADDR_OWVAR 42
98939: PUSH
98940: LD_INT 33
98942: ST_TO_ADDR
98943: GO 99079
98945: LD_INT 28
98947: DOUBLE
98948: EQUAL
98949: IFTRUE 98953
98951: GO 98964
98953: POP
// bc_type := b_armoury ; 29 :
98954: LD_ADDR_OWVAR 42
98958: PUSH
98959: LD_INT 4
98961: ST_TO_ADDR
98962: GO 99079
98964: LD_INT 29
98966: DOUBLE
98967: EQUAL
98968: IFTRUE 98972
98970: GO 98983
98972: POP
// bc_type := b_barracks ; 30 :
98973: LD_ADDR_OWVAR 42
98977: PUSH
98978: LD_INT 5
98980: ST_TO_ADDR
98981: GO 99079
98983: LD_INT 30
98985: DOUBLE
98986: EQUAL
98987: IFTRUE 98991
98989: GO 99002
98991: POP
// bc_type := b_solar_power ; 31 :
98992: LD_ADDR_OWVAR 42
98996: PUSH
98997: LD_INT 27
98999: ST_TO_ADDR
99000: GO 99079
99002: LD_INT 31
99004: DOUBLE
99005: EQUAL
99006: IFTRUE 99010
99008: GO 99021
99010: POP
// bc_type := b_oil_power ; 32 :
99011: LD_ADDR_OWVAR 42
99015: PUSH
99016: LD_INT 26
99018: ST_TO_ADDR
99019: GO 99079
99021: LD_INT 32
99023: DOUBLE
99024: EQUAL
99025: IFTRUE 99029
99027: GO 99040
99029: POP
// bc_type := b_siberite_power ; 33 :
99030: LD_ADDR_OWVAR 42
99034: PUSH
99035: LD_INT 28
99037: ST_TO_ADDR
99038: GO 99079
99040: LD_INT 33
99042: DOUBLE
99043: EQUAL
99044: IFTRUE 99048
99046: GO 99059
99048: POP
// bc_type := b_oil_mine ; 34 :
99049: LD_ADDR_OWVAR 42
99053: PUSH
99054: LD_INT 29
99056: ST_TO_ADDR
99057: GO 99079
99059: LD_INT 34
99061: DOUBLE
99062: EQUAL
99063: IFTRUE 99067
99065: GO 99078
99067: POP
// bc_type := b_siberite_mine ; end ;
99068: LD_ADDR_OWVAR 42
99072: PUSH
99073: LD_INT 30
99075: ST_TO_ADDR
99076: GO 99079
99078: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99079: LD_ADDR_VAR 0 8
99083: PUSH
99084: LD_VAR 0 5
99088: PPUSH
99089: LD_VAR 0 6
99093: PPUSH
99094: LD_VAR 0 3
99098: PPUSH
99099: CALL_OW 47
99103: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99104: LD_OWVAR 42
99108: PUSH
99109: LD_INT 32
99111: PUSH
99112: LD_INT 33
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: IN
99119: IFFALSE 99135
// PlaceWeaponTurret ( b , weapon ) ;
99121: LD_VAR 0 8
99125: PPUSH
99126: LD_VAR 0 4
99130: PPUSH
99131: CALL_OW 431
// end ;
99135: LD_VAR 0 7
99139: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99140: LD_INT 0
99142: PPUSH
99143: PPUSH
99144: PPUSH
99145: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99146: LD_ADDR_VAR 0 4
99150: PUSH
99151: LD_INT 22
99153: PUSH
99154: LD_OWVAR 2
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: PUSH
99163: LD_INT 2
99165: PUSH
99166: LD_INT 30
99168: PUSH
99169: LD_INT 0
99171: PUSH
99172: EMPTY
99173: LIST
99174: LIST
99175: PUSH
99176: LD_INT 30
99178: PUSH
99179: LD_INT 1
99181: PUSH
99182: EMPTY
99183: LIST
99184: LIST
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: LIST
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PPUSH
99195: CALL_OW 69
99199: ST_TO_ADDR
// if not tmp then
99200: LD_VAR 0 4
99204: NOT
99205: IFFALSE 99209
// exit ;
99207: GO 99268
// for i in tmp do
99209: LD_ADDR_VAR 0 2
99213: PUSH
99214: LD_VAR 0 4
99218: PUSH
99219: FOR_IN
99220: IFFALSE 99266
// for j = 1 to 3 do
99222: LD_ADDR_VAR 0 3
99226: PUSH
99227: DOUBLE
99228: LD_INT 1
99230: DEC
99231: ST_TO_ADDR
99232: LD_INT 3
99234: PUSH
99235: FOR_TO
99236: IFFALSE 99262
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99238: LD_VAR 0 2
99242: PPUSH
99243: CALL_OW 274
99247: PPUSH
99248: LD_VAR 0 3
99252: PPUSH
99253: LD_INT 99999
99255: PPUSH
99256: CALL_OW 277
99260: GO 99235
99262: POP
99263: POP
99264: GO 99219
99266: POP
99267: POP
// end ;
99268: LD_VAR 0 1
99272: RET
// export function hHackSetLevel10 ; var i , j ; begin
99273: LD_INT 0
99275: PPUSH
99276: PPUSH
99277: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99278: LD_ADDR_VAR 0 2
99282: PUSH
99283: LD_INT 21
99285: PUSH
99286: LD_INT 1
99288: PUSH
99289: EMPTY
99290: LIST
99291: LIST
99292: PPUSH
99293: CALL_OW 69
99297: PUSH
99298: FOR_IN
99299: IFFALSE 99351
// if IsSelected ( i ) then
99301: LD_VAR 0 2
99305: PPUSH
99306: CALL_OW 306
99310: IFFALSE 99349
// begin for j := 1 to 4 do
99312: LD_ADDR_VAR 0 3
99316: PUSH
99317: DOUBLE
99318: LD_INT 1
99320: DEC
99321: ST_TO_ADDR
99322: LD_INT 4
99324: PUSH
99325: FOR_TO
99326: IFFALSE 99347
// SetSkill ( i , j , 10 ) ;
99328: LD_VAR 0 2
99332: PPUSH
99333: LD_VAR 0 3
99337: PPUSH
99338: LD_INT 10
99340: PPUSH
99341: CALL_OW 237
99345: GO 99325
99347: POP
99348: POP
// end ;
99349: GO 99298
99351: POP
99352: POP
// end ;
99353: LD_VAR 0 1
99357: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99358: LD_INT 0
99360: PPUSH
99361: PPUSH
99362: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99363: LD_ADDR_VAR 0 2
99367: PUSH
99368: LD_INT 22
99370: PUSH
99371: LD_OWVAR 2
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PUSH
99380: LD_INT 21
99382: PUSH
99383: LD_INT 1
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: PUSH
99390: EMPTY
99391: LIST
99392: LIST
99393: PPUSH
99394: CALL_OW 69
99398: PUSH
99399: FOR_IN
99400: IFFALSE 99441
// begin for j := 1 to 4 do
99402: LD_ADDR_VAR 0 3
99406: PUSH
99407: DOUBLE
99408: LD_INT 1
99410: DEC
99411: ST_TO_ADDR
99412: LD_INT 4
99414: PUSH
99415: FOR_TO
99416: IFFALSE 99437
// SetSkill ( i , j , 10 ) ;
99418: LD_VAR 0 2
99422: PPUSH
99423: LD_VAR 0 3
99427: PPUSH
99428: LD_INT 10
99430: PPUSH
99431: CALL_OW 237
99435: GO 99415
99437: POP
99438: POP
// end ;
99439: GO 99399
99441: POP
99442: POP
// end ;
99443: LD_VAR 0 1
99447: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99448: LD_INT 0
99450: PPUSH
// uc_side := your_side ;
99451: LD_ADDR_OWVAR 20
99455: PUSH
99456: LD_OWVAR 2
99460: ST_TO_ADDR
// uc_nation := nation ;
99461: LD_ADDR_OWVAR 21
99465: PUSH
99466: LD_VAR 0 1
99470: ST_TO_ADDR
// InitHc ;
99471: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99475: LD_INT 0
99477: PPUSH
99478: LD_VAR 0 2
99482: PPUSH
99483: LD_VAR 0 3
99487: PPUSH
99488: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99492: LD_VAR 0 4
99496: PPUSH
99497: LD_VAR 0 5
99501: PPUSH
99502: CALL_OW 428
99506: PUSH
99507: LD_INT 0
99509: EQUAL
99510: IFFALSE 99534
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99512: CALL_OW 44
99516: PPUSH
99517: LD_VAR 0 4
99521: PPUSH
99522: LD_VAR 0 5
99526: PPUSH
99527: LD_INT 1
99529: PPUSH
99530: CALL_OW 48
// end ;
99534: LD_VAR 0 6
99538: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99539: LD_INT 0
99541: PPUSH
99542: PPUSH
// uc_side := your_side ;
99543: LD_ADDR_OWVAR 20
99547: PUSH
99548: LD_OWVAR 2
99552: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99553: LD_VAR 0 1
99557: PUSH
99558: LD_INT 1
99560: PUSH
99561: LD_INT 2
99563: PUSH
99564: LD_INT 3
99566: PUSH
99567: LD_INT 4
99569: PUSH
99570: LD_INT 5
99572: PUSH
99573: EMPTY
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: IN
99580: IFFALSE 99592
// uc_nation := nation_american else
99582: LD_ADDR_OWVAR 21
99586: PUSH
99587: LD_INT 1
99589: ST_TO_ADDR
99590: GO 99635
// if chassis in [ 11 , 12 , 13 , 14 ] then
99592: LD_VAR 0 1
99596: PUSH
99597: LD_INT 11
99599: PUSH
99600: LD_INT 12
99602: PUSH
99603: LD_INT 13
99605: PUSH
99606: LD_INT 14
99608: PUSH
99609: EMPTY
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: IN
99615: IFFALSE 99627
// uc_nation := nation_arabian else
99617: LD_ADDR_OWVAR 21
99621: PUSH
99622: LD_INT 2
99624: ST_TO_ADDR
99625: GO 99635
// uc_nation := nation_russian ;
99627: LD_ADDR_OWVAR 21
99631: PUSH
99632: LD_INT 3
99634: ST_TO_ADDR
// vc_chassis := chassis ;
99635: LD_ADDR_OWVAR 37
99639: PUSH
99640: LD_VAR 0 1
99644: ST_TO_ADDR
// vc_engine := engine ;
99645: LD_ADDR_OWVAR 39
99649: PUSH
99650: LD_VAR 0 2
99654: ST_TO_ADDR
// vc_control := control ;
99655: LD_ADDR_OWVAR 38
99659: PUSH
99660: LD_VAR 0 3
99664: ST_TO_ADDR
// vc_weapon := weapon ;
99665: LD_ADDR_OWVAR 40
99669: PUSH
99670: LD_VAR 0 4
99674: ST_TO_ADDR
// un := CreateVehicle ;
99675: LD_ADDR_VAR 0 8
99679: PUSH
99680: CALL_OW 45
99684: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99685: LD_VAR 0 8
99689: PPUSH
99690: LD_INT 0
99692: PPUSH
99693: LD_INT 5
99695: PPUSH
99696: CALL_OW 12
99700: PPUSH
99701: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99705: LD_VAR 0 8
99709: PPUSH
99710: LD_VAR 0 5
99714: PPUSH
99715: LD_VAR 0 6
99719: PPUSH
99720: LD_INT 1
99722: PPUSH
99723: CALL_OW 48
// end ;
99727: LD_VAR 0 7
99731: RET
// export hInvincible ; every 1 do
99732: GO 99734
99734: DISABLE
// hInvincible := [ ] ;
99735: LD_ADDR_EXP 152
99739: PUSH
99740: EMPTY
99741: ST_TO_ADDR
99742: END
// every 10 do var i ;
99743: GO 99745
99745: DISABLE
99746: LD_INT 0
99748: PPUSH
// begin enable ;
99749: ENABLE
// if not hInvincible then
99750: LD_EXP 152
99754: NOT
99755: IFFALSE 99759
// exit ;
99757: GO 99803
// for i in hInvincible do
99759: LD_ADDR_VAR 0 1
99763: PUSH
99764: LD_EXP 152
99768: PUSH
99769: FOR_IN
99770: IFFALSE 99801
// if GetLives ( i ) < 1000 then
99772: LD_VAR 0 1
99776: PPUSH
99777: CALL_OW 256
99781: PUSH
99782: LD_INT 1000
99784: LESS
99785: IFFALSE 99799
// SetLives ( i , 1000 ) ;
99787: LD_VAR 0 1
99791: PPUSH
99792: LD_INT 1000
99794: PPUSH
99795: CALL_OW 234
99799: GO 99769
99801: POP
99802: POP
// end ;
99803: PPOPN 1
99805: END
// export function hHackInvincible ; var i ; begin
99806: LD_INT 0
99808: PPUSH
99809: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99810: LD_ADDR_VAR 0 2
99814: PUSH
99815: LD_INT 2
99817: PUSH
99818: LD_INT 21
99820: PUSH
99821: LD_INT 1
99823: PUSH
99824: EMPTY
99825: LIST
99826: LIST
99827: PUSH
99828: LD_INT 21
99830: PUSH
99831: LD_INT 2
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: PUSH
99838: EMPTY
99839: LIST
99840: LIST
99841: LIST
99842: PPUSH
99843: CALL_OW 69
99847: PUSH
99848: FOR_IN
99849: IFFALSE 99910
// if IsSelected ( i ) then
99851: LD_VAR 0 2
99855: PPUSH
99856: CALL_OW 306
99860: IFFALSE 99908
// begin if i in hInvincible then
99862: LD_VAR 0 2
99866: PUSH
99867: LD_EXP 152
99871: IN
99872: IFFALSE 99892
// hInvincible := hInvincible diff i else
99874: LD_ADDR_EXP 152
99878: PUSH
99879: LD_EXP 152
99883: PUSH
99884: LD_VAR 0 2
99888: DIFF
99889: ST_TO_ADDR
99890: GO 99908
// hInvincible := hInvincible union i ;
99892: LD_ADDR_EXP 152
99896: PUSH
99897: LD_EXP 152
99901: PUSH
99902: LD_VAR 0 2
99906: UNION
99907: ST_TO_ADDR
// end ;
99908: GO 99848
99910: POP
99911: POP
// end ;
99912: LD_VAR 0 1
99916: RET
// export function hHackInvisible ; var i , j ; begin
99917: LD_INT 0
99919: PPUSH
99920: PPUSH
99921: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99922: LD_ADDR_VAR 0 2
99926: PUSH
99927: LD_INT 21
99929: PUSH
99930: LD_INT 1
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PPUSH
99937: CALL_OW 69
99941: PUSH
99942: FOR_IN
99943: IFFALSE 99967
// if IsSelected ( i ) then
99945: LD_VAR 0 2
99949: PPUSH
99950: CALL_OW 306
99954: IFFALSE 99965
// ComForceInvisible ( i ) ;
99956: LD_VAR 0 2
99960: PPUSH
99961: CALL_OW 496
99965: GO 99942
99967: POP
99968: POP
// end ;
99969: LD_VAR 0 1
99973: RET
// export function hHackChangeYourSide ; begin
99974: LD_INT 0
99976: PPUSH
// if your_side = 8 then
99977: LD_OWVAR 2
99981: PUSH
99982: LD_INT 8
99984: EQUAL
99985: IFFALSE 99997
// your_side := 0 else
99987: LD_ADDR_OWVAR 2
99991: PUSH
99992: LD_INT 0
99994: ST_TO_ADDR
99995: GO 100011
// your_side := your_side + 1 ;
99997: LD_ADDR_OWVAR 2
100001: PUSH
100002: LD_OWVAR 2
100006: PUSH
100007: LD_INT 1
100009: PLUS
100010: ST_TO_ADDR
// end ;
100011: LD_VAR 0 1
100015: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100016: LD_INT 0
100018: PPUSH
100019: PPUSH
100020: PPUSH
// for i in all_units do
100021: LD_ADDR_VAR 0 2
100025: PUSH
100026: LD_OWVAR 3
100030: PUSH
100031: FOR_IN
100032: IFFALSE 100110
// if IsSelected ( i ) then
100034: LD_VAR 0 2
100038: PPUSH
100039: CALL_OW 306
100043: IFFALSE 100108
// begin j := GetSide ( i ) ;
100045: LD_ADDR_VAR 0 3
100049: PUSH
100050: LD_VAR 0 2
100054: PPUSH
100055: CALL_OW 255
100059: ST_TO_ADDR
// if j = 8 then
100060: LD_VAR 0 3
100064: PUSH
100065: LD_INT 8
100067: EQUAL
100068: IFFALSE 100080
// j := 0 else
100070: LD_ADDR_VAR 0 3
100074: PUSH
100075: LD_INT 0
100077: ST_TO_ADDR
100078: GO 100094
// j := j + 1 ;
100080: LD_ADDR_VAR 0 3
100084: PUSH
100085: LD_VAR 0 3
100089: PUSH
100090: LD_INT 1
100092: PLUS
100093: ST_TO_ADDR
// SetSide ( i , j ) ;
100094: LD_VAR 0 2
100098: PPUSH
100099: LD_VAR 0 3
100103: PPUSH
100104: CALL_OW 235
// end ;
100108: GO 100031
100110: POP
100111: POP
// end ;
100112: LD_VAR 0 1
100116: RET
// export function hHackFog ; begin
100117: LD_INT 0
100119: PPUSH
// FogOff ( true ) ;
100120: LD_INT 1
100122: PPUSH
100123: CALL_OW 344
// end ;
100127: LD_VAR 0 1
100131: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100132: LD_INT 0
100134: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100135: LD_VAR 0 1
100139: PPUSH
100140: LD_VAR 0 2
100144: PPUSH
100145: LD_VAR 0 3
100149: PPUSH
100150: LD_INT 1
100152: PPUSH
100153: LD_INT 1
100155: PPUSH
100156: CALL_OW 483
// CenterOnXY ( x , y ) ;
100160: LD_VAR 0 2
100164: PPUSH
100165: LD_VAR 0 3
100169: PPUSH
100170: CALL_OW 84
// end ;
100174: LD_VAR 0 4
100178: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
100179: LD_INT 0
100181: PPUSH
100182: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
100183: LD_VAR 0 1
100187: NOT
100188: PUSH
100189: LD_VAR 0 2
100193: PPUSH
100194: LD_VAR 0 3
100198: PPUSH
100199: CALL_OW 488
100203: NOT
100204: OR
100205: PUSH
100206: LD_VAR 0 1
100210: PPUSH
100211: CALL_OW 266
100215: PUSH
100216: LD_INT 3
100218: NONEQUAL
100219: PUSH
100220: LD_VAR 0 1
100224: PPUSH
100225: CALL_OW 247
100229: PUSH
100230: LD_INT 1
100232: EQUAL
100233: NOT
100234: AND
100235: OR
100236: IFFALSE 100240
// exit ;
100238: GO 100389
// if GetType ( factory ) = unit_human then
100240: LD_VAR 0 1
100244: PPUSH
100245: CALL_OW 247
100249: PUSH
100250: LD_INT 1
100252: EQUAL
100253: IFFALSE 100270
// factory := IsInUnit ( factory ) ;
100255: LD_ADDR_VAR 0 1
100259: PUSH
100260: LD_VAR 0 1
100264: PPUSH
100265: CALL_OW 310
100269: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100270: LD_VAR 0 1
100274: PPUSH
100275: CALL_OW 266
100279: PUSH
100280: LD_INT 3
100282: NONEQUAL
100283: IFFALSE 100287
// exit ;
100285: GO 100389
// if HexInfo ( x , y ) = factory then
100287: LD_VAR 0 2
100291: PPUSH
100292: LD_VAR 0 3
100296: PPUSH
100297: CALL_OW 428
100301: PUSH
100302: LD_VAR 0 1
100306: EQUAL
100307: IFFALSE 100334
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100309: LD_ADDR_EXP 153
100313: PUSH
100314: LD_EXP 153
100318: PPUSH
100319: LD_VAR 0 1
100323: PPUSH
100324: LD_INT 0
100326: PPUSH
100327: CALL_OW 1
100331: ST_TO_ADDR
100332: GO 100385
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100334: LD_ADDR_EXP 153
100338: PUSH
100339: LD_EXP 153
100343: PPUSH
100344: LD_VAR 0 1
100348: PPUSH
100349: LD_VAR 0 1
100353: PPUSH
100354: CALL_OW 255
100358: PUSH
100359: LD_VAR 0 1
100363: PUSH
100364: LD_VAR 0 2
100368: PUSH
100369: LD_VAR 0 3
100373: PUSH
100374: EMPTY
100375: LIST
100376: LIST
100377: LIST
100378: LIST
100379: PPUSH
100380: CALL_OW 1
100384: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100385: CALL 100394 0 0
// end ;
100389: LD_VAR 0 4
100393: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
100394: LD_INT 0
100396: PPUSH
100397: PPUSH
100398: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100399: LD_STRING resetFactoryWaypoint();
100401: PPUSH
100402: CALL_OW 559
// if factoryWaypoints then
100406: LD_EXP 153
100410: IFFALSE 100536
// begin list := PrepareArray ( factoryWaypoints ) ;
100412: LD_ADDR_VAR 0 3
100416: PUSH
100417: LD_EXP 153
100421: PPUSH
100422: CALL 54837 0 1
100426: ST_TO_ADDR
// for i := 1 to list do
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: DOUBLE
100433: LD_INT 1
100435: DEC
100436: ST_TO_ADDR
100437: LD_VAR 0 3
100441: PUSH
100442: FOR_TO
100443: IFFALSE 100534
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100445: LD_STRING setFactoryWaypointXY(
100447: PUSH
100448: LD_VAR 0 3
100452: PUSH
100453: LD_VAR 0 2
100457: ARRAY
100458: PUSH
100459: LD_INT 1
100461: ARRAY
100462: STR
100463: PUSH
100464: LD_STRING ,
100466: STR
100467: PUSH
100468: LD_VAR 0 3
100472: PUSH
100473: LD_VAR 0 2
100477: ARRAY
100478: PUSH
100479: LD_INT 2
100481: ARRAY
100482: STR
100483: PUSH
100484: LD_STRING ,
100486: STR
100487: PUSH
100488: LD_VAR 0 3
100492: PUSH
100493: LD_VAR 0 2
100497: ARRAY
100498: PUSH
100499: LD_INT 3
100501: ARRAY
100502: STR
100503: PUSH
100504: LD_STRING ,
100506: STR
100507: PUSH
100508: LD_VAR 0 3
100512: PUSH
100513: LD_VAR 0 2
100517: ARRAY
100518: PUSH
100519: LD_INT 4
100521: ARRAY
100522: STR
100523: PUSH
100524: LD_STRING )
100526: STR
100527: PPUSH
100528: CALL_OW 559
100532: GO 100442
100534: POP
100535: POP
// end ; end ;
100536: LD_VAR 0 1
100540: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
100541: LD_INT 0
100543: PPUSH
// if HexInfo ( x , y ) = warehouse then
100544: LD_VAR 0 2
100548: PPUSH
100549: LD_VAR 0 3
100553: PPUSH
100554: CALL_OW 428
100558: PUSH
100559: LD_VAR 0 1
100563: EQUAL
100564: IFFALSE 100591
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
100566: LD_ADDR_EXP 154
100570: PUSH
100571: LD_EXP 154
100575: PPUSH
100576: LD_VAR 0 1
100580: PPUSH
100581: LD_INT 0
100583: PPUSH
100584: CALL_OW 1
100588: ST_TO_ADDR
100589: GO 100642
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
100591: LD_ADDR_EXP 154
100595: PUSH
100596: LD_EXP 154
100600: PPUSH
100601: LD_VAR 0 1
100605: PPUSH
100606: LD_VAR 0 1
100610: PPUSH
100611: CALL_OW 255
100615: PUSH
100616: LD_VAR 0 1
100620: PUSH
100621: LD_VAR 0 2
100625: PUSH
100626: LD_VAR 0 3
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: PPUSH
100637: CALL_OW 1
100641: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
100642: CALL 100651 0 0
// end ;
100646: LD_VAR 0 4
100650: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
100651: LD_INT 0
100653: PPUSH
100654: PPUSH
100655: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
100656: LD_STRING resetWarehouseGatheringPoints();
100658: PPUSH
100659: CALL_OW 559
// if warehouseGatheringPoints then
100663: LD_EXP 154
100667: IFFALSE 100793
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
100669: LD_ADDR_VAR 0 3
100673: PUSH
100674: LD_EXP 154
100678: PPUSH
100679: CALL 54837 0 1
100683: ST_TO_ADDR
// for i := 1 to list do
100684: LD_ADDR_VAR 0 2
100688: PUSH
100689: DOUBLE
100690: LD_INT 1
100692: DEC
100693: ST_TO_ADDR
100694: LD_VAR 0 3
100698: PUSH
100699: FOR_TO
100700: IFFALSE 100791
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100702: LD_STRING setWarehouseGatheringPointXY(
100704: PUSH
100705: LD_VAR 0 3
100709: PUSH
100710: LD_VAR 0 2
100714: ARRAY
100715: PUSH
100716: LD_INT 1
100718: ARRAY
100719: STR
100720: PUSH
100721: LD_STRING ,
100723: STR
100724: PUSH
100725: LD_VAR 0 3
100729: PUSH
100730: LD_VAR 0 2
100734: ARRAY
100735: PUSH
100736: LD_INT 2
100738: ARRAY
100739: STR
100740: PUSH
100741: LD_STRING ,
100743: STR
100744: PUSH
100745: LD_VAR 0 3
100749: PUSH
100750: LD_VAR 0 2
100754: ARRAY
100755: PUSH
100756: LD_INT 3
100758: ARRAY
100759: STR
100760: PUSH
100761: LD_STRING ,
100763: STR
100764: PUSH
100765: LD_VAR 0 3
100769: PUSH
100770: LD_VAR 0 2
100774: ARRAY
100775: PUSH
100776: LD_INT 4
100778: ARRAY
100779: STR
100780: PUSH
100781: LD_STRING )
100783: STR
100784: PPUSH
100785: CALL_OW 559
100789: GO 100699
100791: POP
100792: POP
// end ; end ;
100793: LD_VAR 0 1
100797: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
100798: LD_EXP 154
100802: IFFALSE 101487
100804: GO 100806
100806: DISABLE
100807: LD_INT 0
100809: PPUSH
100810: PPUSH
100811: PPUSH
100812: PPUSH
100813: PPUSH
100814: PPUSH
100815: PPUSH
100816: PPUSH
100817: PPUSH
// begin enable ;
100818: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
100819: LD_ADDR_VAR 0 3
100823: PUSH
100824: LD_EXP 154
100828: PPUSH
100829: CALL 54837 0 1
100833: ST_TO_ADDR
// if not list then
100834: LD_VAR 0 3
100838: NOT
100839: IFFALSE 100843
// exit ;
100841: GO 101487
// for i := 1 to list do
100843: LD_ADDR_VAR 0 1
100847: PUSH
100848: DOUBLE
100849: LD_INT 1
100851: DEC
100852: ST_TO_ADDR
100853: LD_VAR 0 3
100857: PUSH
100858: FOR_TO
100859: IFFALSE 101485
// begin depot := list [ i ] [ 2 ] ;
100861: LD_ADDR_VAR 0 8
100865: PUSH
100866: LD_VAR 0 3
100870: PUSH
100871: LD_VAR 0 1
100875: ARRAY
100876: PUSH
100877: LD_INT 2
100879: ARRAY
100880: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
100881: LD_ADDR_VAR 0 5
100885: PUSH
100886: LD_VAR 0 3
100890: PUSH
100891: LD_VAR 0 1
100895: ARRAY
100896: PUSH
100897: LD_INT 1
100899: ARRAY
100900: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
100901: LD_VAR 0 8
100905: PPUSH
100906: CALL_OW 301
100910: PUSH
100911: LD_VAR 0 5
100915: PUSH
100916: LD_VAR 0 8
100920: PPUSH
100921: CALL_OW 255
100925: NONEQUAL
100926: OR
100927: IFFALSE 100956
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
100929: LD_ADDR_EXP 154
100933: PUSH
100934: LD_EXP 154
100938: PPUSH
100939: LD_VAR 0 8
100943: PPUSH
100944: LD_INT 0
100946: PPUSH
100947: CALL_OW 1
100951: ST_TO_ADDR
// exit ;
100952: POP
100953: POP
100954: GO 101487
// end ; x := list [ i ] [ 3 ] ;
100956: LD_ADDR_VAR 0 6
100960: PUSH
100961: LD_VAR 0 3
100965: PUSH
100966: LD_VAR 0 1
100970: ARRAY
100971: PUSH
100972: LD_INT 3
100974: ARRAY
100975: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
100976: LD_ADDR_VAR 0 7
100980: PUSH
100981: LD_VAR 0 3
100985: PUSH
100986: LD_VAR 0 1
100990: ARRAY
100991: PUSH
100992: LD_INT 4
100994: ARRAY
100995: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
100996: LD_ADDR_VAR 0 9
101000: PUSH
101001: LD_VAR 0 6
101005: PPUSH
101006: LD_VAR 0 7
101010: PPUSH
101011: LD_INT 16
101013: PPUSH
101014: CALL 53425 0 3
101018: ST_TO_ADDR
// if not cratesNearbyPoint then
101019: LD_VAR 0 9
101023: NOT
101024: IFFALSE 101030
// exit ;
101026: POP
101027: POP
101028: GO 101487
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
101030: LD_ADDR_VAR 0 4
101034: PUSH
101035: LD_INT 22
101037: PUSH
101038: LD_VAR 0 5
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: PUSH
101047: LD_INT 3
101049: PUSH
101050: LD_INT 60
101052: PUSH
101053: EMPTY
101054: LIST
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: LD_INT 91
101062: PUSH
101063: LD_VAR 0 8
101067: PUSH
101068: LD_INT 6
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: LIST
101075: PUSH
101076: LD_INT 2
101078: PUSH
101079: LD_INT 25
101081: PUSH
101082: LD_INT 2
101084: PUSH
101085: EMPTY
101086: LIST
101087: LIST
101088: PUSH
101089: LD_INT 25
101091: PUSH
101092: LD_INT 16
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: PUSH
101099: EMPTY
101100: LIST
101101: LIST
101102: LIST
101103: PUSH
101104: EMPTY
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: PPUSH
101110: CALL_OW 69
101114: PUSH
101115: LD_VAR 0 8
101119: PPUSH
101120: CALL_OW 313
101124: PPUSH
101125: LD_INT 3
101127: PUSH
101128: LD_INT 60
101130: PUSH
101131: EMPTY
101132: LIST
101133: PUSH
101134: EMPTY
101135: LIST
101136: LIST
101137: PUSH
101138: LD_INT 2
101140: PUSH
101141: LD_INT 25
101143: PUSH
101144: LD_INT 2
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PUSH
101151: LD_INT 25
101153: PUSH
101154: LD_INT 16
101156: PUSH
101157: EMPTY
101158: LIST
101159: LIST
101160: PUSH
101161: EMPTY
101162: LIST
101163: LIST
101164: LIST
101165: PUSH
101166: EMPTY
101167: LIST
101168: LIST
101169: PPUSH
101170: CALL_OW 72
101174: UNION
101175: ST_TO_ADDR
// if tmp then
101176: LD_VAR 0 4
101180: IFFALSE 101260
// begin tmp := ShrinkArray ( tmp , 3 ) ;
101182: LD_ADDR_VAR 0 4
101186: PUSH
101187: LD_VAR 0 4
101191: PPUSH
101192: LD_INT 3
101194: PPUSH
101195: CALL 51394 0 2
101199: ST_TO_ADDR
// for j in tmp do
101200: LD_ADDR_VAR 0 2
101204: PUSH
101205: LD_VAR 0 4
101209: PUSH
101210: FOR_IN
101211: IFFALSE 101254
// begin if IsInUnit ( j ) then
101213: LD_VAR 0 2
101217: PPUSH
101218: CALL_OW 310
101222: IFFALSE 101233
// ComExit ( j ) ;
101224: LD_VAR 0 2
101228: PPUSH
101229: CALL 51477 0 1
// AddComCollect ( j , x , y ) ;
101233: LD_VAR 0 2
101237: PPUSH
101238: LD_VAR 0 6
101242: PPUSH
101243: LD_VAR 0 7
101247: PPUSH
101248: CALL_OW 177
// end ;
101252: GO 101210
101254: POP
101255: POP
// exit ;
101256: POP
101257: POP
101258: GO 101487
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
101260: LD_ADDR_VAR 0 4
101264: PUSH
101265: LD_INT 22
101267: PUSH
101268: LD_VAR 0 5
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PUSH
101277: LD_INT 91
101279: PUSH
101280: LD_VAR 0 8
101284: PUSH
101285: LD_INT 8
101287: PUSH
101288: EMPTY
101289: LIST
101290: LIST
101291: LIST
101292: PUSH
101293: LD_INT 2
101295: PUSH
101296: LD_INT 34
101298: PUSH
101299: LD_INT 12
101301: PUSH
101302: EMPTY
101303: LIST
101304: LIST
101305: PUSH
101306: LD_INT 34
101308: PUSH
101309: LD_INT 51
101311: PUSH
101312: EMPTY
101313: LIST
101314: LIST
101315: PUSH
101316: LD_INT 34
101318: PUSH
101319: LD_INT 32
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 34
101328: PUSH
101329: LD_INT 89
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: LIST
101340: LIST
101341: LIST
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: LIST
101347: PPUSH
101348: CALL_OW 69
101352: ST_TO_ADDR
// if tmp then
101353: LD_VAR 0 4
101357: IFFALSE 101483
// begin for j in tmp do
101359: LD_ADDR_VAR 0 2
101363: PUSH
101364: LD_VAR 0 4
101368: PUSH
101369: FOR_IN
101370: IFFALSE 101481
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
101372: LD_VAR 0 2
101376: PPUSH
101377: CALL_OW 262
101381: PUSH
101382: LD_INT 3
101384: EQUAL
101385: PUSH
101386: LD_VAR 0 2
101390: PPUSH
101391: CALL_OW 261
101395: PUSH
101396: LD_INT 20
101398: GREATER
101399: OR
101400: PUSH
101401: LD_VAR 0 2
101405: PPUSH
101406: CALL_OW 314
101410: NOT
101411: AND
101412: PUSH
101413: LD_VAR 0 2
101417: PPUSH
101418: CALL_OW 263
101422: PUSH
101423: LD_INT 1
101425: NONEQUAL
101426: PUSH
101427: LD_VAR 0 2
101431: PPUSH
101432: CALL_OW 311
101436: OR
101437: AND
101438: IFFALSE 101479
// begin ComCollect ( j , x , y ) ;
101440: LD_VAR 0 2
101444: PPUSH
101445: LD_VAR 0 6
101449: PPUSH
101450: LD_VAR 0 7
101454: PPUSH
101455: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
101459: LD_VAR 0 2
101463: PPUSH
101464: LD_VAR 0 8
101468: PPUSH
101469: CALL_OW 172
// exit ;
101473: POP
101474: POP
101475: POP
101476: POP
101477: GO 101487
// end ;
101479: GO 101369
101481: POP
101482: POP
// end ; end ;
101483: GO 100858
101485: POP
101486: POP
// end ; end_of_file
101487: PPOPN 9
101489: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101490: LD_INT 0
101492: PPUSH
101493: PPUSH
101494: PPUSH
101495: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101496: LD_VAR 0 1
101500: PPUSH
101501: CALL_OW 264
101505: PUSH
101506: LD_INT 91
101508: EQUAL
101509: IFFALSE 101581
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101511: LD_INT 68
101513: PPUSH
101514: LD_VAR 0 1
101518: PPUSH
101519: CALL_OW 255
101523: PPUSH
101524: CALL_OW 321
101528: PUSH
101529: LD_INT 2
101531: EQUAL
101532: IFFALSE 101544
// eff := 70 else
101534: LD_ADDR_VAR 0 4
101538: PUSH
101539: LD_INT 70
101541: ST_TO_ADDR
101542: GO 101552
// eff := 30 ;
101544: LD_ADDR_VAR 0 4
101548: PUSH
101549: LD_INT 30
101551: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101552: LD_VAR 0 1
101556: PPUSH
101557: CALL_OW 250
101561: PPUSH
101562: LD_VAR 0 1
101566: PPUSH
101567: CALL_OW 251
101571: PPUSH
101572: LD_VAR 0 4
101576: PPUSH
101577: CALL_OW 495
// end ; end ;
101581: LD_VAR 0 2
101585: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101586: LD_INT 0
101588: PPUSH
// end ;
101589: LD_VAR 0 4
101593: RET
// export function SOS_Command ( cmd ) ; begin
101594: LD_INT 0
101596: PPUSH
// end ;
101597: LD_VAR 0 2
101601: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101602: LD_INT 0
101604: PPUSH
// end ;
101605: LD_VAR 0 6
101609: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
101610: LD_INT 0
101612: PPUSH
101613: PPUSH
// if not vehicle or not factory then
101614: LD_VAR 0 1
101618: NOT
101619: PUSH
101620: LD_VAR 0 2
101624: NOT
101625: OR
101626: IFFALSE 101630
// exit ;
101628: GO 101861
// if factoryWaypoints >= factory then
101630: LD_EXP 153
101634: PUSH
101635: LD_VAR 0 2
101639: GREATEREQUAL
101640: IFFALSE 101861
// if factoryWaypoints [ factory ] then
101642: LD_EXP 153
101646: PUSH
101647: LD_VAR 0 2
101651: ARRAY
101652: IFFALSE 101861
// begin if GetControl ( vehicle ) = control_manual then
101654: LD_VAR 0 1
101658: PPUSH
101659: CALL_OW 263
101663: PUSH
101664: LD_INT 1
101666: EQUAL
101667: IFFALSE 101748
// begin driver := IsDrivenBy ( vehicle ) ;
101669: LD_ADDR_VAR 0 4
101673: PUSH
101674: LD_VAR 0 1
101678: PPUSH
101679: CALL_OW 311
101683: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101684: LD_VAR 0 4
101688: PPUSH
101689: LD_EXP 153
101693: PUSH
101694: LD_VAR 0 2
101698: ARRAY
101699: PUSH
101700: LD_INT 3
101702: ARRAY
101703: PPUSH
101704: LD_EXP 153
101708: PUSH
101709: LD_VAR 0 2
101713: ARRAY
101714: PUSH
101715: LD_INT 4
101717: ARRAY
101718: PPUSH
101719: CALL_OW 171
// AddComExitVehicle ( driver ) ;
101723: LD_VAR 0 4
101727: PPUSH
101728: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
101732: LD_VAR 0 4
101736: PPUSH
101737: LD_VAR 0 2
101741: PPUSH
101742: CALL_OW 180
// end else
101746: GO 101861
// if GetControl ( vehicle ) = control_remote then
101748: LD_VAR 0 1
101752: PPUSH
101753: CALL_OW 263
101757: PUSH
101758: LD_INT 2
101760: EQUAL
101761: IFFALSE 101822
// begin wait ( 0 0$2 ) ;
101763: LD_INT 70
101765: PPUSH
101766: CALL_OW 67
// if Connect ( vehicle ) then
101770: LD_VAR 0 1
101774: PPUSH
101775: CALL 21717 0 1
101779: IFFALSE 101820
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101781: LD_VAR 0 1
101785: PPUSH
101786: LD_EXP 153
101790: PUSH
101791: LD_VAR 0 2
101795: ARRAY
101796: PUSH
101797: LD_INT 3
101799: ARRAY
101800: PPUSH
101801: LD_EXP 153
101805: PUSH
101806: LD_VAR 0 2
101810: ARRAY
101811: PUSH
101812: LD_INT 4
101814: ARRAY
101815: PPUSH
101816: CALL_OW 171
// end else
101820: GO 101861
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101822: LD_VAR 0 1
101826: PPUSH
101827: LD_EXP 153
101831: PUSH
101832: LD_VAR 0 2
101836: ARRAY
101837: PUSH
101838: LD_INT 3
101840: ARRAY
101841: PPUSH
101842: LD_EXP 153
101846: PUSH
101847: LD_VAR 0 2
101851: ARRAY
101852: PUSH
101853: LD_INT 4
101855: ARRAY
101856: PPUSH
101857: CALL_OW 171
// end ; end ;
101861: LD_VAR 0 3
101865: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101866: LD_INT 0
101868: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101869: LD_VAR 0 1
101873: PUSH
101874: LD_INT 250
101876: EQUAL
101877: PUSH
101878: LD_VAR 0 2
101882: PPUSH
101883: CALL_OW 264
101887: PUSH
101888: LD_INT 81
101890: EQUAL
101891: AND
101892: IFFALSE 101913
// MinerPlaceMine ( unit , x , y ) ;
101894: LD_VAR 0 2
101898: PPUSH
101899: LD_VAR 0 4
101903: PPUSH
101904: LD_VAR 0 5
101908: PPUSH
101909: CALL 104298 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101913: LD_VAR 0 1
101917: PUSH
101918: LD_INT 251
101920: EQUAL
101921: PUSH
101922: LD_VAR 0 2
101926: PPUSH
101927: CALL_OW 264
101931: PUSH
101932: LD_INT 81
101934: EQUAL
101935: AND
101936: IFFALSE 101957
// MinerDetonateMine ( unit , x , y ) ;
101938: LD_VAR 0 2
101942: PPUSH
101943: LD_VAR 0 4
101947: PPUSH
101948: LD_VAR 0 5
101952: PPUSH
101953: CALL 104573 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101957: LD_VAR 0 1
101961: PUSH
101962: LD_INT 252
101964: EQUAL
101965: PUSH
101966: LD_VAR 0 2
101970: PPUSH
101971: CALL_OW 264
101975: PUSH
101976: LD_INT 81
101978: EQUAL
101979: AND
101980: IFFALSE 102001
// MinerCreateMinefield ( unit , x , y ) ;
101982: LD_VAR 0 2
101986: PPUSH
101987: LD_VAR 0 4
101991: PPUSH
101992: LD_VAR 0 5
101996: PPUSH
101997: CALL 104990 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
102001: LD_VAR 0 1
102005: PUSH
102006: LD_INT 253
102008: EQUAL
102009: PUSH
102010: LD_VAR 0 2
102014: PPUSH
102015: CALL_OW 257
102019: PUSH
102020: LD_INT 5
102022: EQUAL
102023: AND
102024: IFFALSE 102045
// ComBinocular ( unit , x , y ) ;
102026: LD_VAR 0 2
102030: PPUSH
102031: LD_VAR 0 4
102035: PPUSH
102036: LD_VAR 0 5
102040: PPUSH
102041: CALL 105359 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102045: LD_VAR 0 1
102049: PUSH
102050: LD_INT 254
102052: EQUAL
102053: PUSH
102054: LD_VAR 0 2
102058: PPUSH
102059: CALL_OW 264
102063: PUSH
102064: LD_INT 99
102066: EQUAL
102067: AND
102068: PUSH
102069: LD_VAR 0 3
102073: PPUSH
102074: CALL_OW 263
102078: PUSH
102079: LD_INT 3
102081: EQUAL
102082: AND
102083: IFFALSE 102099
// HackDestroyVehicle ( unit , selectedUnit ) ;
102085: LD_VAR 0 2
102089: PPUSH
102090: LD_VAR 0 3
102094: PPUSH
102095: CALL 103662 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102099: LD_VAR 0 1
102103: PUSH
102104: LD_INT 255
102106: EQUAL
102107: PUSH
102108: LD_VAR 0 2
102112: PPUSH
102113: CALL_OW 264
102117: PUSH
102118: LD_INT 14
102120: PUSH
102121: LD_INT 53
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: IN
102128: AND
102129: PUSH
102130: LD_VAR 0 4
102134: PPUSH
102135: LD_VAR 0 5
102139: PPUSH
102140: CALL_OW 488
102144: AND
102145: IFFALSE 102169
// CutTreeXYR ( unit , x , y , 12 ) ;
102147: LD_VAR 0 2
102151: PPUSH
102152: LD_VAR 0 4
102156: PPUSH
102157: LD_VAR 0 5
102161: PPUSH
102162: LD_INT 12
102164: PPUSH
102165: CALL 102232 0 4
// if cmd = 256 then
102169: LD_VAR 0 1
102173: PUSH
102174: LD_INT 256
102176: EQUAL
102177: IFFALSE 102198
// SetFactoryWaypoint ( unit , x , y ) ;
102179: LD_VAR 0 2
102183: PPUSH
102184: LD_VAR 0 4
102188: PPUSH
102189: LD_VAR 0 5
102193: PPUSH
102194: CALL 100179 0 3
// if cmd = 257 then
102198: LD_VAR 0 1
102202: PUSH
102203: LD_INT 257
102205: EQUAL
102206: IFFALSE 102227
// SetWarehouseGatheringPoint ( unit , x , y ) ;
102208: LD_VAR 0 2
102212: PPUSH
102213: LD_VAR 0 4
102217: PPUSH
102218: LD_VAR 0 5
102222: PPUSH
102223: CALL 100541 0 3
// end ;
102227: LD_VAR 0 6
102231: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102232: LD_INT 0
102234: PPUSH
102235: PPUSH
102236: PPUSH
102237: PPUSH
102238: PPUSH
102239: PPUSH
102240: PPUSH
102241: PPUSH
102242: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102243: LD_VAR 0 1
102247: NOT
102248: PUSH
102249: LD_VAR 0 2
102253: PPUSH
102254: LD_VAR 0 3
102258: PPUSH
102259: CALL_OW 488
102263: NOT
102264: OR
102265: PUSH
102266: LD_VAR 0 4
102270: NOT
102271: OR
102272: IFFALSE 102276
// exit ;
102274: GO 102616
// list := [ ] ;
102276: LD_ADDR_VAR 0 13
102280: PUSH
102281: EMPTY
102282: ST_TO_ADDR
// if x - r < 0 then
102283: LD_VAR 0 2
102287: PUSH
102288: LD_VAR 0 4
102292: MINUS
102293: PUSH
102294: LD_INT 0
102296: LESS
102297: IFFALSE 102309
// min_x := 0 else
102299: LD_ADDR_VAR 0 7
102303: PUSH
102304: LD_INT 0
102306: ST_TO_ADDR
102307: GO 102325
// min_x := x - r ;
102309: LD_ADDR_VAR 0 7
102313: PUSH
102314: LD_VAR 0 2
102318: PUSH
102319: LD_VAR 0 4
102323: MINUS
102324: ST_TO_ADDR
// if y - r < 0 then
102325: LD_VAR 0 3
102329: PUSH
102330: LD_VAR 0 4
102334: MINUS
102335: PUSH
102336: LD_INT 0
102338: LESS
102339: IFFALSE 102351
// min_y := 0 else
102341: LD_ADDR_VAR 0 8
102345: PUSH
102346: LD_INT 0
102348: ST_TO_ADDR
102349: GO 102367
// min_y := y - r ;
102351: LD_ADDR_VAR 0 8
102355: PUSH
102356: LD_VAR 0 3
102360: PUSH
102361: LD_VAR 0 4
102365: MINUS
102366: ST_TO_ADDR
// max_x := x + r ;
102367: LD_ADDR_VAR 0 9
102371: PUSH
102372: LD_VAR 0 2
102376: PUSH
102377: LD_VAR 0 4
102381: PLUS
102382: ST_TO_ADDR
// max_y := y + r ;
102383: LD_ADDR_VAR 0 10
102387: PUSH
102388: LD_VAR 0 3
102392: PUSH
102393: LD_VAR 0 4
102397: PLUS
102398: ST_TO_ADDR
// for _x = min_x to max_x do
102399: LD_ADDR_VAR 0 11
102403: PUSH
102404: DOUBLE
102405: LD_VAR 0 7
102409: DEC
102410: ST_TO_ADDR
102411: LD_VAR 0 9
102415: PUSH
102416: FOR_TO
102417: IFFALSE 102534
// for _y = min_y to max_y do
102419: LD_ADDR_VAR 0 12
102423: PUSH
102424: DOUBLE
102425: LD_VAR 0 8
102429: DEC
102430: ST_TO_ADDR
102431: LD_VAR 0 10
102435: PUSH
102436: FOR_TO
102437: IFFALSE 102530
// begin if not ValidHex ( _x , _y ) then
102439: LD_VAR 0 11
102443: PPUSH
102444: LD_VAR 0 12
102448: PPUSH
102449: CALL_OW 488
102453: NOT
102454: IFFALSE 102458
// continue ;
102456: GO 102436
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102458: LD_VAR 0 11
102462: PPUSH
102463: LD_VAR 0 12
102467: PPUSH
102468: CALL_OW 351
102472: PUSH
102473: LD_VAR 0 11
102477: PPUSH
102478: LD_VAR 0 12
102482: PPUSH
102483: CALL_OW 554
102487: AND
102488: IFFALSE 102528
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102490: LD_ADDR_VAR 0 13
102494: PUSH
102495: LD_VAR 0 13
102499: PPUSH
102500: LD_VAR 0 13
102504: PUSH
102505: LD_INT 1
102507: PLUS
102508: PPUSH
102509: LD_VAR 0 11
102513: PUSH
102514: LD_VAR 0 12
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: PPUSH
102523: CALL_OW 2
102527: ST_TO_ADDR
// end ;
102528: GO 102436
102530: POP
102531: POP
102532: GO 102416
102534: POP
102535: POP
// if not list then
102536: LD_VAR 0 13
102540: NOT
102541: IFFALSE 102545
// exit ;
102543: GO 102616
// for i in list do
102545: LD_ADDR_VAR 0 6
102549: PUSH
102550: LD_VAR 0 13
102554: PUSH
102555: FOR_IN
102556: IFFALSE 102614
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102558: LD_VAR 0 1
102562: PPUSH
102563: LD_STRING M
102565: PUSH
102566: LD_VAR 0 6
102570: PUSH
102571: LD_INT 1
102573: ARRAY
102574: PUSH
102575: LD_VAR 0 6
102579: PUSH
102580: LD_INT 2
102582: ARRAY
102583: PUSH
102584: LD_INT 0
102586: PUSH
102587: LD_INT 0
102589: PUSH
102590: LD_INT 0
102592: PUSH
102593: LD_INT 0
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: LIST
102600: LIST
102601: LIST
102602: LIST
102603: LIST
102604: PUSH
102605: EMPTY
102606: LIST
102607: PPUSH
102608: CALL_OW 447
102612: GO 102555
102614: POP
102615: POP
// end ;
102616: LD_VAR 0 5
102620: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102621: LD_EXP 156
102625: NOT
102626: IFFALSE 102676
102628: GO 102630
102630: DISABLE
// begin initHack := true ;
102631: LD_ADDR_EXP 156
102635: PUSH
102636: LD_INT 1
102638: ST_TO_ADDR
// hackTanks := [ ] ;
102639: LD_ADDR_EXP 157
102643: PUSH
102644: EMPTY
102645: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102646: LD_ADDR_EXP 158
102650: PUSH
102651: EMPTY
102652: ST_TO_ADDR
// hackLimit := 3 ;
102653: LD_ADDR_EXP 159
102657: PUSH
102658: LD_INT 3
102660: ST_TO_ADDR
// hackDist := 12 ;
102661: LD_ADDR_EXP 160
102665: PUSH
102666: LD_INT 12
102668: ST_TO_ADDR
// hackCounter := [ ] ;
102669: LD_ADDR_EXP 161
102673: PUSH
102674: EMPTY
102675: ST_TO_ADDR
// end ;
102676: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102677: LD_EXP 156
102681: PUSH
102682: LD_INT 34
102684: PUSH
102685: LD_INT 99
102687: PUSH
102688: EMPTY
102689: LIST
102690: LIST
102691: PPUSH
102692: CALL_OW 69
102696: AND
102697: IFFALSE 102950
102699: GO 102701
102701: DISABLE
102702: LD_INT 0
102704: PPUSH
102705: PPUSH
// begin enable ;
102706: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102707: LD_ADDR_VAR 0 1
102711: PUSH
102712: LD_INT 34
102714: PUSH
102715: LD_INT 99
102717: PUSH
102718: EMPTY
102719: LIST
102720: LIST
102721: PPUSH
102722: CALL_OW 69
102726: PUSH
102727: FOR_IN
102728: IFFALSE 102948
// begin if not i in hackTanks then
102730: LD_VAR 0 1
102734: PUSH
102735: LD_EXP 157
102739: IN
102740: NOT
102741: IFFALSE 102824
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102743: LD_ADDR_EXP 157
102747: PUSH
102748: LD_EXP 157
102752: PPUSH
102753: LD_EXP 157
102757: PUSH
102758: LD_INT 1
102760: PLUS
102761: PPUSH
102762: LD_VAR 0 1
102766: PPUSH
102767: CALL_OW 1
102771: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102772: LD_ADDR_EXP 158
102776: PUSH
102777: LD_EXP 158
102781: PPUSH
102782: LD_EXP 158
102786: PUSH
102787: LD_INT 1
102789: PLUS
102790: PPUSH
102791: EMPTY
102792: PPUSH
102793: CALL_OW 1
102797: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102798: LD_ADDR_EXP 161
102802: PUSH
102803: LD_EXP 161
102807: PPUSH
102808: LD_EXP 161
102812: PUSH
102813: LD_INT 1
102815: PLUS
102816: PPUSH
102817: EMPTY
102818: PPUSH
102819: CALL_OW 1
102823: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102824: LD_VAR 0 1
102828: PPUSH
102829: CALL_OW 302
102833: NOT
102834: IFFALSE 102847
// begin HackUnlinkAll ( i ) ;
102836: LD_VAR 0 1
102840: PPUSH
102841: CALL 102953 0 1
// continue ;
102845: GO 102727
// end ; HackCheckCapturedStatus ( i ) ;
102847: LD_VAR 0 1
102851: PPUSH
102852: CALL 103396 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102856: LD_ADDR_VAR 0 2
102860: PUSH
102861: LD_INT 81
102863: PUSH
102864: LD_VAR 0 1
102868: PPUSH
102869: CALL_OW 255
102873: PUSH
102874: EMPTY
102875: LIST
102876: LIST
102877: PUSH
102878: LD_INT 33
102880: PUSH
102881: LD_INT 3
102883: PUSH
102884: EMPTY
102885: LIST
102886: LIST
102887: PUSH
102888: LD_INT 91
102890: PUSH
102891: LD_VAR 0 1
102895: PUSH
102896: LD_EXP 160
102900: PUSH
102901: EMPTY
102902: LIST
102903: LIST
102904: LIST
102905: PUSH
102906: LD_INT 50
102908: PUSH
102909: EMPTY
102910: LIST
102911: PUSH
102912: EMPTY
102913: LIST
102914: LIST
102915: LIST
102916: LIST
102917: PPUSH
102918: CALL_OW 69
102922: ST_TO_ADDR
// if not tmp then
102923: LD_VAR 0 2
102927: NOT
102928: IFFALSE 102932
// continue ;
102930: GO 102727
// HackLink ( i , tmp ) ;
102932: LD_VAR 0 1
102936: PPUSH
102937: LD_VAR 0 2
102941: PPUSH
102942: CALL 103089 0 2
// end ;
102946: GO 102727
102948: POP
102949: POP
// end ;
102950: PPOPN 2
102952: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102953: LD_INT 0
102955: PPUSH
102956: PPUSH
102957: PPUSH
// if not hack in hackTanks then
102958: LD_VAR 0 1
102962: PUSH
102963: LD_EXP 157
102967: IN
102968: NOT
102969: IFFALSE 102973
// exit ;
102971: GO 103084
// index := GetElementIndex ( hackTanks , hack ) ;
102973: LD_ADDR_VAR 0 4
102977: PUSH
102978: LD_EXP 157
102982: PPUSH
102983: LD_VAR 0 1
102987: PPUSH
102988: CALL 18533 0 2
102992: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102993: LD_EXP 158
102997: PUSH
102998: LD_VAR 0 4
103002: ARRAY
103003: IFFALSE 103084
// begin for i in hackTanksCaptured [ index ] do
103005: LD_ADDR_VAR 0 3
103009: PUSH
103010: LD_EXP 158
103014: PUSH
103015: LD_VAR 0 4
103019: ARRAY
103020: PUSH
103021: FOR_IN
103022: IFFALSE 103048
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
103024: LD_VAR 0 3
103028: PUSH
103029: LD_INT 1
103031: ARRAY
103032: PPUSH
103033: LD_VAR 0 3
103037: PUSH
103038: LD_INT 2
103040: ARRAY
103041: PPUSH
103042: CALL_OW 235
103046: GO 103021
103048: POP
103049: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
103050: LD_ADDR_EXP 158
103054: PUSH
103055: LD_EXP 158
103059: PPUSH
103060: LD_VAR 0 4
103064: PPUSH
103065: EMPTY
103066: PPUSH
103067: CALL_OW 1
103071: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103072: LD_VAR 0 1
103076: PPUSH
103077: LD_INT 0
103079: PPUSH
103080: CALL_OW 505
// end ; end ;
103084: LD_VAR 0 2
103088: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103089: LD_INT 0
103091: PPUSH
103092: PPUSH
103093: PPUSH
// if not hack in hackTanks or not vehicles then
103094: LD_VAR 0 1
103098: PUSH
103099: LD_EXP 157
103103: IN
103104: NOT
103105: PUSH
103106: LD_VAR 0 2
103110: NOT
103111: OR
103112: IFFALSE 103116
// exit ;
103114: GO 103391
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103116: LD_ADDR_VAR 0 2
103120: PUSH
103121: LD_VAR 0 1
103125: PPUSH
103126: LD_VAR 0 2
103130: PPUSH
103131: LD_INT 1
103133: PPUSH
103134: LD_INT 1
103136: PPUSH
103137: CALL 19183 0 4
103141: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103142: LD_ADDR_VAR 0 5
103146: PUSH
103147: LD_EXP 157
103151: PPUSH
103152: LD_VAR 0 1
103156: PPUSH
103157: CALL 18533 0 2
103161: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103162: LD_EXP 158
103166: PUSH
103167: LD_VAR 0 5
103171: ARRAY
103172: PUSH
103173: LD_EXP 159
103177: LESS
103178: IFFALSE 103367
// begin for i := 1 to vehicles do
103180: LD_ADDR_VAR 0 4
103184: PUSH
103185: DOUBLE
103186: LD_INT 1
103188: DEC
103189: ST_TO_ADDR
103190: LD_VAR 0 2
103194: PUSH
103195: FOR_TO
103196: IFFALSE 103365
// begin if hackTanksCaptured [ index ] = hackLimit then
103198: LD_EXP 158
103202: PUSH
103203: LD_VAR 0 5
103207: ARRAY
103208: PUSH
103209: LD_EXP 159
103213: EQUAL
103214: IFFALSE 103218
// break ;
103216: GO 103365
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103218: LD_ADDR_EXP 161
103222: PUSH
103223: LD_EXP 161
103227: PPUSH
103228: LD_VAR 0 5
103232: PPUSH
103233: LD_EXP 161
103237: PUSH
103238: LD_VAR 0 5
103242: ARRAY
103243: PUSH
103244: LD_INT 1
103246: PLUS
103247: PPUSH
103248: CALL_OW 1
103252: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103253: LD_ADDR_EXP 158
103257: PUSH
103258: LD_EXP 158
103262: PPUSH
103263: LD_VAR 0 5
103267: PUSH
103268: LD_EXP 158
103272: PUSH
103273: LD_VAR 0 5
103277: ARRAY
103278: PUSH
103279: LD_INT 1
103281: PLUS
103282: PUSH
103283: EMPTY
103284: LIST
103285: LIST
103286: PPUSH
103287: LD_VAR 0 2
103291: PUSH
103292: LD_VAR 0 4
103296: ARRAY
103297: PUSH
103298: LD_VAR 0 2
103302: PUSH
103303: LD_VAR 0 4
103307: ARRAY
103308: PPUSH
103309: CALL_OW 255
103313: PUSH
103314: EMPTY
103315: LIST
103316: LIST
103317: PPUSH
103318: CALL 18748 0 3
103322: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103323: LD_VAR 0 2
103327: PUSH
103328: LD_VAR 0 4
103332: ARRAY
103333: PPUSH
103334: LD_VAR 0 1
103338: PPUSH
103339: CALL_OW 255
103343: PPUSH
103344: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103348: LD_VAR 0 2
103352: PUSH
103353: LD_VAR 0 4
103357: ARRAY
103358: PPUSH
103359: CALL_OW 141
// end ;
103363: GO 103195
103365: POP
103366: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103367: LD_VAR 0 1
103371: PPUSH
103372: LD_EXP 158
103376: PUSH
103377: LD_VAR 0 5
103381: ARRAY
103382: PUSH
103383: LD_INT 0
103385: PLUS
103386: PPUSH
103387: CALL_OW 505
// end ;
103391: LD_VAR 0 3
103395: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103396: LD_INT 0
103398: PPUSH
103399: PPUSH
103400: PPUSH
103401: PPUSH
// if not hack in hackTanks then
103402: LD_VAR 0 1
103406: PUSH
103407: LD_EXP 157
103411: IN
103412: NOT
103413: IFFALSE 103417
// exit ;
103415: GO 103657
// index := GetElementIndex ( hackTanks , hack ) ;
103417: LD_ADDR_VAR 0 4
103421: PUSH
103422: LD_EXP 157
103426: PPUSH
103427: LD_VAR 0 1
103431: PPUSH
103432: CALL 18533 0 2
103436: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103437: LD_ADDR_VAR 0 3
103441: PUSH
103442: DOUBLE
103443: LD_EXP 158
103447: PUSH
103448: LD_VAR 0 4
103452: ARRAY
103453: INC
103454: ST_TO_ADDR
103455: LD_INT 1
103457: PUSH
103458: FOR_DOWNTO
103459: IFFALSE 103631
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103461: LD_ADDR_VAR 0 5
103465: PUSH
103466: LD_EXP 158
103470: PUSH
103471: LD_VAR 0 4
103475: ARRAY
103476: PUSH
103477: LD_VAR 0 3
103481: ARRAY
103482: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103483: LD_VAR 0 5
103487: PUSH
103488: LD_INT 1
103490: ARRAY
103491: PPUSH
103492: CALL_OW 302
103496: NOT
103497: PUSH
103498: LD_VAR 0 5
103502: PUSH
103503: LD_INT 1
103505: ARRAY
103506: PPUSH
103507: CALL_OW 255
103511: PUSH
103512: LD_VAR 0 1
103516: PPUSH
103517: CALL_OW 255
103521: NONEQUAL
103522: OR
103523: IFFALSE 103629
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103525: LD_VAR 0 5
103529: PUSH
103530: LD_INT 1
103532: ARRAY
103533: PPUSH
103534: CALL_OW 305
103538: PUSH
103539: LD_VAR 0 5
103543: PUSH
103544: LD_INT 1
103546: ARRAY
103547: PPUSH
103548: CALL_OW 255
103552: PUSH
103553: LD_VAR 0 1
103557: PPUSH
103558: CALL_OW 255
103562: EQUAL
103563: AND
103564: IFFALSE 103588
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103566: LD_VAR 0 5
103570: PUSH
103571: LD_INT 1
103573: ARRAY
103574: PPUSH
103575: LD_VAR 0 5
103579: PUSH
103580: LD_INT 2
103582: ARRAY
103583: PPUSH
103584: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103588: LD_ADDR_EXP 158
103592: PUSH
103593: LD_EXP 158
103597: PPUSH
103598: LD_VAR 0 4
103602: PPUSH
103603: LD_EXP 158
103607: PUSH
103608: LD_VAR 0 4
103612: ARRAY
103613: PPUSH
103614: LD_VAR 0 3
103618: PPUSH
103619: CALL_OW 3
103623: PPUSH
103624: CALL_OW 1
103628: ST_TO_ADDR
// end ; end ;
103629: GO 103458
103631: POP
103632: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103633: LD_VAR 0 1
103637: PPUSH
103638: LD_EXP 158
103642: PUSH
103643: LD_VAR 0 4
103647: ARRAY
103648: PUSH
103649: LD_INT 0
103651: PLUS
103652: PPUSH
103653: CALL_OW 505
// end ;
103657: LD_VAR 0 2
103661: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103662: LD_INT 0
103664: PPUSH
103665: PPUSH
103666: PPUSH
103667: PPUSH
// if not hack in hackTanks then
103668: LD_VAR 0 1
103672: PUSH
103673: LD_EXP 157
103677: IN
103678: NOT
103679: IFFALSE 103683
// exit ;
103681: GO 103768
// index := GetElementIndex ( hackTanks , hack ) ;
103683: LD_ADDR_VAR 0 5
103687: PUSH
103688: LD_EXP 157
103692: PPUSH
103693: LD_VAR 0 1
103697: PPUSH
103698: CALL 18533 0 2
103702: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103703: LD_ADDR_VAR 0 4
103707: PUSH
103708: DOUBLE
103709: LD_INT 1
103711: DEC
103712: ST_TO_ADDR
103713: LD_EXP 158
103717: PUSH
103718: LD_VAR 0 5
103722: ARRAY
103723: PUSH
103724: FOR_TO
103725: IFFALSE 103766
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103727: LD_EXP 158
103731: PUSH
103732: LD_VAR 0 5
103736: ARRAY
103737: PUSH
103738: LD_VAR 0 4
103742: ARRAY
103743: PUSH
103744: LD_INT 1
103746: ARRAY
103747: PUSH
103748: LD_VAR 0 2
103752: EQUAL
103753: IFFALSE 103764
// KillUnit ( vehicle ) ;
103755: LD_VAR 0 2
103759: PPUSH
103760: CALL_OW 66
103764: GO 103724
103766: POP
103767: POP
// end ;
103768: LD_VAR 0 3
103772: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103773: LD_EXP 162
103777: NOT
103778: IFFALSE 103813
103780: GO 103782
103782: DISABLE
// begin initMiner := true ;
103783: LD_ADDR_EXP 162
103787: PUSH
103788: LD_INT 1
103790: ST_TO_ADDR
// minersList := [ ] ;
103791: LD_ADDR_EXP 163
103795: PUSH
103796: EMPTY
103797: ST_TO_ADDR
// minerMinesList := [ ] ;
103798: LD_ADDR_EXP 164
103802: PUSH
103803: EMPTY
103804: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103805: LD_ADDR_EXP 165
103809: PUSH
103810: LD_INT 5
103812: ST_TO_ADDR
// end ;
103813: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103814: LD_EXP 162
103818: PUSH
103819: LD_INT 34
103821: PUSH
103822: LD_INT 81
103824: PUSH
103825: EMPTY
103826: LIST
103827: LIST
103828: PPUSH
103829: CALL_OW 69
103833: AND
103834: IFFALSE 104295
103836: GO 103838
103838: DISABLE
103839: LD_INT 0
103841: PPUSH
103842: PPUSH
103843: PPUSH
103844: PPUSH
// begin enable ;
103845: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103846: LD_ADDR_VAR 0 1
103850: PUSH
103851: LD_INT 34
103853: PUSH
103854: LD_INT 81
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: PPUSH
103861: CALL_OW 69
103865: PUSH
103866: FOR_IN
103867: IFFALSE 103939
// begin if not i in minersList then
103869: LD_VAR 0 1
103873: PUSH
103874: LD_EXP 163
103878: IN
103879: NOT
103880: IFFALSE 103937
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103882: LD_ADDR_EXP 163
103886: PUSH
103887: LD_EXP 163
103891: PPUSH
103892: LD_EXP 163
103896: PUSH
103897: LD_INT 1
103899: PLUS
103900: PPUSH
103901: LD_VAR 0 1
103905: PPUSH
103906: CALL_OW 1
103910: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103911: LD_ADDR_EXP 164
103915: PUSH
103916: LD_EXP 164
103920: PPUSH
103921: LD_EXP 164
103925: PUSH
103926: LD_INT 1
103928: PLUS
103929: PPUSH
103930: EMPTY
103931: PPUSH
103932: CALL_OW 1
103936: ST_TO_ADDR
// end end ;
103937: GO 103866
103939: POP
103940: POP
// for i := minerMinesList downto 1 do
103941: LD_ADDR_VAR 0 1
103945: PUSH
103946: DOUBLE
103947: LD_EXP 164
103951: INC
103952: ST_TO_ADDR
103953: LD_INT 1
103955: PUSH
103956: FOR_DOWNTO
103957: IFFALSE 104293
// begin if IsLive ( minersList [ i ] ) then
103959: LD_EXP 163
103963: PUSH
103964: LD_VAR 0 1
103968: ARRAY
103969: PPUSH
103970: CALL_OW 300
103974: IFFALSE 104002
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103976: LD_EXP 163
103980: PUSH
103981: LD_VAR 0 1
103985: ARRAY
103986: PPUSH
103987: LD_EXP 164
103991: PUSH
103992: LD_VAR 0 1
103996: ARRAY
103997: PPUSH
103998: CALL_OW 505
// if not minerMinesList [ i ] then
104002: LD_EXP 164
104006: PUSH
104007: LD_VAR 0 1
104011: ARRAY
104012: NOT
104013: IFFALSE 104017
// continue ;
104015: GO 103956
// for j := minerMinesList [ i ] downto 1 do
104017: LD_ADDR_VAR 0 2
104021: PUSH
104022: DOUBLE
104023: LD_EXP 164
104027: PUSH
104028: LD_VAR 0 1
104032: ARRAY
104033: INC
104034: ST_TO_ADDR
104035: LD_INT 1
104037: PUSH
104038: FOR_DOWNTO
104039: IFFALSE 104289
// begin side := GetSide ( minersList [ i ] ) ;
104041: LD_ADDR_VAR 0 3
104045: PUSH
104046: LD_EXP 163
104050: PUSH
104051: LD_VAR 0 1
104055: ARRAY
104056: PPUSH
104057: CALL_OW 255
104061: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104062: LD_ADDR_VAR 0 4
104066: PUSH
104067: LD_EXP 164
104071: PUSH
104072: LD_VAR 0 1
104076: ARRAY
104077: PUSH
104078: LD_VAR 0 2
104082: ARRAY
104083: PUSH
104084: LD_INT 1
104086: ARRAY
104087: PPUSH
104088: LD_EXP 164
104092: PUSH
104093: LD_VAR 0 1
104097: ARRAY
104098: PUSH
104099: LD_VAR 0 2
104103: ARRAY
104104: PUSH
104105: LD_INT 2
104107: ARRAY
104108: PPUSH
104109: CALL_OW 428
104113: ST_TO_ADDR
// if not tmp then
104114: LD_VAR 0 4
104118: NOT
104119: IFFALSE 104123
// continue ;
104121: GO 104038
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104123: LD_VAR 0 4
104127: PUSH
104128: LD_INT 81
104130: PUSH
104131: LD_VAR 0 3
104135: PUSH
104136: EMPTY
104137: LIST
104138: LIST
104139: PPUSH
104140: CALL_OW 69
104144: IN
104145: PUSH
104146: LD_EXP 164
104150: PUSH
104151: LD_VAR 0 1
104155: ARRAY
104156: PUSH
104157: LD_VAR 0 2
104161: ARRAY
104162: PUSH
104163: LD_INT 1
104165: ARRAY
104166: PPUSH
104167: LD_EXP 164
104171: PUSH
104172: LD_VAR 0 1
104176: ARRAY
104177: PUSH
104178: LD_VAR 0 2
104182: ARRAY
104183: PUSH
104184: LD_INT 2
104186: ARRAY
104187: PPUSH
104188: CALL_OW 458
104192: AND
104193: IFFALSE 104287
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104195: LD_EXP 164
104199: PUSH
104200: LD_VAR 0 1
104204: ARRAY
104205: PUSH
104206: LD_VAR 0 2
104210: ARRAY
104211: PUSH
104212: LD_INT 1
104214: ARRAY
104215: PPUSH
104216: LD_EXP 164
104220: PUSH
104221: LD_VAR 0 1
104225: ARRAY
104226: PUSH
104227: LD_VAR 0 2
104231: ARRAY
104232: PUSH
104233: LD_INT 2
104235: ARRAY
104236: PPUSH
104237: LD_VAR 0 3
104241: PPUSH
104242: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104246: LD_ADDR_EXP 164
104250: PUSH
104251: LD_EXP 164
104255: PPUSH
104256: LD_VAR 0 1
104260: PPUSH
104261: LD_EXP 164
104265: PUSH
104266: LD_VAR 0 1
104270: ARRAY
104271: PPUSH
104272: LD_VAR 0 2
104276: PPUSH
104277: CALL_OW 3
104281: PPUSH
104282: CALL_OW 1
104286: ST_TO_ADDR
// end ; end ;
104287: GO 104038
104289: POP
104290: POP
// end ;
104291: GO 103956
104293: POP
104294: POP
// end ;
104295: PPOPN 4
104297: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104298: LD_INT 0
104300: PPUSH
104301: PPUSH
// result := false ;
104302: LD_ADDR_VAR 0 4
104306: PUSH
104307: LD_INT 0
104309: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104310: LD_VAR 0 1
104314: PPUSH
104315: CALL_OW 264
104319: PUSH
104320: LD_INT 81
104322: EQUAL
104323: NOT
104324: IFFALSE 104328
// exit ;
104326: GO 104568
// index := GetElementIndex ( minersList , unit ) ;
104328: LD_ADDR_VAR 0 5
104332: PUSH
104333: LD_EXP 163
104337: PPUSH
104338: LD_VAR 0 1
104342: PPUSH
104343: CALL 18533 0 2
104347: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104348: LD_EXP 164
104352: PUSH
104353: LD_VAR 0 5
104357: ARRAY
104358: PUSH
104359: LD_EXP 165
104363: GREATEREQUAL
104364: IFFALSE 104368
// exit ;
104366: GO 104568
// ComMoveXY ( unit , x , y ) ;
104368: LD_VAR 0 1
104372: PPUSH
104373: LD_VAR 0 2
104377: PPUSH
104378: LD_VAR 0 3
104382: PPUSH
104383: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104387: LD_INT 35
104389: PPUSH
104390: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104394: LD_VAR 0 1
104398: PPUSH
104399: LD_VAR 0 2
104403: PPUSH
104404: LD_VAR 0 3
104408: PPUSH
104409: CALL 49888 0 3
104413: NOT
104414: PUSH
104415: LD_VAR 0 1
104419: PPUSH
104420: CALL_OW 314
104424: AND
104425: IFFALSE 104429
// exit ;
104427: GO 104568
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104429: LD_VAR 0 2
104433: PPUSH
104434: LD_VAR 0 3
104438: PPUSH
104439: CALL_OW 428
104443: PUSH
104444: LD_VAR 0 1
104448: EQUAL
104449: PUSH
104450: LD_VAR 0 1
104454: PPUSH
104455: CALL_OW 314
104459: NOT
104460: AND
104461: IFFALSE 104387
// PlaySoundXY ( x , y , PlantMine ) ;
104463: LD_VAR 0 2
104467: PPUSH
104468: LD_VAR 0 3
104472: PPUSH
104473: LD_STRING PlantMine
104475: PPUSH
104476: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104480: LD_VAR 0 2
104484: PPUSH
104485: LD_VAR 0 3
104489: PPUSH
104490: LD_VAR 0 1
104494: PPUSH
104495: CALL_OW 255
104499: PPUSH
104500: LD_INT 0
104502: PPUSH
104503: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104507: LD_ADDR_EXP 164
104511: PUSH
104512: LD_EXP 164
104516: PPUSH
104517: LD_VAR 0 5
104521: PUSH
104522: LD_EXP 164
104526: PUSH
104527: LD_VAR 0 5
104531: ARRAY
104532: PUSH
104533: LD_INT 1
104535: PLUS
104536: PUSH
104537: EMPTY
104538: LIST
104539: LIST
104540: PPUSH
104541: LD_VAR 0 2
104545: PUSH
104546: LD_VAR 0 3
104550: PUSH
104551: EMPTY
104552: LIST
104553: LIST
104554: PPUSH
104555: CALL 18748 0 3
104559: ST_TO_ADDR
// result := true ;
104560: LD_ADDR_VAR 0 4
104564: PUSH
104565: LD_INT 1
104567: ST_TO_ADDR
// end ;
104568: LD_VAR 0 4
104572: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104573: LD_INT 0
104575: PPUSH
104576: PPUSH
104577: PPUSH
// if not unit in minersList then
104578: LD_VAR 0 1
104582: PUSH
104583: LD_EXP 163
104587: IN
104588: NOT
104589: IFFALSE 104593
// exit ;
104591: GO 104985
// index := GetElementIndex ( minersList , unit ) ;
104593: LD_ADDR_VAR 0 6
104597: PUSH
104598: LD_EXP 163
104602: PPUSH
104603: LD_VAR 0 1
104607: PPUSH
104608: CALL 18533 0 2
104612: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104613: LD_ADDR_VAR 0 5
104617: PUSH
104618: DOUBLE
104619: LD_EXP 164
104623: PUSH
104624: LD_VAR 0 6
104628: ARRAY
104629: INC
104630: ST_TO_ADDR
104631: LD_INT 1
104633: PUSH
104634: FOR_DOWNTO
104635: IFFALSE 104796
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104637: LD_EXP 164
104641: PUSH
104642: LD_VAR 0 6
104646: ARRAY
104647: PUSH
104648: LD_VAR 0 5
104652: ARRAY
104653: PUSH
104654: LD_INT 1
104656: ARRAY
104657: PUSH
104658: LD_VAR 0 2
104662: EQUAL
104663: PUSH
104664: LD_EXP 164
104668: PUSH
104669: LD_VAR 0 6
104673: ARRAY
104674: PUSH
104675: LD_VAR 0 5
104679: ARRAY
104680: PUSH
104681: LD_INT 2
104683: ARRAY
104684: PUSH
104685: LD_VAR 0 3
104689: EQUAL
104690: AND
104691: IFFALSE 104794
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104693: LD_EXP 164
104697: PUSH
104698: LD_VAR 0 6
104702: ARRAY
104703: PUSH
104704: LD_VAR 0 5
104708: ARRAY
104709: PUSH
104710: LD_INT 1
104712: ARRAY
104713: PPUSH
104714: LD_EXP 164
104718: PUSH
104719: LD_VAR 0 6
104723: ARRAY
104724: PUSH
104725: LD_VAR 0 5
104729: ARRAY
104730: PUSH
104731: LD_INT 2
104733: ARRAY
104734: PPUSH
104735: LD_VAR 0 1
104739: PPUSH
104740: CALL_OW 255
104744: PPUSH
104745: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104749: LD_ADDR_EXP 164
104753: PUSH
104754: LD_EXP 164
104758: PPUSH
104759: LD_VAR 0 6
104763: PPUSH
104764: LD_EXP 164
104768: PUSH
104769: LD_VAR 0 6
104773: ARRAY
104774: PPUSH
104775: LD_VAR 0 5
104779: PPUSH
104780: CALL_OW 3
104784: PPUSH
104785: CALL_OW 1
104789: ST_TO_ADDR
// exit ;
104790: POP
104791: POP
104792: GO 104985
// end ; end ;
104794: GO 104634
104796: POP
104797: POP
// for i := minerMinesList [ index ] downto 1 do
104798: LD_ADDR_VAR 0 5
104802: PUSH
104803: DOUBLE
104804: LD_EXP 164
104808: PUSH
104809: LD_VAR 0 6
104813: ARRAY
104814: INC
104815: ST_TO_ADDR
104816: LD_INT 1
104818: PUSH
104819: FOR_DOWNTO
104820: IFFALSE 104983
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104822: LD_EXP 164
104826: PUSH
104827: LD_VAR 0 6
104831: ARRAY
104832: PUSH
104833: LD_VAR 0 5
104837: ARRAY
104838: PUSH
104839: LD_INT 1
104841: ARRAY
104842: PPUSH
104843: LD_EXP 164
104847: PUSH
104848: LD_VAR 0 6
104852: ARRAY
104853: PUSH
104854: LD_VAR 0 5
104858: ARRAY
104859: PUSH
104860: LD_INT 2
104862: ARRAY
104863: PPUSH
104864: LD_VAR 0 2
104868: PPUSH
104869: LD_VAR 0 3
104873: PPUSH
104874: CALL_OW 298
104878: PUSH
104879: LD_INT 6
104881: LESS
104882: IFFALSE 104981
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104884: LD_EXP 164
104888: PUSH
104889: LD_VAR 0 6
104893: ARRAY
104894: PUSH
104895: LD_VAR 0 5
104899: ARRAY
104900: PUSH
104901: LD_INT 1
104903: ARRAY
104904: PPUSH
104905: LD_EXP 164
104909: PUSH
104910: LD_VAR 0 6
104914: ARRAY
104915: PUSH
104916: LD_VAR 0 5
104920: ARRAY
104921: PUSH
104922: LD_INT 2
104924: ARRAY
104925: PPUSH
104926: LD_VAR 0 1
104930: PPUSH
104931: CALL_OW 255
104935: PPUSH
104936: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104940: LD_ADDR_EXP 164
104944: PUSH
104945: LD_EXP 164
104949: PPUSH
104950: LD_VAR 0 6
104954: PPUSH
104955: LD_EXP 164
104959: PUSH
104960: LD_VAR 0 6
104964: ARRAY
104965: PPUSH
104966: LD_VAR 0 5
104970: PPUSH
104971: CALL_OW 3
104975: PPUSH
104976: CALL_OW 1
104980: ST_TO_ADDR
// end ; end ;
104981: GO 104819
104983: POP
104984: POP
// end ;
104985: LD_VAR 0 4
104989: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104990: LD_INT 0
104992: PPUSH
104993: PPUSH
104994: PPUSH
104995: PPUSH
104996: PPUSH
104997: PPUSH
104998: PPUSH
104999: PPUSH
105000: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105001: LD_VAR 0 1
105005: PPUSH
105006: CALL_OW 264
105010: PUSH
105011: LD_INT 81
105013: EQUAL
105014: NOT
105015: PUSH
105016: LD_VAR 0 1
105020: PUSH
105021: LD_EXP 163
105025: IN
105026: NOT
105027: OR
105028: IFFALSE 105032
// exit ;
105030: GO 105354
// index := GetElementIndex ( minersList , unit ) ;
105032: LD_ADDR_VAR 0 6
105036: PUSH
105037: LD_EXP 163
105041: PPUSH
105042: LD_VAR 0 1
105046: PPUSH
105047: CALL 18533 0 2
105051: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105052: LD_ADDR_VAR 0 8
105056: PUSH
105057: LD_EXP 165
105061: PUSH
105062: LD_EXP 164
105066: PUSH
105067: LD_VAR 0 6
105071: ARRAY
105072: MINUS
105073: ST_TO_ADDR
// if not minesFreeAmount then
105074: LD_VAR 0 8
105078: NOT
105079: IFFALSE 105083
// exit ;
105081: GO 105354
// tmp := [ ] ;
105083: LD_ADDR_VAR 0 7
105087: PUSH
105088: EMPTY
105089: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105090: LD_ADDR_VAR 0 5
105094: PUSH
105095: DOUBLE
105096: LD_INT 1
105098: DEC
105099: ST_TO_ADDR
105100: LD_VAR 0 8
105104: PUSH
105105: FOR_TO
105106: IFFALSE 105301
// begin _d := rand ( 0 , 5 ) ;
105108: LD_ADDR_VAR 0 11
105112: PUSH
105113: LD_INT 0
105115: PPUSH
105116: LD_INT 5
105118: PPUSH
105119: CALL_OW 12
105123: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105124: LD_ADDR_VAR 0 12
105128: PUSH
105129: LD_INT 2
105131: PPUSH
105132: LD_INT 6
105134: PPUSH
105135: CALL_OW 12
105139: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105140: LD_ADDR_VAR 0 9
105144: PUSH
105145: LD_VAR 0 2
105149: PPUSH
105150: LD_VAR 0 11
105154: PPUSH
105155: LD_VAR 0 12
105159: PPUSH
105160: CALL_OW 272
105164: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105165: LD_ADDR_VAR 0 10
105169: PUSH
105170: LD_VAR 0 3
105174: PPUSH
105175: LD_VAR 0 11
105179: PPUSH
105180: LD_VAR 0 12
105184: PPUSH
105185: CALL_OW 273
105189: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105190: LD_VAR 0 9
105194: PPUSH
105195: LD_VAR 0 10
105199: PPUSH
105200: CALL_OW 488
105204: PUSH
105205: LD_VAR 0 9
105209: PUSH
105210: LD_VAR 0 10
105214: PUSH
105215: EMPTY
105216: LIST
105217: LIST
105218: PUSH
105219: LD_VAR 0 7
105223: IN
105224: NOT
105225: AND
105226: PUSH
105227: LD_VAR 0 9
105231: PPUSH
105232: LD_VAR 0 10
105236: PPUSH
105237: CALL_OW 458
105241: NOT
105242: AND
105243: IFFALSE 105285
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105245: LD_ADDR_VAR 0 7
105249: PUSH
105250: LD_VAR 0 7
105254: PPUSH
105255: LD_VAR 0 7
105259: PUSH
105260: LD_INT 1
105262: PLUS
105263: PPUSH
105264: LD_VAR 0 9
105268: PUSH
105269: LD_VAR 0 10
105273: PUSH
105274: EMPTY
105275: LIST
105276: LIST
105277: PPUSH
105278: CALL_OW 1
105282: ST_TO_ADDR
105283: GO 105299
// i := i - 1 ;
105285: LD_ADDR_VAR 0 5
105289: PUSH
105290: LD_VAR 0 5
105294: PUSH
105295: LD_INT 1
105297: MINUS
105298: ST_TO_ADDR
// end ;
105299: GO 105105
105301: POP
105302: POP
// for i in tmp do
105303: LD_ADDR_VAR 0 5
105307: PUSH
105308: LD_VAR 0 7
105312: PUSH
105313: FOR_IN
105314: IFFALSE 105352
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105316: LD_VAR 0 1
105320: PPUSH
105321: LD_VAR 0 5
105325: PUSH
105326: LD_INT 1
105328: ARRAY
105329: PPUSH
105330: LD_VAR 0 5
105334: PUSH
105335: LD_INT 2
105337: ARRAY
105338: PPUSH
105339: CALL 104298 0 3
105343: NOT
105344: IFFALSE 105350
// exit ;
105346: POP
105347: POP
105348: GO 105354
105350: GO 105313
105352: POP
105353: POP
// end ;
105354: LD_VAR 0 4
105358: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105359: LD_INT 0
105361: PPUSH
105362: PPUSH
105363: PPUSH
105364: PPUSH
105365: PPUSH
105366: PPUSH
105367: PPUSH
// if not GetClass ( unit ) = class_sniper then
105368: LD_VAR 0 1
105372: PPUSH
105373: CALL_OW 257
105377: PUSH
105378: LD_INT 5
105380: EQUAL
105381: NOT
105382: IFFALSE 105386
// exit ;
105384: GO 105774
// dist := 8 ;
105386: LD_ADDR_VAR 0 5
105390: PUSH
105391: LD_INT 8
105393: ST_TO_ADDR
// viewRange := 12 ;
105394: LD_ADDR_VAR 0 7
105398: PUSH
105399: LD_INT 12
105401: ST_TO_ADDR
// side := GetSide ( unit ) ;
105402: LD_ADDR_VAR 0 6
105406: PUSH
105407: LD_VAR 0 1
105411: PPUSH
105412: CALL_OW 255
105416: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105417: LD_INT 61
105419: PPUSH
105420: LD_VAR 0 6
105424: PPUSH
105425: CALL_OW 321
105429: PUSH
105430: LD_INT 2
105432: EQUAL
105433: IFFALSE 105443
// viewRange := 16 ;
105435: LD_ADDR_VAR 0 7
105439: PUSH
105440: LD_INT 16
105442: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105443: LD_VAR 0 1
105447: PPUSH
105448: LD_VAR 0 2
105452: PPUSH
105453: LD_VAR 0 3
105457: PPUSH
105458: CALL_OW 297
105462: PUSH
105463: LD_VAR 0 5
105467: GREATER
105468: IFFALSE 105547
// begin ComMoveXY ( unit , x , y ) ;
105470: LD_VAR 0 1
105474: PPUSH
105475: LD_VAR 0 2
105479: PPUSH
105480: LD_VAR 0 3
105484: PPUSH
105485: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105489: LD_INT 35
105491: PPUSH
105492: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105496: LD_VAR 0 1
105500: PPUSH
105501: LD_VAR 0 2
105505: PPUSH
105506: LD_VAR 0 3
105510: PPUSH
105511: CALL 49888 0 3
105515: NOT
105516: IFFALSE 105520
// exit ;
105518: GO 105774
// until GetDistUnitXY ( unit , x , y ) < dist ;
105520: LD_VAR 0 1
105524: PPUSH
105525: LD_VAR 0 2
105529: PPUSH
105530: LD_VAR 0 3
105534: PPUSH
105535: CALL_OW 297
105539: PUSH
105540: LD_VAR 0 5
105544: LESS
105545: IFFALSE 105489
// end ; ComTurnXY ( unit , x , y ) ;
105547: LD_VAR 0 1
105551: PPUSH
105552: LD_VAR 0 2
105556: PPUSH
105557: LD_VAR 0 3
105561: PPUSH
105562: CALL_OW 118
// wait ( 5 ) ;
105566: LD_INT 5
105568: PPUSH
105569: CALL_OW 67
// _d := GetDir ( unit ) ;
105573: LD_ADDR_VAR 0 10
105577: PUSH
105578: LD_VAR 0 1
105582: PPUSH
105583: CALL_OW 254
105587: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105588: LD_ADDR_VAR 0 8
105592: PUSH
105593: LD_VAR 0 1
105597: PPUSH
105598: CALL_OW 250
105602: PPUSH
105603: LD_VAR 0 10
105607: PPUSH
105608: LD_VAR 0 5
105612: PPUSH
105613: CALL_OW 272
105617: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105618: LD_ADDR_VAR 0 9
105622: PUSH
105623: LD_VAR 0 1
105627: PPUSH
105628: CALL_OW 251
105632: PPUSH
105633: LD_VAR 0 10
105637: PPUSH
105638: LD_VAR 0 5
105642: PPUSH
105643: CALL_OW 273
105647: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105648: LD_VAR 0 8
105652: PPUSH
105653: LD_VAR 0 9
105657: PPUSH
105658: CALL_OW 488
105662: NOT
105663: IFFALSE 105667
// exit ;
105665: GO 105774
// ComAnimCustom ( unit , 1 ) ;
105667: LD_VAR 0 1
105671: PPUSH
105672: LD_INT 1
105674: PPUSH
105675: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105679: LD_VAR 0 8
105683: PPUSH
105684: LD_VAR 0 9
105688: PPUSH
105689: LD_VAR 0 6
105693: PPUSH
105694: LD_VAR 0 7
105698: PPUSH
105699: CALL_OW 330
// repeat wait ( 1 ) ;
105703: LD_INT 1
105705: PPUSH
105706: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105710: LD_VAR 0 1
105714: PPUSH
105715: CALL_OW 316
105719: PUSH
105720: LD_VAR 0 1
105724: PPUSH
105725: CALL_OW 314
105729: OR
105730: PUSH
105731: LD_VAR 0 1
105735: PPUSH
105736: CALL_OW 302
105740: NOT
105741: OR
105742: PUSH
105743: LD_VAR 0 1
105747: PPUSH
105748: CALL_OW 301
105752: OR
105753: IFFALSE 105703
// RemoveSeeing ( _x , _y , side ) ;
105755: LD_VAR 0 8
105759: PPUSH
105760: LD_VAR 0 9
105764: PPUSH
105765: LD_VAR 0 6
105769: PPUSH
105770: CALL_OW 331
// end ; end_of_file
105774: LD_VAR 0 4
105778: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105779: LD_INT 0
105781: PPUSH
105782: PPUSH
105783: PPUSH
105784: PPUSH
105785: PPUSH
105786: PPUSH
105787: PPUSH
105788: PPUSH
105789: PPUSH
105790: PPUSH
105791: PPUSH
105792: PPUSH
105793: PPUSH
105794: PPUSH
105795: PPUSH
105796: PPUSH
105797: PPUSH
105798: PPUSH
105799: PPUSH
105800: PPUSH
105801: PPUSH
105802: PPUSH
105803: PPUSH
105804: PPUSH
105805: PPUSH
105806: PPUSH
105807: PPUSH
105808: PPUSH
105809: PPUSH
105810: PPUSH
105811: PPUSH
105812: PPUSH
105813: PPUSH
105814: PPUSH
// if not list then
105815: LD_VAR 0 1
105819: NOT
105820: IFFALSE 105824
// exit ;
105822: GO 110483
// base := list [ 1 ] ;
105824: LD_ADDR_VAR 0 3
105828: PUSH
105829: LD_VAR 0 1
105833: PUSH
105834: LD_INT 1
105836: ARRAY
105837: ST_TO_ADDR
// group := list [ 2 ] ;
105838: LD_ADDR_VAR 0 4
105842: PUSH
105843: LD_VAR 0 1
105847: PUSH
105848: LD_INT 2
105850: ARRAY
105851: ST_TO_ADDR
// path := list [ 3 ] ;
105852: LD_ADDR_VAR 0 5
105856: PUSH
105857: LD_VAR 0 1
105861: PUSH
105862: LD_INT 3
105864: ARRAY
105865: ST_TO_ADDR
// flags := list [ 4 ] ;
105866: LD_ADDR_VAR 0 6
105870: PUSH
105871: LD_VAR 0 1
105875: PUSH
105876: LD_INT 4
105878: ARRAY
105879: ST_TO_ADDR
// mined := [ ] ;
105880: LD_ADDR_VAR 0 27
105884: PUSH
105885: EMPTY
105886: ST_TO_ADDR
// bombed := [ ] ;
105887: LD_ADDR_VAR 0 28
105891: PUSH
105892: EMPTY
105893: ST_TO_ADDR
// healers := [ ] ;
105894: LD_ADDR_VAR 0 31
105898: PUSH
105899: EMPTY
105900: ST_TO_ADDR
// to_heal := [ ] ;
105901: LD_ADDR_VAR 0 30
105905: PUSH
105906: EMPTY
105907: ST_TO_ADDR
// repairs := [ ] ;
105908: LD_ADDR_VAR 0 33
105912: PUSH
105913: EMPTY
105914: ST_TO_ADDR
// to_repair := [ ] ;
105915: LD_ADDR_VAR 0 32
105919: PUSH
105920: EMPTY
105921: ST_TO_ADDR
// if not group or not path then
105922: LD_VAR 0 4
105926: NOT
105927: PUSH
105928: LD_VAR 0 5
105932: NOT
105933: OR
105934: IFFALSE 105938
// exit ;
105936: GO 110483
// side := GetSide ( group [ 1 ] ) ;
105938: LD_ADDR_VAR 0 35
105942: PUSH
105943: LD_VAR 0 4
105947: PUSH
105948: LD_INT 1
105950: ARRAY
105951: PPUSH
105952: CALL_OW 255
105956: ST_TO_ADDR
// if flags then
105957: LD_VAR 0 6
105961: IFFALSE 106105
// begin f_ignore_area := flags [ 1 ] ;
105963: LD_ADDR_VAR 0 17
105967: PUSH
105968: LD_VAR 0 6
105972: PUSH
105973: LD_INT 1
105975: ARRAY
105976: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105977: LD_ADDR_VAR 0 18
105981: PUSH
105982: LD_VAR 0 6
105986: PUSH
105987: LD_INT 2
105989: ARRAY
105990: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105991: LD_ADDR_VAR 0 19
105995: PUSH
105996: LD_VAR 0 6
106000: PUSH
106001: LD_INT 3
106003: ARRAY
106004: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
106005: LD_ADDR_VAR 0 20
106009: PUSH
106010: LD_VAR 0 6
106014: PUSH
106015: LD_INT 4
106017: ARRAY
106018: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
106019: LD_ADDR_VAR 0 21
106023: PUSH
106024: LD_VAR 0 6
106028: PUSH
106029: LD_INT 5
106031: ARRAY
106032: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
106033: LD_ADDR_VAR 0 22
106037: PUSH
106038: LD_VAR 0 6
106042: PUSH
106043: LD_INT 6
106045: ARRAY
106046: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
106047: LD_ADDR_VAR 0 23
106051: PUSH
106052: LD_VAR 0 6
106056: PUSH
106057: LD_INT 7
106059: ARRAY
106060: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106061: LD_ADDR_VAR 0 24
106065: PUSH
106066: LD_VAR 0 6
106070: PUSH
106071: LD_INT 8
106073: ARRAY
106074: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106075: LD_ADDR_VAR 0 25
106079: PUSH
106080: LD_VAR 0 6
106084: PUSH
106085: LD_INT 9
106087: ARRAY
106088: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106089: LD_ADDR_VAR 0 26
106093: PUSH
106094: LD_VAR 0 6
106098: PUSH
106099: LD_INT 10
106101: ARRAY
106102: ST_TO_ADDR
// end else
106103: GO 106185
// begin f_ignore_area := false ;
106105: LD_ADDR_VAR 0 17
106109: PUSH
106110: LD_INT 0
106112: ST_TO_ADDR
// f_capture := false ;
106113: LD_ADDR_VAR 0 18
106117: PUSH
106118: LD_INT 0
106120: ST_TO_ADDR
// f_ignore_civ := false ;
106121: LD_ADDR_VAR 0 19
106125: PUSH
106126: LD_INT 0
106128: ST_TO_ADDR
// f_murder := false ;
106129: LD_ADDR_VAR 0 20
106133: PUSH
106134: LD_INT 0
106136: ST_TO_ADDR
// f_mines := false ;
106137: LD_ADDR_VAR 0 21
106141: PUSH
106142: LD_INT 0
106144: ST_TO_ADDR
// f_repair := false ;
106145: LD_ADDR_VAR 0 22
106149: PUSH
106150: LD_INT 0
106152: ST_TO_ADDR
// f_heal := false ;
106153: LD_ADDR_VAR 0 23
106157: PUSH
106158: LD_INT 0
106160: ST_TO_ADDR
// f_spacetime := false ;
106161: LD_ADDR_VAR 0 24
106165: PUSH
106166: LD_INT 0
106168: ST_TO_ADDR
// f_attack_depot := false ;
106169: LD_ADDR_VAR 0 25
106173: PUSH
106174: LD_INT 0
106176: ST_TO_ADDR
// f_crawl := false ;
106177: LD_ADDR_VAR 0 26
106181: PUSH
106182: LD_INT 0
106184: ST_TO_ADDR
// end ; if f_heal then
106185: LD_VAR 0 23
106189: IFFALSE 106216
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106191: LD_ADDR_VAR 0 31
106195: PUSH
106196: LD_VAR 0 4
106200: PPUSH
106201: LD_INT 25
106203: PUSH
106204: LD_INT 4
106206: PUSH
106207: EMPTY
106208: LIST
106209: LIST
106210: PPUSH
106211: CALL_OW 72
106215: ST_TO_ADDR
// if f_repair then
106216: LD_VAR 0 22
106220: IFFALSE 106247
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106222: LD_ADDR_VAR 0 33
106226: PUSH
106227: LD_VAR 0 4
106231: PPUSH
106232: LD_INT 25
106234: PUSH
106235: LD_INT 3
106237: PUSH
106238: EMPTY
106239: LIST
106240: LIST
106241: PPUSH
106242: CALL_OW 72
106246: ST_TO_ADDR
// units_path := [ ] ;
106247: LD_ADDR_VAR 0 16
106251: PUSH
106252: EMPTY
106253: ST_TO_ADDR
// for i = 1 to group do
106254: LD_ADDR_VAR 0 7
106258: PUSH
106259: DOUBLE
106260: LD_INT 1
106262: DEC
106263: ST_TO_ADDR
106264: LD_VAR 0 4
106268: PUSH
106269: FOR_TO
106270: IFFALSE 106299
// units_path := Replace ( units_path , i , path ) ;
106272: LD_ADDR_VAR 0 16
106276: PUSH
106277: LD_VAR 0 16
106281: PPUSH
106282: LD_VAR 0 7
106286: PPUSH
106287: LD_VAR 0 5
106291: PPUSH
106292: CALL_OW 1
106296: ST_TO_ADDR
106297: GO 106269
106299: POP
106300: POP
// repeat for i = group downto 1 do
106301: LD_ADDR_VAR 0 7
106305: PUSH
106306: DOUBLE
106307: LD_VAR 0 4
106311: INC
106312: ST_TO_ADDR
106313: LD_INT 1
106315: PUSH
106316: FOR_DOWNTO
106317: IFFALSE 110439
// begin wait ( 5 ) ;
106319: LD_INT 5
106321: PPUSH
106322: CALL_OW 67
// tmp := [ ] ;
106326: LD_ADDR_VAR 0 14
106330: PUSH
106331: EMPTY
106332: ST_TO_ADDR
// attacking := false ;
106333: LD_ADDR_VAR 0 29
106337: PUSH
106338: LD_INT 0
106340: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106341: LD_VAR 0 4
106345: PUSH
106346: LD_VAR 0 7
106350: ARRAY
106351: PPUSH
106352: CALL_OW 301
106356: PUSH
106357: LD_VAR 0 4
106361: PUSH
106362: LD_VAR 0 7
106366: ARRAY
106367: NOT
106368: OR
106369: IFFALSE 106478
// begin if GetType ( group [ i ] ) = unit_human then
106371: LD_VAR 0 4
106375: PUSH
106376: LD_VAR 0 7
106380: ARRAY
106381: PPUSH
106382: CALL_OW 247
106386: PUSH
106387: LD_INT 1
106389: EQUAL
106390: IFFALSE 106436
// begin to_heal := to_heal diff group [ i ] ;
106392: LD_ADDR_VAR 0 30
106396: PUSH
106397: LD_VAR 0 30
106401: PUSH
106402: LD_VAR 0 4
106406: PUSH
106407: LD_VAR 0 7
106411: ARRAY
106412: DIFF
106413: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106414: LD_ADDR_VAR 0 31
106418: PUSH
106419: LD_VAR 0 31
106423: PUSH
106424: LD_VAR 0 4
106428: PUSH
106429: LD_VAR 0 7
106433: ARRAY
106434: DIFF
106435: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106436: LD_ADDR_VAR 0 4
106440: PUSH
106441: LD_VAR 0 4
106445: PPUSH
106446: LD_VAR 0 7
106450: PPUSH
106451: CALL_OW 3
106455: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106456: LD_ADDR_VAR 0 16
106460: PUSH
106461: LD_VAR 0 16
106465: PPUSH
106466: LD_VAR 0 7
106470: PPUSH
106471: CALL_OW 3
106475: ST_TO_ADDR
// continue ;
106476: GO 106316
// end ; if f_repair then
106478: LD_VAR 0 22
106482: IFFALSE 106971
// begin if GetType ( group [ i ] ) = unit_vehicle then
106484: LD_VAR 0 4
106488: PUSH
106489: LD_VAR 0 7
106493: ARRAY
106494: PPUSH
106495: CALL_OW 247
106499: PUSH
106500: LD_INT 2
106502: EQUAL
106503: IFFALSE 106693
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106505: LD_VAR 0 4
106509: PUSH
106510: LD_VAR 0 7
106514: ARRAY
106515: PPUSH
106516: CALL_OW 256
106520: PUSH
106521: LD_INT 700
106523: LESS
106524: PUSH
106525: LD_VAR 0 4
106529: PUSH
106530: LD_VAR 0 7
106534: ARRAY
106535: PUSH
106536: LD_VAR 0 32
106540: IN
106541: NOT
106542: AND
106543: IFFALSE 106567
// to_repair := to_repair union group [ i ] ;
106545: LD_ADDR_VAR 0 32
106549: PUSH
106550: LD_VAR 0 32
106554: PUSH
106555: LD_VAR 0 4
106559: PUSH
106560: LD_VAR 0 7
106564: ARRAY
106565: UNION
106566: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106567: LD_VAR 0 4
106571: PUSH
106572: LD_VAR 0 7
106576: ARRAY
106577: PPUSH
106578: CALL_OW 256
106582: PUSH
106583: LD_INT 1000
106585: EQUAL
106586: PUSH
106587: LD_VAR 0 4
106591: PUSH
106592: LD_VAR 0 7
106596: ARRAY
106597: PUSH
106598: LD_VAR 0 32
106602: IN
106603: AND
106604: IFFALSE 106628
// to_repair := to_repair diff group [ i ] ;
106606: LD_ADDR_VAR 0 32
106610: PUSH
106611: LD_VAR 0 32
106615: PUSH
106616: LD_VAR 0 4
106620: PUSH
106621: LD_VAR 0 7
106625: ARRAY
106626: DIFF
106627: ST_TO_ADDR
// if group [ i ] in to_repair then
106628: LD_VAR 0 4
106632: PUSH
106633: LD_VAR 0 7
106637: ARRAY
106638: PUSH
106639: LD_VAR 0 32
106643: IN
106644: IFFALSE 106691
// begin if not IsInArea ( group [ i ] , f_repair ) then
106646: LD_VAR 0 4
106650: PUSH
106651: LD_VAR 0 7
106655: ARRAY
106656: PPUSH
106657: LD_VAR 0 22
106661: PPUSH
106662: CALL_OW 308
106666: NOT
106667: IFFALSE 106689
// ComMoveToArea ( group [ i ] , f_repair ) ;
106669: LD_VAR 0 4
106673: PUSH
106674: LD_VAR 0 7
106678: ARRAY
106679: PPUSH
106680: LD_VAR 0 22
106684: PPUSH
106685: CALL_OW 113
// continue ;
106689: GO 106316
// end ; end else
106691: GO 106971
// if group [ i ] in repairs then
106693: LD_VAR 0 4
106697: PUSH
106698: LD_VAR 0 7
106702: ARRAY
106703: PUSH
106704: LD_VAR 0 33
106708: IN
106709: IFFALSE 106971
// begin if IsInUnit ( group [ i ] ) then
106711: LD_VAR 0 4
106715: PUSH
106716: LD_VAR 0 7
106720: ARRAY
106721: PPUSH
106722: CALL_OW 310
106726: IFFALSE 106794
// begin z := IsInUnit ( group [ i ] ) ;
106728: LD_ADDR_VAR 0 13
106732: PUSH
106733: LD_VAR 0 4
106737: PUSH
106738: LD_VAR 0 7
106742: ARRAY
106743: PPUSH
106744: CALL_OW 310
106748: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106749: LD_VAR 0 13
106753: PUSH
106754: LD_VAR 0 32
106758: IN
106759: PUSH
106760: LD_VAR 0 13
106764: PPUSH
106765: LD_VAR 0 22
106769: PPUSH
106770: CALL_OW 308
106774: AND
106775: IFFALSE 106792
// ComExitVehicle ( group [ i ] ) ;
106777: LD_VAR 0 4
106781: PUSH
106782: LD_VAR 0 7
106786: ARRAY
106787: PPUSH
106788: CALL_OW 121
// end else
106792: GO 106971
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106794: LD_ADDR_VAR 0 13
106798: PUSH
106799: LD_VAR 0 4
106803: PPUSH
106804: LD_INT 95
106806: PUSH
106807: LD_VAR 0 22
106811: PUSH
106812: EMPTY
106813: LIST
106814: LIST
106815: PUSH
106816: LD_INT 58
106818: PUSH
106819: EMPTY
106820: LIST
106821: PUSH
106822: EMPTY
106823: LIST
106824: LIST
106825: PPUSH
106826: CALL_OW 72
106830: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106831: LD_VAR 0 4
106835: PUSH
106836: LD_VAR 0 7
106840: ARRAY
106841: PPUSH
106842: CALL_OW 314
106846: NOT
106847: IFFALSE 106969
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106849: LD_ADDR_VAR 0 10
106853: PUSH
106854: LD_VAR 0 13
106858: PPUSH
106859: LD_VAR 0 4
106863: PUSH
106864: LD_VAR 0 7
106868: ARRAY
106869: PPUSH
106870: CALL_OW 74
106874: ST_TO_ADDR
// if not x then
106875: LD_VAR 0 10
106879: NOT
106880: IFFALSE 106884
// continue ;
106882: GO 106316
// if GetLives ( x ) < 1000 then
106884: LD_VAR 0 10
106888: PPUSH
106889: CALL_OW 256
106893: PUSH
106894: LD_INT 1000
106896: LESS
106897: IFFALSE 106921
// ComRepairVehicle ( group [ i ] , x ) else
106899: LD_VAR 0 4
106903: PUSH
106904: LD_VAR 0 7
106908: ARRAY
106909: PPUSH
106910: LD_VAR 0 10
106914: PPUSH
106915: CALL_OW 129
106919: GO 106969
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106921: LD_VAR 0 23
106925: PUSH
106926: LD_VAR 0 4
106930: PUSH
106931: LD_VAR 0 7
106935: ARRAY
106936: PPUSH
106937: CALL_OW 256
106941: PUSH
106942: LD_INT 1000
106944: LESS
106945: AND
106946: NOT
106947: IFFALSE 106969
// ComEnterUnit ( group [ i ] , x ) ;
106949: LD_VAR 0 4
106953: PUSH
106954: LD_VAR 0 7
106958: ARRAY
106959: PPUSH
106960: LD_VAR 0 10
106964: PPUSH
106965: CALL_OW 120
// end ; continue ;
106969: GO 106316
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106971: LD_VAR 0 23
106975: PUSH
106976: LD_VAR 0 4
106980: PUSH
106981: LD_VAR 0 7
106985: ARRAY
106986: PPUSH
106987: CALL_OW 247
106991: PUSH
106992: LD_INT 1
106994: EQUAL
106995: AND
106996: IFFALSE 107474
// begin if group [ i ] in healers then
106998: LD_VAR 0 4
107002: PUSH
107003: LD_VAR 0 7
107007: ARRAY
107008: PUSH
107009: LD_VAR 0 31
107013: IN
107014: IFFALSE 107287
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
107016: LD_VAR 0 4
107020: PUSH
107021: LD_VAR 0 7
107025: ARRAY
107026: PPUSH
107027: LD_VAR 0 23
107031: PPUSH
107032: CALL_OW 308
107036: NOT
107037: PUSH
107038: LD_VAR 0 4
107042: PUSH
107043: LD_VAR 0 7
107047: ARRAY
107048: PPUSH
107049: CALL_OW 314
107053: NOT
107054: AND
107055: IFFALSE 107079
// ComMoveToArea ( group [ i ] , f_heal ) else
107057: LD_VAR 0 4
107061: PUSH
107062: LD_VAR 0 7
107066: ARRAY
107067: PPUSH
107068: LD_VAR 0 23
107072: PPUSH
107073: CALL_OW 113
107077: GO 107285
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107079: LD_VAR 0 4
107083: PUSH
107084: LD_VAR 0 7
107088: ARRAY
107089: PPUSH
107090: CALL 48471 0 1
107094: PPUSH
107095: CALL_OW 256
107099: PUSH
107100: LD_INT 1000
107102: EQUAL
107103: IFFALSE 107122
// ComStop ( group [ i ] ) else
107105: LD_VAR 0 4
107109: PUSH
107110: LD_VAR 0 7
107114: ARRAY
107115: PPUSH
107116: CALL_OW 141
107120: GO 107285
// if not HasTask ( group [ i ] ) and to_heal then
107122: LD_VAR 0 4
107126: PUSH
107127: LD_VAR 0 7
107131: ARRAY
107132: PPUSH
107133: CALL_OW 314
107137: NOT
107138: PUSH
107139: LD_VAR 0 30
107143: AND
107144: IFFALSE 107285
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107146: LD_ADDR_VAR 0 13
107150: PUSH
107151: LD_VAR 0 30
107155: PPUSH
107156: LD_INT 3
107158: PUSH
107159: LD_INT 54
107161: PUSH
107162: EMPTY
107163: LIST
107164: PUSH
107165: EMPTY
107166: LIST
107167: LIST
107168: PPUSH
107169: CALL_OW 72
107173: PPUSH
107174: LD_VAR 0 4
107178: PUSH
107179: LD_VAR 0 7
107183: ARRAY
107184: PPUSH
107185: CALL_OW 74
107189: ST_TO_ADDR
// if z then
107190: LD_VAR 0 13
107194: IFFALSE 107285
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107196: LD_INT 91
107198: PUSH
107199: LD_VAR 0 13
107203: PUSH
107204: LD_INT 10
107206: PUSH
107207: EMPTY
107208: LIST
107209: LIST
107210: LIST
107211: PUSH
107212: LD_INT 81
107214: PUSH
107215: LD_VAR 0 13
107219: PPUSH
107220: CALL_OW 255
107224: PUSH
107225: EMPTY
107226: LIST
107227: LIST
107228: PUSH
107229: EMPTY
107230: LIST
107231: LIST
107232: PPUSH
107233: CALL_OW 69
107237: PUSH
107238: LD_INT 0
107240: EQUAL
107241: IFFALSE 107265
// ComHeal ( group [ i ] , z ) else
107243: LD_VAR 0 4
107247: PUSH
107248: LD_VAR 0 7
107252: ARRAY
107253: PPUSH
107254: LD_VAR 0 13
107258: PPUSH
107259: CALL_OW 128
107263: GO 107285
// ComMoveToArea ( group [ i ] , f_heal ) ;
107265: LD_VAR 0 4
107269: PUSH
107270: LD_VAR 0 7
107274: ARRAY
107275: PPUSH
107276: LD_VAR 0 23
107280: PPUSH
107281: CALL_OW 113
// end ; continue ;
107285: GO 106316
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107287: LD_VAR 0 4
107291: PUSH
107292: LD_VAR 0 7
107296: ARRAY
107297: PPUSH
107298: CALL_OW 256
107302: PUSH
107303: LD_INT 700
107305: LESS
107306: PUSH
107307: LD_VAR 0 4
107311: PUSH
107312: LD_VAR 0 7
107316: ARRAY
107317: PUSH
107318: LD_VAR 0 30
107322: IN
107323: NOT
107324: AND
107325: IFFALSE 107349
// to_heal := to_heal union group [ i ] ;
107327: LD_ADDR_VAR 0 30
107331: PUSH
107332: LD_VAR 0 30
107336: PUSH
107337: LD_VAR 0 4
107341: PUSH
107342: LD_VAR 0 7
107346: ARRAY
107347: UNION
107348: ST_TO_ADDR
// if group [ i ] in to_heal then
107349: LD_VAR 0 4
107353: PUSH
107354: LD_VAR 0 7
107358: ARRAY
107359: PUSH
107360: LD_VAR 0 30
107364: IN
107365: IFFALSE 107474
// begin if GetLives ( group [ i ] ) = 1000 then
107367: LD_VAR 0 4
107371: PUSH
107372: LD_VAR 0 7
107376: ARRAY
107377: PPUSH
107378: CALL_OW 256
107382: PUSH
107383: LD_INT 1000
107385: EQUAL
107386: IFFALSE 107412
// to_heal := to_heal diff group [ i ] else
107388: LD_ADDR_VAR 0 30
107392: PUSH
107393: LD_VAR 0 30
107397: PUSH
107398: LD_VAR 0 4
107402: PUSH
107403: LD_VAR 0 7
107407: ARRAY
107408: DIFF
107409: ST_TO_ADDR
107410: GO 107474
// begin if not IsInArea ( group [ i ] , to_heal ) then
107412: LD_VAR 0 4
107416: PUSH
107417: LD_VAR 0 7
107421: ARRAY
107422: PPUSH
107423: LD_VAR 0 30
107427: PPUSH
107428: CALL_OW 308
107432: NOT
107433: IFFALSE 107457
// ComMoveToArea ( group [ i ] , f_heal ) else
107435: LD_VAR 0 4
107439: PUSH
107440: LD_VAR 0 7
107444: ARRAY
107445: PPUSH
107446: LD_VAR 0 23
107450: PPUSH
107451: CALL_OW 113
107455: GO 107472
// ComHold ( group [ i ] ) ;
107457: LD_VAR 0 4
107461: PUSH
107462: LD_VAR 0 7
107466: ARRAY
107467: PPUSH
107468: CALL_OW 140
// continue ;
107472: GO 106316
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107474: LD_VAR 0 4
107478: PUSH
107479: LD_VAR 0 7
107483: ARRAY
107484: PPUSH
107485: LD_INT 10
107487: PPUSH
107488: CALL 46242 0 2
107492: NOT
107493: PUSH
107494: LD_VAR 0 16
107498: PUSH
107499: LD_VAR 0 7
107503: ARRAY
107504: PUSH
107505: EMPTY
107506: EQUAL
107507: NOT
107508: AND
107509: IFFALSE 107775
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107511: LD_VAR 0 4
107515: PUSH
107516: LD_VAR 0 7
107520: ARRAY
107521: PPUSH
107522: CALL_OW 262
107526: PUSH
107527: LD_INT 1
107529: PUSH
107530: LD_INT 2
107532: PUSH
107533: EMPTY
107534: LIST
107535: LIST
107536: IN
107537: IFFALSE 107578
// if GetFuel ( group [ i ] ) < 10 then
107539: LD_VAR 0 4
107543: PUSH
107544: LD_VAR 0 7
107548: ARRAY
107549: PPUSH
107550: CALL_OW 261
107554: PUSH
107555: LD_INT 10
107557: LESS
107558: IFFALSE 107578
// SetFuel ( group [ i ] , 12 ) ;
107560: LD_VAR 0 4
107564: PUSH
107565: LD_VAR 0 7
107569: ARRAY
107570: PPUSH
107571: LD_INT 12
107573: PPUSH
107574: CALL_OW 240
// if units_path [ i ] then
107578: LD_VAR 0 16
107582: PUSH
107583: LD_VAR 0 7
107587: ARRAY
107588: IFFALSE 107773
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107590: LD_VAR 0 4
107594: PUSH
107595: LD_VAR 0 7
107599: ARRAY
107600: PPUSH
107601: LD_VAR 0 16
107605: PUSH
107606: LD_VAR 0 7
107610: ARRAY
107611: PUSH
107612: LD_INT 1
107614: ARRAY
107615: PUSH
107616: LD_INT 1
107618: ARRAY
107619: PPUSH
107620: LD_VAR 0 16
107624: PUSH
107625: LD_VAR 0 7
107629: ARRAY
107630: PUSH
107631: LD_INT 1
107633: ARRAY
107634: PUSH
107635: LD_INT 2
107637: ARRAY
107638: PPUSH
107639: CALL_OW 297
107643: PUSH
107644: LD_INT 6
107646: GREATER
107647: IFFALSE 107722
// begin if not HasTask ( group [ i ] ) then
107649: LD_VAR 0 4
107653: PUSH
107654: LD_VAR 0 7
107658: ARRAY
107659: PPUSH
107660: CALL_OW 314
107664: NOT
107665: IFFALSE 107720
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107667: LD_VAR 0 4
107671: PUSH
107672: LD_VAR 0 7
107676: ARRAY
107677: PPUSH
107678: LD_VAR 0 16
107682: PUSH
107683: LD_VAR 0 7
107687: ARRAY
107688: PUSH
107689: LD_INT 1
107691: ARRAY
107692: PUSH
107693: LD_INT 1
107695: ARRAY
107696: PPUSH
107697: LD_VAR 0 16
107701: PUSH
107702: LD_VAR 0 7
107706: ARRAY
107707: PUSH
107708: LD_INT 1
107710: ARRAY
107711: PUSH
107712: LD_INT 2
107714: ARRAY
107715: PPUSH
107716: CALL_OW 114
// end else
107720: GO 107773
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107722: LD_ADDR_VAR 0 15
107726: PUSH
107727: LD_VAR 0 16
107731: PUSH
107732: LD_VAR 0 7
107736: ARRAY
107737: PPUSH
107738: LD_INT 1
107740: PPUSH
107741: CALL_OW 3
107745: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107746: LD_ADDR_VAR 0 16
107750: PUSH
107751: LD_VAR 0 16
107755: PPUSH
107756: LD_VAR 0 7
107760: PPUSH
107761: LD_VAR 0 15
107765: PPUSH
107766: CALL_OW 1
107770: ST_TO_ADDR
// continue ;
107771: GO 106316
// end ; end ; end else
107773: GO 110437
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107775: LD_ADDR_VAR 0 14
107779: PUSH
107780: LD_INT 81
107782: PUSH
107783: LD_VAR 0 4
107787: PUSH
107788: LD_VAR 0 7
107792: ARRAY
107793: PPUSH
107794: CALL_OW 255
107798: PUSH
107799: EMPTY
107800: LIST
107801: LIST
107802: PPUSH
107803: CALL_OW 69
107807: ST_TO_ADDR
// if not tmp then
107808: LD_VAR 0 14
107812: NOT
107813: IFFALSE 107817
// continue ;
107815: GO 106316
// if f_ignore_area then
107817: LD_VAR 0 17
107821: IFFALSE 107909
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107823: LD_ADDR_VAR 0 15
107827: PUSH
107828: LD_VAR 0 14
107832: PPUSH
107833: LD_INT 3
107835: PUSH
107836: LD_INT 92
107838: PUSH
107839: LD_VAR 0 17
107843: PUSH
107844: LD_INT 1
107846: ARRAY
107847: PUSH
107848: LD_VAR 0 17
107852: PUSH
107853: LD_INT 2
107855: ARRAY
107856: PUSH
107857: LD_VAR 0 17
107861: PUSH
107862: LD_INT 3
107864: ARRAY
107865: PUSH
107866: EMPTY
107867: LIST
107868: LIST
107869: LIST
107870: LIST
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: PPUSH
107876: CALL_OW 72
107880: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107881: LD_VAR 0 14
107885: PUSH
107886: LD_VAR 0 15
107890: DIFF
107891: IFFALSE 107909
// tmp := tmp diff tmp2 ;
107893: LD_ADDR_VAR 0 14
107897: PUSH
107898: LD_VAR 0 14
107902: PUSH
107903: LD_VAR 0 15
107907: DIFF
107908: ST_TO_ADDR
// end ; if not f_murder then
107909: LD_VAR 0 20
107913: NOT
107914: IFFALSE 107972
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107916: LD_ADDR_VAR 0 15
107920: PUSH
107921: LD_VAR 0 14
107925: PPUSH
107926: LD_INT 3
107928: PUSH
107929: LD_INT 50
107931: PUSH
107932: EMPTY
107933: LIST
107934: PUSH
107935: EMPTY
107936: LIST
107937: LIST
107938: PPUSH
107939: CALL_OW 72
107943: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107944: LD_VAR 0 14
107948: PUSH
107949: LD_VAR 0 15
107953: DIFF
107954: IFFALSE 107972
// tmp := tmp diff tmp2 ;
107956: LD_ADDR_VAR 0 14
107960: PUSH
107961: LD_VAR 0 14
107965: PUSH
107966: LD_VAR 0 15
107970: DIFF
107971: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107972: LD_ADDR_VAR 0 14
107976: PUSH
107977: LD_VAR 0 4
107981: PUSH
107982: LD_VAR 0 7
107986: ARRAY
107987: PPUSH
107988: LD_VAR 0 14
107992: PPUSH
107993: LD_INT 1
107995: PPUSH
107996: LD_INT 1
107998: PPUSH
107999: CALL 19183 0 4
108003: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
108004: LD_VAR 0 4
108008: PUSH
108009: LD_VAR 0 7
108013: ARRAY
108014: PPUSH
108015: CALL_OW 257
108019: PUSH
108020: LD_INT 1
108022: EQUAL
108023: IFFALSE 108471
// begin if WantPlant ( group [ i ] ) then
108025: LD_VAR 0 4
108029: PUSH
108030: LD_VAR 0 7
108034: ARRAY
108035: PPUSH
108036: CALL 18684 0 1
108040: IFFALSE 108044
// continue ;
108042: GO 106316
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
108044: LD_VAR 0 18
108048: PUSH
108049: LD_VAR 0 4
108053: PUSH
108054: LD_VAR 0 7
108058: ARRAY
108059: PPUSH
108060: CALL_OW 310
108064: NOT
108065: AND
108066: PUSH
108067: LD_VAR 0 14
108071: PUSH
108072: LD_INT 1
108074: ARRAY
108075: PUSH
108076: LD_VAR 0 14
108080: PPUSH
108081: LD_INT 21
108083: PUSH
108084: LD_INT 2
108086: PUSH
108087: EMPTY
108088: LIST
108089: LIST
108090: PUSH
108091: LD_INT 58
108093: PUSH
108094: EMPTY
108095: LIST
108096: PUSH
108097: EMPTY
108098: LIST
108099: LIST
108100: PPUSH
108101: CALL_OW 72
108105: IN
108106: AND
108107: IFFALSE 108143
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108109: LD_VAR 0 4
108113: PUSH
108114: LD_VAR 0 7
108118: ARRAY
108119: PPUSH
108120: LD_VAR 0 14
108124: PUSH
108125: LD_INT 1
108127: ARRAY
108128: PPUSH
108129: CALL_OW 120
// attacking := true ;
108133: LD_ADDR_VAR 0 29
108137: PUSH
108138: LD_INT 1
108140: ST_TO_ADDR
// continue ;
108141: GO 106316
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108143: LD_VAR 0 26
108147: PUSH
108148: LD_VAR 0 4
108152: PUSH
108153: LD_VAR 0 7
108157: ARRAY
108158: PPUSH
108159: CALL_OW 257
108163: PUSH
108164: LD_INT 1
108166: EQUAL
108167: AND
108168: PUSH
108169: LD_VAR 0 4
108173: PUSH
108174: LD_VAR 0 7
108178: ARRAY
108179: PPUSH
108180: CALL_OW 256
108184: PUSH
108185: LD_INT 800
108187: LESS
108188: AND
108189: PUSH
108190: LD_VAR 0 4
108194: PUSH
108195: LD_VAR 0 7
108199: ARRAY
108200: PPUSH
108201: CALL_OW 318
108205: NOT
108206: AND
108207: IFFALSE 108224
// ComCrawl ( group [ i ] ) ;
108209: LD_VAR 0 4
108213: PUSH
108214: LD_VAR 0 7
108218: ARRAY
108219: PPUSH
108220: CALL_OW 137
// if f_mines then
108224: LD_VAR 0 21
108228: IFFALSE 108471
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108230: LD_VAR 0 14
108234: PUSH
108235: LD_INT 1
108237: ARRAY
108238: PPUSH
108239: CALL_OW 247
108243: PUSH
108244: LD_INT 3
108246: EQUAL
108247: PUSH
108248: LD_VAR 0 14
108252: PUSH
108253: LD_INT 1
108255: ARRAY
108256: PUSH
108257: LD_VAR 0 27
108261: IN
108262: NOT
108263: AND
108264: IFFALSE 108471
// begin x := GetX ( tmp [ 1 ] ) ;
108266: LD_ADDR_VAR 0 10
108270: PUSH
108271: LD_VAR 0 14
108275: PUSH
108276: LD_INT 1
108278: ARRAY
108279: PPUSH
108280: CALL_OW 250
108284: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108285: LD_ADDR_VAR 0 11
108289: PUSH
108290: LD_VAR 0 14
108294: PUSH
108295: LD_INT 1
108297: ARRAY
108298: PPUSH
108299: CALL_OW 251
108303: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108304: LD_ADDR_VAR 0 12
108308: PUSH
108309: LD_VAR 0 4
108313: PUSH
108314: LD_VAR 0 7
108318: ARRAY
108319: PPUSH
108320: CALL 46327 0 1
108324: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108325: LD_VAR 0 4
108329: PUSH
108330: LD_VAR 0 7
108334: ARRAY
108335: PPUSH
108336: LD_VAR 0 10
108340: PPUSH
108341: LD_VAR 0 11
108345: PPUSH
108346: LD_VAR 0 14
108350: PUSH
108351: LD_INT 1
108353: ARRAY
108354: PPUSH
108355: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108359: LD_VAR 0 4
108363: PUSH
108364: LD_VAR 0 7
108368: ARRAY
108369: PPUSH
108370: LD_VAR 0 10
108374: PPUSH
108375: LD_VAR 0 12
108379: PPUSH
108380: LD_INT 7
108382: PPUSH
108383: CALL_OW 272
108387: PPUSH
108388: LD_VAR 0 11
108392: PPUSH
108393: LD_VAR 0 12
108397: PPUSH
108398: LD_INT 7
108400: PPUSH
108401: CALL_OW 273
108405: PPUSH
108406: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108410: LD_VAR 0 4
108414: PUSH
108415: LD_VAR 0 7
108419: ARRAY
108420: PPUSH
108421: LD_INT 71
108423: PPUSH
108424: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108428: LD_ADDR_VAR 0 27
108432: PUSH
108433: LD_VAR 0 27
108437: PPUSH
108438: LD_VAR 0 27
108442: PUSH
108443: LD_INT 1
108445: PLUS
108446: PPUSH
108447: LD_VAR 0 14
108451: PUSH
108452: LD_INT 1
108454: ARRAY
108455: PPUSH
108456: CALL_OW 1
108460: ST_TO_ADDR
// attacking := true ;
108461: LD_ADDR_VAR 0 29
108465: PUSH
108466: LD_INT 1
108468: ST_TO_ADDR
// continue ;
108469: GO 106316
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108471: LD_VAR 0 4
108475: PUSH
108476: LD_VAR 0 7
108480: ARRAY
108481: PPUSH
108482: CALL_OW 257
108486: PUSH
108487: LD_INT 17
108489: EQUAL
108490: PUSH
108491: LD_VAR 0 4
108495: PUSH
108496: LD_VAR 0 7
108500: ARRAY
108501: PPUSH
108502: CALL_OW 110
108506: PUSH
108507: LD_INT 71
108509: EQUAL
108510: NOT
108511: AND
108512: IFFALSE 108658
// begin attacking := false ;
108514: LD_ADDR_VAR 0 29
108518: PUSH
108519: LD_INT 0
108521: ST_TO_ADDR
// k := 5 ;
108522: LD_ADDR_VAR 0 9
108526: PUSH
108527: LD_INT 5
108529: ST_TO_ADDR
// if tmp < k then
108530: LD_VAR 0 14
108534: PUSH
108535: LD_VAR 0 9
108539: LESS
108540: IFFALSE 108552
// k := tmp ;
108542: LD_ADDR_VAR 0 9
108546: PUSH
108547: LD_VAR 0 14
108551: ST_TO_ADDR
// for j = 1 to k do
108552: LD_ADDR_VAR 0 8
108556: PUSH
108557: DOUBLE
108558: LD_INT 1
108560: DEC
108561: ST_TO_ADDR
108562: LD_VAR 0 9
108566: PUSH
108567: FOR_TO
108568: IFFALSE 108656
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108570: LD_VAR 0 14
108574: PUSH
108575: LD_VAR 0 8
108579: ARRAY
108580: PUSH
108581: LD_VAR 0 14
108585: PPUSH
108586: LD_INT 58
108588: PUSH
108589: EMPTY
108590: LIST
108591: PPUSH
108592: CALL_OW 72
108596: IN
108597: NOT
108598: IFFALSE 108654
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108600: LD_VAR 0 4
108604: PUSH
108605: LD_VAR 0 7
108609: ARRAY
108610: PPUSH
108611: LD_VAR 0 14
108615: PUSH
108616: LD_VAR 0 8
108620: ARRAY
108621: PPUSH
108622: CALL_OW 115
// attacking := true ;
108626: LD_ADDR_VAR 0 29
108630: PUSH
108631: LD_INT 1
108633: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108634: LD_VAR 0 4
108638: PUSH
108639: LD_VAR 0 7
108643: ARRAY
108644: PPUSH
108645: LD_INT 71
108647: PPUSH
108648: CALL_OW 109
// continue ;
108652: GO 108567
// end ; end ;
108654: GO 108567
108656: POP
108657: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108658: LD_VAR 0 4
108662: PUSH
108663: LD_VAR 0 7
108667: ARRAY
108668: PPUSH
108669: CALL_OW 257
108673: PUSH
108674: LD_INT 8
108676: EQUAL
108677: PUSH
108678: LD_VAR 0 4
108682: PUSH
108683: LD_VAR 0 7
108687: ARRAY
108688: PPUSH
108689: CALL_OW 264
108693: PUSH
108694: LD_INT 28
108696: PUSH
108697: LD_INT 45
108699: PUSH
108700: LD_INT 7
108702: PUSH
108703: LD_INT 47
108705: PUSH
108706: EMPTY
108707: LIST
108708: LIST
108709: LIST
108710: LIST
108711: IN
108712: OR
108713: IFFALSE 108969
// begin attacking := false ;
108715: LD_ADDR_VAR 0 29
108719: PUSH
108720: LD_INT 0
108722: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108723: LD_VAR 0 14
108727: PUSH
108728: LD_INT 1
108730: ARRAY
108731: PPUSH
108732: CALL_OW 266
108736: PUSH
108737: LD_INT 32
108739: PUSH
108740: LD_INT 31
108742: PUSH
108743: LD_INT 33
108745: PUSH
108746: LD_INT 4
108748: PUSH
108749: LD_INT 5
108751: PUSH
108752: EMPTY
108753: LIST
108754: LIST
108755: LIST
108756: LIST
108757: LIST
108758: IN
108759: IFFALSE 108945
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108761: LD_ADDR_VAR 0 9
108765: PUSH
108766: LD_VAR 0 14
108770: PUSH
108771: LD_INT 1
108773: ARRAY
108774: PPUSH
108775: CALL_OW 266
108779: PPUSH
108780: LD_VAR 0 14
108784: PUSH
108785: LD_INT 1
108787: ARRAY
108788: PPUSH
108789: CALL_OW 250
108793: PPUSH
108794: LD_VAR 0 14
108798: PUSH
108799: LD_INT 1
108801: ARRAY
108802: PPUSH
108803: CALL_OW 251
108807: PPUSH
108808: LD_VAR 0 14
108812: PUSH
108813: LD_INT 1
108815: ARRAY
108816: PPUSH
108817: CALL_OW 254
108821: PPUSH
108822: LD_VAR 0 14
108826: PUSH
108827: LD_INT 1
108829: ARRAY
108830: PPUSH
108831: CALL_OW 248
108835: PPUSH
108836: LD_INT 0
108838: PPUSH
108839: CALL 27697 0 6
108843: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108844: LD_ADDR_VAR 0 8
108848: PUSH
108849: LD_VAR 0 4
108853: PUSH
108854: LD_VAR 0 7
108858: ARRAY
108859: PPUSH
108860: LD_VAR 0 9
108864: PPUSH
108865: CALL 46440 0 2
108869: ST_TO_ADDR
// if j then
108870: LD_VAR 0 8
108874: IFFALSE 108943
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108876: LD_VAR 0 8
108880: PUSH
108881: LD_INT 1
108883: ARRAY
108884: PPUSH
108885: LD_VAR 0 8
108889: PUSH
108890: LD_INT 2
108892: ARRAY
108893: PPUSH
108894: CALL_OW 488
108898: IFFALSE 108943
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108900: LD_VAR 0 4
108904: PUSH
108905: LD_VAR 0 7
108909: ARRAY
108910: PPUSH
108911: LD_VAR 0 8
108915: PUSH
108916: LD_INT 1
108918: ARRAY
108919: PPUSH
108920: LD_VAR 0 8
108924: PUSH
108925: LD_INT 2
108927: ARRAY
108928: PPUSH
108929: CALL_OW 116
// attacking := true ;
108933: LD_ADDR_VAR 0 29
108937: PUSH
108938: LD_INT 1
108940: ST_TO_ADDR
// continue ;
108941: GO 106316
// end ; end else
108943: GO 108969
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108945: LD_VAR 0 4
108949: PUSH
108950: LD_VAR 0 7
108954: ARRAY
108955: PPUSH
108956: LD_VAR 0 14
108960: PUSH
108961: LD_INT 1
108963: ARRAY
108964: PPUSH
108965: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108969: LD_VAR 0 4
108973: PUSH
108974: LD_VAR 0 7
108978: ARRAY
108979: PPUSH
108980: CALL_OW 265
108984: PUSH
108985: LD_INT 11
108987: EQUAL
108988: IFFALSE 109266
// begin k := 10 ;
108990: LD_ADDR_VAR 0 9
108994: PUSH
108995: LD_INT 10
108997: ST_TO_ADDR
// x := 0 ;
108998: LD_ADDR_VAR 0 10
109002: PUSH
109003: LD_INT 0
109005: ST_TO_ADDR
// if tmp < k then
109006: LD_VAR 0 14
109010: PUSH
109011: LD_VAR 0 9
109015: LESS
109016: IFFALSE 109028
// k := tmp ;
109018: LD_ADDR_VAR 0 9
109022: PUSH
109023: LD_VAR 0 14
109027: ST_TO_ADDR
// for j = k downto 1 do
109028: LD_ADDR_VAR 0 8
109032: PUSH
109033: DOUBLE
109034: LD_VAR 0 9
109038: INC
109039: ST_TO_ADDR
109040: LD_INT 1
109042: PUSH
109043: FOR_DOWNTO
109044: IFFALSE 109119
// begin if GetType ( tmp [ j ] ) = unit_human then
109046: LD_VAR 0 14
109050: PUSH
109051: LD_VAR 0 8
109055: ARRAY
109056: PPUSH
109057: CALL_OW 247
109061: PUSH
109062: LD_INT 1
109064: EQUAL
109065: IFFALSE 109117
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109067: LD_VAR 0 4
109071: PUSH
109072: LD_VAR 0 7
109076: ARRAY
109077: PPUSH
109078: LD_VAR 0 14
109082: PUSH
109083: LD_VAR 0 8
109087: ARRAY
109088: PPUSH
109089: CALL 46694 0 2
// x := tmp [ j ] ;
109093: LD_ADDR_VAR 0 10
109097: PUSH
109098: LD_VAR 0 14
109102: PUSH
109103: LD_VAR 0 8
109107: ARRAY
109108: ST_TO_ADDR
// attacking := true ;
109109: LD_ADDR_VAR 0 29
109113: PUSH
109114: LD_INT 1
109116: ST_TO_ADDR
// end ; end ;
109117: GO 109043
109119: POP
109120: POP
// if not x then
109121: LD_VAR 0 10
109125: NOT
109126: IFFALSE 109266
// begin attacking := true ;
109128: LD_ADDR_VAR 0 29
109132: PUSH
109133: LD_INT 1
109135: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109136: LD_VAR 0 4
109140: PUSH
109141: LD_VAR 0 7
109145: ARRAY
109146: PPUSH
109147: CALL_OW 250
109151: PPUSH
109152: LD_VAR 0 4
109156: PUSH
109157: LD_VAR 0 7
109161: ARRAY
109162: PPUSH
109163: CALL_OW 251
109167: PPUSH
109168: CALL_OW 546
109172: PUSH
109173: LD_INT 2
109175: ARRAY
109176: PUSH
109177: LD_VAR 0 14
109181: PUSH
109182: LD_INT 1
109184: ARRAY
109185: PPUSH
109186: CALL_OW 250
109190: PPUSH
109191: LD_VAR 0 14
109195: PUSH
109196: LD_INT 1
109198: ARRAY
109199: PPUSH
109200: CALL_OW 251
109204: PPUSH
109205: CALL_OW 546
109209: PUSH
109210: LD_INT 2
109212: ARRAY
109213: EQUAL
109214: IFFALSE 109242
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109216: LD_VAR 0 4
109220: PUSH
109221: LD_VAR 0 7
109225: ARRAY
109226: PPUSH
109227: LD_VAR 0 14
109231: PUSH
109232: LD_INT 1
109234: ARRAY
109235: PPUSH
109236: CALL 46694 0 2
109240: GO 109266
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109242: LD_VAR 0 4
109246: PUSH
109247: LD_VAR 0 7
109251: ARRAY
109252: PPUSH
109253: LD_VAR 0 14
109257: PUSH
109258: LD_INT 1
109260: ARRAY
109261: PPUSH
109262: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109266: LD_VAR 0 4
109270: PUSH
109271: LD_VAR 0 7
109275: ARRAY
109276: PPUSH
109277: CALL_OW 264
109281: PUSH
109282: LD_INT 29
109284: EQUAL
109285: IFFALSE 109651
// begin if WantsToAttack ( group [ i ] ) in bombed then
109287: LD_VAR 0 4
109291: PUSH
109292: LD_VAR 0 7
109296: ARRAY
109297: PPUSH
109298: CALL_OW 319
109302: PUSH
109303: LD_VAR 0 28
109307: IN
109308: IFFALSE 109312
// continue ;
109310: GO 106316
// k := 8 ;
109312: LD_ADDR_VAR 0 9
109316: PUSH
109317: LD_INT 8
109319: ST_TO_ADDR
// x := 0 ;
109320: LD_ADDR_VAR 0 10
109324: PUSH
109325: LD_INT 0
109327: ST_TO_ADDR
// if tmp < k then
109328: LD_VAR 0 14
109332: PUSH
109333: LD_VAR 0 9
109337: LESS
109338: IFFALSE 109350
// k := tmp ;
109340: LD_ADDR_VAR 0 9
109344: PUSH
109345: LD_VAR 0 14
109349: ST_TO_ADDR
// for j = 1 to k do
109350: LD_ADDR_VAR 0 8
109354: PUSH
109355: DOUBLE
109356: LD_INT 1
109358: DEC
109359: ST_TO_ADDR
109360: LD_VAR 0 9
109364: PUSH
109365: FOR_TO
109366: IFFALSE 109498
// begin if GetType ( tmp [ j ] ) = unit_building then
109368: LD_VAR 0 14
109372: PUSH
109373: LD_VAR 0 8
109377: ARRAY
109378: PPUSH
109379: CALL_OW 247
109383: PUSH
109384: LD_INT 3
109386: EQUAL
109387: IFFALSE 109496
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109389: LD_VAR 0 14
109393: PUSH
109394: LD_VAR 0 8
109398: ARRAY
109399: PUSH
109400: LD_VAR 0 28
109404: IN
109405: NOT
109406: PUSH
109407: LD_VAR 0 14
109411: PUSH
109412: LD_VAR 0 8
109416: ARRAY
109417: PPUSH
109418: CALL_OW 313
109422: AND
109423: IFFALSE 109496
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109425: LD_VAR 0 4
109429: PUSH
109430: LD_VAR 0 7
109434: ARRAY
109435: PPUSH
109436: LD_VAR 0 14
109440: PUSH
109441: LD_VAR 0 8
109445: ARRAY
109446: PPUSH
109447: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109451: LD_ADDR_VAR 0 28
109455: PUSH
109456: LD_VAR 0 28
109460: PPUSH
109461: LD_VAR 0 28
109465: PUSH
109466: LD_INT 1
109468: PLUS
109469: PPUSH
109470: LD_VAR 0 14
109474: PUSH
109475: LD_VAR 0 8
109479: ARRAY
109480: PPUSH
109481: CALL_OW 1
109485: ST_TO_ADDR
// attacking := true ;
109486: LD_ADDR_VAR 0 29
109490: PUSH
109491: LD_INT 1
109493: ST_TO_ADDR
// break ;
109494: GO 109498
// end ; end ;
109496: GO 109365
109498: POP
109499: POP
// if not attacking and f_attack_depot then
109500: LD_VAR 0 29
109504: NOT
109505: PUSH
109506: LD_VAR 0 25
109510: AND
109511: IFFALSE 109606
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109513: LD_ADDR_VAR 0 13
109517: PUSH
109518: LD_VAR 0 14
109522: PPUSH
109523: LD_INT 2
109525: PUSH
109526: LD_INT 30
109528: PUSH
109529: LD_INT 0
109531: PUSH
109532: EMPTY
109533: LIST
109534: LIST
109535: PUSH
109536: LD_INT 30
109538: PUSH
109539: LD_INT 1
109541: PUSH
109542: EMPTY
109543: LIST
109544: LIST
109545: PUSH
109546: EMPTY
109547: LIST
109548: LIST
109549: LIST
109550: PPUSH
109551: CALL_OW 72
109555: ST_TO_ADDR
// if z then
109556: LD_VAR 0 13
109560: IFFALSE 109606
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109562: LD_VAR 0 4
109566: PUSH
109567: LD_VAR 0 7
109571: ARRAY
109572: PPUSH
109573: LD_VAR 0 13
109577: PPUSH
109578: LD_VAR 0 4
109582: PUSH
109583: LD_VAR 0 7
109587: ARRAY
109588: PPUSH
109589: CALL_OW 74
109593: PPUSH
109594: CALL_OW 115
// attacking := true ;
109598: LD_ADDR_VAR 0 29
109602: PUSH
109603: LD_INT 1
109605: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109606: LD_VAR 0 4
109610: PUSH
109611: LD_VAR 0 7
109615: ARRAY
109616: PPUSH
109617: CALL_OW 256
109621: PUSH
109622: LD_INT 500
109624: LESS
109625: IFFALSE 109651
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109627: LD_VAR 0 4
109631: PUSH
109632: LD_VAR 0 7
109636: ARRAY
109637: PPUSH
109638: LD_VAR 0 14
109642: PUSH
109643: LD_INT 1
109645: ARRAY
109646: PPUSH
109647: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109651: LD_VAR 0 4
109655: PUSH
109656: LD_VAR 0 7
109660: ARRAY
109661: PPUSH
109662: CALL_OW 264
109666: PUSH
109667: LD_INT 49
109669: EQUAL
109670: IFFALSE 109791
// begin if not HasTask ( group [ i ] ) then
109672: LD_VAR 0 4
109676: PUSH
109677: LD_VAR 0 7
109681: ARRAY
109682: PPUSH
109683: CALL_OW 314
109687: NOT
109688: IFFALSE 109791
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109690: LD_ADDR_VAR 0 9
109694: PUSH
109695: LD_INT 81
109697: PUSH
109698: LD_VAR 0 4
109702: PUSH
109703: LD_VAR 0 7
109707: ARRAY
109708: PPUSH
109709: CALL_OW 255
109713: PUSH
109714: EMPTY
109715: LIST
109716: LIST
109717: PPUSH
109718: CALL_OW 69
109722: PPUSH
109723: LD_VAR 0 4
109727: PUSH
109728: LD_VAR 0 7
109732: ARRAY
109733: PPUSH
109734: CALL_OW 74
109738: ST_TO_ADDR
// if k then
109739: LD_VAR 0 9
109743: IFFALSE 109791
// if GetDistUnits ( group [ i ] , k ) > 10 then
109745: LD_VAR 0 4
109749: PUSH
109750: LD_VAR 0 7
109754: ARRAY
109755: PPUSH
109756: LD_VAR 0 9
109760: PPUSH
109761: CALL_OW 296
109765: PUSH
109766: LD_INT 10
109768: GREATER
109769: IFFALSE 109791
// ComMoveUnit ( group [ i ] , k ) ;
109771: LD_VAR 0 4
109775: PUSH
109776: LD_VAR 0 7
109780: ARRAY
109781: PPUSH
109782: LD_VAR 0 9
109786: PPUSH
109787: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109791: LD_VAR 0 4
109795: PUSH
109796: LD_VAR 0 7
109800: ARRAY
109801: PPUSH
109802: CALL_OW 256
109806: PUSH
109807: LD_INT 250
109809: LESS
109810: PUSH
109811: LD_VAR 0 4
109815: PUSH
109816: LD_VAR 0 7
109820: ARRAY
109821: PUSH
109822: LD_INT 21
109824: PUSH
109825: LD_INT 2
109827: PUSH
109828: EMPTY
109829: LIST
109830: LIST
109831: PUSH
109832: LD_INT 23
109834: PUSH
109835: LD_INT 2
109837: PUSH
109838: EMPTY
109839: LIST
109840: LIST
109841: PUSH
109842: EMPTY
109843: LIST
109844: LIST
109845: PPUSH
109846: CALL_OW 69
109850: IN
109851: AND
109852: IFFALSE 109977
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109854: LD_ADDR_VAR 0 9
109858: PUSH
109859: LD_OWVAR 3
109863: PUSH
109864: LD_VAR 0 4
109868: PUSH
109869: LD_VAR 0 7
109873: ARRAY
109874: DIFF
109875: PPUSH
109876: LD_VAR 0 4
109880: PUSH
109881: LD_VAR 0 7
109885: ARRAY
109886: PPUSH
109887: CALL_OW 74
109891: ST_TO_ADDR
// if not k then
109892: LD_VAR 0 9
109896: NOT
109897: IFFALSE 109901
// continue ;
109899: GO 106316
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109901: LD_VAR 0 9
109905: PUSH
109906: LD_INT 81
109908: PUSH
109909: LD_VAR 0 4
109913: PUSH
109914: LD_VAR 0 7
109918: ARRAY
109919: PPUSH
109920: CALL_OW 255
109924: PUSH
109925: EMPTY
109926: LIST
109927: LIST
109928: PPUSH
109929: CALL_OW 69
109933: IN
109934: PUSH
109935: LD_VAR 0 9
109939: PPUSH
109940: LD_VAR 0 4
109944: PUSH
109945: LD_VAR 0 7
109949: ARRAY
109950: PPUSH
109951: CALL_OW 296
109955: PUSH
109956: LD_INT 5
109958: LESS
109959: AND
109960: IFFALSE 109977
// ComAutodestruct ( group [ i ] ) ;
109962: LD_VAR 0 4
109966: PUSH
109967: LD_VAR 0 7
109971: ARRAY
109972: PPUSH
109973: CALL 46592 0 1
// end ; if f_attack_depot then
109977: LD_VAR 0 25
109981: IFFALSE 110093
// begin k := 6 ;
109983: LD_ADDR_VAR 0 9
109987: PUSH
109988: LD_INT 6
109990: ST_TO_ADDR
// if tmp < k then
109991: LD_VAR 0 14
109995: PUSH
109996: LD_VAR 0 9
110000: LESS
110001: IFFALSE 110013
// k := tmp ;
110003: LD_ADDR_VAR 0 9
110007: PUSH
110008: LD_VAR 0 14
110012: ST_TO_ADDR
// for j = 1 to k do
110013: LD_ADDR_VAR 0 8
110017: PUSH
110018: DOUBLE
110019: LD_INT 1
110021: DEC
110022: ST_TO_ADDR
110023: LD_VAR 0 9
110027: PUSH
110028: FOR_TO
110029: IFFALSE 110091
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
110031: LD_VAR 0 8
110035: PPUSH
110036: CALL_OW 266
110040: PUSH
110041: LD_INT 0
110043: PUSH
110044: LD_INT 1
110046: PUSH
110047: EMPTY
110048: LIST
110049: LIST
110050: IN
110051: IFFALSE 110089
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110053: LD_VAR 0 4
110057: PUSH
110058: LD_VAR 0 7
110062: ARRAY
110063: PPUSH
110064: LD_VAR 0 14
110068: PUSH
110069: LD_VAR 0 8
110073: ARRAY
110074: PPUSH
110075: CALL_OW 115
// attacking := true ;
110079: LD_ADDR_VAR 0 29
110083: PUSH
110084: LD_INT 1
110086: ST_TO_ADDR
// break ;
110087: GO 110091
// end ;
110089: GO 110028
110091: POP
110092: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110093: LD_VAR 0 4
110097: PUSH
110098: LD_VAR 0 7
110102: ARRAY
110103: PPUSH
110104: CALL_OW 302
110108: PUSH
110109: LD_VAR 0 29
110113: NOT
110114: AND
110115: IFFALSE 110437
// begin if GetTag ( group [ i ] ) = 71 then
110117: LD_VAR 0 4
110121: PUSH
110122: LD_VAR 0 7
110126: ARRAY
110127: PPUSH
110128: CALL_OW 110
110132: PUSH
110133: LD_INT 71
110135: EQUAL
110136: IFFALSE 110177
// begin if HasTask ( group [ i ] ) then
110138: LD_VAR 0 4
110142: PUSH
110143: LD_VAR 0 7
110147: ARRAY
110148: PPUSH
110149: CALL_OW 314
110153: IFFALSE 110159
// continue else
110155: GO 106316
110157: GO 110177
// SetTag ( group [ i ] , 0 ) ;
110159: LD_VAR 0 4
110163: PUSH
110164: LD_VAR 0 7
110168: ARRAY
110169: PPUSH
110170: LD_INT 0
110172: PPUSH
110173: CALL_OW 109
// end ; k := 8 ;
110177: LD_ADDR_VAR 0 9
110181: PUSH
110182: LD_INT 8
110184: ST_TO_ADDR
// x := 0 ;
110185: LD_ADDR_VAR 0 10
110189: PUSH
110190: LD_INT 0
110192: ST_TO_ADDR
// if tmp < k then
110193: LD_VAR 0 14
110197: PUSH
110198: LD_VAR 0 9
110202: LESS
110203: IFFALSE 110215
// k := tmp ;
110205: LD_ADDR_VAR 0 9
110209: PUSH
110210: LD_VAR 0 14
110214: ST_TO_ADDR
// for j = 1 to k do
110215: LD_ADDR_VAR 0 8
110219: PUSH
110220: DOUBLE
110221: LD_INT 1
110223: DEC
110224: ST_TO_ADDR
110225: LD_VAR 0 9
110229: PUSH
110230: FOR_TO
110231: IFFALSE 110329
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110233: LD_VAR 0 14
110237: PUSH
110238: LD_VAR 0 8
110242: ARRAY
110243: PPUSH
110244: CALL_OW 247
110248: PUSH
110249: LD_INT 1
110251: EQUAL
110252: PUSH
110253: LD_VAR 0 14
110257: PUSH
110258: LD_VAR 0 8
110262: ARRAY
110263: PPUSH
110264: CALL_OW 256
110268: PUSH
110269: LD_INT 250
110271: LESS
110272: PUSH
110273: LD_VAR 0 20
110277: AND
110278: PUSH
110279: LD_VAR 0 20
110283: NOT
110284: PUSH
110285: LD_VAR 0 14
110289: PUSH
110290: LD_VAR 0 8
110294: ARRAY
110295: PPUSH
110296: CALL_OW 256
110300: PUSH
110301: LD_INT 250
110303: GREATEREQUAL
110304: AND
110305: OR
110306: AND
110307: IFFALSE 110327
// begin x := tmp [ j ] ;
110309: LD_ADDR_VAR 0 10
110313: PUSH
110314: LD_VAR 0 14
110318: PUSH
110319: LD_VAR 0 8
110323: ARRAY
110324: ST_TO_ADDR
// break ;
110325: GO 110329
// end ;
110327: GO 110230
110329: POP
110330: POP
// if x then
110331: LD_VAR 0 10
110335: IFFALSE 110359
// ComAttackUnit ( group [ i ] , x ) else
110337: LD_VAR 0 4
110341: PUSH
110342: LD_VAR 0 7
110346: ARRAY
110347: PPUSH
110348: LD_VAR 0 10
110352: PPUSH
110353: CALL_OW 115
110357: GO 110383
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110359: LD_VAR 0 4
110363: PUSH
110364: LD_VAR 0 7
110368: ARRAY
110369: PPUSH
110370: LD_VAR 0 14
110374: PUSH
110375: LD_INT 1
110377: ARRAY
110378: PPUSH
110379: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110383: LD_VAR 0 4
110387: PUSH
110388: LD_VAR 0 7
110392: ARRAY
110393: PPUSH
110394: CALL_OW 314
110398: NOT
110399: IFFALSE 110437
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110401: LD_VAR 0 4
110405: PUSH
110406: LD_VAR 0 7
110410: ARRAY
110411: PPUSH
110412: LD_VAR 0 14
110416: PPUSH
110417: LD_VAR 0 4
110421: PUSH
110422: LD_VAR 0 7
110426: ARRAY
110427: PPUSH
110428: CALL_OW 74
110432: PPUSH
110433: CALL_OW 115
// end ; end ; end ;
110437: GO 106316
110439: POP
110440: POP
// wait ( 0 0$2 ) ;
110441: LD_INT 70
110443: PPUSH
110444: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110448: LD_VAR 0 4
110452: NOT
110453: PUSH
110454: LD_VAR 0 4
110458: PUSH
110459: EMPTY
110460: EQUAL
110461: OR
110462: PUSH
110463: LD_INT 81
110465: PUSH
110466: LD_VAR 0 35
110470: PUSH
110471: EMPTY
110472: LIST
110473: LIST
110474: PPUSH
110475: CALL_OW 69
110479: NOT
110480: OR
110481: IFFALSE 106301
// end ;
110483: LD_VAR 0 2
110487: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
110488: LD_INT 0
110490: PPUSH
110491: PPUSH
110492: PPUSH
110493: PPUSH
110494: PPUSH
110495: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110496: LD_VAR 0 1
110500: NOT
110501: PUSH
110502: LD_EXP 50
110506: PUSH
110507: LD_VAR 0 1
110511: ARRAY
110512: NOT
110513: OR
110514: PUSH
110515: LD_VAR 0 2
110519: NOT
110520: OR
110521: IFFALSE 110525
// exit ;
110523: GO 111079
// side := mc_sides [ base ] ;
110525: LD_ADDR_VAR 0 6
110529: PUSH
110530: LD_EXP 76
110534: PUSH
110535: LD_VAR 0 1
110539: ARRAY
110540: ST_TO_ADDR
// if not side then
110541: LD_VAR 0 6
110545: NOT
110546: IFFALSE 110550
// exit ;
110548: GO 111079
// for i in solds do
110550: LD_ADDR_VAR 0 7
110554: PUSH
110555: LD_VAR 0 2
110559: PUSH
110560: FOR_IN
110561: IFFALSE 110622
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110563: LD_VAR 0 7
110567: PPUSH
110568: CALL_OW 310
110572: PPUSH
110573: CALL_OW 266
110577: PUSH
110578: LD_INT 32
110580: PUSH
110581: LD_INT 31
110583: PUSH
110584: EMPTY
110585: LIST
110586: LIST
110587: IN
110588: IFFALSE 110608
// solds := solds diff i else
110590: LD_ADDR_VAR 0 2
110594: PUSH
110595: LD_VAR 0 2
110599: PUSH
110600: LD_VAR 0 7
110604: DIFF
110605: ST_TO_ADDR
110606: GO 110620
// SetTag ( i , 18 ) ;
110608: LD_VAR 0 7
110612: PPUSH
110613: LD_INT 18
110615: PPUSH
110616: CALL_OW 109
110620: GO 110560
110622: POP
110623: POP
// if not solds then
110624: LD_VAR 0 2
110628: NOT
110629: IFFALSE 110633
// exit ;
110631: GO 111079
// repeat wait ( 0 0$2 ) ;
110633: LD_INT 70
110635: PPUSH
110636: CALL_OW 67
// enemy := mc_scan [ base ] ;
110640: LD_ADDR_VAR 0 4
110644: PUSH
110645: LD_EXP 73
110649: PUSH
110650: LD_VAR 0 1
110654: ARRAY
110655: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110656: LD_EXP 50
110660: PUSH
110661: LD_VAR 0 1
110665: ARRAY
110666: NOT
110667: PUSH
110668: LD_EXP 50
110672: PUSH
110673: LD_VAR 0 1
110677: ARRAY
110678: PUSH
110679: EMPTY
110680: EQUAL
110681: OR
110682: IFFALSE 110719
// begin for i in solds do
110684: LD_ADDR_VAR 0 7
110688: PUSH
110689: LD_VAR 0 2
110693: PUSH
110694: FOR_IN
110695: IFFALSE 110708
// ComStop ( i ) ;
110697: LD_VAR 0 7
110701: PPUSH
110702: CALL_OW 141
110706: GO 110694
110708: POP
110709: POP
// solds := [ ] ;
110710: LD_ADDR_VAR 0 2
110714: PUSH
110715: EMPTY
110716: ST_TO_ADDR
// exit ;
110717: GO 111079
// end ; for i in solds do
110719: LD_ADDR_VAR 0 7
110723: PUSH
110724: LD_VAR 0 2
110728: PUSH
110729: FOR_IN
110730: IFFALSE 111051
// begin if IsInUnit ( i ) then
110732: LD_VAR 0 7
110736: PPUSH
110737: CALL_OW 310
110741: IFFALSE 110752
// ComExitBuilding ( i ) ;
110743: LD_VAR 0 7
110747: PPUSH
110748: CALL_OW 122
// if GetLives ( i ) > 500 then
110752: LD_VAR 0 7
110756: PPUSH
110757: CALL_OW 256
110761: PUSH
110762: LD_INT 500
110764: GREATER
110765: IFFALSE 110818
// begin e := NearestUnitToUnit ( enemy , i ) ;
110767: LD_ADDR_VAR 0 5
110771: PUSH
110772: LD_VAR 0 4
110776: PPUSH
110777: LD_VAR 0 7
110781: PPUSH
110782: CALL_OW 74
110786: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
110787: LD_VAR 0 7
110791: PPUSH
110792: LD_VAR 0 5
110796: PPUSH
110797: CALL_OW 250
110801: PPUSH
110802: LD_VAR 0 5
110806: PPUSH
110807: CALL_OW 251
110811: PPUSH
110812: CALL_OW 114
// end else
110816: GO 111049
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110818: LD_VAR 0 7
110822: PPUSH
110823: LD_EXP 50
110827: PUSH
110828: LD_VAR 0 1
110832: ARRAY
110833: PPUSH
110834: LD_INT 2
110836: PUSH
110837: LD_INT 30
110839: PUSH
110840: LD_INT 0
110842: PUSH
110843: EMPTY
110844: LIST
110845: LIST
110846: PUSH
110847: LD_INT 30
110849: PUSH
110850: LD_INT 1
110852: PUSH
110853: EMPTY
110854: LIST
110855: LIST
110856: PUSH
110857: LD_INT 30
110859: PUSH
110860: LD_INT 6
110862: PUSH
110863: EMPTY
110864: LIST
110865: LIST
110866: PUSH
110867: EMPTY
110868: LIST
110869: LIST
110870: LIST
110871: LIST
110872: PPUSH
110873: CALL_OW 72
110877: PPUSH
110878: LD_VAR 0 7
110882: PPUSH
110883: CALL_OW 74
110887: PPUSH
110888: CALL_OW 296
110892: PUSH
110893: LD_INT 10
110895: GREATER
110896: IFFALSE 111049
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110898: LD_ADDR_VAR 0 8
110902: PUSH
110903: LD_EXP 50
110907: PUSH
110908: LD_VAR 0 1
110912: ARRAY
110913: PPUSH
110914: LD_INT 2
110916: PUSH
110917: LD_INT 30
110919: PUSH
110920: LD_INT 0
110922: PUSH
110923: EMPTY
110924: LIST
110925: LIST
110926: PUSH
110927: LD_INT 30
110929: PUSH
110930: LD_INT 1
110932: PUSH
110933: EMPTY
110934: LIST
110935: LIST
110936: PUSH
110937: LD_INT 30
110939: PUSH
110940: LD_INT 6
110942: PUSH
110943: EMPTY
110944: LIST
110945: LIST
110946: PUSH
110947: EMPTY
110948: LIST
110949: LIST
110950: LIST
110951: LIST
110952: PPUSH
110953: CALL_OW 72
110957: PPUSH
110958: LD_VAR 0 7
110962: PPUSH
110963: CALL_OW 74
110967: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110968: LD_VAR 0 7
110972: PPUSH
110973: LD_VAR 0 8
110977: PPUSH
110978: CALL_OW 250
110982: PPUSH
110983: LD_INT 3
110985: PPUSH
110986: LD_INT 5
110988: PPUSH
110989: CALL_OW 272
110993: PPUSH
110994: LD_VAR 0 8
110998: PPUSH
110999: CALL_OW 251
111003: PPUSH
111004: LD_INT 3
111006: PPUSH
111007: LD_INT 5
111009: PPUSH
111010: CALL_OW 273
111014: PPUSH
111015: CALL_OW 111
// SetTag ( i , 0 ) ;
111019: LD_VAR 0 7
111023: PPUSH
111024: LD_INT 0
111026: PPUSH
111027: CALL_OW 109
// solds := solds diff i ;
111031: LD_ADDR_VAR 0 2
111035: PUSH
111036: LD_VAR 0 2
111040: PUSH
111041: LD_VAR 0 7
111045: DIFF
111046: ST_TO_ADDR
// continue ;
111047: GO 110729
// end ; end ;
111049: GO 110729
111051: POP
111052: POP
// until not solds or not enemy ;
111053: LD_VAR 0 2
111057: NOT
111058: PUSH
111059: LD_VAR 0 4
111063: NOT
111064: OR
111065: IFFALSE 110633
// MC_Reset ( base , 18 ) ;
111067: LD_VAR 0 1
111071: PPUSH
111072: LD_INT 18
111074: PPUSH
111075: CALL 59193 0 2
// end ;
111079: LD_VAR 0 3
111083: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
111084: LD_INT 0
111086: PPUSH
111087: PPUSH
111088: PPUSH
111089: PPUSH
111090: PPUSH
111091: PPUSH
111092: PPUSH
111093: PPUSH
111094: PPUSH
111095: PPUSH
111096: PPUSH
111097: PPUSH
111098: PPUSH
111099: PPUSH
111100: PPUSH
111101: PPUSH
111102: PPUSH
111103: PPUSH
111104: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111105: LD_ADDR_VAR 0 12
111109: PUSH
111110: LD_EXP 50
111114: PUSH
111115: LD_VAR 0 1
111119: ARRAY
111120: PPUSH
111121: LD_INT 25
111123: PUSH
111124: LD_INT 3
111126: PUSH
111127: EMPTY
111128: LIST
111129: LIST
111130: PPUSH
111131: CALL_OW 72
111135: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111136: LD_EXP 90
111140: PUSH
111141: LD_VAR 0 1
111145: ARRAY
111146: IFFALSE 111170
// mechs := mechs diff mc_remote_driver [ base ] ;
111148: LD_ADDR_VAR 0 12
111152: PUSH
111153: LD_VAR 0 12
111157: PUSH
111158: LD_EXP 90
111162: PUSH
111163: LD_VAR 0 1
111167: ARRAY
111168: DIFF
111169: ST_TO_ADDR
// for i in mechs do
111170: LD_ADDR_VAR 0 4
111174: PUSH
111175: LD_VAR 0 12
111179: PUSH
111180: FOR_IN
111181: IFFALSE 111216
// if GetTag ( i ) > 0 then
111183: LD_VAR 0 4
111187: PPUSH
111188: CALL_OW 110
111192: PUSH
111193: LD_INT 0
111195: GREATER
111196: IFFALSE 111214
// mechs := mechs diff i ;
111198: LD_ADDR_VAR 0 12
111202: PUSH
111203: LD_VAR 0 12
111207: PUSH
111208: LD_VAR 0 4
111212: DIFF
111213: ST_TO_ADDR
111214: GO 111180
111216: POP
111217: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111218: LD_ADDR_VAR 0 8
111222: PUSH
111223: LD_EXP 50
111227: PUSH
111228: LD_VAR 0 1
111232: ARRAY
111233: PPUSH
111234: LD_INT 2
111236: PUSH
111237: LD_INT 25
111239: PUSH
111240: LD_INT 1
111242: PUSH
111243: EMPTY
111244: LIST
111245: LIST
111246: PUSH
111247: LD_INT 25
111249: PUSH
111250: LD_INT 5
111252: PUSH
111253: EMPTY
111254: LIST
111255: LIST
111256: PUSH
111257: LD_INT 25
111259: PUSH
111260: LD_INT 8
111262: PUSH
111263: EMPTY
111264: LIST
111265: LIST
111266: PUSH
111267: LD_INT 25
111269: PUSH
111270: LD_INT 9
111272: PUSH
111273: EMPTY
111274: LIST
111275: LIST
111276: PUSH
111277: EMPTY
111278: LIST
111279: LIST
111280: LIST
111281: LIST
111282: LIST
111283: PPUSH
111284: CALL_OW 72
111288: ST_TO_ADDR
// if not defenders and not solds then
111289: LD_VAR 0 2
111293: NOT
111294: PUSH
111295: LD_VAR 0 8
111299: NOT
111300: AND
111301: IFFALSE 111305
// exit ;
111303: GO 113075
// depot_under_attack := false ;
111305: LD_ADDR_VAR 0 16
111309: PUSH
111310: LD_INT 0
111312: ST_TO_ADDR
// sold_defenders := [ ] ;
111313: LD_ADDR_VAR 0 17
111317: PUSH
111318: EMPTY
111319: ST_TO_ADDR
// if mechs then
111320: LD_VAR 0 12
111324: IFFALSE 111477
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111326: LD_ADDR_VAR 0 4
111330: PUSH
111331: LD_VAR 0 2
111335: PPUSH
111336: LD_INT 21
111338: PUSH
111339: LD_INT 2
111341: PUSH
111342: EMPTY
111343: LIST
111344: LIST
111345: PPUSH
111346: CALL_OW 72
111350: PUSH
111351: FOR_IN
111352: IFFALSE 111475
// begin if GetTag ( i ) <> 20 then
111354: LD_VAR 0 4
111358: PPUSH
111359: CALL_OW 110
111363: PUSH
111364: LD_INT 20
111366: NONEQUAL
111367: IFFALSE 111381
// SetTag ( i , 20 ) ;
111369: LD_VAR 0 4
111373: PPUSH
111374: LD_INT 20
111376: PPUSH
111377: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111381: LD_VAR 0 4
111385: PPUSH
111386: CALL_OW 263
111390: PUSH
111391: LD_INT 1
111393: EQUAL
111394: PUSH
111395: LD_VAR 0 4
111399: PPUSH
111400: CALL_OW 311
111404: NOT
111405: AND
111406: IFFALSE 111473
// begin un := mechs [ 1 ] ;
111408: LD_ADDR_VAR 0 10
111412: PUSH
111413: LD_VAR 0 12
111417: PUSH
111418: LD_INT 1
111420: ARRAY
111421: ST_TO_ADDR
// ComExit ( un ) ;
111422: LD_VAR 0 10
111426: PPUSH
111427: CALL 51477 0 1
// AddComEnterUnit ( un , i ) ;
111431: LD_VAR 0 10
111435: PPUSH
111436: LD_VAR 0 4
111440: PPUSH
111441: CALL_OW 180
// SetTag ( un , 19 ) ;
111445: LD_VAR 0 10
111449: PPUSH
111450: LD_INT 19
111452: PPUSH
111453: CALL_OW 109
// mechs := mechs diff un ;
111457: LD_ADDR_VAR 0 12
111461: PUSH
111462: LD_VAR 0 12
111466: PUSH
111467: LD_VAR 0 10
111471: DIFF
111472: ST_TO_ADDR
// end ; end ;
111473: GO 111351
111475: POP
111476: POP
// if solds then
111477: LD_VAR 0 8
111481: IFFALSE 111540
// for i in solds do
111483: LD_ADDR_VAR 0 4
111487: PUSH
111488: LD_VAR 0 8
111492: PUSH
111493: FOR_IN
111494: IFFALSE 111538
// if not GetTag ( i ) then
111496: LD_VAR 0 4
111500: PPUSH
111501: CALL_OW 110
111505: NOT
111506: IFFALSE 111536
// begin defenders := defenders union i ;
111508: LD_ADDR_VAR 0 2
111512: PUSH
111513: LD_VAR 0 2
111517: PUSH
111518: LD_VAR 0 4
111522: UNION
111523: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111524: LD_VAR 0 4
111528: PPUSH
111529: LD_INT 18
111531: PPUSH
111532: CALL_OW 109
// end ;
111536: GO 111493
111538: POP
111539: POP
// repeat wait ( 0 0$2 ) ;
111540: LD_INT 70
111542: PPUSH
111543: CALL_OW 67
// enemy := mc_scan [ base ] ;
111547: LD_ADDR_VAR 0 21
111551: PUSH
111552: LD_EXP 73
111556: PUSH
111557: LD_VAR 0 1
111561: ARRAY
111562: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111563: LD_EXP 50
111567: PUSH
111568: LD_VAR 0 1
111572: ARRAY
111573: NOT
111574: PUSH
111575: LD_EXP 50
111579: PUSH
111580: LD_VAR 0 1
111584: ARRAY
111585: PUSH
111586: EMPTY
111587: EQUAL
111588: OR
111589: IFFALSE 111626
// begin for i in defenders do
111591: LD_ADDR_VAR 0 4
111595: PUSH
111596: LD_VAR 0 2
111600: PUSH
111601: FOR_IN
111602: IFFALSE 111615
// ComStop ( i ) ;
111604: LD_VAR 0 4
111608: PPUSH
111609: CALL_OW 141
111613: GO 111601
111615: POP
111616: POP
// defenders := [ ] ;
111617: LD_ADDR_VAR 0 2
111621: PUSH
111622: EMPTY
111623: ST_TO_ADDR
// exit ;
111624: GO 113075
// end ; for i in defenders do
111626: LD_ADDR_VAR 0 4
111630: PUSH
111631: LD_VAR 0 2
111635: PUSH
111636: FOR_IN
111637: IFFALSE 112535
// begin e := NearestUnitToUnit ( enemy , i ) ;
111639: LD_ADDR_VAR 0 13
111643: PUSH
111644: LD_VAR 0 21
111648: PPUSH
111649: LD_VAR 0 4
111653: PPUSH
111654: CALL_OW 74
111658: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111659: LD_ADDR_VAR 0 7
111663: PUSH
111664: LD_EXP 50
111668: PUSH
111669: LD_VAR 0 1
111673: ARRAY
111674: PPUSH
111675: LD_INT 2
111677: PUSH
111678: LD_INT 30
111680: PUSH
111681: LD_INT 0
111683: PUSH
111684: EMPTY
111685: LIST
111686: LIST
111687: PUSH
111688: LD_INT 30
111690: PUSH
111691: LD_INT 1
111693: PUSH
111694: EMPTY
111695: LIST
111696: LIST
111697: PUSH
111698: EMPTY
111699: LIST
111700: LIST
111701: LIST
111702: PPUSH
111703: CALL_OW 72
111707: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111708: LD_ADDR_VAR 0 16
111712: PUSH
111713: LD_VAR 0 7
111717: NOT
111718: PUSH
111719: LD_VAR 0 7
111723: PPUSH
111724: LD_INT 3
111726: PUSH
111727: LD_INT 24
111729: PUSH
111730: LD_INT 600
111732: PUSH
111733: EMPTY
111734: LIST
111735: LIST
111736: PUSH
111737: EMPTY
111738: LIST
111739: LIST
111740: PPUSH
111741: CALL_OW 72
111745: OR
111746: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111747: LD_VAR 0 4
111751: PPUSH
111752: CALL_OW 247
111756: PUSH
111757: LD_INT 2
111759: DOUBLE
111760: EQUAL
111761: IFTRUE 111765
111763: GO 112161
111765: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111766: LD_VAR 0 4
111770: PPUSH
111771: CALL_OW 256
111775: PUSH
111776: LD_INT 1000
111778: EQUAL
111779: PUSH
111780: LD_VAR 0 4
111784: PPUSH
111785: LD_VAR 0 13
111789: PPUSH
111790: CALL_OW 296
111794: PUSH
111795: LD_INT 40
111797: LESS
111798: PUSH
111799: LD_VAR 0 13
111803: PPUSH
111804: LD_EXP 75
111808: PUSH
111809: LD_VAR 0 1
111813: ARRAY
111814: PPUSH
111815: CALL_OW 308
111819: OR
111820: AND
111821: IFFALSE 111943
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111823: LD_VAR 0 4
111827: PPUSH
111828: CALL_OW 262
111832: PUSH
111833: LD_INT 1
111835: EQUAL
111836: PUSH
111837: LD_VAR 0 4
111841: PPUSH
111842: CALL_OW 261
111846: PUSH
111847: LD_INT 30
111849: LESS
111850: AND
111851: PUSH
111852: LD_VAR 0 7
111856: AND
111857: IFFALSE 111927
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111859: LD_VAR 0 4
111863: PPUSH
111864: LD_VAR 0 7
111868: PPUSH
111869: LD_VAR 0 4
111873: PPUSH
111874: CALL_OW 74
111878: PPUSH
111879: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111883: LD_VAR 0 4
111887: PPUSH
111888: LD_VAR 0 7
111892: PPUSH
111893: LD_VAR 0 4
111897: PPUSH
111898: CALL_OW 74
111902: PPUSH
111903: CALL_OW 296
111907: PUSH
111908: LD_INT 6
111910: LESS
111911: IFFALSE 111925
// SetFuel ( i , 100 ) ;
111913: LD_VAR 0 4
111917: PPUSH
111918: LD_INT 100
111920: PPUSH
111921: CALL_OW 240
// end else
111925: GO 111941
// ComAttackUnit ( i , e ) ;
111927: LD_VAR 0 4
111931: PPUSH
111932: LD_VAR 0 13
111936: PPUSH
111937: CALL_OW 115
// end else
111941: GO 112044
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111943: LD_VAR 0 13
111947: PPUSH
111948: LD_EXP 75
111952: PUSH
111953: LD_VAR 0 1
111957: ARRAY
111958: PPUSH
111959: CALL_OW 308
111963: NOT
111964: PUSH
111965: LD_VAR 0 4
111969: PPUSH
111970: LD_VAR 0 13
111974: PPUSH
111975: CALL_OW 296
111979: PUSH
111980: LD_INT 40
111982: GREATEREQUAL
111983: AND
111984: PUSH
111985: LD_VAR 0 4
111989: PPUSH
111990: CALL_OW 256
111994: PUSH
111995: LD_INT 650
111997: LESSEQUAL
111998: OR
111999: PUSH
112000: LD_VAR 0 4
112004: PPUSH
112005: LD_EXP 74
112009: PUSH
112010: LD_VAR 0 1
112014: ARRAY
112015: PPUSH
112016: CALL_OW 308
112020: NOT
112021: AND
112022: IFFALSE 112044
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112024: LD_VAR 0 4
112028: PPUSH
112029: LD_EXP 74
112033: PUSH
112034: LD_VAR 0 1
112038: ARRAY
112039: PPUSH
112040: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
112044: LD_VAR 0 4
112048: PPUSH
112049: CALL_OW 256
112053: PUSH
112054: LD_INT 1000
112056: LESS
112057: PUSH
112058: LD_VAR 0 4
112062: PPUSH
112063: CALL_OW 263
112067: PUSH
112068: LD_INT 1
112070: EQUAL
112071: AND
112072: PUSH
112073: LD_VAR 0 4
112077: PPUSH
112078: CALL_OW 311
112082: AND
112083: PUSH
112084: LD_VAR 0 4
112088: PPUSH
112089: LD_EXP 74
112093: PUSH
112094: LD_VAR 0 1
112098: ARRAY
112099: PPUSH
112100: CALL_OW 308
112104: AND
112105: IFFALSE 112159
// begin mech := IsDrivenBy ( i ) ;
112107: LD_ADDR_VAR 0 9
112111: PUSH
112112: LD_VAR 0 4
112116: PPUSH
112117: CALL_OW 311
112121: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112122: LD_VAR 0 9
112126: PPUSH
112127: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112131: LD_VAR 0 9
112135: PPUSH
112136: LD_VAR 0 4
112140: PPUSH
112141: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112145: LD_VAR 0 9
112149: PPUSH
112150: LD_VAR 0 4
112154: PPUSH
112155: CALL_OW 180
// end ; end ; unit_human :
112159: GO 112506
112161: LD_INT 1
112163: DOUBLE
112164: EQUAL
112165: IFTRUE 112169
112167: GO 112505
112169: POP
// begin b := IsInUnit ( i ) ;
112170: LD_ADDR_VAR 0 18
112174: PUSH
112175: LD_VAR 0 4
112179: PPUSH
112180: CALL_OW 310
112184: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112185: LD_ADDR_VAR 0 19
112189: PUSH
112190: LD_VAR 0 18
112194: NOT
112195: PUSH
112196: LD_VAR 0 18
112200: PPUSH
112201: CALL_OW 266
112205: PUSH
112206: LD_INT 32
112208: PUSH
112209: LD_INT 31
112211: PUSH
112212: EMPTY
112213: LIST
112214: LIST
112215: IN
112216: OR
112217: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
112218: LD_VAR 0 18
112222: PPUSH
112223: CALL_OW 266
112227: PUSH
112228: LD_INT 5
112230: EQUAL
112231: PUSH
112232: LD_VAR 0 4
112236: PPUSH
112237: CALL_OW 257
112241: PUSH
112242: LD_INT 1
112244: PUSH
112245: LD_INT 2
112247: PUSH
112248: LD_INT 3
112250: PUSH
112251: LD_INT 4
112253: PUSH
112254: EMPTY
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: IN
112260: AND
112261: IFFALSE 112298
// begin class := AllowSpecClass ( i ) ;
112263: LD_ADDR_VAR 0 20
112267: PUSH
112268: LD_VAR 0 4
112272: PPUSH
112273: CALL 15397 0 1
112277: ST_TO_ADDR
// if class then
112278: LD_VAR 0 20
112282: IFFALSE 112298
// ComChangeProfession ( i , class ) ;
112284: LD_VAR 0 4
112288: PPUSH
112289: LD_VAR 0 20
112293: PPUSH
112294: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112298: LD_VAR 0 16
112302: PUSH
112303: LD_VAR 0 2
112307: PPUSH
112308: LD_INT 21
112310: PUSH
112311: LD_INT 2
112313: PUSH
112314: EMPTY
112315: LIST
112316: LIST
112317: PPUSH
112318: CALL_OW 72
112322: PUSH
112323: LD_INT 1
112325: LESSEQUAL
112326: OR
112327: PUSH
112328: LD_VAR 0 19
112332: AND
112333: PUSH
112334: LD_VAR 0 4
112338: PUSH
112339: LD_VAR 0 17
112343: IN
112344: NOT
112345: AND
112346: IFFALSE 112439
// begin if b then
112348: LD_VAR 0 18
112352: IFFALSE 112401
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112354: LD_VAR 0 18
112358: PPUSH
112359: LD_VAR 0 21
112363: PPUSH
112364: LD_VAR 0 18
112368: PPUSH
112369: CALL_OW 74
112373: PPUSH
112374: CALL_OW 296
112378: PUSH
112379: LD_INT 10
112381: LESS
112382: PUSH
112383: LD_VAR 0 18
112387: PPUSH
112388: CALL_OW 461
112392: PUSH
112393: LD_INT 7
112395: NONEQUAL
112396: AND
112397: IFFALSE 112401
// continue ;
112399: GO 111636
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112401: LD_ADDR_VAR 0 17
112405: PUSH
112406: LD_VAR 0 17
112410: PPUSH
112411: LD_VAR 0 17
112415: PUSH
112416: LD_INT 1
112418: PLUS
112419: PPUSH
112420: LD_VAR 0 4
112424: PPUSH
112425: CALL_OW 1
112429: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112430: LD_VAR 0 4
112434: PPUSH
112435: CALL_OW 122
// end ; if sold_defenders then
112439: LD_VAR 0 17
112443: IFFALSE 112503
// if i in sold_defenders then
112445: LD_VAR 0 4
112449: PUSH
112450: LD_VAR 0 17
112454: IN
112455: IFFALSE 112503
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112457: LD_VAR 0 4
112461: PPUSH
112462: CALL_OW 314
112466: NOT
112467: PUSH
112468: LD_VAR 0 4
112472: PPUSH
112473: LD_VAR 0 13
112477: PPUSH
112478: CALL_OW 296
112482: PUSH
112483: LD_INT 30
112485: LESS
112486: AND
112487: IFFALSE 112503
// ComAttackUnit ( i , e ) ;
112489: LD_VAR 0 4
112493: PPUSH
112494: LD_VAR 0 13
112498: PPUSH
112499: CALL_OW 115
// end ; end ; end ;
112503: GO 112506
112505: POP
// if IsDead ( i ) then
112506: LD_VAR 0 4
112510: PPUSH
112511: CALL_OW 301
112515: IFFALSE 112533
// defenders := defenders diff i ;
112517: LD_ADDR_VAR 0 2
112521: PUSH
112522: LD_VAR 0 2
112526: PUSH
112527: LD_VAR 0 4
112531: DIFF
112532: ST_TO_ADDR
// end ;
112533: GO 111636
112535: POP
112536: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112537: LD_VAR 0 21
112541: NOT
112542: PUSH
112543: LD_VAR 0 2
112547: NOT
112548: OR
112549: PUSH
112550: LD_EXP 50
112554: PUSH
112555: LD_VAR 0 1
112559: ARRAY
112560: NOT
112561: OR
112562: IFFALSE 111540
// MC_Reset ( base , 18 ) ;
112564: LD_VAR 0 1
112568: PPUSH
112569: LD_INT 18
112571: PPUSH
112572: CALL 59193 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112576: LD_ADDR_VAR 0 2
112580: PUSH
112581: LD_VAR 0 2
112585: PUSH
112586: LD_VAR 0 2
112590: PPUSH
112591: LD_INT 2
112593: PUSH
112594: LD_INT 25
112596: PUSH
112597: LD_INT 1
112599: PUSH
112600: EMPTY
112601: LIST
112602: LIST
112603: PUSH
112604: LD_INT 25
112606: PUSH
112607: LD_INT 5
112609: PUSH
112610: EMPTY
112611: LIST
112612: LIST
112613: PUSH
112614: LD_INT 25
112616: PUSH
112617: LD_INT 8
112619: PUSH
112620: EMPTY
112621: LIST
112622: LIST
112623: PUSH
112624: LD_INT 25
112626: PUSH
112627: LD_INT 9
112629: PUSH
112630: EMPTY
112631: LIST
112632: LIST
112633: PUSH
112634: EMPTY
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: PPUSH
112641: CALL_OW 72
112645: DIFF
112646: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112647: LD_VAR 0 21
112651: NOT
112652: PUSH
112653: LD_VAR 0 2
112657: PPUSH
112658: LD_INT 21
112660: PUSH
112661: LD_INT 2
112663: PUSH
112664: EMPTY
112665: LIST
112666: LIST
112667: PPUSH
112668: CALL_OW 72
112672: AND
112673: IFFALSE 113011
// begin tmp := FilterByTag ( defenders , 19 ) ;
112675: LD_ADDR_VAR 0 11
112679: PUSH
112680: LD_VAR 0 2
112684: PPUSH
112685: LD_INT 19
112687: PPUSH
112688: CALL 48660 0 2
112692: ST_TO_ADDR
// if tmp then
112693: LD_VAR 0 11
112697: IFFALSE 112767
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112699: LD_ADDR_VAR 0 11
112703: PUSH
112704: LD_VAR 0 11
112708: PPUSH
112709: LD_INT 25
112711: PUSH
112712: LD_INT 3
112714: PUSH
112715: EMPTY
112716: LIST
112717: LIST
112718: PPUSH
112719: CALL_OW 72
112723: ST_TO_ADDR
// if tmp then
112724: LD_VAR 0 11
112728: IFFALSE 112767
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112730: LD_ADDR_EXP 62
112734: PUSH
112735: LD_EXP 62
112739: PPUSH
112740: LD_VAR 0 1
112744: PPUSH
112745: LD_EXP 62
112749: PUSH
112750: LD_VAR 0 1
112754: ARRAY
112755: PUSH
112756: LD_VAR 0 11
112760: UNION
112761: PPUSH
112762: CALL_OW 1
112766: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112767: LD_VAR 0 1
112771: PPUSH
112772: LD_INT 19
112774: PPUSH
112775: CALL 59193 0 2
// repeat wait ( 0 0$1 ) ;
112779: LD_INT 35
112781: PPUSH
112782: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112786: LD_EXP 50
112790: PUSH
112791: LD_VAR 0 1
112795: ARRAY
112796: NOT
112797: PUSH
112798: LD_EXP 50
112802: PUSH
112803: LD_VAR 0 1
112807: ARRAY
112808: PUSH
112809: EMPTY
112810: EQUAL
112811: OR
112812: IFFALSE 112849
// begin for i in defenders do
112814: LD_ADDR_VAR 0 4
112818: PUSH
112819: LD_VAR 0 2
112823: PUSH
112824: FOR_IN
112825: IFFALSE 112838
// ComStop ( i ) ;
112827: LD_VAR 0 4
112831: PPUSH
112832: CALL_OW 141
112836: GO 112824
112838: POP
112839: POP
// defenders := [ ] ;
112840: LD_ADDR_VAR 0 2
112844: PUSH
112845: EMPTY
112846: ST_TO_ADDR
// exit ;
112847: GO 113075
// end ; for i in defenders do
112849: LD_ADDR_VAR 0 4
112853: PUSH
112854: LD_VAR 0 2
112858: PUSH
112859: FOR_IN
112860: IFFALSE 112949
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112862: LD_VAR 0 4
112866: PPUSH
112867: LD_EXP 74
112871: PUSH
112872: LD_VAR 0 1
112876: ARRAY
112877: PPUSH
112878: CALL_OW 308
112882: NOT
112883: IFFALSE 112907
// ComMoveToArea ( i , mc_parking [ base ] ) else
112885: LD_VAR 0 4
112889: PPUSH
112890: LD_EXP 74
112894: PUSH
112895: LD_VAR 0 1
112899: ARRAY
112900: PPUSH
112901: CALL_OW 113
112905: GO 112947
// if GetControl ( i ) = control_manual then
112907: LD_VAR 0 4
112911: PPUSH
112912: CALL_OW 263
112916: PUSH
112917: LD_INT 1
112919: EQUAL
112920: IFFALSE 112947
// if IsDrivenBy ( i ) then
112922: LD_VAR 0 4
112926: PPUSH
112927: CALL_OW 311
112931: IFFALSE 112947
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112933: LD_VAR 0 4
112937: PPUSH
112938: CALL_OW 311
112942: PPUSH
112943: CALL_OW 121
// end ;
112947: GO 112859
112949: POP
112950: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112951: LD_VAR 0 2
112955: PPUSH
112956: LD_INT 95
112958: PUSH
112959: LD_EXP 74
112963: PUSH
112964: LD_VAR 0 1
112968: ARRAY
112969: PUSH
112970: EMPTY
112971: LIST
112972: LIST
112973: PPUSH
112974: CALL_OW 72
112978: PUSH
112979: LD_VAR 0 2
112983: EQUAL
112984: PUSH
112985: LD_EXP 73
112989: PUSH
112990: LD_VAR 0 1
112994: ARRAY
112995: OR
112996: PUSH
112997: LD_EXP 50
113001: PUSH
113002: LD_VAR 0 1
113006: ARRAY
113007: NOT
113008: OR
113009: IFFALSE 112779
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113011: LD_ADDR_EXP 72
113015: PUSH
113016: LD_EXP 72
113020: PPUSH
113021: LD_VAR 0 1
113025: PPUSH
113026: LD_VAR 0 2
113030: PPUSH
113031: LD_INT 21
113033: PUSH
113034: LD_INT 2
113036: PUSH
113037: EMPTY
113038: LIST
113039: LIST
113040: PPUSH
113041: CALL_OW 72
113045: PPUSH
113046: CALL_OW 1
113050: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113051: LD_VAR 0 1
113055: PPUSH
113056: LD_INT 19
113058: PPUSH
113059: CALL 59193 0 2
// MC_Reset ( base , 20 ) ;
113063: LD_VAR 0 1
113067: PPUSH
113068: LD_INT 20
113070: PPUSH
113071: CALL 59193 0 2
// end ; end_of_file
113075: LD_VAR 0 3
113079: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113080: LD_VAR 0 1
113084: PUSH
113085: LD_INT 200
113087: DOUBLE
113088: GREATEREQUAL
113089: IFFALSE 113097
113091: LD_INT 299
113093: DOUBLE
113094: LESSEQUAL
113095: IFTRUE 113099
113097: GO 113131
113099: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113100: LD_VAR 0 1
113104: PPUSH
113105: LD_VAR 0 2
113109: PPUSH
113110: LD_VAR 0 3
113114: PPUSH
113115: LD_VAR 0 4
113119: PPUSH
113120: LD_VAR 0 5
113124: PPUSH
113125: CALL 101866 0 5
113129: GO 113208
113131: LD_INT 300
113133: DOUBLE
113134: GREATEREQUAL
113135: IFFALSE 113143
113137: LD_INT 399
113139: DOUBLE
113140: LESSEQUAL
113141: IFTRUE 113145
113143: GO 113207
113145: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
113146: LD_VAR 0 1
113150: PPUSH
113151: LD_VAR 0 2
113155: PPUSH
113156: LD_VAR 0 3
113160: PPUSH
113161: LD_VAR 0 4
113165: PPUSH
113166: LD_VAR 0 5
113170: PPUSH
113171: LD_VAR 0 6
113175: PPUSH
113176: LD_VAR 0 7
113180: PPUSH
113181: LD_VAR 0 8
113185: PPUSH
113186: LD_VAR 0 9
113190: PPUSH
113191: LD_VAR 0 10
113195: PPUSH
113196: LD_VAR 0 11
113200: PPUSH
113201: CALL 98199 0 11
113205: GO 113208
113207: POP
// end ;
113208: PPOPN 11
113210: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
113211: LD_VAR 0 1
113215: PPUSH
113216: LD_VAR 0 2
113220: PPUSH
113221: LD_VAR 0 3
113225: PPUSH
113226: LD_VAR 0 4
113230: PPUSH
113231: LD_VAR 0 5
113235: PPUSH
113236: CALL 101602 0 5
// end ; end_of_file
113240: PPOPN 5
113242: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113243: LD_VAR 0 1
113247: PPUSH
113248: LD_VAR 0 2
113252: PPUSH
113253: LD_VAR 0 3
113257: PPUSH
113258: LD_VAR 0 4
113262: PPUSH
113263: LD_VAR 0 5
113267: PPUSH
113268: LD_VAR 0 6
113272: PPUSH
113273: CALL 85851 0 6
// end ;
113277: PPOPN 6
113279: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
113280: LD_INT 0
113282: PPUSH
// begin if not units then
113283: LD_VAR 0 1
113287: NOT
113288: IFFALSE 113292
// exit ;
113290: GO 113292
// end ;
113292: PPOPN 7
113294: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
113295: CALL 85755 0 0
// end ;
113299: PPOPN 1
113301: END
