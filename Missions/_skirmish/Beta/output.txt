// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12724 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 68
 744: PUSH
 745: LD_EXP 68
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 68
 777: PUSH
 778: LD_EXP 68
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 57135 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12581 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12581 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 68
1974: PUSH
1975: LD_EXP 68
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18628 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18628 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18628 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18628 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18628 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 80463 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 80407 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 79466 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 80295 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 79977 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 79708 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 79327 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 79142 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 79034 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 79884 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 80089 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 80463 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 80407 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 79466 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 80295 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 79977 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 79708 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 79327 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 79142 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 79034 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 79884 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 80089 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 79190 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 79190 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 79190 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 79538 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 87
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 90
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 87
7660: PUSH
7661: LD_EXP 87
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 87
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 68
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 79190 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 79190 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 79190 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 80608 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 87
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 90
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 87
8875: PUSH
8876: LD_EXP 87
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 87
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 68
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18628 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18628 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18628 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18628 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18628 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18628 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL 101247 0 1
// if un = Brighton then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_EXP 9
11276: EQUAL
11277: IFFALSE 11293
// begin wait ( 0 0$1 ) ;
11279: LD_INT 35
11281: PPUSH
11282: CALL_OW 67
// YouLost ( Brighton ) ;
11286: LD_STRING Brighton
11288: PPUSH
11289: CALL_OW 104
// end ; if un = JMM then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_EXP 37
11302: EQUAL
11303: IFFALSE 11319
// begin wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// YouLost ( JMM ) ;
11312: LD_STRING JMM
11314: PPUSH
11315: CALL_OW 104
// end ; if un = Megan then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_EXP 11
11328: EQUAL
11329: IFFALSE 11343
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11331: LD_EXP 9
11335: PPUSH
11336: LD_STRING DBrighton-MeganDeath
11338: PPUSH
11339: CALL_OW 88
// end ; if un = Palmer then
11343: LD_VAR 0 1
11347: PUSH
11348: LD_EXP 10
11352: EQUAL
11353: IFFALSE 11367
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING DBrighton-PalmerDeath
11362: PPUSH
11363: CALL_OW 88
// end ; if un = Burlak then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11409
// begin if JMM_Arrived then
11379: LD_EXP 6
11383: IFFALSE 11397
// Say ( JMM , DJMM-BurlakDead ) ;
11385: LD_EXP 37
11389: PPUSH
11390: LD_STRING DJMM-BurlakDead
11392: PPUSH
11393: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11397: LD_EXP 10
11401: PPUSH
11402: LD_STRING DSol-BurlakDead
11404: PPUSH
11405: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 1
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_INT 3
11425: EQUAL
11426: OR
11427: IFFALSE 11443
// begin wait ( 0 0$1 ) ;
11429: LD_INT 35
11431: PPUSH
11432: CALL_OW 67
// YouLost ( Depot ) ;
11436: LD_STRING Depot
11438: PPUSH
11439: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 255
11452: PUSH
11453: LD_INT 1
11455: EQUAL
11456: PUSH
11457: LD_VAR 0 1
11461: PPUSH
11462: CALL_OW 247
11466: PUSH
11467: LD_INT 1
11469: EQUAL
11470: AND
11471: IFFALSE 11487
// Losses := Losses + 1 ;
11473: LD_ADDR_EXP 45
11477: PUSH
11478: LD_EXP 45
11482: PUSH
11483: LD_INT 1
11485: PLUS
11486: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: CALL 82610 0 1
// end ;
11496: PPOPN 1
11498: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11499: LD_VAR 0 1
11503: PPUSH
11504: CALL_OW 247
11508: PUSH
11509: LD_INT 2
11511: EQUAL
11512: PUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_EXP 17
11522: IN
11523: AND
11524: IFFALSE 11538
// SetLives ( un , 0 ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: LD_INT 0
11533: PPUSH
11534: CALL_OW 234
// if un = Yashin then
11538: LD_VAR 0 1
11542: PUSH
11543: LD_EXP 13
11547: EQUAL
11548: IFFALSE 11562
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11550: LD_EXP 13
11554: PPUSH
11555: LD_STRING DDeath-Yas-3
11557: PPUSH
11558: CALL_OW 91
// if un = Popov then
11562: LD_VAR 0 1
11566: PUSH
11567: LD_EXP 14
11571: EQUAL
11572: IFFALSE 11586
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11574: LD_EXP 14
11578: PPUSH
11579: LD_STRING DDeath-Pop-3
11581: PPUSH
11582: CALL_OW 91
// if un = Gaydar then
11586: LD_VAR 0 1
11590: PUSH
11591: LD_EXP 15
11595: EQUAL
11596: IFFALSE 11610
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11598: LD_EXP 15
11602: PPUSH
11603: LD_STRING DDeath-Gay-3
11605: PPUSH
11606: CALL_OW 91
// if un = Sevi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 16
11619: EQUAL
11620: IFFALSE 11634
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11622: LD_EXP 16
11626: PPUSH
11627: LD_STRING DDeath-Vse-3
11629: PPUSH
11630: CALL_OW 91
// end ;
11634: PPOPN 1
11636: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11637: LD_VAR 0 1
11641: PUSH
11642: LD_INT 10
11644: EQUAL
11645: IFFALSE 11683
// begin Say ( Brighton , DBrighton-C1 ) ;
11647: LD_EXP 9
11651: PPUSH
11652: LD_STRING DBrighton-C1
11654: PPUSH
11655: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_STRING DMegan-C1
11666: PPUSH
11667: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11671: LD_EXP 9
11675: PPUSH
11676: LD_STRING DBrighton-C2
11678: PPUSH
11679: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: CALL 82306 0 2
// end ;
11697: PPOPN 2
11699: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_VAR 0 2
11709: PPUSH
11710: CALL 84944 0 2
// end ;
11714: PPOPN 2
11716: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11717: LD_VAR 0 1
11721: PPUSH
11722: CALL 84012 0 1
// end ;
11726: PPOPN 1
11728: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 266
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 1
11747: PPUSH
11748: CALL_OW 255
11752: PUSH
11753: LD_INT 3
11755: EQUAL
11756: AND
11757: IFFALSE 11819
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 274
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 10000
11774: PPUSH
11775: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 274
11788: PPUSH
11789: LD_INT 2
11791: PPUSH
11792: LD_INT 250
11794: PPUSH
11795: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 274
11808: PPUSH
11809: LD_INT 3
11811: PPUSH
11812: LD_INT 100
11814: PPUSH
11815: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL 84253 0 1
// end ;
11828: PPOPN 1
11830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_VAR 0 2
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: LD_VAR 0 5
11855: PPUSH
11856: CALL 81926 0 5
// end ;
11860: PPOPN 5
11862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11863: LD_VAR 0 1
11867: PPUSH
11868: LD_VAR 0 2
11872: PPUSH
11873: CALL 81507 0 2
// end ;
11877: PPOPN 2
11879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL 81345 0 4
// end ;
11904: PPOPN 4
11906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_VAR 0 2
11916: PPUSH
11917: LD_VAR 0 3
11921: PPUSH
11922: CALL 81120 0 3
// end ;
11926: PPOPN 3
11928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: CALL 81005 0 2
// end ;
11943: PPOPN 2
11945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_VAR 0 2
11955: PPUSH
11956: CALL 85239 0 2
// end ;
11960: PPOPN 2
11962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 255
11972: PUSH
11973: LD_INT 6
11975: EQUAL
11976: IFFALSE 12106
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_EXP 13
11987: PUSH
11988: LD_EXP 16
11992: PUSH
11993: LD_EXP 15
11997: PUSH
11998: LD_EXP 14
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: IN
12009: IFFALSE 12013
// exit ;
12011: GO 12130
// if AssaultStarted then
12013: LD_EXP 8
12017: IFFALSE 12091
// case Rand ( 1 , 4 ) of 1 .. 3 :
12019: LD_INT 1
12021: PPUSH
12022: LD_INT 4
12024: PPUSH
12025: CALL_OW 12
12029: PUSH
12030: LD_INT 1
12032: DOUBLE
12033: GREATEREQUAL
12034: IFFALSE 12042
12036: LD_INT 3
12038: DOUBLE
12039: LESSEQUAL
12040: IFTRUE 12044
12042: GO 12062
12044: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 67
12052: PPUSH
12053: LD_INT 37
12055: PPUSH
12056: CALL_OW 114
12060: GO 12089
12062: LD_INT 4
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12088
12070: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_INT 120
12078: PPUSH
12079: LD_INT 131
12081: PPUSH
12082: CALL_OW 111
12086: GO 12089
12088: POP
12089: GO 12106
// ComMoveXY ( driver , 120 , 131 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 120
12098: PPUSH
12099: LD_INT 131
12101: PPUSH
12102: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12106: LD_VAR 0 1
12110: PPUSH
12111: LD_VAR 0 2
12115: PPUSH
12116: LD_VAR 0 3
12120: PPUSH
12121: LD_VAR 0 4
12125: PPUSH
12126: CALL 85455 0 4
// end ;
12130: PPOPN 4
12132: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12133: LD_VAR 0 1
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 80814 0 2
// end ;
12147: PPOPN 2
12149: END
// on Command ( cmd ) do var i ;
12150: LD_INT 0
12152: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12153: LD_VAR 0 1
12157: PUSH
12158: LD_INT 77
12160: EQUAL
12161: PUSH
12162: LD_EXP 2
12166: AND
12167: IFFALSE 12243
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12169: LD_ADDR_VAR 0 2
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_INT 1
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 2
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 21
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PPUSH
12216: CALL_OW 69
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12241
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 20
12231: PPUSH
12232: LD_INT 19
12234: PPUSH
12235: CALL 51659 0 3
12239: GO 12221
12241: POP
12242: POP
// end ; SOS_Command ( cmd ) ;
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL 101353 0 1
// end ;
12252: PPOPN 2
12254: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12255: LD_EXP 2
12259: PUSH
12260: LD_INT 16
12262: PPUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 1
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 1
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 21
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 70
12309: AND
12310: IFFALSE 12396
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin enable ;
12318: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 16
12326: PPUSH
12327: LD_INT 22
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 2
12339: PUSH
12340: LD_INT 21
12342: PUSH
12343: LD_INT 1
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 2
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PPUSH
12369: CALL_OW 70
12373: PUSH
12374: FOR_IN
12375: IFFALSE 12394
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12377: LD_VAR 0 1
12381: PPUSH
12382: LD_INT 18
12384: PPUSH
12385: LD_INT 19
12387: PPUSH
12388: CALL 51659 0 3
12392: GO 12374
12394: POP
12395: POP
// end ; end_of_file
12396: PPOPN 1
12398: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12399: LD_EXP 6
12403: PUSH
12404: LD_EXP 44
12408: AND
12409: IFFALSE 12580
12411: GO 12413
12413: DISABLE
// begin wait ( 0 0$2 ) ;
12414: LD_INT 70
12416: PPUSH
12417: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12421: LD_EXP 9
12425: PPUSH
12426: LD_STRING DBrighton-G1
12428: PPUSH
12429: CALL_OW 88
// if Losses < 1 then
12433: LD_EXP 45
12437: PUSH
12438: LD_INT 1
12440: LESS
12441: IFFALSE 12455
// AddMedal ( Losses , 1 ) else
12443: LD_STRING Losses
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: CALL_OW 101
12453: GO 12488
// if Losses < 5 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 5
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 2 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 2
12470: PPUSH
12471: CALL_OW 101
12475: GO 12488
// AddMedal ( Losses , - 1 ) ;
12477: LD_STRING Losses
12479: PPUSH
12480: LD_INT 1
12482: NEG
12483: PPUSH
12484: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12488: LD_EXP 7
12492: PUSH
12493: LD_INT 10
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 321
12503: PUSH
12504: LD_INT 2
12506: EQUAL
12507: AND
12508: IFFALSE 12522
// AddMedal ( Laser , 1 ) else
12510: LD_STRING Laser
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 101
12520: GO 12569
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12522: LD_EXP 7
12526: NOT
12527: PUSH
12528: LD_INT 10
12530: PPUSH
12531: LD_INT 1
12533: PPUSH
12534: CALL_OW 321
12538: PUSH
12539: LD_INT 2
12541: EQUAL
12542: AND
12543: IFFALSE 12558
// AddMedal ( Laser , - 1 ) else
12545: LD_STRING Laser
12547: PPUSH
12548: LD_INT 1
12550: NEG
12551: PPUSH
12552: CALL_OW 101
12556: GO 12569
// AddMedal ( Laser , - 2 ) ;
12558: LD_STRING Laser
12560: PPUSH
12561: LD_INT 2
12563: NEG
12564: PPUSH
12565: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12569: LD_STRING BaseMain
12571: PPUSH
12572: CALL_OW 102
// YouWin ;
12576: CALL_OW 103
// end ; end_of_file
12580: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12581: LD_INT 0
12583: PPUSH
12584: PPUSH
// area = ListEnvironmentArea ( area ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: CALL_OW 353
12599: ST_TO_ADDR
// if bulldozer > 0 then
12600: LD_VAR 0 1
12604: PUSH
12605: LD_INT 0
12607: GREATER
12608: IFFALSE 12719
// for i = area downto 1 do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: DOUBLE
12616: LD_VAR 0 2
12620: INC
12621: ST_TO_ADDR
12622: LD_INT 1
12624: PUSH
12625: FOR_DOWNTO
12626: IFFALSE 12717
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 351
12662: IFFALSE 12715
// if not HasTask ( bulldozer ) then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 314
12673: NOT
12674: IFFALSE 12715
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PUSH
12692: LD_INT 1
12694: ARRAY
12695: PPUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PUSH
12707: LD_INT 2
12709: ARRAY
12710: PPUSH
12711: CALL_OW 171
12715: GO 12625
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
12732: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12733: LD_ADDR_VAR 0 8
12737: PUSH
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_INT 22
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 21
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: PPUSH
12778: CALL_OW 72
12782: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12783: LD_ADDR_VAR 0 9
12787: PUSH
12788: LD_VAR 0 1
12792: PPUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 21
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 3
12815: PUSH
12816: LD_INT 25
12818: PUSH
12819: LD_INT 1
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 72
12839: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12840: LD_ADDR_EXP 47
12844: PUSH
12845: LD_VAR 0 8
12849: PPUSH
12850: LD_VAR 0 9
12854: PPUSH
12855: CALL 13248 0 2
12859: ST_TO_ADDR
// offset = 0 ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// for i := 1 to sold_team do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 8
12882: PUSH
12883: FOR_TO
12884: IFFALSE 13015
// begin if IsInUnit ( sold_team [ i ] ) then
12886: LD_VAR 0 8
12890: PUSH
12891: LD_VAR 0 4
12895: ARRAY
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12918
// ComExitBuilding ( sold_team [ i ] ) ;
12903: LD_VAR 0 8
12907: PUSH
12908: LD_VAR 0 4
12912: ARRAY
12913: PPUSH
12914: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12918: LD_VAR 0 8
12922: PUSH
12923: LD_VAR 0 4
12927: ARRAY
12928: PPUSH
12929: LD_EXP 47
12933: PUSH
12934: LD_INT 1
12936: ARRAY
12937: PUSH
12938: LD_VAR 0 4
12942: PUSH
12943: LD_VAR 0 7
12947: PLUS
12948: ARRAY
12949: PPUSH
12950: LD_EXP 47
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: PUSH
12959: LD_VAR 0 4
12963: PUSH
12964: LD_INT 1
12966: PLUS
12967: PUSH
12968: LD_VAR 0 7
12972: PLUS
12973: ARRAY
12974: PPUSH
12975: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12979: LD_VAR 0 8
12983: PUSH
12984: LD_VAR 0 4
12988: ARRAY
12989: PPUSH
12990: LD_EXP 9
12994: PPUSH
12995: CALL_OW 179
// offset = offset + 1 ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 7
13008: PUSH
13009: LD_INT 1
13011: PLUS
13012: ST_TO_ADDR
// end ;
13013: GO 12883
13015: POP
13016: POP
// offset = 0 ;
13017: LD_ADDR_VAR 0 7
13021: PUSH
13022: LD_INT 0
13024: ST_TO_ADDR
// tmp = 1 ;
13025: LD_ADDR_VAR 0 6
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// for i := 2 to rows do
13033: LD_ADDR_VAR 0 4
13037: PUSH
13038: DOUBLE
13039: LD_INT 2
13041: DEC
13042: ST_TO_ADDR
13043: LD_EXP 47
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13241
// begin for x := 1 to sold_team do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13229
// begin if IsInUnit ( civil_team [ tmp ] ) then
13069: LD_VAR 0 9
13073: PUSH
13074: LD_VAR 0 6
13078: ARRAY
13079: PPUSH
13080: CALL_OW 310
13084: IFFALSE 13101
// ComExitBuilding ( civil_team [ tmp ] ) ;
13086: LD_VAR 0 9
13090: PUSH
13091: LD_VAR 0 6
13095: ARRAY
13096: PPUSH
13097: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13101: LD_VAR 0 9
13105: PUSH
13106: LD_VAR 0 6
13110: ARRAY
13111: PPUSH
13112: LD_EXP 47
13116: PUSH
13117: LD_VAR 0 4
13121: ARRAY
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: PLUS
13133: ARRAY
13134: PPUSH
13135: LD_EXP 47
13139: PUSH
13140: LD_VAR 0 4
13144: ARRAY
13145: PUSH
13146: LD_VAR 0 5
13150: PUSH
13151: LD_INT 1
13153: PLUS
13154: PUSH
13155: LD_VAR 0 7
13159: PLUS
13160: ARRAY
13161: PPUSH
13162: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13166: LD_VAR 0 9
13170: PUSH
13171: LD_VAR 0 6
13175: ARRAY
13176: PPUSH
13177: LD_EXP 9
13181: PPUSH
13182: CALL_OW 179
// offset = offset + 1 ;
13186: LD_ADDR_VAR 0 7
13190: PUSH
13191: LD_VAR 0 7
13195: PUSH
13196: LD_INT 1
13198: PLUS
13199: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13200: LD_VAR 0 6
13204: PUSH
13205: LD_VAR 0 9
13209: EQUAL
13210: NOT
13211: IFFALSE 13227
// tmp = tmp + 1 ;
13213: LD_ADDR_VAR 0 6
13217: PUSH
13218: LD_VAR 0 6
13222: PUSH
13223: LD_INT 1
13225: PLUS
13226: ST_TO_ADDR
// end ;
13227: GO 13066
13229: POP
13230: POP
// offset = 0 ;
13231: LD_ADDR_VAR 0 7
13235: PUSH
13236: LD_INT 0
13238: ST_TO_ADDR
// end ;
13239: GO 13048
13241: POP
13242: POP
// end ;
13243: LD_VAR 0 3
13247: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
// start_pos = [ 65 , 34 ] ;
13260: LD_ADDR_VAR 0 6
13264: PUSH
13265: LD_INT 65
13267: PUSH
13268: LD_INT 34
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
// row_size = 0 ;
13275: LD_ADDR_VAR 0 7
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// result_rows = [ ] ;
13283: LD_ADDR_VAR 0 9
13287: PUSH
13288: EMPTY
13289: ST_TO_ADDR
// new_row = [ ] ;
13290: LD_ADDR_VAR 0 8
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// for i := 1 to sold_team do
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: DOUBLE
13303: LD_INT 1
13305: DEC
13306: ST_TO_ADDR
13307: LD_VAR 0 1
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13367
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_VAR 0 8
13324: PUSH
13325: LD_VAR 0 6
13329: PUSH
13330: LD_INT 1
13332: ARRAY
13333: ADD
13334: PUSH
13335: LD_VAR 0 6
13339: PUSH
13340: LD_INT 2
13342: ARRAY
13343: PUSH
13344: LD_VAR 0 4
13348: PLUS
13349: ADD
13350: ST_TO_ADDR
// row_size = row_size + 1 ;
13351: LD_ADDR_VAR 0 7
13355: PUSH
13356: LD_VAR 0 7
13360: PUSH
13361: LD_INT 1
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13312
13367: POP
13368: POP
// result_rows = result_rows ^ [ new_row ] ;
13369: LD_ADDR_VAR 0 9
13373: PUSH
13374: LD_VAR 0 9
13378: PUSH
13379: LD_VAR 0 8
13383: PUSH
13384: EMPTY
13385: LIST
13386: ADD
13387: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13388: LD_ADDR_VAR 0 10
13392: PUSH
13393: LD_VAR 0 2
13397: PUSH
13398: LD_VAR 0 1
13402: DIV
13403: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13404: LD_VAR 0 10
13408: PUSH
13409: LD_VAR 0 1
13413: MOD
13414: PUSH
13415: LD_INT 0
13417: GREATER
13418: IFFALSE 13434
// civil_rows = civil_rows + 1 ;
13420: LD_ADDR_VAR 0 10
13424: PUSH
13425: LD_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ST_TO_ADDR
// offsetX = 2 ;
13434: LD_ADDR_VAR 0 11
13438: PUSH
13439: LD_INT 2
13441: ST_TO_ADDR
// offsetY = 1 ;
13442: LD_ADDR_VAR 0 12
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// for i := 1 to civil_rows do
13450: LD_ADDR_VAR 0 4
13454: PUSH
13455: DOUBLE
13456: LD_INT 1
13458: DEC
13459: ST_TO_ADDR
13460: LD_VAR 0 10
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13594
// begin new_row = [ ] ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: EMPTY
13474: ST_TO_ADDR
// for x := 1 to row_size do
13475: LD_ADDR_VAR 0 5
13479: PUSH
13480: DOUBLE
13481: LD_INT 1
13483: DEC
13484: ST_TO_ADDR
13485: LD_VAR 0 7
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13543
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13493: LD_ADDR_VAR 0 8
13497: PUSH
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 6
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_VAR 0 11
13516: PLUS
13517: ADD
13518: PUSH
13519: LD_VAR 0 6
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: PUSH
13528: LD_VAR 0 12
13532: PLUS
13533: PUSH
13534: LD_VAR 0 5
13538: PLUS
13539: ADD
13540: ST_TO_ADDR
// end ;
13541: GO 13490
13543: POP
13544: POP
// result_rows = result_rows ^ [ new_row ] ;
13545: LD_ADDR_VAR 0 9
13549: PUSH
13550: LD_VAR 0 9
13554: PUSH
13555: LD_VAR 0 8
13559: PUSH
13560: EMPTY
13561: LIST
13562: ADD
13563: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13564: LD_ADDR_VAR 0 11
13568: PUSH
13569: LD_VAR 0 11
13573: PUSH
13574: LD_INT 2
13576: PLUS
13577: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13578: LD_ADDR_VAR 0 12
13582: PUSH
13583: LD_VAR 0 12
13587: PUSH
13588: LD_INT 1
13590: PLUS
13591: ST_TO_ADDR
// end ;
13592: GO 13465
13594: POP
13595: POP
// result = result_rows ;
13596: LD_ADDR_VAR 0 3
13600: PUSH
13601: LD_VAR 0 9
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 3
13610: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
// if exist_mode then
13615: LD_VAR 0 2
13619: IFFALSE 13644
// unit := CreateCharacter ( prefix & ident ) else
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_VAR 0 3
13630: PUSH
13631: LD_VAR 0 1
13635: STR
13636: PPUSH
13637: CALL_OW 34
13641: ST_TO_ADDR
13642: GO 13659
// unit := NewCharacter ( ident ) ;
13644: LD_ADDR_VAR 0 5
13648: PUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 25
13658: ST_TO_ADDR
// result := unit ;
13659: LD_ADDR_VAR 0 4
13663: PUSH
13664: LD_VAR 0 5
13668: ST_TO_ADDR
// end ;
13669: LD_VAR 0 4
13673: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13674: LD_INT 0
13676: PPUSH
13677: PPUSH
// if not side or not nation then
13678: LD_VAR 0 1
13682: NOT
13683: PUSH
13684: LD_VAR 0 2
13688: NOT
13689: OR
13690: IFFALSE 13694
// exit ;
13692: GO 14462
// case nation of nation_american :
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 1
13701: DOUBLE
13702: EQUAL
13703: IFTRUE 13707
13705: GO 13921
13707: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13708: LD_ADDR_VAR 0 4
13712: PUSH
13713: LD_INT 35
13715: PUSH
13716: LD_INT 45
13718: PUSH
13719: LD_INT 46
13721: PUSH
13722: LD_INT 47
13724: PUSH
13725: LD_INT 82
13727: PUSH
13728: LD_INT 83
13730: PUSH
13731: LD_INT 84
13733: PUSH
13734: LD_INT 85
13736: PUSH
13737: LD_INT 86
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: LD_INT 2
13745: PUSH
13746: LD_INT 6
13748: PUSH
13749: LD_INT 15
13751: PUSH
13752: LD_INT 16
13754: PUSH
13755: LD_INT 7
13757: PUSH
13758: LD_INT 12
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: LD_INT 20
13772: PUSH
13773: LD_INT 21
13775: PUSH
13776: LD_INT 22
13778: PUSH
13779: LD_INT 25
13781: PUSH
13782: LD_INT 32
13784: PUSH
13785: LD_INT 27
13787: PUSH
13788: LD_INT 36
13790: PUSH
13791: LD_INT 69
13793: PUSH
13794: LD_INT 39
13796: PUSH
13797: LD_INT 34
13799: PUSH
13800: LD_INT 40
13802: PUSH
13803: LD_INT 48
13805: PUSH
13806: LD_INT 49
13808: PUSH
13809: LD_INT 50
13811: PUSH
13812: LD_INT 51
13814: PUSH
13815: LD_INT 52
13817: PUSH
13818: LD_INT 53
13820: PUSH
13821: LD_INT 54
13823: PUSH
13824: LD_INT 55
13826: PUSH
13827: LD_INT 56
13829: PUSH
13830: LD_INT 57
13832: PUSH
13833: LD_INT 58
13835: PUSH
13836: LD_INT 59
13838: PUSH
13839: LD_INT 60
13841: PUSH
13842: LD_INT 61
13844: PUSH
13845: LD_INT 62
13847: PUSH
13848: LD_INT 80
13850: PUSH
13851: LD_INT 82
13853: PUSH
13854: LD_INT 83
13856: PUSH
13857: LD_INT 84
13859: PUSH
13860: LD_INT 85
13862: PUSH
13863: LD_INT 86
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: ST_TO_ADDR
13919: GO 14386
13921: LD_INT 2
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 14155
13929: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_INT 35
13937: PUSH
13938: LD_INT 45
13940: PUSH
13941: LD_INT 46
13943: PUSH
13944: LD_INT 47
13946: PUSH
13947: LD_INT 82
13949: PUSH
13950: LD_INT 83
13952: PUSH
13953: LD_INT 84
13955: PUSH
13956: LD_INT 85
13958: PUSH
13959: LD_INT 87
13961: PUSH
13962: LD_INT 70
13964: PUSH
13965: LD_INT 1
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: LD_INT 5
13979: PUSH
13980: LD_INT 6
13982: PUSH
13983: LD_INT 15
13985: PUSH
13986: LD_INT 18
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: LD_INT 17
13994: PUSH
13995: LD_INT 8
13997: PUSH
13998: LD_INT 20
14000: PUSH
14001: LD_INT 21
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 72
14009: PUSH
14010: LD_INT 26
14012: PUSH
14013: LD_INT 69
14015: PUSH
14016: LD_INT 39
14018: PUSH
14019: LD_INT 40
14021: PUSH
14022: LD_INT 41
14024: PUSH
14025: LD_INT 42
14027: PUSH
14028: LD_INT 43
14030: PUSH
14031: LD_INT 48
14033: PUSH
14034: LD_INT 49
14036: PUSH
14037: LD_INT 50
14039: PUSH
14040: LD_INT 51
14042: PUSH
14043: LD_INT 52
14045: PUSH
14046: LD_INT 53
14048: PUSH
14049: LD_INT 54
14051: PUSH
14052: LD_INT 55
14054: PUSH
14055: LD_INT 56
14057: PUSH
14058: LD_INT 60
14060: PUSH
14061: LD_INT 61
14063: PUSH
14064: LD_INT 62
14066: PUSH
14067: LD_INT 66
14069: PUSH
14070: LD_INT 67
14072: PUSH
14073: LD_INT 68
14075: PUSH
14076: LD_INT 81
14078: PUSH
14079: LD_INT 82
14081: PUSH
14082: LD_INT 83
14084: PUSH
14085: LD_INT 84
14087: PUSH
14088: LD_INT 85
14090: PUSH
14091: LD_INT 87
14093: PUSH
14094: LD_INT 88
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14386
14155: LD_INT 3
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14385
14163: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14164: LD_ADDR_VAR 0 4
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: LD_INT 47
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 82
14183: PUSH
14184: LD_INT 83
14186: PUSH
14187: LD_INT 84
14189: PUSH
14190: LD_INT 85
14192: PUSH
14193: LD_INT 86
14195: PUSH
14196: LD_INT 11
14198: PUSH
14199: LD_INT 9
14201: PUSH
14202: LD_INT 20
14204: PUSH
14205: LD_INT 19
14207: PUSH
14208: LD_INT 21
14210: PUSH
14211: LD_INT 24
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 25
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: LD_INT 37
14234: PUSH
14235: LD_INT 38
14237: PUSH
14238: LD_INT 32
14240: PUSH
14241: LD_INT 27
14243: PUSH
14244: LD_INT 33
14246: PUSH
14247: LD_INT 69
14249: PUSH
14250: LD_INT 39
14252: PUSH
14253: LD_INT 34
14255: PUSH
14256: LD_INT 40
14258: PUSH
14259: LD_INT 71
14261: PUSH
14262: LD_INT 23
14264: PUSH
14265: LD_INT 44
14267: PUSH
14268: LD_INT 48
14270: PUSH
14271: LD_INT 49
14273: PUSH
14274: LD_INT 50
14276: PUSH
14277: LD_INT 51
14279: PUSH
14280: LD_INT 52
14282: PUSH
14283: LD_INT 53
14285: PUSH
14286: LD_INT 54
14288: PUSH
14289: LD_INT 55
14291: PUSH
14292: LD_INT 56
14294: PUSH
14295: LD_INT 57
14297: PUSH
14298: LD_INT 58
14300: PUSH
14301: LD_INT 59
14303: PUSH
14304: LD_INT 63
14306: PUSH
14307: LD_INT 64
14309: PUSH
14310: LD_INT 65
14312: PUSH
14313: LD_INT 82
14315: PUSH
14316: LD_INT 83
14318: PUSH
14319: LD_INT 84
14321: PUSH
14322: LD_INT 85
14324: PUSH
14325: LD_INT 86
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: ST_TO_ADDR
14383: GO 14386
14385: POP
// if state > - 1 and state < 3 then
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: NEG
14394: GREATER
14395: PUSH
14396: LD_VAR 0 3
14400: PUSH
14401: LD_INT 3
14403: LESS
14404: AND
14405: IFFALSE 14462
// for i in result do
14407: LD_ADDR_VAR 0 5
14411: PUSH
14412: LD_VAR 0 4
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14460
// if GetTech ( i , side ) <> state then
14420: LD_VAR 0 5
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 321
14434: PUSH
14435: LD_VAR 0 3
14439: NONEQUAL
14440: IFFALSE 14458
// result := result diff i ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: DIFF
14457: ST_TO_ADDR
14458: GO 14417
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// result := true ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: LD_INT 1
14479: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: LD_VAR 0 2
14489: PPUSH
14490: CALL_OW 480
14494: ST_TO_ADDR
// if not tmp then
14495: LD_VAR 0 5
14499: NOT
14500: IFFALSE 14504
// exit ;
14502: GO 14553
// for i in tmp do
14504: LD_ADDR_VAR 0 4
14508: PUSH
14509: LD_VAR 0 5
14513: PUSH
14514: FOR_IN
14515: IFFALSE 14551
// if GetTech ( i , side ) <> state_researched then
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 321
14531: PUSH
14532: LD_INT 2
14534: NONEQUAL
14535: IFFALSE 14549
// begin result := false ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 0
14544: ST_TO_ADDR
// exit ;
14545: POP
14546: POP
14547: GO 14553
// end ;
14549: GO 14514
14551: POP
14552: POP
// end ;
14553: LD_VAR 0 3
14557: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
14572: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14573: LD_VAR 0 1
14577: NOT
14578: PUSH
14579: LD_VAR 0 1
14583: PPUSH
14584: CALL_OW 257
14588: PUSH
14589: LD_INT 9
14591: NONEQUAL
14592: OR
14593: IFFALSE 14597
// exit ;
14595: GO 15170
// side := GetSide ( unit ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 255
14611: ST_TO_ADDR
// tech_space := tech_spacanom ;
14612: LD_ADDR_VAR 0 12
14616: PUSH
14617: LD_INT 29
14619: ST_TO_ADDR
// tech_time := tech_taurad ;
14620: LD_ADDR_VAR 0 13
14624: PUSH
14625: LD_INT 28
14627: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14628: LD_ADDR_VAR 0 11
14632: PUSH
14633: LD_VAR 0 1
14637: PPUSH
14638: CALL_OW 310
14642: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14643: LD_VAR 0 11
14647: PPUSH
14648: CALL_OW 247
14652: PUSH
14653: LD_INT 2
14655: EQUAL
14656: IFFALSE 14660
// exit ;
14658: GO 15170
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_INT 81
14667: PUSH
14668: LD_VAR 0 9
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: ST_TO_ADDR
// if not tmp then
14703: LD_VAR 0 8
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15170
// if in_unit then
14712: LD_VAR 0 11
14716: IFFALSE 14740
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14718: LD_ADDR_VAR 0 10
14722: PUSH
14723: LD_VAR 0 8
14727: PPUSH
14728: LD_VAR 0 11
14732: PPUSH
14733: CALL_OW 74
14737: ST_TO_ADDR
14738: GO 14760
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14740: LD_ADDR_VAR 0 10
14744: PUSH
14745: LD_VAR 0 8
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: ST_TO_ADDR
// if not enemy then
14760: LD_VAR 0 10
14764: NOT
14765: IFFALSE 14769
// exit ;
14767: GO 15170
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14769: LD_VAR 0 11
14773: PUSH
14774: LD_VAR 0 11
14778: PPUSH
14779: LD_VAR 0 10
14783: PPUSH
14784: CALL_OW 296
14788: PUSH
14789: LD_INT 13
14791: GREATER
14792: AND
14793: PUSH
14794: LD_VAR 0 1
14798: PPUSH
14799: LD_VAR 0 10
14803: PPUSH
14804: CALL_OW 296
14808: PUSH
14809: LD_INT 12
14811: GREATER
14812: OR
14813: IFFALSE 14817
// exit ;
14815: GO 15170
// missile := [ 1 ] ;
14817: LD_ADDR_VAR 0 14
14821: PUSH
14822: LD_INT 1
14824: PUSH
14825: EMPTY
14826: LIST
14827: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14828: LD_VAR 0 9
14832: PPUSH
14833: LD_VAR 0 12
14837: PPUSH
14838: CALL_OW 325
14842: IFFALSE 14871
// missile := Replace ( missile , missile + 1 , 2 ) ;
14844: LD_ADDR_VAR 0 14
14848: PUSH
14849: LD_VAR 0 14
14853: PPUSH
14854: LD_VAR 0 14
14858: PUSH
14859: LD_INT 1
14861: PLUS
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 1
14870: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 13
14880: PPUSH
14881: CALL_OW 325
14885: PUSH
14886: LD_VAR 0 10
14890: PPUSH
14891: CALL_OW 255
14895: PPUSH
14896: LD_VAR 0 13
14900: PPUSH
14901: CALL_OW 325
14905: NOT
14906: AND
14907: IFFALSE 14936
// missile := Replace ( missile , missile + 1 , 3 ) ;
14909: LD_ADDR_VAR 0 14
14913: PUSH
14914: LD_VAR 0 14
14918: PPUSH
14919: LD_VAR 0 14
14923: PUSH
14924: LD_INT 1
14926: PLUS
14927: PPUSH
14928: LD_INT 3
14930: PPUSH
14931: CALL_OW 1
14935: ST_TO_ADDR
// if missile < 2 then
14936: LD_VAR 0 14
14940: PUSH
14941: LD_INT 2
14943: LESS
14944: IFFALSE 14948
// exit ;
14946: GO 15170
// x := GetX ( enemy ) ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 250
14962: ST_TO_ADDR
// y := GetY ( enemy ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 10
14972: PPUSH
14973: CALL_OW 251
14977: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: NEG
14991: PPUSH
14992: LD_INT 1
14994: PPUSH
14995: CALL_OW 12
14999: PLUS
15000: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15001: LD_ADDR_VAR 0 7
15005: PUSH
15006: LD_VAR 0 5
15010: PUSH
15011: LD_INT 1
15013: NEG
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 12
15022: PLUS
15023: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15024: LD_VAR 0 6
15028: PPUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: CALL_OW 488
15038: NOT
15039: IFFALSE 15061
// begin _x := x ;
15041: LD_ADDR_VAR 0 6
15045: PUSH
15046: LD_VAR 0 4
15050: ST_TO_ADDR
// _y := y ;
15051: LD_ADDR_VAR 0 7
15055: PUSH
15056: LD_VAR 0 5
15060: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 1
15068: PPUSH
15069: LD_VAR 0 14
15073: PPUSH
15074: CALL_OW 12
15078: ST_TO_ADDR
// case i of 1 :
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: DOUBLE
15087: EQUAL
15088: IFTRUE 15092
15090: GO 15109
15092: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15093: LD_VAR 0 1
15097: PPUSH
15098: LD_VAR 0 10
15102: PPUSH
15103: CALL_OW 115
15107: GO 15170
15109: LD_INT 2
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15139
15117: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15118: LD_VAR 0 1
15122: PPUSH
15123: LD_VAR 0 6
15127: PPUSH
15128: LD_VAR 0 7
15132: PPUSH
15133: CALL_OW 153
15137: GO 15170
15139: LD_INT 3
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15169
15147: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 6
15157: PPUSH
15158: LD_VAR 0 7
15162: PPUSH
15163: CALL_OW 154
15167: GO 15170
15169: POP
// end ;
15170: LD_VAR 0 2
15174: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
// if not unit or not building then
15183: LD_VAR 0 1
15187: NOT
15188: PUSH
15189: LD_VAR 0 2
15193: NOT
15194: OR
15195: IFFALSE 15199
// exit ;
15197: GO 15357
// x := GetX ( building ) ;
15199: LD_ADDR_VAR 0 5
15203: PUSH
15204: LD_VAR 0 2
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// y := GetY ( building ) ;
15214: LD_ADDR_VAR 0 6
15218: PUSH
15219: LD_VAR 0 2
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// for i = 0 to 5 do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 0
15237: DEC
15238: ST_TO_ADDR
15239: LD_INT 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15355
// begin _x := ShiftX ( x , i , 3 ) ;
15245: LD_ADDR_VAR 0 7
15249: PUSH
15250: LD_VAR 0 5
15254: PPUSH
15255: LD_VAR 0 4
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 272
15267: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15268: LD_ADDR_VAR 0 8
15272: PUSH
15273: LD_VAR 0 6
15277: PPUSH
15278: LD_VAR 0 4
15282: PPUSH
15283: LD_INT 3
15285: PPUSH
15286: CALL_OW 273
15290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15291: LD_VAR 0 7
15295: PPUSH
15296: LD_VAR 0 8
15300: PPUSH
15301: CALL_OW 488
15305: NOT
15306: IFFALSE 15310
// continue ;
15308: GO 15242
// if HexInfo ( _x , _y ) = 0 then
15310: LD_VAR 0 7
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 428
15324: PUSH
15325: LD_INT 0
15327: EQUAL
15328: IFFALSE 15353
// begin ComMoveXY ( unit , _x , _y ) ;
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 7
15339: PPUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: CALL_OW 111
// exit ;
15349: POP
15350: POP
15351: GO 15357
// end ; end ;
15353: GO 15242
15355: POP
15356: POP
// end ;
15357: LD_VAR 0 3
15361: RET
// export function ScanBase ( side , base_area ) ; begin
15362: LD_INT 0
15364: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15365: LD_ADDR_VAR 0 3
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_INT 81
15377: PUSH
15378: LD_VAR 0 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 70
15391: ST_TO_ADDR
// end ;
15392: LD_VAR 0 3
15396: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15397: LD_INT 0
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// result := false ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// side := GetSide ( unit ) ;
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 255
15425: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15426: LD_ADDR_VAR 0 4
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 248
15440: ST_TO_ADDR
// case nat of 1 :
15441: LD_VAR 0 4
15445: PUSH
15446: LD_INT 1
15448: DOUBLE
15449: EQUAL
15450: IFTRUE 15454
15452: GO 15465
15454: POP
// tech := tech_lassight ; 2 :
15455: LD_ADDR_VAR 0 5
15459: PUSH
15460: LD_INT 12
15462: ST_TO_ADDR
15463: GO 15504
15465: LD_INT 2
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15484
15473: POP
// tech := tech_mortar ; 3 :
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_INT 41
15481: ST_TO_ADDR
15482: GO 15504
15484: LD_INT 3
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15503
15492: POP
// tech := tech_bazooka ; end ;
15493: LD_ADDR_VAR 0 5
15497: PUSH
15498: LD_INT 44
15500: ST_TO_ADDR
15501: GO 15504
15503: POP
// if Researched ( side , tech ) then
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_VAR 0 5
15513: PPUSH
15514: CALL_OW 325
15518: IFFALSE 15545
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15520: LD_ADDR_VAR 0 2
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 8
15530: PUSH
15531: LD_INT 9
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: PUSH
15539: LD_VAR 0 4
15543: ARRAY
15544: ST_TO_ADDR
// end ;
15545: LD_VAR 0 2
15549: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15550: LD_INT 0
15552: PPUSH
15553: PPUSH
15554: PPUSH
// if not mines then
15555: LD_VAR 0 2
15559: NOT
15560: IFFALSE 15564
// exit ;
15562: GO 15708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_INT 81
15571: PUSH
15572: LD_VAR 0 1
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 3
15583: PUSH
15584: LD_INT 21
15586: PUSH
15587: LD_INT 3
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: ST_TO_ADDR
// for i in mines do
15607: LD_ADDR_VAR 0 4
15611: PUSH
15612: LD_VAR 0 2
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15706
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: CALL_OW 458
15642: NOT
15643: IFFALSE 15647
// continue ;
15645: GO 15617
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: PPUSH
15656: LD_VAR 0 4
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: CALL_OW 428
15669: PUSH
15670: LD_VAR 0 5
15674: IN
15675: IFFALSE 15704
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 4
15690: PUSH
15691: LD_INT 2
15693: ARRAY
15694: PPUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 456
// end ;
15704: GO 15617
15706: POP
15707: POP
// end ;
15708: LD_VAR 0 3
15712: RET
// export function Count ( array ) ; var i ; begin
15713: LD_INT 0
15715: PPUSH
15716: PPUSH
// result := 0 ;
15717: LD_ADDR_VAR 0 2
15721: PUSH
15722: LD_INT 0
15724: ST_TO_ADDR
// for i in array do
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_VAR 0 1
15734: PUSH
15735: FOR_IN
15736: IFFALSE 15760
// if i then
15738: LD_VAR 0 3
15742: IFFALSE 15758
// result := result + 1 ;
15744: LD_ADDR_VAR 0 2
15748: PUSH
15749: LD_VAR 0 2
15753: PUSH
15754: LD_INT 1
15756: PLUS
15757: ST_TO_ADDR
15758: GO 15735
15760: POP
15761: POP
// end ;
15762: LD_VAR 0 2
15766: RET
// export function IsEmpty ( building ) ; begin
15767: LD_INT 0
15769: PPUSH
// if not building then
15770: LD_VAR 0 1
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 15822
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15779: LD_ADDR_VAR 0 2
15783: PUSH
15784: LD_VAR 0 1
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_VAR 0 1
15796: PPUSH
15797: CALL_OW 255
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 58
15808: PUSH
15809: EMPTY
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: IN
15821: ST_TO_ADDR
// end ;
15822: LD_VAR 0 2
15826: RET
// export function IsNotFull ( building ) ; var places ; begin
15827: LD_INT 0
15829: PPUSH
15830: PPUSH
// if not building then
15831: LD_VAR 0 1
15835: NOT
15836: IFFALSE 15840
// exit ;
15838: GO 16011
// result := false ;
15840: LD_ADDR_VAR 0 2
15844: PUSH
15845: LD_INT 0
15847: ST_TO_ADDR
// places := 0 ;
15848: LD_ADDR_VAR 0 3
15852: PUSH
15853: LD_INT 0
15855: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
15856: LD_VAR 0 1
15860: PPUSH
15861: CALL_OW 266
15865: PUSH
15866: LD_INT 0
15868: DOUBLE
15869: EQUAL
15870: IFTRUE 15928
15872: LD_INT 1
15874: DOUBLE
15875: EQUAL
15876: IFTRUE 15928
15878: LD_INT 6
15880: DOUBLE
15881: EQUAL
15882: IFTRUE 15928
15884: LD_INT 7
15886: DOUBLE
15887: EQUAL
15888: IFTRUE 15928
15890: LD_INT 8
15892: DOUBLE
15893: EQUAL
15894: IFTRUE 15928
15896: LD_INT 4
15898: DOUBLE
15899: EQUAL
15900: IFTRUE 15928
15902: LD_INT 5
15904: DOUBLE
15905: EQUAL
15906: IFTRUE 15928
15908: LD_INT 2
15910: DOUBLE
15911: EQUAL
15912: IFTRUE 15928
15914: LD_INT 3
15916: DOUBLE
15917: EQUAL
15918: IFTRUE 15928
15920: LD_INT 35
15922: DOUBLE
15923: EQUAL
15924: IFTRUE 15928
15926: GO 15939
15928: POP
// places := 6 ; b_bunker , b_breastwork :
15929: LD_ADDR_VAR 0 3
15933: PUSH
15934: LD_INT 6
15936: ST_TO_ADDR
15937: GO 15984
15939: LD_INT 32
15941: DOUBLE
15942: EQUAL
15943: IFTRUE 15953
15945: LD_INT 31
15947: DOUBLE
15948: EQUAL
15949: IFTRUE 15953
15951: GO 15964
15953: POP
// places := 1 ; b_control_tower :
15954: LD_ADDR_VAR 0 3
15958: PUSH
15959: LD_INT 1
15961: ST_TO_ADDR
15962: GO 15984
15964: LD_INT 36
15966: DOUBLE
15967: EQUAL
15968: IFTRUE 15972
15970: GO 15983
15972: POP
// places := 3 ; end ;
15973: LD_ADDR_VAR 0 3
15977: PUSH
15978: LD_INT 3
15980: ST_TO_ADDR
15981: GO 15984
15983: POP
// if places then
15984: LD_VAR 0 3
15988: IFFALSE 16011
// result := UnitsInside ( building ) < places ;
15990: LD_ADDR_VAR 0 2
15994: PUSH
15995: LD_VAR 0 1
15999: PPUSH
16000: CALL_OW 313
16004: PUSH
16005: LD_VAR 0 3
16009: LESS
16010: ST_TO_ADDR
// end ;
16011: LD_VAR 0 2
16015: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
16020: PPUSH
16021: PPUSH
// tmp := [ ] ;
16022: LD_ADDR_VAR 0 3
16026: PUSH
16027: EMPTY
16028: ST_TO_ADDR
// list := [ ] ;
16029: LD_ADDR_VAR 0 5
16033: PUSH
16034: EMPTY
16035: ST_TO_ADDR
// for i = 16 to 25 do
16036: LD_ADDR_VAR 0 4
16040: PUSH
16041: DOUBLE
16042: LD_INT 16
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 25
16048: PUSH
16049: FOR_TO
16050: IFFALSE 16123
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16052: LD_ADDR_VAR 0 3
16056: PUSH
16057: LD_VAR 0 3
16061: PUSH
16062: LD_INT 22
16064: PUSH
16065: LD_VAR 0 1
16069: PPUSH
16070: CALL_OW 255
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 91
16081: PUSH
16082: LD_VAR 0 1
16086: PUSH
16087: LD_INT 6
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: LIST
16094: PUSH
16095: LD_INT 30
16097: PUSH
16098: LD_VAR 0 4
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: EMPTY
16113: LIST
16114: PPUSH
16115: CALL_OW 69
16119: ADD
16120: ST_TO_ADDR
16121: GO 16049
16123: POP
16124: POP
// for i = 1 to tmp do
16125: LD_ADDR_VAR 0 4
16129: PUSH
16130: DOUBLE
16131: LD_INT 1
16133: DEC
16134: ST_TO_ADDR
16135: LD_VAR 0 3
16139: PUSH
16140: FOR_TO
16141: IFFALSE 16229
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16143: LD_ADDR_VAR 0 5
16147: PUSH
16148: LD_VAR 0 5
16152: PUSH
16153: LD_VAR 0 3
16157: PUSH
16158: LD_VAR 0 4
16162: ARRAY
16163: PPUSH
16164: CALL_OW 266
16168: PUSH
16169: LD_VAR 0 3
16173: PUSH
16174: LD_VAR 0 4
16178: ARRAY
16179: PPUSH
16180: CALL_OW 250
16184: PUSH
16185: LD_VAR 0 3
16189: PUSH
16190: LD_VAR 0 4
16194: ARRAY
16195: PPUSH
16196: CALL_OW 251
16200: PUSH
16201: LD_VAR 0 3
16205: PUSH
16206: LD_VAR 0 4
16210: ARRAY
16211: PPUSH
16212: CALL_OW 254
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: ADD
16226: ST_TO_ADDR
16227: GO 16140
16229: POP
16230: POP
// result := list ;
16231: LD_ADDR_VAR 0 2
16235: PUSH
16236: LD_VAR 0 5
16240: ST_TO_ADDR
// end ;
16241: LD_VAR 0 2
16245: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16246: LD_INT 0
16248: PPUSH
16249: PPUSH
16250: PPUSH
16251: PPUSH
16252: PPUSH
16253: PPUSH
16254: PPUSH
// if not factory then
16255: LD_VAR 0 1
16259: NOT
16260: IFFALSE 16264
// exit ;
16262: GO 16857
// if control = control_apeman then
16264: LD_VAR 0 4
16268: PUSH
16269: LD_INT 5
16271: EQUAL
16272: IFFALSE 16381
// begin tmp := UnitsInside ( factory ) ;
16274: LD_ADDR_VAR 0 8
16278: PUSH
16279: LD_VAR 0 1
16283: PPUSH
16284: CALL_OW 313
16288: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16289: LD_VAR 0 8
16293: PPUSH
16294: LD_INT 25
16296: PUSH
16297: LD_INT 12
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 72
16308: NOT
16309: IFFALSE 16319
// control := control_manual ;
16311: LD_ADDR_VAR 0 4
16315: PUSH
16316: LD_INT 1
16318: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16319: LD_ADDR_VAR 0 8
16323: PUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: CALL 16016 0 1
16333: ST_TO_ADDR
// if tmp then
16334: LD_VAR 0 8
16338: IFFALSE 16381
// begin for i in tmp do
16340: LD_ADDR_VAR 0 7
16344: PUSH
16345: LD_VAR 0 8
16349: PUSH
16350: FOR_IN
16351: IFFALSE 16379
// if i [ 1 ] = b_ext_radio then
16353: LD_VAR 0 7
16357: PUSH
16358: LD_INT 1
16360: ARRAY
16361: PUSH
16362: LD_INT 22
16364: EQUAL
16365: IFFALSE 16377
// begin control := control_remote ;
16367: LD_ADDR_VAR 0 4
16371: PUSH
16372: LD_INT 2
16374: ST_TO_ADDR
// break ;
16375: GO 16379
// end ;
16377: GO 16350
16379: POP
16380: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16381: LD_VAR 0 1
16385: PPUSH
16386: LD_VAR 0 2
16390: PPUSH
16391: LD_VAR 0 3
16395: PPUSH
16396: LD_VAR 0 4
16400: PPUSH
16401: LD_VAR 0 5
16405: PPUSH
16406: CALL_OW 448
16410: IFFALSE 16445
// begin result := [ chassis , engine , control , weapon ] ;
16412: LD_ADDR_VAR 0 6
16416: PUSH
16417: LD_VAR 0 2
16421: PUSH
16422: LD_VAR 0 3
16426: PUSH
16427: LD_VAR 0 4
16431: PUSH
16432: LD_VAR 0 5
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: ST_TO_ADDR
// exit ;
16443: GO 16857
// end ; _chassis := AvailableChassisList ( factory ) ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 1
16454: PPUSH
16455: CALL_OW 475
16459: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16460: LD_ADDR_VAR 0 11
16464: PUSH
16465: LD_VAR 0 1
16469: PPUSH
16470: CALL_OW 476
16474: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16475: LD_ADDR_VAR 0 12
16479: PUSH
16480: LD_VAR 0 1
16484: PPUSH
16485: CALL_OW 477
16489: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16490: LD_ADDR_VAR 0 10
16494: PUSH
16495: LD_VAR 0 1
16499: PPUSH
16500: CALL_OW 478
16504: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16505: LD_VAR 0 9
16509: NOT
16510: PUSH
16511: LD_VAR 0 11
16515: NOT
16516: OR
16517: PUSH
16518: LD_VAR 0 12
16522: NOT
16523: OR
16524: PUSH
16525: LD_VAR 0 10
16529: NOT
16530: OR
16531: IFFALSE 16566
// begin result := [ chassis , engine , control , weapon ] ;
16533: LD_ADDR_VAR 0 6
16537: PUSH
16538: LD_VAR 0 2
16542: PUSH
16543: LD_VAR 0 3
16547: PUSH
16548: LD_VAR 0 4
16552: PUSH
16553: LD_VAR 0 5
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: ST_TO_ADDR
// exit ;
16564: GO 16857
// end ; if not chassis in _chassis then
16566: LD_VAR 0 2
16570: PUSH
16571: LD_VAR 0 9
16575: IN
16576: NOT
16577: IFFALSE 16603
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16579: LD_ADDR_VAR 0 2
16583: PUSH
16584: LD_VAR 0 9
16588: PUSH
16589: LD_INT 1
16591: PPUSH
16592: LD_VAR 0 9
16596: PPUSH
16597: CALL_OW 12
16601: ARRAY
16602: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16603: LD_VAR 0 2
16607: PPUSH
16608: LD_VAR 0 3
16612: PPUSH
16613: CALL 16862 0 2
16617: NOT
16618: IFFALSE 16677
// repeat engine := _engine [ 1 ] ;
16620: LD_ADDR_VAR 0 3
16624: PUSH
16625: LD_VAR 0 11
16629: PUSH
16630: LD_INT 1
16632: ARRAY
16633: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16634: LD_ADDR_VAR 0 11
16638: PUSH
16639: LD_VAR 0 11
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: CALL_OW 3
16651: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16652: LD_VAR 0 2
16656: PPUSH
16657: LD_VAR 0 3
16661: PPUSH
16662: CALL 16862 0 2
16666: PUSH
16667: LD_VAR 0 11
16671: PUSH
16672: EMPTY
16673: EQUAL
16674: OR
16675: IFFALSE 16620
// if not control in _control then
16677: LD_VAR 0 4
16681: PUSH
16682: LD_VAR 0 12
16686: IN
16687: NOT
16688: IFFALSE 16714
// control := _control [ rand ( 1 , _control ) ] ;
16690: LD_ADDR_VAR 0 4
16694: PUSH
16695: LD_VAR 0 12
16699: PUSH
16700: LD_INT 1
16702: PPUSH
16703: LD_VAR 0 12
16707: PPUSH
16708: CALL_OW 12
16712: ARRAY
16713: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16714: LD_VAR 0 2
16718: PPUSH
16719: LD_VAR 0 5
16723: PPUSH
16724: CALL 17082 0 2
16728: NOT
16729: IFFALSE 16788
// repeat weapon := _weapon [ 1 ] ;
16731: LD_ADDR_VAR 0 5
16735: PUSH
16736: LD_VAR 0 10
16740: PUSH
16741: LD_INT 1
16743: ARRAY
16744: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16745: LD_ADDR_VAR 0 10
16749: PUSH
16750: LD_VAR 0 10
16754: PPUSH
16755: LD_INT 1
16757: PPUSH
16758: CALL_OW 3
16762: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16763: LD_VAR 0 2
16767: PPUSH
16768: LD_VAR 0 5
16772: PPUSH
16773: CALL 17082 0 2
16777: PUSH
16778: LD_VAR 0 10
16782: PUSH
16783: EMPTY
16784: EQUAL
16785: OR
16786: IFFALSE 16731
// result := [ ] ;
16788: LD_ADDR_VAR 0 6
16792: PUSH
16793: EMPTY
16794: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16795: LD_VAR 0 1
16799: PPUSH
16800: LD_VAR 0 2
16804: PPUSH
16805: LD_VAR 0 3
16809: PPUSH
16810: LD_VAR 0 4
16814: PPUSH
16815: LD_VAR 0 5
16819: PPUSH
16820: CALL_OW 448
16824: IFFALSE 16857
// result := [ chassis , engine , control , weapon ] ;
16826: LD_ADDR_VAR 0 6
16830: PUSH
16831: LD_VAR 0 2
16835: PUSH
16836: LD_VAR 0 3
16840: PUSH
16841: LD_VAR 0 4
16845: PUSH
16846: LD_VAR 0 5
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: ST_TO_ADDR
// end ;
16857: LD_VAR 0 6
16861: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16862: LD_INT 0
16864: PPUSH
// if not chassis or not engine then
16865: LD_VAR 0 1
16869: NOT
16870: PUSH
16871: LD_VAR 0 2
16875: NOT
16876: OR
16877: IFFALSE 16881
// exit ;
16879: GO 17077
// case engine of engine_solar :
16881: LD_VAR 0 2
16885: PUSH
16886: LD_INT 2
16888: DOUBLE
16889: EQUAL
16890: IFTRUE 16894
16892: GO 16932
16894: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_INT 11
16902: PUSH
16903: LD_INT 12
16905: PUSH
16906: LD_INT 13
16908: PUSH
16909: LD_INT 14
16911: PUSH
16912: LD_INT 1
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: ST_TO_ADDR
16930: GO 17061
16932: LD_INT 1
16934: DOUBLE
16935: EQUAL
16936: IFTRUE 16940
16938: GO 17002
16940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16941: LD_ADDR_VAR 0 3
16945: PUSH
16946: LD_INT 11
16948: PUSH
16949: LD_INT 12
16951: PUSH
16952: LD_INT 13
16954: PUSH
16955: LD_INT 14
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: LD_INT 21
16975: PUSH
16976: LD_INT 23
16978: PUSH
16979: LD_INT 22
16981: PUSH
16982: LD_INT 24
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: ST_TO_ADDR
17000: GO 17061
17002: LD_INT 3
17004: DOUBLE
17005: EQUAL
17006: IFTRUE 17010
17008: GO 17060
17010: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17011: LD_ADDR_VAR 0 3
17015: PUSH
17016: LD_INT 13
17018: PUSH
17019: LD_INT 14
17021: PUSH
17022: LD_INT 2
17024: PUSH
17025: LD_INT 3
17027: PUSH
17028: LD_INT 4
17030: PUSH
17031: LD_INT 5
17033: PUSH
17034: LD_INT 21
17036: PUSH
17037: LD_INT 22
17039: PUSH
17040: LD_INT 23
17042: PUSH
17043: LD_INT 24
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: ST_TO_ADDR
17058: GO 17061
17060: POP
// result := ( chassis in result ) ;
17061: LD_ADDR_VAR 0 3
17065: PUSH
17066: LD_VAR 0 1
17070: PUSH
17071: LD_VAR 0 3
17075: IN
17076: ST_TO_ADDR
// end ;
17077: LD_VAR 0 3
17081: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17082: LD_INT 0
17084: PPUSH
// if not chassis or not weapon then
17085: LD_VAR 0 1
17089: NOT
17090: PUSH
17091: LD_VAR 0 2
17095: NOT
17096: OR
17097: IFFALSE 17101
// exit ;
17099: GO 18163
// case weapon of us_machine_gun :
17101: LD_VAR 0 2
17105: PUSH
17106: LD_INT 2
17108: DOUBLE
17109: EQUAL
17110: IFTRUE 17114
17112: GO 17144
17114: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17115: LD_ADDR_VAR 0 3
17119: PUSH
17120: LD_INT 1
17122: PUSH
17123: LD_INT 2
17125: PUSH
17126: LD_INT 3
17128: PUSH
17129: LD_INT 4
17131: PUSH
17132: LD_INT 5
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: ST_TO_ADDR
17142: GO 18147
17144: LD_INT 3
17146: DOUBLE
17147: EQUAL
17148: IFTRUE 17152
17150: GO 17182
17152: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17153: LD_ADDR_VAR 0 3
17157: PUSH
17158: LD_INT 1
17160: PUSH
17161: LD_INT 2
17163: PUSH
17164: LD_INT 3
17166: PUSH
17167: LD_INT 4
17169: PUSH
17170: LD_INT 5
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: ST_TO_ADDR
17180: GO 18147
17182: LD_INT 11
17184: DOUBLE
17185: EQUAL
17186: IFTRUE 17190
17188: GO 17220
17190: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17191: LD_ADDR_VAR 0 3
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: LD_INT 2
17201: PUSH
17202: LD_INT 3
17204: PUSH
17205: LD_INT 4
17207: PUSH
17208: LD_INT 5
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: ST_TO_ADDR
17218: GO 18147
17220: LD_INT 4
17222: DOUBLE
17223: EQUAL
17224: IFTRUE 17228
17226: GO 17254
17228: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17229: LD_ADDR_VAR 0 3
17233: PUSH
17234: LD_INT 2
17236: PUSH
17237: LD_INT 3
17239: PUSH
17240: LD_INT 4
17242: PUSH
17243: LD_INT 5
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: ST_TO_ADDR
17252: GO 18147
17254: LD_INT 5
17256: DOUBLE
17257: EQUAL
17258: IFTRUE 17262
17260: GO 17288
17262: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17263: LD_ADDR_VAR 0 3
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 3
17273: PUSH
17274: LD_INT 4
17276: PUSH
17277: LD_INT 5
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 18147
17288: LD_INT 9
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17322
17296: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 2
17304: PUSH
17305: LD_INT 3
17307: PUSH
17308: LD_INT 4
17310: PUSH
17311: LD_INT 5
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: ST_TO_ADDR
17320: GO 18147
17322: LD_INT 7
17324: DOUBLE
17325: EQUAL
17326: IFTRUE 17330
17328: GO 17356
17330: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17331: LD_ADDR_VAR 0 3
17335: PUSH
17336: LD_INT 2
17338: PUSH
17339: LD_INT 3
17341: PUSH
17342: LD_INT 4
17344: PUSH
17345: LD_INT 5
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: LIST
17352: LIST
17353: ST_TO_ADDR
17354: GO 18147
17356: LD_INT 12
17358: DOUBLE
17359: EQUAL
17360: IFTRUE 17364
17362: GO 17390
17364: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_INT 2
17372: PUSH
17373: LD_INT 3
17375: PUSH
17376: LD_INT 4
17378: PUSH
17379: LD_INT 5
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: ST_TO_ADDR
17388: GO 18147
17390: LD_INT 13
17392: DOUBLE
17393: EQUAL
17394: IFTRUE 17398
17396: GO 17424
17398: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17399: LD_ADDR_VAR 0 3
17403: PUSH
17404: LD_INT 2
17406: PUSH
17407: LD_INT 3
17409: PUSH
17410: LD_INT 4
17412: PUSH
17413: LD_INT 5
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: ST_TO_ADDR
17422: GO 18147
17424: LD_INT 14
17426: DOUBLE
17427: EQUAL
17428: IFTRUE 17432
17430: GO 17450
17432: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17433: LD_ADDR_VAR 0 3
17437: PUSH
17438: LD_INT 4
17440: PUSH
17441: LD_INT 5
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: ST_TO_ADDR
17448: GO 18147
17450: LD_INT 6
17452: DOUBLE
17453: EQUAL
17454: IFTRUE 17458
17456: GO 17476
17458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17459: LD_ADDR_VAR 0 3
17463: PUSH
17464: LD_INT 4
17466: PUSH
17467: LD_INT 5
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 18147
17476: LD_INT 10
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 4
17492: PUSH
17493: LD_INT 5
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 18147
17502: LD_INT 22
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17536
17510: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 11
17518: PUSH
17519: LD_INT 12
17521: PUSH
17522: LD_INT 13
17524: PUSH
17525: LD_INT 14
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: ST_TO_ADDR
17534: GO 18147
17536: LD_INT 23
17538: DOUBLE
17539: EQUAL
17540: IFTRUE 17544
17542: GO 17570
17544: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17545: LD_ADDR_VAR 0 3
17549: PUSH
17550: LD_INT 11
17552: PUSH
17553: LD_INT 12
17555: PUSH
17556: LD_INT 13
17558: PUSH
17559: LD_INT 14
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: ST_TO_ADDR
17568: GO 18147
17570: LD_INT 24
17572: DOUBLE
17573: EQUAL
17574: IFTRUE 17578
17576: GO 17604
17578: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17579: LD_ADDR_VAR 0 3
17583: PUSH
17584: LD_INT 11
17586: PUSH
17587: LD_INT 12
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: ST_TO_ADDR
17602: GO 18147
17604: LD_INT 30
17606: DOUBLE
17607: EQUAL
17608: IFTRUE 17612
17610: GO 17638
17612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17613: LD_ADDR_VAR 0 3
17617: PUSH
17618: LD_INT 11
17620: PUSH
17621: LD_INT 12
17623: PUSH
17624: LD_INT 13
17626: PUSH
17627: LD_INT 14
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: LIST
17634: LIST
17635: ST_TO_ADDR
17636: GO 18147
17638: LD_INT 25
17640: DOUBLE
17641: EQUAL
17642: IFTRUE 17646
17644: GO 17664
17646: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17647: LD_ADDR_VAR 0 3
17651: PUSH
17652: LD_INT 13
17654: PUSH
17655: LD_INT 14
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: ST_TO_ADDR
17662: GO 18147
17664: LD_INT 27
17666: DOUBLE
17667: EQUAL
17668: IFTRUE 17672
17670: GO 17690
17672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17673: LD_ADDR_VAR 0 3
17677: PUSH
17678: LD_INT 13
17680: PUSH
17681: LD_INT 14
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: ST_TO_ADDR
17688: GO 18147
17690: LD_EXP 53
17694: DOUBLE
17695: EQUAL
17696: IFTRUE 17700
17698: GO 17726
17700: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17701: LD_ADDR_VAR 0 3
17705: PUSH
17706: LD_INT 11
17708: PUSH
17709: LD_INT 12
17711: PUSH
17712: LD_INT 13
17714: PUSH
17715: LD_INT 14
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: ST_TO_ADDR
17724: GO 18147
17726: LD_INT 28
17728: DOUBLE
17729: EQUAL
17730: IFTRUE 17734
17732: GO 17752
17734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17735: LD_ADDR_VAR 0 3
17739: PUSH
17740: LD_INT 13
17742: PUSH
17743: LD_INT 14
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: ST_TO_ADDR
17750: GO 18147
17752: LD_INT 29
17754: DOUBLE
17755: EQUAL
17756: IFTRUE 17760
17758: GO 17778
17760: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17761: LD_ADDR_VAR 0 3
17765: PUSH
17766: LD_INT 13
17768: PUSH
17769: LD_INT 14
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18147
17778: LD_INT 31
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17804
17786: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 13
17794: PUSH
17795: LD_INT 14
17797: PUSH
17798: EMPTY
17799: LIST
17800: LIST
17801: ST_TO_ADDR
17802: GO 18147
17804: LD_INT 26
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17830
17812: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17813: LD_ADDR_VAR 0 3
17817: PUSH
17818: LD_INT 13
17820: PUSH
17821: LD_INT 14
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: ST_TO_ADDR
17828: GO 18147
17830: LD_INT 42
17832: DOUBLE
17833: EQUAL
17834: IFTRUE 17838
17836: GO 17864
17838: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17839: LD_ADDR_VAR 0 3
17843: PUSH
17844: LD_INT 21
17846: PUSH
17847: LD_INT 22
17849: PUSH
17850: LD_INT 23
17852: PUSH
17853: LD_INT 24
17855: PUSH
17856: EMPTY
17857: LIST
17858: LIST
17859: LIST
17860: LIST
17861: ST_TO_ADDR
17862: GO 18147
17864: LD_INT 43
17866: DOUBLE
17867: EQUAL
17868: IFTRUE 17872
17870: GO 17898
17872: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_INT 21
17880: PUSH
17881: LD_INT 22
17883: PUSH
17884: LD_INT 23
17886: PUSH
17887: LD_INT 24
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: ST_TO_ADDR
17896: GO 18147
17898: LD_INT 44
17900: DOUBLE
17901: EQUAL
17902: IFTRUE 17906
17904: GO 17932
17906: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17907: LD_ADDR_VAR 0 3
17911: PUSH
17912: LD_INT 21
17914: PUSH
17915: LD_INT 22
17917: PUSH
17918: LD_INT 23
17920: PUSH
17921: LD_INT 24
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: LIST
17928: LIST
17929: ST_TO_ADDR
17930: GO 18147
17932: LD_INT 45
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17966
17940: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17941: LD_ADDR_VAR 0 3
17945: PUSH
17946: LD_INT 21
17948: PUSH
17949: LD_INT 22
17951: PUSH
17952: LD_INT 23
17954: PUSH
17955: LD_INT 24
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: ST_TO_ADDR
17964: GO 18147
17966: LD_INT 49
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 18000
17974: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17975: LD_ADDR_VAR 0 3
17979: PUSH
17980: LD_INT 21
17982: PUSH
17983: LD_INT 22
17985: PUSH
17986: LD_INT 23
17988: PUSH
17989: LD_INT 24
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18147
18000: LD_INT 51
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18034
18008: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 21
18016: PUSH
18017: LD_INT 22
18019: PUSH
18020: LD_INT 23
18022: PUSH
18023: LD_INT 24
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: ST_TO_ADDR
18032: GO 18147
18034: LD_INT 52
18036: DOUBLE
18037: EQUAL
18038: IFTRUE 18042
18040: GO 18068
18042: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18043: LD_ADDR_VAR 0 3
18047: PUSH
18048: LD_INT 21
18050: PUSH
18051: LD_INT 22
18053: PUSH
18054: LD_INT 23
18056: PUSH
18057: LD_INT 24
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: ST_TO_ADDR
18066: GO 18147
18068: LD_INT 53
18070: DOUBLE
18071: EQUAL
18072: IFTRUE 18076
18074: GO 18094
18076: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18077: LD_ADDR_VAR 0 3
18081: PUSH
18082: LD_INT 23
18084: PUSH
18085: LD_INT 24
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18147
18094: LD_INT 46
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18120
18102: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 23
18110: PUSH
18111: LD_INT 24
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: ST_TO_ADDR
18118: GO 18147
18120: LD_INT 47
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18146
18128: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18129: LD_ADDR_VAR 0 3
18133: PUSH
18134: LD_INT 23
18136: PUSH
18137: LD_INT 24
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: ST_TO_ADDR
18144: GO 18147
18146: POP
// result := ( chassis in result ) ;
18147: LD_ADDR_VAR 0 3
18151: PUSH
18152: LD_VAR 0 1
18156: PUSH
18157: LD_VAR 0 3
18161: IN
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
18176: PPUSH
// result := array ;
18177: LD_ADDR_VAR 0 5
18181: PUSH
18182: LD_VAR 0 1
18186: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18187: LD_VAR 0 1
18191: NOT
18192: PUSH
18193: LD_VAR 0 2
18197: NOT
18198: OR
18199: PUSH
18200: LD_VAR 0 3
18204: NOT
18205: OR
18206: PUSH
18207: LD_VAR 0 2
18211: PUSH
18212: LD_VAR 0 1
18216: GREATER
18217: OR
18218: PUSH
18219: LD_VAR 0 3
18223: PUSH
18224: LD_VAR 0 1
18228: GREATER
18229: OR
18230: IFFALSE 18234
// exit ;
18232: GO 18530
// if direction then
18234: LD_VAR 0 4
18238: IFFALSE 18302
// begin d := 1 ;
18240: LD_ADDR_VAR 0 9
18244: PUSH
18245: LD_INT 1
18247: ST_TO_ADDR
// if i_from > i_to then
18248: LD_VAR 0 2
18252: PUSH
18253: LD_VAR 0 3
18257: GREATER
18258: IFFALSE 18284
// length := ( array - i_from ) + i_to else
18260: LD_ADDR_VAR 0 11
18264: PUSH
18265: LD_VAR 0 1
18269: PUSH
18270: LD_VAR 0 2
18274: MINUS
18275: PUSH
18276: LD_VAR 0 3
18280: PLUS
18281: ST_TO_ADDR
18282: GO 18300
// length := i_to - i_from ;
18284: LD_ADDR_VAR 0 11
18288: PUSH
18289: LD_VAR 0 3
18293: PUSH
18294: LD_VAR 0 2
18298: MINUS
18299: ST_TO_ADDR
// end else
18300: GO 18363
// begin d := - 1 ;
18302: LD_ADDR_VAR 0 9
18306: PUSH
18307: LD_INT 1
18309: NEG
18310: ST_TO_ADDR
// if i_from > i_to then
18311: LD_VAR 0 2
18315: PUSH
18316: LD_VAR 0 3
18320: GREATER
18321: IFFALSE 18341
// length := i_from - i_to else
18323: LD_ADDR_VAR 0 11
18327: PUSH
18328: LD_VAR 0 2
18332: PUSH
18333: LD_VAR 0 3
18337: MINUS
18338: ST_TO_ADDR
18339: GO 18363
// length := ( array - i_to ) + i_from ;
18341: LD_ADDR_VAR 0 11
18345: PUSH
18346: LD_VAR 0 1
18350: PUSH
18351: LD_VAR 0 3
18355: MINUS
18356: PUSH
18357: LD_VAR 0 2
18361: PLUS
18362: ST_TO_ADDR
// end ; if not length then
18363: LD_VAR 0 11
18367: NOT
18368: IFFALSE 18372
// exit ;
18370: GO 18530
// tmp := array ;
18372: LD_ADDR_VAR 0 10
18376: PUSH
18377: LD_VAR 0 1
18381: ST_TO_ADDR
// for i = 1 to length do
18382: LD_ADDR_VAR 0 6
18386: PUSH
18387: DOUBLE
18388: LD_INT 1
18390: DEC
18391: ST_TO_ADDR
18392: LD_VAR 0 11
18396: PUSH
18397: FOR_TO
18398: IFFALSE 18518
// begin for j = 1 to array do
18400: LD_ADDR_VAR 0 7
18404: PUSH
18405: DOUBLE
18406: LD_INT 1
18408: DEC
18409: ST_TO_ADDR
18410: LD_VAR 0 1
18414: PUSH
18415: FOR_TO
18416: IFFALSE 18504
// begin k := j + d ;
18418: LD_ADDR_VAR 0 8
18422: PUSH
18423: LD_VAR 0 7
18427: PUSH
18428: LD_VAR 0 9
18432: PLUS
18433: ST_TO_ADDR
// if k > array then
18434: LD_VAR 0 8
18438: PUSH
18439: LD_VAR 0 1
18443: GREATER
18444: IFFALSE 18454
// k := 1 ;
18446: LD_ADDR_VAR 0 8
18450: PUSH
18451: LD_INT 1
18453: ST_TO_ADDR
// if not k then
18454: LD_VAR 0 8
18458: NOT
18459: IFFALSE 18471
// k := array ;
18461: LD_ADDR_VAR 0 8
18465: PUSH
18466: LD_VAR 0 1
18470: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18471: LD_ADDR_VAR 0 10
18475: PUSH
18476: LD_VAR 0 10
18480: PPUSH
18481: LD_VAR 0 8
18485: PPUSH
18486: LD_VAR 0 1
18490: PUSH
18491: LD_VAR 0 7
18495: ARRAY
18496: PPUSH
18497: CALL_OW 1
18501: ST_TO_ADDR
// end ;
18502: GO 18415
18504: POP
18505: POP
// array := tmp ;
18506: LD_ADDR_VAR 0 1
18510: PUSH
18511: LD_VAR 0 10
18515: ST_TO_ADDR
// end ;
18516: GO 18397
18518: POP
18519: POP
// result := array ;
18520: LD_ADDR_VAR 0 5
18524: PUSH
18525: LD_VAR 0 1
18529: ST_TO_ADDR
// end ;
18530: LD_VAR 0 5
18534: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18535: LD_INT 0
18537: PPUSH
18538: PPUSH
// result := 0 ;
18539: LD_ADDR_VAR 0 3
18543: PUSH
18544: LD_INT 0
18546: ST_TO_ADDR
// if not array or not value in array then
18547: LD_VAR 0 1
18551: NOT
18552: PUSH
18553: LD_VAR 0 2
18557: PUSH
18558: LD_VAR 0 1
18562: IN
18563: NOT
18564: OR
18565: IFFALSE 18569
// exit ;
18567: GO 18623
// for i = 1 to array do
18569: LD_ADDR_VAR 0 4
18573: PUSH
18574: DOUBLE
18575: LD_INT 1
18577: DEC
18578: ST_TO_ADDR
18579: LD_VAR 0 1
18583: PUSH
18584: FOR_TO
18585: IFFALSE 18621
// if value = array [ i ] then
18587: LD_VAR 0 2
18591: PUSH
18592: LD_VAR 0 1
18596: PUSH
18597: LD_VAR 0 4
18601: ARRAY
18602: EQUAL
18603: IFFALSE 18619
// begin result := i ;
18605: LD_ADDR_VAR 0 3
18609: PUSH
18610: LD_VAR 0 4
18614: ST_TO_ADDR
// exit ;
18615: POP
18616: POP
18617: GO 18623
// end ;
18619: GO 18584
18621: POP
18622: POP
// end ;
18623: LD_VAR 0 3
18627: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18628: LD_INT 0
18630: PPUSH
// vc_chassis := chassis ;
18631: LD_ADDR_OWVAR 37
18635: PUSH
18636: LD_VAR 0 1
18640: ST_TO_ADDR
// vc_engine := engine ;
18641: LD_ADDR_OWVAR 39
18645: PUSH
18646: LD_VAR 0 2
18650: ST_TO_ADDR
// vc_control := control ;
18651: LD_ADDR_OWVAR 38
18655: PUSH
18656: LD_VAR 0 3
18660: ST_TO_ADDR
// vc_weapon := weapon ;
18661: LD_ADDR_OWVAR 40
18665: PUSH
18666: LD_VAR 0 4
18670: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18671: LD_ADDR_OWVAR 41
18675: PUSH
18676: LD_VAR 0 5
18680: ST_TO_ADDR
// end ;
18681: LD_VAR 0 6
18685: RET
// export function WantPlant ( unit ) ; var task ; begin
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
// result := false ;
18690: LD_ADDR_VAR 0 2
18694: PUSH
18695: LD_INT 0
18697: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18698: LD_ADDR_VAR 0 3
18702: PUSH
18703: LD_VAR 0 1
18707: PPUSH
18708: CALL_OW 437
18712: ST_TO_ADDR
// if task then
18713: LD_VAR 0 3
18717: IFFALSE 18745
// if task [ 1 ] [ 1 ] = p then
18719: LD_VAR 0 3
18723: PUSH
18724: LD_INT 1
18726: ARRAY
18727: PUSH
18728: LD_INT 1
18730: ARRAY
18731: PUSH
18732: LD_STRING p
18734: EQUAL
18735: IFFALSE 18745
// result := true ;
18737: LD_ADDR_VAR 0 2
18741: PUSH
18742: LD_INT 1
18744: ST_TO_ADDR
// end ;
18745: LD_VAR 0 2
18749: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18750: LD_INT 0
18752: PPUSH
18753: PPUSH
18754: PPUSH
18755: PPUSH
// if pos < 1 then
18756: LD_VAR 0 2
18760: PUSH
18761: LD_INT 1
18763: LESS
18764: IFFALSE 18768
// exit ;
18766: GO 19071
// if pos = 1 then
18768: LD_VAR 0 2
18772: PUSH
18773: LD_INT 1
18775: EQUAL
18776: IFFALSE 18809
// result := Replace ( arr , pos [ 1 ] , value ) else
18778: LD_ADDR_VAR 0 4
18782: PUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: LD_VAR 0 2
18792: PUSH
18793: LD_INT 1
18795: ARRAY
18796: PPUSH
18797: LD_VAR 0 3
18801: PPUSH
18802: CALL_OW 1
18806: ST_TO_ADDR
18807: GO 19071
// begin tmp := arr ;
18809: LD_ADDR_VAR 0 6
18813: PUSH
18814: LD_VAR 0 1
18818: ST_TO_ADDR
// s_arr := [ tmp ] ;
18819: LD_ADDR_VAR 0 7
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: EMPTY
18830: LIST
18831: ST_TO_ADDR
// for i = 1 to pos - 1 do
18832: LD_ADDR_VAR 0 5
18836: PUSH
18837: DOUBLE
18838: LD_INT 1
18840: DEC
18841: ST_TO_ADDR
18842: LD_VAR 0 2
18846: PUSH
18847: LD_INT 1
18849: MINUS
18850: PUSH
18851: FOR_TO
18852: IFFALSE 18897
// begin tmp := tmp [ pos [ i ] ] ;
18854: LD_ADDR_VAR 0 6
18858: PUSH
18859: LD_VAR 0 6
18863: PUSH
18864: LD_VAR 0 2
18868: PUSH
18869: LD_VAR 0 5
18873: ARRAY
18874: ARRAY
18875: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18876: LD_ADDR_VAR 0 7
18880: PUSH
18881: LD_VAR 0 7
18885: PUSH
18886: LD_VAR 0 6
18890: PUSH
18891: EMPTY
18892: LIST
18893: ADD
18894: ST_TO_ADDR
// end ;
18895: GO 18851
18897: POP
18898: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18899: LD_ADDR_VAR 0 6
18903: PUSH
18904: LD_VAR 0 6
18908: PPUSH
18909: LD_VAR 0 2
18913: PUSH
18914: LD_VAR 0 2
18918: ARRAY
18919: PPUSH
18920: LD_VAR 0 3
18924: PPUSH
18925: CALL_OW 1
18929: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18930: LD_ADDR_VAR 0 7
18934: PUSH
18935: LD_VAR 0 7
18939: PPUSH
18940: LD_VAR 0 7
18944: PPUSH
18945: LD_VAR 0 6
18949: PPUSH
18950: CALL_OW 1
18954: ST_TO_ADDR
// for i = s_arr downto 2 do
18955: LD_ADDR_VAR 0 5
18959: PUSH
18960: DOUBLE
18961: LD_VAR 0 7
18965: INC
18966: ST_TO_ADDR
18967: LD_INT 2
18969: PUSH
18970: FOR_DOWNTO
18971: IFFALSE 19055
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18973: LD_ADDR_VAR 0 6
18977: PUSH
18978: LD_VAR 0 7
18982: PUSH
18983: LD_VAR 0 5
18987: PUSH
18988: LD_INT 1
18990: MINUS
18991: ARRAY
18992: PPUSH
18993: LD_VAR 0 2
18997: PUSH
18998: LD_VAR 0 5
19002: PUSH
19003: LD_INT 1
19005: MINUS
19006: ARRAY
19007: PPUSH
19008: LD_VAR 0 7
19012: PUSH
19013: LD_VAR 0 5
19017: ARRAY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19024: LD_ADDR_VAR 0 7
19028: PUSH
19029: LD_VAR 0 7
19033: PPUSH
19034: LD_VAR 0 5
19038: PUSH
19039: LD_INT 1
19041: MINUS
19042: PPUSH
19043: LD_VAR 0 6
19047: PPUSH
19048: CALL_OW 1
19052: ST_TO_ADDR
// end ;
19053: GO 18970
19055: POP
19056: POP
// result := s_arr [ 1 ] ;
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: LD_VAR 0 7
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: ST_TO_ADDR
// end ; end ;
19071: LD_VAR 0 4
19075: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19076: LD_INT 0
19078: PPUSH
19079: PPUSH
// if not list then
19080: LD_VAR 0 1
19084: NOT
19085: IFFALSE 19089
// exit ;
19087: GO 19180
// i := list [ pos1 ] ;
19089: LD_ADDR_VAR 0 5
19093: PUSH
19094: LD_VAR 0 1
19098: PUSH
19099: LD_VAR 0 2
19103: ARRAY
19104: ST_TO_ADDR
// if not i then
19105: LD_VAR 0 5
19109: NOT
19110: IFFALSE 19114
// exit ;
19112: GO 19180
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_VAR 0 1
19123: PPUSH
19124: LD_VAR 0 2
19128: PPUSH
19129: LD_VAR 0 1
19133: PUSH
19134: LD_VAR 0 3
19138: ARRAY
19139: PPUSH
19140: CALL_OW 1
19144: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19145: LD_ADDR_VAR 0 1
19149: PUSH
19150: LD_VAR 0 1
19154: PPUSH
19155: LD_VAR 0 3
19159: PPUSH
19160: LD_VAR 0 5
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// result := list ;
19170: LD_ADDR_VAR 0 4
19174: PUSH
19175: LD_VAR 0 1
19179: ST_TO_ADDR
// end ;
19180: LD_VAR 0 4
19184: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19185: LD_INT 0
19187: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19188: LD_ADDR_VAR 0 5
19192: PUSH
19193: LD_VAR 0 1
19197: PPUSH
19198: CALL_OW 250
19202: PPUSH
19203: LD_VAR 0 1
19207: PPUSH
19208: CALL_OW 251
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: LD_VAR 0 3
19222: PPUSH
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL 19238 0 5
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 5
19237: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if not list then
19244: LD_VAR 0 3
19248: NOT
19249: IFFALSE 19253
// exit ;
19251: GO 19641
// result := [ ] ;
19253: LD_ADDR_VAR 0 6
19257: PUSH
19258: EMPTY
19259: ST_TO_ADDR
// for i in list do
19260: LD_ADDR_VAR 0 7
19264: PUSH
19265: LD_VAR 0 3
19269: PUSH
19270: FOR_IN
19271: IFFALSE 19473
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19273: LD_ADDR_VAR 0 9
19277: PUSH
19278: LD_VAR 0 7
19282: PPUSH
19283: LD_VAR 0 1
19287: PPUSH
19288: LD_VAR 0 2
19292: PPUSH
19293: CALL_OW 297
19297: ST_TO_ADDR
// if not result then
19298: LD_VAR 0 6
19302: NOT
19303: IFFALSE 19329
// result := [ [ i , tmp ] ] else
19305: LD_ADDR_VAR 0 6
19309: PUSH
19310: LD_VAR 0 7
19314: PUSH
19315: LD_VAR 0 9
19319: PUSH
19320: EMPTY
19321: LIST
19322: LIST
19323: PUSH
19324: EMPTY
19325: LIST
19326: ST_TO_ADDR
19327: GO 19471
// begin if result [ result ] [ 2 ] < tmp then
19329: LD_VAR 0 6
19333: PUSH
19334: LD_VAR 0 6
19338: ARRAY
19339: PUSH
19340: LD_INT 2
19342: ARRAY
19343: PUSH
19344: LD_VAR 0 9
19348: LESS
19349: IFFALSE 19391
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19351: LD_ADDR_VAR 0 6
19355: PUSH
19356: LD_VAR 0 6
19360: PPUSH
19361: LD_VAR 0 6
19365: PUSH
19366: LD_INT 1
19368: PLUS
19369: PPUSH
19370: LD_VAR 0 7
19374: PUSH
19375: LD_VAR 0 9
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: PPUSH
19384: CALL_OW 2
19388: ST_TO_ADDR
19389: GO 19471
// for j = 1 to result do
19391: LD_ADDR_VAR 0 8
19395: PUSH
19396: DOUBLE
19397: LD_INT 1
19399: DEC
19400: ST_TO_ADDR
19401: LD_VAR 0 6
19405: PUSH
19406: FOR_TO
19407: IFFALSE 19469
// begin if tmp < result [ j ] [ 2 ] then
19409: LD_VAR 0 9
19413: PUSH
19414: LD_VAR 0 6
19418: PUSH
19419: LD_VAR 0 8
19423: ARRAY
19424: PUSH
19425: LD_INT 2
19427: ARRAY
19428: LESS
19429: IFFALSE 19467
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19431: LD_ADDR_VAR 0 6
19435: PUSH
19436: LD_VAR 0 6
19440: PPUSH
19441: LD_VAR 0 8
19445: PPUSH
19446: LD_VAR 0 7
19450: PUSH
19451: LD_VAR 0 9
19455: PUSH
19456: EMPTY
19457: LIST
19458: LIST
19459: PPUSH
19460: CALL_OW 2
19464: ST_TO_ADDR
// break ;
19465: GO 19469
// end ; end ;
19467: GO 19406
19469: POP
19470: POP
// end ; end ;
19471: GO 19270
19473: POP
19474: POP
// if result and not asc then
19475: LD_VAR 0 6
19479: PUSH
19480: LD_VAR 0 4
19484: NOT
19485: AND
19486: IFFALSE 19561
// begin tmp := result ;
19488: LD_ADDR_VAR 0 9
19492: PUSH
19493: LD_VAR 0 6
19497: ST_TO_ADDR
// for i = tmp downto 1 do
19498: LD_ADDR_VAR 0 7
19502: PUSH
19503: DOUBLE
19504: LD_VAR 0 9
19508: INC
19509: ST_TO_ADDR
19510: LD_INT 1
19512: PUSH
19513: FOR_DOWNTO
19514: IFFALSE 19559
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19516: LD_ADDR_VAR 0 6
19520: PUSH
19521: LD_VAR 0 6
19525: PPUSH
19526: LD_VAR 0 9
19530: PUSH
19531: LD_VAR 0 7
19535: MINUS
19536: PUSH
19537: LD_INT 1
19539: PLUS
19540: PPUSH
19541: LD_VAR 0 9
19545: PUSH
19546: LD_VAR 0 7
19550: ARRAY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
19557: GO 19513
19559: POP
19560: POP
// end ; tmp := [ ] ;
19561: LD_ADDR_VAR 0 9
19565: PUSH
19566: EMPTY
19567: ST_TO_ADDR
// if mode then
19568: LD_VAR 0 5
19572: IFFALSE 19641
// begin for i = 1 to result do
19574: LD_ADDR_VAR 0 7
19578: PUSH
19579: DOUBLE
19580: LD_INT 1
19582: DEC
19583: ST_TO_ADDR
19584: LD_VAR 0 6
19588: PUSH
19589: FOR_TO
19590: IFFALSE 19629
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19592: LD_ADDR_VAR 0 9
19596: PUSH
19597: LD_VAR 0 9
19601: PPUSH
19602: LD_VAR 0 7
19606: PPUSH
19607: LD_VAR 0 6
19611: PUSH
19612: LD_VAR 0 7
19616: ARRAY
19617: PUSH
19618: LD_INT 1
19620: ARRAY
19621: PPUSH
19622: CALL_OW 1
19626: ST_TO_ADDR
19627: GO 19589
19629: POP
19630: POP
// result := tmp ;
19631: LD_ADDR_VAR 0 6
19635: PUSH
19636: LD_VAR 0 9
19640: ST_TO_ADDR
// end ; end ;
19641: LD_VAR 0 6
19645: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19646: LD_INT 0
19648: PPUSH
19649: PPUSH
19650: PPUSH
19651: PPUSH
19652: PPUSH
19653: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19654: LD_ADDR_VAR 0 5
19658: PUSH
19659: LD_INT 0
19661: PUSH
19662: LD_INT 0
19664: PUSH
19665: LD_INT 0
19667: PUSH
19668: EMPTY
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: ST_TO_ADDR
// if not x or not y then
19676: LD_VAR 0 2
19680: NOT
19681: PUSH
19682: LD_VAR 0 3
19686: NOT
19687: OR
19688: IFFALSE 19692
// exit ;
19690: GO 21344
// if not range then
19692: LD_VAR 0 4
19696: NOT
19697: IFFALSE 19707
// range := 10 ;
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: LD_INT 10
19706: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19707: LD_ADDR_VAR 0 8
19711: PUSH
19712: LD_INT 81
19714: PUSH
19715: LD_VAR 0 1
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: LD_INT 92
19726: PUSH
19727: LD_VAR 0 2
19731: PUSH
19732: LD_VAR 0 3
19736: PUSH
19737: LD_VAR 0 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: PUSH
19748: LD_INT 3
19750: PUSH
19751: LD_INT 21
19753: PUSH
19754: LD_INT 3
19756: PUSH
19757: EMPTY
19758: LIST
19759: LIST
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: LIST
19769: PPUSH
19770: CALL_OW 69
19774: ST_TO_ADDR
// if not tmp then
19775: LD_VAR 0 8
19779: NOT
19780: IFFALSE 19784
// exit ;
19782: GO 21344
// for i in tmp do
19784: LD_ADDR_VAR 0 6
19788: PUSH
19789: LD_VAR 0 8
19793: PUSH
19794: FOR_IN
19795: IFFALSE 21319
// begin points := [ 0 , 0 , 0 ] ;
19797: LD_ADDR_VAR 0 9
19801: PUSH
19802: LD_INT 0
19804: PUSH
19805: LD_INT 0
19807: PUSH
19808: LD_INT 0
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: LIST
19815: ST_TO_ADDR
// bpoints := 1 ;
19816: LD_ADDR_VAR 0 10
19820: PUSH
19821: LD_INT 1
19823: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19824: LD_VAR 0 6
19828: PPUSH
19829: CALL_OW 247
19833: PUSH
19834: LD_INT 1
19836: DOUBLE
19837: EQUAL
19838: IFTRUE 19842
19840: GO 20420
19842: POP
// begin if GetClass ( i ) = 1 then
19843: LD_VAR 0 6
19847: PPUSH
19848: CALL_OW 257
19852: PUSH
19853: LD_INT 1
19855: EQUAL
19856: IFFALSE 19877
// points := [ 10 , 5 , 3 ] ;
19858: LD_ADDR_VAR 0 9
19862: PUSH
19863: LD_INT 10
19865: PUSH
19866: LD_INT 5
19868: PUSH
19869: LD_INT 3
19871: PUSH
19872: EMPTY
19873: LIST
19874: LIST
19875: LIST
19876: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19877: LD_VAR 0 6
19881: PPUSH
19882: CALL_OW 257
19886: PUSH
19887: LD_INT 2
19889: PUSH
19890: LD_INT 3
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: LIST
19900: IN
19901: IFFALSE 19922
// points := [ 3 , 2 , 1 ] ;
19903: LD_ADDR_VAR 0 9
19907: PUSH
19908: LD_INT 3
19910: PUSH
19911: LD_INT 2
19913: PUSH
19914: LD_INT 1
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: LIST
19921: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19922: LD_VAR 0 6
19926: PPUSH
19927: CALL_OW 257
19931: PUSH
19932: LD_INT 5
19934: EQUAL
19935: IFFALSE 19956
// points := [ 130 , 5 , 2 ] ;
19937: LD_ADDR_VAR 0 9
19941: PUSH
19942: LD_INT 130
19944: PUSH
19945: LD_INT 5
19947: PUSH
19948: LD_INT 2
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19956: LD_VAR 0 6
19960: PPUSH
19961: CALL_OW 257
19965: PUSH
19966: LD_INT 8
19968: EQUAL
19969: IFFALSE 19990
// points := [ 35 , 35 , 30 ] ;
19971: LD_ADDR_VAR 0 9
19975: PUSH
19976: LD_INT 35
19978: PUSH
19979: LD_INT 35
19981: PUSH
19982: LD_INT 30
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19990: LD_VAR 0 6
19994: PPUSH
19995: CALL_OW 257
19999: PUSH
20000: LD_INT 9
20002: EQUAL
20003: IFFALSE 20024
// points := [ 20 , 55 , 40 ] ;
20005: LD_ADDR_VAR 0 9
20009: PUSH
20010: LD_INT 20
20012: PUSH
20013: LD_INT 55
20015: PUSH
20016: LD_INT 40
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20024: LD_VAR 0 6
20028: PPUSH
20029: CALL_OW 257
20033: PUSH
20034: LD_INT 12
20036: PUSH
20037: LD_INT 16
20039: PUSH
20040: EMPTY
20041: LIST
20042: LIST
20043: IN
20044: IFFALSE 20065
// points := [ 5 , 3 , 2 ] ;
20046: LD_ADDR_VAR 0 9
20050: PUSH
20051: LD_INT 5
20053: PUSH
20054: LD_INT 3
20056: PUSH
20057: LD_INT 2
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: LIST
20064: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20065: LD_VAR 0 6
20069: PPUSH
20070: CALL_OW 257
20074: PUSH
20075: LD_INT 17
20077: EQUAL
20078: IFFALSE 20099
// points := [ 100 , 50 , 75 ] ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_INT 100
20087: PUSH
20088: LD_INT 50
20090: PUSH
20091: LD_INT 75
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20099: LD_VAR 0 6
20103: PPUSH
20104: CALL_OW 257
20108: PUSH
20109: LD_INT 15
20111: EQUAL
20112: IFFALSE 20133
// points := [ 10 , 5 , 3 ] ;
20114: LD_ADDR_VAR 0 9
20118: PUSH
20119: LD_INT 10
20121: PUSH
20122: LD_INT 5
20124: PUSH
20125: LD_INT 3
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: LIST
20132: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20133: LD_VAR 0 6
20137: PPUSH
20138: CALL_OW 257
20142: PUSH
20143: LD_INT 14
20145: EQUAL
20146: IFFALSE 20167
// points := [ 10 , 0 , 0 ] ;
20148: LD_ADDR_VAR 0 9
20152: PUSH
20153: LD_INT 10
20155: PUSH
20156: LD_INT 0
20158: PUSH
20159: LD_INT 0
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: LIST
20166: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20167: LD_VAR 0 6
20171: PPUSH
20172: CALL_OW 257
20176: PUSH
20177: LD_INT 11
20179: EQUAL
20180: IFFALSE 20201
// points := [ 30 , 10 , 5 ] ;
20182: LD_ADDR_VAR 0 9
20186: PUSH
20187: LD_INT 30
20189: PUSH
20190: LD_INT 10
20192: PUSH
20193: LD_INT 5
20195: PUSH
20196: EMPTY
20197: LIST
20198: LIST
20199: LIST
20200: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20201: LD_VAR 0 1
20205: PPUSH
20206: LD_INT 5
20208: PPUSH
20209: CALL_OW 321
20213: PUSH
20214: LD_INT 2
20216: EQUAL
20217: IFFALSE 20234
// bpoints := bpoints * 1.8 ;
20219: LD_ADDR_VAR 0 10
20223: PUSH
20224: LD_VAR 0 10
20228: PUSH
20229: LD_REAL  1.80000000000000E+0000
20232: MUL
20233: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20234: LD_VAR 0 6
20238: PPUSH
20239: CALL_OW 257
20243: PUSH
20244: LD_INT 1
20246: PUSH
20247: LD_INT 2
20249: PUSH
20250: LD_INT 3
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: LIST
20260: LIST
20261: IN
20262: PUSH
20263: LD_VAR 0 1
20267: PPUSH
20268: LD_INT 51
20270: PPUSH
20271: CALL_OW 321
20275: PUSH
20276: LD_INT 2
20278: EQUAL
20279: AND
20280: IFFALSE 20297
// bpoints := bpoints * 1.2 ;
20282: LD_ADDR_VAR 0 10
20286: PUSH
20287: LD_VAR 0 10
20291: PUSH
20292: LD_REAL  1.20000000000000E+0000
20295: MUL
20296: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20297: LD_VAR 0 6
20301: PPUSH
20302: CALL_OW 257
20306: PUSH
20307: LD_INT 5
20309: PUSH
20310: LD_INT 7
20312: PUSH
20313: LD_INT 9
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: LIST
20320: IN
20321: PUSH
20322: LD_VAR 0 1
20326: PPUSH
20327: LD_INT 52
20329: PPUSH
20330: CALL_OW 321
20334: PUSH
20335: LD_INT 2
20337: EQUAL
20338: AND
20339: IFFALSE 20356
// bpoints := bpoints * 1.5 ;
20341: LD_ADDR_VAR 0 10
20345: PUSH
20346: LD_VAR 0 10
20350: PUSH
20351: LD_REAL  1.50000000000000E+0000
20354: MUL
20355: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20356: LD_VAR 0 1
20360: PPUSH
20361: LD_INT 66
20363: PPUSH
20364: CALL_OW 321
20368: PUSH
20369: LD_INT 2
20371: EQUAL
20372: IFFALSE 20389
// bpoints := bpoints * 1.1 ;
20374: LD_ADDR_VAR 0 10
20378: PUSH
20379: LD_VAR 0 10
20383: PUSH
20384: LD_REAL  1.10000000000000E+0000
20387: MUL
20388: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20389: LD_ADDR_VAR 0 10
20393: PUSH
20394: LD_VAR 0 10
20398: PUSH
20399: LD_VAR 0 6
20403: PPUSH
20404: LD_INT 1
20406: PPUSH
20407: CALL_OW 259
20411: PUSH
20412: LD_REAL  1.15000000000000E+0000
20415: MUL
20416: MUL
20417: ST_TO_ADDR
// end ; unit_vehicle :
20418: GO 21248
20420: LD_INT 2
20422: DOUBLE
20423: EQUAL
20424: IFTRUE 20428
20426: GO 21236
20428: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20429: LD_VAR 0 6
20433: PPUSH
20434: CALL_OW 264
20438: PUSH
20439: LD_INT 2
20441: PUSH
20442: LD_INT 42
20444: PUSH
20445: LD_INT 24
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: IN
20453: IFFALSE 20474
// points := [ 25 , 5 , 3 ] ;
20455: LD_ADDR_VAR 0 9
20459: PUSH
20460: LD_INT 25
20462: PUSH
20463: LD_INT 5
20465: PUSH
20466: LD_INT 3
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20474: LD_VAR 0 6
20478: PPUSH
20479: CALL_OW 264
20483: PUSH
20484: LD_INT 4
20486: PUSH
20487: LD_INT 43
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: EMPTY
20494: LIST
20495: LIST
20496: LIST
20497: IN
20498: IFFALSE 20519
// points := [ 40 , 15 , 5 ] ;
20500: LD_ADDR_VAR 0 9
20504: PUSH
20505: LD_INT 40
20507: PUSH
20508: LD_INT 15
20510: PUSH
20511: LD_INT 5
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: LIST
20518: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20519: LD_VAR 0 6
20523: PPUSH
20524: CALL_OW 264
20528: PUSH
20529: LD_INT 3
20531: PUSH
20532: LD_INT 23
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: IN
20539: IFFALSE 20560
// points := [ 7 , 25 , 8 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 7
20548: PUSH
20549: LD_INT 25
20551: PUSH
20552: LD_INT 8
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: LIST
20559: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20560: LD_VAR 0 6
20564: PPUSH
20565: CALL_OW 264
20569: PUSH
20570: LD_INT 5
20572: PUSH
20573: LD_INT 27
20575: PUSH
20576: LD_INT 44
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: LIST
20583: IN
20584: IFFALSE 20605
// points := [ 14 , 50 , 16 ] ;
20586: LD_ADDR_VAR 0 9
20590: PUSH
20591: LD_INT 14
20593: PUSH
20594: LD_INT 50
20596: PUSH
20597: LD_INT 16
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: LIST
20604: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20605: LD_VAR 0 6
20609: PPUSH
20610: CALL_OW 264
20614: PUSH
20615: LD_INT 6
20617: PUSH
20618: LD_INT 46
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: IN
20625: IFFALSE 20646
// points := [ 32 , 120 , 70 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 32
20634: PUSH
20635: LD_INT 120
20637: PUSH
20638: LD_INT 70
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 264
20655: PUSH
20656: LD_INT 7
20658: PUSH
20659: LD_INT 28
20661: PUSH
20662: LD_INT 45
20664: PUSH
20665: LD_EXP 53
20669: PUSH
20670: EMPTY
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: IN
20676: IFFALSE 20697
// points := [ 35 , 20 , 45 ] ;
20678: LD_ADDR_VAR 0 9
20682: PUSH
20683: LD_INT 35
20685: PUSH
20686: LD_INT 20
20688: PUSH
20689: LD_INT 45
20691: PUSH
20692: EMPTY
20693: LIST
20694: LIST
20695: LIST
20696: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20697: LD_VAR 0 6
20701: PPUSH
20702: CALL_OW 264
20706: PUSH
20707: LD_INT 47
20709: PUSH
20710: EMPTY
20711: LIST
20712: IN
20713: IFFALSE 20734
// points := [ 67 , 45 , 75 ] ;
20715: LD_ADDR_VAR 0 9
20719: PUSH
20720: LD_INT 67
20722: PUSH
20723: LD_INT 45
20725: PUSH
20726: LD_INT 75
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20734: LD_VAR 0 6
20738: PPUSH
20739: CALL_OW 264
20743: PUSH
20744: LD_INT 26
20746: PUSH
20747: EMPTY
20748: LIST
20749: IN
20750: IFFALSE 20771
// points := [ 120 , 30 , 80 ] ;
20752: LD_ADDR_VAR 0 9
20756: PUSH
20757: LD_INT 120
20759: PUSH
20760: LD_INT 30
20762: PUSH
20763: LD_INT 80
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: LIST
20770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20771: LD_VAR 0 6
20775: PPUSH
20776: CALL_OW 264
20780: PUSH
20781: LD_INT 22
20783: PUSH
20784: EMPTY
20785: LIST
20786: IN
20787: IFFALSE 20808
// points := [ 40 , 1 , 1 ] ;
20789: LD_ADDR_VAR 0 9
20793: PUSH
20794: LD_INT 40
20796: PUSH
20797: LD_INT 1
20799: PUSH
20800: LD_INT 1
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: LIST
20807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20808: LD_VAR 0 6
20812: PPUSH
20813: CALL_OW 264
20817: PUSH
20818: LD_INT 29
20820: PUSH
20821: EMPTY
20822: LIST
20823: IN
20824: IFFALSE 20845
// points := [ 70 , 200 , 400 ] ;
20826: LD_ADDR_VAR 0 9
20830: PUSH
20831: LD_INT 70
20833: PUSH
20834: LD_INT 200
20836: PUSH
20837: LD_INT 400
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: LIST
20844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20845: LD_VAR 0 6
20849: PPUSH
20850: CALL_OW 264
20854: PUSH
20855: LD_INT 14
20857: PUSH
20858: LD_INT 53
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: IN
20865: IFFALSE 20886
// points := [ 40 , 10 , 20 ] ;
20867: LD_ADDR_VAR 0 9
20871: PUSH
20872: LD_INT 40
20874: PUSH
20875: LD_INT 10
20877: PUSH
20878: LD_INT 20
20880: PUSH
20881: EMPTY
20882: LIST
20883: LIST
20884: LIST
20885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20886: LD_VAR 0 6
20890: PPUSH
20891: CALL_OW 264
20895: PUSH
20896: LD_INT 9
20898: PUSH
20899: EMPTY
20900: LIST
20901: IN
20902: IFFALSE 20923
// points := [ 5 , 70 , 20 ] ;
20904: LD_ADDR_VAR 0 9
20908: PUSH
20909: LD_INT 5
20911: PUSH
20912: LD_INT 70
20914: PUSH
20915: LD_INT 20
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: LIST
20922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20923: LD_VAR 0 6
20927: PPUSH
20928: CALL_OW 264
20932: PUSH
20933: LD_INT 10
20935: PUSH
20936: EMPTY
20937: LIST
20938: IN
20939: IFFALSE 20960
// points := [ 35 , 110 , 70 ] ;
20941: LD_ADDR_VAR 0 9
20945: PUSH
20946: LD_INT 35
20948: PUSH
20949: LD_INT 110
20951: PUSH
20952: LD_INT 70
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: LIST
20959: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20960: LD_VAR 0 6
20964: PPUSH
20965: CALL_OW 265
20969: PUSH
20970: LD_INT 25
20972: EQUAL
20973: IFFALSE 20994
// points := [ 80 , 65 , 100 ] ;
20975: LD_ADDR_VAR 0 9
20979: PUSH
20980: LD_INT 80
20982: PUSH
20983: LD_INT 65
20985: PUSH
20986: LD_INT 100
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: LIST
20993: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20994: LD_VAR 0 6
20998: PPUSH
20999: CALL_OW 263
21003: PUSH
21004: LD_INT 1
21006: EQUAL
21007: IFFALSE 21042
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21009: LD_ADDR_VAR 0 10
21013: PUSH
21014: LD_VAR 0 10
21018: PUSH
21019: LD_VAR 0 6
21023: PPUSH
21024: CALL_OW 311
21028: PPUSH
21029: LD_INT 3
21031: PPUSH
21032: CALL_OW 259
21036: PUSH
21037: LD_INT 4
21039: MUL
21040: MUL
21041: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21042: LD_VAR 0 6
21046: PPUSH
21047: CALL_OW 263
21051: PUSH
21052: LD_INT 2
21054: EQUAL
21055: IFFALSE 21106
// begin j := IsControledBy ( i ) ;
21057: LD_ADDR_VAR 0 7
21061: PUSH
21062: LD_VAR 0 6
21066: PPUSH
21067: CALL_OW 312
21071: ST_TO_ADDR
// if j then
21072: LD_VAR 0 7
21076: IFFALSE 21106
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21078: LD_ADDR_VAR 0 10
21082: PUSH
21083: LD_VAR 0 10
21087: PUSH
21088: LD_VAR 0 7
21092: PPUSH
21093: LD_INT 3
21095: PPUSH
21096: CALL_OW 259
21100: PUSH
21101: LD_INT 3
21103: MUL
21104: MUL
21105: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21106: LD_VAR 0 6
21110: PPUSH
21111: CALL_OW 264
21115: PUSH
21116: LD_INT 5
21118: PUSH
21119: LD_INT 6
21121: PUSH
21122: LD_INT 46
21124: PUSH
21125: LD_INT 44
21127: PUSH
21128: LD_INT 47
21130: PUSH
21131: LD_INT 45
21133: PUSH
21134: LD_INT 28
21136: PUSH
21137: LD_INT 7
21139: PUSH
21140: LD_INT 27
21142: PUSH
21143: LD_INT 29
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: PUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: LD_INT 52
21166: PPUSH
21167: CALL_OW 321
21171: PUSH
21172: LD_INT 2
21174: EQUAL
21175: AND
21176: IFFALSE 21193
// bpoints := bpoints * 1.2 ;
21178: LD_ADDR_VAR 0 10
21182: PUSH
21183: LD_VAR 0 10
21187: PUSH
21188: LD_REAL  1.20000000000000E+0000
21191: MUL
21192: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21193: LD_VAR 0 6
21197: PPUSH
21198: CALL_OW 264
21202: PUSH
21203: LD_INT 6
21205: PUSH
21206: LD_INT 46
21208: PUSH
21209: LD_INT 47
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: LIST
21216: IN
21217: IFFALSE 21234
// bpoints := bpoints * 1.2 ;
21219: LD_ADDR_VAR 0 10
21223: PUSH
21224: LD_VAR 0 10
21228: PUSH
21229: LD_REAL  1.20000000000000E+0000
21232: MUL
21233: ST_TO_ADDR
// end ; unit_building :
21234: GO 21248
21236: LD_INT 3
21238: DOUBLE
21239: EQUAL
21240: IFTRUE 21244
21242: GO 21247
21244: POP
// ; end ;
21245: GO 21248
21247: POP
// for j = 1 to 3 do
21248: LD_ADDR_VAR 0 7
21252: PUSH
21253: DOUBLE
21254: LD_INT 1
21256: DEC
21257: ST_TO_ADDR
21258: LD_INT 3
21260: PUSH
21261: FOR_TO
21262: IFFALSE 21315
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21264: LD_ADDR_VAR 0 5
21268: PUSH
21269: LD_VAR 0 5
21273: PPUSH
21274: LD_VAR 0 7
21278: PPUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_VAR 0 7
21288: ARRAY
21289: PUSH
21290: LD_VAR 0 9
21294: PUSH
21295: LD_VAR 0 7
21299: ARRAY
21300: PUSH
21301: LD_VAR 0 10
21305: MUL
21306: PLUS
21307: PPUSH
21308: CALL_OW 1
21312: ST_TO_ADDR
21313: GO 21261
21315: POP
21316: POP
// end ;
21317: GO 19794
21319: POP
21320: POP
// result := Replace ( result , 4 , tmp ) ;
21321: LD_ADDR_VAR 0 5
21325: PUSH
21326: LD_VAR 0 5
21330: PPUSH
21331: LD_INT 4
21333: PPUSH
21334: LD_VAR 0 8
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// end ;
21344: LD_VAR 0 5
21348: RET
// export function DangerAtRange ( unit , range ) ; begin
21349: LD_INT 0
21351: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21352: LD_ADDR_VAR 0 3
21356: PUSH
21357: LD_VAR 0 1
21361: PPUSH
21362: CALL_OW 255
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: CALL_OW 250
21376: PPUSH
21377: LD_VAR 0 1
21381: PPUSH
21382: CALL_OW 251
21386: PPUSH
21387: LD_VAR 0 2
21391: PPUSH
21392: CALL 19646 0 4
21396: ST_TO_ADDR
// end ;
21397: LD_VAR 0 3
21401: RET
// export function DangerInArea ( side , area ) ; begin
21402: LD_INT 0
21404: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21405: LD_ADDR_VAR 0 3
21409: PUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: LD_INT 81
21417: PUSH
21418: LD_VAR 0 1
21422: PUSH
21423: EMPTY
21424: LIST
21425: LIST
21426: PPUSH
21427: CALL_OW 70
21431: ST_TO_ADDR
// end ;
21432: LD_VAR 0 3
21436: RET
// export function IsExtension ( b ) ; begin
21437: LD_INT 0
21439: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21440: LD_ADDR_VAR 0 2
21444: PUSH
21445: LD_VAR 0 1
21449: PUSH
21450: LD_INT 23
21452: PUSH
21453: LD_INT 20
21455: PUSH
21456: LD_INT 22
21458: PUSH
21459: LD_INT 17
21461: PUSH
21462: LD_INT 24
21464: PUSH
21465: LD_INT 21
21467: PUSH
21468: LD_INT 19
21470: PUSH
21471: LD_INT 16
21473: PUSH
21474: LD_INT 25
21476: PUSH
21477: LD_INT 18
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: LIST
21487: LIST
21488: LIST
21489: LIST
21490: LIST
21491: IN
21492: ST_TO_ADDR
// end ;
21493: LD_VAR 0 2
21497: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21498: LD_INT 0
21500: PPUSH
21501: PPUSH
21502: PPUSH
// result := [ ] ;
21503: LD_ADDR_VAR 0 4
21507: PUSH
21508: EMPTY
21509: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21510: LD_ADDR_VAR 0 5
21514: PUSH
21515: LD_VAR 0 2
21519: PPUSH
21520: LD_INT 21
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: EMPTY
21527: LIST
21528: LIST
21529: PPUSH
21530: CALL_OW 70
21534: ST_TO_ADDR
// if not tmp then
21535: LD_VAR 0 5
21539: NOT
21540: IFFALSE 21544
// exit ;
21542: GO 21608
// if checkLink then
21544: LD_VAR 0 3
21548: IFFALSE 21598
// begin for i in tmp do
21550: LD_ADDR_VAR 0 6
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: FOR_IN
21561: IFFALSE 21596
// if GetBase ( i ) <> base then
21563: LD_VAR 0 6
21567: PPUSH
21568: CALL_OW 274
21572: PUSH
21573: LD_VAR 0 1
21577: NONEQUAL
21578: IFFALSE 21594
// ComLinkToBase ( base , i ) ;
21580: LD_VAR 0 1
21584: PPUSH
21585: LD_VAR 0 6
21589: PPUSH
21590: CALL_OW 169
21594: GO 21560
21596: POP
21597: POP
// end ; result := tmp ;
21598: LD_ADDR_VAR 0 4
21602: PUSH
21603: LD_VAR 0 5
21607: ST_TO_ADDR
// end ;
21608: LD_VAR 0 4
21612: RET
// export function ComComplete ( units , b ) ; var i ; begin
21613: LD_INT 0
21615: PPUSH
21616: PPUSH
// if not units then
21617: LD_VAR 0 1
21621: NOT
21622: IFFALSE 21626
// exit ;
21624: GO 21716
// for i in units do
21626: LD_ADDR_VAR 0 4
21630: PUSH
21631: LD_VAR 0 1
21635: PUSH
21636: FOR_IN
21637: IFFALSE 21714
// if BuildingStatus ( b ) = bs_build then
21639: LD_VAR 0 2
21643: PPUSH
21644: CALL_OW 461
21648: PUSH
21649: LD_INT 1
21651: EQUAL
21652: IFFALSE 21712
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21654: LD_VAR 0 4
21658: PPUSH
21659: LD_STRING h
21661: PUSH
21662: LD_VAR 0 2
21666: PPUSH
21667: CALL_OW 250
21671: PUSH
21672: LD_VAR 0 2
21676: PPUSH
21677: CALL_OW 251
21681: PUSH
21682: LD_VAR 0 2
21686: PUSH
21687: LD_INT 0
21689: PUSH
21690: LD_INT 0
21692: PUSH
21693: LD_INT 0
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: LIST
21700: LIST
21701: LIST
21702: LIST
21703: LIST
21704: PUSH
21705: EMPTY
21706: LIST
21707: PPUSH
21708: CALL_OW 446
21712: GO 21636
21714: POP
21715: POP
// end ;
21716: LD_VAR 0 3
21720: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21721: LD_INT 0
21723: PPUSH
21724: PPUSH
21725: PPUSH
21726: PPUSH
21727: PPUSH
21728: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21729: LD_VAR 0 1
21733: NOT
21734: PUSH
21735: LD_VAR 0 1
21739: PPUSH
21740: CALL_OW 263
21744: PUSH
21745: LD_INT 2
21747: NONEQUAL
21748: OR
21749: IFFALSE 21753
// exit ;
21751: GO 22069
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21753: LD_ADDR_VAR 0 6
21757: PUSH
21758: LD_INT 22
21760: PUSH
21761: LD_VAR 0 1
21765: PPUSH
21766: CALL_OW 255
21770: PUSH
21771: EMPTY
21772: LIST
21773: LIST
21774: PUSH
21775: LD_INT 2
21777: PUSH
21778: LD_INT 30
21780: PUSH
21781: LD_INT 36
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: PUSH
21788: LD_INT 34
21790: PUSH
21791: LD_INT 31
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: PUSH
21798: EMPTY
21799: LIST
21800: LIST
21801: LIST
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: PPUSH
21807: CALL_OW 69
21811: ST_TO_ADDR
// if not tmp then
21812: LD_VAR 0 6
21816: NOT
21817: IFFALSE 21821
// exit ;
21819: GO 22069
// result := [ ] ;
21821: LD_ADDR_VAR 0 2
21825: PUSH
21826: EMPTY
21827: ST_TO_ADDR
// for i in tmp do
21828: LD_ADDR_VAR 0 3
21832: PUSH
21833: LD_VAR 0 6
21837: PUSH
21838: FOR_IN
21839: IFFALSE 21910
// begin t := UnitsInside ( i ) ;
21841: LD_ADDR_VAR 0 4
21845: PUSH
21846: LD_VAR 0 3
21850: PPUSH
21851: CALL_OW 313
21855: ST_TO_ADDR
// if t then
21856: LD_VAR 0 4
21860: IFFALSE 21908
// for j in t do
21862: LD_ADDR_VAR 0 7
21866: PUSH
21867: LD_VAR 0 4
21871: PUSH
21872: FOR_IN
21873: IFFALSE 21906
// result := Replace ( result , result + 1 , j ) ;
21875: LD_ADDR_VAR 0 2
21879: PUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: LD_VAR 0 2
21889: PUSH
21890: LD_INT 1
21892: PLUS
21893: PPUSH
21894: LD_VAR 0 7
21898: PPUSH
21899: CALL_OW 1
21903: ST_TO_ADDR
21904: GO 21872
21906: POP
21907: POP
// end ;
21908: GO 21838
21910: POP
21911: POP
// if not result then
21912: LD_VAR 0 2
21916: NOT
21917: IFFALSE 21921
// exit ;
21919: GO 22069
// mech := result [ 1 ] ;
21921: LD_ADDR_VAR 0 5
21925: PUSH
21926: LD_VAR 0 2
21930: PUSH
21931: LD_INT 1
21933: ARRAY
21934: ST_TO_ADDR
// if result > 1 then
21935: LD_VAR 0 2
21939: PUSH
21940: LD_INT 1
21942: GREATER
21943: IFFALSE 22055
// begin for i = 2 to result do
21945: LD_ADDR_VAR 0 3
21949: PUSH
21950: DOUBLE
21951: LD_INT 2
21953: DEC
21954: ST_TO_ADDR
21955: LD_VAR 0 2
21959: PUSH
21960: FOR_TO
21961: IFFALSE 22053
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21963: LD_ADDR_VAR 0 4
21967: PUSH
21968: LD_VAR 0 2
21972: PUSH
21973: LD_VAR 0 3
21977: ARRAY
21978: PPUSH
21979: LD_INT 3
21981: PPUSH
21982: CALL_OW 259
21986: PUSH
21987: LD_VAR 0 2
21991: PUSH
21992: LD_VAR 0 3
21996: ARRAY
21997: PPUSH
21998: CALL_OW 432
22002: MINUS
22003: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22004: LD_VAR 0 4
22008: PUSH
22009: LD_VAR 0 5
22013: PPUSH
22014: LD_INT 3
22016: PPUSH
22017: CALL_OW 259
22021: PUSH
22022: LD_VAR 0 5
22026: PPUSH
22027: CALL_OW 432
22031: MINUS
22032: GREATEREQUAL
22033: IFFALSE 22051
// mech := result [ i ] ;
22035: LD_ADDR_VAR 0 5
22039: PUSH
22040: LD_VAR 0 2
22044: PUSH
22045: LD_VAR 0 3
22049: ARRAY
22050: ST_TO_ADDR
// end ;
22051: GO 21960
22053: POP
22054: POP
// end ; ComLinkTo ( vehicle , mech ) ;
22055: LD_VAR 0 1
22059: PPUSH
22060: LD_VAR 0 5
22064: PPUSH
22065: CALL_OW 135
// end ;
22069: LD_VAR 0 2
22073: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22074: LD_INT 0
22076: PPUSH
22077: PPUSH
22078: PPUSH
22079: PPUSH
22080: PPUSH
22081: PPUSH
22082: PPUSH
22083: PPUSH
22084: PPUSH
22085: PPUSH
22086: PPUSH
22087: PPUSH
22088: PPUSH
// result := [ ] ;
22089: LD_ADDR_VAR 0 7
22093: PUSH
22094: EMPTY
22095: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22096: LD_VAR 0 1
22100: PPUSH
22101: CALL_OW 266
22105: PUSH
22106: LD_INT 0
22108: PUSH
22109: LD_INT 1
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: IN
22116: NOT
22117: IFFALSE 22121
// exit ;
22119: GO 23755
// if name then
22121: LD_VAR 0 3
22125: IFFALSE 22141
// SetBName ( base_dep , name ) ;
22127: LD_VAR 0 1
22131: PPUSH
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 500
// base := GetBase ( base_dep ) ;
22141: LD_ADDR_VAR 0 15
22145: PUSH
22146: LD_VAR 0 1
22150: PPUSH
22151: CALL_OW 274
22155: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22156: LD_ADDR_VAR 0 16
22160: PUSH
22161: LD_VAR 0 1
22165: PPUSH
22166: CALL_OW 255
22170: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22171: LD_ADDR_VAR 0 17
22175: PUSH
22176: LD_VAR 0 1
22180: PPUSH
22181: CALL_OW 248
22185: ST_TO_ADDR
// if sources then
22186: LD_VAR 0 5
22190: IFFALSE 22237
// for i = 1 to 3 do
22192: LD_ADDR_VAR 0 8
22196: PUSH
22197: DOUBLE
22198: LD_INT 1
22200: DEC
22201: ST_TO_ADDR
22202: LD_INT 3
22204: PUSH
22205: FOR_TO
22206: IFFALSE 22235
// AddResourceType ( base , i , sources [ i ] ) ;
22208: LD_VAR 0 15
22212: PPUSH
22213: LD_VAR 0 8
22217: PPUSH
22218: LD_VAR 0 5
22222: PUSH
22223: LD_VAR 0 8
22227: ARRAY
22228: PPUSH
22229: CALL_OW 276
22233: GO 22205
22235: POP
22236: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22237: LD_ADDR_VAR 0 18
22241: PUSH
22242: LD_VAR 0 15
22246: PPUSH
22247: LD_VAR 0 2
22251: PPUSH
22252: LD_INT 1
22254: PPUSH
22255: CALL 21498 0 3
22259: ST_TO_ADDR
// InitHc ;
22260: CALL_OW 19
// InitUc ;
22264: CALL_OW 18
// uc_side := side ;
22268: LD_ADDR_OWVAR 20
22272: PUSH
22273: LD_VAR 0 16
22277: ST_TO_ADDR
// uc_nation := nation ;
22278: LD_ADDR_OWVAR 21
22282: PUSH
22283: LD_VAR 0 17
22287: ST_TO_ADDR
// if buildings then
22288: LD_VAR 0 18
22292: IFFALSE 23614
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22294: LD_ADDR_VAR 0 19
22298: PUSH
22299: LD_VAR 0 18
22303: PPUSH
22304: LD_INT 2
22306: PUSH
22307: LD_INT 30
22309: PUSH
22310: LD_INT 29
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 30
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: LIST
22331: PPUSH
22332: CALL_OW 72
22336: ST_TO_ADDR
// if tmp then
22337: LD_VAR 0 19
22341: IFFALSE 22389
// for i in tmp do
22343: LD_ADDR_VAR 0 8
22347: PUSH
22348: LD_VAR 0 19
22352: PUSH
22353: FOR_IN
22354: IFFALSE 22387
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22356: LD_VAR 0 8
22360: PPUSH
22361: CALL_OW 250
22365: PPUSH
22366: LD_VAR 0 8
22370: PPUSH
22371: CALL_OW 251
22375: PPUSH
22376: LD_VAR 0 16
22380: PPUSH
22381: CALL_OW 441
22385: GO 22353
22387: POP
22388: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22389: LD_VAR 0 18
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 32
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 33
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: LIST
22421: PPUSH
22422: CALL_OW 72
22426: IFFALSE 22514
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22428: LD_ADDR_VAR 0 8
22432: PUSH
22433: LD_VAR 0 18
22437: PPUSH
22438: LD_INT 2
22440: PUSH
22441: LD_INT 30
22443: PUSH
22444: LD_INT 32
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: LD_INT 30
22453: PUSH
22454: LD_INT 33
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: LIST
22465: PPUSH
22466: CALL_OW 72
22470: PUSH
22471: FOR_IN
22472: IFFALSE 22512
// begin if not GetBWeapon ( i ) then
22474: LD_VAR 0 8
22478: PPUSH
22479: CALL_OW 269
22483: NOT
22484: IFFALSE 22510
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22486: LD_VAR 0 8
22490: PPUSH
22491: LD_VAR 0 8
22495: PPUSH
22496: LD_VAR 0 2
22500: PPUSH
22501: CALL 23760 0 2
22505: PPUSH
22506: CALL_OW 431
// end ;
22510: GO 22471
22512: POP
22513: POP
// end ; for i = 1 to personel do
22514: LD_ADDR_VAR 0 8
22518: PUSH
22519: DOUBLE
22520: LD_INT 1
22522: DEC
22523: ST_TO_ADDR
22524: LD_VAR 0 6
22528: PUSH
22529: FOR_TO
22530: IFFALSE 23594
// begin if i > 4 then
22532: LD_VAR 0 8
22536: PUSH
22537: LD_INT 4
22539: GREATER
22540: IFFALSE 22544
// break ;
22542: GO 23594
// case i of 1 :
22544: LD_VAR 0 8
22548: PUSH
22549: LD_INT 1
22551: DOUBLE
22552: EQUAL
22553: IFTRUE 22557
22555: GO 22637
22557: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22558: LD_ADDR_VAR 0 12
22562: PUSH
22563: LD_VAR 0 18
22567: PPUSH
22568: LD_INT 22
22570: PUSH
22571: LD_VAR 0 16
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: LD_INT 58
22582: PUSH
22583: EMPTY
22584: LIST
22585: PUSH
22586: LD_INT 2
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 32
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 30
22601: PUSH
22602: LD_INT 4
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: LD_INT 30
22611: PUSH
22612: LD_INT 5
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: PUSH
22625: EMPTY
22626: LIST
22627: LIST
22628: LIST
22629: PPUSH
22630: CALL_OW 72
22634: ST_TO_ADDR
22635: GO 22859
22637: LD_INT 2
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22707
22645: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22646: LD_ADDR_VAR 0 12
22650: PUSH
22651: LD_VAR 0 18
22655: PPUSH
22656: LD_INT 22
22658: PUSH
22659: LD_VAR 0 16
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 2
22670: PUSH
22671: LD_INT 30
22673: PUSH
22674: LD_INT 0
22676: PUSH
22677: EMPTY
22678: LIST
22679: LIST
22680: PUSH
22681: LD_INT 30
22683: PUSH
22684: LD_INT 1
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: EMPTY
22692: LIST
22693: LIST
22694: LIST
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: PPUSH
22700: CALL_OW 72
22704: ST_TO_ADDR
22705: GO 22859
22707: LD_INT 3
22709: DOUBLE
22710: EQUAL
22711: IFTRUE 22715
22713: GO 22777
22715: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22716: LD_ADDR_VAR 0 12
22720: PUSH
22721: LD_VAR 0 18
22725: PPUSH
22726: LD_INT 22
22728: PUSH
22729: LD_VAR 0 16
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: PUSH
22738: LD_INT 2
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 2
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 30
22753: PUSH
22754: LD_INT 3
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: LIST
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PPUSH
22770: CALL_OW 72
22774: ST_TO_ADDR
22775: GO 22859
22777: LD_INT 4
22779: DOUBLE
22780: EQUAL
22781: IFTRUE 22785
22783: GO 22858
22785: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22786: LD_ADDR_VAR 0 12
22790: PUSH
22791: LD_VAR 0 18
22795: PPUSH
22796: LD_INT 22
22798: PUSH
22799: LD_VAR 0 16
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 2
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 6
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: LD_INT 30
22823: PUSH
22824: LD_INT 7
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: LD_INT 30
22833: PUSH
22834: LD_INT 8
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PPUSH
22851: CALL_OW 72
22855: ST_TO_ADDR
22856: GO 22859
22858: POP
// if i = 1 then
22859: LD_VAR 0 8
22863: PUSH
22864: LD_INT 1
22866: EQUAL
22867: IFFALSE 22978
// begin tmp := [ ] ;
22869: LD_ADDR_VAR 0 19
22873: PUSH
22874: EMPTY
22875: ST_TO_ADDR
// for j in f do
22876: LD_ADDR_VAR 0 9
22880: PUSH
22881: LD_VAR 0 12
22885: PUSH
22886: FOR_IN
22887: IFFALSE 22960
// if GetBType ( j ) = b_bunker then
22889: LD_VAR 0 9
22893: PPUSH
22894: CALL_OW 266
22898: PUSH
22899: LD_INT 32
22901: EQUAL
22902: IFFALSE 22929
// tmp := Insert ( tmp , 1 , j ) else
22904: LD_ADDR_VAR 0 19
22908: PUSH
22909: LD_VAR 0 19
22913: PPUSH
22914: LD_INT 1
22916: PPUSH
22917: LD_VAR 0 9
22921: PPUSH
22922: CALL_OW 2
22926: ST_TO_ADDR
22927: GO 22958
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22929: LD_ADDR_VAR 0 19
22933: PUSH
22934: LD_VAR 0 19
22938: PPUSH
22939: LD_VAR 0 19
22943: PUSH
22944: LD_INT 1
22946: PLUS
22947: PPUSH
22948: LD_VAR 0 9
22952: PPUSH
22953: CALL_OW 2
22957: ST_TO_ADDR
22958: GO 22886
22960: POP
22961: POP
// if tmp then
22962: LD_VAR 0 19
22966: IFFALSE 22978
// f := tmp ;
22968: LD_ADDR_VAR 0 12
22972: PUSH
22973: LD_VAR 0 19
22977: ST_TO_ADDR
// end ; x := personel [ i ] ;
22978: LD_ADDR_VAR 0 13
22982: PUSH
22983: LD_VAR 0 6
22987: PUSH
22988: LD_VAR 0 8
22992: ARRAY
22993: ST_TO_ADDR
// if x = - 1 then
22994: LD_VAR 0 13
22998: PUSH
22999: LD_INT 1
23001: NEG
23002: EQUAL
23003: IFFALSE 23212
// begin for j in f do
23005: LD_ADDR_VAR 0 9
23009: PUSH
23010: LD_VAR 0 12
23014: PUSH
23015: FOR_IN
23016: IFFALSE 23208
// repeat InitHc ;
23018: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23022: LD_VAR 0 9
23026: PPUSH
23027: CALL_OW 266
23031: PUSH
23032: LD_INT 5
23034: EQUAL
23035: IFFALSE 23105
// begin if UnitsInside ( j ) < 3 then
23037: LD_VAR 0 9
23041: PPUSH
23042: CALL_OW 313
23046: PUSH
23047: LD_INT 3
23049: LESS
23050: IFFALSE 23086
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23052: LD_INT 0
23054: PPUSH
23055: LD_INT 5
23057: PUSH
23058: LD_INT 8
23060: PUSH
23061: LD_INT 9
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: LIST
23068: PUSH
23069: LD_VAR 0 17
23073: ARRAY
23074: PPUSH
23075: LD_VAR 0 4
23079: PPUSH
23080: CALL_OW 380
23084: GO 23103
// PrepareHuman ( false , i , skill ) ;
23086: LD_INT 0
23088: PPUSH
23089: LD_VAR 0 8
23093: PPUSH
23094: LD_VAR 0 4
23098: PPUSH
23099: CALL_OW 380
// end else
23103: GO 23122
// PrepareHuman ( false , i , skill ) ;
23105: LD_INT 0
23107: PPUSH
23108: LD_VAR 0 8
23112: PPUSH
23113: LD_VAR 0 4
23117: PPUSH
23118: CALL_OW 380
// un := CreateHuman ;
23122: LD_ADDR_VAR 0 14
23126: PUSH
23127: CALL_OW 44
23131: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23132: LD_ADDR_VAR 0 7
23136: PUSH
23137: LD_VAR 0 7
23141: PPUSH
23142: LD_INT 1
23144: PPUSH
23145: LD_VAR 0 14
23149: PPUSH
23150: CALL_OW 2
23154: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23155: LD_VAR 0 14
23159: PPUSH
23160: LD_VAR 0 9
23164: PPUSH
23165: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23169: LD_VAR 0 9
23173: PPUSH
23174: CALL_OW 313
23178: PUSH
23179: LD_INT 6
23181: EQUAL
23182: PUSH
23183: LD_VAR 0 9
23187: PPUSH
23188: CALL_OW 266
23192: PUSH
23193: LD_INT 32
23195: PUSH
23196: LD_INT 31
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: IN
23203: OR
23204: IFFALSE 23018
23206: GO 23015
23208: POP
23209: POP
// end else
23210: GO 23592
// for j = 1 to x do
23212: LD_ADDR_VAR 0 9
23216: PUSH
23217: DOUBLE
23218: LD_INT 1
23220: DEC
23221: ST_TO_ADDR
23222: LD_VAR 0 13
23226: PUSH
23227: FOR_TO
23228: IFFALSE 23590
// begin InitHc ;
23230: CALL_OW 19
// if not f then
23234: LD_VAR 0 12
23238: NOT
23239: IFFALSE 23328
// begin PrepareHuman ( false , i , skill ) ;
23241: LD_INT 0
23243: PPUSH
23244: LD_VAR 0 8
23248: PPUSH
23249: LD_VAR 0 4
23253: PPUSH
23254: CALL_OW 380
// un := CreateHuman ;
23258: LD_ADDR_VAR 0 14
23262: PUSH
23263: CALL_OW 44
23267: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23268: LD_ADDR_VAR 0 7
23272: PUSH
23273: LD_VAR 0 7
23277: PPUSH
23278: LD_INT 1
23280: PPUSH
23281: LD_VAR 0 14
23285: PPUSH
23286: CALL_OW 2
23290: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23291: LD_VAR 0 14
23295: PPUSH
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 250
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 251
23315: PPUSH
23316: LD_INT 10
23318: PPUSH
23319: LD_INT 0
23321: PPUSH
23322: CALL_OW 50
// continue ;
23326: GO 23227
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23328: LD_VAR 0 12
23332: PUSH
23333: LD_INT 1
23335: ARRAY
23336: PPUSH
23337: CALL_OW 313
23341: PUSH
23342: LD_VAR 0 12
23346: PUSH
23347: LD_INT 1
23349: ARRAY
23350: PPUSH
23351: CALL_OW 266
23355: PUSH
23356: LD_INT 32
23358: PUSH
23359: LD_INT 31
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: IN
23366: AND
23367: PUSH
23368: LD_VAR 0 12
23372: PUSH
23373: LD_INT 1
23375: ARRAY
23376: PPUSH
23377: CALL_OW 313
23381: PUSH
23382: LD_INT 6
23384: EQUAL
23385: OR
23386: IFFALSE 23406
// f := Delete ( f , 1 ) ;
23388: LD_ADDR_VAR 0 12
23392: PUSH
23393: LD_VAR 0 12
23397: PPUSH
23398: LD_INT 1
23400: PPUSH
23401: CALL_OW 3
23405: ST_TO_ADDR
// if not f then
23406: LD_VAR 0 12
23410: NOT
23411: IFFALSE 23429
// begin x := x + 2 ;
23413: LD_ADDR_VAR 0 13
23417: PUSH
23418: LD_VAR 0 13
23422: PUSH
23423: LD_INT 2
23425: PLUS
23426: ST_TO_ADDR
// continue ;
23427: GO 23227
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23429: LD_VAR 0 12
23433: PUSH
23434: LD_INT 1
23436: ARRAY
23437: PPUSH
23438: CALL_OW 266
23442: PUSH
23443: LD_INT 5
23445: EQUAL
23446: IFFALSE 23520
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23448: LD_VAR 0 12
23452: PUSH
23453: LD_INT 1
23455: ARRAY
23456: PPUSH
23457: CALL_OW 313
23461: PUSH
23462: LD_INT 3
23464: LESS
23465: IFFALSE 23501
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23467: LD_INT 0
23469: PPUSH
23470: LD_INT 5
23472: PUSH
23473: LD_INT 8
23475: PUSH
23476: LD_INT 9
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: LIST
23483: PUSH
23484: LD_VAR 0 17
23488: ARRAY
23489: PPUSH
23490: LD_VAR 0 4
23494: PPUSH
23495: CALL_OW 380
23499: GO 23518
// PrepareHuman ( false , i , skill ) ;
23501: LD_INT 0
23503: PPUSH
23504: LD_VAR 0 8
23508: PPUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: CALL_OW 380
// end else
23518: GO 23537
// PrepareHuman ( false , i , skill ) ;
23520: LD_INT 0
23522: PPUSH
23523: LD_VAR 0 8
23527: PPUSH
23528: LD_VAR 0 4
23532: PPUSH
23533: CALL_OW 380
// un := CreateHuman ;
23537: LD_ADDR_VAR 0 14
23541: PUSH
23542: CALL_OW 44
23546: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23547: LD_ADDR_VAR 0 7
23551: PUSH
23552: LD_VAR 0 7
23556: PPUSH
23557: LD_INT 1
23559: PPUSH
23560: LD_VAR 0 14
23564: PPUSH
23565: CALL_OW 2
23569: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23570: LD_VAR 0 14
23574: PPUSH
23575: LD_VAR 0 12
23579: PUSH
23580: LD_INT 1
23582: ARRAY
23583: PPUSH
23584: CALL_OW 52
// end ;
23588: GO 23227
23590: POP
23591: POP
// end ;
23592: GO 22529
23594: POP
23595: POP
// result := result ^ buildings ;
23596: LD_ADDR_VAR 0 7
23600: PUSH
23601: LD_VAR 0 7
23605: PUSH
23606: LD_VAR 0 18
23610: ADD
23611: ST_TO_ADDR
// end else
23612: GO 23755
// begin for i = 1 to personel do
23614: LD_ADDR_VAR 0 8
23618: PUSH
23619: DOUBLE
23620: LD_INT 1
23622: DEC
23623: ST_TO_ADDR
23624: LD_VAR 0 6
23628: PUSH
23629: FOR_TO
23630: IFFALSE 23753
// begin if i > 4 then
23632: LD_VAR 0 8
23636: PUSH
23637: LD_INT 4
23639: GREATER
23640: IFFALSE 23644
// break ;
23642: GO 23753
// x := personel [ i ] ;
23644: LD_ADDR_VAR 0 13
23648: PUSH
23649: LD_VAR 0 6
23653: PUSH
23654: LD_VAR 0 8
23658: ARRAY
23659: ST_TO_ADDR
// if x = - 1 then
23660: LD_VAR 0 13
23664: PUSH
23665: LD_INT 1
23667: NEG
23668: EQUAL
23669: IFFALSE 23673
// continue ;
23671: GO 23629
// PrepareHuman ( false , i , skill ) ;
23673: LD_INT 0
23675: PPUSH
23676: LD_VAR 0 8
23680: PPUSH
23681: LD_VAR 0 4
23685: PPUSH
23686: CALL_OW 380
// un := CreateHuman ;
23690: LD_ADDR_VAR 0 14
23694: PUSH
23695: CALL_OW 44
23699: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23700: LD_VAR 0 14
23704: PPUSH
23705: LD_VAR 0 1
23709: PPUSH
23710: CALL_OW 250
23714: PPUSH
23715: LD_VAR 0 1
23719: PPUSH
23720: CALL_OW 251
23724: PPUSH
23725: LD_INT 10
23727: PPUSH
23728: LD_INT 0
23730: PPUSH
23731: CALL_OW 50
// result := result ^ un ;
23735: LD_ADDR_VAR 0 7
23739: PUSH
23740: LD_VAR 0 7
23744: PUSH
23745: LD_VAR 0 14
23749: ADD
23750: ST_TO_ADDR
// end ;
23751: GO 23629
23753: POP
23754: POP
// end ; end ;
23755: LD_VAR 0 7
23759: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23760: LD_INT 0
23762: PPUSH
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
23776: PPUSH
23777: PPUSH
// result := false ;
23778: LD_ADDR_VAR 0 3
23782: PUSH
23783: LD_INT 0
23785: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23786: LD_VAR 0 1
23790: NOT
23791: PUSH
23792: LD_VAR 0 1
23796: PPUSH
23797: CALL_OW 266
23801: PUSH
23802: LD_INT 32
23804: PUSH
23805: LD_INT 33
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: IN
23812: NOT
23813: OR
23814: IFFALSE 23818
// exit ;
23816: GO 24927
// nat := GetNation ( tower ) ;
23818: LD_ADDR_VAR 0 12
23822: PUSH
23823: LD_VAR 0 1
23827: PPUSH
23828: CALL_OW 248
23832: ST_TO_ADDR
// side := GetSide ( tower ) ;
23833: LD_ADDR_VAR 0 16
23837: PUSH
23838: LD_VAR 0 1
23842: PPUSH
23843: CALL_OW 255
23847: ST_TO_ADDR
// x := GetX ( tower ) ;
23848: LD_ADDR_VAR 0 10
23852: PUSH
23853: LD_VAR 0 1
23857: PPUSH
23858: CALL_OW 250
23862: ST_TO_ADDR
// y := GetY ( tower ) ;
23863: LD_ADDR_VAR 0 11
23867: PUSH
23868: LD_VAR 0 1
23872: PPUSH
23873: CALL_OW 251
23877: ST_TO_ADDR
// if not x or not y then
23878: LD_VAR 0 10
23882: NOT
23883: PUSH
23884: LD_VAR 0 11
23888: NOT
23889: OR
23890: IFFALSE 23894
// exit ;
23892: GO 24927
// weapon := 0 ;
23894: LD_ADDR_VAR 0 18
23898: PUSH
23899: LD_INT 0
23901: ST_TO_ADDR
// fac_list := [ ] ;
23902: LD_ADDR_VAR 0 17
23906: PUSH
23907: EMPTY
23908: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23909: LD_ADDR_VAR 0 6
23913: PUSH
23914: LD_VAR 0 1
23918: PPUSH
23919: CALL_OW 274
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: LD_INT 0
23931: PPUSH
23932: CALL 21498 0 3
23936: PPUSH
23937: LD_INT 30
23939: PUSH
23940: LD_INT 3
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: PPUSH
23947: CALL_OW 72
23951: ST_TO_ADDR
// if not factories then
23952: LD_VAR 0 6
23956: NOT
23957: IFFALSE 23961
// exit ;
23959: GO 24927
// for i in factories do
23961: LD_ADDR_VAR 0 8
23965: PUSH
23966: LD_VAR 0 6
23970: PUSH
23971: FOR_IN
23972: IFFALSE 23997
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23974: LD_ADDR_VAR 0 17
23978: PUSH
23979: LD_VAR 0 17
23983: PUSH
23984: LD_VAR 0 8
23988: PPUSH
23989: CALL_OW 478
23993: UNION
23994: ST_TO_ADDR
23995: GO 23971
23997: POP
23998: POP
// if not fac_list then
23999: LD_VAR 0 17
24003: NOT
24004: IFFALSE 24008
// exit ;
24006: GO 24927
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24008: LD_ADDR_VAR 0 5
24012: PUSH
24013: LD_INT 4
24015: PUSH
24016: LD_INT 5
24018: PUSH
24019: LD_INT 9
24021: PUSH
24022: LD_INT 10
24024: PUSH
24025: LD_INT 6
24027: PUSH
24028: LD_INT 7
24030: PUSH
24031: LD_INT 11
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: LIST
24042: PUSH
24043: LD_INT 27
24045: PUSH
24046: LD_INT 28
24048: PUSH
24049: LD_INT 26
24051: PUSH
24052: LD_INT 30
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 43
24063: PUSH
24064: LD_INT 44
24066: PUSH
24067: LD_INT 46
24069: PUSH
24070: LD_INT 45
24072: PUSH
24073: LD_INT 47
24075: PUSH
24076: LD_INT 49
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: PUSH
24092: LD_VAR 0 12
24096: ARRAY
24097: ST_TO_ADDR
// list := list isect fac_list ;
24098: LD_ADDR_VAR 0 5
24102: PUSH
24103: LD_VAR 0 5
24107: PUSH
24108: LD_VAR 0 17
24112: ISECT
24113: ST_TO_ADDR
// if not list then
24114: LD_VAR 0 5
24118: NOT
24119: IFFALSE 24123
// exit ;
24121: GO 24927
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24123: LD_VAR 0 12
24127: PUSH
24128: LD_INT 3
24130: EQUAL
24131: PUSH
24132: LD_INT 49
24134: PUSH
24135: LD_VAR 0 5
24139: IN
24140: AND
24141: PUSH
24142: LD_INT 31
24144: PPUSH
24145: LD_VAR 0 16
24149: PPUSH
24150: CALL_OW 321
24154: PUSH
24155: LD_INT 2
24157: EQUAL
24158: AND
24159: IFFALSE 24219
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24161: LD_INT 22
24163: PUSH
24164: LD_VAR 0 16
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PUSH
24173: LD_INT 35
24175: PUSH
24176: LD_INT 49
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: LD_INT 91
24185: PUSH
24186: LD_VAR 0 1
24190: PUSH
24191: LD_INT 10
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: LIST
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: PPUSH
24204: CALL_OW 69
24208: NOT
24209: IFFALSE 24219
// weapon := ru_time_lapser ;
24211: LD_ADDR_VAR 0 18
24215: PUSH
24216: LD_INT 49
24218: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24219: LD_VAR 0 12
24223: PUSH
24224: LD_INT 1
24226: PUSH
24227: LD_INT 2
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: IN
24234: PUSH
24235: LD_INT 11
24237: PUSH
24238: LD_VAR 0 5
24242: IN
24243: PUSH
24244: LD_INT 30
24246: PUSH
24247: LD_VAR 0 5
24251: IN
24252: OR
24253: AND
24254: PUSH
24255: LD_INT 6
24257: PPUSH
24258: LD_VAR 0 16
24262: PPUSH
24263: CALL_OW 321
24267: PUSH
24268: LD_INT 2
24270: EQUAL
24271: AND
24272: IFFALSE 24437
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24274: LD_INT 22
24276: PUSH
24277: LD_VAR 0 16
24281: PUSH
24282: EMPTY
24283: LIST
24284: LIST
24285: PUSH
24286: LD_INT 2
24288: PUSH
24289: LD_INT 35
24291: PUSH
24292: LD_INT 11
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: PUSH
24299: LD_INT 35
24301: PUSH
24302: LD_INT 30
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PUSH
24309: EMPTY
24310: LIST
24311: LIST
24312: LIST
24313: PUSH
24314: LD_INT 91
24316: PUSH
24317: LD_VAR 0 1
24321: PUSH
24322: LD_INT 18
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: LIST
24329: PUSH
24330: EMPTY
24331: LIST
24332: LIST
24333: LIST
24334: PPUSH
24335: CALL_OW 69
24339: NOT
24340: PUSH
24341: LD_INT 22
24343: PUSH
24344: LD_VAR 0 16
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 2
24355: PUSH
24356: LD_INT 30
24358: PUSH
24359: LD_INT 32
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 30
24368: PUSH
24369: LD_INT 33
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 91
24383: PUSH
24384: LD_VAR 0 1
24388: PUSH
24389: LD_INT 12
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: LIST
24396: PUSH
24397: EMPTY
24398: LIST
24399: LIST
24400: LIST
24401: PUSH
24402: EMPTY
24403: LIST
24404: PPUSH
24405: CALL_OW 69
24409: PUSH
24410: LD_INT 2
24412: GREATER
24413: AND
24414: IFFALSE 24437
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24416: LD_ADDR_VAR 0 18
24420: PUSH
24421: LD_INT 11
24423: PUSH
24424: LD_INT 30
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_VAR 0 12
24435: ARRAY
24436: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24437: LD_VAR 0 18
24441: NOT
24442: PUSH
24443: LD_INT 40
24445: PPUSH
24446: LD_VAR 0 16
24450: PPUSH
24451: CALL_OW 321
24455: PUSH
24456: LD_INT 2
24458: EQUAL
24459: AND
24460: PUSH
24461: LD_INT 7
24463: PUSH
24464: LD_VAR 0 5
24468: IN
24469: PUSH
24470: LD_INT 28
24472: PUSH
24473: LD_VAR 0 5
24477: IN
24478: OR
24479: PUSH
24480: LD_INT 45
24482: PUSH
24483: LD_VAR 0 5
24487: IN
24488: OR
24489: AND
24490: IFFALSE 24744
// begin hex := GetHexInfo ( x , y ) ;
24492: LD_ADDR_VAR 0 4
24496: PUSH
24497: LD_VAR 0 10
24501: PPUSH
24502: LD_VAR 0 11
24506: PPUSH
24507: CALL_OW 546
24511: ST_TO_ADDR
// if hex [ 1 ] then
24512: LD_VAR 0 4
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: IFFALSE 24524
// exit ;
24522: GO 24927
// height := hex [ 2 ] ;
24524: LD_ADDR_VAR 0 15
24528: PUSH
24529: LD_VAR 0 4
24533: PUSH
24534: LD_INT 2
24536: ARRAY
24537: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24538: LD_ADDR_VAR 0 14
24542: PUSH
24543: LD_INT 0
24545: PUSH
24546: LD_INT 2
24548: PUSH
24549: LD_INT 3
24551: PUSH
24552: LD_INT 5
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: LIST
24560: ST_TO_ADDR
// for i in tmp do
24561: LD_ADDR_VAR 0 8
24565: PUSH
24566: LD_VAR 0 14
24570: PUSH
24571: FOR_IN
24572: IFFALSE 24742
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24574: LD_ADDR_VAR 0 9
24578: PUSH
24579: LD_VAR 0 10
24583: PPUSH
24584: LD_VAR 0 8
24588: PPUSH
24589: LD_INT 5
24591: PPUSH
24592: CALL_OW 272
24596: PUSH
24597: LD_VAR 0 11
24601: PPUSH
24602: LD_VAR 0 8
24606: PPUSH
24607: LD_INT 5
24609: PPUSH
24610: CALL_OW 273
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24619: LD_VAR 0 9
24623: PUSH
24624: LD_INT 1
24626: ARRAY
24627: PPUSH
24628: LD_VAR 0 9
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 488
24641: IFFALSE 24740
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24643: LD_ADDR_VAR 0 4
24647: PUSH
24648: LD_VAR 0 9
24652: PUSH
24653: LD_INT 1
24655: ARRAY
24656: PPUSH
24657: LD_VAR 0 9
24661: PUSH
24662: LD_INT 2
24664: ARRAY
24665: PPUSH
24666: CALL_OW 546
24670: ST_TO_ADDR
// if hex [ 1 ] then
24671: LD_VAR 0 4
24675: PUSH
24676: LD_INT 1
24678: ARRAY
24679: IFFALSE 24683
// continue ;
24681: GO 24571
// h := hex [ 2 ] ;
24683: LD_ADDR_VAR 0 13
24687: PUSH
24688: LD_VAR 0 4
24692: PUSH
24693: LD_INT 2
24695: ARRAY
24696: ST_TO_ADDR
// if h + 7 < height then
24697: LD_VAR 0 13
24701: PUSH
24702: LD_INT 7
24704: PLUS
24705: PUSH
24706: LD_VAR 0 15
24710: LESS
24711: IFFALSE 24740
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24713: LD_ADDR_VAR 0 18
24717: PUSH
24718: LD_INT 7
24720: PUSH
24721: LD_INT 28
24723: PUSH
24724: LD_INT 45
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: LIST
24731: PUSH
24732: LD_VAR 0 12
24736: ARRAY
24737: ST_TO_ADDR
// break ;
24738: GO 24742
// end ; end ; end ;
24740: GO 24571
24742: POP
24743: POP
// end ; if not weapon then
24744: LD_VAR 0 18
24748: NOT
24749: IFFALSE 24809
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24751: LD_ADDR_VAR 0 5
24755: PUSH
24756: LD_VAR 0 5
24760: PUSH
24761: LD_INT 11
24763: PUSH
24764: LD_INT 30
24766: PUSH
24767: LD_INT 49
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: LIST
24774: DIFF
24775: ST_TO_ADDR
// if not list then
24776: LD_VAR 0 5
24780: NOT
24781: IFFALSE 24785
// exit ;
24783: GO 24927
// weapon := list [ rand ( 1 , list ) ] ;
24785: LD_ADDR_VAR 0 18
24789: PUSH
24790: LD_VAR 0 5
24794: PUSH
24795: LD_INT 1
24797: PPUSH
24798: LD_VAR 0 5
24802: PPUSH
24803: CALL_OW 12
24807: ARRAY
24808: ST_TO_ADDR
// end ; if weapon then
24809: LD_VAR 0 18
24813: IFFALSE 24927
// begin tmp := CostOfWeapon ( weapon ) ;
24815: LD_ADDR_VAR 0 14
24819: PUSH
24820: LD_VAR 0 18
24824: PPUSH
24825: CALL_OW 451
24829: ST_TO_ADDR
// j := GetBase ( tower ) ;
24830: LD_ADDR_VAR 0 9
24834: PUSH
24835: LD_VAR 0 1
24839: PPUSH
24840: CALL_OW 274
24844: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24845: LD_VAR 0 9
24849: PPUSH
24850: LD_INT 1
24852: PPUSH
24853: CALL_OW 275
24857: PUSH
24858: LD_VAR 0 14
24862: PUSH
24863: LD_INT 1
24865: ARRAY
24866: GREATEREQUAL
24867: PUSH
24868: LD_VAR 0 9
24872: PPUSH
24873: LD_INT 2
24875: PPUSH
24876: CALL_OW 275
24880: PUSH
24881: LD_VAR 0 14
24885: PUSH
24886: LD_INT 2
24888: ARRAY
24889: GREATEREQUAL
24890: AND
24891: PUSH
24892: LD_VAR 0 9
24896: PPUSH
24897: LD_INT 3
24899: PPUSH
24900: CALL_OW 275
24904: PUSH
24905: LD_VAR 0 14
24909: PUSH
24910: LD_INT 3
24912: ARRAY
24913: GREATEREQUAL
24914: AND
24915: IFFALSE 24927
// result := weapon ;
24917: LD_ADDR_VAR 0 3
24921: PUSH
24922: LD_VAR 0 18
24926: ST_TO_ADDR
// end ; end ;
24927: LD_VAR 0 3
24931: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24932: LD_INT 0
24934: PPUSH
24935: PPUSH
// result := true ;
24936: LD_ADDR_VAR 0 3
24940: PUSH
24941: LD_INT 1
24943: ST_TO_ADDR
// if array1 = array2 then
24944: LD_VAR 0 1
24948: PUSH
24949: LD_VAR 0 2
24953: EQUAL
24954: IFFALSE 25014
// begin for i = 1 to array1 do
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: DOUBLE
24962: LD_INT 1
24964: DEC
24965: ST_TO_ADDR
24966: LD_VAR 0 1
24970: PUSH
24971: FOR_TO
24972: IFFALSE 25010
// if array1 [ i ] <> array2 [ i ] then
24974: LD_VAR 0 1
24978: PUSH
24979: LD_VAR 0 4
24983: ARRAY
24984: PUSH
24985: LD_VAR 0 2
24989: PUSH
24990: LD_VAR 0 4
24994: ARRAY
24995: NONEQUAL
24996: IFFALSE 25008
// begin result := false ;
24998: LD_ADDR_VAR 0 3
25002: PUSH
25003: LD_INT 0
25005: ST_TO_ADDR
// break ;
25006: GO 25010
// end ;
25008: GO 24971
25010: POP
25011: POP
// end else
25012: GO 25022
// result := false ;
25014: LD_ADDR_VAR 0 3
25018: PUSH
25019: LD_INT 0
25021: ST_TO_ADDR
// end ;
25022: LD_VAR 0 3
25026: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25027: LD_INT 0
25029: PPUSH
25030: PPUSH
// if not array1 or not array2 then
25031: LD_VAR 0 1
25035: NOT
25036: PUSH
25037: LD_VAR 0 2
25041: NOT
25042: OR
25043: IFFALSE 25047
// exit ;
25045: GO 25111
// result := true ;
25047: LD_ADDR_VAR 0 3
25051: PUSH
25052: LD_INT 1
25054: ST_TO_ADDR
// for i = 1 to array1 do
25055: LD_ADDR_VAR 0 4
25059: PUSH
25060: DOUBLE
25061: LD_INT 1
25063: DEC
25064: ST_TO_ADDR
25065: LD_VAR 0 1
25069: PUSH
25070: FOR_TO
25071: IFFALSE 25109
// if array1 [ i ] <> array2 [ i ] then
25073: LD_VAR 0 1
25077: PUSH
25078: LD_VAR 0 4
25082: ARRAY
25083: PUSH
25084: LD_VAR 0 2
25088: PUSH
25089: LD_VAR 0 4
25093: ARRAY
25094: NONEQUAL
25095: IFFALSE 25107
// begin result := false ;
25097: LD_ADDR_VAR 0 3
25101: PUSH
25102: LD_INT 0
25104: ST_TO_ADDR
// break ;
25105: GO 25109
// end ;
25107: GO 25070
25109: POP
25110: POP
// end ;
25111: LD_VAR 0 3
25115: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25116: LD_INT 0
25118: PPUSH
25119: PPUSH
25120: PPUSH
// pom := GetBase ( fac ) ;
25121: LD_ADDR_VAR 0 5
25125: PUSH
25126: LD_VAR 0 1
25130: PPUSH
25131: CALL_OW 274
25135: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25136: LD_ADDR_VAR 0 4
25140: PUSH
25141: LD_VAR 0 2
25145: PUSH
25146: LD_INT 1
25148: ARRAY
25149: PPUSH
25150: LD_VAR 0 2
25154: PUSH
25155: LD_INT 2
25157: ARRAY
25158: PPUSH
25159: LD_VAR 0 2
25163: PUSH
25164: LD_INT 3
25166: ARRAY
25167: PPUSH
25168: LD_VAR 0 2
25172: PUSH
25173: LD_INT 4
25175: ARRAY
25176: PPUSH
25177: CALL_OW 449
25181: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25182: LD_ADDR_VAR 0 3
25186: PUSH
25187: LD_VAR 0 5
25191: PPUSH
25192: LD_INT 1
25194: PPUSH
25195: CALL_OW 275
25199: PUSH
25200: LD_VAR 0 4
25204: PUSH
25205: LD_INT 1
25207: ARRAY
25208: GREATEREQUAL
25209: PUSH
25210: LD_VAR 0 5
25214: PPUSH
25215: LD_INT 2
25217: PPUSH
25218: CALL_OW 275
25222: PUSH
25223: LD_VAR 0 4
25227: PUSH
25228: LD_INT 2
25230: ARRAY
25231: GREATEREQUAL
25232: AND
25233: PUSH
25234: LD_VAR 0 5
25238: PPUSH
25239: LD_INT 3
25241: PPUSH
25242: CALL_OW 275
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_INT 3
25254: ARRAY
25255: GREATEREQUAL
25256: AND
25257: ST_TO_ADDR
// end ;
25258: LD_VAR 0 3
25262: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25263: LD_INT 0
25265: PPUSH
25266: PPUSH
25267: PPUSH
25268: PPUSH
// pom := GetBase ( building ) ;
25269: LD_ADDR_VAR 0 3
25273: PUSH
25274: LD_VAR 0 1
25278: PPUSH
25279: CALL_OW 274
25283: ST_TO_ADDR
// if not pom then
25284: LD_VAR 0 3
25288: NOT
25289: IFFALSE 25293
// exit ;
25291: GO 25463
// btype := GetBType ( building ) ;
25293: LD_ADDR_VAR 0 5
25297: PUSH
25298: LD_VAR 0 1
25302: PPUSH
25303: CALL_OW 266
25307: ST_TO_ADDR
// if btype = b_armoury then
25308: LD_VAR 0 5
25312: PUSH
25313: LD_INT 4
25315: EQUAL
25316: IFFALSE 25326
// btype := b_barracks ;
25318: LD_ADDR_VAR 0 5
25322: PUSH
25323: LD_INT 5
25325: ST_TO_ADDR
// if btype = b_depot then
25326: LD_VAR 0 5
25330: PUSH
25331: LD_INT 0
25333: EQUAL
25334: IFFALSE 25344
// btype := b_warehouse ;
25336: LD_ADDR_VAR 0 5
25340: PUSH
25341: LD_INT 1
25343: ST_TO_ADDR
// if btype = b_workshop then
25344: LD_VAR 0 5
25348: PUSH
25349: LD_INT 2
25351: EQUAL
25352: IFFALSE 25362
// btype := b_factory ;
25354: LD_ADDR_VAR 0 5
25358: PUSH
25359: LD_INT 3
25361: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25362: LD_ADDR_VAR 0 4
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_VAR 0 1
25376: PPUSH
25377: CALL_OW 248
25381: PPUSH
25382: CALL_OW 450
25386: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25387: LD_ADDR_VAR 0 2
25391: PUSH
25392: LD_VAR 0 3
25396: PPUSH
25397: LD_INT 1
25399: PPUSH
25400: CALL_OW 275
25404: PUSH
25405: LD_VAR 0 4
25409: PUSH
25410: LD_INT 1
25412: ARRAY
25413: GREATEREQUAL
25414: PUSH
25415: LD_VAR 0 3
25419: PPUSH
25420: LD_INT 2
25422: PPUSH
25423: CALL_OW 275
25427: PUSH
25428: LD_VAR 0 4
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: GREATEREQUAL
25437: AND
25438: PUSH
25439: LD_VAR 0 3
25443: PPUSH
25444: LD_INT 3
25446: PPUSH
25447: CALL_OW 275
25451: PUSH
25452: LD_VAR 0 4
25456: PUSH
25457: LD_INT 3
25459: ARRAY
25460: GREATEREQUAL
25461: AND
25462: ST_TO_ADDR
// end ;
25463: LD_VAR 0 2
25467: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25468: LD_INT 0
25470: PPUSH
25471: PPUSH
25472: PPUSH
// pom := GetBase ( building ) ;
25473: LD_ADDR_VAR 0 4
25477: PUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: CALL_OW 274
25487: ST_TO_ADDR
// if not pom then
25488: LD_VAR 0 4
25492: NOT
25493: IFFALSE 25497
// exit ;
25495: GO 25598
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25497: LD_ADDR_VAR 0 5
25501: PUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 1
25511: PPUSH
25512: CALL_OW 248
25516: PPUSH
25517: CALL_OW 450
25521: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25522: LD_ADDR_VAR 0 3
25526: PUSH
25527: LD_VAR 0 4
25531: PPUSH
25532: LD_INT 1
25534: PPUSH
25535: CALL_OW 275
25539: PUSH
25540: LD_VAR 0 5
25544: PUSH
25545: LD_INT 1
25547: ARRAY
25548: GREATEREQUAL
25549: PUSH
25550: LD_VAR 0 4
25554: PPUSH
25555: LD_INT 2
25557: PPUSH
25558: CALL_OW 275
25562: PUSH
25563: LD_VAR 0 5
25567: PUSH
25568: LD_INT 2
25570: ARRAY
25571: GREATEREQUAL
25572: AND
25573: PUSH
25574: LD_VAR 0 4
25578: PPUSH
25579: LD_INT 3
25581: PPUSH
25582: CALL_OW 275
25586: PUSH
25587: LD_VAR 0 5
25591: PUSH
25592: LD_INT 3
25594: ARRAY
25595: GREATEREQUAL
25596: AND
25597: ST_TO_ADDR
// end ;
25598: LD_VAR 0 3
25602: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25603: LD_INT 0
25605: PPUSH
25606: PPUSH
25607: PPUSH
25608: PPUSH
25609: PPUSH
25610: PPUSH
25611: PPUSH
25612: PPUSH
25613: PPUSH
25614: PPUSH
25615: PPUSH
// result := false ;
25616: LD_ADDR_VAR 0 8
25620: PUSH
25621: LD_INT 0
25623: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25624: LD_VAR 0 5
25628: NOT
25629: PUSH
25630: LD_VAR 0 1
25634: NOT
25635: OR
25636: PUSH
25637: LD_VAR 0 2
25641: NOT
25642: OR
25643: PUSH
25644: LD_VAR 0 3
25648: NOT
25649: OR
25650: IFFALSE 25654
// exit ;
25652: GO 26468
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25654: LD_ADDR_VAR 0 14
25658: PUSH
25659: LD_VAR 0 1
25663: PPUSH
25664: LD_VAR 0 2
25668: PPUSH
25669: LD_VAR 0 3
25673: PPUSH
25674: LD_VAR 0 4
25678: PPUSH
25679: LD_VAR 0 5
25683: PUSH
25684: LD_INT 1
25686: ARRAY
25687: PPUSH
25688: CALL_OW 248
25692: PPUSH
25693: LD_INT 0
25695: PPUSH
25696: CALL 27705 0 6
25700: ST_TO_ADDR
// if not hexes then
25701: LD_VAR 0 14
25705: NOT
25706: IFFALSE 25710
// exit ;
25708: GO 26468
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25710: LD_ADDR_VAR 0 17
25714: PUSH
25715: LD_VAR 0 5
25719: PPUSH
25720: LD_INT 22
25722: PUSH
25723: LD_VAR 0 13
25727: PPUSH
25728: CALL_OW 255
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: PUSH
25737: LD_INT 2
25739: PUSH
25740: LD_INT 30
25742: PUSH
25743: LD_INT 0
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 30
25752: PUSH
25753: LD_INT 1
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: LIST
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PPUSH
25769: CALL_OW 72
25773: ST_TO_ADDR
// for i = 1 to hexes do
25774: LD_ADDR_VAR 0 9
25778: PUSH
25779: DOUBLE
25780: LD_INT 1
25782: DEC
25783: ST_TO_ADDR
25784: LD_VAR 0 14
25788: PUSH
25789: FOR_TO
25790: IFFALSE 26466
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25792: LD_ADDR_VAR 0 13
25796: PUSH
25797: LD_VAR 0 14
25801: PUSH
25802: LD_VAR 0 9
25806: ARRAY
25807: PUSH
25808: LD_INT 1
25810: ARRAY
25811: PPUSH
25812: LD_VAR 0 14
25816: PUSH
25817: LD_VAR 0 9
25821: ARRAY
25822: PUSH
25823: LD_INT 2
25825: ARRAY
25826: PPUSH
25827: CALL_OW 428
25831: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25832: LD_VAR 0 14
25836: PUSH
25837: LD_VAR 0 9
25841: ARRAY
25842: PUSH
25843: LD_INT 1
25845: ARRAY
25846: PPUSH
25847: LD_VAR 0 14
25851: PUSH
25852: LD_VAR 0 9
25856: ARRAY
25857: PUSH
25858: LD_INT 2
25860: ARRAY
25861: PPUSH
25862: CALL_OW 351
25866: PUSH
25867: LD_VAR 0 14
25871: PUSH
25872: LD_VAR 0 9
25876: ARRAY
25877: PUSH
25878: LD_INT 1
25880: ARRAY
25881: PPUSH
25882: LD_VAR 0 14
25886: PUSH
25887: LD_VAR 0 9
25891: ARRAY
25892: PUSH
25893: LD_INT 2
25895: ARRAY
25896: PPUSH
25897: CALL_OW 488
25901: NOT
25902: OR
25903: PUSH
25904: LD_VAR 0 13
25908: PPUSH
25909: CALL_OW 247
25913: PUSH
25914: LD_INT 3
25916: EQUAL
25917: OR
25918: IFFALSE 25924
// exit ;
25920: POP
25921: POP
25922: GO 26468
// if not tmp then
25924: LD_VAR 0 13
25928: NOT
25929: IFFALSE 25933
// continue ;
25931: GO 25789
// result := true ;
25933: LD_ADDR_VAR 0 8
25937: PUSH
25938: LD_INT 1
25940: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25941: LD_VAR 0 6
25945: PUSH
25946: LD_VAR 0 13
25950: PPUSH
25951: CALL_OW 247
25955: PUSH
25956: LD_INT 2
25958: EQUAL
25959: AND
25960: PUSH
25961: LD_VAR 0 13
25965: PPUSH
25966: CALL_OW 263
25970: PUSH
25971: LD_INT 1
25973: EQUAL
25974: AND
25975: IFFALSE 26139
// begin if IsDrivenBy ( tmp ) then
25977: LD_VAR 0 13
25981: PPUSH
25982: CALL_OW 311
25986: IFFALSE 25990
// continue ;
25988: GO 25789
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25990: LD_VAR 0 6
25994: PPUSH
25995: LD_INT 3
25997: PUSH
25998: LD_INT 60
26000: PUSH
26001: EMPTY
26002: LIST
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 3
26010: PUSH
26011: LD_INT 55
26013: PUSH
26014: EMPTY
26015: LIST
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: EMPTY
26022: LIST
26023: LIST
26024: PPUSH
26025: CALL_OW 72
26029: IFFALSE 26137
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26031: LD_ADDR_VAR 0 18
26035: PUSH
26036: LD_VAR 0 6
26040: PPUSH
26041: LD_INT 3
26043: PUSH
26044: LD_INT 60
26046: PUSH
26047: EMPTY
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PUSH
26054: LD_INT 3
26056: PUSH
26057: LD_INT 55
26059: PUSH
26060: EMPTY
26061: LIST
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: PPUSH
26071: CALL_OW 72
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// if IsInUnit ( driver ) then
26080: LD_VAR 0 18
26084: PPUSH
26085: CALL_OW 310
26089: IFFALSE 26100
// ComExit ( driver ) ;
26091: LD_VAR 0 18
26095: PPUSH
26096: CALL 51393 0 1
// AddComEnterUnit ( driver , tmp ) ;
26100: LD_VAR 0 18
26104: PPUSH
26105: LD_VAR 0 13
26109: PPUSH
26110: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
26114: LD_VAR 0 18
26118: PPUSH
26119: LD_VAR 0 7
26123: PPUSH
26124: CALL_OW 173
// AddComExitVehicle ( driver ) ;
26128: LD_VAR 0 18
26132: PPUSH
26133: CALL_OW 181
// end ; continue ;
26137: GO 25789
// end ; if not cleaners or not tmp in cleaners then
26139: LD_VAR 0 6
26143: NOT
26144: PUSH
26145: LD_VAR 0 13
26149: PUSH
26150: LD_VAR 0 6
26154: IN
26155: NOT
26156: OR
26157: IFFALSE 26464
// begin if dep then
26159: LD_VAR 0 17
26163: IFFALSE 26299
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26165: LD_ADDR_VAR 0 16
26169: PUSH
26170: LD_VAR 0 17
26174: PUSH
26175: LD_INT 1
26177: ARRAY
26178: PPUSH
26179: CALL_OW 250
26183: PPUSH
26184: LD_VAR 0 17
26188: PUSH
26189: LD_INT 1
26191: ARRAY
26192: PPUSH
26193: CALL_OW 254
26197: PPUSH
26198: LD_INT 5
26200: PPUSH
26201: CALL_OW 272
26205: PUSH
26206: LD_VAR 0 17
26210: PUSH
26211: LD_INT 1
26213: ARRAY
26214: PPUSH
26215: CALL_OW 251
26219: PPUSH
26220: LD_VAR 0 17
26224: PUSH
26225: LD_INT 1
26227: ARRAY
26228: PPUSH
26229: CALL_OW 254
26233: PPUSH
26234: LD_INT 5
26236: PPUSH
26237: CALL_OW 273
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26246: LD_VAR 0 16
26250: PUSH
26251: LD_INT 1
26253: ARRAY
26254: PPUSH
26255: LD_VAR 0 16
26259: PUSH
26260: LD_INT 2
26262: ARRAY
26263: PPUSH
26264: CALL_OW 488
26268: IFFALSE 26299
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26270: LD_VAR 0 13
26274: PPUSH
26275: LD_VAR 0 16
26279: PUSH
26280: LD_INT 1
26282: ARRAY
26283: PPUSH
26284: LD_VAR 0 16
26288: PUSH
26289: LD_INT 2
26291: ARRAY
26292: PPUSH
26293: CALL_OW 111
// continue ;
26297: GO 25789
// end ; end ; r := GetDir ( tmp ) ;
26299: LD_ADDR_VAR 0 15
26303: PUSH
26304: LD_VAR 0 13
26308: PPUSH
26309: CALL_OW 254
26313: ST_TO_ADDR
// if r = 5 then
26314: LD_VAR 0 15
26318: PUSH
26319: LD_INT 5
26321: EQUAL
26322: IFFALSE 26332
// r := 0 ;
26324: LD_ADDR_VAR 0 15
26328: PUSH
26329: LD_INT 0
26331: ST_TO_ADDR
// for j = r to 5 do
26332: LD_ADDR_VAR 0 10
26336: PUSH
26337: DOUBLE
26338: LD_VAR 0 15
26342: DEC
26343: ST_TO_ADDR
26344: LD_INT 5
26346: PUSH
26347: FOR_TO
26348: IFFALSE 26462
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26350: LD_ADDR_VAR 0 11
26354: PUSH
26355: LD_VAR 0 13
26359: PPUSH
26360: CALL_OW 250
26364: PPUSH
26365: LD_VAR 0 10
26369: PPUSH
26370: LD_INT 2
26372: PPUSH
26373: CALL_OW 272
26377: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26378: LD_ADDR_VAR 0 12
26382: PUSH
26383: LD_VAR 0 13
26387: PPUSH
26388: CALL_OW 251
26392: PPUSH
26393: LD_VAR 0 10
26397: PPUSH
26398: LD_INT 2
26400: PPUSH
26401: CALL_OW 273
26405: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26406: LD_VAR 0 11
26410: PPUSH
26411: LD_VAR 0 12
26415: PPUSH
26416: CALL_OW 488
26420: PUSH
26421: LD_VAR 0 11
26425: PPUSH
26426: LD_VAR 0 12
26430: PPUSH
26431: CALL_OW 428
26435: NOT
26436: AND
26437: IFFALSE 26460
// begin ComMoveXY ( tmp , _x , _y ) ;
26439: LD_VAR 0 13
26443: PPUSH
26444: LD_VAR 0 11
26448: PPUSH
26449: LD_VAR 0 12
26453: PPUSH
26454: CALL_OW 111
// break ;
26458: GO 26462
// end ; end ;
26460: GO 26347
26462: POP
26463: POP
// end ; end ;
26464: GO 25789
26466: POP
26467: POP
// end ;
26468: LD_VAR 0 8
26472: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26473: LD_INT 0
26475: PPUSH
// result := true ;
26476: LD_ADDR_VAR 0 3
26480: PUSH
26481: LD_INT 1
26483: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26484: LD_VAR 0 2
26488: PUSH
26489: LD_INT 24
26491: DOUBLE
26492: EQUAL
26493: IFTRUE 26503
26495: LD_INT 33
26497: DOUBLE
26498: EQUAL
26499: IFTRUE 26503
26501: GO 26528
26503: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26504: LD_ADDR_VAR 0 3
26508: PUSH
26509: LD_INT 32
26511: PPUSH
26512: LD_VAR 0 1
26516: PPUSH
26517: CALL_OW 321
26521: PUSH
26522: LD_INT 2
26524: EQUAL
26525: ST_TO_ADDR
26526: GO 26848
26528: LD_INT 20
26530: DOUBLE
26531: EQUAL
26532: IFTRUE 26536
26534: GO 26561
26536: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26537: LD_ADDR_VAR 0 3
26541: PUSH
26542: LD_INT 6
26544: PPUSH
26545: LD_VAR 0 1
26549: PPUSH
26550: CALL_OW 321
26554: PUSH
26555: LD_INT 2
26557: EQUAL
26558: ST_TO_ADDR
26559: GO 26848
26561: LD_INT 22
26563: DOUBLE
26564: EQUAL
26565: IFTRUE 26575
26567: LD_INT 36
26569: DOUBLE
26570: EQUAL
26571: IFTRUE 26575
26573: GO 26600
26575: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26576: LD_ADDR_VAR 0 3
26580: PUSH
26581: LD_INT 15
26583: PPUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: CALL_OW 321
26593: PUSH
26594: LD_INT 2
26596: EQUAL
26597: ST_TO_ADDR
26598: GO 26848
26600: LD_INT 30
26602: DOUBLE
26603: EQUAL
26604: IFTRUE 26608
26606: GO 26633
26608: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26609: LD_ADDR_VAR 0 3
26613: PUSH
26614: LD_INT 20
26616: PPUSH
26617: LD_VAR 0 1
26621: PPUSH
26622: CALL_OW 321
26626: PUSH
26627: LD_INT 2
26629: EQUAL
26630: ST_TO_ADDR
26631: GO 26848
26633: LD_INT 28
26635: DOUBLE
26636: EQUAL
26637: IFTRUE 26647
26639: LD_INT 21
26641: DOUBLE
26642: EQUAL
26643: IFTRUE 26647
26645: GO 26672
26647: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26648: LD_ADDR_VAR 0 3
26652: PUSH
26653: LD_INT 21
26655: PPUSH
26656: LD_VAR 0 1
26660: PPUSH
26661: CALL_OW 321
26665: PUSH
26666: LD_INT 2
26668: EQUAL
26669: ST_TO_ADDR
26670: GO 26848
26672: LD_INT 16
26674: DOUBLE
26675: EQUAL
26676: IFTRUE 26680
26678: GO 26707
26680: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: LD_EXP 61
26690: PPUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: CALL_OW 321
26700: PUSH
26701: LD_INT 2
26703: EQUAL
26704: ST_TO_ADDR
26705: GO 26848
26707: LD_INT 19
26709: DOUBLE
26710: EQUAL
26711: IFTRUE 26721
26713: LD_INT 23
26715: DOUBLE
26716: EQUAL
26717: IFTRUE 26721
26719: GO 26748
26721: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26722: LD_ADDR_VAR 0 3
26726: PUSH
26727: LD_EXP 60
26731: PPUSH
26732: LD_VAR 0 1
26736: PPUSH
26737: CALL_OW 321
26741: PUSH
26742: LD_INT 2
26744: EQUAL
26745: ST_TO_ADDR
26746: GO 26848
26748: LD_INT 17
26750: DOUBLE
26751: EQUAL
26752: IFTRUE 26756
26754: GO 26781
26756: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26757: LD_ADDR_VAR 0 3
26761: PUSH
26762: LD_INT 39
26764: PPUSH
26765: LD_VAR 0 1
26769: PPUSH
26770: CALL_OW 321
26774: PUSH
26775: LD_INT 2
26777: EQUAL
26778: ST_TO_ADDR
26779: GO 26848
26781: LD_INT 18
26783: DOUBLE
26784: EQUAL
26785: IFTRUE 26789
26787: GO 26814
26789: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26790: LD_ADDR_VAR 0 3
26794: PUSH
26795: LD_INT 40
26797: PPUSH
26798: LD_VAR 0 1
26802: PPUSH
26803: CALL_OW 321
26807: PUSH
26808: LD_INT 2
26810: EQUAL
26811: ST_TO_ADDR
26812: GO 26848
26814: LD_INT 27
26816: DOUBLE
26817: EQUAL
26818: IFTRUE 26822
26820: GO 26847
26822: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26823: LD_ADDR_VAR 0 3
26827: PUSH
26828: LD_INT 35
26830: PPUSH
26831: LD_VAR 0 1
26835: PPUSH
26836: CALL_OW 321
26840: PUSH
26841: LD_INT 2
26843: EQUAL
26844: ST_TO_ADDR
26845: GO 26848
26847: POP
// end ;
26848: LD_VAR 0 3
26852: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26853: LD_INT 0
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
// result := false ;
26866: LD_ADDR_VAR 0 6
26870: PUSH
26871: LD_INT 0
26873: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26874: LD_VAR 0 1
26878: NOT
26879: PUSH
26880: LD_VAR 0 1
26884: PPUSH
26885: CALL_OW 266
26889: PUSH
26890: LD_INT 0
26892: PUSH
26893: LD_INT 1
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: IN
26900: NOT
26901: OR
26902: PUSH
26903: LD_VAR 0 2
26907: NOT
26908: OR
26909: PUSH
26910: LD_VAR 0 5
26914: PUSH
26915: LD_INT 0
26917: PUSH
26918: LD_INT 1
26920: PUSH
26921: LD_INT 2
26923: PUSH
26924: LD_INT 3
26926: PUSH
26927: LD_INT 4
26929: PUSH
26930: LD_INT 5
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: IN
26941: NOT
26942: OR
26943: PUSH
26944: LD_VAR 0 3
26948: PPUSH
26949: LD_VAR 0 4
26953: PPUSH
26954: CALL_OW 488
26958: NOT
26959: OR
26960: IFFALSE 26964
// exit ;
26962: GO 27700
// side := GetSide ( depot ) ;
26964: LD_ADDR_VAR 0 9
26968: PUSH
26969: LD_VAR 0 1
26973: PPUSH
26974: CALL_OW 255
26978: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26979: LD_VAR 0 9
26983: PPUSH
26984: LD_VAR 0 2
26988: PPUSH
26989: CALL 26473 0 2
26993: NOT
26994: IFFALSE 26998
// exit ;
26996: GO 27700
// pom := GetBase ( depot ) ;
26998: LD_ADDR_VAR 0 10
27002: PUSH
27003: LD_VAR 0 1
27007: PPUSH
27008: CALL_OW 274
27012: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27013: LD_ADDR_VAR 0 11
27017: PUSH
27018: LD_VAR 0 2
27022: PPUSH
27023: LD_VAR 0 1
27027: PPUSH
27028: CALL_OW 248
27032: PPUSH
27033: CALL_OW 450
27037: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27038: LD_VAR 0 10
27042: PPUSH
27043: LD_INT 1
27045: PPUSH
27046: CALL_OW 275
27050: PUSH
27051: LD_VAR 0 11
27055: PUSH
27056: LD_INT 1
27058: ARRAY
27059: GREATEREQUAL
27060: PUSH
27061: LD_VAR 0 10
27065: PPUSH
27066: LD_INT 2
27068: PPUSH
27069: CALL_OW 275
27073: PUSH
27074: LD_VAR 0 11
27078: PUSH
27079: LD_INT 2
27081: ARRAY
27082: GREATEREQUAL
27083: AND
27084: PUSH
27085: LD_VAR 0 10
27089: PPUSH
27090: LD_INT 3
27092: PPUSH
27093: CALL_OW 275
27097: PUSH
27098: LD_VAR 0 11
27102: PUSH
27103: LD_INT 3
27105: ARRAY
27106: GREATEREQUAL
27107: AND
27108: NOT
27109: IFFALSE 27113
// exit ;
27111: GO 27700
// if GetBType ( depot ) = b_depot then
27113: LD_VAR 0 1
27117: PPUSH
27118: CALL_OW 266
27122: PUSH
27123: LD_INT 0
27125: EQUAL
27126: IFFALSE 27138
// dist := 28 else
27128: LD_ADDR_VAR 0 14
27132: PUSH
27133: LD_INT 28
27135: ST_TO_ADDR
27136: GO 27146
// dist := 36 ;
27138: LD_ADDR_VAR 0 14
27142: PUSH
27143: LD_INT 36
27145: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27146: LD_VAR 0 1
27150: PPUSH
27151: LD_VAR 0 3
27155: PPUSH
27156: LD_VAR 0 4
27160: PPUSH
27161: CALL_OW 297
27165: PUSH
27166: LD_VAR 0 14
27170: GREATER
27171: IFFALSE 27175
// exit ;
27173: GO 27700
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27175: LD_ADDR_VAR 0 12
27179: PUSH
27180: LD_VAR 0 2
27184: PPUSH
27185: LD_VAR 0 3
27189: PPUSH
27190: LD_VAR 0 4
27194: PPUSH
27195: LD_VAR 0 5
27199: PPUSH
27200: LD_VAR 0 1
27204: PPUSH
27205: CALL_OW 248
27209: PPUSH
27210: LD_INT 0
27212: PPUSH
27213: CALL 27705 0 6
27217: ST_TO_ADDR
// if not hexes then
27218: LD_VAR 0 12
27222: NOT
27223: IFFALSE 27227
// exit ;
27225: GO 27700
// hex := GetHexInfo ( x , y ) ;
27227: LD_ADDR_VAR 0 15
27231: PUSH
27232: LD_VAR 0 3
27236: PPUSH
27237: LD_VAR 0 4
27241: PPUSH
27242: CALL_OW 546
27246: ST_TO_ADDR
// if hex [ 1 ] then
27247: LD_VAR 0 15
27251: PUSH
27252: LD_INT 1
27254: ARRAY
27255: IFFALSE 27259
// exit ;
27257: GO 27700
// height := hex [ 2 ] ;
27259: LD_ADDR_VAR 0 13
27263: PUSH
27264: LD_VAR 0 15
27268: PUSH
27269: LD_INT 2
27271: ARRAY
27272: ST_TO_ADDR
// for i = 1 to hexes do
27273: LD_ADDR_VAR 0 7
27277: PUSH
27278: DOUBLE
27279: LD_INT 1
27281: DEC
27282: ST_TO_ADDR
27283: LD_VAR 0 12
27287: PUSH
27288: FOR_TO
27289: IFFALSE 27619
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27291: LD_VAR 0 12
27295: PUSH
27296: LD_VAR 0 7
27300: ARRAY
27301: PUSH
27302: LD_INT 1
27304: ARRAY
27305: PPUSH
27306: LD_VAR 0 12
27310: PUSH
27311: LD_VAR 0 7
27315: ARRAY
27316: PUSH
27317: LD_INT 2
27319: ARRAY
27320: PPUSH
27321: CALL_OW 488
27325: NOT
27326: PUSH
27327: LD_VAR 0 12
27331: PUSH
27332: LD_VAR 0 7
27336: ARRAY
27337: PUSH
27338: LD_INT 1
27340: ARRAY
27341: PPUSH
27342: LD_VAR 0 12
27346: PUSH
27347: LD_VAR 0 7
27351: ARRAY
27352: PUSH
27353: LD_INT 2
27355: ARRAY
27356: PPUSH
27357: CALL_OW 428
27361: PUSH
27362: LD_INT 0
27364: GREATER
27365: OR
27366: PUSH
27367: LD_VAR 0 12
27371: PUSH
27372: LD_VAR 0 7
27376: ARRAY
27377: PUSH
27378: LD_INT 1
27380: ARRAY
27381: PPUSH
27382: LD_VAR 0 12
27386: PUSH
27387: LD_VAR 0 7
27391: ARRAY
27392: PUSH
27393: LD_INT 2
27395: ARRAY
27396: PPUSH
27397: CALL_OW 351
27401: OR
27402: IFFALSE 27408
// exit ;
27404: POP
27405: POP
27406: GO 27700
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27408: LD_ADDR_VAR 0 8
27412: PUSH
27413: LD_VAR 0 12
27417: PUSH
27418: LD_VAR 0 7
27422: ARRAY
27423: PUSH
27424: LD_INT 1
27426: ARRAY
27427: PPUSH
27428: LD_VAR 0 12
27432: PUSH
27433: LD_VAR 0 7
27437: ARRAY
27438: PUSH
27439: LD_INT 2
27441: ARRAY
27442: PPUSH
27443: CALL_OW 546
27447: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27448: LD_VAR 0 8
27452: PUSH
27453: LD_INT 1
27455: ARRAY
27456: PUSH
27457: LD_VAR 0 8
27461: PUSH
27462: LD_INT 2
27464: ARRAY
27465: PUSH
27466: LD_VAR 0 13
27470: PUSH
27471: LD_INT 2
27473: PLUS
27474: GREATER
27475: OR
27476: PUSH
27477: LD_VAR 0 8
27481: PUSH
27482: LD_INT 2
27484: ARRAY
27485: PUSH
27486: LD_VAR 0 13
27490: PUSH
27491: LD_INT 2
27493: MINUS
27494: LESS
27495: OR
27496: PUSH
27497: LD_VAR 0 8
27501: PUSH
27502: LD_INT 3
27504: ARRAY
27505: PUSH
27506: LD_INT 0
27508: PUSH
27509: LD_INT 8
27511: PUSH
27512: LD_INT 9
27514: PUSH
27515: LD_INT 10
27517: PUSH
27518: LD_INT 11
27520: PUSH
27521: LD_INT 12
27523: PUSH
27524: LD_INT 13
27526: PUSH
27527: LD_INT 16
27529: PUSH
27530: LD_INT 17
27532: PUSH
27533: LD_INT 18
27535: PUSH
27536: LD_INT 19
27538: PUSH
27539: LD_INT 20
27541: PUSH
27542: LD_INT 21
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: LIST
27559: IN
27560: NOT
27561: OR
27562: PUSH
27563: LD_VAR 0 8
27567: PUSH
27568: LD_INT 5
27570: ARRAY
27571: NOT
27572: OR
27573: PUSH
27574: LD_VAR 0 8
27578: PUSH
27579: LD_INT 6
27581: ARRAY
27582: PUSH
27583: LD_INT 1
27585: PUSH
27586: LD_INT 2
27588: PUSH
27589: LD_INT 7
27591: PUSH
27592: LD_INT 9
27594: PUSH
27595: LD_INT 10
27597: PUSH
27598: LD_INT 11
27600: PUSH
27601: EMPTY
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: IN
27609: NOT
27610: OR
27611: IFFALSE 27617
// exit ;
27613: POP
27614: POP
27615: GO 27700
// end ;
27617: GO 27288
27619: POP
27620: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27621: LD_VAR 0 9
27625: PPUSH
27626: LD_VAR 0 3
27630: PPUSH
27631: LD_VAR 0 4
27635: PPUSH
27636: LD_INT 20
27638: PPUSH
27639: CALL 19646 0 4
27643: PUSH
27644: LD_INT 4
27646: ARRAY
27647: IFFALSE 27651
// exit ;
27649: GO 27700
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27651: LD_VAR 0 2
27655: PUSH
27656: LD_INT 29
27658: PUSH
27659: LD_INT 30
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: IN
27666: PUSH
27667: LD_VAR 0 3
27671: PPUSH
27672: LD_VAR 0 4
27676: PPUSH
27677: LD_VAR 0 9
27681: PPUSH
27682: CALL_OW 440
27686: NOT
27687: AND
27688: IFFALSE 27692
// exit ;
27690: GO 27700
// result := true ;
27692: LD_ADDR_VAR 0 6
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ;
27700: LD_VAR 0 6
27704: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27705: LD_INT 0
27707: PPUSH
27708: PPUSH
27709: PPUSH
27710: PPUSH
27711: PPUSH
27712: PPUSH
27713: PPUSH
27714: PPUSH
27715: PPUSH
27716: PPUSH
27717: PPUSH
27718: PPUSH
27719: PPUSH
27720: PPUSH
27721: PPUSH
27722: PPUSH
27723: PPUSH
27724: PPUSH
27725: PPUSH
27726: PPUSH
27727: PPUSH
27728: PPUSH
27729: PPUSH
27730: PPUSH
27731: PPUSH
27732: PPUSH
27733: PPUSH
27734: PPUSH
27735: PPUSH
27736: PPUSH
27737: PPUSH
27738: PPUSH
27739: PPUSH
27740: PPUSH
27741: PPUSH
27742: PPUSH
27743: PPUSH
27744: PPUSH
27745: PPUSH
27746: PPUSH
27747: PPUSH
27748: PPUSH
27749: PPUSH
27750: PPUSH
27751: PPUSH
27752: PPUSH
27753: PPUSH
27754: PPUSH
27755: PPUSH
27756: PPUSH
27757: PPUSH
27758: PPUSH
27759: PPUSH
27760: PPUSH
27761: PPUSH
27762: PPUSH
27763: PPUSH
27764: PPUSH
// result = [ ] ;
27765: LD_ADDR_VAR 0 7
27769: PUSH
27770: EMPTY
27771: ST_TO_ADDR
// temp_list = [ ] ;
27772: LD_ADDR_VAR 0 9
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27779: LD_VAR 0 4
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: LD_INT 1
27789: PUSH
27790: LD_INT 2
27792: PUSH
27793: LD_INT 3
27795: PUSH
27796: LD_INT 4
27798: PUSH
27799: LD_INT 5
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: IN
27810: NOT
27811: PUSH
27812: LD_VAR 0 1
27816: PUSH
27817: LD_INT 0
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: IN
27827: PUSH
27828: LD_VAR 0 5
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: LD_INT 2
27838: PUSH
27839: LD_INT 3
27841: PUSH
27842: EMPTY
27843: LIST
27844: LIST
27845: LIST
27846: IN
27847: NOT
27848: AND
27849: OR
27850: IFFALSE 27854
// exit ;
27852: GO 46245
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27854: LD_VAR 0 1
27858: PUSH
27859: LD_INT 6
27861: PUSH
27862: LD_INT 7
27864: PUSH
27865: LD_INT 8
27867: PUSH
27868: LD_INT 13
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: LD_INT 15
27876: PUSH
27877: LD_INT 11
27879: PUSH
27880: LD_INT 14
27882: PUSH
27883: LD_INT 10
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: LIST
27890: LIST
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: LIST
27896: IN
27897: IFFALSE 27907
// btype = b_lab ;
27899: LD_ADDR_VAR 0 1
27903: PUSH
27904: LD_INT 6
27906: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27907: LD_VAR 0 6
27911: PUSH
27912: LD_INT 0
27914: PUSH
27915: LD_INT 1
27917: PUSH
27918: LD_INT 2
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: IN
27926: NOT
27927: PUSH
27928: LD_VAR 0 1
27932: PUSH
27933: LD_INT 0
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: LD_INT 3
27944: PUSH
27945: LD_INT 6
27947: PUSH
27948: LD_INT 36
27950: PUSH
27951: LD_INT 4
27953: PUSH
27954: LD_INT 5
27956: PUSH
27957: LD_INT 31
27959: PUSH
27960: LD_INT 32
27962: PUSH
27963: LD_INT 33
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: IN
27979: NOT
27980: PUSH
27981: LD_VAR 0 6
27985: PUSH
27986: LD_INT 1
27988: EQUAL
27989: AND
27990: OR
27991: PUSH
27992: LD_VAR 0 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: LD_INT 3
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: IN
28007: NOT
28008: PUSH
28009: LD_VAR 0 6
28013: PUSH
28014: LD_INT 2
28016: EQUAL
28017: AND
28018: OR
28019: IFFALSE 28029
// mode = 0 ;
28021: LD_ADDR_VAR 0 6
28025: PUSH
28026: LD_INT 0
28028: ST_TO_ADDR
// case mode of 0 :
28029: LD_VAR 0 6
28033: PUSH
28034: LD_INT 0
28036: DOUBLE
28037: EQUAL
28038: IFTRUE 28042
28040: GO 39495
28042: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28043: LD_ADDR_VAR 0 11
28047: PUSH
28048: LD_INT 0
28050: PUSH
28051: LD_INT 0
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 0
28060: PUSH
28061: LD_INT 1
28063: NEG
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 1
28071: PUSH
28072: LD_INT 0
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 1
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: LD_INT 1
28101: NEG
28102: PUSH
28103: LD_INT 0
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 1
28116: NEG
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 2
28128: NEG
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: LD_INT 2
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 0
28168: PUSH
28169: LD_INT 2
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 1
28178: NEG
28179: PUSH
28180: LD_INT 1
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 1
28189: PUSH
28190: LD_INT 3
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 0
28199: PUSH
28200: LD_INT 3
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 1
28209: NEG
28210: PUSH
28211: LD_INT 2
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28236: LD_ADDR_VAR 0 12
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 0
28253: PUSH
28254: LD_INT 1
28256: NEG
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: EMPTY
28269: LIST
28270: LIST
28271: PUSH
28272: LD_INT 1
28274: PUSH
28275: LD_INT 1
28277: PUSH
28278: EMPTY
28279: LIST
28280: LIST
28281: PUSH
28282: LD_INT 0
28284: PUSH
28285: LD_INT 1
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 1
28294: NEG
28295: PUSH
28296: LD_INT 0
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: LD_INT 1
28309: NEG
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 1
28320: NEG
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 2
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 1
28348: NEG
28349: PUSH
28350: LD_INT 1
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 0
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PUSH
28368: LD_INT 2
28370: NEG
28371: PUSH
28372: LD_INT 1
28374: NEG
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 2
28382: NEG
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 3
28393: NEG
28394: PUSH
28395: LD_INT 0
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 3
28404: NEG
28405: PUSH
28406: LD_INT 1
28408: NEG
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28432: LD_ADDR_VAR 0 13
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 1
28460: PUSH
28461: LD_INT 0
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: PUSH
28471: LD_INT 1
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 0
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: PUSH
28488: LD_INT 1
28490: NEG
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: PUSH
28499: LD_INT 1
28501: NEG
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: LD_INT 1
28513: NEG
28514: PUSH
28515: LD_INT 2
28517: NEG
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 2
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 2
28535: PUSH
28536: LD_INT 2
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: LD_INT 1
28545: PUSH
28546: LD_INT 2
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 2
28555: NEG
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 2
28567: NEG
28568: PUSH
28569: LD_INT 2
28571: NEG
28572: PUSH
28573: EMPTY
28574: LIST
28575: LIST
28576: PUSH
28577: LD_INT 2
28579: NEG
28580: PUSH
28581: LD_INT 3
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 3
28591: NEG
28592: PUSH
28593: LD_INT 2
28595: NEG
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 3
28603: NEG
28604: PUSH
28605: LD_INT 3
28607: NEG
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28631: LD_ADDR_VAR 0 14
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 0
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 0
28648: PUSH
28649: LD_INT 1
28651: NEG
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 1
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 1
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 0
28679: PUSH
28680: LD_INT 1
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PUSH
28687: LD_INT 1
28689: NEG
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: LD_INT 1
28704: NEG
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 1
28712: NEG
28713: PUSH
28714: LD_INT 2
28716: NEG
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 0
28724: PUSH
28725: LD_INT 2
28727: NEG
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: LD_INT 1
28735: PUSH
28736: LD_INT 1
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 1
28766: NEG
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 3
28781: NEG
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 3
28792: NEG
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 1
28800: PUSH
28801: LD_INT 2
28803: NEG
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: LIST
28825: LIST
28826: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28827: LD_ADDR_VAR 0 15
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 1
28847: NEG
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 1
28855: PUSH
28856: LD_INT 0
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: LD_INT 1
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 1
28885: NEG
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: NEG
28897: PUSH
28898: LD_INT 1
28900: NEG
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: LD_INT 1
28911: NEG
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 2
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 2
28950: NEG
28951: PUSH
28952: LD_INT 0
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 2
28961: NEG
28962: PUSH
28963: LD_INT 1
28965: NEG
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 2
28973: PUSH
28974: LD_INT 1
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 3
28994: PUSH
28995: LD_INT 1
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29020: LD_ADDR_VAR 0 16
29024: PUSH
29025: LD_INT 0
29027: PUSH
29028: LD_INT 0
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 1
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 1
29048: PUSH
29049: LD_INT 0
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: NEG
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 1
29101: NEG
29102: PUSH
29103: LD_INT 2
29105: NEG
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 2
29113: PUSH
29114: LD_INT 1
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 2
29123: PUSH
29124: LD_INT 2
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: PUSH
29134: LD_INT 2
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: LD_INT 1
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 2
29155: NEG
29156: PUSH
29157: LD_INT 2
29159: NEG
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 3
29167: PUSH
29168: LD_INT 2
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 3
29177: PUSH
29178: LD_INT 3
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: LD_INT 3
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29213: LD_ADDR_VAR 0 17
29217: PUSH
29218: LD_INT 0
29220: PUSH
29221: LD_INT 0
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 1
29233: NEG
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PUSH
29242: LD_INT 0
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 1
29294: NEG
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: LD_INT 2
29309: NEG
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 2
29328: PUSH
29329: LD_INT 0
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 2
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 0
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: NEG
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 2
29389: NEG
29390: PUSH
29391: LD_INT 0
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 2
29400: NEG
29401: PUSH
29402: LD_INT 1
29404: NEG
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 2
29412: NEG
29413: PUSH
29414: LD_INT 2
29416: NEG
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: LIST
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29443: LD_ADDR_VAR 0 18
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 1
29463: NEG
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 1
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 0
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 1
29512: NEG
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: LD_INT 2
29528: NEG
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 0
29536: PUSH
29537: LD_INT 2
29539: NEG
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: LD_INT 1
29550: NEG
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 0
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 1
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: LD_INT 1
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 2
29619: NEG
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: NEG
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29673: LD_ADDR_VAR 0 19
29677: PUSH
29678: LD_INT 0
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 1
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 1
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 1
29731: NEG
29732: PUSH
29733: LD_INT 0
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: NEG
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 2
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 2
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: LD_INT 1
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 2
29788: PUSH
29789: LD_INT 0
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 2
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 2
29849: NEG
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 2
29860: NEG
29861: PUSH
29862: LD_INT 1
29864: NEG
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 2
29872: NEG
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29903: LD_ADDR_VAR 0 20
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 1
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 0
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 1
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 0
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: LD_INT 0
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PUSH
29970: LD_INT 1
29972: NEG
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: NEG
29985: PUSH
29986: LD_INT 2
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 2
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 0
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 2
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 1
30068: NEG
30069: PUSH
30070: LD_INT 1
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 2
30079: NEG
30080: PUSH
30081: LD_INT 0
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 2
30090: NEG
30091: PUSH
30092: LD_INT 1
30094: NEG
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 2
30102: NEG
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30133: LD_ADDR_VAR 0 21
30137: PUSH
30138: LD_INT 0
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 1
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 0
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 0
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 1
30191: NEG
30192: PUSH
30193: LD_INT 0
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: NEG
30203: PUSH
30204: LD_INT 1
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: LD_INT 2
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 2
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 1
30240: NEG
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 2
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 2
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 0
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 1
30298: NEG
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: NEG
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 2
30320: NEG
30321: PUSH
30322: LD_INT 1
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 2
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30363: LD_ADDR_VAR 0 22
30367: PUSH
30368: LD_INT 0
30370: PUSH
30371: LD_INT 0
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 1
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 0
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 0
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 1
30432: NEG
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 1
30444: NEG
30445: PUSH
30446: LD_INT 2
30448: NEG
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 0
30456: PUSH
30457: LD_INT 2
30459: NEG
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 2
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 1
30528: NEG
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 2
30539: NEG
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 2
30550: NEG
30551: PUSH
30552: LD_INT 1
30554: NEG
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 2
30562: NEG
30563: PUSH
30564: LD_INT 2
30566: NEG
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30593: LD_ADDR_VAR 0 23
30597: PUSH
30598: LD_INT 0
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 0
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: LD_INT 1
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 0
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: NEG
30652: PUSH
30653: LD_INT 0
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 1
30662: NEG
30663: PUSH
30664: LD_INT 1
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 0
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 2
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 1
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 2
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: LD_INT 3
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30873: LD_ADDR_VAR 0 24
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 0
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 0
30890: PUSH
30891: LD_INT 1
30893: NEG
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 1
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 1
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 0
30921: PUSH
30922: LD_INT 1
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 0
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: NEG
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 0
30966: PUSH
30967: LD_INT 2
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: LD_INT 1
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 2
30998: PUSH
30999: LD_INT 1
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 2
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: PUSH
31085: LD_INT 2
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: PUSH
31096: LD_INT 1
31098: NEG
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PUSH
31104: LD_INT 3
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 3
31116: PUSH
31117: LD_INT 2
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31149: LD_ADDR_VAR 0 25
31153: PUSH
31154: LD_INT 0
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: LD_INT 1
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 0
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 1
31218: NEG
31219: PUSH
31220: LD_INT 1
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: LD_INT 2
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: LD_INT 0
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: LD_INT 1
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 2
31284: PUSH
31285: LD_INT 2
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 1
31294: PUSH
31295: LD_INT 2
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 0
31304: PUSH
31305: LD_INT 2
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 1
31314: NEG
31315: PUSH
31316: LD_INT 1
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: LD_INT 0
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 2
31336: NEG
31337: PUSH
31338: LD_INT 1
31340: NEG
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 2
31348: NEG
31349: PUSH
31350: LD_INT 2
31352: NEG
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 3
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 3
31370: PUSH
31371: LD_INT 2
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 2
31380: PUSH
31381: LD_INT 3
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: LD_INT 3
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31423: LD_ADDR_VAR 0 26
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: NEG
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 1
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: NEG
31493: PUSH
31494: LD_INT 1
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: LD_INT 2
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 2
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 2
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: LD_INT 2
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 0
31578: PUSH
31579: LD_INT 2
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 1
31588: NEG
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: LD_INT 2
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: PUSH
31635: LD_INT 3
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: LD_INT 2
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 2
31665: NEG
31666: PUSH
31667: LD_INT 1
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31699: LD_ADDR_VAR 0 27
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 0
31716: PUSH
31717: LD_INT 1
31719: NEG
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: LD_INT 1
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: LD_INT 2
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 2
31814: PUSH
31815: LD_INT 0
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 2
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: LD_INT 2
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 1
31864: NEG
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 2
31875: NEG
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 2
31886: NEG
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 2
31898: NEG
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 2
31921: NEG
31922: PUSH
31923: LD_INT 1
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 3
31932: NEG
31933: PUSH
31934: LD_INT 1
31936: NEG
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 3
31944: NEG
31945: PUSH
31946: LD_INT 2
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: LIST
31974: LIST
31975: LIST
31976: LIST
31977: LIST
31978: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31979: LD_ADDR_VAR 0 28
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: LD_INT 0
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 0
31996: PUSH
31997: LD_INT 1
31999: NEG
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 1
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 0
32027: PUSH
32028: LD_INT 1
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: LD_INT 0
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 1
32048: NEG
32049: PUSH
32050: LD_INT 1
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: LD_INT 2
32064: NEG
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 1
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 2
32114: PUSH
32115: LD_INT 2
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: PUSH
32125: LD_INT 2
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 1
32144: NEG
32145: PUSH
32146: LD_INT 1
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: NEG
32167: PUSH
32168: LD_INT 1
32170: NEG
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 2
32178: NEG
32179: PUSH
32180: LD_INT 2
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 2
32190: NEG
32191: PUSH
32192: LD_INT 3
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: NEG
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: NEG
32215: PUSH
32216: LD_INT 1
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 3
32226: NEG
32227: PUSH
32228: LD_INT 2
32230: NEG
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32261: LD_ADDR_VAR 0 29
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 0
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 0
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: LD_INT 1
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: NEG
32320: PUSH
32321: LD_INT 0
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: NEG
32331: PUSH
32332: LD_INT 1
32334: NEG
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 1
32342: NEG
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: LD_INT 2
32357: NEG
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: LD_INT 1
32368: NEG
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: NEG
32440: PUSH
32441: LD_INT 2
32443: NEG
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: NEG
32452: PUSH
32453: LD_INT 3
32455: NEG
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: LD_INT 1
32466: NEG
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: PUSH
32485: LD_INT 3
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: LD_INT 2
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 3
32505: NEG
32506: PUSH
32507: LD_INT 2
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32540: LD_ADDR_VAR 0 30
32544: PUSH
32545: LD_INT 0
32547: PUSH
32548: LD_INT 0
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: LD_INT 1
32560: NEG
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: LD_INT 0
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 0
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 1
32598: NEG
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 1
32609: NEG
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: LD_INT 2
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 2
32636: NEG
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 1
32644: PUSH
32645: LD_INT 1
32647: NEG
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: LD_INT 0
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 2
32665: PUSH
32666: LD_INT 1
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 2
32675: PUSH
32676: LD_INT 2
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 1
32685: PUSH
32686: LD_INT 2
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 2
32706: NEG
32707: PUSH
32708: LD_INT 0
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 2
32717: NEG
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 3
32733: NEG
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 1
32741: PUSH
32742: LD_INT 2
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 3
32752: PUSH
32753: LD_INT 2
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 2
32762: PUSH
32763: LD_INT 3
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 3
32783: NEG
32784: PUSH
32785: LD_INT 1
32787: NEG
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: LIST
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: LIST
32817: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32818: LD_ADDR_VAR 0 31
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: LD_INT 0
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 1
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 1
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 1
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 0
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 1
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: NEG
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 2
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 2
32932: PUSH
32933: LD_INT 1
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 2
32942: PUSH
32943: LD_INT 2
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: LD_INT 2
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 2
32983: NEG
32984: PUSH
32985: LD_INT 1
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: LD_INT 2
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: NEG
33008: PUSH
33009: LD_INT 3
33011: NEG
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 2
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 3
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 3
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 3
33061: NEG
33062: PUSH
33063: LD_INT 2
33065: NEG
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33096: LD_ADDR_VAR 0 32
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 1
33116: NEG
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 0
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 0
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: NEG
33155: PUSH
33156: LD_INT 0
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: LD_INT 2
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: LD_INT 2
33192: NEG
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: LD_INT 1
33203: NEG
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: PUSH
33222: LD_INT 2
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 1
33231: PUSH
33232: LD_INT 2
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: LD_INT 2
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 1
33251: NEG
33252: PUSH
33253: LD_INT 1
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 2
33262: NEG
33263: PUSH
33264: LD_INT 0
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 2
33273: NEG
33274: PUSH
33275: LD_INT 1
33277: NEG
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: LD_INT 3
33289: NEG
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: LD_INT 2
33300: NEG
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 3
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 2
33318: PUSH
33319: LD_INT 3
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: LD_INT 1
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 3
33339: NEG
33340: PUSH
33341: LD_INT 1
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33374: LD_ADDR_VAR 0 33
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: LD_INT 2
33459: NEG
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 2
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 1
33498: PUSH
33499: LD_INT 2
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 2
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 1
33518: NEG
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 2
33540: NEG
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 2
33552: NEG
33553: PUSH
33554: LD_INT 2
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 2
33564: NEG
33565: PUSH
33566: LD_INT 3
33568: NEG
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 2
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 3
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: LD_INT 3
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: NEG
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 3
33618: NEG
33619: PUSH
33620: LD_INT 2
33622: NEG
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33653: LD_ADDR_VAR 0 34
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 0
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 1
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 0
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 1
33711: NEG
33712: PUSH
33713: LD_INT 0
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 1
33722: NEG
33723: PUSH
33724: LD_INT 1
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: NEG
33735: PUSH
33736: LD_INT 2
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: LD_INT 2
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 1
33760: NEG
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: LD_INT 2
33778: PUSH
33779: LD_INT 2
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: LD_INT 2
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 2
33809: NEG
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: NEG
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: NEG
33833: PUSH
33834: LD_INT 2
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 3
33848: NEG
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 3
33867: PUSH
33868: LD_INT 2
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 3
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: LD_INT 1
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 3
33898: NEG
33899: PUSH
33900: LD_INT 1
33902: NEG
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33933: LD_ADDR_VAR 0 35
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 0
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: PUSH
33972: LD_INT 1
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 0
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 1
33991: NEG
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: NEG
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 2
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 2
34024: NEG
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34045: LD_ADDR_VAR 0 36
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: LD_INT 2
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34157: LD_ADDR_VAR 0 37
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 0
34174: PUSH
34175: LD_INT 1
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 0
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 0
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: LD_INT 0
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 1
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34269: LD_ADDR_VAR 0 38
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 0
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: LD_INT 1
34289: NEG
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: LD_INT 1
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 1
34327: NEG
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 2
34360: NEG
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34381: LD_ADDR_VAR 0 39
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: LD_INT 0
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 0
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 1
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 1
34462: NEG
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34493: LD_ADDR_VAR 0 40
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 1
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: NEG
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: NEG
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 1
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34605: LD_ADDR_VAR 0 41
34609: PUSH
34610: LD_INT 0
34612: PUSH
34613: LD_INT 0
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 0
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 1
34633: PUSH
34634: LD_INT 0
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: LD_INT 1
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 0
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: NEG
34664: PUSH
34665: LD_INT 0
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 1
34686: NEG
34687: PUSH
34688: LD_INT 2
34690: NEG
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 1
34698: PUSH
34699: LD_INT 1
34701: NEG
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 2
34709: PUSH
34710: LD_INT 0
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 2
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 2
34729: PUSH
34730: LD_INT 2
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: LD_INT 2
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 1
34749: NEG
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 2
34771: NEG
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 2
34783: NEG
34784: PUSH
34785: LD_INT 2
34787: NEG
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: LD_INT 3
34799: NEG
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 3
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 3
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 3
34838: PUSH
34839: LD_INT 2
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 3
34848: PUSH
34849: LD_INT 3
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 2
34858: PUSH
34859: LD_INT 3
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 2
34868: NEG
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 3
34879: NEG
34880: PUSH
34881: LD_INT 0
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 3
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 3
34902: NEG
34903: PUSH
34904: LD_INT 2
34906: NEG
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 3
34914: NEG
34915: PUSH
34916: LD_INT 3
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34955: LD_ADDR_VAR 0 42
34959: PUSH
34960: LD_INT 0
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: PUSH
34984: LD_INT 0
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: PUSH
34994: LD_INT 1
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 2
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: LD_INT 2
35051: NEG
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 2
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 2
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 2
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 2
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 2
35121: NEG
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 2
35133: NEG
35134: PUSH
35135: LD_INT 2
35137: NEG
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: LD_INT 3
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: NEG
35158: PUSH
35159: LD_INT 3
35161: NEG
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 3
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 2
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 3
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 3
35201: PUSH
35202: LD_INT 3
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 2
35211: PUSH
35212: LD_INT 3
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: PUSH
35222: LD_INT 3
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: LD_INT 3
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: LD_INT 2
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 3
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35305: LD_ADDR_VAR 0 43
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: LD_INT 1
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 0
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 1
35386: NEG
35387: PUSH
35388: LD_INT 2
35390: NEG
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: LD_INT 2
35401: NEG
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: NEG
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 2
35471: NEG
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 2
35482: NEG
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: LD_INT 3
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 3
35509: NEG
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 1
35517: PUSH
35518: LD_INT 2
35520: NEG
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 2
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 3
35539: PUSH
35540: LD_INT 0
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 3
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: PUSH
35560: LD_INT 3
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: LD_INT 3
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: LD_INT 2
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 2
35590: NEG
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 3
35601: NEG
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 3
35612: NEG
35613: PUSH
35614: LD_INT 1
35616: NEG
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35653: LD_ADDR_VAR 0 44
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: PUSH
35682: LD_INT 0
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: LD_INT 1
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 1
35711: NEG
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 1
35734: NEG
35735: PUSH
35736: LD_INT 2
35738: NEG
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: NEG
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 2
35757: PUSH
35758: LD_INT 0
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 2
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 2
35819: NEG
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 2
35831: NEG
35832: PUSH
35833: LD_INT 2
35835: NEG
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: NEG
35844: PUSH
35845: LD_INT 3
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 2
35855: PUSH
35856: LD_INT 1
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 3
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 3
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 3
35886: PUSH
35887: LD_INT 2
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 3
35896: PUSH
35897: LD_INT 3
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 2
35916: NEG
35917: PUSH
35918: LD_INT 1
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 3
35927: NEG
35928: PUSH
35929: LD_INT 0
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: NEG
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 3
35950: NEG
35951: PUSH
35952: LD_INT 2
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 3
35962: NEG
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36003: LD_ADDR_VAR 0 45
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 0
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 0
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 1
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 0
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 1
36061: NEG
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: NEG
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: LD_INT 1
36084: NEG
36085: PUSH
36086: LD_INT 2
36088: NEG
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 2
36099: NEG
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 2
36181: NEG
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: LD_INT 3
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: LD_INT 3
36209: NEG
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 3
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 2
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 3
36239: PUSH
36240: LD_INT 2
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 3
36249: PUSH
36250: LD_INT 3
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 3
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 3
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 3
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 3
36300: NEG
36301: PUSH
36302: LD_INT 2
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 3
36312: NEG
36313: PUSH
36314: LD_INT 3
36316: NEG
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36353: LD_ADDR_VAR 0 46
36357: PUSH
36358: LD_INT 0
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 1
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: PUSH
36392: LD_INT 1
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 0
36401: PUSH
36402: LD_INT 1
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 1
36411: NEG
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 1
36422: NEG
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 2
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 2
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 2
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 2
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 2
36530: NEG
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: LD_INT 3
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 3
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 2
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 2
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 3
36597: PUSH
36598: LD_INT 1
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: LD_INT 3
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 0
36617: PUSH
36618: LD_INT 3
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: LD_INT 2
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 2
36638: NEG
36639: PUSH
36640: LD_INT 1
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 3
36649: NEG
36650: PUSH
36651: LD_INT 0
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: NEG
36661: PUSH
36662: LD_INT 1
36664: NEG
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36701: LD_ADDR_VAR 0 47
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: LD_INT 2
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: NEG
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: NEG
36829: PUSH
36830: LD_INT 2
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36852: LD_ADDR_VAR 0 48
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: LD_INT 0
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: LD_INT 1
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 0
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: LD_INT 1
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: NEG
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 2
36967: PUSH
36968: LD_INT 0
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 2
36977: PUSH
36978: LD_INT 1
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36999: LD_ADDR_VAR 0 49
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: LD_INT 0
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: LD_INT 0
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 1
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: LD_INT 0
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: LD_INT 1
37068: NEG
37069: PUSH
37070: LD_INT 1
37072: NEG
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 1
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 2
37091: PUSH
37092: LD_INT 0
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 2
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 2
37111: PUSH
37112: LD_INT 2
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37143: LD_ADDR_VAR 0 50
37147: PUSH
37148: LD_INT 0
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 0
37160: PUSH
37161: LD_INT 1
37163: NEG
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: LD_INT 0
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 1
37201: NEG
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 2
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 2
37234: PUSH
37235: LD_INT 2
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 1
37244: PUSH
37245: LD_INT 2
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: LD_INT 2
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: LIST
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37287: LD_ADDR_VAR 0 51
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: LD_INT 0
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 0
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: LD_INT 1
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 1
37356: NEG
37357: PUSH
37358: LD_INT 1
37360: NEG
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: LD_INT 2
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 1
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 2
37410: NEG
37411: PUSH
37412: LD_INT 1
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37434: LD_ADDR_VAR 0 52
37438: PUSH
37439: LD_INT 0
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 0
37451: PUSH
37452: LD_INT 1
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: LD_INT 0
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 1
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 0
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 0
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: NEG
37528: PUSH
37529: LD_INT 1
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: NEG
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: NEG
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 2
37561: NEG
37562: PUSH
37563: LD_INT 2
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37585: LD_ADDR_VAR 0 53
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: LD_INT 0
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 1
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 1
37643: NEG
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: NEG
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: LD_INT 2
37670: NEG
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: LD_INT 2
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 2
37700: PUSH
37701: LD_INT 0
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 2
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 1
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 0
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: NEG
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: NEG
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: NEG
37773: PUSH
37774: LD_INT 1
37776: NEG
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: LD_INT 2
37788: NEG
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37815: LD_ADDR_VAR 0 54
37819: PUSH
37820: LD_INT 0
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 1
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 0
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 1
37873: NEG
37874: PUSH
37875: LD_INT 0
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 1
37884: NEG
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 1
37896: NEG
37897: PUSH
37898: LD_INT 2
37900: NEG
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 0
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: LD_INT 1
37922: NEG
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 1
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 2
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 0
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: NEG
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 2
38002: NEG
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 2
38014: NEG
38015: PUSH
38016: LD_INT 2
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38045: LD_ADDR_VAR 0 55
38049: PUSH
38050: LD_INT 0
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 1
38065: NEG
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 1
38103: NEG
38104: PUSH
38105: LD_INT 0
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: LD_INT 1
38118: NEG
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 1
38126: NEG
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 2
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: PUSH
38150: LD_INT 1
38152: NEG
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 2
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 2
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: NEG
38211: PUSH
38212: LD_INT 1
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 2
38221: NEG
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: NEG
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38275: LD_ADDR_VAR 0 56
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: LD_INT 2
38360: NEG
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 0
38368: PUSH
38369: LD_INT 2
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 1
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: NEG
38441: PUSH
38442: LD_INT 1
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 2
38451: NEG
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 2
38462: NEG
38463: PUSH
38464: LD_INT 1
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 2
38474: NEG
38475: PUSH
38476: LD_INT 2
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38505: LD_ADDR_VAR 0 57
38509: PUSH
38510: LD_INT 0
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 1
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 1
38563: NEG
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 1
38574: NEG
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 1
38586: NEG
38587: PUSH
38588: LD_INT 2
38590: NEG
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 0
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: LD_INT 1
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: PUSH
38621: LD_INT 0
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 2
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38735: LD_ADDR_VAR 0 58
38739: PUSH
38740: LD_INT 0
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 1
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 0
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 1
38793: NEG
38794: PUSH
38795: LD_INT 0
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 1
38804: NEG
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: LD_INT 2
38820: NEG
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 0
38828: PUSH
38829: LD_INT 2
38831: NEG
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: LD_INT 1
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 2
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 2
38860: PUSH
38861: LD_INT 1
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: LD_INT 2
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: LD_INT 2
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 1
38900: NEG
38901: PUSH
38902: LD_INT 1
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 2
38922: NEG
38923: PUSH
38924: LD_INT 1
38926: NEG
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 2
38934: NEG
38935: PUSH
38936: LD_INT 2
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: LIST
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38965: LD_ADDR_VAR 0 59
38969: PUSH
38970: LD_INT 0
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 0
38982: PUSH
38983: LD_INT 1
38985: NEG
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 0
39013: PUSH
39014: LD_INT 1
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 1
39023: NEG
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 1
39034: NEG
39035: PUSH
39036: LD_INT 1
39038: NEG
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39053: LD_ADDR_VAR 0 60
39057: PUSH
39058: LD_INT 0
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 1
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 1
39122: NEG
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: LIST
39137: LIST
39138: LIST
39139: LIST
39140: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39141: LD_ADDR_VAR 0 61
39145: PUSH
39146: LD_INT 0
39148: PUSH
39149: LD_INT 0
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 0
39158: PUSH
39159: LD_INT 1
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: PUSH
39170: LD_INT 0
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 1
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 0
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 1
39199: NEG
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: LD_INT 1
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39229: LD_ADDR_VAR 0 62
39233: PUSH
39234: LD_INT 0
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: LD_INT 1
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: LD_INT 1
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: NEG
39299: PUSH
39300: LD_INT 1
39302: NEG
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39317: LD_ADDR_VAR 0 63
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 1
39345: PUSH
39346: LD_INT 0
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: PUSH
39356: LD_INT 1
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: LD_INT 1
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 0
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: NEG
39387: PUSH
39388: LD_INT 1
39390: NEG
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39405: LD_ADDR_VAR 0 64
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: LD_INT 1
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: ST_TO_ADDR
// end ; 1 :
39493: GO 45390
39495: LD_INT 1
39497: DOUBLE
39498: EQUAL
39499: IFTRUE 39503
39501: GO 42126
39503: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39504: LD_ADDR_VAR 0 11
39508: PUSH
39509: LD_INT 1
39511: NEG
39512: PUSH
39513: LD_INT 3
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 0
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 1
39534: PUSH
39535: LD_INT 2
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39548: LD_ADDR_VAR 0 12
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 3
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 3
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: LIST
39588: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39589: LD_ADDR_VAR 0 13
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 3
39606: PUSH
39607: LD_INT 3
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 3
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: LIST
39628: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39629: LD_ADDR_VAR 0 14
39633: PUSH
39634: LD_INT 1
39636: PUSH
39637: LD_INT 3
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 3
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 1
39656: NEG
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: LIST
39669: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39670: LD_ADDR_VAR 0 15
39674: PUSH
39675: LD_INT 2
39677: NEG
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 3
39688: NEG
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: LIST
39713: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39714: LD_ADDR_VAR 0 16
39718: PUSH
39719: LD_INT 2
39721: NEG
39722: PUSH
39723: LD_INT 3
39725: NEG
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 3
39733: NEG
39734: PUSH
39735: LD_INT 2
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 3
39745: NEG
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: LIST
39759: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39760: LD_ADDR_VAR 0 17
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: LD_INT 3
39771: NEG
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: LD_INT 2
39793: NEG
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: LIST
39803: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39804: LD_ADDR_VAR 0 18
39808: PUSH
39809: LD_INT 2
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 3
39822: PUSH
39823: LD_INT 0
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 3
39832: PUSH
39833: LD_INT 1
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: LIST
39844: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39845: LD_ADDR_VAR 0 19
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 2
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 2
39872: PUSH
39873: LD_INT 3
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: LIST
39884: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39885: LD_ADDR_VAR 0 20
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: LD_INT 3
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: LD_INT 3
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 1
39912: NEG
39913: PUSH
39914: LD_INT 2
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39926: LD_ADDR_VAR 0 21
39930: PUSH
39931: LD_INT 2
39933: NEG
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 3
39944: NEG
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 3
39955: NEG
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: LIST
39969: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39970: LD_ADDR_VAR 0 22
39974: PUSH
39975: LD_INT 2
39977: NEG
39978: PUSH
39979: LD_INT 3
39981: NEG
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 3
39989: NEG
39990: PUSH
39991: LD_INT 2
39993: NEG
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 3
40001: NEG
40002: PUSH
40003: LD_INT 3
40005: NEG
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: LIST
40015: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40016: LD_ADDR_VAR 0 23
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 3
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: NEG
40035: PUSH
40036: LD_INT 4
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: LD_INT 3
40049: NEG
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: LIST
40059: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40060: LD_ADDR_VAR 0 24
40064: PUSH
40065: LD_INT 3
40067: PUSH
40068: LD_INT 0
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 3
40077: PUSH
40078: LD_INT 1
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 4
40088: PUSH
40089: LD_INT 1
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: LIST
40100: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40101: LD_ADDR_VAR 0 25
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: LD_INT 3
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 4
40118: PUSH
40119: LD_INT 3
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 3
40128: PUSH
40129: LD_INT 4
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: LIST
40140: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40141: LD_ADDR_VAR 0 26
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: LD_INT 3
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 4
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: NEG
40169: PUSH
40170: LD_INT 3
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: LIST
40181: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40182: LD_ADDR_VAR 0 27
40186: PUSH
40187: LD_INT 3
40189: NEG
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 3
40200: NEG
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: LIST
40225: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40226: LD_ADDR_VAR 0 28
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: LD_INT 3
40237: NEG
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: NEG
40246: PUSH
40247: LD_INT 4
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 4
40257: NEG
40258: PUSH
40259: LD_INT 3
40261: NEG
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: LIST
40271: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40272: LD_ADDR_VAR 0 29
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 3
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 0
40291: PUSH
40292: LD_INT 3
40294: NEG
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 1
40313: NEG
40314: PUSH
40315: LD_INT 4
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: LD_INT 4
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 1
40347: NEG
40348: PUSH
40349: LD_INT 5
40351: NEG
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: LD_INT 5
40362: NEG
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 1
40370: PUSH
40371: LD_INT 4
40373: NEG
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: LD_INT 1
40381: NEG
40382: PUSH
40383: LD_INT 6
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_INT 6
40396: NEG
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40427: LD_ADDR_VAR 0 30
40431: PUSH
40432: LD_INT 2
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 3
40445: PUSH
40446: LD_INT 0
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: PUSH
40456: LD_INT 1
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 1
40468: NEG
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 4
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 4
40486: PUSH
40487: LD_INT 1
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 4
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 5
40507: PUSH
40508: LD_INT 0
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 5
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 5
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 6
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 6
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40570: LD_ADDR_VAR 0 31
40574: PUSH
40575: LD_INT 3
40577: PUSH
40578: LD_INT 2
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 3
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 2
40597: PUSH
40598: LD_INT 3
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: LD_INT 3
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 4
40617: PUSH
40618: LD_INT 4
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 4
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 5
40637: PUSH
40638: LD_INT 4
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 5
40647: PUSH
40648: LD_INT 5
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 4
40657: PUSH
40658: LD_INT 5
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 6
40667: PUSH
40668: LD_INT 5
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 6
40677: PUSH
40678: LD_INT 6
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 5
40687: PUSH
40688: LD_INT 6
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40709: LD_ADDR_VAR 0 32
40713: PUSH
40714: LD_INT 1
40716: PUSH
40717: LD_INT 3
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: LD_INT 3
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 1
40736: NEG
40737: PUSH
40738: LD_INT 2
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: LD_INT 4
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_INT 4
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: LD_INT 3
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: LD_INT 5
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: LD_INT 5
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 1
40798: NEG
40799: PUSH
40800: LD_INT 4
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: LD_INT 6
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 6
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 1
40829: NEG
40830: PUSH
40831: LD_INT 5
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40852: LD_ADDR_VAR 0 33
40856: PUSH
40857: LD_INT 2
40859: NEG
40860: PUSH
40861: LD_INT 1
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 3
40870: NEG
40871: PUSH
40872: LD_INT 0
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 3
40893: NEG
40894: PUSH
40895: LD_INT 1
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 4
40904: NEG
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 4
40915: NEG
40916: PUSH
40917: LD_INT 1
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 4
40927: NEG
40928: PUSH
40929: LD_INT 1
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 5
40938: NEG
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 5
40949: NEG
40950: PUSH
40951: LD_INT 1
40953: NEG
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 5
40961: NEG
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: LD_INT 0
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 6
40983: NEG
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41007: LD_ADDR_VAR 0 34
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: LD_INT 3
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 3
41026: NEG
41027: PUSH
41028: LD_INT 2
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 3
41038: NEG
41039: PUSH
41040: LD_INT 3
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 3
41050: NEG
41051: PUSH
41052: LD_INT 4
41054: NEG
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 3
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 4
41074: NEG
41075: PUSH
41076: LD_INT 4
41078: NEG
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 4
41086: NEG
41087: PUSH
41088: LD_INT 5
41090: NEG
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 5
41098: NEG
41099: PUSH
41100: LD_INT 4
41102: NEG
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 5
41110: NEG
41111: PUSH
41112: LD_INT 5
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 5
41122: NEG
41123: PUSH
41124: LD_INT 6
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 6
41134: NEG
41135: PUSH
41136: LD_INT 5
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 6
41146: NEG
41147: PUSH
41148: LD_INT 6
41150: NEG
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: LIST
41169: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41170: LD_ADDR_VAR 0 41
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 2
41180: NEG
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: LD_INT 3
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 1
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: LIST
41213: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41214: LD_ADDR_VAR 0 42
41218: PUSH
41219: LD_INT 2
41221: PUSH
41222: LD_INT 0
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: LD_INT 1
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 3
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: LIST
41254: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41255: LD_ADDR_VAR 0 43
41259: PUSH
41260: LD_INT 2
41262: PUSH
41263: LD_INT 2
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 3
41272: PUSH
41273: LD_INT 2
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: LD_INT 3
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: LIST
41294: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41295: LD_ADDR_VAR 0 44
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: LD_INT 2
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: LD_INT 3
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 1
41322: NEG
41323: PUSH
41324: LD_INT 2
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: LIST
41335: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41336: LD_ADDR_VAR 0 45
41340: PUSH
41341: LD_INT 2
41343: NEG
41344: PUSH
41345: LD_INT 0
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 2
41354: NEG
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 3
41365: NEG
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41380: LD_ADDR_VAR 0 46
41384: PUSH
41385: LD_INT 2
41387: NEG
41388: PUSH
41389: LD_INT 2
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 2
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 3
41411: NEG
41412: PUSH
41413: LD_INT 2
41415: NEG
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: LIST
41425: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41426: LD_ADDR_VAR 0 47
41430: PUSH
41431: LD_INT 2
41433: NEG
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: NEG
41446: PUSH
41447: LD_INT 3
41449: NEG
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41459: LD_ADDR_VAR 0 48
41463: PUSH
41464: LD_INT 1
41466: PUSH
41467: LD_INT 2
41469: NEG
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 2
41477: PUSH
41478: LD_INT 1
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41490: LD_ADDR_VAR 0 49
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: LD_INT 1
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41519: LD_ADDR_VAR 0 50
41523: PUSH
41524: LD_INT 2
41526: PUSH
41527: LD_INT 3
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: PUSH
41537: LD_INT 3
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41548: LD_ADDR_VAR 0 51
41552: PUSH
41553: LD_INT 1
41555: NEG
41556: PUSH
41557: LD_INT 2
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 2
41566: NEG
41567: PUSH
41568: LD_INT 1
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41579: LD_ADDR_VAR 0 52
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 3
41598: NEG
41599: PUSH
41600: LD_INT 2
41602: NEG
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41612: LD_ADDR_VAR 0 53
41616: PUSH
41617: LD_INT 1
41619: NEG
41620: PUSH
41621: LD_INT 3
41623: NEG
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: PUSH
41629: LD_INT 0
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: LIST
41655: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41656: LD_ADDR_VAR 0 54
41660: PUSH
41661: LD_INT 2
41663: PUSH
41664: LD_INT 1
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 3
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 3
41684: PUSH
41685: LD_INT 1
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: LIST
41696: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41697: LD_ADDR_VAR 0 55
41701: PUSH
41702: LD_INT 3
41704: PUSH
41705: LD_INT 2
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 3
41714: PUSH
41715: LD_INT 3
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 2
41724: PUSH
41725: LD_INT 3
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: LIST
41736: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41737: LD_ADDR_VAR 0 56
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: LD_INT 3
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 0
41754: PUSH
41755: LD_INT 3
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 1
41764: NEG
41765: PUSH
41766: LD_INT 2
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: LIST
41777: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41778: LD_ADDR_VAR 0 57
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 3
41807: NEG
41808: PUSH
41809: LD_INT 1
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: LIST
41821: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41822: LD_ADDR_VAR 0 58
41826: PUSH
41827: LD_INT 2
41829: NEG
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: LD_INT 2
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: LD_INT 3
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: LIST
41867: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41868: LD_ADDR_VAR 0 59
41872: PUSH
41873: LD_INT 1
41875: NEG
41876: PUSH
41877: LD_INT 2
41879: NEG
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 0
41887: PUSH
41888: LD_INT 2
41890: NEG
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 1
41898: PUSH
41899: LD_INT 1
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: LIST
41911: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41912: LD_ADDR_VAR 0 60
41916: PUSH
41917: LD_INT 1
41919: PUSH
41920: LD_INT 1
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: LD_INT 1
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: LIST
41952: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41953: LD_ADDR_VAR 0 61
41957: PUSH
41958: LD_INT 2
41960: PUSH
41961: LD_INT 1
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 2
41970: PUSH
41971: LD_INT 2
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 1
41980: PUSH
41981: LD_INT 2
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: LIST
41992: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41993: LD_ADDR_VAR 0 62
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 2
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 2
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 1
42020: NEG
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42034: LD_ADDR_VAR 0 63
42038: PUSH
42039: LD_INT 1
42041: NEG
42042: PUSH
42043: LD_INT 1
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 2
42052: NEG
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 2
42063: NEG
42064: PUSH
42065: LD_INT 1
42067: NEG
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: LIST
42077: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42078: LD_ADDR_VAR 0 64
42082: PUSH
42083: LD_INT 1
42085: NEG
42086: PUSH
42087: LD_INT 2
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 2
42097: NEG
42098: PUSH
42099: LD_INT 1
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 2
42109: NEG
42110: PUSH
42111: LD_INT 2
42113: NEG
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: LIST
42123: ST_TO_ADDR
// end ; 2 :
42124: GO 45390
42126: LD_INT 2
42128: DOUBLE
42129: EQUAL
42130: IFTRUE 42134
42132: GO 45389
42134: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42135: LD_ADDR_VAR 0 29
42139: PUSH
42140: LD_INT 4
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 4
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 5
42163: PUSH
42164: LD_INT 0
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: LD_INT 1
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 4
42183: PUSH
42184: LD_INT 1
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 3
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: PUSH
42204: LD_INT 1
42206: NEG
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 2
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 5
42225: PUSH
42226: LD_INT 2
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: LD_INT 3
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 2
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 4
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: PUSH
42266: LD_INT 4
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 3
42275: PUSH
42276: LD_INT 4
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 2
42285: PUSH
42286: LD_INT 3
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 2
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 4
42305: PUSH
42306: LD_INT 2
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 2
42315: PUSH
42316: LD_INT 4
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 0
42325: PUSH
42326: LD_INT 4
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 0
42335: PUSH
42336: LD_INT 3
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 1
42345: PUSH
42346: LD_INT 4
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: LD_INT 5
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 0
42365: PUSH
42366: LD_INT 5
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: LD_INT 4
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 1
42386: NEG
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 2
42397: PUSH
42398: LD_INT 5
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 2
42407: NEG
42408: PUSH
42409: LD_INT 3
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 3
42418: NEG
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 3
42429: NEG
42430: PUSH
42431: LD_INT 1
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 2
42452: NEG
42453: PUSH
42454: LD_INT 1
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 3
42463: NEG
42464: PUSH
42465: LD_INT 1
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 4
42474: NEG
42475: PUSH
42476: LD_INT 0
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 4
42485: NEG
42486: PUSH
42487: LD_INT 1
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 4
42497: NEG
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 2
42509: NEG
42510: PUSH
42511: LD_INT 2
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 4
42520: NEG
42521: PUSH
42522: LD_INT 4
42524: NEG
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 4
42532: NEG
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 3
42544: NEG
42545: PUSH
42546: LD_INT 4
42548: NEG
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 3
42556: NEG
42557: PUSH
42558: LD_INT 3
42560: NEG
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 4
42568: NEG
42569: PUSH
42570: LD_INT 3
42572: NEG
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 5
42580: NEG
42581: PUSH
42582: LD_INT 4
42584: NEG
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: LD_INT 5
42592: NEG
42593: PUSH
42594: LD_INT 5
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 3
42604: NEG
42605: PUSH
42606: LD_INT 5
42608: NEG
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 5
42616: NEG
42617: PUSH
42618: LD_INT 3
42620: NEG
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: LIST
42648: LIST
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: LIST
42654: LIST
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42673: LD_ADDR_VAR 0 30
42677: PUSH
42678: LD_INT 4
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 4
42690: PUSH
42691: LD_INT 3
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 5
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: PUSH
42711: LD_INT 5
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 4
42720: PUSH
42721: LD_INT 5
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 3
42730: PUSH
42731: LD_INT 4
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 3
42740: PUSH
42741: LD_INT 3
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 5
42750: PUSH
42751: LD_INT 3
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: LD_INT 3
42760: PUSH
42761: LD_INT 5
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 0
42780: PUSH
42781: LD_INT 2
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 1
42790: PUSH
42791: LD_INT 3
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: LD_INT 1
42800: PUSH
42801: LD_INT 4
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: LD_INT 4
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: LD_INT 3
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: NEG
42832: PUSH
42833: LD_INT 2
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: LD_INT 4
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 2
42852: NEG
42853: PUSH
42854: LD_INT 2
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 4
42863: NEG
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: LD_INT 4
42874: NEG
42875: PUSH
42876: LD_INT 1
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 3
42886: NEG
42887: PUSH
42888: LD_INT 0
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 3
42897: NEG
42898: PUSH
42899: LD_INT 1
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 4
42908: NEG
42909: PUSH
42910: LD_INT 1
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 5
42919: NEG
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 5
42930: NEG
42931: PUSH
42932: LD_INT 1
42934: NEG
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 5
42942: NEG
42943: PUSH
42944: LD_INT 2
42946: NEG
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 3
42954: NEG
42955: PUSH
42956: LD_INT 2
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 3
42965: NEG
42966: PUSH
42967: LD_INT 3
42969: NEG
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 3
42977: NEG
42978: PUSH
42979: LD_INT 4
42981: NEG
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 2
42989: NEG
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: LD_INT 2
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: LD_INT 3
43013: NEG
43014: PUSH
43015: LD_INT 2
43017: NEG
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 4
43025: NEG
43026: PUSH
43027: LD_INT 3
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 4
43037: NEG
43038: PUSH
43039: LD_INT 4
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 2
43049: NEG
43050: PUSH
43051: LD_INT 4
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 4
43061: NEG
43062: PUSH
43063: LD_INT 2
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 0
43084: PUSH
43085: LD_INT 5
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 4
43098: NEG
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 1
43106: PUSH
43107: LD_INT 3
43109: NEG
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: LD_INT 3
43120: NEG
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 4
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: LD_INT 5
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 2
43152: PUSH
43153: LD_INT 3
43155: NEG
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: PUSH
43161: LD_INT 2
43163: NEG
43164: PUSH
43165: LD_INT 5
43167: NEG
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: LIST
43210: LIST
43211: LIST
43212: LIST
43213: LIST
43214: LIST
43215: LIST
43216: LIST
43217: LIST
43218: LIST
43219: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43220: LD_ADDR_VAR 0 31
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: LD_INT 4
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 0
43237: PUSH
43238: LD_INT 3
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 1
43247: PUSH
43248: LD_INT 4
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 1
43257: PUSH
43258: LD_INT 5
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 0
43267: PUSH
43268: LD_INT 5
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 1
43277: NEG
43278: PUSH
43279: LD_INT 4
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 1
43288: NEG
43289: PUSH
43290: LD_INT 3
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 2
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 2
43309: NEG
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 3
43320: NEG
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 3
43331: NEG
43332: PUSH
43333: LD_INT 1
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 2
43343: NEG
43344: PUSH
43345: LD_INT 0
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 2
43354: NEG
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 3
43365: NEG
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 4
43376: NEG
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 4
43387: NEG
43388: PUSH
43389: LD_INT 1
43391: NEG
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 4
43399: NEG
43400: PUSH
43401: LD_INT 2
43403: NEG
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 2
43411: NEG
43412: PUSH
43413: LD_INT 2
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: NEG
43423: PUSH
43424: LD_INT 4
43426: NEG
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 4
43434: NEG
43435: PUSH
43436: LD_INT 5
43438: NEG
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 3
43446: NEG
43447: PUSH
43448: LD_INT 4
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 3
43458: NEG
43459: PUSH
43460: LD_INT 3
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 4
43470: NEG
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: EMPTY
43477: LIST
43478: LIST
43479: PUSH
43480: LD_INT 5
43482: NEG
43483: PUSH
43484: LD_INT 4
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: NEG
43495: PUSH
43496: LD_INT 5
43498: NEG
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: NEG
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 5
43518: NEG
43519: PUSH
43520: LD_INT 3
43522: NEG
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 0
43530: PUSH
43531: LD_INT 3
43533: NEG
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 0
43541: PUSH
43542: LD_INT 4
43544: NEG
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: LD_INT 1
43552: PUSH
43553: LD_INT 3
43555: NEG
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: LD_INT 2
43566: NEG
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: LD_INT 2
43577: NEG
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 3
43589: NEG
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 1
43597: NEG
43598: PUSH
43599: LD_INT 4
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: NEG
43621: PUSH
43622: LD_INT 4
43624: NEG
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: LD_INT 0
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 4
43642: PUSH
43643: LD_INT 1
43645: NEG
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 5
43653: PUSH
43654: LD_INT 0
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 5
43663: PUSH
43664: LD_INT 1
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 4
43673: PUSH
43674: LD_INT 1
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 3
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 3
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 3
43704: PUSH
43705: LD_INT 2
43707: NEG
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 5
43715: PUSH
43716: LD_INT 2
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: LIST
43762: LIST
43763: LIST
43764: LIST
43765: LIST
43766: LIST
43767: LIST
43768: LIST
43769: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43770: LD_ADDR_VAR 0 32
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 4
43788: NEG
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: NEG
43801: PUSH
43802: LD_INT 0
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 3
43811: NEG
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 4
43822: NEG
43823: PUSH
43824: LD_INT 1
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 5
43833: NEG
43834: PUSH
43835: LD_INT 0
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 5
43844: NEG
43845: PUSH
43846: LD_INT 1
43848: NEG
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 5
43856: NEG
43857: PUSH
43858: LD_INT 2
43860: NEG
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 3
43868: NEG
43869: PUSH
43870: LD_INT 2
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: NEG
43880: PUSH
43881: LD_INT 3
43883: NEG
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 3
43891: NEG
43892: PUSH
43893: LD_INT 4
43895: NEG
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 2
43903: NEG
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: NEG
43916: PUSH
43917: LD_INT 2
43919: NEG
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: NEG
43928: PUSH
43929: LD_INT 2
43931: NEG
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 4
43939: NEG
43940: PUSH
43941: LD_INT 3
43943: NEG
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 4
43951: NEG
43952: PUSH
43953: LD_INT 4
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 2
43963: NEG
43964: PUSH
43965: LD_INT 4
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 4
43975: NEG
43976: PUSH
43977: LD_INT 2
43979: NEG
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 0
43987: PUSH
43988: LD_INT 4
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: LD_INT 5
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: PUSH
44010: LD_INT 4
44012: NEG
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 1
44020: PUSH
44021: LD_INT 3
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 3
44034: NEG
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 1
44042: NEG
44043: PUSH
44044: LD_INT 4
44046: NEG
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 1
44054: NEG
44055: PUSH
44056: LD_INT 5
44058: NEG
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 2
44066: PUSH
44067: LD_INT 3
44069: NEG
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 2
44077: NEG
44078: PUSH
44079: LD_INT 5
44081: NEG
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 3
44089: PUSH
44090: LD_INT 0
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 3
44099: PUSH
44100: LD_INT 1
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 4
44110: PUSH
44111: LD_INT 0
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 4
44120: PUSH
44121: LD_INT 1
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 3
44130: PUSH
44131: LD_INT 1
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 2
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 2
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 4
44172: PUSH
44173: LD_INT 2
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 4
44182: PUSH
44183: LD_INT 4
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 4
44192: PUSH
44193: LD_INT 3
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 5
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 5
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 4
44222: PUSH
44223: LD_INT 5
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 3
44232: PUSH
44233: LD_INT 4
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 3
44242: PUSH
44243: LD_INT 3
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 5
44252: PUSH
44253: LD_INT 3
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 3
44262: PUSH
44263: LD_INT 5
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: LIST
44311: LIST
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44317: LD_ADDR_VAR 0 33
44321: PUSH
44322: LD_INT 4
44324: NEG
44325: PUSH
44326: LD_INT 4
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 4
44336: NEG
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 3
44348: NEG
44349: PUSH
44350: LD_INT 4
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 3
44360: NEG
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: NEG
44373: PUSH
44374: LD_INT 3
44376: NEG
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 5
44384: NEG
44385: PUSH
44386: LD_INT 4
44388: NEG
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 5
44396: NEG
44397: PUSH
44398: LD_INT 5
44400: NEG
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 3
44408: NEG
44409: PUSH
44410: LD_INT 5
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 5
44420: NEG
44421: PUSH
44422: LD_INT 3
44424: NEG
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 3
44435: NEG
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 0
44443: PUSH
44444: LD_INT 4
44446: NEG
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 1
44454: PUSH
44455: LD_INT 3
44457: NEG
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: LD_INT 2
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 0
44476: PUSH
44477: LD_INT 2
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 1
44487: NEG
44488: PUSH
44489: LD_INT 3
44491: NEG
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PUSH
44497: LD_INT 1
44499: NEG
44500: PUSH
44501: LD_INT 4
44503: NEG
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 2
44511: PUSH
44512: LD_INT 2
44514: NEG
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 2
44522: NEG
44523: PUSH
44524: LD_INT 4
44526: NEG
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 4
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 4
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: LD_INT 0
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 5
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 4
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 3
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 3
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 3
44606: PUSH
44607: LD_INT 2
44609: NEG
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 5
44617: PUSH
44618: LD_INT 2
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 3
44627: PUSH
44628: LD_INT 3
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 3
44637: PUSH
44638: LD_INT 2
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 4
44647: PUSH
44648: LD_INT 3
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 4
44657: PUSH
44658: LD_INT 4
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 3
44667: PUSH
44668: LD_INT 4
44670: PUSH
44671: EMPTY
44672: LIST
44673: LIST
44674: PUSH
44675: LD_INT 2
44677: PUSH
44678: LD_INT 3
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 2
44687: PUSH
44688: LD_INT 2
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 4
44697: PUSH
44698: LD_INT 2
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 2
44707: PUSH
44708: LD_INT 4
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 0
44717: PUSH
44718: LD_INT 4
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 0
44727: PUSH
44728: LD_INT 3
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 1
44737: PUSH
44738: LD_INT 4
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: PUSH
44748: LD_INT 5
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 0
44757: PUSH
44758: LD_INT 5
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 1
44767: NEG
44768: PUSH
44769: LD_INT 4
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 1
44778: NEG
44779: PUSH
44780: LD_INT 3
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 2
44789: PUSH
44790: LD_INT 5
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 2
44799: NEG
44800: PUSH
44801: LD_INT 3
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: LIST
44847: LIST
44848: LIST
44849: LIST
44850: LIST
44851: LIST
44852: LIST
44853: LIST
44854: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44855: LD_ADDR_VAR 0 34
44859: PUSH
44860: LD_INT 0
44862: PUSH
44863: LD_INT 4
44865: NEG
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 5
44876: NEG
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: LD_INT 4
44887: NEG
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 1
44895: PUSH
44896: LD_INT 3
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 0
44906: PUSH
44907: LD_INT 3
44909: NEG
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 1
44917: NEG
44918: PUSH
44919: LD_INT 4
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 1
44929: NEG
44930: PUSH
44931: LD_INT 5
44933: NEG
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 2
44941: PUSH
44942: LD_INT 3
44944: NEG
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 2
44952: NEG
44953: PUSH
44954: LD_INT 5
44956: NEG
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 3
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 4
44985: PUSH
44986: LD_INT 0
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: LD_INT 1
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 3
45005: PUSH
45006: LD_INT 1
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 0
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 2
45025: PUSH
45026: LD_INT 1
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 2
45036: PUSH
45037: LD_INT 2
45039: NEG
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 4
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 4
45067: PUSH
45068: LD_INT 3
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: PUSH
45075: LD_INT 5
45077: PUSH
45078: LD_INT 4
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: PUSH
45088: LD_INT 5
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 4
45097: PUSH
45098: LD_INT 5
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 3
45107: PUSH
45108: LD_INT 4
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 3
45117: PUSH
45118: LD_INT 3
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 5
45127: PUSH
45128: LD_INT 3
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 3
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: LD_INT 3
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 0
45157: PUSH
45158: LD_INT 2
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 1
45167: PUSH
45168: LD_INT 3
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 1
45177: PUSH
45178: LD_INT 4
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 1
45197: NEG
45198: PUSH
45199: LD_INT 3
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 1
45208: NEG
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 2
45219: PUSH
45220: LD_INT 4
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: NEG
45230: PUSH
45231: LD_INT 2
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 4
45240: NEG
45241: PUSH
45242: LD_INT 0
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 4
45251: NEG
45252: PUSH
45253: LD_INT 1
45255: NEG
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 3
45263: NEG
45264: PUSH
45265: LD_INT 0
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 3
45274: NEG
45275: PUSH
45276: LD_INT 1
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 4
45285: NEG
45286: PUSH
45287: LD_INT 1
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 5
45296: NEG
45297: PUSH
45298: LD_INT 0
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 5
45307: NEG
45308: PUSH
45309: LD_INT 1
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 5
45319: NEG
45320: PUSH
45321: LD_INT 2
45323: NEG
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 3
45331: NEG
45332: PUSH
45333: LD_INT 2
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: ST_TO_ADDR
// end ; end ;
45387: GO 45390
45389: POP
// case btype of b_depot , b_warehouse :
45390: LD_VAR 0 1
45394: PUSH
45395: LD_INT 0
45397: DOUBLE
45398: EQUAL
45399: IFTRUE 45409
45401: LD_INT 1
45403: DOUBLE
45404: EQUAL
45405: IFTRUE 45409
45407: GO 45610
45409: POP
// case nation of nation_american :
45410: LD_VAR 0 5
45414: PUSH
45415: LD_INT 1
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45423
45421: GO 45479
45423: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45424: LD_ADDR_VAR 0 9
45428: PUSH
45429: LD_VAR 0 11
45433: PUSH
45434: LD_VAR 0 12
45438: PUSH
45439: LD_VAR 0 13
45443: PUSH
45444: LD_VAR 0 14
45448: PUSH
45449: LD_VAR 0 15
45453: PUSH
45454: LD_VAR 0 16
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: PUSH
45467: LD_VAR 0 4
45471: PUSH
45472: LD_INT 1
45474: PLUS
45475: ARRAY
45476: ST_TO_ADDR
45477: GO 45608
45479: LD_INT 2
45481: DOUBLE
45482: EQUAL
45483: IFTRUE 45487
45485: GO 45543
45487: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45488: LD_ADDR_VAR 0 9
45492: PUSH
45493: LD_VAR 0 17
45497: PUSH
45498: LD_VAR 0 18
45502: PUSH
45503: LD_VAR 0 19
45507: PUSH
45508: LD_VAR 0 20
45512: PUSH
45513: LD_VAR 0 21
45517: PUSH
45518: LD_VAR 0 22
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: PUSH
45531: LD_VAR 0 4
45535: PUSH
45536: LD_INT 1
45538: PLUS
45539: ARRAY
45540: ST_TO_ADDR
45541: GO 45608
45543: LD_INT 3
45545: DOUBLE
45546: EQUAL
45547: IFTRUE 45551
45549: GO 45607
45551: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45552: LD_ADDR_VAR 0 9
45556: PUSH
45557: LD_VAR 0 23
45561: PUSH
45562: LD_VAR 0 24
45566: PUSH
45567: LD_VAR 0 25
45571: PUSH
45572: LD_VAR 0 26
45576: PUSH
45577: LD_VAR 0 27
45581: PUSH
45582: LD_VAR 0 28
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: PUSH
45595: LD_VAR 0 4
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: ARRAY
45604: ST_TO_ADDR
45605: GO 45608
45607: POP
45608: GO 46163
45610: LD_INT 2
45612: DOUBLE
45613: EQUAL
45614: IFTRUE 45624
45616: LD_INT 3
45618: DOUBLE
45619: EQUAL
45620: IFTRUE 45624
45622: GO 45680
45624: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45625: LD_ADDR_VAR 0 9
45629: PUSH
45630: LD_VAR 0 29
45634: PUSH
45635: LD_VAR 0 30
45639: PUSH
45640: LD_VAR 0 31
45644: PUSH
45645: LD_VAR 0 32
45649: PUSH
45650: LD_VAR 0 33
45654: PUSH
45655: LD_VAR 0 34
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: PUSH
45668: LD_VAR 0 4
45672: PUSH
45673: LD_INT 1
45675: PLUS
45676: ARRAY
45677: ST_TO_ADDR
45678: GO 46163
45680: LD_INT 16
45682: DOUBLE
45683: EQUAL
45684: IFTRUE 45742
45686: LD_INT 17
45688: DOUBLE
45689: EQUAL
45690: IFTRUE 45742
45692: LD_INT 18
45694: DOUBLE
45695: EQUAL
45696: IFTRUE 45742
45698: LD_INT 19
45700: DOUBLE
45701: EQUAL
45702: IFTRUE 45742
45704: LD_INT 22
45706: DOUBLE
45707: EQUAL
45708: IFTRUE 45742
45710: LD_INT 20
45712: DOUBLE
45713: EQUAL
45714: IFTRUE 45742
45716: LD_INT 21
45718: DOUBLE
45719: EQUAL
45720: IFTRUE 45742
45722: LD_INT 23
45724: DOUBLE
45725: EQUAL
45726: IFTRUE 45742
45728: LD_INT 24
45730: DOUBLE
45731: EQUAL
45732: IFTRUE 45742
45734: LD_INT 25
45736: DOUBLE
45737: EQUAL
45738: IFTRUE 45742
45740: GO 45798
45742: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45743: LD_ADDR_VAR 0 9
45747: PUSH
45748: LD_VAR 0 35
45752: PUSH
45753: LD_VAR 0 36
45757: PUSH
45758: LD_VAR 0 37
45762: PUSH
45763: LD_VAR 0 38
45767: PUSH
45768: LD_VAR 0 39
45772: PUSH
45773: LD_VAR 0 40
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: PUSH
45786: LD_VAR 0 4
45790: PUSH
45791: LD_INT 1
45793: PLUS
45794: ARRAY
45795: ST_TO_ADDR
45796: GO 46163
45798: LD_INT 6
45800: DOUBLE
45801: EQUAL
45802: IFTRUE 45854
45804: LD_INT 7
45806: DOUBLE
45807: EQUAL
45808: IFTRUE 45854
45810: LD_INT 8
45812: DOUBLE
45813: EQUAL
45814: IFTRUE 45854
45816: LD_INT 13
45818: DOUBLE
45819: EQUAL
45820: IFTRUE 45854
45822: LD_INT 12
45824: DOUBLE
45825: EQUAL
45826: IFTRUE 45854
45828: LD_INT 15
45830: DOUBLE
45831: EQUAL
45832: IFTRUE 45854
45834: LD_INT 11
45836: DOUBLE
45837: EQUAL
45838: IFTRUE 45854
45840: LD_INT 14
45842: DOUBLE
45843: EQUAL
45844: IFTRUE 45854
45846: LD_INT 10
45848: DOUBLE
45849: EQUAL
45850: IFTRUE 45854
45852: GO 45910
45854: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45855: LD_ADDR_VAR 0 9
45859: PUSH
45860: LD_VAR 0 41
45864: PUSH
45865: LD_VAR 0 42
45869: PUSH
45870: LD_VAR 0 43
45874: PUSH
45875: LD_VAR 0 44
45879: PUSH
45880: LD_VAR 0 45
45884: PUSH
45885: LD_VAR 0 46
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: PUSH
45898: LD_VAR 0 4
45902: PUSH
45903: LD_INT 1
45905: PLUS
45906: ARRAY
45907: ST_TO_ADDR
45908: GO 46163
45910: LD_INT 36
45912: DOUBLE
45913: EQUAL
45914: IFTRUE 45918
45916: GO 45974
45918: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45919: LD_ADDR_VAR 0 9
45923: PUSH
45924: LD_VAR 0 47
45928: PUSH
45929: LD_VAR 0 48
45933: PUSH
45934: LD_VAR 0 49
45938: PUSH
45939: LD_VAR 0 50
45943: PUSH
45944: LD_VAR 0 51
45948: PUSH
45949: LD_VAR 0 52
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: PUSH
45962: LD_VAR 0 4
45966: PUSH
45967: LD_INT 1
45969: PLUS
45970: ARRAY
45971: ST_TO_ADDR
45972: GO 46163
45974: LD_INT 4
45976: DOUBLE
45977: EQUAL
45978: IFTRUE 46000
45980: LD_INT 5
45982: DOUBLE
45983: EQUAL
45984: IFTRUE 46000
45986: LD_INT 34
45988: DOUBLE
45989: EQUAL
45990: IFTRUE 46000
45992: LD_INT 37
45994: DOUBLE
45995: EQUAL
45996: IFTRUE 46000
45998: GO 46056
46000: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46001: LD_ADDR_VAR 0 9
46005: PUSH
46006: LD_VAR 0 53
46010: PUSH
46011: LD_VAR 0 54
46015: PUSH
46016: LD_VAR 0 55
46020: PUSH
46021: LD_VAR 0 56
46025: PUSH
46026: LD_VAR 0 57
46030: PUSH
46031: LD_VAR 0 58
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: PUSH
46044: LD_VAR 0 4
46048: PUSH
46049: LD_INT 1
46051: PLUS
46052: ARRAY
46053: ST_TO_ADDR
46054: GO 46163
46056: LD_INT 31
46058: DOUBLE
46059: EQUAL
46060: IFTRUE 46106
46062: LD_INT 32
46064: DOUBLE
46065: EQUAL
46066: IFTRUE 46106
46068: LD_INT 33
46070: DOUBLE
46071: EQUAL
46072: IFTRUE 46106
46074: LD_INT 27
46076: DOUBLE
46077: EQUAL
46078: IFTRUE 46106
46080: LD_INT 26
46082: DOUBLE
46083: EQUAL
46084: IFTRUE 46106
46086: LD_INT 28
46088: DOUBLE
46089: EQUAL
46090: IFTRUE 46106
46092: LD_INT 29
46094: DOUBLE
46095: EQUAL
46096: IFTRUE 46106
46098: LD_INT 30
46100: DOUBLE
46101: EQUAL
46102: IFTRUE 46106
46104: GO 46162
46106: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46107: LD_ADDR_VAR 0 9
46111: PUSH
46112: LD_VAR 0 59
46116: PUSH
46117: LD_VAR 0 60
46121: PUSH
46122: LD_VAR 0 61
46126: PUSH
46127: LD_VAR 0 62
46131: PUSH
46132: LD_VAR 0 63
46136: PUSH
46137: LD_VAR 0 64
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: PUSH
46150: LD_VAR 0 4
46154: PUSH
46155: LD_INT 1
46157: PLUS
46158: ARRAY
46159: ST_TO_ADDR
46160: GO 46163
46162: POP
// temp_list2 = [ ] ;
46163: LD_ADDR_VAR 0 10
46167: PUSH
46168: EMPTY
46169: ST_TO_ADDR
// for i in temp_list do
46170: LD_ADDR_VAR 0 8
46174: PUSH
46175: LD_VAR 0 9
46179: PUSH
46180: FOR_IN
46181: IFFALSE 46233
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46183: LD_ADDR_VAR 0 10
46187: PUSH
46188: LD_VAR 0 10
46192: PUSH
46193: LD_VAR 0 8
46197: PUSH
46198: LD_INT 1
46200: ARRAY
46201: PUSH
46202: LD_VAR 0 2
46206: PLUS
46207: PUSH
46208: LD_VAR 0 8
46212: PUSH
46213: LD_INT 2
46215: ARRAY
46216: PUSH
46217: LD_VAR 0 3
46221: PLUS
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: EMPTY
46228: LIST
46229: ADD
46230: ST_TO_ADDR
46231: GO 46180
46233: POP
46234: POP
// result = temp_list2 ;
46235: LD_ADDR_VAR 0 7
46239: PUSH
46240: LD_VAR 0 10
46244: ST_TO_ADDR
// end ;
46245: LD_VAR 0 7
46249: RET
// export function EnemyInRange ( unit , dist ) ; begin
46250: LD_INT 0
46252: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46253: LD_ADDR_VAR 0 3
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 255
46267: PPUSH
46268: LD_VAR 0 1
46272: PPUSH
46273: CALL_OW 250
46277: PPUSH
46278: LD_VAR 0 1
46282: PPUSH
46283: CALL_OW 251
46287: PPUSH
46288: LD_VAR 0 2
46292: PPUSH
46293: CALL 19646 0 4
46297: PUSH
46298: LD_INT 4
46300: ARRAY
46301: ST_TO_ADDR
// end ;
46302: LD_VAR 0 3
46306: RET
// export function PlayerSeeMe ( unit ) ; begin
46307: LD_INT 0
46309: PPUSH
// result := See ( your_side , unit ) ;
46310: LD_ADDR_VAR 0 2
46314: PUSH
46315: LD_OWVAR 2
46319: PPUSH
46320: LD_VAR 0 1
46324: PPUSH
46325: CALL_OW 292
46329: ST_TO_ADDR
// end ;
46330: LD_VAR 0 2
46334: RET
// export function ReverseDir ( unit ) ; begin
46335: LD_INT 0
46337: PPUSH
// if not unit then
46338: LD_VAR 0 1
46342: NOT
46343: IFFALSE 46347
// exit ;
46345: GO 46370
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46347: LD_ADDR_VAR 0 2
46351: PUSH
46352: LD_VAR 0 1
46356: PPUSH
46357: CALL_OW 254
46361: PUSH
46362: LD_INT 3
46364: PLUS
46365: PUSH
46366: LD_INT 6
46368: MOD
46369: ST_TO_ADDR
// end ;
46370: LD_VAR 0 2
46374: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
46375: LD_INT 0
46377: PPUSH
46378: PPUSH
46379: PPUSH
46380: PPUSH
46381: PPUSH
46382: PPUSH
// if not unit or not hexes then
46383: LD_VAR 0 1
46387: NOT
46388: PUSH
46389: LD_VAR 0 2
46393: NOT
46394: OR
46395: IFFALSE 46399
// exit ;
46397: GO 46522
// dist := 9999 ;
46399: LD_ADDR_VAR 0 5
46403: PUSH
46404: LD_INT 9999
46406: ST_TO_ADDR
// for i = 1 to hexes do
46407: LD_ADDR_VAR 0 4
46411: PUSH
46412: DOUBLE
46413: LD_INT 1
46415: DEC
46416: ST_TO_ADDR
46417: LD_VAR 0 2
46421: PUSH
46422: FOR_TO
46423: IFFALSE 46510
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46425: LD_ADDR_VAR 0 6
46429: PUSH
46430: LD_VAR 0 1
46434: PPUSH
46435: LD_VAR 0 2
46439: PUSH
46440: LD_VAR 0 4
46444: ARRAY
46445: PUSH
46446: LD_INT 1
46448: ARRAY
46449: PPUSH
46450: LD_VAR 0 2
46454: PUSH
46455: LD_VAR 0 4
46459: ARRAY
46460: PUSH
46461: LD_INT 2
46463: ARRAY
46464: PPUSH
46465: CALL_OW 297
46469: ST_TO_ADDR
// if tdist < dist then
46470: LD_VAR 0 6
46474: PUSH
46475: LD_VAR 0 5
46479: LESS
46480: IFFALSE 46508
// begin hex := hexes [ i ] ;
46482: LD_ADDR_VAR 0 8
46486: PUSH
46487: LD_VAR 0 2
46491: PUSH
46492: LD_VAR 0 4
46496: ARRAY
46497: ST_TO_ADDR
// dist := tdist ;
46498: LD_ADDR_VAR 0 5
46502: PUSH
46503: LD_VAR 0 6
46507: ST_TO_ADDR
// end ; end ;
46508: GO 46422
46510: POP
46511: POP
// result := hex ;
46512: LD_ADDR_VAR 0 3
46516: PUSH
46517: LD_VAR 0 8
46521: ST_TO_ADDR
// end ;
46522: LD_VAR 0 3
46526: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46527: LD_INT 0
46529: PPUSH
46530: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46531: LD_VAR 0 1
46535: NOT
46536: PUSH
46537: LD_VAR 0 1
46541: PUSH
46542: LD_INT 21
46544: PUSH
46545: LD_INT 2
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 23
46554: PUSH
46555: LD_INT 2
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PPUSH
46566: CALL_OW 69
46570: IN
46571: NOT
46572: OR
46573: IFFALSE 46577
// exit ;
46575: GO 46624
// for i = 1 to 3 do
46577: LD_ADDR_VAR 0 3
46581: PUSH
46582: DOUBLE
46583: LD_INT 1
46585: DEC
46586: ST_TO_ADDR
46587: LD_INT 3
46589: PUSH
46590: FOR_TO
46591: IFFALSE 46622
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46593: LD_VAR 0 1
46597: PPUSH
46598: CALL_OW 250
46602: PPUSH
46603: LD_VAR 0 1
46607: PPUSH
46608: CALL_OW 251
46612: PPUSH
46613: LD_INT 1
46615: PPUSH
46616: CALL_OW 453
46620: GO 46590
46622: POP
46623: POP
// end ;
46624: LD_VAR 0 2
46628: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46629: LD_INT 0
46631: PPUSH
46632: PPUSH
46633: PPUSH
46634: PPUSH
46635: PPUSH
46636: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46637: LD_VAR 0 1
46641: NOT
46642: PUSH
46643: LD_VAR 0 2
46647: NOT
46648: OR
46649: PUSH
46650: LD_VAR 0 1
46654: PPUSH
46655: CALL_OW 314
46659: OR
46660: IFFALSE 46664
// exit ;
46662: GO 47105
// x := GetX ( enemy_unit ) ;
46664: LD_ADDR_VAR 0 7
46668: PUSH
46669: LD_VAR 0 2
46673: PPUSH
46674: CALL_OW 250
46678: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46679: LD_ADDR_VAR 0 8
46683: PUSH
46684: LD_VAR 0 2
46688: PPUSH
46689: CALL_OW 251
46693: ST_TO_ADDR
// if not x or not y then
46694: LD_VAR 0 7
46698: NOT
46699: PUSH
46700: LD_VAR 0 8
46704: NOT
46705: OR
46706: IFFALSE 46710
// exit ;
46708: GO 47105
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46710: LD_ADDR_VAR 0 6
46714: PUSH
46715: LD_VAR 0 7
46719: PPUSH
46720: LD_INT 0
46722: PPUSH
46723: LD_INT 4
46725: PPUSH
46726: CALL_OW 272
46730: PUSH
46731: LD_VAR 0 8
46735: PPUSH
46736: LD_INT 0
46738: PPUSH
46739: LD_INT 4
46741: PPUSH
46742: CALL_OW 273
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_VAR 0 7
46755: PPUSH
46756: LD_INT 1
46758: PPUSH
46759: LD_INT 4
46761: PPUSH
46762: CALL_OW 272
46766: PUSH
46767: LD_VAR 0 8
46771: PPUSH
46772: LD_INT 1
46774: PPUSH
46775: LD_INT 4
46777: PPUSH
46778: CALL_OW 273
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_VAR 0 7
46791: PPUSH
46792: LD_INT 2
46794: PPUSH
46795: LD_INT 4
46797: PPUSH
46798: CALL_OW 272
46802: PUSH
46803: LD_VAR 0 8
46807: PPUSH
46808: LD_INT 2
46810: PPUSH
46811: LD_INT 4
46813: PPUSH
46814: CALL_OW 273
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_VAR 0 7
46827: PPUSH
46828: LD_INT 3
46830: PPUSH
46831: LD_INT 4
46833: PPUSH
46834: CALL_OW 272
46838: PUSH
46839: LD_VAR 0 8
46843: PPUSH
46844: LD_INT 3
46846: PPUSH
46847: LD_INT 4
46849: PPUSH
46850: CALL_OW 273
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_VAR 0 7
46863: PPUSH
46864: LD_INT 4
46866: PPUSH
46867: LD_INT 4
46869: PPUSH
46870: CALL_OW 272
46874: PUSH
46875: LD_VAR 0 8
46879: PPUSH
46880: LD_INT 4
46882: PPUSH
46883: LD_INT 4
46885: PPUSH
46886: CALL_OW 273
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: LD_VAR 0 7
46899: PPUSH
46900: LD_INT 5
46902: PPUSH
46903: LD_INT 4
46905: PPUSH
46906: CALL_OW 272
46910: PUSH
46911: LD_VAR 0 8
46915: PPUSH
46916: LD_INT 5
46918: PPUSH
46919: LD_INT 4
46921: PPUSH
46922: CALL_OW 273
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: ST_TO_ADDR
// for i = tmp downto 1 do
46939: LD_ADDR_VAR 0 4
46943: PUSH
46944: DOUBLE
46945: LD_VAR 0 6
46949: INC
46950: ST_TO_ADDR
46951: LD_INT 1
46953: PUSH
46954: FOR_DOWNTO
46955: IFFALSE 47056
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46957: LD_VAR 0 6
46961: PUSH
46962: LD_VAR 0 4
46966: ARRAY
46967: PUSH
46968: LD_INT 1
46970: ARRAY
46971: PPUSH
46972: LD_VAR 0 6
46976: PUSH
46977: LD_VAR 0 4
46981: ARRAY
46982: PUSH
46983: LD_INT 2
46985: ARRAY
46986: PPUSH
46987: CALL_OW 488
46991: NOT
46992: PUSH
46993: LD_VAR 0 6
46997: PUSH
46998: LD_VAR 0 4
47002: ARRAY
47003: PUSH
47004: LD_INT 1
47006: ARRAY
47007: PPUSH
47008: LD_VAR 0 6
47012: PUSH
47013: LD_VAR 0 4
47017: ARRAY
47018: PUSH
47019: LD_INT 2
47021: ARRAY
47022: PPUSH
47023: CALL_OW 428
47027: PUSH
47028: LD_INT 0
47030: NONEQUAL
47031: OR
47032: IFFALSE 47054
// tmp := Delete ( tmp , i ) ;
47034: LD_ADDR_VAR 0 6
47038: PUSH
47039: LD_VAR 0 6
47043: PPUSH
47044: LD_VAR 0 4
47048: PPUSH
47049: CALL_OW 3
47053: ST_TO_ADDR
47054: GO 46954
47056: POP
47057: POP
// j := GetClosestHex ( unit , tmp ) ;
47058: LD_ADDR_VAR 0 5
47062: PUSH
47063: LD_VAR 0 1
47067: PPUSH
47068: LD_VAR 0 6
47072: PPUSH
47073: CALL 46375 0 2
47077: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47078: LD_VAR 0 1
47082: PPUSH
47083: LD_VAR 0 5
47087: PUSH
47088: LD_INT 1
47090: ARRAY
47091: PPUSH
47092: LD_VAR 0 5
47096: PUSH
47097: LD_INT 2
47099: ARRAY
47100: PPUSH
47101: CALL_OW 111
// end ;
47105: LD_VAR 0 3
47109: RET
// export function PrepareApemanSoldier ( ) ; begin
47110: LD_INT 0
47112: PPUSH
// uc_nation := 0 ;
47113: LD_ADDR_OWVAR 21
47117: PUSH
47118: LD_INT 0
47120: ST_TO_ADDR
// hc_sex := sex_male ;
47121: LD_ADDR_OWVAR 27
47125: PUSH
47126: LD_INT 1
47128: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
47129: LD_ADDR_OWVAR 28
47133: PUSH
47134: LD_INT 15
47136: ST_TO_ADDR
// hc_gallery :=  ;
47137: LD_ADDR_OWVAR 33
47141: PUSH
47142: LD_STRING 
47144: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47145: LD_ADDR_OWVAR 31
47149: PUSH
47150: LD_INT 0
47152: PPUSH
47153: LD_INT 3
47155: PPUSH
47156: CALL_OW 12
47160: PUSH
47161: LD_INT 0
47163: PPUSH
47164: LD_INT 3
47166: PPUSH
47167: CALL_OW 12
47171: PUSH
47172: LD_INT 0
47174: PUSH
47175: LD_INT 0
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: ST_TO_ADDR
// end ;
47184: LD_VAR 0 1
47188: RET
// export function PrepareApemanEngineer ( ) ; begin
47189: LD_INT 0
47191: PPUSH
// uc_nation := 0 ;
47192: LD_ADDR_OWVAR 21
47196: PUSH
47197: LD_INT 0
47199: ST_TO_ADDR
// hc_sex := sex_male ;
47200: LD_ADDR_OWVAR 27
47204: PUSH
47205: LD_INT 1
47207: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
47208: LD_ADDR_OWVAR 28
47212: PUSH
47213: LD_INT 16
47215: ST_TO_ADDR
// hc_gallery :=  ;
47216: LD_ADDR_OWVAR 33
47220: PUSH
47221: LD_STRING 
47223: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47224: LD_ADDR_OWVAR 31
47228: PUSH
47229: LD_INT 0
47231: PPUSH
47232: LD_INT 3
47234: PPUSH
47235: CALL_OW 12
47239: PUSH
47240: LD_INT 0
47242: PPUSH
47243: LD_INT 3
47245: PPUSH
47246: CALL_OW 12
47250: PUSH
47251: LD_INT 0
47253: PUSH
47254: LD_INT 0
47256: PUSH
47257: EMPTY
47258: LIST
47259: LIST
47260: LIST
47261: LIST
47262: ST_TO_ADDR
// end ;
47263: LD_VAR 0 1
47267: RET
// export function PrepareApeman ( agressivity ) ; begin
47268: LD_INT 0
47270: PPUSH
// uc_side := 0 ;
47271: LD_ADDR_OWVAR 20
47275: PUSH
47276: LD_INT 0
47278: ST_TO_ADDR
// uc_nation := 0 ;
47279: LD_ADDR_OWVAR 21
47283: PUSH
47284: LD_INT 0
47286: ST_TO_ADDR
// hc_sex := sex_male ;
47287: LD_ADDR_OWVAR 27
47291: PUSH
47292: LD_INT 1
47294: ST_TO_ADDR
// hc_class := class_apeman ;
47295: LD_ADDR_OWVAR 28
47299: PUSH
47300: LD_INT 12
47302: ST_TO_ADDR
// hc_gallery :=  ;
47303: LD_ADDR_OWVAR 33
47307: PUSH
47308: LD_STRING 
47310: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47311: LD_ADDR_OWVAR 35
47315: PUSH
47316: LD_VAR 0 1
47320: NEG
47321: PPUSH
47322: LD_VAR 0 1
47326: PPUSH
47327: CALL_OW 12
47331: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47332: LD_ADDR_OWVAR 31
47336: PUSH
47337: LD_INT 0
47339: PPUSH
47340: LD_INT 3
47342: PPUSH
47343: CALL_OW 12
47347: PUSH
47348: LD_INT 0
47350: PPUSH
47351: LD_INT 3
47353: PPUSH
47354: CALL_OW 12
47358: PUSH
47359: LD_INT 0
47361: PUSH
47362: LD_INT 0
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: ST_TO_ADDR
// end ;
47371: LD_VAR 0 2
47375: RET
// export function PrepareTiger ( agressivity ) ; begin
47376: LD_INT 0
47378: PPUSH
// uc_side := 0 ;
47379: LD_ADDR_OWVAR 20
47383: PUSH
47384: LD_INT 0
47386: ST_TO_ADDR
// uc_nation := 0 ;
47387: LD_ADDR_OWVAR 21
47391: PUSH
47392: LD_INT 0
47394: ST_TO_ADDR
// hc_class := class_tiger ;
47395: LD_ADDR_OWVAR 28
47399: PUSH
47400: LD_INT 14
47402: ST_TO_ADDR
// hc_gallery :=  ;
47403: LD_ADDR_OWVAR 33
47407: PUSH
47408: LD_STRING 
47410: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47411: LD_ADDR_OWVAR 35
47415: PUSH
47416: LD_VAR 0 1
47420: NEG
47421: PPUSH
47422: LD_VAR 0 1
47426: PPUSH
47427: CALL_OW 12
47431: ST_TO_ADDR
// end ;
47432: LD_VAR 0 2
47436: RET
// export function PrepareEnchidna ( ) ; begin
47437: LD_INT 0
47439: PPUSH
// uc_side := 0 ;
47440: LD_ADDR_OWVAR 20
47444: PUSH
47445: LD_INT 0
47447: ST_TO_ADDR
// uc_nation := 0 ;
47448: LD_ADDR_OWVAR 21
47452: PUSH
47453: LD_INT 0
47455: ST_TO_ADDR
// hc_class := class_baggie ;
47456: LD_ADDR_OWVAR 28
47460: PUSH
47461: LD_INT 13
47463: ST_TO_ADDR
// hc_gallery :=  ;
47464: LD_ADDR_OWVAR 33
47468: PUSH
47469: LD_STRING 
47471: ST_TO_ADDR
// end ;
47472: LD_VAR 0 1
47476: RET
// export function PrepareFrog ( ) ; begin
47477: LD_INT 0
47479: PPUSH
// uc_side := 0 ;
47480: LD_ADDR_OWVAR 20
47484: PUSH
47485: LD_INT 0
47487: ST_TO_ADDR
// uc_nation := 0 ;
47488: LD_ADDR_OWVAR 21
47492: PUSH
47493: LD_INT 0
47495: ST_TO_ADDR
// hc_class := class_frog ;
47496: LD_ADDR_OWVAR 28
47500: PUSH
47501: LD_INT 19
47503: ST_TO_ADDR
// hc_gallery :=  ;
47504: LD_ADDR_OWVAR 33
47508: PUSH
47509: LD_STRING 
47511: ST_TO_ADDR
// end ;
47512: LD_VAR 0 1
47516: RET
// export function PrepareFish ( ) ; begin
47517: LD_INT 0
47519: PPUSH
// uc_side := 0 ;
47520: LD_ADDR_OWVAR 20
47524: PUSH
47525: LD_INT 0
47527: ST_TO_ADDR
// uc_nation := 0 ;
47528: LD_ADDR_OWVAR 21
47532: PUSH
47533: LD_INT 0
47535: ST_TO_ADDR
// hc_class := class_fish ;
47536: LD_ADDR_OWVAR 28
47540: PUSH
47541: LD_INT 20
47543: ST_TO_ADDR
// hc_gallery :=  ;
47544: LD_ADDR_OWVAR 33
47548: PUSH
47549: LD_STRING 
47551: ST_TO_ADDR
// end ;
47552: LD_VAR 0 1
47556: RET
// export function PrepareBird ( ) ; begin
47557: LD_INT 0
47559: PPUSH
// uc_side := 0 ;
47560: LD_ADDR_OWVAR 20
47564: PUSH
47565: LD_INT 0
47567: ST_TO_ADDR
// uc_nation := 0 ;
47568: LD_ADDR_OWVAR 21
47572: PUSH
47573: LD_INT 0
47575: ST_TO_ADDR
// hc_class := class_phororhacos ;
47576: LD_ADDR_OWVAR 28
47580: PUSH
47581: LD_INT 18
47583: ST_TO_ADDR
// hc_gallery :=  ;
47584: LD_ADDR_OWVAR 33
47588: PUSH
47589: LD_STRING 
47591: ST_TO_ADDR
// end ;
47592: LD_VAR 0 1
47596: RET
// export function PrepareHorse ( ) ; begin
47597: LD_INT 0
47599: PPUSH
// uc_side := 0 ;
47600: LD_ADDR_OWVAR 20
47604: PUSH
47605: LD_INT 0
47607: ST_TO_ADDR
// uc_nation := 0 ;
47608: LD_ADDR_OWVAR 21
47612: PUSH
47613: LD_INT 0
47615: ST_TO_ADDR
// hc_class := class_horse ;
47616: LD_ADDR_OWVAR 28
47620: PUSH
47621: LD_INT 21
47623: ST_TO_ADDR
// hc_gallery :=  ;
47624: LD_ADDR_OWVAR 33
47628: PUSH
47629: LD_STRING 
47631: ST_TO_ADDR
// end ;
47632: LD_VAR 0 1
47636: RET
// export function PrepareMastodont ( ) ; begin
47637: LD_INT 0
47639: PPUSH
// uc_side := 0 ;
47640: LD_ADDR_OWVAR 20
47644: PUSH
47645: LD_INT 0
47647: ST_TO_ADDR
// uc_nation := 0 ;
47648: LD_ADDR_OWVAR 21
47652: PUSH
47653: LD_INT 0
47655: ST_TO_ADDR
// vc_chassis := class_mastodont ;
47656: LD_ADDR_OWVAR 37
47660: PUSH
47661: LD_INT 31
47663: ST_TO_ADDR
// vc_control := control_rider ;
47664: LD_ADDR_OWVAR 38
47668: PUSH
47669: LD_INT 4
47671: ST_TO_ADDR
// end ;
47672: LD_VAR 0 1
47676: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47677: LD_INT 0
47679: PPUSH
47680: PPUSH
47681: PPUSH
// uc_side = 0 ;
47682: LD_ADDR_OWVAR 20
47686: PUSH
47687: LD_INT 0
47689: ST_TO_ADDR
// uc_nation = 0 ;
47690: LD_ADDR_OWVAR 21
47694: PUSH
47695: LD_INT 0
47697: ST_TO_ADDR
// InitHc_All ( ) ;
47698: CALL_OW 584
// InitVc ;
47702: CALL_OW 20
// if mastodonts then
47706: LD_VAR 0 6
47710: IFFALSE 47777
// for i = 1 to mastodonts do
47712: LD_ADDR_VAR 0 11
47716: PUSH
47717: DOUBLE
47718: LD_INT 1
47720: DEC
47721: ST_TO_ADDR
47722: LD_VAR 0 6
47726: PUSH
47727: FOR_TO
47728: IFFALSE 47775
// begin vc_chassis := 31 ;
47730: LD_ADDR_OWVAR 37
47734: PUSH
47735: LD_INT 31
47737: ST_TO_ADDR
// vc_control := control_rider ;
47738: LD_ADDR_OWVAR 38
47742: PUSH
47743: LD_INT 4
47745: ST_TO_ADDR
// animal := CreateVehicle ;
47746: LD_ADDR_VAR 0 12
47750: PUSH
47751: CALL_OW 45
47755: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47756: LD_VAR 0 12
47760: PPUSH
47761: LD_VAR 0 8
47765: PPUSH
47766: LD_INT 0
47768: PPUSH
47769: CALL 49912 0 3
// end ;
47773: GO 47727
47775: POP
47776: POP
// if horses then
47777: LD_VAR 0 5
47781: IFFALSE 47848
// for i = 1 to horses do
47783: LD_ADDR_VAR 0 11
47787: PUSH
47788: DOUBLE
47789: LD_INT 1
47791: DEC
47792: ST_TO_ADDR
47793: LD_VAR 0 5
47797: PUSH
47798: FOR_TO
47799: IFFALSE 47846
// begin hc_class := 21 ;
47801: LD_ADDR_OWVAR 28
47805: PUSH
47806: LD_INT 21
47808: ST_TO_ADDR
// hc_gallery :=  ;
47809: LD_ADDR_OWVAR 33
47813: PUSH
47814: LD_STRING 
47816: ST_TO_ADDR
// animal := CreateHuman ;
47817: LD_ADDR_VAR 0 12
47821: PUSH
47822: CALL_OW 44
47826: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47827: LD_VAR 0 12
47831: PPUSH
47832: LD_VAR 0 8
47836: PPUSH
47837: LD_INT 0
47839: PPUSH
47840: CALL 49912 0 3
// end ;
47844: GO 47798
47846: POP
47847: POP
// if birds then
47848: LD_VAR 0 1
47852: IFFALSE 47919
// for i = 1 to birds do
47854: LD_ADDR_VAR 0 11
47858: PUSH
47859: DOUBLE
47860: LD_INT 1
47862: DEC
47863: ST_TO_ADDR
47864: LD_VAR 0 1
47868: PUSH
47869: FOR_TO
47870: IFFALSE 47917
// begin hc_class = 18 ;
47872: LD_ADDR_OWVAR 28
47876: PUSH
47877: LD_INT 18
47879: ST_TO_ADDR
// hc_gallery =  ;
47880: LD_ADDR_OWVAR 33
47884: PUSH
47885: LD_STRING 
47887: ST_TO_ADDR
// animal := CreateHuman ;
47888: LD_ADDR_VAR 0 12
47892: PUSH
47893: CALL_OW 44
47897: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47898: LD_VAR 0 12
47902: PPUSH
47903: LD_VAR 0 8
47907: PPUSH
47908: LD_INT 0
47910: PPUSH
47911: CALL 49912 0 3
// end ;
47915: GO 47869
47917: POP
47918: POP
// if tigers then
47919: LD_VAR 0 2
47923: IFFALSE 48007
// for i = 1 to tigers do
47925: LD_ADDR_VAR 0 11
47929: PUSH
47930: DOUBLE
47931: LD_INT 1
47933: DEC
47934: ST_TO_ADDR
47935: LD_VAR 0 2
47939: PUSH
47940: FOR_TO
47941: IFFALSE 48005
// begin hc_class = class_tiger ;
47943: LD_ADDR_OWVAR 28
47947: PUSH
47948: LD_INT 14
47950: ST_TO_ADDR
// hc_gallery =  ;
47951: LD_ADDR_OWVAR 33
47955: PUSH
47956: LD_STRING 
47958: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47959: LD_ADDR_OWVAR 35
47963: PUSH
47964: LD_INT 7
47966: NEG
47967: PPUSH
47968: LD_INT 7
47970: PPUSH
47971: CALL_OW 12
47975: ST_TO_ADDR
// animal := CreateHuman ;
47976: LD_ADDR_VAR 0 12
47980: PUSH
47981: CALL_OW 44
47985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47986: LD_VAR 0 12
47990: PPUSH
47991: LD_VAR 0 8
47995: PPUSH
47996: LD_INT 0
47998: PPUSH
47999: CALL 49912 0 3
// end ;
48003: GO 47940
48005: POP
48006: POP
// if apemans then
48007: LD_VAR 0 3
48011: IFFALSE 48134
// for i = 1 to apemans do
48013: LD_ADDR_VAR 0 11
48017: PUSH
48018: DOUBLE
48019: LD_INT 1
48021: DEC
48022: ST_TO_ADDR
48023: LD_VAR 0 3
48027: PUSH
48028: FOR_TO
48029: IFFALSE 48132
// begin hc_class = class_apeman ;
48031: LD_ADDR_OWVAR 28
48035: PUSH
48036: LD_INT 12
48038: ST_TO_ADDR
// hc_gallery =  ;
48039: LD_ADDR_OWVAR 33
48043: PUSH
48044: LD_STRING 
48046: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48047: LD_ADDR_OWVAR 35
48051: PUSH
48052: LD_INT 2
48054: NEG
48055: PPUSH
48056: LD_INT 2
48058: PPUSH
48059: CALL_OW 12
48063: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48064: LD_ADDR_OWVAR 31
48068: PUSH
48069: LD_INT 1
48071: PPUSH
48072: LD_INT 3
48074: PPUSH
48075: CALL_OW 12
48079: PUSH
48080: LD_INT 1
48082: PPUSH
48083: LD_INT 3
48085: PPUSH
48086: CALL_OW 12
48090: PUSH
48091: LD_INT 0
48093: PUSH
48094: LD_INT 0
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: LIST
48101: LIST
48102: ST_TO_ADDR
// animal := CreateHuman ;
48103: LD_ADDR_VAR 0 12
48107: PUSH
48108: CALL_OW 44
48112: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48113: LD_VAR 0 12
48117: PPUSH
48118: LD_VAR 0 8
48122: PPUSH
48123: LD_INT 0
48125: PPUSH
48126: CALL 49912 0 3
// end ;
48130: GO 48028
48132: POP
48133: POP
// if enchidnas then
48134: LD_VAR 0 4
48138: IFFALSE 48205
// for i = 1 to enchidnas do
48140: LD_ADDR_VAR 0 11
48144: PUSH
48145: DOUBLE
48146: LD_INT 1
48148: DEC
48149: ST_TO_ADDR
48150: LD_VAR 0 4
48154: PUSH
48155: FOR_TO
48156: IFFALSE 48203
// begin hc_class = 13 ;
48158: LD_ADDR_OWVAR 28
48162: PUSH
48163: LD_INT 13
48165: ST_TO_ADDR
// hc_gallery =  ;
48166: LD_ADDR_OWVAR 33
48170: PUSH
48171: LD_STRING 
48173: ST_TO_ADDR
// animal := CreateHuman ;
48174: LD_ADDR_VAR 0 12
48178: PUSH
48179: CALL_OW 44
48183: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48184: LD_VAR 0 12
48188: PPUSH
48189: LD_VAR 0 8
48193: PPUSH
48194: LD_INT 0
48196: PPUSH
48197: CALL 49912 0 3
// end ;
48201: GO 48155
48203: POP
48204: POP
// if fishes then
48205: LD_VAR 0 7
48209: IFFALSE 48276
// for i = 1 to fishes do
48211: LD_ADDR_VAR 0 11
48215: PUSH
48216: DOUBLE
48217: LD_INT 1
48219: DEC
48220: ST_TO_ADDR
48221: LD_VAR 0 7
48225: PUSH
48226: FOR_TO
48227: IFFALSE 48274
// begin hc_class = 20 ;
48229: LD_ADDR_OWVAR 28
48233: PUSH
48234: LD_INT 20
48236: ST_TO_ADDR
// hc_gallery =  ;
48237: LD_ADDR_OWVAR 33
48241: PUSH
48242: LD_STRING 
48244: ST_TO_ADDR
// animal := CreateHuman ;
48245: LD_ADDR_VAR 0 12
48249: PUSH
48250: CALL_OW 44
48254: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48255: LD_VAR 0 12
48259: PPUSH
48260: LD_VAR 0 9
48264: PPUSH
48265: LD_INT 0
48267: PPUSH
48268: CALL 49912 0 3
// end ;
48272: GO 48226
48274: POP
48275: POP
// end ;
48276: LD_VAR 0 10
48280: RET
// export function WantHeal ( sci , unit ) ; begin
48281: LD_INT 0
48283: PPUSH
// if GetTaskList ( sci ) > 0 then
48284: LD_VAR 0 1
48288: PPUSH
48289: CALL_OW 437
48293: PUSH
48294: LD_INT 0
48296: GREATER
48297: IFFALSE 48367
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48299: LD_VAR 0 1
48303: PPUSH
48304: CALL_OW 437
48308: PUSH
48309: LD_INT 1
48311: ARRAY
48312: PUSH
48313: LD_INT 1
48315: ARRAY
48316: PUSH
48317: LD_STRING l
48319: EQUAL
48320: PUSH
48321: LD_VAR 0 1
48325: PPUSH
48326: CALL_OW 437
48330: PUSH
48331: LD_INT 1
48333: ARRAY
48334: PUSH
48335: LD_INT 4
48337: ARRAY
48338: PUSH
48339: LD_VAR 0 2
48343: EQUAL
48344: AND
48345: IFFALSE 48357
// result := true else
48347: LD_ADDR_VAR 0 3
48351: PUSH
48352: LD_INT 1
48354: ST_TO_ADDR
48355: GO 48365
// result := false ;
48357: LD_ADDR_VAR 0 3
48361: PUSH
48362: LD_INT 0
48364: ST_TO_ADDR
// end else
48365: GO 48375
// result := false ;
48367: LD_ADDR_VAR 0 3
48371: PUSH
48372: LD_INT 0
48374: ST_TO_ADDR
// end ;
48375: LD_VAR 0 3
48379: RET
// export function HealTarget ( sci ) ; begin
48380: LD_INT 0
48382: PPUSH
// if not sci then
48383: LD_VAR 0 1
48387: NOT
48388: IFFALSE 48392
// exit ;
48390: GO 48457
// result := 0 ;
48392: LD_ADDR_VAR 0 2
48396: PUSH
48397: LD_INT 0
48399: ST_TO_ADDR
// if GetTaskList ( sci ) then
48400: LD_VAR 0 1
48404: PPUSH
48405: CALL_OW 437
48409: IFFALSE 48457
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48411: LD_VAR 0 1
48415: PPUSH
48416: CALL_OW 437
48420: PUSH
48421: LD_INT 1
48423: ARRAY
48424: PUSH
48425: LD_INT 1
48427: ARRAY
48428: PUSH
48429: LD_STRING l
48431: EQUAL
48432: IFFALSE 48457
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48434: LD_ADDR_VAR 0 2
48438: PUSH
48439: LD_VAR 0 1
48443: PPUSH
48444: CALL_OW 437
48448: PUSH
48449: LD_INT 1
48451: ARRAY
48452: PUSH
48453: LD_INT 4
48455: ARRAY
48456: ST_TO_ADDR
// end ;
48457: LD_VAR 0 2
48461: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48462: LD_INT 0
48464: PPUSH
48465: PPUSH
48466: PPUSH
48467: PPUSH
// if not base_units then
48468: LD_VAR 0 1
48472: NOT
48473: IFFALSE 48477
// exit ;
48475: GO 48564
// result := false ;
48477: LD_ADDR_VAR 0 2
48481: PUSH
48482: LD_INT 0
48484: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48485: LD_ADDR_VAR 0 5
48489: PUSH
48490: LD_VAR 0 1
48494: PPUSH
48495: LD_INT 21
48497: PUSH
48498: LD_INT 3
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PPUSH
48505: CALL_OW 72
48509: ST_TO_ADDR
// if not tmp then
48510: LD_VAR 0 5
48514: NOT
48515: IFFALSE 48519
// exit ;
48517: GO 48564
// for i in tmp do
48519: LD_ADDR_VAR 0 3
48523: PUSH
48524: LD_VAR 0 5
48528: PUSH
48529: FOR_IN
48530: IFFALSE 48562
// begin result := EnemyInRange ( i , 22 ) ;
48532: LD_ADDR_VAR 0 2
48536: PUSH
48537: LD_VAR 0 3
48541: PPUSH
48542: LD_INT 22
48544: PPUSH
48545: CALL 46250 0 2
48549: ST_TO_ADDR
// if result then
48550: LD_VAR 0 2
48554: IFFALSE 48560
// exit ;
48556: POP
48557: POP
48558: GO 48564
// end ;
48560: GO 48529
48562: POP
48563: POP
// end ;
48564: LD_VAR 0 2
48568: RET
// export function FilterByTag ( units , tag ) ; begin
48569: LD_INT 0
48571: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
48572: LD_ADDR_VAR 0 3
48576: PUSH
48577: LD_VAR 0 1
48581: PPUSH
48582: LD_INT 120
48584: PUSH
48585: LD_VAR 0 2
48589: PUSH
48590: EMPTY
48591: LIST
48592: LIST
48593: PPUSH
48594: CALL_OW 72
48598: ST_TO_ADDR
// end ;
48599: LD_VAR 0 3
48603: RET
// export function IsDriver ( un ) ; begin
48604: LD_INT 0
48606: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48607: LD_ADDR_VAR 0 2
48611: PUSH
48612: LD_VAR 0 1
48616: PUSH
48617: LD_INT 55
48619: PUSH
48620: EMPTY
48621: LIST
48622: PPUSH
48623: CALL_OW 69
48627: IN
48628: ST_TO_ADDR
// end ;
48629: LD_VAR 0 2
48633: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48634: LD_INT 0
48636: PPUSH
48637: PPUSH
// list := [ ] ;
48638: LD_ADDR_VAR 0 5
48642: PUSH
48643: EMPTY
48644: ST_TO_ADDR
// case d of 0 :
48645: LD_VAR 0 3
48649: PUSH
48650: LD_INT 0
48652: DOUBLE
48653: EQUAL
48654: IFTRUE 48658
48656: GO 48791
48658: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48659: LD_ADDR_VAR 0 5
48663: PUSH
48664: LD_VAR 0 1
48668: PUSH
48669: LD_INT 4
48671: MINUS
48672: PUSH
48673: LD_VAR 0 2
48677: PUSH
48678: LD_INT 4
48680: MINUS
48681: PUSH
48682: LD_INT 2
48684: PUSH
48685: EMPTY
48686: LIST
48687: LIST
48688: LIST
48689: PUSH
48690: LD_VAR 0 1
48694: PUSH
48695: LD_INT 3
48697: MINUS
48698: PUSH
48699: LD_VAR 0 2
48703: PUSH
48704: LD_INT 1
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: LIST
48711: PUSH
48712: LD_VAR 0 1
48716: PUSH
48717: LD_INT 4
48719: PLUS
48720: PUSH
48721: LD_VAR 0 2
48725: PUSH
48726: LD_INT 4
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: LIST
48733: PUSH
48734: LD_VAR 0 1
48738: PUSH
48739: LD_INT 3
48741: PLUS
48742: PUSH
48743: LD_VAR 0 2
48747: PUSH
48748: LD_INT 3
48750: PLUS
48751: PUSH
48752: LD_INT 5
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: LIST
48759: PUSH
48760: LD_VAR 0 1
48764: PUSH
48765: LD_VAR 0 2
48769: PUSH
48770: LD_INT 4
48772: PLUS
48773: PUSH
48774: LD_INT 0
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: LIST
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: ST_TO_ADDR
// end ; 1 :
48789: GO 49489
48791: LD_INT 1
48793: DOUBLE
48794: EQUAL
48795: IFTRUE 48799
48797: GO 48932
48799: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48800: LD_ADDR_VAR 0 5
48804: PUSH
48805: LD_VAR 0 1
48809: PUSH
48810: LD_VAR 0 2
48814: PUSH
48815: LD_INT 4
48817: MINUS
48818: PUSH
48819: LD_INT 3
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: LIST
48826: PUSH
48827: LD_VAR 0 1
48831: PUSH
48832: LD_INT 3
48834: MINUS
48835: PUSH
48836: LD_VAR 0 2
48840: PUSH
48841: LD_INT 3
48843: MINUS
48844: PUSH
48845: LD_INT 2
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: LIST
48852: PUSH
48853: LD_VAR 0 1
48857: PUSH
48858: LD_INT 4
48860: MINUS
48861: PUSH
48862: LD_VAR 0 2
48866: PUSH
48867: LD_INT 1
48869: PUSH
48870: EMPTY
48871: LIST
48872: LIST
48873: LIST
48874: PUSH
48875: LD_VAR 0 1
48879: PUSH
48880: LD_VAR 0 2
48884: PUSH
48885: LD_INT 3
48887: PLUS
48888: PUSH
48889: LD_INT 0
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: LIST
48896: PUSH
48897: LD_VAR 0 1
48901: PUSH
48902: LD_INT 4
48904: PLUS
48905: PUSH
48906: LD_VAR 0 2
48910: PUSH
48911: LD_INT 4
48913: PLUS
48914: PUSH
48915: LD_INT 5
48917: PUSH
48918: EMPTY
48919: LIST
48920: LIST
48921: LIST
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: ST_TO_ADDR
// end ; 2 :
48930: GO 49489
48932: LD_INT 2
48934: DOUBLE
48935: EQUAL
48936: IFTRUE 48940
48938: GO 49069
48940: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48941: LD_ADDR_VAR 0 5
48945: PUSH
48946: LD_VAR 0 1
48950: PUSH
48951: LD_VAR 0 2
48955: PUSH
48956: LD_INT 3
48958: MINUS
48959: PUSH
48960: LD_INT 3
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: LIST
48967: PUSH
48968: LD_VAR 0 1
48972: PUSH
48973: LD_INT 4
48975: PLUS
48976: PUSH
48977: LD_VAR 0 2
48981: PUSH
48982: LD_INT 4
48984: PUSH
48985: EMPTY
48986: LIST
48987: LIST
48988: LIST
48989: PUSH
48990: LD_VAR 0 1
48994: PUSH
48995: LD_VAR 0 2
48999: PUSH
49000: LD_INT 4
49002: PLUS
49003: PUSH
49004: LD_INT 0
49006: PUSH
49007: EMPTY
49008: LIST
49009: LIST
49010: LIST
49011: PUSH
49012: LD_VAR 0 1
49016: PUSH
49017: LD_INT 3
49019: MINUS
49020: PUSH
49021: LD_VAR 0 2
49025: PUSH
49026: LD_INT 1
49028: PUSH
49029: EMPTY
49030: LIST
49031: LIST
49032: LIST
49033: PUSH
49034: LD_VAR 0 1
49038: PUSH
49039: LD_INT 4
49041: MINUS
49042: PUSH
49043: LD_VAR 0 2
49047: PUSH
49048: LD_INT 4
49050: MINUS
49051: PUSH
49052: LD_INT 2
49054: PUSH
49055: EMPTY
49056: LIST
49057: LIST
49058: LIST
49059: PUSH
49060: EMPTY
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: ST_TO_ADDR
// end ; 3 :
49067: GO 49489
49069: LD_INT 3
49071: DOUBLE
49072: EQUAL
49073: IFTRUE 49077
49075: GO 49210
49077: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49078: LD_ADDR_VAR 0 5
49082: PUSH
49083: LD_VAR 0 1
49087: PUSH
49088: LD_INT 3
49090: PLUS
49091: PUSH
49092: LD_VAR 0 2
49096: PUSH
49097: LD_INT 4
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: LIST
49104: PUSH
49105: LD_VAR 0 1
49109: PUSH
49110: LD_INT 4
49112: PLUS
49113: PUSH
49114: LD_VAR 0 2
49118: PUSH
49119: LD_INT 4
49121: PLUS
49122: PUSH
49123: LD_INT 5
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: LIST
49130: PUSH
49131: LD_VAR 0 1
49135: PUSH
49136: LD_INT 4
49138: MINUS
49139: PUSH
49140: LD_VAR 0 2
49144: PUSH
49145: LD_INT 1
49147: PUSH
49148: EMPTY
49149: LIST
49150: LIST
49151: LIST
49152: PUSH
49153: LD_VAR 0 1
49157: PUSH
49158: LD_VAR 0 2
49162: PUSH
49163: LD_INT 4
49165: MINUS
49166: PUSH
49167: LD_INT 3
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: LIST
49174: PUSH
49175: LD_VAR 0 1
49179: PUSH
49180: LD_INT 3
49182: MINUS
49183: PUSH
49184: LD_VAR 0 2
49188: PUSH
49189: LD_INT 3
49191: MINUS
49192: PUSH
49193: LD_INT 2
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: LIST
49200: PUSH
49201: EMPTY
49202: LIST
49203: LIST
49204: LIST
49205: LIST
49206: LIST
49207: ST_TO_ADDR
// end ; 4 :
49208: GO 49489
49210: LD_INT 4
49212: DOUBLE
49213: EQUAL
49214: IFTRUE 49218
49216: GO 49351
49218: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49219: LD_ADDR_VAR 0 5
49223: PUSH
49224: LD_VAR 0 1
49228: PUSH
49229: LD_VAR 0 2
49233: PUSH
49234: LD_INT 4
49236: PLUS
49237: PUSH
49238: LD_INT 0
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: LIST
49245: PUSH
49246: LD_VAR 0 1
49250: PUSH
49251: LD_INT 3
49253: PLUS
49254: PUSH
49255: LD_VAR 0 2
49259: PUSH
49260: LD_INT 3
49262: PLUS
49263: PUSH
49264: LD_INT 5
49266: PUSH
49267: EMPTY
49268: LIST
49269: LIST
49270: LIST
49271: PUSH
49272: LD_VAR 0 1
49276: PUSH
49277: LD_INT 4
49279: PLUS
49280: PUSH
49281: LD_VAR 0 2
49285: PUSH
49286: LD_INT 4
49288: PUSH
49289: EMPTY
49290: LIST
49291: LIST
49292: LIST
49293: PUSH
49294: LD_VAR 0 1
49298: PUSH
49299: LD_VAR 0 2
49303: PUSH
49304: LD_INT 3
49306: MINUS
49307: PUSH
49308: LD_INT 3
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: LIST
49315: PUSH
49316: LD_VAR 0 1
49320: PUSH
49321: LD_INT 4
49323: MINUS
49324: PUSH
49325: LD_VAR 0 2
49329: PUSH
49330: LD_INT 4
49332: MINUS
49333: PUSH
49334: LD_INT 2
49336: PUSH
49337: EMPTY
49338: LIST
49339: LIST
49340: LIST
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: ST_TO_ADDR
// end ; 5 :
49349: GO 49489
49351: LD_INT 5
49353: DOUBLE
49354: EQUAL
49355: IFTRUE 49359
49357: GO 49488
49359: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49360: LD_ADDR_VAR 0 5
49364: PUSH
49365: LD_VAR 0 1
49369: PUSH
49370: LD_INT 4
49372: MINUS
49373: PUSH
49374: LD_VAR 0 2
49378: PUSH
49379: LD_INT 1
49381: PUSH
49382: EMPTY
49383: LIST
49384: LIST
49385: LIST
49386: PUSH
49387: LD_VAR 0 1
49391: PUSH
49392: LD_VAR 0 2
49396: PUSH
49397: LD_INT 4
49399: MINUS
49400: PUSH
49401: LD_INT 3
49403: PUSH
49404: EMPTY
49405: LIST
49406: LIST
49407: LIST
49408: PUSH
49409: LD_VAR 0 1
49413: PUSH
49414: LD_INT 4
49416: PLUS
49417: PUSH
49418: LD_VAR 0 2
49422: PUSH
49423: LD_INT 4
49425: PLUS
49426: PUSH
49427: LD_INT 5
49429: PUSH
49430: EMPTY
49431: LIST
49432: LIST
49433: LIST
49434: PUSH
49435: LD_VAR 0 1
49439: PUSH
49440: LD_INT 3
49442: PLUS
49443: PUSH
49444: LD_VAR 0 2
49448: PUSH
49449: LD_INT 4
49451: PUSH
49452: EMPTY
49453: LIST
49454: LIST
49455: LIST
49456: PUSH
49457: LD_VAR 0 1
49461: PUSH
49462: LD_VAR 0 2
49466: PUSH
49467: LD_INT 3
49469: PLUS
49470: PUSH
49471: LD_INT 0
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: LIST
49478: PUSH
49479: EMPTY
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: ST_TO_ADDR
// end ; end ;
49486: GO 49489
49488: POP
// result := list ;
49489: LD_ADDR_VAR 0 4
49493: PUSH
49494: LD_VAR 0 5
49498: ST_TO_ADDR
// end ;
49499: LD_VAR 0 4
49503: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49504: LD_INT 0
49506: PPUSH
49507: PPUSH
49508: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49509: LD_VAR 0 1
49513: NOT
49514: PUSH
49515: LD_VAR 0 2
49519: PUSH
49520: LD_INT 1
49522: PUSH
49523: LD_INT 2
49525: PUSH
49526: LD_INT 3
49528: PUSH
49529: LD_INT 4
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: LIST
49536: LIST
49537: IN
49538: NOT
49539: OR
49540: IFFALSE 49544
// exit ;
49542: GO 49636
// tmp := [ ] ;
49544: LD_ADDR_VAR 0 5
49548: PUSH
49549: EMPTY
49550: ST_TO_ADDR
// for i in units do
49551: LD_ADDR_VAR 0 4
49555: PUSH
49556: LD_VAR 0 1
49560: PUSH
49561: FOR_IN
49562: IFFALSE 49605
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49564: LD_ADDR_VAR 0 5
49568: PUSH
49569: LD_VAR 0 5
49573: PPUSH
49574: LD_VAR 0 5
49578: PUSH
49579: LD_INT 1
49581: PLUS
49582: PPUSH
49583: LD_VAR 0 4
49587: PPUSH
49588: LD_VAR 0 2
49592: PPUSH
49593: CALL_OW 259
49597: PPUSH
49598: CALL_OW 2
49602: ST_TO_ADDR
49603: GO 49561
49605: POP
49606: POP
// if not tmp then
49607: LD_VAR 0 5
49611: NOT
49612: IFFALSE 49616
// exit ;
49614: GO 49636
// result := SortListByListDesc ( units , tmp ) ;
49616: LD_ADDR_VAR 0 3
49620: PUSH
49621: LD_VAR 0 1
49625: PPUSH
49626: LD_VAR 0 5
49630: PPUSH
49631: CALL_OW 77
49635: ST_TO_ADDR
// end ;
49636: LD_VAR 0 3
49640: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49641: LD_INT 0
49643: PPUSH
49644: PPUSH
49645: PPUSH
// result := false ;
49646: LD_ADDR_VAR 0 3
49650: PUSH
49651: LD_INT 0
49653: ST_TO_ADDR
// x := GetX ( building ) ;
49654: LD_ADDR_VAR 0 4
49658: PUSH
49659: LD_VAR 0 2
49663: PPUSH
49664: CALL_OW 250
49668: ST_TO_ADDR
// y := GetY ( building ) ;
49669: LD_ADDR_VAR 0 5
49673: PUSH
49674: LD_VAR 0 2
49678: PPUSH
49679: CALL_OW 251
49683: ST_TO_ADDR
// if not building or not x or not y then
49684: LD_VAR 0 2
49688: NOT
49689: PUSH
49690: LD_VAR 0 4
49694: NOT
49695: OR
49696: PUSH
49697: LD_VAR 0 5
49701: NOT
49702: OR
49703: IFFALSE 49707
// exit ;
49705: GO 49799
// if GetTaskList ( unit ) then
49707: LD_VAR 0 1
49711: PPUSH
49712: CALL_OW 437
49716: IFFALSE 49799
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49718: LD_STRING e
49720: PUSH
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL_OW 437
49730: PUSH
49731: LD_INT 1
49733: ARRAY
49734: PUSH
49735: LD_INT 1
49737: ARRAY
49738: EQUAL
49739: PUSH
49740: LD_VAR 0 4
49744: PUSH
49745: LD_VAR 0 1
49749: PPUSH
49750: CALL_OW 437
49754: PUSH
49755: LD_INT 1
49757: ARRAY
49758: PUSH
49759: LD_INT 2
49761: ARRAY
49762: EQUAL
49763: AND
49764: PUSH
49765: LD_VAR 0 5
49769: PUSH
49770: LD_VAR 0 1
49774: PPUSH
49775: CALL_OW 437
49779: PUSH
49780: LD_INT 1
49782: ARRAY
49783: PUSH
49784: LD_INT 3
49786: ARRAY
49787: EQUAL
49788: AND
49789: IFFALSE 49799
// result := true end ;
49791: LD_ADDR_VAR 0 3
49795: PUSH
49796: LD_INT 1
49798: ST_TO_ADDR
// end ;
49799: LD_VAR 0 3
49803: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49804: LD_INT 0
49806: PPUSH
// result := false ;
49807: LD_ADDR_VAR 0 4
49811: PUSH
49812: LD_INT 0
49814: ST_TO_ADDR
// if GetTaskList ( unit ) then
49815: LD_VAR 0 1
49819: PPUSH
49820: CALL_OW 437
49824: IFFALSE 49907
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49826: LD_STRING M
49828: PUSH
49829: LD_VAR 0 1
49833: PPUSH
49834: CALL_OW 437
49838: PUSH
49839: LD_INT 1
49841: ARRAY
49842: PUSH
49843: LD_INT 1
49845: ARRAY
49846: EQUAL
49847: PUSH
49848: LD_VAR 0 2
49852: PUSH
49853: LD_VAR 0 1
49857: PPUSH
49858: CALL_OW 437
49862: PUSH
49863: LD_INT 1
49865: ARRAY
49866: PUSH
49867: LD_INT 2
49869: ARRAY
49870: EQUAL
49871: AND
49872: PUSH
49873: LD_VAR 0 3
49877: PUSH
49878: LD_VAR 0 1
49882: PPUSH
49883: CALL_OW 437
49887: PUSH
49888: LD_INT 1
49890: ARRAY
49891: PUSH
49892: LD_INT 3
49894: ARRAY
49895: EQUAL
49896: AND
49897: IFFALSE 49907
// result := true ;
49899: LD_ADDR_VAR 0 4
49903: PUSH
49904: LD_INT 1
49906: ST_TO_ADDR
// end ; end ;
49907: LD_VAR 0 4
49911: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49912: LD_INT 0
49914: PPUSH
49915: PPUSH
49916: PPUSH
49917: PPUSH
// if not unit or not area then
49918: LD_VAR 0 1
49922: NOT
49923: PUSH
49924: LD_VAR 0 2
49928: NOT
49929: OR
49930: IFFALSE 49934
// exit ;
49932: GO 50098
// tmp := AreaToList ( area , i ) ;
49934: LD_ADDR_VAR 0 6
49938: PUSH
49939: LD_VAR 0 2
49943: PPUSH
49944: LD_VAR 0 5
49948: PPUSH
49949: CALL_OW 517
49953: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49954: LD_ADDR_VAR 0 5
49958: PUSH
49959: DOUBLE
49960: LD_INT 1
49962: DEC
49963: ST_TO_ADDR
49964: LD_VAR 0 6
49968: PUSH
49969: LD_INT 1
49971: ARRAY
49972: PUSH
49973: FOR_TO
49974: IFFALSE 50096
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49976: LD_ADDR_VAR 0 7
49980: PUSH
49981: LD_VAR 0 6
49985: PUSH
49986: LD_INT 1
49988: ARRAY
49989: PUSH
49990: LD_VAR 0 5
49994: ARRAY
49995: PUSH
49996: LD_VAR 0 6
50000: PUSH
50001: LD_INT 2
50003: ARRAY
50004: PUSH
50005: LD_VAR 0 5
50009: ARRAY
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50015: LD_VAR 0 7
50019: PUSH
50020: LD_INT 1
50022: ARRAY
50023: PPUSH
50024: LD_VAR 0 7
50028: PUSH
50029: LD_INT 2
50031: ARRAY
50032: PPUSH
50033: CALL_OW 428
50037: PUSH
50038: LD_INT 0
50040: EQUAL
50041: IFFALSE 50094
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50043: LD_VAR 0 1
50047: PPUSH
50048: LD_VAR 0 7
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: PPUSH
50057: LD_VAR 0 7
50061: PUSH
50062: LD_INT 2
50064: ARRAY
50065: PPUSH
50066: LD_VAR 0 3
50070: PPUSH
50071: CALL_OW 48
// result := IsPlaced ( unit ) ;
50075: LD_ADDR_VAR 0 4
50079: PUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 305
50089: ST_TO_ADDR
// exit ;
50090: POP
50091: POP
50092: GO 50098
// end ; end ;
50094: GO 49973
50096: POP
50097: POP
// end ;
50098: LD_VAR 0 4
50102: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50103: LD_INT 0
50105: PPUSH
50106: PPUSH
50107: PPUSH
// if not side or side > 8 then
50108: LD_VAR 0 1
50112: NOT
50113: PUSH
50114: LD_VAR 0 1
50118: PUSH
50119: LD_INT 8
50121: GREATER
50122: OR
50123: IFFALSE 50127
// exit ;
50125: GO 50314
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50127: LD_ADDR_VAR 0 4
50131: PUSH
50132: LD_INT 22
50134: PUSH
50135: LD_VAR 0 1
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 21
50146: PUSH
50147: LD_INT 3
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: EMPTY
50155: LIST
50156: LIST
50157: PPUSH
50158: CALL_OW 69
50162: ST_TO_ADDR
// if not tmp then
50163: LD_VAR 0 4
50167: NOT
50168: IFFALSE 50172
// exit ;
50170: GO 50314
// enable_addtolog := true ;
50172: LD_ADDR_OWVAR 81
50176: PUSH
50177: LD_INT 1
50179: ST_TO_ADDR
// AddToLog ( [ ) ;
50180: LD_STRING [
50182: PPUSH
50183: CALL_OW 561
// for i in tmp do
50187: LD_ADDR_VAR 0 3
50191: PUSH
50192: LD_VAR 0 4
50196: PUSH
50197: FOR_IN
50198: IFFALSE 50305
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50200: LD_STRING [
50202: PUSH
50203: LD_VAR 0 3
50207: PPUSH
50208: CALL_OW 266
50212: STR
50213: PUSH
50214: LD_STRING , 
50216: STR
50217: PUSH
50218: LD_VAR 0 3
50222: PPUSH
50223: CALL_OW 250
50227: STR
50228: PUSH
50229: LD_STRING , 
50231: STR
50232: PUSH
50233: LD_VAR 0 3
50237: PPUSH
50238: CALL_OW 251
50242: STR
50243: PUSH
50244: LD_STRING , 
50246: STR
50247: PUSH
50248: LD_VAR 0 3
50252: PPUSH
50253: CALL_OW 254
50257: STR
50258: PUSH
50259: LD_STRING , 
50261: STR
50262: PUSH
50263: LD_VAR 0 3
50267: PPUSH
50268: LD_INT 1
50270: PPUSH
50271: CALL_OW 268
50275: STR
50276: PUSH
50277: LD_STRING , 
50279: STR
50280: PUSH
50281: LD_VAR 0 3
50285: PPUSH
50286: LD_INT 2
50288: PPUSH
50289: CALL_OW 268
50293: STR
50294: PUSH
50295: LD_STRING ],
50297: STR
50298: PPUSH
50299: CALL_OW 561
// end ;
50303: GO 50197
50305: POP
50306: POP
// AddToLog ( ]; ) ;
50307: LD_STRING ];
50309: PPUSH
50310: CALL_OW 561
// end ;
50314: LD_VAR 0 2
50318: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50319: LD_INT 0
50321: PPUSH
50322: PPUSH
50323: PPUSH
50324: PPUSH
50325: PPUSH
// if not area or not rate or not max then
50326: LD_VAR 0 1
50330: NOT
50331: PUSH
50332: LD_VAR 0 2
50336: NOT
50337: OR
50338: PUSH
50339: LD_VAR 0 4
50343: NOT
50344: OR
50345: IFFALSE 50349
// exit ;
50347: GO 50538
// while 1 do
50349: LD_INT 1
50351: IFFALSE 50538
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50353: LD_ADDR_VAR 0 9
50357: PUSH
50358: LD_VAR 0 1
50362: PPUSH
50363: LD_INT 1
50365: PPUSH
50366: CALL_OW 287
50370: PUSH
50371: LD_INT 10
50373: MUL
50374: ST_TO_ADDR
// r := rate / 10 ;
50375: LD_ADDR_VAR 0 7
50379: PUSH
50380: LD_VAR 0 2
50384: PUSH
50385: LD_INT 10
50387: DIVREAL
50388: ST_TO_ADDR
// time := 1 1$00 ;
50389: LD_ADDR_VAR 0 8
50393: PUSH
50394: LD_INT 2100
50396: ST_TO_ADDR
// if amount < min then
50397: LD_VAR 0 9
50401: PUSH
50402: LD_VAR 0 3
50406: LESS
50407: IFFALSE 50425
// r := r * 2 else
50409: LD_ADDR_VAR 0 7
50413: PUSH
50414: LD_VAR 0 7
50418: PUSH
50419: LD_INT 2
50421: MUL
50422: ST_TO_ADDR
50423: GO 50451
// if amount > max then
50425: LD_VAR 0 9
50429: PUSH
50430: LD_VAR 0 4
50434: GREATER
50435: IFFALSE 50451
// r := r / 2 ;
50437: LD_ADDR_VAR 0 7
50441: PUSH
50442: LD_VAR 0 7
50446: PUSH
50447: LD_INT 2
50449: DIVREAL
50450: ST_TO_ADDR
// time := time / r ;
50451: LD_ADDR_VAR 0 8
50455: PUSH
50456: LD_VAR 0 8
50460: PUSH
50461: LD_VAR 0 7
50465: DIVREAL
50466: ST_TO_ADDR
// if time < 0 then
50467: LD_VAR 0 8
50471: PUSH
50472: LD_INT 0
50474: LESS
50475: IFFALSE 50492
// time := time * - 1 ;
50477: LD_ADDR_VAR 0 8
50481: PUSH
50482: LD_VAR 0 8
50486: PUSH
50487: LD_INT 1
50489: NEG
50490: MUL
50491: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
50492: LD_VAR 0 8
50496: PUSH
50497: LD_INT 35
50499: PPUSH
50500: LD_INT 875
50502: PPUSH
50503: CALL_OW 12
50507: PLUS
50508: PPUSH
50509: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50513: LD_INT 1
50515: PPUSH
50516: LD_INT 5
50518: PPUSH
50519: CALL_OW 12
50523: PPUSH
50524: LD_VAR 0 1
50528: PPUSH
50529: LD_INT 1
50531: PPUSH
50532: CALL_OW 55
// end ;
50536: GO 50349
// end ;
50538: LD_VAR 0 5
50542: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50543: LD_INT 0
50545: PPUSH
50546: PPUSH
50547: PPUSH
50548: PPUSH
50549: PPUSH
50550: PPUSH
50551: PPUSH
50552: PPUSH
// if not turrets or not factories then
50553: LD_VAR 0 1
50557: NOT
50558: PUSH
50559: LD_VAR 0 2
50563: NOT
50564: OR
50565: IFFALSE 50569
// exit ;
50567: GO 50876
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50569: LD_ADDR_VAR 0 10
50573: PUSH
50574: LD_INT 5
50576: PUSH
50577: LD_INT 6
50579: PUSH
50580: EMPTY
50581: LIST
50582: LIST
50583: PUSH
50584: LD_INT 2
50586: PUSH
50587: LD_INT 4
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: PUSH
50594: LD_INT 3
50596: PUSH
50597: LD_INT 5
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: LIST
50608: PUSH
50609: LD_INT 24
50611: PUSH
50612: LD_INT 25
50614: PUSH
50615: EMPTY
50616: LIST
50617: LIST
50618: PUSH
50619: LD_INT 23
50621: PUSH
50622: LD_INT 27
50624: PUSH
50625: EMPTY
50626: LIST
50627: LIST
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: PUSH
50633: LD_INT 42
50635: PUSH
50636: LD_INT 43
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PUSH
50643: LD_INT 44
50645: PUSH
50646: LD_INT 46
50648: PUSH
50649: EMPTY
50650: LIST
50651: LIST
50652: PUSH
50653: LD_INT 45
50655: PUSH
50656: LD_INT 47
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: LIST
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: LIST
50672: ST_TO_ADDR
// result := [ ] ;
50673: LD_ADDR_VAR 0 3
50677: PUSH
50678: EMPTY
50679: ST_TO_ADDR
// for i in turrets do
50680: LD_ADDR_VAR 0 4
50684: PUSH
50685: LD_VAR 0 1
50689: PUSH
50690: FOR_IN
50691: IFFALSE 50874
// begin nat := GetNation ( i ) ;
50693: LD_ADDR_VAR 0 7
50697: PUSH
50698: LD_VAR 0 4
50702: PPUSH
50703: CALL_OW 248
50707: ST_TO_ADDR
// weapon := 0 ;
50708: LD_ADDR_VAR 0 8
50712: PUSH
50713: LD_INT 0
50715: ST_TO_ADDR
// if not nat then
50716: LD_VAR 0 7
50720: NOT
50721: IFFALSE 50725
// continue ;
50723: GO 50690
// for j in list [ nat ] do
50725: LD_ADDR_VAR 0 5
50729: PUSH
50730: LD_VAR 0 10
50734: PUSH
50735: LD_VAR 0 7
50739: ARRAY
50740: PUSH
50741: FOR_IN
50742: IFFALSE 50783
// if GetBWeapon ( i ) = j [ 1 ] then
50744: LD_VAR 0 4
50748: PPUSH
50749: CALL_OW 269
50753: PUSH
50754: LD_VAR 0 5
50758: PUSH
50759: LD_INT 1
50761: ARRAY
50762: EQUAL
50763: IFFALSE 50781
// begin weapon := j [ 2 ] ;
50765: LD_ADDR_VAR 0 8
50769: PUSH
50770: LD_VAR 0 5
50774: PUSH
50775: LD_INT 2
50777: ARRAY
50778: ST_TO_ADDR
// break ;
50779: GO 50783
// end ;
50781: GO 50741
50783: POP
50784: POP
// if not weapon then
50785: LD_VAR 0 8
50789: NOT
50790: IFFALSE 50794
// continue ;
50792: GO 50690
// for k in factories do
50794: LD_ADDR_VAR 0 6
50798: PUSH
50799: LD_VAR 0 2
50803: PUSH
50804: FOR_IN
50805: IFFALSE 50870
// begin weapons := AvailableWeaponList ( k ) ;
50807: LD_ADDR_VAR 0 9
50811: PUSH
50812: LD_VAR 0 6
50816: PPUSH
50817: CALL_OW 478
50821: ST_TO_ADDR
// if not weapons then
50822: LD_VAR 0 9
50826: NOT
50827: IFFALSE 50831
// continue ;
50829: GO 50804
// if weapon in weapons then
50831: LD_VAR 0 8
50835: PUSH
50836: LD_VAR 0 9
50840: IN
50841: IFFALSE 50868
// begin result := [ i , weapon ] ;
50843: LD_ADDR_VAR 0 3
50847: PUSH
50848: LD_VAR 0 4
50852: PUSH
50853: LD_VAR 0 8
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: ST_TO_ADDR
// exit ;
50862: POP
50863: POP
50864: POP
50865: POP
50866: GO 50876
// end ; end ;
50868: GO 50804
50870: POP
50871: POP
// end ;
50872: GO 50690
50874: POP
50875: POP
// end ;
50876: LD_VAR 0 3
50880: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50881: LD_INT 0
50883: PPUSH
// if not side or side > 8 then
50884: LD_VAR 0 3
50888: NOT
50889: PUSH
50890: LD_VAR 0 3
50894: PUSH
50895: LD_INT 8
50897: GREATER
50898: OR
50899: IFFALSE 50903
// exit ;
50901: GO 50962
// if not range then
50903: LD_VAR 0 4
50907: NOT
50908: IFFALSE 50919
// range := - 12 ;
50910: LD_ADDR_VAR 0 4
50914: PUSH
50915: LD_INT 12
50917: NEG
50918: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50919: LD_VAR 0 1
50923: PPUSH
50924: LD_VAR 0 2
50928: PPUSH
50929: LD_VAR 0 3
50933: PPUSH
50934: LD_VAR 0 4
50938: PPUSH
50939: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50943: LD_VAR 0 1
50947: PPUSH
50948: LD_VAR 0 2
50952: PPUSH
50953: LD_VAR 0 3
50957: PPUSH
50958: CALL_OW 331
// end ;
50962: LD_VAR 0 5
50966: RET
// export function Video ( mode ) ; begin
50967: LD_INT 0
50969: PPUSH
// ingame_video = mode ;
50970: LD_ADDR_OWVAR 52
50974: PUSH
50975: LD_VAR 0 1
50979: ST_TO_ADDR
// interface_hidden = mode ;
50980: LD_ADDR_OWVAR 54
50984: PUSH
50985: LD_VAR 0 1
50989: ST_TO_ADDR
// end ;
50990: LD_VAR 0 2
50994: RET
// export function Join ( array , element ) ; begin
50995: LD_INT 0
50997: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50998: LD_ADDR_VAR 0 3
51002: PUSH
51003: LD_VAR 0 1
51007: PPUSH
51008: LD_VAR 0 1
51012: PUSH
51013: LD_INT 1
51015: PLUS
51016: PPUSH
51017: LD_VAR 0 2
51021: PPUSH
51022: CALL_OW 1
51026: ST_TO_ADDR
// end ;
51027: LD_VAR 0 3
51031: RET
// export function JoinUnion ( array , element ) ; begin
51032: LD_INT 0
51034: PPUSH
// result := array union element ;
51035: LD_ADDR_VAR 0 3
51039: PUSH
51040: LD_VAR 0 1
51044: PUSH
51045: LD_VAR 0 2
51049: UNION
51050: ST_TO_ADDR
// end ;
51051: LD_VAR 0 3
51055: RET
// export function GetBehemoths ( side ) ; begin
51056: LD_INT 0
51058: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
51059: LD_ADDR_VAR 0 2
51063: PUSH
51064: LD_INT 22
51066: PUSH
51067: LD_VAR 0 1
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: PUSH
51076: LD_INT 31
51078: PUSH
51079: LD_INT 25
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: PPUSH
51090: CALL_OW 69
51094: ST_TO_ADDR
// end ;
51095: LD_VAR 0 2
51099: RET
// export function Shuffle ( array ) ; var i , index ; begin
51100: LD_INT 0
51102: PPUSH
51103: PPUSH
51104: PPUSH
// result := [ ] ;
51105: LD_ADDR_VAR 0 2
51109: PUSH
51110: EMPTY
51111: ST_TO_ADDR
// if not array then
51112: LD_VAR 0 1
51116: NOT
51117: IFFALSE 51121
// exit ;
51119: GO 51220
// Randomize ;
51121: CALL_OW 10
// for i = array downto 1 do
51125: LD_ADDR_VAR 0 3
51129: PUSH
51130: DOUBLE
51131: LD_VAR 0 1
51135: INC
51136: ST_TO_ADDR
51137: LD_INT 1
51139: PUSH
51140: FOR_DOWNTO
51141: IFFALSE 51218
// begin index := rand ( 1 , array ) ;
51143: LD_ADDR_VAR 0 4
51147: PUSH
51148: LD_INT 1
51150: PPUSH
51151: LD_VAR 0 1
51155: PPUSH
51156: CALL_OW 12
51160: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51161: LD_ADDR_VAR 0 2
51165: PUSH
51166: LD_VAR 0 2
51170: PPUSH
51171: LD_VAR 0 2
51175: PUSH
51176: LD_INT 1
51178: PLUS
51179: PPUSH
51180: LD_VAR 0 1
51184: PUSH
51185: LD_VAR 0 4
51189: ARRAY
51190: PPUSH
51191: CALL_OW 2
51195: ST_TO_ADDR
// array := Delete ( array , index ) ;
51196: LD_ADDR_VAR 0 1
51200: PUSH
51201: LD_VAR 0 1
51205: PPUSH
51206: LD_VAR 0 4
51210: PPUSH
51211: CALL_OW 3
51215: ST_TO_ADDR
// end ;
51216: GO 51140
51218: POP
51219: POP
// end ;
51220: LD_VAR 0 2
51224: RET
// export function GetBaseMaterials ( base ) ; begin
51225: LD_INT 0
51227: PPUSH
// result := [ 0 , 0 , 0 ] ;
51228: LD_ADDR_VAR 0 2
51232: PUSH
51233: LD_INT 0
51235: PUSH
51236: LD_INT 0
51238: PUSH
51239: LD_INT 0
51241: PUSH
51242: EMPTY
51243: LIST
51244: LIST
51245: LIST
51246: ST_TO_ADDR
// if not base then
51247: LD_VAR 0 1
51251: NOT
51252: IFFALSE 51256
// exit ;
51254: GO 51305
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51256: LD_ADDR_VAR 0 2
51260: PUSH
51261: LD_VAR 0 1
51265: PPUSH
51266: LD_INT 1
51268: PPUSH
51269: CALL_OW 275
51273: PUSH
51274: LD_VAR 0 1
51278: PPUSH
51279: LD_INT 2
51281: PPUSH
51282: CALL_OW 275
51286: PUSH
51287: LD_VAR 0 1
51291: PPUSH
51292: LD_INT 3
51294: PPUSH
51295: CALL_OW 275
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: LIST
51304: ST_TO_ADDR
// end ;
51305: LD_VAR 0 2
51309: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51310: LD_INT 0
51312: PPUSH
51313: PPUSH
// result := array ;
51314: LD_ADDR_VAR 0 3
51318: PUSH
51319: LD_VAR 0 1
51323: ST_TO_ADDR
// if size >= result then
51324: LD_VAR 0 2
51328: PUSH
51329: LD_VAR 0 3
51333: GREATEREQUAL
51334: IFFALSE 51338
// exit ;
51336: GO 51388
// if size then
51338: LD_VAR 0 2
51342: IFFALSE 51388
// for i := array downto size do
51344: LD_ADDR_VAR 0 4
51348: PUSH
51349: DOUBLE
51350: LD_VAR 0 1
51354: INC
51355: ST_TO_ADDR
51356: LD_VAR 0 2
51360: PUSH
51361: FOR_DOWNTO
51362: IFFALSE 51386
// result := Delete ( result , result ) ;
51364: LD_ADDR_VAR 0 3
51368: PUSH
51369: LD_VAR 0 3
51373: PPUSH
51374: LD_VAR 0 3
51378: PPUSH
51379: CALL_OW 3
51383: ST_TO_ADDR
51384: GO 51361
51386: POP
51387: POP
// end ;
51388: LD_VAR 0 3
51392: RET
// export function ComExit ( unit ) ; var tmp ; begin
51393: LD_INT 0
51395: PPUSH
51396: PPUSH
// if not IsInUnit ( unit ) then
51397: LD_VAR 0 1
51401: PPUSH
51402: CALL_OW 310
51406: NOT
51407: IFFALSE 51411
// exit ;
51409: GO 51471
// tmp := IsInUnit ( unit ) ;
51411: LD_ADDR_VAR 0 3
51415: PUSH
51416: LD_VAR 0 1
51420: PPUSH
51421: CALL_OW 310
51425: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51426: LD_VAR 0 3
51430: PPUSH
51431: CALL_OW 247
51435: PUSH
51436: LD_INT 2
51438: EQUAL
51439: IFFALSE 51452
// ComExitVehicle ( unit ) else
51441: LD_VAR 0 1
51445: PPUSH
51446: CALL_OW 121
51450: GO 51461
// ComExitBuilding ( unit ) ;
51452: LD_VAR 0 1
51456: PPUSH
51457: CALL_OW 122
// result := tmp ;
51461: LD_ADDR_VAR 0 2
51465: PUSH
51466: LD_VAR 0 3
51470: ST_TO_ADDR
// end ;
51471: LD_VAR 0 2
51475: RET
// export function ComExitAll ( units ) ; var i ; begin
51476: LD_INT 0
51478: PPUSH
51479: PPUSH
// if not units then
51480: LD_VAR 0 1
51484: NOT
51485: IFFALSE 51489
// exit ;
51487: GO 51515
// for i in units do
51489: LD_ADDR_VAR 0 3
51493: PUSH
51494: LD_VAR 0 1
51498: PUSH
51499: FOR_IN
51500: IFFALSE 51513
// ComExit ( i ) ;
51502: LD_VAR 0 3
51506: PPUSH
51507: CALL 51393 0 1
51511: GO 51499
51513: POP
51514: POP
// end ;
51515: LD_VAR 0 2
51519: RET
// export function ResetHc ; begin
51520: LD_INT 0
51522: PPUSH
// InitHc ;
51523: CALL_OW 19
// hc_importance := 0 ;
51527: LD_ADDR_OWVAR 32
51531: PUSH
51532: LD_INT 0
51534: ST_TO_ADDR
// end ;
51535: LD_VAR 0 1
51539: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51540: LD_INT 0
51542: PPUSH
51543: PPUSH
51544: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51545: LD_ADDR_VAR 0 6
51549: PUSH
51550: LD_VAR 0 1
51554: PUSH
51555: LD_VAR 0 3
51559: PLUS
51560: PUSH
51561: LD_INT 2
51563: DIV
51564: ST_TO_ADDR
// if _x < 0 then
51565: LD_VAR 0 6
51569: PUSH
51570: LD_INT 0
51572: LESS
51573: IFFALSE 51590
// _x := _x * - 1 ;
51575: LD_ADDR_VAR 0 6
51579: PUSH
51580: LD_VAR 0 6
51584: PUSH
51585: LD_INT 1
51587: NEG
51588: MUL
51589: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51590: LD_ADDR_VAR 0 7
51594: PUSH
51595: LD_VAR 0 2
51599: PUSH
51600: LD_VAR 0 4
51604: PLUS
51605: PUSH
51606: LD_INT 2
51608: DIV
51609: ST_TO_ADDR
// if _y < 0 then
51610: LD_VAR 0 7
51614: PUSH
51615: LD_INT 0
51617: LESS
51618: IFFALSE 51635
// _y := _y * - 1 ;
51620: LD_ADDR_VAR 0 7
51624: PUSH
51625: LD_VAR 0 7
51629: PUSH
51630: LD_INT 1
51632: NEG
51633: MUL
51634: ST_TO_ADDR
// result := [ _x , _y ] ;
51635: LD_ADDR_VAR 0 5
51639: PUSH
51640: LD_VAR 0 6
51644: PUSH
51645: LD_VAR 0 7
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: ST_TO_ADDR
// end ;
51654: LD_VAR 0 5
51658: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51659: LD_INT 0
51661: PPUSH
51662: PPUSH
51663: PPUSH
51664: PPUSH
// task := GetTaskList ( unit ) ;
51665: LD_ADDR_VAR 0 7
51669: PUSH
51670: LD_VAR 0 1
51674: PPUSH
51675: CALL_OW 437
51679: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51680: LD_VAR 0 7
51684: NOT
51685: PUSH
51686: LD_VAR 0 1
51690: PPUSH
51691: LD_VAR 0 2
51695: PPUSH
51696: CALL_OW 308
51700: NOT
51701: AND
51702: IFFALSE 51706
// exit ;
51704: GO 51824
// if IsInArea ( unit , area ) then
51706: LD_VAR 0 1
51710: PPUSH
51711: LD_VAR 0 2
51715: PPUSH
51716: CALL_OW 308
51720: IFFALSE 51738
// begin ComMoveToArea ( unit , goAway ) ;
51722: LD_VAR 0 1
51726: PPUSH
51727: LD_VAR 0 3
51731: PPUSH
51732: CALL_OW 113
// exit ;
51736: GO 51824
// end ; if task [ 1 ] [ 1 ] <> M then
51738: LD_VAR 0 7
51742: PUSH
51743: LD_INT 1
51745: ARRAY
51746: PUSH
51747: LD_INT 1
51749: ARRAY
51750: PUSH
51751: LD_STRING M
51753: NONEQUAL
51754: IFFALSE 51758
// exit ;
51756: GO 51824
// x := task [ 1 ] [ 2 ] ;
51758: LD_ADDR_VAR 0 5
51762: PUSH
51763: LD_VAR 0 7
51767: PUSH
51768: LD_INT 1
51770: ARRAY
51771: PUSH
51772: LD_INT 2
51774: ARRAY
51775: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51776: LD_ADDR_VAR 0 6
51780: PUSH
51781: LD_VAR 0 7
51785: PUSH
51786: LD_INT 1
51788: ARRAY
51789: PUSH
51790: LD_INT 3
51792: ARRAY
51793: ST_TO_ADDR
// if InArea ( x , y , area ) then
51794: LD_VAR 0 5
51798: PPUSH
51799: LD_VAR 0 6
51803: PPUSH
51804: LD_VAR 0 2
51808: PPUSH
51809: CALL_OW 309
51813: IFFALSE 51824
// ComStop ( unit ) ;
51815: LD_VAR 0 1
51819: PPUSH
51820: CALL_OW 141
// end ;
51824: LD_VAR 0 4
51828: RET
// export function Abs ( value ) ; begin
51829: LD_INT 0
51831: PPUSH
// result := value ;
51832: LD_ADDR_VAR 0 2
51836: PUSH
51837: LD_VAR 0 1
51841: ST_TO_ADDR
// if value < 0 then
51842: LD_VAR 0 1
51846: PUSH
51847: LD_INT 0
51849: LESS
51850: IFFALSE 51867
// result := value * - 1 ;
51852: LD_ADDR_VAR 0 2
51856: PUSH
51857: LD_VAR 0 1
51861: PUSH
51862: LD_INT 1
51864: NEG
51865: MUL
51866: ST_TO_ADDR
// end ;
51867: LD_VAR 0 2
51871: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51872: LD_INT 0
51874: PPUSH
51875: PPUSH
51876: PPUSH
51877: PPUSH
51878: PPUSH
51879: PPUSH
51880: PPUSH
51881: PPUSH
// if not unit or not building then
51882: LD_VAR 0 1
51886: NOT
51887: PUSH
51888: LD_VAR 0 2
51892: NOT
51893: OR
51894: IFFALSE 51898
// exit ;
51896: GO 52124
// x := GetX ( building ) ;
51898: LD_ADDR_VAR 0 4
51902: PUSH
51903: LD_VAR 0 2
51907: PPUSH
51908: CALL_OW 250
51912: ST_TO_ADDR
// y := GetY ( building ) ;
51913: LD_ADDR_VAR 0 6
51917: PUSH
51918: LD_VAR 0 2
51922: PPUSH
51923: CALL_OW 251
51927: ST_TO_ADDR
// d := GetDir ( building ) ;
51928: LD_ADDR_VAR 0 8
51932: PUSH
51933: LD_VAR 0 2
51937: PPUSH
51938: CALL_OW 254
51942: ST_TO_ADDR
// r := 4 ;
51943: LD_ADDR_VAR 0 9
51947: PUSH
51948: LD_INT 4
51950: ST_TO_ADDR
// for i := 1 to 5 do
51951: LD_ADDR_VAR 0 10
51955: PUSH
51956: DOUBLE
51957: LD_INT 1
51959: DEC
51960: ST_TO_ADDR
51961: LD_INT 5
51963: PUSH
51964: FOR_TO
51965: IFFALSE 52122
// begin _x := ShiftX ( x , d , r + i ) ;
51967: LD_ADDR_VAR 0 5
51971: PUSH
51972: LD_VAR 0 4
51976: PPUSH
51977: LD_VAR 0 8
51981: PPUSH
51982: LD_VAR 0 9
51986: PUSH
51987: LD_VAR 0 10
51991: PLUS
51992: PPUSH
51993: CALL_OW 272
51997: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51998: LD_ADDR_VAR 0 7
52002: PUSH
52003: LD_VAR 0 6
52007: PPUSH
52008: LD_VAR 0 8
52012: PPUSH
52013: LD_VAR 0 9
52017: PUSH
52018: LD_VAR 0 10
52022: PLUS
52023: PPUSH
52024: CALL_OW 273
52028: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52029: LD_VAR 0 5
52033: PPUSH
52034: LD_VAR 0 7
52038: PPUSH
52039: CALL_OW 488
52043: PUSH
52044: LD_VAR 0 5
52048: PPUSH
52049: LD_VAR 0 7
52053: PPUSH
52054: CALL_OW 428
52058: PPUSH
52059: CALL_OW 247
52063: PUSH
52064: LD_INT 3
52066: PUSH
52067: LD_INT 2
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: IN
52074: NOT
52075: AND
52076: IFFALSE 52120
// begin ComMoveXY ( unit , _x , _y ) ;
52078: LD_VAR 0 1
52082: PPUSH
52083: LD_VAR 0 5
52087: PPUSH
52088: LD_VAR 0 7
52092: PPUSH
52093: CALL_OW 111
// result := [ _x , _y ] ;
52097: LD_ADDR_VAR 0 3
52101: PUSH
52102: LD_VAR 0 5
52106: PUSH
52107: LD_VAR 0 7
52111: PUSH
52112: EMPTY
52113: LIST
52114: LIST
52115: ST_TO_ADDR
// exit ;
52116: POP
52117: POP
52118: GO 52124
// end ; end ;
52120: GO 51964
52122: POP
52123: POP
// end ;
52124: LD_VAR 0 3
52128: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52129: LD_INT 0
52131: PPUSH
52132: PPUSH
52133: PPUSH
// result := 0 ;
52134: LD_ADDR_VAR 0 3
52138: PUSH
52139: LD_INT 0
52141: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52142: LD_VAR 0 1
52146: PUSH
52147: LD_INT 0
52149: LESS
52150: PUSH
52151: LD_VAR 0 1
52155: PUSH
52156: LD_INT 8
52158: GREATER
52159: OR
52160: PUSH
52161: LD_VAR 0 2
52165: PUSH
52166: LD_INT 0
52168: LESS
52169: OR
52170: PUSH
52171: LD_VAR 0 2
52175: PUSH
52176: LD_INT 8
52178: GREATER
52179: OR
52180: IFFALSE 52184
// exit ;
52182: GO 52259
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52184: LD_ADDR_VAR 0 4
52188: PUSH
52189: LD_INT 22
52191: PUSH
52192: LD_VAR 0 2
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: PPUSH
52201: CALL_OW 69
52205: PUSH
52206: FOR_IN
52207: IFFALSE 52257
// begin un := UnitShoot ( i ) ;
52209: LD_ADDR_VAR 0 5
52213: PUSH
52214: LD_VAR 0 4
52218: PPUSH
52219: CALL_OW 504
52223: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52224: LD_VAR 0 5
52228: PPUSH
52229: CALL_OW 255
52233: PUSH
52234: LD_VAR 0 1
52238: EQUAL
52239: IFFALSE 52255
// begin result := un ;
52241: LD_ADDR_VAR 0 3
52245: PUSH
52246: LD_VAR 0 5
52250: ST_TO_ADDR
// exit ;
52251: POP
52252: POP
52253: GO 52259
// end ; end ;
52255: GO 52206
52257: POP
52258: POP
// end ;
52259: LD_VAR 0 3
52263: RET
// export function GetCargoBay ( units ) ; begin
52264: LD_INT 0
52266: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52267: LD_ADDR_VAR 0 2
52271: PUSH
52272: LD_VAR 0 1
52276: PPUSH
52277: LD_INT 2
52279: PUSH
52280: LD_INT 34
52282: PUSH
52283: LD_INT 12
52285: PUSH
52286: EMPTY
52287: LIST
52288: LIST
52289: PUSH
52290: LD_INT 34
52292: PUSH
52293: LD_INT 51
52295: PUSH
52296: EMPTY
52297: LIST
52298: LIST
52299: PUSH
52300: LD_INT 34
52302: PUSH
52303: LD_INT 32
52305: PUSH
52306: EMPTY
52307: LIST
52308: LIST
52309: PUSH
52310: LD_INT 34
52312: PUSH
52313: LD_EXP 49
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: PPUSH
52329: CALL_OW 72
52333: ST_TO_ADDR
// end ;
52334: LD_VAR 0 2
52338: RET
// export function Negate ( value ) ; begin
52339: LD_INT 0
52341: PPUSH
// result := not value ;
52342: LD_ADDR_VAR 0 2
52346: PUSH
52347: LD_VAR 0 1
52351: NOT
52352: ST_TO_ADDR
// end ;
52353: LD_VAR 0 2
52357: RET
// export function Inc ( value ) ; begin
52358: LD_INT 0
52360: PPUSH
// result := value + 1 ;
52361: LD_ADDR_VAR 0 2
52365: PUSH
52366: LD_VAR 0 1
52370: PUSH
52371: LD_INT 1
52373: PLUS
52374: ST_TO_ADDR
// end ;
52375: LD_VAR 0 2
52379: RET
// export function Dec ( value ) ; begin
52380: LD_INT 0
52382: PPUSH
// result := value - 1 ;
52383: LD_ADDR_VAR 0 2
52387: PUSH
52388: LD_VAR 0 1
52392: PUSH
52393: LD_INT 1
52395: MINUS
52396: ST_TO_ADDR
// end ;
52397: LD_VAR 0 2
52401: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52402: LD_INT 0
52404: PPUSH
52405: PPUSH
52406: PPUSH
52407: PPUSH
52408: PPUSH
52409: PPUSH
52410: PPUSH
52411: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52412: LD_VAR 0 1
52416: PPUSH
52417: LD_VAR 0 2
52421: PPUSH
52422: CALL_OW 488
52426: NOT
52427: PUSH
52428: LD_VAR 0 3
52432: PPUSH
52433: LD_VAR 0 4
52437: PPUSH
52438: CALL_OW 488
52442: NOT
52443: OR
52444: IFFALSE 52457
// begin result := - 1 ;
52446: LD_ADDR_VAR 0 5
52450: PUSH
52451: LD_INT 1
52453: NEG
52454: ST_TO_ADDR
// exit ;
52455: GO 52692
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
52457: LD_ADDR_VAR 0 12
52461: PUSH
52462: LD_VAR 0 1
52466: PPUSH
52467: LD_VAR 0 2
52471: PPUSH
52472: LD_VAR 0 3
52476: PPUSH
52477: LD_VAR 0 4
52481: PPUSH
52482: CALL 51540 0 4
52486: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
52487: LD_ADDR_VAR 0 11
52491: PUSH
52492: LD_VAR 0 1
52496: PPUSH
52497: LD_VAR 0 2
52501: PPUSH
52502: LD_VAR 0 12
52506: PUSH
52507: LD_INT 1
52509: ARRAY
52510: PPUSH
52511: LD_VAR 0 12
52515: PUSH
52516: LD_INT 2
52518: ARRAY
52519: PPUSH
52520: CALL_OW 298
52524: ST_TO_ADDR
// distance := 9999 ;
52525: LD_ADDR_VAR 0 10
52529: PUSH
52530: LD_INT 9999
52532: ST_TO_ADDR
// for i := 0 to 5 do
52533: LD_ADDR_VAR 0 6
52537: PUSH
52538: DOUBLE
52539: LD_INT 0
52541: DEC
52542: ST_TO_ADDR
52543: LD_INT 5
52545: PUSH
52546: FOR_TO
52547: IFFALSE 52690
// begin _x := ShiftX ( x1 , i , centerDist ) ;
52549: LD_ADDR_VAR 0 7
52553: PUSH
52554: LD_VAR 0 1
52558: PPUSH
52559: LD_VAR 0 6
52563: PPUSH
52564: LD_VAR 0 11
52568: PPUSH
52569: CALL_OW 272
52573: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
52574: LD_ADDR_VAR 0 8
52578: PUSH
52579: LD_VAR 0 2
52583: PPUSH
52584: LD_VAR 0 6
52588: PPUSH
52589: LD_VAR 0 11
52593: PPUSH
52594: CALL_OW 273
52598: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52599: LD_VAR 0 7
52603: PPUSH
52604: LD_VAR 0 8
52608: PPUSH
52609: CALL_OW 488
52613: NOT
52614: IFFALSE 52618
// continue ;
52616: GO 52546
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
52618: LD_ADDR_VAR 0 9
52622: PUSH
52623: LD_VAR 0 12
52627: PUSH
52628: LD_INT 1
52630: ARRAY
52631: PPUSH
52632: LD_VAR 0 12
52636: PUSH
52637: LD_INT 2
52639: ARRAY
52640: PPUSH
52641: LD_VAR 0 7
52645: PPUSH
52646: LD_VAR 0 8
52650: PPUSH
52651: CALL_OW 298
52655: ST_TO_ADDR
// if tmp < distance then
52656: LD_VAR 0 9
52660: PUSH
52661: LD_VAR 0 10
52665: LESS
52666: IFFALSE 52688
// begin result := i ;
52668: LD_ADDR_VAR 0 5
52672: PUSH
52673: LD_VAR 0 6
52677: ST_TO_ADDR
// distance := tmp ;
52678: LD_ADDR_VAR 0 10
52682: PUSH
52683: LD_VAR 0 9
52687: ST_TO_ADDR
// end ; end ;
52688: GO 52546
52690: POP
52691: POP
// end ;
52692: LD_VAR 0 5
52696: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52697: LD_INT 0
52699: PPUSH
52700: PPUSH
// if not driver or not IsInUnit ( driver ) then
52701: LD_VAR 0 1
52705: NOT
52706: PUSH
52707: LD_VAR 0 1
52711: PPUSH
52712: CALL_OW 310
52716: NOT
52717: OR
52718: IFFALSE 52722
// exit ;
52720: GO 52812
// vehicle := IsInUnit ( driver ) ;
52722: LD_ADDR_VAR 0 3
52726: PUSH
52727: LD_VAR 0 1
52731: PPUSH
52732: CALL_OW 310
52736: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52737: LD_VAR 0 1
52741: PPUSH
52742: LD_STRING \
52744: PUSH
52745: LD_INT 0
52747: PUSH
52748: LD_INT 0
52750: PUSH
52751: LD_INT 0
52753: PUSH
52754: LD_INT 0
52756: PUSH
52757: LD_INT 0
52759: PUSH
52760: LD_INT 0
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: LIST
52771: PUSH
52772: LD_STRING E
52774: PUSH
52775: LD_INT 0
52777: PUSH
52778: LD_INT 0
52780: PUSH
52781: LD_VAR 0 3
52785: PUSH
52786: LD_INT 0
52788: PUSH
52789: LD_INT 0
52791: PUSH
52792: LD_INT 0
52794: PUSH
52795: EMPTY
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: LIST
52802: LIST
52803: PUSH
52804: EMPTY
52805: LIST
52806: LIST
52807: PPUSH
52808: CALL_OW 446
// end ;
52812: LD_VAR 0 2
52816: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52817: LD_INT 0
52819: PPUSH
52820: PPUSH
// if not driver or not IsInUnit ( driver ) then
52821: LD_VAR 0 1
52825: NOT
52826: PUSH
52827: LD_VAR 0 1
52831: PPUSH
52832: CALL_OW 310
52836: NOT
52837: OR
52838: IFFALSE 52842
// exit ;
52840: GO 52932
// vehicle := IsInUnit ( driver ) ;
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: LD_VAR 0 1
52851: PPUSH
52852: CALL_OW 310
52856: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52857: LD_VAR 0 1
52861: PPUSH
52862: LD_STRING \
52864: PUSH
52865: LD_INT 0
52867: PUSH
52868: LD_INT 0
52870: PUSH
52871: LD_INT 0
52873: PUSH
52874: LD_INT 0
52876: PUSH
52877: LD_INT 0
52879: PUSH
52880: LD_INT 0
52882: PUSH
52883: EMPTY
52884: LIST
52885: LIST
52886: LIST
52887: LIST
52888: LIST
52889: LIST
52890: LIST
52891: PUSH
52892: LD_STRING E
52894: PUSH
52895: LD_INT 0
52897: PUSH
52898: LD_INT 0
52900: PUSH
52901: LD_VAR 0 3
52905: PUSH
52906: LD_INT 0
52908: PUSH
52909: LD_INT 0
52911: PUSH
52912: LD_INT 0
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: LIST
52920: LIST
52921: LIST
52922: LIST
52923: PUSH
52924: EMPTY
52925: LIST
52926: LIST
52927: PPUSH
52928: CALL_OW 447
// end ;
52932: LD_VAR 0 2
52936: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52937: LD_INT 0
52939: PPUSH
52940: PPUSH
52941: PPUSH
// tmp := [ ] ;
52942: LD_ADDR_VAR 0 5
52946: PUSH
52947: EMPTY
52948: ST_TO_ADDR
// for i in units do
52949: LD_ADDR_VAR 0 4
52953: PUSH
52954: LD_VAR 0 1
52958: PUSH
52959: FOR_IN
52960: IFFALSE 52998
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52962: LD_ADDR_VAR 0 5
52966: PUSH
52967: LD_VAR 0 5
52971: PPUSH
52972: LD_VAR 0 5
52976: PUSH
52977: LD_INT 1
52979: PLUS
52980: PPUSH
52981: LD_VAR 0 4
52985: PPUSH
52986: CALL_OW 256
52990: PPUSH
52991: CALL_OW 2
52995: ST_TO_ADDR
52996: GO 52959
52998: POP
52999: POP
// if not tmp then
53000: LD_VAR 0 5
53004: NOT
53005: IFFALSE 53009
// exit ;
53007: GO 53057
// if asc then
53009: LD_VAR 0 2
53013: IFFALSE 53037
// result := SortListByListAsc ( units , tmp ) else
53015: LD_ADDR_VAR 0 3
53019: PUSH
53020: LD_VAR 0 1
53024: PPUSH
53025: LD_VAR 0 5
53029: PPUSH
53030: CALL_OW 76
53034: ST_TO_ADDR
53035: GO 53057
// result := SortListByListDesc ( units , tmp ) ;
53037: LD_ADDR_VAR 0 3
53041: PUSH
53042: LD_VAR 0 1
53046: PPUSH
53047: LD_VAR 0 5
53051: PPUSH
53052: CALL_OW 77
53056: ST_TO_ADDR
// end ;
53057: LD_VAR 0 3
53061: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53062: LD_INT 0
53064: PPUSH
53065: PPUSH
// task := GetTaskList ( mech ) ;
53066: LD_ADDR_VAR 0 4
53070: PUSH
53071: LD_VAR 0 1
53075: PPUSH
53076: CALL_OW 437
53080: ST_TO_ADDR
// if not task then
53081: LD_VAR 0 4
53085: NOT
53086: IFFALSE 53090
// exit ;
53088: GO 53132
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53090: LD_ADDR_VAR 0 3
53094: PUSH
53095: LD_VAR 0 4
53099: PUSH
53100: LD_INT 1
53102: ARRAY
53103: PUSH
53104: LD_INT 1
53106: ARRAY
53107: PUSH
53108: LD_STRING r
53110: EQUAL
53111: PUSH
53112: LD_VAR 0 4
53116: PUSH
53117: LD_INT 1
53119: ARRAY
53120: PUSH
53121: LD_INT 4
53123: ARRAY
53124: PUSH
53125: LD_VAR 0 2
53129: EQUAL
53130: AND
53131: ST_TO_ADDR
// end ;
53132: LD_VAR 0 3
53136: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53137: LD_INT 0
53139: PPUSH
// SetDir ( unit , d ) ;
53140: LD_VAR 0 1
53144: PPUSH
53145: LD_VAR 0 4
53149: PPUSH
53150: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53154: LD_VAR 0 1
53158: PPUSH
53159: LD_VAR 0 2
53163: PPUSH
53164: LD_VAR 0 3
53168: PPUSH
53169: LD_VAR 0 5
53173: PPUSH
53174: CALL_OW 48
// end ;
53178: LD_VAR 0 6
53182: RET
// export function ToNaturalNumber ( number ) ; begin
53183: LD_INT 0
53185: PPUSH
// result := number div 1 ;
53186: LD_ADDR_VAR 0 2
53190: PUSH
53191: LD_VAR 0 1
53195: PUSH
53196: LD_INT 1
53198: DIV
53199: ST_TO_ADDR
// if number < 0 then
53200: LD_VAR 0 1
53204: PUSH
53205: LD_INT 0
53207: LESS
53208: IFFALSE 53218
// result := 0 ;
53210: LD_ADDR_VAR 0 2
53214: PUSH
53215: LD_INT 0
53217: ST_TO_ADDR
// end ;
53218: LD_VAR 0 2
53222: RET
// export function SortByClass ( units , class ) ; var un ; begin
53223: LD_INT 0
53225: PPUSH
53226: PPUSH
// if not units or not class then
53227: LD_VAR 0 1
53231: NOT
53232: PUSH
53233: LD_VAR 0 2
53237: NOT
53238: OR
53239: IFFALSE 53243
// exit ;
53241: GO 53338
// result := [ ] ;
53243: LD_ADDR_VAR 0 3
53247: PUSH
53248: EMPTY
53249: ST_TO_ADDR
// for un in units do
53250: LD_ADDR_VAR 0 4
53254: PUSH
53255: LD_VAR 0 1
53259: PUSH
53260: FOR_IN
53261: IFFALSE 53336
// if GetClass ( un ) = class then
53263: LD_VAR 0 4
53267: PPUSH
53268: CALL_OW 257
53272: PUSH
53273: LD_VAR 0 2
53277: EQUAL
53278: IFFALSE 53305
// result := Insert ( result , 1 , un ) else
53280: LD_ADDR_VAR 0 3
53284: PUSH
53285: LD_VAR 0 3
53289: PPUSH
53290: LD_INT 1
53292: PPUSH
53293: LD_VAR 0 4
53297: PPUSH
53298: CALL_OW 2
53302: ST_TO_ADDR
53303: GO 53334
// result := Replace ( result , result + 1 , un ) ;
53305: LD_ADDR_VAR 0 3
53309: PUSH
53310: LD_VAR 0 3
53314: PPUSH
53315: LD_VAR 0 3
53319: PUSH
53320: LD_INT 1
53322: PLUS
53323: PPUSH
53324: LD_VAR 0 4
53328: PPUSH
53329: CALL_OW 1
53333: ST_TO_ADDR
53334: GO 53260
53336: POP
53337: POP
// end ;
53338: LD_VAR 0 3
53342: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53343: LD_INT 0
53345: PPUSH
53346: PPUSH
53347: PPUSH
53348: PPUSH
53349: PPUSH
53350: PPUSH
53351: PPUSH
// result := [ ] ;
53352: LD_ADDR_VAR 0 4
53356: PUSH
53357: EMPTY
53358: ST_TO_ADDR
// if x - r < 0 then
53359: LD_VAR 0 1
53363: PUSH
53364: LD_VAR 0 3
53368: MINUS
53369: PUSH
53370: LD_INT 0
53372: LESS
53373: IFFALSE 53385
// min_x := 0 else
53375: LD_ADDR_VAR 0 8
53379: PUSH
53380: LD_INT 0
53382: ST_TO_ADDR
53383: GO 53401
// min_x := x - r ;
53385: LD_ADDR_VAR 0 8
53389: PUSH
53390: LD_VAR 0 1
53394: PUSH
53395: LD_VAR 0 3
53399: MINUS
53400: ST_TO_ADDR
// if y - r < 0 then
53401: LD_VAR 0 2
53405: PUSH
53406: LD_VAR 0 3
53410: MINUS
53411: PUSH
53412: LD_INT 0
53414: LESS
53415: IFFALSE 53427
// min_y := 0 else
53417: LD_ADDR_VAR 0 7
53421: PUSH
53422: LD_INT 0
53424: ST_TO_ADDR
53425: GO 53443
// min_y := y - r ;
53427: LD_ADDR_VAR 0 7
53431: PUSH
53432: LD_VAR 0 2
53436: PUSH
53437: LD_VAR 0 3
53441: MINUS
53442: ST_TO_ADDR
// max_x := x + r ;
53443: LD_ADDR_VAR 0 9
53447: PUSH
53448: LD_VAR 0 1
53452: PUSH
53453: LD_VAR 0 3
53457: PLUS
53458: ST_TO_ADDR
// max_y := y + r ;
53459: LD_ADDR_VAR 0 10
53463: PUSH
53464: LD_VAR 0 2
53468: PUSH
53469: LD_VAR 0 3
53473: PLUS
53474: ST_TO_ADDR
// for _x = min_x to max_x do
53475: LD_ADDR_VAR 0 5
53479: PUSH
53480: DOUBLE
53481: LD_VAR 0 8
53485: DEC
53486: ST_TO_ADDR
53487: LD_VAR 0 9
53491: PUSH
53492: FOR_TO
53493: IFFALSE 53594
// for _y = min_y to max_y do
53495: LD_ADDR_VAR 0 6
53499: PUSH
53500: DOUBLE
53501: LD_VAR 0 7
53505: DEC
53506: ST_TO_ADDR
53507: LD_VAR 0 10
53511: PUSH
53512: FOR_TO
53513: IFFALSE 53590
// begin if not ValidHex ( _x , _y ) then
53515: LD_VAR 0 5
53519: PPUSH
53520: LD_VAR 0 6
53524: PPUSH
53525: CALL_OW 488
53529: NOT
53530: IFFALSE 53534
// continue ;
53532: GO 53512
// if GetResourceTypeXY ( _x , _y ) then
53534: LD_VAR 0 5
53538: PPUSH
53539: LD_VAR 0 6
53543: PPUSH
53544: CALL_OW 283
53548: IFFALSE 53588
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53550: LD_ADDR_VAR 0 4
53554: PUSH
53555: LD_VAR 0 4
53559: PPUSH
53560: LD_VAR 0 4
53564: PUSH
53565: LD_INT 1
53567: PLUS
53568: PPUSH
53569: LD_VAR 0 5
53573: PUSH
53574: LD_VAR 0 6
53578: PUSH
53579: EMPTY
53580: LIST
53581: LIST
53582: PPUSH
53583: CALL_OW 1
53587: ST_TO_ADDR
// end ;
53588: GO 53512
53590: POP
53591: POP
53592: GO 53492
53594: POP
53595: POP
// end ;
53596: LD_VAR 0 4
53600: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
53601: LD_INT 0
53603: PPUSH
53604: PPUSH
53605: PPUSH
53606: PPUSH
53607: PPUSH
53608: PPUSH
53609: PPUSH
53610: PPUSH
// if not units then
53611: LD_VAR 0 1
53615: NOT
53616: IFFALSE 53620
// exit ;
53618: GO 54146
// result := UnitFilter ( units , [ f_ok ] ) ;
53620: LD_ADDR_VAR 0 3
53624: PUSH
53625: LD_VAR 0 1
53629: PPUSH
53630: LD_INT 50
53632: PUSH
53633: EMPTY
53634: LIST
53635: PPUSH
53636: CALL_OW 72
53640: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53641: LD_ADDR_VAR 0 8
53645: PUSH
53646: LD_VAR 0 1
53650: PUSH
53651: LD_INT 1
53653: ARRAY
53654: PPUSH
53655: CALL_OW 255
53659: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
53660: LD_ADDR_VAR 0 10
53664: PUSH
53665: LD_INT 29
53667: PUSH
53668: LD_EXP 52
53672: PUSH
53673: LD_INT 49
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: LIST
53680: ST_TO_ADDR
// if not result then
53681: LD_VAR 0 3
53685: NOT
53686: IFFALSE 53690
// exit ;
53688: GO 54146
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53690: LD_ADDR_VAR 0 5
53694: PUSH
53695: LD_INT 81
53697: PUSH
53698: LD_VAR 0 8
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PPUSH
53707: CALL_OW 69
53711: ST_TO_ADDR
// for i in result do
53712: LD_ADDR_VAR 0 4
53716: PUSH
53717: LD_VAR 0 3
53721: PUSH
53722: FOR_IN
53723: IFFALSE 54144
// begin tag := GetTag ( i ) + 1 ;
53725: LD_ADDR_VAR 0 9
53729: PUSH
53730: LD_VAR 0 4
53734: PPUSH
53735: CALL_OW 110
53739: PUSH
53740: LD_INT 1
53742: PLUS
53743: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53744: LD_ADDR_VAR 0 7
53748: PUSH
53749: LD_VAR 0 4
53753: PPUSH
53754: CALL_OW 250
53758: PPUSH
53759: LD_VAR 0 4
53763: PPUSH
53764: CALL_OW 251
53768: PPUSH
53769: LD_INT 6
53771: PPUSH
53772: CALL 53343 0 3
53776: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53777: LD_VAR 0 4
53781: PPUSH
53782: CALL_OW 247
53786: PUSH
53787: LD_INT 2
53789: EQUAL
53790: PUSH
53791: LD_VAR 0 7
53795: AND
53796: PUSH
53797: LD_VAR 0 4
53801: PPUSH
53802: CALL_OW 264
53806: PUSH
53807: LD_VAR 0 10
53811: IN
53812: NOT
53813: AND
53814: IFFALSE 53853
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53816: LD_VAR 0 4
53820: PPUSH
53821: LD_VAR 0 7
53825: PUSH
53826: LD_INT 1
53828: ARRAY
53829: PUSH
53830: LD_INT 1
53832: ARRAY
53833: PPUSH
53834: LD_VAR 0 7
53838: PUSH
53839: LD_INT 1
53841: ARRAY
53842: PUSH
53843: LD_INT 2
53845: ARRAY
53846: PPUSH
53847: CALL_OW 116
53851: GO 54142
// if path > tag then
53853: LD_VAR 0 2
53857: PUSH
53858: LD_VAR 0 9
53862: GREATER
53863: IFFALSE 54071
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
53865: LD_ADDR_VAR 0 6
53869: PUSH
53870: LD_VAR 0 5
53874: PPUSH
53875: LD_INT 91
53877: PUSH
53878: LD_VAR 0 4
53882: PUSH
53883: LD_INT 8
53885: PUSH
53886: EMPTY
53887: LIST
53888: LIST
53889: LIST
53890: PPUSH
53891: CALL_OW 72
53895: ST_TO_ADDR
// if nearEnemy then
53896: LD_VAR 0 6
53900: IFFALSE 53969
// begin if GetWeapon ( i ) = ru_time_lapser then
53902: LD_VAR 0 4
53906: PPUSH
53907: CALL_OW 264
53911: PUSH
53912: LD_INT 49
53914: EQUAL
53915: IFFALSE 53943
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53917: LD_VAR 0 4
53921: PPUSH
53922: LD_VAR 0 6
53926: PPUSH
53927: LD_VAR 0 4
53931: PPUSH
53932: CALL_OW 74
53936: PPUSH
53937: CALL_OW 112
53941: GO 53967
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
53943: LD_VAR 0 4
53947: PPUSH
53948: LD_VAR 0 6
53952: PPUSH
53953: LD_VAR 0 4
53957: PPUSH
53958: CALL_OW 74
53962: PPUSH
53963: CALL_OW 115
// end else
53967: GO 54069
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53969: LD_VAR 0 4
53973: PPUSH
53974: LD_VAR 0 2
53978: PUSH
53979: LD_VAR 0 9
53983: ARRAY
53984: PUSH
53985: LD_INT 1
53987: ARRAY
53988: PPUSH
53989: LD_VAR 0 2
53993: PUSH
53994: LD_VAR 0 9
53998: ARRAY
53999: PUSH
54000: LD_INT 2
54002: ARRAY
54003: PPUSH
54004: CALL_OW 297
54008: PUSH
54009: LD_INT 6
54011: GREATER
54012: IFFALSE 54055
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54014: LD_VAR 0 4
54018: PPUSH
54019: LD_VAR 0 2
54023: PUSH
54024: LD_VAR 0 9
54028: ARRAY
54029: PUSH
54030: LD_INT 1
54032: ARRAY
54033: PPUSH
54034: LD_VAR 0 2
54038: PUSH
54039: LD_VAR 0 9
54043: ARRAY
54044: PUSH
54045: LD_INT 2
54047: ARRAY
54048: PPUSH
54049: CALL_OW 114
54053: GO 54069
// SetTag ( i , tag ) ;
54055: LD_VAR 0 4
54059: PPUSH
54060: LD_VAR 0 9
54064: PPUSH
54065: CALL_OW 109
// end else
54069: GO 54142
// if enemy then
54071: LD_VAR 0 5
54075: IFFALSE 54142
// begin if GetWeapon ( i ) = ru_time_lapser then
54077: LD_VAR 0 4
54081: PPUSH
54082: CALL_OW 264
54086: PUSH
54087: LD_INT 49
54089: EQUAL
54090: IFFALSE 54118
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54092: LD_VAR 0 4
54096: PPUSH
54097: LD_VAR 0 5
54101: PPUSH
54102: LD_VAR 0 4
54106: PPUSH
54107: CALL_OW 74
54111: PPUSH
54112: CALL_OW 112
54116: GO 54142
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54118: LD_VAR 0 4
54122: PPUSH
54123: LD_VAR 0 5
54127: PPUSH
54128: LD_VAR 0 4
54132: PPUSH
54133: CALL_OW 74
54137: PPUSH
54138: CALL_OW 115
// end ; end ;
54142: GO 53722
54144: POP
54145: POP
// end ;
54146: LD_VAR 0 3
54150: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54151: LD_INT 0
54153: PPUSH
54154: PPUSH
54155: PPUSH
// if not unit or IsInUnit ( unit ) then
54156: LD_VAR 0 1
54160: NOT
54161: PUSH
54162: LD_VAR 0 1
54166: PPUSH
54167: CALL_OW 310
54171: OR
54172: IFFALSE 54176
// exit ;
54174: GO 54267
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54176: LD_ADDR_VAR 0 4
54180: PUSH
54181: LD_VAR 0 1
54185: PPUSH
54186: CALL_OW 250
54190: PPUSH
54191: LD_VAR 0 2
54195: PPUSH
54196: LD_INT 1
54198: PPUSH
54199: CALL_OW 272
54203: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54204: LD_ADDR_VAR 0 5
54208: PUSH
54209: LD_VAR 0 1
54213: PPUSH
54214: CALL_OW 251
54218: PPUSH
54219: LD_VAR 0 2
54223: PPUSH
54224: LD_INT 1
54226: PPUSH
54227: CALL_OW 273
54231: ST_TO_ADDR
// if ValidHex ( x , y ) then
54232: LD_VAR 0 4
54236: PPUSH
54237: LD_VAR 0 5
54241: PPUSH
54242: CALL_OW 488
54246: IFFALSE 54267
// ComTurnXY ( unit , x , y ) ;
54248: LD_VAR 0 1
54252: PPUSH
54253: LD_VAR 0 4
54257: PPUSH
54258: LD_VAR 0 5
54262: PPUSH
54263: CALL_OW 118
// end ;
54267: LD_VAR 0 3
54271: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54272: LD_INT 0
54274: PPUSH
54275: PPUSH
// result := false ;
54276: LD_ADDR_VAR 0 3
54280: PUSH
54281: LD_INT 0
54283: ST_TO_ADDR
// if not units then
54284: LD_VAR 0 2
54288: NOT
54289: IFFALSE 54293
// exit ;
54291: GO 54338
// for i in units do
54293: LD_ADDR_VAR 0 4
54297: PUSH
54298: LD_VAR 0 2
54302: PUSH
54303: FOR_IN
54304: IFFALSE 54336
// if See ( side , i ) then
54306: LD_VAR 0 1
54310: PPUSH
54311: LD_VAR 0 4
54315: PPUSH
54316: CALL_OW 292
54320: IFFALSE 54334
// begin result := true ;
54322: LD_ADDR_VAR 0 3
54326: PUSH
54327: LD_INT 1
54329: ST_TO_ADDR
// exit ;
54330: POP
54331: POP
54332: GO 54338
// end ;
54334: GO 54303
54336: POP
54337: POP
// end ;
54338: LD_VAR 0 3
54342: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54343: LD_INT 0
54345: PPUSH
54346: PPUSH
54347: PPUSH
54348: PPUSH
// if not unit or not points then
54349: LD_VAR 0 1
54353: NOT
54354: PUSH
54355: LD_VAR 0 2
54359: NOT
54360: OR
54361: IFFALSE 54365
// exit ;
54363: GO 54455
// dist := 99999 ;
54365: LD_ADDR_VAR 0 5
54369: PUSH
54370: LD_INT 99999
54372: ST_TO_ADDR
// for i in points do
54373: LD_ADDR_VAR 0 4
54377: PUSH
54378: LD_VAR 0 2
54382: PUSH
54383: FOR_IN
54384: IFFALSE 54453
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54386: LD_ADDR_VAR 0 6
54390: PUSH
54391: LD_VAR 0 1
54395: PPUSH
54396: LD_VAR 0 4
54400: PUSH
54401: LD_INT 1
54403: ARRAY
54404: PPUSH
54405: LD_VAR 0 4
54409: PUSH
54410: LD_INT 2
54412: ARRAY
54413: PPUSH
54414: CALL_OW 297
54418: ST_TO_ADDR
// if tmpDist < dist then
54419: LD_VAR 0 6
54423: PUSH
54424: LD_VAR 0 5
54428: LESS
54429: IFFALSE 54451
// begin result := i ;
54431: LD_ADDR_VAR 0 3
54435: PUSH
54436: LD_VAR 0 4
54440: ST_TO_ADDR
// dist := tmpDist ;
54441: LD_ADDR_VAR 0 5
54445: PUSH
54446: LD_VAR 0 6
54450: ST_TO_ADDR
// end ; end ;
54451: GO 54383
54453: POP
54454: POP
// end ;
54455: LD_VAR 0 3
54459: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
54460: LD_INT 0
54462: PPUSH
// uc_side := side ;
54463: LD_ADDR_OWVAR 20
54467: PUSH
54468: LD_VAR 0 1
54472: ST_TO_ADDR
// uc_nation := 3 ;
54473: LD_ADDR_OWVAR 21
54477: PUSH
54478: LD_INT 3
54480: ST_TO_ADDR
// vc_chassis := 25 ;
54481: LD_ADDR_OWVAR 37
54485: PUSH
54486: LD_INT 25
54488: ST_TO_ADDR
// vc_engine := engine_siberite ;
54489: LD_ADDR_OWVAR 39
54493: PUSH
54494: LD_INT 3
54496: ST_TO_ADDR
// vc_control := control_computer ;
54497: LD_ADDR_OWVAR 38
54501: PUSH
54502: LD_INT 3
54504: ST_TO_ADDR
// vc_weapon := 59 ;
54505: LD_ADDR_OWVAR 40
54509: PUSH
54510: LD_INT 59
54512: ST_TO_ADDR
// result := CreateVehicle ;
54513: LD_ADDR_VAR 0 5
54517: PUSH
54518: CALL_OW 45
54522: ST_TO_ADDR
// SetDir ( result , d ) ;
54523: LD_VAR 0 5
54527: PPUSH
54528: LD_VAR 0 4
54532: PPUSH
54533: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
54537: LD_VAR 0 5
54541: PPUSH
54542: LD_VAR 0 2
54546: PPUSH
54547: LD_VAR 0 3
54551: PPUSH
54552: LD_INT 0
54554: PPUSH
54555: CALL_OW 48
// end ;
54559: LD_VAR 0 5
54563: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
54564: LD_INT 0
54566: PPUSH
54567: PPUSH
54568: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
54569: LD_ADDR_VAR 0 2
54573: PUSH
54574: LD_INT 0
54576: PUSH
54577: LD_INT 0
54579: PUSH
54580: LD_INT 0
54582: PUSH
54583: LD_INT 0
54585: PUSH
54586: EMPTY
54587: LIST
54588: LIST
54589: LIST
54590: LIST
54591: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
54592: LD_VAR 0 1
54596: NOT
54597: PUSH
54598: LD_VAR 0 1
54602: PPUSH
54603: CALL_OW 264
54607: PUSH
54608: LD_INT 12
54610: PUSH
54611: LD_INT 51
54613: PUSH
54614: LD_INT 32
54616: PUSH
54617: LD_EXP 49
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: LIST
54626: LIST
54627: IN
54628: NOT
54629: OR
54630: IFFALSE 54634
// exit ;
54632: GO 54732
// for i := 1 to 3 do
54634: LD_ADDR_VAR 0 3
54638: PUSH
54639: DOUBLE
54640: LD_INT 1
54642: DEC
54643: ST_TO_ADDR
54644: LD_INT 3
54646: PUSH
54647: FOR_TO
54648: IFFALSE 54730
// begin tmp := GetCargo ( cargo , i ) ;
54650: LD_ADDR_VAR 0 4
54654: PUSH
54655: LD_VAR 0 1
54659: PPUSH
54660: LD_VAR 0 3
54664: PPUSH
54665: CALL_OW 289
54669: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
54670: LD_ADDR_VAR 0 2
54674: PUSH
54675: LD_VAR 0 2
54679: PPUSH
54680: LD_VAR 0 3
54684: PPUSH
54685: LD_VAR 0 4
54689: PPUSH
54690: CALL_OW 1
54694: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
54695: LD_ADDR_VAR 0 2
54699: PUSH
54700: LD_VAR 0 2
54704: PPUSH
54705: LD_INT 4
54707: PPUSH
54708: LD_VAR 0 2
54712: PUSH
54713: LD_INT 4
54715: ARRAY
54716: PUSH
54717: LD_VAR 0 4
54721: PLUS
54722: PPUSH
54723: CALL_OW 1
54727: ST_TO_ADDR
// end ;
54728: GO 54647
54730: POP
54731: POP
// end ;
54732: LD_VAR 0 2
54736: RET
// export function Length ( array ) ; begin
54737: LD_INT 0
54739: PPUSH
// result := array + 0 ;
54740: LD_ADDR_VAR 0 2
54744: PUSH
54745: LD_VAR 0 1
54749: PUSH
54750: LD_INT 0
54752: PLUS
54753: ST_TO_ADDR
// end ;
54754: LD_VAR 0 2
54758: RET
// export function PrepareArray ( array ) ; begin
54759: LD_INT 0
54761: PPUSH
// result := array diff 0 ;
54762: LD_ADDR_VAR 0 2
54766: PUSH
54767: LD_VAR 0 1
54771: PUSH
54772: LD_INT 0
54774: DIFF
54775: ST_TO_ADDR
// if not result [ 1 ] then
54776: LD_VAR 0 2
54780: PUSH
54781: LD_INT 1
54783: ARRAY
54784: NOT
54785: IFFALSE 54805
// result := Delete ( result , 1 ) ;
54787: LD_ADDR_VAR 0 2
54791: PUSH
54792: LD_VAR 0 2
54796: PPUSH
54797: LD_INT 1
54799: PPUSH
54800: CALL_OW 3
54804: ST_TO_ADDR
// end ; end_of_file
54805: LD_VAR 0 2
54809: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
54810: LD_INT 0
54812: PPUSH
// ar_miner := 81 ;
54813: LD_ADDR_EXP 55
54817: PUSH
54818: LD_INT 81
54820: ST_TO_ADDR
// ar_crane := 88 ;
54821: LD_ADDR_EXP 54
54825: PUSH
54826: LD_INT 88
54828: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
54829: LD_ADDR_EXP 49
54833: PUSH
54834: LD_INT 89
54836: ST_TO_ADDR
// us_hack := 99 ;
54837: LD_ADDR_EXP 50
54841: PUSH
54842: LD_INT 99
54844: ST_TO_ADDR
// us_artillery := 97 ;
54845: LD_ADDR_EXP 51
54849: PUSH
54850: LD_INT 97
54852: ST_TO_ADDR
// ar_bio_bomb := 91 ;
54853: LD_ADDR_EXP 52
54857: PUSH
54858: LD_INT 91
54860: ST_TO_ADDR
// ar_mortar := 92 ;
54861: LD_ADDR_EXP 53
54865: PUSH
54866: LD_INT 92
54868: ST_TO_ADDR
// ru_flamethrower := 93 ;
54869: LD_ADDR_EXP 56
54873: PUSH
54874: LD_INT 93
54876: ST_TO_ADDR
// ru_radar := 98 ;
54877: LD_ADDR_EXP 48
54881: PUSH
54882: LD_INT 98
54884: ST_TO_ADDR
// tech_Artillery := 80 ;
54885: LD_ADDR_EXP 57
54889: PUSH
54890: LD_INT 80
54892: ST_TO_ADDR
// tech_RadMat := 81 ;
54893: LD_ADDR_EXP 58
54897: PUSH
54898: LD_INT 81
54900: ST_TO_ADDR
// tech_BasicTools := 82 ;
54901: LD_ADDR_EXP 59
54905: PUSH
54906: LD_INT 82
54908: ST_TO_ADDR
// tech_Cargo := 83 ;
54909: LD_ADDR_EXP 60
54913: PUSH
54914: LD_INT 83
54916: ST_TO_ADDR
// tech_Track := 84 ;
54917: LD_ADDR_EXP 61
54921: PUSH
54922: LD_INT 84
54924: ST_TO_ADDR
// tech_Crane := 85 ;
54925: LD_ADDR_EXP 62
54929: PUSH
54930: LD_INT 85
54932: ST_TO_ADDR
// tech_Bulldozer := 86 ;
54933: LD_ADDR_EXP 63
54937: PUSH
54938: LD_INT 86
54940: ST_TO_ADDR
// tech_Hovercraft := 87 ;
54941: LD_ADDR_EXP 64
54945: PUSH
54946: LD_INT 87
54948: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
54949: LD_ADDR_EXP 65
54953: PUSH
54954: LD_INT 88
54956: ST_TO_ADDR
// end ;
54957: LD_VAR 0 1
54961: RET
// every 1 do
54962: GO 54964
54964: DISABLE
// InitGlobalVariables ; end_of_file
54965: CALL 54810 0 0
54969: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54970: LD_INT 0
54972: PPUSH
54973: PPUSH
// skirmish := false ;
54974: LD_ADDR_EXP 66
54978: PUSH
54979: LD_INT 0
54981: ST_TO_ADDR
// debug_mc := false ;
54982: LD_ADDR_EXP 67
54986: PUSH
54987: LD_INT 0
54989: ST_TO_ADDR
// mc_bases := [ ] ;
54990: LD_ADDR_EXP 68
54994: PUSH
54995: EMPTY
54996: ST_TO_ADDR
// mc_sides := [ ] ;
54997: LD_ADDR_EXP 94
55001: PUSH
55002: EMPTY
55003: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55004: LD_ADDR_EXP 69
55008: PUSH
55009: EMPTY
55010: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55011: LD_ADDR_EXP 70
55015: PUSH
55016: EMPTY
55017: ST_TO_ADDR
// mc_need_heal := [ ] ;
55018: LD_ADDR_EXP 71
55022: PUSH
55023: EMPTY
55024: ST_TO_ADDR
// mc_healers := [ ] ;
55025: LD_ADDR_EXP 72
55029: PUSH
55030: EMPTY
55031: ST_TO_ADDR
// mc_build_list := [ ] ;
55032: LD_ADDR_EXP 73
55036: PUSH
55037: EMPTY
55038: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55039: LD_ADDR_EXP 100
55043: PUSH
55044: EMPTY
55045: ST_TO_ADDR
// mc_builders := [ ] ;
55046: LD_ADDR_EXP 74
55050: PUSH
55051: EMPTY
55052: ST_TO_ADDR
// mc_construct_list := [ ] ;
55053: LD_ADDR_EXP 75
55057: PUSH
55058: EMPTY
55059: ST_TO_ADDR
// mc_turret_list := [ ] ;
55060: LD_ADDR_EXP 76
55064: PUSH
55065: EMPTY
55066: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55067: LD_ADDR_EXP 77
55071: PUSH
55072: EMPTY
55073: ST_TO_ADDR
// mc_miners := [ ] ;
55074: LD_ADDR_EXP 82
55078: PUSH
55079: EMPTY
55080: ST_TO_ADDR
// mc_mines := [ ] ;
55081: LD_ADDR_EXP 81
55085: PUSH
55086: EMPTY
55087: ST_TO_ADDR
// mc_minefields := [ ] ;
55088: LD_ADDR_EXP 83
55092: PUSH
55093: EMPTY
55094: ST_TO_ADDR
// mc_crates := [ ] ;
55095: LD_ADDR_EXP 84
55099: PUSH
55100: EMPTY
55101: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55102: LD_ADDR_EXP 85
55106: PUSH
55107: EMPTY
55108: ST_TO_ADDR
// mc_crates_area := [ ] ;
55109: LD_ADDR_EXP 86
55113: PUSH
55114: EMPTY
55115: ST_TO_ADDR
// mc_vehicles := [ ] ;
55116: LD_ADDR_EXP 87
55120: PUSH
55121: EMPTY
55122: ST_TO_ADDR
// mc_attack := [ ] ;
55123: LD_ADDR_EXP 88
55127: PUSH
55128: EMPTY
55129: ST_TO_ADDR
// mc_produce := [ ] ;
55130: LD_ADDR_EXP 89
55134: PUSH
55135: EMPTY
55136: ST_TO_ADDR
// mc_defender := [ ] ;
55137: LD_ADDR_EXP 90
55141: PUSH
55142: EMPTY
55143: ST_TO_ADDR
// mc_parking := [ ] ;
55144: LD_ADDR_EXP 92
55148: PUSH
55149: EMPTY
55150: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55151: LD_ADDR_EXP 78
55155: PUSH
55156: EMPTY
55157: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55158: LD_ADDR_EXP 80
55162: PUSH
55163: EMPTY
55164: ST_TO_ADDR
// mc_scan := [ ] ;
55165: LD_ADDR_EXP 91
55169: PUSH
55170: EMPTY
55171: ST_TO_ADDR
// mc_scan_area := [ ] ;
55172: LD_ADDR_EXP 93
55176: PUSH
55177: EMPTY
55178: ST_TO_ADDR
// mc_tech := [ ] ;
55179: LD_ADDR_EXP 95
55183: PUSH
55184: EMPTY
55185: ST_TO_ADDR
// mc_class := [ ] ;
55186: LD_ADDR_EXP 109
55190: PUSH
55191: EMPTY
55192: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55193: LD_ADDR_EXP 110
55197: PUSH
55198: EMPTY
55199: ST_TO_ADDR
// mc_is_defending := [ ] ;
55200: LD_ADDR_EXP 111
55204: PUSH
55205: EMPTY
55206: ST_TO_ADDR
// end ;
55207: LD_VAR 0 1
55211: RET
// export function MC_Kill ( base ) ; begin
55212: LD_INT 0
55214: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55215: LD_ADDR_EXP 68
55219: PUSH
55220: LD_EXP 68
55224: PPUSH
55225: LD_VAR 0 1
55229: PPUSH
55230: EMPTY
55231: PPUSH
55232: CALL_OW 1
55236: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55237: LD_ADDR_EXP 69
55241: PUSH
55242: LD_EXP 69
55246: PPUSH
55247: LD_VAR 0 1
55251: PPUSH
55252: EMPTY
55253: PPUSH
55254: CALL_OW 1
55258: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55259: LD_ADDR_EXP 70
55263: PUSH
55264: LD_EXP 70
55268: PPUSH
55269: LD_VAR 0 1
55273: PPUSH
55274: EMPTY
55275: PPUSH
55276: CALL_OW 1
55280: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55281: LD_ADDR_EXP 71
55285: PUSH
55286: LD_EXP 71
55290: PPUSH
55291: LD_VAR 0 1
55295: PPUSH
55296: EMPTY
55297: PPUSH
55298: CALL_OW 1
55302: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55303: LD_ADDR_EXP 72
55307: PUSH
55308: LD_EXP 72
55312: PPUSH
55313: LD_VAR 0 1
55317: PPUSH
55318: EMPTY
55319: PPUSH
55320: CALL_OW 1
55324: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55325: LD_ADDR_EXP 73
55329: PUSH
55330: LD_EXP 73
55334: PPUSH
55335: LD_VAR 0 1
55339: PPUSH
55340: EMPTY
55341: PPUSH
55342: CALL_OW 1
55346: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55347: LD_ADDR_EXP 74
55351: PUSH
55352: LD_EXP 74
55356: PPUSH
55357: LD_VAR 0 1
55361: PPUSH
55362: EMPTY
55363: PPUSH
55364: CALL_OW 1
55368: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55369: LD_ADDR_EXP 75
55373: PUSH
55374: LD_EXP 75
55378: PPUSH
55379: LD_VAR 0 1
55383: PPUSH
55384: EMPTY
55385: PPUSH
55386: CALL_OW 1
55390: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55391: LD_ADDR_EXP 76
55395: PUSH
55396: LD_EXP 76
55400: PPUSH
55401: LD_VAR 0 1
55405: PPUSH
55406: EMPTY
55407: PPUSH
55408: CALL_OW 1
55412: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55413: LD_ADDR_EXP 77
55417: PUSH
55418: LD_EXP 77
55422: PPUSH
55423: LD_VAR 0 1
55427: PPUSH
55428: EMPTY
55429: PPUSH
55430: CALL_OW 1
55434: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55435: LD_ADDR_EXP 78
55439: PUSH
55440: LD_EXP 78
55444: PPUSH
55445: LD_VAR 0 1
55449: PPUSH
55450: EMPTY
55451: PPUSH
55452: CALL_OW 1
55456: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55457: LD_ADDR_EXP 79
55461: PUSH
55462: LD_EXP 79
55466: PPUSH
55467: LD_VAR 0 1
55471: PPUSH
55472: LD_INT 0
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55480: LD_ADDR_EXP 80
55484: PUSH
55485: LD_EXP 80
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: EMPTY
55496: PPUSH
55497: CALL_OW 1
55501: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55502: LD_ADDR_EXP 81
55506: PUSH
55507: LD_EXP 81
55511: PPUSH
55512: LD_VAR 0 1
55516: PPUSH
55517: EMPTY
55518: PPUSH
55519: CALL_OW 1
55523: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55524: LD_ADDR_EXP 82
55528: PUSH
55529: LD_EXP 82
55533: PPUSH
55534: LD_VAR 0 1
55538: PPUSH
55539: EMPTY
55540: PPUSH
55541: CALL_OW 1
55545: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55546: LD_ADDR_EXP 83
55550: PUSH
55551: LD_EXP 83
55555: PPUSH
55556: LD_VAR 0 1
55560: PPUSH
55561: EMPTY
55562: PPUSH
55563: CALL_OW 1
55567: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55568: LD_ADDR_EXP 84
55572: PUSH
55573: LD_EXP 84
55577: PPUSH
55578: LD_VAR 0 1
55582: PPUSH
55583: EMPTY
55584: PPUSH
55585: CALL_OW 1
55589: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55590: LD_ADDR_EXP 85
55594: PUSH
55595: LD_EXP 85
55599: PPUSH
55600: LD_VAR 0 1
55604: PPUSH
55605: EMPTY
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55612: LD_ADDR_EXP 86
55616: PUSH
55617: LD_EXP 86
55621: PPUSH
55622: LD_VAR 0 1
55626: PPUSH
55627: EMPTY
55628: PPUSH
55629: CALL_OW 1
55633: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55634: LD_ADDR_EXP 87
55638: PUSH
55639: LD_EXP 87
55643: PPUSH
55644: LD_VAR 0 1
55648: PPUSH
55649: EMPTY
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55656: LD_ADDR_EXP 88
55660: PUSH
55661: LD_EXP 88
55665: PPUSH
55666: LD_VAR 0 1
55670: PPUSH
55671: EMPTY
55672: PPUSH
55673: CALL_OW 1
55677: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55678: LD_ADDR_EXP 89
55682: PUSH
55683: LD_EXP 89
55687: PPUSH
55688: LD_VAR 0 1
55692: PPUSH
55693: EMPTY
55694: PPUSH
55695: CALL_OW 1
55699: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55700: LD_ADDR_EXP 90
55704: PUSH
55705: LD_EXP 90
55709: PPUSH
55710: LD_VAR 0 1
55714: PPUSH
55715: EMPTY
55716: PPUSH
55717: CALL_OW 1
55721: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55722: LD_ADDR_EXP 91
55726: PUSH
55727: LD_EXP 91
55731: PPUSH
55732: LD_VAR 0 1
55736: PPUSH
55737: EMPTY
55738: PPUSH
55739: CALL_OW 1
55743: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55744: LD_ADDR_EXP 92
55748: PUSH
55749: LD_EXP 92
55753: PPUSH
55754: LD_VAR 0 1
55758: PPUSH
55759: EMPTY
55760: PPUSH
55761: CALL_OW 1
55765: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55766: LD_ADDR_EXP 93
55770: PUSH
55771: LD_EXP 93
55775: PPUSH
55776: LD_VAR 0 1
55780: PPUSH
55781: EMPTY
55782: PPUSH
55783: CALL_OW 1
55787: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55788: LD_ADDR_EXP 95
55792: PUSH
55793: LD_EXP 95
55797: PPUSH
55798: LD_VAR 0 1
55802: PPUSH
55803: EMPTY
55804: PPUSH
55805: CALL_OW 1
55809: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55810: LD_ADDR_EXP 97
55814: PUSH
55815: LD_EXP 97
55819: PPUSH
55820: LD_VAR 0 1
55824: PPUSH
55825: EMPTY
55826: PPUSH
55827: CALL_OW 1
55831: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55832: LD_ADDR_EXP 98
55836: PUSH
55837: LD_EXP 98
55841: PPUSH
55842: LD_VAR 0 1
55846: PPUSH
55847: EMPTY
55848: PPUSH
55849: CALL_OW 1
55853: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55854: LD_ADDR_EXP 99
55858: PUSH
55859: LD_EXP 99
55863: PPUSH
55864: LD_VAR 0 1
55868: PPUSH
55869: EMPTY
55870: PPUSH
55871: CALL_OW 1
55875: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55876: LD_ADDR_EXP 100
55880: PUSH
55881: LD_EXP 100
55885: PPUSH
55886: LD_VAR 0 1
55890: PPUSH
55891: EMPTY
55892: PPUSH
55893: CALL_OW 1
55897: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55898: LD_ADDR_EXP 101
55902: PUSH
55903: LD_EXP 101
55907: PPUSH
55908: LD_VAR 0 1
55912: PPUSH
55913: EMPTY
55914: PPUSH
55915: CALL_OW 1
55919: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55920: LD_ADDR_EXP 102
55924: PUSH
55925: LD_EXP 102
55929: PPUSH
55930: LD_VAR 0 1
55934: PPUSH
55935: EMPTY
55936: PPUSH
55937: CALL_OW 1
55941: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55942: LD_ADDR_EXP 103
55946: PUSH
55947: LD_EXP 103
55951: PPUSH
55952: LD_VAR 0 1
55956: PPUSH
55957: EMPTY
55958: PPUSH
55959: CALL_OW 1
55963: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55964: LD_ADDR_EXP 104
55968: PUSH
55969: LD_EXP 104
55973: PPUSH
55974: LD_VAR 0 1
55978: PPUSH
55979: EMPTY
55980: PPUSH
55981: CALL_OW 1
55985: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55986: LD_ADDR_EXP 105
55990: PUSH
55991: LD_EXP 105
55995: PPUSH
55996: LD_VAR 0 1
56000: PPUSH
56001: EMPTY
56002: PPUSH
56003: CALL_OW 1
56007: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56008: LD_ADDR_EXP 106
56012: PUSH
56013: LD_EXP 106
56017: PPUSH
56018: LD_VAR 0 1
56022: PPUSH
56023: EMPTY
56024: PPUSH
56025: CALL_OW 1
56029: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56030: LD_ADDR_EXP 107
56034: PUSH
56035: LD_EXP 107
56039: PPUSH
56040: LD_VAR 0 1
56044: PPUSH
56045: EMPTY
56046: PPUSH
56047: CALL_OW 1
56051: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56052: LD_ADDR_EXP 108
56056: PUSH
56057: LD_EXP 108
56061: PPUSH
56062: LD_VAR 0 1
56066: PPUSH
56067: EMPTY
56068: PPUSH
56069: CALL_OW 1
56073: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56074: LD_ADDR_EXP 109
56078: PUSH
56079: LD_EXP 109
56083: PPUSH
56084: LD_VAR 0 1
56088: PPUSH
56089: EMPTY
56090: PPUSH
56091: CALL_OW 1
56095: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56096: LD_ADDR_EXP 110
56100: PUSH
56101: LD_EXP 110
56105: PPUSH
56106: LD_VAR 0 1
56110: PPUSH
56111: LD_INT 0
56113: PPUSH
56114: CALL_OW 1
56118: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56119: LD_ADDR_EXP 111
56123: PUSH
56124: LD_EXP 111
56128: PPUSH
56129: LD_VAR 0 1
56133: PPUSH
56134: LD_INT 0
56136: PPUSH
56137: CALL_OW 1
56141: ST_TO_ADDR
// end ;
56142: LD_VAR 0 2
56146: RET
// export function MC_Add ( side , units ) ; var base ; begin
56147: LD_INT 0
56149: PPUSH
56150: PPUSH
// base := mc_bases + 1 ;
56151: LD_ADDR_VAR 0 4
56155: PUSH
56156: LD_EXP 68
56160: PUSH
56161: LD_INT 1
56163: PLUS
56164: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56165: LD_ADDR_EXP 94
56169: PUSH
56170: LD_EXP 94
56174: PPUSH
56175: LD_VAR 0 4
56179: PPUSH
56180: LD_VAR 0 1
56184: PPUSH
56185: CALL_OW 1
56189: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56190: LD_ADDR_EXP 68
56194: PUSH
56195: LD_EXP 68
56199: PPUSH
56200: LD_VAR 0 4
56204: PPUSH
56205: LD_VAR 0 2
56209: PPUSH
56210: CALL_OW 1
56214: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56215: LD_ADDR_EXP 69
56219: PUSH
56220: LD_EXP 69
56224: PPUSH
56225: LD_VAR 0 4
56229: PPUSH
56230: EMPTY
56231: PPUSH
56232: CALL_OW 1
56236: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56237: LD_ADDR_EXP 70
56241: PUSH
56242: LD_EXP 70
56246: PPUSH
56247: LD_VAR 0 4
56251: PPUSH
56252: EMPTY
56253: PPUSH
56254: CALL_OW 1
56258: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56259: LD_ADDR_EXP 71
56263: PUSH
56264: LD_EXP 71
56268: PPUSH
56269: LD_VAR 0 4
56273: PPUSH
56274: EMPTY
56275: PPUSH
56276: CALL_OW 1
56280: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56281: LD_ADDR_EXP 72
56285: PUSH
56286: LD_EXP 72
56290: PPUSH
56291: LD_VAR 0 4
56295: PPUSH
56296: EMPTY
56297: PPUSH
56298: CALL_OW 1
56302: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56303: LD_ADDR_EXP 73
56307: PUSH
56308: LD_EXP 73
56312: PPUSH
56313: LD_VAR 0 4
56317: PPUSH
56318: EMPTY
56319: PPUSH
56320: CALL_OW 1
56324: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56325: LD_ADDR_EXP 74
56329: PUSH
56330: LD_EXP 74
56334: PPUSH
56335: LD_VAR 0 4
56339: PPUSH
56340: EMPTY
56341: PPUSH
56342: CALL_OW 1
56346: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56347: LD_ADDR_EXP 75
56351: PUSH
56352: LD_EXP 75
56356: PPUSH
56357: LD_VAR 0 4
56361: PPUSH
56362: EMPTY
56363: PPUSH
56364: CALL_OW 1
56368: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56369: LD_ADDR_EXP 76
56373: PUSH
56374: LD_EXP 76
56378: PPUSH
56379: LD_VAR 0 4
56383: PPUSH
56384: EMPTY
56385: PPUSH
56386: CALL_OW 1
56390: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56391: LD_ADDR_EXP 77
56395: PUSH
56396: LD_EXP 77
56400: PPUSH
56401: LD_VAR 0 4
56405: PPUSH
56406: EMPTY
56407: PPUSH
56408: CALL_OW 1
56412: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56413: LD_ADDR_EXP 78
56417: PUSH
56418: LD_EXP 78
56422: PPUSH
56423: LD_VAR 0 4
56427: PPUSH
56428: EMPTY
56429: PPUSH
56430: CALL_OW 1
56434: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56435: LD_ADDR_EXP 79
56439: PUSH
56440: LD_EXP 79
56444: PPUSH
56445: LD_VAR 0 4
56449: PPUSH
56450: LD_INT 0
56452: PPUSH
56453: CALL_OW 1
56457: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56458: LD_ADDR_EXP 80
56462: PUSH
56463: LD_EXP 80
56467: PPUSH
56468: LD_VAR 0 4
56472: PPUSH
56473: EMPTY
56474: PPUSH
56475: CALL_OW 1
56479: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56480: LD_ADDR_EXP 81
56484: PUSH
56485: LD_EXP 81
56489: PPUSH
56490: LD_VAR 0 4
56494: PPUSH
56495: EMPTY
56496: PPUSH
56497: CALL_OW 1
56501: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56502: LD_ADDR_EXP 82
56506: PUSH
56507: LD_EXP 82
56511: PPUSH
56512: LD_VAR 0 4
56516: PPUSH
56517: EMPTY
56518: PPUSH
56519: CALL_OW 1
56523: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56524: LD_ADDR_EXP 83
56528: PUSH
56529: LD_EXP 83
56533: PPUSH
56534: LD_VAR 0 4
56538: PPUSH
56539: EMPTY
56540: PPUSH
56541: CALL_OW 1
56545: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56546: LD_ADDR_EXP 84
56550: PUSH
56551: LD_EXP 84
56555: PPUSH
56556: LD_VAR 0 4
56560: PPUSH
56561: EMPTY
56562: PPUSH
56563: CALL_OW 1
56567: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56568: LD_ADDR_EXP 85
56572: PUSH
56573: LD_EXP 85
56577: PPUSH
56578: LD_VAR 0 4
56582: PPUSH
56583: EMPTY
56584: PPUSH
56585: CALL_OW 1
56589: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56590: LD_ADDR_EXP 86
56594: PUSH
56595: LD_EXP 86
56599: PPUSH
56600: LD_VAR 0 4
56604: PPUSH
56605: EMPTY
56606: PPUSH
56607: CALL_OW 1
56611: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56612: LD_ADDR_EXP 87
56616: PUSH
56617: LD_EXP 87
56621: PPUSH
56622: LD_VAR 0 4
56626: PPUSH
56627: EMPTY
56628: PPUSH
56629: CALL_OW 1
56633: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56634: LD_ADDR_EXP 88
56638: PUSH
56639: LD_EXP 88
56643: PPUSH
56644: LD_VAR 0 4
56648: PPUSH
56649: EMPTY
56650: PPUSH
56651: CALL_OW 1
56655: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56656: LD_ADDR_EXP 89
56660: PUSH
56661: LD_EXP 89
56665: PPUSH
56666: LD_VAR 0 4
56670: PPUSH
56671: EMPTY
56672: PPUSH
56673: CALL_OW 1
56677: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56678: LD_ADDR_EXP 90
56682: PUSH
56683: LD_EXP 90
56687: PPUSH
56688: LD_VAR 0 4
56692: PPUSH
56693: EMPTY
56694: PPUSH
56695: CALL_OW 1
56699: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56700: LD_ADDR_EXP 91
56704: PUSH
56705: LD_EXP 91
56709: PPUSH
56710: LD_VAR 0 4
56714: PPUSH
56715: EMPTY
56716: PPUSH
56717: CALL_OW 1
56721: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56722: LD_ADDR_EXP 92
56726: PUSH
56727: LD_EXP 92
56731: PPUSH
56732: LD_VAR 0 4
56736: PPUSH
56737: EMPTY
56738: PPUSH
56739: CALL_OW 1
56743: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56744: LD_ADDR_EXP 93
56748: PUSH
56749: LD_EXP 93
56753: PPUSH
56754: LD_VAR 0 4
56758: PPUSH
56759: EMPTY
56760: PPUSH
56761: CALL_OW 1
56765: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56766: LD_ADDR_EXP 95
56770: PUSH
56771: LD_EXP 95
56775: PPUSH
56776: LD_VAR 0 4
56780: PPUSH
56781: EMPTY
56782: PPUSH
56783: CALL_OW 1
56787: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56788: LD_ADDR_EXP 97
56792: PUSH
56793: LD_EXP 97
56797: PPUSH
56798: LD_VAR 0 4
56802: PPUSH
56803: EMPTY
56804: PPUSH
56805: CALL_OW 1
56809: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56810: LD_ADDR_EXP 98
56814: PUSH
56815: LD_EXP 98
56819: PPUSH
56820: LD_VAR 0 4
56824: PPUSH
56825: EMPTY
56826: PPUSH
56827: CALL_OW 1
56831: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56832: LD_ADDR_EXP 99
56836: PUSH
56837: LD_EXP 99
56841: PPUSH
56842: LD_VAR 0 4
56846: PPUSH
56847: EMPTY
56848: PPUSH
56849: CALL_OW 1
56853: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56854: LD_ADDR_EXP 100
56858: PUSH
56859: LD_EXP 100
56863: PPUSH
56864: LD_VAR 0 4
56868: PPUSH
56869: EMPTY
56870: PPUSH
56871: CALL_OW 1
56875: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56876: LD_ADDR_EXP 101
56880: PUSH
56881: LD_EXP 101
56885: PPUSH
56886: LD_VAR 0 4
56890: PPUSH
56891: EMPTY
56892: PPUSH
56893: CALL_OW 1
56897: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56898: LD_ADDR_EXP 102
56902: PUSH
56903: LD_EXP 102
56907: PPUSH
56908: LD_VAR 0 4
56912: PPUSH
56913: EMPTY
56914: PPUSH
56915: CALL_OW 1
56919: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56920: LD_ADDR_EXP 103
56924: PUSH
56925: LD_EXP 103
56929: PPUSH
56930: LD_VAR 0 4
56934: PPUSH
56935: EMPTY
56936: PPUSH
56937: CALL_OW 1
56941: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56942: LD_ADDR_EXP 104
56946: PUSH
56947: LD_EXP 104
56951: PPUSH
56952: LD_VAR 0 4
56956: PPUSH
56957: EMPTY
56958: PPUSH
56959: CALL_OW 1
56963: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56964: LD_ADDR_EXP 105
56968: PUSH
56969: LD_EXP 105
56973: PPUSH
56974: LD_VAR 0 4
56978: PPUSH
56979: EMPTY
56980: PPUSH
56981: CALL_OW 1
56985: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56986: LD_ADDR_EXP 106
56990: PUSH
56991: LD_EXP 106
56995: PPUSH
56996: LD_VAR 0 4
57000: PPUSH
57001: EMPTY
57002: PPUSH
57003: CALL_OW 1
57007: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57008: LD_ADDR_EXP 107
57012: PUSH
57013: LD_EXP 107
57017: PPUSH
57018: LD_VAR 0 4
57022: PPUSH
57023: EMPTY
57024: PPUSH
57025: CALL_OW 1
57029: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57030: LD_ADDR_EXP 108
57034: PUSH
57035: LD_EXP 108
57039: PPUSH
57040: LD_VAR 0 4
57044: PPUSH
57045: EMPTY
57046: PPUSH
57047: CALL_OW 1
57051: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57052: LD_ADDR_EXP 109
57056: PUSH
57057: LD_EXP 109
57061: PPUSH
57062: LD_VAR 0 4
57066: PPUSH
57067: EMPTY
57068: PPUSH
57069: CALL_OW 1
57073: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57074: LD_ADDR_EXP 110
57078: PUSH
57079: LD_EXP 110
57083: PPUSH
57084: LD_VAR 0 4
57088: PPUSH
57089: LD_INT 0
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57097: LD_ADDR_EXP 111
57101: PUSH
57102: LD_EXP 111
57106: PPUSH
57107: LD_VAR 0 4
57111: PPUSH
57112: LD_INT 0
57114: PPUSH
57115: CALL_OW 1
57119: ST_TO_ADDR
// result := base ;
57120: LD_ADDR_VAR 0 3
57124: PUSH
57125: LD_VAR 0 4
57129: ST_TO_ADDR
// end ;
57130: LD_VAR 0 3
57134: RET
// export function MC_Start ( ) ; var i ; begin
57135: LD_INT 0
57137: PPUSH
57138: PPUSH
// for i = 1 to mc_bases do
57139: LD_ADDR_VAR 0 2
57143: PUSH
57144: DOUBLE
57145: LD_INT 1
57147: DEC
57148: ST_TO_ADDR
57149: LD_EXP 68
57153: PUSH
57154: FOR_TO
57155: IFFALSE 58255
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57157: LD_ADDR_EXP 68
57161: PUSH
57162: LD_EXP 68
57166: PPUSH
57167: LD_VAR 0 2
57171: PPUSH
57172: LD_EXP 68
57176: PUSH
57177: LD_VAR 0 2
57181: ARRAY
57182: PUSH
57183: LD_INT 0
57185: DIFF
57186: PPUSH
57187: CALL_OW 1
57191: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57192: LD_ADDR_EXP 69
57196: PUSH
57197: LD_EXP 69
57201: PPUSH
57202: LD_VAR 0 2
57206: PPUSH
57207: EMPTY
57208: PPUSH
57209: CALL_OW 1
57213: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57214: LD_ADDR_EXP 70
57218: PUSH
57219: LD_EXP 70
57223: PPUSH
57224: LD_VAR 0 2
57228: PPUSH
57229: EMPTY
57230: PPUSH
57231: CALL_OW 1
57235: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57236: LD_ADDR_EXP 71
57240: PUSH
57241: LD_EXP 71
57245: PPUSH
57246: LD_VAR 0 2
57250: PPUSH
57251: EMPTY
57252: PPUSH
57253: CALL_OW 1
57257: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57258: LD_ADDR_EXP 72
57262: PUSH
57263: LD_EXP 72
57267: PPUSH
57268: LD_VAR 0 2
57272: PPUSH
57273: EMPTY
57274: PUSH
57275: EMPTY
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: PPUSH
57281: CALL_OW 1
57285: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57286: LD_ADDR_EXP 73
57290: PUSH
57291: LD_EXP 73
57295: PPUSH
57296: LD_VAR 0 2
57300: PPUSH
57301: EMPTY
57302: PPUSH
57303: CALL_OW 1
57307: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57308: LD_ADDR_EXP 100
57312: PUSH
57313: LD_EXP 100
57317: PPUSH
57318: LD_VAR 0 2
57322: PPUSH
57323: EMPTY
57324: PPUSH
57325: CALL_OW 1
57329: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57330: LD_ADDR_EXP 74
57334: PUSH
57335: LD_EXP 74
57339: PPUSH
57340: LD_VAR 0 2
57344: PPUSH
57345: EMPTY
57346: PPUSH
57347: CALL_OW 1
57351: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57352: LD_ADDR_EXP 75
57356: PUSH
57357: LD_EXP 75
57361: PPUSH
57362: LD_VAR 0 2
57366: PPUSH
57367: EMPTY
57368: PPUSH
57369: CALL_OW 1
57373: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57374: LD_ADDR_EXP 76
57378: PUSH
57379: LD_EXP 76
57383: PPUSH
57384: LD_VAR 0 2
57388: PPUSH
57389: LD_EXP 68
57393: PUSH
57394: LD_VAR 0 2
57398: ARRAY
57399: PPUSH
57400: LD_INT 2
57402: PUSH
57403: LD_INT 30
57405: PUSH
57406: LD_INT 32
57408: PUSH
57409: EMPTY
57410: LIST
57411: LIST
57412: PUSH
57413: LD_INT 30
57415: PUSH
57416: LD_INT 33
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: LIST
57427: PPUSH
57428: CALL_OW 72
57432: PPUSH
57433: CALL_OW 1
57437: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57438: LD_ADDR_EXP 77
57442: PUSH
57443: LD_EXP 77
57447: PPUSH
57448: LD_VAR 0 2
57452: PPUSH
57453: LD_EXP 68
57457: PUSH
57458: LD_VAR 0 2
57462: ARRAY
57463: PPUSH
57464: LD_INT 2
57466: PUSH
57467: LD_INT 30
57469: PUSH
57470: LD_INT 32
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: PUSH
57477: LD_INT 30
57479: PUSH
57480: LD_INT 31
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: PUSH
57487: EMPTY
57488: LIST
57489: LIST
57490: LIST
57491: PUSH
57492: LD_INT 58
57494: PUSH
57495: EMPTY
57496: LIST
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: PPUSH
57502: CALL_OW 72
57506: PPUSH
57507: CALL_OW 1
57511: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57512: LD_ADDR_EXP 78
57516: PUSH
57517: LD_EXP 78
57521: PPUSH
57522: LD_VAR 0 2
57526: PPUSH
57527: EMPTY
57528: PPUSH
57529: CALL_OW 1
57533: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57534: LD_ADDR_EXP 82
57538: PUSH
57539: LD_EXP 82
57543: PPUSH
57544: LD_VAR 0 2
57548: PPUSH
57549: EMPTY
57550: PPUSH
57551: CALL_OW 1
57555: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57556: LD_ADDR_EXP 81
57560: PUSH
57561: LD_EXP 81
57565: PPUSH
57566: LD_VAR 0 2
57570: PPUSH
57571: EMPTY
57572: PPUSH
57573: CALL_OW 1
57577: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57578: LD_ADDR_EXP 83
57582: PUSH
57583: LD_EXP 83
57587: PPUSH
57588: LD_VAR 0 2
57592: PPUSH
57593: EMPTY
57594: PPUSH
57595: CALL_OW 1
57599: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57600: LD_ADDR_EXP 84
57604: PUSH
57605: LD_EXP 84
57609: PPUSH
57610: LD_VAR 0 2
57614: PPUSH
57615: EMPTY
57616: PPUSH
57617: CALL_OW 1
57621: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57622: LD_ADDR_EXP 85
57626: PUSH
57627: LD_EXP 85
57631: PPUSH
57632: LD_VAR 0 2
57636: PPUSH
57637: EMPTY
57638: PPUSH
57639: CALL_OW 1
57643: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57644: LD_ADDR_EXP 86
57648: PUSH
57649: LD_EXP 86
57653: PPUSH
57654: LD_VAR 0 2
57658: PPUSH
57659: EMPTY
57660: PPUSH
57661: CALL_OW 1
57665: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57666: LD_ADDR_EXP 87
57670: PUSH
57671: LD_EXP 87
57675: PPUSH
57676: LD_VAR 0 2
57680: PPUSH
57681: EMPTY
57682: PPUSH
57683: CALL_OW 1
57687: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57688: LD_ADDR_EXP 88
57692: PUSH
57693: LD_EXP 88
57697: PPUSH
57698: LD_VAR 0 2
57702: PPUSH
57703: EMPTY
57704: PPUSH
57705: CALL_OW 1
57709: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57710: LD_ADDR_EXP 89
57714: PUSH
57715: LD_EXP 89
57719: PPUSH
57720: LD_VAR 0 2
57724: PPUSH
57725: EMPTY
57726: PPUSH
57727: CALL_OW 1
57731: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57732: LD_ADDR_EXP 90
57736: PUSH
57737: LD_EXP 90
57741: PPUSH
57742: LD_VAR 0 2
57746: PPUSH
57747: EMPTY
57748: PPUSH
57749: CALL_OW 1
57753: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57754: LD_ADDR_EXP 79
57758: PUSH
57759: LD_EXP 79
57763: PPUSH
57764: LD_VAR 0 2
57768: PPUSH
57769: LD_INT 0
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57777: LD_ADDR_EXP 92
57781: PUSH
57782: LD_EXP 92
57786: PPUSH
57787: LD_VAR 0 2
57791: PPUSH
57792: LD_INT 0
57794: PPUSH
57795: CALL_OW 1
57799: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57800: LD_ADDR_EXP 80
57804: PUSH
57805: LD_EXP 80
57809: PPUSH
57810: LD_VAR 0 2
57814: PPUSH
57815: EMPTY
57816: PPUSH
57817: CALL_OW 1
57821: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57822: LD_ADDR_EXP 91
57826: PUSH
57827: LD_EXP 91
57831: PPUSH
57832: LD_VAR 0 2
57836: PPUSH
57837: LD_INT 0
57839: PPUSH
57840: CALL_OW 1
57844: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57845: LD_ADDR_EXP 93
57849: PUSH
57850: LD_EXP 93
57854: PPUSH
57855: LD_VAR 0 2
57859: PPUSH
57860: EMPTY
57861: PPUSH
57862: CALL_OW 1
57866: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57867: LD_ADDR_EXP 96
57871: PUSH
57872: LD_EXP 96
57876: PPUSH
57877: LD_VAR 0 2
57881: PPUSH
57882: LD_INT 0
57884: PPUSH
57885: CALL_OW 1
57889: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57890: LD_ADDR_EXP 97
57894: PUSH
57895: LD_EXP 97
57899: PPUSH
57900: LD_VAR 0 2
57904: PPUSH
57905: EMPTY
57906: PPUSH
57907: CALL_OW 1
57911: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57912: LD_ADDR_EXP 98
57916: PUSH
57917: LD_EXP 98
57921: PPUSH
57922: LD_VAR 0 2
57926: PPUSH
57927: EMPTY
57928: PPUSH
57929: CALL_OW 1
57933: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57934: LD_ADDR_EXP 99
57938: PUSH
57939: LD_EXP 99
57943: PPUSH
57944: LD_VAR 0 2
57948: PPUSH
57949: EMPTY
57950: PPUSH
57951: CALL_OW 1
57955: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57956: LD_ADDR_EXP 101
57960: PUSH
57961: LD_EXP 101
57965: PPUSH
57966: LD_VAR 0 2
57970: PPUSH
57971: LD_EXP 68
57975: PUSH
57976: LD_VAR 0 2
57980: ARRAY
57981: PPUSH
57982: LD_INT 2
57984: PUSH
57985: LD_INT 30
57987: PUSH
57988: LD_INT 6
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: PUSH
57995: LD_INT 30
57997: PUSH
57998: LD_INT 7
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: LD_INT 30
58007: PUSH
58008: LD_INT 8
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: LIST
58019: LIST
58020: PPUSH
58021: CALL_OW 72
58025: PPUSH
58026: CALL_OW 1
58030: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58031: LD_ADDR_EXP 102
58035: PUSH
58036: LD_EXP 102
58040: PPUSH
58041: LD_VAR 0 2
58045: PPUSH
58046: EMPTY
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58053: LD_ADDR_EXP 103
58057: PUSH
58058: LD_EXP 103
58062: PPUSH
58063: LD_VAR 0 2
58067: PPUSH
58068: EMPTY
58069: PPUSH
58070: CALL_OW 1
58074: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58075: LD_ADDR_EXP 104
58079: PUSH
58080: LD_EXP 104
58084: PPUSH
58085: LD_VAR 0 2
58089: PPUSH
58090: EMPTY
58091: PPUSH
58092: CALL_OW 1
58096: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58097: LD_ADDR_EXP 105
58101: PUSH
58102: LD_EXP 105
58106: PPUSH
58107: LD_VAR 0 2
58111: PPUSH
58112: EMPTY
58113: PPUSH
58114: CALL_OW 1
58118: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58119: LD_ADDR_EXP 106
58123: PUSH
58124: LD_EXP 106
58128: PPUSH
58129: LD_VAR 0 2
58133: PPUSH
58134: EMPTY
58135: PPUSH
58136: CALL_OW 1
58140: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58141: LD_ADDR_EXP 107
58145: PUSH
58146: LD_EXP 107
58150: PPUSH
58151: LD_VAR 0 2
58155: PPUSH
58156: EMPTY
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58163: LD_ADDR_EXP 108
58167: PUSH
58168: LD_EXP 108
58172: PPUSH
58173: LD_VAR 0 2
58177: PPUSH
58178: EMPTY
58179: PPUSH
58180: CALL_OW 1
58184: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58185: LD_ADDR_EXP 109
58189: PUSH
58190: LD_EXP 109
58194: PPUSH
58195: LD_VAR 0 2
58199: PPUSH
58200: EMPTY
58201: PPUSH
58202: CALL_OW 1
58206: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58207: LD_ADDR_EXP 110
58211: PUSH
58212: LD_EXP 110
58216: PPUSH
58217: LD_VAR 0 2
58221: PPUSH
58222: LD_INT 0
58224: PPUSH
58225: CALL_OW 1
58229: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58230: LD_ADDR_EXP 111
58234: PUSH
58235: LD_EXP 111
58239: PPUSH
58240: LD_VAR 0 2
58244: PPUSH
58245: LD_INT 0
58247: PPUSH
58248: CALL_OW 1
58252: ST_TO_ADDR
// end ;
58253: GO 57154
58255: POP
58256: POP
// MC_InitSides ( ) ;
58257: CALL 58543 0 0
// MC_InitResearch ( ) ;
58261: CALL 58282 0 0
// CustomInitMacro ( ) ;
58265: CALL 5753 0 0
// skirmish := true ;
58269: LD_ADDR_EXP 66
58273: PUSH
58274: LD_INT 1
58276: ST_TO_ADDR
// end ;
58277: LD_VAR 0 1
58281: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58282: LD_INT 0
58284: PPUSH
58285: PPUSH
58286: PPUSH
58287: PPUSH
58288: PPUSH
58289: PPUSH
// if not mc_bases then
58290: LD_EXP 68
58294: NOT
58295: IFFALSE 58299
// exit ;
58297: GO 58538
// for i = 1 to 8 do
58299: LD_ADDR_VAR 0 2
58303: PUSH
58304: DOUBLE
58305: LD_INT 1
58307: DEC
58308: ST_TO_ADDR
58309: LD_INT 8
58311: PUSH
58312: FOR_TO
58313: IFFALSE 58339
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58315: LD_ADDR_EXP 95
58319: PUSH
58320: LD_EXP 95
58324: PPUSH
58325: LD_VAR 0 2
58329: PPUSH
58330: EMPTY
58331: PPUSH
58332: CALL_OW 1
58336: ST_TO_ADDR
58337: GO 58312
58339: POP
58340: POP
// tmp := [ ] ;
58341: LD_ADDR_VAR 0 5
58345: PUSH
58346: EMPTY
58347: ST_TO_ADDR
// for i = 1 to mc_sides do
58348: LD_ADDR_VAR 0 2
58352: PUSH
58353: DOUBLE
58354: LD_INT 1
58356: DEC
58357: ST_TO_ADDR
58358: LD_EXP 94
58362: PUSH
58363: FOR_TO
58364: IFFALSE 58422
// if not mc_sides [ i ] in tmp then
58366: LD_EXP 94
58370: PUSH
58371: LD_VAR 0 2
58375: ARRAY
58376: PUSH
58377: LD_VAR 0 5
58381: IN
58382: NOT
58383: IFFALSE 58420
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58385: LD_ADDR_VAR 0 5
58389: PUSH
58390: LD_VAR 0 5
58394: PPUSH
58395: LD_VAR 0 5
58399: PUSH
58400: LD_INT 1
58402: PLUS
58403: PPUSH
58404: LD_EXP 94
58408: PUSH
58409: LD_VAR 0 2
58413: ARRAY
58414: PPUSH
58415: CALL_OW 2
58419: ST_TO_ADDR
58420: GO 58363
58422: POP
58423: POP
// if not tmp then
58424: LD_VAR 0 5
58428: NOT
58429: IFFALSE 58433
// exit ;
58431: GO 58538
// for j in tmp do
58433: LD_ADDR_VAR 0 3
58437: PUSH
58438: LD_VAR 0 5
58442: PUSH
58443: FOR_IN
58444: IFFALSE 58536
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58446: LD_ADDR_VAR 0 6
58450: PUSH
58451: LD_INT 22
58453: PUSH
58454: LD_VAR 0 3
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: PPUSH
58463: CALL_OW 69
58467: ST_TO_ADDR
// if not un then
58468: LD_VAR 0 6
58472: NOT
58473: IFFALSE 58477
// continue ;
58475: GO 58443
// nation := GetNation ( un [ 1 ] ) ;
58477: LD_ADDR_VAR 0 4
58481: PUSH
58482: LD_VAR 0 6
58486: PUSH
58487: LD_INT 1
58489: ARRAY
58490: PPUSH
58491: CALL_OW 248
58495: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58496: LD_ADDR_EXP 95
58500: PUSH
58501: LD_EXP 95
58505: PPUSH
58506: LD_VAR 0 3
58510: PPUSH
58511: LD_VAR 0 3
58515: PPUSH
58516: LD_VAR 0 4
58520: PPUSH
58521: LD_INT 1
58523: PPUSH
58524: CALL 13674 0 3
58528: PPUSH
58529: CALL_OW 1
58533: ST_TO_ADDR
// end ;
58534: GO 58443
58536: POP
58537: POP
// end ;
58538: LD_VAR 0 1
58542: RET
// export function MC_InitSides ( ) ; var i ; begin
58543: LD_INT 0
58545: PPUSH
58546: PPUSH
// if not mc_bases then
58547: LD_EXP 68
58551: NOT
58552: IFFALSE 58556
// exit ;
58554: GO 58630
// for i = 1 to mc_bases do
58556: LD_ADDR_VAR 0 2
58560: PUSH
58561: DOUBLE
58562: LD_INT 1
58564: DEC
58565: ST_TO_ADDR
58566: LD_EXP 68
58570: PUSH
58571: FOR_TO
58572: IFFALSE 58628
// if mc_bases [ i ] then
58574: LD_EXP 68
58578: PUSH
58579: LD_VAR 0 2
58583: ARRAY
58584: IFFALSE 58626
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58586: LD_ADDR_EXP 94
58590: PUSH
58591: LD_EXP 94
58595: PPUSH
58596: LD_VAR 0 2
58600: PPUSH
58601: LD_EXP 68
58605: PUSH
58606: LD_VAR 0 2
58610: ARRAY
58611: PUSH
58612: LD_INT 1
58614: ARRAY
58615: PPUSH
58616: CALL_OW 255
58620: PPUSH
58621: CALL_OW 1
58625: ST_TO_ADDR
58626: GO 58571
58628: POP
58629: POP
// end ;
58630: LD_VAR 0 1
58634: RET
// every 0 0$03 trigger skirmish do
58635: LD_EXP 66
58639: IFFALSE 58793
58641: GO 58643
58643: DISABLE
// begin enable ;
58644: ENABLE
// MC_CheckBuildings ( ) ;
58645: CALL 63291 0 0
// MC_CheckPeopleLife ( ) ;
58649: CALL 63452 0 0
// RaiseSailEvent ( 100 ) ;
58653: LD_INT 100
58655: PPUSH
58656: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58660: LD_INT 103
58662: PPUSH
58663: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58667: LD_INT 104
58669: PPUSH
58670: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58674: LD_INT 105
58676: PPUSH
58677: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58681: LD_INT 106
58683: PPUSH
58684: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58688: LD_INT 107
58690: PPUSH
58691: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58695: LD_INT 108
58697: PPUSH
58698: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58702: LD_INT 109
58704: PPUSH
58705: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58709: LD_INT 110
58711: PPUSH
58712: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58716: LD_INT 111
58718: PPUSH
58719: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58723: LD_INT 112
58725: PPUSH
58726: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58730: LD_INT 113
58732: PPUSH
58733: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58737: LD_INT 120
58739: PPUSH
58740: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58744: LD_INT 121
58746: PPUSH
58747: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58751: LD_INT 122
58753: PPUSH
58754: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58758: LD_INT 123
58760: PPUSH
58761: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58765: LD_INT 124
58767: PPUSH
58768: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58772: LD_INT 125
58774: PPUSH
58775: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58779: LD_INT 126
58781: PPUSH
58782: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58786: LD_INT 200
58788: PPUSH
58789: CALL_OW 427
// end ;
58793: END
// on SailEvent ( event ) do begin if event < 100 then
58794: LD_VAR 0 1
58798: PUSH
58799: LD_INT 100
58801: LESS
58802: IFFALSE 58813
// CustomEvent ( event ) ;
58804: LD_VAR 0 1
58808: PPUSH
58809: CALL 5745 0 1
// if event = 100 then
58813: LD_VAR 0 1
58817: PUSH
58818: LD_INT 100
58820: EQUAL
58821: IFFALSE 58827
// MC_ClassManager ( ) ;
58823: CALL 59219 0 0
// if event = 101 then
58827: LD_VAR 0 1
58831: PUSH
58832: LD_INT 101
58834: EQUAL
58835: IFFALSE 58841
// MC_RepairBuildings ( ) ;
58837: CALL 64037 0 0
// if event = 102 then
58841: LD_VAR 0 1
58845: PUSH
58846: LD_INT 102
58848: EQUAL
58849: IFFALSE 58855
// MC_Heal ( ) ;
58851: CALL 64944 0 0
// if event = 103 then
58855: LD_VAR 0 1
58859: PUSH
58860: LD_INT 103
58862: EQUAL
58863: IFFALSE 58869
// MC_Build ( ) ;
58865: CALL 65366 0 0
// if event = 104 then
58869: LD_VAR 0 1
58873: PUSH
58874: LD_INT 104
58876: EQUAL
58877: IFFALSE 58883
// MC_TurretWeapon ( ) ;
58879: CALL 67007 0 0
// if event = 105 then
58883: LD_VAR 0 1
58887: PUSH
58888: LD_INT 105
58890: EQUAL
58891: IFFALSE 58897
// MC_BuildUpgrade ( ) ;
58893: CALL 66558 0 0
// if event = 106 then
58897: LD_VAR 0 1
58901: PUSH
58902: LD_INT 106
58904: EQUAL
58905: IFFALSE 58911
// MC_PlantMines ( ) ;
58907: CALL 67437 0 0
// if event = 107 then
58911: LD_VAR 0 1
58915: PUSH
58916: LD_INT 107
58918: EQUAL
58919: IFFALSE 58925
// MC_CollectCrates ( ) ;
58921: CALL 68228 0 0
// if event = 108 then
58925: LD_VAR 0 1
58929: PUSH
58930: LD_INT 108
58932: EQUAL
58933: IFFALSE 58939
// MC_LinkRemoteControl ( ) ;
58935: CALL 70078 0 0
// if event = 109 then
58939: LD_VAR 0 1
58943: PUSH
58944: LD_INT 109
58946: EQUAL
58947: IFFALSE 58953
// MC_ProduceVehicle ( ) ;
58949: CALL 70259 0 0
// if event = 110 then
58953: LD_VAR 0 1
58957: PUSH
58958: LD_INT 110
58960: EQUAL
58961: IFFALSE 58967
// MC_SendAttack ( ) ;
58963: CALL 70725 0 0
// if event = 111 then
58967: LD_VAR 0 1
58971: PUSH
58972: LD_INT 111
58974: EQUAL
58975: IFFALSE 58981
// MC_Defend ( ) ;
58977: CALL 70833 0 0
// if event = 112 then
58981: LD_VAR 0 1
58985: PUSH
58986: LD_INT 112
58988: EQUAL
58989: IFFALSE 58995
// MC_Research ( ) ;
58991: CALL 71713 0 0
// if event = 113 then
58995: LD_VAR 0 1
58999: PUSH
59000: LD_INT 113
59002: EQUAL
59003: IFFALSE 59009
// MC_MinesTrigger ( ) ;
59005: CALL 72827 0 0
// if event = 120 then
59009: LD_VAR 0 1
59013: PUSH
59014: LD_INT 120
59016: EQUAL
59017: IFFALSE 59023
// MC_RepairVehicle ( ) ;
59019: CALL 72926 0 0
// if event = 121 then
59023: LD_VAR 0 1
59027: PUSH
59028: LD_INT 121
59030: EQUAL
59031: IFFALSE 59037
// MC_TameApe ( ) ;
59033: CALL 73667 0 0
// if event = 122 then
59037: LD_VAR 0 1
59041: PUSH
59042: LD_INT 122
59044: EQUAL
59045: IFFALSE 59051
// MC_ChangeApeClass ( ) ;
59047: CALL 74496 0 0
// if event = 123 then
59051: LD_VAR 0 1
59055: PUSH
59056: LD_INT 123
59058: EQUAL
59059: IFFALSE 59065
// MC_Bazooka ( ) ;
59061: CALL 75146 0 0
// if event = 124 then
59065: LD_VAR 0 1
59069: PUSH
59070: LD_INT 124
59072: EQUAL
59073: IFFALSE 59079
// MC_TeleportExit ( ) ;
59075: CALL 75344 0 0
// if event = 125 then
59079: LD_VAR 0 1
59083: PUSH
59084: LD_INT 125
59086: EQUAL
59087: IFFALSE 59093
// MC_Deposits ( ) ;
59089: CALL 75991 0 0
// if event = 126 then
59093: LD_VAR 0 1
59097: PUSH
59098: LD_INT 126
59100: EQUAL
59101: IFFALSE 59107
// MC_RemoteDriver ( ) ;
59103: CALL 76616 0 0
// if event = 200 then
59107: LD_VAR 0 1
59111: PUSH
59112: LD_INT 200
59114: EQUAL
59115: IFFALSE 59121
// MC_Idle ( ) ;
59117: CALL 78565 0 0
// end ;
59121: PPOPN 1
59123: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59124: LD_INT 0
59126: PPUSH
59127: PPUSH
// if not mc_bases [ base ] or not tag then
59128: LD_EXP 68
59132: PUSH
59133: LD_VAR 0 1
59137: ARRAY
59138: NOT
59139: PUSH
59140: LD_VAR 0 2
59144: NOT
59145: OR
59146: IFFALSE 59150
// exit ;
59148: GO 59214
// for i in mc_bases [ base ] union mc_ape [ base ] do
59150: LD_ADDR_VAR 0 4
59154: PUSH
59155: LD_EXP 68
59159: PUSH
59160: LD_VAR 0 1
59164: ARRAY
59165: PUSH
59166: LD_EXP 97
59170: PUSH
59171: LD_VAR 0 1
59175: ARRAY
59176: UNION
59177: PUSH
59178: FOR_IN
59179: IFFALSE 59212
// if GetTag ( i ) = tag then
59181: LD_VAR 0 4
59185: PPUSH
59186: CALL_OW 110
59190: PUSH
59191: LD_VAR 0 2
59195: EQUAL
59196: IFFALSE 59210
// SetTag ( i , 0 ) ;
59198: LD_VAR 0 4
59202: PPUSH
59203: LD_INT 0
59205: PPUSH
59206: CALL_OW 109
59210: GO 59178
59212: POP
59213: POP
// end ;
59214: LD_VAR 0 3
59218: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59219: LD_INT 0
59221: PPUSH
59222: PPUSH
59223: PPUSH
59224: PPUSH
59225: PPUSH
59226: PPUSH
59227: PPUSH
59228: PPUSH
// if not mc_bases then
59229: LD_EXP 68
59233: NOT
59234: IFFALSE 59238
// exit ;
59236: GO 59696
// for i = 1 to mc_bases do
59238: LD_ADDR_VAR 0 2
59242: PUSH
59243: DOUBLE
59244: LD_INT 1
59246: DEC
59247: ST_TO_ADDR
59248: LD_EXP 68
59252: PUSH
59253: FOR_TO
59254: IFFALSE 59694
// begin tmp := MC_ClassCheckReq ( i ) ;
59256: LD_ADDR_VAR 0 4
59260: PUSH
59261: LD_VAR 0 2
59265: PPUSH
59266: CALL 59701 0 1
59270: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59271: LD_ADDR_EXP 109
59275: PUSH
59276: LD_EXP 109
59280: PPUSH
59281: LD_VAR 0 2
59285: PPUSH
59286: LD_VAR 0 4
59290: PPUSH
59291: CALL_OW 1
59295: ST_TO_ADDR
// if not tmp then
59296: LD_VAR 0 4
59300: NOT
59301: IFFALSE 59305
// continue ;
59303: GO 59253
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59305: LD_ADDR_VAR 0 6
59309: PUSH
59310: LD_EXP 68
59314: PUSH
59315: LD_VAR 0 2
59319: ARRAY
59320: PPUSH
59321: LD_INT 2
59323: PUSH
59324: LD_INT 30
59326: PUSH
59327: LD_INT 4
59329: PUSH
59330: EMPTY
59331: LIST
59332: LIST
59333: PUSH
59334: LD_INT 30
59336: PUSH
59337: LD_INT 5
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PUSH
59344: EMPTY
59345: LIST
59346: LIST
59347: LIST
59348: PPUSH
59349: CALL_OW 72
59353: PUSH
59354: LD_EXP 68
59358: PUSH
59359: LD_VAR 0 2
59363: ARRAY
59364: PPUSH
59365: LD_INT 2
59367: PUSH
59368: LD_INT 30
59370: PUSH
59371: LD_INT 0
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: PUSH
59378: LD_INT 30
59380: PUSH
59381: LD_INT 1
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: EMPTY
59389: LIST
59390: LIST
59391: LIST
59392: PPUSH
59393: CALL_OW 72
59397: PUSH
59398: LD_EXP 68
59402: PUSH
59403: LD_VAR 0 2
59407: ARRAY
59408: PPUSH
59409: LD_INT 30
59411: PUSH
59412: LD_INT 3
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PPUSH
59419: CALL_OW 72
59423: PUSH
59424: LD_EXP 68
59428: PUSH
59429: LD_VAR 0 2
59433: ARRAY
59434: PPUSH
59435: LD_INT 2
59437: PUSH
59438: LD_INT 30
59440: PUSH
59441: LD_INT 6
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: LD_INT 7
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PUSH
59458: LD_INT 30
59460: PUSH
59461: LD_INT 8
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: LIST
59472: LIST
59473: PPUSH
59474: CALL_OW 72
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: LIST
59483: LIST
59484: ST_TO_ADDR
// for j = 1 to 4 do
59485: LD_ADDR_VAR 0 3
59489: PUSH
59490: DOUBLE
59491: LD_INT 1
59493: DEC
59494: ST_TO_ADDR
59495: LD_INT 4
59497: PUSH
59498: FOR_TO
59499: IFFALSE 59690
// begin if not tmp [ j ] then
59501: LD_VAR 0 4
59505: PUSH
59506: LD_VAR 0 3
59510: ARRAY
59511: NOT
59512: IFFALSE 59516
// continue ;
59514: GO 59498
// for p in tmp [ j ] do
59516: LD_ADDR_VAR 0 5
59520: PUSH
59521: LD_VAR 0 4
59525: PUSH
59526: LD_VAR 0 3
59530: ARRAY
59531: PUSH
59532: FOR_IN
59533: IFFALSE 59686
// begin if not b [ j ] then
59535: LD_VAR 0 6
59539: PUSH
59540: LD_VAR 0 3
59544: ARRAY
59545: NOT
59546: IFFALSE 59550
// break ;
59548: GO 59686
// e := 0 ;
59550: LD_ADDR_VAR 0 7
59554: PUSH
59555: LD_INT 0
59557: ST_TO_ADDR
// for k in b [ j ] do
59558: LD_ADDR_VAR 0 8
59562: PUSH
59563: LD_VAR 0 6
59567: PUSH
59568: LD_VAR 0 3
59572: ARRAY
59573: PUSH
59574: FOR_IN
59575: IFFALSE 59602
// if IsNotFull ( k ) then
59577: LD_VAR 0 8
59581: PPUSH
59582: CALL 15827 0 1
59586: IFFALSE 59600
// begin e := k ;
59588: LD_ADDR_VAR 0 7
59592: PUSH
59593: LD_VAR 0 8
59597: ST_TO_ADDR
// break ;
59598: GO 59602
// end ;
59600: GO 59574
59602: POP
59603: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59604: LD_VAR 0 7
59608: PUSH
59609: LD_VAR 0 5
59613: PPUSH
59614: LD_VAR 0 7
59618: PPUSH
59619: CALL 49641 0 2
59623: NOT
59624: AND
59625: IFFALSE 59684
// begin if IsInUnit ( p ) then
59627: LD_VAR 0 5
59631: PPUSH
59632: CALL_OW 310
59636: IFFALSE 59647
// ComExitBuilding ( p ) ;
59638: LD_VAR 0 5
59642: PPUSH
59643: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59647: LD_VAR 0 5
59651: PPUSH
59652: LD_VAR 0 7
59656: PPUSH
59657: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59661: LD_VAR 0 5
59665: PPUSH
59666: LD_VAR 0 3
59670: PPUSH
59671: CALL_OW 183
// AddComExitBuilding ( p ) ;
59675: LD_VAR 0 5
59679: PPUSH
59680: CALL_OW 182
// end ; end ;
59684: GO 59532
59686: POP
59687: POP
// end ;
59688: GO 59498
59690: POP
59691: POP
// end ;
59692: GO 59253
59694: POP
59695: POP
// end ;
59696: LD_VAR 0 1
59700: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59701: LD_INT 0
59703: PPUSH
59704: PPUSH
59705: PPUSH
59706: PPUSH
59707: PPUSH
59708: PPUSH
59709: PPUSH
59710: PPUSH
59711: PPUSH
59712: PPUSH
59713: PPUSH
59714: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59715: LD_VAR 0 1
59719: NOT
59720: PUSH
59721: LD_EXP 68
59725: PUSH
59726: LD_VAR 0 1
59730: ARRAY
59731: NOT
59732: OR
59733: PUSH
59734: LD_EXP 68
59738: PUSH
59739: LD_VAR 0 1
59743: ARRAY
59744: PPUSH
59745: LD_INT 2
59747: PUSH
59748: LD_INT 30
59750: PUSH
59751: LD_INT 0
59753: PUSH
59754: EMPTY
59755: LIST
59756: LIST
59757: PUSH
59758: LD_INT 30
59760: PUSH
59761: LD_INT 1
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: LIST
59772: PPUSH
59773: CALL_OW 72
59777: NOT
59778: OR
59779: IFFALSE 59783
// exit ;
59781: GO 63286
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59783: LD_ADDR_VAR 0 4
59787: PUSH
59788: LD_EXP 68
59792: PUSH
59793: LD_VAR 0 1
59797: ARRAY
59798: PPUSH
59799: LD_INT 2
59801: PUSH
59802: LD_INT 25
59804: PUSH
59805: LD_INT 1
59807: PUSH
59808: EMPTY
59809: LIST
59810: LIST
59811: PUSH
59812: LD_INT 25
59814: PUSH
59815: LD_INT 2
59817: PUSH
59818: EMPTY
59819: LIST
59820: LIST
59821: PUSH
59822: LD_INT 25
59824: PUSH
59825: LD_INT 3
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: PUSH
59832: LD_INT 25
59834: PUSH
59835: LD_INT 4
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: PUSH
59842: LD_INT 25
59844: PUSH
59845: LD_INT 5
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: PUSH
59852: LD_INT 25
59854: PUSH
59855: LD_INT 8
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: PUSH
59862: LD_INT 25
59864: PUSH
59865: LD_INT 9
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: LIST
59876: LIST
59877: LIST
59878: LIST
59879: LIST
59880: LIST
59881: PPUSH
59882: CALL_OW 72
59886: ST_TO_ADDR
// if not tmp then
59887: LD_VAR 0 4
59891: NOT
59892: IFFALSE 59896
// exit ;
59894: GO 63286
// for i in tmp do
59896: LD_ADDR_VAR 0 3
59900: PUSH
59901: LD_VAR 0 4
59905: PUSH
59906: FOR_IN
59907: IFFALSE 59938
// if GetTag ( i ) then
59909: LD_VAR 0 3
59913: PPUSH
59914: CALL_OW 110
59918: IFFALSE 59936
// tmp := tmp diff i ;
59920: LD_ADDR_VAR 0 4
59924: PUSH
59925: LD_VAR 0 4
59929: PUSH
59930: LD_VAR 0 3
59934: DIFF
59935: ST_TO_ADDR
59936: GO 59906
59938: POP
59939: POP
// if not tmp then
59940: LD_VAR 0 4
59944: NOT
59945: IFFALSE 59949
// exit ;
59947: GO 63286
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59949: LD_ADDR_VAR 0 5
59953: PUSH
59954: LD_EXP 68
59958: PUSH
59959: LD_VAR 0 1
59963: ARRAY
59964: PPUSH
59965: LD_INT 2
59967: PUSH
59968: LD_INT 25
59970: PUSH
59971: LD_INT 1
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: LD_INT 25
59980: PUSH
59981: LD_INT 5
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: PUSH
59988: LD_INT 25
59990: PUSH
59991: LD_INT 8
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: PUSH
59998: LD_INT 25
60000: PUSH
60001: LD_INT 9
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: PUSH
60008: EMPTY
60009: LIST
60010: LIST
60011: LIST
60012: LIST
60013: LIST
60014: PPUSH
60015: CALL_OW 72
60019: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60020: LD_ADDR_VAR 0 6
60024: PUSH
60025: LD_EXP 68
60029: PUSH
60030: LD_VAR 0 1
60034: ARRAY
60035: PPUSH
60036: LD_INT 25
60038: PUSH
60039: LD_INT 2
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PPUSH
60046: CALL_OW 72
60050: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60051: LD_ADDR_VAR 0 7
60055: PUSH
60056: LD_EXP 68
60060: PUSH
60061: LD_VAR 0 1
60065: ARRAY
60066: PPUSH
60067: LD_INT 25
60069: PUSH
60070: LD_INT 3
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: PPUSH
60077: CALL_OW 72
60081: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60082: LD_ADDR_VAR 0 8
60086: PUSH
60087: LD_EXP 68
60091: PUSH
60092: LD_VAR 0 1
60096: ARRAY
60097: PPUSH
60098: LD_INT 25
60100: PUSH
60101: LD_INT 4
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: PUSH
60108: LD_INT 24
60110: PUSH
60111: LD_INT 251
60113: PUSH
60114: EMPTY
60115: LIST
60116: LIST
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: PPUSH
60122: CALL_OW 72
60126: ST_TO_ADDR
// if mc_is_defending [ base ] then
60127: LD_EXP 111
60131: PUSH
60132: LD_VAR 0 1
60136: ARRAY
60137: IFFALSE 60598
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60139: LD_ADDR_EXP 110
60143: PUSH
60144: LD_EXP 110
60148: PPUSH
60149: LD_VAR 0 1
60153: PPUSH
60154: LD_INT 4
60156: PPUSH
60157: CALL_OW 1
60161: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60162: LD_ADDR_VAR 0 12
60166: PUSH
60167: LD_EXP 68
60171: PUSH
60172: LD_VAR 0 1
60176: ARRAY
60177: PPUSH
60178: LD_INT 2
60180: PUSH
60181: LD_INT 30
60183: PUSH
60184: LD_INT 4
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 30
60193: PUSH
60194: LD_INT 5
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: LIST
60205: PPUSH
60206: CALL_OW 72
60210: ST_TO_ADDR
// if not b then
60211: LD_VAR 0 12
60215: NOT
60216: IFFALSE 60220
// exit ;
60218: GO 63286
// p := [ ] ;
60220: LD_ADDR_VAR 0 11
60224: PUSH
60225: EMPTY
60226: ST_TO_ADDR
// if sci >= 2 then
60227: LD_VAR 0 8
60231: PUSH
60232: LD_INT 2
60234: GREATEREQUAL
60235: IFFALSE 60266
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60237: LD_ADDR_VAR 0 8
60241: PUSH
60242: LD_VAR 0 8
60246: PUSH
60247: LD_INT 1
60249: ARRAY
60250: PUSH
60251: LD_VAR 0 8
60255: PUSH
60256: LD_INT 2
60258: ARRAY
60259: PUSH
60260: EMPTY
60261: LIST
60262: LIST
60263: ST_TO_ADDR
60264: GO 60327
// if sci = 1 then
60266: LD_VAR 0 8
60270: PUSH
60271: LD_INT 1
60273: EQUAL
60274: IFFALSE 60295
// sci := [ sci [ 1 ] ] else
60276: LD_ADDR_VAR 0 8
60280: PUSH
60281: LD_VAR 0 8
60285: PUSH
60286: LD_INT 1
60288: ARRAY
60289: PUSH
60290: EMPTY
60291: LIST
60292: ST_TO_ADDR
60293: GO 60327
// if sci = 0 then
60295: LD_VAR 0 8
60299: PUSH
60300: LD_INT 0
60302: EQUAL
60303: IFFALSE 60327
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60305: LD_ADDR_VAR 0 11
60309: PUSH
60310: LD_VAR 0 4
60314: PPUSH
60315: LD_INT 4
60317: PPUSH
60318: CALL 49504 0 2
60322: PUSH
60323: LD_INT 1
60325: ARRAY
60326: ST_TO_ADDR
// if eng > 4 then
60327: LD_VAR 0 6
60331: PUSH
60332: LD_INT 4
60334: GREATER
60335: IFFALSE 60381
// for i = eng downto 4 do
60337: LD_ADDR_VAR 0 3
60341: PUSH
60342: DOUBLE
60343: LD_VAR 0 6
60347: INC
60348: ST_TO_ADDR
60349: LD_INT 4
60351: PUSH
60352: FOR_DOWNTO
60353: IFFALSE 60379
// eng := eng diff eng [ i ] ;
60355: LD_ADDR_VAR 0 6
60359: PUSH
60360: LD_VAR 0 6
60364: PUSH
60365: LD_VAR 0 6
60369: PUSH
60370: LD_VAR 0 3
60374: ARRAY
60375: DIFF
60376: ST_TO_ADDR
60377: GO 60352
60379: POP
60380: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60381: LD_ADDR_VAR 0 4
60385: PUSH
60386: LD_VAR 0 4
60390: PUSH
60391: LD_VAR 0 5
60395: PUSH
60396: LD_VAR 0 6
60400: UNION
60401: PUSH
60402: LD_VAR 0 7
60406: UNION
60407: PUSH
60408: LD_VAR 0 8
60412: UNION
60413: DIFF
60414: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60415: LD_ADDR_VAR 0 13
60419: PUSH
60420: LD_EXP 68
60424: PUSH
60425: LD_VAR 0 1
60429: ARRAY
60430: PPUSH
60431: LD_INT 2
60433: PUSH
60434: LD_INT 30
60436: PUSH
60437: LD_INT 32
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: LD_INT 30
60446: PUSH
60447: LD_INT 31
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: EMPTY
60455: LIST
60456: LIST
60457: LIST
60458: PPUSH
60459: CALL_OW 72
60463: PUSH
60464: LD_EXP 68
60468: PUSH
60469: LD_VAR 0 1
60473: ARRAY
60474: PPUSH
60475: LD_INT 2
60477: PUSH
60478: LD_INT 30
60480: PUSH
60481: LD_INT 4
60483: PUSH
60484: EMPTY
60485: LIST
60486: LIST
60487: PUSH
60488: LD_INT 30
60490: PUSH
60491: LD_INT 5
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: LIST
60502: PPUSH
60503: CALL_OW 72
60507: PUSH
60508: LD_INT 6
60510: MUL
60511: PLUS
60512: ST_TO_ADDR
// if bcount < tmp then
60513: LD_VAR 0 13
60517: PUSH
60518: LD_VAR 0 4
60522: LESS
60523: IFFALSE 60569
// for i = tmp downto bcount do
60525: LD_ADDR_VAR 0 3
60529: PUSH
60530: DOUBLE
60531: LD_VAR 0 4
60535: INC
60536: ST_TO_ADDR
60537: LD_VAR 0 13
60541: PUSH
60542: FOR_DOWNTO
60543: IFFALSE 60567
// tmp := Delete ( tmp , tmp ) ;
60545: LD_ADDR_VAR 0 4
60549: PUSH
60550: LD_VAR 0 4
60554: PPUSH
60555: LD_VAR 0 4
60559: PPUSH
60560: CALL_OW 3
60564: ST_TO_ADDR
60565: GO 60542
60567: POP
60568: POP
// result := [ tmp , 0 , 0 , p ] ;
60569: LD_ADDR_VAR 0 2
60573: PUSH
60574: LD_VAR 0 4
60578: PUSH
60579: LD_INT 0
60581: PUSH
60582: LD_INT 0
60584: PUSH
60585: LD_VAR 0 11
60589: PUSH
60590: EMPTY
60591: LIST
60592: LIST
60593: LIST
60594: LIST
60595: ST_TO_ADDR
// exit ;
60596: GO 63286
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60598: LD_EXP 68
60602: PUSH
60603: LD_VAR 0 1
60607: ARRAY
60608: PPUSH
60609: LD_INT 2
60611: PUSH
60612: LD_INT 30
60614: PUSH
60615: LD_INT 6
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: PUSH
60622: LD_INT 30
60624: PUSH
60625: LD_INT 7
60627: PUSH
60628: EMPTY
60629: LIST
60630: LIST
60631: PUSH
60632: LD_INT 30
60634: PUSH
60635: LD_INT 8
60637: PUSH
60638: EMPTY
60639: LIST
60640: LIST
60641: PUSH
60642: EMPTY
60643: LIST
60644: LIST
60645: LIST
60646: LIST
60647: PPUSH
60648: CALL_OW 72
60652: NOT
60653: PUSH
60654: LD_EXP 68
60658: PUSH
60659: LD_VAR 0 1
60663: ARRAY
60664: PPUSH
60665: LD_INT 30
60667: PUSH
60668: LD_INT 3
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: PPUSH
60675: CALL_OW 72
60679: NOT
60680: AND
60681: IFFALSE 60753
// begin if eng = tmp then
60683: LD_VAR 0 6
60687: PUSH
60688: LD_VAR 0 4
60692: EQUAL
60693: IFFALSE 60697
// exit ;
60695: GO 63286
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60697: LD_ADDR_EXP 110
60701: PUSH
60702: LD_EXP 110
60706: PPUSH
60707: LD_VAR 0 1
60711: PPUSH
60712: LD_INT 1
60714: PPUSH
60715: CALL_OW 1
60719: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60720: LD_ADDR_VAR 0 2
60724: PUSH
60725: LD_INT 0
60727: PUSH
60728: LD_VAR 0 4
60732: PUSH
60733: LD_VAR 0 6
60737: DIFF
60738: PUSH
60739: LD_INT 0
60741: PUSH
60742: LD_INT 0
60744: PUSH
60745: EMPTY
60746: LIST
60747: LIST
60748: LIST
60749: LIST
60750: ST_TO_ADDR
// exit ;
60751: GO 63286
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60753: LD_EXP 95
60757: PUSH
60758: LD_EXP 94
60762: PUSH
60763: LD_VAR 0 1
60767: ARRAY
60768: ARRAY
60769: PUSH
60770: LD_EXP 68
60774: PUSH
60775: LD_VAR 0 1
60779: ARRAY
60780: PPUSH
60781: LD_INT 2
60783: PUSH
60784: LD_INT 30
60786: PUSH
60787: LD_INT 6
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: LD_INT 30
60796: PUSH
60797: LD_INT 7
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: LD_INT 30
60806: PUSH
60807: LD_INT 8
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: LIST
60818: LIST
60819: PPUSH
60820: CALL_OW 72
60824: AND
60825: PUSH
60826: LD_EXP 68
60830: PUSH
60831: LD_VAR 0 1
60835: ARRAY
60836: PPUSH
60837: LD_INT 30
60839: PUSH
60840: LD_INT 3
60842: PUSH
60843: EMPTY
60844: LIST
60845: LIST
60846: PPUSH
60847: CALL_OW 72
60851: NOT
60852: AND
60853: IFFALSE 61067
// begin if sci >= 6 then
60855: LD_VAR 0 8
60859: PUSH
60860: LD_INT 6
60862: GREATEREQUAL
60863: IFFALSE 60867
// exit ;
60865: GO 63286
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60867: LD_ADDR_EXP 110
60871: PUSH
60872: LD_EXP 110
60876: PPUSH
60877: LD_VAR 0 1
60881: PPUSH
60882: LD_INT 2
60884: PPUSH
60885: CALL_OW 1
60889: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60890: LD_ADDR_VAR 0 9
60894: PUSH
60895: LD_VAR 0 4
60899: PUSH
60900: LD_VAR 0 8
60904: DIFF
60905: PPUSH
60906: LD_INT 4
60908: PPUSH
60909: CALL 49504 0 2
60913: ST_TO_ADDR
// p := [ ] ;
60914: LD_ADDR_VAR 0 11
60918: PUSH
60919: EMPTY
60920: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60921: LD_VAR 0 8
60925: PUSH
60926: LD_INT 6
60928: LESS
60929: PUSH
60930: LD_VAR 0 9
60934: PUSH
60935: LD_INT 6
60937: GREATER
60938: AND
60939: IFFALSE 61020
// begin for i = 1 to 6 - sci do
60941: LD_ADDR_VAR 0 3
60945: PUSH
60946: DOUBLE
60947: LD_INT 1
60949: DEC
60950: ST_TO_ADDR
60951: LD_INT 6
60953: PUSH
60954: LD_VAR 0 8
60958: MINUS
60959: PUSH
60960: FOR_TO
60961: IFFALSE 61016
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60963: LD_ADDR_VAR 0 11
60967: PUSH
60968: LD_VAR 0 11
60972: PPUSH
60973: LD_VAR 0 11
60977: PUSH
60978: LD_INT 1
60980: PLUS
60981: PPUSH
60982: LD_VAR 0 9
60986: PUSH
60987: LD_INT 1
60989: ARRAY
60990: PPUSH
60991: CALL_OW 2
60995: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60996: LD_ADDR_VAR 0 9
61000: PUSH
61001: LD_VAR 0 9
61005: PPUSH
61006: LD_INT 1
61008: PPUSH
61009: CALL_OW 3
61013: ST_TO_ADDR
// end ;
61014: GO 60960
61016: POP
61017: POP
// end else
61018: GO 61040
// if sort then
61020: LD_VAR 0 9
61024: IFFALSE 61040
// p := sort [ 1 ] ;
61026: LD_ADDR_VAR 0 11
61030: PUSH
61031: LD_VAR 0 9
61035: PUSH
61036: LD_INT 1
61038: ARRAY
61039: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61040: LD_ADDR_VAR 0 2
61044: PUSH
61045: LD_INT 0
61047: PUSH
61048: LD_INT 0
61050: PUSH
61051: LD_INT 0
61053: PUSH
61054: LD_VAR 0 11
61058: PUSH
61059: EMPTY
61060: LIST
61061: LIST
61062: LIST
61063: LIST
61064: ST_TO_ADDR
// exit ;
61065: GO 63286
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61067: LD_EXP 95
61071: PUSH
61072: LD_EXP 94
61076: PUSH
61077: LD_VAR 0 1
61081: ARRAY
61082: ARRAY
61083: PUSH
61084: LD_EXP 68
61088: PUSH
61089: LD_VAR 0 1
61093: ARRAY
61094: PPUSH
61095: LD_INT 2
61097: PUSH
61098: LD_INT 30
61100: PUSH
61101: LD_INT 6
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PUSH
61108: LD_INT 30
61110: PUSH
61111: LD_INT 7
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: PUSH
61118: LD_INT 30
61120: PUSH
61121: LD_INT 8
61123: PUSH
61124: EMPTY
61125: LIST
61126: LIST
61127: PUSH
61128: EMPTY
61129: LIST
61130: LIST
61131: LIST
61132: LIST
61133: PPUSH
61134: CALL_OW 72
61138: AND
61139: PUSH
61140: LD_EXP 68
61144: PUSH
61145: LD_VAR 0 1
61149: ARRAY
61150: PPUSH
61151: LD_INT 30
61153: PUSH
61154: LD_INT 3
61156: PUSH
61157: EMPTY
61158: LIST
61159: LIST
61160: PPUSH
61161: CALL_OW 72
61165: AND
61166: IFFALSE 61900
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61168: LD_ADDR_EXP 110
61172: PUSH
61173: LD_EXP 110
61177: PPUSH
61178: LD_VAR 0 1
61182: PPUSH
61183: LD_INT 3
61185: PPUSH
61186: CALL_OW 1
61190: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61191: LD_ADDR_VAR 0 2
61195: PUSH
61196: LD_INT 0
61198: PUSH
61199: LD_INT 0
61201: PUSH
61202: LD_INT 0
61204: PUSH
61205: LD_INT 0
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: ST_TO_ADDR
// if not eng then
61214: LD_VAR 0 6
61218: NOT
61219: IFFALSE 61282
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61221: LD_ADDR_VAR 0 11
61225: PUSH
61226: LD_VAR 0 4
61230: PPUSH
61231: LD_INT 2
61233: PPUSH
61234: CALL 49504 0 2
61238: PUSH
61239: LD_INT 1
61241: ARRAY
61242: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61243: LD_ADDR_VAR 0 2
61247: PUSH
61248: LD_VAR 0 2
61252: PPUSH
61253: LD_INT 2
61255: PPUSH
61256: LD_VAR 0 11
61260: PPUSH
61261: CALL_OW 1
61265: ST_TO_ADDR
// tmp := tmp diff p ;
61266: LD_ADDR_VAR 0 4
61270: PUSH
61271: LD_VAR 0 4
61275: PUSH
61276: LD_VAR 0 11
61280: DIFF
61281: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61282: LD_VAR 0 4
61286: PUSH
61287: LD_VAR 0 8
61291: PUSH
61292: LD_INT 6
61294: LESS
61295: AND
61296: IFFALSE 61484
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61298: LD_ADDR_VAR 0 9
61302: PUSH
61303: LD_VAR 0 4
61307: PUSH
61308: LD_VAR 0 8
61312: PUSH
61313: LD_VAR 0 7
61317: UNION
61318: DIFF
61319: PPUSH
61320: LD_INT 4
61322: PPUSH
61323: CALL 49504 0 2
61327: ST_TO_ADDR
// p := [ ] ;
61328: LD_ADDR_VAR 0 11
61332: PUSH
61333: EMPTY
61334: ST_TO_ADDR
// if sort then
61335: LD_VAR 0 9
61339: IFFALSE 61455
// for i = 1 to 6 - sci do
61341: LD_ADDR_VAR 0 3
61345: PUSH
61346: DOUBLE
61347: LD_INT 1
61349: DEC
61350: ST_TO_ADDR
61351: LD_INT 6
61353: PUSH
61354: LD_VAR 0 8
61358: MINUS
61359: PUSH
61360: FOR_TO
61361: IFFALSE 61453
// begin if i = sort then
61363: LD_VAR 0 3
61367: PUSH
61368: LD_VAR 0 9
61372: EQUAL
61373: IFFALSE 61377
// break ;
61375: GO 61453
// if GetClass ( i ) = 4 then
61377: LD_VAR 0 3
61381: PPUSH
61382: CALL_OW 257
61386: PUSH
61387: LD_INT 4
61389: EQUAL
61390: IFFALSE 61394
// continue ;
61392: GO 61360
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61394: LD_ADDR_VAR 0 11
61398: PUSH
61399: LD_VAR 0 11
61403: PPUSH
61404: LD_VAR 0 11
61408: PUSH
61409: LD_INT 1
61411: PLUS
61412: PPUSH
61413: LD_VAR 0 9
61417: PUSH
61418: LD_VAR 0 3
61422: ARRAY
61423: PPUSH
61424: CALL_OW 2
61428: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61429: LD_ADDR_VAR 0 4
61433: PUSH
61434: LD_VAR 0 4
61438: PUSH
61439: LD_VAR 0 9
61443: PUSH
61444: LD_VAR 0 3
61448: ARRAY
61449: DIFF
61450: ST_TO_ADDR
// end ;
61451: GO 61360
61453: POP
61454: POP
// if p then
61455: LD_VAR 0 11
61459: IFFALSE 61484
// result := Replace ( result , 4 , p ) ;
61461: LD_ADDR_VAR 0 2
61465: PUSH
61466: LD_VAR 0 2
61470: PPUSH
61471: LD_INT 4
61473: PPUSH
61474: LD_VAR 0 11
61478: PPUSH
61479: CALL_OW 1
61483: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61484: LD_VAR 0 4
61488: PUSH
61489: LD_VAR 0 7
61493: PUSH
61494: LD_INT 6
61496: LESS
61497: AND
61498: IFFALSE 61686
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61500: LD_ADDR_VAR 0 9
61504: PUSH
61505: LD_VAR 0 4
61509: PUSH
61510: LD_VAR 0 8
61514: PUSH
61515: LD_VAR 0 7
61519: UNION
61520: DIFF
61521: PPUSH
61522: LD_INT 3
61524: PPUSH
61525: CALL 49504 0 2
61529: ST_TO_ADDR
// p := [ ] ;
61530: LD_ADDR_VAR 0 11
61534: PUSH
61535: EMPTY
61536: ST_TO_ADDR
// if sort then
61537: LD_VAR 0 9
61541: IFFALSE 61657
// for i = 1 to 6 - mech do
61543: LD_ADDR_VAR 0 3
61547: PUSH
61548: DOUBLE
61549: LD_INT 1
61551: DEC
61552: ST_TO_ADDR
61553: LD_INT 6
61555: PUSH
61556: LD_VAR 0 7
61560: MINUS
61561: PUSH
61562: FOR_TO
61563: IFFALSE 61655
// begin if i = sort then
61565: LD_VAR 0 3
61569: PUSH
61570: LD_VAR 0 9
61574: EQUAL
61575: IFFALSE 61579
// break ;
61577: GO 61655
// if GetClass ( i ) = 3 then
61579: LD_VAR 0 3
61583: PPUSH
61584: CALL_OW 257
61588: PUSH
61589: LD_INT 3
61591: EQUAL
61592: IFFALSE 61596
// continue ;
61594: GO 61562
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61596: LD_ADDR_VAR 0 11
61600: PUSH
61601: LD_VAR 0 11
61605: PPUSH
61606: LD_VAR 0 11
61610: PUSH
61611: LD_INT 1
61613: PLUS
61614: PPUSH
61615: LD_VAR 0 9
61619: PUSH
61620: LD_VAR 0 3
61624: ARRAY
61625: PPUSH
61626: CALL_OW 2
61630: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61631: LD_ADDR_VAR 0 4
61635: PUSH
61636: LD_VAR 0 4
61640: PUSH
61641: LD_VAR 0 9
61645: PUSH
61646: LD_VAR 0 3
61650: ARRAY
61651: DIFF
61652: ST_TO_ADDR
// end ;
61653: GO 61562
61655: POP
61656: POP
// if p then
61657: LD_VAR 0 11
61661: IFFALSE 61686
// result := Replace ( result , 3 , p ) ;
61663: LD_ADDR_VAR 0 2
61667: PUSH
61668: LD_VAR 0 2
61672: PPUSH
61673: LD_INT 3
61675: PPUSH
61676: LD_VAR 0 11
61680: PPUSH
61681: CALL_OW 1
61685: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61686: LD_VAR 0 4
61690: PUSH
61691: LD_INT 6
61693: GREATER
61694: PUSH
61695: LD_VAR 0 6
61699: PUSH
61700: LD_INT 6
61702: LESS
61703: AND
61704: IFFALSE 61898
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61706: LD_ADDR_VAR 0 9
61710: PUSH
61711: LD_VAR 0 4
61715: PUSH
61716: LD_VAR 0 8
61720: PUSH
61721: LD_VAR 0 7
61725: UNION
61726: PUSH
61727: LD_VAR 0 6
61731: UNION
61732: DIFF
61733: PPUSH
61734: LD_INT 2
61736: PPUSH
61737: CALL 49504 0 2
61741: ST_TO_ADDR
// p := [ ] ;
61742: LD_ADDR_VAR 0 11
61746: PUSH
61747: EMPTY
61748: ST_TO_ADDR
// if sort then
61749: LD_VAR 0 9
61753: IFFALSE 61869
// for i = 1 to 6 - eng do
61755: LD_ADDR_VAR 0 3
61759: PUSH
61760: DOUBLE
61761: LD_INT 1
61763: DEC
61764: ST_TO_ADDR
61765: LD_INT 6
61767: PUSH
61768: LD_VAR 0 6
61772: MINUS
61773: PUSH
61774: FOR_TO
61775: IFFALSE 61867
// begin if i = sort then
61777: LD_VAR 0 3
61781: PUSH
61782: LD_VAR 0 9
61786: EQUAL
61787: IFFALSE 61791
// break ;
61789: GO 61867
// if GetClass ( i ) = 2 then
61791: LD_VAR 0 3
61795: PPUSH
61796: CALL_OW 257
61800: PUSH
61801: LD_INT 2
61803: EQUAL
61804: IFFALSE 61808
// continue ;
61806: GO 61774
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61808: LD_ADDR_VAR 0 11
61812: PUSH
61813: LD_VAR 0 11
61817: PPUSH
61818: LD_VAR 0 11
61822: PUSH
61823: LD_INT 1
61825: PLUS
61826: PPUSH
61827: LD_VAR 0 9
61831: PUSH
61832: LD_VAR 0 3
61836: ARRAY
61837: PPUSH
61838: CALL_OW 2
61842: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61843: LD_ADDR_VAR 0 4
61847: PUSH
61848: LD_VAR 0 4
61852: PUSH
61853: LD_VAR 0 9
61857: PUSH
61858: LD_VAR 0 3
61862: ARRAY
61863: DIFF
61864: ST_TO_ADDR
// end ;
61865: GO 61774
61867: POP
61868: POP
// if p then
61869: LD_VAR 0 11
61873: IFFALSE 61898
// result := Replace ( result , 2 , p ) ;
61875: LD_ADDR_VAR 0 2
61879: PUSH
61880: LD_VAR 0 2
61884: PPUSH
61885: LD_INT 2
61887: PPUSH
61888: LD_VAR 0 11
61892: PPUSH
61893: CALL_OW 1
61897: ST_TO_ADDR
// end ; exit ;
61898: GO 63286
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61900: LD_EXP 95
61904: PUSH
61905: LD_EXP 94
61909: PUSH
61910: LD_VAR 0 1
61914: ARRAY
61915: ARRAY
61916: NOT
61917: PUSH
61918: LD_EXP 68
61922: PUSH
61923: LD_VAR 0 1
61927: ARRAY
61928: PPUSH
61929: LD_INT 30
61931: PUSH
61932: LD_INT 3
61934: PUSH
61935: EMPTY
61936: LIST
61937: LIST
61938: PPUSH
61939: CALL_OW 72
61943: AND
61944: PUSH
61945: LD_EXP 73
61949: PUSH
61950: LD_VAR 0 1
61954: ARRAY
61955: AND
61956: IFFALSE 62564
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61958: LD_ADDR_EXP 110
61962: PUSH
61963: LD_EXP 110
61967: PPUSH
61968: LD_VAR 0 1
61972: PPUSH
61973: LD_INT 5
61975: PPUSH
61976: CALL_OW 1
61980: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61981: LD_ADDR_VAR 0 2
61985: PUSH
61986: LD_INT 0
61988: PUSH
61989: LD_INT 0
61991: PUSH
61992: LD_INT 0
61994: PUSH
61995: LD_INT 0
61997: PUSH
61998: EMPTY
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: ST_TO_ADDR
// if sci > 1 then
62004: LD_VAR 0 8
62008: PUSH
62009: LD_INT 1
62011: GREATER
62012: IFFALSE 62040
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62014: LD_ADDR_VAR 0 4
62018: PUSH
62019: LD_VAR 0 4
62023: PUSH
62024: LD_VAR 0 8
62028: PUSH
62029: LD_VAR 0 8
62033: PUSH
62034: LD_INT 1
62036: ARRAY
62037: DIFF
62038: DIFF
62039: ST_TO_ADDR
// if tmp and not sci then
62040: LD_VAR 0 4
62044: PUSH
62045: LD_VAR 0 8
62049: NOT
62050: AND
62051: IFFALSE 62120
// begin sort := SortBySkill ( tmp , 4 ) ;
62053: LD_ADDR_VAR 0 9
62057: PUSH
62058: LD_VAR 0 4
62062: PPUSH
62063: LD_INT 4
62065: PPUSH
62066: CALL 49504 0 2
62070: ST_TO_ADDR
// if sort then
62071: LD_VAR 0 9
62075: IFFALSE 62091
// p := sort [ 1 ] ;
62077: LD_ADDR_VAR 0 11
62081: PUSH
62082: LD_VAR 0 9
62086: PUSH
62087: LD_INT 1
62089: ARRAY
62090: ST_TO_ADDR
// if p then
62091: LD_VAR 0 11
62095: IFFALSE 62120
// result := Replace ( result , 4 , p ) ;
62097: LD_ADDR_VAR 0 2
62101: PUSH
62102: LD_VAR 0 2
62106: PPUSH
62107: LD_INT 4
62109: PPUSH
62110: LD_VAR 0 11
62114: PPUSH
62115: CALL_OW 1
62119: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62120: LD_ADDR_VAR 0 4
62124: PUSH
62125: LD_VAR 0 4
62129: PUSH
62130: LD_VAR 0 7
62134: DIFF
62135: ST_TO_ADDR
// if tmp and mech < 6 then
62136: LD_VAR 0 4
62140: PUSH
62141: LD_VAR 0 7
62145: PUSH
62146: LD_INT 6
62148: LESS
62149: AND
62150: IFFALSE 62338
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62152: LD_ADDR_VAR 0 9
62156: PUSH
62157: LD_VAR 0 4
62161: PUSH
62162: LD_VAR 0 8
62166: PUSH
62167: LD_VAR 0 7
62171: UNION
62172: DIFF
62173: PPUSH
62174: LD_INT 3
62176: PPUSH
62177: CALL 49504 0 2
62181: ST_TO_ADDR
// p := [ ] ;
62182: LD_ADDR_VAR 0 11
62186: PUSH
62187: EMPTY
62188: ST_TO_ADDR
// if sort then
62189: LD_VAR 0 9
62193: IFFALSE 62309
// for i = 1 to 6 - mech do
62195: LD_ADDR_VAR 0 3
62199: PUSH
62200: DOUBLE
62201: LD_INT 1
62203: DEC
62204: ST_TO_ADDR
62205: LD_INT 6
62207: PUSH
62208: LD_VAR 0 7
62212: MINUS
62213: PUSH
62214: FOR_TO
62215: IFFALSE 62307
// begin if i = sort then
62217: LD_VAR 0 3
62221: PUSH
62222: LD_VAR 0 9
62226: EQUAL
62227: IFFALSE 62231
// break ;
62229: GO 62307
// if GetClass ( i ) = 3 then
62231: LD_VAR 0 3
62235: PPUSH
62236: CALL_OW 257
62240: PUSH
62241: LD_INT 3
62243: EQUAL
62244: IFFALSE 62248
// continue ;
62246: GO 62214
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62248: LD_ADDR_VAR 0 11
62252: PUSH
62253: LD_VAR 0 11
62257: PPUSH
62258: LD_VAR 0 11
62262: PUSH
62263: LD_INT 1
62265: PLUS
62266: PPUSH
62267: LD_VAR 0 9
62271: PUSH
62272: LD_VAR 0 3
62276: ARRAY
62277: PPUSH
62278: CALL_OW 2
62282: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62283: LD_ADDR_VAR 0 4
62287: PUSH
62288: LD_VAR 0 4
62292: PUSH
62293: LD_VAR 0 9
62297: PUSH
62298: LD_VAR 0 3
62302: ARRAY
62303: DIFF
62304: ST_TO_ADDR
// end ;
62305: GO 62214
62307: POP
62308: POP
// if p then
62309: LD_VAR 0 11
62313: IFFALSE 62338
// result := Replace ( result , 3 , p ) ;
62315: LD_ADDR_VAR 0 2
62319: PUSH
62320: LD_VAR 0 2
62324: PPUSH
62325: LD_INT 3
62327: PPUSH
62328: LD_VAR 0 11
62332: PPUSH
62333: CALL_OW 1
62337: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62338: LD_ADDR_VAR 0 4
62342: PUSH
62343: LD_VAR 0 4
62347: PUSH
62348: LD_VAR 0 6
62352: DIFF
62353: ST_TO_ADDR
// if tmp and eng < 6 then
62354: LD_VAR 0 4
62358: PUSH
62359: LD_VAR 0 6
62363: PUSH
62364: LD_INT 6
62366: LESS
62367: AND
62368: IFFALSE 62562
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62370: LD_ADDR_VAR 0 9
62374: PUSH
62375: LD_VAR 0 4
62379: PUSH
62380: LD_VAR 0 8
62384: PUSH
62385: LD_VAR 0 7
62389: UNION
62390: PUSH
62391: LD_VAR 0 6
62395: UNION
62396: DIFF
62397: PPUSH
62398: LD_INT 2
62400: PPUSH
62401: CALL 49504 0 2
62405: ST_TO_ADDR
// p := [ ] ;
62406: LD_ADDR_VAR 0 11
62410: PUSH
62411: EMPTY
62412: ST_TO_ADDR
// if sort then
62413: LD_VAR 0 9
62417: IFFALSE 62533
// for i = 1 to 6 - eng do
62419: LD_ADDR_VAR 0 3
62423: PUSH
62424: DOUBLE
62425: LD_INT 1
62427: DEC
62428: ST_TO_ADDR
62429: LD_INT 6
62431: PUSH
62432: LD_VAR 0 6
62436: MINUS
62437: PUSH
62438: FOR_TO
62439: IFFALSE 62531
// begin if i = sort then
62441: LD_VAR 0 3
62445: PUSH
62446: LD_VAR 0 9
62450: EQUAL
62451: IFFALSE 62455
// break ;
62453: GO 62531
// if GetClass ( i ) = 2 then
62455: LD_VAR 0 3
62459: PPUSH
62460: CALL_OW 257
62464: PUSH
62465: LD_INT 2
62467: EQUAL
62468: IFFALSE 62472
// continue ;
62470: GO 62438
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62472: LD_ADDR_VAR 0 11
62476: PUSH
62477: LD_VAR 0 11
62481: PPUSH
62482: LD_VAR 0 11
62486: PUSH
62487: LD_INT 1
62489: PLUS
62490: PPUSH
62491: LD_VAR 0 9
62495: PUSH
62496: LD_VAR 0 3
62500: ARRAY
62501: PPUSH
62502: CALL_OW 2
62506: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62507: LD_ADDR_VAR 0 4
62511: PUSH
62512: LD_VAR 0 4
62516: PUSH
62517: LD_VAR 0 9
62521: PUSH
62522: LD_VAR 0 3
62526: ARRAY
62527: DIFF
62528: ST_TO_ADDR
// end ;
62529: GO 62438
62531: POP
62532: POP
// if p then
62533: LD_VAR 0 11
62537: IFFALSE 62562
// result := Replace ( result , 2 , p ) ;
62539: LD_ADDR_VAR 0 2
62543: PUSH
62544: LD_VAR 0 2
62548: PPUSH
62549: LD_INT 2
62551: PPUSH
62552: LD_VAR 0 11
62556: PPUSH
62557: CALL_OW 1
62561: ST_TO_ADDR
// end ; exit ;
62562: GO 63286
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62564: LD_EXP 95
62568: PUSH
62569: LD_EXP 94
62573: PUSH
62574: LD_VAR 0 1
62578: ARRAY
62579: ARRAY
62580: NOT
62581: PUSH
62582: LD_EXP 68
62586: PUSH
62587: LD_VAR 0 1
62591: ARRAY
62592: PPUSH
62593: LD_INT 30
62595: PUSH
62596: LD_INT 3
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: PPUSH
62603: CALL_OW 72
62607: AND
62608: PUSH
62609: LD_EXP 73
62613: PUSH
62614: LD_VAR 0 1
62618: ARRAY
62619: NOT
62620: AND
62621: IFFALSE 63286
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62623: LD_ADDR_EXP 110
62627: PUSH
62628: LD_EXP 110
62632: PPUSH
62633: LD_VAR 0 1
62637: PPUSH
62638: LD_INT 6
62640: PPUSH
62641: CALL_OW 1
62645: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62646: LD_ADDR_VAR 0 2
62650: PUSH
62651: LD_INT 0
62653: PUSH
62654: LD_INT 0
62656: PUSH
62657: LD_INT 0
62659: PUSH
62660: LD_INT 0
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: LIST
62667: LIST
62668: ST_TO_ADDR
// if sci >= 1 then
62669: LD_VAR 0 8
62673: PUSH
62674: LD_INT 1
62676: GREATEREQUAL
62677: IFFALSE 62699
// tmp := tmp diff sci [ 1 ] ;
62679: LD_ADDR_VAR 0 4
62683: PUSH
62684: LD_VAR 0 4
62688: PUSH
62689: LD_VAR 0 8
62693: PUSH
62694: LD_INT 1
62696: ARRAY
62697: DIFF
62698: ST_TO_ADDR
// if tmp and not sci then
62699: LD_VAR 0 4
62703: PUSH
62704: LD_VAR 0 8
62708: NOT
62709: AND
62710: IFFALSE 62779
// begin sort := SortBySkill ( tmp , 4 ) ;
62712: LD_ADDR_VAR 0 9
62716: PUSH
62717: LD_VAR 0 4
62721: PPUSH
62722: LD_INT 4
62724: PPUSH
62725: CALL 49504 0 2
62729: ST_TO_ADDR
// if sort then
62730: LD_VAR 0 9
62734: IFFALSE 62750
// p := sort [ 1 ] ;
62736: LD_ADDR_VAR 0 11
62740: PUSH
62741: LD_VAR 0 9
62745: PUSH
62746: LD_INT 1
62748: ARRAY
62749: ST_TO_ADDR
// if p then
62750: LD_VAR 0 11
62754: IFFALSE 62779
// result := Replace ( result , 4 , p ) ;
62756: LD_ADDR_VAR 0 2
62760: PUSH
62761: LD_VAR 0 2
62765: PPUSH
62766: LD_INT 4
62768: PPUSH
62769: LD_VAR 0 11
62773: PPUSH
62774: CALL_OW 1
62778: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62779: LD_ADDR_VAR 0 4
62783: PUSH
62784: LD_VAR 0 4
62788: PUSH
62789: LD_VAR 0 7
62793: DIFF
62794: ST_TO_ADDR
// if tmp and mech < 6 then
62795: LD_VAR 0 4
62799: PUSH
62800: LD_VAR 0 7
62804: PUSH
62805: LD_INT 6
62807: LESS
62808: AND
62809: IFFALSE 62991
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62811: LD_ADDR_VAR 0 9
62815: PUSH
62816: LD_VAR 0 4
62820: PUSH
62821: LD_VAR 0 7
62825: DIFF
62826: PPUSH
62827: LD_INT 3
62829: PPUSH
62830: CALL 49504 0 2
62834: ST_TO_ADDR
// p := [ ] ;
62835: LD_ADDR_VAR 0 11
62839: PUSH
62840: EMPTY
62841: ST_TO_ADDR
// if sort then
62842: LD_VAR 0 9
62846: IFFALSE 62962
// for i = 1 to 6 - mech do
62848: LD_ADDR_VAR 0 3
62852: PUSH
62853: DOUBLE
62854: LD_INT 1
62856: DEC
62857: ST_TO_ADDR
62858: LD_INT 6
62860: PUSH
62861: LD_VAR 0 7
62865: MINUS
62866: PUSH
62867: FOR_TO
62868: IFFALSE 62960
// begin if i = sort then
62870: LD_VAR 0 3
62874: PUSH
62875: LD_VAR 0 9
62879: EQUAL
62880: IFFALSE 62884
// break ;
62882: GO 62960
// if GetClass ( i ) = 3 then
62884: LD_VAR 0 3
62888: PPUSH
62889: CALL_OW 257
62893: PUSH
62894: LD_INT 3
62896: EQUAL
62897: IFFALSE 62901
// continue ;
62899: GO 62867
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62901: LD_ADDR_VAR 0 11
62905: PUSH
62906: LD_VAR 0 11
62910: PPUSH
62911: LD_VAR 0 11
62915: PUSH
62916: LD_INT 1
62918: PLUS
62919: PPUSH
62920: LD_VAR 0 9
62924: PUSH
62925: LD_VAR 0 3
62929: ARRAY
62930: PPUSH
62931: CALL_OW 2
62935: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62936: LD_ADDR_VAR 0 4
62940: PUSH
62941: LD_VAR 0 4
62945: PUSH
62946: LD_VAR 0 9
62950: PUSH
62951: LD_VAR 0 3
62955: ARRAY
62956: DIFF
62957: ST_TO_ADDR
// end ;
62958: GO 62867
62960: POP
62961: POP
// if p then
62962: LD_VAR 0 11
62966: IFFALSE 62991
// result := Replace ( result , 3 , p ) ;
62968: LD_ADDR_VAR 0 2
62972: PUSH
62973: LD_VAR 0 2
62977: PPUSH
62978: LD_INT 3
62980: PPUSH
62981: LD_VAR 0 11
62985: PPUSH
62986: CALL_OW 1
62990: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62991: LD_ADDR_VAR 0 4
62995: PUSH
62996: LD_VAR 0 4
63000: PUSH
63001: LD_VAR 0 6
63005: DIFF
63006: ST_TO_ADDR
// if tmp and eng < 4 then
63007: LD_VAR 0 4
63011: PUSH
63012: LD_VAR 0 6
63016: PUSH
63017: LD_INT 4
63019: LESS
63020: AND
63021: IFFALSE 63211
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63023: LD_ADDR_VAR 0 9
63027: PUSH
63028: LD_VAR 0 4
63032: PUSH
63033: LD_VAR 0 7
63037: PUSH
63038: LD_VAR 0 6
63042: UNION
63043: DIFF
63044: PPUSH
63045: LD_INT 2
63047: PPUSH
63048: CALL 49504 0 2
63052: ST_TO_ADDR
// p := [ ] ;
63053: LD_ADDR_VAR 0 11
63057: PUSH
63058: EMPTY
63059: ST_TO_ADDR
// if sort then
63060: LD_VAR 0 9
63064: IFFALSE 63180
// for i = 1 to 4 - eng do
63066: LD_ADDR_VAR 0 3
63070: PUSH
63071: DOUBLE
63072: LD_INT 1
63074: DEC
63075: ST_TO_ADDR
63076: LD_INT 4
63078: PUSH
63079: LD_VAR 0 6
63083: MINUS
63084: PUSH
63085: FOR_TO
63086: IFFALSE 63178
// begin if i = sort then
63088: LD_VAR 0 3
63092: PUSH
63093: LD_VAR 0 9
63097: EQUAL
63098: IFFALSE 63102
// break ;
63100: GO 63178
// if GetClass ( i ) = 2 then
63102: LD_VAR 0 3
63106: PPUSH
63107: CALL_OW 257
63111: PUSH
63112: LD_INT 2
63114: EQUAL
63115: IFFALSE 63119
// continue ;
63117: GO 63085
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63119: LD_ADDR_VAR 0 11
63123: PUSH
63124: LD_VAR 0 11
63128: PPUSH
63129: LD_VAR 0 11
63133: PUSH
63134: LD_INT 1
63136: PLUS
63137: PPUSH
63138: LD_VAR 0 9
63142: PUSH
63143: LD_VAR 0 3
63147: ARRAY
63148: PPUSH
63149: CALL_OW 2
63153: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63154: LD_ADDR_VAR 0 4
63158: PUSH
63159: LD_VAR 0 4
63163: PUSH
63164: LD_VAR 0 9
63168: PUSH
63169: LD_VAR 0 3
63173: ARRAY
63174: DIFF
63175: ST_TO_ADDR
// end ;
63176: GO 63085
63178: POP
63179: POP
// if p then
63180: LD_VAR 0 11
63184: IFFALSE 63209
// result := Replace ( result , 2 , p ) ;
63186: LD_ADDR_VAR 0 2
63190: PUSH
63191: LD_VAR 0 2
63195: PPUSH
63196: LD_INT 2
63198: PPUSH
63199: LD_VAR 0 11
63203: PPUSH
63204: CALL_OW 1
63208: ST_TO_ADDR
// end else
63209: GO 63255
// for i = eng downto 5 do
63211: LD_ADDR_VAR 0 3
63215: PUSH
63216: DOUBLE
63217: LD_VAR 0 6
63221: INC
63222: ST_TO_ADDR
63223: LD_INT 5
63225: PUSH
63226: FOR_DOWNTO
63227: IFFALSE 63253
// tmp := tmp union eng [ i ] ;
63229: LD_ADDR_VAR 0 4
63233: PUSH
63234: LD_VAR 0 4
63238: PUSH
63239: LD_VAR 0 6
63243: PUSH
63244: LD_VAR 0 3
63248: ARRAY
63249: UNION
63250: ST_TO_ADDR
63251: GO 63226
63253: POP
63254: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63255: LD_ADDR_VAR 0 2
63259: PUSH
63260: LD_VAR 0 2
63264: PPUSH
63265: LD_INT 1
63267: PPUSH
63268: LD_VAR 0 4
63272: PUSH
63273: LD_VAR 0 5
63277: DIFF
63278: PPUSH
63279: CALL_OW 1
63283: ST_TO_ADDR
// exit ;
63284: GO 63286
// end ; end ;
63286: LD_VAR 0 2
63290: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63291: LD_INT 0
63293: PPUSH
63294: PPUSH
63295: PPUSH
// if not mc_bases then
63296: LD_EXP 68
63300: NOT
63301: IFFALSE 63305
// exit ;
63303: GO 63447
// for i = 1 to mc_bases do
63305: LD_ADDR_VAR 0 2
63309: PUSH
63310: DOUBLE
63311: LD_INT 1
63313: DEC
63314: ST_TO_ADDR
63315: LD_EXP 68
63319: PUSH
63320: FOR_TO
63321: IFFALSE 63438
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63323: LD_ADDR_VAR 0 3
63327: PUSH
63328: LD_EXP 68
63332: PUSH
63333: LD_VAR 0 2
63337: ARRAY
63338: PPUSH
63339: LD_INT 21
63341: PUSH
63342: LD_INT 3
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: PUSH
63349: LD_INT 3
63351: PUSH
63352: LD_INT 2
63354: PUSH
63355: LD_INT 30
63357: PUSH
63358: LD_INT 29
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PUSH
63365: LD_INT 30
63367: PUSH
63368: LD_INT 30
63370: PUSH
63371: EMPTY
63372: LIST
63373: LIST
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: LIST
63379: PUSH
63380: EMPTY
63381: LIST
63382: LIST
63383: PUSH
63384: LD_INT 3
63386: PUSH
63387: LD_INT 24
63389: PUSH
63390: LD_INT 1000
63392: PUSH
63393: EMPTY
63394: LIST
63395: LIST
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: LIST
63405: PPUSH
63406: CALL_OW 72
63410: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63411: LD_ADDR_EXP 69
63415: PUSH
63416: LD_EXP 69
63420: PPUSH
63421: LD_VAR 0 2
63425: PPUSH
63426: LD_VAR 0 3
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// end ;
63436: GO 63320
63438: POP
63439: POP
// RaiseSailEvent ( 101 ) ;
63440: LD_INT 101
63442: PPUSH
63443: CALL_OW 427
// end ;
63447: LD_VAR 0 1
63451: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63452: LD_INT 0
63454: PPUSH
63455: PPUSH
63456: PPUSH
63457: PPUSH
63458: PPUSH
63459: PPUSH
63460: PPUSH
// if not mc_bases then
63461: LD_EXP 68
63465: NOT
63466: IFFALSE 63470
// exit ;
63468: GO 64032
// for i = 1 to mc_bases do
63470: LD_ADDR_VAR 0 2
63474: PUSH
63475: DOUBLE
63476: LD_INT 1
63478: DEC
63479: ST_TO_ADDR
63480: LD_EXP 68
63484: PUSH
63485: FOR_TO
63486: IFFALSE 64023
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63488: LD_ADDR_VAR 0 5
63492: PUSH
63493: LD_EXP 68
63497: PUSH
63498: LD_VAR 0 2
63502: ARRAY
63503: PUSH
63504: LD_EXP 97
63508: PUSH
63509: LD_VAR 0 2
63513: ARRAY
63514: UNION
63515: PPUSH
63516: LD_INT 21
63518: PUSH
63519: LD_INT 1
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PUSH
63526: LD_INT 1
63528: PUSH
63529: LD_INT 3
63531: PUSH
63532: LD_INT 54
63534: PUSH
63535: EMPTY
63536: LIST
63537: PUSH
63538: EMPTY
63539: LIST
63540: LIST
63541: PUSH
63542: LD_INT 3
63544: PUSH
63545: LD_INT 24
63547: PUSH
63548: LD_INT 1000
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: LIST
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PPUSH
63568: CALL_OW 72
63572: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63573: LD_ADDR_VAR 0 6
63577: PUSH
63578: LD_EXP 68
63582: PUSH
63583: LD_VAR 0 2
63587: ARRAY
63588: PPUSH
63589: LD_INT 21
63591: PUSH
63592: LD_INT 1
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 1
63601: PUSH
63602: LD_INT 3
63604: PUSH
63605: LD_INT 54
63607: PUSH
63608: EMPTY
63609: LIST
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: PUSH
63615: LD_INT 3
63617: PUSH
63618: LD_INT 24
63620: PUSH
63621: LD_INT 250
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: LIST
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PPUSH
63641: CALL_OW 72
63645: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63646: LD_ADDR_VAR 0 7
63650: PUSH
63651: LD_VAR 0 5
63655: PUSH
63656: LD_VAR 0 6
63660: DIFF
63661: ST_TO_ADDR
// if not need_heal_1 then
63662: LD_VAR 0 6
63666: NOT
63667: IFFALSE 63700
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63669: LD_ADDR_EXP 71
63673: PUSH
63674: LD_EXP 71
63678: PPUSH
63679: LD_VAR 0 2
63683: PUSH
63684: LD_INT 1
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: PPUSH
63691: EMPTY
63692: PPUSH
63693: CALL 18750 0 3
63697: ST_TO_ADDR
63698: GO 63770
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63700: LD_ADDR_EXP 71
63704: PUSH
63705: LD_EXP 71
63709: PPUSH
63710: LD_VAR 0 2
63714: PUSH
63715: LD_INT 1
63717: PUSH
63718: EMPTY
63719: LIST
63720: LIST
63721: PPUSH
63722: LD_EXP 71
63726: PUSH
63727: LD_VAR 0 2
63731: ARRAY
63732: PUSH
63733: LD_INT 1
63735: ARRAY
63736: PPUSH
63737: LD_INT 3
63739: PUSH
63740: LD_INT 24
63742: PUSH
63743: LD_INT 1000
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PPUSH
63754: CALL_OW 72
63758: PUSH
63759: LD_VAR 0 6
63763: UNION
63764: PPUSH
63765: CALL 18750 0 3
63769: ST_TO_ADDR
// if not need_heal_2 then
63770: LD_VAR 0 7
63774: NOT
63775: IFFALSE 63808
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63777: LD_ADDR_EXP 71
63781: PUSH
63782: LD_EXP 71
63786: PPUSH
63787: LD_VAR 0 2
63791: PUSH
63792: LD_INT 2
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PPUSH
63799: EMPTY
63800: PPUSH
63801: CALL 18750 0 3
63805: ST_TO_ADDR
63806: GO 63840
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63808: LD_ADDR_EXP 71
63812: PUSH
63813: LD_EXP 71
63817: PPUSH
63818: LD_VAR 0 2
63822: PUSH
63823: LD_INT 2
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PPUSH
63830: LD_VAR 0 7
63834: PPUSH
63835: CALL 18750 0 3
63839: ST_TO_ADDR
// if need_heal_2 then
63840: LD_VAR 0 7
63844: IFFALSE 64005
// for j in need_heal_2 do
63846: LD_ADDR_VAR 0 3
63850: PUSH
63851: LD_VAR 0 7
63855: PUSH
63856: FOR_IN
63857: IFFALSE 64003
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63859: LD_ADDR_VAR 0 5
63863: PUSH
63864: LD_EXP 68
63868: PUSH
63869: LD_VAR 0 2
63873: ARRAY
63874: PPUSH
63875: LD_INT 2
63877: PUSH
63878: LD_INT 30
63880: PUSH
63881: LD_INT 6
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 30
63890: PUSH
63891: LD_INT 7
63893: PUSH
63894: EMPTY
63895: LIST
63896: LIST
63897: PUSH
63898: LD_INT 30
63900: PUSH
63901: LD_INT 8
63903: PUSH
63904: EMPTY
63905: LIST
63906: LIST
63907: PUSH
63908: LD_INT 30
63910: PUSH
63911: LD_INT 0
63913: PUSH
63914: EMPTY
63915: LIST
63916: LIST
63917: PUSH
63918: LD_INT 30
63920: PUSH
63921: LD_INT 1
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: EMPTY
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: PPUSH
63936: CALL_OW 72
63940: ST_TO_ADDR
// if tmp then
63941: LD_VAR 0 5
63945: IFFALSE 64001
// begin k := NearestUnitToUnit ( tmp , j ) ;
63947: LD_ADDR_VAR 0 4
63951: PUSH
63952: LD_VAR 0 5
63956: PPUSH
63957: LD_VAR 0 3
63961: PPUSH
63962: CALL_OW 74
63966: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63967: LD_VAR 0 3
63971: PPUSH
63972: LD_VAR 0 4
63976: PPUSH
63977: CALL_OW 296
63981: PUSH
63982: LD_INT 5
63984: GREATER
63985: IFFALSE 64001
// ComMoveToNearbyEntrance ( j , k ) ;
63987: LD_VAR 0 3
63991: PPUSH
63992: LD_VAR 0 4
63996: PPUSH
63997: CALL 51872 0 2
// end ; end ;
64001: GO 63856
64003: POP
64004: POP
// if not need_heal_1 and not need_heal_2 then
64005: LD_VAR 0 6
64009: NOT
64010: PUSH
64011: LD_VAR 0 7
64015: NOT
64016: AND
64017: IFFALSE 64021
// continue ;
64019: GO 63485
// end ;
64021: GO 63485
64023: POP
64024: POP
// RaiseSailEvent ( 102 ) ;
64025: LD_INT 102
64027: PPUSH
64028: CALL_OW 427
// end ;
64032: LD_VAR 0 1
64036: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
64037: LD_INT 0
64039: PPUSH
64040: PPUSH
64041: PPUSH
64042: PPUSH
64043: PPUSH
64044: PPUSH
64045: PPUSH
64046: PPUSH
// if not mc_bases then
64047: LD_EXP 68
64051: NOT
64052: IFFALSE 64056
// exit ;
64054: GO 64939
// for i = 1 to mc_bases do
64056: LD_ADDR_VAR 0 2
64060: PUSH
64061: DOUBLE
64062: LD_INT 1
64064: DEC
64065: ST_TO_ADDR
64066: LD_EXP 68
64070: PUSH
64071: FOR_TO
64072: IFFALSE 64937
// begin if not mc_building_need_repair [ i ] then
64074: LD_EXP 69
64078: PUSH
64079: LD_VAR 0 2
64083: ARRAY
64084: NOT
64085: IFFALSE 64272
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64087: LD_ADDR_VAR 0 6
64091: PUSH
64092: LD_EXP 87
64096: PUSH
64097: LD_VAR 0 2
64101: ARRAY
64102: PPUSH
64103: LD_INT 3
64105: PUSH
64106: LD_INT 24
64108: PUSH
64109: LD_INT 1000
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 2
64122: PUSH
64123: LD_INT 34
64125: PUSH
64126: LD_INT 13
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: LD_INT 34
64135: PUSH
64136: LD_INT 52
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 34
64145: PUSH
64146: LD_EXP 54
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: LIST
64159: LIST
64160: PUSH
64161: EMPTY
64162: LIST
64163: LIST
64164: PPUSH
64165: CALL_OW 72
64169: ST_TO_ADDR
// if cranes then
64170: LD_VAR 0 6
64174: IFFALSE 64236
// for j in cranes do
64176: LD_ADDR_VAR 0 3
64180: PUSH
64181: LD_VAR 0 6
64185: PUSH
64186: FOR_IN
64187: IFFALSE 64234
// if not IsInArea ( j , mc_parking [ i ] ) then
64189: LD_VAR 0 3
64193: PPUSH
64194: LD_EXP 92
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: PPUSH
64205: CALL_OW 308
64209: NOT
64210: IFFALSE 64232
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64212: LD_VAR 0 3
64216: PPUSH
64217: LD_EXP 92
64221: PUSH
64222: LD_VAR 0 2
64226: ARRAY
64227: PPUSH
64228: CALL_OW 113
64232: GO 64186
64234: POP
64235: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64236: LD_ADDR_EXP 70
64240: PUSH
64241: LD_EXP 70
64245: PPUSH
64246: LD_VAR 0 2
64250: PPUSH
64251: EMPTY
64252: PPUSH
64253: CALL_OW 1
64257: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64258: LD_VAR 0 2
64262: PPUSH
64263: LD_INT 101
64265: PPUSH
64266: CALL 59124 0 2
// continue ;
64270: GO 64071
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64272: LD_ADDR_EXP 74
64276: PUSH
64277: LD_EXP 74
64281: PPUSH
64282: LD_VAR 0 2
64286: PPUSH
64287: EMPTY
64288: PPUSH
64289: CALL_OW 1
64293: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64294: LD_VAR 0 2
64298: PPUSH
64299: LD_INT 103
64301: PPUSH
64302: CALL 59124 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64306: LD_ADDR_VAR 0 5
64310: PUSH
64311: LD_EXP 68
64315: PUSH
64316: LD_VAR 0 2
64320: ARRAY
64321: PUSH
64322: LD_EXP 97
64326: PUSH
64327: LD_VAR 0 2
64331: ARRAY
64332: UNION
64333: PPUSH
64334: LD_INT 2
64336: PUSH
64337: LD_INT 25
64339: PUSH
64340: LD_INT 2
64342: PUSH
64343: EMPTY
64344: LIST
64345: LIST
64346: PUSH
64347: LD_INT 25
64349: PUSH
64350: LD_INT 16
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: LIST
64361: PUSH
64362: EMPTY
64363: LIST
64364: PPUSH
64365: CALL_OW 72
64369: ST_TO_ADDR
// if mc_need_heal [ i ] then
64370: LD_EXP 71
64374: PUSH
64375: LD_VAR 0 2
64379: ARRAY
64380: IFFALSE 64424
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64382: LD_ADDR_VAR 0 5
64386: PUSH
64387: LD_VAR 0 5
64391: PUSH
64392: LD_EXP 71
64396: PUSH
64397: LD_VAR 0 2
64401: ARRAY
64402: PUSH
64403: LD_INT 1
64405: ARRAY
64406: PUSH
64407: LD_EXP 71
64411: PUSH
64412: LD_VAR 0 2
64416: ARRAY
64417: PUSH
64418: LD_INT 2
64420: ARRAY
64421: UNION
64422: DIFF
64423: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64424: LD_ADDR_VAR 0 6
64428: PUSH
64429: LD_EXP 87
64433: PUSH
64434: LD_VAR 0 2
64438: ARRAY
64439: PPUSH
64440: LD_INT 2
64442: PUSH
64443: LD_INT 34
64445: PUSH
64446: LD_INT 13
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PUSH
64453: LD_INT 34
64455: PUSH
64456: LD_INT 52
64458: PUSH
64459: EMPTY
64460: LIST
64461: LIST
64462: PUSH
64463: LD_INT 34
64465: PUSH
64466: LD_EXP 54
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: PPUSH
64481: CALL_OW 72
64485: ST_TO_ADDR
// if cranes then
64486: LD_VAR 0 6
64490: IFFALSE 64626
// begin for j in cranes do
64492: LD_ADDR_VAR 0 3
64496: PUSH
64497: LD_VAR 0 6
64501: PUSH
64502: FOR_IN
64503: IFFALSE 64624
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64505: LD_VAR 0 3
64509: PPUSH
64510: CALL_OW 256
64514: PUSH
64515: LD_INT 1000
64517: EQUAL
64518: PUSH
64519: LD_VAR 0 3
64523: PPUSH
64524: CALL_OW 314
64528: NOT
64529: AND
64530: IFFALSE 64564
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
64532: LD_VAR 0 3
64536: PPUSH
64537: LD_EXP 69
64541: PUSH
64542: LD_VAR 0 2
64546: ARRAY
64547: PPUSH
64548: LD_VAR 0 3
64552: PPUSH
64553: CALL_OW 74
64557: PPUSH
64558: CALL_OW 130
64562: GO 64622
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64564: LD_VAR 0 3
64568: PPUSH
64569: CALL_OW 256
64573: PUSH
64574: LD_INT 500
64576: LESS
64577: PUSH
64578: LD_VAR 0 3
64582: PPUSH
64583: LD_EXP 92
64587: PUSH
64588: LD_VAR 0 2
64592: ARRAY
64593: PPUSH
64594: CALL_OW 308
64598: NOT
64599: AND
64600: IFFALSE 64622
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64602: LD_VAR 0 3
64606: PPUSH
64607: LD_EXP 92
64611: PUSH
64612: LD_VAR 0 2
64616: ARRAY
64617: PPUSH
64618: CALL_OW 113
// end ;
64622: GO 64502
64624: POP
64625: POP
// end ; if tmp > 3 then
64626: LD_VAR 0 5
64630: PUSH
64631: LD_INT 3
64633: GREATER
64634: IFFALSE 64654
// tmp := ShrinkArray ( tmp , 4 ) ;
64636: LD_ADDR_VAR 0 5
64640: PUSH
64641: LD_VAR 0 5
64645: PPUSH
64646: LD_INT 4
64648: PPUSH
64649: CALL 51310 0 2
64653: ST_TO_ADDR
// if not tmp then
64654: LD_VAR 0 5
64658: NOT
64659: IFFALSE 64663
// continue ;
64661: GO 64071
// for j in tmp do
64663: LD_ADDR_VAR 0 3
64667: PUSH
64668: LD_VAR 0 5
64672: PUSH
64673: FOR_IN
64674: IFFALSE 64933
// begin if IsInUnit ( j ) then
64676: LD_VAR 0 3
64680: PPUSH
64681: CALL_OW 310
64685: IFFALSE 64696
// ComExitBuilding ( j ) ;
64687: LD_VAR 0 3
64691: PPUSH
64692: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64696: LD_VAR 0 3
64700: PUSH
64701: LD_EXP 70
64705: PUSH
64706: LD_VAR 0 2
64710: ARRAY
64711: IN
64712: NOT
64713: IFFALSE 64771
// begin SetTag ( j , 101 ) ;
64715: LD_VAR 0 3
64719: PPUSH
64720: LD_INT 101
64722: PPUSH
64723: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64727: LD_ADDR_EXP 70
64731: PUSH
64732: LD_EXP 70
64736: PPUSH
64737: LD_VAR 0 2
64741: PUSH
64742: LD_EXP 70
64746: PUSH
64747: LD_VAR 0 2
64751: ARRAY
64752: PUSH
64753: LD_INT 1
64755: PLUS
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: PPUSH
64761: LD_VAR 0 3
64765: PPUSH
64766: CALL 18750 0 3
64770: ST_TO_ADDR
// end ; wait ( 1 ) ;
64771: LD_INT 1
64773: PPUSH
64774: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64778: LD_ADDR_VAR 0 7
64782: PUSH
64783: LD_EXP 69
64787: PUSH
64788: LD_VAR 0 2
64792: ARRAY
64793: ST_TO_ADDR
// if mc_scan [ i ] then
64794: LD_EXP 91
64798: PUSH
64799: LD_VAR 0 2
64803: ARRAY
64804: IFFALSE 64866
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64806: LD_ADDR_VAR 0 7
64810: PUSH
64811: LD_EXP 69
64815: PUSH
64816: LD_VAR 0 2
64820: ARRAY
64821: PPUSH
64822: LD_INT 3
64824: PUSH
64825: LD_INT 30
64827: PUSH
64828: LD_INT 32
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: LD_INT 30
64837: PUSH
64838: LD_INT 33
64840: PUSH
64841: EMPTY
64842: LIST
64843: LIST
64844: PUSH
64845: LD_INT 30
64847: PUSH
64848: LD_INT 31
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: PPUSH
64861: CALL_OW 72
64865: ST_TO_ADDR
// if not to_repair_tmp then
64866: LD_VAR 0 7
64870: NOT
64871: IFFALSE 64875
// continue ;
64873: GO 64673
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64875: LD_ADDR_VAR 0 8
64879: PUSH
64880: LD_VAR 0 7
64884: PPUSH
64885: LD_VAR 0 3
64889: PPUSH
64890: CALL_OW 74
64894: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64895: LD_VAR 0 8
64899: PPUSH
64900: LD_INT 16
64902: PPUSH
64903: CALL 21349 0 2
64907: PUSH
64908: LD_INT 4
64910: ARRAY
64911: PUSH
64912: LD_INT 10
64914: LESS
64915: IFFALSE 64931
// ComRepairBuilding ( j , to_repair ) ;
64917: LD_VAR 0 3
64921: PPUSH
64922: LD_VAR 0 8
64926: PPUSH
64927: CALL_OW 130
// end ;
64931: GO 64673
64933: POP
64934: POP
// end ;
64935: GO 64071
64937: POP
64938: POP
// end ;
64939: LD_VAR 0 1
64943: RET
// export function MC_Heal ; var i , j , tmp ; begin
64944: LD_INT 0
64946: PPUSH
64947: PPUSH
64948: PPUSH
64949: PPUSH
// if not mc_bases then
64950: LD_EXP 68
64954: NOT
64955: IFFALSE 64959
// exit ;
64957: GO 65361
// for i = 1 to mc_bases do
64959: LD_ADDR_VAR 0 2
64963: PUSH
64964: DOUBLE
64965: LD_INT 1
64967: DEC
64968: ST_TO_ADDR
64969: LD_EXP 68
64973: PUSH
64974: FOR_TO
64975: IFFALSE 65359
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64977: LD_EXP 71
64981: PUSH
64982: LD_VAR 0 2
64986: ARRAY
64987: PUSH
64988: LD_INT 1
64990: ARRAY
64991: NOT
64992: PUSH
64993: LD_EXP 71
64997: PUSH
64998: LD_VAR 0 2
65002: ARRAY
65003: PUSH
65004: LD_INT 2
65006: ARRAY
65007: NOT
65008: AND
65009: IFFALSE 65047
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65011: LD_ADDR_EXP 72
65015: PUSH
65016: LD_EXP 72
65020: PPUSH
65021: LD_VAR 0 2
65025: PPUSH
65026: EMPTY
65027: PPUSH
65028: CALL_OW 1
65032: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65033: LD_VAR 0 2
65037: PPUSH
65038: LD_INT 102
65040: PPUSH
65041: CALL 59124 0 2
// continue ;
65045: GO 64974
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65047: LD_ADDR_VAR 0 4
65051: PUSH
65052: LD_EXP 68
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: PPUSH
65063: LD_INT 25
65065: PUSH
65066: LD_INT 4
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PPUSH
65073: CALL_OW 72
65077: ST_TO_ADDR
// if not tmp then
65078: LD_VAR 0 4
65082: NOT
65083: IFFALSE 65087
// continue ;
65085: GO 64974
// if mc_taming [ i ] then
65087: LD_EXP 99
65091: PUSH
65092: LD_VAR 0 2
65096: ARRAY
65097: IFFALSE 65121
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65099: LD_ADDR_EXP 99
65103: PUSH
65104: LD_EXP 99
65108: PPUSH
65109: LD_VAR 0 2
65113: PPUSH
65114: EMPTY
65115: PPUSH
65116: CALL_OW 1
65120: ST_TO_ADDR
// for j in tmp do
65121: LD_ADDR_VAR 0 3
65125: PUSH
65126: LD_VAR 0 4
65130: PUSH
65131: FOR_IN
65132: IFFALSE 65355
// begin if IsInUnit ( j ) then
65134: LD_VAR 0 3
65138: PPUSH
65139: CALL_OW 310
65143: IFFALSE 65154
// ComExitBuilding ( j ) ;
65145: LD_VAR 0 3
65149: PPUSH
65150: CALL_OW 122
// if not j in mc_healers [ i ] then
65154: LD_VAR 0 3
65158: PUSH
65159: LD_EXP 72
65163: PUSH
65164: LD_VAR 0 2
65168: ARRAY
65169: IN
65170: NOT
65171: IFFALSE 65217
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65173: LD_ADDR_EXP 72
65177: PUSH
65178: LD_EXP 72
65182: PPUSH
65183: LD_VAR 0 2
65187: PUSH
65188: LD_EXP 72
65192: PUSH
65193: LD_VAR 0 2
65197: ARRAY
65198: PUSH
65199: LD_INT 1
65201: PLUS
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PPUSH
65207: LD_VAR 0 3
65211: PPUSH
65212: CALL 18750 0 3
65216: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65217: LD_VAR 0 3
65221: PPUSH
65222: CALL_OW 110
65226: PUSH
65227: LD_INT 102
65229: NONEQUAL
65230: IFFALSE 65244
// SetTag ( j , 102 ) ;
65232: LD_VAR 0 3
65236: PPUSH
65237: LD_INT 102
65239: PPUSH
65240: CALL_OW 109
// Wait ( 3 ) ;
65244: LD_INT 3
65246: PPUSH
65247: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65251: LD_EXP 71
65255: PUSH
65256: LD_VAR 0 2
65260: ARRAY
65261: PUSH
65262: LD_INT 1
65264: ARRAY
65265: IFFALSE 65297
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65267: LD_VAR 0 3
65271: PPUSH
65272: LD_EXP 71
65276: PUSH
65277: LD_VAR 0 2
65281: ARRAY
65282: PUSH
65283: LD_INT 1
65285: ARRAY
65286: PUSH
65287: LD_INT 1
65289: ARRAY
65290: PPUSH
65291: CALL_OW 128
65295: GO 65353
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65297: LD_VAR 0 3
65301: PPUSH
65302: CALL_OW 314
65306: NOT
65307: PUSH
65308: LD_EXP 71
65312: PUSH
65313: LD_VAR 0 2
65317: ARRAY
65318: PUSH
65319: LD_INT 2
65321: ARRAY
65322: AND
65323: IFFALSE 65353
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65325: LD_VAR 0 3
65329: PPUSH
65330: LD_EXP 71
65334: PUSH
65335: LD_VAR 0 2
65339: ARRAY
65340: PUSH
65341: LD_INT 2
65343: ARRAY
65344: PUSH
65345: LD_INT 1
65347: ARRAY
65348: PPUSH
65349: CALL_OW 128
// end ;
65353: GO 65131
65355: POP
65356: POP
// end ;
65357: GO 64974
65359: POP
65360: POP
// end ;
65361: LD_VAR 0 1
65365: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65366: LD_INT 0
65368: PPUSH
65369: PPUSH
65370: PPUSH
65371: PPUSH
65372: PPUSH
// if not mc_bases then
65373: LD_EXP 68
65377: NOT
65378: IFFALSE 65382
// exit ;
65380: GO 66553
// for i = 1 to mc_bases do
65382: LD_ADDR_VAR 0 2
65386: PUSH
65387: DOUBLE
65388: LD_INT 1
65390: DEC
65391: ST_TO_ADDR
65392: LD_EXP 68
65396: PUSH
65397: FOR_TO
65398: IFFALSE 66551
// begin if mc_scan [ i ] then
65400: LD_EXP 91
65404: PUSH
65405: LD_VAR 0 2
65409: ARRAY
65410: IFFALSE 65414
// continue ;
65412: GO 65397
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65414: LD_EXP 73
65418: PUSH
65419: LD_VAR 0 2
65423: ARRAY
65424: NOT
65425: PUSH
65426: LD_EXP 75
65430: PUSH
65431: LD_VAR 0 2
65435: ARRAY
65436: NOT
65437: AND
65438: PUSH
65439: LD_EXP 74
65443: PUSH
65444: LD_VAR 0 2
65448: ARRAY
65449: AND
65450: IFFALSE 65488
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65452: LD_ADDR_EXP 74
65456: PUSH
65457: LD_EXP 74
65461: PPUSH
65462: LD_VAR 0 2
65466: PPUSH
65467: EMPTY
65468: PPUSH
65469: CALL_OW 1
65473: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65474: LD_VAR 0 2
65478: PPUSH
65479: LD_INT 103
65481: PPUSH
65482: CALL 59124 0 2
// continue ;
65486: GO 65397
// end ; if mc_construct_list [ i ] then
65488: LD_EXP 75
65492: PUSH
65493: LD_VAR 0 2
65497: ARRAY
65498: IFFALSE 65718
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65500: LD_ADDR_VAR 0 4
65504: PUSH
65505: LD_EXP 68
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PPUSH
65516: LD_INT 25
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PPUSH
65526: CALL_OW 72
65530: PUSH
65531: LD_EXP 70
65535: PUSH
65536: LD_VAR 0 2
65540: ARRAY
65541: DIFF
65542: ST_TO_ADDR
// if not tmp then
65543: LD_VAR 0 4
65547: NOT
65548: IFFALSE 65552
// continue ;
65550: GO 65397
// for j in tmp do
65552: LD_ADDR_VAR 0 3
65556: PUSH
65557: LD_VAR 0 4
65561: PUSH
65562: FOR_IN
65563: IFFALSE 65714
// begin if not mc_builders [ i ] then
65565: LD_EXP 74
65569: PUSH
65570: LD_VAR 0 2
65574: ARRAY
65575: NOT
65576: IFFALSE 65634
// begin SetTag ( j , 103 ) ;
65578: LD_VAR 0 3
65582: PPUSH
65583: LD_INT 103
65585: PPUSH
65586: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65590: LD_ADDR_EXP 74
65594: PUSH
65595: LD_EXP 74
65599: PPUSH
65600: LD_VAR 0 2
65604: PUSH
65605: LD_EXP 74
65609: PUSH
65610: LD_VAR 0 2
65614: ARRAY
65615: PUSH
65616: LD_INT 1
65618: PLUS
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PPUSH
65624: LD_VAR 0 3
65628: PPUSH
65629: CALL 18750 0 3
65633: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65634: LD_VAR 0 3
65638: PPUSH
65639: CALL_OW 310
65643: IFFALSE 65654
// ComExitBuilding ( j ) ;
65645: LD_VAR 0 3
65649: PPUSH
65650: CALL_OW 122
// wait ( 3 ) ;
65654: LD_INT 3
65656: PPUSH
65657: CALL_OW 67
// if not mc_construct_list [ i ] then
65661: LD_EXP 75
65665: PUSH
65666: LD_VAR 0 2
65670: ARRAY
65671: NOT
65672: IFFALSE 65676
// break ;
65674: GO 65714
// if not HasTask ( j ) then
65676: LD_VAR 0 3
65680: PPUSH
65681: CALL_OW 314
65685: NOT
65686: IFFALSE 65712
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65688: LD_VAR 0 3
65692: PPUSH
65693: LD_EXP 75
65697: PUSH
65698: LD_VAR 0 2
65702: ARRAY
65703: PUSH
65704: LD_INT 1
65706: ARRAY
65707: PPUSH
65708: CALL 21613 0 2
// end ;
65712: GO 65562
65714: POP
65715: POP
// end else
65716: GO 66549
// if mc_build_list [ i ] then
65718: LD_EXP 73
65722: PUSH
65723: LD_VAR 0 2
65727: ARRAY
65728: IFFALSE 66549
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65730: LD_ADDR_VAR 0 5
65734: PUSH
65735: LD_EXP 68
65739: PUSH
65740: LD_VAR 0 2
65744: ARRAY
65745: PPUSH
65746: LD_INT 2
65748: PUSH
65749: LD_INT 30
65751: PUSH
65752: LD_INT 0
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 30
65761: PUSH
65762: LD_INT 1
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: EMPTY
65770: LIST
65771: LIST
65772: LIST
65773: PPUSH
65774: CALL_OW 72
65778: ST_TO_ADDR
// if depot then
65779: LD_VAR 0 5
65783: IFFALSE 65801
// depot := depot [ 1 ] else
65785: LD_ADDR_VAR 0 5
65789: PUSH
65790: LD_VAR 0 5
65794: PUSH
65795: LD_INT 1
65797: ARRAY
65798: ST_TO_ADDR
65799: GO 65809
// depot := 0 ;
65801: LD_ADDR_VAR 0 5
65805: PUSH
65806: LD_INT 0
65808: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65809: LD_EXP 73
65813: PUSH
65814: LD_VAR 0 2
65818: ARRAY
65819: PUSH
65820: LD_INT 1
65822: ARRAY
65823: PUSH
65824: LD_INT 1
65826: ARRAY
65827: PPUSH
65828: CALL 21437 0 1
65832: PUSH
65833: LD_EXP 68
65837: PUSH
65838: LD_VAR 0 2
65842: ARRAY
65843: PPUSH
65844: LD_INT 2
65846: PUSH
65847: LD_INT 30
65849: PUSH
65850: LD_INT 2
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PUSH
65857: LD_INT 30
65859: PUSH
65860: LD_INT 3
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: LIST
65871: PPUSH
65872: CALL_OW 72
65876: NOT
65877: AND
65878: IFFALSE 65983
// begin for j = 1 to mc_build_list [ i ] do
65880: LD_ADDR_VAR 0 3
65884: PUSH
65885: DOUBLE
65886: LD_INT 1
65888: DEC
65889: ST_TO_ADDR
65890: LD_EXP 73
65894: PUSH
65895: LD_VAR 0 2
65899: ARRAY
65900: PUSH
65901: FOR_TO
65902: IFFALSE 65981
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65904: LD_EXP 73
65908: PUSH
65909: LD_VAR 0 2
65913: ARRAY
65914: PUSH
65915: LD_VAR 0 3
65919: ARRAY
65920: PUSH
65921: LD_INT 1
65923: ARRAY
65924: PUSH
65925: LD_INT 2
65927: EQUAL
65928: IFFALSE 65979
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65930: LD_ADDR_EXP 73
65934: PUSH
65935: LD_EXP 73
65939: PPUSH
65940: LD_VAR 0 2
65944: PPUSH
65945: LD_EXP 73
65949: PUSH
65950: LD_VAR 0 2
65954: ARRAY
65955: PPUSH
65956: LD_VAR 0 3
65960: PPUSH
65961: LD_INT 1
65963: PPUSH
65964: LD_INT 0
65966: PPUSH
65967: CALL 18168 0 4
65971: PPUSH
65972: CALL_OW 1
65976: ST_TO_ADDR
// break ;
65977: GO 65981
// end ;
65979: GO 65901
65981: POP
65982: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65983: LD_EXP 73
65987: PUSH
65988: LD_VAR 0 2
65992: ARRAY
65993: PUSH
65994: LD_INT 1
65996: ARRAY
65997: PUSH
65998: LD_INT 1
66000: ARRAY
66001: PUSH
66002: LD_INT 0
66004: EQUAL
66005: PUSH
66006: LD_VAR 0 5
66010: PUSH
66011: LD_VAR 0 5
66015: PPUSH
66016: LD_EXP 73
66020: PUSH
66021: LD_VAR 0 2
66025: ARRAY
66026: PUSH
66027: LD_INT 1
66029: ARRAY
66030: PUSH
66031: LD_INT 1
66033: ARRAY
66034: PPUSH
66035: LD_EXP 73
66039: PUSH
66040: LD_VAR 0 2
66044: ARRAY
66045: PUSH
66046: LD_INT 1
66048: ARRAY
66049: PUSH
66050: LD_INT 2
66052: ARRAY
66053: PPUSH
66054: LD_EXP 73
66058: PUSH
66059: LD_VAR 0 2
66063: ARRAY
66064: PUSH
66065: LD_INT 1
66067: ARRAY
66068: PUSH
66069: LD_INT 3
66071: ARRAY
66072: PPUSH
66073: LD_EXP 73
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: PUSH
66084: LD_INT 1
66086: ARRAY
66087: PUSH
66088: LD_INT 4
66090: ARRAY
66091: PPUSH
66092: CALL 26853 0 5
66096: AND
66097: OR
66098: IFFALSE 66379
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66100: LD_ADDR_VAR 0 4
66104: PUSH
66105: LD_EXP 68
66109: PUSH
66110: LD_VAR 0 2
66114: ARRAY
66115: PPUSH
66116: LD_INT 25
66118: PUSH
66119: LD_INT 2
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PPUSH
66126: CALL_OW 72
66130: PUSH
66131: LD_EXP 70
66135: PUSH
66136: LD_VAR 0 2
66140: ARRAY
66141: DIFF
66142: ST_TO_ADDR
// if not tmp then
66143: LD_VAR 0 4
66147: NOT
66148: IFFALSE 66152
// continue ;
66150: GO 65397
// for j in tmp do
66152: LD_ADDR_VAR 0 3
66156: PUSH
66157: LD_VAR 0 4
66161: PUSH
66162: FOR_IN
66163: IFFALSE 66375
// begin if not mc_builders [ i ] then
66165: LD_EXP 74
66169: PUSH
66170: LD_VAR 0 2
66174: ARRAY
66175: NOT
66176: IFFALSE 66234
// begin SetTag ( j , 103 ) ;
66178: LD_VAR 0 3
66182: PPUSH
66183: LD_INT 103
66185: PPUSH
66186: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66190: LD_ADDR_EXP 74
66194: PUSH
66195: LD_EXP 74
66199: PPUSH
66200: LD_VAR 0 2
66204: PUSH
66205: LD_EXP 74
66209: PUSH
66210: LD_VAR 0 2
66214: ARRAY
66215: PUSH
66216: LD_INT 1
66218: PLUS
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PPUSH
66224: LD_VAR 0 3
66228: PPUSH
66229: CALL 18750 0 3
66233: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66234: LD_VAR 0 3
66238: PPUSH
66239: CALL_OW 310
66243: IFFALSE 66254
// ComExitBuilding ( j ) ;
66245: LD_VAR 0 3
66249: PPUSH
66250: CALL_OW 122
// wait ( 3 ) ;
66254: LD_INT 3
66256: PPUSH
66257: CALL_OW 67
// if not mc_build_list [ i ] then
66261: LD_EXP 73
66265: PUSH
66266: LD_VAR 0 2
66270: ARRAY
66271: NOT
66272: IFFALSE 66276
// break ;
66274: GO 66375
// if not HasTask ( j ) then
66276: LD_VAR 0 3
66280: PPUSH
66281: CALL_OW 314
66285: NOT
66286: IFFALSE 66373
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66288: LD_VAR 0 3
66292: PPUSH
66293: LD_EXP 73
66297: PUSH
66298: LD_VAR 0 2
66302: ARRAY
66303: PUSH
66304: LD_INT 1
66306: ARRAY
66307: PUSH
66308: LD_INT 1
66310: ARRAY
66311: PPUSH
66312: LD_EXP 73
66316: PUSH
66317: LD_VAR 0 2
66321: ARRAY
66322: PUSH
66323: LD_INT 1
66325: ARRAY
66326: PUSH
66327: LD_INT 2
66329: ARRAY
66330: PPUSH
66331: LD_EXP 73
66335: PUSH
66336: LD_VAR 0 2
66340: ARRAY
66341: PUSH
66342: LD_INT 1
66344: ARRAY
66345: PUSH
66346: LD_INT 3
66348: ARRAY
66349: PPUSH
66350: LD_EXP 73
66354: PUSH
66355: LD_VAR 0 2
66359: ARRAY
66360: PUSH
66361: LD_INT 1
66363: ARRAY
66364: PUSH
66365: LD_INT 4
66367: ARRAY
66368: PPUSH
66369: CALL_OW 145
// end ;
66373: GO 66162
66375: POP
66376: POP
// end else
66377: GO 66549
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66379: LD_EXP 68
66383: PUSH
66384: LD_VAR 0 2
66388: ARRAY
66389: PPUSH
66390: LD_EXP 73
66394: PUSH
66395: LD_VAR 0 2
66399: ARRAY
66400: PUSH
66401: LD_INT 1
66403: ARRAY
66404: PUSH
66405: LD_INT 1
66407: ARRAY
66408: PPUSH
66409: LD_EXP 73
66413: PUSH
66414: LD_VAR 0 2
66418: ARRAY
66419: PUSH
66420: LD_INT 1
66422: ARRAY
66423: PUSH
66424: LD_INT 2
66426: ARRAY
66427: PPUSH
66428: LD_EXP 73
66432: PUSH
66433: LD_VAR 0 2
66437: ARRAY
66438: PUSH
66439: LD_INT 1
66441: ARRAY
66442: PUSH
66443: LD_INT 3
66445: ARRAY
66446: PPUSH
66447: LD_EXP 73
66451: PUSH
66452: LD_VAR 0 2
66456: ARRAY
66457: PUSH
66458: LD_INT 1
66460: ARRAY
66461: PUSH
66462: LD_INT 4
66464: ARRAY
66465: PPUSH
66466: LD_EXP 68
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: PPUSH
66477: LD_INT 21
66479: PUSH
66480: LD_INT 3
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PPUSH
66487: CALL_OW 72
66491: PPUSH
66492: EMPTY
66493: PPUSH
66494: CALL 25603 0 7
66498: NOT
66499: IFFALSE 66549
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66501: LD_ADDR_EXP 73
66505: PUSH
66506: LD_EXP 73
66510: PPUSH
66511: LD_VAR 0 2
66515: PPUSH
66516: LD_EXP 73
66520: PUSH
66521: LD_VAR 0 2
66525: ARRAY
66526: PPUSH
66527: LD_INT 1
66529: PPUSH
66530: LD_INT 1
66532: NEG
66533: PPUSH
66534: LD_INT 0
66536: PPUSH
66537: CALL 18168 0 4
66541: PPUSH
66542: CALL_OW 1
66546: ST_TO_ADDR
// continue ;
66547: GO 65397
// end ; end ; end ;
66549: GO 65397
66551: POP
66552: POP
// end ;
66553: LD_VAR 0 1
66557: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66558: LD_INT 0
66560: PPUSH
66561: PPUSH
66562: PPUSH
66563: PPUSH
66564: PPUSH
66565: PPUSH
// if not mc_bases then
66566: LD_EXP 68
66570: NOT
66571: IFFALSE 66575
// exit ;
66573: GO 67002
// for i = 1 to mc_bases do
66575: LD_ADDR_VAR 0 2
66579: PUSH
66580: DOUBLE
66581: LD_INT 1
66583: DEC
66584: ST_TO_ADDR
66585: LD_EXP 68
66589: PUSH
66590: FOR_TO
66591: IFFALSE 67000
// begin tmp := mc_build_upgrade [ i ] ;
66593: LD_ADDR_VAR 0 4
66597: PUSH
66598: LD_EXP 100
66602: PUSH
66603: LD_VAR 0 2
66607: ARRAY
66608: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66609: LD_ADDR_VAR 0 6
66613: PUSH
66614: LD_EXP 101
66618: PUSH
66619: LD_VAR 0 2
66623: ARRAY
66624: PPUSH
66625: LD_INT 2
66627: PUSH
66628: LD_INT 30
66630: PUSH
66631: LD_INT 6
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: LD_INT 30
66640: PUSH
66641: LD_INT 7
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: LIST
66652: PPUSH
66653: CALL_OW 72
66657: ST_TO_ADDR
// if not tmp and not lab then
66658: LD_VAR 0 4
66662: NOT
66663: PUSH
66664: LD_VAR 0 6
66668: NOT
66669: AND
66670: IFFALSE 66674
// continue ;
66672: GO 66590
// if tmp then
66674: LD_VAR 0 4
66678: IFFALSE 66798
// for j in tmp do
66680: LD_ADDR_VAR 0 3
66684: PUSH
66685: LD_VAR 0 4
66689: PUSH
66690: FOR_IN
66691: IFFALSE 66796
// begin if UpgradeCost ( j ) then
66693: LD_VAR 0 3
66697: PPUSH
66698: CALL 25263 0 1
66702: IFFALSE 66794
// begin ComUpgrade ( j ) ;
66704: LD_VAR 0 3
66708: PPUSH
66709: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66713: LD_ADDR_EXP 100
66717: PUSH
66718: LD_EXP 100
66722: PPUSH
66723: LD_VAR 0 2
66727: PPUSH
66728: LD_EXP 100
66732: PUSH
66733: LD_VAR 0 2
66737: ARRAY
66738: PUSH
66739: LD_VAR 0 3
66743: DIFF
66744: PPUSH
66745: CALL_OW 1
66749: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66750: LD_ADDR_EXP 75
66754: PUSH
66755: LD_EXP 75
66759: PPUSH
66760: LD_VAR 0 2
66764: PUSH
66765: LD_EXP 75
66769: PUSH
66770: LD_VAR 0 2
66774: ARRAY
66775: PUSH
66776: LD_INT 1
66778: PLUS
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PPUSH
66784: LD_VAR 0 3
66788: PPUSH
66789: CALL 18750 0 3
66793: ST_TO_ADDR
// end ; end ;
66794: GO 66690
66796: POP
66797: POP
// if not lab or not mc_lab_upgrade [ i ] then
66798: LD_VAR 0 6
66802: NOT
66803: PUSH
66804: LD_EXP 102
66808: PUSH
66809: LD_VAR 0 2
66813: ARRAY
66814: NOT
66815: OR
66816: IFFALSE 66820
// continue ;
66818: GO 66590
// for j in lab do
66820: LD_ADDR_VAR 0 3
66824: PUSH
66825: LD_VAR 0 6
66829: PUSH
66830: FOR_IN
66831: IFFALSE 66996
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66833: LD_VAR 0 3
66837: PPUSH
66838: CALL_OW 266
66842: PUSH
66843: LD_INT 6
66845: PUSH
66846: LD_INT 7
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: IN
66853: PUSH
66854: LD_VAR 0 3
66858: PPUSH
66859: CALL_OW 461
66863: PUSH
66864: LD_INT 1
66866: NONEQUAL
66867: AND
66868: IFFALSE 66994
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66870: LD_VAR 0 3
66874: PPUSH
66875: LD_EXP 102
66879: PUSH
66880: LD_VAR 0 2
66884: ARRAY
66885: PUSH
66886: LD_INT 1
66888: ARRAY
66889: PPUSH
66890: CALL 25468 0 2
66894: IFFALSE 66994
// begin ComCancel ( j ) ;
66896: LD_VAR 0 3
66900: PPUSH
66901: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66905: LD_VAR 0 3
66909: PPUSH
66910: LD_EXP 102
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PUSH
66921: LD_INT 1
66923: ARRAY
66924: PPUSH
66925: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66929: LD_VAR 0 3
66933: PUSH
66934: LD_EXP 75
66938: PUSH
66939: LD_VAR 0 2
66943: ARRAY
66944: IN
66945: NOT
66946: IFFALSE 66992
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66948: LD_ADDR_EXP 75
66952: PUSH
66953: LD_EXP 75
66957: PPUSH
66958: LD_VAR 0 2
66962: PUSH
66963: LD_EXP 75
66967: PUSH
66968: LD_VAR 0 2
66972: ARRAY
66973: PUSH
66974: LD_INT 1
66976: PLUS
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PPUSH
66982: LD_VAR 0 3
66986: PPUSH
66987: CALL 18750 0 3
66991: ST_TO_ADDR
// break ;
66992: GO 66996
// end ; end ; end ;
66994: GO 66830
66996: POP
66997: POP
// end ;
66998: GO 66590
67000: POP
67001: POP
// end ;
67002: LD_VAR 0 1
67006: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67007: LD_INT 0
67009: PPUSH
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
// if not mc_bases then
67018: LD_EXP 68
67022: NOT
67023: IFFALSE 67027
// exit ;
67025: GO 67432
// for i = 1 to mc_bases do
67027: LD_ADDR_VAR 0 2
67031: PUSH
67032: DOUBLE
67033: LD_INT 1
67035: DEC
67036: ST_TO_ADDR
67037: LD_EXP 68
67041: PUSH
67042: FOR_TO
67043: IFFALSE 67430
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67045: LD_EXP 76
67049: PUSH
67050: LD_VAR 0 2
67054: ARRAY
67055: NOT
67056: PUSH
67057: LD_EXP 68
67061: PUSH
67062: LD_VAR 0 2
67066: ARRAY
67067: PPUSH
67068: LD_INT 30
67070: PUSH
67071: LD_INT 3
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PPUSH
67078: CALL_OW 72
67082: NOT
67083: OR
67084: IFFALSE 67088
// continue ;
67086: GO 67042
// busy := false ;
67088: LD_ADDR_VAR 0 8
67092: PUSH
67093: LD_INT 0
67095: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67096: LD_ADDR_VAR 0 4
67100: PUSH
67101: LD_EXP 68
67105: PUSH
67106: LD_VAR 0 2
67110: ARRAY
67111: PPUSH
67112: LD_INT 30
67114: PUSH
67115: LD_INT 3
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PPUSH
67122: CALL_OW 72
67126: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67127: LD_ADDR_VAR 0 6
67131: PUSH
67132: LD_EXP 76
67136: PUSH
67137: LD_VAR 0 2
67141: ARRAY
67142: PPUSH
67143: LD_INT 2
67145: PUSH
67146: LD_INT 30
67148: PUSH
67149: LD_INT 32
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 30
67158: PUSH
67159: LD_INT 33
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: LIST
67170: PPUSH
67171: CALL_OW 72
67175: ST_TO_ADDR
// if not t then
67176: LD_VAR 0 6
67180: NOT
67181: IFFALSE 67185
// continue ;
67183: GO 67042
// for j in tmp do
67185: LD_ADDR_VAR 0 3
67189: PUSH
67190: LD_VAR 0 4
67194: PUSH
67195: FOR_IN
67196: IFFALSE 67226
// if not BuildingStatus ( j ) = bs_idle then
67198: LD_VAR 0 3
67202: PPUSH
67203: CALL_OW 461
67207: PUSH
67208: LD_INT 2
67210: EQUAL
67211: NOT
67212: IFFALSE 67224
// begin busy := true ;
67214: LD_ADDR_VAR 0 8
67218: PUSH
67219: LD_INT 1
67221: ST_TO_ADDR
// break ;
67222: GO 67226
// end ;
67224: GO 67195
67226: POP
67227: POP
// if busy then
67228: LD_VAR 0 8
67232: IFFALSE 67236
// continue ;
67234: GO 67042
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67236: LD_ADDR_VAR 0 7
67240: PUSH
67241: LD_VAR 0 6
67245: PPUSH
67246: LD_INT 35
67248: PUSH
67249: LD_INT 0
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PPUSH
67256: CALL_OW 72
67260: ST_TO_ADDR
// if tw then
67261: LD_VAR 0 7
67265: IFFALSE 67342
// begin tw := tw [ 1 ] ;
67267: LD_ADDR_VAR 0 7
67271: PUSH
67272: LD_VAR 0 7
67276: PUSH
67277: LD_INT 1
67279: ARRAY
67280: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67281: LD_ADDR_VAR 0 9
67285: PUSH
67286: LD_VAR 0 7
67290: PPUSH
67291: LD_EXP 93
67295: PUSH
67296: LD_VAR 0 2
67300: ARRAY
67301: PPUSH
67302: CALL 23760 0 2
67306: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67307: LD_EXP 107
67311: PUSH
67312: LD_VAR 0 2
67316: ARRAY
67317: IFFALSE 67340
// if not weapon in mc_allowed_tower_weapons [ i ] then
67319: LD_VAR 0 9
67323: PUSH
67324: LD_EXP 107
67328: PUSH
67329: LD_VAR 0 2
67333: ARRAY
67334: IN
67335: NOT
67336: IFFALSE 67340
// continue ;
67338: GO 67042
// end else
67340: GO 67405
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67342: LD_ADDR_VAR 0 5
67346: PUSH
67347: LD_EXP 76
67351: PUSH
67352: LD_VAR 0 2
67356: ARRAY
67357: PPUSH
67358: LD_VAR 0 4
67362: PPUSH
67363: CALL 50543 0 2
67367: ST_TO_ADDR
// if not tmp2 then
67368: LD_VAR 0 5
67372: NOT
67373: IFFALSE 67377
// continue ;
67375: GO 67042
// tw := tmp2 [ 1 ] ;
67377: LD_ADDR_VAR 0 7
67381: PUSH
67382: LD_VAR 0 5
67386: PUSH
67387: LD_INT 1
67389: ARRAY
67390: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67391: LD_ADDR_VAR 0 9
67395: PUSH
67396: LD_VAR 0 5
67400: PUSH
67401: LD_INT 2
67403: ARRAY
67404: ST_TO_ADDR
// end ; if not weapon then
67405: LD_VAR 0 9
67409: NOT
67410: IFFALSE 67414
// continue ;
67412: GO 67042
// ComPlaceWeapon ( tw , weapon ) ;
67414: LD_VAR 0 7
67418: PPUSH
67419: LD_VAR 0 9
67423: PPUSH
67424: CALL_OW 148
// end ;
67428: GO 67042
67430: POP
67431: POP
// end ;
67432: LD_VAR 0 1
67436: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67437: LD_INT 0
67439: PPUSH
67440: PPUSH
67441: PPUSH
67442: PPUSH
67443: PPUSH
67444: PPUSH
67445: PPUSH
// if not mc_bases then
67446: LD_EXP 68
67450: NOT
67451: IFFALSE 67455
// exit ;
67453: GO 68223
// for i = 1 to mc_bases do
67455: LD_ADDR_VAR 0 2
67459: PUSH
67460: DOUBLE
67461: LD_INT 1
67463: DEC
67464: ST_TO_ADDR
67465: LD_EXP 68
67469: PUSH
67470: FOR_TO
67471: IFFALSE 68221
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67473: LD_EXP 81
67477: PUSH
67478: LD_VAR 0 2
67482: ARRAY
67483: NOT
67484: PUSH
67485: LD_EXP 81
67489: PUSH
67490: LD_VAR 0 2
67494: ARRAY
67495: PUSH
67496: LD_EXP 82
67500: PUSH
67501: LD_VAR 0 2
67505: ARRAY
67506: EQUAL
67507: OR
67508: PUSH
67509: LD_EXP 91
67513: PUSH
67514: LD_VAR 0 2
67518: ARRAY
67519: OR
67520: IFFALSE 67524
// continue ;
67522: GO 67470
// if mc_miners [ i ] then
67524: LD_EXP 82
67528: PUSH
67529: LD_VAR 0 2
67533: ARRAY
67534: IFFALSE 67908
// begin for j = mc_miners [ i ] downto 1 do
67536: LD_ADDR_VAR 0 3
67540: PUSH
67541: DOUBLE
67542: LD_EXP 82
67546: PUSH
67547: LD_VAR 0 2
67551: ARRAY
67552: INC
67553: ST_TO_ADDR
67554: LD_INT 1
67556: PUSH
67557: FOR_DOWNTO
67558: IFFALSE 67906
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67560: LD_EXP 82
67564: PUSH
67565: LD_VAR 0 2
67569: ARRAY
67570: PUSH
67571: LD_VAR 0 3
67575: ARRAY
67576: PPUSH
67577: CALL_OW 301
67581: PUSH
67582: LD_EXP 82
67586: PUSH
67587: LD_VAR 0 2
67591: ARRAY
67592: PUSH
67593: LD_VAR 0 3
67597: ARRAY
67598: PPUSH
67599: CALL_OW 257
67603: PUSH
67604: LD_INT 1
67606: NONEQUAL
67607: OR
67608: IFFALSE 67671
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67610: LD_ADDR_VAR 0 5
67614: PUSH
67615: LD_EXP 82
67619: PUSH
67620: LD_VAR 0 2
67624: ARRAY
67625: PUSH
67626: LD_EXP 82
67630: PUSH
67631: LD_VAR 0 2
67635: ARRAY
67636: PUSH
67637: LD_VAR 0 3
67641: ARRAY
67642: DIFF
67643: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67644: LD_ADDR_EXP 82
67648: PUSH
67649: LD_EXP 82
67653: PPUSH
67654: LD_VAR 0 2
67658: PPUSH
67659: LD_VAR 0 5
67663: PPUSH
67664: CALL_OW 1
67668: ST_TO_ADDR
// continue ;
67669: GO 67557
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67671: LD_EXP 82
67675: PUSH
67676: LD_VAR 0 2
67680: ARRAY
67681: PUSH
67682: LD_VAR 0 3
67686: ARRAY
67687: PPUSH
67688: CALL_OW 257
67692: PUSH
67693: LD_INT 1
67695: EQUAL
67696: PUSH
67697: LD_EXP 82
67701: PUSH
67702: LD_VAR 0 2
67706: ARRAY
67707: PUSH
67708: LD_VAR 0 3
67712: ARRAY
67713: PPUSH
67714: CALL_OW 459
67718: NOT
67719: AND
67720: PUSH
67721: LD_EXP 82
67725: PUSH
67726: LD_VAR 0 2
67730: ARRAY
67731: PUSH
67732: LD_VAR 0 3
67736: ARRAY
67737: PPUSH
67738: CALL_OW 314
67742: NOT
67743: AND
67744: IFFALSE 67904
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67746: LD_EXP 82
67750: PUSH
67751: LD_VAR 0 2
67755: ARRAY
67756: PUSH
67757: LD_VAR 0 3
67761: ARRAY
67762: PPUSH
67763: CALL_OW 310
67767: IFFALSE 67790
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67769: LD_EXP 82
67773: PUSH
67774: LD_VAR 0 2
67778: ARRAY
67779: PUSH
67780: LD_VAR 0 3
67784: ARRAY
67785: PPUSH
67786: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67790: LD_EXP 82
67794: PUSH
67795: LD_VAR 0 2
67799: ARRAY
67800: PUSH
67801: LD_VAR 0 3
67805: ARRAY
67806: PPUSH
67807: CALL_OW 314
67811: NOT
67812: IFFALSE 67904
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67814: LD_ADDR_VAR 0 7
67818: PUSH
67819: LD_INT 1
67821: PPUSH
67822: LD_EXP 81
67826: PUSH
67827: LD_VAR 0 2
67831: ARRAY
67832: PPUSH
67833: CALL_OW 12
67837: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67838: LD_EXP 82
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: PUSH
67849: LD_VAR 0 3
67853: ARRAY
67854: PPUSH
67855: LD_EXP 81
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: PUSH
67866: LD_VAR 0 7
67870: ARRAY
67871: PUSH
67872: LD_INT 1
67874: ARRAY
67875: PPUSH
67876: LD_EXP 81
67880: PUSH
67881: LD_VAR 0 2
67885: ARRAY
67886: PUSH
67887: LD_VAR 0 7
67891: ARRAY
67892: PUSH
67893: LD_INT 2
67895: ARRAY
67896: PPUSH
67897: LD_INT 0
67899: PPUSH
67900: CALL_OW 193
// end ; end ; end ;
67904: GO 67557
67906: POP
67907: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67908: LD_ADDR_VAR 0 5
67912: PUSH
67913: LD_EXP 68
67917: PUSH
67918: LD_VAR 0 2
67922: ARRAY
67923: PPUSH
67924: LD_INT 2
67926: PUSH
67927: LD_INT 30
67929: PUSH
67930: LD_INT 4
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 30
67939: PUSH
67940: LD_INT 5
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 30
67949: PUSH
67950: LD_INT 32
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: PPUSH
67963: CALL_OW 72
67967: ST_TO_ADDR
// if not tmp then
67968: LD_VAR 0 5
67972: NOT
67973: IFFALSE 67977
// continue ;
67975: GO 67470
// list := [ ] ;
67977: LD_ADDR_VAR 0 6
67981: PUSH
67982: EMPTY
67983: ST_TO_ADDR
// for j in tmp do
67984: LD_ADDR_VAR 0 3
67988: PUSH
67989: LD_VAR 0 5
67993: PUSH
67994: FOR_IN
67995: IFFALSE 68064
// begin for k in UnitsInside ( j ) do
67997: LD_ADDR_VAR 0 4
68001: PUSH
68002: LD_VAR 0 3
68006: PPUSH
68007: CALL_OW 313
68011: PUSH
68012: FOR_IN
68013: IFFALSE 68060
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68015: LD_VAR 0 4
68019: PPUSH
68020: CALL_OW 257
68024: PUSH
68025: LD_INT 1
68027: EQUAL
68028: PUSH
68029: LD_VAR 0 4
68033: PPUSH
68034: CALL_OW 459
68038: NOT
68039: AND
68040: IFFALSE 68058
// list := list ^ k ;
68042: LD_ADDR_VAR 0 6
68046: PUSH
68047: LD_VAR 0 6
68051: PUSH
68052: LD_VAR 0 4
68056: ADD
68057: ST_TO_ADDR
68058: GO 68012
68060: POP
68061: POP
// end ;
68062: GO 67994
68064: POP
68065: POP
// list := list diff mc_miners [ i ] ;
68066: LD_ADDR_VAR 0 6
68070: PUSH
68071: LD_VAR 0 6
68075: PUSH
68076: LD_EXP 82
68080: PUSH
68081: LD_VAR 0 2
68085: ARRAY
68086: DIFF
68087: ST_TO_ADDR
// if not list then
68088: LD_VAR 0 6
68092: NOT
68093: IFFALSE 68097
// continue ;
68095: GO 67470
// k := mc_mines [ i ] - mc_miners [ i ] ;
68097: LD_ADDR_VAR 0 4
68101: PUSH
68102: LD_EXP 81
68106: PUSH
68107: LD_VAR 0 2
68111: ARRAY
68112: PUSH
68113: LD_EXP 82
68117: PUSH
68118: LD_VAR 0 2
68122: ARRAY
68123: MINUS
68124: ST_TO_ADDR
// if k > list then
68125: LD_VAR 0 4
68129: PUSH
68130: LD_VAR 0 6
68134: GREATER
68135: IFFALSE 68147
// k := list ;
68137: LD_ADDR_VAR 0 4
68141: PUSH
68142: LD_VAR 0 6
68146: ST_TO_ADDR
// for j = 1 to k do
68147: LD_ADDR_VAR 0 3
68151: PUSH
68152: DOUBLE
68153: LD_INT 1
68155: DEC
68156: ST_TO_ADDR
68157: LD_VAR 0 4
68161: PUSH
68162: FOR_TO
68163: IFFALSE 68217
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68165: LD_ADDR_EXP 82
68169: PUSH
68170: LD_EXP 82
68174: PPUSH
68175: LD_VAR 0 2
68179: PUSH
68180: LD_EXP 82
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: PUSH
68191: LD_INT 1
68193: PLUS
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PPUSH
68199: LD_VAR 0 6
68203: PUSH
68204: LD_VAR 0 3
68208: ARRAY
68209: PPUSH
68210: CALL 18750 0 3
68214: ST_TO_ADDR
68215: GO 68162
68217: POP
68218: POP
// end ;
68219: GO 67470
68221: POP
68222: POP
// end ;
68223: LD_VAR 0 1
68227: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68228: LD_INT 0
68230: PPUSH
68231: PPUSH
68232: PPUSH
68233: PPUSH
68234: PPUSH
68235: PPUSH
68236: PPUSH
68237: PPUSH
68238: PPUSH
68239: PPUSH
68240: PPUSH
// if not mc_bases then
68241: LD_EXP 68
68245: NOT
68246: IFFALSE 68250
// exit ;
68248: GO 70073
// for i = 1 to mc_bases do
68250: LD_ADDR_VAR 0 2
68254: PUSH
68255: DOUBLE
68256: LD_INT 1
68258: DEC
68259: ST_TO_ADDR
68260: LD_EXP 68
68264: PUSH
68265: FOR_TO
68266: IFFALSE 70071
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68268: LD_EXP 68
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: NOT
68279: PUSH
68280: LD_EXP 75
68284: PUSH
68285: LD_VAR 0 2
68289: ARRAY
68290: OR
68291: IFFALSE 68295
// continue ;
68293: GO 68265
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68295: LD_EXP 84
68299: PUSH
68300: LD_VAR 0 2
68304: ARRAY
68305: NOT
68306: PUSH
68307: LD_EXP 85
68311: PUSH
68312: LD_VAR 0 2
68316: ARRAY
68317: AND
68318: IFFALSE 68356
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68320: LD_ADDR_EXP 85
68324: PUSH
68325: LD_EXP 85
68329: PPUSH
68330: LD_VAR 0 2
68334: PPUSH
68335: EMPTY
68336: PPUSH
68337: CALL_OW 1
68341: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68342: LD_VAR 0 2
68346: PPUSH
68347: LD_INT 107
68349: PPUSH
68350: CALL 59124 0 2
// continue ;
68354: GO 68265
// end ; target := [ ] ;
68356: LD_ADDR_VAR 0 7
68360: PUSH
68361: EMPTY
68362: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68363: LD_ADDR_VAR 0 6
68367: PUSH
68368: LD_EXP 68
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: PUSH
68379: LD_INT 1
68381: ARRAY
68382: PPUSH
68383: CALL_OW 255
68387: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68388: LD_ADDR_VAR 0 9
68392: PUSH
68393: LD_EXP 68
68397: PUSH
68398: LD_VAR 0 2
68402: ARRAY
68403: PPUSH
68404: LD_INT 2
68406: PUSH
68407: LD_INT 30
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PUSH
68417: LD_INT 30
68419: PUSH
68420: LD_INT 1
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: LIST
68431: PPUSH
68432: CALL_OW 72
68436: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68437: LD_ADDR_VAR 0 3
68441: PUSH
68442: DOUBLE
68443: LD_EXP 84
68447: PUSH
68448: LD_VAR 0 2
68452: ARRAY
68453: INC
68454: ST_TO_ADDR
68455: LD_INT 1
68457: PUSH
68458: FOR_DOWNTO
68459: IFFALSE 68704
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68461: LD_EXP 84
68465: PUSH
68466: LD_VAR 0 2
68470: ARRAY
68471: PUSH
68472: LD_VAR 0 3
68476: ARRAY
68477: PUSH
68478: LD_INT 2
68480: ARRAY
68481: PPUSH
68482: LD_EXP 84
68486: PUSH
68487: LD_VAR 0 2
68491: ARRAY
68492: PUSH
68493: LD_VAR 0 3
68497: ARRAY
68498: PUSH
68499: LD_INT 3
68501: ARRAY
68502: PPUSH
68503: CALL_OW 488
68507: PUSH
68508: LD_EXP 84
68512: PUSH
68513: LD_VAR 0 2
68517: ARRAY
68518: PUSH
68519: LD_VAR 0 3
68523: ARRAY
68524: PUSH
68525: LD_INT 2
68527: ARRAY
68528: PPUSH
68529: LD_EXP 84
68533: PUSH
68534: LD_VAR 0 2
68538: ARRAY
68539: PUSH
68540: LD_VAR 0 3
68544: ARRAY
68545: PUSH
68546: LD_INT 3
68548: ARRAY
68549: PPUSH
68550: CALL_OW 284
68554: PUSH
68555: LD_INT 0
68557: EQUAL
68558: AND
68559: IFFALSE 68614
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68561: LD_ADDR_VAR 0 5
68565: PUSH
68566: LD_EXP 84
68570: PUSH
68571: LD_VAR 0 2
68575: ARRAY
68576: PPUSH
68577: LD_VAR 0 3
68581: PPUSH
68582: CALL_OW 3
68586: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68587: LD_ADDR_EXP 84
68591: PUSH
68592: LD_EXP 84
68596: PPUSH
68597: LD_VAR 0 2
68601: PPUSH
68602: LD_VAR 0 5
68606: PPUSH
68607: CALL_OW 1
68611: ST_TO_ADDR
// continue ;
68612: GO 68458
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68614: LD_VAR 0 6
68618: PPUSH
68619: LD_EXP 84
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: PUSH
68630: LD_VAR 0 3
68634: ARRAY
68635: PUSH
68636: LD_INT 2
68638: ARRAY
68639: PPUSH
68640: LD_EXP 84
68644: PUSH
68645: LD_VAR 0 2
68649: ARRAY
68650: PUSH
68651: LD_VAR 0 3
68655: ARRAY
68656: PUSH
68657: LD_INT 3
68659: ARRAY
68660: PPUSH
68661: LD_INT 30
68663: PPUSH
68664: CALL 19646 0 4
68668: PUSH
68669: LD_INT 4
68671: ARRAY
68672: PUSH
68673: LD_INT 0
68675: EQUAL
68676: IFFALSE 68702
// begin target := mc_crates [ i ] [ j ] ;
68678: LD_ADDR_VAR 0 7
68682: PUSH
68683: LD_EXP 84
68687: PUSH
68688: LD_VAR 0 2
68692: ARRAY
68693: PUSH
68694: LD_VAR 0 3
68698: ARRAY
68699: ST_TO_ADDR
// break ;
68700: GO 68704
// end ; end ;
68702: GO 68458
68704: POP
68705: POP
// if not target then
68706: LD_VAR 0 7
68710: NOT
68711: IFFALSE 68715
// continue ;
68713: GO 68265
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68715: LD_ADDR_VAR 0 8
68719: PUSH
68720: LD_EXP 87
68724: PUSH
68725: LD_VAR 0 2
68729: ARRAY
68730: PPUSH
68731: LD_INT 2
68733: PUSH
68734: LD_INT 3
68736: PUSH
68737: LD_INT 58
68739: PUSH
68740: EMPTY
68741: LIST
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 61
68749: PUSH
68750: EMPTY
68751: LIST
68752: PUSH
68753: LD_INT 33
68755: PUSH
68756: LD_INT 5
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 33
68765: PUSH
68766: LD_INT 3
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: LD_INT 34
68785: PUSH
68786: LD_INT 32
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 34
68795: PUSH
68796: LD_INT 51
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 34
68805: PUSH
68806: LD_INT 12
68808: PUSH
68809: EMPTY
68810: LIST
68811: LIST
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: LIST
68817: LIST
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PPUSH
68823: CALL_OW 72
68827: ST_TO_ADDR
// if not cargo then
68828: LD_VAR 0 8
68832: NOT
68833: IFFALSE 69539
// begin if mc_crates_collector [ i ] < 5 then
68835: LD_EXP 85
68839: PUSH
68840: LD_VAR 0 2
68844: ARRAY
68845: PUSH
68846: LD_INT 5
68848: LESS
68849: IFFALSE 69215
// begin if mc_ape [ i ] then
68851: LD_EXP 97
68855: PUSH
68856: LD_VAR 0 2
68860: ARRAY
68861: IFFALSE 68908
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68863: LD_ADDR_VAR 0 5
68867: PUSH
68868: LD_EXP 97
68872: PUSH
68873: LD_VAR 0 2
68877: ARRAY
68878: PPUSH
68879: LD_INT 25
68881: PUSH
68882: LD_INT 16
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 24
68891: PUSH
68892: LD_INT 750
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PPUSH
68903: CALL_OW 72
68907: ST_TO_ADDR
// if not tmp then
68908: LD_VAR 0 5
68912: NOT
68913: IFFALSE 68960
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68915: LD_ADDR_VAR 0 5
68919: PUSH
68920: LD_EXP 68
68924: PUSH
68925: LD_VAR 0 2
68929: ARRAY
68930: PPUSH
68931: LD_INT 25
68933: PUSH
68934: LD_INT 2
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 24
68943: PUSH
68944: LD_INT 750
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PPUSH
68955: CALL_OW 72
68959: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68960: LD_EXP 97
68964: PUSH
68965: LD_VAR 0 2
68969: ARRAY
68970: PUSH
68971: LD_EXP 68
68975: PUSH
68976: LD_VAR 0 2
68980: ARRAY
68981: PPUSH
68982: LD_INT 25
68984: PUSH
68985: LD_INT 2
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 24
68994: PUSH
68995: LD_INT 750
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PPUSH
69006: CALL_OW 72
69010: AND
69011: PUSH
69012: LD_VAR 0 5
69016: PUSH
69017: LD_INT 5
69019: LESS
69020: AND
69021: IFFALSE 69103
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69023: LD_ADDR_VAR 0 3
69027: PUSH
69028: LD_EXP 68
69032: PUSH
69033: LD_VAR 0 2
69037: ARRAY
69038: PPUSH
69039: LD_INT 25
69041: PUSH
69042: LD_INT 2
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 24
69051: PUSH
69052: LD_INT 750
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PPUSH
69063: CALL_OW 72
69067: PUSH
69068: FOR_IN
69069: IFFALSE 69101
// begin tmp := tmp union j ;
69071: LD_ADDR_VAR 0 5
69075: PUSH
69076: LD_VAR 0 5
69080: PUSH
69081: LD_VAR 0 3
69085: UNION
69086: ST_TO_ADDR
// if tmp >= 5 then
69087: LD_VAR 0 5
69091: PUSH
69092: LD_INT 5
69094: GREATEREQUAL
69095: IFFALSE 69099
// break ;
69097: GO 69101
// end ;
69099: GO 69068
69101: POP
69102: POP
// end ; if not tmp then
69103: LD_VAR 0 5
69107: NOT
69108: IFFALSE 69112
// continue ;
69110: GO 68265
// for j in tmp do
69112: LD_ADDR_VAR 0 3
69116: PUSH
69117: LD_VAR 0 5
69121: PUSH
69122: FOR_IN
69123: IFFALSE 69213
// if not GetTag ( j ) then
69125: LD_VAR 0 3
69129: PPUSH
69130: CALL_OW 110
69134: NOT
69135: IFFALSE 69211
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69137: LD_ADDR_EXP 85
69141: PUSH
69142: LD_EXP 85
69146: PPUSH
69147: LD_VAR 0 2
69151: PUSH
69152: LD_EXP 85
69156: PUSH
69157: LD_VAR 0 2
69161: ARRAY
69162: PUSH
69163: LD_INT 1
69165: PLUS
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PPUSH
69171: LD_VAR 0 3
69175: PPUSH
69176: CALL 18750 0 3
69180: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69181: LD_VAR 0 3
69185: PPUSH
69186: LD_INT 107
69188: PPUSH
69189: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69193: LD_EXP 85
69197: PUSH
69198: LD_VAR 0 2
69202: ARRAY
69203: PUSH
69204: LD_INT 5
69206: GREATEREQUAL
69207: IFFALSE 69211
// break ;
69209: GO 69213
// end ;
69211: GO 69122
69213: POP
69214: POP
// end ; if mc_crates_collector [ i ] and target then
69215: LD_EXP 85
69219: PUSH
69220: LD_VAR 0 2
69224: ARRAY
69225: PUSH
69226: LD_VAR 0 7
69230: AND
69231: IFFALSE 69537
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69233: LD_EXP 85
69237: PUSH
69238: LD_VAR 0 2
69242: ARRAY
69243: PUSH
69244: LD_VAR 0 7
69248: PUSH
69249: LD_INT 1
69251: ARRAY
69252: LESS
69253: IFFALSE 69273
// tmp := mc_crates_collector [ i ] else
69255: LD_ADDR_VAR 0 5
69259: PUSH
69260: LD_EXP 85
69264: PUSH
69265: LD_VAR 0 2
69269: ARRAY
69270: ST_TO_ADDR
69271: GO 69287
// tmp := target [ 1 ] ;
69273: LD_ADDR_VAR 0 5
69277: PUSH
69278: LD_VAR 0 7
69282: PUSH
69283: LD_INT 1
69285: ARRAY
69286: ST_TO_ADDR
// k := 0 ;
69287: LD_ADDR_VAR 0 4
69291: PUSH
69292: LD_INT 0
69294: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69295: LD_ADDR_VAR 0 3
69299: PUSH
69300: LD_EXP 85
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: PUSH
69311: FOR_IN
69312: IFFALSE 69535
// begin k := k + 1 ;
69314: LD_ADDR_VAR 0 4
69318: PUSH
69319: LD_VAR 0 4
69323: PUSH
69324: LD_INT 1
69326: PLUS
69327: ST_TO_ADDR
// if k > tmp then
69328: LD_VAR 0 4
69332: PUSH
69333: LD_VAR 0 5
69337: GREATER
69338: IFFALSE 69342
// break ;
69340: GO 69535
// if not GetClass ( j ) in [ 2 , 16 ] then
69342: LD_VAR 0 3
69346: PPUSH
69347: CALL_OW 257
69351: PUSH
69352: LD_INT 2
69354: PUSH
69355: LD_INT 16
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: IN
69362: NOT
69363: IFFALSE 69416
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69365: LD_ADDR_EXP 85
69369: PUSH
69370: LD_EXP 85
69374: PPUSH
69375: LD_VAR 0 2
69379: PPUSH
69380: LD_EXP 85
69384: PUSH
69385: LD_VAR 0 2
69389: ARRAY
69390: PUSH
69391: LD_VAR 0 3
69395: DIFF
69396: PPUSH
69397: CALL_OW 1
69401: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69402: LD_VAR 0 3
69406: PPUSH
69407: LD_INT 0
69409: PPUSH
69410: CALL_OW 109
// continue ;
69414: GO 69311
// end ; if IsInUnit ( j ) then
69416: LD_VAR 0 3
69420: PPUSH
69421: CALL_OW 310
69425: IFFALSE 69436
// ComExitBuilding ( j ) ;
69427: LD_VAR 0 3
69431: PPUSH
69432: CALL_OW 122
// wait ( 3 ) ;
69436: LD_INT 3
69438: PPUSH
69439: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69443: LD_VAR 0 3
69447: PPUSH
69448: CALL_OW 314
69452: PUSH
69453: LD_VAR 0 6
69457: PPUSH
69458: LD_VAR 0 7
69462: PUSH
69463: LD_INT 2
69465: ARRAY
69466: PPUSH
69467: LD_VAR 0 7
69471: PUSH
69472: LD_INT 3
69474: ARRAY
69475: PPUSH
69476: LD_INT 30
69478: PPUSH
69479: CALL 19646 0 4
69483: PUSH
69484: LD_INT 4
69486: ARRAY
69487: AND
69488: IFFALSE 69506
// ComStandNearbyBuilding ( j , depot ) else
69490: LD_VAR 0 3
69494: PPUSH
69495: LD_VAR 0 9
69499: PPUSH
69500: CALL 15175 0 2
69504: GO 69533
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69506: LD_VAR 0 3
69510: PPUSH
69511: LD_VAR 0 7
69515: PUSH
69516: LD_INT 2
69518: ARRAY
69519: PPUSH
69520: LD_VAR 0 7
69524: PUSH
69525: LD_INT 3
69527: ARRAY
69528: PPUSH
69529: CALL_OW 117
// end ;
69533: GO 69311
69535: POP
69536: POP
// end ; end else
69537: GO 70069
// begin for j in cargo do
69539: LD_ADDR_VAR 0 3
69543: PUSH
69544: LD_VAR 0 8
69548: PUSH
69549: FOR_IN
69550: IFFALSE 70067
// begin if GetTag ( j ) <> 0 then
69552: LD_VAR 0 3
69556: PPUSH
69557: CALL_OW 110
69561: PUSH
69562: LD_INT 0
69564: NONEQUAL
69565: IFFALSE 69569
// continue ;
69567: GO 69549
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL_OW 256
69578: PUSH
69579: LD_INT 1000
69581: LESS
69582: PUSH
69583: LD_VAR 0 3
69587: PPUSH
69588: LD_EXP 92
69592: PUSH
69593: LD_VAR 0 2
69597: ARRAY
69598: PPUSH
69599: CALL_OW 308
69603: NOT
69604: AND
69605: IFFALSE 69627
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69607: LD_VAR 0 3
69611: PPUSH
69612: LD_EXP 92
69616: PUSH
69617: LD_VAR 0 2
69621: ARRAY
69622: PPUSH
69623: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69627: LD_VAR 0 3
69631: PPUSH
69632: CALL_OW 256
69636: PUSH
69637: LD_INT 1000
69639: LESS
69640: PUSH
69641: LD_VAR 0 3
69645: PPUSH
69646: LD_EXP 92
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: PPUSH
69657: CALL_OW 308
69661: AND
69662: IFFALSE 69666
// continue ;
69664: GO 69549
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69666: LD_VAR 0 3
69670: PPUSH
69671: CALL_OW 262
69675: PUSH
69676: LD_INT 2
69678: EQUAL
69679: PUSH
69680: LD_VAR 0 3
69684: PPUSH
69685: CALL_OW 261
69689: PUSH
69690: LD_INT 15
69692: LESS
69693: AND
69694: IFFALSE 69698
// continue ;
69696: GO 69549
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69698: LD_VAR 0 3
69702: PPUSH
69703: CALL_OW 262
69707: PUSH
69708: LD_INT 1
69710: EQUAL
69711: PUSH
69712: LD_VAR 0 3
69716: PPUSH
69717: CALL_OW 261
69721: PUSH
69722: LD_INT 10
69724: LESS
69725: AND
69726: IFFALSE 70006
// begin if not depot then
69728: LD_VAR 0 9
69732: NOT
69733: IFFALSE 69737
// continue ;
69735: GO 69549
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69737: LD_VAR 0 3
69741: PPUSH
69742: LD_VAR 0 9
69746: PPUSH
69747: LD_VAR 0 3
69751: PPUSH
69752: CALL_OW 74
69756: PPUSH
69757: CALL_OW 296
69761: PUSH
69762: LD_INT 6
69764: LESS
69765: IFFALSE 69781
// SetFuel ( j , 100 ) else
69767: LD_VAR 0 3
69771: PPUSH
69772: LD_INT 100
69774: PPUSH
69775: CALL_OW 240
69779: GO 70006
// if GetFuel ( j ) = 0 then
69781: LD_VAR 0 3
69785: PPUSH
69786: CALL_OW 261
69790: PUSH
69791: LD_INT 0
69793: EQUAL
69794: IFFALSE 70006
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69796: LD_ADDR_EXP 87
69800: PUSH
69801: LD_EXP 87
69805: PPUSH
69806: LD_VAR 0 2
69810: PPUSH
69811: LD_EXP 87
69815: PUSH
69816: LD_VAR 0 2
69820: ARRAY
69821: PUSH
69822: LD_VAR 0 3
69826: DIFF
69827: PPUSH
69828: CALL_OW 1
69832: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69833: LD_VAR 0 3
69837: PPUSH
69838: CALL_OW 263
69842: PUSH
69843: LD_INT 1
69845: EQUAL
69846: IFFALSE 69862
// ComExitVehicle ( IsInUnit ( j ) ) ;
69848: LD_VAR 0 3
69852: PPUSH
69853: CALL_OW 310
69857: PPUSH
69858: CALL_OW 121
// if GetControl ( j ) = control_remote then
69862: LD_VAR 0 3
69866: PPUSH
69867: CALL_OW 263
69871: PUSH
69872: LD_INT 2
69874: EQUAL
69875: IFFALSE 69886
// ComUnlink ( j ) ;
69877: LD_VAR 0 3
69881: PPUSH
69882: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69886: LD_ADDR_VAR 0 10
69890: PUSH
69891: LD_VAR 0 2
69895: PPUSH
69896: LD_INT 3
69898: PPUSH
69899: CALL 79645 0 2
69903: ST_TO_ADDR
// if fac then
69904: LD_VAR 0 10
69908: IFFALSE 70004
// begin for k in fac do
69910: LD_ADDR_VAR 0 4
69914: PUSH
69915: LD_VAR 0 10
69919: PUSH
69920: FOR_IN
69921: IFFALSE 70002
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69923: LD_ADDR_VAR 0 11
69927: PUSH
69928: LD_VAR 0 10
69932: PPUSH
69933: LD_VAR 0 3
69937: PPUSH
69938: CALL_OW 265
69942: PPUSH
69943: LD_VAR 0 3
69947: PPUSH
69948: CALL_OW 262
69952: PPUSH
69953: LD_VAR 0 3
69957: PPUSH
69958: CALL_OW 263
69962: PPUSH
69963: LD_VAR 0 3
69967: PPUSH
69968: CALL_OW 264
69972: PPUSH
69973: CALL 16246 0 5
69977: ST_TO_ADDR
// if components then
69978: LD_VAR 0 11
69982: IFFALSE 70000
// begin MC_InsertProduceList ( i , components ) ;
69984: LD_VAR 0 2
69988: PPUSH
69989: LD_VAR 0 11
69993: PPUSH
69994: CALL 79190 0 2
// break ;
69998: GO 70002
// end ; end ;
70000: GO 69920
70002: POP
70003: POP
// end ; continue ;
70004: GO 69549
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70006: LD_VAR 0 3
70010: PPUSH
70011: LD_INT 1
70013: PPUSH
70014: CALL_OW 289
70018: PUSH
70019: LD_INT 100
70021: LESS
70022: PUSH
70023: LD_VAR 0 3
70027: PPUSH
70028: CALL_OW 314
70032: NOT
70033: AND
70034: IFFALSE 70063
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70036: LD_VAR 0 3
70040: PPUSH
70041: LD_VAR 0 7
70045: PUSH
70046: LD_INT 2
70048: ARRAY
70049: PPUSH
70050: LD_VAR 0 7
70054: PUSH
70055: LD_INT 3
70057: ARRAY
70058: PPUSH
70059: CALL_OW 117
// break ;
70063: GO 70067
// end ;
70065: GO 69549
70067: POP
70068: POP
// end ; end ;
70069: GO 68265
70071: POP
70072: POP
// end ;
70073: LD_VAR 0 1
70077: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70078: LD_INT 0
70080: PPUSH
70081: PPUSH
70082: PPUSH
70083: PPUSH
// if not mc_bases then
70084: LD_EXP 68
70088: NOT
70089: IFFALSE 70093
// exit ;
70091: GO 70254
// for i = 1 to mc_bases do
70093: LD_ADDR_VAR 0 2
70097: PUSH
70098: DOUBLE
70099: LD_INT 1
70101: DEC
70102: ST_TO_ADDR
70103: LD_EXP 68
70107: PUSH
70108: FOR_TO
70109: IFFALSE 70252
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70111: LD_ADDR_VAR 0 4
70115: PUSH
70116: LD_EXP 87
70120: PUSH
70121: LD_VAR 0 2
70125: ARRAY
70126: PUSH
70127: LD_EXP 90
70131: PUSH
70132: LD_VAR 0 2
70136: ARRAY
70137: UNION
70138: PPUSH
70139: LD_INT 33
70141: PUSH
70142: LD_INT 2
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: PPUSH
70149: CALL_OW 72
70153: ST_TO_ADDR
// if tmp then
70154: LD_VAR 0 4
70158: IFFALSE 70250
// for j in tmp do
70160: LD_ADDR_VAR 0 3
70164: PUSH
70165: LD_VAR 0 4
70169: PUSH
70170: FOR_IN
70171: IFFALSE 70248
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70173: LD_VAR 0 3
70177: PPUSH
70178: CALL_OW 312
70182: NOT
70183: PUSH
70184: LD_VAR 0 3
70188: PPUSH
70189: CALL_OW 256
70193: PUSH
70194: LD_INT 250
70196: GREATEREQUAL
70197: AND
70198: IFFALSE 70211
// Connect ( j ) else
70200: LD_VAR 0 3
70204: PPUSH
70205: CALL 21721 0 1
70209: GO 70246
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70211: LD_VAR 0 3
70215: PPUSH
70216: CALL_OW 256
70220: PUSH
70221: LD_INT 250
70223: LESS
70224: PUSH
70225: LD_VAR 0 3
70229: PPUSH
70230: CALL_OW 312
70234: AND
70235: IFFALSE 70246
// ComUnlink ( j ) ;
70237: LD_VAR 0 3
70241: PPUSH
70242: CALL_OW 136
70246: GO 70170
70248: POP
70249: POP
// end ;
70250: GO 70108
70252: POP
70253: POP
// end ;
70254: LD_VAR 0 1
70258: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70259: LD_INT 0
70261: PPUSH
70262: PPUSH
70263: PPUSH
70264: PPUSH
70265: PPUSH
// if not mc_bases then
70266: LD_EXP 68
70270: NOT
70271: IFFALSE 70275
// exit ;
70273: GO 70720
// for i = 1 to mc_bases do
70275: LD_ADDR_VAR 0 2
70279: PUSH
70280: DOUBLE
70281: LD_INT 1
70283: DEC
70284: ST_TO_ADDR
70285: LD_EXP 68
70289: PUSH
70290: FOR_TO
70291: IFFALSE 70718
// begin if not mc_produce [ i ] then
70293: LD_EXP 89
70297: PUSH
70298: LD_VAR 0 2
70302: ARRAY
70303: NOT
70304: IFFALSE 70308
// continue ;
70306: GO 70290
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70308: LD_ADDR_VAR 0 5
70312: PUSH
70313: LD_EXP 68
70317: PUSH
70318: LD_VAR 0 2
70322: ARRAY
70323: PPUSH
70324: LD_INT 30
70326: PUSH
70327: LD_INT 3
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PPUSH
70334: CALL_OW 72
70338: ST_TO_ADDR
// if not fac then
70339: LD_VAR 0 5
70343: NOT
70344: IFFALSE 70348
// continue ;
70346: GO 70290
// for j in fac do
70348: LD_ADDR_VAR 0 3
70352: PUSH
70353: LD_VAR 0 5
70357: PUSH
70358: FOR_IN
70359: IFFALSE 70714
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70361: LD_VAR 0 3
70365: PPUSH
70366: CALL_OW 461
70370: PUSH
70371: LD_INT 2
70373: NONEQUAL
70374: PUSH
70375: LD_VAR 0 3
70379: PPUSH
70380: LD_INT 15
70382: PPUSH
70383: CALL 21349 0 2
70387: PUSH
70388: LD_INT 4
70390: ARRAY
70391: OR
70392: IFFALSE 70396
// continue ;
70394: GO 70358
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70396: LD_VAR 0 3
70400: PPUSH
70401: LD_EXP 89
70405: PUSH
70406: LD_VAR 0 2
70410: ARRAY
70411: PUSH
70412: LD_INT 1
70414: ARRAY
70415: PUSH
70416: LD_INT 1
70418: ARRAY
70419: PPUSH
70420: LD_EXP 89
70424: PUSH
70425: LD_VAR 0 2
70429: ARRAY
70430: PUSH
70431: LD_INT 1
70433: ARRAY
70434: PUSH
70435: LD_INT 2
70437: ARRAY
70438: PPUSH
70439: LD_EXP 89
70443: PUSH
70444: LD_VAR 0 2
70448: ARRAY
70449: PUSH
70450: LD_INT 1
70452: ARRAY
70453: PUSH
70454: LD_INT 3
70456: ARRAY
70457: PPUSH
70458: LD_EXP 89
70462: PUSH
70463: LD_VAR 0 2
70467: ARRAY
70468: PUSH
70469: LD_INT 1
70471: ARRAY
70472: PUSH
70473: LD_INT 4
70475: ARRAY
70476: PPUSH
70477: CALL_OW 448
70481: PUSH
70482: LD_VAR 0 3
70486: PPUSH
70487: LD_EXP 89
70491: PUSH
70492: LD_VAR 0 2
70496: ARRAY
70497: PUSH
70498: LD_INT 1
70500: ARRAY
70501: PUSH
70502: LD_INT 1
70504: ARRAY
70505: PUSH
70506: LD_EXP 89
70510: PUSH
70511: LD_VAR 0 2
70515: ARRAY
70516: PUSH
70517: LD_INT 1
70519: ARRAY
70520: PUSH
70521: LD_INT 2
70523: ARRAY
70524: PUSH
70525: LD_EXP 89
70529: PUSH
70530: LD_VAR 0 2
70534: ARRAY
70535: PUSH
70536: LD_INT 1
70538: ARRAY
70539: PUSH
70540: LD_INT 3
70542: ARRAY
70543: PUSH
70544: LD_EXP 89
70548: PUSH
70549: LD_VAR 0 2
70553: ARRAY
70554: PUSH
70555: LD_INT 1
70557: ARRAY
70558: PUSH
70559: LD_INT 4
70561: ARRAY
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: PPUSH
70569: CALL 25116 0 2
70573: AND
70574: IFFALSE 70712
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70576: LD_VAR 0 3
70580: PPUSH
70581: LD_EXP 89
70585: PUSH
70586: LD_VAR 0 2
70590: ARRAY
70591: PUSH
70592: LD_INT 1
70594: ARRAY
70595: PUSH
70596: LD_INT 1
70598: ARRAY
70599: PPUSH
70600: LD_EXP 89
70604: PUSH
70605: LD_VAR 0 2
70609: ARRAY
70610: PUSH
70611: LD_INT 1
70613: ARRAY
70614: PUSH
70615: LD_INT 2
70617: ARRAY
70618: PPUSH
70619: LD_EXP 89
70623: PUSH
70624: LD_VAR 0 2
70628: ARRAY
70629: PUSH
70630: LD_INT 1
70632: ARRAY
70633: PUSH
70634: LD_INT 3
70636: ARRAY
70637: PPUSH
70638: LD_EXP 89
70642: PUSH
70643: LD_VAR 0 2
70647: ARRAY
70648: PUSH
70649: LD_INT 1
70651: ARRAY
70652: PUSH
70653: LD_INT 4
70655: ARRAY
70656: PPUSH
70657: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70661: LD_ADDR_VAR 0 4
70665: PUSH
70666: LD_EXP 89
70670: PUSH
70671: LD_VAR 0 2
70675: ARRAY
70676: PPUSH
70677: LD_INT 1
70679: PPUSH
70680: CALL_OW 3
70684: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70685: LD_ADDR_EXP 89
70689: PUSH
70690: LD_EXP 89
70694: PPUSH
70695: LD_VAR 0 2
70699: PPUSH
70700: LD_VAR 0 4
70704: PPUSH
70705: CALL_OW 1
70709: ST_TO_ADDR
// break ;
70710: GO 70714
// end ; end ;
70712: GO 70358
70714: POP
70715: POP
// end ;
70716: GO 70290
70718: POP
70719: POP
// end ;
70720: LD_VAR 0 1
70724: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70725: LD_INT 0
70727: PPUSH
70728: PPUSH
70729: PPUSH
// if not mc_bases then
70730: LD_EXP 68
70734: NOT
70735: IFFALSE 70739
// exit ;
70737: GO 70828
// for i = 1 to mc_bases do
70739: LD_ADDR_VAR 0 2
70743: PUSH
70744: DOUBLE
70745: LD_INT 1
70747: DEC
70748: ST_TO_ADDR
70749: LD_EXP 68
70753: PUSH
70754: FOR_TO
70755: IFFALSE 70826
// begin if mc_attack [ i ] then
70757: LD_EXP 88
70761: PUSH
70762: LD_VAR 0 2
70766: ARRAY
70767: IFFALSE 70824
// begin tmp := mc_attack [ i ] [ 1 ] ;
70769: LD_ADDR_VAR 0 3
70773: PUSH
70774: LD_EXP 88
70778: PUSH
70779: LD_VAR 0 2
70783: ARRAY
70784: PUSH
70785: LD_INT 1
70787: ARRAY
70788: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70789: LD_ADDR_EXP 88
70793: PUSH
70794: LD_EXP 88
70798: PPUSH
70799: LD_VAR 0 2
70803: PPUSH
70804: EMPTY
70805: PPUSH
70806: CALL_OW 1
70810: ST_TO_ADDR
// Attack ( tmp ) ;
70811: LD_VAR 0 3
70815: PPUSH
70816: CALL 105558 0 1
// exit ;
70820: POP
70821: POP
70822: GO 70828
// end ; end ;
70824: GO 70754
70826: POP
70827: POP
// end ;
70828: LD_VAR 0 1
70832: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70833: LD_INT 0
70835: PPUSH
70836: PPUSH
70837: PPUSH
70838: PPUSH
70839: PPUSH
70840: PPUSH
70841: PPUSH
// if not mc_bases then
70842: LD_EXP 68
70846: NOT
70847: IFFALSE 70851
// exit ;
70849: GO 71708
// for i = 1 to mc_bases do
70851: LD_ADDR_VAR 0 2
70855: PUSH
70856: DOUBLE
70857: LD_INT 1
70859: DEC
70860: ST_TO_ADDR
70861: LD_EXP 68
70865: PUSH
70866: FOR_TO
70867: IFFALSE 71706
// begin if not mc_bases [ i ] then
70869: LD_EXP 68
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: NOT
70880: IFFALSE 70884
// continue ;
70882: GO 70866
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70884: LD_ADDR_VAR 0 7
70888: PUSH
70889: LD_EXP 68
70893: PUSH
70894: LD_VAR 0 2
70898: ARRAY
70899: PUSH
70900: LD_INT 1
70902: ARRAY
70903: PPUSH
70904: CALL 15397 0 1
70908: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70909: LD_ADDR_EXP 91
70913: PUSH
70914: LD_EXP 91
70918: PPUSH
70919: LD_VAR 0 2
70923: PPUSH
70924: LD_EXP 68
70928: PUSH
70929: LD_VAR 0 2
70933: ARRAY
70934: PUSH
70935: LD_INT 1
70937: ARRAY
70938: PPUSH
70939: CALL_OW 255
70943: PPUSH
70944: LD_EXP 93
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: PPUSH
70955: CALL 15362 0 2
70959: PPUSH
70960: CALL_OW 1
70964: ST_TO_ADDR
// if not mc_scan [ i ] then
70965: LD_EXP 91
70969: PUSH
70970: LD_VAR 0 2
70974: ARRAY
70975: NOT
70976: IFFALSE 71154
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70978: LD_ADDR_EXP 111
70982: PUSH
70983: LD_EXP 111
70987: PPUSH
70988: LD_VAR 0 2
70992: PPUSH
70993: LD_INT 0
70995: PPUSH
70996: CALL_OW 1
71000: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71001: LD_ADDR_VAR 0 4
71005: PUSH
71006: LD_EXP 68
71010: PUSH
71011: LD_VAR 0 2
71015: ARRAY
71016: PPUSH
71017: LD_INT 2
71019: PUSH
71020: LD_INT 25
71022: PUSH
71023: LD_INT 5
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 25
71032: PUSH
71033: LD_INT 8
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 25
71042: PUSH
71043: LD_INT 9
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: LIST
71054: LIST
71055: PPUSH
71056: CALL_OW 72
71060: ST_TO_ADDR
// if not tmp then
71061: LD_VAR 0 4
71065: NOT
71066: IFFALSE 71070
// continue ;
71068: GO 70866
// for j in tmp do
71070: LD_ADDR_VAR 0 3
71074: PUSH
71075: LD_VAR 0 4
71079: PUSH
71080: FOR_IN
71081: IFFALSE 71152
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71083: LD_VAR 0 3
71087: PPUSH
71088: CALL_OW 310
71092: PPUSH
71093: CALL_OW 266
71097: PUSH
71098: LD_INT 5
71100: EQUAL
71101: PUSH
71102: LD_VAR 0 3
71106: PPUSH
71107: CALL_OW 257
71111: PUSH
71112: LD_INT 1
71114: EQUAL
71115: AND
71116: PUSH
71117: LD_VAR 0 3
71121: PPUSH
71122: CALL_OW 459
71126: NOT
71127: AND
71128: PUSH
71129: LD_VAR 0 7
71133: AND
71134: IFFALSE 71150
// ComChangeProfession ( j , class ) ;
71136: LD_VAR 0 3
71140: PPUSH
71141: LD_VAR 0 7
71145: PPUSH
71146: CALL_OW 123
71150: GO 71080
71152: POP
71153: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71154: LD_EXP 91
71158: PUSH
71159: LD_VAR 0 2
71163: ARRAY
71164: PUSH
71165: LD_EXP 111
71169: PUSH
71170: LD_VAR 0 2
71174: ARRAY
71175: NOT
71176: AND
71177: PUSH
71178: LD_EXP 90
71182: PUSH
71183: LD_VAR 0 2
71187: ARRAY
71188: NOT
71189: AND
71190: PUSH
71191: LD_EXP 68
71195: PUSH
71196: LD_VAR 0 2
71200: ARRAY
71201: PPUSH
71202: LD_INT 50
71204: PUSH
71205: EMPTY
71206: LIST
71207: PUSH
71208: LD_INT 2
71210: PUSH
71211: LD_INT 30
71213: PUSH
71214: LD_INT 32
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: PUSH
71221: LD_INT 30
71223: PUSH
71224: LD_INT 33
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: LD_INT 30
71233: PUSH
71234: LD_INT 4
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 30
71243: PUSH
71244: LD_INT 5
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PPUSH
71262: CALL_OW 72
71266: PUSH
71267: LD_INT 4
71269: LESS
71270: PUSH
71271: LD_EXP 68
71275: PUSH
71276: LD_VAR 0 2
71280: ARRAY
71281: PPUSH
71282: LD_INT 3
71284: PUSH
71285: LD_INT 24
71287: PUSH
71288: LD_INT 1000
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: PUSH
71299: LD_INT 2
71301: PUSH
71302: LD_INT 30
71304: PUSH
71305: LD_INT 0
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 30
71314: PUSH
71315: LD_INT 1
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: LIST
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PPUSH
71331: CALL_OW 72
71335: OR
71336: AND
71337: IFFALSE 71588
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71339: LD_ADDR_EXP 111
71343: PUSH
71344: LD_EXP 111
71348: PPUSH
71349: LD_VAR 0 2
71353: PPUSH
71354: LD_INT 1
71356: PPUSH
71357: CALL_OW 1
71361: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71362: LD_ADDR_VAR 0 4
71366: PUSH
71367: LD_EXP 68
71371: PUSH
71372: LD_VAR 0 2
71376: ARRAY
71377: PPUSH
71378: LD_INT 2
71380: PUSH
71381: LD_INT 25
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 25
71393: PUSH
71394: LD_INT 5
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 25
71403: PUSH
71404: LD_INT 8
71406: PUSH
71407: EMPTY
71408: LIST
71409: LIST
71410: PUSH
71411: LD_INT 25
71413: PUSH
71414: LD_INT 9
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: PPUSH
71428: CALL_OW 72
71432: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71433: LD_ADDR_VAR 0 4
71437: PUSH
71438: LD_VAR 0 4
71442: PUSH
71443: LD_VAR 0 4
71447: PPUSH
71448: LD_INT 18
71450: PPUSH
71451: CALL 48569 0 2
71455: DIFF
71456: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71457: LD_VAR 0 4
71461: NOT
71462: PUSH
71463: LD_EXP 68
71467: PUSH
71468: LD_VAR 0 2
71472: ARRAY
71473: PPUSH
71474: LD_INT 2
71476: PUSH
71477: LD_INT 30
71479: PUSH
71480: LD_INT 4
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 30
71489: PUSH
71490: LD_INT 5
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: LIST
71501: PPUSH
71502: CALL_OW 72
71506: NOT
71507: AND
71508: IFFALSE 71570
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71510: LD_ADDR_VAR 0 4
71514: PUSH
71515: LD_EXP 68
71519: PUSH
71520: LD_VAR 0 2
71524: ARRAY
71525: PPUSH
71526: LD_INT 2
71528: PUSH
71529: LD_INT 25
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 25
71541: PUSH
71542: LD_INT 3
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: LD_INT 25
71551: PUSH
71552: LD_INT 4
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: LIST
71563: LIST
71564: PPUSH
71565: CALL_OW 72
71569: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71570: LD_VAR 0 2
71574: PPUSH
71575: LD_VAR 0 4
71579: PPUSH
71580: CALL 110267 0 2
// exit ;
71584: POP
71585: POP
71586: GO 71708
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71588: LD_EXP 91
71592: PUSH
71593: LD_VAR 0 2
71597: ARRAY
71598: PUSH
71599: LD_EXP 111
71603: PUSH
71604: LD_VAR 0 2
71608: ARRAY
71609: NOT
71610: AND
71611: PUSH
71612: LD_EXP 90
71616: PUSH
71617: LD_VAR 0 2
71621: ARRAY
71622: AND
71623: IFFALSE 71704
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71625: LD_ADDR_EXP 111
71629: PUSH
71630: LD_EXP 111
71634: PPUSH
71635: LD_VAR 0 2
71639: PPUSH
71640: LD_INT 1
71642: PPUSH
71643: CALL_OW 1
71647: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71648: LD_ADDR_VAR 0 4
71652: PUSH
71653: LD_EXP 90
71657: PUSH
71658: LD_VAR 0 2
71662: ARRAY
71663: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71664: LD_ADDR_EXP 90
71668: PUSH
71669: LD_EXP 90
71673: PPUSH
71674: LD_VAR 0 2
71678: PPUSH
71679: EMPTY
71680: PPUSH
71681: CALL_OW 1
71685: ST_TO_ADDR
// Defend ( i , tmp ) ;
71686: LD_VAR 0 2
71690: PPUSH
71691: LD_VAR 0 4
71695: PPUSH
71696: CALL 110863 0 2
// exit ;
71700: POP
71701: POP
71702: GO 71708
// end ; end ;
71704: GO 70866
71706: POP
71707: POP
// end ;
71708: LD_VAR 0 1
71712: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71713: LD_INT 0
71715: PPUSH
71716: PPUSH
71717: PPUSH
71718: PPUSH
71719: PPUSH
71720: PPUSH
71721: PPUSH
71722: PPUSH
71723: PPUSH
71724: PPUSH
71725: PPUSH
// if not mc_bases then
71726: LD_EXP 68
71730: NOT
71731: IFFALSE 71735
// exit ;
71733: GO 72822
// for i = 1 to mc_bases do
71735: LD_ADDR_VAR 0 2
71739: PUSH
71740: DOUBLE
71741: LD_INT 1
71743: DEC
71744: ST_TO_ADDR
71745: LD_EXP 68
71749: PUSH
71750: FOR_TO
71751: IFFALSE 72820
// begin tmp := mc_lab [ i ] ;
71753: LD_ADDR_VAR 0 6
71757: PUSH
71758: LD_EXP 101
71762: PUSH
71763: LD_VAR 0 2
71767: ARRAY
71768: ST_TO_ADDR
// if not tmp then
71769: LD_VAR 0 6
71773: NOT
71774: IFFALSE 71778
// continue ;
71776: GO 71750
// idle_lab := 0 ;
71778: LD_ADDR_VAR 0 11
71782: PUSH
71783: LD_INT 0
71785: ST_TO_ADDR
// for j in tmp do
71786: LD_ADDR_VAR 0 3
71790: PUSH
71791: LD_VAR 0 6
71795: PUSH
71796: FOR_IN
71797: IFFALSE 72816
// begin researching := false ;
71799: LD_ADDR_VAR 0 10
71803: PUSH
71804: LD_INT 0
71806: ST_TO_ADDR
// side := GetSide ( j ) ;
71807: LD_ADDR_VAR 0 4
71811: PUSH
71812: LD_VAR 0 3
71816: PPUSH
71817: CALL_OW 255
71821: ST_TO_ADDR
// if not mc_tech [ side ] then
71822: LD_EXP 95
71826: PUSH
71827: LD_VAR 0 4
71831: ARRAY
71832: NOT
71833: IFFALSE 71837
// continue ;
71835: GO 71796
// if BuildingStatus ( j ) = bs_idle then
71837: LD_VAR 0 3
71841: PPUSH
71842: CALL_OW 461
71846: PUSH
71847: LD_INT 2
71849: EQUAL
71850: IFFALSE 72038
// begin if idle_lab and UnitsInside ( j ) < 6 then
71852: LD_VAR 0 11
71856: PUSH
71857: LD_VAR 0 3
71861: PPUSH
71862: CALL_OW 313
71866: PUSH
71867: LD_INT 6
71869: LESS
71870: AND
71871: IFFALSE 71942
// begin tmp2 := UnitsInside ( idle_lab ) ;
71873: LD_ADDR_VAR 0 9
71877: PUSH
71878: LD_VAR 0 11
71882: PPUSH
71883: CALL_OW 313
71887: ST_TO_ADDR
// if tmp2 then
71888: LD_VAR 0 9
71892: IFFALSE 71934
// for x in tmp2 do
71894: LD_ADDR_VAR 0 7
71898: PUSH
71899: LD_VAR 0 9
71903: PUSH
71904: FOR_IN
71905: IFFALSE 71932
// begin ComExitBuilding ( x ) ;
71907: LD_VAR 0 7
71911: PPUSH
71912: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71916: LD_VAR 0 7
71920: PPUSH
71921: LD_VAR 0 3
71925: PPUSH
71926: CALL_OW 180
// end ;
71930: GO 71904
71932: POP
71933: POP
// idle_lab := 0 ;
71934: LD_ADDR_VAR 0 11
71938: PUSH
71939: LD_INT 0
71941: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71942: LD_ADDR_VAR 0 5
71946: PUSH
71947: LD_EXP 95
71951: PUSH
71952: LD_VAR 0 4
71956: ARRAY
71957: PUSH
71958: FOR_IN
71959: IFFALSE 72019
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71961: LD_VAR 0 3
71965: PPUSH
71966: LD_VAR 0 5
71970: PPUSH
71971: CALL_OW 430
71975: PUSH
71976: LD_VAR 0 4
71980: PPUSH
71981: LD_VAR 0 5
71985: PPUSH
71986: CALL 14467 0 2
71990: AND
71991: IFFALSE 72017
// begin researching := true ;
71993: LD_ADDR_VAR 0 10
71997: PUSH
71998: LD_INT 1
72000: ST_TO_ADDR
// ComResearch ( j , t ) ;
72001: LD_VAR 0 3
72005: PPUSH
72006: LD_VAR 0 5
72010: PPUSH
72011: CALL_OW 124
// break ;
72015: GO 72019
// end ;
72017: GO 71958
72019: POP
72020: POP
// if not researching then
72021: LD_VAR 0 10
72025: NOT
72026: IFFALSE 72038
// idle_lab := j ;
72028: LD_ADDR_VAR 0 11
72032: PUSH
72033: LD_VAR 0 3
72037: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72038: LD_VAR 0 3
72042: PPUSH
72043: CALL_OW 461
72047: PUSH
72048: LD_INT 10
72050: EQUAL
72051: IFFALSE 72639
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72053: LD_EXP 97
72057: PUSH
72058: LD_VAR 0 2
72062: ARRAY
72063: NOT
72064: PUSH
72065: LD_EXP 98
72069: PUSH
72070: LD_VAR 0 2
72074: ARRAY
72075: NOT
72076: AND
72077: PUSH
72078: LD_EXP 95
72082: PUSH
72083: LD_VAR 0 4
72087: ARRAY
72088: PUSH
72089: LD_INT 1
72091: GREATER
72092: AND
72093: IFFALSE 72224
// begin ComCancel ( j ) ;
72095: LD_VAR 0 3
72099: PPUSH
72100: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72104: LD_ADDR_EXP 95
72108: PUSH
72109: LD_EXP 95
72113: PPUSH
72114: LD_VAR 0 4
72118: PPUSH
72119: LD_EXP 95
72123: PUSH
72124: LD_VAR 0 4
72128: ARRAY
72129: PPUSH
72130: LD_EXP 95
72134: PUSH
72135: LD_VAR 0 4
72139: ARRAY
72140: PUSH
72141: LD_INT 1
72143: MINUS
72144: PPUSH
72145: LD_EXP 95
72149: PUSH
72150: LD_VAR 0 4
72154: ARRAY
72155: PPUSH
72156: LD_INT 0
72158: PPUSH
72159: CALL 18168 0 4
72163: PPUSH
72164: CALL_OW 1
72168: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72169: LD_ADDR_EXP 95
72173: PUSH
72174: LD_EXP 95
72178: PPUSH
72179: LD_VAR 0 4
72183: PPUSH
72184: LD_EXP 95
72188: PUSH
72189: LD_VAR 0 4
72193: ARRAY
72194: PPUSH
72195: LD_EXP 95
72199: PUSH
72200: LD_VAR 0 4
72204: ARRAY
72205: PPUSH
72206: LD_INT 1
72208: PPUSH
72209: LD_INT 0
72211: PPUSH
72212: CALL 18168 0 4
72216: PPUSH
72217: CALL_OW 1
72221: ST_TO_ADDR
// continue ;
72222: GO 71796
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72224: LD_EXP 97
72228: PUSH
72229: LD_VAR 0 2
72233: ARRAY
72234: PUSH
72235: LD_EXP 98
72239: PUSH
72240: LD_VAR 0 2
72244: ARRAY
72245: NOT
72246: AND
72247: IFFALSE 72374
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72249: LD_ADDR_EXP 98
72253: PUSH
72254: LD_EXP 98
72258: PPUSH
72259: LD_VAR 0 2
72263: PUSH
72264: LD_EXP 98
72268: PUSH
72269: LD_VAR 0 2
72273: ARRAY
72274: PUSH
72275: LD_INT 1
72277: PLUS
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PPUSH
72283: LD_EXP 97
72287: PUSH
72288: LD_VAR 0 2
72292: ARRAY
72293: PUSH
72294: LD_INT 1
72296: ARRAY
72297: PPUSH
72298: CALL 18750 0 3
72302: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72303: LD_EXP 97
72307: PUSH
72308: LD_VAR 0 2
72312: ARRAY
72313: PUSH
72314: LD_INT 1
72316: ARRAY
72317: PPUSH
72318: LD_INT 112
72320: PPUSH
72321: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72325: LD_ADDR_VAR 0 9
72329: PUSH
72330: LD_EXP 97
72334: PUSH
72335: LD_VAR 0 2
72339: ARRAY
72340: PPUSH
72341: LD_INT 1
72343: PPUSH
72344: CALL_OW 3
72348: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72349: LD_ADDR_EXP 97
72353: PUSH
72354: LD_EXP 97
72358: PPUSH
72359: LD_VAR 0 2
72363: PPUSH
72364: LD_VAR 0 9
72368: PPUSH
72369: CALL_OW 1
72373: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72374: LD_EXP 97
72378: PUSH
72379: LD_VAR 0 2
72383: ARRAY
72384: PUSH
72385: LD_EXP 98
72389: PUSH
72390: LD_VAR 0 2
72394: ARRAY
72395: AND
72396: PUSH
72397: LD_EXP 98
72401: PUSH
72402: LD_VAR 0 2
72406: ARRAY
72407: PUSH
72408: LD_INT 1
72410: ARRAY
72411: PPUSH
72412: CALL_OW 310
72416: NOT
72417: AND
72418: PUSH
72419: LD_VAR 0 3
72423: PPUSH
72424: CALL_OW 313
72428: PUSH
72429: LD_INT 6
72431: EQUAL
72432: AND
72433: IFFALSE 72489
// begin tmp2 := UnitsInside ( j ) ;
72435: LD_ADDR_VAR 0 9
72439: PUSH
72440: LD_VAR 0 3
72444: PPUSH
72445: CALL_OW 313
72449: ST_TO_ADDR
// if tmp2 = 6 then
72450: LD_VAR 0 9
72454: PUSH
72455: LD_INT 6
72457: EQUAL
72458: IFFALSE 72489
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72460: LD_VAR 0 9
72464: PUSH
72465: LD_INT 1
72467: ARRAY
72468: PPUSH
72469: LD_INT 112
72471: PPUSH
72472: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72476: LD_VAR 0 9
72480: PUSH
72481: LD_INT 1
72483: ARRAY
72484: PPUSH
72485: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72489: LD_EXP 98
72493: PUSH
72494: LD_VAR 0 2
72498: ARRAY
72499: PUSH
72500: LD_EXP 98
72504: PUSH
72505: LD_VAR 0 2
72509: ARRAY
72510: PUSH
72511: LD_INT 1
72513: ARRAY
72514: PPUSH
72515: CALL_OW 314
72519: NOT
72520: AND
72521: PUSH
72522: LD_EXP 98
72526: PUSH
72527: LD_VAR 0 2
72531: ARRAY
72532: PUSH
72533: LD_INT 1
72535: ARRAY
72536: PPUSH
72537: CALL_OW 310
72541: NOT
72542: AND
72543: IFFALSE 72569
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72545: LD_EXP 98
72549: PUSH
72550: LD_VAR 0 2
72554: ARRAY
72555: PUSH
72556: LD_INT 1
72558: ARRAY
72559: PPUSH
72560: LD_VAR 0 3
72564: PPUSH
72565: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72569: LD_EXP 98
72573: PUSH
72574: LD_VAR 0 2
72578: ARRAY
72579: PUSH
72580: LD_INT 1
72582: ARRAY
72583: PPUSH
72584: CALL_OW 310
72588: PUSH
72589: LD_EXP 98
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PPUSH
72604: CALL_OW 310
72608: PPUSH
72609: CALL_OW 461
72613: PUSH
72614: LD_INT 3
72616: NONEQUAL
72617: AND
72618: IFFALSE 72639
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72620: LD_EXP 98
72624: PUSH
72625: LD_VAR 0 2
72629: ARRAY
72630: PUSH
72631: LD_INT 1
72633: ARRAY
72634: PPUSH
72635: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72639: LD_VAR 0 3
72643: PPUSH
72644: CALL_OW 461
72648: PUSH
72649: LD_INT 6
72651: EQUAL
72652: PUSH
72653: LD_VAR 0 6
72657: PUSH
72658: LD_INT 1
72660: GREATER
72661: AND
72662: IFFALSE 72814
// begin sci := [ ] ;
72664: LD_ADDR_VAR 0 8
72668: PUSH
72669: EMPTY
72670: ST_TO_ADDR
// for x in ( tmp diff j ) do
72671: LD_ADDR_VAR 0 7
72675: PUSH
72676: LD_VAR 0 6
72680: PUSH
72681: LD_VAR 0 3
72685: DIFF
72686: PUSH
72687: FOR_IN
72688: IFFALSE 72740
// begin if sci = 6 then
72690: LD_VAR 0 8
72694: PUSH
72695: LD_INT 6
72697: EQUAL
72698: IFFALSE 72702
// break ;
72700: GO 72740
// if BuildingStatus ( x ) = bs_idle then
72702: LD_VAR 0 7
72706: PPUSH
72707: CALL_OW 461
72711: PUSH
72712: LD_INT 2
72714: EQUAL
72715: IFFALSE 72738
// sci := sci ^ UnitsInside ( x ) ;
72717: LD_ADDR_VAR 0 8
72721: PUSH
72722: LD_VAR 0 8
72726: PUSH
72727: LD_VAR 0 7
72731: PPUSH
72732: CALL_OW 313
72736: ADD
72737: ST_TO_ADDR
// end ;
72738: GO 72687
72740: POP
72741: POP
// if not sci then
72742: LD_VAR 0 8
72746: NOT
72747: IFFALSE 72751
// continue ;
72749: GO 71796
// for x in sci do
72751: LD_ADDR_VAR 0 7
72755: PUSH
72756: LD_VAR 0 8
72760: PUSH
72761: FOR_IN
72762: IFFALSE 72812
// if IsInUnit ( x ) and not HasTask ( x ) then
72764: LD_VAR 0 7
72768: PPUSH
72769: CALL_OW 310
72773: PUSH
72774: LD_VAR 0 7
72778: PPUSH
72779: CALL_OW 314
72783: NOT
72784: AND
72785: IFFALSE 72810
// begin ComExitBuilding ( x ) ;
72787: LD_VAR 0 7
72791: PPUSH
72792: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72796: LD_VAR 0 7
72800: PPUSH
72801: LD_VAR 0 3
72805: PPUSH
72806: CALL_OW 180
// end ;
72810: GO 72761
72812: POP
72813: POP
// end ; end ;
72814: GO 71796
72816: POP
72817: POP
// end ;
72818: GO 71750
72820: POP
72821: POP
// end ;
72822: LD_VAR 0 1
72826: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72827: LD_INT 0
72829: PPUSH
72830: PPUSH
// if not mc_bases then
72831: LD_EXP 68
72835: NOT
72836: IFFALSE 72840
// exit ;
72838: GO 72921
// for i = 1 to mc_bases do
72840: LD_ADDR_VAR 0 2
72844: PUSH
72845: DOUBLE
72846: LD_INT 1
72848: DEC
72849: ST_TO_ADDR
72850: LD_EXP 68
72854: PUSH
72855: FOR_TO
72856: IFFALSE 72919
// if mc_mines [ i ] and mc_miners [ i ] then
72858: LD_EXP 81
72862: PUSH
72863: LD_VAR 0 2
72867: ARRAY
72868: PUSH
72869: LD_EXP 82
72873: PUSH
72874: LD_VAR 0 2
72878: ARRAY
72879: AND
72880: IFFALSE 72917
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72882: LD_EXP 82
72886: PUSH
72887: LD_VAR 0 2
72891: ARRAY
72892: PUSH
72893: LD_INT 1
72895: ARRAY
72896: PPUSH
72897: CALL_OW 255
72901: PPUSH
72902: LD_EXP 81
72906: PUSH
72907: LD_VAR 0 2
72911: ARRAY
72912: PPUSH
72913: CALL 15550 0 2
72917: GO 72855
72919: POP
72920: POP
// end ;
72921: LD_VAR 0 1
72925: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72926: LD_INT 0
72928: PPUSH
72929: PPUSH
72930: PPUSH
72931: PPUSH
72932: PPUSH
72933: PPUSH
72934: PPUSH
72935: PPUSH
// if not mc_bases or not mc_parking then
72936: LD_EXP 68
72940: NOT
72941: PUSH
72942: LD_EXP 92
72946: NOT
72947: OR
72948: IFFALSE 72952
// exit ;
72950: GO 73662
// for i = 1 to mc_bases do
72952: LD_ADDR_VAR 0 2
72956: PUSH
72957: DOUBLE
72958: LD_INT 1
72960: DEC
72961: ST_TO_ADDR
72962: LD_EXP 68
72966: PUSH
72967: FOR_TO
72968: IFFALSE 73660
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72970: LD_EXP 68
72974: PUSH
72975: LD_VAR 0 2
72979: ARRAY
72980: NOT
72981: PUSH
72982: LD_EXP 92
72986: PUSH
72987: LD_VAR 0 2
72991: ARRAY
72992: NOT
72993: OR
72994: IFFALSE 72998
// continue ;
72996: GO 72967
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72998: LD_ADDR_VAR 0 5
73002: PUSH
73003: LD_EXP 68
73007: PUSH
73008: LD_VAR 0 2
73012: ARRAY
73013: PUSH
73014: LD_INT 1
73016: ARRAY
73017: PPUSH
73018: CALL_OW 255
73022: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73023: LD_ADDR_VAR 0 6
73027: PUSH
73028: LD_EXP 68
73032: PUSH
73033: LD_VAR 0 2
73037: ARRAY
73038: PPUSH
73039: LD_INT 30
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: EMPTY
73046: LIST
73047: LIST
73048: PPUSH
73049: CALL_OW 72
73053: ST_TO_ADDR
// if not fac then
73054: LD_VAR 0 6
73058: NOT
73059: IFFALSE 73110
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73061: LD_ADDR_VAR 0 6
73065: PUSH
73066: LD_EXP 68
73070: PUSH
73071: LD_VAR 0 2
73075: ARRAY
73076: PPUSH
73077: LD_INT 2
73079: PUSH
73080: LD_INT 30
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 30
73092: PUSH
73093: LD_INT 1
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: LIST
73104: PPUSH
73105: CALL_OW 72
73109: ST_TO_ADDR
// if not fac then
73110: LD_VAR 0 6
73114: NOT
73115: IFFALSE 73119
// continue ;
73117: GO 72967
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73119: LD_ADDR_VAR 0 7
73123: PUSH
73124: LD_EXP 92
73128: PUSH
73129: LD_VAR 0 2
73133: ARRAY
73134: PPUSH
73135: LD_INT 22
73137: PUSH
73138: LD_VAR 0 5
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: PUSH
73147: LD_INT 21
73149: PUSH
73150: LD_INT 2
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 3
73159: PUSH
73160: LD_INT 24
73162: PUSH
73163: LD_INT 1000
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: LIST
73178: PPUSH
73179: CALL_OW 70
73183: ST_TO_ADDR
// for j in fac do
73184: LD_ADDR_VAR 0 3
73188: PUSH
73189: LD_VAR 0 6
73193: PUSH
73194: FOR_IN
73195: IFFALSE 73276
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73197: LD_ADDR_VAR 0 7
73201: PUSH
73202: LD_VAR 0 7
73206: PUSH
73207: LD_INT 22
73209: PUSH
73210: LD_VAR 0 5
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: LD_INT 91
73221: PUSH
73222: LD_VAR 0 3
73226: PUSH
73227: LD_INT 15
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: LIST
73234: PUSH
73235: LD_INT 21
73237: PUSH
73238: LD_INT 2
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 3
73247: PUSH
73248: LD_INT 24
73250: PUSH
73251: LD_INT 1000
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: PPUSH
73268: CALL_OW 69
73272: UNION
73273: ST_TO_ADDR
73274: GO 73194
73276: POP
73277: POP
// if not vehs then
73278: LD_VAR 0 7
73282: NOT
73283: IFFALSE 73309
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73285: LD_ADDR_EXP 80
73289: PUSH
73290: LD_EXP 80
73294: PPUSH
73295: LD_VAR 0 2
73299: PPUSH
73300: EMPTY
73301: PPUSH
73302: CALL_OW 1
73306: ST_TO_ADDR
// continue ;
73307: GO 72967
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73309: LD_ADDR_VAR 0 8
73313: PUSH
73314: LD_EXP 68
73318: PUSH
73319: LD_VAR 0 2
73323: ARRAY
73324: PPUSH
73325: LD_INT 30
73327: PUSH
73328: LD_INT 3
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PPUSH
73335: CALL_OW 72
73339: ST_TO_ADDR
// if tmp then
73340: LD_VAR 0 8
73344: IFFALSE 73447
// begin for j in tmp do
73346: LD_ADDR_VAR 0 3
73350: PUSH
73351: LD_VAR 0 8
73355: PUSH
73356: FOR_IN
73357: IFFALSE 73445
// for k in UnitsInside ( j ) do
73359: LD_ADDR_VAR 0 4
73363: PUSH
73364: LD_VAR 0 3
73368: PPUSH
73369: CALL_OW 313
73373: PUSH
73374: FOR_IN
73375: IFFALSE 73441
// if k then
73377: LD_VAR 0 4
73381: IFFALSE 73439
// if not k in mc_repair_vehicle [ i ] then
73383: LD_VAR 0 4
73387: PUSH
73388: LD_EXP 80
73392: PUSH
73393: LD_VAR 0 2
73397: ARRAY
73398: IN
73399: NOT
73400: IFFALSE 73439
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73402: LD_ADDR_EXP 80
73406: PUSH
73407: LD_EXP 80
73411: PPUSH
73412: LD_VAR 0 2
73416: PPUSH
73417: LD_EXP 80
73421: PUSH
73422: LD_VAR 0 2
73426: ARRAY
73427: PUSH
73428: LD_VAR 0 4
73432: UNION
73433: PPUSH
73434: CALL_OW 1
73438: ST_TO_ADDR
73439: GO 73374
73441: POP
73442: POP
73443: GO 73356
73445: POP
73446: POP
// end ; if not mc_repair_vehicle [ i ] then
73447: LD_EXP 80
73451: PUSH
73452: LD_VAR 0 2
73456: ARRAY
73457: NOT
73458: IFFALSE 73462
// continue ;
73460: GO 72967
// for j in mc_repair_vehicle [ i ] do
73462: LD_ADDR_VAR 0 3
73466: PUSH
73467: LD_EXP 80
73471: PUSH
73472: LD_VAR 0 2
73476: ARRAY
73477: PUSH
73478: FOR_IN
73479: IFFALSE 73656
// begin if GetClass ( j ) <> 3 then
73481: LD_VAR 0 3
73485: PPUSH
73486: CALL_OW 257
73490: PUSH
73491: LD_INT 3
73493: NONEQUAL
73494: IFFALSE 73535
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73496: LD_ADDR_EXP 80
73500: PUSH
73501: LD_EXP 80
73505: PPUSH
73506: LD_VAR 0 2
73510: PPUSH
73511: LD_EXP 80
73515: PUSH
73516: LD_VAR 0 2
73520: ARRAY
73521: PUSH
73522: LD_VAR 0 3
73526: DIFF
73527: PPUSH
73528: CALL_OW 1
73532: ST_TO_ADDR
// continue ;
73533: GO 73478
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73535: LD_VAR 0 3
73539: PPUSH
73540: CALL_OW 311
73544: NOT
73545: PUSH
73546: LD_VAR 0 3
73550: PUSH
73551: LD_EXP 71
73555: PUSH
73556: LD_VAR 0 2
73560: ARRAY
73561: PUSH
73562: LD_INT 1
73564: ARRAY
73565: IN
73566: NOT
73567: AND
73568: PUSH
73569: LD_VAR 0 3
73573: PUSH
73574: LD_EXP 71
73578: PUSH
73579: LD_VAR 0 2
73583: ARRAY
73584: PUSH
73585: LD_INT 2
73587: ARRAY
73588: IN
73589: NOT
73590: AND
73591: IFFALSE 73654
// begin if IsInUnit ( j ) then
73593: LD_VAR 0 3
73597: PPUSH
73598: CALL_OW 310
73602: IFFALSE 73615
// ComExitBuilding ( j ) else
73604: LD_VAR 0 3
73608: PPUSH
73609: CALL_OW 122
73613: GO 73654
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73615: LD_VAR 0 3
73619: PPUSH
73620: LD_VAR 0 7
73624: PUSH
73625: LD_INT 1
73627: ARRAY
73628: PPUSH
73629: CALL 53062 0 2
73633: NOT
73634: IFFALSE 73654
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73636: LD_VAR 0 3
73640: PPUSH
73641: LD_VAR 0 7
73645: PUSH
73646: LD_INT 1
73648: ARRAY
73649: PPUSH
73650: CALL_OW 129
// end ; end ;
73654: GO 73478
73656: POP
73657: POP
// end ;
73658: GO 72967
73660: POP
73661: POP
// end ;
73662: LD_VAR 0 1
73666: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73667: LD_INT 0
73669: PPUSH
73670: PPUSH
73671: PPUSH
73672: PPUSH
73673: PPUSH
73674: PPUSH
73675: PPUSH
73676: PPUSH
73677: PPUSH
73678: PPUSH
73679: PPUSH
// if not mc_bases then
73680: LD_EXP 68
73684: NOT
73685: IFFALSE 73689
// exit ;
73687: GO 74491
// for i = 1 to mc_bases do
73689: LD_ADDR_VAR 0 2
73693: PUSH
73694: DOUBLE
73695: LD_INT 1
73697: DEC
73698: ST_TO_ADDR
73699: LD_EXP 68
73703: PUSH
73704: FOR_TO
73705: IFFALSE 74489
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73707: LD_EXP 96
73711: PUSH
73712: LD_VAR 0 2
73716: ARRAY
73717: NOT
73718: PUSH
73719: LD_EXP 71
73723: PUSH
73724: LD_VAR 0 2
73728: ARRAY
73729: PUSH
73730: LD_INT 1
73732: ARRAY
73733: OR
73734: PUSH
73735: LD_EXP 71
73739: PUSH
73740: LD_VAR 0 2
73744: ARRAY
73745: PUSH
73746: LD_INT 2
73748: ARRAY
73749: OR
73750: PUSH
73751: LD_EXP 94
73755: PUSH
73756: LD_VAR 0 2
73760: ARRAY
73761: PPUSH
73762: LD_INT 1
73764: PPUSH
73765: CALL_OW 325
73769: NOT
73770: OR
73771: PUSH
73772: LD_EXP 91
73776: PUSH
73777: LD_VAR 0 2
73781: ARRAY
73782: OR
73783: IFFALSE 73787
// continue ;
73785: GO 73704
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73787: LD_ADDR_VAR 0 8
73791: PUSH
73792: LD_EXP 68
73796: PUSH
73797: LD_VAR 0 2
73801: ARRAY
73802: PPUSH
73803: LD_INT 25
73805: PUSH
73806: LD_INT 4
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PUSH
73813: LD_INT 50
73815: PUSH
73816: EMPTY
73817: LIST
73818: PUSH
73819: LD_INT 3
73821: PUSH
73822: LD_INT 60
73824: PUSH
73825: EMPTY
73826: LIST
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: LIST
73836: PPUSH
73837: CALL_OW 72
73841: PUSH
73842: LD_EXP 72
73846: PUSH
73847: LD_VAR 0 2
73851: ARRAY
73852: DIFF
73853: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73854: LD_ADDR_VAR 0 9
73858: PUSH
73859: LD_EXP 68
73863: PUSH
73864: LD_VAR 0 2
73868: ARRAY
73869: PPUSH
73870: LD_INT 2
73872: PUSH
73873: LD_INT 30
73875: PUSH
73876: LD_INT 0
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PUSH
73883: LD_INT 30
73885: PUSH
73886: LD_INT 1
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: EMPTY
73894: LIST
73895: LIST
73896: LIST
73897: PPUSH
73898: CALL_OW 72
73902: ST_TO_ADDR
// if not tmp or not dep then
73903: LD_VAR 0 8
73907: NOT
73908: PUSH
73909: LD_VAR 0 9
73913: NOT
73914: OR
73915: IFFALSE 73919
// continue ;
73917: GO 73704
// side := GetSide ( tmp [ 1 ] ) ;
73919: LD_ADDR_VAR 0 11
73923: PUSH
73924: LD_VAR 0 8
73928: PUSH
73929: LD_INT 1
73931: ARRAY
73932: PPUSH
73933: CALL_OW 255
73937: ST_TO_ADDR
// dep := dep [ 1 ] ;
73938: LD_ADDR_VAR 0 9
73942: PUSH
73943: LD_VAR 0 9
73947: PUSH
73948: LD_INT 1
73950: ARRAY
73951: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73952: LD_ADDR_VAR 0 7
73956: PUSH
73957: LD_EXP 96
73961: PUSH
73962: LD_VAR 0 2
73966: ARRAY
73967: PPUSH
73968: LD_INT 22
73970: PUSH
73971: LD_INT 0
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 25
73980: PUSH
73981: LD_INT 12
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PPUSH
73992: CALL_OW 70
73996: PUSH
73997: LD_INT 22
73999: PUSH
74000: LD_INT 0
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 25
74009: PUSH
74010: LD_INT 12
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 91
74019: PUSH
74020: LD_VAR 0 9
74024: PUSH
74025: LD_INT 20
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: LIST
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: LIST
74037: PPUSH
74038: CALL_OW 69
74042: UNION
74043: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74044: LD_ADDR_VAR 0 10
74048: PUSH
74049: LD_EXP 96
74053: PUSH
74054: LD_VAR 0 2
74058: ARRAY
74059: PPUSH
74060: LD_INT 81
74062: PUSH
74063: LD_VAR 0 11
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PPUSH
74072: CALL_OW 70
74076: ST_TO_ADDR
// if not apes or danger_at_area then
74077: LD_VAR 0 7
74081: NOT
74082: PUSH
74083: LD_VAR 0 10
74087: OR
74088: IFFALSE 74138
// begin if mc_taming [ i ] then
74090: LD_EXP 99
74094: PUSH
74095: LD_VAR 0 2
74099: ARRAY
74100: IFFALSE 74136
// begin MC_Reset ( i , 121 ) ;
74102: LD_VAR 0 2
74106: PPUSH
74107: LD_INT 121
74109: PPUSH
74110: CALL 59124 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74114: LD_ADDR_EXP 99
74118: PUSH
74119: LD_EXP 99
74123: PPUSH
74124: LD_VAR 0 2
74128: PPUSH
74129: EMPTY
74130: PPUSH
74131: CALL_OW 1
74135: ST_TO_ADDR
// end ; continue ;
74136: GO 73704
// end ; for j in tmp do
74138: LD_ADDR_VAR 0 3
74142: PUSH
74143: LD_VAR 0 8
74147: PUSH
74148: FOR_IN
74149: IFFALSE 74485
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74151: LD_VAR 0 3
74155: PUSH
74156: LD_EXP 99
74160: PUSH
74161: LD_VAR 0 2
74165: ARRAY
74166: IN
74167: NOT
74168: PUSH
74169: LD_EXP 99
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: PUSH
74180: LD_INT 3
74182: LESS
74183: AND
74184: IFFALSE 74242
// begin SetTag ( j , 121 ) ;
74186: LD_VAR 0 3
74190: PPUSH
74191: LD_INT 121
74193: PPUSH
74194: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74198: LD_ADDR_EXP 99
74202: PUSH
74203: LD_EXP 99
74207: PPUSH
74208: LD_VAR 0 2
74212: PUSH
74213: LD_EXP 99
74217: PUSH
74218: LD_VAR 0 2
74222: ARRAY
74223: PUSH
74224: LD_INT 1
74226: PLUS
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PPUSH
74232: LD_VAR 0 3
74236: PPUSH
74237: CALL 18750 0 3
74241: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74242: LD_VAR 0 3
74246: PUSH
74247: LD_EXP 99
74251: PUSH
74252: LD_VAR 0 2
74256: ARRAY
74257: IN
74258: IFFALSE 74483
// begin if GetClass ( j ) <> 4 then
74260: LD_VAR 0 3
74264: PPUSH
74265: CALL_OW 257
74269: PUSH
74270: LD_INT 4
74272: NONEQUAL
74273: IFFALSE 74326
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74275: LD_ADDR_EXP 99
74279: PUSH
74280: LD_EXP 99
74284: PPUSH
74285: LD_VAR 0 2
74289: PPUSH
74290: LD_EXP 99
74294: PUSH
74295: LD_VAR 0 2
74299: ARRAY
74300: PUSH
74301: LD_VAR 0 3
74305: DIFF
74306: PPUSH
74307: CALL_OW 1
74311: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74312: LD_VAR 0 3
74316: PPUSH
74317: LD_INT 0
74319: PPUSH
74320: CALL_OW 109
// continue ;
74324: GO 74148
// end ; if IsInUnit ( j ) then
74326: LD_VAR 0 3
74330: PPUSH
74331: CALL_OW 310
74335: IFFALSE 74346
// ComExitBuilding ( j ) ;
74337: LD_VAR 0 3
74341: PPUSH
74342: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74346: LD_ADDR_VAR 0 6
74350: PUSH
74351: LD_VAR 0 7
74355: PPUSH
74356: LD_VAR 0 3
74360: PPUSH
74361: CALL_OW 74
74365: ST_TO_ADDR
// if not ape then
74366: LD_VAR 0 6
74370: NOT
74371: IFFALSE 74375
// break ;
74373: GO 74485
// x := GetX ( ape ) ;
74375: LD_ADDR_VAR 0 4
74379: PUSH
74380: LD_VAR 0 6
74384: PPUSH
74385: CALL_OW 250
74389: ST_TO_ADDR
// y := GetY ( ape ) ;
74390: LD_ADDR_VAR 0 5
74394: PUSH
74395: LD_VAR 0 6
74399: PPUSH
74400: CALL_OW 251
74404: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74405: LD_VAR 0 4
74409: PPUSH
74410: LD_VAR 0 5
74414: PPUSH
74415: CALL_OW 488
74419: NOT
74420: PUSH
74421: LD_VAR 0 11
74425: PPUSH
74426: LD_VAR 0 4
74430: PPUSH
74431: LD_VAR 0 5
74435: PPUSH
74436: LD_INT 20
74438: PPUSH
74439: CALL 19646 0 4
74443: PUSH
74444: LD_INT 4
74446: ARRAY
74447: OR
74448: IFFALSE 74452
// break ;
74450: GO 74485
// if not HasTask ( j ) then
74452: LD_VAR 0 3
74456: PPUSH
74457: CALL_OW 314
74461: NOT
74462: IFFALSE 74483
// ComTameXY ( j , x , y ) ;
74464: LD_VAR 0 3
74468: PPUSH
74469: LD_VAR 0 4
74473: PPUSH
74474: LD_VAR 0 5
74478: PPUSH
74479: CALL_OW 131
// end ; end ;
74483: GO 74148
74485: POP
74486: POP
// end ;
74487: GO 73704
74489: POP
74490: POP
// end ;
74491: LD_VAR 0 1
74495: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74496: LD_INT 0
74498: PPUSH
74499: PPUSH
74500: PPUSH
74501: PPUSH
74502: PPUSH
74503: PPUSH
74504: PPUSH
74505: PPUSH
// if not mc_bases then
74506: LD_EXP 68
74510: NOT
74511: IFFALSE 74515
// exit ;
74513: GO 75141
// for i = 1 to mc_bases do
74515: LD_ADDR_VAR 0 2
74519: PUSH
74520: DOUBLE
74521: LD_INT 1
74523: DEC
74524: ST_TO_ADDR
74525: LD_EXP 68
74529: PUSH
74530: FOR_TO
74531: IFFALSE 75139
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74533: LD_EXP 97
74537: PUSH
74538: LD_VAR 0 2
74542: ARRAY
74543: NOT
74544: PUSH
74545: LD_EXP 97
74549: PUSH
74550: LD_VAR 0 2
74554: ARRAY
74555: PPUSH
74556: LD_INT 25
74558: PUSH
74559: LD_INT 12
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PPUSH
74566: CALL_OW 72
74570: NOT
74571: OR
74572: IFFALSE 74576
// continue ;
74574: GO 74530
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74576: LD_ADDR_VAR 0 5
74580: PUSH
74581: LD_EXP 97
74585: PUSH
74586: LD_VAR 0 2
74590: ARRAY
74591: PUSH
74592: LD_INT 1
74594: ARRAY
74595: PPUSH
74596: CALL_OW 255
74600: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74601: LD_VAR 0 5
74605: PPUSH
74606: LD_INT 2
74608: PPUSH
74609: CALL_OW 325
74613: IFFALSE 74866
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74615: LD_ADDR_VAR 0 4
74619: PUSH
74620: LD_EXP 97
74624: PUSH
74625: LD_VAR 0 2
74629: ARRAY
74630: PPUSH
74631: LD_INT 25
74633: PUSH
74634: LD_INT 16
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PPUSH
74641: CALL_OW 72
74645: ST_TO_ADDR
// if tmp < 6 then
74646: LD_VAR 0 4
74650: PUSH
74651: LD_INT 6
74653: LESS
74654: IFFALSE 74866
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74656: LD_ADDR_VAR 0 6
74660: PUSH
74661: LD_EXP 68
74665: PUSH
74666: LD_VAR 0 2
74670: ARRAY
74671: PPUSH
74672: LD_INT 2
74674: PUSH
74675: LD_INT 30
74677: PUSH
74678: LD_INT 0
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: PUSH
74685: LD_INT 30
74687: PUSH
74688: LD_INT 1
74690: PUSH
74691: EMPTY
74692: LIST
74693: LIST
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: LIST
74699: PPUSH
74700: CALL_OW 72
74704: ST_TO_ADDR
// if depot then
74705: LD_VAR 0 6
74709: IFFALSE 74866
// begin selected := 0 ;
74711: LD_ADDR_VAR 0 7
74715: PUSH
74716: LD_INT 0
74718: ST_TO_ADDR
// for j in depot do
74719: LD_ADDR_VAR 0 3
74723: PUSH
74724: LD_VAR 0 6
74728: PUSH
74729: FOR_IN
74730: IFFALSE 74761
// begin if UnitsInside ( j ) < 6 then
74732: LD_VAR 0 3
74736: PPUSH
74737: CALL_OW 313
74741: PUSH
74742: LD_INT 6
74744: LESS
74745: IFFALSE 74759
// begin selected := j ;
74747: LD_ADDR_VAR 0 7
74751: PUSH
74752: LD_VAR 0 3
74756: ST_TO_ADDR
// break ;
74757: GO 74761
// end ; end ;
74759: GO 74729
74761: POP
74762: POP
// if selected then
74763: LD_VAR 0 7
74767: IFFALSE 74866
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74769: LD_ADDR_VAR 0 3
74773: PUSH
74774: LD_EXP 97
74778: PUSH
74779: LD_VAR 0 2
74783: ARRAY
74784: PPUSH
74785: LD_INT 25
74787: PUSH
74788: LD_INT 12
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PPUSH
74795: CALL_OW 72
74799: PUSH
74800: FOR_IN
74801: IFFALSE 74864
// if not HasTask ( j ) then
74803: LD_VAR 0 3
74807: PPUSH
74808: CALL_OW 314
74812: NOT
74813: IFFALSE 74862
// begin if not IsInUnit ( j ) then
74815: LD_VAR 0 3
74819: PPUSH
74820: CALL_OW 310
74824: NOT
74825: IFFALSE 74841
// ComEnterUnit ( j , selected ) ;
74827: LD_VAR 0 3
74831: PPUSH
74832: LD_VAR 0 7
74836: PPUSH
74837: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74841: LD_VAR 0 3
74845: PPUSH
74846: LD_INT 16
74848: PPUSH
74849: CALL_OW 183
// AddComExitBuilding ( j ) ;
74853: LD_VAR 0 3
74857: PPUSH
74858: CALL_OW 182
// end ;
74862: GO 74800
74864: POP
74865: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74866: LD_VAR 0 5
74870: PPUSH
74871: LD_INT 11
74873: PPUSH
74874: CALL_OW 325
74878: IFFALSE 75137
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74880: LD_ADDR_VAR 0 4
74884: PUSH
74885: LD_EXP 97
74889: PUSH
74890: LD_VAR 0 2
74894: ARRAY
74895: PPUSH
74896: LD_INT 25
74898: PUSH
74899: LD_INT 16
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PPUSH
74906: CALL_OW 72
74910: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74911: LD_VAR 0 4
74915: PUSH
74916: LD_INT 6
74918: GREATEREQUAL
74919: PUSH
74920: LD_VAR 0 5
74924: PPUSH
74925: LD_INT 2
74927: PPUSH
74928: CALL_OW 325
74932: NOT
74933: OR
74934: IFFALSE 75137
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74936: LD_ADDR_VAR 0 8
74940: PUSH
74941: LD_EXP 68
74945: PUSH
74946: LD_VAR 0 2
74950: ARRAY
74951: PPUSH
74952: LD_INT 2
74954: PUSH
74955: LD_INT 30
74957: PUSH
74958: LD_INT 4
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 30
74967: PUSH
74968: LD_INT 5
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: LIST
74979: PPUSH
74980: CALL_OW 72
74984: ST_TO_ADDR
// if barracks then
74985: LD_VAR 0 8
74989: IFFALSE 75137
// begin selected := 0 ;
74991: LD_ADDR_VAR 0 7
74995: PUSH
74996: LD_INT 0
74998: ST_TO_ADDR
// for j in barracks do
74999: LD_ADDR_VAR 0 3
75003: PUSH
75004: LD_VAR 0 8
75008: PUSH
75009: FOR_IN
75010: IFFALSE 75041
// begin if UnitsInside ( j ) < 6 then
75012: LD_VAR 0 3
75016: PPUSH
75017: CALL_OW 313
75021: PUSH
75022: LD_INT 6
75024: LESS
75025: IFFALSE 75039
// begin selected := j ;
75027: LD_ADDR_VAR 0 7
75031: PUSH
75032: LD_VAR 0 3
75036: ST_TO_ADDR
// break ;
75037: GO 75041
// end ; end ;
75039: GO 75009
75041: POP
75042: POP
// if selected then
75043: LD_VAR 0 7
75047: IFFALSE 75137
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75049: LD_ADDR_VAR 0 3
75053: PUSH
75054: LD_EXP 97
75058: PUSH
75059: LD_VAR 0 2
75063: ARRAY
75064: PPUSH
75065: LD_INT 25
75067: PUSH
75068: LD_INT 12
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: PPUSH
75075: CALL_OW 72
75079: PUSH
75080: FOR_IN
75081: IFFALSE 75135
// if not IsInUnit ( j ) and not HasTask ( j ) then
75083: LD_VAR 0 3
75087: PPUSH
75088: CALL_OW 310
75092: NOT
75093: PUSH
75094: LD_VAR 0 3
75098: PPUSH
75099: CALL_OW 314
75103: NOT
75104: AND
75105: IFFALSE 75133
// begin ComEnterUnit ( j , selected ) ;
75107: LD_VAR 0 3
75111: PPUSH
75112: LD_VAR 0 7
75116: PPUSH
75117: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75121: LD_VAR 0 3
75125: PPUSH
75126: LD_INT 15
75128: PPUSH
75129: CALL_OW 183
// end ;
75133: GO 75080
75135: POP
75136: POP
// end ; end ; end ; end ; end ;
75137: GO 74530
75139: POP
75140: POP
// end ;
75141: LD_VAR 0 1
75145: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75146: LD_INT 0
75148: PPUSH
75149: PPUSH
75150: PPUSH
75151: PPUSH
// if not mc_bases then
75152: LD_EXP 68
75156: NOT
75157: IFFALSE 75161
// exit ;
75159: GO 75339
// for i = 1 to mc_bases do
75161: LD_ADDR_VAR 0 2
75165: PUSH
75166: DOUBLE
75167: LD_INT 1
75169: DEC
75170: ST_TO_ADDR
75171: LD_EXP 68
75175: PUSH
75176: FOR_TO
75177: IFFALSE 75337
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75179: LD_ADDR_VAR 0 4
75183: PUSH
75184: LD_EXP 68
75188: PUSH
75189: LD_VAR 0 2
75193: ARRAY
75194: PPUSH
75195: LD_INT 25
75197: PUSH
75198: LD_INT 9
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PPUSH
75205: CALL_OW 72
75209: ST_TO_ADDR
// if not tmp then
75210: LD_VAR 0 4
75214: NOT
75215: IFFALSE 75219
// continue ;
75217: GO 75176
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75219: LD_EXP 94
75223: PUSH
75224: LD_VAR 0 2
75228: ARRAY
75229: PPUSH
75230: LD_INT 29
75232: PPUSH
75233: CALL_OW 325
75237: NOT
75238: PUSH
75239: LD_EXP 94
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PPUSH
75250: LD_INT 28
75252: PPUSH
75253: CALL_OW 325
75257: NOT
75258: AND
75259: IFFALSE 75263
// continue ;
75261: GO 75176
// for j in tmp do
75263: LD_ADDR_VAR 0 3
75267: PUSH
75268: LD_VAR 0 4
75272: PUSH
75273: FOR_IN
75274: IFFALSE 75333
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75276: LD_VAR 0 3
75280: PUSH
75281: LD_EXP 71
75285: PUSH
75286: LD_VAR 0 2
75290: ARRAY
75291: PUSH
75292: LD_INT 1
75294: ARRAY
75295: IN
75296: NOT
75297: PUSH
75298: LD_VAR 0 3
75302: PUSH
75303: LD_EXP 71
75307: PUSH
75308: LD_VAR 0 2
75312: ARRAY
75313: PUSH
75314: LD_INT 2
75316: ARRAY
75317: IN
75318: NOT
75319: AND
75320: IFFALSE 75331
// ComSpaceTimeShoot ( j ) ;
75322: LD_VAR 0 3
75326: PPUSH
75327: CALL 14558 0 1
75331: GO 75273
75333: POP
75334: POP
// end ;
75335: GO 75176
75337: POP
75338: POP
// end ;
75339: LD_VAR 0 1
75343: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75344: LD_INT 0
75346: PPUSH
75347: PPUSH
75348: PPUSH
75349: PPUSH
75350: PPUSH
75351: PPUSH
75352: PPUSH
75353: PPUSH
75354: PPUSH
// if not mc_bases then
75355: LD_EXP 68
75359: NOT
75360: IFFALSE 75364
// exit ;
75362: GO 75986
// for i = 1 to mc_bases do
75364: LD_ADDR_VAR 0 2
75368: PUSH
75369: DOUBLE
75370: LD_INT 1
75372: DEC
75373: ST_TO_ADDR
75374: LD_EXP 68
75378: PUSH
75379: FOR_TO
75380: IFFALSE 75984
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75382: LD_EXP 103
75386: PUSH
75387: LD_VAR 0 2
75391: ARRAY
75392: NOT
75393: PUSH
75394: LD_INT 38
75396: PPUSH
75397: LD_EXP 94
75401: PUSH
75402: LD_VAR 0 2
75406: ARRAY
75407: PPUSH
75408: CALL_OW 321
75412: PUSH
75413: LD_INT 2
75415: NONEQUAL
75416: OR
75417: IFFALSE 75421
// continue ;
75419: GO 75379
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75421: LD_ADDR_VAR 0 8
75425: PUSH
75426: LD_EXP 68
75430: PUSH
75431: LD_VAR 0 2
75435: ARRAY
75436: PPUSH
75437: LD_INT 30
75439: PUSH
75440: LD_INT 34
75442: PUSH
75443: EMPTY
75444: LIST
75445: LIST
75446: PPUSH
75447: CALL_OW 72
75451: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75452: LD_ADDR_VAR 0 9
75456: PUSH
75457: LD_EXP 68
75461: PUSH
75462: LD_VAR 0 2
75466: ARRAY
75467: PPUSH
75468: LD_INT 25
75470: PUSH
75471: LD_INT 4
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PPUSH
75478: CALL_OW 72
75482: PPUSH
75483: LD_INT 0
75485: PPUSH
75486: CALL 48569 0 2
75490: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75491: LD_VAR 0 9
75495: NOT
75496: PUSH
75497: LD_VAR 0 8
75501: NOT
75502: OR
75503: PUSH
75504: LD_EXP 68
75508: PUSH
75509: LD_VAR 0 2
75513: ARRAY
75514: PPUSH
75515: LD_INT 124
75517: PPUSH
75518: CALL 48569 0 2
75522: OR
75523: IFFALSE 75527
// continue ;
75525: GO 75379
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75527: LD_EXP 104
75531: PUSH
75532: LD_VAR 0 2
75536: ARRAY
75537: PUSH
75538: LD_EXP 103
75542: PUSH
75543: LD_VAR 0 2
75547: ARRAY
75548: LESS
75549: PUSH
75550: LD_EXP 104
75554: PUSH
75555: LD_VAR 0 2
75559: ARRAY
75560: PUSH
75561: LD_VAR 0 8
75565: LESS
75566: AND
75567: IFFALSE 75982
// begin tmp := sci [ 1 ] ;
75569: LD_ADDR_VAR 0 7
75573: PUSH
75574: LD_VAR 0 9
75578: PUSH
75579: LD_INT 1
75581: ARRAY
75582: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75583: LD_VAR 0 7
75587: PPUSH
75588: LD_INT 124
75590: PPUSH
75591: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75595: LD_ADDR_VAR 0 3
75599: PUSH
75600: DOUBLE
75601: LD_EXP 103
75605: PUSH
75606: LD_VAR 0 2
75610: ARRAY
75611: INC
75612: ST_TO_ADDR
75613: LD_EXP 103
75617: PUSH
75618: LD_VAR 0 2
75622: ARRAY
75623: PUSH
75624: FOR_DOWNTO
75625: IFFALSE 75968
// begin if IsInUnit ( tmp ) then
75627: LD_VAR 0 7
75631: PPUSH
75632: CALL_OW 310
75636: IFFALSE 75647
// ComExitBuilding ( tmp ) ;
75638: LD_VAR 0 7
75642: PPUSH
75643: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75647: LD_INT 35
75649: PPUSH
75650: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75654: LD_VAR 0 7
75658: PPUSH
75659: CALL_OW 310
75663: NOT
75664: PUSH
75665: LD_VAR 0 7
75669: PPUSH
75670: CALL_OW 314
75674: NOT
75675: AND
75676: IFFALSE 75647
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75678: LD_ADDR_VAR 0 6
75682: PUSH
75683: LD_VAR 0 7
75687: PPUSH
75688: CALL_OW 250
75692: PUSH
75693: LD_VAR 0 7
75697: PPUSH
75698: CALL_OW 251
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75707: LD_INT 35
75709: PPUSH
75710: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75714: LD_ADDR_VAR 0 4
75718: PUSH
75719: LD_EXP 103
75723: PUSH
75724: LD_VAR 0 2
75728: ARRAY
75729: PUSH
75730: LD_VAR 0 3
75734: ARRAY
75735: PUSH
75736: LD_INT 1
75738: ARRAY
75739: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75740: LD_ADDR_VAR 0 5
75744: PUSH
75745: LD_EXP 103
75749: PUSH
75750: LD_VAR 0 2
75754: ARRAY
75755: PUSH
75756: LD_VAR 0 3
75760: ARRAY
75761: PUSH
75762: LD_INT 2
75764: ARRAY
75765: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75766: LD_VAR 0 7
75770: PPUSH
75771: LD_INT 10
75773: PPUSH
75774: CALL 21349 0 2
75778: PUSH
75779: LD_INT 4
75781: ARRAY
75782: IFFALSE 75820
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75784: LD_VAR 0 7
75788: PPUSH
75789: LD_VAR 0 6
75793: PUSH
75794: LD_INT 1
75796: ARRAY
75797: PPUSH
75798: LD_VAR 0 6
75802: PUSH
75803: LD_INT 2
75805: ARRAY
75806: PPUSH
75807: CALL_OW 111
// wait ( 0 0$10 ) ;
75811: LD_INT 350
75813: PPUSH
75814: CALL_OW 67
// end else
75818: GO 75846
// begin ComMoveXY ( tmp , x , y ) ;
75820: LD_VAR 0 7
75824: PPUSH
75825: LD_VAR 0 4
75829: PPUSH
75830: LD_VAR 0 5
75834: PPUSH
75835: CALL_OW 111
// wait ( 0 0$3 ) ;
75839: LD_INT 105
75841: PPUSH
75842: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75846: LD_VAR 0 7
75850: PPUSH
75851: LD_VAR 0 4
75855: PPUSH
75856: LD_VAR 0 5
75860: PPUSH
75861: CALL_OW 307
75865: IFFALSE 75707
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75867: LD_VAR 0 7
75871: PPUSH
75872: LD_VAR 0 4
75876: PPUSH
75877: LD_VAR 0 5
75881: PPUSH
75882: LD_VAR 0 8
75886: PUSH
75887: LD_VAR 0 3
75891: ARRAY
75892: PPUSH
75893: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75897: LD_INT 35
75899: PPUSH
75900: CALL_OW 67
// until not HasTask ( tmp ) ;
75904: LD_VAR 0 7
75908: PPUSH
75909: CALL_OW 314
75913: NOT
75914: IFFALSE 75897
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75916: LD_ADDR_EXP 104
75920: PUSH
75921: LD_EXP 104
75925: PPUSH
75926: LD_VAR 0 2
75930: PUSH
75931: LD_EXP 104
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: PUSH
75942: LD_INT 1
75944: PLUS
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PPUSH
75950: LD_VAR 0 8
75954: PUSH
75955: LD_VAR 0 3
75959: ARRAY
75960: PPUSH
75961: CALL 18750 0 3
75965: ST_TO_ADDR
// end ;
75966: GO 75624
75968: POP
75969: POP
// MC_Reset ( i , 124 ) ;
75970: LD_VAR 0 2
75974: PPUSH
75975: LD_INT 124
75977: PPUSH
75978: CALL 59124 0 2
// end ; end ;
75982: GO 75379
75984: POP
75985: POP
// end ;
75986: LD_VAR 0 1
75990: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75991: LD_INT 0
75993: PPUSH
75994: PPUSH
75995: PPUSH
// if not mc_bases then
75996: LD_EXP 68
76000: NOT
76001: IFFALSE 76005
// exit ;
76003: GO 76611
// for i = 1 to mc_bases do
76005: LD_ADDR_VAR 0 2
76009: PUSH
76010: DOUBLE
76011: LD_INT 1
76013: DEC
76014: ST_TO_ADDR
76015: LD_EXP 68
76019: PUSH
76020: FOR_TO
76021: IFFALSE 76609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76023: LD_ADDR_VAR 0 3
76027: PUSH
76028: LD_EXP 68
76032: PUSH
76033: LD_VAR 0 2
76037: ARRAY
76038: PPUSH
76039: LD_INT 25
76041: PUSH
76042: LD_INT 4
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PPUSH
76049: CALL_OW 72
76053: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76054: LD_VAR 0 3
76058: NOT
76059: PUSH
76060: LD_EXP 105
76064: PUSH
76065: LD_VAR 0 2
76069: ARRAY
76070: NOT
76071: OR
76072: PUSH
76073: LD_EXP 68
76077: PUSH
76078: LD_VAR 0 2
76082: ARRAY
76083: PPUSH
76084: LD_INT 2
76086: PUSH
76087: LD_INT 30
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 30
76099: PUSH
76100: LD_INT 1
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: LIST
76111: PPUSH
76112: CALL_OW 72
76116: NOT
76117: OR
76118: IFFALSE 76168
// begin if mc_deposits_finder [ i ] then
76120: LD_EXP 106
76124: PUSH
76125: LD_VAR 0 2
76129: ARRAY
76130: IFFALSE 76166
// begin MC_Reset ( i , 125 ) ;
76132: LD_VAR 0 2
76136: PPUSH
76137: LD_INT 125
76139: PPUSH
76140: CALL 59124 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76144: LD_ADDR_EXP 106
76148: PUSH
76149: LD_EXP 106
76153: PPUSH
76154: LD_VAR 0 2
76158: PPUSH
76159: EMPTY
76160: PPUSH
76161: CALL_OW 1
76165: ST_TO_ADDR
// end ; continue ;
76166: GO 76020
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76168: LD_EXP 105
76172: PUSH
76173: LD_VAR 0 2
76177: ARRAY
76178: PUSH
76179: LD_INT 1
76181: ARRAY
76182: PUSH
76183: LD_INT 3
76185: ARRAY
76186: PUSH
76187: LD_INT 1
76189: EQUAL
76190: PUSH
76191: LD_INT 20
76193: PPUSH
76194: LD_EXP 94
76198: PUSH
76199: LD_VAR 0 2
76203: ARRAY
76204: PPUSH
76205: CALL_OW 321
76209: PUSH
76210: LD_INT 2
76212: NONEQUAL
76213: AND
76214: IFFALSE 76264
// begin if mc_deposits_finder [ i ] then
76216: LD_EXP 106
76220: PUSH
76221: LD_VAR 0 2
76225: ARRAY
76226: IFFALSE 76262
// begin MC_Reset ( i , 125 ) ;
76228: LD_VAR 0 2
76232: PPUSH
76233: LD_INT 125
76235: PPUSH
76236: CALL 59124 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76240: LD_ADDR_EXP 106
76244: PUSH
76245: LD_EXP 106
76249: PPUSH
76250: LD_VAR 0 2
76254: PPUSH
76255: EMPTY
76256: PPUSH
76257: CALL_OW 1
76261: ST_TO_ADDR
// end ; continue ;
76262: GO 76020
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76264: LD_EXP 105
76268: PUSH
76269: LD_VAR 0 2
76273: ARRAY
76274: PUSH
76275: LD_INT 1
76277: ARRAY
76278: PUSH
76279: LD_INT 1
76281: ARRAY
76282: PPUSH
76283: LD_EXP 105
76287: PUSH
76288: LD_VAR 0 2
76292: ARRAY
76293: PUSH
76294: LD_INT 1
76296: ARRAY
76297: PUSH
76298: LD_INT 2
76300: ARRAY
76301: PPUSH
76302: LD_EXP 94
76306: PUSH
76307: LD_VAR 0 2
76311: ARRAY
76312: PPUSH
76313: CALL_OW 440
76317: IFFALSE 76360
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76319: LD_ADDR_EXP 105
76323: PUSH
76324: LD_EXP 105
76328: PPUSH
76329: LD_VAR 0 2
76333: PPUSH
76334: LD_EXP 105
76338: PUSH
76339: LD_VAR 0 2
76343: ARRAY
76344: PPUSH
76345: LD_INT 1
76347: PPUSH
76348: CALL_OW 3
76352: PPUSH
76353: CALL_OW 1
76357: ST_TO_ADDR
76358: GO 76607
// begin if not mc_deposits_finder [ i ] then
76360: LD_EXP 106
76364: PUSH
76365: LD_VAR 0 2
76369: ARRAY
76370: NOT
76371: IFFALSE 76423
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76373: LD_ADDR_EXP 106
76377: PUSH
76378: LD_EXP 106
76382: PPUSH
76383: LD_VAR 0 2
76387: PPUSH
76388: LD_VAR 0 3
76392: PUSH
76393: LD_INT 1
76395: ARRAY
76396: PUSH
76397: EMPTY
76398: LIST
76399: PPUSH
76400: CALL_OW 1
76404: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76405: LD_VAR 0 3
76409: PUSH
76410: LD_INT 1
76412: ARRAY
76413: PPUSH
76414: LD_INT 125
76416: PPUSH
76417: CALL_OW 109
// end else
76421: GO 76607
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76423: LD_EXP 106
76427: PUSH
76428: LD_VAR 0 2
76432: ARRAY
76433: PUSH
76434: LD_INT 1
76436: ARRAY
76437: PPUSH
76438: CALL_OW 310
76442: IFFALSE 76465
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76444: LD_EXP 106
76448: PUSH
76449: LD_VAR 0 2
76453: ARRAY
76454: PUSH
76455: LD_INT 1
76457: ARRAY
76458: PPUSH
76459: CALL_OW 122
76463: GO 76607
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76465: LD_EXP 106
76469: PUSH
76470: LD_VAR 0 2
76474: ARRAY
76475: PUSH
76476: LD_INT 1
76478: ARRAY
76479: PPUSH
76480: CALL_OW 314
76484: NOT
76485: PUSH
76486: LD_EXP 106
76490: PUSH
76491: LD_VAR 0 2
76495: ARRAY
76496: PUSH
76497: LD_INT 1
76499: ARRAY
76500: PPUSH
76501: LD_EXP 105
76505: PUSH
76506: LD_VAR 0 2
76510: ARRAY
76511: PUSH
76512: LD_INT 1
76514: ARRAY
76515: PUSH
76516: LD_INT 1
76518: ARRAY
76519: PPUSH
76520: LD_EXP 105
76524: PUSH
76525: LD_VAR 0 2
76529: ARRAY
76530: PUSH
76531: LD_INT 1
76533: ARRAY
76534: PUSH
76535: LD_INT 2
76537: ARRAY
76538: PPUSH
76539: CALL_OW 297
76543: PUSH
76544: LD_INT 6
76546: GREATER
76547: AND
76548: IFFALSE 76607
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76550: LD_EXP 106
76554: PUSH
76555: LD_VAR 0 2
76559: ARRAY
76560: PUSH
76561: LD_INT 1
76563: ARRAY
76564: PPUSH
76565: LD_EXP 105
76569: PUSH
76570: LD_VAR 0 2
76574: ARRAY
76575: PUSH
76576: LD_INT 1
76578: ARRAY
76579: PUSH
76580: LD_INT 1
76582: ARRAY
76583: PPUSH
76584: LD_EXP 105
76588: PUSH
76589: LD_VAR 0 2
76593: ARRAY
76594: PUSH
76595: LD_INT 1
76597: ARRAY
76598: PUSH
76599: LD_INT 2
76601: ARRAY
76602: PPUSH
76603: CALL_OW 111
// end ; end ; end ;
76607: GO 76020
76609: POP
76610: POP
// end ;
76611: LD_VAR 0 1
76615: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76616: LD_INT 0
76618: PPUSH
76619: PPUSH
76620: PPUSH
76621: PPUSH
76622: PPUSH
76623: PPUSH
76624: PPUSH
76625: PPUSH
76626: PPUSH
76627: PPUSH
76628: PPUSH
// if not mc_bases then
76629: LD_EXP 68
76633: NOT
76634: IFFALSE 76638
// exit ;
76636: GO 77578
// for i = 1 to mc_bases do
76638: LD_ADDR_VAR 0 2
76642: PUSH
76643: DOUBLE
76644: LD_INT 1
76646: DEC
76647: ST_TO_ADDR
76648: LD_EXP 68
76652: PUSH
76653: FOR_TO
76654: IFFALSE 77576
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76656: LD_EXP 68
76660: PUSH
76661: LD_VAR 0 2
76665: ARRAY
76666: NOT
76667: PUSH
76668: LD_EXP 91
76672: PUSH
76673: LD_VAR 0 2
76677: ARRAY
76678: OR
76679: IFFALSE 76683
// continue ;
76681: GO 76653
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76683: LD_ADDR_VAR 0 7
76687: PUSH
76688: LD_EXP 68
76692: PUSH
76693: LD_VAR 0 2
76697: ARRAY
76698: PUSH
76699: LD_INT 1
76701: ARRAY
76702: PPUSH
76703: CALL_OW 248
76707: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76708: LD_VAR 0 7
76712: PUSH
76713: LD_INT 3
76715: EQUAL
76716: PUSH
76717: LD_EXP 87
76721: PUSH
76722: LD_VAR 0 2
76726: ARRAY
76727: PUSH
76728: LD_EXP 90
76732: PUSH
76733: LD_VAR 0 2
76737: ARRAY
76738: UNION
76739: PPUSH
76740: LD_INT 33
76742: PUSH
76743: LD_INT 2
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PPUSH
76750: CALL_OW 72
76754: NOT
76755: OR
76756: IFFALSE 76760
// continue ;
76758: GO 76653
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76760: LD_ADDR_VAR 0 9
76764: PUSH
76765: LD_EXP 68
76769: PUSH
76770: LD_VAR 0 2
76774: ARRAY
76775: PPUSH
76776: LD_INT 30
76778: PUSH
76779: LD_INT 36
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PPUSH
76786: CALL_OW 72
76790: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76791: LD_ADDR_VAR 0 10
76795: PUSH
76796: LD_EXP 87
76800: PUSH
76801: LD_VAR 0 2
76805: ARRAY
76806: PPUSH
76807: LD_INT 34
76809: PUSH
76810: LD_INT 31
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PPUSH
76817: CALL_OW 72
76821: ST_TO_ADDR
// if not cts and not mcts then
76822: LD_VAR 0 9
76826: NOT
76827: PUSH
76828: LD_VAR 0 10
76832: NOT
76833: AND
76834: IFFALSE 76838
// continue ;
76836: GO 76653
// x := cts ;
76838: LD_ADDR_VAR 0 11
76842: PUSH
76843: LD_VAR 0 9
76847: ST_TO_ADDR
// if not x then
76848: LD_VAR 0 11
76852: NOT
76853: IFFALSE 76865
// x := mcts ;
76855: LD_ADDR_VAR 0 11
76859: PUSH
76860: LD_VAR 0 10
76864: ST_TO_ADDR
// if not x then
76865: LD_VAR 0 11
76869: NOT
76870: IFFALSE 76874
// continue ;
76872: GO 76653
// if mc_remote_driver [ i ] then
76874: LD_EXP 108
76878: PUSH
76879: LD_VAR 0 2
76883: ARRAY
76884: IFFALSE 77271
// for j in mc_remote_driver [ i ] do
76886: LD_ADDR_VAR 0 3
76890: PUSH
76891: LD_EXP 108
76895: PUSH
76896: LD_VAR 0 2
76900: ARRAY
76901: PUSH
76902: FOR_IN
76903: IFFALSE 77269
// begin if GetClass ( j ) <> 3 then
76905: LD_VAR 0 3
76909: PPUSH
76910: CALL_OW 257
76914: PUSH
76915: LD_INT 3
76917: NONEQUAL
76918: IFFALSE 76971
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76920: LD_ADDR_EXP 108
76924: PUSH
76925: LD_EXP 108
76929: PPUSH
76930: LD_VAR 0 2
76934: PPUSH
76935: LD_EXP 108
76939: PUSH
76940: LD_VAR 0 2
76944: ARRAY
76945: PUSH
76946: LD_VAR 0 3
76950: DIFF
76951: PPUSH
76952: CALL_OW 1
76956: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76957: LD_VAR 0 3
76961: PPUSH
76962: LD_INT 0
76964: PPUSH
76965: CALL_OW 109
// continue ;
76969: GO 76902
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76971: LD_EXP 87
76975: PUSH
76976: LD_VAR 0 2
76980: ARRAY
76981: PPUSH
76982: LD_INT 34
76984: PUSH
76985: LD_INT 31
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 58
76994: PUSH
76995: EMPTY
76996: LIST
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PPUSH
77002: CALL_OW 72
77006: PUSH
77007: LD_VAR 0 3
77011: PPUSH
77012: CALL 48604 0 1
77016: NOT
77017: AND
77018: IFFALSE 77089
// begin if IsInUnit ( j ) then
77020: LD_VAR 0 3
77024: PPUSH
77025: CALL_OW 310
77029: IFFALSE 77040
// ComExitBuilding ( j ) ;
77031: LD_VAR 0 3
77035: PPUSH
77036: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77040: LD_VAR 0 3
77044: PPUSH
77045: LD_EXP 87
77049: PUSH
77050: LD_VAR 0 2
77054: ARRAY
77055: PPUSH
77056: LD_INT 34
77058: PUSH
77059: LD_INT 31
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 58
77068: PUSH
77069: EMPTY
77070: LIST
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PPUSH
77076: CALL_OW 72
77080: PUSH
77081: LD_INT 1
77083: ARRAY
77084: PPUSH
77085: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77089: LD_VAR 0 3
77093: PPUSH
77094: CALL_OW 310
77098: NOT
77099: PUSH
77100: LD_VAR 0 3
77104: PPUSH
77105: CALL_OW 310
77109: PPUSH
77110: CALL_OW 266
77114: PUSH
77115: LD_INT 36
77117: NONEQUAL
77118: PUSH
77119: LD_VAR 0 3
77123: PPUSH
77124: CALL 48604 0 1
77128: NOT
77129: AND
77130: OR
77131: IFFALSE 77267
// begin if IsInUnit ( j ) then
77133: LD_VAR 0 3
77137: PPUSH
77138: CALL_OW 310
77142: IFFALSE 77153
// ComExitBuilding ( j ) ;
77144: LD_VAR 0 3
77148: PPUSH
77149: CALL_OW 122
// ct := 0 ;
77153: LD_ADDR_VAR 0 8
77157: PUSH
77158: LD_INT 0
77160: ST_TO_ADDR
// for k in x do
77161: LD_ADDR_VAR 0 4
77165: PUSH
77166: LD_VAR 0 11
77170: PUSH
77171: FOR_IN
77172: IFFALSE 77245
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77174: LD_VAR 0 4
77178: PPUSH
77179: CALL_OW 264
77183: PUSH
77184: LD_INT 31
77186: EQUAL
77187: PUSH
77188: LD_VAR 0 4
77192: PPUSH
77193: CALL_OW 311
77197: NOT
77198: AND
77199: PUSH
77200: LD_VAR 0 4
77204: PPUSH
77205: CALL_OW 266
77209: PUSH
77210: LD_INT 36
77212: EQUAL
77213: PUSH
77214: LD_VAR 0 4
77218: PPUSH
77219: CALL_OW 313
77223: PUSH
77224: LD_INT 3
77226: LESS
77227: AND
77228: OR
77229: IFFALSE 77243
// begin ct := k ;
77231: LD_ADDR_VAR 0 8
77235: PUSH
77236: LD_VAR 0 4
77240: ST_TO_ADDR
// break ;
77241: GO 77245
// end ;
77243: GO 77171
77245: POP
77246: POP
// if ct then
77247: LD_VAR 0 8
77251: IFFALSE 77267
// ComEnterUnit ( j , ct ) ;
77253: LD_VAR 0 3
77257: PPUSH
77258: LD_VAR 0 8
77262: PPUSH
77263: CALL_OW 120
// end ; end ;
77267: GO 76902
77269: POP
77270: POP
// places := 0 ;
77271: LD_ADDR_VAR 0 5
77275: PUSH
77276: LD_INT 0
77278: ST_TO_ADDR
// for j = 1 to x do
77279: LD_ADDR_VAR 0 3
77283: PUSH
77284: DOUBLE
77285: LD_INT 1
77287: DEC
77288: ST_TO_ADDR
77289: LD_VAR 0 11
77293: PUSH
77294: FOR_TO
77295: IFFALSE 77371
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77297: LD_VAR 0 11
77301: PUSH
77302: LD_VAR 0 3
77306: ARRAY
77307: PPUSH
77308: CALL_OW 264
77312: PUSH
77313: LD_INT 31
77315: EQUAL
77316: IFFALSE 77334
// places := places + 1 else
77318: LD_ADDR_VAR 0 5
77322: PUSH
77323: LD_VAR 0 5
77327: PUSH
77328: LD_INT 1
77330: PLUS
77331: ST_TO_ADDR
77332: GO 77369
// if GetBType ( x [ j ] ) = b_control_tower then
77334: LD_VAR 0 11
77338: PUSH
77339: LD_VAR 0 3
77343: ARRAY
77344: PPUSH
77345: CALL_OW 266
77349: PUSH
77350: LD_INT 36
77352: EQUAL
77353: IFFALSE 77369
// places := places + 3 ;
77355: LD_ADDR_VAR 0 5
77359: PUSH
77360: LD_VAR 0 5
77364: PUSH
77365: LD_INT 3
77367: PLUS
77368: ST_TO_ADDR
77369: GO 77294
77371: POP
77372: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77373: LD_VAR 0 5
77377: PUSH
77378: LD_INT 0
77380: EQUAL
77381: PUSH
77382: LD_VAR 0 5
77386: PUSH
77387: LD_EXP 108
77391: PUSH
77392: LD_VAR 0 2
77396: ARRAY
77397: LESSEQUAL
77398: OR
77399: IFFALSE 77403
// continue ;
77401: GO 76653
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77403: LD_ADDR_VAR 0 6
77407: PUSH
77408: LD_EXP 68
77412: PUSH
77413: LD_VAR 0 2
77417: ARRAY
77418: PPUSH
77419: LD_INT 25
77421: PUSH
77422: LD_INT 3
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PPUSH
77429: CALL_OW 72
77433: PUSH
77434: LD_EXP 108
77438: PUSH
77439: LD_VAR 0 2
77443: ARRAY
77444: DIFF
77445: PPUSH
77446: LD_INT 3
77448: PPUSH
77449: CALL 49504 0 2
77453: ST_TO_ADDR
// for j in tmp do
77454: LD_ADDR_VAR 0 3
77458: PUSH
77459: LD_VAR 0 6
77463: PUSH
77464: FOR_IN
77465: IFFALSE 77500
// if GetTag ( j ) > 0 then
77467: LD_VAR 0 3
77471: PPUSH
77472: CALL_OW 110
77476: PUSH
77477: LD_INT 0
77479: GREATER
77480: IFFALSE 77498
// tmp := tmp diff j ;
77482: LD_ADDR_VAR 0 6
77486: PUSH
77487: LD_VAR 0 6
77491: PUSH
77492: LD_VAR 0 3
77496: DIFF
77497: ST_TO_ADDR
77498: GO 77464
77500: POP
77501: POP
// if not tmp then
77502: LD_VAR 0 6
77506: NOT
77507: IFFALSE 77511
// continue ;
77509: GO 76653
// if places then
77511: LD_VAR 0 5
77515: IFFALSE 77574
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77517: LD_ADDR_EXP 108
77521: PUSH
77522: LD_EXP 108
77526: PPUSH
77527: LD_VAR 0 2
77531: PPUSH
77532: LD_EXP 108
77536: PUSH
77537: LD_VAR 0 2
77541: ARRAY
77542: PUSH
77543: LD_VAR 0 6
77547: PUSH
77548: LD_INT 1
77550: ARRAY
77551: UNION
77552: PPUSH
77553: CALL_OW 1
77557: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77558: LD_VAR 0 6
77562: PUSH
77563: LD_INT 1
77565: ARRAY
77566: PPUSH
77567: LD_INT 126
77569: PPUSH
77570: CALL_OW 109
// end ; end ;
77574: GO 76653
77576: POP
77577: POP
// end ;
77578: LD_VAR 0 1
77582: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77583: LD_INT 0
77585: PPUSH
77586: PPUSH
77587: PPUSH
77588: PPUSH
77589: PPUSH
77590: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77591: LD_VAR 0 1
77595: NOT
77596: PUSH
77597: LD_VAR 0 2
77601: NOT
77602: OR
77603: PUSH
77604: LD_VAR 0 3
77608: NOT
77609: OR
77610: PUSH
77611: LD_VAR 0 4
77615: PUSH
77616: LD_INT 1
77618: PUSH
77619: LD_INT 2
77621: PUSH
77622: LD_INT 3
77624: PUSH
77625: LD_INT 4
77627: PUSH
77628: LD_INT 5
77630: PUSH
77631: LD_INT 8
77633: PUSH
77634: LD_INT 9
77636: PUSH
77637: LD_INT 15
77639: PUSH
77640: LD_INT 16
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: IN
77654: NOT
77655: OR
77656: IFFALSE 77660
// exit ;
77658: GO 78560
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77660: LD_ADDR_VAR 0 2
77664: PUSH
77665: LD_VAR 0 2
77669: PPUSH
77670: LD_INT 21
77672: PUSH
77673: LD_INT 3
77675: PUSH
77676: EMPTY
77677: LIST
77678: LIST
77679: PUSH
77680: LD_INT 24
77682: PUSH
77683: LD_INT 250
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PPUSH
77694: CALL_OW 72
77698: ST_TO_ADDR
// case class of 1 , 15 :
77699: LD_VAR 0 4
77703: PUSH
77704: LD_INT 1
77706: DOUBLE
77707: EQUAL
77708: IFTRUE 77718
77710: LD_INT 15
77712: DOUBLE
77713: EQUAL
77714: IFTRUE 77718
77716: GO 77803
77718: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77719: LD_ADDR_VAR 0 8
77723: PUSH
77724: LD_VAR 0 2
77728: PPUSH
77729: LD_INT 2
77731: PUSH
77732: LD_INT 30
77734: PUSH
77735: LD_INT 32
77737: PUSH
77738: EMPTY
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 30
77744: PUSH
77745: LD_INT 31
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: LIST
77756: PPUSH
77757: CALL_OW 72
77761: PUSH
77762: LD_VAR 0 2
77766: PPUSH
77767: LD_INT 2
77769: PUSH
77770: LD_INT 30
77772: PUSH
77773: LD_INT 4
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 30
77782: PUSH
77783: LD_INT 5
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: LIST
77794: PPUSH
77795: CALL_OW 72
77799: ADD
77800: ST_TO_ADDR
77801: GO 78049
77803: LD_INT 2
77805: DOUBLE
77806: EQUAL
77807: IFTRUE 77817
77809: LD_INT 16
77811: DOUBLE
77812: EQUAL
77813: IFTRUE 77817
77815: GO 77863
77817: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77818: LD_ADDR_VAR 0 8
77822: PUSH
77823: LD_VAR 0 2
77827: PPUSH
77828: LD_INT 2
77830: PUSH
77831: LD_INT 30
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 30
77843: PUSH
77844: LD_INT 1
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: LIST
77855: PPUSH
77856: CALL_OW 72
77860: ST_TO_ADDR
77861: GO 78049
77863: LD_INT 3
77865: DOUBLE
77866: EQUAL
77867: IFTRUE 77871
77869: GO 77917
77871: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77872: LD_ADDR_VAR 0 8
77876: PUSH
77877: LD_VAR 0 2
77881: PPUSH
77882: LD_INT 2
77884: PUSH
77885: LD_INT 30
77887: PUSH
77888: LD_INT 2
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 30
77897: PUSH
77898: LD_INT 3
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: PPUSH
77910: CALL_OW 72
77914: ST_TO_ADDR
77915: GO 78049
77917: LD_INT 4
77919: DOUBLE
77920: EQUAL
77921: IFTRUE 77925
77923: GO 77982
77925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77926: LD_ADDR_VAR 0 8
77930: PUSH
77931: LD_VAR 0 2
77935: PPUSH
77936: LD_INT 2
77938: PUSH
77939: LD_INT 30
77941: PUSH
77942: LD_INT 6
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 30
77951: PUSH
77952: LD_INT 7
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 30
77961: PUSH
77962: LD_INT 8
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: PPUSH
77975: CALL_OW 72
77979: ST_TO_ADDR
77980: GO 78049
77982: LD_INT 5
77984: DOUBLE
77985: EQUAL
77986: IFTRUE 78002
77988: LD_INT 8
77990: DOUBLE
77991: EQUAL
77992: IFTRUE 78002
77994: LD_INT 9
77996: DOUBLE
77997: EQUAL
77998: IFTRUE 78002
78000: GO 78048
78002: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78003: LD_ADDR_VAR 0 8
78007: PUSH
78008: LD_VAR 0 2
78012: PPUSH
78013: LD_INT 2
78015: PUSH
78016: LD_INT 30
78018: PUSH
78019: LD_INT 4
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: LD_INT 30
78028: PUSH
78029: LD_INT 5
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: LIST
78040: PPUSH
78041: CALL_OW 72
78045: ST_TO_ADDR
78046: GO 78049
78048: POP
// if not tmp then
78049: LD_VAR 0 8
78053: NOT
78054: IFFALSE 78058
// exit ;
78056: GO 78560
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78058: LD_VAR 0 4
78062: PUSH
78063: LD_INT 1
78065: PUSH
78066: LD_INT 15
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: IN
78073: PUSH
78074: LD_EXP 77
78078: PUSH
78079: LD_VAR 0 1
78083: ARRAY
78084: AND
78085: IFFALSE 78241
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78087: LD_ADDR_VAR 0 9
78091: PUSH
78092: LD_EXP 77
78096: PUSH
78097: LD_VAR 0 1
78101: ARRAY
78102: PUSH
78103: LD_INT 1
78105: ARRAY
78106: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78107: LD_VAR 0 9
78111: PUSH
78112: LD_EXP 78
78116: PUSH
78117: LD_VAR 0 1
78121: ARRAY
78122: IN
78123: NOT
78124: IFFALSE 78239
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78126: LD_ADDR_EXP 78
78130: PUSH
78131: LD_EXP 78
78135: PPUSH
78136: LD_VAR 0 1
78140: PUSH
78141: LD_EXP 78
78145: PUSH
78146: LD_VAR 0 1
78150: ARRAY
78151: PUSH
78152: LD_INT 1
78154: PLUS
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PPUSH
78160: LD_VAR 0 9
78164: PPUSH
78165: CALL 18750 0 3
78169: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78170: LD_ADDR_EXP 77
78174: PUSH
78175: LD_EXP 77
78179: PPUSH
78180: LD_VAR 0 1
78184: PPUSH
78185: LD_EXP 77
78189: PUSH
78190: LD_VAR 0 1
78194: ARRAY
78195: PUSH
78196: LD_VAR 0 9
78200: DIFF
78201: PPUSH
78202: CALL_OW 1
78206: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78207: LD_VAR 0 3
78211: PPUSH
78212: LD_EXP 78
78216: PUSH
78217: LD_VAR 0 1
78221: ARRAY
78222: PUSH
78223: LD_EXP 78
78227: PUSH
78228: LD_VAR 0 1
78232: ARRAY
78233: ARRAY
78234: PPUSH
78235: CALL_OW 120
// end ; exit ;
78239: GO 78560
// end ; if tmp > 1 then
78241: LD_VAR 0 8
78245: PUSH
78246: LD_INT 1
78248: GREATER
78249: IFFALSE 78353
// for i = 2 to tmp do
78251: LD_ADDR_VAR 0 6
78255: PUSH
78256: DOUBLE
78257: LD_INT 2
78259: DEC
78260: ST_TO_ADDR
78261: LD_VAR 0 8
78265: PUSH
78266: FOR_TO
78267: IFFALSE 78351
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78269: LD_VAR 0 8
78273: PUSH
78274: LD_VAR 0 6
78278: ARRAY
78279: PPUSH
78280: CALL_OW 461
78284: PUSH
78285: LD_INT 6
78287: EQUAL
78288: IFFALSE 78349
// begin x := tmp [ i ] ;
78290: LD_ADDR_VAR 0 9
78294: PUSH
78295: LD_VAR 0 8
78299: PUSH
78300: LD_VAR 0 6
78304: ARRAY
78305: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78306: LD_ADDR_VAR 0 8
78310: PUSH
78311: LD_VAR 0 8
78315: PPUSH
78316: LD_VAR 0 6
78320: PPUSH
78321: CALL_OW 3
78325: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78326: LD_ADDR_VAR 0 8
78330: PUSH
78331: LD_VAR 0 8
78335: PPUSH
78336: LD_INT 1
78338: PPUSH
78339: LD_VAR 0 9
78343: PPUSH
78344: CALL_OW 2
78348: ST_TO_ADDR
// end ;
78349: GO 78266
78351: POP
78352: POP
// for i in tmp do
78353: LD_ADDR_VAR 0 6
78357: PUSH
78358: LD_VAR 0 8
78362: PUSH
78363: FOR_IN
78364: IFFALSE 78433
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78366: LD_VAR 0 6
78370: PPUSH
78371: CALL_OW 313
78375: PUSH
78376: LD_INT 6
78378: LESS
78379: PUSH
78380: LD_VAR 0 6
78384: PPUSH
78385: CALL_OW 266
78389: PUSH
78390: LD_INT 31
78392: PUSH
78393: LD_INT 32
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: IN
78400: NOT
78401: AND
78402: PUSH
78403: LD_VAR 0 6
78407: PPUSH
78408: CALL_OW 313
78412: PUSH
78413: LD_INT 0
78415: EQUAL
78416: OR
78417: IFFALSE 78431
// begin j := i ;
78419: LD_ADDR_VAR 0 7
78423: PUSH
78424: LD_VAR 0 6
78428: ST_TO_ADDR
// break ;
78429: GO 78433
// end ; end ;
78431: GO 78363
78433: POP
78434: POP
// if j then
78435: LD_VAR 0 7
78439: IFFALSE 78457
// ComEnterUnit ( unit , j ) else
78441: LD_VAR 0 3
78445: PPUSH
78446: LD_VAR 0 7
78450: PPUSH
78451: CALL_OW 120
78455: GO 78560
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78457: LD_ADDR_VAR 0 10
78461: PUSH
78462: LD_VAR 0 2
78466: PPUSH
78467: LD_INT 2
78469: PUSH
78470: LD_INT 30
78472: PUSH
78473: LD_INT 0
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 30
78482: PUSH
78483: LD_INT 1
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: LIST
78494: PPUSH
78495: CALL_OW 72
78499: ST_TO_ADDR
// if depot then
78500: LD_VAR 0 10
78504: IFFALSE 78560
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78506: LD_ADDR_VAR 0 10
78510: PUSH
78511: LD_VAR 0 10
78515: PPUSH
78516: LD_VAR 0 3
78520: PPUSH
78521: CALL_OW 74
78525: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78526: LD_VAR 0 3
78530: PPUSH
78531: LD_VAR 0 10
78535: PPUSH
78536: CALL_OW 296
78540: PUSH
78541: LD_INT 10
78543: GREATER
78544: IFFALSE 78560
// ComStandNearbyBuilding ( unit , depot ) ;
78546: LD_VAR 0 3
78550: PPUSH
78551: LD_VAR 0 10
78555: PPUSH
78556: CALL 15175 0 2
// end ; end ; end ;
78560: LD_VAR 0 5
78564: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78565: LD_INT 0
78567: PPUSH
78568: PPUSH
78569: PPUSH
78570: PPUSH
// if not mc_bases then
78571: LD_EXP 68
78575: NOT
78576: IFFALSE 78580
// exit ;
78578: GO 78819
// for i = 1 to mc_bases do
78580: LD_ADDR_VAR 0 2
78584: PUSH
78585: DOUBLE
78586: LD_INT 1
78588: DEC
78589: ST_TO_ADDR
78590: LD_EXP 68
78594: PUSH
78595: FOR_TO
78596: IFFALSE 78817
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78598: LD_ADDR_VAR 0 4
78602: PUSH
78603: LD_EXP 68
78607: PUSH
78608: LD_VAR 0 2
78612: ARRAY
78613: PPUSH
78614: LD_INT 21
78616: PUSH
78617: LD_INT 1
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PPUSH
78624: CALL_OW 72
78628: PUSH
78629: LD_EXP 97
78633: PUSH
78634: LD_VAR 0 2
78638: ARRAY
78639: UNION
78640: ST_TO_ADDR
// if not tmp then
78641: LD_VAR 0 4
78645: NOT
78646: IFFALSE 78650
// continue ;
78648: GO 78595
// for j in tmp do
78650: LD_ADDR_VAR 0 3
78654: PUSH
78655: LD_VAR 0 4
78659: PUSH
78660: FOR_IN
78661: IFFALSE 78813
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78663: LD_VAR 0 3
78667: PPUSH
78668: CALL_OW 110
78672: NOT
78673: PUSH
78674: LD_VAR 0 3
78678: PPUSH
78679: CALL_OW 314
78683: NOT
78684: AND
78685: PUSH
78686: LD_VAR 0 3
78690: PPUSH
78691: CALL_OW 311
78695: NOT
78696: AND
78697: PUSH
78698: LD_VAR 0 3
78702: PPUSH
78703: CALL_OW 310
78707: NOT
78708: AND
78709: PUSH
78710: LD_VAR 0 3
78714: PUSH
78715: LD_EXP 71
78719: PUSH
78720: LD_VAR 0 2
78724: ARRAY
78725: PUSH
78726: LD_INT 1
78728: ARRAY
78729: IN
78730: NOT
78731: AND
78732: PUSH
78733: LD_VAR 0 3
78737: PUSH
78738: LD_EXP 71
78742: PUSH
78743: LD_VAR 0 2
78747: ARRAY
78748: PUSH
78749: LD_INT 2
78751: ARRAY
78752: IN
78753: NOT
78754: AND
78755: PUSH
78756: LD_VAR 0 3
78760: PUSH
78761: LD_EXP 80
78765: PUSH
78766: LD_VAR 0 2
78770: ARRAY
78771: IN
78772: NOT
78773: AND
78774: IFFALSE 78811
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78776: LD_VAR 0 2
78780: PPUSH
78781: LD_EXP 68
78785: PUSH
78786: LD_VAR 0 2
78790: ARRAY
78791: PPUSH
78792: LD_VAR 0 3
78796: PPUSH
78797: LD_VAR 0 3
78801: PPUSH
78802: CALL_OW 257
78806: PPUSH
78807: CALL 77583 0 4
// end ;
78811: GO 78660
78813: POP
78814: POP
// end ;
78815: GO 78595
78817: POP
78818: POP
// end ;
78819: LD_VAR 0 1
78823: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78824: LD_INT 0
78826: PPUSH
78827: PPUSH
78828: PPUSH
78829: PPUSH
78830: PPUSH
78831: PPUSH
// if not mc_bases [ base ] then
78832: LD_EXP 68
78836: PUSH
78837: LD_VAR 0 1
78841: ARRAY
78842: NOT
78843: IFFALSE 78847
// exit ;
78845: GO 79029
// tmp := [ ] ;
78847: LD_ADDR_VAR 0 6
78851: PUSH
78852: EMPTY
78853: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78854: LD_ADDR_VAR 0 7
78858: PUSH
78859: LD_VAR 0 3
78863: PPUSH
78864: LD_INT 0
78866: PPUSH
78867: CALL_OW 517
78871: ST_TO_ADDR
// if not list then
78872: LD_VAR 0 7
78876: NOT
78877: IFFALSE 78881
// exit ;
78879: GO 79029
// for i = 1 to amount do
78881: LD_ADDR_VAR 0 5
78885: PUSH
78886: DOUBLE
78887: LD_INT 1
78889: DEC
78890: ST_TO_ADDR
78891: LD_VAR 0 2
78895: PUSH
78896: FOR_TO
78897: IFFALSE 78977
// begin x := rand ( 1 , list [ 1 ] ) ;
78899: LD_ADDR_VAR 0 8
78903: PUSH
78904: LD_INT 1
78906: PPUSH
78907: LD_VAR 0 7
78911: PUSH
78912: LD_INT 1
78914: ARRAY
78915: PPUSH
78916: CALL_OW 12
78920: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78921: LD_ADDR_VAR 0 6
78925: PUSH
78926: LD_VAR 0 6
78930: PPUSH
78931: LD_VAR 0 5
78935: PPUSH
78936: LD_VAR 0 7
78940: PUSH
78941: LD_INT 1
78943: ARRAY
78944: PUSH
78945: LD_VAR 0 8
78949: ARRAY
78950: PUSH
78951: LD_VAR 0 7
78955: PUSH
78956: LD_INT 2
78958: ARRAY
78959: PUSH
78960: LD_VAR 0 8
78964: ARRAY
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PPUSH
78970: CALL_OW 1
78974: ST_TO_ADDR
// end ;
78975: GO 78896
78977: POP
78978: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78979: LD_ADDR_EXP 81
78983: PUSH
78984: LD_EXP 81
78988: PPUSH
78989: LD_VAR 0 1
78993: PPUSH
78994: LD_VAR 0 6
78998: PPUSH
78999: CALL_OW 1
79003: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79004: LD_ADDR_EXP 83
79008: PUSH
79009: LD_EXP 83
79013: PPUSH
79014: LD_VAR 0 1
79018: PPUSH
79019: LD_VAR 0 3
79023: PPUSH
79024: CALL_OW 1
79028: ST_TO_ADDR
// end ;
79029: LD_VAR 0 4
79033: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79034: LD_INT 0
79036: PPUSH
// if not mc_bases [ base ] then
79037: LD_EXP 68
79041: PUSH
79042: LD_VAR 0 1
79046: ARRAY
79047: NOT
79048: IFFALSE 79052
// exit ;
79050: GO 79077
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79052: LD_ADDR_EXP 73
79056: PUSH
79057: LD_EXP 73
79061: PPUSH
79062: LD_VAR 0 1
79066: PPUSH
79067: LD_VAR 0 2
79071: PPUSH
79072: CALL_OW 1
79076: ST_TO_ADDR
// end ;
79077: LD_VAR 0 3
79081: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79082: LD_INT 0
79084: PPUSH
// if not mc_bases [ base ] then
79085: LD_EXP 68
79089: PUSH
79090: LD_VAR 0 1
79094: ARRAY
79095: NOT
79096: IFFALSE 79100
// exit ;
79098: GO 79137
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79100: LD_ADDR_EXP 73
79104: PUSH
79105: LD_EXP 73
79109: PPUSH
79110: LD_VAR 0 1
79114: PPUSH
79115: LD_EXP 73
79119: PUSH
79120: LD_VAR 0 1
79124: ARRAY
79125: PUSH
79126: LD_VAR 0 2
79130: UNION
79131: PPUSH
79132: CALL_OW 1
79136: ST_TO_ADDR
// end ;
79137: LD_VAR 0 3
79141: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79142: LD_INT 0
79144: PPUSH
// if not mc_bases [ base ] then
79145: LD_EXP 68
79149: PUSH
79150: LD_VAR 0 1
79154: ARRAY
79155: NOT
79156: IFFALSE 79160
// exit ;
79158: GO 79185
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79160: LD_ADDR_EXP 89
79164: PUSH
79165: LD_EXP 89
79169: PPUSH
79170: LD_VAR 0 1
79174: PPUSH
79175: LD_VAR 0 2
79179: PPUSH
79180: CALL_OW 1
79184: ST_TO_ADDR
// end ;
79185: LD_VAR 0 3
79189: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79190: LD_INT 0
79192: PPUSH
// if not mc_bases [ base ] then
79193: LD_EXP 68
79197: PUSH
79198: LD_VAR 0 1
79202: ARRAY
79203: NOT
79204: IFFALSE 79208
// exit ;
79206: GO 79245
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79208: LD_ADDR_EXP 89
79212: PUSH
79213: LD_EXP 89
79217: PPUSH
79218: LD_VAR 0 1
79222: PPUSH
79223: LD_EXP 89
79227: PUSH
79228: LD_VAR 0 1
79232: ARRAY
79233: PUSH
79234: LD_VAR 0 2
79238: ADD
79239: PPUSH
79240: CALL_OW 1
79244: ST_TO_ADDR
// end ;
79245: LD_VAR 0 3
79249: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79250: LD_INT 0
79252: PPUSH
// if not mc_bases [ base ] then
79253: LD_EXP 68
79257: PUSH
79258: LD_VAR 0 1
79262: ARRAY
79263: NOT
79264: IFFALSE 79268
// exit ;
79266: GO 79322
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79268: LD_ADDR_EXP 90
79272: PUSH
79273: LD_EXP 90
79277: PPUSH
79278: LD_VAR 0 1
79282: PPUSH
79283: LD_VAR 0 2
79287: PPUSH
79288: CALL_OW 1
79292: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79293: LD_ADDR_EXP 79
79297: PUSH
79298: LD_EXP 79
79302: PPUSH
79303: LD_VAR 0 1
79307: PPUSH
79308: LD_VAR 0 2
79312: PUSH
79313: LD_INT 0
79315: PLUS
79316: PPUSH
79317: CALL_OW 1
79321: ST_TO_ADDR
// end ;
79322: LD_VAR 0 3
79326: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79327: LD_INT 0
79329: PPUSH
// if not mc_bases [ base ] then
79330: LD_EXP 68
79334: PUSH
79335: LD_VAR 0 1
79339: ARRAY
79340: NOT
79341: IFFALSE 79345
// exit ;
79343: GO 79370
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79345: LD_ADDR_EXP 79
79349: PUSH
79350: LD_EXP 79
79354: PPUSH
79355: LD_VAR 0 1
79359: PPUSH
79360: LD_VAR 0 2
79364: PPUSH
79365: CALL_OW 1
79369: ST_TO_ADDR
// end ;
79370: LD_VAR 0 3
79374: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79375: LD_INT 0
79377: PPUSH
79378: PPUSH
79379: PPUSH
79380: PPUSH
// if not mc_bases [ base ] then
79381: LD_EXP 68
79385: PUSH
79386: LD_VAR 0 1
79390: ARRAY
79391: NOT
79392: IFFALSE 79396
// exit ;
79394: GO 79461
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79396: LD_ADDR_EXP 88
79400: PUSH
79401: LD_EXP 88
79405: PPUSH
79406: LD_VAR 0 1
79410: PUSH
79411: LD_EXP 88
79415: PUSH
79416: LD_VAR 0 1
79420: ARRAY
79421: PUSH
79422: LD_INT 1
79424: PLUS
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PPUSH
79430: LD_VAR 0 1
79434: PUSH
79435: LD_VAR 0 2
79439: PUSH
79440: LD_VAR 0 3
79444: PUSH
79445: LD_VAR 0 4
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: PPUSH
79456: CALL 18750 0 3
79460: ST_TO_ADDR
// end ;
79461: LD_VAR 0 5
79465: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79466: LD_INT 0
79468: PPUSH
// if not mc_bases [ base ] then
79469: LD_EXP 68
79473: PUSH
79474: LD_VAR 0 1
79478: ARRAY
79479: NOT
79480: IFFALSE 79484
// exit ;
79482: GO 79509
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79484: LD_ADDR_EXP 105
79488: PUSH
79489: LD_EXP 105
79493: PPUSH
79494: LD_VAR 0 1
79498: PPUSH
79499: LD_VAR 0 2
79503: PPUSH
79504: CALL_OW 1
79508: ST_TO_ADDR
// end ;
79509: LD_VAR 0 3
79513: RET
// export function MC_GetMinesField ( base ) ; begin
79514: LD_INT 0
79516: PPUSH
// result := mc_mines [ base ] ;
79517: LD_ADDR_VAR 0 2
79521: PUSH
79522: LD_EXP 81
79526: PUSH
79527: LD_VAR 0 1
79531: ARRAY
79532: ST_TO_ADDR
// end ;
79533: LD_VAR 0 2
79537: RET
// export function MC_GetProduceList ( base ) ; begin
79538: LD_INT 0
79540: PPUSH
// result := mc_produce [ base ] ;
79541: LD_ADDR_VAR 0 2
79545: PUSH
79546: LD_EXP 89
79550: PUSH
79551: LD_VAR 0 1
79555: ARRAY
79556: ST_TO_ADDR
// end ;
79557: LD_VAR 0 2
79561: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79562: LD_INT 0
79564: PPUSH
79565: PPUSH
// if not mc_bases then
79566: LD_EXP 68
79570: NOT
79571: IFFALSE 79575
// exit ;
79573: GO 79640
// if mc_bases [ base ] then
79575: LD_EXP 68
79579: PUSH
79580: LD_VAR 0 1
79584: ARRAY
79585: IFFALSE 79640
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79587: LD_ADDR_VAR 0 3
79591: PUSH
79592: LD_EXP 68
79596: PUSH
79597: LD_VAR 0 1
79601: ARRAY
79602: PPUSH
79603: LD_INT 30
79605: PUSH
79606: LD_VAR 0 2
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PPUSH
79615: CALL_OW 72
79619: ST_TO_ADDR
// if result then
79620: LD_VAR 0 3
79624: IFFALSE 79640
// result := result [ 1 ] ;
79626: LD_ADDR_VAR 0 3
79630: PUSH
79631: LD_VAR 0 3
79635: PUSH
79636: LD_INT 1
79638: ARRAY
79639: ST_TO_ADDR
// end ; end ;
79640: LD_VAR 0 3
79644: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79645: LD_INT 0
79647: PPUSH
79648: PPUSH
// if not mc_bases then
79649: LD_EXP 68
79653: NOT
79654: IFFALSE 79658
// exit ;
79656: GO 79703
// if mc_bases [ base ] then
79658: LD_EXP 68
79662: PUSH
79663: LD_VAR 0 1
79667: ARRAY
79668: IFFALSE 79703
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79670: LD_ADDR_VAR 0 3
79674: PUSH
79675: LD_EXP 68
79679: PUSH
79680: LD_VAR 0 1
79684: ARRAY
79685: PPUSH
79686: LD_INT 30
79688: PUSH
79689: LD_VAR 0 2
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PPUSH
79698: CALL_OW 72
79702: ST_TO_ADDR
// end ;
79703: LD_VAR 0 3
79707: RET
// export function MC_SetTame ( base , area ) ; begin
79708: LD_INT 0
79710: PPUSH
// if not mc_bases or not base then
79711: LD_EXP 68
79715: NOT
79716: PUSH
79717: LD_VAR 0 1
79721: NOT
79722: OR
79723: IFFALSE 79727
// exit ;
79725: GO 79752
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79727: LD_ADDR_EXP 96
79731: PUSH
79732: LD_EXP 96
79736: PPUSH
79737: LD_VAR 0 1
79741: PPUSH
79742: LD_VAR 0 2
79746: PPUSH
79747: CALL_OW 1
79751: ST_TO_ADDR
// end ;
79752: LD_VAR 0 3
79756: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79757: LD_INT 0
79759: PPUSH
79760: PPUSH
// if not mc_bases or not base then
79761: LD_EXP 68
79765: NOT
79766: PUSH
79767: LD_VAR 0 1
79771: NOT
79772: OR
79773: IFFALSE 79777
// exit ;
79775: GO 79879
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79777: LD_ADDR_VAR 0 4
79781: PUSH
79782: LD_EXP 68
79786: PUSH
79787: LD_VAR 0 1
79791: ARRAY
79792: PPUSH
79793: LD_INT 30
79795: PUSH
79796: LD_VAR 0 2
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PPUSH
79805: CALL_OW 72
79809: ST_TO_ADDR
// if not tmp then
79810: LD_VAR 0 4
79814: NOT
79815: IFFALSE 79819
// exit ;
79817: GO 79879
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79819: LD_ADDR_EXP 100
79823: PUSH
79824: LD_EXP 100
79828: PPUSH
79829: LD_VAR 0 1
79833: PPUSH
79834: LD_EXP 100
79838: PUSH
79839: LD_VAR 0 1
79843: ARRAY
79844: PPUSH
79845: LD_EXP 100
79849: PUSH
79850: LD_VAR 0 1
79854: ARRAY
79855: PUSH
79856: LD_INT 1
79858: PLUS
79859: PPUSH
79860: LD_VAR 0 4
79864: PUSH
79865: LD_INT 1
79867: ARRAY
79868: PPUSH
79869: CALL_OW 2
79873: PPUSH
79874: CALL_OW 1
79878: ST_TO_ADDR
// end ;
79879: LD_VAR 0 3
79883: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79884: LD_INT 0
79886: PPUSH
79887: PPUSH
// if not mc_bases or not base or not kinds then
79888: LD_EXP 68
79892: NOT
79893: PUSH
79894: LD_VAR 0 1
79898: NOT
79899: OR
79900: PUSH
79901: LD_VAR 0 2
79905: NOT
79906: OR
79907: IFFALSE 79911
// exit ;
79909: GO 79972
// for i in kinds do
79911: LD_ADDR_VAR 0 4
79915: PUSH
79916: LD_VAR 0 2
79920: PUSH
79921: FOR_IN
79922: IFFALSE 79970
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79924: LD_ADDR_EXP 102
79928: PUSH
79929: LD_EXP 102
79933: PPUSH
79934: LD_VAR 0 1
79938: PUSH
79939: LD_EXP 102
79943: PUSH
79944: LD_VAR 0 1
79948: ARRAY
79949: PUSH
79950: LD_INT 1
79952: PLUS
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PPUSH
79958: LD_VAR 0 4
79962: PPUSH
79963: CALL 18750 0 3
79967: ST_TO_ADDR
79968: GO 79921
79970: POP
79971: POP
// end ;
79972: LD_VAR 0 3
79976: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79977: LD_INT 0
79979: PPUSH
// if not mc_bases or not base or not areas then
79980: LD_EXP 68
79984: NOT
79985: PUSH
79986: LD_VAR 0 1
79990: NOT
79991: OR
79992: PUSH
79993: LD_VAR 0 2
79997: NOT
79998: OR
79999: IFFALSE 80003
// exit ;
80001: GO 80028
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80003: LD_ADDR_EXP 86
80007: PUSH
80008: LD_EXP 86
80012: PPUSH
80013: LD_VAR 0 1
80017: PPUSH
80018: LD_VAR 0 2
80022: PPUSH
80023: CALL_OW 1
80027: ST_TO_ADDR
// end ;
80028: LD_VAR 0 3
80032: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80033: LD_INT 0
80035: PPUSH
// if not mc_bases or not base or not teleports_exit then
80036: LD_EXP 68
80040: NOT
80041: PUSH
80042: LD_VAR 0 1
80046: NOT
80047: OR
80048: PUSH
80049: LD_VAR 0 2
80053: NOT
80054: OR
80055: IFFALSE 80059
// exit ;
80057: GO 80084
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80059: LD_ADDR_EXP 103
80063: PUSH
80064: LD_EXP 103
80068: PPUSH
80069: LD_VAR 0 1
80073: PPUSH
80074: LD_VAR 0 2
80078: PPUSH
80079: CALL_OW 1
80083: ST_TO_ADDR
// end ;
80084: LD_VAR 0 3
80088: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80089: LD_INT 0
80091: PPUSH
80092: PPUSH
80093: PPUSH
// if not mc_bases or not base or not ext_list then
80094: LD_EXP 68
80098: NOT
80099: PUSH
80100: LD_VAR 0 1
80104: NOT
80105: OR
80106: PUSH
80107: LD_VAR 0 5
80111: NOT
80112: OR
80113: IFFALSE 80117
// exit ;
80115: GO 80290
// tmp := GetFacExtXYD ( x , y , d ) ;
80117: LD_ADDR_VAR 0 8
80121: PUSH
80122: LD_VAR 0 2
80126: PPUSH
80127: LD_VAR 0 3
80131: PPUSH
80132: LD_VAR 0 4
80136: PPUSH
80137: CALL 48634 0 3
80141: ST_TO_ADDR
// if not tmp then
80142: LD_VAR 0 8
80146: NOT
80147: IFFALSE 80151
// exit ;
80149: GO 80290
// for i in tmp do
80151: LD_ADDR_VAR 0 7
80155: PUSH
80156: LD_VAR 0 8
80160: PUSH
80161: FOR_IN
80162: IFFALSE 80288
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80164: LD_ADDR_EXP 73
80168: PUSH
80169: LD_EXP 73
80173: PPUSH
80174: LD_VAR 0 1
80178: PPUSH
80179: LD_EXP 73
80183: PUSH
80184: LD_VAR 0 1
80188: ARRAY
80189: PPUSH
80190: LD_EXP 73
80194: PUSH
80195: LD_VAR 0 1
80199: ARRAY
80200: PUSH
80201: LD_INT 1
80203: PLUS
80204: PPUSH
80205: LD_VAR 0 5
80209: PUSH
80210: LD_INT 1
80212: ARRAY
80213: PUSH
80214: LD_VAR 0 7
80218: PUSH
80219: LD_INT 1
80221: ARRAY
80222: PUSH
80223: LD_VAR 0 7
80227: PUSH
80228: LD_INT 2
80230: ARRAY
80231: PUSH
80232: LD_VAR 0 7
80236: PUSH
80237: LD_INT 3
80239: ARRAY
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: PPUSH
80247: CALL_OW 2
80251: PPUSH
80252: CALL_OW 1
80256: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80257: LD_ADDR_VAR 0 5
80261: PUSH
80262: LD_VAR 0 5
80266: PPUSH
80267: LD_INT 1
80269: PPUSH
80270: CALL_OW 3
80274: ST_TO_ADDR
// if not ext_list then
80275: LD_VAR 0 5
80279: NOT
80280: IFFALSE 80286
// exit ;
80282: POP
80283: POP
80284: GO 80290
// end ;
80286: GO 80161
80288: POP
80289: POP
// end ;
80290: LD_VAR 0 6
80294: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80295: LD_INT 0
80297: PPUSH
// if not mc_bases or not base or not weapon_list then
80298: LD_EXP 68
80302: NOT
80303: PUSH
80304: LD_VAR 0 1
80308: NOT
80309: OR
80310: PUSH
80311: LD_VAR 0 2
80315: NOT
80316: OR
80317: IFFALSE 80321
// exit ;
80319: GO 80346
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80321: LD_ADDR_EXP 107
80325: PUSH
80326: LD_EXP 107
80330: PPUSH
80331: LD_VAR 0 1
80335: PPUSH
80336: LD_VAR 0 2
80340: PPUSH
80341: CALL_OW 1
80345: ST_TO_ADDR
// end ;
80346: LD_VAR 0 3
80350: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80351: LD_INT 0
80353: PPUSH
// if not mc_bases or not base or not tech_list then
80354: LD_EXP 68
80358: NOT
80359: PUSH
80360: LD_VAR 0 1
80364: NOT
80365: OR
80366: PUSH
80367: LD_VAR 0 2
80371: NOT
80372: OR
80373: IFFALSE 80377
// exit ;
80375: GO 80402
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80377: LD_ADDR_EXP 95
80381: PUSH
80382: LD_EXP 95
80386: PPUSH
80387: LD_VAR 0 1
80391: PPUSH
80392: LD_VAR 0 2
80396: PPUSH
80397: CALL_OW 1
80401: ST_TO_ADDR
// end ;
80402: LD_VAR 0 3
80406: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80407: LD_INT 0
80409: PPUSH
// if not mc_bases or not parking_area or not base then
80410: LD_EXP 68
80414: NOT
80415: PUSH
80416: LD_VAR 0 2
80420: NOT
80421: OR
80422: PUSH
80423: LD_VAR 0 1
80427: NOT
80428: OR
80429: IFFALSE 80433
// exit ;
80431: GO 80458
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80433: LD_ADDR_EXP 92
80437: PUSH
80438: LD_EXP 92
80442: PPUSH
80443: LD_VAR 0 1
80447: PPUSH
80448: LD_VAR 0 2
80452: PPUSH
80453: CALL_OW 1
80457: ST_TO_ADDR
// end ;
80458: LD_VAR 0 3
80462: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80463: LD_INT 0
80465: PPUSH
// if not mc_bases or not base or not scan_area then
80466: LD_EXP 68
80470: NOT
80471: PUSH
80472: LD_VAR 0 1
80476: NOT
80477: OR
80478: PUSH
80479: LD_VAR 0 2
80483: NOT
80484: OR
80485: IFFALSE 80489
// exit ;
80487: GO 80514
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80489: LD_ADDR_EXP 93
80493: PUSH
80494: LD_EXP 93
80498: PPUSH
80499: LD_VAR 0 1
80503: PPUSH
80504: LD_VAR 0 2
80508: PPUSH
80509: CALL_OW 1
80513: ST_TO_ADDR
// end ;
80514: LD_VAR 0 3
80518: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80519: LD_INT 0
80521: PPUSH
80522: PPUSH
// if not mc_bases or not base then
80523: LD_EXP 68
80527: NOT
80528: PUSH
80529: LD_VAR 0 1
80533: NOT
80534: OR
80535: IFFALSE 80539
// exit ;
80537: GO 80603
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80539: LD_ADDR_VAR 0 3
80543: PUSH
80544: LD_INT 1
80546: PUSH
80547: LD_INT 2
80549: PUSH
80550: LD_INT 3
80552: PUSH
80553: LD_INT 4
80555: PUSH
80556: LD_INT 11
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80566: LD_ADDR_EXP 95
80570: PUSH
80571: LD_EXP 95
80575: PPUSH
80576: LD_VAR 0 1
80580: PPUSH
80581: LD_EXP 95
80585: PUSH
80586: LD_VAR 0 1
80590: ARRAY
80591: PUSH
80592: LD_VAR 0 3
80596: DIFF
80597: PPUSH
80598: CALL_OW 1
80602: ST_TO_ADDR
// end ;
80603: LD_VAR 0 2
80607: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80608: LD_INT 0
80610: PPUSH
// result := mc_vehicles [ base ] ;
80611: LD_ADDR_VAR 0 3
80615: PUSH
80616: LD_EXP 87
80620: PUSH
80621: LD_VAR 0 1
80625: ARRAY
80626: ST_TO_ADDR
// if onlyCombat then
80627: LD_VAR 0 2
80631: IFFALSE 80809
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80633: LD_ADDR_VAR 0 3
80637: PUSH
80638: LD_VAR 0 3
80642: PUSH
80643: LD_VAR 0 3
80647: PPUSH
80648: LD_INT 2
80650: PUSH
80651: LD_INT 34
80653: PUSH
80654: LD_INT 12
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 34
80663: PUSH
80664: LD_INT 51
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 34
80673: PUSH
80674: LD_EXP 49
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 34
80685: PUSH
80686: LD_INT 32
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 34
80695: PUSH
80696: LD_INT 13
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 34
80705: PUSH
80706: LD_INT 52
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 34
80715: PUSH
80716: LD_EXP 54
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PUSH
80725: LD_INT 34
80727: PUSH
80728: LD_INT 14
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 34
80737: PUSH
80738: LD_INT 53
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 34
80747: PUSH
80748: LD_EXP 48
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 34
80759: PUSH
80760: LD_INT 31
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 34
80769: PUSH
80770: LD_INT 48
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 34
80779: PUSH
80780: LD_INT 8
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: PPUSH
80803: CALL_OW 72
80807: DIFF
80808: ST_TO_ADDR
// end ; end_of_file
80809: LD_VAR 0 3
80813: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80814: LD_INT 0
80816: PPUSH
80817: PPUSH
80818: PPUSH
// if not mc_bases or not skirmish then
80819: LD_EXP 68
80823: NOT
80824: PUSH
80825: LD_EXP 66
80829: NOT
80830: OR
80831: IFFALSE 80835
// exit ;
80833: GO 81000
// for i = 1 to mc_bases do
80835: LD_ADDR_VAR 0 4
80839: PUSH
80840: DOUBLE
80841: LD_INT 1
80843: DEC
80844: ST_TO_ADDR
80845: LD_EXP 68
80849: PUSH
80850: FOR_TO
80851: IFFALSE 80998
// begin if sci in mc_bases [ i ] then
80853: LD_VAR 0 2
80857: PUSH
80858: LD_EXP 68
80862: PUSH
80863: LD_VAR 0 4
80867: ARRAY
80868: IN
80869: IFFALSE 80996
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80871: LD_ADDR_EXP 97
80875: PUSH
80876: LD_EXP 97
80880: PPUSH
80881: LD_VAR 0 4
80885: PUSH
80886: LD_EXP 97
80890: PUSH
80891: LD_VAR 0 4
80895: ARRAY
80896: PUSH
80897: LD_INT 1
80899: PLUS
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PPUSH
80905: LD_VAR 0 1
80909: PPUSH
80910: CALL 18750 0 3
80914: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80915: LD_ADDR_VAR 0 5
80919: PUSH
80920: LD_EXP 68
80924: PUSH
80925: LD_VAR 0 4
80929: ARRAY
80930: PPUSH
80931: LD_INT 2
80933: PUSH
80934: LD_INT 30
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 30
80946: PUSH
80947: LD_INT 1
80949: PUSH
80950: EMPTY
80951: LIST
80952: LIST
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: LIST
80958: PPUSH
80959: CALL_OW 72
80963: PPUSH
80964: LD_VAR 0 1
80968: PPUSH
80969: CALL_OW 74
80973: ST_TO_ADDR
// if tmp then
80974: LD_VAR 0 5
80978: IFFALSE 80994
// ComStandNearbyBuilding ( ape , tmp ) ;
80980: LD_VAR 0 1
80984: PPUSH
80985: LD_VAR 0 5
80989: PPUSH
80990: CALL 15175 0 2
// break ;
80994: GO 80998
// end ; end ;
80996: GO 80850
80998: POP
80999: POP
// end ;
81000: LD_VAR 0 3
81004: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81005: LD_INT 0
81007: PPUSH
81008: PPUSH
81009: PPUSH
// if not mc_bases or not skirmish then
81010: LD_EXP 68
81014: NOT
81015: PUSH
81016: LD_EXP 66
81020: NOT
81021: OR
81022: IFFALSE 81026
// exit ;
81024: GO 81115
// for i = 1 to mc_bases do
81026: LD_ADDR_VAR 0 4
81030: PUSH
81031: DOUBLE
81032: LD_INT 1
81034: DEC
81035: ST_TO_ADDR
81036: LD_EXP 68
81040: PUSH
81041: FOR_TO
81042: IFFALSE 81113
// begin if building in mc_busy_turret_list [ i ] then
81044: LD_VAR 0 1
81048: PUSH
81049: LD_EXP 78
81053: PUSH
81054: LD_VAR 0 4
81058: ARRAY
81059: IN
81060: IFFALSE 81111
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81062: LD_ADDR_VAR 0 5
81066: PUSH
81067: LD_EXP 78
81071: PUSH
81072: LD_VAR 0 4
81076: ARRAY
81077: PUSH
81078: LD_VAR 0 1
81082: DIFF
81083: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81084: LD_ADDR_EXP 78
81088: PUSH
81089: LD_EXP 78
81093: PPUSH
81094: LD_VAR 0 4
81098: PPUSH
81099: LD_VAR 0 5
81103: PPUSH
81104: CALL_OW 1
81108: ST_TO_ADDR
// break ;
81109: GO 81113
// end ; end ;
81111: GO 81041
81113: POP
81114: POP
// end ;
81115: LD_VAR 0 3
81119: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81120: LD_INT 0
81122: PPUSH
81123: PPUSH
81124: PPUSH
// if not mc_bases or not skirmish then
81125: LD_EXP 68
81129: NOT
81130: PUSH
81131: LD_EXP 66
81135: NOT
81136: OR
81137: IFFALSE 81141
// exit ;
81139: GO 81340
// for i = 1 to mc_bases do
81141: LD_ADDR_VAR 0 5
81145: PUSH
81146: DOUBLE
81147: LD_INT 1
81149: DEC
81150: ST_TO_ADDR
81151: LD_EXP 68
81155: PUSH
81156: FOR_TO
81157: IFFALSE 81338
// if building in mc_bases [ i ] then
81159: LD_VAR 0 1
81163: PUSH
81164: LD_EXP 68
81168: PUSH
81169: LD_VAR 0 5
81173: ARRAY
81174: IN
81175: IFFALSE 81336
// begin tmp := mc_bases [ i ] diff building ;
81177: LD_ADDR_VAR 0 6
81181: PUSH
81182: LD_EXP 68
81186: PUSH
81187: LD_VAR 0 5
81191: ARRAY
81192: PUSH
81193: LD_VAR 0 1
81197: DIFF
81198: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81199: LD_ADDR_EXP 68
81203: PUSH
81204: LD_EXP 68
81208: PPUSH
81209: LD_VAR 0 5
81213: PPUSH
81214: LD_VAR 0 6
81218: PPUSH
81219: CALL_OW 1
81223: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81224: LD_VAR 0 1
81228: PUSH
81229: LD_EXP 76
81233: PUSH
81234: LD_VAR 0 5
81238: ARRAY
81239: IN
81240: IFFALSE 81279
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81242: LD_ADDR_EXP 76
81246: PUSH
81247: LD_EXP 76
81251: PPUSH
81252: LD_VAR 0 5
81256: PPUSH
81257: LD_EXP 76
81261: PUSH
81262: LD_VAR 0 5
81266: ARRAY
81267: PUSH
81268: LD_VAR 0 1
81272: DIFF
81273: PPUSH
81274: CALL_OW 1
81278: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81279: LD_VAR 0 1
81283: PUSH
81284: LD_EXP 77
81288: PUSH
81289: LD_VAR 0 5
81293: ARRAY
81294: IN
81295: IFFALSE 81334
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81297: LD_ADDR_EXP 77
81301: PUSH
81302: LD_EXP 77
81306: PPUSH
81307: LD_VAR 0 5
81311: PPUSH
81312: LD_EXP 77
81316: PUSH
81317: LD_VAR 0 5
81321: ARRAY
81322: PUSH
81323: LD_VAR 0 1
81327: DIFF
81328: PPUSH
81329: CALL_OW 1
81333: ST_TO_ADDR
// break ;
81334: GO 81338
// end ;
81336: GO 81156
81338: POP
81339: POP
// end ;
81340: LD_VAR 0 4
81344: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81345: LD_INT 0
81347: PPUSH
81348: PPUSH
81349: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81350: LD_EXP 68
81354: NOT
81355: PUSH
81356: LD_EXP 66
81360: NOT
81361: OR
81362: PUSH
81363: LD_VAR 0 3
81367: PUSH
81368: LD_EXP 94
81372: IN
81373: NOT
81374: OR
81375: IFFALSE 81379
// exit ;
81377: GO 81502
// for i = 1 to mc_vehicles do
81379: LD_ADDR_VAR 0 6
81383: PUSH
81384: DOUBLE
81385: LD_INT 1
81387: DEC
81388: ST_TO_ADDR
81389: LD_EXP 87
81393: PUSH
81394: FOR_TO
81395: IFFALSE 81500
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81397: LD_VAR 0 2
81401: PUSH
81402: LD_EXP 87
81406: PUSH
81407: LD_VAR 0 6
81411: ARRAY
81412: IN
81413: PUSH
81414: LD_VAR 0 1
81418: PUSH
81419: LD_EXP 87
81423: PUSH
81424: LD_VAR 0 6
81428: ARRAY
81429: IN
81430: OR
81431: IFFALSE 81498
// begin tmp := mc_vehicles [ i ] diff old ;
81433: LD_ADDR_VAR 0 7
81437: PUSH
81438: LD_EXP 87
81442: PUSH
81443: LD_VAR 0 6
81447: ARRAY
81448: PUSH
81449: LD_VAR 0 2
81453: DIFF
81454: ST_TO_ADDR
// tmp := tmp diff new ;
81455: LD_ADDR_VAR 0 7
81459: PUSH
81460: LD_VAR 0 7
81464: PUSH
81465: LD_VAR 0 1
81469: DIFF
81470: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81471: LD_ADDR_EXP 87
81475: PUSH
81476: LD_EXP 87
81480: PPUSH
81481: LD_VAR 0 6
81485: PPUSH
81486: LD_VAR 0 7
81490: PPUSH
81491: CALL_OW 1
81495: ST_TO_ADDR
// break ;
81496: GO 81500
// end ;
81498: GO 81394
81500: POP
81501: POP
// end ;
81502: LD_VAR 0 5
81506: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81507: LD_INT 0
81509: PPUSH
81510: PPUSH
81511: PPUSH
81512: PPUSH
// if not mc_bases or not skirmish then
81513: LD_EXP 68
81517: NOT
81518: PUSH
81519: LD_EXP 66
81523: NOT
81524: OR
81525: IFFALSE 81529
// exit ;
81527: GO 81921
// side := GetSide ( vehicle ) ;
81529: LD_ADDR_VAR 0 5
81533: PUSH
81534: LD_VAR 0 1
81538: PPUSH
81539: CALL_OW 255
81543: ST_TO_ADDR
// for i = 1 to mc_bases do
81544: LD_ADDR_VAR 0 4
81548: PUSH
81549: DOUBLE
81550: LD_INT 1
81552: DEC
81553: ST_TO_ADDR
81554: LD_EXP 68
81558: PUSH
81559: FOR_TO
81560: IFFALSE 81919
// begin if factory in mc_bases [ i ] then
81562: LD_VAR 0 2
81566: PUSH
81567: LD_EXP 68
81571: PUSH
81572: LD_VAR 0 4
81576: ARRAY
81577: IN
81578: IFFALSE 81917
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81580: LD_EXP 90
81584: PUSH
81585: LD_VAR 0 4
81589: ARRAY
81590: PUSH
81591: LD_EXP 79
81595: PUSH
81596: LD_VAR 0 4
81600: ARRAY
81601: LESS
81602: PUSH
81603: LD_VAR 0 1
81607: PPUSH
81608: CALL_OW 264
81612: PUSH
81613: LD_INT 31
81615: PUSH
81616: LD_INT 32
81618: PUSH
81619: LD_INT 51
81621: PUSH
81622: LD_EXP 49
81626: PUSH
81627: LD_INT 12
81629: PUSH
81630: LD_INT 30
81632: PUSH
81633: LD_EXP 48
81637: PUSH
81638: LD_INT 11
81640: PUSH
81641: LD_INT 53
81643: PUSH
81644: LD_INT 14
81646: PUSH
81647: LD_EXP 52
81651: PUSH
81652: LD_INT 29
81654: PUSH
81655: LD_EXP 50
81659: PUSH
81660: LD_INT 13
81662: PUSH
81663: LD_INT 52
81665: PUSH
81666: LD_EXP 54
81670: PUSH
81671: LD_INT 48
81673: PUSH
81674: LD_INT 8
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: IN
81697: NOT
81698: AND
81699: IFFALSE 81747
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81701: LD_ADDR_EXP 90
81705: PUSH
81706: LD_EXP 90
81710: PPUSH
81711: LD_VAR 0 4
81715: PUSH
81716: LD_EXP 90
81720: PUSH
81721: LD_VAR 0 4
81725: ARRAY
81726: PUSH
81727: LD_INT 1
81729: PLUS
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PPUSH
81735: LD_VAR 0 1
81739: PPUSH
81740: CALL 18750 0 3
81744: ST_TO_ADDR
81745: GO 81791
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81747: LD_ADDR_EXP 87
81751: PUSH
81752: LD_EXP 87
81756: PPUSH
81757: LD_VAR 0 4
81761: PUSH
81762: LD_EXP 87
81766: PUSH
81767: LD_VAR 0 4
81771: ARRAY
81772: PUSH
81773: LD_INT 1
81775: PLUS
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PPUSH
81781: LD_VAR 0 1
81785: PPUSH
81786: CALL 18750 0 3
81790: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81791: LD_VAR 0 1
81795: PPUSH
81796: CALL_OW 263
81800: PUSH
81801: LD_INT 2
81803: EQUAL
81804: IFFALSE 81833
// begin repeat wait ( 0 0$3 ) ;
81806: LD_INT 105
81808: PPUSH
81809: CALL_OW 67
// Connect ( vehicle ) ;
81813: LD_VAR 0 1
81817: PPUSH
81818: CALL 21721 0 1
// until IsControledBy ( vehicle ) ;
81822: LD_VAR 0 1
81826: PPUSH
81827: CALL_OW 312
81831: IFFALSE 81806
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81833: LD_VAR 0 1
81837: PPUSH
81838: LD_EXP 92
81842: PUSH
81843: LD_VAR 0 4
81847: ARRAY
81848: PPUSH
81849: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81853: LD_VAR 0 1
81857: PPUSH
81858: CALL_OW 263
81862: PUSH
81863: LD_INT 1
81865: NONEQUAL
81866: IFFALSE 81870
// break ;
81868: GO 81919
// repeat wait ( 0 0$1 ) ;
81870: LD_INT 35
81872: PPUSH
81873: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81877: LD_VAR 0 1
81881: PPUSH
81882: LD_EXP 92
81886: PUSH
81887: LD_VAR 0 4
81891: ARRAY
81892: PPUSH
81893: CALL_OW 308
81897: IFFALSE 81870
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81899: LD_VAR 0 1
81903: PPUSH
81904: CALL_OW 311
81908: PPUSH
81909: CALL_OW 121
// exit ;
81913: POP
81914: POP
81915: GO 81921
// end ; end ;
81917: GO 81559
81919: POP
81920: POP
// end ;
81921: LD_VAR 0 3
81925: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81926: LD_INT 0
81928: PPUSH
81929: PPUSH
81930: PPUSH
81931: PPUSH
// if not mc_bases or not skirmish then
81932: LD_EXP 68
81936: NOT
81937: PUSH
81938: LD_EXP 66
81942: NOT
81943: OR
81944: IFFALSE 81948
// exit ;
81946: GO 82301
// repeat wait ( 0 0$1 ) ;
81948: LD_INT 35
81950: PPUSH
81951: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81955: LD_VAR 0 2
81959: PPUSH
81960: LD_VAR 0 3
81964: PPUSH
81965: CALL_OW 284
81969: IFFALSE 81948
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81971: LD_VAR 0 2
81975: PPUSH
81976: LD_VAR 0 3
81980: PPUSH
81981: CALL_OW 283
81985: PUSH
81986: LD_INT 4
81988: EQUAL
81989: IFFALSE 81993
// exit ;
81991: GO 82301
// for i = 1 to mc_bases do
81993: LD_ADDR_VAR 0 7
81997: PUSH
81998: DOUBLE
81999: LD_INT 1
82001: DEC
82002: ST_TO_ADDR
82003: LD_EXP 68
82007: PUSH
82008: FOR_TO
82009: IFFALSE 82299
// begin if mc_crates_area [ i ] then
82011: LD_EXP 86
82015: PUSH
82016: LD_VAR 0 7
82020: ARRAY
82021: IFFALSE 82132
// for j in mc_crates_area [ i ] do
82023: LD_ADDR_VAR 0 8
82027: PUSH
82028: LD_EXP 86
82032: PUSH
82033: LD_VAR 0 7
82037: ARRAY
82038: PUSH
82039: FOR_IN
82040: IFFALSE 82130
// if InArea ( x , y , j ) then
82042: LD_VAR 0 2
82046: PPUSH
82047: LD_VAR 0 3
82051: PPUSH
82052: LD_VAR 0 8
82056: PPUSH
82057: CALL_OW 309
82061: IFFALSE 82128
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82063: LD_ADDR_EXP 84
82067: PUSH
82068: LD_EXP 84
82072: PPUSH
82073: LD_VAR 0 7
82077: PUSH
82078: LD_EXP 84
82082: PUSH
82083: LD_VAR 0 7
82087: ARRAY
82088: PUSH
82089: LD_INT 1
82091: PLUS
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PPUSH
82097: LD_VAR 0 4
82101: PUSH
82102: LD_VAR 0 2
82106: PUSH
82107: LD_VAR 0 3
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: LIST
82116: PPUSH
82117: CALL 18750 0 3
82121: ST_TO_ADDR
// exit ;
82122: POP
82123: POP
82124: POP
82125: POP
82126: GO 82301
// end ;
82128: GO 82039
82130: POP
82131: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82132: LD_ADDR_VAR 0 9
82136: PUSH
82137: LD_EXP 68
82141: PUSH
82142: LD_VAR 0 7
82146: ARRAY
82147: PPUSH
82148: LD_INT 2
82150: PUSH
82151: LD_INT 30
82153: PUSH
82154: LD_INT 0
82156: PUSH
82157: EMPTY
82158: LIST
82159: LIST
82160: PUSH
82161: LD_INT 30
82163: PUSH
82164: LD_INT 1
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: LIST
82175: PPUSH
82176: CALL_OW 72
82180: ST_TO_ADDR
// if not depot then
82181: LD_VAR 0 9
82185: NOT
82186: IFFALSE 82190
// continue ;
82188: GO 82008
// for j in depot do
82190: LD_ADDR_VAR 0 8
82194: PUSH
82195: LD_VAR 0 9
82199: PUSH
82200: FOR_IN
82201: IFFALSE 82295
// if GetDistUnitXY ( j , x , y ) < 30 then
82203: LD_VAR 0 8
82207: PPUSH
82208: LD_VAR 0 2
82212: PPUSH
82213: LD_VAR 0 3
82217: PPUSH
82218: CALL_OW 297
82222: PUSH
82223: LD_INT 30
82225: LESS
82226: IFFALSE 82293
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82228: LD_ADDR_EXP 84
82232: PUSH
82233: LD_EXP 84
82237: PPUSH
82238: LD_VAR 0 7
82242: PUSH
82243: LD_EXP 84
82247: PUSH
82248: LD_VAR 0 7
82252: ARRAY
82253: PUSH
82254: LD_INT 1
82256: PLUS
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PPUSH
82262: LD_VAR 0 4
82266: PUSH
82267: LD_VAR 0 2
82271: PUSH
82272: LD_VAR 0 3
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: LIST
82281: PPUSH
82282: CALL 18750 0 3
82286: ST_TO_ADDR
// exit ;
82287: POP
82288: POP
82289: POP
82290: POP
82291: GO 82301
// end ;
82293: GO 82200
82295: POP
82296: POP
// end ;
82297: GO 82008
82299: POP
82300: POP
// end ;
82301: LD_VAR 0 6
82305: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82306: LD_INT 0
82308: PPUSH
82309: PPUSH
82310: PPUSH
82311: PPUSH
// if not mc_bases or not skirmish then
82312: LD_EXP 68
82316: NOT
82317: PUSH
82318: LD_EXP 66
82322: NOT
82323: OR
82324: IFFALSE 82328
// exit ;
82326: GO 82605
// side := GetSide ( lab ) ;
82328: LD_ADDR_VAR 0 4
82332: PUSH
82333: LD_VAR 0 2
82337: PPUSH
82338: CALL_OW 255
82342: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82343: LD_VAR 0 4
82347: PUSH
82348: LD_EXP 94
82352: IN
82353: NOT
82354: PUSH
82355: LD_EXP 95
82359: NOT
82360: OR
82361: PUSH
82362: LD_EXP 68
82366: NOT
82367: OR
82368: IFFALSE 82372
// exit ;
82370: GO 82605
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82372: LD_ADDR_EXP 95
82376: PUSH
82377: LD_EXP 95
82381: PPUSH
82382: LD_VAR 0 4
82386: PPUSH
82387: LD_EXP 95
82391: PUSH
82392: LD_VAR 0 4
82396: ARRAY
82397: PUSH
82398: LD_VAR 0 1
82402: DIFF
82403: PPUSH
82404: CALL_OW 1
82408: ST_TO_ADDR
// for i = 1 to mc_bases do
82409: LD_ADDR_VAR 0 5
82413: PUSH
82414: DOUBLE
82415: LD_INT 1
82417: DEC
82418: ST_TO_ADDR
82419: LD_EXP 68
82423: PUSH
82424: FOR_TO
82425: IFFALSE 82603
// begin if lab in mc_bases [ i ] then
82427: LD_VAR 0 2
82431: PUSH
82432: LD_EXP 68
82436: PUSH
82437: LD_VAR 0 5
82441: ARRAY
82442: IN
82443: IFFALSE 82601
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82445: LD_VAR 0 1
82449: PUSH
82450: LD_INT 11
82452: PUSH
82453: LD_INT 4
82455: PUSH
82456: LD_INT 3
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: IN
82468: PUSH
82469: LD_EXP 98
82473: PUSH
82474: LD_VAR 0 5
82478: ARRAY
82479: AND
82480: IFFALSE 82601
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82482: LD_ADDR_VAR 0 6
82486: PUSH
82487: LD_EXP 98
82491: PUSH
82492: LD_VAR 0 5
82496: ARRAY
82497: PUSH
82498: LD_INT 1
82500: ARRAY
82501: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82502: LD_ADDR_EXP 98
82506: PUSH
82507: LD_EXP 98
82511: PPUSH
82512: LD_VAR 0 5
82516: PPUSH
82517: EMPTY
82518: PPUSH
82519: CALL_OW 1
82523: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82524: LD_VAR 0 6
82528: PPUSH
82529: LD_INT 0
82531: PPUSH
82532: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82536: LD_VAR 0 6
82540: PPUSH
82541: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82545: LD_ADDR_EXP 97
82549: PUSH
82550: LD_EXP 97
82554: PPUSH
82555: LD_VAR 0 5
82559: PPUSH
82560: LD_EXP 97
82564: PUSH
82565: LD_VAR 0 5
82569: ARRAY
82570: PPUSH
82571: LD_INT 1
82573: PPUSH
82574: LD_VAR 0 6
82578: PPUSH
82579: CALL_OW 2
82583: PPUSH
82584: CALL_OW 1
82588: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82589: LD_VAR 0 5
82593: PPUSH
82594: LD_INT 112
82596: PPUSH
82597: CALL 59124 0 2
// end ; end ; end ;
82601: GO 82424
82603: POP
82604: POP
// end ;
82605: LD_VAR 0 3
82609: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82610: LD_INT 0
82612: PPUSH
82613: PPUSH
82614: PPUSH
82615: PPUSH
82616: PPUSH
82617: PPUSH
82618: PPUSH
82619: PPUSH
// if not mc_bases or not skirmish then
82620: LD_EXP 68
82624: NOT
82625: PUSH
82626: LD_EXP 66
82630: NOT
82631: OR
82632: IFFALSE 82636
// exit ;
82634: GO 84007
// for i = 1 to mc_bases do
82636: LD_ADDR_VAR 0 3
82640: PUSH
82641: DOUBLE
82642: LD_INT 1
82644: DEC
82645: ST_TO_ADDR
82646: LD_EXP 68
82650: PUSH
82651: FOR_TO
82652: IFFALSE 84005
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82654: LD_VAR 0 1
82658: PUSH
82659: LD_EXP 68
82663: PUSH
82664: LD_VAR 0 3
82668: ARRAY
82669: IN
82670: PUSH
82671: LD_VAR 0 1
82675: PUSH
82676: LD_EXP 75
82680: PUSH
82681: LD_VAR 0 3
82685: ARRAY
82686: IN
82687: OR
82688: PUSH
82689: LD_VAR 0 1
82693: PUSH
82694: LD_EXP 90
82698: PUSH
82699: LD_VAR 0 3
82703: ARRAY
82704: IN
82705: OR
82706: PUSH
82707: LD_VAR 0 1
82711: PUSH
82712: LD_EXP 87
82716: PUSH
82717: LD_VAR 0 3
82721: ARRAY
82722: IN
82723: OR
82724: PUSH
82725: LD_VAR 0 1
82729: PUSH
82730: LD_EXP 97
82734: PUSH
82735: LD_VAR 0 3
82739: ARRAY
82740: IN
82741: OR
82742: PUSH
82743: LD_VAR 0 1
82747: PUSH
82748: LD_EXP 98
82752: PUSH
82753: LD_VAR 0 3
82757: ARRAY
82758: IN
82759: OR
82760: IFFALSE 84003
// begin if un in mc_ape [ i ] then
82762: LD_VAR 0 1
82766: PUSH
82767: LD_EXP 97
82771: PUSH
82772: LD_VAR 0 3
82776: ARRAY
82777: IN
82778: IFFALSE 82817
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82780: LD_ADDR_EXP 97
82784: PUSH
82785: LD_EXP 97
82789: PPUSH
82790: LD_VAR 0 3
82794: PPUSH
82795: LD_EXP 97
82799: PUSH
82800: LD_VAR 0 3
82804: ARRAY
82805: PUSH
82806: LD_VAR 0 1
82810: DIFF
82811: PPUSH
82812: CALL_OW 1
82816: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82817: LD_VAR 0 1
82821: PUSH
82822: LD_EXP 98
82826: PUSH
82827: LD_VAR 0 3
82831: ARRAY
82832: IN
82833: IFFALSE 82857
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82835: LD_ADDR_EXP 98
82839: PUSH
82840: LD_EXP 98
82844: PPUSH
82845: LD_VAR 0 3
82849: PPUSH
82850: EMPTY
82851: PPUSH
82852: CALL_OW 1
82856: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82857: LD_VAR 0 1
82861: PPUSH
82862: CALL_OW 247
82866: PUSH
82867: LD_INT 2
82869: EQUAL
82870: PUSH
82871: LD_VAR 0 1
82875: PPUSH
82876: CALL_OW 110
82880: PUSH
82881: LD_INT 20
82883: EQUAL
82884: PUSH
82885: LD_VAR 0 1
82889: PUSH
82890: LD_EXP 90
82894: PUSH
82895: LD_VAR 0 3
82899: ARRAY
82900: IN
82901: OR
82902: PUSH
82903: LD_VAR 0 1
82907: PPUSH
82908: CALL_OW 264
82912: PUSH
82913: LD_INT 12
82915: PUSH
82916: LD_INT 51
82918: PUSH
82919: LD_EXP 49
82923: PUSH
82924: LD_INT 32
82926: PUSH
82927: LD_INT 13
82929: PUSH
82930: LD_INT 52
82932: PUSH
82933: LD_INT 31
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: IN
82945: OR
82946: AND
82947: IFFALSE 83255
// begin if un in mc_defender [ i ] then
82949: LD_VAR 0 1
82953: PUSH
82954: LD_EXP 90
82958: PUSH
82959: LD_VAR 0 3
82963: ARRAY
82964: IN
82965: IFFALSE 83004
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82967: LD_ADDR_EXP 90
82971: PUSH
82972: LD_EXP 90
82976: PPUSH
82977: LD_VAR 0 3
82981: PPUSH
82982: LD_EXP 90
82986: PUSH
82987: LD_VAR 0 3
82991: ARRAY
82992: PUSH
82993: LD_VAR 0 1
82997: DIFF
82998: PPUSH
82999: CALL_OW 1
83003: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83004: LD_ADDR_VAR 0 8
83008: PUSH
83009: LD_VAR 0 3
83013: PPUSH
83014: LD_INT 3
83016: PPUSH
83017: CALL 79645 0 2
83021: ST_TO_ADDR
// if fac then
83022: LD_VAR 0 8
83026: IFFALSE 83255
// begin for j in fac do
83028: LD_ADDR_VAR 0 4
83032: PUSH
83033: LD_VAR 0 8
83037: PUSH
83038: FOR_IN
83039: IFFALSE 83253
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83041: LD_ADDR_VAR 0 9
83045: PUSH
83046: LD_VAR 0 8
83050: PPUSH
83051: LD_VAR 0 1
83055: PPUSH
83056: CALL_OW 265
83060: PPUSH
83061: LD_VAR 0 1
83065: PPUSH
83066: CALL_OW 262
83070: PPUSH
83071: LD_VAR 0 1
83075: PPUSH
83076: CALL_OW 263
83080: PPUSH
83081: LD_VAR 0 1
83085: PPUSH
83086: CALL_OW 264
83090: PPUSH
83091: CALL 16246 0 5
83095: ST_TO_ADDR
// if components then
83096: LD_VAR 0 9
83100: IFFALSE 83251
// begin if GetWeapon ( un ) = ar_control_tower then
83102: LD_VAR 0 1
83106: PPUSH
83107: CALL_OW 264
83111: PUSH
83112: LD_INT 31
83114: EQUAL
83115: IFFALSE 83232
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83117: LD_VAR 0 1
83121: PPUSH
83122: CALL_OW 311
83126: PPUSH
83127: LD_INT 0
83129: PPUSH
83130: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83134: LD_ADDR_EXP 108
83138: PUSH
83139: LD_EXP 108
83143: PPUSH
83144: LD_VAR 0 3
83148: PPUSH
83149: LD_EXP 108
83153: PUSH
83154: LD_VAR 0 3
83158: ARRAY
83159: PUSH
83160: LD_VAR 0 1
83164: PPUSH
83165: CALL_OW 311
83169: DIFF
83170: PPUSH
83171: CALL_OW 1
83175: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83176: LD_ADDR_VAR 0 7
83180: PUSH
83181: LD_EXP 89
83185: PUSH
83186: LD_VAR 0 3
83190: ARRAY
83191: PPUSH
83192: LD_INT 1
83194: PPUSH
83195: LD_VAR 0 9
83199: PPUSH
83200: CALL_OW 2
83204: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83205: LD_ADDR_EXP 89
83209: PUSH
83210: LD_EXP 89
83214: PPUSH
83215: LD_VAR 0 3
83219: PPUSH
83220: LD_VAR 0 7
83224: PPUSH
83225: CALL_OW 1
83229: ST_TO_ADDR
// end else
83230: GO 83249
// MC_InsertProduceList ( i , [ components ] ) ;
83232: LD_VAR 0 3
83236: PPUSH
83237: LD_VAR 0 9
83241: PUSH
83242: EMPTY
83243: LIST
83244: PPUSH
83245: CALL 79190 0 2
// break ;
83249: GO 83253
// end ; end ;
83251: GO 83038
83253: POP
83254: POP
// end ; end ; if GetType ( un ) = unit_building then
83255: LD_VAR 0 1
83259: PPUSH
83260: CALL_OW 247
83264: PUSH
83265: LD_INT 3
83267: EQUAL
83268: IFFALSE 83671
// begin btype := GetBType ( un ) ;
83270: LD_ADDR_VAR 0 5
83274: PUSH
83275: LD_VAR 0 1
83279: PPUSH
83280: CALL_OW 266
83284: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83285: LD_VAR 0 5
83289: PUSH
83290: LD_INT 29
83292: PUSH
83293: LD_INT 30
83295: PUSH
83296: EMPTY
83297: LIST
83298: LIST
83299: IN
83300: IFFALSE 83373
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83302: LD_VAR 0 1
83306: PPUSH
83307: CALL_OW 250
83311: PPUSH
83312: LD_VAR 0 1
83316: PPUSH
83317: CALL_OW 251
83321: PPUSH
83322: LD_VAR 0 1
83326: PPUSH
83327: CALL_OW 255
83331: PPUSH
83332: CALL_OW 440
83336: NOT
83337: IFFALSE 83373
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83339: LD_VAR 0 1
83343: PPUSH
83344: CALL_OW 250
83348: PPUSH
83349: LD_VAR 0 1
83353: PPUSH
83354: CALL_OW 251
83358: PPUSH
83359: LD_VAR 0 1
83363: PPUSH
83364: CALL_OW 255
83368: PPUSH
83369: CALL_OW 441
// end ; if btype = b_warehouse then
83373: LD_VAR 0 5
83377: PUSH
83378: LD_INT 1
83380: EQUAL
83381: IFFALSE 83399
// begin btype := b_depot ;
83383: LD_ADDR_VAR 0 5
83387: PUSH
83388: LD_INT 0
83390: ST_TO_ADDR
// pos := 1 ;
83391: LD_ADDR_VAR 0 6
83395: PUSH
83396: LD_INT 1
83398: ST_TO_ADDR
// end ; if btype = b_factory then
83399: LD_VAR 0 5
83403: PUSH
83404: LD_INT 3
83406: EQUAL
83407: IFFALSE 83425
// begin btype := b_workshop ;
83409: LD_ADDR_VAR 0 5
83413: PUSH
83414: LD_INT 2
83416: ST_TO_ADDR
// pos := 1 ;
83417: LD_ADDR_VAR 0 6
83421: PUSH
83422: LD_INT 1
83424: ST_TO_ADDR
// end ; if btype = b_barracks then
83425: LD_VAR 0 5
83429: PUSH
83430: LD_INT 5
83432: EQUAL
83433: IFFALSE 83443
// btype := b_armoury ;
83435: LD_ADDR_VAR 0 5
83439: PUSH
83440: LD_INT 4
83442: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83443: LD_VAR 0 5
83447: PUSH
83448: LD_INT 7
83450: PUSH
83451: LD_INT 8
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: IN
83458: IFFALSE 83468
// btype := b_lab ;
83460: LD_ADDR_VAR 0 5
83464: PUSH
83465: LD_INT 6
83467: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83468: LD_ADDR_EXP 73
83472: PUSH
83473: LD_EXP 73
83477: PPUSH
83478: LD_VAR 0 3
83482: PUSH
83483: LD_EXP 73
83487: PUSH
83488: LD_VAR 0 3
83492: ARRAY
83493: PUSH
83494: LD_INT 1
83496: PLUS
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PPUSH
83502: LD_VAR 0 5
83506: PUSH
83507: LD_VAR 0 1
83511: PPUSH
83512: CALL_OW 250
83516: PUSH
83517: LD_VAR 0 1
83521: PPUSH
83522: CALL_OW 251
83526: PUSH
83527: LD_VAR 0 1
83531: PPUSH
83532: CALL_OW 254
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: PPUSH
83543: CALL 18750 0 3
83547: ST_TO_ADDR
// if pos = 1 then
83548: LD_VAR 0 6
83552: PUSH
83553: LD_INT 1
83555: EQUAL
83556: IFFALSE 83671
// begin tmp := mc_build_list [ i ] ;
83558: LD_ADDR_VAR 0 7
83562: PUSH
83563: LD_EXP 73
83567: PUSH
83568: LD_VAR 0 3
83572: ARRAY
83573: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83574: LD_VAR 0 7
83578: PPUSH
83579: LD_INT 2
83581: PUSH
83582: LD_INT 30
83584: PUSH
83585: LD_INT 0
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 30
83594: PUSH
83595: LD_INT 1
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: PPUSH
83607: CALL_OW 72
83611: IFFALSE 83621
// pos := 2 ;
83613: LD_ADDR_VAR 0 6
83617: PUSH
83618: LD_INT 2
83620: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83621: LD_ADDR_VAR 0 7
83625: PUSH
83626: LD_VAR 0 7
83630: PPUSH
83631: LD_VAR 0 6
83635: PPUSH
83636: LD_VAR 0 7
83640: PPUSH
83641: CALL 19076 0 3
83645: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83646: LD_ADDR_EXP 73
83650: PUSH
83651: LD_EXP 73
83655: PPUSH
83656: LD_VAR 0 3
83660: PPUSH
83661: LD_VAR 0 7
83665: PPUSH
83666: CALL_OW 1
83670: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83671: LD_VAR 0 1
83675: PUSH
83676: LD_EXP 68
83680: PUSH
83681: LD_VAR 0 3
83685: ARRAY
83686: IN
83687: IFFALSE 83726
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83689: LD_ADDR_EXP 68
83693: PUSH
83694: LD_EXP 68
83698: PPUSH
83699: LD_VAR 0 3
83703: PPUSH
83704: LD_EXP 68
83708: PUSH
83709: LD_VAR 0 3
83713: ARRAY
83714: PUSH
83715: LD_VAR 0 1
83719: DIFF
83720: PPUSH
83721: CALL_OW 1
83725: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83726: LD_VAR 0 1
83730: PUSH
83731: LD_EXP 75
83735: PUSH
83736: LD_VAR 0 3
83740: ARRAY
83741: IN
83742: IFFALSE 83781
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83744: LD_ADDR_EXP 75
83748: PUSH
83749: LD_EXP 75
83753: PPUSH
83754: LD_VAR 0 3
83758: PPUSH
83759: LD_EXP 75
83763: PUSH
83764: LD_VAR 0 3
83768: ARRAY
83769: PUSH
83770: LD_VAR 0 1
83774: DIFF
83775: PPUSH
83776: CALL_OW 1
83780: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83781: LD_VAR 0 1
83785: PUSH
83786: LD_EXP 87
83790: PUSH
83791: LD_VAR 0 3
83795: ARRAY
83796: IN
83797: IFFALSE 83836
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83799: LD_ADDR_EXP 87
83803: PUSH
83804: LD_EXP 87
83808: PPUSH
83809: LD_VAR 0 3
83813: PPUSH
83814: LD_EXP 87
83818: PUSH
83819: LD_VAR 0 3
83823: ARRAY
83824: PUSH
83825: LD_VAR 0 1
83829: DIFF
83830: PPUSH
83831: CALL_OW 1
83835: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83836: LD_VAR 0 1
83840: PUSH
83841: LD_EXP 90
83845: PUSH
83846: LD_VAR 0 3
83850: ARRAY
83851: IN
83852: IFFALSE 83891
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83854: LD_ADDR_EXP 90
83858: PUSH
83859: LD_EXP 90
83863: PPUSH
83864: LD_VAR 0 3
83868: PPUSH
83869: LD_EXP 90
83873: PUSH
83874: LD_VAR 0 3
83878: ARRAY
83879: PUSH
83880: LD_VAR 0 1
83884: DIFF
83885: PPUSH
83886: CALL_OW 1
83890: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83891: LD_VAR 0 1
83895: PUSH
83896: LD_EXP 77
83900: PUSH
83901: LD_VAR 0 3
83905: ARRAY
83906: IN
83907: IFFALSE 83946
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83909: LD_ADDR_EXP 77
83913: PUSH
83914: LD_EXP 77
83918: PPUSH
83919: LD_VAR 0 3
83923: PPUSH
83924: LD_EXP 77
83928: PUSH
83929: LD_VAR 0 3
83933: ARRAY
83934: PUSH
83935: LD_VAR 0 1
83939: DIFF
83940: PPUSH
83941: CALL_OW 1
83945: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83946: LD_VAR 0 1
83950: PUSH
83951: LD_EXP 76
83955: PUSH
83956: LD_VAR 0 3
83960: ARRAY
83961: IN
83962: IFFALSE 84001
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83964: LD_ADDR_EXP 76
83968: PUSH
83969: LD_EXP 76
83973: PPUSH
83974: LD_VAR 0 3
83978: PPUSH
83979: LD_EXP 76
83983: PUSH
83984: LD_VAR 0 3
83988: ARRAY
83989: PUSH
83990: LD_VAR 0 1
83994: DIFF
83995: PPUSH
83996: CALL_OW 1
84000: ST_TO_ADDR
// end ; break ;
84001: GO 84005
// end ;
84003: GO 82651
84005: POP
84006: POP
// end ;
84007: LD_VAR 0 2
84011: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84012: LD_INT 0
84014: PPUSH
84015: PPUSH
84016: PPUSH
// if not mc_bases or not skirmish then
84017: LD_EXP 68
84021: NOT
84022: PUSH
84023: LD_EXP 66
84027: NOT
84028: OR
84029: IFFALSE 84033
// exit ;
84031: GO 84248
// for i = 1 to mc_bases do
84033: LD_ADDR_VAR 0 3
84037: PUSH
84038: DOUBLE
84039: LD_INT 1
84041: DEC
84042: ST_TO_ADDR
84043: LD_EXP 68
84047: PUSH
84048: FOR_TO
84049: IFFALSE 84246
// begin if building in mc_construct_list [ i ] then
84051: LD_VAR 0 1
84055: PUSH
84056: LD_EXP 75
84060: PUSH
84061: LD_VAR 0 3
84065: ARRAY
84066: IN
84067: IFFALSE 84244
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84069: LD_ADDR_EXP 75
84073: PUSH
84074: LD_EXP 75
84078: PPUSH
84079: LD_VAR 0 3
84083: PPUSH
84084: LD_EXP 75
84088: PUSH
84089: LD_VAR 0 3
84093: ARRAY
84094: PUSH
84095: LD_VAR 0 1
84099: DIFF
84100: PPUSH
84101: CALL_OW 1
84105: ST_TO_ADDR
// if building in mc_lab [ i ] then
84106: LD_VAR 0 1
84110: PUSH
84111: LD_EXP 101
84115: PUSH
84116: LD_VAR 0 3
84120: ARRAY
84121: IN
84122: IFFALSE 84177
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84124: LD_ADDR_EXP 102
84128: PUSH
84129: LD_EXP 102
84133: PPUSH
84134: LD_VAR 0 3
84138: PPUSH
84139: LD_EXP 102
84143: PUSH
84144: LD_VAR 0 3
84148: ARRAY
84149: PPUSH
84150: LD_INT 1
84152: PPUSH
84153: LD_EXP 102
84157: PUSH
84158: LD_VAR 0 3
84162: ARRAY
84163: PPUSH
84164: LD_INT 0
84166: PPUSH
84167: CALL 18168 0 4
84171: PPUSH
84172: CALL_OW 1
84176: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84177: LD_VAR 0 1
84181: PUSH
84182: LD_EXP 68
84186: PUSH
84187: LD_VAR 0 3
84191: ARRAY
84192: IN
84193: NOT
84194: IFFALSE 84240
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84196: LD_ADDR_EXP 68
84200: PUSH
84201: LD_EXP 68
84205: PPUSH
84206: LD_VAR 0 3
84210: PUSH
84211: LD_EXP 68
84215: PUSH
84216: LD_VAR 0 3
84220: ARRAY
84221: PUSH
84222: LD_INT 1
84224: PLUS
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PPUSH
84230: LD_VAR 0 1
84234: PPUSH
84235: CALL 18750 0 3
84239: ST_TO_ADDR
// exit ;
84240: POP
84241: POP
84242: GO 84248
// end ; end ;
84244: GO 84048
84246: POP
84247: POP
// end ;
84248: LD_VAR 0 2
84252: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84253: LD_INT 0
84255: PPUSH
84256: PPUSH
84257: PPUSH
84258: PPUSH
84259: PPUSH
84260: PPUSH
84261: PPUSH
// if not mc_bases or not skirmish then
84262: LD_EXP 68
84266: NOT
84267: PUSH
84268: LD_EXP 66
84272: NOT
84273: OR
84274: IFFALSE 84278
// exit ;
84276: GO 84939
// for i = 1 to mc_bases do
84278: LD_ADDR_VAR 0 3
84282: PUSH
84283: DOUBLE
84284: LD_INT 1
84286: DEC
84287: ST_TO_ADDR
84288: LD_EXP 68
84292: PUSH
84293: FOR_TO
84294: IFFALSE 84937
// begin if building in mc_construct_list [ i ] then
84296: LD_VAR 0 1
84300: PUSH
84301: LD_EXP 75
84305: PUSH
84306: LD_VAR 0 3
84310: ARRAY
84311: IN
84312: IFFALSE 84935
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84314: LD_ADDR_EXP 75
84318: PUSH
84319: LD_EXP 75
84323: PPUSH
84324: LD_VAR 0 3
84328: PPUSH
84329: LD_EXP 75
84333: PUSH
84334: LD_VAR 0 3
84338: ARRAY
84339: PUSH
84340: LD_VAR 0 1
84344: DIFF
84345: PPUSH
84346: CALL_OW 1
84350: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84351: LD_ADDR_EXP 68
84355: PUSH
84356: LD_EXP 68
84360: PPUSH
84361: LD_VAR 0 3
84365: PUSH
84366: LD_EXP 68
84370: PUSH
84371: LD_VAR 0 3
84375: ARRAY
84376: PUSH
84377: LD_INT 1
84379: PLUS
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PPUSH
84385: LD_VAR 0 1
84389: PPUSH
84390: CALL 18750 0 3
84394: ST_TO_ADDR
// btype := GetBType ( building ) ;
84395: LD_ADDR_VAR 0 5
84399: PUSH
84400: LD_VAR 0 1
84404: PPUSH
84405: CALL_OW 266
84409: ST_TO_ADDR
// side := GetSide ( building ) ;
84410: LD_ADDR_VAR 0 8
84414: PUSH
84415: LD_VAR 0 1
84419: PPUSH
84420: CALL_OW 255
84424: ST_TO_ADDR
// if btype = b_lab then
84425: LD_VAR 0 5
84429: PUSH
84430: LD_INT 6
84432: EQUAL
84433: IFFALSE 84483
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84435: LD_ADDR_EXP 101
84439: PUSH
84440: LD_EXP 101
84444: PPUSH
84445: LD_VAR 0 3
84449: PUSH
84450: LD_EXP 101
84454: PUSH
84455: LD_VAR 0 3
84459: ARRAY
84460: PUSH
84461: LD_INT 1
84463: PLUS
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PPUSH
84469: LD_VAR 0 1
84473: PPUSH
84474: CALL 18750 0 3
84478: ST_TO_ADDR
// exit ;
84479: POP
84480: POP
84481: GO 84939
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84483: LD_VAR 0 5
84487: PUSH
84488: LD_INT 0
84490: PUSH
84491: LD_INT 2
84493: PUSH
84494: LD_INT 4
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: LIST
84501: IN
84502: IFFALSE 84626
// begin if btype = b_armoury then
84504: LD_VAR 0 5
84508: PUSH
84509: LD_INT 4
84511: EQUAL
84512: IFFALSE 84522
// btype := b_barracks ;
84514: LD_ADDR_VAR 0 5
84518: PUSH
84519: LD_INT 5
84521: ST_TO_ADDR
// if btype = b_depot then
84522: LD_VAR 0 5
84526: PUSH
84527: LD_INT 0
84529: EQUAL
84530: IFFALSE 84540
// btype := b_warehouse ;
84532: LD_ADDR_VAR 0 5
84536: PUSH
84537: LD_INT 1
84539: ST_TO_ADDR
// if btype = b_workshop then
84540: LD_VAR 0 5
84544: PUSH
84545: LD_INT 2
84547: EQUAL
84548: IFFALSE 84558
// btype := b_factory ;
84550: LD_ADDR_VAR 0 5
84554: PUSH
84555: LD_INT 3
84557: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84558: LD_VAR 0 5
84562: PPUSH
84563: LD_VAR 0 8
84567: PPUSH
84568: CALL_OW 323
84572: PUSH
84573: LD_INT 1
84575: EQUAL
84576: IFFALSE 84622
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84578: LD_ADDR_EXP 100
84582: PUSH
84583: LD_EXP 100
84587: PPUSH
84588: LD_VAR 0 3
84592: PUSH
84593: LD_EXP 100
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: PUSH
84604: LD_INT 1
84606: PLUS
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PPUSH
84612: LD_VAR 0 1
84616: PPUSH
84617: CALL 18750 0 3
84621: ST_TO_ADDR
// exit ;
84622: POP
84623: POP
84624: GO 84939
// end ; if btype in [ b_bunker , b_turret ] then
84626: LD_VAR 0 5
84630: PUSH
84631: LD_INT 32
84633: PUSH
84634: LD_INT 33
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: IN
84641: IFFALSE 84931
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84643: LD_ADDR_EXP 76
84647: PUSH
84648: LD_EXP 76
84652: PPUSH
84653: LD_VAR 0 3
84657: PUSH
84658: LD_EXP 76
84662: PUSH
84663: LD_VAR 0 3
84667: ARRAY
84668: PUSH
84669: LD_INT 1
84671: PLUS
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PPUSH
84677: LD_VAR 0 1
84681: PPUSH
84682: CALL 18750 0 3
84686: ST_TO_ADDR
// if btype = b_bunker then
84687: LD_VAR 0 5
84691: PUSH
84692: LD_INT 32
84694: EQUAL
84695: IFFALSE 84931
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84697: LD_ADDR_EXP 77
84701: PUSH
84702: LD_EXP 77
84706: PPUSH
84707: LD_VAR 0 3
84711: PUSH
84712: LD_EXP 77
84716: PUSH
84717: LD_VAR 0 3
84721: ARRAY
84722: PUSH
84723: LD_INT 1
84725: PLUS
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PPUSH
84731: LD_VAR 0 1
84735: PPUSH
84736: CALL 18750 0 3
84740: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84741: LD_ADDR_VAR 0 6
84745: PUSH
84746: LD_EXP 68
84750: PUSH
84751: LD_VAR 0 3
84755: ARRAY
84756: PPUSH
84757: LD_INT 25
84759: PUSH
84760: LD_INT 1
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 3
84769: PUSH
84770: LD_INT 54
84772: PUSH
84773: EMPTY
84774: LIST
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PPUSH
84784: CALL_OW 72
84788: ST_TO_ADDR
// if tmp then
84789: LD_VAR 0 6
84793: IFFALSE 84799
// exit ;
84795: POP
84796: POP
84797: GO 84939
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84799: LD_ADDR_VAR 0 6
84803: PUSH
84804: LD_EXP 68
84808: PUSH
84809: LD_VAR 0 3
84813: ARRAY
84814: PPUSH
84815: LD_INT 2
84817: PUSH
84818: LD_INT 30
84820: PUSH
84821: LD_INT 4
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 30
84830: PUSH
84831: LD_INT 5
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: PPUSH
84843: CALL_OW 72
84847: ST_TO_ADDR
// if not tmp then
84848: LD_VAR 0 6
84852: NOT
84853: IFFALSE 84859
// exit ;
84855: POP
84856: POP
84857: GO 84939
// for j in tmp do
84859: LD_ADDR_VAR 0 4
84863: PUSH
84864: LD_VAR 0 6
84868: PUSH
84869: FOR_IN
84870: IFFALSE 84929
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84872: LD_ADDR_VAR 0 7
84876: PUSH
84877: LD_VAR 0 4
84881: PPUSH
84882: CALL_OW 313
84886: PPUSH
84887: LD_INT 25
84889: PUSH
84890: LD_INT 1
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PPUSH
84897: CALL_OW 72
84901: ST_TO_ADDR
// if units then
84902: LD_VAR 0 7
84906: IFFALSE 84927
// begin ComExitBuilding ( units [ 1 ] ) ;
84908: LD_VAR 0 7
84912: PUSH
84913: LD_INT 1
84915: ARRAY
84916: PPUSH
84917: CALL_OW 122
// exit ;
84921: POP
84922: POP
84923: POP
84924: POP
84925: GO 84939
// end ; end ;
84927: GO 84869
84929: POP
84930: POP
// end ; end ; exit ;
84931: POP
84932: POP
84933: GO 84939
// end ; end ;
84935: GO 84293
84937: POP
84938: POP
// end ;
84939: LD_VAR 0 2
84943: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84944: LD_INT 0
84946: PPUSH
84947: PPUSH
84948: PPUSH
84949: PPUSH
84950: PPUSH
84951: PPUSH
84952: PPUSH
// if not mc_bases or not skirmish then
84953: LD_EXP 68
84957: NOT
84958: PUSH
84959: LD_EXP 66
84963: NOT
84964: OR
84965: IFFALSE 84969
// exit ;
84967: GO 85234
// btype := GetBType ( building ) ;
84969: LD_ADDR_VAR 0 6
84973: PUSH
84974: LD_VAR 0 1
84978: PPUSH
84979: CALL_OW 266
84983: ST_TO_ADDR
// x := GetX ( building ) ;
84984: LD_ADDR_VAR 0 7
84988: PUSH
84989: LD_VAR 0 1
84993: PPUSH
84994: CALL_OW 250
84998: ST_TO_ADDR
// y := GetY ( building ) ;
84999: LD_ADDR_VAR 0 8
85003: PUSH
85004: LD_VAR 0 1
85008: PPUSH
85009: CALL_OW 251
85013: ST_TO_ADDR
// d := GetDir ( building ) ;
85014: LD_ADDR_VAR 0 9
85018: PUSH
85019: LD_VAR 0 1
85023: PPUSH
85024: CALL_OW 254
85028: ST_TO_ADDR
// for i = 1 to mc_bases do
85029: LD_ADDR_VAR 0 4
85033: PUSH
85034: DOUBLE
85035: LD_INT 1
85037: DEC
85038: ST_TO_ADDR
85039: LD_EXP 68
85043: PUSH
85044: FOR_TO
85045: IFFALSE 85232
// begin if not mc_build_list [ i ] then
85047: LD_EXP 73
85051: PUSH
85052: LD_VAR 0 4
85056: ARRAY
85057: NOT
85058: IFFALSE 85062
// continue ;
85060: GO 85044
// for j := 1 to mc_build_list [ i ] do
85062: LD_ADDR_VAR 0 5
85066: PUSH
85067: DOUBLE
85068: LD_INT 1
85070: DEC
85071: ST_TO_ADDR
85072: LD_EXP 73
85076: PUSH
85077: LD_VAR 0 4
85081: ARRAY
85082: PUSH
85083: FOR_TO
85084: IFFALSE 85228
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85086: LD_VAR 0 6
85090: PUSH
85091: LD_VAR 0 7
85095: PUSH
85096: LD_VAR 0 8
85100: PUSH
85101: LD_VAR 0 9
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: PPUSH
85112: LD_EXP 73
85116: PUSH
85117: LD_VAR 0 4
85121: ARRAY
85122: PUSH
85123: LD_VAR 0 5
85127: ARRAY
85128: PPUSH
85129: CALL 24932 0 2
85133: IFFALSE 85226
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85135: LD_ADDR_EXP 73
85139: PUSH
85140: LD_EXP 73
85144: PPUSH
85145: LD_VAR 0 4
85149: PPUSH
85150: LD_EXP 73
85154: PUSH
85155: LD_VAR 0 4
85159: ARRAY
85160: PPUSH
85161: LD_VAR 0 5
85165: PPUSH
85166: CALL_OW 3
85170: PPUSH
85171: CALL_OW 1
85175: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85176: LD_ADDR_EXP 75
85180: PUSH
85181: LD_EXP 75
85185: PPUSH
85186: LD_VAR 0 4
85190: PUSH
85191: LD_EXP 75
85195: PUSH
85196: LD_VAR 0 4
85200: ARRAY
85201: PUSH
85202: LD_INT 1
85204: PLUS
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PPUSH
85210: LD_VAR 0 1
85214: PPUSH
85215: CALL 18750 0 3
85219: ST_TO_ADDR
// exit ;
85220: POP
85221: POP
85222: POP
85223: POP
85224: GO 85234
// end ;
85226: GO 85083
85228: POP
85229: POP
// end ;
85230: GO 85044
85232: POP
85233: POP
// end ;
85234: LD_VAR 0 3
85238: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85239: LD_INT 0
85241: PPUSH
85242: PPUSH
85243: PPUSH
// if not mc_bases or not skirmish then
85244: LD_EXP 68
85248: NOT
85249: PUSH
85250: LD_EXP 66
85254: NOT
85255: OR
85256: IFFALSE 85260
// exit ;
85258: GO 85450
// for i = 1 to mc_bases do
85260: LD_ADDR_VAR 0 4
85264: PUSH
85265: DOUBLE
85266: LD_INT 1
85268: DEC
85269: ST_TO_ADDR
85270: LD_EXP 68
85274: PUSH
85275: FOR_TO
85276: IFFALSE 85363
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85278: LD_VAR 0 1
85282: PUSH
85283: LD_EXP 76
85287: PUSH
85288: LD_VAR 0 4
85292: ARRAY
85293: IN
85294: PUSH
85295: LD_VAR 0 1
85299: PUSH
85300: LD_EXP 77
85304: PUSH
85305: LD_VAR 0 4
85309: ARRAY
85310: IN
85311: NOT
85312: AND
85313: IFFALSE 85361
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85315: LD_ADDR_EXP 77
85319: PUSH
85320: LD_EXP 77
85324: PPUSH
85325: LD_VAR 0 4
85329: PUSH
85330: LD_EXP 77
85334: PUSH
85335: LD_VAR 0 4
85339: ARRAY
85340: PUSH
85341: LD_INT 1
85343: PLUS
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PPUSH
85349: LD_VAR 0 1
85353: PPUSH
85354: CALL 18750 0 3
85358: ST_TO_ADDR
// break ;
85359: GO 85363
// end ; end ;
85361: GO 85275
85363: POP
85364: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85365: LD_VAR 0 1
85369: PPUSH
85370: CALL_OW 257
85374: PUSH
85375: LD_EXP 94
85379: IN
85380: PUSH
85381: LD_VAR 0 1
85385: PPUSH
85386: CALL_OW 266
85390: PUSH
85391: LD_INT 5
85393: EQUAL
85394: AND
85395: PUSH
85396: LD_VAR 0 2
85400: PPUSH
85401: CALL_OW 110
85405: PUSH
85406: LD_INT 18
85408: NONEQUAL
85409: AND
85410: IFFALSE 85450
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85412: LD_VAR 0 2
85416: PPUSH
85417: CALL_OW 257
85421: PUSH
85422: LD_INT 5
85424: PUSH
85425: LD_INT 8
85427: PUSH
85428: LD_INT 9
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: LIST
85435: IN
85436: IFFALSE 85450
// SetClass ( unit , 1 ) ;
85438: LD_VAR 0 2
85442: PPUSH
85443: LD_INT 1
85445: PPUSH
85446: CALL_OW 336
// end ;
85450: LD_VAR 0 3
85454: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85455: LD_INT 0
85457: PPUSH
85458: PPUSH
// if not mc_bases or not skirmish then
85459: LD_EXP 68
85463: NOT
85464: PUSH
85465: LD_EXP 66
85469: NOT
85470: OR
85471: IFFALSE 85475
// exit ;
85473: GO 85591
// if GetLives ( abandoned_vehicle ) > 250 then
85475: LD_VAR 0 2
85479: PPUSH
85480: CALL_OW 256
85484: PUSH
85485: LD_INT 250
85487: GREATER
85488: IFFALSE 85492
// exit ;
85490: GO 85591
// for i = 1 to mc_bases do
85492: LD_ADDR_VAR 0 6
85496: PUSH
85497: DOUBLE
85498: LD_INT 1
85500: DEC
85501: ST_TO_ADDR
85502: LD_EXP 68
85506: PUSH
85507: FOR_TO
85508: IFFALSE 85589
// begin if driver in mc_bases [ i ] then
85510: LD_VAR 0 1
85514: PUSH
85515: LD_EXP 68
85519: PUSH
85520: LD_VAR 0 6
85524: ARRAY
85525: IN
85526: IFFALSE 85587
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85528: LD_VAR 0 1
85532: PPUSH
85533: LD_EXP 68
85537: PUSH
85538: LD_VAR 0 6
85542: ARRAY
85543: PPUSH
85544: LD_INT 2
85546: PUSH
85547: LD_INT 30
85549: PUSH
85550: LD_INT 0
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 30
85559: PUSH
85560: LD_INT 1
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: LIST
85571: PPUSH
85572: CALL_OW 72
85576: PUSH
85577: LD_INT 1
85579: ARRAY
85580: PPUSH
85581: CALL 51872 0 2
// break ;
85585: GO 85589
// end ; end ;
85587: GO 85507
85589: POP
85590: POP
// end ; end_of_file end_of_file
85591: LD_VAR 0 5
85595: RET
// every 0 0$1 do
85596: GO 85598
85598: DISABLE
// begin enable ;
85599: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85600: LD_STRING updateTimer(
85602: PUSH
85603: LD_OWVAR 1
85607: STR
85608: PUSH
85609: LD_STRING );
85611: STR
85612: PPUSH
85613: CALL_OW 559
// end ;
85617: END
// export function SOS_MapStart ( ) ; begin
85618: LD_INT 0
85620: PPUSH
// if streamModeActive then
85621: LD_EXP 112
85625: IFFALSE 85634
// DefineStreamItems ( true ) ;
85627: LD_INT 1
85629: PPUSH
85630: CALL 87288 0 1
// UpdateFactoryWaypoints ( ) ;
85634: CALL 100149 0 0
// UpdateWarehouseGatheringPoints ( ) ;
85638: CALL 100406 0 0
// end ;
85642: LD_VAR 0 1
85646: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85647: LD_INT 0
85649: PPUSH
// if p2 = 100 then
85650: LD_VAR 0 2
85654: PUSH
85655: LD_INT 100
85657: EQUAL
85658: IFFALSE 86661
// begin if not StreamModeActive then
85660: LD_EXP 112
85664: NOT
85665: IFFALSE 85675
// StreamModeActive := true ;
85667: LD_ADDR_EXP 112
85671: PUSH
85672: LD_INT 1
85674: ST_TO_ADDR
// if p3 = 0 then
85675: LD_VAR 0 3
85679: PUSH
85680: LD_INT 0
85682: EQUAL
85683: IFFALSE 85689
// InitStreamMode ;
85685: CALL 86824 0 0
// if p3 = 1 then
85689: LD_VAR 0 3
85693: PUSH
85694: LD_INT 1
85696: EQUAL
85697: IFFALSE 85707
// sRocket := true ;
85699: LD_ADDR_EXP 117
85703: PUSH
85704: LD_INT 1
85706: ST_TO_ADDR
// if p3 = 2 then
85707: LD_VAR 0 3
85711: PUSH
85712: LD_INT 2
85714: EQUAL
85715: IFFALSE 85725
// sSpeed := true ;
85717: LD_ADDR_EXP 116
85721: PUSH
85722: LD_INT 1
85724: ST_TO_ADDR
// if p3 = 3 then
85725: LD_VAR 0 3
85729: PUSH
85730: LD_INT 3
85732: EQUAL
85733: IFFALSE 85743
// sEngine := true ;
85735: LD_ADDR_EXP 118
85739: PUSH
85740: LD_INT 1
85742: ST_TO_ADDR
// if p3 = 4 then
85743: LD_VAR 0 3
85747: PUSH
85748: LD_INT 4
85750: EQUAL
85751: IFFALSE 85761
// sSpec := true ;
85753: LD_ADDR_EXP 115
85757: PUSH
85758: LD_INT 1
85760: ST_TO_ADDR
// if p3 = 5 then
85761: LD_VAR 0 3
85765: PUSH
85766: LD_INT 5
85768: EQUAL
85769: IFFALSE 85779
// sLevel := true ;
85771: LD_ADDR_EXP 119
85775: PUSH
85776: LD_INT 1
85778: ST_TO_ADDR
// if p3 = 6 then
85779: LD_VAR 0 3
85783: PUSH
85784: LD_INT 6
85786: EQUAL
85787: IFFALSE 85797
// sArmoury := true ;
85789: LD_ADDR_EXP 120
85793: PUSH
85794: LD_INT 1
85796: ST_TO_ADDR
// if p3 = 7 then
85797: LD_VAR 0 3
85801: PUSH
85802: LD_INT 7
85804: EQUAL
85805: IFFALSE 85815
// sRadar := true ;
85807: LD_ADDR_EXP 121
85811: PUSH
85812: LD_INT 1
85814: ST_TO_ADDR
// if p3 = 8 then
85815: LD_VAR 0 3
85819: PUSH
85820: LD_INT 8
85822: EQUAL
85823: IFFALSE 85833
// sBunker := true ;
85825: LD_ADDR_EXP 122
85829: PUSH
85830: LD_INT 1
85832: ST_TO_ADDR
// if p3 = 9 then
85833: LD_VAR 0 3
85837: PUSH
85838: LD_INT 9
85840: EQUAL
85841: IFFALSE 85851
// sHack := true ;
85843: LD_ADDR_EXP 123
85847: PUSH
85848: LD_INT 1
85850: ST_TO_ADDR
// if p3 = 10 then
85851: LD_VAR 0 3
85855: PUSH
85856: LD_INT 10
85858: EQUAL
85859: IFFALSE 85869
// sFire := true ;
85861: LD_ADDR_EXP 124
85865: PUSH
85866: LD_INT 1
85868: ST_TO_ADDR
// if p3 = 11 then
85869: LD_VAR 0 3
85873: PUSH
85874: LD_INT 11
85876: EQUAL
85877: IFFALSE 85887
// sRefresh := true ;
85879: LD_ADDR_EXP 125
85883: PUSH
85884: LD_INT 1
85886: ST_TO_ADDR
// if p3 = 12 then
85887: LD_VAR 0 3
85891: PUSH
85892: LD_INT 12
85894: EQUAL
85895: IFFALSE 85905
// sExp := true ;
85897: LD_ADDR_EXP 126
85901: PUSH
85902: LD_INT 1
85904: ST_TO_ADDR
// if p3 = 13 then
85905: LD_VAR 0 3
85909: PUSH
85910: LD_INT 13
85912: EQUAL
85913: IFFALSE 85923
// sDepot := true ;
85915: LD_ADDR_EXP 127
85919: PUSH
85920: LD_INT 1
85922: ST_TO_ADDR
// if p3 = 14 then
85923: LD_VAR 0 3
85927: PUSH
85928: LD_INT 14
85930: EQUAL
85931: IFFALSE 85941
// sFlag := true ;
85933: LD_ADDR_EXP 128
85937: PUSH
85938: LD_INT 1
85940: ST_TO_ADDR
// if p3 = 15 then
85941: LD_VAR 0 3
85945: PUSH
85946: LD_INT 15
85948: EQUAL
85949: IFFALSE 85959
// sKamikadze := true ;
85951: LD_ADDR_EXP 136
85955: PUSH
85956: LD_INT 1
85958: ST_TO_ADDR
// if p3 = 16 then
85959: LD_VAR 0 3
85963: PUSH
85964: LD_INT 16
85966: EQUAL
85967: IFFALSE 85977
// sTroll := true ;
85969: LD_ADDR_EXP 137
85973: PUSH
85974: LD_INT 1
85976: ST_TO_ADDR
// if p3 = 17 then
85977: LD_VAR 0 3
85981: PUSH
85982: LD_INT 17
85984: EQUAL
85985: IFFALSE 85995
// sSlow := true ;
85987: LD_ADDR_EXP 138
85991: PUSH
85992: LD_INT 1
85994: ST_TO_ADDR
// if p3 = 18 then
85995: LD_VAR 0 3
85999: PUSH
86000: LD_INT 18
86002: EQUAL
86003: IFFALSE 86013
// sLack := true ;
86005: LD_ADDR_EXP 139
86009: PUSH
86010: LD_INT 1
86012: ST_TO_ADDR
// if p3 = 19 then
86013: LD_VAR 0 3
86017: PUSH
86018: LD_INT 19
86020: EQUAL
86021: IFFALSE 86031
// sTank := true ;
86023: LD_ADDR_EXP 141
86027: PUSH
86028: LD_INT 1
86030: ST_TO_ADDR
// if p3 = 20 then
86031: LD_VAR 0 3
86035: PUSH
86036: LD_INT 20
86038: EQUAL
86039: IFFALSE 86049
// sRemote := true ;
86041: LD_ADDR_EXP 142
86045: PUSH
86046: LD_INT 1
86048: ST_TO_ADDR
// if p3 = 21 then
86049: LD_VAR 0 3
86053: PUSH
86054: LD_INT 21
86056: EQUAL
86057: IFFALSE 86067
// sPowell := true ;
86059: LD_ADDR_EXP 143
86063: PUSH
86064: LD_INT 1
86066: ST_TO_ADDR
// if p3 = 22 then
86067: LD_VAR 0 3
86071: PUSH
86072: LD_INT 22
86074: EQUAL
86075: IFFALSE 86085
// sTeleport := true ;
86077: LD_ADDR_EXP 146
86081: PUSH
86082: LD_INT 1
86084: ST_TO_ADDR
// if p3 = 23 then
86085: LD_VAR 0 3
86089: PUSH
86090: LD_INT 23
86092: EQUAL
86093: IFFALSE 86103
// sOilTower := true ;
86095: LD_ADDR_EXP 148
86099: PUSH
86100: LD_INT 1
86102: ST_TO_ADDR
// if p3 = 24 then
86103: LD_VAR 0 3
86107: PUSH
86108: LD_INT 24
86110: EQUAL
86111: IFFALSE 86121
// sShovel := true ;
86113: LD_ADDR_EXP 149
86117: PUSH
86118: LD_INT 1
86120: ST_TO_ADDR
// if p3 = 25 then
86121: LD_VAR 0 3
86125: PUSH
86126: LD_INT 25
86128: EQUAL
86129: IFFALSE 86139
// sSheik := true ;
86131: LD_ADDR_EXP 150
86135: PUSH
86136: LD_INT 1
86138: ST_TO_ADDR
// if p3 = 26 then
86139: LD_VAR 0 3
86143: PUSH
86144: LD_INT 26
86146: EQUAL
86147: IFFALSE 86157
// sEarthquake := true ;
86149: LD_ADDR_EXP 152
86153: PUSH
86154: LD_INT 1
86156: ST_TO_ADDR
// if p3 = 27 then
86157: LD_VAR 0 3
86161: PUSH
86162: LD_INT 27
86164: EQUAL
86165: IFFALSE 86175
// sAI := true ;
86167: LD_ADDR_EXP 153
86171: PUSH
86172: LD_INT 1
86174: ST_TO_ADDR
// if p3 = 28 then
86175: LD_VAR 0 3
86179: PUSH
86180: LD_INT 28
86182: EQUAL
86183: IFFALSE 86193
// sCargo := true ;
86185: LD_ADDR_EXP 156
86189: PUSH
86190: LD_INT 1
86192: ST_TO_ADDR
// if p3 = 29 then
86193: LD_VAR 0 3
86197: PUSH
86198: LD_INT 29
86200: EQUAL
86201: IFFALSE 86211
// sDLaser := true ;
86203: LD_ADDR_EXP 157
86207: PUSH
86208: LD_INT 1
86210: ST_TO_ADDR
// if p3 = 30 then
86211: LD_VAR 0 3
86215: PUSH
86216: LD_INT 30
86218: EQUAL
86219: IFFALSE 86229
// sExchange := true ;
86221: LD_ADDR_EXP 158
86225: PUSH
86226: LD_INT 1
86228: ST_TO_ADDR
// if p3 = 31 then
86229: LD_VAR 0 3
86233: PUSH
86234: LD_INT 31
86236: EQUAL
86237: IFFALSE 86247
// sFac := true ;
86239: LD_ADDR_EXP 159
86243: PUSH
86244: LD_INT 1
86246: ST_TO_ADDR
// if p3 = 32 then
86247: LD_VAR 0 3
86251: PUSH
86252: LD_INT 32
86254: EQUAL
86255: IFFALSE 86265
// sPower := true ;
86257: LD_ADDR_EXP 160
86261: PUSH
86262: LD_INT 1
86264: ST_TO_ADDR
// if p3 = 33 then
86265: LD_VAR 0 3
86269: PUSH
86270: LD_INT 33
86272: EQUAL
86273: IFFALSE 86283
// sRandom := true ;
86275: LD_ADDR_EXP 161
86279: PUSH
86280: LD_INT 1
86282: ST_TO_ADDR
// if p3 = 34 then
86283: LD_VAR 0 3
86287: PUSH
86288: LD_INT 34
86290: EQUAL
86291: IFFALSE 86301
// sShield := true ;
86293: LD_ADDR_EXP 162
86297: PUSH
86298: LD_INT 1
86300: ST_TO_ADDR
// if p3 = 35 then
86301: LD_VAR 0 3
86305: PUSH
86306: LD_INT 35
86308: EQUAL
86309: IFFALSE 86319
// sTime := true ;
86311: LD_ADDR_EXP 163
86315: PUSH
86316: LD_INT 1
86318: ST_TO_ADDR
// if p3 = 36 then
86319: LD_VAR 0 3
86323: PUSH
86324: LD_INT 36
86326: EQUAL
86327: IFFALSE 86337
// sTools := true ;
86329: LD_ADDR_EXP 164
86333: PUSH
86334: LD_INT 1
86336: ST_TO_ADDR
// if p3 = 101 then
86337: LD_VAR 0 3
86341: PUSH
86342: LD_INT 101
86344: EQUAL
86345: IFFALSE 86355
// sSold := true ;
86347: LD_ADDR_EXP 129
86351: PUSH
86352: LD_INT 1
86354: ST_TO_ADDR
// if p3 = 102 then
86355: LD_VAR 0 3
86359: PUSH
86360: LD_INT 102
86362: EQUAL
86363: IFFALSE 86373
// sDiff := true ;
86365: LD_ADDR_EXP 130
86369: PUSH
86370: LD_INT 1
86372: ST_TO_ADDR
// if p3 = 103 then
86373: LD_VAR 0 3
86377: PUSH
86378: LD_INT 103
86380: EQUAL
86381: IFFALSE 86391
// sFog := true ;
86383: LD_ADDR_EXP 133
86387: PUSH
86388: LD_INT 1
86390: ST_TO_ADDR
// if p3 = 104 then
86391: LD_VAR 0 3
86395: PUSH
86396: LD_INT 104
86398: EQUAL
86399: IFFALSE 86409
// sReset := true ;
86401: LD_ADDR_EXP 134
86405: PUSH
86406: LD_INT 1
86408: ST_TO_ADDR
// if p3 = 105 then
86409: LD_VAR 0 3
86413: PUSH
86414: LD_INT 105
86416: EQUAL
86417: IFFALSE 86427
// sSun := true ;
86419: LD_ADDR_EXP 135
86423: PUSH
86424: LD_INT 1
86426: ST_TO_ADDR
// if p3 = 106 then
86427: LD_VAR 0 3
86431: PUSH
86432: LD_INT 106
86434: EQUAL
86435: IFFALSE 86445
// sTiger := true ;
86437: LD_ADDR_EXP 131
86441: PUSH
86442: LD_INT 1
86444: ST_TO_ADDR
// if p3 = 107 then
86445: LD_VAR 0 3
86449: PUSH
86450: LD_INT 107
86452: EQUAL
86453: IFFALSE 86463
// sBomb := true ;
86455: LD_ADDR_EXP 132
86459: PUSH
86460: LD_INT 1
86462: ST_TO_ADDR
// if p3 = 108 then
86463: LD_VAR 0 3
86467: PUSH
86468: LD_INT 108
86470: EQUAL
86471: IFFALSE 86481
// sWound := true ;
86473: LD_ADDR_EXP 140
86477: PUSH
86478: LD_INT 1
86480: ST_TO_ADDR
// if p3 = 109 then
86481: LD_VAR 0 3
86485: PUSH
86486: LD_INT 109
86488: EQUAL
86489: IFFALSE 86499
// sBetray := true ;
86491: LD_ADDR_EXP 144
86495: PUSH
86496: LD_INT 1
86498: ST_TO_ADDR
// if p3 = 110 then
86499: LD_VAR 0 3
86503: PUSH
86504: LD_INT 110
86506: EQUAL
86507: IFFALSE 86517
// sContamin := true ;
86509: LD_ADDR_EXP 145
86513: PUSH
86514: LD_INT 1
86516: ST_TO_ADDR
// if p3 = 111 then
86517: LD_VAR 0 3
86521: PUSH
86522: LD_INT 111
86524: EQUAL
86525: IFFALSE 86535
// sOil := true ;
86527: LD_ADDR_EXP 147
86531: PUSH
86532: LD_INT 1
86534: ST_TO_ADDR
// if p3 = 112 then
86535: LD_VAR 0 3
86539: PUSH
86540: LD_INT 112
86542: EQUAL
86543: IFFALSE 86553
// sStu := true ;
86545: LD_ADDR_EXP 151
86549: PUSH
86550: LD_INT 1
86552: ST_TO_ADDR
// if p3 = 113 then
86553: LD_VAR 0 3
86557: PUSH
86558: LD_INT 113
86560: EQUAL
86561: IFFALSE 86571
// sBazooka := true ;
86563: LD_ADDR_EXP 154
86567: PUSH
86568: LD_INT 1
86570: ST_TO_ADDR
// if p3 = 114 then
86571: LD_VAR 0 3
86575: PUSH
86576: LD_INT 114
86578: EQUAL
86579: IFFALSE 86589
// sMortar := true ;
86581: LD_ADDR_EXP 155
86585: PUSH
86586: LD_INT 1
86588: ST_TO_ADDR
// if p3 = 115 then
86589: LD_VAR 0 3
86593: PUSH
86594: LD_INT 115
86596: EQUAL
86597: IFFALSE 86607
// sRanger := true ;
86599: LD_ADDR_EXP 165
86603: PUSH
86604: LD_INT 1
86606: ST_TO_ADDR
// if p3 = 116 then
86607: LD_VAR 0 3
86611: PUSH
86612: LD_INT 116
86614: EQUAL
86615: IFFALSE 86625
// sComputer := true ;
86617: LD_ADDR_EXP 166
86621: PUSH
86622: LD_INT 1
86624: ST_TO_ADDR
// if p3 = 117 then
86625: LD_VAR 0 3
86629: PUSH
86630: LD_INT 117
86632: EQUAL
86633: IFFALSE 86643
// s30 := true ;
86635: LD_ADDR_EXP 167
86639: PUSH
86640: LD_INT 1
86642: ST_TO_ADDR
// if p3 = 118 then
86643: LD_VAR 0 3
86647: PUSH
86648: LD_INT 118
86650: EQUAL
86651: IFFALSE 86661
// s60 := true ;
86653: LD_ADDR_EXP 168
86657: PUSH
86658: LD_INT 1
86660: ST_TO_ADDR
// end ; if p2 = 101 then
86661: LD_VAR 0 2
86665: PUSH
86666: LD_INT 101
86668: EQUAL
86669: IFFALSE 86797
// begin case p3 of 1 :
86671: LD_VAR 0 3
86675: PUSH
86676: LD_INT 1
86678: DOUBLE
86679: EQUAL
86680: IFTRUE 86684
86682: GO 86691
86684: POP
// hHackUnlimitedResources ; 2 :
86685: CALL 98895 0 0
86689: GO 86797
86691: LD_INT 2
86693: DOUBLE
86694: EQUAL
86695: IFTRUE 86699
86697: GO 86706
86699: POP
// hHackSetLevel10 ; 3 :
86700: CALL 99028 0 0
86704: GO 86797
86706: LD_INT 3
86708: DOUBLE
86709: EQUAL
86710: IFTRUE 86714
86712: GO 86721
86714: POP
// hHackSetLevel10YourUnits ; 4 :
86715: CALL 99113 0 0
86719: GO 86797
86721: LD_INT 4
86723: DOUBLE
86724: EQUAL
86725: IFTRUE 86729
86727: GO 86736
86729: POP
// hHackInvincible ; 5 :
86730: CALL 99561 0 0
86734: GO 86797
86736: LD_INT 5
86738: DOUBLE
86739: EQUAL
86740: IFTRUE 86744
86742: GO 86751
86744: POP
// hHackInvisible ; 6 :
86745: CALL 99672 0 0
86749: GO 86797
86751: LD_INT 6
86753: DOUBLE
86754: EQUAL
86755: IFTRUE 86759
86757: GO 86766
86759: POP
// hHackChangeYourSide ; 7 :
86760: CALL 99729 0 0
86764: GO 86797
86766: LD_INT 7
86768: DOUBLE
86769: EQUAL
86770: IFTRUE 86774
86772: GO 86781
86774: POP
// hHackChangeUnitSide ; 8 :
86775: CALL 99771 0 0
86779: GO 86797
86781: LD_INT 8
86783: DOUBLE
86784: EQUAL
86785: IFTRUE 86789
86787: GO 86796
86789: POP
// hHackFog ; end ;
86790: CALL 99872 0 0
86794: GO 86797
86796: POP
// end ; end ;
86797: LD_VAR 0 7
86801: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
86802: GO 86804
86804: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86805: LD_STRING initStreamRollete();
86807: PPUSH
86808: CALL_OW 559
// InitStreamMode ;
86812: CALL 86824 0 0
// DefineStreamItems ( false ) ;
86816: LD_INT 0
86818: PPUSH
86819: CALL 87288 0 1
// end ;
86823: END
// function InitStreamMode ; begin
86824: LD_INT 0
86826: PPUSH
// streamModeActive := false ;
86827: LD_ADDR_EXP 112
86831: PUSH
86832: LD_INT 0
86834: ST_TO_ADDR
// normalCounter := 36 ;
86835: LD_ADDR_EXP 113
86839: PUSH
86840: LD_INT 36
86842: ST_TO_ADDR
// hardcoreCounter := 18 ;
86843: LD_ADDR_EXP 114
86847: PUSH
86848: LD_INT 18
86850: ST_TO_ADDR
// sRocket := false ;
86851: LD_ADDR_EXP 117
86855: PUSH
86856: LD_INT 0
86858: ST_TO_ADDR
// sSpeed := false ;
86859: LD_ADDR_EXP 116
86863: PUSH
86864: LD_INT 0
86866: ST_TO_ADDR
// sEngine := false ;
86867: LD_ADDR_EXP 118
86871: PUSH
86872: LD_INT 0
86874: ST_TO_ADDR
// sSpec := false ;
86875: LD_ADDR_EXP 115
86879: PUSH
86880: LD_INT 0
86882: ST_TO_ADDR
// sLevel := false ;
86883: LD_ADDR_EXP 119
86887: PUSH
86888: LD_INT 0
86890: ST_TO_ADDR
// sArmoury := false ;
86891: LD_ADDR_EXP 120
86895: PUSH
86896: LD_INT 0
86898: ST_TO_ADDR
// sRadar := false ;
86899: LD_ADDR_EXP 121
86903: PUSH
86904: LD_INT 0
86906: ST_TO_ADDR
// sBunker := false ;
86907: LD_ADDR_EXP 122
86911: PUSH
86912: LD_INT 0
86914: ST_TO_ADDR
// sHack := false ;
86915: LD_ADDR_EXP 123
86919: PUSH
86920: LD_INT 0
86922: ST_TO_ADDR
// sFire := false ;
86923: LD_ADDR_EXP 124
86927: PUSH
86928: LD_INT 0
86930: ST_TO_ADDR
// sRefresh := false ;
86931: LD_ADDR_EXP 125
86935: PUSH
86936: LD_INT 0
86938: ST_TO_ADDR
// sExp := false ;
86939: LD_ADDR_EXP 126
86943: PUSH
86944: LD_INT 0
86946: ST_TO_ADDR
// sDepot := false ;
86947: LD_ADDR_EXP 127
86951: PUSH
86952: LD_INT 0
86954: ST_TO_ADDR
// sFlag := false ;
86955: LD_ADDR_EXP 128
86959: PUSH
86960: LD_INT 0
86962: ST_TO_ADDR
// sKamikadze := false ;
86963: LD_ADDR_EXP 136
86967: PUSH
86968: LD_INT 0
86970: ST_TO_ADDR
// sTroll := false ;
86971: LD_ADDR_EXP 137
86975: PUSH
86976: LD_INT 0
86978: ST_TO_ADDR
// sSlow := false ;
86979: LD_ADDR_EXP 138
86983: PUSH
86984: LD_INT 0
86986: ST_TO_ADDR
// sLack := false ;
86987: LD_ADDR_EXP 139
86991: PUSH
86992: LD_INT 0
86994: ST_TO_ADDR
// sTank := false ;
86995: LD_ADDR_EXP 141
86999: PUSH
87000: LD_INT 0
87002: ST_TO_ADDR
// sRemote := false ;
87003: LD_ADDR_EXP 142
87007: PUSH
87008: LD_INT 0
87010: ST_TO_ADDR
// sPowell := false ;
87011: LD_ADDR_EXP 143
87015: PUSH
87016: LD_INT 0
87018: ST_TO_ADDR
// sTeleport := false ;
87019: LD_ADDR_EXP 146
87023: PUSH
87024: LD_INT 0
87026: ST_TO_ADDR
// sOilTower := false ;
87027: LD_ADDR_EXP 148
87031: PUSH
87032: LD_INT 0
87034: ST_TO_ADDR
// sShovel := false ;
87035: LD_ADDR_EXP 149
87039: PUSH
87040: LD_INT 0
87042: ST_TO_ADDR
// sSheik := false ;
87043: LD_ADDR_EXP 150
87047: PUSH
87048: LD_INT 0
87050: ST_TO_ADDR
// sEarthquake := false ;
87051: LD_ADDR_EXP 152
87055: PUSH
87056: LD_INT 0
87058: ST_TO_ADDR
// sAI := false ;
87059: LD_ADDR_EXP 153
87063: PUSH
87064: LD_INT 0
87066: ST_TO_ADDR
// sCargo := false ;
87067: LD_ADDR_EXP 156
87071: PUSH
87072: LD_INT 0
87074: ST_TO_ADDR
// sDLaser := false ;
87075: LD_ADDR_EXP 157
87079: PUSH
87080: LD_INT 0
87082: ST_TO_ADDR
// sExchange := false ;
87083: LD_ADDR_EXP 158
87087: PUSH
87088: LD_INT 0
87090: ST_TO_ADDR
// sFac := false ;
87091: LD_ADDR_EXP 159
87095: PUSH
87096: LD_INT 0
87098: ST_TO_ADDR
// sPower := false ;
87099: LD_ADDR_EXP 160
87103: PUSH
87104: LD_INT 0
87106: ST_TO_ADDR
// sRandom := false ;
87107: LD_ADDR_EXP 161
87111: PUSH
87112: LD_INT 0
87114: ST_TO_ADDR
// sShield := false ;
87115: LD_ADDR_EXP 162
87119: PUSH
87120: LD_INT 0
87122: ST_TO_ADDR
// sTime := false ;
87123: LD_ADDR_EXP 163
87127: PUSH
87128: LD_INT 0
87130: ST_TO_ADDR
// sTools := false ;
87131: LD_ADDR_EXP 164
87135: PUSH
87136: LD_INT 0
87138: ST_TO_ADDR
// sSold := false ;
87139: LD_ADDR_EXP 129
87143: PUSH
87144: LD_INT 0
87146: ST_TO_ADDR
// sDiff := false ;
87147: LD_ADDR_EXP 130
87151: PUSH
87152: LD_INT 0
87154: ST_TO_ADDR
// sFog := false ;
87155: LD_ADDR_EXP 133
87159: PUSH
87160: LD_INT 0
87162: ST_TO_ADDR
// sReset := false ;
87163: LD_ADDR_EXP 134
87167: PUSH
87168: LD_INT 0
87170: ST_TO_ADDR
// sSun := false ;
87171: LD_ADDR_EXP 135
87175: PUSH
87176: LD_INT 0
87178: ST_TO_ADDR
// sTiger := false ;
87179: LD_ADDR_EXP 131
87183: PUSH
87184: LD_INT 0
87186: ST_TO_ADDR
// sBomb := false ;
87187: LD_ADDR_EXP 132
87191: PUSH
87192: LD_INT 0
87194: ST_TO_ADDR
// sWound := false ;
87195: LD_ADDR_EXP 140
87199: PUSH
87200: LD_INT 0
87202: ST_TO_ADDR
// sBetray := false ;
87203: LD_ADDR_EXP 144
87207: PUSH
87208: LD_INT 0
87210: ST_TO_ADDR
// sContamin := false ;
87211: LD_ADDR_EXP 145
87215: PUSH
87216: LD_INT 0
87218: ST_TO_ADDR
// sOil := false ;
87219: LD_ADDR_EXP 147
87223: PUSH
87224: LD_INT 0
87226: ST_TO_ADDR
// sStu := false ;
87227: LD_ADDR_EXP 151
87231: PUSH
87232: LD_INT 0
87234: ST_TO_ADDR
// sBazooka := false ;
87235: LD_ADDR_EXP 154
87239: PUSH
87240: LD_INT 0
87242: ST_TO_ADDR
// sMortar := false ;
87243: LD_ADDR_EXP 155
87247: PUSH
87248: LD_INT 0
87250: ST_TO_ADDR
// sRanger := false ;
87251: LD_ADDR_EXP 165
87255: PUSH
87256: LD_INT 0
87258: ST_TO_ADDR
// sComputer := false ;
87259: LD_ADDR_EXP 166
87263: PUSH
87264: LD_INT 0
87266: ST_TO_ADDR
// s30 := false ;
87267: LD_ADDR_EXP 167
87271: PUSH
87272: LD_INT 0
87274: ST_TO_ADDR
// s60 := false ;
87275: LD_ADDR_EXP 168
87279: PUSH
87280: LD_INT 0
87282: ST_TO_ADDR
// end ;
87283: LD_VAR 0 1
87287: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87288: LD_INT 0
87290: PPUSH
87291: PPUSH
87292: PPUSH
87293: PPUSH
87294: PPUSH
87295: PPUSH
87296: PPUSH
// result := [ ] ;
87297: LD_ADDR_VAR 0 2
87301: PUSH
87302: EMPTY
87303: ST_TO_ADDR
// if campaign_id = 1 then
87304: LD_OWVAR 69
87308: PUSH
87309: LD_INT 1
87311: EQUAL
87312: IFFALSE 90478
// begin case mission_number of 1 :
87314: LD_OWVAR 70
87318: PUSH
87319: LD_INT 1
87321: DOUBLE
87322: EQUAL
87323: IFTRUE 87327
87325: GO 87403
87327: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87328: LD_ADDR_VAR 0 2
87332: PUSH
87333: LD_INT 2
87335: PUSH
87336: LD_INT 4
87338: PUSH
87339: LD_INT 11
87341: PUSH
87342: LD_INT 12
87344: PUSH
87345: LD_INT 15
87347: PUSH
87348: LD_INT 16
87350: PUSH
87351: LD_INT 22
87353: PUSH
87354: LD_INT 23
87356: PUSH
87357: LD_INT 26
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 101
87373: PUSH
87374: LD_INT 102
87376: PUSH
87377: LD_INT 106
87379: PUSH
87380: LD_INT 116
87382: PUSH
87383: LD_INT 117
87385: PUSH
87386: LD_INT 118
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: ST_TO_ADDR
87401: GO 90476
87403: LD_INT 2
87405: DOUBLE
87406: EQUAL
87407: IFTRUE 87411
87409: GO 87495
87411: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87412: LD_ADDR_VAR 0 2
87416: PUSH
87417: LD_INT 2
87419: PUSH
87420: LD_INT 4
87422: PUSH
87423: LD_INT 11
87425: PUSH
87426: LD_INT 12
87428: PUSH
87429: LD_INT 15
87431: PUSH
87432: LD_INT 16
87434: PUSH
87435: LD_INT 22
87437: PUSH
87438: LD_INT 23
87440: PUSH
87441: LD_INT 26
87443: PUSH
87444: EMPTY
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 101
87457: PUSH
87458: LD_INT 102
87460: PUSH
87461: LD_INT 105
87463: PUSH
87464: LD_INT 106
87466: PUSH
87467: LD_INT 108
87469: PUSH
87470: LD_INT 116
87472: PUSH
87473: LD_INT 117
87475: PUSH
87476: LD_INT 118
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: ST_TO_ADDR
87493: GO 90476
87495: LD_INT 3
87497: DOUBLE
87498: EQUAL
87499: IFTRUE 87503
87501: GO 87591
87503: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87504: LD_ADDR_VAR 0 2
87508: PUSH
87509: LD_INT 2
87511: PUSH
87512: LD_INT 4
87514: PUSH
87515: LD_INT 5
87517: PUSH
87518: LD_INT 11
87520: PUSH
87521: LD_INT 12
87523: PUSH
87524: LD_INT 15
87526: PUSH
87527: LD_INT 16
87529: PUSH
87530: LD_INT 22
87532: PUSH
87533: LD_INT 26
87535: PUSH
87536: LD_INT 36
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 101
87553: PUSH
87554: LD_INT 102
87556: PUSH
87557: LD_INT 105
87559: PUSH
87560: LD_INT 106
87562: PUSH
87563: LD_INT 108
87565: PUSH
87566: LD_INT 116
87568: PUSH
87569: LD_INT 117
87571: PUSH
87572: LD_INT 118
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: ST_TO_ADDR
87589: GO 90476
87591: LD_INT 4
87593: DOUBLE
87594: EQUAL
87595: IFTRUE 87599
87597: GO 87695
87599: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87600: LD_ADDR_VAR 0 2
87604: PUSH
87605: LD_INT 2
87607: PUSH
87608: LD_INT 4
87610: PUSH
87611: LD_INT 5
87613: PUSH
87614: LD_INT 8
87616: PUSH
87617: LD_INT 11
87619: PUSH
87620: LD_INT 12
87622: PUSH
87623: LD_INT 15
87625: PUSH
87626: LD_INT 16
87628: PUSH
87629: LD_INT 22
87631: PUSH
87632: LD_INT 23
87634: PUSH
87635: LD_INT 26
87637: PUSH
87638: LD_INT 36
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: LIST
87645: LIST
87646: LIST
87647: LIST
87648: LIST
87649: LIST
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 101
87657: PUSH
87658: LD_INT 102
87660: PUSH
87661: LD_INT 105
87663: PUSH
87664: LD_INT 106
87666: PUSH
87667: LD_INT 108
87669: PUSH
87670: LD_INT 116
87672: PUSH
87673: LD_INT 117
87675: PUSH
87676: LD_INT 118
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: ST_TO_ADDR
87693: GO 90476
87695: LD_INT 5
87697: DOUBLE
87698: EQUAL
87699: IFTRUE 87703
87701: GO 87815
87703: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87704: LD_ADDR_VAR 0 2
87708: PUSH
87709: LD_INT 2
87711: PUSH
87712: LD_INT 4
87714: PUSH
87715: LD_INT 5
87717: PUSH
87718: LD_INT 6
87720: PUSH
87721: LD_INT 8
87723: PUSH
87724: LD_INT 11
87726: PUSH
87727: LD_INT 12
87729: PUSH
87730: LD_INT 15
87732: PUSH
87733: LD_INT 16
87735: PUSH
87736: LD_INT 22
87738: PUSH
87739: LD_INT 23
87741: PUSH
87742: LD_INT 25
87744: PUSH
87745: LD_INT 26
87747: PUSH
87748: LD_INT 36
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 101
87769: PUSH
87770: LD_INT 102
87772: PUSH
87773: LD_INT 105
87775: PUSH
87776: LD_INT 106
87778: PUSH
87779: LD_INT 108
87781: PUSH
87782: LD_INT 109
87784: PUSH
87785: LD_INT 112
87787: PUSH
87788: LD_INT 116
87790: PUSH
87791: LD_INT 117
87793: PUSH
87794: LD_INT 118
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: ST_TO_ADDR
87813: GO 90476
87815: LD_INT 6
87817: DOUBLE
87818: EQUAL
87819: IFTRUE 87823
87821: GO 87955
87823: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
87824: LD_ADDR_VAR 0 2
87828: PUSH
87829: LD_INT 2
87831: PUSH
87832: LD_INT 4
87834: PUSH
87835: LD_INT 5
87837: PUSH
87838: LD_INT 6
87840: PUSH
87841: LD_INT 8
87843: PUSH
87844: LD_INT 11
87846: PUSH
87847: LD_INT 12
87849: PUSH
87850: LD_INT 15
87852: PUSH
87853: LD_INT 16
87855: PUSH
87856: LD_INT 20
87858: PUSH
87859: LD_INT 21
87861: PUSH
87862: LD_INT 22
87864: PUSH
87865: LD_INT 23
87867: PUSH
87868: LD_INT 25
87870: PUSH
87871: LD_INT 26
87873: PUSH
87874: LD_INT 30
87876: PUSH
87877: LD_INT 31
87879: PUSH
87880: LD_INT 32
87882: PUSH
87883: LD_INT 36
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 101
87909: PUSH
87910: LD_INT 102
87912: PUSH
87913: LD_INT 105
87915: PUSH
87916: LD_INT 106
87918: PUSH
87919: LD_INT 108
87921: PUSH
87922: LD_INT 109
87924: PUSH
87925: LD_INT 112
87927: PUSH
87928: LD_INT 116
87930: PUSH
87931: LD_INT 117
87933: PUSH
87934: LD_INT 118
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: LIST
87943: LIST
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: ST_TO_ADDR
87953: GO 90476
87955: LD_INT 7
87957: DOUBLE
87958: EQUAL
87959: IFTRUE 87963
87961: GO 88075
87963: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
87964: LD_ADDR_VAR 0 2
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: LD_INT 4
87974: PUSH
87975: LD_INT 5
87977: PUSH
87978: LD_INT 7
87980: PUSH
87981: LD_INT 11
87983: PUSH
87984: LD_INT 12
87986: PUSH
87987: LD_INT 15
87989: PUSH
87990: LD_INT 16
87992: PUSH
87993: LD_INT 20
87995: PUSH
87996: LD_INT 21
87998: PUSH
87999: LD_INT 22
88001: PUSH
88002: LD_INT 23
88004: PUSH
88005: LD_INT 25
88007: PUSH
88008: LD_INT 26
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 101
88029: PUSH
88030: LD_INT 102
88032: PUSH
88033: LD_INT 103
88035: PUSH
88036: LD_INT 105
88038: PUSH
88039: LD_INT 106
88041: PUSH
88042: LD_INT 108
88044: PUSH
88045: LD_INT 112
88047: PUSH
88048: LD_INT 116
88050: PUSH
88051: LD_INT 117
88053: PUSH
88054: LD_INT 118
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: ST_TO_ADDR
88073: GO 90476
88075: LD_INT 8
88077: DOUBLE
88078: EQUAL
88079: IFTRUE 88083
88081: GO 88223
88083: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88084: LD_ADDR_VAR 0 2
88088: PUSH
88089: LD_INT 2
88091: PUSH
88092: LD_INT 4
88094: PUSH
88095: LD_INT 5
88097: PUSH
88098: LD_INT 6
88100: PUSH
88101: LD_INT 7
88103: PUSH
88104: LD_INT 8
88106: PUSH
88107: LD_INT 11
88109: PUSH
88110: LD_INT 12
88112: PUSH
88113: LD_INT 15
88115: PUSH
88116: LD_INT 16
88118: PUSH
88119: LD_INT 20
88121: PUSH
88122: LD_INT 21
88124: PUSH
88125: LD_INT 22
88127: PUSH
88128: LD_INT 23
88130: PUSH
88131: LD_INT 25
88133: PUSH
88134: LD_INT 26
88136: PUSH
88137: LD_INT 30
88139: PUSH
88140: LD_INT 31
88142: PUSH
88143: LD_INT 32
88145: PUSH
88146: LD_INT 36
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 101
88173: PUSH
88174: LD_INT 102
88176: PUSH
88177: LD_INT 103
88179: PUSH
88180: LD_INT 105
88182: PUSH
88183: LD_INT 106
88185: PUSH
88186: LD_INT 108
88188: PUSH
88189: LD_INT 109
88191: PUSH
88192: LD_INT 112
88194: PUSH
88195: LD_INT 116
88197: PUSH
88198: LD_INT 117
88200: PUSH
88201: LD_INT 118
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: ST_TO_ADDR
88221: GO 90476
88223: LD_INT 9
88225: DOUBLE
88226: EQUAL
88227: IFTRUE 88231
88229: GO 88379
88231: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88232: LD_ADDR_VAR 0 2
88236: PUSH
88237: LD_INT 2
88239: PUSH
88240: LD_INT 4
88242: PUSH
88243: LD_INT 5
88245: PUSH
88246: LD_INT 6
88248: PUSH
88249: LD_INT 7
88251: PUSH
88252: LD_INT 8
88254: PUSH
88255: LD_INT 11
88257: PUSH
88258: LD_INT 12
88260: PUSH
88261: LD_INT 15
88263: PUSH
88264: LD_INT 16
88266: PUSH
88267: LD_INT 20
88269: PUSH
88270: LD_INT 21
88272: PUSH
88273: LD_INT 22
88275: PUSH
88276: LD_INT 23
88278: PUSH
88279: LD_INT 25
88281: PUSH
88282: LD_INT 26
88284: PUSH
88285: LD_INT 28
88287: PUSH
88288: LD_INT 30
88290: PUSH
88291: LD_INT 31
88293: PUSH
88294: LD_INT 32
88296: PUSH
88297: LD_INT 36
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 101
88325: PUSH
88326: LD_INT 102
88328: PUSH
88329: LD_INT 103
88331: PUSH
88332: LD_INT 105
88334: PUSH
88335: LD_INT 106
88337: PUSH
88338: LD_INT 108
88340: PUSH
88341: LD_INT 109
88343: PUSH
88344: LD_INT 112
88346: PUSH
88347: LD_INT 114
88349: PUSH
88350: LD_INT 116
88352: PUSH
88353: LD_INT 117
88355: PUSH
88356: LD_INT 118
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: ST_TO_ADDR
88377: GO 90476
88379: LD_INT 10
88381: DOUBLE
88382: EQUAL
88383: IFTRUE 88387
88385: GO 88583
88387: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88388: LD_ADDR_VAR 0 2
88392: PUSH
88393: LD_INT 2
88395: PUSH
88396: LD_INT 4
88398: PUSH
88399: LD_INT 5
88401: PUSH
88402: LD_INT 6
88404: PUSH
88405: LD_INT 7
88407: PUSH
88408: LD_INT 8
88410: PUSH
88411: LD_INT 9
88413: PUSH
88414: LD_INT 10
88416: PUSH
88417: LD_INT 11
88419: PUSH
88420: LD_INT 12
88422: PUSH
88423: LD_INT 13
88425: PUSH
88426: LD_INT 14
88428: PUSH
88429: LD_INT 15
88431: PUSH
88432: LD_INT 16
88434: PUSH
88435: LD_INT 17
88437: PUSH
88438: LD_INT 18
88440: PUSH
88441: LD_INT 19
88443: PUSH
88444: LD_INT 20
88446: PUSH
88447: LD_INT 21
88449: PUSH
88450: LD_INT 22
88452: PUSH
88453: LD_INT 23
88455: PUSH
88456: LD_INT 24
88458: PUSH
88459: LD_INT 25
88461: PUSH
88462: LD_INT 26
88464: PUSH
88465: LD_INT 28
88467: PUSH
88468: LD_INT 30
88470: PUSH
88471: LD_INT 31
88473: PUSH
88474: LD_INT 32
88476: PUSH
88477: LD_INT 36
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 101
88513: PUSH
88514: LD_INT 102
88516: PUSH
88517: LD_INT 103
88519: PUSH
88520: LD_INT 104
88522: PUSH
88523: LD_INT 105
88525: PUSH
88526: LD_INT 106
88528: PUSH
88529: LD_INT 107
88531: PUSH
88532: LD_INT 108
88534: PUSH
88535: LD_INT 109
88537: PUSH
88538: LD_INT 110
88540: PUSH
88541: LD_INT 111
88543: PUSH
88544: LD_INT 112
88546: PUSH
88547: LD_INT 114
88549: PUSH
88550: LD_INT 116
88552: PUSH
88553: LD_INT 117
88555: PUSH
88556: LD_INT 118
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: ST_TO_ADDR
88581: GO 90476
88583: LD_INT 11
88585: DOUBLE
88586: EQUAL
88587: IFTRUE 88591
88589: GO 88795
88591: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88592: LD_ADDR_VAR 0 2
88596: PUSH
88597: LD_INT 2
88599: PUSH
88600: LD_INT 3
88602: PUSH
88603: LD_INT 4
88605: PUSH
88606: LD_INT 5
88608: PUSH
88609: LD_INT 6
88611: PUSH
88612: LD_INT 7
88614: PUSH
88615: LD_INT 8
88617: PUSH
88618: LD_INT 9
88620: PUSH
88621: LD_INT 10
88623: PUSH
88624: LD_INT 11
88626: PUSH
88627: LD_INT 12
88629: PUSH
88630: LD_INT 13
88632: PUSH
88633: LD_INT 14
88635: PUSH
88636: LD_INT 15
88638: PUSH
88639: LD_INT 16
88641: PUSH
88642: LD_INT 17
88644: PUSH
88645: LD_INT 18
88647: PUSH
88648: LD_INT 19
88650: PUSH
88651: LD_INT 20
88653: PUSH
88654: LD_INT 21
88656: PUSH
88657: LD_INT 22
88659: PUSH
88660: LD_INT 23
88662: PUSH
88663: LD_INT 24
88665: PUSH
88666: LD_INT 25
88668: PUSH
88669: LD_INT 26
88671: PUSH
88672: LD_INT 28
88674: PUSH
88675: LD_INT 30
88677: PUSH
88678: LD_INT 31
88680: PUSH
88681: LD_INT 32
88683: PUSH
88684: LD_INT 34
88686: PUSH
88687: LD_INT 36
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 101
88725: PUSH
88726: LD_INT 102
88728: PUSH
88729: LD_INT 103
88731: PUSH
88732: LD_INT 104
88734: PUSH
88735: LD_INT 105
88737: PUSH
88738: LD_INT 106
88740: PUSH
88741: LD_INT 107
88743: PUSH
88744: LD_INT 108
88746: PUSH
88747: LD_INT 109
88749: PUSH
88750: LD_INT 110
88752: PUSH
88753: LD_INT 111
88755: PUSH
88756: LD_INT 112
88758: PUSH
88759: LD_INT 114
88761: PUSH
88762: LD_INT 116
88764: PUSH
88765: LD_INT 117
88767: PUSH
88768: LD_INT 118
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: ST_TO_ADDR
88793: GO 90476
88795: LD_INT 12
88797: DOUBLE
88798: EQUAL
88799: IFTRUE 88803
88801: GO 89023
88803: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
88804: LD_ADDR_VAR 0 2
88808: PUSH
88809: LD_INT 1
88811: PUSH
88812: LD_INT 2
88814: PUSH
88815: LD_INT 3
88817: PUSH
88818: LD_INT 4
88820: PUSH
88821: LD_INT 5
88823: PUSH
88824: LD_INT 6
88826: PUSH
88827: LD_INT 7
88829: PUSH
88830: LD_INT 8
88832: PUSH
88833: LD_INT 9
88835: PUSH
88836: LD_INT 10
88838: PUSH
88839: LD_INT 11
88841: PUSH
88842: LD_INT 12
88844: PUSH
88845: LD_INT 13
88847: PUSH
88848: LD_INT 14
88850: PUSH
88851: LD_INT 15
88853: PUSH
88854: LD_INT 16
88856: PUSH
88857: LD_INT 17
88859: PUSH
88860: LD_INT 18
88862: PUSH
88863: LD_INT 19
88865: PUSH
88866: LD_INT 20
88868: PUSH
88869: LD_INT 21
88871: PUSH
88872: LD_INT 22
88874: PUSH
88875: LD_INT 23
88877: PUSH
88878: LD_INT 24
88880: PUSH
88881: LD_INT 25
88883: PUSH
88884: LD_INT 26
88886: PUSH
88887: LD_INT 27
88889: PUSH
88890: LD_INT 28
88892: PUSH
88893: LD_INT 30
88895: PUSH
88896: LD_INT 31
88898: PUSH
88899: LD_INT 32
88901: PUSH
88902: LD_INT 33
88904: PUSH
88905: LD_INT 34
88907: PUSH
88908: LD_INT 36
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 101
88949: PUSH
88950: LD_INT 102
88952: PUSH
88953: LD_INT 103
88955: PUSH
88956: LD_INT 104
88958: PUSH
88959: LD_INT 105
88961: PUSH
88962: LD_INT 106
88964: PUSH
88965: LD_INT 107
88967: PUSH
88968: LD_INT 108
88970: PUSH
88971: LD_INT 109
88973: PUSH
88974: LD_INT 110
88976: PUSH
88977: LD_INT 111
88979: PUSH
88980: LD_INT 112
88982: PUSH
88983: LD_INT 113
88985: PUSH
88986: LD_INT 114
88988: PUSH
88989: LD_INT 116
88991: PUSH
88992: LD_INT 117
88994: PUSH
88995: LD_INT 118
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: ST_TO_ADDR
89021: GO 90476
89023: LD_INT 13
89025: DOUBLE
89026: EQUAL
89027: IFTRUE 89031
89029: GO 89239
89031: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89032: LD_ADDR_VAR 0 2
89036: PUSH
89037: LD_INT 1
89039: PUSH
89040: LD_INT 2
89042: PUSH
89043: LD_INT 3
89045: PUSH
89046: LD_INT 4
89048: PUSH
89049: LD_INT 5
89051: PUSH
89052: LD_INT 8
89054: PUSH
89055: LD_INT 9
89057: PUSH
89058: LD_INT 10
89060: PUSH
89061: LD_INT 11
89063: PUSH
89064: LD_INT 12
89066: PUSH
89067: LD_INT 14
89069: PUSH
89070: LD_INT 15
89072: PUSH
89073: LD_INT 16
89075: PUSH
89076: LD_INT 17
89078: PUSH
89079: LD_INT 18
89081: PUSH
89082: LD_INT 19
89084: PUSH
89085: LD_INT 20
89087: PUSH
89088: LD_INT 21
89090: PUSH
89091: LD_INT 22
89093: PUSH
89094: LD_INT 23
89096: PUSH
89097: LD_INT 24
89099: PUSH
89100: LD_INT 25
89102: PUSH
89103: LD_INT 26
89105: PUSH
89106: LD_INT 27
89108: PUSH
89109: LD_INT 28
89111: PUSH
89112: LD_INT 30
89114: PUSH
89115: LD_INT 31
89117: PUSH
89118: LD_INT 32
89120: PUSH
89121: LD_INT 33
89123: PUSH
89124: LD_INT 34
89126: PUSH
89127: LD_INT 36
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 101
89165: PUSH
89166: LD_INT 102
89168: PUSH
89169: LD_INT 103
89171: PUSH
89172: LD_INT 104
89174: PUSH
89175: LD_INT 105
89177: PUSH
89178: LD_INT 106
89180: PUSH
89181: LD_INT 107
89183: PUSH
89184: LD_INT 108
89186: PUSH
89187: LD_INT 109
89189: PUSH
89190: LD_INT 110
89192: PUSH
89193: LD_INT 111
89195: PUSH
89196: LD_INT 112
89198: PUSH
89199: LD_INT 113
89201: PUSH
89202: LD_INT 114
89204: PUSH
89205: LD_INT 116
89207: PUSH
89208: LD_INT 117
89210: PUSH
89211: LD_INT 118
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: ST_TO_ADDR
89237: GO 90476
89239: LD_INT 14
89241: DOUBLE
89242: EQUAL
89243: IFTRUE 89247
89245: GO 89471
89247: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89248: LD_ADDR_VAR 0 2
89252: PUSH
89253: LD_INT 1
89255: PUSH
89256: LD_INT 2
89258: PUSH
89259: LD_INT 3
89261: PUSH
89262: LD_INT 4
89264: PUSH
89265: LD_INT 5
89267: PUSH
89268: LD_INT 6
89270: PUSH
89271: LD_INT 7
89273: PUSH
89274: LD_INT 8
89276: PUSH
89277: LD_INT 9
89279: PUSH
89280: LD_INT 10
89282: PUSH
89283: LD_INT 11
89285: PUSH
89286: LD_INT 12
89288: PUSH
89289: LD_INT 13
89291: PUSH
89292: LD_INT 14
89294: PUSH
89295: LD_INT 15
89297: PUSH
89298: LD_INT 16
89300: PUSH
89301: LD_INT 17
89303: PUSH
89304: LD_INT 18
89306: PUSH
89307: LD_INT 19
89309: PUSH
89310: LD_INT 20
89312: PUSH
89313: LD_INT 21
89315: PUSH
89316: LD_INT 22
89318: PUSH
89319: LD_INT 23
89321: PUSH
89322: LD_INT 24
89324: PUSH
89325: LD_INT 25
89327: PUSH
89328: LD_INT 26
89330: PUSH
89331: LD_INT 27
89333: PUSH
89334: LD_INT 28
89336: PUSH
89337: LD_INT 29
89339: PUSH
89340: LD_INT 30
89342: PUSH
89343: LD_INT 31
89345: PUSH
89346: LD_INT 32
89348: PUSH
89349: LD_INT 33
89351: PUSH
89352: LD_INT 34
89354: PUSH
89355: LD_INT 36
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 101
89397: PUSH
89398: LD_INT 102
89400: PUSH
89401: LD_INT 103
89403: PUSH
89404: LD_INT 104
89406: PUSH
89407: LD_INT 105
89409: PUSH
89410: LD_INT 106
89412: PUSH
89413: LD_INT 107
89415: PUSH
89416: LD_INT 108
89418: PUSH
89419: LD_INT 109
89421: PUSH
89422: LD_INT 110
89424: PUSH
89425: LD_INT 111
89427: PUSH
89428: LD_INT 112
89430: PUSH
89431: LD_INT 113
89433: PUSH
89434: LD_INT 114
89436: PUSH
89437: LD_INT 116
89439: PUSH
89440: LD_INT 117
89442: PUSH
89443: LD_INT 118
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: ST_TO_ADDR
89469: GO 90476
89471: LD_INT 15
89473: DOUBLE
89474: EQUAL
89475: IFTRUE 89479
89477: GO 89703
89479: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89480: LD_ADDR_VAR 0 2
89484: PUSH
89485: LD_INT 1
89487: PUSH
89488: LD_INT 2
89490: PUSH
89491: LD_INT 3
89493: PUSH
89494: LD_INT 4
89496: PUSH
89497: LD_INT 5
89499: PUSH
89500: LD_INT 6
89502: PUSH
89503: LD_INT 7
89505: PUSH
89506: LD_INT 8
89508: PUSH
89509: LD_INT 9
89511: PUSH
89512: LD_INT 10
89514: PUSH
89515: LD_INT 11
89517: PUSH
89518: LD_INT 12
89520: PUSH
89521: LD_INT 13
89523: PUSH
89524: LD_INT 14
89526: PUSH
89527: LD_INT 15
89529: PUSH
89530: LD_INT 16
89532: PUSH
89533: LD_INT 17
89535: PUSH
89536: LD_INT 18
89538: PUSH
89539: LD_INT 19
89541: PUSH
89542: LD_INT 20
89544: PUSH
89545: LD_INT 21
89547: PUSH
89548: LD_INT 22
89550: PUSH
89551: LD_INT 23
89553: PUSH
89554: LD_INT 24
89556: PUSH
89557: LD_INT 25
89559: PUSH
89560: LD_INT 26
89562: PUSH
89563: LD_INT 27
89565: PUSH
89566: LD_INT 28
89568: PUSH
89569: LD_INT 29
89571: PUSH
89572: LD_INT 30
89574: PUSH
89575: LD_INT 31
89577: PUSH
89578: LD_INT 32
89580: PUSH
89581: LD_INT 33
89583: PUSH
89584: LD_INT 34
89586: PUSH
89587: LD_INT 36
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 101
89629: PUSH
89630: LD_INT 102
89632: PUSH
89633: LD_INT 103
89635: PUSH
89636: LD_INT 104
89638: PUSH
89639: LD_INT 105
89641: PUSH
89642: LD_INT 106
89644: PUSH
89645: LD_INT 107
89647: PUSH
89648: LD_INT 108
89650: PUSH
89651: LD_INT 109
89653: PUSH
89654: LD_INT 110
89656: PUSH
89657: LD_INT 111
89659: PUSH
89660: LD_INT 112
89662: PUSH
89663: LD_INT 113
89665: PUSH
89666: LD_INT 114
89668: PUSH
89669: LD_INT 116
89671: PUSH
89672: LD_INT 117
89674: PUSH
89675: LD_INT 118
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: ST_TO_ADDR
89701: GO 90476
89703: LD_INT 16
89705: DOUBLE
89706: EQUAL
89707: IFTRUE 89711
89709: GO 89847
89711: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89712: LD_ADDR_VAR 0 2
89716: PUSH
89717: LD_INT 2
89719: PUSH
89720: LD_INT 4
89722: PUSH
89723: LD_INT 5
89725: PUSH
89726: LD_INT 7
89728: PUSH
89729: LD_INT 11
89731: PUSH
89732: LD_INT 12
89734: PUSH
89735: LD_INT 15
89737: PUSH
89738: LD_INT 16
89740: PUSH
89741: LD_INT 20
89743: PUSH
89744: LD_INT 21
89746: PUSH
89747: LD_INT 22
89749: PUSH
89750: LD_INT 23
89752: PUSH
89753: LD_INT 25
89755: PUSH
89756: LD_INT 26
89758: PUSH
89759: LD_INT 30
89761: PUSH
89762: LD_INT 31
89764: PUSH
89765: LD_INT 32
89767: PUSH
89768: LD_INT 33
89770: PUSH
89771: LD_INT 34
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 101
89797: PUSH
89798: LD_INT 102
89800: PUSH
89801: LD_INT 103
89803: PUSH
89804: LD_INT 106
89806: PUSH
89807: LD_INT 108
89809: PUSH
89810: LD_INT 112
89812: PUSH
89813: LD_INT 113
89815: PUSH
89816: LD_INT 114
89818: PUSH
89819: LD_INT 116
89821: PUSH
89822: LD_INT 117
89824: PUSH
89825: LD_INT 118
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: ST_TO_ADDR
89845: GO 90476
89847: LD_INT 17
89849: DOUBLE
89850: EQUAL
89851: IFTRUE 89855
89853: GO 90079
89855: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
89856: LD_ADDR_VAR 0 2
89860: PUSH
89861: LD_INT 1
89863: PUSH
89864: LD_INT 2
89866: PUSH
89867: LD_INT 3
89869: PUSH
89870: LD_INT 4
89872: PUSH
89873: LD_INT 5
89875: PUSH
89876: LD_INT 6
89878: PUSH
89879: LD_INT 7
89881: PUSH
89882: LD_INT 8
89884: PUSH
89885: LD_INT 9
89887: PUSH
89888: LD_INT 10
89890: PUSH
89891: LD_INT 11
89893: PUSH
89894: LD_INT 12
89896: PUSH
89897: LD_INT 13
89899: PUSH
89900: LD_INT 14
89902: PUSH
89903: LD_INT 15
89905: PUSH
89906: LD_INT 16
89908: PUSH
89909: LD_INT 17
89911: PUSH
89912: LD_INT 18
89914: PUSH
89915: LD_INT 19
89917: PUSH
89918: LD_INT 20
89920: PUSH
89921: LD_INT 21
89923: PUSH
89924: LD_INT 22
89926: PUSH
89927: LD_INT 23
89929: PUSH
89930: LD_INT 24
89932: PUSH
89933: LD_INT 25
89935: PUSH
89936: LD_INT 26
89938: PUSH
89939: LD_INT 27
89941: PUSH
89942: LD_INT 28
89944: PUSH
89945: LD_INT 29
89947: PUSH
89948: LD_INT 30
89950: PUSH
89951: LD_INT 31
89953: PUSH
89954: LD_INT 32
89956: PUSH
89957: LD_INT 33
89959: PUSH
89960: LD_INT 34
89962: PUSH
89963: LD_INT 36
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 101
90005: PUSH
90006: LD_INT 102
90008: PUSH
90009: LD_INT 103
90011: PUSH
90012: LD_INT 104
90014: PUSH
90015: LD_INT 105
90017: PUSH
90018: LD_INT 106
90020: PUSH
90021: LD_INT 107
90023: PUSH
90024: LD_INT 108
90026: PUSH
90027: LD_INT 109
90029: PUSH
90030: LD_INT 110
90032: PUSH
90033: LD_INT 111
90035: PUSH
90036: LD_INT 112
90038: PUSH
90039: LD_INT 113
90041: PUSH
90042: LD_INT 114
90044: PUSH
90045: LD_INT 116
90047: PUSH
90048: LD_INT 117
90050: PUSH
90051: LD_INT 118
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: ST_TO_ADDR
90077: GO 90476
90079: LD_INT 18
90081: DOUBLE
90082: EQUAL
90083: IFTRUE 90087
90085: GO 90235
90087: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90088: LD_ADDR_VAR 0 2
90092: PUSH
90093: LD_INT 2
90095: PUSH
90096: LD_INT 4
90098: PUSH
90099: LD_INT 5
90101: PUSH
90102: LD_INT 7
90104: PUSH
90105: LD_INT 11
90107: PUSH
90108: LD_INT 12
90110: PUSH
90111: LD_INT 15
90113: PUSH
90114: LD_INT 16
90116: PUSH
90117: LD_INT 20
90119: PUSH
90120: LD_INT 21
90122: PUSH
90123: LD_INT 22
90125: PUSH
90126: LD_INT 23
90128: PUSH
90129: LD_INT 25
90131: PUSH
90132: LD_INT 26
90134: PUSH
90135: LD_INT 30
90137: PUSH
90138: LD_INT 31
90140: PUSH
90141: LD_INT 32
90143: PUSH
90144: LD_INT 33
90146: PUSH
90147: LD_INT 34
90149: PUSH
90150: LD_INT 35
90152: PUSH
90153: LD_INT 36
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 101
90181: PUSH
90182: LD_INT 102
90184: PUSH
90185: LD_INT 103
90187: PUSH
90188: LD_INT 106
90190: PUSH
90191: LD_INT 108
90193: PUSH
90194: LD_INT 112
90196: PUSH
90197: LD_INT 113
90199: PUSH
90200: LD_INT 114
90202: PUSH
90203: LD_INT 115
90205: PUSH
90206: LD_INT 116
90208: PUSH
90209: LD_INT 117
90211: PUSH
90212: LD_INT 118
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: ST_TO_ADDR
90233: GO 90476
90235: LD_INT 19
90237: DOUBLE
90238: EQUAL
90239: IFTRUE 90243
90241: GO 90475
90243: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90244: LD_ADDR_VAR 0 2
90248: PUSH
90249: LD_INT 1
90251: PUSH
90252: LD_INT 2
90254: PUSH
90255: LD_INT 3
90257: PUSH
90258: LD_INT 4
90260: PUSH
90261: LD_INT 5
90263: PUSH
90264: LD_INT 6
90266: PUSH
90267: LD_INT 7
90269: PUSH
90270: LD_INT 8
90272: PUSH
90273: LD_INT 9
90275: PUSH
90276: LD_INT 10
90278: PUSH
90279: LD_INT 11
90281: PUSH
90282: LD_INT 12
90284: PUSH
90285: LD_INT 13
90287: PUSH
90288: LD_INT 14
90290: PUSH
90291: LD_INT 15
90293: PUSH
90294: LD_INT 16
90296: PUSH
90297: LD_INT 17
90299: PUSH
90300: LD_INT 18
90302: PUSH
90303: LD_INT 19
90305: PUSH
90306: LD_INT 20
90308: PUSH
90309: LD_INT 21
90311: PUSH
90312: LD_INT 22
90314: PUSH
90315: LD_INT 23
90317: PUSH
90318: LD_INT 24
90320: PUSH
90321: LD_INT 25
90323: PUSH
90324: LD_INT 26
90326: PUSH
90327: LD_INT 27
90329: PUSH
90330: LD_INT 28
90332: PUSH
90333: LD_INT 29
90335: PUSH
90336: LD_INT 30
90338: PUSH
90339: LD_INT 31
90341: PUSH
90342: LD_INT 32
90344: PUSH
90345: LD_INT 33
90347: PUSH
90348: LD_INT 34
90350: PUSH
90351: LD_INT 35
90353: PUSH
90354: LD_INT 36
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 101
90397: PUSH
90398: LD_INT 102
90400: PUSH
90401: LD_INT 103
90403: PUSH
90404: LD_INT 104
90406: PUSH
90407: LD_INT 105
90409: PUSH
90410: LD_INT 106
90412: PUSH
90413: LD_INT 107
90415: PUSH
90416: LD_INT 108
90418: PUSH
90419: LD_INT 109
90421: PUSH
90422: LD_INT 110
90424: PUSH
90425: LD_INT 111
90427: PUSH
90428: LD_INT 112
90430: PUSH
90431: LD_INT 113
90433: PUSH
90434: LD_INT 114
90436: PUSH
90437: LD_INT 115
90439: PUSH
90440: LD_INT 116
90442: PUSH
90443: LD_INT 117
90445: PUSH
90446: LD_INT 118
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: ST_TO_ADDR
90473: GO 90476
90475: POP
// end else
90476: GO 90707
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90478: LD_ADDR_VAR 0 2
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: LD_INT 3
90491: PUSH
90492: LD_INT 4
90494: PUSH
90495: LD_INT 5
90497: PUSH
90498: LD_INT 6
90500: PUSH
90501: LD_INT 7
90503: PUSH
90504: LD_INT 8
90506: PUSH
90507: LD_INT 9
90509: PUSH
90510: LD_INT 10
90512: PUSH
90513: LD_INT 11
90515: PUSH
90516: LD_INT 12
90518: PUSH
90519: LD_INT 13
90521: PUSH
90522: LD_INT 14
90524: PUSH
90525: LD_INT 15
90527: PUSH
90528: LD_INT 16
90530: PUSH
90531: LD_INT 17
90533: PUSH
90534: LD_INT 18
90536: PUSH
90537: LD_INT 19
90539: PUSH
90540: LD_INT 20
90542: PUSH
90543: LD_INT 21
90545: PUSH
90546: LD_INT 22
90548: PUSH
90549: LD_INT 23
90551: PUSH
90552: LD_INT 24
90554: PUSH
90555: LD_INT 25
90557: PUSH
90558: LD_INT 26
90560: PUSH
90561: LD_INT 27
90563: PUSH
90564: LD_INT 28
90566: PUSH
90567: LD_INT 29
90569: PUSH
90570: LD_INT 30
90572: PUSH
90573: LD_INT 31
90575: PUSH
90576: LD_INT 32
90578: PUSH
90579: LD_INT 33
90581: PUSH
90582: LD_INT 34
90584: PUSH
90585: LD_INT 35
90587: PUSH
90588: LD_INT 36
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 101
90631: PUSH
90632: LD_INT 102
90634: PUSH
90635: LD_INT 103
90637: PUSH
90638: LD_INT 104
90640: PUSH
90641: LD_INT 105
90643: PUSH
90644: LD_INT 106
90646: PUSH
90647: LD_INT 107
90649: PUSH
90650: LD_INT 108
90652: PUSH
90653: LD_INT 109
90655: PUSH
90656: LD_INT 110
90658: PUSH
90659: LD_INT 111
90661: PUSH
90662: LD_INT 112
90664: PUSH
90665: LD_INT 113
90667: PUSH
90668: LD_INT 114
90670: PUSH
90671: LD_INT 115
90673: PUSH
90674: LD_INT 116
90676: PUSH
90677: LD_INT 117
90679: PUSH
90680: LD_INT 118
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: ST_TO_ADDR
// if result then
90707: LD_VAR 0 2
90711: IFFALSE 91497
// begin normal :=  ;
90713: LD_ADDR_VAR 0 5
90717: PUSH
90718: LD_STRING 
90720: ST_TO_ADDR
// hardcore :=  ;
90721: LD_ADDR_VAR 0 6
90725: PUSH
90726: LD_STRING 
90728: ST_TO_ADDR
// active :=  ;
90729: LD_ADDR_VAR 0 7
90733: PUSH
90734: LD_STRING 
90736: ST_TO_ADDR
// for i = 1 to normalCounter do
90737: LD_ADDR_VAR 0 8
90741: PUSH
90742: DOUBLE
90743: LD_INT 1
90745: DEC
90746: ST_TO_ADDR
90747: LD_EXP 113
90751: PUSH
90752: FOR_TO
90753: IFFALSE 90854
// begin tmp := 0 ;
90755: LD_ADDR_VAR 0 3
90759: PUSH
90760: LD_STRING 0
90762: ST_TO_ADDR
// if result [ 1 ] then
90763: LD_VAR 0 2
90767: PUSH
90768: LD_INT 1
90770: ARRAY
90771: IFFALSE 90836
// if result [ 1 ] [ 1 ] = i then
90773: LD_VAR 0 2
90777: PUSH
90778: LD_INT 1
90780: ARRAY
90781: PUSH
90782: LD_INT 1
90784: ARRAY
90785: PUSH
90786: LD_VAR 0 8
90790: EQUAL
90791: IFFALSE 90836
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90793: LD_ADDR_VAR 0 2
90797: PUSH
90798: LD_VAR 0 2
90802: PPUSH
90803: LD_INT 1
90805: PPUSH
90806: LD_VAR 0 2
90810: PUSH
90811: LD_INT 1
90813: ARRAY
90814: PPUSH
90815: LD_INT 1
90817: PPUSH
90818: CALL_OW 3
90822: PPUSH
90823: CALL_OW 1
90827: ST_TO_ADDR
// tmp := 1 ;
90828: LD_ADDR_VAR 0 3
90832: PUSH
90833: LD_STRING 1
90835: ST_TO_ADDR
// end ; normal := normal & tmp ;
90836: LD_ADDR_VAR 0 5
90840: PUSH
90841: LD_VAR 0 5
90845: PUSH
90846: LD_VAR 0 3
90850: STR
90851: ST_TO_ADDR
// end ;
90852: GO 90752
90854: POP
90855: POP
// for i = 1 to hardcoreCounter do
90856: LD_ADDR_VAR 0 8
90860: PUSH
90861: DOUBLE
90862: LD_INT 1
90864: DEC
90865: ST_TO_ADDR
90866: LD_EXP 114
90870: PUSH
90871: FOR_TO
90872: IFFALSE 90977
// begin tmp := 0 ;
90874: LD_ADDR_VAR 0 3
90878: PUSH
90879: LD_STRING 0
90881: ST_TO_ADDR
// if result [ 2 ] then
90882: LD_VAR 0 2
90886: PUSH
90887: LD_INT 2
90889: ARRAY
90890: IFFALSE 90959
// if result [ 2 ] [ 1 ] = 100 + i then
90892: LD_VAR 0 2
90896: PUSH
90897: LD_INT 2
90899: ARRAY
90900: PUSH
90901: LD_INT 1
90903: ARRAY
90904: PUSH
90905: LD_INT 100
90907: PUSH
90908: LD_VAR 0 8
90912: PLUS
90913: EQUAL
90914: IFFALSE 90959
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90916: LD_ADDR_VAR 0 2
90920: PUSH
90921: LD_VAR 0 2
90925: PPUSH
90926: LD_INT 2
90928: PPUSH
90929: LD_VAR 0 2
90933: PUSH
90934: LD_INT 2
90936: ARRAY
90937: PPUSH
90938: LD_INT 1
90940: PPUSH
90941: CALL_OW 3
90945: PPUSH
90946: CALL_OW 1
90950: ST_TO_ADDR
// tmp := 1 ;
90951: LD_ADDR_VAR 0 3
90955: PUSH
90956: LD_STRING 1
90958: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90959: LD_ADDR_VAR 0 6
90963: PUSH
90964: LD_VAR 0 6
90968: PUSH
90969: LD_VAR 0 3
90973: STR
90974: ST_TO_ADDR
// end ;
90975: GO 90871
90977: POP
90978: POP
// if isGameLoad then
90979: LD_VAR 0 1
90983: IFFALSE 91458
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
90985: LD_ADDR_VAR 0 4
90989: PUSH
90990: LD_EXP 117
90994: PUSH
90995: LD_EXP 116
90999: PUSH
91000: LD_EXP 118
91004: PUSH
91005: LD_EXP 115
91009: PUSH
91010: LD_EXP 119
91014: PUSH
91015: LD_EXP 120
91019: PUSH
91020: LD_EXP 121
91024: PUSH
91025: LD_EXP 122
91029: PUSH
91030: LD_EXP 123
91034: PUSH
91035: LD_EXP 124
91039: PUSH
91040: LD_EXP 125
91044: PUSH
91045: LD_EXP 126
91049: PUSH
91050: LD_EXP 127
91054: PUSH
91055: LD_EXP 128
91059: PUSH
91060: LD_EXP 136
91064: PUSH
91065: LD_EXP 137
91069: PUSH
91070: LD_EXP 138
91074: PUSH
91075: LD_EXP 139
91079: PUSH
91080: LD_EXP 141
91084: PUSH
91085: LD_EXP 142
91089: PUSH
91090: LD_EXP 143
91094: PUSH
91095: LD_EXP 146
91099: PUSH
91100: LD_EXP 148
91104: PUSH
91105: LD_EXP 149
91109: PUSH
91110: LD_EXP 150
91114: PUSH
91115: LD_EXP 152
91119: PUSH
91120: LD_EXP 153
91124: PUSH
91125: LD_EXP 156
91129: PUSH
91130: LD_EXP 157
91134: PUSH
91135: LD_EXP 158
91139: PUSH
91140: LD_EXP 159
91144: PUSH
91145: LD_EXP 160
91149: PUSH
91150: LD_EXP 161
91154: PUSH
91155: LD_EXP 162
91159: PUSH
91160: LD_EXP 163
91164: PUSH
91165: LD_EXP 164
91169: PUSH
91170: LD_EXP 129
91174: PUSH
91175: LD_EXP 130
91179: PUSH
91180: LD_EXP 133
91184: PUSH
91185: LD_EXP 134
91189: PUSH
91190: LD_EXP 135
91194: PUSH
91195: LD_EXP 131
91199: PUSH
91200: LD_EXP 132
91204: PUSH
91205: LD_EXP 140
91209: PUSH
91210: LD_EXP 144
91214: PUSH
91215: LD_EXP 145
91219: PUSH
91220: LD_EXP 147
91224: PUSH
91225: LD_EXP 151
91229: PUSH
91230: LD_EXP 154
91234: PUSH
91235: LD_EXP 155
91239: PUSH
91240: LD_EXP 165
91244: PUSH
91245: LD_EXP 166
91249: PUSH
91250: LD_EXP 167
91254: PUSH
91255: LD_EXP 168
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: ST_TO_ADDR
// tmp :=  ;
91316: LD_ADDR_VAR 0 3
91320: PUSH
91321: LD_STRING 
91323: ST_TO_ADDR
// for i = 1 to normalCounter do
91324: LD_ADDR_VAR 0 8
91328: PUSH
91329: DOUBLE
91330: LD_INT 1
91332: DEC
91333: ST_TO_ADDR
91334: LD_EXP 113
91338: PUSH
91339: FOR_TO
91340: IFFALSE 91376
// begin if flags [ i ] then
91342: LD_VAR 0 4
91346: PUSH
91347: LD_VAR 0 8
91351: ARRAY
91352: IFFALSE 91374
// tmp := tmp & i & ; ;
91354: LD_ADDR_VAR 0 3
91358: PUSH
91359: LD_VAR 0 3
91363: PUSH
91364: LD_VAR 0 8
91368: STR
91369: PUSH
91370: LD_STRING ;
91372: STR
91373: ST_TO_ADDR
// end ;
91374: GO 91339
91376: POP
91377: POP
// for i = 1 to hardcoreCounter do
91378: LD_ADDR_VAR 0 8
91382: PUSH
91383: DOUBLE
91384: LD_INT 1
91386: DEC
91387: ST_TO_ADDR
91388: LD_EXP 114
91392: PUSH
91393: FOR_TO
91394: IFFALSE 91440
// begin if flags [ normalCounter + i ] then
91396: LD_VAR 0 4
91400: PUSH
91401: LD_EXP 113
91405: PUSH
91406: LD_VAR 0 8
91410: PLUS
91411: ARRAY
91412: IFFALSE 91438
// tmp := tmp & ( 100 + i ) & ; ;
91414: LD_ADDR_VAR 0 3
91418: PUSH
91419: LD_VAR 0 3
91423: PUSH
91424: LD_INT 100
91426: PUSH
91427: LD_VAR 0 8
91431: PLUS
91432: STR
91433: PUSH
91434: LD_STRING ;
91436: STR
91437: ST_TO_ADDR
// end ;
91438: GO 91393
91440: POP
91441: POP
// if tmp then
91442: LD_VAR 0 3
91446: IFFALSE 91458
// active := tmp ;
91448: LD_ADDR_VAR 0 7
91452: PUSH
91453: LD_VAR 0 3
91457: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91458: LD_STRING getStreamItemsFromMission("
91460: PUSH
91461: LD_VAR 0 5
91465: STR
91466: PUSH
91467: LD_STRING ","
91469: STR
91470: PUSH
91471: LD_VAR 0 6
91475: STR
91476: PUSH
91477: LD_STRING ","
91479: STR
91480: PUSH
91481: LD_VAR 0 7
91485: STR
91486: PUSH
91487: LD_STRING ")
91489: STR
91490: PPUSH
91491: CALL_OW 559
// end else
91495: GO 91504
// ToLua ( getStreamItemsFromMission("","","") ) ;
91497: LD_STRING getStreamItemsFromMission("","","")
91499: PPUSH
91500: CALL_OW 559
// end ;
91504: LD_VAR 0 2
91508: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91509: LD_EXP 112
91513: PUSH
91514: LD_EXP 117
91518: AND
91519: IFFALSE 91643
91521: GO 91523
91523: DISABLE
91524: LD_INT 0
91526: PPUSH
91527: PPUSH
// begin enable ;
91528: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91529: LD_ADDR_VAR 0 2
91533: PUSH
91534: LD_INT 22
91536: PUSH
91537: LD_OWVAR 2
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 2
91548: PUSH
91549: LD_INT 34
91551: PUSH
91552: LD_INT 7
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 34
91561: PUSH
91562: LD_INT 45
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 34
91571: PUSH
91572: LD_INT 28
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 34
91581: PUSH
91582: LD_INT 47
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PPUSH
91600: CALL_OW 69
91604: ST_TO_ADDR
// if not tmp then
91605: LD_VAR 0 2
91609: NOT
91610: IFFALSE 91614
// exit ;
91612: GO 91643
// for i in tmp do
91614: LD_ADDR_VAR 0 1
91618: PUSH
91619: LD_VAR 0 2
91623: PUSH
91624: FOR_IN
91625: IFFALSE 91641
// begin SetLives ( i , 0 ) ;
91627: LD_VAR 0 1
91631: PPUSH
91632: LD_INT 0
91634: PPUSH
91635: CALL_OW 234
// end ;
91639: GO 91624
91641: POP
91642: POP
// end ;
91643: PPOPN 2
91645: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91646: LD_EXP 112
91650: PUSH
91651: LD_EXP 118
91655: AND
91656: IFFALSE 91740
91658: GO 91660
91660: DISABLE
91661: LD_INT 0
91663: PPUSH
91664: PPUSH
// begin enable ;
91665: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91666: LD_ADDR_VAR 0 2
91670: PUSH
91671: LD_INT 22
91673: PUSH
91674: LD_OWVAR 2
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 32
91685: PUSH
91686: LD_INT 3
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PPUSH
91697: CALL_OW 69
91701: ST_TO_ADDR
// if not tmp then
91702: LD_VAR 0 2
91706: NOT
91707: IFFALSE 91711
// exit ;
91709: GO 91740
// for i in tmp do
91711: LD_ADDR_VAR 0 1
91715: PUSH
91716: LD_VAR 0 2
91720: PUSH
91721: FOR_IN
91722: IFFALSE 91738
// begin SetLives ( i , 0 ) ;
91724: LD_VAR 0 1
91728: PPUSH
91729: LD_INT 0
91731: PPUSH
91732: CALL_OW 234
// end ;
91736: GO 91721
91738: POP
91739: POP
// end ;
91740: PPOPN 2
91742: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91743: LD_EXP 112
91747: PUSH
91748: LD_EXP 115
91752: AND
91753: IFFALSE 91846
91755: GO 91757
91757: DISABLE
91758: LD_INT 0
91760: PPUSH
// begin enable ;
91761: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91762: LD_ADDR_VAR 0 1
91766: PUSH
91767: LD_INT 22
91769: PUSH
91770: LD_OWVAR 2
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: LD_INT 2
91781: PUSH
91782: LD_INT 25
91784: PUSH
91785: LD_INT 5
91787: PUSH
91788: EMPTY
91789: LIST
91790: LIST
91791: PUSH
91792: LD_INT 25
91794: PUSH
91795: LD_INT 9
91797: PUSH
91798: EMPTY
91799: LIST
91800: LIST
91801: PUSH
91802: LD_INT 25
91804: PUSH
91805: LD_INT 8
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PPUSH
91822: CALL_OW 69
91826: PUSH
91827: FOR_IN
91828: IFFALSE 91844
// begin SetClass ( i , 1 ) ;
91830: LD_VAR 0 1
91834: PPUSH
91835: LD_INT 1
91837: PPUSH
91838: CALL_OW 336
// end ;
91842: GO 91827
91844: POP
91845: POP
// end ;
91846: PPOPN 1
91848: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91849: LD_EXP 112
91853: PUSH
91854: LD_EXP 116
91858: AND
91859: PUSH
91860: LD_OWVAR 65
91864: PUSH
91865: LD_INT 7
91867: LESS
91868: AND
91869: IFFALSE 91883
91871: GO 91873
91873: DISABLE
// begin enable ;
91874: ENABLE
// game_speed := 7 ;
91875: LD_ADDR_OWVAR 65
91879: PUSH
91880: LD_INT 7
91882: ST_TO_ADDR
// end ;
91883: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91884: LD_EXP 112
91888: PUSH
91889: LD_EXP 119
91893: AND
91894: IFFALSE 92096
91896: GO 91898
91898: DISABLE
91899: LD_INT 0
91901: PPUSH
91902: PPUSH
91903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91904: LD_ADDR_VAR 0 3
91908: PUSH
91909: LD_INT 81
91911: PUSH
91912: LD_OWVAR 2
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 21
91923: PUSH
91924: LD_INT 1
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PPUSH
91935: CALL_OW 69
91939: ST_TO_ADDR
// if not tmp then
91940: LD_VAR 0 3
91944: NOT
91945: IFFALSE 91949
// exit ;
91947: GO 92096
// if tmp > 5 then
91949: LD_VAR 0 3
91953: PUSH
91954: LD_INT 5
91956: GREATER
91957: IFFALSE 91969
// k := 5 else
91959: LD_ADDR_VAR 0 2
91963: PUSH
91964: LD_INT 5
91966: ST_TO_ADDR
91967: GO 91979
// k := tmp ;
91969: LD_ADDR_VAR 0 2
91973: PUSH
91974: LD_VAR 0 3
91978: ST_TO_ADDR
// for i := 1 to k do
91979: LD_ADDR_VAR 0 1
91983: PUSH
91984: DOUBLE
91985: LD_INT 1
91987: DEC
91988: ST_TO_ADDR
91989: LD_VAR 0 2
91993: PUSH
91994: FOR_TO
91995: IFFALSE 92094
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
91997: LD_VAR 0 3
92001: PUSH
92002: LD_VAR 0 1
92006: ARRAY
92007: PPUSH
92008: LD_VAR 0 1
92012: PUSH
92013: LD_INT 4
92015: MOD
92016: PUSH
92017: LD_INT 1
92019: PLUS
92020: PPUSH
92021: CALL_OW 259
92025: PUSH
92026: LD_INT 10
92028: LESS
92029: IFFALSE 92092
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92031: LD_VAR 0 3
92035: PUSH
92036: LD_VAR 0 1
92040: ARRAY
92041: PPUSH
92042: LD_VAR 0 1
92046: PUSH
92047: LD_INT 4
92049: MOD
92050: PUSH
92051: LD_INT 1
92053: PLUS
92054: PPUSH
92055: LD_VAR 0 3
92059: PUSH
92060: LD_VAR 0 1
92064: ARRAY
92065: PPUSH
92066: LD_VAR 0 1
92070: PUSH
92071: LD_INT 4
92073: MOD
92074: PUSH
92075: LD_INT 1
92077: PLUS
92078: PPUSH
92079: CALL_OW 259
92083: PUSH
92084: LD_INT 1
92086: PLUS
92087: PPUSH
92088: CALL_OW 237
92092: GO 91994
92094: POP
92095: POP
// end ;
92096: PPOPN 3
92098: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92099: LD_EXP 112
92103: PUSH
92104: LD_EXP 120
92108: AND
92109: IFFALSE 92129
92111: GO 92113
92113: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92114: LD_INT 4
92116: PPUSH
92117: LD_OWVAR 2
92121: PPUSH
92122: LD_INT 0
92124: PPUSH
92125: CALL_OW 324
92129: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92130: LD_EXP 112
92134: PUSH
92135: LD_EXP 149
92139: AND
92140: IFFALSE 92160
92142: GO 92144
92144: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92145: LD_INT 19
92147: PPUSH
92148: LD_OWVAR 2
92152: PPUSH
92153: LD_INT 0
92155: PPUSH
92156: CALL_OW 324
92160: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92161: LD_EXP 112
92165: PUSH
92166: LD_EXP 121
92170: AND
92171: IFFALSE 92273
92173: GO 92175
92175: DISABLE
92176: LD_INT 0
92178: PPUSH
92179: PPUSH
// begin enable ;
92180: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92181: LD_ADDR_VAR 0 2
92185: PUSH
92186: LD_INT 22
92188: PUSH
92189: LD_OWVAR 2
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: PUSH
92198: LD_INT 2
92200: PUSH
92201: LD_INT 34
92203: PUSH
92204: LD_INT 11
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 34
92213: PUSH
92214: LD_INT 30
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: LIST
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PPUSH
92230: CALL_OW 69
92234: ST_TO_ADDR
// if not tmp then
92235: LD_VAR 0 2
92239: NOT
92240: IFFALSE 92244
// exit ;
92242: GO 92273
// for i in tmp do
92244: LD_ADDR_VAR 0 1
92248: PUSH
92249: LD_VAR 0 2
92253: PUSH
92254: FOR_IN
92255: IFFALSE 92271
// begin SetLives ( i , 0 ) ;
92257: LD_VAR 0 1
92261: PPUSH
92262: LD_INT 0
92264: PPUSH
92265: CALL_OW 234
// end ;
92269: GO 92254
92271: POP
92272: POP
// end ;
92273: PPOPN 2
92275: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92276: LD_EXP 112
92280: PUSH
92281: LD_EXP 122
92285: AND
92286: IFFALSE 92306
92288: GO 92290
92290: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92291: LD_INT 32
92293: PPUSH
92294: LD_OWVAR 2
92298: PPUSH
92299: LD_INT 0
92301: PPUSH
92302: CALL_OW 324
92306: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92307: LD_EXP 112
92311: PUSH
92312: LD_EXP 123
92316: AND
92317: IFFALSE 92498
92319: GO 92321
92321: DISABLE
92322: LD_INT 0
92324: PPUSH
92325: PPUSH
92326: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92327: LD_ADDR_VAR 0 2
92331: PUSH
92332: LD_INT 22
92334: PUSH
92335: LD_OWVAR 2
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 33
92346: PUSH
92347: LD_INT 3
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PPUSH
92358: CALL_OW 69
92362: ST_TO_ADDR
// if not tmp then
92363: LD_VAR 0 2
92367: NOT
92368: IFFALSE 92372
// exit ;
92370: GO 92498
// side := 0 ;
92372: LD_ADDR_VAR 0 3
92376: PUSH
92377: LD_INT 0
92379: ST_TO_ADDR
// for i := 1 to 8 do
92380: LD_ADDR_VAR 0 1
92384: PUSH
92385: DOUBLE
92386: LD_INT 1
92388: DEC
92389: ST_TO_ADDR
92390: LD_INT 8
92392: PUSH
92393: FOR_TO
92394: IFFALSE 92442
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92396: LD_OWVAR 2
92400: PUSH
92401: LD_VAR 0 1
92405: NONEQUAL
92406: PUSH
92407: LD_OWVAR 2
92411: PPUSH
92412: LD_VAR 0 1
92416: PPUSH
92417: CALL_OW 81
92421: PUSH
92422: LD_INT 2
92424: EQUAL
92425: AND
92426: IFFALSE 92440
// begin side := i ;
92428: LD_ADDR_VAR 0 3
92432: PUSH
92433: LD_VAR 0 1
92437: ST_TO_ADDR
// break ;
92438: GO 92442
// end ;
92440: GO 92393
92442: POP
92443: POP
// if not side then
92444: LD_VAR 0 3
92448: NOT
92449: IFFALSE 92453
// exit ;
92451: GO 92498
// for i := 1 to tmp do
92453: LD_ADDR_VAR 0 1
92457: PUSH
92458: DOUBLE
92459: LD_INT 1
92461: DEC
92462: ST_TO_ADDR
92463: LD_VAR 0 2
92467: PUSH
92468: FOR_TO
92469: IFFALSE 92496
// if Prob ( 60 ) then
92471: LD_INT 60
92473: PPUSH
92474: CALL_OW 13
92478: IFFALSE 92494
// SetSide ( i , side ) ;
92480: LD_VAR 0 1
92484: PPUSH
92485: LD_VAR 0 3
92489: PPUSH
92490: CALL_OW 235
92494: GO 92468
92496: POP
92497: POP
// end ;
92498: PPOPN 3
92500: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92501: LD_EXP 112
92505: PUSH
92506: LD_EXP 125
92510: AND
92511: IFFALSE 92630
92513: GO 92515
92515: DISABLE
92516: LD_INT 0
92518: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92519: LD_ADDR_VAR 0 1
92523: PUSH
92524: LD_INT 22
92526: PUSH
92527: LD_OWVAR 2
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 21
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 3
92548: PUSH
92549: LD_INT 23
92551: PUSH
92552: LD_INT 0
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: LIST
92567: PPUSH
92568: CALL_OW 69
92572: PUSH
92573: FOR_IN
92574: IFFALSE 92628
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92576: LD_VAR 0 1
92580: PPUSH
92581: CALL_OW 257
92585: PUSH
92586: LD_INT 1
92588: PUSH
92589: LD_INT 2
92591: PUSH
92592: LD_INT 3
92594: PUSH
92595: LD_INT 4
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: IN
92604: IFFALSE 92626
// SetClass ( un , rand ( 1 , 4 ) ) ;
92606: LD_VAR 0 1
92610: PPUSH
92611: LD_INT 1
92613: PPUSH
92614: LD_INT 4
92616: PPUSH
92617: CALL_OW 12
92621: PPUSH
92622: CALL_OW 336
92626: GO 92573
92628: POP
92629: POP
// end ;
92630: PPOPN 1
92632: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92633: LD_EXP 112
92637: PUSH
92638: LD_EXP 124
92642: AND
92643: IFFALSE 92722
92645: GO 92647
92647: DISABLE
92648: LD_INT 0
92650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92651: LD_ADDR_VAR 0 1
92655: PUSH
92656: LD_INT 22
92658: PUSH
92659: LD_OWVAR 2
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 21
92670: PUSH
92671: LD_INT 3
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PPUSH
92682: CALL_OW 69
92686: ST_TO_ADDR
// if not tmp then
92687: LD_VAR 0 1
92691: NOT
92692: IFFALSE 92696
// exit ;
92694: GO 92722
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92696: LD_VAR 0 1
92700: PUSH
92701: LD_INT 1
92703: PPUSH
92704: LD_VAR 0 1
92708: PPUSH
92709: CALL_OW 12
92713: ARRAY
92714: PPUSH
92715: LD_INT 100
92717: PPUSH
92718: CALL_OW 234
// end ;
92722: PPOPN 1
92724: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92725: LD_EXP 112
92729: PUSH
92730: LD_EXP 126
92734: AND
92735: IFFALSE 92833
92737: GO 92739
92739: DISABLE
92740: LD_INT 0
92742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92743: LD_ADDR_VAR 0 1
92747: PUSH
92748: LD_INT 22
92750: PUSH
92751: LD_OWVAR 2
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 21
92762: PUSH
92763: LD_INT 1
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PPUSH
92774: CALL_OW 69
92778: ST_TO_ADDR
// if not tmp then
92779: LD_VAR 0 1
92783: NOT
92784: IFFALSE 92788
// exit ;
92786: GO 92833
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92788: LD_VAR 0 1
92792: PUSH
92793: LD_INT 1
92795: PPUSH
92796: LD_VAR 0 1
92800: PPUSH
92801: CALL_OW 12
92805: ARRAY
92806: PPUSH
92807: LD_INT 1
92809: PPUSH
92810: LD_INT 4
92812: PPUSH
92813: CALL_OW 12
92817: PPUSH
92818: LD_INT 3000
92820: PPUSH
92821: LD_INT 9000
92823: PPUSH
92824: CALL_OW 12
92828: PPUSH
92829: CALL_OW 492
// end ;
92833: PPOPN 1
92835: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92836: LD_EXP 112
92840: PUSH
92841: LD_EXP 127
92845: AND
92846: IFFALSE 92866
92848: GO 92850
92850: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92851: LD_INT 1
92853: PPUSH
92854: LD_OWVAR 2
92858: PPUSH
92859: LD_INT 0
92861: PPUSH
92862: CALL_OW 324
92866: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92867: LD_EXP 112
92871: PUSH
92872: LD_EXP 128
92876: AND
92877: IFFALSE 92960
92879: GO 92881
92881: DISABLE
92882: LD_INT 0
92884: PPUSH
92885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92886: LD_ADDR_VAR 0 2
92890: PUSH
92891: LD_INT 22
92893: PUSH
92894: LD_OWVAR 2
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 21
92905: PUSH
92906: LD_INT 3
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PPUSH
92917: CALL_OW 69
92921: ST_TO_ADDR
// if not tmp then
92922: LD_VAR 0 2
92926: NOT
92927: IFFALSE 92931
// exit ;
92929: GO 92960
// for i in tmp do
92931: LD_ADDR_VAR 0 1
92935: PUSH
92936: LD_VAR 0 2
92940: PUSH
92941: FOR_IN
92942: IFFALSE 92958
// SetBLevel ( i , 10 ) ;
92944: LD_VAR 0 1
92948: PPUSH
92949: LD_INT 10
92951: PPUSH
92952: CALL_OW 241
92956: GO 92941
92958: POP
92959: POP
// end ;
92960: PPOPN 2
92962: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
92963: LD_EXP 112
92967: PUSH
92968: LD_EXP 129
92972: AND
92973: IFFALSE 93084
92975: GO 92977
92977: DISABLE
92978: LD_INT 0
92980: PPUSH
92981: PPUSH
92982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92983: LD_ADDR_VAR 0 3
92987: PUSH
92988: LD_INT 22
92990: PUSH
92991: LD_OWVAR 2
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 25
93002: PUSH
93003: LD_INT 1
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PPUSH
93014: CALL_OW 69
93018: ST_TO_ADDR
// if not tmp then
93019: LD_VAR 0 3
93023: NOT
93024: IFFALSE 93028
// exit ;
93026: GO 93084
// un := tmp [ rand ( 1 , tmp ) ] ;
93028: LD_ADDR_VAR 0 2
93032: PUSH
93033: LD_VAR 0 3
93037: PUSH
93038: LD_INT 1
93040: PPUSH
93041: LD_VAR 0 3
93045: PPUSH
93046: CALL_OW 12
93050: ARRAY
93051: ST_TO_ADDR
// if Crawls ( un ) then
93052: LD_VAR 0 2
93056: PPUSH
93057: CALL_OW 318
93061: IFFALSE 93072
// ComWalk ( un ) ;
93063: LD_VAR 0 2
93067: PPUSH
93068: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93072: LD_VAR 0 2
93076: PPUSH
93077: LD_INT 5
93079: PPUSH
93080: CALL_OW 336
// end ;
93084: PPOPN 3
93086: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93087: LD_EXP 112
93091: PUSH
93092: LD_EXP 130
93096: AND
93097: PUSH
93098: LD_OWVAR 67
93102: PUSH
93103: LD_INT 4
93105: LESS
93106: AND
93107: IFFALSE 93126
93109: GO 93111
93111: DISABLE
// begin Difficulty := Difficulty + 1 ;
93112: LD_ADDR_OWVAR 67
93116: PUSH
93117: LD_OWVAR 67
93121: PUSH
93122: LD_INT 1
93124: PLUS
93125: ST_TO_ADDR
// end ;
93126: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93127: LD_EXP 112
93131: PUSH
93132: LD_EXP 131
93136: AND
93137: IFFALSE 93240
93139: GO 93141
93141: DISABLE
93142: LD_INT 0
93144: PPUSH
// begin for i := 1 to 5 do
93145: LD_ADDR_VAR 0 1
93149: PUSH
93150: DOUBLE
93151: LD_INT 1
93153: DEC
93154: ST_TO_ADDR
93155: LD_INT 5
93157: PUSH
93158: FOR_TO
93159: IFFALSE 93238
// begin uc_nation := nation_nature ;
93161: LD_ADDR_OWVAR 21
93165: PUSH
93166: LD_INT 0
93168: ST_TO_ADDR
// uc_side := 0 ;
93169: LD_ADDR_OWVAR 20
93173: PUSH
93174: LD_INT 0
93176: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93177: LD_ADDR_OWVAR 29
93181: PUSH
93182: LD_INT 12
93184: PUSH
93185: LD_INT 12
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: ST_TO_ADDR
// hc_agressivity := 20 ;
93192: LD_ADDR_OWVAR 35
93196: PUSH
93197: LD_INT 20
93199: ST_TO_ADDR
// hc_class := class_tiger ;
93200: LD_ADDR_OWVAR 28
93204: PUSH
93205: LD_INT 14
93207: ST_TO_ADDR
// hc_gallery :=  ;
93208: LD_ADDR_OWVAR 33
93212: PUSH
93213: LD_STRING 
93215: ST_TO_ADDR
// hc_name :=  ;
93216: LD_ADDR_OWVAR 26
93220: PUSH
93221: LD_STRING 
93223: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93224: CALL_OW 44
93228: PPUSH
93229: LD_INT 0
93231: PPUSH
93232: CALL_OW 51
// end ;
93236: GO 93158
93238: POP
93239: POP
// end ;
93240: PPOPN 1
93242: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93243: LD_EXP 112
93247: PUSH
93248: LD_EXP 132
93252: AND
93253: IFFALSE 93262
93255: GO 93257
93257: DISABLE
// StreamSibBomb ;
93258: CALL 93263 0 0
93262: END
// export function StreamSibBomb ; var i , x , y ; begin
93263: LD_INT 0
93265: PPUSH
93266: PPUSH
93267: PPUSH
93268: PPUSH
// result := false ;
93269: LD_ADDR_VAR 0 1
93273: PUSH
93274: LD_INT 0
93276: ST_TO_ADDR
// for i := 1 to 16 do
93277: LD_ADDR_VAR 0 2
93281: PUSH
93282: DOUBLE
93283: LD_INT 1
93285: DEC
93286: ST_TO_ADDR
93287: LD_INT 16
93289: PUSH
93290: FOR_TO
93291: IFFALSE 93490
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93293: LD_ADDR_VAR 0 3
93297: PUSH
93298: LD_INT 10
93300: PUSH
93301: LD_INT 20
93303: PUSH
93304: LD_INT 30
93306: PUSH
93307: LD_INT 40
93309: PUSH
93310: LD_INT 50
93312: PUSH
93313: LD_INT 60
93315: PUSH
93316: LD_INT 70
93318: PUSH
93319: LD_INT 80
93321: PUSH
93322: LD_INT 90
93324: PUSH
93325: LD_INT 100
93327: PUSH
93328: LD_INT 110
93330: PUSH
93331: LD_INT 120
93333: PUSH
93334: LD_INT 130
93336: PUSH
93337: LD_INT 140
93339: PUSH
93340: LD_INT 150
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 1
93362: PPUSH
93363: LD_INT 15
93365: PPUSH
93366: CALL_OW 12
93370: ARRAY
93371: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93372: LD_ADDR_VAR 0 4
93376: PUSH
93377: LD_INT 10
93379: PUSH
93380: LD_INT 20
93382: PUSH
93383: LD_INT 30
93385: PUSH
93386: LD_INT 40
93388: PUSH
93389: LD_INT 50
93391: PUSH
93392: LD_INT 60
93394: PUSH
93395: LD_INT 70
93397: PUSH
93398: LD_INT 80
93400: PUSH
93401: LD_INT 90
93403: PUSH
93404: LD_INT 100
93406: PUSH
93407: LD_INT 110
93409: PUSH
93410: LD_INT 120
93412: PUSH
93413: LD_INT 130
93415: PUSH
93416: LD_INT 140
93418: PUSH
93419: LD_INT 150
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: PUSH
93439: LD_INT 1
93441: PPUSH
93442: LD_INT 15
93444: PPUSH
93445: CALL_OW 12
93449: ARRAY
93450: ST_TO_ADDR
// if ValidHex ( x , y ) then
93451: LD_VAR 0 3
93455: PPUSH
93456: LD_VAR 0 4
93460: PPUSH
93461: CALL_OW 488
93465: IFFALSE 93488
// begin result := [ x , y ] ;
93467: LD_ADDR_VAR 0 1
93471: PUSH
93472: LD_VAR 0 3
93476: PUSH
93477: LD_VAR 0 4
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: ST_TO_ADDR
// break ;
93486: GO 93490
// end ; end ;
93488: GO 93290
93490: POP
93491: POP
// if result then
93492: LD_VAR 0 1
93496: IFFALSE 93556
// begin ToLua ( playSibBomb() ) ;
93498: LD_STRING playSibBomb()
93500: PPUSH
93501: CALL_OW 559
// wait ( 0 0$14 ) ;
93505: LD_INT 490
93507: PPUSH
93508: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93512: LD_VAR 0 1
93516: PUSH
93517: LD_INT 1
93519: ARRAY
93520: PPUSH
93521: LD_VAR 0 1
93525: PUSH
93526: LD_INT 2
93528: ARRAY
93529: PPUSH
93530: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93534: LD_VAR 0 1
93538: PUSH
93539: LD_INT 1
93541: ARRAY
93542: PPUSH
93543: LD_VAR 0 1
93547: PUSH
93548: LD_INT 2
93550: ARRAY
93551: PPUSH
93552: CALL_OW 429
// end ; end ;
93556: LD_VAR 0 1
93560: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93561: LD_EXP 112
93565: PUSH
93566: LD_EXP 134
93570: AND
93571: IFFALSE 93583
93573: GO 93575
93575: DISABLE
// YouLost (  ) ;
93576: LD_STRING 
93578: PPUSH
93579: CALL_OW 104
93583: END
// every 0 0$1 trigger StreamModeActive and sFog do
93584: LD_EXP 112
93588: PUSH
93589: LD_EXP 133
93593: AND
93594: IFFALSE 93608
93596: GO 93598
93598: DISABLE
// FogOff ( your_side ) ;
93599: LD_OWVAR 2
93603: PPUSH
93604: CALL_OW 344
93608: END
// every 0 0$1 trigger StreamModeActive and sSun do
93609: LD_EXP 112
93613: PUSH
93614: LD_EXP 135
93618: AND
93619: IFFALSE 93647
93621: GO 93623
93623: DISABLE
// begin solar_recharge_percent := 0 ;
93624: LD_ADDR_OWVAR 79
93628: PUSH
93629: LD_INT 0
93631: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93632: LD_INT 10500
93634: PPUSH
93635: CALL_OW 67
// solar_recharge_percent := 100 ;
93639: LD_ADDR_OWVAR 79
93643: PUSH
93644: LD_INT 100
93646: ST_TO_ADDR
// end ;
93647: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93648: LD_EXP 112
93652: PUSH
93653: LD_EXP 136
93657: AND
93658: IFFALSE 93897
93660: GO 93662
93662: DISABLE
93663: LD_INT 0
93665: PPUSH
93666: PPUSH
93667: PPUSH
// begin tmp := [ ] ;
93668: LD_ADDR_VAR 0 3
93672: PUSH
93673: EMPTY
93674: ST_TO_ADDR
// for i := 1 to 6 do
93675: LD_ADDR_VAR 0 1
93679: PUSH
93680: DOUBLE
93681: LD_INT 1
93683: DEC
93684: ST_TO_ADDR
93685: LD_INT 6
93687: PUSH
93688: FOR_TO
93689: IFFALSE 93794
// begin uc_nation := nation_nature ;
93691: LD_ADDR_OWVAR 21
93695: PUSH
93696: LD_INT 0
93698: ST_TO_ADDR
// uc_side := 0 ;
93699: LD_ADDR_OWVAR 20
93703: PUSH
93704: LD_INT 0
93706: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93707: LD_ADDR_OWVAR 29
93711: PUSH
93712: LD_INT 12
93714: PUSH
93715: LD_INT 12
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: ST_TO_ADDR
// hc_agressivity := 20 ;
93722: LD_ADDR_OWVAR 35
93726: PUSH
93727: LD_INT 20
93729: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93730: LD_ADDR_OWVAR 28
93734: PUSH
93735: LD_INT 17
93737: ST_TO_ADDR
// hc_gallery :=  ;
93738: LD_ADDR_OWVAR 33
93742: PUSH
93743: LD_STRING 
93745: ST_TO_ADDR
// hc_name :=  ;
93746: LD_ADDR_OWVAR 26
93750: PUSH
93751: LD_STRING 
93753: ST_TO_ADDR
// un := CreateHuman ;
93754: LD_ADDR_VAR 0 2
93758: PUSH
93759: CALL_OW 44
93763: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93764: LD_VAR 0 2
93768: PPUSH
93769: LD_INT 1
93771: PPUSH
93772: CALL_OW 51
// tmp := tmp ^ un ;
93776: LD_ADDR_VAR 0 3
93780: PUSH
93781: LD_VAR 0 3
93785: PUSH
93786: LD_VAR 0 2
93790: ADD
93791: ST_TO_ADDR
// end ;
93792: GO 93688
93794: POP
93795: POP
// repeat wait ( 0 0$1 ) ;
93796: LD_INT 35
93798: PPUSH
93799: CALL_OW 67
// for un in tmp do
93803: LD_ADDR_VAR 0 2
93807: PUSH
93808: LD_VAR 0 3
93812: PUSH
93813: FOR_IN
93814: IFFALSE 93888
// begin if IsDead ( un ) then
93816: LD_VAR 0 2
93820: PPUSH
93821: CALL_OW 301
93825: IFFALSE 93845
// begin tmp := tmp diff un ;
93827: LD_ADDR_VAR 0 3
93831: PUSH
93832: LD_VAR 0 3
93836: PUSH
93837: LD_VAR 0 2
93841: DIFF
93842: ST_TO_ADDR
// continue ;
93843: GO 93813
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93845: LD_VAR 0 2
93849: PPUSH
93850: LD_INT 3
93852: PUSH
93853: LD_INT 22
93855: PUSH
93856: LD_INT 0
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PPUSH
93867: CALL_OW 69
93871: PPUSH
93872: LD_VAR 0 2
93876: PPUSH
93877: CALL_OW 74
93881: PPUSH
93882: CALL_OW 115
// end ;
93886: GO 93813
93888: POP
93889: POP
// until not tmp ;
93890: LD_VAR 0 3
93894: NOT
93895: IFFALSE 93796
// end ;
93897: PPOPN 3
93899: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93900: LD_EXP 112
93904: PUSH
93905: LD_EXP 137
93909: AND
93910: IFFALSE 93964
93912: GO 93914
93914: DISABLE
// begin ToLua ( displayTroll(); ) ;
93915: LD_STRING displayTroll();
93917: PPUSH
93918: CALL_OW 559
// wait ( 3 3$00 ) ;
93922: LD_INT 6300
93924: PPUSH
93925: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93929: LD_STRING hideTroll();
93931: PPUSH
93932: CALL_OW 559
// wait ( 1 1$00 ) ;
93936: LD_INT 2100
93938: PPUSH
93939: CALL_OW 67
// ToLua ( displayTroll(); ) ;
93943: LD_STRING displayTroll();
93945: PPUSH
93946: CALL_OW 559
// wait ( 1 1$00 ) ;
93950: LD_INT 2100
93952: PPUSH
93953: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93957: LD_STRING hideTroll();
93959: PPUSH
93960: CALL_OW 559
// end ;
93964: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
93965: LD_EXP 112
93969: PUSH
93970: LD_EXP 138
93974: AND
93975: IFFALSE 94038
93977: GO 93979
93979: DISABLE
93980: LD_INT 0
93982: PPUSH
// begin p := 0 ;
93983: LD_ADDR_VAR 0 1
93987: PUSH
93988: LD_INT 0
93990: ST_TO_ADDR
// repeat game_speed := 1 ;
93991: LD_ADDR_OWVAR 65
93995: PUSH
93996: LD_INT 1
93998: ST_TO_ADDR
// wait ( 0 0$1 ) ;
93999: LD_INT 35
94001: PPUSH
94002: CALL_OW 67
// p := p + 1 ;
94006: LD_ADDR_VAR 0 1
94010: PUSH
94011: LD_VAR 0 1
94015: PUSH
94016: LD_INT 1
94018: PLUS
94019: ST_TO_ADDR
// until p >= 60 ;
94020: LD_VAR 0 1
94024: PUSH
94025: LD_INT 60
94027: GREATEREQUAL
94028: IFFALSE 93991
// game_speed := 4 ;
94030: LD_ADDR_OWVAR 65
94034: PUSH
94035: LD_INT 4
94037: ST_TO_ADDR
// end ;
94038: PPOPN 1
94040: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94041: LD_EXP 112
94045: PUSH
94046: LD_EXP 139
94050: AND
94051: IFFALSE 94197
94053: GO 94055
94055: DISABLE
94056: LD_INT 0
94058: PPUSH
94059: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94060: LD_ADDR_VAR 0 1
94064: PUSH
94065: LD_INT 22
94067: PUSH
94068: LD_OWVAR 2
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 2
94079: PUSH
94080: LD_INT 30
94082: PUSH
94083: LD_INT 0
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 30
94092: PUSH
94093: LD_INT 1
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: LIST
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PPUSH
94109: CALL_OW 69
94113: ST_TO_ADDR
// if not depot then
94114: LD_VAR 0 1
94118: NOT
94119: IFFALSE 94123
// exit ;
94121: GO 94197
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94123: LD_ADDR_VAR 0 2
94127: PUSH
94128: LD_VAR 0 1
94132: PUSH
94133: LD_INT 1
94135: PPUSH
94136: LD_VAR 0 1
94140: PPUSH
94141: CALL_OW 12
94145: ARRAY
94146: PPUSH
94147: CALL_OW 274
94151: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94152: LD_VAR 0 2
94156: PPUSH
94157: LD_INT 1
94159: PPUSH
94160: LD_INT 0
94162: PPUSH
94163: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94167: LD_VAR 0 2
94171: PPUSH
94172: LD_INT 2
94174: PPUSH
94175: LD_INT 0
94177: PPUSH
94178: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94182: LD_VAR 0 2
94186: PPUSH
94187: LD_INT 3
94189: PPUSH
94190: LD_INT 0
94192: PPUSH
94193: CALL_OW 277
// end ;
94197: PPOPN 2
94199: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94200: LD_EXP 112
94204: PUSH
94205: LD_EXP 140
94209: AND
94210: IFFALSE 94307
94212: GO 94214
94214: DISABLE
94215: LD_INT 0
94217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94218: LD_ADDR_VAR 0 1
94222: PUSH
94223: LD_INT 22
94225: PUSH
94226: LD_OWVAR 2
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 21
94237: PUSH
94238: LD_INT 1
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 3
94247: PUSH
94248: LD_INT 23
94250: PUSH
94251: LD_INT 0
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: LIST
94266: PPUSH
94267: CALL_OW 69
94271: ST_TO_ADDR
// if not tmp then
94272: LD_VAR 0 1
94276: NOT
94277: IFFALSE 94281
// exit ;
94279: GO 94307
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94281: LD_VAR 0 1
94285: PUSH
94286: LD_INT 1
94288: PPUSH
94289: LD_VAR 0 1
94293: PPUSH
94294: CALL_OW 12
94298: ARRAY
94299: PPUSH
94300: LD_INT 200
94302: PPUSH
94303: CALL_OW 234
// end ;
94307: PPOPN 1
94309: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94310: LD_EXP 112
94314: PUSH
94315: LD_EXP 141
94319: AND
94320: IFFALSE 94399
94322: GO 94324
94324: DISABLE
94325: LD_INT 0
94327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94328: LD_ADDR_VAR 0 1
94332: PUSH
94333: LD_INT 22
94335: PUSH
94336: LD_OWVAR 2
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 21
94347: PUSH
94348: LD_INT 2
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PPUSH
94359: CALL_OW 69
94363: ST_TO_ADDR
// if not tmp then
94364: LD_VAR 0 1
94368: NOT
94369: IFFALSE 94373
// exit ;
94371: GO 94399
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94373: LD_VAR 0 1
94377: PUSH
94378: LD_INT 1
94380: PPUSH
94381: LD_VAR 0 1
94385: PPUSH
94386: CALL_OW 12
94390: ARRAY
94391: PPUSH
94392: LD_INT 60
94394: PPUSH
94395: CALL_OW 234
// end ;
94399: PPOPN 1
94401: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94402: LD_EXP 112
94406: PUSH
94407: LD_EXP 142
94411: AND
94412: IFFALSE 94511
94414: GO 94416
94416: DISABLE
94417: LD_INT 0
94419: PPUSH
94420: PPUSH
// begin enable ;
94421: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94422: LD_ADDR_VAR 0 1
94426: PUSH
94427: LD_INT 22
94429: PUSH
94430: LD_OWVAR 2
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 61
94441: PUSH
94442: EMPTY
94443: LIST
94444: PUSH
94445: LD_INT 33
94447: PUSH
94448: LD_INT 2
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: LIST
94459: PPUSH
94460: CALL_OW 69
94464: ST_TO_ADDR
// if not tmp then
94465: LD_VAR 0 1
94469: NOT
94470: IFFALSE 94474
// exit ;
94472: GO 94511
// for i in tmp do
94474: LD_ADDR_VAR 0 2
94478: PUSH
94479: LD_VAR 0 1
94483: PUSH
94484: FOR_IN
94485: IFFALSE 94509
// if IsControledBy ( i ) then
94487: LD_VAR 0 2
94491: PPUSH
94492: CALL_OW 312
94496: IFFALSE 94507
// ComUnlink ( i ) ;
94498: LD_VAR 0 2
94502: PPUSH
94503: CALL_OW 136
94507: GO 94484
94509: POP
94510: POP
// end ;
94511: PPOPN 2
94513: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94514: LD_EXP 112
94518: PUSH
94519: LD_EXP 143
94523: AND
94524: IFFALSE 94664
94526: GO 94528
94528: DISABLE
94529: LD_INT 0
94531: PPUSH
94532: PPUSH
// begin ToLua ( displayPowell(); ) ;
94533: LD_STRING displayPowell();
94535: PPUSH
94536: CALL_OW 559
// uc_side := 0 ;
94540: LD_ADDR_OWVAR 20
94544: PUSH
94545: LD_INT 0
94547: ST_TO_ADDR
// uc_nation := 2 ;
94548: LD_ADDR_OWVAR 21
94552: PUSH
94553: LD_INT 2
94555: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94556: LD_ADDR_OWVAR 37
94560: PUSH
94561: LD_INT 14
94563: ST_TO_ADDR
// vc_engine := engine_siberite ;
94564: LD_ADDR_OWVAR 39
94568: PUSH
94569: LD_INT 3
94571: ST_TO_ADDR
// vc_control := control_apeman ;
94572: LD_ADDR_OWVAR 38
94576: PUSH
94577: LD_INT 5
94579: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94580: LD_ADDR_OWVAR 40
94584: PUSH
94585: LD_INT 29
94587: ST_TO_ADDR
// un := CreateVehicle ;
94588: LD_ADDR_VAR 0 2
94592: PUSH
94593: CALL_OW 45
94597: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94598: LD_VAR 0 2
94602: PPUSH
94603: LD_INT 1
94605: PPUSH
94606: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94610: LD_INT 35
94612: PPUSH
94613: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94617: LD_VAR 0 2
94621: PPUSH
94622: LD_INT 22
94624: PUSH
94625: LD_OWVAR 2
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PPUSH
94634: CALL_OW 69
94638: PPUSH
94639: LD_VAR 0 2
94643: PPUSH
94644: CALL_OW 74
94648: PPUSH
94649: CALL_OW 115
// until IsDead ( un ) ;
94653: LD_VAR 0 2
94657: PPUSH
94658: CALL_OW 301
94662: IFFALSE 94610
// end ;
94664: PPOPN 2
94666: END
// every 0 0$1 trigger StreamModeActive and sStu do
94667: LD_EXP 112
94671: PUSH
94672: LD_EXP 151
94676: AND
94677: IFFALSE 94693
94679: GO 94681
94681: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94682: LD_STRING displayStucuk();
94684: PPUSH
94685: CALL_OW 559
// ResetFog ;
94689: CALL_OW 335
// end ;
94693: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94694: LD_EXP 112
94698: PUSH
94699: LD_EXP 144
94703: AND
94704: IFFALSE 94845
94706: GO 94708
94708: DISABLE
94709: LD_INT 0
94711: PPUSH
94712: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94713: LD_ADDR_VAR 0 2
94717: PUSH
94718: LD_INT 22
94720: PUSH
94721: LD_OWVAR 2
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 21
94732: PUSH
94733: LD_INT 1
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PPUSH
94744: CALL_OW 69
94748: ST_TO_ADDR
// if not tmp then
94749: LD_VAR 0 2
94753: NOT
94754: IFFALSE 94758
// exit ;
94756: GO 94845
// un := tmp [ rand ( 1 , tmp ) ] ;
94758: LD_ADDR_VAR 0 1
94762: PUSH
94763: LD_VAR 0 2
94767: PUSH
94768: LD_INT 1
94770: PPUSH
94771: LD_VAR 0 2
94775: PPUSH
94776: CALL_OW 12
94780: ARRAY
94781: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94782: LD_VAR 0 1
94786: PPUSH
94787: LD_INT 0
94789: PPUSH
94790: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94794: LD_VAR 0 1
94798: PPUSH
94799: LD_OWVAR 3
94803: PUSH
94804: LD_VAR 0 1
94808: DIFF
94809: PPUSH
94810: LD_VAR 0 1
94814: PPUSH
94815: CALL_OW 74
94819: PPUSH
94820: CALL_OW 115
// wait ( 0 0$20 ) ;
94824: LD_INT 700
94826: PPUSH
94827: CALL_OW 67
// SetSide ( un , your_side ) ;
94831: LD_VAR 0 1
94835: PPUSH
94836: LD_OWVAR 2
94840: PPUSH
94841: CALL_OW 235
// end ;
94845: PPOPN 2
94847: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94848: LD_EXP 112
94852: PUSH
94853: LD_EXP 145
94857: AND
94858: IFFALSE 94964
94860: GO 94862
94862: DISABLE
94863: LD_INT 0
94865: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94866: LD_ADDR_VAR 0 1
94870: PUSH
94871: LD_INT 22
94873: PUSH
94874: LD_OWVAR 2
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 2
94885: PUSH
94886: LD_INT 30
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 30
94898: PUSH
94899: LD_INT 1
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: LIST
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PPUSH
94915: CALL_OW 69
94919: ST_TO_ADDR
// if not depot then
94920: LD_VAR 0 1
94924: NOT
94925: IFFALSE 94929
// exit ;
94927: GO 94964
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
94929: LD_VAR 0 1
94933: PUSH
94934: LD_INT 1
94936: ARRAY
94937: PPUSH
94938: CALL_OW 250
94942: PPUSH
94943: LD_VAR 0 1
94947: PUSH
94948: LD_INT 1
94950: ARRAY
94951: PPUSH
94952: CALL_OW 251
94956: PPUSH
94957: LD_INT 70
94959: PPUSH
94960: CALL_OW 495
// end ;
94964: PPOPN 1
94966: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
94967: LD_EXP 112
94971: PUSH
94972: LD_EXP 146
94976: AND
94977: IFFALSE 95188
94979: GO 94981
94981: DISABLE
94982: LD_INT 0
94984: PPUSH
94985: PPUSH
94986: PPUSH
94987: PPUSH
94988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94989: LD_ADDR_VAR 0 5
94993: PUSH
94994: LD_INT 22
94996: PUSH
94997: LD_OWVAR 2
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 21
95008: PUSH
95009: LD_INT 1
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PPUSH
95020: CALL_OW 69
95024: ST_TO_ADDR
// if not tmp then
95025: LD_VAR 0 5
95029: NOT
95030: IFFALSE 95034
// exit ;
95032: GO 95188
// for i in tmp do
95034: LD_ADDR_VAR 0 1
95038: PUSH
95039: LD_VAR 0 5
95043: PUSH
95044: FOR_IN
95045: IFFALSE 95186
// begin d := rand ( 0 , 5 ) ;
95047: LD_ADDR_VAR 0 4
95051: PUSH
95052: LD_INT 0
95054: PPUSH
95055: LD_INT 5
95057: PPUSH
95058: CALL_OW 12
95062: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95063: LD_ADDR_VAR 0 2
95067: PUSH
95068: LD_VAR 0 1
95072: PPUSH
95073: CALL_OW 250
95077: PPUSH
95078: LD_VAR 0 4
95082: PPUSH
95083: LD_INT 3
95085: PPUSH
95086: LD_INT 12
95088: PPUSH
95089: CALL_OW 12
95093: PPUSH
95094: CALL_OW 272
95098: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95099: LD_ADDR_VAR 0 3
95103: PUSH
95104: LD_VAR 0 1
95108: PPUSH
95109: CALL_OW 251
95113: PPUSH
95114: LD_VAR 0 4
95118: PPUSH
95119: LD_INT 3
95121: PPUSH
95122: LD_INT 12
95124: PPUSH
95125: CALL_OW 12
95129: PPUSH
95130: CALL_OW 273
95134: ST_TO_ADDR
// if ValidHex ( x , y ) then
95135: LD_VAR 0 2
95139: PPUSH
95140: LD_VAR 0 3
95144: PPUSH
95145: CALL_OW 488
95149: IFFALSE 95184
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95151: LD_VAR 0 1
95155: PPUSH
95156: LD_VAR 0 2
95160: PPUSH
95161: LD_VAR 0 3
95165: PPUSH
95166: LD_INT 3
95168: PPUSH
95169: LD_INT 6
95171: PPUSH
95172: CALL_OW 12
95176: PPUSH
95177: LD_INT 1
95179: PPUSH
95180: CALL_OW 483
// end ;
95184: GO 95044
95186: POP
95187: POP
// end ;
95188: PPOPN 5
95190: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95191: LD_EXP 112
95195: PUSH
95196: LD_EXP 147
95200: AND
95201: IFFALSE 95295
95203: GO 95205
95205: DISABLE
95206: LD_INT 0
95208: PPUSH
95209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95210: LD_ADDR_VAR 0 2
95214: PUSH
95215: LD_INT 22
95217: PUSH
95218: LD_OWVAR 2
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 32
95229: PUSH
95230: LD_INT 1
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 21
95239: PUSH
95240: LD_INT 2
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: LIST
95251: PPUSH
95252: CALL_OW 69
95256: ST_TO_ADDR
// if not tmp then
95257: LD_VAR 0 2
95261: NOT
95262: IFFALSE 95266
// exit ;
95264: GO 95295
// for i in tmp do
95266: LD_ADDR_VAR 0 1
95270: PUSH
95271: LD_VAR 0 2
95275: PUSH
95276: FOR_IN
95277: IFFALSE 95293
// SetFuel ( i , 0 ) ;
95279: LD_VAR 0 1
95283: PPUSH
95284: LD_INT 0
95286: PPUSH
95287: CALL_OW 240
95291: GO 95276
95293: POP
95294: POP
// end ;
95295: PPOPN 2
95297: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95298: LD_EXP 112
95302: PUSH
95303: LD_EXP 148
95307: AND
95308: IFFALSE 95374
95310: GO 95312
95312: DISABLE
95313: LD_INT 0
95315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95316: LD_ADDR_VAR 0 1
95320: PUSH
95321: LD_INT 22
95323: PUSH
95324: LD_OWVAR 2
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: PUSH
95333: LD_INT 30
95335: PUSH
95336: LD_INT 29
95338: PUSH
95339: EMPTY
95340: LIST
95341: LIST
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PPUSH
95347: CALL_OW 69
95351: ST_TO_ADDR
// if not tmp then
95352: LD_VAR 0 1
95356: NOT
95357: IFFALSE 95361
// exit ;
95359: GO 95374
// DestroyUnit ( tmp [ 1 ] ) ;
95361: LD_VAR 0 1
95365: PUSH
95366: LD_INT 1
95368: ARRAY
95369: PPUSH
95370: CALL_OW 65
// end ;
95374: PPOPN 1
95376: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95377: LD_EXP 112
95381: PUSH
95382: LD_EXP 150
95386: AND
95387: IFFALSE 95516
95389: GO 95391
95391: DISABLE
95392: LD_INT 0
95394: PPUSH
// begin uc_side := 0 ;
95395: LD_ADDR_OWVAR 20
95399: PUSH
95400: LD_INT 0
95402: ST_TO_ADDR
// uc_nation := nation_arabian ;
95403: LD_ADDR_OWVAR 21
95407: PUSH
95408: LD_INT 2
95410: ST_TO_ADDR
// hc_gallery :=  ;
95411: LD_ADDR_OWVAR 33
95415: PUSH
95416: LD_STRING 
95418: ST_TO_ADDR
// hc_name :=  ;
95419: LD_ADDR_OWVAR 26
95423: PUSH
95424: LD_STRING 
95426: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95427: LD_INT 1
95429: PPUSH
95430: LD_INT 11
95432: PPUSH
95433: LD_INT 10
95435: PPUSH
95436: CALL_OW 380
// un := CreateHuman ;
95440: LD_ADDR_VAR 0 1
95444: PUSH
95445: CALL_OW 44
95449: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95450: LD_VAR 0 1
95454: PPUSH
95455: LD_INT 1
95457: PPUSH
95458: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95462: LD_INT 35
95464: PPUSH
95465: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95469: LD_VAR 0 1
95473: PPUSH
95474: LD_INT 22
95476: PUSH
95477: LD_OWVAR 2
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PPUSH
95486: CALL_OW 69
95490: PPUSH
95491: LD_VAR 0 1
95495: PPUSH
95496: CALL_OW 74
95500: PPUSH
95501: CALL_OW 115
// until IsDead ( un ) ;
95505: LD_VAR 0 1
95509: PPUSH
95510: CALL_OW 301
95514: IFFALSE 95462
// end ;
95516: PPOPN 1
95518: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95519: LD_EXP 112
95523: PUSH
95524: LD_EXP 152
95528: AND
95529: IFFALSE 95541
95531: GO 95533
95533: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95534: LD_STRING earthquake(getX(game), 0, 32)
95536: PPUSH
95537: CALL_OW 559
95541: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95542: LD_EXP 112
95546: PUSH
95547: LD_EXP 153
95551: AND
95552: IFFALSE 95643
95554: GO 95556
95556: DISABLE
95557: LD_INT 0
95559: PPUSH
// begin enable ;
95560: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95561: LD_ADDR_VAR 0 1
95565: PUSH
95566: LD_INT 22
95568: PUSH
95569: LD_OWVAR 2
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: LD_INT 21
95580: PUSH
95581: LD_INT 2
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: LD_INT 33
95590: PUSH
95591: LD_INT 3
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: EMPTY
95599: LIST
95600: LIST
95601: LIST
95602: PPUSH
95603: CALL_OW 69
95607: ST_TO_ADDR
// if not tmp then
95608: LD_VAR 0 1
95612: NOT
95613: IFFALSE 95617
// exit ;
95615: GO 95643
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95617: LD_VAR 0 1
95621: PUSH
95622: LD_INT 1
95624: PPUSH
95625: LD_VAR 0 1
95629: PPUSH
95630: CALL_OW 12
95634: ARRAY
95635: PPUSH
95636: LD_INT 1
95638: PPUSH
95639: CALL_OW 234
// end ;
95643: PPOPN 1
95645: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95646: LD_EXP 112
95650: PUSH
95651: LD_EXP 154
95655: AND
95656: IFFALSE 95797
95658: GO 95660
95660: DISABLE
95661: LD_INT 0
95663: PPUSH
95664: PPUSH
95665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95666: LD_ADDR_VAR 0 3
95670: PUSH
95671: LD_INT 22
95673: PUSH
95674: LD_OWVAR 2
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 25
95685: PUSH
95686: LD_INT 1
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: PPUSH
95697: CALL_OW 69
95701: ST_TO_ADDR
// if not tmp then
95702: LD_VAR 0 3
95706: NOT
95707: IFFALSE 95711
// exit ;
95709: GO 95797
// un := tmp [ rand ( 1 , tmp ) ] ;
95711: LD_ADDR_VAR 0 2
95715: PUSH
95716: LD_VAR 0 3
95720: PUSH
95721: LD_INT 1
95723: PPUSH
95724: LD_VAR 0 3
95728: PPUSH
95729: CALL_OW 12
95733: ARRAY
95734: ST_TO_ADDR
// if Crawls ( un ) then
95735: LD_VAR 0 2
95739: PPUSH
95740: CALL_OW 318
95744: IFFALSE 95755
// ComWalk ( un ) ;
95746: LD_VAR 0 2
95750: PPUSH
95751: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95755: LD_VAR 0 2
95759: PPUSH
95760: LD_INT 9
95762: PPUSH
95763: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95767: LD_INT 28
95769: PPUSH
95770: LD_OWVAR 2
95774: PPUSH
95775: LD_INT 2
95777: PPUSH
95778: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95782: LD_INT 29
95784: PPUSH
95785: LD_OWVAR 2
95789: PPUSH
95790: LD_INT 2
95792: PPUSH
95793: CALL_OW 322
// end ;
95797: PPOPN 3
95799: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95800: LD_EXP 112
95804: PUSH
95805: LD_EXP 155
95809: AND
95810: IFFALSE 95921
95812: GO 95814
95814: DISABLE
95815: LD_INT 0
95817: PPUSH
95818: PPUSH
95819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95820: LD_ADDR_VAR 0 3
95824: PUSH
95825: LD_INT 22
95827: PUSH
95828: LD_OWVAR 2
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 25
95839: PUSH
95840: LD_INT 1
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PPUSH
95851: CALL_OW 69
95855: ST_TO_ADDR
// if not tmp then
95856: LD_VAR 0 3
95860: NOT
95861: IFFALSE 95865
// exit ;
95863: GO 95921
// un := tmp [ rand ( 1 , tmp ) ] ;
95865: LD_ADDR_VAR 0 2
95869: PUSH
95870: LD_VAR 0 3
95874: PUSH
95875: LD_INT 1
95877: PPUSH
95878: LD_VAR 0 3
95882: PPUSH
95883: CALL_OW 12
95887: ARRAY
95888: ST_TO_ADDR
// if Crawls ( un ) then
95889: LD_VAR 0 2
95893: PPUSH
95894: CALL_OW 318
95898: IFFALSE 95909
// ComWalk ( un ) ;
95900: LD_VAR 0 2
95904: PPUSH
95905: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95909: LD_VAR 0 2
95913: PPUSH
95914: LD_INT 8
95916: PPUSH
95917: CALL_OW 336
// end ;
95921: PPOPN 3
95923: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
95924: LD_EXP 112
95928: PUSH
95929: LD_EXP 156
95933: AND
95934: IFFALSE 96078
95936: GO 95938
95938: DISABLE
95939: LD_INT 0
95941: PPUSH
95942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
95943: LD_ADDR_VAR 0 2
95947: PUSH
95948: LD_INT 22
95950: PUSH
95951: LD_OWVAR 2
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 21
95962: PUSH
95963: LD_INT 2
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: LD_INT 34
95975: PUSH
95976: LD_INT 12
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 34
95985: PUSH
95986: LD_INT 51
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 34
95995: PUSH
95996: LD_INT 32
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: EMPTY
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: LIST
96013: PPUSH
96014: CALL_OW 69
96018: ST_TO_ADDR
// if not tmp then
96019: LD_VAR 0 2
96023: NOT
96024: IFFALSE 96028
// exit ;
96026: GO 96078
// for i in tmp do
96028: LD_ADDR_VAR 0 1
96032: PUSH
96033: LD_VAR 0 2
96037: PUSH
96038: FOR_IN
96039: IFFALSE 96076
// if GetCargo ( i , mat_artifact ) = 0 then
96041: LD_VAR 0 1
96045: PPUSH
96046: LD_INT 4
96048: PPUSH
96049: CALL_OW 289
96053: PUSH
96054: LD_INT 0
96056: EQUAL
96057: IFFALSE 96074
// SetCargo ( i , mat_siberit , 100 ) ;
96059: LD_VAR 0 1
96063: PPUSH
96064: LD_INT 3
96066: PPUSH
96067: LD_INT 100
96069: PPUSH
96070: CALL_OW 290
96074: GO 96038
96076: POP
96077: POP
// end ;
96078: PPOPN 2
96080: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96081: LD_EXP 112
96085: PUSH
96086: LD_EXP 157
96090: AND
96091: IFFALSE 96274
96093: GO 96095
96095: DISABLE
96096: LD_INT 0
96098: PPUSH
96099: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96100: LD_ADDR_VAR 0 2
96104: PUSH
96105: LD_INT 22
96107: PUSH
96108: LD_OWVAR 2
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PPUSH
96117: CALL_OW 69
96121: ST_TO_ADDR
// if not tmp then
96122: LD_VAR 0 2
96126: NOT
96127: IFFALSE 96131
// exit ;
96129: GO 96274
// for i := 1 to 2 do
96131: LD_ADDR_VAR 0 1
96135: PUSH
96136: DOUBLE
96137: LD_INT 1
96139: DEC
96140: ST_TO_ADDR
96141: LD_INT 2
96143: PUSH
96144: FOR_TO
96145: IFFALSE 96272
// begin uc_side := your_side ;
96147: LD_ADDR_OWVAR 20
96151: PUSH
96152: LD_OWVAR 2
96156: ST_TO_ADDR
// uc_nation := nation_american ;
96157: LD_ADDR_OWVAR 21
96161: PUSH
96162: LD_INT 1
96164: ST_TO_ADDR
// vc_chassis := us_morphling ;
96165: LD_ADDR_OWVAR 37
96169: PUSH
96170: LD_INT 5
96172: ST_TO_ADDR
// vc_engine := engine_siberite ;
96173: LD_ADDR_OWVAR 39
96177: PUSH
96178: LD_INT 3
96180: ST_TO_ADDR
// vc_control := control_computer ;
96181: LD_ADDR_OWVAR 38
96185: PUSH
96186: LD_INT 3
96188: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96189: LD_ADDR_OWVAR 40
96193: PUSH
96194: LD_INT 10
96196: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96197: LD_VAR 0 2
96201: PUSH
96202: LD_INT 1
96204: ARRAY
96205: PPUSH
96206: CALL_OW 310
96210: NOT
96211: IFFALSE 96258
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96213: CALL_OW 45
96217: PPUSH
96218: LD_VAR 0 2
96222: PUSH
96223: LD_INT 1
96225: ARRAY
96226: PPUSH
96227: CALL_OW 250
96231: PPUSH
96232: LD_VAR 0 2
96236: PUSH
96237: LD_INT 1
96239: ARRAY
96240: PPUSH
96241: CALL_OW 251
96245: PPUSH
96246: LD_INT 12
96248: PPUSH
96249: LD_INT 1
96251: PPUSH
96252: CALL_OW 50
96256: GO 96270
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96258: CALL_OW 45
96262: PPUSH
96263: LD_INT 1
96265: PPUSH
96266: CALL_OW 51
// end ;
96270: GO 96144
96272: POP
96273: POP
// end ;
96274: PPOPN 2
96276: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96277: LD_EXP 112
96281: PUSH
96282: LD_EXP 158
96286: AND
96287: IFFALSE 96509
96289: GO 96291
96291: DISABLE
96292: LD_INT 0
96294: PPUSH
96295: PPUSH
96296: PPUSH
96297: PPUSH
96298: PPUSH
96299: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96300: LD_ADDR_VAR 0 6
96304: PUSH
96305: LD_INT 22
96307: PUSH
96308: LD_OWVAR 2
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: PUSH
96317: LD_INT 21
96319: PUSH
96320: LD_INT 1
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 3
96329: PUSH
96330: LD_INT 23
96332: PUSH
96333: LD_INT 0
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: EMPTY
96345: LIST
96346: LIST
96347: LIST
96348: PPUSH
96349: CALL_OW 69
96353: ST_TO_ADDR
// if not tmp then
96354: LD_VAR 0 6
96358: NOT
96359: IFFALSE 96363
// exit ;
96361: GO 96509
// s1 := rand ( 1 , 4 ) ;
96363: LD_ADDR_VAR 0 2
96367: PUSH
96368: LD_INT 1
96370: PPUSH
96371: LD_INT 4
96373: PPUSH
96374: CALL_OW 12
96378: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96379: LD_ADDR_VAR 0 4
96383: PUSH
96384: LD_VAR 0 6
96388: PUSH
96389: LD_INT 1
96391: ARRAY
96392: PPUSH
96393: LD_VAR 0 2
96397: PPUSH
96398: CALL_OW 259
96402: ST_TO_ADDR
// if s1 = 1 then
96403: LD_VAR 0 2
96407: PUSH
96408: LD_INT 1
96410: EQUAL
96411: IFFALSE 96431
// s2 := rand ( 2 , 4 ) else
96413: LD_ADDR_VAR 0 3
96417: PUSH
96418: LD_INT 2
96420: PPUSH
96421: LD_INT 4
96423: PPUSH
96424: CALL_OW 12
96428: ST_TO_ADDR
96429: GO 96439
// s2 := 1 ;
96431: LD_ADDR_VAR 0 3
96435: PUSH
96436: LD_INT 1
96438: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96439: LD_ADDR_VAR 0 5
96443: PUSH
96444: LD_VAR 0 6
96448: PUSH
96449: LD_INT 1
96451: ARRAY
96452: PPUSH
96453: LD_VAR 0 3
96457: PPUSH
96458: CALL_OW 259
96462: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96463: LD_VAR 0 6
96467: PUSH
96468: LD_INT 1
96470: ARRAY
96471: PPUSH
96472: LD_VAR 0 2
96476: PPUSH
96477: LD_VAR 0 5
96481: PPUSH
96482: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96486: LD_VAR 0 6
96490: PUSH
96491: LD_INT 1
96493: ARRAY
96494: PPUSH
96495: LD_VAR 0 3
96499: PPUSH
96500: LD_VAR 0 4
96504: PPUSH
96505: CALL_OW 237
// end ;
96509: PPOPN 6
96511: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96512: LD_EXP 112
96516: PUSH
96517: LD_EXP 159
96521: AND
96522: IFFALSE 96601
96524: GO 96526
96526: DISABLE
96527: LD_INT 0
96529: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96530: LD_ADDR_VAR 0 1
96534: PUSH
96535: LD_INT 22
96537: PUSH
96538: LD_OWVAR 2
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PUSH
96547: LD_INT 30
96549: PUSH
96550: LD_INT 3
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PPUSH
96561: CALL_OW 69
96565: ST_TO_ADDR
// if not tmp then
96566: LD_VAR 0 1
96570: NOT
96571: IFFALSE 96575
// exit ;
96573: GO 96601
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96575: LD_VAR 0 1
96579: PUSH
96580: LD_INT 1
96582: PPUSH
96583: LD_VAR 0 1
96587: PPUSH
96588: CALL_OW 12
96592: ARRAY
96593: PPUSH
96594: LD_INT 1
96596: PPUSH
96597: CALL_OW 234
// end ;
96601: PPOPN 1
96603: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96604: LD_EXP 112
96608: PUSH
96609: LD_EXP 160
96613: AND
96614: IFFALSE 96726
96616: GO 96618
96618: DISABLE
96619: LD_INT 0
96621: PPUSH
96622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96623: LD_ADDR_VAR 0 2
96627: PUSH
96628: LD_INT 22
96630: PUSH
96631: LD_OWVAR 2
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 2
96642: PUSH
96643: LD_INT 30
96645: PUSH
96646: LD_INT 27
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 30
96655: PUSH
96656: LD_INT 26
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 30
96665: PUSH
96666: LD_INT 28
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: EMPTY
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: PPUSH
96683: CALL_OW 69
96687: ST_TO_ADDR
// if not tmp then
96688: LD_VAR 0 2
96692: NOT
96693: IFFALSE 96697
// exit ;
96695: GO 96726
// for i in tmp do
96697: LD_ADDR_VAR 0 1
96701: PUSH
96702: LD_VAR 0 2
96706: PUSH
96707: FOR_IN
96708: IFFALSE 96724
// SetLives ( i , 1 ) ;
96710: LD_VAR 0 1
96714: PPUSH
96715: LD_INT 1
96717: PPUSH
96718: CALL_OW 234
96722: GO 96707
96724: POP
96725: POP
// end ;
96726: PPOPN 2
96728: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96729: LD_EXP 112
96733: PUSH
96734: LD_EXP 161
96738: AND
96739: IFFALSE 97026
96741: GO 96743
96743: DISABLE
96744: LD_INT 0
96746: PPUSH
96747: PPUSH
96748: PPUSH
// begin i := rand ( 1 , 7 ) ;
96749: LD_ADDR_VAR 0 1
96753: PUSH
96754: LD_INT 1
96756: PPUSH
96757: LD_INT 7
96759: PPUSH
96760: CALL_OW 12
96764: ST_TO_ADDR
// case i of 1 :
96765: LD_VAR 0 1
96769: PUSH
96770: LD_INT 1
96772: DOUBLE
96773: EQUAL
96774: IFTRUE 96778
96776: GO 96788
96778: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96779: LD_STRING earthquake(getX(game), 0, 32)
96781: PPUSH
96782: CALL_OW 559
96786: GO 97026
96788: LD_INT 2
96790: DOUBLE
96791: EQUAL
96792: IFTRUE 96796
96794: GO 96810
96796: POP
// begin ToLua ( displayStucuk(); ) ;
96797: LD_STRING displayStucuk();
96799: PPUSH
96800: CALL_OW 559
// ResetFog ;
96804: CALL_OW 335
// end ; 3 :
96808: GO 97026
96810: LD_INT 3
96812: DOUBLE
96813: EQUAL
96814: IFTRUE 96818
96816: GO 96922
96818: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96819: LD_ADDR_VAR 0 2
96823: PUSH
96824: LD_INT 22
96826: PUSH
96827: LD_OWVAR 2
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 25
96838: PUSH
96839: LD_INT 1
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: EMPTY
96847: LIST
96848: LIST
96849: PPUSH
96850: CALL_OW 69
96854: ST_TO_ADDR
// if not tmp then
96855: LD_VAR 0 2
96859: NOT
96860: IFFALSE 96864
// exit ;
96862: GO 97026
// un := tmp [ rand ( 1 , tmp ) ] ;
96864: LD_ADDR_VAR 0 3
96868: PUSH
96869: LD_VAR 0 2
96873: PUSH
96874: LD_INT 1
96876: PPUSH
96877: LD_VAR 0 2
96881: PPUSH
96882: CALL_OW 12
96886: ARRAY
96887: ST_TO_ADDR
// if Crawls ( un ) then
96888: LD_VAR 0 3
96892: PPUSH
96893: CALL_OW 318
96897: IFFALSE 96908
// ComWalk ( un ) ;
96899: LD_VAR 0 3
96903: PPUSH
96904: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96908: LD_VAR 0 3
96912: PPUSH
96913: LD_INT 8
96915: PPUSH
96916: CALL_OW 336
// end ; 4 :
96920: GO 97026
96922: LD_INT 4
96924: DOUBLE
96925: EQUAL
96926: IFTRUE 96930
96928: GO 97004
96930: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96931: LD_ADDR_VAR 0 2
96935: PUSH
96936: LD_INT 22
96938: PUSH
96939: LD_OWVAR 2
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: PUSH
96948: LD_INT 30
96950: PUSH
96951: LD_INT 29
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: EMPTY
96959: LIST
96960: LIST
96961: PPUSH
96962: CALL_OW 69
96966: ST_TO_ADDR
// if not tmp then
96967: LD_VAR 0 2
96971: NOT
96972: IFFALSE 96976
// exit ;
96974: GO 97026
// CenterNowOnUnits ( tmp [ 1 ] ) ;
96976: LD_VAR 0 2
96980: PUSH
96981: LD_INT 1
96983: ARRAY
96984: PPUSH
96985: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
96989: LD_VAR 0 2
96993: PUSH
96994: LD_INT 1
96996: ARRAY
96997: PPUSH
96998: CALL_OW 65
// end ; 5 .. 7 :
97002: GO 97026
97004: LD_INT 5
97006: DOUBLE
97007: GREATEREQUAL
97008: IFFALSE 97016
97010: LD_INT 7
97012: DOUBLE
97013: LESSEQUAL
97014: IFTRUE 97018
97016: GO 97025
97018: POP
// StreamSibBomb ; end ;
97019: CALL 93263 0 0
97023: GO 97026
97025: POP
// end ;
97026: PPOPN 3
97028: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97029: LD_EXP 112
97033: PUSH
97034: LD_EXP 162
97038: AND
97039: IFFALSE 97195
97041: GO 97043
97043: DISABLE
97044: LD_INT 0
97046: PPUSH
97047: PPUSH
97048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97049: LD_ADDR_VAR 0 2
97053: PUSH
97054: LD_INT 81
97056: PUSH
97057: LD_OWVAR 2
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 2
97068: PUSH
97069: LD_INT 21
97071: PUSH
97072: LD_INT 1
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 21
97081: PUSH
97082: LD_INT 2
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: LIST
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: PPUSH
97098: CALL_OW 69
97102: ST_TO_ADDR
// if not tmp then
97103: LD_VAR 0 2
97107: NOT
97108: IFFALSE 97112
// exit ;
97110: GO 97195
// p := 0 ;
97112: LD_ADDR_VAR 0 3
97116: PUSH
97117: LD_INT 0
97119: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97120: LD_INT 35
97122: PPUSH
97123: CALL_OW 67
// p := p + 1 ;
97127: LD_ADDR_VAR 0 3
97131: PUSH
97132: LD_VAR 0 3
97136: PUSH
97137: LD_INT 1
97139: PLUS
97140: ST_TO_ADDR
// for i in tmp do
97141: LD_ADDR_VAR 0 1
97145: PUSH
97146: LD_VAR 0 2
97150: PUSH
97151: FOR_IN
97152: IFFALSE 97183
// if GetLives ( i ) < 1000 then
97154: LD_VAR 0 1
97158: PPUSH
97159: CALL_OW 256
97163: PUSH
97164: LD_INT 1000
97166: LESS
97167: IFFALSE 97181
// SetLives ( i , 1000 ) ;
97169: LD_VAR 0 1
97173: PPUSH
97174: LD_INT 1000
97176: PPUSH
97177: CALL_OW 234
97181: GO 97151
97183: POP
97184: POP
// until p > 20 ;
97185: LD_VAR 0 3
97189: PUSH
97190: LD_INT 20
97192: GREATER
97193: IFFALSE 97120
// end ;
97195: PPOPN 3
97197: END
// every 0 0$1 trigger StreamModeActive and sTime do
97198: LD_EXP 112
97202: PUSH
97203: LD_EXP 163
97207: AND
97208: IFFALSE 97243
97210: GO 97212
97212: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97213: LD_INT 28
97215: PPUSH
97216: LD_OWVAR 2
97220: PPUSH
97221: LD_INT 2
97223: PPUSH
97224: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97228: LD_INT 30
97230: PPUSH
97231: LD_OWVAR 2
97235: PPUSH
97236: LD_INT 2
97238: PPUSH
97239: CALL_OW 322
// end ;
97243: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97244: LD_EXP 112
97248: PUSH
97249: LD_EXP 164
97253: AND
97254: IFFALSE 97375
97256: GO 97258
97258: DISABLE
97259: LD_INT 0
97261: PPUSH
97262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97263: LD_ADDR_VAR 0 2
97267: PUSH
97268: LD_INT 22
97270: PUSH
97271: LD_OWVAR 2
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 21
97282: PUSH
97283: LD_INT 1
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 3
97292: PUSH
97293: LD_INT 23
97295: PUSH
97296: LD_INT 0
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: EMPTY
97308: LIST
97309: LIST
97310: LIST
97311: PPUSH
97312: CALL_OW 69
97316: ST_TO_ADDR
// if not tmp then
97317: LD_VAR 0 2
97321: NOT
97322: IFFALSE 97326
// exit ;
97324: GO 97375
// for i in tmp do
97326: LD_ADDR_VAR 0 1
97330: PUSH
97331: LD_VAR 0 2
97335: PUSH
97336: FOR_IN
97337: IFFALSE 97373
// begin if Crawls ( i ) then
97339: LD_VAR 0 1
97343: PPUSH
97344: CALL_OW 318
97348: IFFALSE 97359
// ComWalk ( i ) ;
97350: LD_VAR 0 1
97354: PPUSH
97355: CALL_OW 138
// SetClass ( i , 2 ) ;
97359: LD_VAR 0 1
97363: PPUSH
97364: LD_INT 2
97366: PPUSH
97367: CALL_OW 336
// end ;
97371: GO 97336
97373: POP
97374: POP
// end ;
97375: PPOPN 2
97377: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97378: LD_EXP 112
97382: PUSH
97383: LD_EXP 165
97387: AND
97388: IFFALSE 97676
97390: GO 97392
97392: DISABLE
97393: LD_INT 0
97395: PPUSH
97396: PPUSH
97397: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97398: LD_OWVAR 2
97402: PPUSH
97403: LD_INT 9
97405: PPUSH
97406: LD_INT 1
97408: PPUSH
97409: LD_INT 1
97411: PPUSH
97412: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97416: LD_INT 9
97418: PPUSH
97419: LD_OWVAR 2
97423: PPUSH
97424: CALL_OW 343
// uc_side := 9 ;
97428: LD_ADDR_OWVAR 20
97432: PUSH
97433: LD_INT 9
97435: ST_TO_ADDR
// uc_nation := 2 ;
97436: LD_ADDR_OWVAR 21
97440: PUSH
97441: LD_INT 2
97443: ST_TO_ADDR
// hc_name := Dark Warrior ;
97444: LD_ADDR_OWVAR 26
97448: PUSH
97449: LD_STRING Dark Warrior
97451: ST_TO_ADDR
// hc_gallery :=  ;
97452: LD_ADDR_OWVAR 33
97456: PUSH
97457: LD_STRING 
97459: ST_TO_ADDR
// hc_noskilllimit := true ;
97460: LD_ADDR_OWVAR 76
97464: PUSH
97465: LD_INT 1
97467: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97468: LD_ADDR_OWVAR 31
97472: PUSH
97473: LD_INT 30
97475: PUSH
97476: LD_INT 30
97478: PUSH
97479: LD_INT 30
97481: PUSH
97482: LD_INT 30
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: ST_TO_ADDR
// un := CreateHuman ;
97491: LD_ADDR_VAR 0 3
97495: PUSH
97496: CALL_OW 44
97500: ST_TO_ADDR
// hc_noskilllimit := false ;
97501: LD_ADDR_OWVAR 76
97505: PUSH
97506: LD_INT 0
97508: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97509: LD_VAR 0 3
97513: PPUSH
97514: LD_INT 1
97516: PPUSH
97517: CALL_OW 51
// ToLua ( playRanger() ) ;
97521: LD_STRING playRanger()
97523: PPUSH
97524: CALL_OW 559
// p := 0 ;
97528: LD_ADDR_VAR 0 2
97532: PUSH
97533: LD_INT 0
97535: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97536: LD_INT 35
97538: PPUSH
97539: CALL_OW 67
// p := p + 1 ;
97543: LD_ADDR_VAR 0 2
97547: PUSH
97548: LD_VAR 0 2
97552: PUSH
97553: LD_INT 1
97555: PLUS
97556: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97557: LD_VAR 0 3
97561: PPUSH
97562: CALL_OW 256
97566: PUSH
97567: LD_INT 1000
97569: LESS
97570: IFFALSE 97584
// SetLives ( un , 1000 ) ;
97572: LD_VAR 0 3
97576: PPUSH
97577: LD_INT 1000
97579: PPUSH
97580: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97584: LD_VAR 0 3
97588: PPUSH
97589: LD_INT 81
97591: PUSH
97592: LD_OWVAR 2
97596: PUSH
97597: EMPTY
97598: LIST
97599: LIST
97600: PUSH
97601: LD_INT 91
97603: PUSH
97604: LD_VAR 0 3
97608: PUSH
97609: LD_INT 30
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: LIST
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PPUSH
97621: CALL_OW 69
97625: PPUSH
97626: LD_VAR 0 3
97630: PPUSH
97631: CALL_OW 74
97635: PPUSH
97636: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
97640: LD_VAR 0 2
97644: PUSH
97645: LD_INT 80
97647: GREATER
97648: PUSH
97649: LD_VAR 0 3
97653: PPUSH
97654: CALL_OW 301
97658: OR
97659: IFFALSE 97536
// if un then
97661: LD_VAR 0 3
97665: IFFALSE 97676
// RemoveUnit ( un ) ;
97667: LD_VAR 0 3
97671: PPUSH
97672: CALL_OW 64
// end ;
97676: PPOPN 3
97678: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
97679: LD_EXP 166
97683: IFFALSE 97799
97685: GO 97687
97687: DISABLE
97688: LD_INT 0
97690: PPUSH
97691: PPUSH
97692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97693: LD_ADDR_VAR 0 2
97697: PUSH
97698: LD_INT 81
97700: PUSH
97701: LD_OWVAR 2
97705: PUSH
97706: EMPTY
97707: LIST
97708: LIST
97709: PUSH
97710: LD_INT 21
97712: PUSH
97713: LD_INT 1
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PPUSH
97724: CALL_OW 69
97728: ST_TO_ADDR
// ToLua ( playComputer() ) ;
97729: LD_STRING playComputer()
97731: PPUSH
97732: CALL_OW 559
// if not tmp then
97736: LD_VAR 0 2
97740: NOT
97741: IFFALSE 97745
// exit ;
97743: GO 97799
// for i in tmp do
97745: LD_ADDR_VAR 0 1
97749: PUSH
97750: LD_VAR 0 2
97754: PUSH
97755: FOR_IN
97756: IFFALSE 97797
// for j := 1 to 4 do
97758: LD_ADDR_VAR 0 3
97762: PUSH
97763: DOUBLE
97764: LD_INT 1
97766: DEC
97767: ST_TO_ADDR
97768: LD_INT 4
97770: PUSH
97771: FOR_TO
97772: IFFALSE 97793
// SetSkill ( i , j , 10 ) ;
97774: LD_VAR 0 1
97778: PPUSH
97779: LD_VAR 0 3
97783: PPUSH
97784: LD_INT 10
97786: PPUSH
97787: CALL_OW 237
97791: GO 97771
97793: POP
97794: POP
97795: GO 97755
97797: POP
97798: POP
// end ;
97799: PPOPN 3
97801: END
// every 0 0$1 trigger s30 do var i , tmp ;
97802: LD_EXP 167
97806: IFFALSE 97875
97808: GO 97810
97810: DISABLE
97811: LD_INT 0
97813: PPUSH
97814: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97815: LD_ADDR_VAR 0 2
97819: PUSH
97820: LD_INT 22
97822: PUSH
97823: LD_OWVAR 2
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PPUSH
97832: CALL_OW 69
97836: ST_TO_ADDR
// if not tmp then
97837: LD_VAR 0 2
97841: NOT
97842: IFFALSE 97846
// exit ;
97844: GO 97875
// for i in tmp do
97846: LD_ADDR_VAR 0 1
97850: PUSH
97851: LD_VAR 0 2
97855: PUSH
97856: FOR_IN
97857: IFFALSE 97873
// SetLives ( i , 300 ) ;
97859: LD_VAR 0 1
97863: PPUSH
97864: LD_INT 300
97866: PPUSH
97867: CALL_OW 234
97871: GO 97856
97873: POP
97874: POP
// end ;
97875: PPOPN 2
97877: END
// every 0 0$1 trigger s60 do var i , tmp ;
97878: LD_EXP 168
97882: IFFALSE 97951
97884: GO 97886
97886: DISABLE
97887: LD_INT 0
97889: PPUSH
97890: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97891: LD_ADDR_VAR 0 2
97895: PUSH
97896: LD_INT 22
97898: PUSH
97899: LD_OWVAR 2
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PPUSH
97908: CALL_OW 69
97912: ST_TO_ADDR
// if not tmp then
97913: LD_VAR 0 2
97917: NOT
97918: IFFALSE 97922
// exit ;
97920: GO 97951
// for i in tmp do
97922: LD_ADDR_VAR 0 1
97926: PUSH
97927: LD_VAR 0 2
97931: PUSH
97932: FOR_IN
97933: IFFALSE 97949
// SetLives ( i , 600 ) ;
97935: LD_VAR 0 1
97939: PPUSH
97940: LD_INT 600
97942: PPUSH
97943: CALL_OW 234
97947: GO 97932
97949: POP
97950: POP
// end ;
97951: PPOPN 2
97953: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
97954: LD_INT 0
97956: PPUSH
// case cmd of 301 :
97957: LD_VAR 0 1
97961: PUSH
97962: LD_INT 301
97964: DOUBLE
97965: EQUAL
97966: IFTRUE 97970
97968: GO 98002
97970: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
97971: LD_VAR 0 6
97975: PPUSH
97976: LD_VAR 0 7
97980: PPUSH
97981: LD_VAR 0 8
97985: PPUSH
97986: LD_VAR 0 4
97990: PPUSH
97991: LD_VAR 0 5
97995: PPUSH
97996: CALL 99203 0 5
98000: GO 98123
98002: LD_INT 302
98004: DOUBLE
98005: EQUAL
98006: IFTRUE 98010
98008: GO 98047
98010: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98011: LD_VAR 0 6
98015: PPUSH
98016: LD_VAR 0 7
98020: PPUSH
98021: LD_VAR 0 8
98025: PPUSH
98026: LD_VAR 0 9
98030: PPUSH
98031: LD_VAR 0 4
98035: PPUSH
98036: LD_VAR 0 5
98040: PPUSH
98041: CALL 99294 0 6
98045: GO 98123
98047: LD_INT 303
98049: DOUBLE
98050: EQUAL
98051: IFTRUE 98055
98053: GO 98092
98055: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98056: LD_VAR 0 6
98060: PPUSH
98061: LD_VAR 0 7
98065: PPUSH
98066: LD_VAR 0 8
98070: PPUSH
98071: LD_VAR 0 9
98075: PPUSH
98076: LD_VAR 0 4
98080: PPUSH
98081: LD_VAR 0 5
98085: PPUSH
98086: CALL 98128 0 6
98090: GO 98123
98092: LD_INT 304
98094: DOUBLE
98095: EQUAL
98096: IFTRUE 98100
98098: GO 98122
98100: POP
// hHackTeleport ( unit , x , y ) ; end ;
98101: LD_VAR 0 2
98105: PPUSH
98106: LD_VAR 0 4
98110: PPUSH
98111: LD_VAR 0 5
98115: PPUSH
98116: CALL 99887 0 3
98120: GO 98123
98122: POP
// end ;
98123: LD_VAR 0 12
98127: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98128: LD_INT 0
98130: PPUSH
98131: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98132: LD_VAR 0 1
98136: PUSH
98137: LD_INT 1
98139: LESS
98140: PUSH
98141: LD_VAR 0 1
98145: PUSH
98146: LD_INT 3
98148: GREATER
98149: OR
98150: PUSH
98151: LD_VAR 0 5
98155: PPUSH
98156: LD_VAR 0 6
98160: PPUSH
98161: CALL_OW 428
98165: OR
98166: IFFALSE 98170
// exit ;
98168: GO 98890
// uc_side := your_side ;
98170: LD_ADDR_OWVAR 20
98174: PUSH
98175: LD_OWVAR 2
98179: ST_TO_ADDR
// uc_nation := nation ;
98180: LD_ADDR_OWVAR 21
98184: PUSH
98185: LD_VAR 0 1
98189: ST_TO_ADDR
// bc_level = 1 ;
98190: LD_ADDR_OWVAR 43
98194: PUSH
98195: LD_INT 1
98197: ST_TO_ADDR
// case btype of 1 :
98198: LD_VAR 0 2
98202: PUSH
98203: LD_INT 1
98205: DOUBLE
98206: EQUAL
98207: IFTRUE 98211
98209: GO 98222
98211: POP
// bc_type := b_depot ; 2 :
98212: LD_ADDR_OWVAR 42
98216: PUSH
98217: LD_INT 0
98219: ST_TO_ADDR
98220: GO 98834
98222: LD_INT 2
98224: DOUBLE
98225: EQUAL
98226: IFTRUE 98230
98228: GO 98241
98230: POP
// bc_type := b_warehouse ; 3 :
98231: LD_ADDR_OWVAR 42
98235: PUSH
98236: LD_INT 1
98238: ST_TO_ADDR
98239: GO 98834
98241: LD_INT 3
98243: DOUBLE
98244: EQUAL
98245: IFTRUE 98249
98247: GO 98260
98249: POP
// bc_type := b_lab ; 4 .. 9 :
98250: LD_ADDR_OWVAR 42
98254: PUSH
98255: LD_INT 6
98257: ST_TO_ADDR
98258: GO 98834
98260: LD_INT 4
98262: DOUBLE
98263: GREATEREQUAL
98264: IFFALSE 98272
98266: LD_INT 9
98268: DOUBLE
98269: LESSEQUAL
98270: IFTRUE 98274
98272: GO 98326
98274: POP
// begin bc_type := b_lab_half ;
98275: LD_ADDR_OWVAR 42
98279: PUSH
98280: LD_INT 7
98282: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98283: LD_ADDR_OWVAR 44
98287: PUSH
98288: LD_INT 10
98290: PUSH
98291: LD_INT 11
98293: PUSH
98294: LD_INT 12
98296: PUSH
98297: LD_INT 15
98299: PUSH
98300: LD_INT 14
98302: PUSH
98303: LD_INT 13
98305: PUSH
98306: EMPTY
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: PUSH
98314: LD_VAR 0 2
98318: PUSH
98319: LD_INT 3
98321: MINUS
98322: ARRAY
98323: ST_TO_ADDR
// end ; 10 .. 13 :
98324: GO 98834
98326: LD_INT 10
98328: DOUBLE
98329: GREATEREQUAL
98330: IFFALSE 98338
98332: LD_INT 13
98334: DOUBLE
98335: LESSEQUAL
98336: IFTRUE 98340
98338: GO 98417
98340: POP
// begin bc_type := b_lab_full ;
98341: LD_ADDR_OWVAR 42
98345: PUSH
98346: LD_INT 8
98348: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98349: LD_ADDR_OWVAR 44
98353: PUSH
98354: LD_INT 10
98356: PUSH
98357: LD_INT 12
98359: PUSH
98360: LD_INT 14
98362: PUSH
98363: LD_INT 13
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: PUSH
98372: LD_VAR 0 2
98376: PUSH
98377: LD_INT 9
98379: MINUS
98380: ARRAY
98381: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98382: LD_ADDR_OWVAR 45
98386: PUSH
98387: LD_INT 11
98389: PUSH
98390: LD_INT 15
98392: PUSH
98393: LD_INT 12
98395: PUSH
98396: LD_INT 15
98398: PUSH
98399: EMPTY
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: PUSH
98405: LD_VAR 0 2
98409: PUSH
98410: LD_INT 9
98412: MINUS
98413: ARRAY
98414: ST_TO_ADDR
// end ; 14 :
98415: GO 98834
98417: LD_INT 14
98419: DOUBLE
98420: EQUAL
98421: IFTRUE 98425
98423: GO 98436
98425: POP
// bc_type := b_workshop ; 15 :
98426: LD_ADDR_OWVAR 42
98430: PUSH
98431: LD_INT 2
98433: ST_TO_ADDR
98434: GO 98834
98436: LD_INT 15
98438: DOUBLE
98439: EQUAL
98440: IFTRUE 98444
98442: GO 98455
98444: POP
// bc_type := b_factory ; 16 :
98445: LD_ADDR_OWVAR 42
98449: PUSH
98450: LD_INT 3
98452: ST_TO_ADDR
98453: GO 98834
98455: LD_INT 16
98457: DOUBLE
98458: EQUAL
98459: IFTRUE 98463
98461: GO 98474
98463: POP
// bc_type := b_ext_gun ; 17 :
98464: LD_ADDR_OWVAR 42
98468: PUSH
98469: LD_INT 17
98471: ST_TO_ADDR
98472: GO 98834
98474: LD_INT 17
98476: DOUBLE
98477: EQUAL
98478: IFTRUE 98482
98480: GO 98510
98482: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98483: LD_ADDR_OWVAR 42
98487: PUSH
98488: LD_INT 19
98490: PUSH
98491: LD_INT 23
98493: PUSH
98494: LD_INT 19
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: LIST
98501: PUSH
98502: LD_VAR 0 1
98506: ARRAY
98507: ST_TO_ADDR
98508: GO 98834
98510: LD_INT 18
98512: DOUBLE
98513: EQUAL
98514: IFTRUE 98518
98516: GO 98529
98518: POP
// bc_type := b_ext_radar ; 19 :
98519: LD_ADDR_OWVAR 42
98523: PUSH
98524: LD_INT 20
98526: ST_TO_ADDR
98527: GO 98834
98529: LD_INT 19
98531: DOUBLE
98532: EQUAL
98533: IFTRUE 98537
98535: GO 98548
98537: POP
// bc_type := b_ext_radio ; 20 :
98538: LD_ADDR_OWVAR 42
98542: PUSH
98543: LD_INT 22
98545: ST_TO_ADDR
98546: GO 98834
98548: LD_INT 20
98550: DOUBLE
98551: EQUAL
98552: IFTRUE 98556
98554: GO 98567
98556: POP
// bc_type := b_ext_siberium ; 21 :
98557: LD_ADDR_OWVAR 42
98561: PUSH
98562: LD_INT 21
98564: ST_TO_ADDR
98565: GO 98834
98567: LD_INT 21
98569: DOUBLE
98570: EQUAL
98571: IFTRUE 98575
98573: GO 98586
98575: POP
// bc_type := b_ext_computer ; 22 :
98576: LD_ADDR_OWVAR 42
98580: PUSH
98581: LD_INT 24
98583: ST_TO_ADDR
98584: GO 98834
98586: LD_INT 22
98588: DOUBLE
98589: EQUAL
98590: IFTRUE 98594
98592: GO 98605
98594: POP
// bc_type := b_ext_track ; 23 :
98595: LD_ADDR_OWVAR 42
98599: PUSH
98600: LD_INT 16
98602: ST_TO_ADDR
98603: GO 98834
98605: LD_INT 23
98607: DOUBLE
98608: EQUAL
98609: IFTRUE 98613
98611: GO 98624
98613: POP
// bc_type := b_ext_laser ; 24 :
98614: LD_ADDR_OWVAR 42
98618: PUSH
98619: LD_INT 25
98621: ST_TO_ADDR
98622: GO 98834
98624: LD_INT 24
98626: DOUBLE
98627: EQUAL
98628: IFTRUE 98632
98630: GO 98643
98632: POP
// bc_type := b_control_tower ; 25 :
98633: LD_ADDR_OWVAR 42
98637: PUSH
98638: LD_INT 36
98640: ST_TO_ADDR
98641: GO 98834
98643: LD_INT 25
98645: DOUBLE
98646: EQUAL
98647: IFTRUE 98651
98649: GO 98662
98651: POP
// bc_type := b_breastwork ; 26 :
98652: LD_ADDR_OWVAR 42
98656: PUSH
98657: LD_INT 31
98659: ST_TO_ADDR
98660: GO 98834
98662: LD_INT 26
98664: DOUBLE
98665: EQUAL
98666: IFTRUE 98670
98668: GO 98681
98670: POP
// bc_type := b_bunker ; 27 :
98671: LD_ADDR_OWVAR 42
98675: PUSH
98676: LD_INT 32
98678: ST_TO_ADDR
98679: GO 98834
98681: LD_INT 27
98683: DOUBLE
98684: EQUAL
98685: IFTRUE 98689
98687: GO 98700
98689: POP
// bc_type := b_turret ; 28 :
98690: LD_ADDR_OWVAR 42
98694: PUSH
98695: LD_INT 33
98697: ST_TO_ADDR
98698: GO 98834
98700: LD_INT 28
98702: DOUBLE
98703: EQUAL
98704: IFTRUE 98708
98706: GO 98719
98708: POP
// bc_type := b_armoury ; 29 :
98709: LD_ADDR_OWVAR 42
98713: PUSH
98714: LD_INT 4
98716: ST_TO_ADDR
98717: GO 98834
98719: LD_INT 29
98721: DOUBLE
98722: EQUAL
98723: IFTRUE 98727
98725: GO 98738
98727: POP
// bc_type := b_barracks ; 30 :
98728: LD_ADDR_OWVAR 42
98732: PUSH
98733: LD_INT 5
98735: ST_TO_ADDR
98736: GO 98834
98738: LD_INT 30
98740: DOUBLE
98741: EQUAL
98742: IFTRUE 98746
98744: GO 98757
98746: POP
// bc_type := b_solar_power ; 31 :
98747: LD_ADDR_OWVAR 42
98751: PUSH
98752: LD_INT 27
98754: ST_TO_ADDR
98755: GO 98834
98757: LD_INT 31
98759: DOUBLE
98760: EQUAL
98761: IFTRUE 98765
98763: GO 98776
98765: POP
// bc_type := b_oil_power ; 32 :
98766: LD_ADDR_OWVAR 42
98770: PUSH
98771: LD_INT 26
98773: ST_TO_ADDR
98774: GO 98834
98776: LD_INT 32
98778: DOUBLE
98779: EQUAL
98780: IFTRUE 98784
98782: GO 98795
98784: POP
// bc_type := b_siberite_power ; 33 :
98785: LD_ADDR_OWVAR 42
98789: PUSH
98790: LD_INT 28
98792: ST_TO_ADDR
98793: GO 98834
98795: LD_INT 33
98797: DOUBLE
98798: EQUAL
98799: IFTRUE 98803
98801: GO 98814
98803: POP
// bc_type := b_oil_mine ; 34 :
98804: LD_ADDR_OWVAR 42
98808: PUSH
98809: LD_INT 29
98811: ST_TO_ADDR
98812: GO 98834
98814: LD_INT 34
98816: DOUBLE
98817: EQUAL
98818: IFTRUE 98822
98820: GO 98833
98822: POP
// bc_type := b_siberite_mine ; end ;
98823: LD_ADDR_OWVAR 42
98827: PUSH
98828: LD_INT 30
98830: ST_TO_ADDR
98831: GO 98834
98833: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
98834: LD_ADDR_VAR 0 8
98838: PUSH
98839: LD_VAR 0 5
98843: PPUSH
98844: LD_VAR 0 6
98848: PPUSH
98849: LD_VAR 0 3
98853: PPUSH
98854: CALL_OW 47
98858: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98859: LD_OWVAR 42
98863: PUSH
98864: LD_INT 32
98866: PUSH
98867: LD_INT 33
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: IN
98874: IFFALSE 98890
// PlaceWeaponTurret ( b , weapon ) ;
98876: LD_VAR 0 8
98880: PPUSH
98881: LD_VAR 0 4
98885: PPUSH
98886: CALL_OW 431
// end ;
98890: LD_VAR 0 7
98894: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98895: LD_INT 0
98897: PPUSH
98898: PPUSH
98899: PPUSH
98900: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98901: LD_ADDR_VAR 0 4
98905: PUSH
98906: LD_INT 22
98908: PUSH
98909: LD_OWVAR 2
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PUSH
98918: LD_INT 2
98920: PUSH
98921: LD_INT 30
98923: PUSH
98924: LD_INT 0
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: PUSH
98931: LD_INT 30
98933: PUSH
98934: LD_INT 1
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: PUSH
98941: EMPTY
98942: LIST
98943: LIST
98944: LIST
98945: PUSH
98946: EMPTY
98947: LIST
98948: LIST
98949: PPUSH
98950: CALL_OW 69
98954: ST_TO_ADDR
// if not tmp then
98955: LD_VAR 0 4
98959: NOT
98960: IFFALSE 98964
// exit ;
98962: GO 99023
// for i in tmp do
98964: LD_ADDR_VAR 0 2
98968: PUSH
98969: LD_VAR 0 4
98973: PUSH
98974: FOR_IN
98975: IFFALSE 99021
// for j = 1 to 3 do
98977: LD_ADDR_VAR 0 3
98981: PUSH
98982: DOUBLE
98983: LD_INT 1
98985: DEC
98986: ST_TO_ADDR
98987: LD_INT 3
98989: PUSH
98990: FOR_TO
98991: IFFALSE 99017
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
98993: LD_VAR 0 2
98997: PPUSH
98998: CALL_OW 274
99002: PPUSH
99003: LD_VAR 0 3
99007: PPUSH
99008: LD_INT 99999
99010: PPUSH
99011: CALL_OW 277
99015: GO 98990
99017: POP
99018: POP
99019: GO 98974
99021: POP
99022: POP
// end ;
99023: LD_VAR 0 1
99027: RET
// export function hHackSetLevel10 ; var i , j ; begin
99028: LD_INT 0
99030: PPUSH
99031: PPUSH
99032: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99033: LD_ADDR_VAR 0 2
99037: PUSH
99038: LD_INT 21
99040: PUSH
99041: LD_INT 1
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PPUSH
99048: CALL_OW 69
99052: PUSH
99053: FOR_IN
99054: IFFALSE 99106
// if IsSelected ( i ) then
99056: LD_VAR 0 2
99060: PPUSH
99061: CALL_OW 306
99065: IFFALSE 99104
// begin for j := 1 to 4 do
99067: LD_ADDR_VAR 0 3
99071: PUSH
99072: DOUBLE
99073: LD_INT 1
99075: DEC
99076: ST_TO_ADDR
99077: LD_INT 4
99079: PUSH
99080: FOR_TO
99081: IFFALSE 99102
// SetSkill ( i , j , 10 ) ;
99083: LD_VAR 0 2
99087: PPUSH
99088: LD_VAR 0 3
99092: PPUSH
99093: LD_INT 10
99095: PPUSH
99096: CALL_OW 237
99100: GO 99080
99102: POP
99103: POP
// end ;
99104: GO 99053
99106: POP
99107: POP
// end ;
99108: LD_VAR 0 1
99112: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99113: LD_INT 0
99115: PPUSH
99116: PPUSH
99117: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99118: LD_ADDR_VAR 0 2
99122: PUSH
99123: LD_INT 22
99125: PUSH
99126: LD_OWVAR 2
99130: PUSH
99131: EMPTY
99132: LIST
99133: LIST
99134: PUSH
99135: LD_INT 21
99137: PUSH
99138: LD_INT 1
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PPUSH
99149: CALL_OW 69
99153: PUSH
99154: FOR_IN
99155: IFFALSE 99196
// begin for j := 1 to 4 do
99157: LD_ADDR_VAR 0 3
99161: PUSH
99162: DOUBLE
99163: LD_INT 1
99165: DEC
99166: ST_TO_ADDR
99167: LD_INT 4
99169: PUSH
99170: FOR_TO
99171: IFFALSE 99192
// SetSkill ( i , j , 10 ) ;
99173: LD_VAR 0 2
99177: PPUSH
99178: LD_VAR 0 3
99182: PPUSH
99183: LD_INT 10
99185: PPUSH
99186: CALL_OW 237
99190: GO 99170
99192: POP
99193: POP
// end ;
99194: GO 99154
99196: POP
99197: POP
// end ;
99198: LD_VAR 0 1
99202: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99203: LD_INT 0
99205: PPUSH
// uc_side := your_side ;
99206: LD_ADDR_OWVAR 20
99210: PUSH
99211: LD_OWVAR 2
99215: ST_TO_ADDR
// uc_nation := nation ;
99216: LD_ADDR_OWVAR 21
99220: PUSH
99221: LD_VAR 0 1
99225: ST_TO_ADDR
// InitHc ;
99226: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99230: LD_INT 0
99232: PPUSH
99233: LD_VAR 0 2
99237: PPUSH
99238: LD_VAR 0 3
99242: PPUSH
99243: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99247: LD_VAR 0 4
99251: PPUSH
99252: LD_VAR 0 5
99256: PPUSH
99257: CALL_OW 428
99261: PUSH
99262: LD_INT 0
99264: EQUAL
99265: IFFALSE 99289
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99267: CALL_OW 44
99271: PPUSH
99272: LD_VAR 0 4
99276: PPUSH
99277: LD_VAR 0 5
99281: PPUSH
99282: LD_INT 1
99284: PPUSH
99285: CALL_OW 48
// end ;
99289: LD_VAR 0 6
99293: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99294: LD_INT 0
99296: PPUSH
99297: PPUSH
// uc_side := your_side ;
99298: LD_ADDR_OWVAR 20
99302: PUSH
99303: LD_OWVAR 2
99307: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99308: LD_VAR 0 1
99312: PUSH
99313: LD_INT 1
99315: PUSH
99316: LD_INT 2
99318: PUSH
99319: LD_INT 3
99321: PUSH
99322: LD_INT 4
99324: PUSH
99325: LD_INT 5
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: IN
99335: IFFALSE 99347
// uc_nation := nation_american else
99337: LD_ADDR_OWVAR 21
99341: PUSH
99342: LD_INT 1
99344: ST_TO_ADDR
99345: GO 99390
// if chassis in [ 11 , 12 , 13 , 14 ] then
99347: LD_VAR 0 1
99351: PUSH
99352: LD_INT 11
99354: PUSH
99355: LD_INT 12
99357: PUSH
99358: LD_INT 13
99360: PUSH
99361: LD_INT 14
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: IN
99370: IFFALSE 99382
// uc_nation := nation_arabian else
99372: LD_ADDR_OWVAR 21
99376: PUSH
99377: LD_INT 2
99379: ST_TO_ADDR
99380: GO 99390
// uc_nation := nation_russian ;
99382: LD_ADDR_OWVAR 21
99386: PUSH
99387: LD_INT 3
99389: ST_TO_ADDR
// vc_chassis := chassis ;
99390: LD_ADDR_OWVAR 37
99394: PUSH
99395: LD_VAR 0 1
99399: ST_TO_ADDR
// vc_engine := engine ;
99400: LD_ADDR_OWVAR 39
99404: PUSH
99405: LD_VAR 0 2
99409: ST_TO_ADDR
// vc_control := control ;
99410: LD_ADDR_OWVAR 38
99414: PUSH
99415: LD_VAR 0 3
99419: ST_TO_ADDR
// vc_weapon := weapon ;
99420: LD_ADDR_OWVAR 40
99424: PUSH
99425: LD_VAR 0 4
99429: ST_TO_ADDR
// un := CreateVehicle ;
99430: LD_ADDR_VAR 0 8
99434: PUSH
99435: CALL_OW 45
99439: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99440: LD_VAR 0 8
99444: PPUSH
99445: LD_INT 0
99447: PPUSH
99448: LD_INT 5
99450: PPUSH
99451: CALL_OW 12
99455: PPUSH
99456: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99460: LD_VAR 0 8
99464: PPUSH
99465: LD_VAR 0 5
99469: PPUSH
99470: LD_VAR 0 6
99474: PPUSH
99475: LD_INT 1
99477: PPUSH
99478: CALL_OW 48
// end ;
99482: LD_VAR 0 7
99486: RET
// export hInvincible ; every 1 do
99487: GO 99489
99489: DISABLE
// hInvincible := [ ] ;
99490: LD_ADDR_EXP 169
99494: PUSH
99495: EMPTY
99496: ST_TO_ADDR
99497: END
// every 10 do var i ;
99498: GO 99500
99500: DISABLE
99501: LD_INT 0
99503: PPUSH
// begin enable ;
99504: ENABLE
// if not hInvincible then
99505: LD_EXP 169
99509: NOT
99510: IFFALSE 99514
// exit ;
99512: GO 99558
// for i in hInvincible do
99514: LD_ADDR_VAR 0 1
99518: PUSH
99519: LD_EXP 169
99523: PUSH
99524: FOR_IN
99525: IFFALSE 99556
// if GetLives ( i ) < 1000 then
99527: LD_VAR 0 1
99531: PPUSH
99532: CALL_OW 256
99536: PUSH
99537: LD_INT 1000
99539: LESS
99540: IFFALSE 99554
// SetLives ( i , 1000 ) ;
99542: LD_VAR 0 1
99546: PPUSH
99547: LD_INT 1000
99549: PPUSH
99550: CALL_OW 234
99554: GO 99524
99556: POP
99557: POP
// end ;
99558: PPOPN 1
99560: END
// export function hHackInvincible ; var i ; begin
99561: LD_INT 0
99563: PPUSH
99564: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99565: LD_ADDR_VAR 0 2
99569: PUSH
99570: LD_INT 2
99572: PUSH
99573: LD_INT 21
99575: PUSH
99576: LD_INT 1
99578: PUSH
99579: EMPTY
99580: LIST
99581: LIST
99582: PUSH
99583: LD_INT 21
99585: PUSH
99586: LD_INT 2
99588: PUSH
99589: EMPTY
99590: LIST
99591: LIST
99592: PUSH
99593: EMPTY
99594: LIST
99595: LIST
99596: LIST
99597: PPUSH
99598: CALL_OW 69
99602: PUSH
99603: FOR_IN
99604: IFFALSE 99665
// if IsSelected ( i ) then
99606: LD_VAR 0 2
99610: PPUSH
99611: CALL_OW 306
99615: IFFALSE 99663
// begin if i in hInvincible then
99617: LD_VAR 0 2
99621: PUSH
99622: LD_EXP 169
99626: IN
99627: IFFALSE 99647
// hInvincible := hInvincible diff i else
99629: LD_ADDR_EXP 169
99633: PUSH
99634: LD_EXP 169
99638: PUSH
99639: LD_VAR 0 2
99643: DIFF
99644: ST_TO_ADDR
99645: GO 99663
// hInvincible := hInvincible union i ;
99647: LD_ADDR_EXP 169
99651: PUSH
99652: LD_EXP 169
99656: PUSH
99657: LD_VAR 0 2
99661: UNION
99662: ST_TO_ADDR
// end ;
99663: GO 99603
99665: POP
99666: POP
// end ;
99667: LD_VAR 0 1
99671: RET
// export function hHackInvisible ; var i , j ; begin
99672: LD_INT 0
99674: PPUSH
99675: PPUSH
99676: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99677: LD_ADDR_VAR 0 2
99681: PUSH
99682: LD_INT 21
99684: PUSH
99685: LD_INT 1
99687: PUSH
99688: EMPTY
99689: LIST
99690: LIST
99691: PPUSH
99692: CALL_OW 69
99696: PUSH
99697: FOR_IN
99698: IFFALSE 99722
// if IsSelected ( i ) then
99700: LD_VAR 0 2
99704: PPUSH
99705: CALL_OW 306
99709: IFFALSE 99720
// ComForceInvisible ( i ) ;
99711: LD_VAR 0 2
99715: PPUSH
99716: CALL_OW 496
99720: GO 99697
99722: POP
99723: POP
// end ;
99724: LD_VAR 0 1
99728: RET
// export function hHackChangeYourSide ; begin
99729: LD_INT 0
99731: PPUSH
// if your_side = 8 then
99732: LD_OWVAR 2
99736: PUSH
99737: LD_INT 8
99739: EQUAL
99740: IFFALSE 99752
// your_side := 0 else
99742: LD_ADDR_OWVAR 2
99746: PUSH
99747: LD_INT 0
99749: ST_TO_ADDR
99750: GO 99766
// your_side := your_side + 1 ;
99752: LD_ADDR_OWVAR 2
99756: PUSH
99757: LD_OWVAR 2
99761: PUSH
99762: LD_INT 1
99764: PLUS
99765: ST_TO_ADDR
// end ;
99766: LD_VAR 0 1
99770: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99771: LD_INT 0
99773: PPUSH
99774: PPUSH
99775: PPUSH
// for i in all_units do
99776: LD_ADDR_VAR 0 2
99780: PUSH
99781: LD_OWVAR 3
99785: PUSH
99786: FOR_IN
99787: IFFALSE 99865
// if IsSelected ( i ) then
99789: LD_VAR 0 2
99793: PPUSH
99794: CALL_OW 306
99798: IFFALSE 99863
// begin j := GetSide ( i ) ;
99800: LD_ADDR_VAR 0 3
99804: PUSH
99805: LD_VAR 0 2
99809: PPUSH
99810: CALL_OW 255
99814: ST_TO_ADDR
// if j = 8 then
99815: LD_VAR 0 3
99819: PUSH
99820: LD_INT 8
99822: EQUAL
99823: IFFALSE 99835
// j := 0 else
99825: LD_ADDR_VAR 0 3
99829: PUSH
99830: LD_INT 0
99832: ST_TO_ADDR
99833: GO 99849
// j := j + 1 ;
99835: LD_ADDR_VAR 0 3
99839: PUSH
99840: LD_VAR 0 3
99844: PUSH
99845: LD_INT 1
99847: PLUS
99848: ST_TO_ADDR
// SetSide ( i , j ) ;
99849: LD_VAR 0 2
99853: PPUSH
99854: LD_VAR 0 3
99858: PPUSH
99859: CALL_OW 235
// end ;
99863: GO 99786
99865: POP
99866: POP
// end ;
99867: LD_VAR 0 1
99871: RET
// export function hHackFog ; begin
99872: LD_INT 0
99874: PPUSH
// FogOff ( true ) ;
99875: LD_INT 1
99877: PPUSH
99878: CALL_OW 344
// end ;
99882: LD_VAR 0 1
99886: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99887: LD_INT 0
99889: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99890: LD_VAR 0 1
99894: PPUSH
99895: LD_VAR 0 2
99899: PPUSH
99900: LD_VAR 0 3
99904: PPUSH
99905: LD_INT 1
99907: PPUSH
99908: LD_INT 1
99910: PPUSH
99911: CALL_OW 483
// CenterOnXY ( x , y ) ;
99915: LD_VAR 0 2
99919: PPUSH
99920: LD_VAR 0 3
99924: PPUSH
99925: CALL_OW 84
// end ;
99929: LD_VAR 0 4
99933: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
99934: LD_INT 0
99936: PPUSH
99937: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
99938: LD_VAR 0 1
99942: NOT
99943: PUSH
99944: LD_VAR 0 2
99948: PPUSH
99949: LD_VAR 0 3
99953: PPUSH
99954: CALL_OW 488
99958: NOT
99959: OR
99960: PUSH
99961: LD_VAR 0 1
99965: PPUSH
99966: CALL_OW 266
99970: PUSH
99971: LD_INT 3
99973: NONEQUAL
99974: PUSH
99975: LD_VAR 0 1
99979: PPUSH
99980: CALL_OW 247
99984: PUSH
99985: LD_INT 1
99987: EQUAL
99988: NOT
99989: AND
99990: OR
99991: IFFALSE 99995
// exit ;
99993: GO 100144
// if GetType ( factory ) = unit_human then
99995: LD_VAR 0 1
99999: PPUSH
100000: CALL_OW 247
100004: PUSH
100005: LD_INT 1
100007: EQUAL
100008: IFFALSE 100025
// factory := IsInUnit ( factory ) ;
100010: LD_ADDR_VAR 0 1
100014: PUSH
100015: LD_VAR 0 1
100019: PPUSH
100020: CALL_OW 310
100024: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100025: LD_VAR 0 1
100029: PPUSH
100030: CALL_OW 266
100034: PUSH
100035: LD_INT 3
100037: NONEQUAL
100038: IFFALSE 100042
// exit ;
100040: GO 100144
// if HexInfo ( x , y ) = factory then
100042: LD_VAR 0 2
100046: PPUSH
100047: LD_VAR 0 3
100051: PPUSH
100052: CALL_OW 428
100056: PUSH
100057: LD_VAR 0 1
100061: EQUAL
100062: IFFALSE 100089
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100064: LD_ADDR_EXP 170
100068: PUSH
100069: LD_EXP 170
100073: PPUSH
100074: LD_VAR 0 1
100078: PPUSH
100079: LD_INT 0
100081: PPUSH
100082: CALL_OW 1
100086: ST_TO_ADDR
100087: GO 100140
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100089: LD_ADDR_EXP 170
100093: PUSH
100094: LD_EXP 170
100098: PPUSH
100099: LD_VAR 0 1
100103: PPUSH
100104: LD_VAR 0 1
100108: PPUSH
100109: CALL_OW 255
100113: PUSH
100114: LD_VAR 0 1
100118: PUSH
100119: LD_VAR 0 2
100123: PUSH
100124: LD_VAR 0 3
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: LIST
100133: LIST
100134: PPUSH
100135: CALL_OW 1
100139: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100140: CALL 100149 0 0
// end ;
100144: LD_VAR 0 4
100148: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
100149: LD_INT 0
100151: PPUSH
100152: PPUSH
100153: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100154: LD_STRING resetFactoryWaypoint();
100156: PPUSH
100157: CALL_OW 559
// if factoryWaypoints then
100161: LD_EXP 170
100165: IFFALSE 100291
// begin list := PrepareArray ( factoryWaypoints ) ;
100167: LD_ADDR_VAR 0 3
100171: PUSH
100172: LD_EXP 170
100176: PPUSH
100177: CALL 54759 0 1
100181: ST_TO_ADDR
// for i := 1 to list do
100182: LD_ADDR_VAR 0 2
100186: PUSH
100187: DOUBLE
100188: LD_INT 1
100190: DEC
100191: ST_TO_ADDR
100192: LD_VAR 0 3
100196: PUSH
100197: FOR_TO
100198: IFFALSE 100289
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100200: LD_STRING setFactoryWaypointXY(
100202: PUSH
100203: LD_VAR 0 3
100207: PUSH
100208: LD_VAR 0 2
100212: ARRAY
100213: PUSH
100214: LD_INT 1
100216: ARRAY
100217: STR
100218: PUSH
100219: LD_STRING ,
100221: STR
100222: PUSH
100223: LD_VAR 0 3
100227: PUSH
100228: LD_VAR 0 2
100232: ARRAY
100233: PUSH
100234: LD_INT 2
100236: ARRAY
100237: STR
100238: PUSH
100239: LD_STRING ,
100241: STR
100242: PUSH
100243: LD_VAR 0 3
100247: PUSH
100248: LD_VAR 0 2
100252: ARRAY
100253: PUSH
100254: LD_INT 3
100256: ARRAY
100257: STR
100258: PUSH
100259: LD_STRING ,
100261: STR
100262: PUSH
100263: LD_VAR 0 3
100267: PUSH
100268: LD_VAR 0 2
100272: ARRAY
100273: PUSH
100274: LD_INT 4
100276: ARRAY
100277: STR
100278: PUSH
100279: LD_STRING )
100281: STR
100282: PPUSH
100283: CALL_OW 559
100287: GO 100197
100289: POP
100290: POP
// end ; end ;
100291: LD_VAR 0 1
100295: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
100296: LD_INT 0
100298: PPUSH
// if HexInfo ( x , y ) = warehouse then
100299: LD_VAR 0 2
100303: PPUSH
100304: LD_VAR 0 3
100308: PPUSH
100309: CALL_OW 428
100313: PUSH
100314: LD_VAR 0 1
100318: EQUAL
100319: IFFALSE 100346
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
100321: LD_ADDR_EXP 171
100325: PUSH
100326: LD_EXP 171
100330: PPUSH
100331: LD_VAR 0 1
100335: PPUSH
100336: LD_INT 0
100338: PPUSH
100339: CALL_OW 1
100343: ST_TO_ADDR
100344: GO 100397
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
100346: LD_ADDR_EXP 171
100350: PUSH
100351: LD_EXP 171
100355: PPUSH
100356: LD_VAR 0 1
100360: PPUSH
100361: LD_VAR 0 1
100365: PPUSH
100366: CALL_OW 255
100370: PUSH
100371: LD_VAR 0 1
100375: PUSH
100376: LD_VAR 0 2
100380: PUSH
100381: LD_VAR 0 3
100385: PUSH
100386: EMPTY
100387: LIST
100388: LIST
100389: LIST
100390: LIST
100391: PPUSH
100392: CALL_OW 1
100396: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
100397: CALL 100406 0 0
// end ;
100401: LD_VAR 0 4
100405: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
100406: LD_INT 0
100408: PPUSH
100409: PPUSH
100410: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
100411: LD_STRING resetWarehouseGatheringPoints();
100413: PPUSH
100414: CALL_OW 559
// if warehouseGatheringPoints then
100418: LD_EXP 171
100422: IFFALSE 100548
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
100424: LD_ADDR_VAR 0 3
100428: PUSH
100429: LD_EXP 171
100433: PPUSH
100434: CALL 54759 0 1
100438: ST_TO_ADDR
// for i := 1 to list do
100439: LD_ADDR_VAR 0 2
100443: PUSH
100444: DOUBLE
100445: LD_INT 1
100447: DEC
100448: ST_TO_ADDR
100449: LD_VAR 0 3
100453: PUSH
100454: FOR_TO
100455: IFFALSE 100546
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100457: LD_STRING setWarehouseGatheringPointXY(
100459: PUSH
100460: LD_VAR 0 3
100464: PUSH
100465: LD_VAR 0 2
100469: ARRAY
100470: PUSH
100471: LD_INT 1
100473: ARRAY
100474: STR
100475: PUSH
100476: LD_STRING ,
100478: STR
100479: PUSH
100480: LD_VAR 0 3
100484: PUSH
100485: LD_VAR 0 2
100489: ARRAY
100490: PUSH
100491: LD_INT 2
100493: ARRAY
100494: STR
100495: PUSH
100496: LD_STRING ,
100498: STR
100499: PUSH
100500: LD_VAR 0 3
100504: PUSH
100505: LD_VAR 0 2
100509: ARRAY
100510: PUSH
100511: LD_INT 3
100513: ARRAY
100514: STR
100515: PUSH
100516: LD_STRING ,
100518: STR
100519: PUSH
100520: LD_VAR 0 3
100524: PUSH
100525: LD_VAR 0 2
100529: ARRAY
100530: PUSH
100531: LD_INT 4
100533: ARRAY
100534: STR
100535: PUSH
100536: LD_STRING )
100538: STR
100539: PPUSH
100540: CALL_OW 559
100544: GO 100454
100546: POP
100547: POP
// end ; end ;
100548: LD_VAR 0 1
100552: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
100553: LD_EXP 171
100557: IFFALSE 101244
100559: GO 100561
100561: DISABLE
100562: LD_INT 0
100564: PPUSH
100565: PPUSH
100566: PPUSH
100567: PPUSH
100568: PPUSH
100569: PPUSH
100570: PPUSH
100571: PPUSH
100572: PPUSH
// begin enable ;
100573: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
100574: LD_ADDR_VAR 0 3
100578: PUSH
100579: LD_EXP 171
100583: PPUSH
100584: CALL 54759 0 1
100588: ST_TO_ADDR
// if not list then
100589: LD_VAR 0 3
100593: NOT
100594: IFFALSE 100598
// exit ;
100596: GO 101244
// for i := 1 to list do
100598: LD_ADDR_VAR 0 1
100602: PUSH
100603: DOUBLE
100604: LD_INT 1
100606: DEC
100607: ST_TO_ADDR
100608: LD_VAR 0 3
100612: PUSH
100613: FOR_TO
100614: IFFALSE 101242
// begin depot := list [ i ] [ 2 ] ;
100616: LD_ADDR_VAR 0 8
100620: PUSH
100621: LD_VAR 0 3
100625: PUSH
100626: LD_VAR 0 1
100630: ARRAY
100631: PUSH
100632: LD_INT 2
100634: ARRAY
100635: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
100636: LD_ADDR_VAR 0 5
100640: PUSH
100641: LD_VAR 0 3
100645: PUSH
100646: LD_VAR 0 1
100650: ARRAY
100651: PUSH
100652: LD_INT 1
100654: ARRAY
100655: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
100656: LD_VAR 0 8
100660: PPUSH
100661: CALL_OW 301
100665: PUSH
100666: LD_VAR 0 5
100670: PUSH
100671: LD_VAR 0 8
100675: PPUSH
100676: CALL_OW 255
100680: NONEQUAL
100681: OR
100682: IFFALSE 100711
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
100684: LD_ADDR_EXP 171
100688: PUSH
100689: LD_EXP 171
100693: PPUSH
100694: LD_VAR 0 8
100698: PPUSH
100699: LD_INT 0
100701: PPUSH
100702: CALL_OW 1
100706: ST_TO_ADDR
// exit ;
100707: POP
100708: POP
100709: GO 101244
// end ; x := list [ i ] [ 3 ] ;
100711: LD_ADDR_VAR 0 6
100715: PUSH
100716: LD_VAR 0 3
100720: PUSH
100721: LD_VAR 0 1
100725: ARRAY
100726: PUSH
100727: LD_INT 3
100729: ARRAY
100730: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
100731: LD_ADDR_VAR 0 7
100735: PUSH
100736: LD_VAR 0 3
100740: PUSH
100741: LD_VAR 0 1
100745: ARRAY
100746: PUSH
100747: LD_INT 4
100749: ARRAY
100750: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
100751: LD_ADDR_VAR 0 9
100755: PUSH
100756: LD_VAR 0 6
100760: PPUSH
100761: LD_VAR 0 7
100765: PPUSH
100766: LD_INT 16
100768: PPUSH
100769: CALL 53343 0 3
100773: ST_TO_ADDR
// if not cratesNearbyPoint then
100774: LD_VAR 0 9
100778: NOT
100779: IFFALSE 100785
// exit ;
100781: POP
100782: POP
100783: GO 101244
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
100785: LD_ADDR_VAR 0 4
100789: PUSH
100790: LD_INT 22
100792: PUSH
100793: LD_VAR 0 5
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: PUSH
100802: LD_INT 3
100804: PUSH
100805: LD_INT 60
100807: PUSH
100808: EMPTY
100809: LIST
100810: PUSH
100811: EMPTY
100812: LIST
100813: LIST
100814: PUSH
100815: LD_INT 91
100817: PUSH
100818: LD_VAR 0 8
100822: PUSH
100823: LD_INT 6
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: LIST
100830: PUSH
100831: LD_INT 2
100833: PUSH
100834: LD_INT 25
100836: PUSH
100837: LD_INT 2
100839: PUSH
100840: EMPTY
100841: LIST
100842: LIST
100843: PUSH
100844: LD_INT 25
100846: PUSH
100847: LD_INT 16
100849: PUSH
100850: EMPTY
100851: LIST
100852: LIST
100853: PUSH
100854: EMPTY
100855: LIST
100856: LIST
100857: LIST
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: LIST
100863: LIST
100864: PPUSH
100865: CALL_OW 69
100869: PUSH
100870: LD_VAR 0 8
100874: PPUSH
100875: CALL_OW 313
100879: PPUSH
100880: LD_INT 3
100882: PUSH
100883: LD_INT 60
100885: PUSH
100886: EMPTY
100887: LIST
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: LD_INT 2
100895: PUSH
100896: LD_INT 25
100898: PUSH
100899: LD_INT 2
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: LD_INT 25
100908: PUSH
100909: LD_INT 16
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: LIST
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PPUSH
100925: CALL_OW 72
100929: UNION
100930: ST_TO_ADDR
// if tmp then
100931: LD_VAR 0 4
100935: IFFALSE 101015
// begin tmp := ShrinkArray ( tmp , 3 ) ;
100937: LD_ADDR_VAR 0 4
100941: PUSH
100942: LD_VAR 0 4
100946: PPUSH
100947: LD_INT 3
100949: PPUSH
100950: CALL 51310 0 2
100954: ST_TO_ADDR
// for j in tmp do
100955: LD_ADDR_VAR 0 2
100959: PUSH
100960: LD_VAR 0 4
100964: PUSH
100965: FOR_IN
100966: IFFALSE 101009
// begin if IsInUnit ( j ) then
100968: LD_VAR 0 2
100972: PPUSH
100973: CALL_OW 310
100977: IFFALSE 100988
// ComExit ( j ) ;
100979: LD_VAR 0 2
100983: PPUSH
100984: CALL 51393 0 1
// AddComCollect ( j , x , y ) ;
100988: LD_VAR 0 2
100992: PPUSH
100993: LD_VAR 0 6
100997: PPUSH
100998: LD_VAR 0 7
101002: PPUSH
101003: CALL_OW 177
// end ;
101007: GO 100965
101009: POP
101010: POP
// exit ;
101011: POP
101012: POP
101013: GO 101244
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
101015: LD_ADDR_VAR 0 4
101019: PUSH
101020: LD_INT 22
101022: PUSH
101023: LD_VAR 0 5
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PUSH
101032: LD_INT 91
101034: PUSH
101035: LD_VAR 0 8
101039: PUSH
101040: LD_INT 8
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: LIST
101047: PUSH
101048: LD_INT 2
101050: PUSH
101051: LD_INT 34
101053: PUSH
101054: LD_INT 12
101056: PUSH
101057: EMPTY
101058: LIST
101059: LIST
101060: PUSH
101061: LD_INT 34
101063: PUSH
101064: LD_INT 51
101066: PUSH
101067: EMPTY
101068: LIST
101069: LIST
101070: PUSH
101071: LD_INT 34
101073: PUSH
101074: LD_INT 32
101076: PUSH
101077: EMPTY
101078: LIST
101079: LIST
101080: PUSH
101081: LD_INT 34
101083: PUSH
101084: LD_EXP 49
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: PUSH
101093: EMPTY
101094: LIST
101095: LIST
101096: LIST
101097: LIST
101098: LIST
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: LIST
101104: PPUSH
101105: CALL_OW 69
101109: ST_TO_ADDR
// if tmp then
101110: LD_VAR 0 4
101114: IFFALSE 101240
// begin for j in tmp do
101116: LD_ADDR_VAR 0 2
101120: PUSH
101121: LD_VAR 0 4
101125: PUSH
101126: FOR_IN
101127: IFFALSE 101238
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
101129: LD_VAR 0 2
101133: PPUSH
101134: CALL_OW 262
101138: PUSH
101139: LD_INT 3
101141: EQUAL
101142: PUSH
101143: LD_VAR 0 2
101147: PPUSH
101148: CALL_OW 261
101152: PUSH
101153: LD_INT 20
101155: GREATER
101156: OR
101157: PUSH
101158: LD_VAR 0 2
101162: PPUSH
101163: CALL_OW 314
101167: NOT
101168: AND
101169: PUSH
101170: LD_VAR 0 2
101174: PPUSH
101175: CALL_OW 263
101179: PUSH
101180: LD_INT 1
101182: NONEQUAL
101183: PUSH
101184: LD_VAR 0 2
101188: PPUSH
101189: CALL_OW 311
101193: OR
101194: AND
101195: IFFALSE 101236
// begin ComCollect ( j , x , y ) ;
101197: LD_VAR 0 2
101201: PPUSH
101202: LD_VAR 0 6
101206: PPUSH
101207: LD_VAR 0 7
101211: PPUSH
101212: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
101216: LD_VAR 0 2
101220: PPUSH
101221: LD_VAR 0 8
101225: PPUSH
101226: CALL_OW 172
// exit ;
101230: POP
101231: POP
101232: POP
101233: POP
101234: GO 101244
// end ;
101236: GO 101126
101238: POP
101239: POP
// end ; end ;
101240: GO 100613
101242: POP
101243: POP
// end ; end_of_file
101244: PPOPN 9
101246: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101247: LD_INT 0
101249: PPUSH
101250: PPUSH
101251: PPUSH
101252: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101253: LD_VAR 0 1
101257: PPUSH
101258: CALL_OW 264
101262: PUSH
101263: LD_EXP 52
101267: EQUAL
101268: IFFALSE 101340
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101270: LD_INT 68
101272: PPUSH
101273: LD_VAR 0 1
101277: PPUSH
101278: CALL_OW 255
101282: PPUSH
101283: CALL_OW 321
101287: PUSH
101288: LD_INT 2
101290: EQUAL
101291: IFFALSE 101303
// eff := 70 else
101293: LD_ADDR_VAR 0 4
101297: PUSH
101298: LD_INT 70
101300: ST_TO_ADDR
101301: GO 101311
// eff := 30 ;
101303: LD_ADDR_VAR 0 4
101307: PUSH
101308: LD_INT 30
101310: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101311: LD_VAR 0 1
101315: PPUSH
101316: CALL_OW 250
101320: PPUSH
101321: LD_VAR 0 1
101325: PPUSH
101326: CALL_OW 251
101330: PPUSH
101331: LD_VAR 0 4
101335: PPUSH
101336: CALL_OW 495
// end ; end ;
101340: LD_VAR 0 2
101344: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101345: LD_INT 0
101347: PPUSH
// end ;
101348: LD_VAR 0 4
101352: RET
// export function SOS_Command ( cmd ) ; begin
101353: LD_INT 0
101355: PPUSH
// end ;
101356: LD_VAR 0 2
101360: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101361: LD_INT 0
101363: PPUSH
// end ;
101364: LD_VAR 0 6
101368: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
101369: LD_INT 0
101371: PPUSH
101372: PPUSH
// if not vehicle or not factory then
101373: LD_VAR 0 1
101377: NOT
101378: PUSH
101379: LD_VAR 0 2
101383: NOT
101384: OR
101385: IFFALSE 101389
// exit ;
101387: GO 101620
// if factoryWaypoints >= factory then
101389: LD_EXP 170
101393: PUSH
101394: LD_VAR 0 2
101398: GREATEREQUAL
101399: IFFALSE 101620
// if factoryWaypoints [ factory ] then
101401: LD_EXP 170
101405: PUSH
101406: LD_VAR 0 2
101410: ARRAY
101411: IFFALSE 101620
// begin if GetControl ( vehicle ) = control_manual then
101413: LD_VAR 0 1
101417: PPUSH
101418: CALL_OW 263
101422: PUSH
101423: LD_INT 1
101425: EQUAL
101426: IFFALSE 101507
// begin driver := IsDrivenBy ( vehicle ) ;
101428: LD_ADDR_VAR 0 4
101432: PUSH
101433: LD_VAR 0 1
101437: PPUSH
101438: CALL_OW 311
101442: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101443: LD_VAR 0 4
101447: PPUSH
101448: LD_EXP 170
101452: PUSH
101453: LD_VAR 0 2
101457: ARRAY
101458: PUSH
101459: LD_INT 3
101461: ARRAY
101462: PPUSH
101463: LD_EXP 170
101467: PUSH
101468: LD_VAR 0 2
101472: ARRAY
101473: PUSH
101474: LD_INT 4
101476: ARRAY
101477: PPUSH
101478: CALL_OW 171
// AddComExitVehicle ( driver ) ;
101482: LD_VAR 0 4
101486: PPUSH
101487: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
101491: LD_VAR 0 4
101495: PPUSH
101496: LD_VAR 0 2
101500: PPUSH
101501: CALL_OW 180
// end else
101505: GO 101620
// if GetControl ( vehicle ) = control_remote then
101507: LD_VAR 0 1
101511: PPUSH
101512: CALL_OW 263
101516: PUSH
101517: LD_INT 2
101519: EQUAL
101520: IFFALSE 101581
// begin wait ( 0 0$2 ) ;
101522: LD_INT 70
101524: PPUSH
101525: CALL_OW 67
// if Connect ( vehicle ) then
101529: LD_VAR 0 1
101533: PPUSH
101534: CALL 21721 0 1
101538: IFFALSE 101579
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101540: LD_VAR 0 1
101544: PPUSH
101545: LD_EXP 170
101549: PUSH
101550: LD_VAR 0 2
101554: ARRAY
101555: PUSH
101556: LD_INT 3
101558: ARRAY
101559: PPUSH
101560: LD_EXP 170
101564: PUSH
101565: LD_VAR 0 2
101569: ARRAY
101570: PUSH
101571: LD_INT 4
101573: ARRAY
101574: PPUSH
101575: CALL_OW 171
// end else
101579: GO 101620
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101581: LD_VAR 0 1
101585: PPUSH
101586: LD_EXP 170
101590: PUSH
101591: LD_VAR 0 2
101595: ARRAY
101596: PUSH
101597: LD_INT 3
101599: ARRAY
101600: PPUSH
101601: LD_EXP 170
101605: PUSH
101606: LD_VAR 0 2
101610: ARRAY
101611: PUSH
101612: LD_INT 4
101614: ARRAY
101615: PPUSH
101616: CALL_OW 171
// end ; end ;
101620: LD_VAR 0 3
101624: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101625: LD_INT 0
101627: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101628: LD_VAR 0 1
101632: PUSH
101633: LD_INT 250
101635: EQUAL
101636: PUSH
101637: LD_VAR 0 2
101641: PPUSH
101642: CALL_OW 264
101646: PUSH
101647: LD_EXP 55
101651: EQUAL
101652: AND
101653: IFFALSE 101674
// MinerPlaceMine ( unit , x , y ) ;
101655: LD_VAR 0 2
101659: PPUSH
101660: LD_VAR 0 4
101664: PPUSH
101665: LD_VAR 0 5
101669: PPUSH
101670: CALL 104073 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101674: LD_VAR 0 1
101678: PUSH
101679: LD_INT 251
101681: EQUAL
101682: PUSH
101683: LD_VAR 0 2
101687: PPUSH
101688: CALL_OW 264
101692: PUSH
101693: LD_EXP 55
101697: EQUAL
101698: AND
101699: IFFALSE 101720
// MinerDetonateMine ( unit , x , y ) ;
101701: LD_VAR 0 2
101705: PPUSH
101706: LD_VAR 0 4
101710: PPUSH
101711: LD_VAR 0 5
101715: PPUSH
101716: CALL 104350 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101720: LD_VAR 0 1
101724: PUSH
101725: LD_INT 252
101727: EQUAL
101728: PUSH
101729: LD_VAR 0 2
101733: PPUSH
101734: CALL_OW 264
101738: PUSH
101739: LD_EXP 55
101743: EQUAL
101744: AND
101745: IFFALSE 101766
// MinerCreateMinefield ( unit , x , y ) ;
101747: LD_VAR 0 2
101751: PPUSH
101752: LD_VAR 0 4
101756: PPUSH
101757: LD_VAR 0 5
101761: PPUSH
101762: CALL 104767 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101766: LD_VAR 0 1
101770: PUSH
101771: LD_INT 253
101773: EQUAL
101774: PUSH
101775: LD_VAR 0 2
101779: PPUSH
101780: CALL_OW 257
101784: PUSH
101785: LD_INT 5
101787: EQUAL
101788: AND
101789: IFFALSE 101810
// ComBinocular ( unit , x , y ) ;
101791: LD_VAR 0 2
101795: PPUSH
101796: LD_VAR 0 4
101800: PPUSH
101801: LD_VAR 0 5
101805: PPUSH
101806: CALL 105138 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101810: LD_VAR 0 1
101814: PUSH
101815: LD_INT 254
101817: EQUAL
101818: PUSH
101819: LD_VAR 0 2
101823: PPUSH
101824: CALL_OW 264
101828: PUSH
101829: LD_EXP 50
101833: EQUAL
101834: AND
101835: PUSH
101836: LD_VAR 0 3
101840: PPUSH
101841: CALL_OW 263
101845: PUSH
101846: LD_INT 3
101848: EQUAL
101849: AND
101850: IFFALSE 101866
// HackDestroyVehicle ( unit , selectedUnit ) ;
101852: LD_VAR 0 2
101856: PPUSH
101857: LD_VAR 0 3
101861: PPUSH
101862: CALL 103433 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101866: LD_VAR 0 1
101870: PUSH
101871: LD_INT 255
101873: EQUAL
101874: PUSH
101875: LD_VAR 0 2
101879: PPUSH
101880: CALL_OW 264
101884: PUSH
101885: LD_INT 14
101887: PUSH
101888: LD_INT 53
101890: PUSH
101891: EMPTY
101892: LIST
101893: LIST
101894: IN
101895: AND
101896: PUSH
101897: LD_VAR 0 4
101901: PPUSH
101902: LD_VAR 0 5
101906: PPUSH
101907: CALL_OW 488
101911: AND
101912: IFFALSE 101936
// CutTreeXYR ( unit , x , y , 12 ) ;
101914: LD_VAR 0 2
101918: PPUSH
101919: LD_VAR 0 4
101923: PPUSH
101924: LD_VAR 0 5
101928: PPUSH
101929: LD_INT 12
101931: PPUSH
101932: CALL 101999 0 4
// if cmd = 256 then
101936: LD_VAR 0 1
101940: PUSH
101941: LD_INT 256
101943: EQUAL
101944: IFFALSE 101965
// SetFactoryWaypoint ( unit , x , y ) ;
101946: LD_VAR 0 2
101950: PPUSH
101951: LD_VAR 0 4
101955: PPUSH
101956: LD_VAR 0 5
101960: PPUSH
101961: CALL 99934 0 3
// if cmd = 257 then
101965: LD_VAR 0 1
101969: PUSH
101970: LD_INT 257
101972: EQUAL
101973: IFFALSE 101994
// SetWarehouseGatheringPoint ( unit , x , y ) ;
101975: LD_VAR 0 2
101979: PPUSH
101980: LD_VAR 0 4
101984: PPUSH
101985: LD_VAR 0 5
101989: PPUSH
101990: CALL 100296 0 3
// end ;
101994: LD_VAR 0 6
101998: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101999: LD_INT 0
102001: PPUSH
102002: PPUSH
102003: PPUSH
102004: PPUSH
102005: PPUSH
102006: PPUSH
102007: PPUSH
102008: PPUSH
102009: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102010: LD_VAR 0 1
102014: NOT
102015: PUSH
102016: LD_VAR 0 2
102020: PPUSH
102021: LD_VAR 0 3
102025: PPUSH
102026: CALL_OW 488
102030: NOT
102031: OR
102032: PUSH
102033: LD_VAR 0 4
102037: NOT
102038: OR
102039: IFFALSE 102043
// exit ;
102041: GO 102383
// list := [ ] ;
102043: LD_ADDR_VAR 0 13
102047: PUSH
102048: EMPTY
102049: ST_TO_ADDR
// if x - r < 0 then
102050: LD_VAR 0 2
102054: PUSH
102055: LD_VAR 0 4
102059: MINUS
102060: PUSH
102061: LD_INT 0
102063: LESS
102064: IFFALSE 102076
// min_x := 0 else
102066: LD_ADDR_VAR 0 7
102070: PUSH
102071: LD_INT 0
102073: ST_TO_ADDR
102074: GO 102092
// min_x := x - r ;
102076: LD_ADDR_VAR 0 7
102080: PUSH
102081: LD_VAR 0 2
102085: PUSH
102086: LD_VAR 0 4
102090: MINUS
102091: ST_TO_ADDR
// if y - r < 0 then
102092: LD_VAR 0 3
102096: PUSH
102097: LD_VAR 0 4
102101: MINUS
102102: PUSH
102103: LD_INT 0
102105: LESS
102106: IFFALSE 102118
// min_y := 0 else
102108: LD_ADDR_VAR 0 8
102112: PUSH
102113: LD_INT 0
102115: ST_TO_ADDR
102116: GO 102134
// min_y := y - r ;
102118: LD_ADDR_VAR 0 8
102122: PUSH
102123: LD_VAR 0 3
102127: PUSH
102128: LD_VAR 0 4
102132: MINUS
102133: ST_TO_ADDR
// max_x := x + r ;
102134: LD_ADDR_VAR 0 9
102138: PUSH
102139: LD_VAR 0 2
102143: PUSH
102144: LD_VAR 0 4
102148: PLUS
102149: ST_TO_ADDR
// max_y := y + r ;
102150: LD_ADDR_VAR 0 10
102154: PUSH
102155: LD_VAR 0 3
102159: PUSH
102160: LD_VAR 0 4
102164: PLUS
102165: ST_TO_ADDR
// for _x = min_x to max_x do
102166: LD_ADDR_VAR 0 11
102170: PUSH
102171: DOUBLE
102172: LD_VAR 0 7
102176: DEC
102177: ST_TO_ADDR
102178: LD_VAR 0 9
102182: PUSH
102183: FOR_TO
102184: IFFALSE 102301
// for _y = min_y to max_y do
102186: LD_ADDR_VAR 0 12
102190: PUSH
102191: DOUBLE
102192: LD_VAR 0 8
102196: DEC
102197: ST_TO_ADDR
102198: LD_VAR 0 10
102202: PUSH
102203: FOR_TO
102204: IFFALSE 102297
// begin if not ValidHex ( _x , _y ) then
102206: LD_VAR 0 11
102210: PPUSH
102211: LD_VAR 0 12
102215: PPUSH
102216: CALL_OW 488
102220: NOT
102221: IFFALSE 102225
// continue ;
102223: GO 102203
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102225: LD_VAR 0 11
102229: PPUSH
102230: LD_VAR 0 12
102234: PPUSH
102235: CALL_OW 351
102239: PUSH
102240: LD_VAR 0 11
102244: PPUSH
102245: LD_VAR 0 12
102249: PPUSH
102250: CALL_OW 554
102254: AND
102255: IFFALSE 102295
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102257: LD_ADDR_VAR 0 13
102261: PUSH
102262: LD_VAR 0 13
102266: PPUSH
102267: LD_VAR 0 13
102271: PUSH
102272: LD_INT 1
102274: PLUS
102275: PPUSH
102276: LD_VAR 0 11
102280: PUSH
102281: LD_VAR 0 12
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PPUSH
102290: CALL_OW 2
102294: ST_TO_ADDR
// end ;
102295: GO 102203
102297: POP
102298: POP
102299: GO 102183
102301: POP
102302: POP
// if not list then
102303: LD_VAR 0 13
102307: NOT
102308: IFFALSE 102312
// exit ;
102310: GO 102383
// for i in list do
102312: LD_ADDR_VAR 0 6
102316: PUSH
102317: LD_VAR 0 13
102321: PUSH
102322: FOR_IN
102323: IFFALSE 102381
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102325: LD_VAR 0 1
102329: PPUSH
102330: LD_STRING M
102332: PUSH
102333: LD_VAR 0 6
102337: PUSH
102338: LD_INT 1
102340: ARRAY
102341: PUSH
102342: LD_VAR 0 6
102346: PUSH
102347: LD_INT 2
102349: ARRAY
102350: PUSH
102351: LD_INT 0
102353: PUSH
102354: LD_INT 0
102356: PUSH
102357: LD_INT 0
102359: PUSH
102360: LD_INT 0
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: LIST
102367: LIST
102368: LIST
102369: LIST
102370: LIST
102371: PUSH
102372: EMPTY
102373: LIST
102374: PPUSH
102375: CALL_OW 447
102379: GO 102322
102381: POP
102382: POP
// end ;
102383: LD_VAR 0 5
102387: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102388: LD_EXP 173
102392: NOT
102393: IFFALSE 102443
102395: GO 102397
102397: DISABLE
// begin initHack := true ;
102398: LD_ADDR_EXP 173
102402: PUSH
102403: LD_INT 1
102405: ST_TO_ADDR
// hackTanks := [ ] ;
102406: LD_ADDR_EXP 174
102410: PUSH
102411: EMPTY
102412: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102413: LD_ADDR_EXP 175
102417: PUSH
102418: EMPTY
102419: ST_TO_ADDR
// hackLimit := 3 ;
102420: LD_ADDR_EXP 176
102424: PUSH
102425: LD_INT 3
102427: ST_TO_ADDR
// hackDist := 12 ;
102428: LD_ADDR_EXP 177
102432: PUSH
102433: LD_INT 12
102435: ST_TO_ADDR
// hackCounter := [ ] ;
102436: LD_ADDR_EXP 178
102440: PUSH
102441: EMPTY
102442: ST_TO_ADDR
// end ;
102443: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102444: LD_EXP 173
102448: PUSH
102449: LD_INT 34
102451: PUSH
102452: LD_EXP 50
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PPUSH
102461: CALL_OW 69
102465: AND
102466: IFFALSE 102721
102468: GO 102470
102470: DISABLE
102471: LD_INT 0
102473: PPUSH
102474: PPUSH
// begin enable ;
102475: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102476: LD_ADDR_VAR 0 1
102480: PUSH
102481: LD_INT 34
102483: PUSH
102484: LD_EXP 50
102488: PUSH
102489: EMPTY
102490: LIST
102491: LIST
102492: PPUSH
102493: CALL_OW 69
102497: PUSH
102498: FOR_IN
102499: IFFALSE 102719
// begin if not i in hackTanks then
102501: LD_VAR 0 1
102505: PUSH
102506: LD_EXP 174
102510: IN
102511: NOT
102512: IFFALSE 102595
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102514: LD_ADDR_EXP 174
102518: PUSH
102519: LD_EXP 174
102523: PPUSH
102524: LD_EXP 174
102528: PUSH
102529: LD_INT 1
102531: PLUS
102532: PPUSH
102533: LD_VAR 0 1
102537: PPUSH
102538: CALL_OW 1
102542: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102543: LD_ADDR_EXP 175
102547: PUSH
102548: LD_EXP 175
102552: PPUSH
102553: LD_EXP 175
102557: PUSH
102558: LD_INT 1
102560: PLUS
102561: PPUSH
102562: EMPTY
102563: PPUSH
102564: CALL_OW 1
102568: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102569: LD_ADDR_EXP 178
102573: PUSH
102574: LD_EXP 178
102578: PPUSH
102579: LD_EXP 178
102583: PUSH
102584: LD_INT 1
102586: PLUS
102587: PPUSH
102588: EMPTY
102589: PPUSH
102590: CALL_OW 1
102594: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102595: LD_VAR 0 1
102599: PPUSH
102600: CALL_OW 302
102604: NOT
102605: IFFALSE 102618
// begin HackUnlinkAll ( i ) ;
102607: LD_VAR 0 1
102611: PPUSH
102612: CALL 102724 0 1
// continue ;
102616: GO 102498
// end ; HackCheckCapturedStatus ( i ) ;
102618: LD_VAR 0 1
102622: PPUSH
102623: CALL 103167 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102627: LD_ADDR_VAR 0 2
102631: PUSH
102632: LD_INT 81
102634: PUSH
102635: LD_VAR 0 1
102639: PPUSH
102640: CALL_OW 255
102644: PUSH
102645: EMPTY
102646: LIST
102647: LIST
102648: PUSH
102649: LD_INT 33
102651: PUSH
102652: LD_INT 3
102654: PUSH
102655: EMPTY
102656: LIST
102657: LIST
102658: PUSH
102659: LD_INT 91
102661: PUSH
102662: LD_VAR 0 1
102666: PUSH
102667: LD_EXP 177
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: LIST
102676: PUSH
102677: LD_INT 50
102679: PUSH
102680: EMPTY
102681: LIST
102682: PUSH
102683: EMPTY
102684: LIST
102685: LIST
102686: LIST
102687: LIST
102688: PPUSH
102689: CALL_OW 69
102693: ST_TO_ADDR
// if not tmp then
102694: LD_VAR 0 2
102698: NOT
102699: IFFALSE 102703
// continue ;
102701: GO 102498
// HackLink ( i , tmp ) ;
102703: LD_VAR 0 1
102707: PPUSH
102708: LD_VAR 0 2
102712: PPUSH
102713: CALL 102860 0 2
// end ;
102717: GO 102498
102719: POP
102720: POP
// end ;
102721: PPOPN 2
102723: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102724: LD_INT 0
102726: PPUSH
102727: PPUSH
102728: PPUSH
// if not hack in hackTanks then
102729: LD_VAR 0 1
102733: PUSH
102734: LD_EXP 174
102738: IN
102739: NOT
102740: IFFALSE 102744
// exit ;
102742: GO 102855
// index := GetElementIndex ( hackTanks , hack ) ;
102744: LD_ADDR_VAR 0 4
102748: PUSH
102749: LD_EXP 174
102753: PPUSH
102754: LD_VAR 0 1
102758: PPUSH
102759: CALL 18535 0 2
102763: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102764: LD_EXP 175
102768: PUSH
102769: LD_VAR 0 4
102773: ARRAY
102774: IFFALSE 102855
// begin for i in hackTanksCaptured [ index ] do
102776: LD_ADDR_VAR 0 3
102780: PUSH
102781: LD_EXP 175
102785: PUSH
102786: LD_VAR 0 4
102790: ARRAY
102791: PUSH
102792: FOR_IN
102793: IFFALSE 102819
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102795: LD_VAR 0 3
102799: PUSH
102800: LD_INT 1
102802: ARRAY
102803: PPUSH
102804: LD_VAR 0 3
102808: PUSH
102809: LD_INT 2
102811: ARRAY
102812: PPUSH
102813: CALL_OW 235
102817: GO 102792
102819: POP
102820: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102821: LD_ADDR_EXP 175
102825: PUSH
102826: LD_EXP 175
102830: PPUSH
102831: LD_VAR 0 4
102835: PPUSH
102836: EMPTY
102837: PPUSH
102838: CALL_OW 1
102842: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102843: LD_VAR 0 1
102847: PPUSH
102848: LD_INT 0
102850: PPUSH
102851: CALL_OW 505
// end ; end ;
102855: LD_VAR 0 2
102859: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102860: LD_INT 0
102862: PPUSH
102863: PPUSH
102864: PPUSH
// if not hack in hackTanks or not vehicles then
102865: LD_VAR 0 1
102869: PUSH
102870: LD_EXP 174
102874: IN
102875: NOT
102876: PUSH
102877: LD_VAR 0 2
102881: NOT
102882: OR
102883: IFFALSE 102887
// exit ;
102885: GO 103162
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102887: LD_ADDR_VAR 0 2
102891: PUSH
102892: LD_VAR 0 1
102896: PPUSH
102897: LD_VAR 0 2
102901: PPUSH
102902: LD_INT 1
102904: PPUSH
102905: LD_INT 1
102907: PPUSH
102908: CALL 19185 0 4
102912: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102913: LD_ADDR_VAR 0 5
102917: PUSH
102918: LD_EXP 174
102922: PPUSH
102923: LD_VAR 0 1
102927: PPUSH
102928: CALL 18535 0 2
102932: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102933: LD_EXP 175
102937: PUSH
102938: LD_VAR 0 5
102942: ARRAY
102943: PUSH
102944: LD_EXP 176
102948: LESS
102949: IFFALSE 103138
// begin for i := 1 to vehicles do
102951: LD_ADDR_VAR 0 4
102955: PUSH
102956: DOUBLE
102957: LD_INT 1
102959: DEC
102960: ST_TO_ADDR
102961: LD_VAR 0 2
102965: PUSH
102966: FOR_TO
102967: IFFALSE 103136
// begin if hackTanksCaptured [ index ] = hackLimit then
102969: LD_EXP 175
102973: PUSH
102974: LD_VAR 0 5
102978: ARRAY
102979: PUSH
102980: LD_EXP 176
102984: EQUAL
102985: IFFALSE 102989
// break ;
102987: GO 103136
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102989: LD_ADDR_EXP 178
102993: PUSH
102994: LD_EXP 178
102998: PPUSH
102999: LD_VAR 0 5
103003: PPUSH
103004: LD_EXP 178
103008: PUSH
103009: LD_VAR 0 5
103013: ARRAY
103014: PUSH
103015: LD_INT 1
103017: PLUS
103018: PPUSH
103019: CALL_OW 1
103023: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103024: LD_ADDR_EXP 175
103028: PUSH
103029: LD_EXP 175
103033: PPUSH
103034: LD_VAR 0 5
103038: PUSH
103039: LD_EXP 175
103043: PUSH
103044: LD_VAR 0 5
103048: ARRAY
103049: PUSH
103050: LD_INT 1
103052: PLUS
103053: PUSH
103054: EMPTY
103055: LIST
103056: LIST
103057: PPUSH
103058: LD_VAR 0 2
103062: PUSH
103063: LD_VAR 0 4
103067: ARRAY
103068: PUSH
103069: LD_VAR 0 2
103073: PUSH
103074: LD_VAR 0 4
103078: ARRAY
103079: PPUSH
103080: CALL_OW 255
103084: PUSH
103085: EMPTY
103086: LIST
103087: LIST
103088: PPUSH
103089: CALL 18750 0 3
103093: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103094: LD_VAR 0 2
103098: PUSH
103099: LD_VAR 0 4
103103: ARRAY
103104: PPUSH
103105: LD_VAR 0 1
103109: PPUSH
103110: CALL_OW 255
103114: PPUSH
103115: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103119: LD_VAR 0 2
103123: PUSH
103124: LD_VAR 0 4
103128: ARRAY
103129: PPUSH
103130: CALL_OW 141
// end ;
103134: GO 102966
103136: POP
103137: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103138: LD_VAR 0 1
103142: PPUSH
103143: LD_EXP 175
103147: PUSH
103148: LD_VAR 0 5
103152: ARRAY
103153: PUSH
103154: LD_INT 0
103156: PLUS
103157: PPUSH
103158: CALL_OW 505
// end ;
103162: LD_VAR 0 3
103166: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103167: LD_INT 0
103169: PPUSH
103170: PPUSH
103171: PPUSH
103172: PPUSH
// if not hack in hackTanks then
103173: LD_VAR 0 1
103177: PUSH
103178: LD_EXP 174
103182: IN
103183: NOT
103184: IFFALSE 103188
// exit ;
103186: GO 103428
// index := GetElementIndex ( hackTanks , hack ) ;
103188: LD_ADDR_VAR 0 4
103192: PUSH
103193: LD_EXP 174
103197: PPUSH
103198: LD_VAR 0 1
103202: PPUSH
103203: CALL 18535 0 2
103207: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103208: LD_ADDR_VAR 0 3
103212: PUSH
103213: DOUBLE
103214: LD_EXP 175
103218: PUSH
103219: LD_VAR 0 4
103223: ARRAY
103224: INC
103225: ST_TO_ADDR
103226: LD_INT 1
103228: PUSH
103229: FOR_DOWNTO
103230: IFFALSE 103402
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103232: LD_ADDR_VAR 0 5
103236: PUSH
103237: LD_EXP 175
103241: PUSH
103242: LD_VAR 0 4
103246: ARRAY
103247: PUSH
103248: LD_VAR 0 3
103252: ARRAY
103253: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103254: LD_VAR 0 5
103258: PUSH
103259: LD_INT 1
103261: ARRAY
103262: PPUSH
103263: CALL_OW 302
103267: NOT
103268: PUSH
103269: LD_VAR 0 5
103273: PUSH
103274: LD_INT 1
103276: ARRAY
103277: PPUSH
103278: CALL_OW 255
103282: PUSH
103283: LD_VAR 0 1
103287: PPUSH
103288: CALL_OW 255
103292: NONEQUAL
103293: OR
103294: IFFALSE 103400
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103296: LD_VAR 0 5
103300: PUSH
103301: LD_INT 1
103303: ARRAY
103304: PPUSH
103305: CALL_OW 305
103309: PUSH
103310: LD_VAR 0 5
103314: PUSH
103315: LD_INT 1
103317: ARRAY
103318: PPUSH
103319: CALL_OW 255
103323: PUSH
103324: LD_VAR 0 1
103328: PPUSH
103329: CALL_OW 255
103333: EQUAL
103334: AND
103335: IFFALSE 103359
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103337: LD_VAR 0 5
103341: PUSH
103342: LD_INT 1
103344: ARRAY
103345: PPUSH
103346: LD_VAR 0 5
103350: PUSH
103351: LD_INT 2
103353: ARRAY
103354: PPUSH
103355: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103359: LD_ADDR_EXP 175
103363: PUSH
103364: LD_EXP 175
103368: PPUSH
103369: LD_VAR 0 4
103373: PPUSH
103374: LD_EXP 175
103378: PUSH
103379: LD_VAR 0 4
103383: ARRAY
103384: PPUSH
103385: LD_VAR 0 3
103389: PPUSH
103390: CALL_OW 3
103394: PPUSH
103395: CALL_OW 1
103399: ST_TO_ADDR
// end ; end ;
103400: GO 103229
103402: POP
103403: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103404: LD_VAR 0 1
103408: PPUSH
103409: LD_EXP 175
103413: PUSH
103414: LD_VAR 0 4
103418: ARRAY
103419: PUSH
103420: LD_INT 0
103422: PLUS
103423: PPUSH
103424: CALL_OW 505
// end ;
103428: LD_VAR 0 2
103432: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103433: LD_INT 0
103435: PPUSH
103436: PPUSH
103437: PPUSH
103438: PPUSH
// if not hack in hackTanks then
103439: LD_VAR 0 1
103443: PUSH
103444: LD_EXP 174
103448: IN
103449: NOT
103450: IFFALSE 103454
// exit ;
103452: GO 103539
// index := GetElementIndex ( hackTanks , hack ) ;
103454: LD_ADDR_VAR 0 5
103458: PUSH
103459: LD_EXP 174
103463: PPUSH
103464: LD_VAR 0 1
103468: PPUSH
103469: CALL 18535 0 2
103473: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103474: LD_ADDR_VAR 0 4
103478: PUSH
103479: DOUBLE
103480: LD_INT 1
103482: DEC
103483: ST_TO_ADDR
103484: LD_EXP 175
103488: PUSH
103489: LD_VAR 0 5
103493: ARRAY
103494: PUSH
103495: FOR_TO
103496: IFFALSE 103537
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103498: LD_EXP 175
103502: PUSH
103503: LD_VAR 0 5
103507: ARRAY
103508: PUSH
103509: LD_VAR 0 4
103513: ARRAY
103514: PUSH
103515: LD_INT 1
103517: ARRAY
103518: PUSH
103519: LD_VAR 0 2
103523: EQUAL
103524: IFFALSE 103535
// KillUnit ( vehicle ) ;
103526: LD_VAR 0 2
103530: PPUSH
103531: CALL_OW 66
103535: GO 103495
103537: POP
103538: POP
// end ;
103539: LD_VAR 0 3
103543: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103544: LD_EXP 179
103548: NOT
103549: IFFALSE 103584
103551: GO 103553
103553: DISABLE
// begin initMiner := true ;
103554: LD_ADDR_EXP 179
103558: PUSH
103559: LD_INT 1
103561: ST_TO_ADDR
// minersList := [ ] ;
103562: LD_ADDR_EXP 180
103566: PUSH
103567: EMPTY
103568: ST_TO_ADDR
// minerMinesList := [ ] ;
103569: LD_ADDR_EXP 181
103573: PUSH
103574: EMPTY
103575: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103576: LD_ADDR_EXP 182
103580: PUSH
103581: LD_INT 5
103583: ST_TO_ADDR
// end ;
103584: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103585: LD_EXP 179
103589: PUSH
103590: LD_INT 34
103592: PUSH
103593: LD_EXP 55
103597: PUSH
103598: EMPTY
103599: LIST
103600: LIST
103601: PPUSH
103602: CALL_OW 69
103606: AND
103607: IFFALSE 104070
103609: GO 103611
103611: DISABLE
103612: LD_INT 0
103614: PPUSH
103615: PPUSH
103616: PPUSH
103617: PPUSH
// begin enable ;
103618: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103619: LD_ADDR_VAR 0 1
103623: PUSH
103624: LD_INT 34
103626: PUSH
103627: LD_EXP 55
103631: PUSH
103632: EMPTY
103633: LIST
103634: LIST
103635: PPUSH
103636: CALL_OW 69
103640: PUSH
103641: FOR_IN
103642: IFFALSE 103714
// begin if not i in minersList then
103644: LD_VAR 0 1
103648: PUSH
103649: LD_EXP 180
103653: IN
103654: NOT
103655: IFFALSE 103712
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103657: LD_ADDR_EXP 180
103661: PUSH
103662: LD_EXP 180
103666: PPUSH
103667: LD_EXP 180
103671: PUSH
103672: LD_INT 1
103674: PLUS
103675: PPUSH
103676: LD_VAR 0 1
103680: PPUSH
103681: CALL_OW 1
103685: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103686: LD_ADDR_EXP 181
103690: PUSH
103691: LD_EXP 181
103695: PPUSH
103696: LD_EXP 181
103700: PUSH
103701: LD_INT 1
103703: PLUS
103704: PPUSH
103705: EMPTY
103706: PPUSH
103707: CALL_OW 1
103711: ST_TO_ADDR
// end end ;
103712: GO 103641
103714: POP
103715: POP
// for i := minerMinesList downto 1 do
103716: LD_ADDR_VAR 0 1
103720: PUSH
103721: DOUBLE
103722: LD_EXP 181
103726: INC
103727: ST_TO_ADDR
103728: LD_INT 1
103730: PUSH
103731: FOR_DOWNTO
103732: IFFALSE 104068
// begin if IsLive ( minersList [ i ] ) then
103734: LD_EXP 180
103738: PUSH
103739: LD_VAR 0 1
103743: ARRAY
103744: PPUSH
103745: CALL_OW 300
103749: IFFALSE 103777
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103751: LD_EXP 180
103755: PUSH
103756: LD_VAR 0 1
103760: ARRAY
103761: PPUSH
103762: LD_EXP 181
103766: PUSH
103767: LD_VAR 0 1
103771: ARRAY
103772: PPUSH
103773: CALL_OW 505
// if not minerMinesList [ i ] then
103777: LD_EXP 181
103781: PUSH
103782: LD_VAR 0 1
103786: ARRAY
103787: NOT
103788: IFFALSE 103792
// continue ;
103790: GO 103731
// for j := minerMinesList [ i ] downto 1 do
103792: LD_ADDR_VAR 0 2
103796: PUSH
103797: DOUBLE
103798: LD_EXP 181
103802: PUSH
103803: LD_VAR 0 1
103807: ARRAY
103808: INC
103809: ST_TO_ADDR
103810: LD_INT 1
103812: PUSH
103813: FOR_DOWNTO
103814: IFFALSE 104064
// begin side := GetSide ( minersList [ i ] ) ;
103816: LD_ADDR_VAR 0 3
103820: PUSH
103821: LD_EXP 180
103825: PUSH
103826: LD_VAR 0 1
103830: ARRAY
103831: PPUSH
103832: CALL_OW 255
103836: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103837: LD_ADDR_VAR 0 4
103841: PUSH
103842: LD_EXP 181
103846: PUSH
103847: LD_VAR 0 1
103851: ARRAY
103852: PUSH
103853: LD_VAR 0 2
103857: ARRAY
103858: PUSH
103859: LD_INT 1
103861: ARRAY
103862: PPUSH
103863: LD_EXP 181
103867: PUSH
103868: LD_VAR 0 1
103872: ARRAY
103873: PUSH
103874: LD_VAR 0 2
103878: ARRAY
103879: PUSH
103880: LD_INT 2
103882: ARRAY
103883: PPUSH
103884: CALL_OW 428
103888: ST_TO_ADDR
// if not tmp then
103889: LD_VAR 0 4
103893: NOT
103894: IFFALSE 103898
// continue ;
103896: GO 103813
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103898: LD_VAR 0 4
103902: PUSH
103903: LD_INT 81
103905: PUSH
103906: LD_VAR 0 3
103910: PUSH
103911: EMPTY
103912: LIST
103913: LIST
103914: PPUSH
103915: CALL_OW 69
103919: IN
103920: PUSH
103921: LD_EXP 181
103925: PUSH
103926: LD_VAR 0 1
103930: ARRAY
103931: PUSH
103932: LD_VAR 0 2
103936: ARRAY
103937: PUSH
103938: LD_INT 1
103940: ARRAY
103941: PPUSH
103942: LD_EXP 181
103946: PUSH
103947: LD_VAR 0 1
103951: ARRAY
103952: PUSH
103953: LD_VAR 0 2
103957: ARRAY
103958: PUSH
103959: LD_INT 2
103961: ARRAY
103962: PPUSH
103963: CALL_OW 458
103967: AND
103968: IFFALSE 104062
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103970: LD_EXP 181
103974: PUSH
103975: LD_VAR 0 1
103979: ARRAY
103980: PUSH
103981: LD_VAR 0 2
103985: ARRAY
103986: PUSH
103987: LD_INT 1
103989: ARRAY
103990: PPUSH
103991: LD_EXP 181
103995: PUSH
103996: LD_VAR 0 1
104000: ARRAY
104001: PUSH
104002: LD_VAR 0 2
104006: ARRAY
104007: PUSH
104008: LD_INT 2
104010: ARRAY
104011: PPUSH
104012: LD_VAR 0 3
104016: PPUSH
104017: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104021: LD_ADDR_EXP 181
104025: PUSH
104026: LD_EXP 181
104030: PPUSH
104031: LD_VAR 0 1
104035: PPUSH
104036: LD_EXP 181
104040: PUSH
104041: LD_VAR 0 1
104045: ARRAY
104046: PPUSH
104047: LD_VAR 0 2
104051: PPUSH
104052: CALL_OW 3
104056: PPUSH
104057: CALL_OW 1
104061: ST_TO_ADDR
// end ; end ;
104062: GO 103813
104064: POP
104065: POP
// end ;
104066: GO 103731
104068: POP
104069: POP
// end ;
104070: PPOPN 4
104072: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104073: LD_INT 0
104075: PPUSH
104076: PPUSH
// result := false ;
104077: LD_ADDR_VAR 0 4
104081: PUSH
104082: LD_INT 0
104084: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104085: LD_VAR 0 1
104089: PPUSH
104090: CALL_OW 264
104094: PUSH
104095: LD_EXP 55
104099: EQUAL
104100: NOT
104101: IFFALSE 104105
// exit ;
104103: GO 104345
// index := GetElementIndex ( minersList , unit ) ;
104105: LD_ADDR_VAR 0 5
104109: PUSH
104110: LD_EXP 180
104114: PPUSH
104115: LD_VAR 0 1
104119: PPUSH
104120: CALL 18535 0 2
104124: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104125: LD_EXP 181
104129: PUSH
104130: LD_VAR 0 5
104134: ARRAY
104135: PUSH
104136: LD_EXP 182
104140: GREATEREQUAL
104141: IFFALSE 104145
// exit ;
104143: GO 104345
// ComMoveXY ( unit , x , y ) ;
104145: LD_VAR 0 1
104149: PPUSH
104150: LD_VAR 0 2
104154: PPUSH
104155: LD_VAR 0 3
104159: PPUSH
104160: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104164: LD_INT 35
104166: PPUSH
104167: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104171: LD_VAR 0 1
104175: PPUSH
104176: LD_VAR 0 2
104180: PPUSH
104181: LD_VAR 0 3
104185: PPUSH
104186: CALL 49804 0 3
104190: NOT
104191: PUSH
104192: LD_VAR 0 1
104196: PPUSH
104197: CALL_OW 314
104201: AND
104202: IFFALSE 104206
// exit ;
104204: GO 104345
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104206: LD_VAR 0 2
104210: PPUSH
104211: LD_VAR 0 3
104215: PPUSH
104216: CALL_OW 428
104220: PUSH
104221: LD_VAR 0 1
104225: EQUAL
104226: PUSH
104227: LD_VAR 0 1
104231: PPUSH
104232: CALL_OW 314
104236: NOT
104237: AND
104238: IFFALSE 104164
// PlaySoundXY ( x , y , PlantMine ) ;
104240: LD_VAR 0 2
104244: PPUSH
104245: LD_VAR 0 3
104249: PPUSH
104250: LD_STRING PlantMine
104252: PPUSH
104253: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104257: LD_VAR 0 2
104261: PPUSH
104262: LD_VAR 0 3
104266: PPUSH
104267: LD_VAR 0 1
104271: PPUSH
104272: CALL_OW 255
104276: PPUSH
104277: LD_INT 0
104279: PPUSH
104280: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104284: LD_ADDR_EXP 181
104288: PUSH
104289: LD_EXP 181
104293: PPUSH
104294: LD_VAR 0 5
104298: PUSH
104299: LD_EXP 181
104303: PUSH
104304: LD_VAR 0 5
104308: ARRAY
104309: PUSH
104310: LD_INT 1
104312: PLUS
104313: PUSH
104314: EMPTY
104315: LIST
104316: LIST
104317: PPUSH
104318: LD_VAR 0 2
104322: PUSH
104323: LD_VAR 0 3
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: PPUSH
104332: CALL 18750 0 3
104336: ST_TO_ADDR
// result := true ;
104337: LD_ADDR_VAR 0 4
104341: PUSH
104342: LD_INT 1
104344: ST_TO_ADDR
// end ;
104345: LD_VAR 0 4
104349: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104350: LD_INT 0
104352: PPUSH
104353: PPUSH
104354: PPUSH
// if not unit in minersList then
104355: LD_VAR 0 1
104359: PUSH
104360: LD_EXP 180
104364: IN
104365: NOT
104366: IFFALSE 104370
// exit ;
104368: GO 104762
// index := GetElementIndex ( minersList , unit ) ;
104370: LD_ADDR_VAR 0 6
104374: PUSH
104375: LD_EXP 180
104379: PPUSH
104380: LD_VAR 0 1
104384: PPUSH
104385: CALL 18535 0 2
104389: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104390: LD_ADDR_VAR 0 5
104394: PUSH
104395: DOUBLE
104396: LD_EXP 181
104400: PUSH
104401: LD_VAR 0 6
104405: ARRAY
104406: INC
104407: ST_TO_ADDR
104408: LD_INT 1
104410: PUSH
104411: FOR_DOWNTO
104412: IFFALSE 104573
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104414: LD_EXP 181
104418: PUSH
104419: LD_VAR 0 6
104423: ARRAY
104424: PUSH
104425: LD_VAR 0 5
104429: ARRAY
104430: PUSH
104431: LD_INT 1
104433: ARRAY
104434: PUSH
104435: LD_VAR 0 2
104439: EQUAL
104440: PUSH
104441: LD_EXP 181
104445: PUSH
104446: LD_VAR 0 6
104450: ARRAY
104451: PUSH
104452: LD_VAR 0 5
104456: ARRAY
104457: PUSH
104458: LD_INT 2
104460: ARRAY
104461: PUSH
104462: LD_VAR 0 3
104466: EQUAL
104467: AND
104468: IFFALSE 104571
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104470: LD_EXP 181
104474: PUSH
104475: LD_VAR 0 6
104479: ARRAY
104480: PUSH
104481: LD_VAR 0 5
104485: ARRAY
104486: PUSH
104487: LD_INT 1
104489: ARRAY
104490: PPUSH
104491: LD_EXP 181
104495: PUSH
104496: LD_VAR 0 6
104500: ARRAY
104501: PUSH
104502: LD_VAR 0 5
104506: ARRAY
104507: PUSH
104508: LD_INT 2
104510: ARRAY
104511: PPUSH
104512: LD_VAR 0 1
104516: PPUSH
104517: CALL_OW 255
104521: PPUSH
104522: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104526: LD_ADDR_EXP 181
104530: PUSH
104531: LD_EXP 181
104535: PPUSH
104536: LD_VAR 0 6
104540: PPUSH
104541: LD_EXP 181
104545: PUSH
104546: LD_VAR 0 6
104550: ARRAY
104551: PPUSH
104552: LD_VAR 0 5
104556: PPUSH
104557: CALL_OW 3
104561: PPUSH
104562: CALL_OW 1
104566: ST_TO_ADDR
// exit ;
104567: POP
104568: POP
104569: GO 104762
// end ; end ;
104571: GO 104411
104573: POP
104574: POP
// for i := minerMinesList [ index ] downto 1 do
104575: LD_ADDR_VAR 0 5
104579: PUSH
104580: DOUBLE
104581: LD_EXP 181
104585: PUSH
104586: LD_VAR 0 6
104590: ARRAY
104591: INC
104592: ST_TO_ADDR
104593: LD_INT 1
104595: PUSH
104596: FOR_DOWNTO
104597: IFFALSE 104760
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104599: LD_EXP 181
104603: PUSH
104604: LD_VAR 0 6
104608: ARRAY
104609: PUSH
104610: LD_VAR 0 5
104614: ARRAY
104615: PUSH
104616: LD_INT 1
104618: ARRAY
104619: PPUSH
104620: LD_EXP 181
104624: PUSH
104625: LD_VAR 0 6
104629: ARRAY
104630: PUSH
104631: LD_VAR 0 5
104635: ARRAY
104636: PUSH
104637: LD_INT 2
104639: ARRAY
104640: PPUSH
104641: LD_VAR 0 2
104645: PPUSH
104646: LD_VAR 0 3
104650: PPUSH
104651: CALL_OW 298
104655: PUSH
104656: LD_INT 6
104658: LESS
104659: IFFALSE 104758
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104661: LD_EXP 181
104665: PUSH
104666: LD_VAR 0 6
104670: ARRAY
104671: PUSH
104672: LD_VAR 0 5
104676: ARRAY
104677: PUSH
104678: LD_INT 1
104680: ARRAY
104681: PPUSH
104682: LD_EXP 181
104686: PUSH
104687: LD_VAR 0 6
104691: ARRAY
104692: PUSH
104693: LD_VAR 0 5
104697: ARRAY
104698: PUSH
104699: LD_INT 2
104701: ARRAY
104702: PPUSH
104703: LD_VAR 0 1
104707: PPUSH
104708: CALL_OW 255
104712: PPUSH
104713: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104717: LD_ADDR_EXP 181
104721: PUSH
104722: LD_EXP 181
104726: PPUSH
104727: LD_VAR 0 6
104731: PPUSH
104732: LD_EXP 181
104736: PUSH
104737: LD_VAR 0 6
104741: ARRAY
104742: PPUSH
104743: LD_VAR 0 5
104747: PPUSH
104748: CALL_OW 3
104752: PPUSH
104753: CALL_OW 1
104757: ST_TO_ADDR
// end ; end ;
104758: GO 104596
104760: POP
104761: POP
// end ;
104762: LD_VAR 0 4
104766: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104767: LD_INT 0
104769: PPUSH
104770: PPUSH
104771: PPUSH
104772: PPUSH
104773: PPUSH
104774: PPUSH
104775: PPUSH
104776: PPUSH
104777: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104778: LD_VAR 0 1
104782: PPUSH
104783: CALL_OW 264
104787: PUSH
104788: LD_EXP 55
104792: EQUAL
104793: NOT
104794: PUSH
104795: LD_VAR 0 1
104799: PUSH
104800: LD_EXP 180
104804: IN
104805: NOT
104806: OR
104807: IFFALSE 104811
// exit ;
104809: GO 105133
// index := GetElementIndex ( minersList , unit ) ;
104811: LD_ADDR_VAR 0 6
104815: PUSH
104816: LD_EXP 180
104820: PPUSH
104821: LD_VAR 0 1
104825: PPUSH
104826: CALL 18535 0 2
104830: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104831: LD_ADDR_VAR 0 8
104835: PUSH
104836: LD_EXP 182
104840: PUSH
104841: LD_EXP 181
104845: PUSH
104846: LD_VAR 0 6
104850: ARRAY
104851: MINUS
104852: ST_TO_ADDR
// if not minesFreeAmount then
104853: LD_VAR 0 8
104857: NOT
104858: IFFALSE 104862
// exit ;
104860: GO 105133
// tmp := [ ] ;
104862: LD_ADDR_VAR 0 7
104866: PUSH
104867: EMPTY
104868: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104869: LD_ADDR_VAR 0 5
104873: PUSH
104874: DOUBLE
104875: LD_INT 1
104877: DEC
104878: ST_TO_ADDR
104879: LD_VAR 0 8
104883: PUSH
104884: FOR_TO
104885: IFFALSE 105080
// begin _d := rand ( 0 , 5 ) ;
104887: LD_ADDR_VAR 0 11
104891: PUSH
104892: LD_INT 0
104894: PPUSH
104895: LD_INT 5
104897: PPUSH
104898: CALL_OW 12
104902: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104903: LD_ADDR_VAR 0 12
104907: PUSH
104908: LD_INT 2
104910: PPUSH
104911: LD_INT 6
104913: PPUSH
104914: CALL_OW 12
104918: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104919: LD_ADDR_VAR 0 9
104923: PUSH
104924: LD_VAR 0 2
104928: PPUSH
104929: LD_VAR 0 11
104933: PPUSH
104934: LD_VAR 0 12
104938: PPUSH
104939: CALL_OW 272
104943: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104944: LD_ADDR_VAR 0 10
104948: PUSH
104949: LD_VAR 0 3
104953: PPUSH
104954: LD_VAR 0 11
104958: PPUSH
104959: LD_VAR 0 12
104963: PPUSH
104964: CALL_OW 273
104968: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104969: LD_VAR 0 9
104973: PPUSH
104974: LD_VAR 0 10
104978: PPUSH
104979: CALL_OW 488
104983: PUSH
104984: LD_VAR 0 9
104988: PUSH
104989: LD_VAR 0 10
104993: PUSH
104994: EMPTY
104995: LIST
104996: LIST
104997: PUSH
104998: LD_VAR 0 7
105002: IN
105003: NOT
105004: AND
105005: PUSH
105006: LD_VAR 0 9
105010: PPUSH
105011: LD_VAR 0 10
105015: PPUSH
105016: CALL_OW 458
105020: NOT
105021: AND
105022: IFFALSE 105064
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105024: LD_ADDR_VAR 0 7
105028: PUSH
105029: LD_VAR 0 7
105033: PPUSH
105034: LD_VAR 0 7
105038: PUSH
105039: LD_INT 1
105041: PLUS
105042: PPUSH
105043: LD_VAR 0 9
105047: PUSH
105048: LD_VAR 0 10
105052: PUSH
105053: EMPTY
105054: LIST
105055: LIST
105056: PPUSH
105057: CALL_OW 1
105061: ST_TO_ADDR
105062: GO 105078
// i := i - 1 ;
105064: LD_ADDR_VAR 0 5
105068: PUSH
105069: LD_VAR 0 5
105073: PUSH
105074: LD_INT 1
105076: MINUS
105077: ST_TO_ADDR
// end ;
105078: GO 104884
105080: POP
105081: POP
// for i in tmp do
105082: LD_ADDR_VAR 0 5
105086: PUSH
105087: LD_VAR 0 7
105091: PUSH
105092: FOR_IN
105093: IFFALSE 105131
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105095: LD_VAR 0 1
105099: PPUSH
105100: LD_VAR 0 5
105104: PUSH
105105: LD_INT 1
105107: ARRAY
105108: PPUSH
105109: LD_VAR 0 5
105113: PUSH
105114: LD_INT 2
105116: ARRAY
105117: PPUSH
105118: CALL 104073 0 3
105122: NOT
105123: IFFALSE 105129
// exit ;
105125: POP
105126: POP
105127: GO 105133
105129: GO 105092
105131: POP
105132: POP
// end ;
105133: LD_VAR 0 4
105137: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105138: LD_INT 0
105140: PPUSH
105141: PPUSH
105142: PPUSH
105143: PPUSH
105144: PPUSH
105145: PPUSH
105146: PPUSH
// if not GetClass ( unit ) = class_sniper then
105147: LD_VAR 0 1
105151: PPUSH
105152: CALL_OW 257
105156: PUSH
105157: LD_INT 5
105159: EQUAL
105160: NOT
105161: IFFALSE 105165
// exit ;
105163: GO 105553
// dist := 8 ;
105165: LD_ADDR_VAR 0 5
105169: PUSH
105170: LD_INT 8
105172: ST_TO_ADDR
// viewRange := 12 ;
105173: LD_ADDR_VAR 0 7
105177: PUSH
105178: LD_INT 12
105180: ST_TO_ADDR
// side := GetSide ( unit ) ;
105181: LD_ADDR_VAR 0 6
105185: PUSH
105186: LD_VAR 0 1
105190: PPUSH
105191: CALL_OW 255
105195: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105196: LD_INT 61
105198: PPUSH
105199: LD_VAR 0 6
105203: PPUSH
105204: CALL_OW 321
105208: PUSH
105209: LD_INT 2
105211: EQUAL
105212: IFFALSE 105222
// viewRange := 16 ;
105214: LD_ADDR_VAR 0 7
105218: PUSH
105219: LD_INT 16
105221: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105222: LD_VAR 0 1
105226: PPUSH
105227: LD_VAR 0 2
105231: PPUSH
105232: LD_VAR 0 3
105236: PPUSH
105237: CALL_OW 297
105241: PUSH
105242: LD_VAR 0 5
105246: GREATER
105247: IFFALSE 105326
// begin ComMoveXY ( unit , x , y ) ;
105249: LD_VAR 0 1
105253: PPUSH
105254: LD_VAR 0 2
105258: PPUSH
105259: LD_VAR 0 3
105263: PPUSH
105264: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105268: LD_INT 35
105270: PPUSH
105271: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105275: LD_VAR 0 1
105279: PPUSH
105280: LD_VAR 0 2
105284: PPUSH
105285: LD_VAR 0 3
105289: PPUSH
105290: CALL 49804 0 3
105294: NOT
105295: IFFALSE 105299
// exit ;
105297: GO 105553
// until GetDistUnitXY ( unit , x , y ) < dist ;
105299: LD_VAR 0 1
105303: PPUSH
105304: LD_VAR 0 2
105308: PPUSH
105309: LD_VAR 0 3
105313: PPUSH
105314: CALL_OW 297
105318: PUSH
105319: LD_VAR 0 5
105323: LESS
105324: IFFALSE 105268
// end ; ComTurnXY ( unit , x , y ) ;
105326: LD_VAR 0 1
105330: PPUSH
105331: LD_VAR 0 2
105335: PPUSH
105336: LD_VAR 0 3
105340: PPUSH
105341: CALL_OW 118
// wait ( 5 ) ;
105345: LD_INT 5
105347: PPUSH
105348: CALL_OW 67
// _d := GetDir ( unit ) ;
105352: LD_ADDR_VAR 0 10
105356: PUSH
105357: LD_VAR 0 1
105361: PPUSH
105362: CALL_OW 254
105366: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105367: LD_ADDR_VAR 0 8
105371: PUSH
105372: LD_VAR 0 1
105376: PPUSH
105377: CALL_OW 250
105381: PPUSH
105382: LD_VAR 0 10
105386: PPUSH
105387: LD_VAR 0 5
105391: PPUSH
105392: CALL_OW 272
105396: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105397: LD_ADDR_VAR 0 9
105401: PUSH
105402: LD_VAR 0 1
105406: PPUSH
105407: CALL_OW 251
105411: PPUSH
105412: LD_VAR 0 10
105416: PPUSH
105417: LD_VAR 0 5
105421: PPUSH
105422: CALL_OW 273
105426: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105427: LD_VAR 0 8
105431: PPUSH
105432: LD_VAR 0 9
105436: PPUSH
105437: CALL_OW 488
105441: NOT
105442: IFFALSE 105446
// exit ;
105444: GO 105553
// ComAnimCustom ( unit , 1 ) ;
105446: LD_VAR 0 1
105450: PPUSH
105451: LD_INT 1
105453: PPUSH
105454: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105458: LD_VAR 0 8
105462: PPUSH
105463: LD_VAR 0 9
105467: PPUSH
105468: LD_VAR 0 6
105472: PPUSH
105473: LD_VAR 0 7
105477: PPUSH
105478: CALL_OW 330
// repeat wait ( 1 ) ;
105482: LD_INT 1
105484: PPUSH
105485: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105489: LD_VAR 0 1
105493: PPUSH
105494: CALL_OW 316
105498: PUSH
105499: LD_VAR 0 1
105503: PPUSH
105504: CALL_OW 314
105508: OR
105509: PUSH
105510: LD_VAR 0 1
105514: PPUSH
105515: CALL_OW 302
105519: NOT
105520: OR
105521: PUSH
105522: LD_VAR 0 1
105526: PPUSH
105527: CALL_OW 301
105531: OR
105532: IFFALSE 105482
// RemoveSeeing ( _x , _y , side ) ;
105534: LD_VAR 0 8
105538: PPUSH
105539: LD_VAR 0 9
105543: PPUSH
105544: LD_VAR 0 6
105548: PPUSH
105549: CALL_OW 331
// end ; end_of_file
105553: LD_VAR 0 4
105557: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105558: LD_INT 0
105560: PPUSH
105561: PPUSH
105562: PPUSH
105563: PPUSH
105564: PPUSH
105565: PPUSH
105566: PPUSH
105567: PPUSH
105568: PPUSH
105569: PPUSH
105570: PPUSH
105571: PPUSH
105572: PPUSH
105573: PPUSH
105574: PPUSH
105575: PPUSH
105576: PPUSH
105577: PPUSH
105578: PPUSH
105579: PPUSH
105580: PPUSH
105581: PPUSH
105582: PPUSH
105583: PPUSH
105584: PPUSH
105585: PPUSH
105586: PPUSH
105587: PPUSH
105588: PPUSH
105589: PPUSH
105590: PPUSH
105591: PPUSH
105592: PPUSH
105593: PPUSH
// if not list then
105594: LD_VAR 0 1
105598: NOT
105599: IFFALSE 105603
// exit ;
105601: GO 110262
// base := list [ 1 ] ;
105603: LD_ADDR_VAR 0 3
105607: PUSH
105608: LD_VAR 0 1
105612: PUSH
105613: LD_INT 1
105615: ARRAY
105616: ST_TO_ADDR
// group := list [ 2 ] ;
105617: LD_ADDR_VAR 0 4
105621: PUSH
105622: LD_VAR 0 1
105626: PUSH
105627: LD_INT 2
105629: ARRAY
105630: ST_TO_ADDR
// path := list [ 3 ] ;
105631: LD_ADDR_VAR 0 5
105635: PUSH
105636: LD_VAR 0 1
105640: PUSH
105641: LD_INT 3
105643: ARRAY
105644: ST_TO_ADDR
// flags := list [ 4 ] ;
105645: LD_ADDR_VAR 0 6
105649: PUSH
105650: LD_VAR 0 1
105654: PUSH
105655: LD_INT 4
105657: ARRAY
105658: ST_TO_ADDR
// mined := [ ] ;
105659: LD_ADDR_VAR 0 27
105663: PUSH
105664: EMPTY
105665: ST_TO_ADDR
// bombed := [ ] ;
105666: LD_ADDR_VAR 0 28
105670: PUSH
105671: EMPTY
105672: ST_TO_ADDR
// healers := [ ] ;
105673: LD_ADDR_VAR 0 31
105677: PUSH
105678: EMPTY
105679: ST_TO_ADDR
// to_heal := [ ] ;
105680: LD_ADDR_VAR 0 30
105684: PUSH
105685: EMPTY
105686: ST_TO_ADDR
// repairs := [ ] ;
105687: LD_ADDR_VAR 0 33
105691: PUSH
105692: EMPTY
105693: ST_TO_ADDR
// to_repair := [ ] ;
105694: LD_ADDR_VAR 0 32
105698: PUSH
105699: EMPTY
105700: ST_TO_ADDR
// if not group or not path then
105701: LD_VAR 0 4
105705: NOT
105706: PUSH
105707: LD_VAR 0 5
105711: NOT
105712: OR
105713: IFFALSE 105717
// exit ;
105715: GO 110262
// side := GetSide ( group [ 1 ] ) ;
105717: LD_ADDR_VAR 0 35
105721: PUSH
105722: LD_VAR 0 4
105726: PUSH
105727: LD_INT 1
105729: ARRAY
105730: PPUSH
105731: CALL_OW 255
105735: ST_TO_ADDR
// if flags then
105736: LD_VAR 0 6
105740: IFFALSE 105884
// begin f_ignore_area := flags [ 1 ] ;
105742: LD_ADDR_VAR 0 17
105746: PUSH
105747: LD_VAR 0 6
105751: PUSH
105752: LD_INT 1
105754: ARRAY
105755: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105756: LD_ADDR_VAR 0 18
105760: PUSH
105761: LD_VAR 0 6
105765: PUSH
105766: LD_INT 2
105768: ARRAY
105769: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105770: LD_ADDR_VAR 0 19
105774: PUSH
105775: LD_VAR 0 6
105779: PUSH
105780: LD_INT 3
105782: ARRAY
105783: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105784: LD_ADDR_VAR 0 20
105788: PUSH
105789: LD_VAR 0 6
105793: PUSH
105794: LD_INT 4
105796: ARRAY
105797: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105798: LD_ADDR_VAR 0 21
105802: PUSH
105803: LD_VAR 0 6
105807: PUSH
105808: LD_INT 5
105810: ARRAY
105811: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105812: LD_ADDR_VAR 0 22
105816: PUSH
105817: LD_VAR 0 6
105821: PUSH
105822: LD_INT 6
105824: ARRAY
105825: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105826: LD_ADDR_VAR 0 23
105830: PUSH
105831: LD_VAR 0 6
105835: PUSH
105836: LD_INT 7
105838: ARRAY
105839: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105840: LD_ADDR_VAR 0 24
105844: PUSH
105845: LD_VAR 0 6
105849: PUSH
105850: LD_INT 8
105852: ARRAY
105853: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105854: LD_ADDR_VAR 0 25
105858: PUSH
105859: LD_VAR 0 6
105863: PUSH
105864: LD_INT 9
105866: ARRAY
105867: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105868: LD_ADDR_VAR 0 26
105872: PUSH
105873: LD_VAR 0 6
105877: PUSH
105878: LD_INT 10
105880: ARRAY
105881: ST_TO_ADDR
// end else
105882: GO 105964
// begin f_ignore_area := false ;
105884: LD_ADDR_VAR 0 17
105888: PUSH
105889: LD_INT 0
105891: ST_TO_ADDR
// f_capture := false ;
105892: LD_ADDR_VAR 0 18
105896: PUSH
105897: LD_INT 0
105899: ST_TO_ADDR
// f_ignore_civ := false ;
105900: LD_ADDR_VAR 0 19
105904: PUSH
105905: LD_INT 0
105907: ST_TO_ADDR
// f_murder := false ;
105908: LD_ADDR_VAR 0 20
105912: PUSH
105913: LD_INT 0
105915: ST_TO_ADDR
// f_mines := false ;
105916: LD_ADDR_VAR 0 21
105920: PUSH
105921: LD_INT 0
105923: ST_TO_ADDR
// f_repair := false ;
105924: LD_ADDR_VAR 0 22
105928: PUSH
105929: LD_INT 0
105931: ST_TO_ADDR
// f_heal := false ;
105932: LD_ADDR_VAR 0 23
105936: PUSH
105937: LD_INT 0
105939: ST_TO_ADDR
// f_spacetime := false ;
105940: LD_ADDR_VAR 0 24
105944: PUSH
105945: LD_INT 0
105947: ST_TO_ADDR
// f_attack_depot := false ;
105948: LD_ADDR_VAR 0 25
105952: PUSH
105953: LD_INT 0
105955: ST_TO_ADDR
// f_crawl := false ;
105956: LD_ADDR_VAR 0 26
105960: PUSH
105961: LD_INT 0
105963: ST_TO_ADDR
// end ; if f_heal then
105964: LD_VAR 0 23
105968: IFFALSE 105995
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105970: LD_ADDR_VAR 0 31
105974: PUSH
105975: LD_VAR 0 4
105979: PPUSH
105980: LD_INT 25
105982: PUSH
105983: LD_INT 4
105985: PUSH
105986: EMPTY
105987: LIST
105988: LIST
105989: PPUSH
105990: CALL_OW 72
105994: ST_TO_ADDR
// if f_repair then
105995: LD_VAR 0 22
105999: IFFALSE 106026
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106001: LD_ADDR_VAR 0 33
106005: PUSH
106006: LD_VAR 0 4
106010: PPUSH
106011: LD_INT 25
106013: PUSH
106014: LD_INT 3
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: PPUSH
106021: CALL_OW 72
106025: ST_TO_ADDR
// units_path := [ ] ;
106026: LD_ADDR_VAR 0 16
106030: PUSH
106031: EMPTY
106032: ST_TO_ADDR
// for i = 1 to group do
106033: LD_ADDR_VAR 0 7
106037: PUSH
106038: DOUBLE
106039: LD_INT 1
106041: DEC
106042: ST_TO_ADDR
106043: LD_VAR 0 4
106047: PUSH
106048: FOR_TO
106049: IFFALSE 106078
// units_path := Replace ( units_path , i , path ) ;
106051: LD_ADDR_VAR 0 16
106055: PUSH
106056: LD_VAR 0 16
106060: PPUSH
106061: LD_VAR 0 7
106065: PPUSH
106066: LD_VAR 0 5
106070: PPUSH
106071: CALL_OW 1
106075: ST_TO_ADDR
106076: GO 106048
106078: POP
106079: POP
// repeat for i = group downto 1 do
106080: LD_ADDR_VAR 0 7
106084: PUSH
106085: DOUBLE
106086: LD_VAR 0 4
106090: INC
106091: ST_TO_ADDR
106092: LD_INT 1
106094: PUSH
106095: FOR_DOWNTO
106096: IFFALSE 110218
// begin wait ( 5 ) ;
106098: LD_INT 5
106100: PPUSH
106101: CALL_OW 67
// tmp := [ ] ;
106105: LD_ADDR_VAR 0 14
106109: PUSH
106110: EMPTY
106111: ST_TO_ADDR
// attacking := false ;
106112: LD_ADDR_VAR 0 29
106116: PUSH
106117: LD_INT 0
106119: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106120: LD_VAR 0 4
106124: PUSH
106125: LD_VAR 0 7
106129: ARRAY
106130: PPUSH
106131: CALL_OW 301
106135: PUSH
106136: LD_VAR 0 4
106140: PUSH
106141: LD_VAR 0 7
106145: ARRAY
106146: NOT
106147: OR
106148: IFFALSE 106257
// begin if GetType ( group [ i ] ) = unit_human then
106150: LD_VAR 0 4
106154: PUSH
106155: LD_VAR 0 7
106159: ARRAY
106160: PPUSH
106161: CALL_OW 247
106165: PUSH
106166: LD_INT 1
106168: EQUAL
106169: IFFALSE 106215
// begin to_heal := to_heal diff group [ i ] ;
106171: LD_ADDR_VAR 0 30
106175: PUSH
106176: LD_VAR 0 30
106180: PUSH
106181: LD_VAR 0 4
106185: PUSH
106186: LD_VAR 0 7
106190: ARRAY
106191: DIFF
106192: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106193: LD_ADDR_VAR 0 31
106197: PUSH
106198: LD_VAR 0 31
106202: PUSH
106203: LD_VAR 0 4
106207: PUSH
106208: LD_VAR 0 7
106212: ARRAY
106213: DIFF
106214: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106215: LD_ADDR_VAR 0 4
106219: PUSH
106220: LD_VAR 0 4
106224: PPUSH
106225: LD_VAR 0 7
106229: PPUSH
106230: CALL_OW 3
106234: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106235: LD_ADDR_VAR 0 16
106239: PUSH
106240: LD_VAR 0 16
106244: PPUSH
106245: LD_VAR 0 7
106249: PPUSH
106250: CALL_OW 3
106254: ST_TO_ADDR
// continue ;
106255: GO 106095
// end ; if f_repair then
106257: LD_VAR 0 22
106261: IFFALSE 106750
// begin if GetType ( group [ i ] ) = unit_vehicle then
106263: LD_VAR 0 4
106267: PUSH
106268: LD_VAR 0 7
106272: ARRAY
106273: PPUSH
106274: CALL_OW 247
106278: PUSH
106279: LD_INT 2
106281: EQUAL
106282: IFFALSE 106472
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106284: LD_VAR 0 4
106288: PUSH
106289: LD_VAR 0 7
106293: ARRAY
106294: PPUSH
106295: CALL_OW 256
106299: PUSH
106300: LD_INT 700
106302: LESS
106303: PUSH
106304: LD_VAR 0 4
106308: PUSH
106309: LD_VAR 0 7
106313: ARRAY
106314: PUSH
106315: LD_VAR 0 32
106319: IN
106320: NOT
106321: AND
106322: IFFALSE 106346
// to_repair := to_repair union group [ i ] ;
106324: LD_ADDR_VAR 0 32
106328: PUSH
106329: LD_VAR 0 32
106333: PUSH
106334: LD_VAR 0 4
106338: PUSH
106339: LD_VAR 0 7
106343: ARRAY
106344: UNION
106345: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106346: LD_VAR 0 4
106350: PUSH
106351: LD_VAR 0 7
106355: ARRAY
106356: PPUSH
106357: CALL_OW 256
106361: PUSH
106362: LD_INT 1000
106364: EQUAL
106365: PUSH
106366: LD_VAR 0 4
106370: PUSH
106371: LD_VAR 0 7
106375: ARRAY
106376: PUSH
106377: LD_VAR 0 32
106381: IN
106382: AND
106383: IFFALSE 106407
// to_repair := to_repair diff group [ i ] ;
106385: LD_ADDR_VAR 0 32
106389: PUSH
106390: LD_VAR 0 32
106394: PUSH
106395: LD_VAR 0 4
106399: PUSH
106400: LD_VAR 0 7
106404: ARRAY
106405: DIFF
106406: ST_TO_ADDR
// if group [ i ] in to_repair then
106407: LD_VAR 0 4
106411: PUSH
106412: LD_VAR 0 7
106416: ARRAY
106417: PUSH
106418: LD_VAR 0 32
106422: IN
106423: IFFALSE 106470
// begin if not IsInArea ( group [ i ] , f_repair ) then
106425: LD_VAR 0 4
106429: PUSH
106430: LD_VAR 0 7
106434: ARRAY
106435: PPUSH
106436: LD_VAR 0 22
106440: PPUSH
106441: CALL_OW 308
106445: NOT
106446: IFFALSE 106468
// ComMoveToArea ( group [ i ] , f_repair ) ;
106448: LD_VAR 0 4
106452: PUSH
106453: LD_VAR 0 7
106457: ARRAY
106458: PPUSH
106459: LD_VAR 0 22
106463: PPUSH
106464: CALL_OW 113
// continue ;
106468: GO 106095
// end ; end else
106470: GO 106750
// if group [ i ] in repairs then
106472: LD_VAR 0 4
106476: PUSH
106477: LD_VAR 0 7
106481: ARRAY
106482: PUSH
106483: LD_VAR 0 33
106487: IN
106488: IFFALSE 106750
// begin if IsInUnit ( group [ i ] ) then
106490: LD_VAR 0 4
106494: PUSH
106495: LD_VAR 0 7
106499: ARRAY
106500: PPUSH
106501: CALL_OW 310
106505: IFFALSE 106573
// begin z := IsInUnit ( group [ i ] ) ;
106507: LD_ADDR_VAR 0 13
106511: PUSH
106512: LD_VAR 0 4
106516: PUSH
106517: LD_VAR 0 7
106521: ARRAY
106522: PPUSH
106523: CALL_OW 310
106527: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106528: LD_VAR 0 13
106532: PUSH
106533: LD_VAR 0 32
106537: IN
106538: PUSH
106539: LD_VAR 0 13
106543: PPUSH
106544: LD_VAR 0 22
106548: PPUSH
106549: CALL_OW 308
106553: AND
106554: IFFALSE 106571
// ComExitVehicle ( group [ i ] ) ;
106556: LD_VAR 0 4
106560: PUSH
106561: LD_VAR 0 7
106565: ARRAY
106566: PPUSH
106567: CALL_OW 121
// end else
106571: GO 106750
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106573: LD_ADDR_VAR 0 13
106577: PUSH
106578: LD_VAR 0 4
106582: PPUSH
106583: LD_INT 95
106585: PUSH
106586: LD_VAR 0 22
106590: PUSH
106591: EMPTY
106592: LIST
106593: LIST
106594: PUSH
106595: LD_INT 58
106597: PUSH
106598: EMPTY
106599: LIST
106600: PUSH
106601: EMPTY
106602: LIST
106603: LIST
106604: PPUSH
106605: CALL_OW 72
106609: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106610: LD_VAR 0 4
106614: PUSH
106615: LD_VAR 0 7
106619: ARRAY
106620: PPUSH
106621: CALL_OW 314
106625: NOT
106626: IFFALSE 106748
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106628: LD_ADDR_VAR 0 10
106632: PUSH
106633: LD_VAR 0 13
106637: PPUSH
106638: LD_VAR 0 4
106642: PUSH
106643: LD_VAR 0 7
106647: ARRAY
106648: PPUSH
106649: CALL_OW 74
106653: ST_TO_ADDR
// if not x then
106654: LD_VAR 0 10
106658: NOT
106659: IFFALSE 106663
// continue ;
106661: GO 106095
// if GetLives ( x ) < 1000 then
106663: LD_VAR 0 10
106667: PPUSH
106668: CALL_OW 256
106672: PUSH
106673: LD_INT 1000
106675: LESS
106676: IFFALSE 106700
// ComRepairVehicle ( group [ i ] , x ) else
106678: LD_VAR 0 4
106682: PUSH
106683: LD_VAR 0 7
106687: ARRAY
106688: PPUSH
106689: LD_VAR 0 10
106693: PPUSH
106694: CALL_OW 129
106698: GO 106748
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106700: LD_VAR 0 23
106704: PUSH
106705: LD_VAR 0 4
106709: PUSH
106710: LD_VAR 0 7
106714: ARRAY
106715: PPUSH
106716: CALL_OW 256
106720: PUSH
106721: LD_INT 1000
106723: LESS
106724: AND
106725: NOT
106726: IFFALSE 106748
// ComEnterUnit ( group [ i ] , x ) ;
106728: LD_VAR 0 4
106732: PUSH
106733: LD_VAR 0 7
106737: ARRAY
106738: PPUSH
106739: LD_VAR 0 10
106743: PPUSH
106744: CALL_OW 120
// end ; continue ;
106748: GO 106095
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106750: LD_VAR 0 23
106754: PUSH
106755: LD_VAR 0 4
106759: PUSH
106760: LD_VAR 0 7
106764: ARRAY
106765: PPUSH
106766: CALL_OW 247
106770: PUSH
106771: LD_INT 1
106773: EQUAL
106774: AND
106775: IFFALSE 107253
// begin if group [ i ] in healers then
106777: LD_VAR 0 4
106781: PUSH
106782: LD_VAR 0 7
106786: ARRAY
106787: PUSH
106788: LD_VAR 0 31
106792: IN
106793: IFFALSE 107066
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106795: LD_VAR 0 4
106799: PUSH
106800: LD_VAR 0 7
106804: ARRAY
106805: PPUSH
106806: LD_VAR 0 23
106810: PPUSH
106811: CALL_OW 308
106815: NOT
106816: PUSH
106817: LD_VAR 0 4
106821: PUSH
106822: LD_VAR 0 7
106826: ARRAY
106827: PPUSH
106828: CALL_OW 314
106832: NOT
106833: AND
106834: IFFALSE 106858
// ComMoveToArea ( group [ i ] , f_heal ) else
106836: LD_VAR 0 4
106840: PUSH
106841: LD_VAR 0 7
106845: ARRAY
106846: PPUSH
106847: LD_VAR 0 23
106851: PPUSH
106852: CALL_OW 113
106856: GO 107064
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106858: LD_VAR 0 4
106862: PUSH
106863: LD_VAR 0 7
106867: ARRAY
106868: PPUSH
106869: CALL 48380 0 1
106873: PPUSH
106874: CALL_OW 256
106878: PUSH
106879: LD_INT 1000
106881: EQUAL
106882: IFFALSE 106901
// ComStop ( group [ i ] ) else
106884: LD_VAR 0 4
106888: PUSH
106889: LD_VAR 0 7
106893: ARRAY
106894: PPUSH
106895: CALL_OW 141
106899: GO 107064
// if not HasTask ( group [ i ] ) and to_heal then
106901: LD_VAR 0 4
106905: PUSH
106906: LD_VAR 0 7
106910: ARRAY
106911: PPUSH
106912: CALL_OW 314
106916: NOT
106917: PUSH
106918: LD_VAR 0 30
106922: AND
106923: IFFALSE 107064
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106925: LD_ADDR_VAR 0 13
106929: PUSH
106930: LD_VAR 0 30
106934: PPUSH
106935: LD_INT 3
106937: PUSH
106938: LD_INT 54
106940: PUSH
106941: EMPTY
106942: LIST
106943: PUSH
106944: EMPTY
106945: LIST
106946: LIST
106947: PPUSH
106948: CALL_OW 72
106952: PPUSH
106953: LD_VAR 0 4
106957: PUSH
106958: LD_VAR 0 7
106962: ARRAY
106963: PPUSH
106964: CALL_OW 74
106968: ST_TO_ADDR
// if z then
106969: LD_VAR 0 13
106973: IFFALSE 107064
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106975: LD_INT 91
106977: PUSH
106978: LD_VAR 0 13
106982: PUSH
106983: LD_INT 10
106985: PUSH
106986: EMPTY
106987: LIST
106988: LIST
106989: LIST
106990: PUSH
106991: LD_INT 81
106993: PUSH
106994: LD_VAR 0 13
106998: PPUSH
106999: CALL_OW 255
107003: PUSH
107004: EMPTY
107005: LIST
107006: LIST
107007: PUSH
107008: EMPTY
107009: LIST
107010: LIST
107011: PPUSH
107012: CALL_OW 69
107016: PUSH
107017: LD_INT 0
107019: EQUAL
107020: IFFALSE 107044
// ComHeal ( group [ i ] , z ) else
107022: LD_VAR 0 4
107026: PUSH
107027: LD_VAR 0 7
107031: ARRAY
107032: PPUSH
107033: LD_VAR 0 13
107037: PPUSH
107038: CALL_OW 128
107042: GO 107064
// ComMoveToArea ( group [ i ] , f_heal ) ;
107044: LD_VAR 0 4
107048: PUSH
107049: LD_VAR 0 7
107053: ARRAY
107054: PPUSH
107055: LD_VAR 0 23
107059: PPUSH
107060: CALL_OW 113
// end ; continue ;
107064: GO 106095
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107066: LD_VAR 0 4
107070: PUSH
107071: LD_VAR 0 7
107075: ARRAY
107076: PPUSH
107077: CALL_OW 256
107081: PUSH
107082: LD_INT 700
107084: LESS
107085: PUSH
107086: LD_VAR 0 4
107090: PUSH
107091: LD_VAR 0 7
107095: ARRAY
107096: PUSH
107097: LD_VAR 0 30
107101: IN
107102: NOT
107103: AND
107104: IFFALSE 107128
// to_heal := to_heal union group [ i ] ;
107106: LD_ADDR_VAR 0 30
107110: PUSH
107111: LD_VAR 0 30
107115: PUSH
107116: LD_VAR 0 4
107120: PUSH
107121: LD_VAR 0 7
107125: ARRAY
107126: UNION
107127: ST_TO_ADDR
// if group [ i ] in to_heal then
107128: LD_VAR 0 4
107132: PUSH
107133: LD_VAR 0 7
107137: ARRAY
107138: PUSH
107139: LD_VAR 0 30
107143: IN
107144: IFFALSE 107253
// begin if GetLives ( group [ i ] ) = 1000 then
107146: LD_VAR 0 4
107150: PUSH
107151: LD_VAR 0 7
107155: ARRAY
107156: PPUSH
107157: CALL_OW 256
107161: PUSH
107162: LD_INT 1000
107164: EQUAL
107165: IFFALSE 107191
// to_heal := to_heal diff group [ i ] else
107167: LD_ADDR_VAR 0 30
107171: PUSH
107172: LD_VAR 0 30
107176: PUSH
107177: LD_VAR 0 4
107181: PUSH
107182: LD_VAR 0 7
107186: ARRAY
107187: DIFF
107188: ST_TO_ADDR
107189: GO 107253
// begin if not IsInArea ( group [ i ] , to_heal ) then
107191: LD_VAR 0 4
107195: PUSH
107196: LD_VAR 0 7
107200: ARRAY
107201: PPUSH
107202: LD_VAR 0 30
107206: PPUSH
107207: CALL_OW 308
107211: NOT
107212: IFFALSE 107236
// ComMoveToArea ( group [ i ] , f_heal ) else
107214: LD_VAR 0 4
107218: PUSH
107219: LD_VAR 0 7
107223: ARRAY
107224: PPUSH
107225: LD_VAR 0 23
107229: PPUSH
107230: CALL_OW 113
107234: GO 107251
// ComHold ( group [ i ] ) ;
107236: LD_VAR 0 4
107240: PUSH
107241: LD_VAR 0 7
107245: ARRAY
107246: PPUSH
107247: CALL_OW 140
// continue ;
107251: GO 106095
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107253: LD_VAR 0 4
107257: PUSH
107258: LD_VAR 0 7
107262: ARRAY
107263: PPUSH
107264: LD_INT 10
107266: PPUSH
107267: CALL 46250 0 2
107271: NOT
107272: PUSH
107273: LD_VAR 0 16
107277: PUSH
107278: LD_VAR 0 7
107282: ARRAY
107283: PUSH
107284: EMPTY
107285: EQUAL
107286: NOT
107287: AND
107288: IFFALSE 107554
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107290: LD_VAR 0 4
107294: PUSH
107295: LD_VAR 0 7
107299: ARRAY
107300: PPUSH
107301: CALL_OW 262
107305: PUSH
107306: LD_INT 1
107308: PUSH
107309: LD_INT 2
107311: PUSH
107312: EMPTY
107313: LIST
107314: LIST
107315: IN
107316: IFFALSE 107357
// if GetFuel ( group [ i ] ) < 10 then
107318: LD_VAR 0 4
107322: PUSH
107323: LD_VAR 0 7
107327: ARRAY
107328: PPUSH
107329: CALL_OW 261
107333: PUSH
107334: LD_INT 10
107336: LESS
107337: IFFALSE 107357
// SetFuel ( group [ i ] , 12 ) ;
107339: LD_VAR 0 4
107343: PUSH
107344: LD_VAR 0 7
107348: ARRAY
107349: PPUSH
107350: LD_INT 12
107352: PPUSH
107353: CALL_OW 240
// if units_path [ i ] then
107357: LD_VAR 0 16
107361: PUSH
107362: LD_VAR 0 7
107366: ARRAY
107367: IFFALSE 107552
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107369: LD_VAR 0 4
107373: PUSH
107374: LD_VAR 0 7
107378: ARRAY
107379: PPUSH
107380: LD_VAR 0 16
107384: PUSH
107385: LD_VAR 0 7
107389: ARRAY
107390: PUSH
107391: LD_INT 1
107393: ARRAY
107394: PUSH
107395: LD_INT 1
107397: ARRAY
107398: PPUSH
107399: LD_VAR 0 16
107403: PUSH
107404: LD_VAR 0 7
107408: ARRAY
107409: PUSH
107410: LD_INT 1
107412: ARRAY
107413: PUSH
107414: LD_INT 2
107416: ARRAY
107417: PPUSH
107418: CALL_OW 297
107422: PUSH
107423: LD_INT 6
107425: GREATER
107426: IFFALSE 107501
// begin if not HasTask ( group [ i ] ) then
107428: LD_VAR 0 4
107432: PUSH
107433: LD_VAR 0 7
107437: ARRAY
107438: PPUSH
107439: CALL_OW 314
107443: NOT
107444: IFFALSE 107499
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107446: LD_VAR 0 4
107450: PUSH
107451: LD_VAR 0 7
107455: ARRAY
107456: PPUSH
107457: LD_VAR 0 16
107461: PUSH
107462: LD_VAR 0 7
107466: ARRAY
107467: PUSH
107468: LD_INT 1
107470: ARRAY
107471: PUSH
107472: LD_INT 1
107474: ARRAY
107475: PPUSH
107476: LD_VAR 0 16
107480: PUSH
107481: LD_VAR 0 7
107485: ARRAY
107486: PUSH
107487: LD_INT 1
107489: ARRAY
107490: PUSH
107491: LD_INT 2
107493: ARRAY
107494: PPUSH
107495: CALL_OW 114
// end else
107499: GO 107552
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107501: LD_ADDR_VAR 0 15
107505: PUSH
107506: LD_VAR 0 16
107510: PUSH
107511: LD_VAR 0 7
107515: ARRAY
107516: PPUSH
107517: LD_INT 1
107519: PPUSH
107520: CALL_OW 3
107524: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107525: LD_ADDR_VAR 0 16
107529: PUSH
107530: LD_VAR 0 16
107534: PPUSH
107535: LD_VAR 0 7
107539: PPUSH
107540: LD_VAR 0 15
107544: PPUSH
107545: CALL_OW 1
107549: ST_TO_ADDR
// continue ;
107550: GO 106095
// end ; end ; end else
107552: GO 110216
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107554: LD_ADDR_VAR 0 14
107558: PUSH
107559: LD_INT 81
107561: PUSH
107562: LD_VAR 0 4
107566: PUSH
107567: LD_VAR 0 7
107571: ARRAY
107572: PPUSH
107573: CALL_OW 255
107577: PUSH
107578: EMPTY
107579: LIST
107580: LIST
107581: PPUSH
107582: CALL_OW 69
107586: ST_TO_ADDR
// if not tmp then
107587: LD_VAR 0 14
107591: NOT
107592: IFFALSE 107596
// continue ;
107594: GO 106095
// if f_ignore_area then
107596: LD_VAR 0 17
107600: IFFALSE 107688
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107602: LD_ADDR_VAR 0 15
107606: PUSH
107607: LD_VAR 0 14
107611: PPUSH
107612: LD_INT 3
107614: PUSH
107615: LD_INT 92
107617: PUSH
107618: LD_VAR 0 17
107622: PUSH
107623: LD_INT 1
107625: ARRAY
107626: PUSH
107627: LD_VAR 0 17
107631: PUSH
107632: LD_INT 2
107634: ARRAY
107635: PUSH
107636: LD_VAR 0 17
107640: PUSH
107641: LD_INT 3
107643: ARRAY
107644: PUSH
107645: EMPTY
107646: LIST
107647: LIST
107648: LIST
107649: LIST
107650: PUSH
107651: EMPTY
107652: LIST
107653: LIST
107654: PPUSH
107655: CALL_OW 72
107659: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107660: LD_VAR 0 14
107664: PUSH
107665: LD_VAR 0 15
107669: DIFF
107670: IFFALSE 107688
// tmp := tmp diff tmp2 ;
107672: LD_ADDR_VAR 0 14
107676: PUSH
107677: LD_VAR 0 14
107681: PUSH
107682: LD_VAR 0 15
107686: DIFF
107687: ST_TO_ADDR
// end ; if not f_murder then
107688: LD_VAR 0 20
107692: NOT
107693: IFFALSE 107751
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107695: LD_ADDR_VAR 0 15
107699: PUSH
107700: LD_VAR 0 14
107704: PPUSH
107705: LD_INT 3
107707: PUSH
107708: LD_INT 50
107710: PUSH
107711: EMPTY
107712: LIST
107713: PUSH
107714: EMPTY
107715: LIST
107716: LIST
107717: PPUSH
107718: CALL_OW 72
107722: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107723: LD_VAR 0 14
107727: PUSH
107728: LD_VAR 0 15
107732: DIFF
107733: IFFALSE 107751
// tmp := tmp diff tmp2 ;
107735: LD_ADDR_VAR 0 14
107739: PUSH
107740: LD_VAR 0 14
107744: PUSH
107745: LD_VAR 0 15
107749: DIFF
107750: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107751: LD_ADDR_VAR 0 14
107755: PUSH
107756: LD_VAR 0 4
107760: PUSH
107761: LD_VAR 0 7
107765: ARRAY
107766: PPUSH
107767: LD_VAR 0 14
107771: PPUSH
107772: LD_INT 1
107774: PPUSH
107775: LD_INT 1
107777: PPUSH
107778: CALL 19185 0 4
107782: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107783: LD_VAR 0 4
107787: PUSH
107788: LD_VAR 0 7
107792: ARRAY
107793: PPUSH
107794: CALL_OW 257
107798: PUSH
107799: LD_INT 1
107801: EQUAL
107802: IFFALSE 108250
// begin if WantPlant ( group [ i ] ) then
107804: LD_VAR 0 4
107808: PUSH
107809: LD_VAR 0 7
107813: ARRAY
107814: PPUSH
107815: CALL 18686 0 1
107819: IFFALSE 107823
// continue ;
107821: GO 106095
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107823: LD_VAR 0 18
107827: PUSH
107828: LD_VAR 0 4
107832: PUSH
107833: LD_VAR 0 7
107837: ARRAY
107838: PPUSH
107839: CALL_OW 310
107843: NOT
107844: AND
107845: PUSH
107846: LD_VAR 0 14
107850: PUSH
107851: LD_INT 1
107853: ARRAY
107854: PUSH
107855: LD_VAR 0 14
107859: PPUSH
107860: LD_INT 21
107862: PUSH
107863: LD_INT 2
107865: PUSH
107866: EMPTY
107867: LIST
107868: LIST
107869: PUSH
107870: LD_INT 58
107872: PUSH
107873: EMPTY
107874: LIST
107875: PUSH
107876: EMPTY
107877: LIST
107878: LIST
107879: PPUSH
107880: CALL_OW 72
107884: IN
107885: AND
107886: IFFALSE 107922
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107888: LD_VAR 0 4
107892: PUSH
107893: LD_VAR 0 7
107897: ARRAY
107898: PPUSH
107899: LD_VAR 0 14
107903: PUSH
107904: LD_INT 1
107906: ARRAY
107907: PPUSH
107908: CALL_OW 120
// attacking := true ;
107912: LD_ADDR_VAR 0 29
107916: PUSH
107917: LD_INT 1
107919: ST_TO_ADDR
// continue ;
107920: GO 106095
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107922: LD_VAR 0 26
107926: PUSH
107927: LD_VAR 0 4
107931: PUSH
107932: LD_VAR 0 7
107936: ARRAY
107937: PPUSH
107938: CALL_OW 257
107942: PUSH
107943: LD_INT 1
107945: EQUAL
107946: AND
107947: PUSH
107948: LD_VAR 0 4
107952: PUSH
107953: LD_VAR 0 7
107957: ARRAY
107958: PPUSH
107959: CALL_OW 256
107963: PUSH
107964: LD_INT 800
107966: LESS
107967: AND
107968: PUSH
107969: LD_VAR 0 4
107973: PUSH
107974: LD_VAR 0 7
107978: ARRAY
107979: PPUSH
107980: CALL_OW 318
107984: NOT
107985: AND
107986: IFFALSE 108003
// ComCrawl ( group [ i ] ) ;
107988: LD_VAR 0 4
107992: PUSH
107993: LD_VAR 0 7
107997: ARRAY
107998: PPUSH
107999: CALL_OW 137
// if f_mines then
108003: LD_VAR 0 21
108007: IFFALSE 108250
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108009: LD_VAR 0 14
108013: PUSH
108014: LD_INT 1
108016: ARRAY
108017: PPUSH
108018: CALL_OW 247
108022: PUSH
108023: LD_INT 3
108025: EQUAL
108026: PUSH
108027: LD_VAR 0 14
108031: PUSH
108032: LD_INT 1
108034: ARRAY
108035: PUSH
108036: LD_VAR 0 27
108040: IN
108041: NOT
108042: AND
108043: IFFALSE 108250
// begin x := GetX ( tmp [ 1 ] ) ;
108045: LD_ADDR_VAR 0 10
108049: PUSH
108050: LD_VAR 0 14
108054: PUSH
108055: LD_INT 1
108057: ARRAY
108058: PPUSH
108059: CALL_OW 250
108063: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108064: LD_ADDR_VAR 0 11
108068: PUSH
108069: LD_VAR 0 14
108073: PUSH
108074: LD_INT 1
108076: ARRAY
108077: PPUSH
108078: CALL_OW 251
108082: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108083: LD_ADDR_VAR 0 12
108087: PUSH
108088: LD_VAR 0 4
108092: PUSH
108093: LD_VAR 0 7
108097: ARRAY
108098: PPUSH
108099: CALL 46335 0 1
108103: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108104: LD_VAR 0 4
108108: PUSH
108109: LD_VAR 0 7
108113: ARRAY
108114: PPUSH
108115: LD_VAR 0 10
108119: PPUSH
108120: LD_VAR 0 11
108124: PPUSH
108125: LD_VAR 0 14
108129: PUSH
108130: LD_INT 1
108132: ARRAY
108133: PPUSH
108134: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108138: LD_VAR 0 4
108142: PUSH
108143: LD_VAR 0 7
108147: ARRAY
108148: PPUSH
108149: LD_VAR 0 10
108153: PPUSH
108154: LD_VAR 0 12
108158: PPUSH
108159: LD_INT 7
108161: PPUSH
108162: CALL_OW 272
108166: PPUSH
108167: LD_VAR 0 11
108171: PPUSH
108172: LD_VAR 0 12
108176: PPUSH
108177: LD_INT 7
108179: PPUSH
108180: CALL_OW 273
108184: PPUSH
108185: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108189: LD_VAR 0 4
108193: PUSH
108194: LD_VAR 0 7
108198: ARRAY
108199: PPUSH
108200: LD_INT 71
108202: PPUSH
108203: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108207: LD_ADDR_VAR 0 27
108211: PUSH
108212: LD_VAR 0 27
108216: PPUSH
108217: LD_VAR 0 27
108221: PUSH
108222: LD_INT 1
108224: PLUS
108225: PPUSH
108226: LD_VAR 0 14
108230: PUSH
108231: LD_INT 1
108233: ARRAY
108234: PPUSH
108235: CALL_OW 1
108239: ST_TO_ADDR
// attacking := true ;
108240: LD_ADDR_VAR 0 29
108244: PUSH
108245: LD_INT 1
108247: ST_TO_ADDR
// continue ;
108248: GO 106095
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108250: LD_VAR 0 4
108254: PUSH
108255: LD_VAR 0 7
108259: ARRAY
108260: PPUSH
108261: CALL_OW 257
108265: PUSH
108266: LD_INT 17
108268: EQUAL
108269: PUSH
108270: LD_VAR 0 4
108274: PUSH
108275: LD_VAR 0 7
108279: ARRAY
108280: PPUSH
108281: CALL_OW 110
108285: PUSH
108286: LD_INT 71
108288: EQUAL
108289: NOT
108290: AND
108291: IFFALSE 108437
// begin attacking := false ;
108293: LD_ADDR_VAR 0 29
108297: PUSH
108298: LD_INT 0
108300: ST_TO_ADDR
// k := 5 ;
108301: LD_ADDR_VAR 0 9
108305: PUSH
108306: LD_INT 5
108308: ST_TO_ADDR
// if tmp < k then
108309: LD_VAR 0 14
108313: PUSH
108314: LD_VAR 0 9
108318: LESS
108319: IFFALSE 108331
// k := tmp ;
108321: LD_ADDR_VAR 0 9
108325: PUSH
108326: LD_VAR 0 14
108330: ST_TO_ADDR
// for j = 1 to k do
108331: LD_ADDR_VAR 0 8
108335: PUSH
108336: DOUBLE
108337: LD_INT 1
108339: DEC
108340: ST_TO_ADDR
108341: LD_VAR 0 9
108345: PUSH
108346: FOR_TO
108347: IFFALSE 108435
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108349: LD_VAR 0 14
108353: PUSH
108354: LD_VAR 0 8
108358: ARRAY
108359: PUSH
108360: LD_VAR 0 14
108364: PPUSH
108365: LD_INT 58
108367: PUSH
108368: EMPTY
108369: LIST
108370: PPUSH
108371: CALL_OW 72
108375: IN
108376: NOT
108377: IFFALSE 108433
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108379: LD_VAR 0 4
108383: PUSH
108384: LD_VAR 0 7
108388: ARRAY
108389: PPUSH
108390: LD_VAR 0 14
108394: PUSH
108395: LD_VAR 0 8
108399: ARRAY
108400: PPUSH
108401: CALL_OW 115
// attacking := true ;
108405: LD_ADDR_VAR 0 29
108409: PUSH
108410: LD_INT 1
108412: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108413: LD_VAR 0 4
108417: PUSH
108418: LD_VAR 0 7
108422: ARRAY
108423: PPUSH
108424: LD_INT 71
108426: PPUSH
108427: CALL_OW 109
// continue ;
108431: GO 108346
// end ; end ;
108433: GO 108346
108435: POP
108436: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108437: LD_VAR 0 4
108441: PUSH
108442: LD_VAR 0 7
108446: ARRAY
108447: PPUSH
108448: CALL_OW 257
108452: PUSH
108453: LD_INT 8
108455: EQUAL
108456: PUSH
108457: LD_VAR 0 4
108461: PUSH
108462: LD_VAR 0 7
108466: ARRAY
108467: PPUSH
108468: CALL_OW 264
108472: PUSH
108473: LD_INT 28
108475: PUSH
108476: LD_INT 45
108478: PUSH
108479: LD_INT 7
108481: PUSH
108482: LD_INT 47
108484: PUSH
108485: EMPTY
108486: LIST
108487: LIST
108488: LIST
108489: LIST
108490: IN
108491: OR
108492: IFFALSE 108748
// begin attacking := false ;
108494: LD_ADDR_VAR 0 29
108498: PUSH
108499: LD_INT 0
108501: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108502: LD_VAR 0 14
108506: PUSH
108507: LD_INT 1
108509: ARRAY
108510: PPUSH
108511: CALL_OW 266
108515: PUSH
108516: LD_INT 32
108518: PUSH
108519: LD_INT 31
108521: PUSH
108522: LD_INT 33
108524: PUSH
108525: LD_INT 4
108527: PUSH
108528: LD_INT 5
108530: PUSH
108531: EMPTY
108532: LIST
108533: LIST
108534: LIST
108535: LIST
108536: LIST
108537: IN
108538: IFFALSE 108724
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108540: LD_ADDR_VAR 0 9
108544: PUSH
108545: LD_VAR 0 14
108549: PUSH
108550: LD_INT 1
108552: ARRAY
108553: PPUSH
108554: CALL_OW 266
108558: PPUSH
108559: LD_VAR 0 14
108563: PUSH
108564: LD_INT 1
108566: ARRAY
108567: PPUSH
108568: CALL_OW 250
108572: PPUSH
108573: LD_VAR 0 14
108577: PUSH
108578: LD_INT 1
108580: ARRAY
108581: PPUSH
108582: CALL_OW 251
108586: PPUSH
108587: LD_VAR 0 14
108591: PUSH
108592: LD_INT 1
108594: ARRAY
108595: PPUSH
108596: CALL_OW 254
108600: PPUSH
108601: LD_VAR 0 14
108605: PUSH
108606: LD_INT 1
108608: ARRAY
108609: PPUSH
108610: CALL_OW 248
108614: PPUSH
108615: LD_INT 0
108617: PPUSH
108618: CALL 27705 0 6
108622: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108623: LD_ADDR_VAR 0 8
108627: PUSH
108628: LD_VAR 0 4
108632: PUSH
108633: LD_VAR 0 7
108637: ARRAY
108638: PPUSH
108639: LD_VAR 0 9
108643: PPUSH
108644: CALL 46375 0 2
108648: ST_TO_ADDR
// if j then
108649: LD_VAR 0 8
108653: IFFALSE 108722
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108655: LD_VAR 0 8
108659: PUSH
108660: LD_INT 1
108662: ARRAY
108663: PPUSH
108664: LD_VAR 0 8
108668: PUSH
108669: LD_INT 2
108671: ARRAY
108672: PPUSH
108673: CALL_OW 488
108677: IFFALSE 108722
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108679: LD_VAR 0 4
108683: PUSH
108684: LD_VAR 0 7
108688: ARRAY
108689: PPUSH
108690: LD_VAR 0 8
108694: PUSH
108695: LD_INT 1
108697: ARRAY
108698: PPUSH
108699: LD_VAR 0 8
108703: PUSH
108704: LD_INT 2
108706: ARRAY
108707: PPUSH
108708: CALL_OW 116
// attacking := true ;
108712: LD_ADDR_VAR 0 29
108716: PUSH
108717: LD_INT 1
108719: ST_TO_ADDR
// continue ;
108720: GO 106095
// end ; end else
108722: GO 108748
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108724: LD_VAR 0 4
108728: PUSH
108729: LD_VAR 0 7
108733: ARRAY
108734: PPUSH
108735: LD_VAR 0 14
108739: PUSH
108740: LD_INT 1
108742: ARRAY
108743: PPUSH
108744: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108748: LD_VAR 0 4
108752: PUSH
108753: LD_VAR 0 7
108757: ARRAY
108758: PPUSH
108759: CALL_OW 265
108763: PUSH
108764: LD_INT 11
108766: EQUAL
108767: IFFALSE 109045
// begin k := 10 ;
108769: LD_ADDR_VAR 0 9
108773: PUSH
108774: LD_INT 10
108776: ST_TO_ADDR
// x := 0 ;
108777: LD_ADDR_VAR 0 10
108781: PUSH
108782: LD_INT 0
108784: ST_TO_ADDR
// if tmp < k then
108785: LD_VAR 0 14
108789: PUSH
108790: LD_VAR 0 9
108794: LESS
108795: IFFALSE 108807
// k := tmp ;
108797: LD_ADDR_VAR 0 9
108801: PUSH
108802: LD_VAR 0 14
108806: ST_TO_ADDR
// for j = k downto 1 do
108807: LD_ADDR_VAR 0 8
108811: PUSH
108812: DOUBLE
108813: LD_VAR 0 9
108817: INC
108818: ST_TO_ADDR
108819: LD_INT 1
108821: PUSH
108822: FOR_DOWNTO
108823: IFFALSE 108898
// begin if GetType ( tmp [ j ] ) = unit_human then
108825: LD_VAR 0 14
108829: PUSH
108830: LD_VAR 0 8
108834: ARRAY
108835: PPUSH
108836: CALL_OW 247
108840: PUSH
108841: LD_INT 1
108843: EQUAL
108844: IFFALSE 108896
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108846: LD_VAR 0 4
108850: PUSH
108851: LD_VAR 0 7
108855: ARRAY
108856: PPUSH
108857: LD_VAR 0 14
108861: PUSH
108862: LD_VAR 0 8
108866: ARRAY
108867: PPUSH
108868: CALL 46629 0 2
// x := tmp [ j ] ;
108872: LD_ADDR_VAR 0 10
108876: PUSH
108877: LD_VAR 0 14
108881: PUSH
108882: LD_VAR 0 8
108886: ARRAY
108887: ST_TO_ADDR
// attacking := true ;
108888: LD_ADDR_VAR 0 29
108892: PUSH
108893: LD_INT 1
108895: ST_TO_ADDR
// end ; end ;
108896: GO 108822
108898: POP
108899: POP
// if not x then
108900: LD_VAR 0 10
108904: NOT
108905: IFFALSE 109045
// begin attacking := true ;
108907: LD_ADDR_VAR 0 29
108911: PUSH
108912: LD_INT 1
108914: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108915: LD_VAR 0 4
108919: PUSH
108920: LD_VAR 0 7
108924: ARRAY
108925: PPUSH
108926: CALL_OW 250
108930: PPUSH
108931: LD_VAR 0 4
108935: PUSH
108936: LD_VAR 0 7
108940: ARRAY
108941: PPUSH
108942: CALL_OW 251
108946: PPUSH
108947: CALL_OW 546
108951: PUSH
108952: LD_INT 2
108954: ARRAY
108955: PUSH
108956: LD_VAR 0 14
108960: PUSH
108961: LD_INT 1
108963: ARRAY
108964: PPUSH
108965: CALL_OW 250
108969: PPUSH
108970: LD_VAR 0 14
108974: PUSH
108975: LD_INT 1
108977: ARRAY
108978: PPUSH
108979: CALL_OW 251
108983: PPUSH
108984: CALL_OW 546
108988: PUSH
108989: LD_INT 2
108991: ARRAY
108992: EQUAL
108993: IFFALSE 109021
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108995: LD_VAR 0 4
108999: PUSH
109000: LD_VAR 0 7
109004: ARRAY
109005: PPUSH
109006: LD_VAR 0 14
109010: PUSH
109011: LD_INT 1
109013: ARRAY
109014: PPUSH
109015: CALL 46629 0 2
109019: GO 109045
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109021: LD_VAR 0 4
109025: PUSH
109026: LD_VAR 0 7
109030: ARRAY
109031: PPUSH
109032: LD_VAR 0 14
109036: PUSH
109037: LD_INT 1
109039: ARRAY
109040: PPUSH
109041: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109045: LD_VAR 0 4
109049: PUSH
109050: LD_VAR 0 7
109054: ARRAY
109055: PPUSH
109056: CALL_OW 264
109060: PUSH
109061: LD_INT 29
109063: EQUAL
109064: IFFALSE 109430
// begin if WantsToAttack ( group [ i ] ) in bombed then
109066: LD_VAR 0 4
109070: PUSH
109071: LD_VAR 0 7
109075: ARRAY
109076: PPUSH
109077: CALL_OW 319
109081: PUSH
109082: LD_VAR 0 28
109086: IN
109087: IFFALSE 109091
// continue ;
109089: GO 106095
// k := 8 ;
109091: LD_ADDR_VAR 0 9
109095: PUSH
109096: LD_INT 8
109098: ST_TO_ADDR
// x := 0 ;
109099: LD_ADDR_VAR 0 10
109103: PUSH
109104: LD_INT 0
109106: ST_TO_ADDR
// if tmp < k then
109107: LD_VAR 0 14
109111: PUSH
109112: LD_VAR 0 9
109116: LESS
109117: IFFALSE 109129
// k := tmp ;
109119: LD_ADDR_VAR 0 9
109123: PUSH
109124: LD_VAR 0 14
109128: ST_TO_ADDR
// for j = 1 to k do
109129: LD_ADDR_VAR 0 8
109133: PUSH
109134: DOUBLE
109135: LD_INT 1
109137: DEC
109138: ST_TO_ADDR
109139: LD_VAR 0 9
109143: PUSH
109144: FOR_TO
109145: IFFALSE 109277
// begin if GetType ( tmp [ j ] ) = unit_building then
109147: LD_VAR 0 14
109151: PUSH
109152: LD_VAR 0 8
109156: ARRAY
109157: PPUSH
109158: CALL_OW 247
109162: PUSH
109163: LD_INT 3
109165: EQUAL
109166: IFFALSE 109275
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109168: LD_VAR 0 14
109172: PUSH
109173: LD_VAR 0 8
109177: ARRAY
109178: PUSH
109179: LD_VAR 0 28
109183: IN
109184: NOT
109185: PUSH
109186: LD_VAR 0 14
109190: PUSH
109191: LD_VAR 0 8
109195: ARRAY
109196: PPUSH
109197: CALL_OW 313
109201: AND
109202: IFFALSE 109275
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109204: LD_VAR 0 4
109208: PUSH
109209: LD_VAR 0 7
109213: ARRAY
109214: PPUSH
109215: LD_VAR 0 14
109219: PUSH
109220: LD_VAR 0 8
109224: ARRAY
109225: PPUSH
109226: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109230: LD_ADDR_VAR 0 28
109234: PUSH
109235: LD_VAR 0 28
109239: PPUSH
109240: LD_VAR 0 28
109244: PUSH
109245: LD_INT 1
109247: PLUS
109248: PPUSH
109249: LD_VAR 0 14
109253: PUSH
109254: LD_VAR 0 8
109258: ARRAY
109259: PPUSH
109260: CALL_OW 1
109264: ST_TO_ADDR
// attacking := true ;
109265: LD_ADDR_VAR 0 29
109269: PUSH
109270: LD_INT 1
109272: ST_TO_ADDR
// break ;
109273: GO 109277
// end ; end ;
109275: GO 109144
109277: POP
109278: POP
// if not attacking and f_attack_depot then
109279: LD_VAR 0 29
109283: NOT
109284: PUSH
109285: LD_VAR 0 25
109289: AND
109290: IFFALSE 109385
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109292: LD_ADDR_VAR 0 13
109296: PUSH
109297: LD_VAR 0 14
109301: PPUSH
109302: LD_INT 2
109304: PUSH
109305: LD_INT 30
109307: PUSH
109308: LD_INT 0
109310: PUSH
109311: EMPTY
109312: LIST
109313: LIST
109314: PUSH
109315: LD_INT 30
109317: PUSH
109318: LD_INT 1
109320: PUSH
109321: EMPTY
109322: LIST
109323: LIST
109324: PUSH
109325: EMPTY
109326: LIST
109327: LIST
109328: LIST
109329: PPUSH
109330: CALL_OW 72
109334: ST_TO_ADDR
// if z then
109335: LD_VAR 0 13
109339: IFFALSE 109385
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109341: LD_VAR 0 4
109345: PUSH
109346: LD_VAR 0 7
109350: ARRAY
109351: PPUSH
109352: LD_VAR 0 13
109356: PPUSH
109357: LD_VAR 0 4
109361: PUSH
109362: LD_VAR 0 7
109366: ARRAY
109367: PPUSH
109368: CALL_OW 74
109372: PPUSH
109373: CALL_OW 115
// attacking := true ;
109377: LD_ADDR_VAR 0 29
109381: PUSH
109382: LD_INT 1
109384: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109385: LD_VAR 0 4
109389: PUSH
109390: LD_VAR 0 7
109394: ARRAY
109395: PPUSH
109396: CALL_OW 256
109400: PUSH
109401: LD_INT 500
109403: LESS
109404: IFFALSE 109430
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109406: LD_VAR 0 4
109410: PUSH
109411: LD_VAR 0 7
109415: ARRAY
109416: PPUSH
109417: LD_VAR 0 14
109421: PUSH
109422: LD_INT 1
109424: ARRAY
109425: PPUSH
109426: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109430: LD_VAR 0 4
109434: PUSH
109435: LD_VAR 0 7
109439: ARRAY
109440: PPUSH
109441: CALL_OW 264
109445: PUSH
109446: LD_INT 49
109448: EQUAL
109449: IFFALSE 109570
// begin if not HasTask ( group [ i ] ) then
109451: LD_VAR 0 4
109455: PUSH
109456: LD_VAR 0 7
109460: ARRAY
109461: PPUSH
109462: CALL_OW 314
109466: NOT
109467: IFFALSE 109570
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109469: LD_ADDR_VAR 0 9
109473: PUSH
109474: LD_INT 81
109476: PUSH
109477: LD_VAR 0 4
109481: PUSH
109482: LD_VAR 0 7
109486: ARRAY
109487: PPUSH
109488: CALL_OW 255
109492: PUSH
109493: EMPTY
109494: LIST
109495: LIST
109496: PPUSH
109497: CALL_OW 69
109501: PPUSH
109502: LD_VAR 0 4
109506: PUSH
109507: LD_VAR 0 7
109511: ARRAY
109512: PPUSH
109513: CALL_OW 74
109517: ST_TO_ADDR
// if k then
109518: LD_VAR 0 9
109522: IFFALSE 109570
// if GetDistUnits ( group [ i ] , k ) > 10 then
109524: LD_VAR 0 4
109528: PUSH
109529: LD_VAR 0 7
109533: ARRAY
109534: PPUSH
109535: LD_VAR 0 9
109539: PPUSH
109540: CALL_OW 296
109544: PUSH
109545: LD_INT 10
109547: GREATER
109548: IFFALSE 109570
// ComMoveUnit ( group [ i ] , k ) ;
109550: LD_VAR 0 4
109554: PUSH
109555: LD_VAR 0 7
109559: ARRAY
109560: PPUSH
109561: LD_VAR 0 9
109565: PPUSH
109566: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109570: LD_VAR 0 4
109574: PUSH
109575: LD_VAR 0 7
109579: ARRAY
109580: PPUSH
109581: CALL_OW 256
109585: PUSH
109586: LD_INT 250
109588: LESS
109589: PUSH
109590: LD_VAR 0 4
109594: PUSH
109595: LD_VAR 0 7
109599: ARRAY
109600: PUSH
109601: LD_INT 21
109603: PUSH
109604: LD_INT 2
109606: PUSH
109607: EMPTY
109608: LIST
109609: LIST
109610: PUSH
109611: LD_INT 23
109613: PUSH
109614: LD_INT 2
109616: PUSH
109617: EMPTY
109618: LIST
109619: LIST
109620: PUSH
109621: EMPTY
109622: LIST
109623: LIST
109624: PPUSH
109625: CALL_OW 69
109629: IN
109630: AND
109631: IFFALSE 109756
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109633: LD_ADDR_VAR 0 9
109637: PUSH
109638: LD_OWVAR 3
109642: PUSH
109643: LD_VAR 0 4
109647: PUSH
109648: LD_VAR 0 7
109652: ARRAY
109653: DIFF
109654: PPUSH
109655: LD_VAR 0 4
109659: PUSH
109660: LD_VAR 0 7
109664: ARRAY
109665: PPUSH
109666: CALL_OW 74
109670: ST_TO_ADDR
// if not k then
109671: LD_VAR 0 9
109675: NOT
109676: IFFALSE 109680
// continue ;
109678: GO 106095
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109680: LD_VAR 0 9
109684: PUSH
109685: LD_INT 81
109687: PUSH
109688: LD_VAR 0 4
109692: PUSH
109693: LD_VAR 0 7
109697: ARRAY
109698: PPUSH
109699: CALL_OW 255
109703: PUSH
109704: EMPTY
109705: LIST
109706: LIST
109707: PPUSH
109708: CALL_OW 69
109712: IN
109713: PUSH
109714: LD_VAR 0 9
109718: PPUSH
109719: LD_VAR 0 4
109723: PUSH
109724: LD_VAR 0 7
109728: ARRAY
109729: PPUSH
109730: CALL_OW 296
109734: PUSH
109735: LD_INT 5
109737: LESS
109738: AND
109739: IFFALSE 109756
// ComAutodestruct ( group [ i ] ) ;
109741: LD_VAR 0 4
109745: PUSH
109746: LD_VAR 0 7
109750: ARRAY
109751: PPUSH
109752: CALL 46527 0 1
// end ; if f_attack_depot then
109756: LD_VAR 0 25
109760: IFFALSE 109872
// begin k := 6 ;
109762: LD_ADDR_VAR 0 9
109766: PUSH
109767: LD_INT 6
109769: ST_TO_ADDR
// if tmp < k then
109770: LD_VAR 0 14
109774: PUSH
109775: LD_VAR 0 9
109779: LESS
109780: IFFALSE 109792
// k := tmp ;
109782: LD_ADDR_VAR 0 9
109786: PUSH
109787: LD_VAR 0 14
109791: ST_TO_ADDR
// for j = 1 to k do
109792: LD_ADDR_VAR 0 8
109796: PUSH
109797: DOUBLE
109798: LD_INT 1
109800: DEC
109801: ST_TO_ADDR
109802: LD_VAR 0 9
109806: PUSH
109807: FOR_TO
109808: IFFALSE 109870
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109810: LD_VAR 0 8
109814: PPUSH
109815: CALL_OW 266
109819: PUSH
109820: LD_INT 0
109822: PUSH
109823: LD_INT 1
109825: PUSH
109826: EMPTY
109827: LIST
109828: LIST
109829: IN
109830: IFFALSE 109868
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109832: LD_VAR 0 4
109836: PUSH
109837: LD_VAR 0 7
109841: ARRAY
109842: PPUSH
109843: LD_VAR 0 14
109847: PUSH
109848: LD_VAR 0 8
109852: ARRAY
109853: PPUSH
109854: CALL_OW 115
// attacking := true ;
109858: LD_ADDR_VAR 0 29
109862: PUSH
109863: LD_INT 1
109865: ST_TO_ADDR
// break ;
109866: GO 109870
// end ;
109868: GO 109807
109870: POP
109871: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109872: LD_VAR 0 4
109876: PUSH
109877: LD_VAR 0 7
109881: ARRAY
109882: PPUSH
109883: CALL_OW 302
109887: PUSH
109888: LD_VAR 0 29
109892: NOT
109893: AND
109894: IFFALSE 110216
// begin if GetTag ( group [ i ] ) = 71 then
109896: LD_VAR 0 4
109900: PUSH
109901: LD_VAR 0 7
109905: ARRAY
109906: PPUSH
109907: CALL_OW 110
109911: PUSH
109912: LD_INT 71
109914: EQUAL
109915: IFFALSE 109956
// begin if HasTask ( group [ i ] ) then
109917: LD_VAR 0 4
109921: PUSH
109922: LD_VAR 0 7
109926: ARRAY
109927: PPUSH
109928: CALL_OW 314
109932: IFFALSE 109938
// continue else
109934: GO 106095
109936: GO 109956
// SetTag ( group [ i ] , 0 ) ;
109938: LD_VAR 0 4
109942: PUSH
109943: LD_VAR 0 7
109947: ARRAY
109948: PPUSH
109949: LD_INT 0
109951: PPUSH
109952: CALL_OW 109
// end ; k := 8 ;
109956: LD_ADDR_VAR 0 9
109960: PUSH
109961: LD_INT 8
109963: ST_TO_ADDR
// x := 0 ;
109964: LD_ADDR_VAR 0 10
109968: PUSH
109969: LD_INT 0
109971: ST_TO_ADDR
// if tmp < k then
109972: LD_VAR 0 14
109976: PUSH
109977: LD_VAR 0 9
109981: LESS
109982: IFFALSE 109994
// k := tmp ;
109984: LD_ADDR_VAR 0 9
109988: PUSH
109989: LD_VAR 0 14
109993: ST_TO_ADDR
// for j = 1 to k do
109994: LD_ADDR_VAR 0 8
109998: PUSH
109999: DOUBLE
110000: LD_INT 1
110002: DEC
110003: ST_TO_ADDR
110004: LD_VAR 0 9
110008: PUSH
110009: FOR_TO
110010: IFFALSE 110108
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110012: LD_VAR 0 14
110016: PUSH
110017: LD_VAR 0 8
110021: ARRAY
110022: PPUSH
110023: CALL_OW 247
110027: PUSH
110028: LD_INT 1
110030: EQUAL
110031: PUSH
110032: LD_VAR 0 14
110036: PUSH
110037: LD_VAR 0 8
110041: ARRAY
110042: PPUSH
110043: CALL_OW 256
110047: PUSH
110048: LD_INT 250
110050: LESS
110051: PUSH
110052: LD_VAR 0 20
110056: AND
110057: PUSH
110058: LD_VAR 0 20
110062: NOT
110063: PUSH
110064: LD_VAR 0 14
110068: PUSH
110069: LD_VAR 0 8
110073: ARRAY
110074: PPUSH
110075: CALL_OW 256
110079: PUSH
110080: LD_INT 250
110082: GREATEREQUAL
110083: AND
110084: OR
110085: AND
110086: IFFALSE 110106
// begin x := tmp [ j ] ;
110088: LD_ADDR_VAR 0 10
110092: PUSH
110093: LD_VAR 0 14
110097: PUSH
110098: LD_VAR 0 8
110102: ARRAY
110103: ST_TO_ADDR
// break ;
110104: GO 110108
// end ;
110106: GO 110009
110108: POP
110109: POP
// if x then
110110: LD_VAR 0 10
110114: IFFALSE 110138
// ComAttackUnit ( group [ i ] , x ) else
110116: LD_VAR 0 4
110120: PUSH
110121: LD_VAR 0 7
110125: ARRAY
110126: PPUSH
110127: LD_VAR 0 10
110131: PPUSH
110132: CALL_OW 115
110136: GO 110162
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110138: LD_VAR 0 4
110142: PUSH
110143: LD_VAR 0 7
110147: ARRAY
110148: PPUSH
110149: LD_VAR 0 14
110153: PUSH
110154: LD_INT 1
110156: ARRAY
110157: PPUSH
110158: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110162: LD_VAR 0 4
110166: PUSH
110167: LD_VAR 0 7
110171: ARRAY
110172: PPUSH
110173: CALL_OW 314
110177: NOT
110178: IFFALSE 110216
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110180: LD_VAR 0 4
110184: PUSH
110185: LD_VAR 0 7
110189: ARRAY
110190: PPUSH
110191: LD_VAR 0 14
110195: PPUSH
110196: LD_VAR 0 4
110200: PUSH
110201: LD_VAR 0 7
110205: ARRAY
110206: PPUSH
110207: CALL_OW 74
110211: PPUSH
110212: CALL_OW 115
// end ; end ; end ;
110216: GO 106095
110218: POP
110219: POP
// wait ( 0 0$2 ) ;
110220: LD_INT 70
110222: PPUSH
110223: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110227: LD_VAR 0 4
110231: NOT
110232: PUSH
110233: LD_VAR 0 4
110237: PUSH
110238: EMPTY
110239: EQUAL
110240: OR
110241: PUSH
110242: LD_INT 81
110244: PUSH
110245: LD_VAR 0 35
110249: PUSH
110250: EMPTY
110251: LIST
110252: LIST
110253: PPUSH
110254: CALL_OW 69
110258: NOT
110259: OR
110260: IFFALSE 106080
// end ;
110262: LD_VAR 0 2
110266: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
110267: LD_INT 0
110269: PPUSH
110270: PPUSH
110271: PPUSH
110272: PPUSH
110273: PPUSH
110274: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110275: LD_VAR 0 1
110279: NOT
110280: PUSH
110281: LD_EXP 68
110285: PUSH
110286: LD_VAR 0 1
110290: ARRAY
110291: NOT
110292: OR
110293: PUSH
110294: LD_VAR 0 2
110298: NOT
110299: OR
110300: IFFALSE 110304
// exit ;
110302: GO 110858
// side := mc_sides [ base ] ;
110304: LD_ADDR_VAR 0 6
110308: PUSH
110309: LD_EXP 94
110313: PUSH
110314: LD_VAR 0 1
110318: ARRAY
110319: ST_TO_ADDR
// if not side then
110320: LD_VAR 0 6
110324: NOT
110325: IFFALSE 110329
// exit ;
110327: GO 110858
// for i in solds do
110329: LD_ADDR_VAR 0 7
110333: PUSH
110334: LD_VAR 0 2
110338: PUSH
110339: FOR_IN
110340: IFFALSE 110401
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110342: LD_VAR 0 7
110346: PPUSH
110347: CALL_OW 310
110351: PPUSH
110352: CALL_OW 266
110356: PUSH
110357: LD_INT 32
110359: PUSH
110360: LD_INT 31
110362: PUSH
110363: EMPTY
110364: LIST
110365: LIST
110366: IN
110367: IFFALSE 110387
// solds := solds diff i else
110369: LD_ADDR_VAR 0 2
110373: PUSH
110374: LD_VAR 0 2
110378: PUSH
110379: LD_VAR 0 7
110383: DIFF
110384: ST_TO_ADDR
110385: GO 110399
// SetTag ( i , 18 ) ;
110387: LD_VAR 0 7
110391: PPUSH
110392: LD_INT 18
110394: PPUSH
110395: CALL_OW 109
110399: GO 110339
110401: POP
110402: POP
// if not solds then
110403: LD_VAR 0 2
110407: NOT
110408: IFFALSE 110412
// exit ;
110410: GO 110858
// repeat wait ( 0 0$2 ) ;
110412: LD_INT 70
110414: PPUSH
110415: CALL_OW 67
// enemy := mc_scan [ base ] ;
110419: LD_ADDR_VAR 0 4
110423: PUSH
110424: LD_EXP 91
110428: PUSH
110429: LD_VAR 0 1
110433: ARRAY
110434: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110435: LD_EXP 68
110439: PUSH
110440: LD_VAR 0 1
110444: ARRAY
110445: NOT
110446: PUSH
110447: LD_EXP 68
110451: PUSH
110452: LD_VAR 0 1
110456: ARRAY
110457: PUSH
110458: EMPTY
110459: EQUAL
110460: OR
110461: IFFALSE 110498
// begin for i in solds do
110463: LD_ADDR_VAR 0 7
110467: PUSH
110468: LD_VAR 0 2
110472: PUSH
110473: FOR_IN
110474: IFFALSE 110487
// ComStop ( i ) ;
110476: LD_VAR 0 7
110480: PPUSH
110481: CALL_OW 141
110485: GO 110473
110487: POP
110488: POP
// solds := [ ] ;
110489: LD_ADDR_VAR 0 2
110493: PUSH
110494: EMPTY
110495: ST_TO_ADDR
// exit ;
110496: GO 110858
// end ; for i in solds do
110498: LD_ADDR_VAR 0 7
110502: PUSH
110503: LD_VAR 0 2
110507: PUSH
110508: FOR_IN
110509: IFFALSE 110830
// begin if IsInUnit ( i ) then
110511: LD_VAR 0 7
110515: PPUSH
110516: CALL_OW 310
110520: IFFALSE 110531
// ComExitBuilding ( i ) ;
110522: LD_VAR 0 7
110526: PPUSH
110527: CALL_OW 122
// if GetLives ( i ) > 500 then
110531: LD_VAR 0 7
110535: PPUSH
110536: CALL_OW 256
110540: PUSH
110541: LD_INT 500
110543: GREATER
110544: IFFALSE 110597
// begin e := NearestUnitToUnit ( enemy , i ) ;
110546: LD_ADDR_VAR 0 5
110550: PUSH
110551: LD_VAR 0 4
110555: PPUSH
110556: LD_VAR 0 7
110560: PPUSH
110561: CALL_OW 74
110565: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
110566: LD_VAR 0 7
110570: PPUSH
110571: LD_VAR 0 5
110575: PPUSH
110576: CALL_OW 250
110580: PPUSH
110581: LD_VAR 0 5
110585: PPUSH
110586: CALL_OW 251
110590: PPUSH
110591: CALL_OW 114
// end else
110595: GO 110828
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110597: LD_VAR 0 7
110601: PPUSH
110602: LD_EXP 68
110606: PUSH
110607: LD_VAR 0 1
110611: ARRAY
110612: PPUSH
110613: LD_INT 2
110615: PUSH
110616: LD_INT 30
110618: PUSH
110619: LD_INT 0
110621: PUSH
110622: EMPTY
110623: LIST
110624: LIST
110625: PUSH
110626: LD_INT 30
110628: PUSH
110629: LD_INT 1
110631: PUSH
110632: EMPTY
110633: LIST
110634: LIST
110635: PUSH
110636: LD_INT 30
110638: PUSH
110639: LD_INT 6
110641: PUSH
110642: EMPTY
110643: LIST
110644: LIST
110645: PUSH
110646: EMPTY
110647: LIST
110648: LIST
110649: LIST
110650: LIST
110651: PPUSH
110652: CALL_OW 72
110656: PPUSH
110657: LD_VAR 0 7
110661: PPUSH
110662: CALL_OW 74
110666: PPUSH
110667: CALL_OW 296
110671: PUSH
110672: LD_INT 10
110674: GREATER
110675: IFFALSE 110828
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110677: LD_ADDR_VAR 0 8
110681: PUSH
110682: LD_EXP 68
110686: PUSH
110687: LD_VAR 0 1
110691: ARRAY
110692: PPUSH
110693: LD_INT 2
110695: PUSH
110696: LD_INT 30
110698: PUSH
110699: LD_INT 0
110701: PUSH
110702: EMPTY
110703: LIST
110704: LIST
110705: PUSH
110706: LD_INT 30
110708: PUSH
110709: LD_INT 1
110711: PUSH
110712: EMPTY
110713: LIST
110714: LIST
110715: PUSH
110716: LD_INT 30
110718: PUSH
110719: LD_INT 6
110721: PUSH
110722: EMPTY
110723: LIST
110724: LIST
110725: PUSH
110726: EMPTY
110727: LIST
110728: LIST
110729: LIST
110730: LIST
110731: PPUSH
110732: CALL_OW 72
110736: PPUSH
110737: LD_VAR 0 7
110741: PPUSH
110742: CALL_OW 74
110746: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110747: LD_VAR 0 7
110751: PPUSH
110752: LD_VAR 0 8
110756: PPUSH
110757: CALL_OW 250
110761: PPUSH
110762: LD_INT 3
110764: PPUSH
110765: LD_INT 5
110767: PPUSH
110768: CALL_OW 272
110772: PPUSH
110773: LD_VAR 0 8
110777: PPUSH
110778: CALL_OW 251
110782: PPUSH
110783: LD_INT 3
110785: PPUSH
110786: LD_INT 5
110788: PPUSH
110789: CALL_OW 273
110793: PPUSH
110794: CALL_OW 111
// SetTag ( i , 0 ) ;
110798: LD_VAR 0 7
110802: PPUSH
110803: LD_INT 0
110805: PPUSH
110806: CALL_OW 109
// solds := solds diff i ;
110810: LD_ADDR_VAR 0 2
110814: PUSH
110815: LD_VAR 0 2
110819: PUSH
110820: LD_VAR 0 7
110824: DIFF
110825: ST_TO_ADDR
// continue ;
110826: GO 110508
// end ; end ;
110828: GO 110508
110830: POP
110831: POP
// until not solds or not enemy ;
110832: LD_VAR 0 2
110836: NOT
110837: PUSH
110838: LD_VAR 0 4
110842: NOT
110843: OR
110844: IFFALSE 110412
// MC_Reset ( base , 18 ) ;
110846: LD_VAR 0 1
110850: PPUSH
110851: LD_INT 18
110853: PPUSH
110854: CALL 59124 0 2
// end ;
110858: LD_VAR 0 3
110862: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
110863: LD_INT 0
110865: PPUSH
110866: PPUSH
110867: PPUSH
110868: PPUSH
110869: PPUSH
110870: PPUSH
110871: PPUSH
110872: PPUSH
110873: PPUSH
110874: PPUSH
110875: PPUSH
110876: PPUSH
110877: PPUSH
110878: PPUSH
110879: PPUSH
110880: PPUSH
110881: PPUSH
110882: PPUSH
110883: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110884: LD_ADDR_VAR 0 12
110888: PUSH
110889: LD_EXP 68
110893: PUSH
110894: LD_VAR 0 1
110898: ARRAY
110899: PPUSH
110900: LD_INT 25
110902: PUSH
110903: LD_INT 3
110905: PUSH
110906: EMPTY
110907: LIST
110908: LIST
110909: PPUSH
110910: CALL_OW 72
110914: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110915: LD_EXP 108
110919: PUSH
110920: LD_VAR 0 1
110924: ARRAY
110925: IFFALSE 110949
// mechs := mechs diff mc_remote_driver [ base ] ;
110927: LD_ADDR_VAR 0 12
110931: PUSH
110932: LD_VAR 0 12
110936: PUSH
110937: LD_EXP 108
110941: PUSH
110942: LD_VAR 0 1
110946: ARRAY
110947: DIFF
110948: ST_TO_ADDR
// for i in mechs do
110949: LD_ADDR_VAR 0 4
110953: PUSH
110954: LD_VAR 0 12
110958: PUSH
110959: FOR_IN
110960: IFFALSE 110995
// if GetTag ( i ) > 0 then
110962: LD_VAR 0 4
110966: PPUSH
110967: CALL_OW 110
110971: PUSH
110972: LD_INT 0
110974: GREATER
110975: IFFALSE 110993
// mechs := mechs diff i ;
110977: LD_ADDR_VAR 0 12
110981: PUSH
110982: LD_VAR 0 12
110986: PUSH
110987: LD_VAR 0 4
110991: DIFF
110992: ST_TO_ADDR
110993: GO 110959
110995: POP
110996: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110997: LD_ADDR_VAR 0 8
111001: PUSH
111002: LD_EXP 68
111006: PUSH
111007: LD_VAR 0 1
111011: ARRAY
111012: PPUSH
111013: LD_INT 2
111015: PUSH
111016: LD_INT 25
111018: PUSH
111019: LD_INT 1
111021: PUSH
111022: EMPTY
111023: LIST
111024: LIST
111025: PUSH
111026: LD_INT 25
111028: PUSH
111029: LD_INT 5
111031: PUSH
111032: EMPTY
111033: LIST
111034: LIST
111035: PUSH
111036: LD_INT 25
111038: PUSH
111039: LD_INT 8
111041: PUSH
111042: EMPTY
111043: LIST
111044: LIST
111045: PUSH
111046: LD_INT 25
111048: PUSH
111049: LD_INT 9
111051: PUSH
111052: EMPTY
111053: LIST
111054: LIST
111055: PUSH
111056: EMPTY
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: LIST
111062: PPUSH
111063: CALL_OW 72
111067: ST_TO_ADDR
// if not defenders and not solds then
111068: LD_VAR 0 2
111072: NOT
111073: PUSH
111074: LD_VAR 0 8
111078: NOT
111079: AND
111080: IFFALSE 111084
// exit ;
111082: GO 112854
// depot_under_attack := false ;
111084: LD_ADDR_VAR 0 16
111088: PUSH
111089: LD_INT 0
111091: ST_TO_ADDR
// sold_defenders := [ ] ;
111092: LD_ADDR_VAR 0 17
111096: PUSH
111097: EMPTY
111098: ST_TO_ADDR
// if mechs then
111099: LD_VAR 0 12
111103: IFFALSE 111256
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111105: LD_ADDR_VAR 0 4
111109: PUSH
111110: LD_VAR 0 2
111114: PPUSH
111115: LD_INT 21
111117: PUSH
111118: LD_INT 2
111120: PUSH
111121: EMPTY
111122: LIST
111123: LIST
111124: PPUSH
111125: CALL_OW 72
111129: PUSH
111130: FOR_IN
111131: IFFALSE 111254
// begin if GetTag ( i ) <> 20 then
111133: LD_VAR 0 4
111137: PPUSH
111138: CALL_OW 110
111142: PUSH
111143: LD_INT 20
111145: NONEQUAL
111146: IFFALSE 111160
// SetTag ( i , 20 ) ;
111148: LD_VAR 0 4
111152: PPUSH
111153: LD_INT 20
111155: PPUSH
111156: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111160: LD_VAR 0 4
111164: PPUSH
111165: CALL_OW 263
111169: PUSH
111170: LD_INT 1
111172: EQUAL
111173: PUSH
111174: LD_VAR 0 4
111178: PPUSH
111179: CALL_OW 311
111183: NOT
111184: AND
111185: IFFALSE 111252
// begin un := mechs [ 1 ] ;
111187: LD_ADDR_VAR 0 10
111191: PUSH
111192: LD_VAR 0 12
111196: PUSH
111197: LD_INT 1
111199: ARRAY
111200: ST_TO_ADDR
// ComExit ( un ) ;
111201: LD_VAR 0 10
111205: PPUSH
111206: CALL 51393 0 1
// AddComEnterUnit ( un , i ) ;
111210: LD_VAR 0 10
111214: PPUSH
111215: LD_VAR 0 4
111219: PPUSH
111220: CALL_OW 180
// SetTag ( un , 19 ) ;
111224: LD_VAR 0 10
111228: PPUSH
111229: LD_INT 19
111231: PPUSH
111232: CALL_OW 109
// mechs := mechs diff un ;
111236: LD_ADDR_VAR 0 12
111240: PUSH
111241: LD_VAR 0 12
111245: PUSH
111246: LD_VAR 0 10
111250: DIFF
111251: ST_TO_ADDR
// end ; end ;
111252: GO 111130
111254: POP
111255: POP
// if solds then
111256: LD_VAR 0 8
111260: IFFALSE 111319
// for i in solds do
111262: LD_ADDR_VAR 0 4
111266: PUSH
111267: LD_VAR 0 8
111271: PUSH
111272: FOR_IN
111273: IFFALSE 111317
// if not GetTag ( i ) then
111275: LD_VAR 0 4
111279: PPUSH
111280: CALL_OW 110
111284: NOT
111285: IFFALSE 111315
// begin defenders := defenders union i ;
111287: LD_ADDR_VAR 0 2
111291: PUSH
111292: LD_VAR 0 2
111296: PUSH
111297: LD_VAR 0 4
111301: UNION
111302: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111303: LD_VAR 0 4
111307: PPUSH
111308: LD_INT 18
111310: PPUSH
111311: CALL_OW 109
// end ;
111315: GO 111272
111317: POP
111318: POP
// repeat wait ( 0 0$2 ) ;
111319: LD_INT 70
111321: PPUSH
111322: CALL_OW 67
// enemy := mc_scan [ base ] ;
111326: LD_ADDR_VAR 0 21
111330: PUSH
111331: LD_EXP 91
111335: PUSH
111336: LD_VAR 0 1
111340: ARRAY
111341: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111342: LD_EXP 68
111346: PUSH
111347: LD_VAR 0 1
111351: ARRAY
111352: NOT
111353: PUSH
111354: LD_EXP 68
111358: PUSH
111359: LD_VAR 0 1
111363: ARRAY
111364: PUSH
111365: EMPTY
111366: EQUAL
111367: OR
111368: IFFALSE 111405
// begin for i in defenders do
111370: LD_ADDR_VAR 0 4
111374: PUSH
111375: LD_VAR 0 2
111379: PUSH
111380: FOR_IN
111381: IFFALSE 111394
// ComStop ( i ) ;
111383: LD_VAR 0 4
111387: PPUSH
111388: CALL_OW 141
111392: GO 111380
111394: POP
111395: POP
// defenders := [ ] ;
111396: LD_ADDR_VAR 0 2
111400: PUSH
111401: EMPTY
111402: ST_TO_ADDR
// exit ;
111403: GO 112854
// end ; for i in defenders do
111405: LD_ADDR_VAR 0 4
111409: PUSH
111410: LD_VAR 0 2
111414: PUSH
111415: FOR_IN
111416: IFFALSE 112314
// begin e := NearestUnitToUnit ( enemy , i ) ;
111418: LD_ADDR_VAR 0 13
111422: PUSH
111423: LD_VAR 0 21
111427: PPUSH
111428: LD_VAR 0 4
111432: PPUSH
111433: CALL_OW 74
111437: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111438: LD_ADDR_VAR 0 7
111442: PUSH
111443: LD_EXP 68
111447: PUSH
111448: LD_VAR 0 1
111452: ARRAY
111453: PPUSH
111454: LD_INT 2
111456: PUSH
111457: LD_INT 30
111459: PUSH
111460: LD_INT 0
111462: PUSH
111463: EMPTY
111464: LIST
111465: LIST
111466: PUSH
111467: LD_INT 30
111469: PUSH
111470: LD_INT 1
111472: PUSH
111473: EMPTY
111474: LIST
111475: LIST
111476: PUSH
111477: EMPTY
111478: LIST
111479: LIST
111480: LIST
111481: PPUSH
111482: CALL_OW 72
111486: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111487: LD_ADDR_VAR 0 16
111491: PUSH
111492: LD_VAR 0 7
111496: NOT
111497: PUSH
111498: LD_VAR 0 7
111502: PPUSH
111503: LD_INT 3
111505: PUSH
111506: LD_INT 24
111508: PUSH
111509: LD_INT 600
111511: PUSH
111512: EMPTY
111513: LIST
111514: LIST
111515: PUSH
111516: EMPTY
111517: LIST
111518: LIST
111519: PPUSH
111520: CALL_OW 72
111524: OR
111525: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111526: LD_VAR 0 4
111530: PPUSH
111531: CALL_OW 247
111535: PUSH
111536: LD_INT 2
111538: DOUBLE
111539: EQUAL
111540: IFTRUE 111544
111542: GO 111940
111544: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111545: LD_VAR 0 4
111549: PPUSH
111550: CALL_OW 256
111554: PUSH
111555: LD_INT 1000
111557: EQUAL
111558: PUSH
111559: LD_VAR 0 4
111563: PPUSH
111564: LD_VAR 0 13
111568: PPUSH
111569: CALL_OW 296
111573: PUSH
111574: LD_INT 40
111576: LESS
111577: PUSH
111578: LD_VAR 0 13
111582: PPUSH
111583: LD_EXP 93
111587: PUSH
111588: LD_VAR 0 1
111592: ARRAY
111593: PPUSH
111594: CALL_OW 308
111598: OR
111599: AND
111600: IFFALSE 111722
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111602: LD_VAR 0 4
111606: PPUSH
111607: CALL_OW 262
111611: PUSH
111612: LD_INT 1
111614: EQUAL
111615: PUSH
111616: LD_VAR 0 4
111620: PPUSH
111621: CALL_OW 261
111625: PUSH
111626: LD_INT 30
111628: LESS
111629: AND
111630: PUSH
111631: LD_VAR 0 7
111635: AND
111636: IFFALSE 111706
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111638: LD_VAR 0 4
111642: PPUSH
111643: LD_VAR 0 7
111647: PPUSH
111648: LD_VAR 0 4
111652: PPUSH
111653: CALL_OW 74
111657: PPUSH
111658: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111662: LD_VAR 0 4
111666: PPUSH
111667: LD_VAR 0 7
111671: PPUSH
111672: LD_VAR 0 4
111676: PPUSH
111677: CALL_OW 74
111681: PPUSH
111682: CALL_OW 296
111686: PUSH
111687: LD_INT 6
111689: LESS
111690: IFFALSE 111704
// SetFuel ( i , 100 ) ;
111692: LD_VAR 0 4
111696: PPUSH
111697: LD_INT 100
111699: PPUSH
111700: CALL_OW 240
// end else
111704: GO 111720
// ComAttackUnit ( i , e ) ;
111706: LD_VAR 0 4
111710: PPUSH
111711: LD_VAR 0 13
111715: PPUSH
111716: CALL_OW 115
// end else
111720: GO 111823
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111722: LD_VAR 0 13
111726: PPUSH
111727: LD_EXP 93
111731: PUSH
111732: LD_VAR 0 1
111736: ARRAY
111737: PPUSH
111738: CALL_OW 308
111742: NOT
111743: PUSH
111744: LD_VAR 0 4
111748: PPUSH
111749: LD_VAR 0 13
111753: PPUSH
111754: CALL_OW 296
111758: PUSH
111759: LD_INT 40
111761: GREATEREQUAL
111762: AND
111763: PUSH
111764: LD_VAR 0 4
111768: PPUSH
111769: CALL_OW 256
111773: PUSH
111774: LD_INT 650
111776: LESSEQUAL
111777: OR
111778: PUSH
111779: LD_VAR 0 4
111783: PPUSH
111784: LD_EXP 92
111788: PUSH
111789: LD_VAR 0 1
111793: ARRAY
111794: PPUSH
111795: CALL_OW 308
111799: NOT
111800: AND
111801: IFFALSE 111823
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111803: LD_VAR 0 4
111807: PPUSH
111808: LD_EXP 92
111812: PUSH
111813: LD_VAR 0 1
111817: ARRAY
111818: PPUSH
111819: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111823: LD_VAR 0 4
111827: PPUSH
111828: CALL_OW 256
111832: PUSH
111833: LD_INT 1000
111835: LESS
111836: PUSH
111837: LD_VAR 0 4
111841: PPUSH
111842: CALL_OW 263
111846: PUSH
111847: LD_INT 1
111849: EQUAL
111850: AND
111851: PUSH
111852: LD_VAR 0 4
111856: PPUSH
111857: CALL_OW 311
111861: AND
111862: PUSH
111863: LD_VAR 0 4
111867: PPUSH
111868: LD_EXP 92
111872: PUSH
111873: LD_VAR 0 1
111877: ARRAY
111878: PPUSH
111879: CALL_OW 308
111883: AND
111884: IFFALSE 111938
// begin mech := IsDrivenBy ( i ) ;
111886: LD_ADDR_VAR 0 9
111890: PUSH
111891: LD_VAR 0 4
111895: PPUSH
111896: CALL_OW 311
111900: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111901: LD_VAR 0 9
111905: PPUSH
111906: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111910: LD_VAR 0 9
111914: PPUSH
111915: LD_VAR 0 4
111919: PPUSH
111920: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111924: LD_VAR 0 9
111928: PPUSH
111929: LD_VAR 0 4
111933: PPUSH
111934: CALL_OW 180
// end ; end ; unit_human :
111938: GO 112285
111940: LD_INT 1
111942: DOUBLE
111943: EQUAL
111944: IFTRUE 111948
111946: GO 112284
111948: POP
// begin b := IsInUnit ( i ) ;
111949: LD_ADDR_VAR 0 18
111953: PUSH
111954: LD_VAR 0 4
111958: PPUSH
111959: CALL_OW 310
111963: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111964: LD_ADDR_VAR 0 19
111968: PUSH
111969: LD_VAR 0 18
111973: NOT
111974: PUSH
111975: LD_VAR 0 18
111979: PPUSH
111980: CALL_OW 266
111984: PUSH
111985: LD_INT 32
111987: PUSH
111988: LD_INT 31
111990: PUSH
111991: EMPTY
111992: LIST
111993: LIST
111994: IN
111995: OR
111996: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
111997: LD_VAR 0 18
112001: PPUSH
112002: CALL_OW 266
112006: PUSH
112007: LD_INT 5
112009: EQUAL
112010: PUSH
112011: LD_VAR 0 4
112015: PPUSH
112016: CALL_OW 257
112020: PUSH
112021: LD_INT 1
112023: PUSH
112024: LD_INT 2
112026: PUSH
112027: LD_INT 3
112029: PUSH
112030: LD_INT 4
112032: PUSH
112033: EMPTY
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: IN
112039: AND
112040: IFFALSE 112077
// begin class := AllowSpecClass ( i ) ;
112042: LD_ADDR_VAR 0 20
112046: PUSH
112047: LD_VAR 0 4
112051: PPUSH
112052: CALL 15397 0 1
112056: ST_TO_ADDR
// if class then
112057: LD_VAR 0 20
112061: IFFALSE 112077
// ComChangeProfession ( i , class ) ;
112063: LD_VAR 0 4
112067: PPUSH
112068: LD_VAR 0 20
112072: PPUSH
112073: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112077: LD_VAR 0 16
112081: PUSH
112082: LD_VAR 0 2
112086: PPUSH
112087: LD_INT 21
112089: PUSH
112090: LD_INT 2
112092: PUSH
112093: EMPTY
112094: LIST
112095: LIST
112096: PPUSH
112097: CALL_OW 72
112101: PUSH
112102: LD_INT 1
112104: LESSEQUAL
112105: OR
112106: PUSH
112107: LD_VAR 0 19
112111: AND
112112: PUSH
112113: LD_VAR 0 4
112117: PUSH
112118: LD_VAR 0 17
112122: IN
112123: NOT
112124: AND
112125: IFFALSE 112218
// begin if b then
112127: LD_VAR 0 18
112131: IFFALSE 112180
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112133: LD_VAR 0 18
112137: PPUSH
112138: LD_VAR 0 21
112142: PPUSH
112143: LD_VAR 0 18
112147: PPUSH
112148: CALL_OW 74
112152: PPUSH
112153: CALL_OW 296
112157: PUSH
112158: LD_INT 10
112160: LESS
112161: PUSH
112162: LD_VAR 0 18
112166: PPUSH
112167: CALL_OW 461
112171: PUSH
112172: LD_INT 7
112174: NONEQUAL
112175: AND
112176: IFFALSE 112180
// continue ;
112178: GO 111415
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112180: LD_ADDR_VAR 0 17
112184: PUSH
112185: LD_VAR 0 17
112189: PPUSH
112190: LD_VAR 0 17
112194: PUSH
112195: LD_INT 1
112197: PLUS
112198: PPUSH
112199: LD_VAR 0 4
112203: PPUSH
112204: CALL_OW 1
112208: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112209: LD_VAR 0 4
112213: PPUSH
112214: CALL_OW 122
// end ; if sold_defenders then
112218: LD_VAR 0 17
112222: IFFALSE 112282
// if i in sold_defenders then
112224: LD_VAR 0 4
112228: PUSH
112229: LD_VAR 0 17
112233: IN
112234: IFFALSE 112282
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112236: LD_VAR 0 4
112240: PPUSH
112241: CALL_OW 314
112245: NOT
112246: PUSH
112247: LD_VAR 0 4
112251: PPUSH
112252: LD_VAR 0 13
112256: PPUSH
112257: CALL_OW 296
112261: PUSH
112262: LD_INT 30
112264: LESS
112265: AND
112266: IFFALSE 112282
// ComAttackUnit ( i , e ) ;
112268: LD_VAR 0 4
112272: PPUSH
112273: LD_VAR 0 13
112277: PPUSH
112278: CALL_OW 115
// end ; end ; end ;
112282: GO 112285
112284: POP
// if IsDead ( i ) then
112285: LD_VAR 0 4
112289: PPUSH
112290: CALL_OW 301
112294: IFFALSE 112312
// defenders := defenders diff i ;
112296: LD_ADDR_VAR 0 2
112300: PUSH
112301: LD_VAR 0 2
112305: PUSH
112306: LD_VAR 0 4
112310: DIFF
112311: ST_TO_ADDR
// end ;
112312: GO 111415
112314: POP
112315: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112316: LD_VAR 0 21
112320: NOT
112321: PUSH
112322: LD_VAR 0 2
112326: NOT
112327: OR
112328: PUSH
112329: LD_EXP 68
112333: PUSH
112334: LD_VAR 0 1
112338: ARRAY
112339: NOT
112340: OR
112341: IFFALSE 111319
// MC_Reset ( base , 18 ) ;
112343: LD_VAR 0 1
112347: PPUSH
112348: LD_INT 18
112350: PPUSH
112351: CALL 59124 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112355: LD_ADDR_VAR 0 2
112359: PUSH
112360: LD_VAR 0 2
112364: PUSH
112365: LD_VAR 0 2
112369: PPUSH
112370: LD_INT 2
112372: PUSH
112373: LD_INT 25
112375: PUSH
112376: LD_INT 1
112378: PUSH
112379: EMPTY
112380: LIST
112381: LIST
112382: PUSH
112383: LD_INT 25
112385: PUSH
112386: LD_INT 5
112388: PUSH
112389: EMPTY
112390: LIST
112391: LIST
112392: PUSH
112393: LD_INT 25
112395: PUSH
112396: LD_INT 8
112398: PUSH
112399: EMPTY
112400: LIST
112401: LIST
112402: PUSH
112403: LD_INT 25
112405: PUSH
112406: LD_INT 9
112408: PUSH
112409: EMPTY
112410: LIST
112411: LIST
112412: PUSH
112413: EMPTY
112414: LIST
112415: LIST
112416: LIST
112417: LIST
112418: LIST
112419: PPUSH
112420: CALL_OW 72
112424: DIFF
112425: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112426: LD_VAR 0 21
112430: NOT
112431: PUSH
112432: LD_VAR 0 2
112436: PPUSH
112437: LD_INT 21
112439: PUSH
112440: LD_INT 2
112442: PUSH
112443: EMPTY
112444: LIST
112445: LIST
112446: PPUSH
112447: CALL_OW 72
112451: AND
112452: IFFALSE 112790
// begin tmp := FilterByTag ( defenders , 19 ) ;
112454: LD_ADDR_VAR 0 11
112458: PUSH
112459: LD_VAR 0 2
112463: PPUSH
112464: LD_INT 19
112466: PPUSH
112467: CALL 48569 0 2
112471: ST_TO_ADDR
// if tmp then
112472: LD_VAR 0 11
112476: IFFALSE 112546
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112478: LD_ADDR_VAR 0 11
112482: PUSH
112483: LD_VAR 0 11
112487: PPUSH
112488: LD_INT 25
112490: PUSH
112491: LD_INT 3
112493: PUSH
112494: EMPTY
112495: LIST
112496: LIST
112497: PPUSH
112498: CALL_OW 72
112502: ST_TO_ADDR
// if tmp then
112503: LD_VAR 0 11
112507: IFFALSE 112546
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112509: LD_ADDR_EXP 80
112513: PUSH
112514: LD_EXP 80
112518: PPUSH
112519: LD_VAR 0 1
112523: PPUSH
112524: LD_EXP 80
112528: PUSH
112529: LD_VAR 0 1
112533: ARRAY
112534: PUSH
112535: LD_VAR 0 11
112539: UNION
112540: PPUSH
112541: CALL_OW 1
112545: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112546: LD_VAR 0 1
112550: PPUSH
112551: LD_INT 19
112553: PPUSH
112554: CALL 59124 0 2
// repeat wait ( 0 0$1 ) ;
112558: LD_INT 35
112560: PPUSH
112561: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112565: LD_EXP 68
112569: PUSH
112570: LD_VAR 0 1
112574: ARRAY
112575: NOT
112576: PUSH
112577: LD_EXP 68
112581: PUSH
112582: LD_VAR 0 1
112586: ARRAY
112587: PUSH
112588: EMPTY
112589: EQUAL
112590: OR
112591: IFFALSE 112628
// begin for i in defenders do
112593: LD_ADDR_VAR 0 4
112597: PUSH
112598: LD_VAR 0 2
112602: PUSH
112603: FOR_IN
112604: IFFALSE 112617
// ComStop ( i ) ;
112606: LD_VAR 0 4
112610: PPUSH
112611: CALL_OW 141
112615: GO 112603
112617: POP
112618: POP
// defenders := [ ] ;
112619: LD_ADDR_VAR 0 2
112623: PUSH
112624: EMPTY
112625: ST_TO_ADDR
// exit ;
112626: GO 112854
// end ; for i in defenders do
112628: LD_ADDR_VAR 0 4
112632: PUSH
112633: LD_VAR 0 2
112637: PUSH
112638: FOR_IN
112639: IFFALSE 112728
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112641: LD_VAR 0 4
112645: PPUSH
112646: LD_EXP 92
112650: PUSH
112651: LD_VAR 0 1
112655: ARRAY
112656: PPUSH
112657: CALL_OW 308
112661: NOT
112662: IFFALSE 112686
// ComMoveToArea ( i , mc_parking [ base ] ) else
112664: LD_VAR 0 4
112668: PPUSH
112669: LD_EXP 92
112673: PUSH
112674: LD_VAR 0 1
112678: ARRAY
112679: PPUSH
112680: CALL_OW 113
112684: GO 112726
// if GetControl ( i ) = control_manual then
112686: LD_VAR 0 4
112690: PPUSH
112691: CALL_OW 263
112695: PUSH
112696: LD_INT 1
112698: EQUAL
112699: IFFALSE 112726
// if IsDrivenBy ( i ) then
112701: LD_VAR 0 4
112705: PPUSH
112706: CALL_OW 311
112710: IFFALSE 112726
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112712: LD_VAR 0 4
112716: PPUSH
112717: CALL_OW 311
112721: PPUSH
112722: CALL_OW 121
// end ;
112726: GO 112638
112728: POP
112729: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112730: LD_VAR 0 2
112734: PPUSH
112735: LD_INT 95
112737: PUSH
112738: LD_EXP 92
112742: PUSH
112743: LD_VAR 0 1
112747: ARRAY
112748: PUSH
112749: EMPTY
112750: LIST
112751: LIST
112752: PPUSH
112753: CALL_OW 72
112757: PUSH
112758: LD_VAR 0 2
112762: EQUAL
112763: PUSH
112764: LD_EXP 91
112768: PUSH
112769: LD_VAR 0 1
112773: ARRAY
112774: OR
112775: PUSH
112776: LD_EXP 68
112780: PUSH
112781: LD_VAR 0 1
112785: ARRAY
112786: NOT
112787: OR
112788: IFFALSE 112558
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112790: LD_ADDR_EXP 90
112794: PUSH
112795: LD_EXP 90
112799: PPUSH
112800: LD_VAR 0 1
112804: PPUSH
112805: LD_VAR 0 2
112809: PPUSH
112810: LD_INT 21
112812: PUSH
112813: LD_INT 2
112815: PUSH
112816: EMPTY
112817: LIST
112818: LIST
112819: PPUSH
112820: CALL_OW 72
112824: PPUSH
112825: CALL_OW 1
112829: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112830: LD_VAR 0 1
112834: PPUSH
112835: LD_INT 19
112837: PPUSH
112838: CALL 59124 0 2
// MC_Reset ( base , 20 ) ;
112842: LD_VAR 0 1
112846: PPUSH
112847: LD_INT 20
112849: PPUSH
112850: CALL 59124 0 2
// end ; end_of_file
112854: LD_VAR 0 3
112858: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112859: LD_VAR 0 1
112863: PUSH
112864: LD_INT 200
112866: DOUBLE
112867: GREATEREQUAL
112868: IFFALSE 112876
112870: LD_INT 299
112872: DOUBLE
112873: LESSEQUAL
112874: IFTRUE 112878
112876: GO 112910
112878: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112879: LD_VAR 0 1
112883: PPUSH
112884: LD_VAR 0 2
112888: PPUSH
112889: LD_VAR 0 3
112893: PPUSH
112894: LD_VAR 0 4
112898: PPUSH
112899: LD_VAR 0 5
112903: PPUSH
112904: CALL 101625 0 5
112908: GO 112987
112910: LD_INT 300
112912: DOUBLE
112913: GREATEREQUAL
112914: IFFALSE 112922
112916: LD_INT 399
112918: DOUBLE
112919: LESSEQUAL
112920: IFTRUE 112924
112922: GO 112986
112924: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112925: LD_VAR 0 1
112929: PPUSH
112930: LD_VAR 0 2
112934: PPUSH
112935: LD_VAR 0 3
112939: PPUSH
112940: LD_VAR 0 4
112944: PPUSH
112945: LD_VAR 0 5
112949: PPUSH
112950: LD_VAR 0 6
112954: PPUSH
112955: LD_VAR 0 7
112959: PPUSH
112960: LD_VAR 0 8
112964: PPUSH
112965: LD_VAR 0 9
112969: PPUSH
112970: LD_VAR 0 10
112974: PPUSH
112975: LD_VAR 0 11
112979: PPUSH
112980: CALL 97954 0 11
112984: GO 112987
112986: POP
// end ;
112987: PPOPN 11
112989: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
112990: LD_VAR 0 1
112994: PPUSH
112995: LD_VAR 0 2
112999: PPUSH
113000: LD_VAR 0 3
113004: PPUSH
113005: LD_VAR 0 4
113009: PPUSH
113010: LD_VAR 0 5
113014: PPUSH
113015: CALL 101361 0 5
// end ; end_of_file
113019: PPOPN 5
113021: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113022: LD_VAR 0 1
113026: PPUSH
113027: LD_VAR 0 2
113031: PPUSH
113032: LD_VAR 0 3
113036: PPUSH
113037: LD_VAR 0 4
113041: PPUSH
113042: LD_VAR 0 5
113046: PPUSH
113047: LD_VAR 0 6
113051: PPUSH
113052: CALL 85647 0 6
// end ;
113056: PPOPN 6
113058: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
113059: LD_INT 0
113061: PPUSH
// begin if not units then
113062: LD_VAR 0 1
113066: NOT
113067: IFFALSE 113071
// exit ;
113069: GO 113071
// end ;
113071: PPOPN 7
113073: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
113074: CALL 85618 0 0
// end ;
113078: PPOPN 1
113080: END
