// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12715 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 66
 744: PUSH
 745: LD_EXP 66
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 66
 777: PUSH
 778: LD_EXP 66
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 53514 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12572 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12572 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 66
1974: PUSH
1975: LD_EXP 66
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18426 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18426 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18426 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18426 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18426 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 76423 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 76367 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 75426 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 76255 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 75937 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 75668 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 75287 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 75102 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 74994 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 75844 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 76049 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 76423 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 76367 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 75426 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 76255 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 75937 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 75668 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 75287 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 75102 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 74994 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 75844 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 76049 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 75150 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 75150 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 75150 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 75498 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 85
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 88
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 85
7660: PUSH
7661: LD_EXP 85
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 85
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 66
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 75150 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 75150 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 75150 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 76568 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 85
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 88
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 85
8875: PUSH
8876: LD_EXP 85
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 85
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 66
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18426 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18426 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18426 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18426 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18426 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18426 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11258: LD_VAR 0 1
11262: PUSH
11263: LD_EXP 9
11267: EQUAL
11268: IFFALSE 11284
// begin wait ( 0 0$1 ) ;
11270: LD_INT 35
11272: PPUSH
11273: CALL_OW 67
// YouLost ( Brighton ) ;
11277: LD_STRING Brighton
11279: PPUSH
11280: CALL_OW 104
// end ; if un = JMM then
11284: LD_VAR 0 1
11288: PUSH
11289: LD_EXP 37
11293: EQUAL
11294: IFFALSE 11310
// begin wait ( 0 0$1 ) ;
11296: LD_INT 35
11298: PPUSH
11299: CALL_OW 67
// YouLost ( JMM ) ;
11303: LD_STRING JMM
11305: PPUSH
11306: CALL_OW 104
// end ; if un = Megan then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 11
11319: EQUAL
11320: IFFALSE 11334
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11322: LD_EXP 9
11326: PPUSH
11327: LD_STRING DBrighton-MeganDeath
11329: PPUSH
11330: CALL_OW 88
// end ; if un = Palmer then
11334: LD_VAR 0 1
11338: PUSH
11339: LD_EXP 10
11343: EQUAL
11344: IFFALSE 11358
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11346: LD_EXP 9
11350: PPUSH
11351: LD_STRING DBrighton-PalmerDeath
11353: PPUSH
11354: CALL_OW 88
// end ; if un = Burlak then
11358: LD_VAR 0 1
11362: PUSH
11363: LD_EXP 19
11367: EQUAL
11368: IFFALSE 11400
// begin if JMM_Arrived then
11370: LD_EXP 6
11374: IFFALSE 11388
// Say ( JMM , DJMM-BurlakDead ) ;
11376: LD_EXP 37
11380: PPUSH
11381: LD_STRING DJMM-BurlakDead
11383: PPUSH
11384: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11388: LD_EXP 10
11392: PPUSH
11393: LD_STRING DSol-BurlakDead
11395: PPUSH
11396: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11400: LD_VAR 0 1
11404: PUSH
11405: LD_INT 1
11407: EQUAL
11408: PUSH
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 3
11416: EQUAL
11417: OR
11418: IFFALSE 11434
// begin wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// YouLost ( Depot ) ;
11427: LD_STRING Depot
11429: PPUSH
11430: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11434: LD_VAR 0 1
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 1
11446: EQUAL
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 247
11457: PUSH
11458: LD_INT 1
11460: EQUAL
11461: AND
11462: IFFALSE 11478
// Losses := Losses + 1 ;
11464: LD_ADDR_EXP 45
11468: PUSH
11469: LD_EXP 45
11473: PUSH
11474: LD_INT 1
11476: PLUS
11477: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11478: LD_VAR 0 1
11482: PPUSH
11483: CALL 78561 0 1
// end ;
11487: PPOPN 1
11489: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 247
11499: PUSH
11500: LD_INT 2
11502: EQUAL
11503: PUSH
11504: LD_VAR 0 1
11508: PUSH
11509: LD_EXP 17
11513: IN
11514: AND
11515: IFFALSE 11529
// SetLives ( un , 0 ) ;
11517: LD_VAR 0 1
11521: PPUSH
11522: LD_INT 0
11524: PPUSH
11525: CALL_OW 234
// if un = Yashin then
11529: LD_VAR 0 1
11533: PUSH
11534: LD_EXP 13
11538: EQUAL
11539: IFFALSE 11553
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11541: LD_EXP 13
11545: PPUSH
11546: LD_STRING DDeath-Yas-3
11548: PPUSH
11549: CALL_OW 91
// if un = Popov then
11553: LD_VAR 0 1
11557: PUSH
11558: LD_EXP 14
11562: EQUAL
11563: IFFALSE 11577
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11565: LD_EXP 14
11569: PPUSH
11570: LD_STRING DDeath-Pop-3
11572: PPUSH
11573: CALL_OW 91
// if un = Gaydar then
11577: LD_VAR 0 1
11581: PUSH
11582: LD_EXP 15
11586: EQUAL
11587: IFFALSE 11601
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11589: LD_EXP 15
11593: PPUSH
11594: LD_STRING DDeath-Gay-3
11596: PPUSH
11597: CALL_OW 91
// if un = Sevi then
11601: LD_VAR 0 1
11605: PUSH
11606: LD_EXP 16
11610: EQUAL
11611: IFFALSE 11625
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11613: LD_EXP 16
11617: PPUSH
11618: LD_STRING DDeath-Vse-3
11620: PPUSH
11621: CALL_OW 91
// end ;
11625: PPOPN 1
11627: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11628: LD_VAR 0 1
11632: PUSH
11633: LD_INT 10
11635: EQUAL
11636: IFFALSE 11674
// begin Say ( Brighton , DBrighton-C1 ) ;
11638: LD_EXP 9
11642: PPUSH
11643: LD_STRING DBrighton-C1
11645: PPUSH
11646: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11650: LD_EXP 11
11654: PPUSH
11655: LD_STRING DMegan-C1
11657: PPUSH
11658: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11662: LD_EXP 9
11666: PPUSH
11667: LD_STRING DBrighton-C2
11669: PPUSH
11670: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_VAR 0 2
11683: PPUSH
11684: CALL 78257 0 2
// end ;
11688: PPOPN 2
11690: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL 80895 0 2
// end ;
11705: PPOPN 2
11707: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11708: LD_VAR 0 1
11712: PPUSH
11713: CALL 79963 0 1
// end ;
11717: PPOPN 1
11719: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11720: LD_VAR 0 1
11724: PPUSH
11725: CALL_OW 266
11729: PUSH
11730: LD_INT 0
11732: EQUAL
11733: PUSH
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 255
11743: PUSH
11744: LD_INT 3
11746: EQUAL
11747: AND
11748: IFFALSE 11810
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11750: LD_VAR 0 1
11754: PPUSH
11755: CALL_OW 274
11759: PPUSH
11760: LD_INT 1
11762: PPUSH
11763: LD_INT 10000
11765: PPUSH
11766: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11770: LD_VAR 0 1
11774: PPUSH
11775: CALL_OW 274
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 250
11785: PPUSH
11786: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 274
11799: PPUSH
11800: LD_INT 3
11802: PPUSH
11803: LD_INT 100
11805: PPUSH
11806: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11810: LD_VAR 0 1
11814: PPUSH
11815: CALL 80204 0 1
// end ;
11819: PPOPN 1
11821: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11822: LD_VAR 0 1
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: LD_VAR 0 3
11836: PPUSH
11837: LD_VAR 0 4
11841: PPUSH
11842: LD_VAR 0 5
11846: PPUSH
11847: CALL 77877 0 5
// end ;
11851: PPOPN 5
11853: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11854: LD_VAR 0 1
11858: PPUSH
11859: LD_VAR 0 2
11863: PPUSH
11864: CALL 77467 0 2
// end ;
11868: PPOPN 2
11870: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_VAR 0 2
11880: PPUSH
11881: LD_VAR 0 3
11885: PPUSH
11886: LD_VAR 0 4
11890: PPUSH
11891: CALL 77305 0 4
// end ;
11895: PPOPN 4
11897: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11898: LD_VAR 0 1
11902: PPUSH
11903: LD_VAR 0 2
11907: PPUSH
11908: LD_VAR 0 3
11912: PPUSH
11913: CALL 77080 0 3
// end ;
11917: PPOPN 3
11919: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11920: LD_VAR 0 1
11924: PPUSH
11925: LD_VAR 0 2
11929: PPUSH
11930: CALL 76965 0 2
// end ;
11934: PPOPN 2
11936: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11937: LD_VAR 0 1
11941: PPUSH
11942: LD_VAR 0 2
11946: PPUSH
11947: CALL 81156 0 2
// end ;
11951: PPOPN 2
11953: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11954: LD_VAR 0 1
11958: PPUSH
11959: CALL_OW 255
11963: PUSH
11964: LD_INT 6
11966: EQUAL
11967: IFFALSE 12097
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11969: LD_VAR 0 1
11973: PUSH
11974: LD_EXP 13
11978: PUSH
11979: LD_EXP 16
11983: PUSH
11984: LD_EXP 15
11988: PUSH
11989: LD_EXP 14
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: IN
12000: IFFALSE 12004
// exit ;
12002: GO 12121
// if AssaultStarted then
12004: LD_EXP 8
12008: IFFALSE 12082
// case Rand ( 1 , 4 ) of 1 .. 3 :
12010: LD_INT 1
12012: PPUSH
12013: LD_INT 4
12015: PPUSH
12016: CALL_OW 12
12020: PUSH
12021: LD_INT 1
12023: DOUBLE
12024: GREATEREQUAL
12025: IFFALSE 12033
12027: LD_INT 3
12029: DOUBLE
12030: LESSEQUAL
12031: IFTRUE 12035
12033: GO 12053
12035: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12036: LD_VAR 0 1
12040: PPUSH
12041: LD_INT 67
12043: PPUSH
12044: LD_INT 37
12046: PPUSH
12047: CALL_OW 114
12051: GO 12080
12053: LD_INT 4
12055: DOUBLE
12056: EQUAL
12057: IFTRUE 12061
12059: GO 12079
12061: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12062: LD_VAR 0 1
12066: PPUSH
12067: LD_INT 120
12069: PPUSH
12070: LD_INT 131
12072: PPUSH
12073: CALL_OW 111
12077: GO 12080
12079: POP
12080: GO 12097
// ComMoveXY ( driver , 120 , 131 ) ;
12082: LD_VAR 0 1
12086: PPUSH
12087: LD_INT 120
12089: PPUSH
12090: LD_INT 131
12092: PPUSH
12093: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12097: LD_VAR 0 1
12101: PPUSH
12102: LD_VAR 0 2
12106: PPUSH
12107: LD_VAR 0 3
12111: PPUSH
12112: LD_VAR 0 4
12116: PPUSH
12117: CALL 81372 0 4
// end ;
12121: PPOPN 4
12123: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: CALL 76774 0 2
// end ;
12138: PPOPN 2
12140: END
// on Command ( cmd ) do var i ;
12141: LD_INT 0
12143: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12144: LD_VAR 0 1
12148: PUSH
12149: LD_INT 77
12151: EQUAL
12152: PUSH
12153: LD_EXP 2
12157: AND
12158: IFFALSE 12234
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12160: LD_ADDR_VAR 0 2
12164: PUSH
12165: LD_INT 22
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: LD_INT 2
12177: PUSH
12178: LD_INT 21
12180: PUSH
12181: LD_INT 1
12183: PUSH
12184: EMPTY
12185: LIST
12186: LIST
12187: PUSH
12188: LD_INT 21
12190: PUSH
12191: LD_INT 2
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: LIST
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PPUSH
12207: CALL_OW 69
12211: PUSH
12212: FOR_IN
12213: IFFALSE 12232
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12215: LD_VAR 0 2
12219: PPUSH
12220: LD_INT 20
12222: PPUSH
12223: LD_INT 19
12225: PPUSH
12226: CALL 50578 0 3
12230: GO 12212
12232: POP
12233: POP
// end ; SOS_Command ( cmd ) ;
12234: LD_VAR 0 1
12238: PPUSH
12239: CALL 94786 0 1
// end ;
12243: PPOPN 2
12245: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12246: LD_EXP 2
12250: PUSH
12251: LD_INT 16
12253: PPUSH
12254: LD_INT 22
12256: PUSH
12257: LD_INT 1
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: PUSH
12264: LD_INT 2
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 1
12272: PUSH
12273: EMPTY
12274: LIST
12275: LIST
12276: PUSH
12277: LD_INT 21
12279: PUSH
12280: LD_INT 2
12282: PUSH
12283: EMPTY
12284: LIST
12285: LIST
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: LIST
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PPUSH
12296: CALL_OW 70
12300: AND
12301: IFFALSE 12387
12303: GO 12305
12305: DISABLE
12306: LD_INT 0
12308: PPUSH
// begin enable ;
12309: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12310: LD_ADDR_VAR 0 1
12314: PUSH
12315: LD_INT 16
12317: PPUSH
12318: LD_INT 22
12320: PUSH
12321: LD_INT 1
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 2
12330: PUSH
12331: LD_INT 21
12333: PUSH
12334: LD_INT 1
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: LD_INT 21
12343: PUSH
12344: LD_INT 2
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: LIST
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PPUSH
12360: CALL_OW 70
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12385
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_INT 18
12375: PPUSH
12376: LD_INT 19
12378: PPUSH
12379: CALL 50578 0 3
12383: GO 12365
12385: POP
12386: POP
// end ; end_of_file
12387: PPOPN 1
12389: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12390: LD_EXP 6
12394: PUSH
12395: LD_EXP 44
12399: AND
12400: IFFALSE 12571
12402: GO 12404
12404: DISABLE
// begin wait ( 0 0$2 ) ;
12405: LD_INT 70
12407: PPUSH
12408: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12412: LD_EXP 9
12416: PPUSH
12417: LD_STRING DBrighton-G1
12419: PPUSH
12420: CALL_OW 88
// if Losses < 1 then
12424: LD_EXP 45
12428: PUSH
12429: LD_INT 1
12431: LESS
12432: IFFALSE 12446
// AddMedal ( Losses , 1 ) else
12434: LD_STRING Losses
12436: PPUSH
12437: LD_INT 1
12439: PPUSH
12440: CALL_OW 101
12444: GO 12479
// if Losses < 5 then
12446: LD_EXP 45
12450: PUSH
12451: LD_INT 5
12453: LESS
12454: IFFALSE 12468
// AddMedal ( Losses , 2 ) else
12456: LD_STRING Losses
12458: PPUSH
12459: LD_INT 2
12461: PPUSH
12462: CALL_OW 101
12466: GO 12479
// AddMedal ( Losses , - 1 ) ;
12468: LD_STRING Losses
12470: PPUSH
12471: LD_INT 1
12473: NEG
12474: PPUSH
12475: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12479: LD_EXP 7
12483: PUSH
12484: LD_INT 10
12486: PPUSH
12487: LD_INT 1
12489: PPUSH
12490: CALL_OW 321
12494: PUSH
12495: LD_INT 2
12497: EQUAL
12498: AND
12499: IFFALSE 12513
// AddMedal ( Laser , 1 ) else
12501: LD_STRING Laser
12503: PPUSH
12504: LD_INT 1
12506: PPUSH
12507: CALL_OW 101
12511: GO 12560
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12513: LD_EXP 7
12517: NOT
12518: PUSH
12519: LD_INT 10
12521: PPUSH
12522: LD_INT 1
12524: PPUSH
12525: CALL_OW 321
12529: PUSH
12530: LD_INT 2
12532: EQUAL
12533: AND
12534: IFFALSE 12549
// AddMedal ( Laser , - 1 ) else
12536: LD_STRING Laser
12538: PPUSH
12539: LD_INT 1
12541: NEG
12542: PPUSH
12543: CALL_OW 101
12547: GO 12560
// AddMedal ( Laser , - 2 ) ;
12549: LD_STRING Laser
12551: PPUSH
12552: LD_INT 2
12554: NEG
12555: PPUSH
12556: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12560: LD_STRING BaseMain
12562: PPUSH
12563: CALL_OW 102
// YouWin ;
12567: CALL_OW 103
// end ; end_of_file
12571: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12572: LD_INT 0
12574: PPUSH
12575: PPUSH
// area = ListEnvironmentArea ( area ) ;
12576: LD_ADDR_VAR 0 2
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 353
12590: ST_TO_ADDR
// if bulldozer > 0 then
12591: LD_VAR 0 1
12595: PUSH
12596: LD_INT 0
12598: GREATER
12599: IFFALSE 12710
// for i = area downto 1 do
12601: LD_ADDR_VAR 0 4
12605: PUSH
12606: DOUBLE
12607: LD_VAR 0 2
12611: INC
12612: ST_TO_ADDR
12613: LD_INT 1
12615: PUSH
12616: FOR_DOWNTO
12617: IFFALSE 12708
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12619: LD_VAR 0 2
12623: PUSH
12624: LD_VAR 0 4
12628: ARRAY
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_VAR 0 2
12638: PUSH
12639: LD_VAR 0 4
12643: ARRAY
12644: PUSH
12645: LD_INT 2
12647: ARRAY
12648: PPUSH
12649: CALL_OW 351
12653: IFFALSE 12706
// if not HasTask ( bulldozer ) then
12655: LD_VAR 0 1
12659: PPUSH
12660: CALL_OW 314
12664: NOT
12665: IFFALSE 12706
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12667: LD_VAR 0 1
12671: PPUSH
12672: LD_VAR 0 2
12676: PUSH
12677: LD_VAR 0 4
12681: ARRAY
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_VAR 0 2
12691: PUSH
12692: LD_VAR 0 4
12696: ARRAY
12697: PUSH
12698: LD_INT 2
12700: ARRAY
12701: PPUSH
12702: CALL_OW 171
12706: GO 12616
12708: POP
12709: POP
// end ;
12710: LD_VAR 0 3
12714: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12715: LD_INT 0
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12724: LD_ADDR_VAR 0 8
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: LD_INT 22
12736: PUSH
12737: LD_INT 1
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 72
12773: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12774: LD_ADDR_VAR 0 9
12778: PUSH
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 1
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 21
12796: PUSH
12797: LD_INT 1
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 3
12806: PUSH
12807: LD_INT 25
12809: PUSH
12810: LD_INT 1
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: PPUSH
12826: CALL_OW 72
12830: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12831: LD_ADDR_EXP 47
12835: PUSH
12836: LD_VAR 0 8
12840: PPUSH
12841: LD_VAR 0 9
12845: PPUSH
12846: CALL 13239 0 2
12850: ST_TO_ADDR
// offset = 0 ;
12851: LD_ADDR_VAR 0 7
12855: PUSH
12856: LD_INT 0
12858: ST_TO_ADDR
// for i := 1 to sold_team do
12859: LD_ADDR_VAR 0 4
12863: PUSH
12864: DOUBLE
12865: LD_INT 1
12867: DEC
12868: ST_TO_ADDR
12869: LD_VAR 0 8
12873: PUSH
12874: FOR_TO
12875: IFFALSE 13006
// begin if IsInUnit ( sold_team [ i ] ) then
12877: LD_VAR 0 8
12881: PUSH
12882: LD_VAR 0 4
12886: ARRAY
12887: PPUSH
12888: CALL_OW 310
12892: IFFALSE 12909
// ComExitBuilding ( sold_team [ i ] ) ;
12894: LD_VAR 0 8
12898: PUSH
12899: LD_VAR 0 4
12903: ARRAY
12904: PPUSH
12905: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12909: LD_VAR 0 8
12913: PUSH
12914: LD_VAR 0 4
12918: ARRAY
12919: PPUSH
12920: LD_EXP 47
12924: PUSH
12925: LD_INT 1
12927: ARRAY
12928: PUSH
12929: LD_VAR 0 4
12933: PUSH
12934: LD_VAR 0 7
12938: PLUS
12939: ARRAY
12940: PPUSH
12941: LD_EXP 47
12945: PUSH
12946: LD_INT 1
12948: ARRAY
12949: PUSH
12950: LD_VAR 0 4
12954: PUSH
12955: LD_INT 1
12957: PLUS
12958: PUSH
12959: LD_VAR 0 7
12963: PLUS
12964: ARRAY
12965: PPUSH
12966: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12970: LD_VAR 0 8
12974: PUSH
12975: LD_VAR 0 4
12979: ARRAY
12980: PPUSH
12981: LD_EXP 9
12985: PPUSH
12986: CALL_OW 179
// offset = offset + 1 ;
12990: LD_ADDR_VAR 0 7
12994: PUSH
12995: LD_VAR 0 7
12999: PUSH
13000: LD_INT 1
13002: PLUS
13003: ST_TO_ADDR
// end ;
13004: GO 12874
13006: POP
13007: POP
// offset = 0 ;
13008: LD_ADDR_VAR 0 7
13012: PUSH
13013: LD_INT 0
13015: ST_TO_ADDR
// tmp = 1 ;
13016: LD_ADDR_VAR 0 6
13020: PUSH
13021: LD_INT 1
13023: ST_TO_ADDR
// for i := 2 to rows do
13024: LD_ADDR_VAR 0 4
13028: PUSH
13029: DOUBLE
13030: LD_INT 2
13032: DEC
13033: ST_TO_ADDR
13034: LD_EXP 47
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13232
// begin for x := 1 to sold_team do
13042: LD_ADDR_VAR 0 5
13046: PUSH
13047: DOUBLE
13048: LD_INT 1
13050: DEC
13051: ST_TO_ADDR
13052: LD_VAR 0 8
13056: PUSH
13057: FOR_TO
13058: IFFALSE 13220
// begin if IsInUnit ( civil_team [ tmp ] ) then
13060: LD_VAR 0 9
13064: PUSH
13065: LD_VAR 0 6
13069: ARRAY
13070: PPUSH
13071: CALL_OW 310
13075: IFFALSE 13092
// ComExitBuilding ( civil_team [ tmp ] ) ;
13077: LD_VAR 0 9
13081: PUSH
13082: LD_VAR 0 6
13086: ARRAY
13087: PPUSH
13088: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13092: LD_VAR 0 9
13096: PUSH
13097: LD_VAR 0 6
13101: ARRAY
13102: PPUSH
13103: LD_EXP 47
13107: PUSH
13108: LD_VAR 0 4
13112: ARRAY
13113: PUSH
13114: LD_VAR 0 5
13118: PUSH
13119: LD_VAR 0 7
13123: PLUS
13124: ARRAY
13125: PPUSH
13126: LD_EXP 47
13130: PUSH
13131: LD_VAR 0 4
13135: ARRAY
13136: PUSH
13137: LD_VAR 0 5
13141: PUSH
13142: LD_INT 1
13144: PLUS
13145: PUSH
13146: LD_VAR 0 7
13150: PLUS
13151: ARRAY
13152: PPUSH
13153: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13157: LD_VAR 0 9
13161: PUSH
13162: LD_VAR 0 6
13166: ARRAY
13167: PPUSH
13168: LD_EXP 9
13172: PPUSH
13173: CALL_OW 179
// offset = offset + 1 ;
13177: LD_ADDR_VAR 0 7
13181: PUSH
13182: LD_VAR 0 7
13186: PUSH
13187: LD_INT 1
13189: PLUS
13190: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13191: LD_VAR 0 6
13195: PUSH
13196: LD_VAR 0 9
13200: EQUAL
13201: NOT
13202: IFFALSE 13218
// tmp = tmp + 1 ;
13204: LD_ADDR_VAR 0 6
13208: PUSH
13209: LD_VAR 0 6
13213: PUSH
13214: LD_INT 1
13216: PLUS
13217: ST_TO_ADDR
// end ;
13218: GO 13057
13220: POP
13221: POP
// offset = 0 ;
13222: LD_ADDR_VAR 0 7
13226: PUSH
13227: LD_INT 0
13229: ST_TO_ADDR
// end ;
13230: GO 13039
13232: POP
13233: POP
// end ;
13234: LD_VAR 0 3
13238: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13239: LD_INT 0
13241: PPUSH
13242: PPUSH
13243: PPUSH
13244: PPUSH
13245: PPUSH
13246: PPUSH
13247: PPUSH
13248: PPUSH
13249: PPUSH
13250: PPUSH
// start_pos = [ 65 , 34 ] ;
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: LD_INT 65
13258: PUSH
13259: LD_INT 34
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: ST_TO_ADDR
// row_size = 0 ;
13266: LD_ADDR_VAR 0 7
13270: PUSH
13271: LD_INT 0
13273: ST_TO_ADDR
// result_rows = [ ] ;
13274: LD_ADDR_VAR 0 9
13278: PUSH
13279: EMPTY
13280: ST_TO_ADDR
// new_row = [ ] ;
13281: LD_ADDR_VAR 0 8
13285: PUSH
13286: EMPTY
13287: ST_TO_ADDR
// for i := 1 to sold_team do
13288: LD_ADDR_VAR 0 4
13292: PUSH
13293: DOUBLE
13294: LD_INT 1
13296: DEC
13297: ST_TO_ADDR
13298: LD_VAR 0 1
13302: PUSH
13303: FOR_TO
13304: IFFALSE 13358
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13306: LD_ADDR_VAR 0 8
13310: PUSH
13311: LD_VAR 0 8
13315: PUSH
13316: LD_VAR 0 6
13320: PUSH
13321: LD_INT 1
13323: ARRAY
13324: ADD
13325: PUSH
13326: LD_VAR 0 6
13330: PUSH
13331: LD_INT 2
13333: ARRAY
13334: PUSH
13335: LD_VAR 0 4
13339: PLUS
13340: ADD
13341: ST_TO_ADDR
// row_size = row_size + 1 ;
13342: LD_ADDR_VAR 0 7
13346: PUSH
13347: LD_VAR 0 7
13351: PUSH
13352: LD_INT 1
13354: PLUS
13355: ST_TO_ADDR
// end ;
13356: GO 13303
13358: POP
13359: POP
// result_rows = result_rows ^ [ new_row ] ;
13360: LD_ADDR_VAR 0 9
13364: PUSH
13365: LD_VAR 0 9
13369: PUSH
13370: LD_VAR 0 8
13374: PUSH
13375: EMPTY
13376: LIST
13377: ADD
13378: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13379: LD_ADDR_VAR 0 10
13383: PUSH
13384: LD_VAR 0 2
13388: PUSH
13389: LD_VAR 0 1
13393: DIV
13394: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13395: LD_VAR 0 10
13399: PUSH
13400: LD_VAR 0 1
13404: MOD
13405: PUSH
13406: LD_INT 0
13408: GREATER
13409: IFFALSE 13425
// civil_rows = civil_rows + 1 ;
13411: LD_ADDR_VAR 0 10
13415: PUSH
13416: LD_VAR 0 10
13420: PUSH
13421: LD_INT 1
13423: PLUS
13424: ST_TO_ADDR
// offsetX = 2 ;
13425: LD_ADDR_VAR 0 11
13429: PUSH
13430: LD_INT 2
13432: ST_TO_ADDR
// offsetY = 1 ;
13433: LD_ADDR_VAR 0 12
13437: PUSH
13438: LD_INT 1
13440: ST_TO_ADDR
// for i := 1 to civil_rows do
13441: LD_ADDR_VAR 0 4
13445: PUSH
13446: DOUBLE
13447: LD_INT 1
13449: DEC
13450: ST_TO_ADDR
13451: LD_VAR 0 10
13455: PUSH
13456: FOR_TO
13457: IFFALSE 13585
// begin new_row = [ ] ;
13459: LD_ADDR_VAR 0 8
13463: PUSH
13464: EMPTY
13465: ST_TO_ADDR
// for x := 1 to row_size do
13466: LD_ADDR_VAR 0 5
13470: PUSH
13471: DOUBLE
13472: LD_INT 1
13474: DEC
13475: ST_TO_ADDR
13476: LD_VAR 0 7
13480: PUSH
13481: FOR_TO
13482: IFFALSE 13534
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13484: LD_ADDR_VAR 0 8
13488: PUSH
13489: LD_VAR 0 8
13493: PUSH
13494: LD_VAR 0 6
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_VAR 0 11
13507: PLUS
13508: ADD
13509: PUSH
13510: LD_VAR 0 6
13514: PUSH
13515: LD_INT 2
13517: ARRAY
13518: PUSH
13519: LD_VAR 0 12
13523: PLUS
13524: PUSH
13525: LD_VAR 0 5
13529: PLUS
13530: ADD
13531: ST_TO_ADDR
// end ;
13532: GO 13481
13534: POP
13535: POP
// result_rows = result_rows ^ [ new_row ] ;
13536: LD_ADDR_VAR 0 9
13540: PUSH
13541: LD_VAR 0 9
13545: PUSH
13546: LD_VAR 0 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: ADD
13554: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13555: LD_ADDR_VAR 0 11
13559: PUSH
13560: LD_VAR 0 11
13564: PUSH
13565: LD_INT 2
13567: PLUS
13568: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13569: LD_ADDR_VAR 0 12
13573: PUSH
13574: LD_VAR 0 12
13578: PUSH
13579: LD_INT 1
13581: PLUS
13582: ST_TO_ADDR
// end ;
13583: GO 13456
13585: POP
13586: POP
// result = result_rows ;
13587: LD_ADDR_VAR 0 3
13591: PUSH
13592: LD_VAR 0 9
13596: ST_TO_ADDR
// end ; end_of_file
13597: LD_VAR 0 3
13601: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13602: LD_INT 0
13604: PPUSH
13605: PPUSH
// if exist_mode then
13606: LD_VAR 0 2
13610: IFFALSE 13635
// unit := CreateCharacter ( prefix & ident ) else
13612: LD_ADDR_VAR 0 5
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 1
13626: STR
13627: PPUSH
13628: CALL_OW 34
13632: ST_TO_ADDR
13633: GO 13650
// unit := NewCharacter ( ident ) ;
13635: LD_ADDR_VAR 0 5
13639: PUSH
13640: LD_VAR 0 1
13644: PPUSH
13645: CALL_OW 25
13649: ST_TO_ADDR
// result := unit ;
13650: LD_ADDR_VAR 0 4
13654: PUSH
13655: LD_VAR 0 5
13659: ST_TO_ADDR
// end ;
13660: LD_VAR 0 4
13664: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13665: LD_INT 0
13667: PPUSH
13668: PPUSH
// if not side or not nation then
13669: LD_VAR 0 1
13673: NOT
13674: PUSH
13675: LD_VAR 0 2
13679: NOT
13680: OR
13681: IFFALSE 13685
// exit ;
13683: GO 14449
// case nation of nation_american :
13685: LD_VAR 0 2
13689: PUSH
13690: LD_INT 1
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13912
13698: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13699: LD_ADDR_VAR 0 4
13703: PUSH
13704: LD_INT 35
13706: PUSH
13707: LD_INT 45
13709: PUSH
13710: LD_INT 46
13712: PUSH
13713: LD_INT 47
13715: PUSH
13716: LD_INT 82
13718: PUSH
13719: LD_INT 83
13721: PUSH
13722: LD_INT 84
13724: PUSH
13725: LD_INT 85
13727: PUSH
13728: LD_INT 86
13730: PUSH
13731: LD_INT 1
13733: PUSH
13734: LD_INT 2
13736: PUSH
13737: LD_INT 6
13739: PUSH
13740: LD_INT 15
13742: PUSH
13743: LD_INT 16
13745: PUSH
13746: LD_INT 7
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: LD_INT 13
13754: PUSH
13755: LD_INT 10
13757: PUSH
13758: LD_INT 14
13760: PUSH
13761: LD_INT 20
13763: PUSH
13764: LD_INT 21
13766: PUSH
13767: LD_INT 22
13769: PUSH
13770: LD_INT 25
13772: PUSH
13773: LD_INT 32
13775: PUSH
13776: LD_INT 27
13778: PUSH
13779: LD_INT 36
13781: PUSH
13782: LD_INT 69
13784: PUSH
13785: LD_INT 39
13787: PUSH
13788: LD_INT 34
13790: PUSH
13791: LD_INT 40
13793: PUSH
13794: LD_INT 48
13796: PUSH
13797: LD_INT 49
13799: PUSH
13800: LD_INT 50
13802: PUSH
13803: LD_INT 51
13805: PUSH
13806: LD_INT 52
13808: PUSH
13809: LD_INT 53
13811: PUSH
13812: LD_INT 54
13814: PUSH
13815: LD_INT 55
13817: PUSH
13818: LD_INT 56
13820: PUSH
13821: LD_INT 57
13823: PUSH
13824: LD_INT 58
13826: PUSH
13827: LD_INT 59
13829: PUSH
13830: LD_INT 60
13832: PUSH
13833: LD_INT 61
13835: PUSH
13836: LD_INT 62
13838: PUSH
13839: LD_INT 80
13841: PUSH
13842: LD_INT 82
13844: PUSH
13845: LD_INT 83
13847: PUSH
13848: LD_INT 84
13850: PUSH
13851: LD_INT 85
13853: PUSH
13854: LD_INT 86
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: ST_TO_ADDR
13910: GO 14373
13912: LD_INT 2
13914: DOUBLE
13915: EQUAL
13916: IFTRUE 13920
13918: GO 14142
13920: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13921: LD_ADDR_VAR 0 4
13925: PUSH
13926: LD_INT 35
13928: PUSH
13929: LD_INT 45
13931: PUSH
13932: LD_INT 46
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: LD_INT 82
13940: PUSH
13941: LD_INT 83
13943: PUSH
13944: LD_INT 84
13946: PUSH
13947: LD_INT 85
13949: PUSH
13950: LD_INT 87
13952: PUSH
13953: LD_INT 70
13955: PUSH
13956: LD_INT 1
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 4
13967: PUSH
13968: LD_INT 5
13970: PUSH
13971: LD_INT 6
13973: PUSH
13974: LD_INT 15
13976: PUSH
13977: LD_INT 18
13979: PUSH
13980: LD_INT 7
13982: PUSH
13983: LD_INT 17
13985: PUSH
13986: LD_INT 8
13988: PUSH
13989: LD_INT 20
13991: PUSH
13992: LD_INT 21
13994: PUSH
13995: LD_INT 22
13997: PUSH
13998: LD_INT 72
14000: PUSH
14001: LD_INT 26
14003: PUSH
14004: LD_INT 69
14006: PUSH
14007: LD_INT 39
14009: PUSH
14010: LD_INT 40
14012: PUSH
14013: LD_INT 41
14015: PUSH
14016: LD_INT 42
14018: PUSH
14019: LD_INT 43
14021: PUSH
14022: LD_INT 48
14024: PUSH
14025: LD_INT 49
14027: PUSH
14028: LD_INT 50
14030: PUSH
14031: LD_INT 51
14033: PUSH
14034: LD_INT 52
14036: PUSH
14037: LD_INT 53
14039: PUSH
14040: LD_INT 54
14042: PUSH
14043: LD_INT 55
14045: PUSH
14046: LD_INT 56
14048: PUSH
14049: LD_INT 60
14051: PUSH
14052: LD_INT 61
14054: PUSH
14055: LD_INT 62
14057: PUSH
14058: LD_INT 66
14060: PUSH
14061: LD_INT 67
14063: PUSH
14064: LD_INT 68
14066: PUSH
14067: LD_INT 81
14069: PUSH
14070: LD_INT 82
14072: PUSH
14073: LD_INT 83
14075: PUSH
14076: LD_INT 84
14078: PUSH
14079: LD_INT 85
14081: PUSH
14082: LD_INT 87
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: ST_TO_ADDR
14140: GO 14373
14142: LD_INT 3
14144: DOUBLE
14145: EQUAL
14146: IFTRUE 14150
14148: GO 14372
14150: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14151: LD_ADDR_VAR 0 4
14155: PUSH
14156: LD_INT 46
14158: PUSH
14159: LD_INT 47
14161: PUSH
14162: LD_INT 1
14164: PUSH
14165: LD_INT 2
14167: PUSH
14168: LD_INT 82
14170: PUSH
14171: LD_INT 83
14173: PUSH
14174: LD_INT 84
14176: PUSH
14177: LD_INT 85
14179: PUSH
14180: LD_INT 86
14182: PUSH
14183: LD_INT 11
14185: PUSH
14186: LD_INT 9
14188: PUSH
14189: LD_INT 20
14191: PUSH
14192: LD_INT 19
14194: PUSH
14195: LD_INT 21
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: LD_INT 22
14203: PUSH
14204: LD_INT 25
14206: PUSH
14207: LD_INT 28
14209: PUSH
14210: LD_INT 29
14212: PUSH
14213: LD_INT 30
14215: PUSH
14216: LD_INT 31
14218: PUSH
14219: LD_INT 37
14221: PUSH
14222: LD_INT 38
14224: PUSH
14225: LD_INT 32
14227: PUSH
14228: LD_INT 27
14230: PUSH
14231: LD_INT 33
14233: PUSH
14234: LD_INT 69
14236: PUSH
14237: LD_INT 39
14239: PUSH
14240: LD_INT 34
14242: PUSH
14243: LD_INT 40
14245: PUSH
14246: LD_INT 71
14248: PUSH
14249: LD_INT 23
14251: PUSH
14252: LD_INT 44
14254: PUSH
14255: LD_INT 48
14257: PUSH
14258: LD_INT 49
14260: PUSH
14261: LD_INT 50
14263: PUSH
14264: LD_INT 51
14266: PUSH
14267: LD_INT 52
14269: PUSH
14270: LD_INT 53
14272: PUSH
14273: LD_INT 54
14275: PUSH
14276: LD_INT 55
14278: PUSH
14279: LD_INT 56
14281: PUSH
14282: LD_INT 57
14284: PUSH
14285: LD_INT 58
14287: PUSH
14288: LD_INT 59
14290: PUSH
14291: LD_INT 63
14293: PUSH
14294: LD_INT 64
14296: PUSH
14297: LD_INT 65
14299: PUSH
14300: LD_INT 82
14302: PUSH
14303: LD_INT 83
14305: PUSH
14306: LD_INT 84
14308: PUSH
14309: LD_INT 85
14311: PUSH
14312: LD_INT 86
14314: PUSH
14315: EMPTY
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: ST_TO_ADDR
14370: GO 14373
14372: POP
// if state > - 1 and state < 3 then
14373: LD_VAR 0 3
14377: PUSH
14378: LD_INT 1
14380: NEG
14381: GREATER
14382: PUSH
14383: LD_VAR 0 3
14387: PUSH
14388: LD_INT 3
14390: LESS
14391: AND
14392: IFFALSE 14449
// for i in result do
14394: LD_ADDR_VAR 0 5
14398: PUSH
14399: LD_VAR 0 4
14403: PUSH
14404: FOR_IN
14405: IFFALSE 14447
// if GetTech ( i , side ) <> state then
14407: LD_VAR 0 5
14411: PPUSH
14412: LD_VAR 0 1
14416: PPUSH
14417: CALL_OW 321
14421: PUSH
14422: LD_VAR 0 3
14426: NONEQUAL
14427: IFFALSE 14445
// result := result diff i ;
14429: LD_ADDR_VAR 0 4
14433: PUSH
14434: LD_VAR 0 4
14438: PUSH
14439: LD_VAR 0 5
14443: DIFF
14444: ST_TO_ADDR
14445: GO 14404
14447: POP
14448: POP
// end ;
14449: LD_VAR 0 4
14453: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14454: LD_INT 0
14456: PPUSH
14457: PPUSH
14458: PPUSH
// result := true ;
14459: LD_ADDR_VAR 0 3
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14467: LD_ADDR_VAR 0 5
14471: PUSH
14472: LD_VAR 0 2
14476: PPUSH
14477: CALL_OW 480
14481: ST_TO_ADDR
// if not tmp then
14482: LD_VAR 0 5
14486: NOT
14487: IFFALSE 14491
// exit ;
14489: GO 14540
// for i in tmp do
14491: LD_ADDR_VAR 0 4
14495: PUSH
14496: LD_VAR 0 5
14500: PUSH
14501: FOR_IN
14502: IFFALSE 14538
// if GetTech ( i , side ) <> state_researched then
14504: LD_VAR 0 4
14508: PPUSH
14509: LD_VAR 0 1
14513: PPUSH
14514: CALL_OW 321
14518: PUSH
14519: LD_INT 2
14521: NONEQUAL
14522: IFFALSE 14536
// begin result := false ;
14524: LD_ADDR_VAR 0 3
14528: PUSH
14529: LD_INT 0
14531: ST_TO_ADDR
// exit ;
14532: POP
14533: POP
14534: GO 14540
// end ;
14536: GO 14501
14538: POP
14539: POP
// end ;
14540: LD_VAR 0 3
14544: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14545: LD_INT 0
14547: PPUSH
14548: PPUSH
14549: PPUSH
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
14555: PPUSH
14556: PPUSH
14557: PPUSH
14558: PPUSH
14559: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14560: LD_VAR 0 1
14564: NOT
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: CALL_OW 257
14575: PUSH
14576: LD_INT 9
14578: NONEQUAL
14579: OR
14580: IFFALSE 14584
// exit ;
14582: GO 15157
// side := GetSide ( unit ) ;
14584: LD_ADDR_VAR 0 9
14588: PUSH
14589: LD_VAR 0 1
14593: PPUSH
14594: CALL_OW 255
14598: ST_TO_ADDR
// tech_space := tech_spacanom ;
14599: LD_ADDR_VAR 0 12
14603: PUSH
14604: LD_INT 29
14606: ST_TO_ADDR
// tech_time := tech_taurad ;
14607: LD_ADDR_VAR 0 13
14611: PUSH
14612: LD_INT 28
14614: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14615: LD_ADDR_VAR 0 11
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: CALL_OW 310
14629: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14630: LD_VAR 0 11
14634: PPUSH
14635: CALL_OW 247
14639: PUSH
14640: LD_INT 2
14642: EQUAL
14643: IFFALSE 14647
// exit ;
14645: GO 15157
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14647: LD_ADDR_VAR 0 8
14651: PUSH
14652: LD_INT 81
14654: PUSH
14655: LD_VAR 0 9
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: PUSH
14664: LD_INT 3
14666: PUSH
14667: LD_INT 21
14669: PUSH
14670: LD_INT 3
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: ST_TO_ADDR
// if not tmp then
14690: LD_VAR 0 8
14694: NOT
14695: IFFALSE 14699
// exit ;
14697: GO 15157
// if in_unit then
14699: LD_VAR 0 11
14703: IFFALSE 14727
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14705: LD_ADDR_VAR 0 10
14709: PUSH
14710: LD_VAR 0 8
14714: PPUSH
14715: LD_VAR 0 11
14719: PPUSH
14720: CALL_OW 74
14724: ST_TO_ADDR
14725: GO 14747
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14727: LD_ADDR_VAR 0 10
14731: PUSH
14732: LD_VAR 0 8
14736: PPUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: CALL_OW 74
14746: ST_TO_ADDR
// if not enemy then
14747: LD_VAR 0 10
14751: NOT
14752: IFFALSE 14756
// exit ;
14754: GO 15157
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14756: LD_VAR 0 11
14760: PUSH
14761: LD_VAR 0 11
14765: PPUSH
14766: LD_VAR 0 10
14770: PPUSH
14771: CALL_OW 296
14775: PUSH
14776: LD_INT 13
14778: GREATER
14779: AND
14780: PUSH
14781: LD_VAR 0 1
14785: PPUSH
14786: LD_VAR 0 10
14790: PPUSH
14791: CALL_OW 296
14795: PUSH
14796: LD_INT 12
14798: GREATER
14799: OR
14800: IFFALSE 14804
// exit ;
14802: GO 15157
// missile := [ 1 ] ;
14804: LD_ADDR_VAR 0 14
14808: PUSH
14809: LD_INT 1
14811: PUSH
14812: EMPTY
14813: LIST
14814: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14815: LD_VAR 0 9
14819: PPUSH
14820: LD_VAR 0 12
14824: PPUSH
14825: CALL_OW 325
14829: IFFALSE 14858
// missile := Insert ( missile , missile + 1 , 2 ) ;
14831: LD_ADDR_VAR 0 14
14835: PUSH
14836: LD_VAR 0 14
14840: PPUSH
14841: LD_VAR 0 14
14845: PUSH
14846: LD_INT 1
14848: PLUS
14849: PPUSH
14850: LD_INT 2
14852: PPUSH
14853: CALL_OW 2
14857: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14858: LD_VAR 0 9
14862: PPUSH
14863: LD_VAR 0 13
14867: PPUSH
14868: CALL_OW 325
14872: PUSH
14873: LD_VAR 0 10
14877: PPUSH
14878: CALL_OW 255
14882: PPUSH
14883: LD_VAR 0 13
14887: PPUSH
14888: CALL_OW 325
14892: NOT
14893: AND
14894: IFFALSE 14923
// missile := Insert ( missile , missile + 1 , 3 ) ;
14896: LD_ADDR_VAR 0 14
14900: PUSH
14901: LD_VAR 0 14
14905: PPUSH
14906: LD_VAR 0 14
14910: PUSH
14911: LD_INT 1
14913: PLUS
14914: PPUSH
14915: LD_INT 3
14917: PPUSH
14918: CALL_OW 2
14922: ST_TO_ADDR
// if missile < 2 then
14923: LD_VAR 0 14
14927: PUSH
14928: LD_INT 2
14930: LESS
14931: IFFALSE 14935
// exit ;
14933: GO 15157
// x := GetX ( enemy ) ;
14935: LD_ADDR_VAR 0 4
14939: PUSH
14940: LD_VAR 0 10
14944: PPUSH
14945: CALL_OW 250
14949: ST_TO_ADDR
// y := GetY ( enemy ) ;
14950: LD_ADDR_VAR 0 5
14954: PUSH
14955: LD_VAR 0 10
14959: PPUSH
14960: CALL_OW 251
14964: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14965: LD_ADDR_VAR 0 6
14969: PUSH
14970: LD_VAR 0 4
14974: PUSH
14975: LD_INT 1
14977: NEG
14978: PPUSH
14979: LD_INT 1
14981: PPUSH
14982: CALL_OW 12
14986: PLUS
14987: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14988: LD_ADDR_VAR 0 7
14992: PUSH
14993: LD_VAR 0 5
14997: PUSH
14998: LD_INT 1
15000: NEG
15001: PPUSH
15002: LD_INT 1
15004: PPUSH
15005: CALL_OW 12
15009: PLUS
15010: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15011: LD_VAR 0 6
15015: PPUSH
15016: LD_VAR 0 7
15020: PPUSH
15021: CALL_OW 488
15025: NOT
15026: IFFALSE 15048
// begin _x := x ;
15028: LD_ADDR_VAR 0 6
15032: PUSH
15033: LD_VAR 0 4
15037: ST_TO_ADDR
// _y := y ;
15038: LD_ADDR_VAR 0 7
15042: PUSH
15043: LD_VAR 0 5
15047: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15048: LD_ADDR_VAR 0 3
15052: PUSH
15053: LD_INT 1
15055: PPUSH
15056: LD_VAR 0 14
15060: PPUSH
15061: CALL_OW 12
15065: ST_TO_ADDR
// case i of 1 :
15066: LD_VAR 0 3
15070: PUSH
15071: LD_INT 1
15073: DOUBLE
15074: EQUAL
15075: IFTRUE 15079
15077: GO 15096
15079: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15080: LD_VAR 0 1
15084: PPUSH
15085: LD_VAR 0 10
15089: PPUSH
15090: CALL_OW 115
15094: GO 15157
15096: LD_INT 2
15098: DOUBLE
15099: EQUAL
15100: IFTRUE 15104
15102: GO 15126
15104: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15105: LD_VAR 0 1
15109: PPUSH
15110: LD_VAR 0 6
15114: PPUSH
15115: LD_VAR 0 7
15119: PPUSH
15120: CALL_OW 153
15124: GO 15157
15126: LD_INT 3
15128: DOUBLE
15129: EQUAL
15130: IFTRUE 15134
15132: GO 15156
15134: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15135: LD_VAR 0 1
15139: PPUSH
15140: LD_VAR 0 6
15144: PPUSH
15145: LD_VAR 0 7
15149: PPUSH
15150: CALL_OW 154
15154: GO 15157
15156: POP
// end ;
15157: LD_VAR 0 2
15161: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15162: LD_INT 0
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
15168: PPUSH
15169: PPUSH
// if not unit or not building then
15170: LD_VAR 0 1
15174: NOT
15175: PUSH
15176: LD_VAR 0 2
15180: NOT
15181: OR
15182: IFFALSE 15186
// exit ;
15184: GO 15344
// x := GetX ( building ) ;
15186: LD_ADDR_VAR 0 5
15190: PUSH
15191: LD_VAR 0 2
15195: PPUSH
15196: CALL_OW 250
15200: ST_TO_ADDR
// y := GetY ( building ) ;
15201: LD_ADDR_VAR 0 6
15205: PUSH
15206: LD_VAR 0 2
15210: PPUSH
15211: CALL_OW 251
15215: ST_TO_ADDR
// for i = 0 to 5 do
15216: LD_ADDR_VAR 0 4
15220: PUSH
15221: DOUBLE
15222: LD_INT 0
15224: DEC
15225: ST_TO_ADDR
15226: LD_INT 5
15228: PUSH
15229: FOR_TO
15230: IFFALSE 15342
// begin _x := ShiftX ( x , i , 3 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PPUSH
15242: LD_VAR 0 4
15246: PPUSH
15247: LD_INT 3
15249: PPUSH
15250: CALL_OW 272
15254: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15255: LD_ADDR_VAR 0 8
15259: PUSH
15260: LD_VAR 0 6
15264: PPUSH
15265: LD_VAR 0 4
15269: PPUSH
15270: LD_INT 3
15272: PPUSH
15273: CALL_OW 273
15277: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15278: LD_VAR 0 7
15282: PPUSH
15283: LD_VAR 0 8
15287: PPUSH
15288: CALL_OW 488
15292: NOT
15293: IFFALSE 15297
// continue ;
15295: GO 15229
// if HexInfo ( _x , _y ) = 0 then
15297: LD_VAR 0 7
15301: PPUSH
15302: LD_VAR 0 8
15306: PPUSH
15307: CALL_OW 428
15311: PUSH
15312: LD_INT 0
15314: EQUAL
15315: IFFALSE 15340
// begin ComMoveXY ( unit , _x , _y ) ;
15317: LD_VAR 0 1
15321: PPUSH
15322: LD_VAR 0 7
15326: PPUSH
15327: LD_VAR 0 8
15331: PPUSH
15332: CALL_OW 111
// exit ;
15336: POP
15337: POP
15338: GO 15344
// end ; end ;
15340: GO 15229
15342: POP
15343: POP
// end ;
15344: LD_VAR 0 3
15348: RET
// export function ScanBase ( side , base_area ) ; begin
15349: LD_INT 0
15351: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15352: LD_ADDR_VAR 0 3
15356: PUSH
15357: LD_VAR 0 2
15361: PPUSH
15362: LD_INT 81
15364: PUSH
15365: LD_VAR 0 1
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PPUSH
15374: CALL_OW 70
15378: ST_TO_ADDR
// end ;
15379: LD_VAR 0 3
15383: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15384: LD_INT 0
15386: PPUSH
15387: PPUSH
15388: PPUSH
15389: PPUSH
// result := false ;
15390: LD_ADDR_VAR 0 2
15394: PUSH
15395: LD_INT 0
15397: ST_TO_ADDR
// side := GetSide ( unit ) ;
15398: LD_ADDR_VAR 0 3
15402: PUSH
15403: LD_VAR 0 1
15407: PPUSH
15408: CALL_OW 255
15412: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15413: LD_ADDR_VAR 0 4
15417: PUSH
15418: LD_VAR 0 1
15422: PPUSH
15423: CALL_OW 248
15427: ST_TO_ADDR
// case nat of 1 :
15428: LD_VAR 0 4
15432: PUSH
15433: LD_INT 1
15435: DOUBLE
15436: EQUAL
15437: IFTRUE 15441
15439: GO 15452
15441: POP
// tech := tech_lassight ; 2 :
15442: LD_ADDR_VAR 0 5
15446: PUSH
15447: LD_INT 12
15449: ST_TO_ADDR
15450: GO 15491
15452: LD_INT 2
15454: DOUBLE
15455: EQUAL
15456: IFTRUE 15460
15458: GO 15471
15460: POP
// tech := tech_mortar ; 3 :
15461: LD_ADDR_VAR 0 5
15465: PUSH
15466: LD_INT 41
15468: ST_TO_ADDR
15469: GO 15491
15471: LD_INT 3
15473: DOUBLE
15474: EQUAL
15475: IFTRUE 15479
15477: GO 15490
15479: POP
// tech := tech_bazooka ; end ;
15480: LD_ADDR_VAR 0 5
15484: PUSH
15485: LD_INT 44
15487: ST_TO_ADDR
15488: GO 15491
15490: POP
// if Researched ( side , tech ) then
15491: LD_VAR 0 3
15495: PPUSH
15496: LD_VAR 0 5
15500: PPUSH
15501: CALL_OW 325
15505: IFFALSE 15532
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15507: LD_ADDR_VAR 0 2
15511: PUSH
15512: LD_INT 5
15514: PUSH
15515: LD_INT 8
15517: PUSH
15518: LD_INT 9
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: PUSH
15526: LD_VAR 0 4
15530: ARRAY
15531: ST_TO_ADDR
// end ;
15532: LD_VAR 0 2
15536: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15537: LD_INT 0
15539: PPUSH
15540: PPUSH
15541: PPUSH
// if not mines then
15542: LD_VAR 0 2
15546: NOT
15547: IFFALSE 15551
// exit ;
15549: GO 15695
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15551: LD_ADDR_VAR 0 5
15555: PUSH
15556: LD_INT 81
15558: PUSH
15559: LD_VAR 0 1
15563: PUSH
15564: EMPTY
15565: LIST
15566: LIST
15567: PUSH
15568: LD_INT 3
15570: PUSH
15571: LD_INT 21
15573: PUSH
15574: LD_INT 3
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: ST_TO_ADDR
// for i in mines do
15594: LD_ADDR_VAR 0 4
15598: PUSH
15599: LD_VAR 0 2
15603: PUSH
15604: FOR_IN
15605: IFFALSE 15693
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15607: LD_VAR 0 4
15611: PUSH
15612: LD_INT 1
15614: ARRAY
15615: PPUSH
15616: LD_VAR 0 4
15620: PUSH
15621: LD_INT 2
15623: ARRAY
15624: PPUSH
15625: CALL_OW 458
15629: NOT
15630: IFFALSE 15634
// continue ;
15632: GO 15604
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15634: LD_VAR 0 4
15638: PUSH
15639: LD_INT 1
15641: ARRAY
15642: PPUSH
15643: LD_VAR 0 4
15647: PUSH
15648: LD_INT 2
15650: ARRAY
15651: PPUSH
15652: CALL_OW 428
15656: PUSH
15657: LD_VAR 0 5
15661: IN
15662: IFFALSE 15691
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15664: LD_VAR 0 4
15668: PUSH
15669: LD_INT 1
15671: ARRAY
15672: PPUSH
15673: LD_VAR 0 4
15677: PUSH
15678: LD_INT 2
15680: ARRAY
15681: PPUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: CALL_OW 456
// end ;
15691: GO 15604
15693: POP
15694: POP
// end ;
15695: LD_VAR 0 3
15699: RET
// export function Count ( array ) ; var i ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
// result := 0 ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 0
15711: ST_TO_ADDR
// for i in array do
15712: LD_ADDR_VAR 0 3
15716: PUSH
15717: LD_VAR 0 1
15721: PUSH
15722: FOR_IN
15723: IFFALSE 15747
// if i then
15725: LD_VAR 0 3
15729: IFFALSE 15745
// result := result + 1 ;
15731: LD_ADDR_VAR 0 2
15735: PUSH
15736: LD_VAR 0 2
15740: PUSH
15741: LD_INT 1
15743: PLUS
15744: ST_TO_ADDR
15745: GO 15722
15747: POP
15748: POP
// end ;
15749: LD_VAR 0 2
15753: RET
// export function IsEmpty ( building ) ; begin
15754: LD_INT 0
15756: PPUSH
// if not building then
15757: LD_VAR 0 1
15761: NOT
15762: IFFALSE 15766
// exit ;
15764: GO 15809
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15766: LD_ADDR_VAR 0 2
15770: PUSH
15771: LD_VAR 0 1
15775: PUSH
15776: LD_INT 22
15778: PUSH
15779: LD_VAR 0 1
15783: PPUSH
15784: CALL_OW 255
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: PUSH
15793: LD_INT 58
15795: PUSH
15796: EMPTY
15797: LIST
15798: PUSH
15799: EMPTY
15800: LIST
15801: LIST
15802: PPUSH
15803: CALL_OW 69
15807: IN
15808: ST_TO_ADDR
// end ;
15809: LD_VAR 0 2
15813: RET
// export function IsNotFull ( building ) ; begin
15814: LD_INT 0
15816: PPUSH
// if not building then
15817: LD_VAR 0 1
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15845
// result := UnitsInside ( building ) < 6 ;
15826: LD_ADDR_VAR 0 2
15830: PUSH
15831: LD_VAR 0 1
15835: PPUSH
15836: CALL_OW 313
15840: PUSH
15841: LD_INT 6
15843: LESS
15844: ST_TO_ADDR
// end ;
15845: LD_VAR 0 2
15849: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15850: LD_INT 0
15852: PPUSH
15853: PPUSH
15854: PPUSH
15855: PPUSH
// tmp := [ ] ;
15856: LD_ADDR_VAR 0 3
15860: PUSH
15861: EMPTY
15862: ST_TO_ADDR
// list := [ ] ;
15863: LD_ADDR_VAR 0 5
15867: PUSH
15868: EMPTY
15869: ST_TO_ADDR
// for i = 16 to 25 do
15870: LD_ADDR_VAR 0 4
15874: PUSH
15875: DOUBLE
15876: LD_INT 16
15878: DEC
15879: ST_TO_ADDR
15880: LD_INT 25
15882: PUSH
15883: FOR_TO
15884: IFFALSE 15957
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15886: LD_ADDR_VAR 0 3
15890: PUSH
15891: LD_VAR 0 3
15895: PUSH
15896: LD_INT 22
15898: PUSH
15899: LD_VAR 0 1
15903: PPUSH
15904: CALL_OW 255
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 91
15915: PUSH
15916: LD_VAR 0 1
15920: PUSH
15921: LD_INT 6
15923: PUSH
15924: EMPTY
15925: LIST
15926: LIST
15927: LIST
15928: PUSH
15929: LD_INT 30
15931: PUSH
15932: LD_VAR 0 4
15936: PUSH
15937: EMPTY
15938: LIST
15939: LIST
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: PPUSH
15949: CALL_OW 69
15953: ADD
15954: ST_TO_ADDR
15955: GO 15883
15957: POP
15958: POP
// for i = 1 to tmp do
15959: LD_ADDR_VAR 0 4
15963: PUSH
15964: DOUBLE
15965: LD_INT 1
15967: DEC
15968: ST_TO_ADDR
15969: LD_VAR 0 3
15973: PUSH
15974: FOR_TO
15975: IFFALSE 16063
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15977: LD_ADDR_VAR 0 5
15981: PUSH
15982: LD_VAR 0 5
15986: PUSH
15987: LD_VAR 0 3
15991: PUSH
15992: LD_VAR 0 4
15996: ARRAY
15997: PPUSH
15998: CALL_OW 266
16002: PUSH
16003: LD_VAR 0 3
16007: PUSH
16008: LD_VAR 0 4
16012: ARRAY
16013: PPUSH
16014: CALL_OW 250
16018: PUSH
16019: LD_VAR 0 3
16023: PUSH
16024: LD_VAR 0 4
16028: ARRAY
16029: PPUSH
16030: CALL_OW 251
16034: PUSH
16035: LD_VAR 0 3
16039: PUSH
16040: LD_VAR 0 4
16044: ARRAY
16045: PPUSH
16046: CALL_OW 254
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: LIST
16056: PUSH
16057: EMPTY
16058: LIST
16059: ADD
16060: ST_TO_ADDR
16061: GO 15974
16063: POP
16064: POP
// result := list ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_VAR 0 5
16074: ST_TO_ADDR
// end ;
16075: LD_VAR 0 2
16079: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16080: LD_INT 0
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
16087: PPUSH
16088: PPUSH
// if not factory then
16089: LD_VAR 0 1
16093: NOT
16094: IFFALSE 16098
// exit ;
16096: GO 16691
// if control = control_apeman then
16098: LD_VAR 0 4
16102: PUSH
16103: LD_INT 5
16105: EQUAL
16106: IFFALSE 16215
// begin tmp := UnitsInside ( factory ) ;
16108: LD_ADDR_VAR 0 8
16112: PUSH
16113: LD_VAR 0 1
16117: PPUSH
16118: CALL_OW 313
16122: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16123: LD_VAR 0 8
16127: PPUSH
16128: LD_INT 25
16130: PUSH
16131: LD_INT 12
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PPUSH
16138: CALL_OW 72
16142: NOT
16143: IFFALSE 16153
// control := control_manual ;
16145: LD_ADDR_VAR 0 4
16149: PUSH
16150: LD_INT 1
16152: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16153: LD_ADDR_VAR 0 8
16157: PUSH
16158: LD_VAR 0 1
16162: PPUSH
16163: CALL 15850 0 1
16167: ST_TO_ADDR
// if tmp then
16168: LD_VAR 0 8
16172: IFFALSE 16215
// begin for i in tmp do
16174: LD_ADDR_VAR 0 7
16178: PUSH
16179: LD_VAR 0 8
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16213
// if i [ 1 ] = b_ext_radio then
16187: LD_VAR 0 7
16191: PUSH
16192: LD_INT 1
16194: ARRAY
16195: PUSH
16196: LD_INT 22
16198: EQUAL
16199: IFFALSE 16211
// begin control := control_remote ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_INT 2
16208: ST_TO_ADDR
// break ;
16209: GO 16213
// end ;
16211: GO 16184
16213: POP
16214: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16215: LD_VAR 0 1
16219: PPUSH
16220: LD_VAR 0 2
16224: PPUSH
16225: LD_VAR 0 3
16229: PPUSH
16230: LD_VAR 0 4
16234: PPUSH
16235: LD_VAR 0 5
16239: PPUSH
16240: CALL_OW 448
16244: IFFALSE 16279
// begin result := [ chassis , engine , control , weapon ] ;
16246: LD_ADDR_VAR 0 6
16250: PUSH
16251: LD_VAR 0 2
16255: PUSH
16256: LD_VAR 0 3
16260: PUSH
16261: LD_VAR 0 4
16265: PUSH
16266: LD_VAR 0 5
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: LIST
16275: LIST
16276: ST_TO_ADDR
// exit ;
16277: GO 16691
// end ; _chassis := AvailableChassisList ( factory ) ;
16279: LD_ADDR_VAR 0 9
16283: PUSH
16284: LD_VAR 0 1
16288: PPUSH
16289: CALL_OW 475
16293: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16294: LD_ADDR_VAR 0 11
16298: PUSH
16299: LD_VAR 0 1
16303: PPUSH
16304: CALL_OW 476
16308: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16309: LD_ADDR_VAR 0 12
16313: PUSH
16314: LD_VAR 0 1
16318: PPUSH
16319: CALL_OW 477
16323: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16324: LD_ADDR_VAR 0 10
16328: PUSH
16329: LD_VAR 0 1
16333: PPUSH
16334: CALL_OW 478
16338: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16339: LD_VAR 0 9
16343: NOT
16344: PUSH
16345: LD_VAR 0 11
16349: NOT
16350: OR
16351: PUSH
16352: LD_VAR 0 12
16356: NOT
16357: OR
16358: PUSH
16359: LD_VAR 0 10
16363: NOT
16364: OR
16365: IFFALSE 16400
// begin result := [ chassis , engine , control , weapon ] ;
16367: LD_ADDR_VAR 0 6
16371: PUSH
16372: LD_VAR 0 2
16376: PUSH
16377: LD_VAR 0 3
16381: PUSH
16382: LD_VAR 0 4
16386: PUSH
16387: LD_VAR 0 5
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: LIST
16396: LIST
16397: ST_TO_ADDR
// exit ;
16398: GO 16691
// end ; if not chassis in _chassis then
16400: LD_VAR 0 2
16404: PUSH
16405: LD_VAR 0 9
16409: IN
16410: NOT
16411: IFFALSE 16437
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16413: LD_ADDR_VAR 0 2
16417: PUSH
16418: LD_VAR 0 9
16422: PUSH
16423: LD_INT 1
16425: PPUSH
16426: LD_VAR 0 9
16430: PPUSH
16431: CALL_OW 12
16435: ARRAY
16436: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16437: LD_VAR 0 2
16441: PPUSH
16442: LD_VAR 0 3
16446: PPUSH
16447: CALL 16696 0 2
16451: NOT
16452: IFFALSE 16511
// repeat engine := _engine [ 1 ] ;
16454: LD_ADDR_VAR 0 3
16458: PUSH
16459: LD_VAR 0 11
16463: PUSH
16464: LD_INT 1
16466: ARRAY
16467: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16468: LD_ADDR_VAR 0 11
16472: PUSH
16473: LD_VAR 0 11
16477: PPUSH
16478: LD_INT 1
16480: PPUSH
16481: CALL_OW 3
16485: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16486: LD_VAR 0 2
16490: PPUSH
16491: LD_VAR 0 3
16495: PPUSH
16496: CALL 16696 0 2
16500: PUSH
16501: LD_VAR 0 11
16505: PUSH
16506: EMPTY
16507: EQUAL
16508: OR
16509: IFFALSE 16454
// if not control in _control then
16511: LD_VAR 0 4
16515: PUSH
16516: LD_VAR 0 12
16520: IN
16521: NOT
16522: IFFALSE 16548
// control := _control [ rand ( 1 , _control ) ] ;
16524: LD_ADDR_VAR 0 4
16528: PUSH
16529: LD_VAR 0 12
16533: PUSH
16534: LD_INT 1
16536: PPUSH
16537: LD_VAR 0 12
16541: PPUSH
16542: CALL_OW 12
16546: ARRAY
16547: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16548: LD_VAR 0 2
16552: PPUSH
16553: LD_VAR 0 5
16557: PPUSH
16558: CALL 16916 0 2
16562: NOT
16563: IFFALSE 16622
// repeat weapon := _weapon [ 1 ] ;
16565: LD_ADDR_VAR 0 5
16569: PUSH
16570: LD_VAR 0 10
16574: PUSH
16575: LD_INT 1
16577: ARRAY
16578: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PPUSH
16589: LD_INT 1
16591: PPUSH
16592: CALL_OW 3
16596: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16597: LD_VAR 0 2
16601: PPUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: CALL 16916 0 2
16611: PUSH
16612: LD_VAR 0 10
16616: PUSH
16617: EMPTY
16618: EQUAL
16619: OR
16620: IFFALSE 16565
// result := [ ] ;
16622: LD_ADDR_VAR 0 6
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16629: LD_VAR 0 1
16633: PPUSH
16634: LD_VAR 0 2
16638: PPUSH
16639: LD_VAR 0 3
16643: PPUSH
16644: LD_VAR 0 4
16648: PPUSH
16649: LD_VAR 0 5
16653: PPUSH
16654: CALL_OW 448
16658: IFFALSE 16691
// result := [ chassis , engine , control , weapon ] ;
16660: LD_ADDR_VAR 0 6
16664: PUSH
16665: LD_VAR 0 2
16669: PUSH
16670: LD_VAR 0 3
16674: PUSH
16675: LD_VAR 0 4
16679: PUSH
16680: LD_VAR 0 5
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: LIST
16690: ST_TO_ADDR
// end ;
16691: LD_VAR 0 6
16695: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16696: LD_INT 0
16698: PPUSH
// if not chassis or not engine then
16699: LD_VAR 0 1
16703: NOT
16704: PUSH
16705: LD_VAR 0 2
16709: NOT
16710: OR
16711: IFFALSE 16715
// exit ;
16713: GO 16911
// case engine of engine_solar :
16715: LD_VAR 0 2
16719: PUSH
16720: LD_INT 2
16722: DOUBLE
16723: EQUAL
16724: IFTRUE 16728
16726: GO 16766
16728: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 11
16736: PUSH
16737: LD_INT 12
16739: PUSH
16740: LD_INT 13
16742: PUSH
16743: LD_INT 14
16745: PUSH
16746: LD_INT 1
16748: PUSH
16749: LD_INT 2
16751: PUSH
16752: LD_INT 3
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: LIST
16763: ST_TO_ADDR
16764: GO 16895
16766: LD_INT 1
16768: DOUBLE
16769: EQUAL
16770: IFTRUE 16774
16772: GO 16836
16774: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16775: LD_ADDR_VAR 0 3
16779: PUSH
16780: LD_INT 11
16782: PUSH
16783: LD_INT 12
16785: PUSH
16786: LD_INT 13
16788: PUSH
16789: LD_INT 14
16791: PUSH
16792: LD_INT 1
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 3
16800: PUSH
16801: LD_INT 4
16803: PUSH
16804: LD_INT 5
16806: PUSH
16807: LD_INT 21
16809: PUSH
16810: LD_INT 23
16812: PUSH
16813: LD_INT 22
16815: PUSH
16816: LD_INT 24
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: LIST
16826: LIST
16827: LIST
16828: LIST
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: ST_TO_ADDR
16834: GO 16895
16836: LD_INT 3
16838: DOUBLE
16839: EQUAL
16840: IFTRUE 16844
16842: GO 16894
16844: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16845: LD_ADDR_VAR 0 3
16849: PUSH
16850: LD_INT 13
16852: PUSH
16853: LD_INT 14
16855: PUSH
16856: LD_INT 2
16858: PUSH
16859: LD_INT 3
16861: PUSH
16862: LD_INT 4
16864: PUSH
16865: LD_INT 5
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 22
16873: PUSH
16874: LD_INT 23
16876: PUSH
16877: LD_INT 24
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: LIST
16884: LIST
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: LIST
16890: LIST
16891: ST_TO_ADDR
16892: GO 16895
16894: POP
// result := ( chassis in result ) ;
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_VAR 0 1
16904: PUSH
16905: LD_VAR 0 3
16909: IN
16910: ST_TO_ADDR
// end ;
16911: LD_VAR 0 3
16915: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16916: LD_INT 0
16918: PPUSH
// if not chassis or not weapon then
16919: LD_VAR 0 1
16923: NOT
16924: PUSH
16925: LD_VAR 0 2
16929: NOT
16930: OR
16931: IFFALSE 16935
// exit ;
16933: GO 17961
// case weapon of us_machine_gun :
16935: LD_VAR 0 2
16939: PUSH
16940: LD_INT 2
16942: DOUBLE
16943: EQUAL
16944: IFTRUE 16948
16946: GO 16978
16948: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16949: LD_ADDR_VAR 0 3
16953: PUSH
16954: LD_INT 1
16956: PUSH
16957: LD_INT 2
16959: PUSH
16960: LD_INT 3
16962: PUSH
16963: LD_INT 4
16965: PUSH
16966: LD_INT 5
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: ST_TO_ADDR
16976: GO 17945
16978: LD_INT 3
16980: DOUBLE
16981: EQUAL
16982: IFTRUE 16986
16984: GO 17016
16986: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16987: LD_ADDR_VAR 0 3
16991: PUSH
16992: LD_INT 1
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: LD_INT 3
17000: PUSH
17001: LD_INT 4
17003: PUSH
17004: LD_INT 5
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: ST_TO_ADDR
17014: GO 17945
17016: LD_INT 11
17018: DOUBLE
17019: EQUAL
17020: IFTRUE 17024
17022: GO 17054
17024: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17025: LD_ADDR_VAR 0 3
17029: PUSH
17030: LD_INT 1
17032: PUSH
17033: LD_INT 2
17035: PUSH
17036: LD_INT 3
17038: PUSH
17039: LD_INT 4
17041: PUSH
17042: LD_INT 5
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: ST_TO_ADDR
17052: GO 17945
17054: LD_INT 4
17056: DOUBLE
17057: EQUAL
17058: IFTRUE 17062
17060: GO 17088
17062: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17063: LD_ADDR_VAR 0 3
17067: PUSH
17068: LD_INT 2
17070: PUSH
17071: LD_INT 3
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: LD_INT 5
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: LIST
17085: ST_TO_ADDR
17086: GO 17945
17088: LD_INT 5
17090: DOUBLE
17091: EQUAL
17092: IFTRUE 17096
17094: GO 17122
17096: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17097: LD_ADDR_VAR 0 3
17101: PUSH
17102: LD_INT 2
17104: PUSH
17105: LD_INT 3
17107: PUSH
17108: LD_INT 4
17110: PUSH
17111: LD_INT 5
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: ST_TO_ADDR
17120: GO 17945
17122: LD_INT 9
17124: DOUBLE
17125: EQUAL
17126: IFTRUE 17130
17128: GO 17156
17130: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17131: LD_ADDR_VAR 0 3
17135: PUSH
17136: LD_INT 2
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 4
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: LIST
17152: LIST
17153: ST_TO_ADDR
17154: GO 17945
17156: LD_INT 7
17158: DOUBLE
17159: EQUAL
17160: IFTRUE 17164
17162: GO 17190
17164: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17165: LD_ADDR_VAR 0 3
17169: PUSH
17170: LD_INT 2
17172: PUSH
17173: LD_INT 3
17175: PUSH
17176: LD_INT 4
17178: PUSH
17179: LD_INT 5
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: ST_TO_ADDR
17188: GO 17945
17190: LD_INT 12
17192: DOUBLE
17193: EQUAL
17194: IFTRUE 17198
17196: GO 17224
17198: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17199: LD_ADDR_VAR 0 3
17203: PUSH
17204: LD_INT 2
17206: PUSH
17207: LD_INT 3
17209: PUSH
17210: LD_INT 4
17212: PUSH
17213: LD_INT 5
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: ST_TO_ADDR
17222: GO 17945
17224: LD_INT 13
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17232
17230: GO 17258
17232: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17233: LD_ADDR_VAR 0 3
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: LD_INT 3
17243: PUSH
17244: LD_INT 4
17246: PUSH
17247: LD_INT 5
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: ST_TO_ADDR
17256: GO 17945
17258: LD_INT 14
17260: DOUBLE
17261: EQUAL
17262: IFTRUE 17266
17264: GO 17284
17266: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17267: LD_ADDR_VAR 0 3
17271: PUSH
17272: LD_INT 4
17274: PUSH
17275: LD_INT 5
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: ST_TO_ADDR
17282: GO 17945
17284: LD_INT 6
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17310
17292: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17293: LD_ADDR_VAR 0 3
17297: PUSH
17298: LD_INT 4
17300: PUSH
17301: LD_INT 5
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: ST_TO_ADDR
17308: GO 17945
17310: LD_INT 10
17312: DOUBLE
17313: EQUAL
17314: IFTRUE 17318
17316: GO 17336
17318: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17319: LD_ADDR_VAR 0 3
17323: PUSH
17324: LD_INT 4
17326: PUSH
17327: LD_INT 5
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: ST_TO_ADDR
17334: GO 17945
17336: LD_INT 22
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17370
17344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17345: LD_ADDR_VAR 0 3
17349: PUSH
17350: LD_INT 11
17352: PUSH
17353: LD_INT 12
17355: PUSH
17356: LD_INT 13
17358: PUSH
17359: LD_INT 14
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: LIST
17367: ST_TO_ADDR
17368: GO 17945
17370: LD_INT 23
17372: DOUBLE
17373: EQUAL
17374: IFTRUE 17378
17376: GO 17404
17378: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17379: LD_ADDR_VAR 0 3
17383: PUSH
17384: LD_INT 11
17386: PUSH
17387: LD_INT 12
17389: PUSH
17390: LD_INT 13
17392: PUSH
17393: LD_INT 14
17395: PUSH
17396: EMPTY
17397: LIST
17398: LIST
17399: LIST
17400: LIST
17401: ST_TO_ADDR
17402: GO 17945
17404: LD_INT 24
17406: DOUBLE
17407: EQUAL
17408: IFTRUE 17412
17410: GO 17438
17412: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17413: LD_ADDR_VAR 0 3
17417: PUSH
17418: LD_INT 11
17420: PUSH
17421: LD_INT 12
17423: PUSH
17424: LD_INT 13
17426: PUSH
17427: LD_INT 14
17429: PUSH
17430: EMPTY
17431: LIST
17432: LIST
17433: LIST
17434: LIST
17435: ST_TO_ADDR
17436: GO 17945
17438: LD_INT 30
17440: DOUBLE
17441: EQUAL
17442: IFTRUE 17446
17444: GO 17472
17446: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: LD_INT 11
17454: PUSH
17455: LD_INT 12
17457: PUSH
17458: LD_INT 13
17460: PUSH
17461: LD_INT 14
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: LIST
17468: LIST
17469: ST_TO_ADDR
17470: GO 17945
17472: LD_INT 25
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17498
17480: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17481: LD_ADDR_VAR 0 3
17485: PUSH
17486: LD_INT 13
17488: PUSH
17489: LD_INT 14
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: ST_TO_ADDR
17496: GO 17945
17498: LD_INT 27
17500: DOUBLE
17501: EQUAL
17502: IFTRUE 17506
17504: GO 17524
17506: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17507: LD_ADDR_VAR 0 3
17511: PUSH
17512: LD_INT 13
17514: PUSH
17515: LD_INT 14
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: ST_TO_ADDR
17522: GO 17945
17524: LD_INT 28
17526: DOUBLE
17527: EQUAL
17528: IFTRUE 17532
17530: GO 17550
17532: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17533: LD_ADDR_VAR 0 3
17537: PUSH
17538: LD_INT 13
17540: PUSH
17541: LD_INT 14
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: ST_TO_ADDR
17548: GO 17945
17550: LD_INT 29
17552: DOUBLE
17553: EQUAL
17554: IFTRUE 17558
17556: GO 17576
17558: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17559: LD_ADDR_VAR 0 3
17563: PUSH
17564: LD_INT 13
17566: PUSH
17567: LD_INT 14
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: ST_TO_ADDR
17574: GO 17945
17576: LD_INT 31
17578: DOUBLE
17579: EQUAL
17580: IFTRUE 17584
17582: GO 17602
17584: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: ST_TO_ADDR
17600: GO 17945
17602: LD_INT 26
17604: DOUBLE
17605: EQUAL
17606: IFTRUE 17610
17608: GO 17628
17610: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17611: LD_ADDR_VAR 0 3
17615: PUSH
17616: LD_INT 13
17618: PUSH
17619: LD_INT 14
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: ST_TO_ADDR
17626: GO 17945
17628: LD_INT 42
17630: DOUBLE
17631: EQUAL
17632: IFTRUE 17636
17634: GO 17662
17636: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17637: LD_ADDR_VAR 0 3
17641: PUSH
17642: LD_INT 21
17644: PUSH
17645: LD_INT 22
17647: PUSH
17648: LD_INT 23
17650: PUSH
17651: LD_INT 24
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: ST_TO_ADDR
17660: GO 17945
17662: LD_INT 43
17664: DOUBLE
17665: EQUAL
17666: IFTRUE 17670
17668: GO 17696
17670: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_INT 21
17678: PUSH
17679: LD_INT 22
17681: PUSH
17682: LD_INT 23
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: LIST
17693: ST_TO_ADDR
17694: GO 17945
17696: LD_INT 44
17698: DOUBLE
17699: EQUAL
17700: IFTRUE 17704
17702: GO 17730
17704: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17705: LD_ADDR_VAR 0 3
17709: PUSH
17710: LD_INT 21
17712: PUSH
17713: LD_INT 22
17715: PUSH
17716: LD_INT 23
17718: PUSH
17719: LD_INT 24
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: ST_TO_ADDR
17728: GO 17945
17730: LD_INT 45
17732: DOUBLE
17733: EQUAL
17734: IFTRUE 17738
17736: GO 17764
17738: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17739: LD_ADDR_VAR 0 3
17743: PUSH
17744: LD_INT 21
17746: PUSH
17747: LD_INT 22
17749: PUSH
17750: LD_INT 23
17752: PUSH
17753: LD_INT 24
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: ST_TO_ADDR
17762: GO 17945
17764: LD_INT 49
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17798
17772: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17773: LD_ADDR_VAR 0 3
17777: PUSH
17778: LD_INT 21
17780: PUSH
17781: LD_INT 22
17783: PUSH
17784: LD_INT 23
17786: PUSH
17787: LD_INT 24
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: ST_TO_ADDR
17796: GO 17945
17798: LD_INT 51
17800: DOUBLE
17801: EQUAL
17802: IFTRUE 17806
17804: GO 17832
17806: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17807: LD_ADDR_VAR 0 3
17811: PUSH
17812: LD_INT 21
17814: PUSH
17815: LD_INT 22
17817: PUSH
17818: LD_INT 23
17820: PUSH
17821: LD_INT 24
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: LIST
17828: LIST
17829: ST_TO_ADDR
17830: GO 17945
17832: LD_INT 52
17834: DOUBLE
17835: EQUAL
17836: IFTRUE 17840
17838: GO 17866
17840: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17841: LD_ADDR_VAR 0 3
17845: PUSH
17846: LD_INT 21
17848: PUSH
17849: LD_INT 22
17851: PUSH
17852: LD_INT 23
17854: PUSH
17855: LD_INT 24
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
17864: GO 17945
17866: LD_INT 53
17868: DOUBLE
17869: EQUAL
17870: IFTRUE 17874
17872: GO 17892
17874: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17875: LD_ADDR_VAR 0 3
17879: PUSH
17880: LD_INT 23
17882: PUSH
17883: LD_INT 24
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: ST_TO_ADDR
17890: GO 17945
17892: LD_INT 46
17894: DOUBLE
17895: EQUAL
17896: IFTRUE 17900
17898: GO 17918
17900: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17901: LD_ADDR_VAR 0 3
17905: PUSH
17906: LD_INT 23
17908: PUSH
17909: LD_INT 24
17911: PUSH
17912: EMPTY
17913: LIST
17914: LIST
17915: ST_TO_ADDR
17916: GO 17945
17918: LD_INT 47
17920: DOUBLE
17921: EQUAL
17922: IFTRUE 17926
17924: GO 17944
17926: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17927: LD_ADDR_VAR 0 3
17931: PUSH
17932: LD_INT 23
17934: PUSH
17935: LD_INT 24
17937: PUSH
17938: EMPTY
17939: LIST
17940: LIST
17941: ST_TO_ADDR
17942: GO 17945
17944: POP
// result := ( chassis in result ) ;
17945: LD_ADDR_VAR 0 3
17949: PUSH
17950: LD_VAR 0 1
17954: PUSH
17955: LD_VAR 0 3
17959: IN
17960: ST_TO_ADDR
// end ;
17961: LD_VAR 0 3
17965: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17966: LD_INT 0
17968: PPUSH
17969: PPUSH
17970: PPUSH
17971: PPUSH
17972: PPUSH
17973: PPUSH
17974: PPUSH
// result := array ;
17975: LD_ADDR_VAR 0 5
17979: PUSH
17980: LD_VAR 0 1
17984: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17985: LD_VAR 0 1
17989: NOT
17990: PUSH
17991: LD_VAR 0 2
17995: NOT
17996: OR
17997: PUSH
17998: LD_VAR 0 3
18002: NOT
18003: OR
18004: PUSH
18005: LD_VAR 0 2
18009: PUSH
18010: LD_VAR 0 1
18014: GREATER
18015: OR
18016: PUSH
18017: LD_VAR 0 3
18021: PUSH
18022: LD_VAR 0 1
18026: GREATER
18027: OR
18028: IFFALSE 18032
// exit ;
18030: GO 18328
// if direction then
18032: LD_VAR 0 4
18036: IFFALSE 18100
// begin d := 1 ;
18038: LD_ADDR_VAR 0 9
18042: PUSH
18043: LD_INT 1
18045: ST_TO_ADDR
// if i_from > i_to then
18046: LD_VAR 0 2
18050: PUSH
18051: LD_VAR 0 3
18055: GREATER
18056: IFFALSE 18082
// length := ( array - i_from ) + i_to else
18058: LD_ADDR_VAR 0 11
18062: PUSH
18063: LD_VAR 0 1
18067: PUSH
18068: LD_VAR 0 2
18072: MINUS
18073: PUSH
18074: LD_VAR 0 3
18078: PLUS
18079: ST_TO_ADDR
18080: GO 18098
// length := i_to - i_from ;
18082: LD_ADDR_VAR 0 11
18086: PUSH
18087: LD_VAR 0 3
18091: PUSH
18092: LD_VAR 0 2
18096: MINUS
18097: ST_TO_ADDR
// end else
18098: GO 18161
// begin d := - 1 ;
18100: LD_ADDR_VAR 0 9
18104: PUSH
18105: LD_INT 1
18107: NEG
18108: ST_TO_ADDR
// if i_from > i_to then
18109: LD_VAR 0 2
18113: PUSH
18114: LD_VAR 0 3
18118: GREATER
18119: IFFALSE 18139
// length := i_from - i_to else
18121: LD_ADDR_VAR 0 11
18125: PUSH
18126: LD_VAR 0 2
18130: PUSH
18131: LD_VAR 0 3
18135: MINUS
18136: ST_TO_ADDR
18137: GO 18161
// length := ( array - i_to ) + i_from ;
18139: LD_ADDR_VAR 0 11
18143: PUSH
18144: LD_VAR 0 1
18148: PUSH
18149: LD_VAR 0 3
18153: MINUS
18154: PUSH
18155: LD_VAR 0 2
18159: PLUS
18160: ST_TO_ADDR
// end ; if not length then
18161: LD_VAR 0 11
18165: NOT
18166: IFFALSE 18170
// exit ;
18168: GO 18328
// tmp := array ;
18170: LD_ADDR_VAR 0 10
18174: PUSH
18175: LD_VAR 0 1
18179: ST_TO_ADDR
// for i = 1 to length do
18180: LD_ADDR_VAR 0 6
18184: PUSH
18185: DOUBLE
18186: LD_INT 1
18188: DEC
18189: ST_TO_ADDR
18190: LD_VAR 0 11
18194: PUSH
18195: FOR_TO
18196: IFFALSE 18316
// begin for j = 1 to array do
18198: LD_ADDR_VAR 0 7
18202: PUSH
18203: DOUBLE
18204: LD_INT 1
18206: DEC
18207: ST_TO_ADDR
18208: LD_VAR 0 1
18212: PUSH
18213: FOR_TO
18214: IFFALSE 18302
// begin k := j + d ;
18216: LD_ADDR_VAR 0 8
18220: PUSH
18221: LD_VAR 0 7
18225: PUSH
18226: LD_VAR 0 9
18230: PLUS
18231: ST_TO_ADDR
// if k > array then
18232: LD_VAR 0 8
18236: PUSH
18237: LD_VAR 0 1
18241: GREATER
18242: IFFALSE 18252
// k := 1 ;
18244: LD_ADDR_VAR 0 8
18248: PUSH
18249: LD_INT 1
18251: ST_TO_ADDR
// if not k then
18252: LD_VAR 0 8
18256: NOT
18257: IFFALSE 18269
// k := array ;
18259: LD_ADDR_VAR 0 8
18263: PUSH
18264: LD_VAR 0 1
18268: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18269: LD_ADDR_VAR 0 10
18273: PUSH
18274: LD_VAR 0 10
18278: PPUSH
18279: LD_VAR 0 8
18283: PPUSH
18284: LD_VAR 0 1
18288: PUSH
18289: LD_VAR 0 7
18293: ARRAY
18294: PPUSH
18295: CALL_OW 1
18299: ST_TO_ADDR
// end ;
18300: GO 18213
18302: POP
18303: POP
// array := tmp ;
18304: LD_ADDR_VAR 0 1
18308: PUSH
18309: LD_VAR 0 10
18313: ST_TO_ADDR
// end ;
18314: GO 18195
18316: POP
18317: POP
// result := array ;
18318: LD_ADDR_VAR 0 5
18322: PUSH
18323: LD_VAR 0 1
18327: ST_TO_ADDR
// end ;
18328: LD_VAR 0 5
18332: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18333: LD_INT 0
18335: PPUSH
18336: PPUSH
// result := 0 ;
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 0
18344: ST_TO_ADDR
// if not array or not value in array then
18345: LD_VAR 0 1
18349: NOT
18350: PUSH
18351: LD_VAR 0 2
18355: PUSH
18356: LD_VAR 0 1
18360: IN
18361: NOT
18362: OR
18363: IFFALSE 18367
// exit ;
18365: GO 18421
// for i = 1 to array do
18367: LD_ADDR_VAR 0 4
18371: PUSH
18372: DOUBLE
18373: LD_INT 1
18375: DEC
18376: ST_TO_ADDR
18377: LD_VAR 0 1
18381: PUSH
18382: FOR_TO
18383: IFFALSE 18419
// if value = array [ i ] then
18385: LD_VAR 0 2
18389: PUSH
18390: LD_VAR 0 1
18394: PUSH
18395: LD_VAR 0 4
18399: ARRAY
18400: EQUAL
18401: IFFALSE 18417
// begin result := i ;
18403: LD_ADDR_VAR 0 3
18407: PUSH
18408: LD_VAR 0 4
18412: ST_TO_ADDR
// exit ;
18413: POP
18414: POP
18415: GO 18421
// end ;
18417: GO 18382
18419: POP
18420: POP
// end ;
18421: LD_VAR 0 3
18425: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18426: LD_INT 0
18428: PPUSH
// vc_chassis := chassis ;
18429: LD_ADDR_OWVAR 37
18433: PUSH
18434: LD_VAR 0 1
18438: ST_TO_ADDR
// vc_engine := engine ;
18439: LD_ADDR_OWVAR 39
18443: PUSH
18444: LD_VAR 0 2
18448: ST_TO_ADDR
// vc_control := control ;
18449: LD_ADDR_OWVAR 38
18453: PUSH
18454: LD_VAR 0 3
18458: ST_TO_ADDR
// vc_weapon := weapon ;
18459: LD_ADDR_OWVAR 40
18463: PUSH
18464: LD_VAR 0 4
18468: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18469: LD_ADDR_OWVAR 41
18473: PUSH
18474: LD_VAR 0 5
18478: ST_TO_ADDR
// end ;
18479: LD_VAR 0 6
18483: RET
// export function WantPlant ( unit ) ; var task ; begin
18484: LD_INT 0
18486: PPUSH
18487: PPUSH
// result := false ;
18488: LD_ADDR_VAR 0 2
18492: PUSH
18493: LD_INT 0
18495: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: CALL_OW 437
18510: ST_TO_ADDR
// if task then
18511: LD_VAR 0 3
18515: IFFALSE 18543
// if task [ 1 ] [ 1 ] = p then
18517: LD_VAR 0 3
18521: PUSH
18522: LD_INT 1
18524: ARRAY
18525: PUSH
18526: LD_INT 1
18528: ARRAY
18529: PUSH
18530: LD_STRING p
18532: EQUAL
18533: IFFALSE 18543
// result := true ;
18535: LD_ADDR_VAR 0 2
18539: PUSH
18540: LD_INT 1
18542: ST_TO_ADDR
// end ;
18543: LD_VAR 0 2
18547: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18548: LD_INT 0
18550: PPUSH
18551: PPUSH
18552: PPUSH
18553: PPUSH
// if pos < 1 then
18554: LD_VAR 0 2
18558: PUSH
18559: LD_INT 1
18561: LESS
18562: IFFALSE 18566
// exit ;
18564: GO 18869
// if pos = 1 then
18566: LD_VAR 0 2
18570: PUSH
18571: LD_INT 1
18573: EQUAL
18574: IFFALSE 18607
// result := Replace ( arr , pos [ 1 ] , value ) else
18576: LD_ADDR_VAR 0 4
18580: PUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: LD_VAR 0 2
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PPUSH
18595: LD_VAR 0 3
18599: PPUSH
18600: CALL_OW 1
18604: ST_TO_ADDR
18605: GO 18869
// begin tmp := arr ;
18607: LD_ADDR_VAR 0 6
18611: PUSH
18612: LD_VAR 0 1
18616: ST_TO_ADDR
// s_arr := [ tmp ] ;
18617: LD_ADDR_VAR 0 7
18621: PUSH
18622: LD_VAR 0 6
18626: PUSH
18627: EMPTY
18628: LIST
18629: ST_TO_ADDR
// for i = 1 to pos - 1 do
18630: LD_ADDR_VAR 0 5
18634: PUSH
18635: DOUBLE
18636: LD_INT 1
18638: DEC
18639: ST_TO_ADDR
18640: LD_VAR 0 2
18644: PUSH
18645: LD_INT 1
18647: MINUS
18648: PUSH
18649: FOR_TO
18650: IFFALSE 18695
// begin tmp := tmp [ pos [ i ] ] ;
18652: LD_ADDR_VAR 0 6
18656: PUSH
18657: LD_VAR 0 6
18661: PUSH
18662: LD_VAR 0 2
18666: PUSH
18667: LD_VAR 0 5
18671: ARRAY
18672: ARRAY
18673: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18674: LD_ADDR_VAR 0 7
18678: PUSH
18679: LD_VAR 0 7
18683: PUSH
18684: LD_VAR 0 6
18688: PUSH
18689: EMPTY
18690: LIST
18691: ADD
18692: ST_TO_ADDR
// end ;
18693: GO 18649
18695: POP
18696: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18697: LD_ADDR_VAR 0 6
18701: PUSH
18702: LD_VAR 0 6
18706: PPUSH
18707: LD_VAR 0 2
18711: PUSH
18712: LD_VAR 0 2
18716: ARRAY
18717: PPUSH
18718: LD_VAR 0 3
18722: PPUSH
18723: CALL_OW 1
18727: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18728: LD_ADDR_VAR 0 7
18732: PUSH
18733: LD_VAR 0 7
18737: PPUSH
18738: LD_VAR 0 7
18742: PPUSH
18743: LD_VAR 0 6
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// for i = s_arr downto 2 do
18753: LD_ADDR_VAR 0 5
18757: PUSH
18758: DOUBLE
18759: LD_VAR 0 7
18763: INC
18764: ST_TO_ADDR
18765: LD_INT 2
18767: PUSH
18768: FOR_DOWNTO
18769: IFFALSE 18853
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18771: LD_ADDR_VAR 0 6
18775: PUSH
18776: LD_VAR 0 7
18780: PUSH
18781: LD_VAR 0 5
18785: PUSH
18786: LD_INT 1
18788: MINUS
18789: ARRAY
18790: PPUSH
18791: LD_VAR 0 2
18795: PUSH
18796: LD_VAR 0 5
18800: PUSH
18801: LD_INT 1
18803: MINUS
18804: ARRAY
18805: PPUSH
18806: LD_VAR 0 7
18810: PUSH
18811: LD_VAR 0 5
18815: ARRAY
18816: PPUSH
18817: CALL_OW 1
18821: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18822: LD_ADDR_VAR 0 7
18826: PUSH
18827: LD_VAR 0 7
18831: PPUSH
18832: LD_VAR 0 5
18836: PUSH
18837: LD_INT 1
18839: MINUS
18840: PPUSH
18841: LD_VAR 0 6
18845: PPUSH
18846: CALL_OW 1
18850: ST_TO_ADDR
// end ;
18851: GO 18768
18853: POP
18854: POP
// result := s_arr [ 1 ] ;
18855: LD_ADDR_VAR 0 4
18859: PUSH
18860: LD_VAR 0 7
18864: PUSH
18865: LD_INT 1
18867: ARRAY
18868: ST_TO_ADDR
// end ; end ;
18869: LD_VAR 0 4
18873: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18874: LD_INT 0
18876: PPUSH
18877: PPUSH
// if not list then
18878: LD_VAR 0 1
18882: NOT
18883: IFFALSE 18887
// exit ;
18885: GO 18978
// i := list [ pos1 ] ;
18887: LD_ADDR_VAR 0 5
18891: PUSH
18892: LD_VAR 0 1
18896: PUSH
18897: LD_VAR 0 2
18901: ARRAY
18902: ST_TO_ADDR
// if not i then
18903: LD_VAR 0 5
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 18978
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18912: LD_ADDR_VAR 0 1
18916: PUSH
18917: LD_VAR 0 1
18921: PPUSH
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 1
18931: PUSH
18932: LD_VAR 0 3
18936: ARRAY
18937: PPUSH
18938: CALL_OW 1
18942: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_VAR 0 1
18952: PPUSH
18953: LD_VAR 0 3
18957: PPUSH
18958: LD_VAR 0 5
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// result := list ;
18968: LD_ADDR_VAR 0 4
18972: PUSH
18973: LD_VAR 0 1
18977: ST_TO_ADDR
// end ;
18978: LD_VAR 0 4
18982: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18983: LD_INT 0
18985: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18986: LD_ADDR_VAR 0 5
18990: PUSH
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 250
19000: PPUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 251
19010: PPUSH
19011: LD_VAR 0 2
19015: PPUSH
19016: LD_VAR 0 3
19020: PPUSH
19021: LD_VAR 0 4
19025: PPUSH
19026: CALL 19036 0 5
19030: ST_TO_ADDR
// end ;
19031: LD_VAR 0 5
19035: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19036: LD_INT 0
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
// if not list then
19042: LD_VAR 0 3
19046: NOT
19047: IFFALSE 19051
// exit ;
19049: GO 19439
// result := [ ] ;
19051: LD_ADDR_VAR 0 6
19055: PUSH
19056: EMPTY
19057: ST_TO_ADDR
// for i in list do
19058: LD_ADDR_VAR 0 7
19062: PUSH
19063: LD_VAR 0 3
19067: PUSH
19068: FOR_IN
19069: IFFALSE 19271
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19071: LD_ADDR_VAR 0 9
19075: PUSH
19076: LD_VAR 0 7
19080: PPUSH
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 297
19095: ST_TO_ADDR
// if not result then
19096: LD_VAR 0 6
19100: NOT
19101: IFFALSE 19127
// result := [ [ i , tmp ] ] else
19103: LD_ADDR_VAR 0 6
19107: PUSH
19108: LD_VAR 0 7
19112: PUSH
19113: LD_VAR 0 9
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: EMPTY
19123: LIST
19124: ST_TO_ADDR
19125: GO 19269
// begin if result [ result ] [ 2 ] < tmp then
19127: LD_VAR 0 6
19131: PUSH
19132: LD_VAR 0 6
19136: ARRAY
19137: PUSH
19138: LD_INT 2
19140: ARRAY
19141: PUSH
19142: LD_VAR 0 9
19146: LESS
19147: IFFALSE 19189
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19149: LD_ADDR_VAR 0 6
19153: PUSH
19154: LD_VAR 0 6
19158: PPUSH
19159: LD_VAR 0 6
19163: PUSH
19164: LD_INT 1
19166: PLUS
19167: PPUSH
19168: LD_VAR 0 7
19172: PUSH
19173: LD_VAR 0 9
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 2
19186: ST_TO_ADDR
19187: GO 19269
// for j = 1 to result do
19189: LD_ADDR_VAR 0 8
19193: PUSH
19194: DOUBLE
19195: LD_INT 1
19197: DEC
19198: ST_TO_ADDR
19199: LD_VAR 0 6
19203: PUSH
19204: FOR_TO
19205: IFFALSE 19267
// begin if tmp < result [ j ] [ 2 ] then
19207: LD_VAR 0 9
19211: PUSH
19212: LD_VAR 0 6
19216: PUSH
19217: LD_VAR 0 8
19221: ARRAY
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: LESS
19227: IFFALSE 19265
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19229: LD_ADDR_VAR 0 6
19233: PUSH
19234: LD_VAR 0 6
19238: PPUSH
19239: LD_VAR 0 8
19243: PPUSH
19244: LD_VAR 0 7
19248: PUSH
19249: LD_VAR 0 9
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PPUSH
19258: CALL_OW 2
19262: ST_TO_ADDR
// break ;
19263: GO 19267
// end ; end ;
19265: GO 19204
19267: POP
19268: POP
// end ; end ;
19269: GO 19068
19271: POP
19272: POP
// if result and not asc then
19273: LD_VAR 0 6
19277: PUSH
19278: LD_VAR 0 4
19282: NOT
19283: AND
19284: IFFALSE 19359
// begin tmp := result ;
19286: LD_ADDR_VAR 0 9
19290: PUSH
19291: LD_VAR 0 6
19295: ST_TO_ADDR
// for i = tmp downto 1 do
19296: LD_ADDR_VAR 0 7
19300: PUSH
19301: DOUBLE
19302: LD_VAR 0 9
19306: INC
19307: ST_TO_ADDR
19308: LD_INT 1
19310: PUSH
19311: FOR_DOWNTO
19312: IFFALSE 19357
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19314: LD_ADDR_VAR 0 6
19318: PUSH
19319: LD_VAR 0 6
19323: PPUSH
19324: LD_VAR 0 9
19328: PUSH
19329: LD_VAR 0 7
19333: MINUS
19334: PUSH
19335: LD_INT 1
19337: PLUS
19338: PPUSH
19339: LD_VAR 0 9
19343: PUSH
19344: LD_VAR 0 7
19348: ARRAY
19349: PPUSH
19350: CALL_OW 1
19354: ST_TO_ADDR
19355: GO 19311
19357: POP
19358: POP
// end ; tmp := [ ] ;
19359: LD_ADDR_VAR 0 9
19363: PUSH
19364: EMPTY
19365: ST_TO_ADDR
// if mode then
19366: LD_VAR 0 5
19370: IFFALSE 19439
// begin for i = 1 to result do
19372: LD_ADDR_VAR 0 7
19376: PUSH
19377: DOUBLE
19378: LD_INT 1
19380: DEC
19381: ST_TO_ADDR
19382: LD_VAR 0 6
19386: PUSH
19387: FOR_TO
19388: IFFALSE 19427
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19390: LD_ADDR_VAR 0 9
19394: PUSH
19395: LD_VAR 0 9
19399: PPUSH
19400: LD_VAR 0 7
19404: PPUSH
19405: LD_VAR 0 6
19409: PUSH
19410: LD_VAR 0 7
19414: ARRAY
19415: PUSH
19416: LD_INT 1
19418: ARRAY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
19425: GO 19387
19427: POP
19428: POP
// result := tmp ;
19429: LD_ADDR_VAR 0 6
19433: PUSH
19434: LD_VAR 0 9
19438: ST_TO_ADDR
// end ; end ;
19439: LD_VAR 0 6
19443: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19444: LD_INT 0
19446: PPUSH
19447: PPUSH
19448: PPUSH
19449: PPUSH
19450: PPUSH
19451: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19452: LD_ADDR_VAR 0 5
19456: PUSH
19457: LD_INT 0
19459: PUSH
19460: LD_INT 0
19462: PUSH
19463: LD_INT 0
19465: PUSH
19466: EMPTY
19467: PUSH
19468: EMPTY
19469: LIST
19470: LIST
19471: LIST
19472: LIST
19473: ST_TO_ADDR
// if not x or not y then
19474: LD_VAR 0 2
19478: NOT
19479: PUSH
19480: LD_VAR 0 3
19484: NOT
19485: OR
19486: IFFALSE 19490
// exit ;
19488: GO 21136
// if not range then
19490: LD_VAR 0 4
19494: NOT
19495: IFFALSE 19505
// range := 10 ;
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_INT 10
19504: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19505: LD_ADDR_VAR 0 8
19509: PUSH
19510: LD_INT 81
19512: PUSH
19513: LD_VAR 0 1
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PUSH
19522: LD_INT 92
19524: PUSH
19525: LD_VAR 0 2
19529: PUSH
19530: LD_VAR 0 3
19534: PUSH
19535: LD_VAR 0 4
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: LIST
19544: LIST
19545: PUSH
19546: LD_INT 3
19548: PUSH
19549: LD_INT 21
19551: PUSH
19552: LD_INT 3
19554: PUSH
19555: EMPTY
19556: LIST
19557: LIST
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: LIST
19567: PPUSH
19568: CALL_OW 69
19572: ST_TO_ADDR
// if not tmp then
19573: LD_VAR 0 8
19577: NOT
19578: IFFALSE 19582
// exit ;
19580: GO 21136
// for i in tmp do
19582: LD_ADDR_VAR 0 6
19586: PUSH
19587: LD_VAR 0 8
19591: PUSH
19592: FOR_IN
19593: IFFALSE 21111
// begin points := [ 0 , 0 , 0 ] ;
19595: LD_ADDR_VAR 0 9
19599: PUSH
19600: LD_INT 0
19602: PUSH
19603: LD_INT 0
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: ST_TO_ADDR
// bpoints := 1 ;
19614: LD_ADDR_VAR 0 10
19618: PUSH
19619: LD_INT 1
19621: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19622: LD_VAR 0 6
19626: PPUSH
19627: CALL_OW 247
19631: PUSH
19632: LD_INT 1
19634: DOUBLE
19635: EQUAL
19636: IFTRUE 19640
19638: GO 20218
19640: POP
// begin if GetClass ( i ) = 1 then
19641: LD_VAR 0 6
19645: PPUSH
19646: CALL_OW 257
19650: PUSH
19651: LD_INT 1
19653: EQUAL
19654: IFFALSE 19675
// points := [ 10 , 5 , 3 ] ;
19656: LD_ADDR_VAR 0 9
19660: PUSH
19661: LD_INT 10
19663: PUSH
19664: LD_INT 5
19666: PUSH
19667: LD_INT 3
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19675: LD_VAR 0 6
19679: PPUSH
19680: CALL_OW 257
19684: PUSH
19685: LD_INT 2
19687: PUSH
19688: LD_INT 3
19690: PUSH
19691: LD_INT 4
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: IN
19699: IFFALSE 19720
// points := [ 3 , 2 , 1 ] ;
19701: LD_ADDR_VAR 0 9
19705: PUSH
19706: LD_INT 3
19708: PUSH
19709: LD_INT 2
19711: PUSH
19712: LD_INT 1
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19720: LD_VAR 0 6
19724: PPUSH
19725: CALL_OW 257
19729: PUSH
19730: LD_INT 5
19732: EQUAL
19733: IFFALSE 19754
// points := [ 130 , 5 , 2 ] ;
19735: LD_ADDR_VAR 0 9
19739: PUSH
19740: LD_INT 130
19742: PUSH
19743: LD_INT 5
19745: PUSH
19746: LD_INT 2
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: LIST
19753: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19754: LD_VAR 0 6
19758: PPUSH
19759: CALL_OW 257
19763: PUSH
19764: LD_INT 8
19766: EQUAL
19767: IFFALSE 19788
// points := [ 35 , 35 , 30 ] ;
19769: LD_ADDR_VAR 0 9
19773: PUSH
19774: LD_INT 35
19776: PUSH
19777: LD_INT 35
19779: PUSH
19780: LD_INT 30
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: LIST
19787: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19788: LD_VAR 0 6
19792: PPUSH
19793: CALL_OW 257
19797: PUSH
19798: LD_INT 9
19800: EQUAL
19801: IFFALSE 19822
// points := [ 20 , 55 , 40 ] ;
19803: LD_ADDR_VAR 0 9
19807: PUSH
19808: LD_INT 20
19810: PUSH
19811: LD_INT 55
19813: PUSH
19814: LD_INT 40
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19822: LD_VAR 0 6
19826: PPUSH
19827: CALL_OW 257
19831: PUSH
19832: LD_INT 12
19834: PUSH
19835: LD_INT 16
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: IN
19842: IFFALSE 19863
// points := [ 5 , 3 , 2 ] ;
19844: LD_ADDR_VAR 0 9
19848: PUSH
19849: LD_INT 5
19851: PUSH
19852: LD_INT 3
19854: PUSH
19855: LD_INT 2
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: LIST
19862: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19863: LD_VAR 0 6
19867: PPUSH
19868: CALL_OW 257
19872: PUSH
19873: LD_INT 17
19875: EQUAL
19876: IFFALSE 19897
// points := [ 100 , 50 , 75 ] ;
19878: LD_ADDR_VAR 0 9
19882: PUSH
19883: LD_INT 100
19885: PUSH
19886: LD_INT 50
19888: PUSH
19889: LD_INT 75
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: LIST
19896: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19897: LD_VAR 0 6
19901: PPUSH
19902: CALL_OW 257
19906: PUSH
19907: LD_INT 15
19909: EQUAL
19910: IFFALSE 19931
// points := [ 10 , 5 , 3 ] ;
19912: LD_ADDR_VAR 0 9
19916: PUSH
19917: LD_INT 10
19919: PUSH
19920: LD_INT 5
19922: PUSH
19923: LD_INT 3
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: LIST
19930: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19931: LD_VAR 0 6
19935: PPUSH
19936: CALL_OW 257
19940: PUSH
19941: LD_INT 14
19943: EQUAL
19944: IFFALSE 19965
// points := [ 10 , 0 , 0 ] ;
19946: LD_ADDR_VAR 0 9
19950: PUSH
19951: LD_INT 10
19953: PUSH
19954: LD_INT 0
19956: PUSH
19957: LD_INT 0
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19965: LD_VAR 0 6
19969: PPUSH
19970: CALL_OW 257
19974: PUSH
19975: LD_INT 11
19977: EQUAL
19978: IFFALSE 19999
// points := [ 30 , 10 , 5 ] ;
19980: LD_ADDR_VAR 0 9
19984: PUSH
19985: LD_INT 30
19987: PUSH
19988: LD_INT 10
19990: PUSH
19991: LD_INT 5
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19999: LD_VAR 0 1
20003: PPUSH
20004: LD_INT 5
20006: PPUSH
20007: CALL_OW 321
20011: PUSH
20012: LD_INT 2
20014: EQUAL
20015: IFFALSE 20032
// bpoints := bpoints * 1.8 ;
20017: LD_ADDR_VAR 0 10
20021: PUSH
20022: LD_VAR 0 10
20026: PUSH
20027: LD_REAL  1.80000000000000E+0000
20030: MUL
20031: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20032: LD_VAR 0 6
20036: PPUSH
20037: CALL_OW 257
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: LD_INT 3
20050: PUSH
20051: LD_INT 4
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: LIST
20058: LIST
20059: IN
20060: PUSH
20061: LD_VAR 0 1
20065: PPUSH
20066: LD_INT 51
20068: PPUSH
20069: CALL_OW 321
20073: PUSH
20074: LD_INT 2
20076: EQUAL
20077: AND
20078: IFFALSE 20095
// bpoints := bpoints * 1.2 ;
20080: LD_ADDR_VAR 0 10
20084: PUSH
20085: LD_VAR 0 10
20089: PUSH
20090: LD_REAL  1.20000000000000E+0000
20093: MUL
20094: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20095: LD_VAR 0 6
20099: PPUSH
20100: CALL_OW 257
20104: PUSH
20105: LD_INT 5
20107: PUSH
20108: LD_INT 7
20110: PUSH
20111: LD_INT 9
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: LIST
20118: IN
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: LD_INT 52
20127: PPUSH
20128: CALL_OW 321
20132: PUSH
20133: LD_INT 2
20135: EQUAL
20136: AND
20137: IFFALSE 20154
// bpoints := bpoints * 1.5 ;
20139: LD_ADDR_VAR 0 10
20143: PUSH
20144: LD_VAR 0 10
20148: PUSH
20149: LD_REAL  1.50000000000000E+0000
20152: MUL
20153: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20154: LD_VAR 0 1
20158: PPUSH
20159: LD_INT 66
20161: PPUSH
20162: CALL_OW 321
20166: PUSH
20167: LD_INT 2
20169: EQUAL
20170: IFFALSE 20187
// bpoints := bpoints * 1.1 ;
20172: LD_ADDR_VAR 0 10
20176: PUSH
20177: LD_VAR 0 10
20181: PUSH
20182: LD_REAL  1.10000000000000E+0000
20185: MUL
20186: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20187: LD_ADDR_VAR 0 10
20191: PUSH
20192: LD_VAR 0 10
20196: PUSH
20197: LD_VAR 0 6
20201: PPUSH
20202: LD_INT 1
20204: PPUSH
20205: CALL_OW 259
20209: PUSH
20210: LD_REAL  1.15000000000000E+0000
20213: MUL
20214: MUL
20215: ST_TO_ADDR
// end ; unit_vehicle :
20216: GO 21040
20218: LD_INT 2
20220: DOUBLE
20221: EQUAL
20222: IFTRUE 20226
20224: GO 21028
20226: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20227: LD_VAR 0 6
20231: PPUSH
20232: CALL_OW 264
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 42
20242: PUSH
20243: LD_INT 24
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: LIST
20250: IN
20251: IFFALSE 20272
// points := [ 25 , 5 , 3 ] ;
20253: LD_ADDR_VAR 0 9
20257: PUSH
20258: LD_INT 25
20260: PUSH
20261: LD_INT 5
20263: PUSH
20264: LD_INT 3
20266: PUSH
20267: EMPTY
20268: LIST
20269: LIST
20270: LIST
20271: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20272: LD_VAR 0 6
20276: PPUSH
20277: CALL_OW 264
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 43
20287: PUSH
20288: LD_INT 25
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: IN
20296: IFFALSE 20317
// points := [ 40 , 15 , 5 ] ;
20298: LD_ADDR_VAR 0 9
20302: PUSH
20303: LD_INT 40
20305: PUSH
20306: LD_INT 15
20308: PUSH
20309: LD_INT 5
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20317: LD_VAR 0 6
20321: PPUSH
20322: CALL_OW 264
20326: PUSH
20327: LD_INT 3
20329: PUSH
20330: LD_INT 23
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: IN
20337: IFFALSE 20358
// points := [ 7 , 25 , 8 ] ;
20339: LD_ADDR_VAR 0 9
20343: PUSH
20344: LD_INT 7
20346: PUSH
20347: LD_INT 25
20349: PUSH
20350: LD_INT 8
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: LIST
20357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20358: LD_VAR 0 6
20362: PPUSH
20363: CALL_OW 264
20367: PUSH
20368: LD_INT 5
20370: PUSH
20371: LD_INT 27
20373: PUSH
20374: LD_INT 44
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: LIST
20381: IN
20382: IFFALSE 20403
// points := [ 14 , 50 , 16 ] ;
20384: LD_ADDR_VAR 0 9
20388: PUSH
20389: LD_INT 14
20391: PUSH
20392: LD_INT 50
20394: PUSH
20395: LD_INT 16
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20403: LD_VAR 0 6
20407: PPUSH
20408: CALL_OW 264
20412: PUSH
20413: LD_INT 6
20415: PUSH
20416: LD_INT 46
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: IN
20423: IFFALSE 20444
// points := [ 32 , 120 , 70 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 32
20432: PUSH
20433: LD_INT 120
20435: PUSH
20436: LD_INT 70
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 264
20453: PUSH
20454: LD_INT 7
20456: PUSH
20457: LD_INT 28
20459: PUSH
20460: LD_INT 45
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: IN
20468: IFFALSE 20489
// points := [ 35 , 20 , 45 ] ;
20470: LD_ADDR_VAR 0 9
20474: PUSH
20475: LD_INT 35
20477: PUSH
20478: LD_INT 20
20480: PUSH
20481: LD_INT 45
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20489: LD_VAR 0 6
20493: PPUSH
20494: CALL_OW 264
20498: PUSH
20499: LD_INT 47
20501: PUSH
20502: EMPTY
20503: LIST
20504: IN
20505: IFFALSE 20526
// points := [ 67 , 45 , 75 ] ;
20507: LD_ADDR_VAR 0 9
20511: PUSH
20512: LD_INT 67
20514: PUSH
20515: LD_INT 45
20517: PUSH
20518: LD_INT 75
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20526: LD_VAR 0 6
20530: PPUSH
20531: CALL_OW 264
20535: PUSH
20536: LD_INT 26
20538: PUSH
20539: EMPTY
20540: LIST
20541: IN
20542: IFFALSE 20563
// points := [ 120 , 30 , 80 ] ;
20544: LD_ADDR_VAR 0 9
20548: PUSH
20549: LD_INT 120
20551: PUSH
20552: LD_INT 30
20554: PUSH
20555: LD_INT 80
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: LIST
20562: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 264
20572: PUSH
20573: LD_INT 22
20575: PUSH
20576: EMPTY
20577: LIST
20578: IN
20579: IFFALSE 20600
// points := [ 40 , 1 , 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 40
20588: PUSH
20589: LD_INT 1
20591: PUSH
20592: LD_INT 1
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20600: LD_VAR 0 6
20604: PPUSH
20605: CALL_OW 264
20609: PUSH
20610: LD_INT 29
20612: PUSH
20613: EMPTY
20614: LIST
20615: IN
20616: IFFALSE 20637
// points := [ 70 , 200 , 400 ] ;
20618: LD_ADDR_VAR 0 9
20622: PUSH
20623: LD_INT 70
20625: PUSH
20626: LD_INT 200
20628: PUSH
20629: LD_INT 400
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20637: LD_VAR 0 6
20641: PPUSH
20642: CALL_OW 264
20646: PUSH
20647: LD_INT 14
20649: PUSH
20650: LD_INT 53
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: IN
20657: IFFALSE 20678
// points := [ 40 , 10 , 20 ] ;
20659: LD_ADDR_VAR 0 9
20663: PUSH
20664: LD_INT 40
20666: PUSH
20667: LD_INT 10
20669: PUSH
20670: LD_INT 20
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20678: LD_VAR 0 6
20682: PPUSH
20683: CALL_OW 264
20687: PUSH
20688: LD_INT 9
20690: PUSH
20691: EMPTY
20692: LIST
20693: IN
20694: IFFALSE 20715
// points := [ 5 , 70 , 20 ] ;
20696: LD_ADDR_VAR 0 9
20700: PUSH
20701: LD_INT 5
20703: PUSH
20704: LD_INT 70
20706: PUSH
20707: LD_INT 20
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: LIST
20714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20715: LD_VAR 0 6
20719: PPUSH
20720: CALL_OW 264
20724: PUSH
20725: LD_INT 10
20727: PUSH
20728: EMPTY
20729: LIST
20730: IN
20731: IFFALSE 20752
// points := [ 35 , 110 , 70 ] ;
20733: LD_ADDR_VAR 0 9
20737: PUSH
20738: LD_INT 35
20740: PUSH
20741: LD_INT 110
20743: PUSH
20744: LD_INT 70
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20752: LD_VAR 0 6
20756: PPUSH
20757: CALL_OW 265
20761: PUSH
20762: LD_INT 25
20764: EQUAL
20765: IFFALSE 20786
// points := [ 80 , 65 , 100 ] ;
20767: LD_ADDR_VAR 0 9
20771: PUSH
20772: LD_INT 80
20774: PUSH
20775: LD_INT 65
20777: PUSH
20778: LD_INT 100
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20786: LD_VAR 0 6
20790: PPUSH
20791: CALL_OW 263
20795: PUSH
20796: LD_INT 1
20798: EQUAL
20799: IFFALSE 20834
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20801: LD_ADDR_VAR 0 10
20805: PUSH
20806: LD_VAR 0 10
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: CALL_OW 311
20820: PPUSH
20821: LD_INT 3
20823: PPUSH
20824: CALL_OW 259
20828: PUSH
20829: LD_INT 4
20831: MUL
20832: MUL
20833: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20834: LD_VAR 0 6
20838: PPUSH
20839: CALL_OW 263
20843: PUSH
20844: LD_INT 2
20846: EQUAL
20847: IFFALSE 20898
// begin j := IsControledBy ( i ) ;
20849: LD_ADDR_VAR 0 7
20853: PUSH
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 312
20863: ST_TO_ADDR
// if j then
20864: LD_VAR 0 7
20868: IFFALSE 20898
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20870: LD_ADDR_VAR 0 10
20874: PUSH
20875: LD_VAR 0 10
20879: PUSH
20880: LD_VAR 0 7
20884: PPUSH
20885: LD_INT 3
20887: PPUSH
20888: CALL_OW 259
20892: PUSH
20893: LD_INT 3
20895: MUL
20896: MUL
20897: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20898: LD_VAR 0 6
20902: PPUSH
20903: CALL_OW 264
20907: PUSH
20908: LD_INT 5
20910: PUSH
20911: LD_INT 6
20913: PUSH
20914: LD_INT 46
20916: PUSH
20917: LD_INT 44
20919: PUSH
20920: LD_INT 47
20922: PUSH
20923: LD_INT 45
20925: PUSH
20926: LD_INT 28
20928: PUSH
20929: LD_INT 7
20931: PUSH
20932: LD_INT 27
20934: PUSH
20935: LD_INT 29
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: LIST
20942: LIST
20943: LIST
20944: LIST
20945: LIST
20946: LIST
20947: LIST
20948: LIST
20949: IN
20950: PUSH
20951: LD_VAR 0 1
20955: PPUSH
20956: LD_INT 52
20958: PPUSH
20959: CALL_OW 321
20963: PUSH
20964: LD_INT 2
20966: EQUAL
20967: AND
20968: IFFALSE 20985
// bpoints := bpoints * 1.2 ;
20970: LD_ADDR_VAR 0 10
20974: PUSH
20975: LD_VAR 0 10
20979: PUSH
20980: LD_REAL  1.20000000000000E+0000
20983: MUL
20984: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20985: LD_VAR 0 6
20989: PPUSH
20990: CALL_OW 264
20994: PUSH
20995: LD_INT 6
20997: PUSH
20998: LD_INT 46
21000: PUSH
21001: LD_INT 47
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: LIST
21008: IN
21009: IFFALSE 21026
// bpoints := bpoints * 1.2 ;
21011: LD_ADDR_VAR 0 10
21015: PUSH
21016: LD_VAR 0 10
21020: PUSH
21021: LD_REAL  1.20000000000000E+0000
21024: MUL
21025: ST_TO_ADDR
// end ; unit_building :
21026: GO 21040
21028: LD_INT 3
21030: DOUBLE
21031: EQUAL
21032: IFTRUE 21036
21034: GO 21039
21036: POP
// ; end ;
21037: GO 21040
21039: POP
// for j = 1 to 3 do
21040: LD_ADDR_VAR 0 7
21044: PUSH
21045: DOUBLE
21046: LD_INT 1
21048: DEC
21049: ST_TO_ADDR
21050: LD_INT 3
21052: PUSH
21053: FOR_TO
21054: IFFALSE 21107
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21056: LD_ADDR_VAR 0 5
21060: PUSH
21061: LD_VAR 0 5
21065: PPUSH
21066: LD_VAR 0 7
21070: PPUSH
21071: LD_VAR 0 5
21075: PUSH
21076: LD_VAR 0 7
21080: ARRAY
21081: PUSH
21082: LD_VAR 0 9
21086: PUSH
21087: LD_VAR 0 7
21091: ARRAY
21092: PUSH
21093: LD_VAR 0 10
21097: MUL
21098: PLUS
21099: PPUSH
21100: CALL_OW 1
21104: ST_TO_ADDR
21105: GO 21053
21107: POP
21108: POP
// end ;
21109: GO 19592
21111: POP
21112: POP
// result := Replace ( result , 4 , tmp ) ;
21113: LD_ADDR_VAR 0 5
21117: PUSH
21118: LD_VAR 0 5
21122: PPUSH
21123: LD_INT 4
21125: PPUSH
21126: LD_VAR 0 8
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
// end ;
21136: LD_VAR 0 5
21140: RET
// export function DangerAtRange ( unit , range ) ; begin
21141: LD_INT 0
21143: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21144: LD_ADDR_VAR 0 3
21148: PUSH
21149: LD_VAR 0 1
21153: PPUSH
21154: CALL_OW 255
21158: PPUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: CALL_OW 250
21168: PPUSH
21169: LD_VAR 0 1
21173: PPUSH
21174: CALL_OW 251
21178: PPUSH
21179: LD_VAR 0 2
21183: PPUSH
21184: CALL 19444 0 4
21188: ST_TO_ADDR
// end ;
21189: LD_VAR 0 3
21193: RET
// export function DangerInArea ( side , area ) ; begin
21194: LD_INT 0
21196: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21197: LD_ADDR_VAR 0 3
21201: PUSH
21202: LD_VAR 0 2
21206: PPUSH
21207: LD_INT 81
21209: PUSH
21210: LD_VAR 0 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PPUSH
21219: CALL_OW 70
21223: ST_TO_ADDR
// end ;
21224: LD_VAR 0 3
21228: RET
// export function IsExtension ( b ) ; begin
21229: LD_INT 0
21231: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21232: LD_ADDR_VAR 0 2
21236: PUSH
21237: LD_VAR 0 1
21241: PUSH
21242: LD_INT 23
21244: PUSH
21245: LD_INT 20
21247: PUSH
21248: LD_INT 22
21250: PUSH
21251: LD_INT 17
21253: PUSH
21254: LD_INT 24
21256: PUSH
21257: LD_INT 21
21259: PUSH
21260: LD_INT 19
21262: PUSH
21263: LD_INT 16
21265: PUSH
21266: LD_INT 25
21268: PUSH
21269: LD_INT 18
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: LIST
21283: IN
21284: ST_TO_ADDR
// end ;
21285: LD_VAR 0 2
21289: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21290: LD_INT 0
21292: PPUSH
21293: PPUSH
21294: PPUSH
// result := [ ] ;
21295: LD_ADDR_VAR 0 4
21299: PUSH
21300: EMPTY
21301: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21302: LD_ADDR_VAR 0 5
21306: PUSH
21307: LD_VAR 0 2
21311: PPUSH
21312: LD_INT 21
21314: PUSH
21315: LD_INT 3
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: PPUSH
21322: CALL_OW 70
21326: ST_TO_ADDR
// if not tmp then
21327: LD_VAR 0 5
21331: NOT
21332: IFFALSE 21336
// exit ;
21334: GO 21400
// if checkLink then
21336: LD_VAR 0 3
21340: IFFALSE 21390
// begin for i in tmp do
21342: LD_ADDR_VAR 0 6
21346: PUSH
21347: LD_VAR 0 5
21351: PUSH
21352: FOR_IN
21353: IFFALSE 21388
// if GetBase ( i ) <> base then
21355: LD_VAR 0 6
21359: PPUSH
21360: CALL_OW 274
21364: PUSH
21365: LD_VAR 0 1
21369: NONEQUAL
21370: IFFALSE 21386
// ComLinkToBase ( base , i ) ;
21372: LD_VAR 0 1
21376: PPUSH
21377: LD_VAR 0 6
21381: PPUSH
21382: CALL_OW 169
21386: GO 21352
21388: POP
21389: POP
// end ; result := tmp ;
21390: LD_ADDR_VAR 0 4
21394: PUSH
21395: LD_VAR 0 5
21399: ST_TO_ADDR
// end ;
21400: LD_VAR 0 4
21404: RET
// export function ComComplete ( units , b ) ; var i ; begin
21405: LD_INT 0
21407: PPUSH
21408: PPUSH
// if not units then
21409: LD_VAR 0 1
21413: NOT
21414: IFFALSE 21418
// exit ;
21416: GO 21508
// for i in units do
21418: LD_ADDR_VAR 0 4
21422: PUSH
21423: LD_VAR 0 1
21427: PUSH
21428: FOR_IN
21429: IFFALSE 21506
// if BuildingStatus ( b ) = bs_build then
21431: LD_VAR 0 2
21435: PPUSH
21436: CALL_OW 461
21440: PUSH
21441: LD_INT 1
21443: EQUAL
21444: IFFALSE 21504
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21446: LD_VAR 0 4
21450: PPUSH
21451: LD_STRING h
21453: PUSH
21454: LD_VAR 0 2
21458: PPUSH
21459: CALL_OW 250
21463: PUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: CALL_OW 251
21473: PUSH
21474: LD_VAR 0 2
21478: PUSH
21479: LD_INT 0
21481: PUSH
21482: LD_INT 0
21484: PUSH
21485: LD_INT 0
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: LIST
21492: LIST
21493: LIST
21494: LIST
21495: LIST
21496: PUSH
21497: EMPTY
21498: LIST
21499: PPUSH
21500: CALL_OW 446
21504: GO 21428
21506: POP
21507: POP
// end ;
21508: LD_VAR 0 3
21512: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21513: LD_INT 0
21515: PPUSH
21516: PPUSH
21517: PPUSH
21518: PPUSH
21519: PPUSH
21520: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21521: LD_VAR 0 1
21525: NOT
21526: PUSH
21527: LD_VAR 0 1
21531: PPUSH
21532: CALL_OW 263
21536: PUSH
21537: LD_INT 2
21539: EQUAL
21540: NOT
21541: OR
21542: IFFALSE 21546
// exit ;
21544: GO 21862
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_INT 22
21553: PUSH
21554: LD_VAR 0 1
21558: PPUSH
21559: CALL_OW 255
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PUSH
21568: LD_INT 2
21570: PUSH
21571: LD_INT 30
21573: PUSH
21574: LD_INT 36
21576: PUSH
21577: EMPTY
21578: LIST
21579: LIST
21580: PUSH
21581: LD_INT 34
21583: PUSH
21584: LD_INT 31
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: LIST
21595: PUSH
21596: EMPTY
21597: LIST
21598: LIST
21599: PPUSH
21600: CALL_OW 69
21604: ST_TO_ADDR
// if not tmp then
21605: LD_VAR 0 6
21609: NOT
21610: IFFALSE 21614
// exit ;
21612: GO 21862
// result := [ ] ;
21614: LD_ADDR_VAR 0 2
21618: PUSH
21619: EMPTY
21620: ST_TO_ADDR
// for i in tmp do
21621: LD_ADDR_VAR 0 3
21625: PUSH
21626: LD_VAR 0 6
21630: PUSH
21631: FOR_IN
21632: IFFALSE 21703
// begin t := UnitsInside ( i ) ;
21634: LD_ADDR_VAR 0 4
21638: PUSH
21639: LD_VAR 0 3
21643: PPUSH
21644: CALL_OW 313
21648: ST_TO_ADDR
// if t then
21649: LD_VAR 0 4
21653: IFFALSE 21701
// for j in t do
21655: LD_ADDR_VAR 0 7
21659: PUSH
21660: LD_VAR 0 4
21664: PUSH
21665: FOR_IN
21666: IFFALSE 21699
// result := Insert ( result , result + 1 , j ) ;
21668: LD_ADDR_VAR 0 2
21672: PUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: LD_VAR 0 2
21682: PUSH
21683: LD_INT 1
21685: PLUS
21686: PPUSH
21687: LD_VAR 0 7
21691: PPUSH
21692: CALL_OW 2
21696: ST_TO_ADDR
21697: GO 21665
21699: POP
21700: POP
// end ;
21701: GO 21631
21703: POP
21704: POP
// if not result then
21705: LD_VAR 0 2
21709: NOT
21710: IFFALSE 21714
// exit ;
21712: GO 21862
// mech := result [ 1 ] ;
21714: LD_ADDR_VAR 0 5
21718: PUSH
21719: LD_VAR 0 2
21723: PUSH
21724: LD_INT 1
21726: ARRAY
21727: ST_TO_ADDR
// if result > 1 then
21728: LD_VAR 0 2
21732: PUSH
21733: LD_INT 1
21735: GREATER
21736: IFFALSE 21848
// for i = 2 to result do
21738: LD_ADDR_VAR 0 3
21742: PUSH
21743: DOUBLE
21744: LD_INT 2
21746: DEC
21747: ST_TO_ADDR
21748: LD_VAR 0 2
21752: PUSH
21753: FOR_TO
21754: IFFALSE 21846
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21756: LD_ADDR_VAR 0 4
21760: PUSH
21761: LD_VAR 0 2
21765: PUSH
21766: LD_VAR 0 3
21770: ARRAY
21771: PPUSH
21772: LD_INT 3
21774: PPUSH
21775: CALL_OW 259
21779: PUSH
21780: LD_VAR 0 2
21784: PUSH
21785: LD_VAR 0 3
21789: ARRAY
21790: PPUSH
21791: CALL_OW 432
21795: MINUS
21796: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21797: LD_VAR 0 4
21801: PUSH
21802: LD_VAR 0 5
21806: PPUSH
21807: LD_INT 3
21809: PPUSH
21810: CALL_OW 259
21814: PUSH
21815: LD_VAR 0 5
21819: PPUSH
21820: CALL_OW 432
21824: MINUS
21825: GREATEREQUAL
21826: IFFALSE 21844
// mech := result [ i ] ;
21828: LD_ADDR_VAR 0 5
21832: PUSH
21833: LD_VAR 0 2
21837: PUSH
21838: LD_VAR 0 3
21842: ARRAY
21843: ST_TO_ADDR
// end ;
21844: GO 21753
21846: POP
21847: POP
// ComLinkTo ( vehicle , mech ) ;
21848: LD_VAR 0 1
21852: PPUSH
21853: LD_VAR 0 5
21857: PPUSH
21858: CALL_OW 135
// end ;
21862: LD_VAR 0 2
21866: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21867: LD_INT 0
21869: PPUSH
21870: PPUSH
21871: PPUSH
21872: PPUSH
21873: PPUSH
21874: PPUSH
21875: PPUSH
21876: PPUSH
21877: PPUSH
21878: PPUSH
21879: PPUSH
21880: PPUSH
21881: PPUSH
// result := [ ] ;
21882: LD_ADDR_VAR 0 7
21886: PUSH
21887: EMPTY
21888: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21889: LD_VAR 0 1
21893: PPUSH
21894: CALL_OW 266
21898: PUSH
21899: LD_INT 0
21901: PUSH
21902: LD_INT 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: IN
21909: NOT
21910: IFFALSE 21914
// exit ;
21912: GO 23548
// if name then
21914: LD_VAR 0 3
21918: IFFALSE 21934
// SetBName ( base_dep , name ) ;
21920: LD_VAR 0 1
21924: PPUSH
21925: LD_VAR 0 3
21929: PPUSH
21930: CALL_OW 500
// base := GetBase ( base_dep ) ;
21934: LD_ADDR_VAR 0 15
21938: PUSH
21939: LD_VAR 0 1
21943: PPUSH
21944: CALL_OW 274
21948: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21949: LD_ADDR_VAR 0 16
21953: PUSH
21954: LD_VAR 0 1
21958: PPUSH
21959: CALL_OW 255
21963: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21964: LD_ADDR_VAR 0 17
21968: PUSH
21969: LD_VAR 0 1
21973: PPUSH
21974: CALL_OW 248
21978: ST_TO_ADDR
// if sources then
21979: LD_VAR 0 5
21983: IFFALSE 22030
// for i = 1 to 3 do
21985: LD_ADDR_VAR 0 8
21989: PUSH
21990: DOUBLE
21991: LD_INT 1
21993: DEC
21994: ST_TO_ADDR
21995: LD_INT 3
21997: PUSH
21998: FOR_TO
21999: IFFALSE 22028
// AddResourceType ( base , i , sources [ i ] ) ;
22001: LD_VAR 0 15
22005: PPUSH
22006: LD_VAR 0 8
22010: PPUSH
22011: LD_VAR 0 5
22015: PUSH
22016: LD_VAR 0 8
22020: ARRAY
22021: PPUSH
22022: CALL_OW 276
22026: GO 21998
22028: POP
22029: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22030: LD_ADDR_VAR 0 18
22034: PUSH
22035: LD_VAR 0 15
22039: PPUSH
22040: LD_VAR 0 2
22044: PPUSH
22045: LD_INT 1
22047: PPUSH
22048: CALL 21290 0 3
22052: ST_TO_ADDR
// InitHc ;
22053: CALL_OW 19
// InitUc ;
22057: CALL_OW 18
// uc_side := side ;
22061: LD_ADDR_OWVAR 20
22065: PUSH
22066: LD_VAR 0 16
22070: ST_TO_ADDR
// uc_nation := nation ;
22071: LD_ADDR_OWVAR 21
22075: PUSH
22076: LD_VAR 0 17
22080: ST_TO_ADDR
// if buildings then
22081: LD_VAR 0 18
22085: IFFALSE 23407
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22087: LD_ADDR_VAR 0 19
22091: PUSH
22092: LD_VAR 0 18
22096: PPUSH
22097: LD_INT 2
22099: PUSH
22100: LD_INT 30
22102: PUSH
22103: LD_INT 29
22105: PUSH
22106: EMPTY
22107: LIST
22108: LIST
22109: PUSH
22110: LD_INT 30
22112: PUSH
22113: LD_INT 30
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: PPUSH
22125: CALL_OW 72
22129: ST_TO_ADDR
// if tmp then
22130: LD_VAR 0 19
22134: IFFALSE 22182
// for i in tmp do
22136: LD_ADDR_VAR 0 8
22140: PUSH
22141: LD_VAR 0 19
22145: PUSH
22146: FOR_IN
22147: IFFALSE 22180
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22149: LD_VAR 0 8
22153: PPUSH
22154: CALL_OW 250
22158: PPUSH
22159: LD_VAR 0 8
22163: PPUSH
22164: CALL_OW 251
22168: PPUSH
22169: LD_VAR 0 16
22173: PPUSH
22174: CALL_OW 441
22178: GO 22146
22180: POP
22181: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22182: LD_VAR 0 18
22186: PPUSH
22187: LD_INT 2
22189: PUSH
22190: LD_INT 30
22192: PUSH
22193: LD_INT 32
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: LD_INT 30
22202: PUSH
22203: LD_INT 33
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: PPUSH
22215: CALL_OW 72
22219: IFFALSE 22307
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22221: LD_ADDR_VAR 0 8
22225: PUSH
22226: LD_VAR 0 18
22230: PPUSH
22231: LD_INT 2
22233: PUSH
22234: LD_INT 30
22236: PUSH
22237: LD_INT 32
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 30
22246: PUSH
22247: LD_INT 33
22249: PUSH
22250: EMPTY
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: LIST
22258: PPUSH
22259: CALL_OW 72
22263: PUSH
22264: FOR_IN
22265: IFFALSE 22305
// begin if not GetBWeapon ( i ) then
22267: LD_VAR 0 8
22271: PPUSH
22272: CALL_OW 269
22276: NOT
22277: IFFALSE 22303
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22279: LD_VAR 0 8
22283: PPUSH
22284: LD_VAR 0 8
22288: PPUSH
22289: LD_VAR 0 2
22293: PPUSH
22294: CALL 23553 0 2
22298: PPUSH
22299: CALL_OW 431
// end ;
22303: GO 22264
22305: POP
22306: POP
// end ; for i = 1 to personel do
22307: LD_ADDR_VAR 0 8
22311: PUSH
22312: DOUBLE
22313: LD_INT 1
22315: DEC
22316: ST_TO_ADDR
22317: LD_VAR 0 6
22321: PUSH
22322: FOR_TO
22323: IFFALSE 23387
// begin if i > 4 then
22325: LD_VAR 0 8
22329: PUSH
22330: LD_INT 4
22332: GREATER
22333: IFFALSE 22337
// break ;
22335: GO 23387
// case i of 1 :
22337: LD_VAR 0 8
22341: PUSH
22342: LD_INT 1
22344: DOUBLE
22345: EQUAL
22346: IFTRUE 22350
22348: GO 22430
22350: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22351: LD_ADDR_VAR 0 12
22355: PUSH
22356: LD_VAR 0 18
22360: PPUSH
22361: LD_INT 22
22363: PUSH
22364: LD_VAR 0 16
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: PUSH
22373: LD_INT 58
22375: PUSH
22376: EMPTY
22377: LIST
22378: PUSH
22379: LD_INT 2
22381: PUSH
22382: LD_INT 30
22384: PUSH
22385: LD_INT 32
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: PUSH
22392: LD_INT 30
22394: PUSH
22395: LD_INT 4
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: PUSH
22402: LD_INT 30
22404: PUSH
22405: LD_INT 5
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: LIST
22416: LIST
22417: PUSH
22418: EMPTY
22419: LIST
22420: LIST
22421: LIST
22422: PPUSH
22423: CALL_OW 72
22427: ST_TO_ADDR
22428: GO 22652
22430: LD_INT 2
22432: DOUBLE
22433: EQUAL
22434: IFTRUE 22438
22436: GO 22500
22438: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22439: LD_ADDR_VAR 0 12
22443: PUSH
22444: LD_VAR 0 18
22448: PPUSH
22449: LD_INT 22
22451: PUSH
22452: LD_VAR 0 16
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 2
22463: PUSH
22464: LD_INT 30
22466: PUSH
22467: LD_INT 0
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: PUSH
22474: LD_INT 30
22476: PUSH
22477: LD_INT 1
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: PUSH
22484: EMPTY
22485: LIST
22486: LIST
22487: LIST
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: PPUSH
22493: CALL_OW 72
22497: ST_TO_ADDR
22498: GO 22652
22500: LD_INT 3
22502: DOUBLE
22503: EQUAL
22504: IFTRUE 22508
22506: GO 22570
22508: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22509: LD_ADDR_VAR 0 12
22513: PUSH
22514: LD_VAR 0 18
22518: PPUSH
22519: LD_INT 22
22521: PUSH
22522: LD_VAR 0 16
22526: PUSH
22527: EMPTY
22528: LIST
22529: LIST
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: LD_INT 30
22536: PUSH
22537: LD_INT 2
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: PUSH
22544: LD_INT 30
22546: PUSH
22547: LD_INT 3
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: PUSH
22554: EMPTY
22555: LIST
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 72
22567: ST_TO_ADDR
22568: GO 22652
22570: LD_INT 4
22572: DOUBLE
22573: EQUAL
22574: IFTRUE 22578
22576: GO 22651
22578: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22579: LD_ADDR_VAR 0 12
22583: PUSH
22584: LD_VAR 0 18
22588: PPUSH
22589: LD_INT 22
22591: PUSH
22592: LD_VAR 0 16
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: PUSH
22601: LD_INT 2
22603: PUSH
22604: LD_INT 30
22606: PUSH
22607: LD_INT 6
22609: PUSH
22610: EMPTY
22611: LIST
22612: LIST
22613: PUSH
22614: LD_INT 30
22616: PUSH
22617: LD_INT 7
22619: PUSH
22620: EMPTY
22621: LIST
22622: LIST
22623: PUSH
22624: LD_INT 30
22626: PUSH
22627: LD_INT 8
22629: PUSH
22630: EMPTY
22631: LIST
22632: LIST
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: LIST
22638: LIST
22639: PUSH
22640: EMPTY
22641: LIST
22642: LIST
22643: PPUSH
22644: CALL_OW 72
22648: ST_TO_ADDR
22649: GO 22652
22651: POP
// if i = 1 then
22652: LD_VAR 0 8
22656: PUSH
22657: LD_INT 1
22659: EQUAL
22660: IFFALSE 22771
// begin tmp := [ ] ;
22662: LD_ADDR_VAR 0 19
22666: PUSH
22667: EMPTY
22668: ST_TO_ADDR
// for j in f do
22669: LD_ADDR_VAR 0 9
22673: PUSH
22674: LD_VAR 0 12
22678: PUSH
22679: FOR_IN
22680: IFFALSE 22753
// if GetBType ( j ) = b_bunker then
22682: LD_VAR 0 9
22686: PPUSH
22687: CALL_OW 266
22691: PUSH
22692: LD_INT 32
22694: EQUAL
22695: IFFALSE 22722
// tmp := Insert ( tmp , 1 , j ) else
22697: LD_ADDR_VAR 0 19
22701: PUSH
22702: LD_VAR 0 19
22706: PPUSH
22707: LD_INT 1
22709: PPUSH
22710: LD_VAR 0 9
22714: PPUSH
22715: CALL_OW 2
22719: ST_TO_ADDR
22720: GO 22751
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22722: LD_ADDR_VAR 0 19
22726: PUSH
22727: LD_VAR 0 19
22731: PPUSH
22732: LD_VAR 0 19
22736: PUSH
22737: LD_INT 1
22739: PLUS
22740: PPUSH
22741: LD_VAR 0 9
22745: PPUSH
22746: CALL_OW 2
22750: ST_TO_ADDR
22751: GO 22679
22753: POP
22754: POP
// if tmp then
22755: LD_VAR 0 19
22759: IFFALSE 22771
// f := tmp ;
22761: LD_ADDR_VAR 0 12
22765: PUSH
22766: LD_VAR 0 19
22770: ST_TO_ADDR
// end ; x := personel [ i ] ;
22771: LD_ADDR_VAR 0 13
22775: PUSH
22776: LD_VAR 0 6
22780: PUSH
22781: LD_VAR 0 8
22785: ARRAY
22786: ST_TO_ADDR
// if x = - 1 then
22787: LD_VAR 0 13
22791: PUSH
22792: LD_INT 1
22794: NEG
22795: EQUAL
22796: IFFALSE 23005
// begin for j in f do
22798: LD_ADDR_VAR 0 9
22802: PUSH
22803: LD_VAR 0 12
22807: PUSH
22808: FOR_IN
22809: IFFALSE 23001
// repeat InitHc ;
22811: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22815: LD_VAR 0 9
22819: PPUSH
22820: CALL_OW 266
22824: PUSH
22825: LD_INT 5
22827: EQUAL
22828: IFFALSE 22898
// begin if UnitsInside ( j ) < 3 then
22830: LD_VAR 0 9
22834: PPUSH
22835: CALL_OW 313
22839: PUSH
22840: LD_INT 3
22842: LESS
22843: IFFALSE 22879
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22845: LD_INT 0
22847: PPUSH
22848: LD_INT 5
22850: PUSH
22851: LD_INT 8
22853: PUSH
22854: LD_INT 9
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: PUSH
22862: LD_VAR 0 17
22866: ARRAY
22867: PPUSH
22868: LD_VAR 0 4
22872: PPUSH
22873: CALL_OW 380
22877: GO 22896
// PrepareHuman ( false , i , skill ) ;
22879: LD_INT 0
22881: PPUSH
22882: LD_VAR 0 8
22886: PPUSH
22887: LD_VAR 0 4
22891: PPUSH
22892: CALL_OW 380
// end else
22896: GO 22915
// PrepareHuman ( false , i , skill ) ;
22898: LD_INT 0
22900: PPUSH
22901: LD_VAR 0 8
22905: PPUSH
22906: LD_VAR 0 4
22910: PPUSH
22911: CALL_OW 380
// un := CreateHuman ;
22915: LD_ADDR_VAR 0 14
22919: PUSH
22920: CALL_OW 44
22924: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22925: LD_ADDR_VAR 0 7
22929: PUSH
22930: LD_VAR 0 7
22934: PPUSH
22935: LD_INT 1
22937: PPUSH
22938: LD_VAR 0 14
22942: PPUSH
22943: CALL_OW 2
22947: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22948: LD_VAR 0 14
22952: PPUSH
22953: LD_VAR 0 9
22957: PPUSH
22958: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22962: LD_VAR 0 9
22966: PPUSH
22967: CALL_OW 313
22971: PUSH
22972: LD_INT 6
22974: EQUAL
22975: PUSH
22976: LD_VAR 0 9
22980: PPUSH
22981: CALL_OW 266
22985: PUSH
22986: LD_INT 32
22988: PUSH
22989: LD_INT 31
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: IN
22996: OR
22997: IFFALSE 22811
22999: GO 22808
23001: POP
23002: POP
// end else
23003: GO 23385
// for j = 1 to x do
23005: LD_ADDR_VAR 0 9
23009: PUSH
23010: DOUBLE
23011: LD_INT 1
23013: DEC
23014: ST_TO_ADDR
23015: LD_VAR 0 13
23019: PUSH
23020: FOR_TO
23021: IFFALSE 23383
// begin InitHc ;
23023: CALL_OW 19
// if not f then
23027: LD_VAR 0 12
23031: NOT
23032: IFFALSE 23121
// begin PrepareHuman ( false , i , skill ) ;
23034: LD_INT 0
23036: PPUSH
23037: LD_VAR 0 8
23041: PPUSH
23042: LD_VAR 0 4
23046: PPUSH
23047: CALL_OW 380
// un := CreateHuman ;
23051: LD_ADDR_VAR 0 14
23055: PUSH
23056: CALL_OW 44
23060: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23061: LD_ADDR_VAR 0 7
23065: PUSH
23066: LD_VAR 0 7
23070: PPUSH
23071: LD_INT 1
23073: PPUSH
23074: LD_VAR 0 14
23078: PPUSH
23079: CALL_OW 2
23083: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23084: LD_VAR 0 14
23088: PPUSH
23089: LD_VAR 0 1
23093: PPUSH
23094: CALL_OW 250
23098: PPUSH
23099: LD_VAR 0 1
23103: PPUSH
23104: CALL_OW 251
23108: PPUSH
23109: LD_INT 10
23111: PPUSH
23112: LD_INT 0
23114: PPUSH
23115: CALL_OW 50
// continue ;
23119: GO 23020
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23121: LD_VAR 0 12
23125: PUSH
23126: LD_INT 1
23128: ARRAY
23129: PPUSH
23130: CALL_OW 313
23134: PUSH
23135: LD_VAR 0 12
23139: PUSH
23140: LD_INT 1
23142: ARRAY
23143: PPUSH
23144: CALL_OW 266
23148: PUSH
23149: LD_INT 32
23151: PUSH
23152: LD_INT 31
23154: PUSH
23155: EMPTY
23156: LIST
23157: LIST
23158: IN
23159: AND
23160: PUSH
23161: LD_VAR 0 12
23165: PUSH
23166: LD_INT 1
23168: ARRAY
23169: PPUSH
23170: CALL_OW 313
23174: PUSH
23175: LD_INT 6
23177: EQUAL
23178: OR
23179: IFFALSE 23199
// f := Delete ( f , 1 ) ;
23181: LD_ADDR_VAR 0 12
23185: PUSH
23186: LD_VAR 0 12
23190: PPUSH
23191: LD_INT 1
23193: PPUSH
23194: CALL_OW 3
23198: ST_TO_ADDR
// if not f then
23199: LD_VAR 0 12
23203: NOT
23204: IFFALSE 23222
// begin x := x + 2 ;
23206: LD_ADDR_VAR 0 13
23210: PUSH
23211: LD_VAR 0 13
23215: PUSH
23216: LD_INT 2
23218: PLUS
23219: ST_TO_ADDR
// continue ;
23220: GO 23020
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23222: LD_VAR 0 12
23226: PUSH
23227: LD_INT 1
23229: ARRAY
23230: PPUSH
23231: CALL_OW 266
23235: PUSH
23236: LD_INT 5
23238: EQUAL
23239: IFFALSE 23313
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23241: LD_VAR 0 12
23245: PUSH
23246: LD_INT 1
23248: ARRAY
23249: PPUSH
23250: CALL_OW 313
23254: PUSH
23255: LD_INT 3
23257: LESS
23258: IFFALSE 23294
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23260: LD_INT 0
23262: PPUSH
23263: LD_INT 5
23265: PUSH
23266: LD_INT 8
23268: PUSH
23269: LD_INT 9
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: LIST
23276: PUSH
23277: LD_VAR 0 17
23281: ARRAY
23282: PPUSH
23283: LD_VAR 0 4
23287: PPUSH
23288: CALL_OW 380
23292: GO 23311
// PrepareHuman ( false , i , skill ) ;
23294: LD_INT 0
23296: PPUSH
23297: LD_VAR 0 8
23301: PPUSH
23302: LD_VAR 0 4
23306: PPUSH
23307: CALL_OW 380
// end else
23311: GO 23330
// PrepareHuman ( false , i , skill ) ;
23313: LD_INT 0
23315: PPUSH
23316: LD_VAR 0 8
23320: PPUSH
23321: LD_VAR 0 4
23325: PPUSH
23326: CALL_OW 380
// un := CreateHuman ;
23330: LD_ADDR_VAR 0 14
23334: PUSH
23335: CALL_OW 44
23339: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23340: LD_ADDR_VAR 0 7
23344: PUSH
23345: LD_VAR 0 7
23349: PPUSH
23350: LD_INT 1
23352: PPUSH
23353: LD_VAR 0 14
23357: PPUSH
23358: CALL_OW 2
23362: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23363: LD_VAR 0 14
23367: PPUSH
23368: LD_VAR 0 12
23372: PUSH
23373: LD_INT 1
23375: ARRAY
23376: PPUSH
23377: CALL_OW 52
// end ;
23381: GO 23020
23383: POP
23384: POP
// end ;
23385: GO 22322
23387: POP
23388: POP
// result := result ^ buildings ;
23389: LD_ADDR_VAR 0 7
23393: PUSH
23394: LD_VAR 0 7
23398: PUSH
23399: LD_VAR 0 18
23403: ADD
23404: ST_TO_ADDR
// end else
23405: GO 23548
// begin for i = 1 to personel do
23407: LD_ADDR_VAR 0 8
23411: PUSH
23412: DOUBLE
23413: LD_INT 1
23415: DEC
23416: ST_TO_ADDR
23417: LD_VAR 0 6
23421: PUSH
23422: FOR_TO
23423: IFFALSE 23546
// begin if i > 4 then
23425: LD_VAR 0 8
23429: PUSH
23430: LD_INT 4
23432: GREATER
23433: IFFALSE 23437
// break ;
23435: GO 23546
// x := personel [ i ] ;
23437: LD_ADDR_VAR 0 13
23441: PUSH
23442: LD_VAR 0 6
23446: PUSH
23447: LD_VAR 0 8
23451: ARRAY
23452: ST_TO_ADDR
// if x = - 1 then
23453: LD_VAR 0 13
23457: PUSH
23458: LD_INT 1
23460: NEG
23461: EQUAL
23462: IFFALSE 23466
// continue ;
23464: GO 23422
// PrepareHuman ( false , i , skill ) ;
23466: LD_INT 0
23468: PPUSH
23469: LD_VAR 0 8
23473: PPUSH
23474: LD_VAR 0 4
23478: PPUSH
23479: CALL_OW 380
// un := CreateHuman ;
23483: LD_ADDR_VAR 0 14
23487: PUSH
23488: CALL_OW 44
23492: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23493: LD_VAR 0 14
23497: PPUSH
23498: LD_VAR 0 1
23502: PPUSH
23503: CALL_OW 250
23507: PPUSH
23508: LD_VAR 0 1
23512: PPUSH
23513: CALL_OW 251
23517: PPUSH
23518: LD_INT 10
23520: PPUSH
23521: LD_INT 0
23523: PPUSH
23524: CALL_OW 50
// result := result ^ un ;
23528: LD_ADDR_VAR 0 7
23532: PUSH
23533: LD_VAR 0 7
23537: PUSH
23538: LD_VAR 0 14
23542: ADD
23543: ST_TO_ADDR
// end ;
23544: GO 23422
23546: POP
23547: POP
// end ; end ;
23548: LD_VAR 0 7
23552: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23553: LD_INT 0
23555: PPUSH
23556: PPUSH
23557: PPUSH
23558: PPUSH
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
// result := false ;
23571: LD_ADDR_VAR 0 3
23575: PUSH
23576: LD_INT 0
23578: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23579: LD_VAR 0 1
23583: NOT
23584: PUSH
23585: LD_VAR 0 1
23589: PPUSH
23590: CALL_OW 266
23594: PUSH
23595: LD_INT 32
23597: PUSH
23598: LD_INT 33
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: IN
23605: NOT
23606: OR
23607: IFFALSE 23611
// exit ;
23609: GO 24750
// nat := GetNation ( tower ) ;
23611: LD_ADDR_VAR 0 12
23615: PUSH
23616: LD_VAR 0 1
23620: PPUSH
23621: CALL_OW 248
23625: ST_TO_ADDR
// side := GetSide ( tower ) ;
23626: LD_ADDR_VAR 0 16
23630: PUSH
23631: LD_VAR 0 1
23635: PPUSH
23636: CALL_OW 255
23640: ST_TO_ADDR
// x := GetX ( tower ) ;
23641: LD_ADDR_VAR 0 10
23645: PUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: CALL_OW 250
23655: ST_TO_ADDR
// y := GetY ( tower ) ;
23656: LD_ADDR_VAR 0 11
23660: PUSH
23661: LD_VAR 0 1
23665: PPUSH
23666: CALL_OW 251
23670: ST_TO_ADDR
// if not x or not y then
23671: LD_VAR 0 10
23675: NOT
23676: PUSH
23677: LD_VAR 0 11
23681: NOT
23682: OR
23683: IFFALSE 23687
// exit ;
23685: GO 24750
// weapon := 0 ;
23687: LD_ADDR_VAR 0 18
23691: PUSH
23692: LD_INT 0
23694: ST_TO_ADDR
// fac_list := [ ] ;
23695: LD_ADDR_VAR 0 17
23699: PUSH
23700: EMPTY
23701: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23702: LD_ADDR_VAR 0 6
23706: PUSH
23707: LD_VAR 0 1
23711: PPUSH
23712: CALL_OW 274
23716: PPUSH
23717: LD_VAR 0 2
23721: PPUSH
23722: LD_INT 0
23724: PPUSH
23725: CALL 21290 0 3
23729: PPUSH
23730: LD_INT 30
23732: PUSH
23733: LD_INT 3
23735: PUSH
23736: EMPTY
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: ST_TO_ADDR
// if not factories then
23745: LD_VAR 0 6
23749: NOT
23750: IFFALSE 23754
// exit ;
23752: GO 24750
// for i in factories do
23754: LD_ADDR_VAR 0 8
23758: PUSH
23759: LD_VAR 0 6
23763: PUSH
23764: FOR_IN
23765: IFFALSE 23790
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23767: LD_ADDR_VAR 0 17
23771: PUSH
23772: LD_VAR 0 17
23776: PUSH
23777: LD_VAR 0 8
23781: PPUSH
23782: CALL_OW 478
23786: UNION
23787: ST_TO_ADDR
23788: GO 23764
23790: POP
23791: POP
// if not fac_list then
23792: LD_VAR 0 17
23796: NOT
23797: IFFALSE 23801
// exit ;
23799: GO 24750
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23801: LD_ADDR_VAR 0 5
23805: PUSH
23806: LD_INT 4
23808: PUSH
23809: LD_INT 5
23811: PUSH
23812: LD_INT 9
23814: PUSH
23815: LD_INT 10
23817: PUSH
23818: LD_INT 6
23820: PUSH
23821: LD_INT 7
23823: PUSH
23824: LD_INT 11
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: LIST
23835: PUSH
23836: LD_INT 27
23838: PUSH
23839: LD_INT 28
23841: PUSH
23842: LD_INT 26
23844: PUSH
23845: LD_INT 30
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 43
23856: PUSH
23857: LD_INT 44
23859: PUSH
23860: LD_INT 46
23862: PUSH
23863: LD_INT 45
23865: PUSH
23866: LD_INT 47
23868: PUSH
23869: LD_INT 49
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: LIST
23884: PUSH
23885: LD_VAR 0 12
23889: ARRAY
23890: ST_TO_ADDR
// for i in list do
23891: LD_ADDR_VAR 0 8
23895: PUSH
23896: LD_VAR 0 5
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23935
// if not i in fac_list then
23904: LD_VAR 0 8
23908: PUSH
23909: LD_VAR 0 17
23913: IN
23914: NOT
23915: IFFALSE 23933
// list := list diff i ;
23917: LD_ADDR_VAR 0 5
23921: PUSH
23922: LD_VAR 0 5
23926: PUSH
23927: LD_VAR 0 8
23931: DIFF
23932: ST_TO_ADDR
23933: GO 23901
23935: POP
23936: POP
// if not list then
23937: LD_VAR 0 5
23941: NOT
23942: IFFALSE 23946
// exit ;
23944: GO 24750
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23946: LD_VAR 0 12
23950: PUSH
23951: LD_INT 3
23953: EQUAL
23954: PUSH
23955: LD_INT 49
23957: PUSH
23958: LD_VAR 0 5
23962: IN
23963: AND
23964: PUSH
23965: LD_INT 31
23967: PPUSH
23968: LD_VAR 0 16
23972: PPUSH
23973: CALL_OW 321
23977: PUSH
23978: LD_INT 2
23980: EQUAL
23981: AND
23982: IFFALSE 24042
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23984: LD_INT 22
23986: PUSH
23987: LD_VAR 0 16
23991: PUSH
23992: EMPTY
23993: LIST
23994: LIST
23995: PUSH
23996: LD_INT 35
23998: PUSH
23999: LD_INT 49
24001: PUSH
24002: EMPTY
24003: LIST
24004: LIST
24005: PUSH
24006: LD_INT 91
24008: PUSH
24009: LD_VAR 0 1
24013: PUSH
24014: LD_INT 10
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PPUSH
24027: CALL_OW 69
24031: NOT
24032: IFFALSE 24042
// weapon := ru_time_lapser ;
24034: LD_ADDR_VAR 0 18
24038: PUSH
24039: LD_INT 49
24041: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24042: LD_VAR 0 12
24046: PUSH
24047: LD_INT 1
24049: PUSH
24050: LD_INT 2
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: IN
24057: PUSH
24058: LD_INT 11
24060: PUSH
24061: LD_VAR 0 5
24065: IN
24066: PUSH
24067: LD_INT 30
24069: PUSH
24070: LD_VAR 0 5
24074: IN
24075: OR
24076: AND
24077: PUSH
24078: LD_INT 6
24080: PPUSH
24081: LD_VAR 0 16
24085: PPUSH
24086: CALL_OW 321
24090: PUSH
24091: LD_INT 2
24093: EQUAL
24094: AND
24095: IFFALSE 24260
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24097: LD_INT 22
24099: PUSH
24100: LD_VAR 0 16
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 2
24111: PUSH
24112: LD_INT 35
24114: PUSH
24115: LD_INT 11
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: PUSH
24122: LD_INT 35
24124: PUSH
24125: LD_INT 30
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 91
24139: PUSH
24140: LD_VAR 0 1
24144: PUSH
24145: LD_INT 18
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: PPUSH
24158: CALL_OW 69
24162: NOT
24163: PUSH
24164: LD_INT 22
24166: PUSH
24167: LD_VAR 0 16
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 2
24178: PUSH
24179: LD_INT 30
24181: PUSH
24182: LD_INT 32
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PUSH
24189: LD_INT 30
24191: PUSH
24192: LD_INT 33
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: PUSH
24204: LD_INT 91
24206: PUSH
24207: LD_VAR 0 1
24211: PUSH
24212: LD_INT 12
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: LIST
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: LIST
24224: PUSH
24225: EMPTY
24226: LIST
24227: PPUSH
24228: CALL_OW 69
24232: PUSH
24233: LD_INT 2
24235: GREATER
24236: AND
24237: IFFALSE 24260
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24239: LD_ADDR_VAR 0 18
24243: PUSH
24244: LD_INT 11
24246: PUSH
24247: LD_INT 30
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PUSH
24254: LD_VAR 0 12
24258: ARRAY
24259: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24260: LD_VAR 0 18
24264: NOT
24265: PUSH
24266: LD_INT 40
24268: PPUSH
24269: LD_VAR 0 16
24273: PPUSH
24274: CALL_OW 321
24278: PUSH
24279: LD_INT 2
24281: EQUAL
24282: AND
24283: PUSH
24284: LD_INT 7
24286: PUSH
24287: LD_VAR 0 5
24291: IN
24292: PUSH
24293: LD_INT 28
24295: PUSH
24296: LD_VAR 0 5
24300: IN
24301: OR
24302: PUSH
24303: LD_INT 45
24305: PUSH
24306: LD_VAR 0 5
24310: IN
24311: OR
24312: AND
24313: IFFALSE 24567
// begin hex := GetHexInfo ( x , y ) ;
24315: LD_ADDR_VAR 0 4
24319: PUSH
24320: LD_VAR 0 10
24324: PPUSH
24325: LD_VAR 0 11
24329: PPUSH
24330: CALL_OW 546
24334: ST_TO_ADDR
// if hex [ 1 ] then
24335: LD_VAR 0 4
24339: PUSH
24340: LD_INT 1
24342: ARRAY
24343: IFFALSE 24347
// exit ;
24345: GO 24750
// height := hex [ 2 ] ;
24347: LD_ADDR_VAR 0 15
24351: PUSH
24352: LD_VAR 0 4
24356: PUSH
24357: LD_INT 2
24359: ARRAY
24360: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24361: LD_ADDR_VAR 0 14
24365: PUSH
24366: LD_INT 0
24368: PUSH
24369: LD_INT 2
24371: PUSH
24372: LD_INT 3
24374: PUSH
24375: LD_INT 5
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: LIST
24382: LIST
24383: ST_TO_ADDR
// for i in tmp do
24384: LD_ADDR_VAR 0 8
24388: PUSH
24389: LD_VAR 0 14
24393: PUSH
24394: FOR_IN
24395: IFFALSE 24565
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24397: LD_ADDR_VAR 0 9
24401: PUSH
24402: LD_VAR 0 10
24406: PPUSH
24407: LD_VAR 0 8
24411: PPUSH
24412: LD_INT 5
24414: PPUSH
24415: CALL_OW 272
24419: PUSH
24420: LD_VAR 0 11
24424: PPUSH
24425: LD_VAR 0 8
24429: PPUSH
24430: LD_INT 5
24432: PPUSH
24433: CALL_OW 273
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24442: LD_VAR 0 9
24446: PUSH
24447: LD_INT 1
24449: ARRAY
24450: PPUSH
24451: LD_VAR 0 9
24455: PUSH
24456: LD_INT 2
24458: ARRAY
24459: PPUSH
24460: CALL_OW 488
24464: IFFALSE 24563
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24466: LD_ADDR_VAR 0 4
24470: PUSH
24471: LD_VAR 0 9
24475: PUSH
24476: LD_INT 1
24478: ARRAY
24479: PPUSH
24480: LD_VAR 0 9
24484: PUSH
24485: LD_INT 2
24487: ARRAY
24488: PPUSH
24489: CALL_OW 546
24493: ST_TO_ADDR
// if hex [ 1 ] then
24494: LD_VAR 0 4
24498: PUSH
24499: LD_INT 1
24501: ARRAY
24502: IFFALSE 24506
// continue ;
24504: GO 24394
// h := hex [ 2 ] ;
24506: LD_ADDR_VAR 0 13
24510: PUSH
24511: LD_VAR 0 4
24515: PUSH
24516: LD_INT 2
24518: ARRAY
24519: ST_TO_ADDR
// if h + 7 < height then
24520: LD_VAR 0 13
24524: PUSH
24525: LD_INT 7
24527: PLUS
24528: PUSH
24529: LD_VAR 0 15
24533: LESS
24534: IFFALSE 24563
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24536: LD_ADDR_VAR 0 18
24540: PUSH
24541: LD_INT 7
24543: PUSH
24544: LD_INT 28
24546: PUSH
24547: LD_INT 45
24549: PUSH
24550: EMPTY
24551: LIST
24552: LIST
24553: LIST
24554: PUSH
24555: LD_VAR 0 12
24559: ARRAY
24560: ST_TO_ADDR
// break ;
24561: GO 24565
// end ; end ; end ;
24563: GO 24394
24565: POP
24566: POP
// end ; if not weapon then
24567: LD_VAR 0 18
24571: NOT
24572: IFFALSE 24632
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24574: LD_ADDR_VAR 0 5
24578: PUSH
24579: LD_VAR 0 5
24583: PUSH
24584: LD_INT 11
24586: PUSH
24587: LD_INT 30
24589: PUSH
24590: LD_INT 49
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: LIST
24597: DIFF
24598: ST_TO_ADDR
// if not list then
24599: LD_VAR 0 5
24603: NOT
24604: IFFALSE 24608
// exit ;
24606: GO 24750
// weapon := list [ rand ( 1 , list ) ] ;
24608: LD_ADDR_VAR 0 18
24612: PUSH
24613: LD_VAR 0 5
24617: PUSH
24618: LD_INT 1
24620: PPUSH
24621: LD_VAR 0 5
24625: PPUSH
24626: CALL_OW 12
24630: ARRAY
24631: ST_TO_ADDR
// end ; if weapon then
24632: LD_VAR 0 18
24636: IFFALSE 24750
// begin tmp := CostOfWeapon ( weapon ) ;
24638: LD_ADDR_VAR 0 14
24642: PUSH
24643: LD_VAR 0 18
24647: PPUSH
24648: CALL_OW 451
24652: ST_TO_ADDR
// j := GetBase ( tower ) ;
24653: LD_ADDR_VAR 0 9
24657: PUSH
24658: LD_VAR 0 1
24662: PPUSH
24663: CALL_OW 274
24667: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24668: LD_VAR 0 9
24672: PPUSH
24673: LD_INT 1
24675: PPUSH
24676: CALL_OW 275
24680: PUSH
24681: LD_VAR 0 14
24685: PUSH
24686: LD_INT 1
24688: ARRAY
24689: GREATEREQUAL
24690: PUSH
24691: LD_VAR 0 9
24695: PPUSH
24696: LD_INT 2
24698: PPUSH
24699: CALL_OW 275
24703: PUSH
24704: LD_VAR 0 14
24708: PUSH
24709: LD_INT 2
24711: ARRAY
24712: GREATEREQUAL
24713: AND
24714: PUSH
24715: LD_VAR 0 9
24719: PPUSH
24720: LD_INT 3
24722: PPUSH
24723: CALL_OW 275
24727: PUSH
24728: LD_VAR 0 14
24732: PUSH
24733: LD_INT 3
24735: ARRAY
24736: GREATEREQUAL
24737: AND
24738: IFFALSE 24750
// result := weapon ;
24740: LD_ADDR_VAR 0 3
24744: PUSH
24745: LD_VAR 0 18
24749: ST_TO_ADDR
// end ; end ;
24750: LD_VAR 0 3
24754: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24755: LD_INT 0
24757: PPUSH
24758: PPUSH
// result := true ;
24759: LD_ADDR_VAR 0 3
24763: PUSH
24764: LD_INT 1
24766: ST_TO_ADDR
// if array1 = array2 then
24767: LD_VAR 0 1
24771: PUSH
24772: LD_VAR 0 2
24776: EQUAL
24777: IFFALSE 24837
// begin for i = 1 to array1 do
24779: LD_ADDR_VAR 0 4
24783: PUSH
24784: DOUBLE
24785: LD_INT 1
24787: DEC
24788: ST_TO_ADDR
24789: LD_VAR 0 1
24793: PUSH
24794: FOR_TO
24795: IFFALSE 24833
// if array1 [ i ] <> array2 [ i ] then
24797: LD_VAR 0 1
24801: PUSH
24802: LD_VAR 0 4
24806: ARRAY
24807: PUSH
24808: LD_VAR 0 2
24812: PUSH
24813: LD_VAR 0 4
24817: ARRAY
24818: NONEQUAL
24819: IFFALSE 24831
// begin result := false ;
24821: LD_ADDR_VAR 0 3
24825: PUSH
24826: LD_INT 0
24828: ST_TO_ADDR
// break ;
24829: GO 24833
// end ;
24831: GO 24794
24833: POP
24834: POP
// end else
24835: GO 24845
// result := false ;
24837: LD_ADDR_VAR 0 3
24841: PUSH
24842: LD_INT 0
24844: ST_TO_ADDR
// end ;
24845: LD_VAR 0 3
24849: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24850: LD_INT 0
24852: PPUSH
24853: PPUSH
// if not array1 or not array2 then
24854: LD_VAR 0 1
24858: NOT
24859: PUSH
24860: LD_VAR 0 2
24864: NOT
24865: OR
24866: IFFALSE 24870
// exit ;
24868: GO 24934
// result := true ;
24870: LD_ADDR_VAR 0 3
24874: PUSH
24875: LD_INT 1
24877: ST_TO_ADDR
// for i = 1 to array1 do
24878: LD_ADDR_VAR 0 4
24882: PUSH
24883: DOUBLE
24884: LD_INT 1
24886: DEC
24887: ST_TO_ADDR
24888: LD_VAR 0 1
24892: PUSH
24893: FOR_TO
24894: IFFALSE 24932
// if array1 [ i ] <> array2 [ i ] then
24896: LD_VAR 0 1
24900: PUSH
24901: LD_VAR 0 4
24905: ARRAY
24906: PUSH
24907: LD_VAR 0 2
24911: PUSH
24912: LD_VAR 0 4
24916: ARRAY
24917: NONEQUAL
24918: IFFALSE 24930
// begin result := false ;
24920: LD_ADDR_VAR 0 3
24924: PUSH
24925: LD_INT 0
24927: ST_TO_ADDR
// break ;
24928: GO 24932
// end ;
24930: GO 24893
24932: POP
24933: POP
// end ;
24934: LD_VAR 0 3
24938: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24939: LD_INT 0
24941: PPUSH
24942: PPUSH
24943: PPUSH
// pom := GetBase ( fac ) ;
24944: LD_ADDR_VAR 0 5
24948: PUSH
24949: LD_VAR 0 1
24953: PPUSH
24954: CALL_OW 274
24958: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24959: LD_ADDR_VAR 0 4
24963: PUSH
24964: LD_VAR 0 2
24968: PUSH
24969: LD_INT 1
24971: ARRAY
24972: PPUSH
24973: LD_VAR 0 2
24977: PUSH
24978: LD_INT 2
24980: ARRAY
24981: PPUSH
24982: LD_VAR 0 2
24986: PUSH
24987: LD_INT 3
24989: ARRAY
24990: PPUSH
24991: LD_VAR 0 2
24995: PUSH
24996: LD_INT 4
24998: ARRAY
24999: PPUSH
25000: CALL_OW 449
25004: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25005: LD_ADDR_VAR 0 3
25009: PUSH
25010: LD_VAR 0 5
25014: PPUSH
25015: LD_INT 1
25017: PPUSH
25018: CALL_OW 275
25022: PUSH
25023: LD_VAR 0 4
25027: PUSH
25028: LD_INT 1
25030: ARRAY
25031: GREATEREQUAL
25032: PUSH
25033: LD_VAR 0 5
25037: PPUSH
25038: LD_INT 2
25040: PPUSH
25041: CALL_OW 275
25045: PUSH
25046: LD_VAR 0 4
25050: PUSH
25051: LD_INT 2
25053: ARRAY
25054: GREATEREQUAL
25055: AND
25056: PUSH
25057: LD_VAR 0 5
25061: PPUSH
25062: LD_INT 3
25064: PPUSH
25065: CALL_OW 275
25069: PUSH
25070: LD_VAR 0 4
25074: PUSH
25075: LD_INT 3
25077: ARRAY
25078: GREATEREQUAL
25079: AND
25080: ST_TO_ADDR
// end ;
25081: LD_VAR 0 3
25085: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25086: LD_INT 0
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
// pom := GetBase ( building ) ;
25092: LD_ADDR_VAR 0 3
25096: PUSH
25097: LD_VAR 0 1
25101: PPUSH
25102: CALL_OW 274
25106: ST_TO_ADDR
// if not pom then
25107: LD_VAR 0 3
25111: NOT
25112: IFFALSE 25116
// exit ;
25114: GO 25286
// btype := GetBType ( building ) ;
25116: LD_ADDR_VAR 0 5
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 266
25130: ST_TO_ADDR
// if btype = b_armoury then
25131: LD_VAR 0 5
25135: PUSH
25136: LD_INT 4
25138: EQUAL
25139: IFFALSE 25149
// btype := b_barracks ;
25141: LD_ADDR_VAR 0 5
25145: PUSH
25146: LD_INT 5
25148: ST_TO_ADDR
// if btype = b_depot then
25149: LD_VAR 0 5
25153: PUSH
25154: LD_INT 0
25156: EQUAL
25157: IFFALSE 25167
// btype := b_warehouse ;
25159: LD_ADDR_VAR 0 5
25163: PUSH
25164: LD_INT 1
25166: ST_TO_ADDR
// if btype = b_workshop then
25167: LD_VAR 0 5
25171: PUSH
25172: LD_INT 2
25174: EQUAL
25175: IFFALSE 25185
// btype := b_factory ;
25177: LD_ADDR_VAR 0 5
25181: PUSH
25182: LD_INT 3
25184: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25185: LD_ADDR_VAR 0 4
25189: PUSH
25190: LD_VAR 0 5
25194: PPUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 248
25204: PPUSH
25205: CALL_OW 450
25209: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25210: LD_ADDR_VAR 0 2
25214: PUSH
25215: LD_VAR 0 3
25219: PPUSH
25220: LD_INT 1
25222: PPUSH
25223: CALL_OW 275
25227: PUSH
25228: LD_VAR 0 4
25232: PUSH
25233: LD_INT 1
25235: ARRAY
25236: GREATEREQUAL
25237: PUSH
25238: LD_VAR 0 3
25242: PPUSH
25243: LD_INT 2
25245: PPUSH
25246: CALL_OW 275
25250: PUSH
25251: LD_VAR 0 4
25255: PUSH
25256: LD_INT 2
25258: ARRAY
25259: GREATEREQUAL
25260: AND
25261: PUSH
25262: LD_VAR 0 3
25266: PPUSH
25267: LD_INT 3
25269: PPUSH
25270: CALL_OW 275
25274: PUSH
25275: LD_VAR 0 4
25279: PUSH
25280: LD_INT 3
25282: ARRAY
25283: GREATEREQUAL
25284: AND
25285: ST_TO_ADDR
// end ;
25286: LD_VAR 0 2
25290: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25291: LD_INT 0
25293: PPUSH
25294: PPUSH
25295: PPUSH
// pom := GetBase ( building ) ;
25296: LD_ADDR_VAR 0 4
25300: PUSH
25301: LD_VAR 0 1
25305: PPUSH
25306: CALL_OW 274
25310: ST_TO_ADDR
// if not pom then
25311: LD_VAR 0 4
25315: NOT
25316: IFFALSE 25320
// exit ;
25318: GO 25421
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25320: LD_ADDR_VAR 0 5
25324: PUSH
25325: LD_VAR 0 2
25329: PPUSH
25330: LD_VAR 0 1
25334: PPUSH
25335: CALL_OW 248
25339: PPUSH
25340: CALL_OW 450
25344: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_VAR 0 4
25354: PPUSH
25355: LD_INT 1
25357: PPUSH
25358: CALL_OW 275
25362: PUSH
25363: LD_VAR 0 5
25367: PUSH
25368: LD_INT 1
25370: ARRAY
25371: GREATEREQUAL
25372: PUSH
25373: LD_VAR 0 4
25377: PPUSH
25378: LD_INT 2
25380: PPUSH
25381: CALL_OW 275
25385: PUSH
25386: LD_VAR 0 5
25390: PUSH
25391: LD_INT 2
25393: ARRAY
25394: GREATEREQUAL
25395: AND
25396: PUSH
25397: LD_VAR 0 4
25401: PPUSH
25402: LD_INT 3
25404: PPUSH
25405: CALL_OW 275
25409: PUSH
25410: LD_VAR 0 5
25414: PUSH
25415: LD_INT 3
25417: ARRAY
25418: GREATEREQUAL
25419: AND
25420: ST_TO_ADDR
// end ;
25421: LD_VAR 0 3
25425: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25426: LD_INT 0
25428: PPUSH
25429: PPUSH
25430: PPUSH
25431: PPUSH
25432: PPUSH
25433: PPUSH
25434: PPUSH
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
// result := false ;
25439: LD_ADDR_VAR 0 8
25443: PUSH
25444: LD_INT 0
25446: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25447: LD_VAR 0 5
25451: NOT
25452: PUSH
25453: LD_VAR 0 1
25457: NOT
25458: OR
25459: PUSH
25460: LD_VAR 0 2
25464: NOT
25465: OR
25466: PUSH
25467: LD_VAR 0 3
25471: NOT
25472: OR
25473: IFFALSE 25477
// exit ;
25475: GO 26291
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25477: LD_ADDR_VAR 0 14
25481: PUSH
25482: LD_VAR 0 1
25486: PPUSH
25487: LD_VAR 0 2
25491: PPUSH
25492: LD_VAR 0 3
25496: PPUSH
25497: LD_VAR 0 4
25501: PPUSH
25502: LD_VAR 0 5
25506: PUSH
25507: LD_INT 1
25509: ARRAY
25510: PPUSH
25511: CALL_OW 248
25515: PPUSH
25516: LD_INT 0
25518: PPUSH
25519: CALL 27128 0 6
25523: ST_TO_ADDR
// if not hexes then
25524: LD_VAR 0 14
25528: NOT
25529: IFFALSE 25533
// exit ;
25531: GO 26291
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25533: LD_ADDR_VAR 0 17
25537: PUSH
25538: LD_VAR 0 5
25542: PPUSH
25543: LD_INT 22
25545: PUSH
25546: LD_VAR 0 13
25550: PPUSH
25551: CALL_OW 255
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 30
25565: PUSH
25566: LD_INT 0
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 30
25575: PUSH
25576: LD_INT 1
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PPUSH
25592: CALL_OW 72
25596: ST_TO_ADDR
// for i = 1 to hexes do
25597: LD_ADDR_VAR 0 9
25601: PUSH
25602: DOUBLE
25603: LD_INT 1
25605: DEC
25606: ST_TO_ADDR
25607: LD_VAR 0 14
25611: PUSH
25612: FOR_TO
25613: IFFALSE 26289
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25615: LD_ADDR_VAR 0 13
25619: PUSH
25620: LD_VAR 0 14
25624: PUSH
25625: LD_VAR 0 9
25629: ARRAY
25630: PUSH
25631: LD_INT 1
25633: ARRAY
25634: PPUSH
25635: LD_VAR 0 14
25639: PUSH
25640: LD_VAR 0 9
25644: ARRAY
25645: PUSH
25646: LD_INT 2
25648: ARRAY
25649: PPUSH
25650: CALL_OW 428
25654: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25655: LD_VAR 0 14
25659: PUSH
25660: LD_VAR 0 9
25664: ARRAY
25665: PUSH
25666: LD_INT 1
25668: ARRAY
25669: PPUSH
25670: LD_VAR 0 14
25674: PUSH
25675: LD_VAR 0 9
25679: ARRAY
25680: PUSH
25681: LD_INT 2
25683: ARRAY
25684: PPUSH
25685: CALL_OW 351
25689: PUSH
25690: LD_VAR 0 14
25694: PUSH
25695: LD_VAR 0 9
25699: ARRAY
25700: PUSH
25701: LD_INT 1
25703: ARRAY
25704: PPUSH
25705: LD_VAR 0 14
25709: PUSH
25710: LD_VAR 0 9
25714: ARRAY
25715: PUSH
25716: LD_INT 2
25718: ARRAY
25719: PPUSH
25720: CALL_OW 488
25724: NOT
25725: OR
25726: PUSH
25727: LD_VAR 0 13
25731: PPUSH
25732: CALL_OW 247
25736: PUSH
25737: LD_INT 3
25739: EQUAL
25740: OR
25741: IFFALSE 25747
// exit ;
25743: POP
25744: POP
25745: GO 26291
// if not tmp then
25747: LD_VAR 0 13
25751: NOT
25752: IFFALSE 25756
// continue ;
25754: GO 25612
// result := true ;
25756: LD_ADDR_VAR 0 8
25760: PUSH
25761: LD_INT 1
25763: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25764: LD_VAR 0 6
25768: PUSH
25769: LD_VAR 0 13
25773: PPUSH
25774: CALL_OW 247
25778: PUSH
25779: LD_INT 2
25781: EQUAL
25782: AND
25783: PUSH
25784: LD_VAR 0 13
25788: PPUSH
25789: CALL_OW 263
25793: PUSH
25794: LD_INT 1
25796: EQUAL
25797: AND
25798: IFFALSE 25962
// begin if IsDrivenBy ( tmp ) then
25800: LD_VAR 0 13
25804: PPUSH
25805: CALL_OW 311
25809: IFFALSE 25813
// continue ;
25811: GO 25612
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25813: LD_VAR 0 6
25817: PPUSH
25818: LD_INT 3
25820: PUSH
25821: LD_INT 60
25823: PUSH
25824: EMPTY
25825: LIST
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 3
25833: PUSH
25834: LD_INT 55
25836: PUSH
25837: EMPTY
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PPUSH
25848: CALL_OW 72
25852: IFFALSE 25960
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25854: LD_ADDR_VAR 0 18
25858: PUSH
25859: LD_VAR 0 6
25863: PPUSH
25864: LD_INT 3
25866: PUSH
25867: LD_INT 60
25869: PUSH
25870: EMPTY
25871: LIST
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 3
25879: PUSH
25880: LD_INT 55
25882: PUSH
25883: EMPTY
25884: LIST
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PPUSH
25894: CALL_OW 72
25898: PUSH
25899: LD_INT 1
25901: ARRAY
25902: ST_TO_ADDR
// if IsInUnit ( driver ) then
25903: LD_VAR 0 18
25907: PPUSH
25908: CALL_OW 310
25912: IFFALSE 25923
// ComExit ( driver ) ;
25914: LD_VAR 0 18
25918: PPUSH
25919: CALL 50312 0 1
// AddComEnterUnit ( driver , tmp ) ;
25923: LD_VAR 0 18
25927: PPUSH
25928: LD_VAR 0 13
25932: PPUSH
25933: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25937: LD_VAR 0 18
25941: PPUSH
25942: LD_VAR 0 7
25946: PPUSH
25947: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25951: LD_VAR 0 18
25955: PPUSH
25956: CALL_OW 181
// end ; continue ;
25960: GO 25612
// end ; if not cleaners or not tmp in cleaners then
25962: LD_VAR 0 6
25966: NOT
25967: PUSH
25968: LD_VAR 0 13
25972: PUSH
25973: LD_VAR 0 6
25977: IN
25978: NOT
25979: OR
25980: IFFALSE 26287
// begin if dep then
25982: LD_VAR 0 17
25986: IFFALSE 26122
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25988: LD_ADDR_VAR 0 16
25992: PUSH
25993: LD_VAR 0 17
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 250
26006: PPUSH
26007: LD_VAR 0 17
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: PPUSH
26016: CALL_OW 254
26020: PPUSH
26021: LD_INT 5
26023: PPUSH
26024: CALL_OW 272
26028: PUSH
26029: LD_VAR 0 17
26033: PUSH
26034: LD_INT 1
26036: ARRAY
26037: PPUSH
26038: CALL_OW 251
26042: PPUSH
26043: LD_VAR 0 17
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PPUSH
26052: CALL_OW 254
26056: PPUSH
26057: LD_INT 5
26059: PPUSH
26060: CALL_OW 273
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26069: LD_VAR 0 16
26073: PUSH
26074: LD_INT 1
26076: ARRAY
26077: PPUSH
26078: LD_VAR 0 16
26082: PUSH
26083: LD_INT 2
26085: ARRAY
26086: PPUSH
26087: CALL_OW 488
26091: IFFALSE 26122
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26093: LD_VAR 0 13
26097: PPUSH
26098: LD_VAR 0 16
26102: PUSH
26103: LD_INT 1
26105: ARRAY
26106: PPUSH
26107: LD_VAR 0 16
26111: PUSH
26112: LD_INT 2
26114: ARRAY
26115: PPUSH
26116: CALL_OW 111
// continue ;
26120: GO 25612
// end ; end ; r := GetDir ( tmp ) ;
26122: LD_ADDR_VAR 0 15
26126: PUSH
26127: LD_VAR 0 13
26131: PPUSH
26132: CALL_OW 254
26136: ST_TO_ADDR
// if r = 5 then
26137: LD_VAR 0 15
26141: PUSH
26142: LD_INT 5
26144: EQUAL
26145: IFFALSE 26155
// r := 0 ;
26147: LD_ADDR_VAR 0 15
26151: PUSH
26152: LD_INT 0
26154: ST_TO_ADDR
// for j = r to 5 do
26155: LD_ADDR_VAR 0 10
26159: PUSH
26160: DOUBLE
26161: LD_VAR 0 15
26165: DEC
26166: ST_TO_ADDR
26167: LD_INT 5
26169: PUSH
26170: FOR_TO
26171: IFFALSE 26285
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26173: LD_ADDR_VAR 0 11
26177: PUSH
26178: LD_VAR 0 13
26182: PPUSH
26183: CALL_OW 250
26187: PPUSH
26188: LD_VAR 0 10
26192: PPUSH
26193: LD_INT 2
26195: PPUSH
26196: CALL_OW 272
26200: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26201: LD_ADDR_VAR 0 12
26205: PUSH
26206: LD_VAR 0 13
26210: PPUSH
26211: CALL_OW 251
26215: PPUSH
26216: LD_VAR 0 10
26220: PPUSH
26221: LD_INT 2
26223: PPUSH
26224: CALL_OW 273
26228: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26229: LD_VAR 0 11
26233: PPUSH
26234: LD_VAR 0 12
26238: PPUSH
26239: CALL_OW 488
26243: PUSH
26244: LD_VAR 0 11
26248: PPUSH
26249: LD_VAR 0 12
26253: PPUSH
26254: CALL_OW 428
26258: NOT
26259: AND
26260: IFFALSE 26283
// begin ComMoveXY ( tmp , _x , _y ) ;
26262: LD_VAR 0 13
26266: PPUSH
26267: LD_VAR 0 11
26271: PPUSH
26272: LD_VAR 0 12
26276: PPUSH
26277: CALL_OW 111
// break ;
26281: GO 26285
// end ; end ;
26283: GO 26170
26285: POP
26286: POP
// end ; end ;
26287: GO 25612
26289: POP
26290: POP
// end ;
26291: LD_VAR 0 8
26295: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26296: LD_INT 0
26298: PPUSH
26299: PPUSH
26300: PPUSH
26301: PPUSH
26302: PPUSH
26303: PPUSH
26304: PPUSH
26305: PPUSH
26306: PPUSH
26307: PPUSH
// result := false ;
26308: LD_ADDR_VAR 0 6
26312: PUSH
26313: LD_INT 0
26315: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26316: LD_VAR 0 1
26320: NOT
26321: PUSH
26322: LD_VAR 0 1
26326: PPUSH
26327: CALL_OW 266
26331: PUSH
26332: LD_INT 0
26334: PUSH
26335: LD_INT 1
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: IN
26342: NOT
26343: OR
26344: PUSH
26345: LD_VAR 0 2
26349: NOT
26350: OR
26351: PUSH
26352: LD_VAR 0 5
26356: PUSH
26357: LD_INT 0
26359: PUSH
26360: LD_INT 1
26362: PUSH
26363: LD_INT 2
26365: PUSH
26366: LD_INT 3
26368: PUSH
26369: LD_INT 4
26371: PUSH
26372: LD_INT 5
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: LIST
26379: LIST
26380: LIST
26381: LIST
26382: IN
26383: NOT
26384: OR
26385: PUSH
26386: LD_VAR 0 3
26390: PPUSH
26391: LD_VAR 0 4
26395: PPUSH
26396: CALL_OW 488
26400: NOT
26401: OR
26402: IFFALSE 26406
// exit ;
26404: GO 27123
// pom := GetBase ( depot ) ;
26406: LD_ADDR_VAR 0 10
26410: PUSH
26411: LD_VAR 0 1
26415: PPUSH
26416: CALL_OW 274
26420: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26421: LD_ADDR_VAR 0 11
26425: PUSH
26426: LD_VAR 0 2
26430: PPUSH
26431: LD_VAR 0 1
26435: PPUSH
26436: CALL_OW 248
26440: PPUSH
26441: CALL_OW 450
26445: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26446: LD_VAR 0 10
26450: PPUSH
26451: LD_INT 1
26453: PPUSH
26454: CALL_OW 275
26458: PUSH
26459: LD_VAR 0 11
26463: PUSH
26464: LD_INT 1
26466: ARRAY
26467: GREATEREQUAL
26468: PUSH
26469: LD_VAR 0 10
26473: PPUSH
26474: LD_INT 2
26476: PPUSH
26477: CALL_OW 275
26481: PUSH
26482: LD_VAR 0 11
26486: PUSH
26487: LD_INT 2
26489: ARRAY
26490: GREATEREQUAL
26491: AND
26492: PUSH
26493: LD_VAR 0 10
26497: PPUSH
26498: LD_INT 3
26500: PPUSH
26501: CALL_OW 275
26505: PUSH
26506: LD_VAR 0 11
26510: PUSH
26511: LD_INT 3
26513: ARRAY
26514: GREATEREQUAL
26515: AND
26516: NOT
26517: IFFALSE 26521
// exit ;
26519: GO 27123
// if GetBType ( depot ) = b_depot then
26521: LD_VAR 0 1
26525: PPUSH
26526: CALL_OW 266
26530: PUSH
26531: LD_INT 0
26533: EQUAL
26534: IFFALSE 26546
// dist := 28 else
26536: LD_ADDR_VAR 0 14
26540: PUSH
26541: LD_INT 28
26543: ST_TO_ADDR
26544: GO 26554
// dist := 36 ;
26546: LD_ADDR_VAR 0 14
26550: PUSH
26551: LD_INT 36
26553: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26554: LD_VAR 0 1
26558: PPUSH
26559: LD_VAR 0 3
26563: PPUSH
26564: LD_VAR 0 4
26568: PPUSH
26569: CALL_OW 297
26573: PUSH
26574: LD_VAR 0 14
26578: GREATER
26579: IFFALSE 26583
// exit ;
26581: GO 27123
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26583: LD_ADDR_VAR 0 12
26587: PUSH
26588: LD_VAR 0 2
26592: PPUSH
26593: LD_VAR 0 3
26597: PPUSH
26598: LD_VAR 0 4
26602: PPUSH
26603: LD_VAR 0 5
26607: PPUSH
26608: LD_VAR 0 1
26612: PPUSH
26613: CALL_OW 248
26617: PPUSH
26618: LD_INT 0
26620: PPUSH
26621: CALL 27128 0 6
26625: ST_TO_ADDR
// if not hexes then
26626: LD_VAR 0 12
26630: NOT
26631: IFFALSE 26635
// exit ;
26633: GO 27123
// hex := GetHexInfo ( x , y ) ;
26635: LD_ADDR_VAR 0 15
26639: PUSH
26640: LD_VAR 0 3
26644: PPUSH
26645: LD_VAR 0 4
26649: PPUSH
26650: CALL_OW 546
26654: ST_TO_ADDR
// if hex [ 1 ] then
26655: LD_VAR 0 15
26659: PUSH
26660: LD_INT 1
26662: ARRAY
26663: IFFALSE 26667
// exit ;
26665: GO 27123
// height := hex [ 2 ] ;
26667: LD_ADDR_VAR 0 13
26671: PUSH
26672: LD_VAR 0 15
26676: PUSH
26677: LD_INT 2
26679: ARRAY
26680: ST_TO_ADDR
// for i = 1 to hexes do
26681: LD_ADDR_VAR 0 7
26685: PUSH
26686: DOUBLE
26687: LD_INT 1
26689: DEC
26690: ST_TO_ADDR
26691: LD_VAR 0 12
26695: PUSH
26696: FOR_TO
26697: IFFALSE 27027
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26699: LD_VAR 0 12
26703: PUSH
26704: LD_VAR 0 7
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: LD_VAR 0 12
26718: PUSH
26719: LD_VAR 0 7
26723: ARRAY
26724: PUSH
26725: LD_INT 2
26727: ARRAY
26728: PPUSH
26729: CALL_OW 488
26733: NOT
26734: PUSH
26735: LD_VAR 0 12
26739: PUSH
26740: LD_VAR 0 7
26744: ARRAY
26745: PUSH
26746: LD_INT 1
26748: ARRAY
26749: PPUSH
26750: LD_VAR 0 12
26754: PUSH
26755: LD_VAR 0 7
26759: ARRAY
26760: PUSH
26761: LD_INT 2
26763: ARRAY
26764: PPUSH
26765: CALL_OW 428
26769: PUSH
26770: LD_INT 0
26772: GREATER
26773: OR
26774: PUSH
26775: LD_VAR 0 12
26779: PUSH
26780: LD_VAR 0 7
26784: ARRAY
26785: PUSH
26786: LD_INT 1
26788: ARRAY
26789: PPUSH
26790: LD_VAR 0 12
26794: PUSH
26795: LD_VAR 0 7
26799: ARRAY
26800: PUSH
26801: LD_INT 2
26803: ARRAY
26804: PPUSH
26805: CALL_OW 351
26809: OR
26810: IFFALSE 26816
// exit ;
26812: POP
26813: POP
26814: GO 27123
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26816: LD_ADDR_VAR 0 8
26820: PUSH
26821: LD_VAR 0 12
26825: PUSH
26826: LD_VAR 0 7
26830: ARRAY
26831: PUSH
26832: LD_INT 1
26834: ARRAY
26835: PPUSH
26836: LD_VAR 0 12
26840: PUSH
26841: LD_VAR 0 7
26845: ARRAY
26846: PUSH
26847: LD_INT 2
26849: ARRAY
26850: PPUSH
26851: CALL_OW 546
26855: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26856: LD_VAR 0 8
26860: PUSH
26861: LD_INT 1
26863: ARRAY
26864: PUSH
26865: LD_VAR 0 8
26869: PUSH
26870: LD_INT 2
26872: ARRAY
26873: PUSH
26874: LD_VAR 0 13
26878: PUSH
26879: LD_INT 2
26881: PLUS
26882: GREATER
26883: OR
26884: PUSH
26885: LD_VAR 0 8
26889: PUSH
26890: LD_INT 2
26892: ARRAY
26893: PUSH
26894: LD_VAR 0 13
26898: PUSH
26899: LD_INT 2
26901: MINUS
26902: LESS
26903: OR
26904: PUSH
26905: LD_VAR 0 8
26909: PUSH
26910: LD_INT 3
26912: ARRAY
26913: PUSH
26914: LD_INT 0
26916: PUSH
26917: LD_INT 8
26919: PUSH
26920: LD_INT 9
26922: PUSH
26923: LD_INT 10
26925: PUSH
26926: LD_INT 11
26928: PUSH
26929: LD_INT 12
26931: PUSH
26932: LD_INT 13
26934: PUSH
26935: LD_INT 16
26937: PUSH
26938: LD_INT 17
26940: PUSH
26941: LD_INT 18
26943: PUSH
26944: LD_INT 19
26946: PUSH
26947: LD_INT 20
26949: PUSH
26950: LD_INT 21
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: LIST
26966: LIST
26967: IN
26968: NOT
26969: OR
26970: PUSH
26971: LD_VAR 0 8
26975: PUSH
26976: LD_INT 5
26978: ARRAY
26979: NOT
26980: OR
26981: PUSH
26982: LD_VAR 0 8
26986: PUSH
26987: LD_INT 6
26989: ARRAY
26990: PUSH
26991: LD_INT 1
26993: PUSH
26994: LD_INT 2
26996: PUSH
26997: LD_INT 7
26999: PUSH
27000: LD_INT 9
27002: PUSH
27003: LD_INT 10
27005: PUSH
27006: LD_INT 11
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: IN
27017: NOT
27018: OR
27019: IFFALSE 27025
// exit ;
27021: POP
27022: POP
27023: GO 27123
// end ;
27025: GO 26696
27027: POP
27028: POP
// side := GetSide ( depot ) ;
27029: LD_ADDR_VAR 0 9
27033: PUSH
27034: LD_VAR 0 1
27038: PPUSH
27039: CALL_OW 255
27043: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27044: LD_VAR 0 9
27048: PPUSH
27049: LD_VAR 0 3
27053: PPUSH
27054: LD_VAR 0 4
27058: PPUSH
27059: LD_INT 20
27061: PPUSH
27062: CALL 19444 0 4
27066: PUSH
27067: LD_INT 4
27069: ARRAY
27070: IFFALSE 27074
// exit ;
27072: GO 27123
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27074: LD_VAR 0 2
27078: PUSH
27079: LD_INT 29
27081: PUSH
27082: LD_INT 30
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: IN
27089: PUSH
27090: LD_VAR 0 3
27094: PPUSH
27095: LD_VAR 0 4
27099: PPUSH
27100: LD_VAR 0 9
27104: PPUSH
27105: CALL_OW 440
27109: NOT
27110: AND
27111: IFFALSE 27115
// exit ;
27113: GO 27123
// result := true ;
27115: LD_ADDR_VAR 0 6
27119: PUSH
27120: LD_INT 1
27122: ST_TO_ADDR
// end ;
27123: LD_VAR 0 6
27127: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27128: LD_INT 0
27130: PPUSH
27131: PPUSH
27132: PPUSH
27133: PPUSH
27134: PPUSH
27135: PPUSH
27136: PPUSH
27137: PPUSH
27138: PPUSH
27139: PPUSH
27140: PPUSH
27141: PPUSH
27142: PPUSH
27143: PPUSH
27144: PPUSH
27145: PPUSH
27146: PPUSH
27147: PPUSH
27148: PPUSH
27149: PPUSH
27150: PPUSH
27151: PPUSH
27152: PPUSH
27153: PPUSH
27154: PPUSH
27155: PPUSH
27156: PPUSH
27157: PPUSH
27158: PPUSH
27159: PPUSH
27160: PPUSH
27161: PPUSH
27162: PPUSH
27163: PPUSH
27164: PPUSH
27165: PPUSH
27166: PPUSH
27167: PPUSH
27168: PPUSH
27169: PPUSH
27170: PPUSH
27171: PPUSH
27172: PPUSH
27173: PPUSH
27174: PPUSH
27175: PPUSH
27176: PPUSH
27177: PPUSH
27178: PPUSH
27179: PPUSH
27180: PPUSH
27181: PPUSH
27182: PPUSH
27183: PPUSH
27184: PPUSH
27185: PPUSH
27186: PPUSH
27187: PPUSH
// result = [ ] ;
27188: LD_ADDR_VAR 0 7
27192: PUSH
27193: EMPTY
27194: ST_TO_ADDR
// temp_list = [ ] ;
27195: LD_ADDR_VAR 0 9
27199: PUSH
27200: EMPTY
27201: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27202: LD_VAR 0 4
27206: PUSH
27207: LD_INT 0
27209: PUSH
27210: LD_INT 1
27212: PUSH
27213: LD_INT 2
27215: PUSH
27216: LD_INT 3
27218: PUSH
27219: LD_INT 4
27221: PUSH
27222: LD_INT 5
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: LIST
27231: LIST
27232: IN
27233: NOT
27234: PUSH
27235: LD_VAR 0 1
27239: PUSH
27240: LD_INT 0
27242: PUSH
27243: LD_INT 1
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: IN
27250: PUSH
27251: LD_VAR 0 5
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: LD_INT 3
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: LIST
27269: IN
27270: NOT
27271: AND
27272: OR
27273: IFFALSE 27277
// exit ;
27275: GO 45668
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27277: LD_VAR 0 1
27281: PUSH
27282: LD_INT 6
27284: PUSH
27285: LD_INT 7
27287: PUSH
27288: LD_INT 8
27290: PUSH
27291: LD_INT 13
27293: PUSH
27294: LD_INT 12
27296: PUSH
27297: LD_INT 15
27299: PUSH
27300: LD_INT 11
27302: PUSH
27303: LD_INT 14
27305: PUSH
27306: LD_INT 10
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: IN
27320: IFFALSE 27330
// btype = b_lab ;
27322: LD_ADDR_VAR 0 1
27326: PUSH
27327: LD_INT 6
27329: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27330: LD_VAR 0 6
27334: PUSH
27335: LD_INT 0
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: LD_INT 2
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: LIST
27348: IN
27349: NOT
27350: PUSH
27351: LD_VAR 0 1
27355: PUSH
27356: LD_INT 0
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: LD_INT 2
27364: PUSH
27365: LD_INT 3
27367: PUSH
27368: LD_INT 6
27370: PUSH
27371: LD_INT 36
27373: PUSH
27374: LD_INT 4
27376: PUSH
27377: LD_INT 5
27379: PUSH
27380: LD_INT 31
27382: PUSH
27383: LD_INT 32
27385: PUSH
27386: LD_INT 33
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: IN
27402: NOT
27403: PUSH
27404: LD_VAR 0 6
27408: PUSH
27409: LD_INT 1
27411: EQUAL
27412: AND
27413: OR
27414: PUSH
27415: LD_VAR 0 1
27419: PUSH
27420: LD_INT 2
27422: PUSH
27423: LD_INT 3
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: IN
27430: NOT
27431: PUSH
27432: LD_VAR 0 6
27436: PUSH
27437: LD_INT 2
27439: EQUAL
27440: AND
27441: OR
27442: IFFALSE 27452
// mode = 0 ;
27444: LD_ADDR_VAR 0 6
27448: PUSH
27449: LD_INT 0
27451: ST_TO_ADDR
// case mode of 0 :
27452: LD_VAR 0 6
27456: PUSH
27457: LD_INT 0
27459: DOUBLE
27460: EQUAL
27461: IFTRUE 27465
27463: GO 38918
27465: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27466: LD_ADDR_VAR 0 11
27470: PUSH
27471: LD_INT 0
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: LD_INT 1
27486: NEG
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 1
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 1
27504: PUSH
27505: LD_INT 1
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 0
27514: PUSH
27515: LD_INT 1
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 1
27524: NEG
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 1
27535: NEG
27536: PUSH
27537: LD_INT 1
27539: NEG
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 1
27547: NEG
27548: PUSH
27549: LD_INT 2
27551: NEG
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 0
27559: PUSH
27560: LD_INT 2
27562: NEG
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: LD_INT 1
27573: NEG
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PUSH
27582: LD_INT 2
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: LD_INT 2
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 1
27601: NEG
27602: PUSH
27603: LD_INT 1
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 1
27612: PUSH
27613: LD_INT 3
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 0
27622: PUSH
27623: LD_INT 3
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 1
27632: NEG
27633: PUSH
27634: LD_INT 2
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27659: LD_ADDR_VAR 0 12
27663: PUSH
27664: LD_INT 0
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 0
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 1
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 1
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 0
27707: PUSH
27708: LD_INT 1
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 1
27717: NEG
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: LD_INT 1
27740: PUSH
27741: LD_INT 1
27743: NEG
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: LD_INT 0
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 1
27771: NEG
27772: PUSH
27773: LD_INT 1
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 2
27782: NEG
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: LD_INT 2
27793: NEG
27794: PUSH
27795: LD_INT 1
27797: NEG
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 2
27805: NEG
27806: PUSH
27807: LD_INT 1
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 3
27816: NEG
27817: PUSH
27818: LD_INT 0
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 3
27827: NEG
27828: PUSH
27829: LD_INT 1
27831: NEG
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27855: LD_ADDR_VAR 0 13
27859: PUSH
27860: LD_INT 0
27862: PUSH
27863: LD_INT 0
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 1
27875: NEG
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 1
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 1
27893: PUSH
27894: LD_INT 1
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 0
27903: PUSH
27904: LD_INT 1
27906: PUSH
27907: EMPTY
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 1
27913: NEG
27914: PUSH
27915: LD_INT 0
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: LD_INT 1
27928: NEG
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: LD_INT 1
27936: NEG
27937: PUSH
27938: LD_INT 2
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 1
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 2
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 1
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 2
27978: NEG
27979: PUSH
27980: LD_INT 1
27982: NEG
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: LD_INT 2
27990: NEG
27991: PUSH
27992: LD_INT 2
27994: NEG
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 2
28002: NEG
28003: PUSH
28004: LD_INT 3
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 3
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 3
28026: NEG
28027: PUSH
28028: LD_INT 3
28030: NEG
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: LIST
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28054: LD_ADDR_VAR 0 14
28058: PUSH
28059: LD_INT 0
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 0
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: LD_INT 0
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: LD_INT 1
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 0
28102: PUSH
28103: LD_INT 1
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 0
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 1
28123: NEG
28124: PUSH
28125: LD_INT 1
28127: NEG
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 0
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: LD_INT 1
28161: NEG
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 1
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: LD_INT 2
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 1
28189: NEG
28190: PUSH
28191: LD_INT 1
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 1
28200: NEG
28201: PUSH
28202: LD_INT 3
28204: NEG
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 0
28212: PUSH
28213: LD_INT 3
28215: NEG
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: LD_INT 2
28226: NEG
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28250: LD_ADDR_VAR 0 15
28254: PUSH
28255: LD_INT 0
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: LD_INT 0
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 1
28288: PUSH
28289: LD_INT 1
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 0
28298: PUSH
28299: LD_INT 1
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: LD_INT 0
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 1
28319: NEG
28320: PUSH
28321: LD_INT 1
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 1
28334: NEG
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 2
28342: PUSH
28343: LD_INT 0
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 1
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 1
28362: NEG
28363: PUSH
28364: LD_INT 1
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: NEG
28374: PUSH
28375: LD_INT 0
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: NEG
28385: PUSH
28386: LD_INT 1
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 2
28396: PUSH
28397: LD_INT 1
28399: NEG
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 3
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 3
28417: PUSH
28418: LD_INT 1
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28443: LD_ADDR_VAR 0 16
28447: PUSH
28448: LD_INT 0
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 0
28460: PUSH
28461: LD_INT 1
28463: NEG
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 1
28471: PUSH
28472: LD_INT 0
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 1
28481: PUSH
28482: LD_INT 1
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 1
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: PUSH
28499: LD_INT 1
28501: NEG
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: LD_INT 1
28516: NEG
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 1
28524: NEG
28525: PUSH
28526: LD_INT 2
28528: NEG
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 2
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 2
28546: PUSH
28547: LD_INT 2
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PUSH
28554: LD_INT 1
28556: PUSH
28557: LD_INT 2
28559: PUSH
28560: EMPTY
28561: LIST
28562: LIST
28563: PUSH
28564: LD_INT 2
28566: NEG
28567: PUSH
28568: LD_INT 1
28570: NEG
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 2
28578: NEG
28579: PUSH
28580: LD_INT 2
28582: NEG
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: PUSH
28588: LD_INT 3
28590: PUSH
28591: LD_INT 2
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 3
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 2
28610: PUSH
28611: LD_INT 3
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28636: LD_ADDR_VAR 0 17
28640: PUSH
28641: LD_INT 0
28643: PUSH
28644: LD_INT 0
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: LD_INT 0
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: LD_INT 1
28664: PUSH
28665: LD_INT 0
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 1
28674: PUSH
28675: LD_INT 1
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: LD_INT 1
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: LD_INT 0
28698: PUSH
28699: EMPTY
28700: LIST
28701: LIST
28702: PUSH
28703: LD_INT 1
28705: NEG
28706: PUSH
28707: LD_INT 1
28709: NEG
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: LD_INT 1
28717: NEG
28718: PUSH
28719: LD_INT 2
28721: NEG
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PUSH
28738: LD_INT 1
28740: PUSH
28741: LD_INT 1
28743: NEG
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: LD_INT 2
28751: PUSH
28752: LD_INT 0
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 1
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 2
28771: PUSH
28772: LD_INT 2
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: LD_INT 2
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: LD_INT 2
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: NEG
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 2
28812: NEG
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 2
28823: NEG
28824: PUSH
28825: LD_INT 1
28827: NEG
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 2
28835: NEG
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28866: LD_ADDR_VAR 0 18
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 0
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: PUSH
28895: LD_INT 0
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 1
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: PUSH
28912: LD_INT 0
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 1
28924: NEG
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 1
28947: NEG
28948: PUSH
28949: LD_INT 2
28951: NEG
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: LD_INT 0
28959: PUSH
28960: LD_INT 2
28962: NEG
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: LD_INT 1
28970: PUSH
28971: LD_INT 1
28973: NEG
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 0
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: PUSH
28989: LD_INT 2
28991: PUSH
28992: LD_INT 1
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: PUSH
28999: LD_INT 2
29001: PUSH
29002: LD_INT 2
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 1
29011: PUSH
29012: LD_INT 2
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 0
29021: PUSH
29022: LD_INT 2
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: NEG
29032: PUSH
29033: LD_INT 1
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 2
29042: NEG
29043: PUSH
29044: LD_INT 0
29046: PUSH
29047: EMPTY
29048: LIST
29049: LIST
29050: PUSH
29051: LD_INT 2
29053: NEG
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 2
29065: NEG
29066: PUSH
29067: LD_INT 2
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: LIST
29094: LIST
29095: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29096: LD_ADDR_VAR 0 19
29100: PUSH
29101: LD_INT 0
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 1
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 1
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 0
29144: PUSH
29145: LD_INT 1
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 1
29154: NEG
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 1
29165: NEG
29166: PUSH
29167: LD_INT 1
29169: NEG
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 1
29177: NEG
29178: PUSH
29179: LD_INT 2
29181: NEG
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 1
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 2
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 2
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PUSH
29242: LD_INT 2
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 0
29251: PUSH
29252: LD_INT 2
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: NEG
29262: PUSH
29263: LD_INT 1
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 2
29272: NEG
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 2
29283: NEG
29284: PUSH
29285: LD_INT 1
29287: NEG
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 2
29295: NEG
29296: PUSH
29297: LD_INT 2
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29326: LD_ADDR_VAR 0 20
29330: PUSH
29331: LD_INT 0
29333: PUSH
29334: LD_INT 0
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: LD_INT 1
29346: NEG
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: PUSH
29355: LD_INT 0
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 1
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: PUSH
29405: LD_INT 1
29407: NEG
29408: PUSH
29409: LD_INT 2
29411: NEG
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 1
29430: PUSH
29431: LD_INT 1
29433: NEG
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: PUSH
29439: LD_INT 2
29441: PUSH
29442: LD_INT 0
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PUSH
29449: LD_INT 2
29451: PUSH
29452: LD_INT 1
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 2
29461: PUSH
29462: LD_INT 2
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 2
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 2
29525: NEG
29526: PUSH
29527: LD_INT 2
29529: NEG
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: LIST
29550: LIST
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29556: LD_ADDR_VAR 0 21
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: LD_INT 0
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: LD_INT 1
29576: NEG
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: LD_INT 1
29584: PUSH
29585: LD_INT 0
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: LD_INT 1
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PUSH
29612: LD_INT 1
29614: NEG
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 1
29629: NEG
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: LD_INT 1
29637: NEG
29638: PUSH
29639: LD_INT 2
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 0
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: LD_INT 1
29663: NEG
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: PUSH
29692: LD_INT 2
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 2
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 0
29711: PUSH
29712: LD_INT 2
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: NEG
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 2
29732: NEG
29733: PUSH
29734: LD_INT 0
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 2
29743: NEG
29744: PUSH
29745: LD_INT 1
29747: NEG
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: LD_INT 2
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29786: LD_ADDR_VAR 0 22
29790: PUSH
29791: LD_INT 0
29793: PUSH
29794: LD_INT 0
29796: PUSH
29797: EMPTY
29798: LIST
29799: LIST
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: LD_INT 1
29806: NEG
29807: PUSH
29808: EMPTY
29809: LIST
29810: LIST
29811: PUSH
29812: LD_INT 1
29814: PUSH
29815: LD_INT 0
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 1
29824: PUSH
29825: LD_INT 1
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 1
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: NEG
29845: PUSH
29846: LD_INT 0
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 1
29855: NEG
29856: PUSH
29857: LD_INT 1
29859: NEG
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: NEG
29868: PUSH
29869: LD_INT 2
29871: NEG
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: LD_INT 2
29911: PUSH
29912: LD_INT 1
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 2
29921: PUSH
29922: LD_INT 2
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 2
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 0
29941: PUSH
29942: LD_INT 2
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: LD_INT 1
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 2
29962: NEG
29963: PUSH
29964: LD_INT 0
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 2
29973: NEG
29974: PUSH
29975: LD_INT 1
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 2
29985: NEG
29986: PUSH
29987: LD_INT 2
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30016: LD_ADDR_VAR 0 23
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: LD_INT 0
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: NEG
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: NEG
30098: PUSH
30099: LD_INT 2
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 0
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 1
30120: PUSH
30121: LD_INT 1
30123: NEG
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 2
30131: PUSH
30132: LD_INT 0
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 2
30141: PUSH
30142: LD_INT 1
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 2
30151: PUSH
30152: LD_INT 2
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 0
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: NEG
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 2
30192: NEG
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 2
30203: NEG
30204: PUSH
30205: LD_INT 1
30207: NEG
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PUSH
30213: LD_INT 2
30215: NEG
30216: PUSH
30217: LD_INT 2
30219: NEG
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 2
30227: NEG
30228: PUSH
30229: LD_INT 3
30231: NEG
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: NEG
30240: PUSH
30241: LD_INT 3
30243: NEG
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: LD_INT 2
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 2
30262: PUSH
30263: LD_INT 1
30265: NEG
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30296: LD_ADDR_VAR 0 24
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: LD_INT 1
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: LD_INT 1
30369: NEG
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: PUSH
30375: LD_INT 1
30377: NEG
30378: PUSH
30379: LD_INT 2
30381: NEG
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 0
30389: PUSH
30390: LD_INT 2
30392: NEG
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 1
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 2
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 2
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 2
30431: PUSH
30432: LD_INT 2
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: LD_INT 2
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: LD_INT 2
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: LD_INT 1
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 2
30472: NEG
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 2
30495: NEG
30496: PUSH
30497: LD_INT 2
30499: NEG
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: LD_INT 2
30510: NEG
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 2
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 3
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 3
30539: PUSH
30540: LD_INT 2
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: LIST
30562: LIST
30563: LIST
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30572: LD_ADDR_VAR 0 25
30576: PUSH
30577: LD_INT 0
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: LD_INT 1
30592: NEG
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: LD_INT 1
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 1
30641: NEG
30642: PUSH
30643: LD_INT 1
30645: NEG
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: LD_INT 2
30657: NEG
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 0
30665: PUSH
30666: LD_INT 2
30668: NEG
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: LD_INT 1
30679: NEG
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 2
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 2
30697: PUSH
30698: LD_INT 1
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 2
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 1
30717: PUSH
30718: LD_INT 2
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: LD_INT 2
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 1
30737: NEG
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 2
30748: NEG
30749: PUSH
30750: LD_INT 0
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 2
30759: NEG
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 2
30771: NEG
30772: PUSH
30773: LD_INT 2
30775: NEG
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 3
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 3
30793: PUSH
30794: LD_INT 2
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: PUSH
30804: LD_INT 3
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 1
30813: PUSH
30814: LD_INT 3
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: LIST
30844: LIST
30845: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30846: LD_ADDR_VAR 0 26
30850: PUSH
30851: LD_INT 0
30853: PUSH
30854: LD_INT 0
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 0
30863: PUSH
30864: LD_INT 1
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 1
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 1
30884: PUSH
30885: LD_INT 1
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 0
30894: PUSH
30895: LD_INT 1
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 1
30904: NEG
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: LD_INT 1
30919: NEG
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: LD_INT 2
30931: NEG
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: LD_INT 2
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 1
30950: PUSH
30951: LD_INT 1
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 2
30971: PUSH
30972: LD_INT 1
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 2
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 1
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 0
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 1
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 2
31022: NEG
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 2
31033: NEG
31034: PUSH
31035: LD_INT 1
31037: NEG
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 2
31045: NEG
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 2
31057: PUSH
31058: LD_INT 3
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 1
31067: PUSH
31068: LD_INT 3
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: NEG
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 2
31088: NEG
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: LIST
31114: LIST
31115: LIST
31116: LIST
31117: LIST
31118: LIST
31119: LIST
31120: LIST
31121: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31122: LD_ADDR_VAR 0 27
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: LD_INT 0
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 0
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: LD_INT 1
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 0
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: LD_INT 0
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 1
31191: NEG
31192: PUSH
31193: LD_INT 1
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: LD_INT 2
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 0
31215: PUSH
31216: LD_INT 2
31218: NEG
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 2
31237: PUSH
31238: LD_INT 0
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 2
31247: PUSH
31248: LD_INT 1
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: LD_INT 2
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: LD_INT 2
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: LD_INT 2
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 1
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: NEG
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 2
31309: NEG
31310: PUSH
31311: LD_INT 1
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 2
31321: NEG
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 1
31333: NEG
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 3
31355: NEG
31356: PUSH
31357: LD_INT 1
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 3
31367: NEG
31368: PUSH
31369: LD_INT 2
31371: NEG
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31402: LD_ADDR_VAR 0 28
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 0
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 0
31419: PUSH
31420: LD_INT 1
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 1
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 0
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 1
31471: NEG
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 1
31483: NEG
31484: PUSH
31485: LD_INT 2
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 2
31498: NEG
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: PUSH
31518: LD_INT 0
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 2
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 2
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 1
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 2
31578: NEG
31579: PUSH
31580: LD_INT 0
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: LD_INT 1
31593: NEG
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 3
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: LD_INT 3
31629: NEG
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 3
31637: NEG
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 3
31649: NEG
31650: PUSH
31651: LD_INT 2
31653: NEG
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31684: LD_ADDR_VAR 0 29
31688: PUSH
31689: LD_INT 0
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: LD_INT 1
31704: NEG
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 1
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 1
31722: PUSH
31723: LD_INT 1
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: LD_INT 2
31769: NEG
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 0
31777: PUSH
31778: LD_INT 2
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 1
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 2
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: LD_INT 2
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 2
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: LD_INT 1
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 2
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: NEG
31875: PUSH
31876: LD_INT 3
31878: NEG
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 3
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 1
31917: NEG
31918: PUSH
31919: LD_INT 2
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 3
31928: NEG
31929: PUSH
31930: LD_INT 2
31932: NEG
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31963: LD_ADDR_VAR 0 30
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 0
31980: PUSH
31981: LD_INT 1
31983: NEG
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: LD_INT 0
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 0
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 1
32021: NEG
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: LD_INT 1
32036: NEG
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 1
32044: NEG
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 1
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 0
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 2
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: PUSH
32109: LD_INT 2
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: NEG
32119: PUSH
32120: LD_INT 1
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 2
32129: NEG
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: NEG
32141: PUSH
32142: LD_INT 1
32144: NEG
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: NEG
32153: PUSH
32154: LD_INT 3
32156: NEG
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 3
32175: PUSH
32176: LD_INT 2
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 2
32185: PUSH
32186: LD_INT 3
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: LD_INT 1
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: LD_INT 1
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32241: LD_ADDR_VAR 0 31
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 0
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 0
32258: PUSH
32259: LD_INT 1
32261: NEG
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: PUSH
32270: LD_INT 0
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 0
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: LD_INT 1
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 2
32326: NEG
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: PUSH
32335: LD_INT 1
32337: NEG
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 1
32375: PUSH
32376: LD_INT 2
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: LD_INT 2
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 1
32395: NEG
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 2
32406: NEG
32407: PUSH
32408: LD_INT 1
32410: NEG
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 2
32418: NEG
32419: PUSH
32420: LD_INT 2
32422: NEG
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: LD_INT 3
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 2
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 3
32453: PUSH
32454: LD_INT 1
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 1
32473: NEG
32474: PUSH
32475: LD_INT 2
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 3
32484: NEG
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32519: LD_ADDR_VAR 0 32
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: LD_INT 0
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: LD_INT 1
32539: NEG
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 0
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 1
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 1
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 1
32577: NEG
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: LD_INT 1
32592: NEG
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: LD_INT 2
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 0
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 2
32634: PUSH
32635: LD_INT 1
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 2
32644: PUSH
32645: LD_INT 2
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 2
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 1
32708: NEG
32709: PUSH
32710: LD_INT 3
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 2
32723: NEG
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 3
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: LD_INT 3
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 2
32751: NEG
32752: PUSH
32753: LD_INT 1
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 3
32762: NEG
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32797: LD_ADDR_VAR 0 33
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: LD_INT 1
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: LD_INT 0
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 1
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 1
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: NEG
32879: PUSH
32880: LD_INT 2
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: LD_INT 1
32893: NEG
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: LD_INT 0
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 2
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 2
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: LD_INT 3
32991: NEG
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 2
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 3
33010: PUSH
33011: LD_INT 1
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: PUSH
33021: LD_INT 3
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 1
33030: NEG
33031: PUSH
33032: LD_INT 2
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 3
33041: NEG
33042: PUSH
33043: LD_INT 2
33045: NEG
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33076: LD_ADDR_VAR 0 34
33080: PUSH
33081: LD_INT 0
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 0
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: NEG
33135: PUSH
33136: LD_INT 0
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: LD_INT 2
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: LD_INT 2
33172: NEG
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: LD_INT 1
33183: NEG
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 2
33191: PUSH
33192: LD_INT 1
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 2
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 1
33211: PUSH
33212: LD_INT 2
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 2
33232: NEG
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: NEG
33244: PUSH
33245: LD_INT 1
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 2
33255: NEG
33256: PUSH
33257: LD_INT 2
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: NEG
33268: PUSH
33269: LD_INT 3
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: LD_INT 2
33282: NEG
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 3
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 2
33300: PUSH
33301: LD_INT 3
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 2
33310: NEG
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 3
33321: NEG
33322: PUSH
33323: LD_INT 1
33325: NEG
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33356: LD_ADDR_VAR 0 35
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: NEG
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 2
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 2
33447: NEG
33448: PUSH
33449: LD_INT 1
33451: NEG
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: LIST
33461: LIST
33462: LIST
33463: LIST
33464: LIST
33465: LIST
33466: LIST
33467: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33468: LD_ADDR_VAR 0 36
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 0
33485: PUSH
33486: LD_INT 1
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 1
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 0
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: NEG
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33580: LD_ADDR_VAR 0 37
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 0
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: LD_INT 0
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 1
33653: NEG
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: LD_INT 1
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 1
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33692: LD_ADDR_VAR 0 38
33696: PUSH
33697: LD_INT 0
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 0
33740: PUSH
33741: LD_INT 1
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 1
33750: NEG
33751: PUSH
33752: LD_INT 0
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 2
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: NEG
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: LIST
33803: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33804: LD_ADDR_VAR 0 39
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 1
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 1
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 1
33873: NEG
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: PUSH
33887: LD_INT 2
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 2
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33916: LD_ADDR_VAR 0 40
33920: PUSH
33921: LD_INT 0
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: LD_INT 1
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 1
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 1
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: NEG
33986: PUSH
33987: LD_INT 1
33989: NEG
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 1
33997: PUSH
33998: LD_INT 1
34000: NEG
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: LD_INT 1
34008: NEG
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: LIST
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34028: LD_ADDR_VAR 0 41
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: PUSH
34067: LD_INT 1
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: LD_INT 1
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 1
34086: NEG
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 1
34097: NEG
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: NEG
34110: PUSH
34111: LD_INT 2
34113: NEG
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 2
34132: PUSH
34133: LD_INT 0
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 2
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 2
34152: PUSH
34153: LD_INT 2
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 1
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: PUSH
34177: EMPTY
34178: LIST
34179: LIST
34180: PUSH
34181: LD_INT 2
34183: NEG
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 2
34194: NEG
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: NEG
34207: PUSH
34208: LD_INT 2
34210: NEG
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 2
34218: NEG
34219: PUSH
34220: LD_INT 3
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 2
34230: PUSH
34231: LD_INT 1
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 3
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 3
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 3
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 3
34271: PUSH
34272: LD_INT 3
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 2
34281: PUSH
34282: LD_INT 3
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 3
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 3
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: LD_INT 2
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 3
34337: NEG
34338: PUSH
34339: LD_INT 3
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34378: LD_ADDR_VAR 0 42
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: LD_INT 1
34398: NEG
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: LD_INT 1
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 1
34416: PUSH
34417: LD_INT 1
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: LD_INT 1
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: LD_INT 1
34451: NEG
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 1
34459: NEG
34460: PUSH
34461: LD_INT 2
34463: NEG
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 0
34471: PUSH
34472: LD_INT 2
34474: NEG
34475: PUSH
34476: EMPTY
34477: LIST
34478: LIST
34479: PUSH
34480: LD_INT 1
34482: PUSH
34483: LD_INT 1
34485: NEG
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 2
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 2
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 2
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: LD_INT 2
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 2
34544: NEG
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 2
34556: NEG
34557: PUSH
34558: LD_INT 2
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 2
34568: NEG
34569: PUSH
34570: LD_INT 3
34572: NEG
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: LD_INT 3
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: LD_INT 3
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 3
34614: PUSH
34615: LD_INT 2
34617: PUSH
34618: EMPTY
34619: LIST
34620: LIST
34621: PUSH
34622: LD_INT 3
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 2
34634: PUSH
34635: LD_INT 3
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: LD_INT 3
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 3
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: NEG
34665: PUSH
34666: LD_INT 2
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 3
34675: NEG
34676: PUSH
34677: LD_INT 2
34679: NEG
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 3
34687: NEG
34688: PUSH
34689: LD_INT 3
34691: NEG
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34728: LD_ADDR_VAR 0 43
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 1
34748: NEG
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: LD_INT 2
34813: NEG
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: PUSH
34833: LD_INT 1
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: PUSH
34854: LD_INT 1
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 2
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 2
34894: NEG
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 2
34905: NEG
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: NEG
34918: PUSH
34919: LD_INT 3
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 3
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: LD_INT 2
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 3
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 3
34972: PUSH
34973: LD_INT 1
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 1
35002: NEG
35003: PUSH
35004: LD_INT 2
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 2
35013: NEG
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 3
35024: NEG
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 3
35035: NEG
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35076: LD_ADDR_VAR 0 44
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: LD_INT 1
35096: NEG
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: LD_INT 1
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 0
35124: PUSH
35125: LD_INT 1
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: NEG
35135: PUSH
35136: LD_INT 0
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 1
35145: NEG
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: NEG
35158: PUSH
35159: LD_INT 2
35161: NEG
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 2
35266: NEG
35267: PUSH
35268: LD_INT 3
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 2
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 3
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 3
35299: PUSH
35300: LD_INT 1
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: LD_INT 3
35309: PUSH
35310: LD_INT 2
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 3
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: PUSH
35330: LD_INT 3
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 2
35339: NEG
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 3
35350: NEG
35351: PUSH
35352: LD_INT 0
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 3
35361: NEG
35362: PUSH
35363: LD_INT 1
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 3
35373: NEG
35374: PUSH
35375: LD_INT 2
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 3
35385: NEG
35386: PUSH
35387: LD_INT 3
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35426: LD_ADDR_VAR 0 45
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: LD_INT 0
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: LD_INT 1
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: LD_INT 1
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 1
35484: NEG
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: LD_INT 2
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: LD_INT 2
35522: NEG
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 2
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 2
35551: PUSH
35552: LD_INT 2
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 2
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 0
35571: PUSH
35572: LD_INT 2
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 2
35592: NEG
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 2
35604: NEG
35605: PUSH
35606: LD_INT 2
35608: NEG
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 2
35616: NEG
35617: PUSH
35618: LD_INT 3
35620: NEG
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 3
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: LD_INT 3
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 3
35662: PUSH
35663: LD_INT 2
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 3
35672: PUSH
35673: LD_INT 3
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 2
35682: PUSH
35683: LD_INT 3
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: PUSH
35693: LD_INT 3
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: LD_INT 3
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 1
35712: NEG
35713: PUSH
35714: LD_INT 2
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 3
35723: NEG
35724: PUSH
35725: LD_INT 2
35727: NEG
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 3
35735: NEG
35736: PUSH
35737: LD_INT 3
35739: NEG
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35776: LD_ADDR_VAR 0 46
35780: PUSH
35781: LD_INT 0
35783: PUSH
35784: LD_INT 0
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: LD_INT 1
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 1
35834: NEG
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: LD_INT 1
35849: NEG
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: LD_INT 2
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: PUSH
35881: LD_INT 1
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 2
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 2
35901: PUSH
35902: LD_INT 1
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: LD_INT 2
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 0
35921: PUSH
35922: LD_INT 2
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: LD_INT 1
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 2
35942: NEG
35943: PUSH
35944: LD_INT 0
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 2
35953: NEG
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: LD_INT 3
35980: NEG
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 2
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 3
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 3
36020: PUSH
36021: LD_INT 1
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 1
36030: PUSH
36031: LD_INT 3
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: PUSH
36038: LD_INT 0
36040: PUSH
36041: LD_INT 3
36043: PUSH
36044: EMPTY
36045: LIST
36046: LIST
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: LD_INT 2
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: LD_INT 1
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 3
36072: NEG
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 3
36083: NEG
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: LIST
36099: LIST
36100: LIST
36101: LIST
36102: LIST
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36124: LD_ADDR_VAR 0 47
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 1
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 0
36172: PUSH
36173: LD_INT 1
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: NEG
36183: PUSH
36184: LD_INT 0
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: LD_INT 2
36209: NEG
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 2
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 2
36239: NEG
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 2
36251: NEG
36252: PUSH
36253: LD_INT 2
36255: NEG
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36275: LD_ADDR_VAR 0 48
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 1
36295: NEG
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 1
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 0
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 1
36344: NEG
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: LD_INT 2
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: PUSH
36380: LD_INT 1
36382: NEG
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: LD_INT 0
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 1
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36422: LD_ADDR_VAR 0 49
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 0
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 1
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 2
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: EMPTY
36519: LIST
36520: LIST
36521: PUSH
36522: LD_INT 2
36524: PUSH
36525: LD_INT 1
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 2
36534: PUSH
36535: LD_INT 2
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 2
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: LIST
36564: LIST
36565: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36566: LD_ADDR_VAR 0 50
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: LD_INT 0
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: LD_INT 1
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 1
36635: NEG
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 2
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 2
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: PUSH
36668: LD_INT 2
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 2
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36710: LD_ADDR_VAR 0 51
36714: PUSH
36715: LD_INT 0
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 1
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: LD_INT 2
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: LD_INT 2
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: LD_INT 1
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 2
36822: NEG
36823: PUSH
36824: LD_INT 0
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 2
36833: NEG
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36857: LD_ADDR_VAR 0 52
36861: PUSH
36862: LD_INT 0
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: LD_INT 0
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: LD_INT 2
36942: NEG
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: LD_INT 1
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 2
36972: NEG
36973: PUSH
36974: LD_INT 1
36976: NEG
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 2
36984: NEG
36985: PUSH
36986: LD_INT 2
36988: NEG
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37008: LD_ADDR_VAR 0 53
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: LD_INT 0
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 0
37025: PUSH
37026: LD_INT 1
37028: NEG
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 0
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 1
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 0
37056: PUSH
37057: LD_INT 1
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 1
37077: NEG
37078: PUSH
37079: LD_INT 1
37081: NEG
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 1
37089: NEG
37090: PUSH
37091: LD_INT 2
37093: NEG
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 0
37101: PUSH
37102: LD_INT 2
37104: NEG
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 2
37123: PUSH
37124: LD_INT 0
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: PUSH
37134: LD_INT 1
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 2
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 1
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 2
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: LD_INT 2
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37238: LD_ADDR_VAR 0 54
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: LD_INT 0
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 0
37255: PUSH
37256: LD_INT 1
37258: NEG
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: PUSH
37267: LD_INT 0
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 1
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 0
37286: PUSH
37287: LD_INT 1
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: NEG
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: NEG
37320: PUSH
37321: LD_INT 2
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 0
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 2
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: LD_INT 2
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 1
37383: PUSH
37384: LD_INT 2
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 0
37393: PUSH
37394: LD_INT 2
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 2
37414: NEG
37415: PUSH
37416: LD_INT 0
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: PUSH
37423: LD_INT 2
37425: NEG
37426: PUSH
37427: LD_INT 1
37429: NEG
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 2
37437: NEG
37438: PUSH
37439: LD_INT 2
37441: NEG
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: LIST
37462: LIST
37463: LIST
37464: LIST
37465: LIST
37466: LIST
37467: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37468: LD_ADDR_VAR 0 55
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 0
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 1
37496: PUSH
37497: LD_INT 0
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 1
37506: PUSH
37507: LD_INT 1
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: PUSH
37514: LD_INT 0
37516: PUSH
37517: LD_INT 1
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 1
37526: NEG
37527: PUSH
37528: LD_INT 0
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 1
37537: NEG
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: LD_INT 2
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 0
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: LD_INT 1
37575: NEG
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 2
37583: PUSH
37584: LD_INT 0
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 2
37593: PUSH
37594: LD_INT 1
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 2
37603: PUSH
37604: LD_INT 2
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: LD_INT 2
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 2
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 2
37644: NEG
37645: PUSH
37646: LD_INT 0
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: LD_INT 2
37655: NEG
37656: PUSH
37657: LD_INT 1
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: NEG
37668: PUSH
37669: LD_INT 2
37671: NEG
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37698: LD_ADDR_VAR 0 56
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 1
37718: NEG
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 1
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 1
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 1
37756: NEG
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 1
37767: NEG
37768: PUSH
37769: LD_INT 1
37771: NEG
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 1
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: PUSH
37814: LD_INT 0
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 2
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: PUSH
37834: LD_INT 2
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 2
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 0
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: NEG
37864: PUSH
37865: LD_INT 1
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: LD_INT 0
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 2
37897: NEG
37898: PUSH
37899: LD_INT 2
37901: NEG
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37928: LD_ADDR_VAR 0 57
37932: PUSH
37933: LD_INT 0
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 1
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 0
37976: PUSH
37977: LD_INT 1
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 1
37986: NEG
37987: PUSH
37988: LD_INT 0
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: LD_INT 1
38001: NEG
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: LD_INT 2
38013: NEG
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 1
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 2
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 2
38053: PUSH
38054: LD_INT 1
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 2
38063: PUSH
38064: LD_INT 2
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 2
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 2
38104: NEG
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: NEG
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 2
38127: NEG
38128: PUSH
38129: LD_INT 2
38131: NEG
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: LIST
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38158: LD_ADDR_VAR 0 58
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: LD_INT 0
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: LD_INT 1
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: LD_INT 0
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: NEG
38217: PUSH
38218: LD_INT 0
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: LD_INT 1
38231: NEG
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: LD_INT 2
38243: NEG
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: LD_INT 1
38262: PUSH
38263: LD_INT 1
38265: NEG
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 2
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: LD_INT 1
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 2
38293: PUSH
38294: LD_INT 2
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 2
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 0
38313: PUSH
38314: LD_INT 2
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 2
38334: NEG
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: LD_INT 2
38361: NEG
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: LIST
38380: LIST
38381: LIST
38382: LIST
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38388: LD_ADDR_VAR 0 59
38392: PUSH
38393: LD_INT 0
38395: PUSH
38396: LD_INT 0
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 0
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: LD_INT 0
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: LD_INT 1
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 1
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 1
38457: NEG
38458: PUSH
38459: LD_INT 1
38461: NEG
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38476: LD_ADDR_VAR 0 60
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: LD_INT 1
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38564: LD_ADDR_VAR 0 61
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: PUSH
38593: LD_INT 0
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 1
38602: PUSH
38603: LD_INT 1
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: LD_INT 1
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38652: LD_ADDR_VAR 0 62
38656: PUSH
38657: LD_INT 0
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: LD_INT 1
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: LD_INT 0
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: LD_INT 1
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: LD_INT 1
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: LD_INT 1
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38740: LD_ADDR_VAR 0 63
38744: PUSH
38745: LD_INT 0
38747: PUSH
38748: LD_INT 0
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 0
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: PUSH
38769: LD_INT 0
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: LD_INT 1
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 0
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: NEG
38799: PUSH
38800: LD_INT 0
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 1
38809: NEG
38810: PUSH
38811: LD_INT 1
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38828: LD_ADDR_VAR 0 64
38832: PUSH
38833: LD_INT 0
38835: PUSH
38836: LD_INT 0
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 1
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 1
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: ST_TO_ADDR
// end ; 1 :
38916: GO 44813
38918: LD_INT 1
38920: DOUBLE
38921: EQUAL
38922: IFTRUE 38926
38924: GO 41549
38926: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38927: LD_ADDR_VAR 0 11
38931: PUSH
38932: LD_INT 1
38934: NEG
38935: PUSH
38936: LD_INT 3
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: LD_INT 3
38949: NEG
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: PUSH
38958: LD_INT 2
38960: NEG
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: LIST
38970: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38971: LD_ADDR_VAR 0 12
38975: PUSH
38976: LD_INT 2
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 3
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 3
38999: PUSH
39000: LD_INT 1
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: LIST
39011: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39012: LD_ADDR_VAR 0 13
39016: PUSH
39017: LD_INT 3
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 3
39029: PUSH
39030: LD_INT 3
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 2
39039: PUSH
39040: LD_INT 3
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39052: LD_ADDR_VAR 0 14
39056: PUSH
39057: LD_INT 1
39059: PUSH
39060: LD_INT 3
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: LD_INT 3
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 1
39079: NEG
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39093: LD_ADDR_VAR 0 15
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 3
39111: NEG
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 3
39122: NEG
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39137: LD_ADDR_VAR 0 16
39141: PUSH
39142: LD_INT 2
39144: NEG
39145: PUSH
39146: LD_INT 3
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 3
39156: NEG
39157: PUSH
39158: LD_INT 2
39160: NEG
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 3
39168: NEG
39169: PUSH
39170: LD_INT 3
39172: NEG
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: LIST
39182: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39183: LD_ADDR_VAR 0 17
39187: PUSH
39188: LD_INT 1
39190: NEG
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 2
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: LIST
39226: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39227: LD_ADDR_VAR 0 18
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 3
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 3
39255: PUSH
39256: LD_INT 1
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: LIST
39267: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39268: LD_ADDR_VAR 0 19
39272: PUSH
39273: LD_INT 3
39275: PUSH
39276: LD_INT 2
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 3
39285: PUSH
39286: LD_INT 3
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 3
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: LIST
39307: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39308: LD_ADDR_VAR 0 20
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 3
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 0
39325: PUSH
39326: LD_INT 3
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 2
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39349: LD_ADDR_VAR 0 21
39353: PUSH
39354: LD_INT 2
39356: NEG
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 3
39367: NEG
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 3
39378: NEG
39379: PUSH
39380: LD_INT 1
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39393: LD_ADDR_VAR 0 22
39397: PUSH
39398: LD_INT 2
39400: NEG
39401: PUSH
39402: LD_INT 3
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 3
39412: NEG
39413: PUSH
39414: LD_INT 2
39416: NEG
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 3
39424: NEG
39425: PUSH
39426: LD_INT 3
39428: NEG
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: LIST
39438: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39439: LD_ADDR_VAR 0 23
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: LD_INT 3
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 4
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: LD_INT 3
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: LIST
39482: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39483: LD_ADDR_VAR 0 24
39487: PUSH
39488: LD_INT 3
39490: PUSH
39491: LD_INT 0
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 3
39500: PUSH
39501: LD_INT 1
39503: NEG
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 4
39511: PUSH
39512: LD_INT 1
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: LIST
39523: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39524: LD_ADDR_VAR 0 25
39528: PUSH
39529: LD_INT 3
39531: PUSH
39532: LD_INT 3
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 4
39541: PUSH
39542: LD_INT 3
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: LD_INT 4
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: LIST
39563: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39564: LD_ADDR_VAR 0 26
39568: PUSH
39569: LD_INT 0
39571: PUSH
39572: LD_INT 3
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 1
39581: PUSH
39582: LD_INT 4
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: NEG
39592: PUSH
39593: LD_INT 3
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: LIST
39604: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39605: LD_ADDR_VAR 0 27
39609: PUSH
39610: LD_INT 3
39612: NEG
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 3
39623: NEG
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 4
39634: NEG
39635: PUSH
39636: LD_INT 1
39638: NEG
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: LIST
39648: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39649: LD_ADDR_VAR 0 28
39653: PUSH
39654: LD_INT 3
39656: NEG
39657: PUSH
39658: LD_INT 3
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 3
39668: NEG
39669: PUSH
39670: LD_INT 4
39672: NEG
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 4
39680: NEG
39681: PUSH
39682: LD_INT 3
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: LIST
39694: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39695: LD_ADDR_VAR 0 29
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 0
39714: PUSH
39715: LD_INT 3
39717: NEG
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: PUSH
39726: LD_INT 2
39728: NEG
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: LD_INT 4
39740: NEG
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: LD_INT 4
39751: NEG
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: PUSH
39760: LD_INT 3
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 5
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 5
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 1
39793: PUSH
39794: LD_INT 4
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: NEG
39805: PUSH
39806: LD_INT 6
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 0
39816: PUSH
39817: LD_INT 6
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: LD_INT 5
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39850: LD_ADDR_VAR 0 30
39854: PUSH
39855: LD_INT 2
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 3
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 3
39878: PUSH
39879: LD_INT 1
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 1
39891: NEG
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 4
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 4
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 4
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 5
39930: PUSH
39931: LD_INT 0
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 1
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 1
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 6
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 6
39971: PUSH
39972: LD_INT 1
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39993: LD_ADDR_VAR 0 31
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 3
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 2
40020: PUSH
40021: LD_INT 3
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 4
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 4
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 3
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 5
40060: PUSH
40061: LD_INT 4
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 5
40070: PUSH
40071: LD_INT 5
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 4
40080: PUSH
40081: LD_INT 5
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 6
40090: PUSH
40091: LD_INT 5
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 6
40100: PUSH
40101: LD_INT 6
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 5
40110: PUSH
40111: LD_INT 6
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40132: LD_ADDR_VAR 0 32
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 3
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 0
40149: PUSH
40150: LD_INT 3
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 2
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: LD_INT 4
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: LD_INT 4
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: LD_INT 3
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 1
40201: PUSH
40202: LD_INT 5
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 0
40211: PUSH
40212: LD_INT 5
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 1
40221: NEG
40222: PUSH
40223: LD_INT 4
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: LD_INT 6
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: LD_INT 6
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: NEG
40253: PUSH
40254: LD_INT 5
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40275: LD_ADDR_VAR 0 33
40279: PUSH
40280: LD_INT 2
40282: NEG
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: NEG
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 3
40304: NEG
40305: PUSH
40306: LD_INT 1
40308: NEG
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 3
40316: NEG
40317: PUSH
40318: LD_INT 1
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 4
40327: NEG
40328: PUSH
40329: LD_INT 0
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: LD_INT 1
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 4
40350: NEG
40351: PUSH
40352: LD_INT 1
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 5
40361: NEG
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 5
40372: NEG
40373: PUSH
40374: LD_INT 1
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: LD_INT 1
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 6
40395: NEG
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 6
40406: NEG
40407: PUSH
40408: LD_INT 1
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40430: LD_ADDR_VAR 0 34
40434: PUSH
40435: LD_INT 2
40437: NEG
40438: PUSH
40439: LD_INT 3
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 3
40449: NEG
40450: PUSH
40451: LD_INT 2
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 3
40461: NEG
40462: PUSH
40463: LD_INT 3
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 3
40473: NEG
40474: PUSH
40475: LD_INT 4
40477: NEG
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 4
40485: NEG
40486: PUSH
40487: LD_INT 3
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 4
40497: NEG
40498: PUSH
40499: LD_INT 4
40501: NEG
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 4
40509: NEG
40510: PUSH
40511: LD_INT 5
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 5
40521: NEG
40522: PUSH
40523: LD_INT 4
40525: NEG
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 5
40533: NEG
40534: PUSH
40535: LD_INT 5
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 5
40545: NEG
40546: PUSH
40547: LD_INT 6
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 6
40557: NEG
40558: PUSH
40559: LD_INT 5
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 6
40569: NEG
40570: PUSH
40571: LD_INT 6
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40593: LD_ADDR_VAR 0 41
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: LD_INT 2
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: NEG
40612: PUSH
40613: LD_INT 3
40615: NEG
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 1
40623: PUSH
40624: LD_INT 2
40626: NEG
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: LIST
40636: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40637: LD_ADDR_VAR 0 42
40641: PUSH
40642: LD_INT 2
40644: PUSH
40645: LD_INT 0
40647: PUSH
40648: EMPTY
40649: LIST
40650: LIST
40651: PUSH
40652: LD_INT 2
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 3
40665: PUSH
40666: LD_INT 1
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: LIST
40677: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40678: LD_ADDR_VAR 0 43
40682: PUSH
40683: LD_INT 2
40685: PUSH
40686: LD_INT 2
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 3
40695: PUSH
40696: LD_INT 2
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 2
40705: PUSH
40706: LD_INT 3
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: LIST
40717: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40718: LD_ADDR_VAR 0 44
40722: PUSH
40723: LD_INT 0
40725: PUSH
40726: LD_INT 2
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: LD_INT 1
40735: PUSH
40736: LD_INT 3
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: LD_INT 2
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: LIST
40758: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40759: LD_ADDR_VAR 0 45
40763: PUSH
40764: LD_INT 2
40766: NEG
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 2
40777: NEG
40778: PUSH
40779: LD_INT 1
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 3
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40803: LD_ADDR_VAR 0 46
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 2
40822: NEG
40823: PUSH
40824: LD_INT 3
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 3
40834: NEG
40835: PUSH
40836: LD_INT 2
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: LIST
40848: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40849: LD_ADDR_VAR 0 47
40853: PUSH
40854: LD_INT 2
40856: NEG
40857: PUSH
40858: LD_INT 3
40860: NEG
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 1
40868: NEG
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40882: LD_ADDR_VAR 0 48
40886: PUSH
40887: LD_INT 1
40889: PUSH
40890: LD_INT 2
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 1
40903: NEG
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40913: LD_ADDR_VAR 0 49
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 3
40930: PUSH
40931: LD_INT 2
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40942: LD_ADDR_VAR 0 50
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: LD_INT 3
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 3
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40971: LD_ADDR_VAR 0 51
40975: PUSH
40976: LD_INT 1
40978: NEG
40979: PUSH
40980: LD_INT 2
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 2
40989: NEG
40990: PUSH
40991: LD_INT 1
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41002: LD_ADDR_VAR 0 52
41006: PUSH
41007: LD_INT 3
41009: NEG
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: LD_INT 2
41025: NEG
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41035: LD_ADDR_VAR 0 53
41039: PUSH
41040: LD_INT 1
41042: NEG
41043: PUSH
41044: LD_INT 3
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: LD_INT 3
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 1
41065: PUSH
41066: LD_INT 2
41068: NEG
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: LIST
41078: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41079: LD_ADDR_VAR 0 54
41083: PUSH
41084: LD_INT 2
41086: PUSH
41087: LD_INT 1
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 3
41107: PUSH
41108: LD_INT 1
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: LIST
41119: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41120: LD_ADDR_VAR 0 55
41124: PUSH
41125: LD_INT 3
41127: PUSH
41128: LD_INT 2
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: LD_INT 3
41137: PUSH
41138: LD_INT 3
41140: PUSH
41141: EMPTY
41142: LIST
41143: LIST
41144: PUSH
41145: LD_INT 2
41147: PUSH
41148: LD_INT 3
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41160: LD_ADDR_VAR 0 56
41164: PUSH
41165: LD_INT 1
41167: PUSH
41168: LD_INT 3
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 3
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 1
41187: NEG
41188: PUSH
41189: LD_INT 2
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: LIST
41200: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41201: LD_ADDR_VAR 0 57
41205: PUSH
41206: LD_INT 2
41208: NEG
41209: PUSH
41210: LD_INT 1
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 3
41219: NEG
41220: PUSH
41221: LD_INT 0
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 3
41230: NEG
41231: PUSH
41232: LD_INT 1
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: LIST
41244: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41245: LD_ADDR_VAR 0 58
41249: PUSH
41250: LD_INT 2
41252: NEG
41253: PUSH
41254: LD_INT 3
41256: NEG
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 3
41264: NEG
41265: PUSH
41266: LD_INT 2
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 3
41276: NEG
41277: PUSH
41278: LD_INT 3
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: LIST
41290: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41291: LD_ADDR_VAR 0 59
41295: PUSH
41296: LD_INT 1
41298: NEG
41299: PUSH
41300: LD_INT 2
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 0
41310: PUSH
41311: LD_INT 2
41313: NEG
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 1
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: LIST
41334: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41335: LD_ADDR_VAR 0 60
41339: PUSH
41340: LD_INT 1
41342: PUSH
41343: LD_INT 1
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 2
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 2
41363: PUSH
41364: LD_INT 1
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: LIST
41375: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41376: LD_ADDR_VAR 0 61
41380: PUSH
41381: LD_INT 2
41383: PUSH
41384: LD_INT 1
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: LD_INT 2
41393: PUSH
41394: LD_INT 2
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 1
41403: PUSH
41404: LD_INT 2
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: LIST
41415: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41416: LD_ADDR_VAR 0 62
41420: PUSH
41421: LD_INT 1
41423: PUSH
41424: LD_INT 2
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: LD_INT 2
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 1
41443: NEG
41444: PUSH
41445: LD_INT 1
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: LIST
41456: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41457: LD_ADDR_VAR 0 63
41461: PUSH
41462: LD_INT 1
41464: NEG
41465: PUSH
41466: LD_INT 1
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 2
41475: NEG
41476: PUSH
41477: LD_INT 0
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 2
41486: NEG
41487: PUSH
41488: LD_INT 1
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41501: LD_ADDR_VAR 0 64
41505: PUSH
41506: LD_INT 1
41508: NEG
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 2
41520: NEG
41521: PUSH
41522: LD_INT 1
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 2
41532: NEG
41533: PUSH
41534: LD_INT 2
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: LIST
41546: ST_TO_ADDR
// end ; 2 :
41547: GO 44813
41549: LD_INT 2
41551: DOUBLE
41552: EQUAL
41553: IFTRUE 41557
41555: GO 44812
41557: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41558: LD_ADDR_VAR 0 29
41562: PUSH
41563: LD_INT 4
41565: PUSH
41566: LD_INT 0
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 4
41575: PUSH
41576: LD_INT 1
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 5
41586: PUSH
41587: LD_INT 0
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 5
41596: PUSH
41597: LD_INT 1
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 4
41606: PUSH
41607: LD_INT 1
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 3
41616: PUSH
41617: LD_INT 0
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 3
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 3
41637: PUSH
41638: LD_INT 2
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 5
41648: PUSH
41649: LD_INT 2
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 3
41668: PUSH
41669: LD_INT 2
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 4
41678: PUSH
41679: LD_INT 3
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 4
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 4
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 2
41718: PUSH
41719: LD_INT 2
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 4
41728: PUSH
41729: LD_INT 2
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 2
41738: PUSH
41739: LD_INT 4
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 0
41748: PUSH
41749: LD_INT 4
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PUSH
41756: LD_INT 0
41758: PUSH
41759: LD_INT 3
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 1
41768: PUSH
41769: LD_INT 4
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 1
41778: PUSH
41779: LD_INT 5
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: LD_INT 5
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 1
41798: NEG
41799: PUSH
41800: LD_INT 4
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 1
41809: NEG
41810: PUSH
41811: LD_INT 3
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 2
41820: PUSH
41821: LD_INT 5
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 2
41830: NEG
41831: PUSH
41832: LD_INT 3
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: LD_INT 0
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: NEG
41853: PUSH
41854: LD_INT 1
41856: NEG
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: LD_INT 0
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: LD_INT 2
41875: NEG
41876: PUSH
41877: LD_INT 1
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 3
41886: NEG
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: NEG
41898: PUSH
41899: LD_INT 0
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 4
41908: NEG
41909: PUSH
41910: LD_INT 1
41912: NEG
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 4
41920: NEG
41921: PUSH
41922: LD_INT 2
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 2
41932: NEG
41933: PUSH
41934: LD_INT 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 4
41943: NEG
41944: PUSH
41945: LD_INT 4
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 4
41955: NEG
41956: PUSH
41957: LD_INT 5
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 3
41967: NEG
41968: PUSH
41969: LD_INT 4
41971: NEG
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 3
41979: NEG
41980: PUSH
41981: LD_INT 3
41983: NEG
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 4
41991: NEG
41992: PUSH
41993: LD_INT 3
41995: NEG
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 5
42003: NEG
42004: PUSH
42005: LD_INT 4
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 5
42015: NEG
42016: PUSH
42017: LD_INT 5
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: NEG
42028: PUSH
42029: LD_INT 5
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 5
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: LIST
42095: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42096: LD_ADDR_VAR 0 30
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 4
42113: PUSH
42114: LD_INT 3
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 5
42123: PUSH
42124: LD_INT 4
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 5
42133: PUSH
42134: LD_INT 5
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 3
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 3
42163: PUSH
42164: LD_INT 3
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 3
42183: PUSH
42184: LD_INT 5
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 0
42193: PUSH
42194: LD_INT 3
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 0
42203: PUSH
42204: LD_INT 2
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: PUSH
42214: LD_INT 3
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 1
42223: PUSH
42224: LD_INT 4
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 0
42233: PUSH
42234: LD_INT 4
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 1
42243: NEG
42244: PUSH
42245: LD_INT 3
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 1
42254: NEG
42255: PUSH
42256: LD_INT 2
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 4
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 2
42275: NEG
42276: PUSH
42277: LD_INT 2
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 4
42286: NEG
42287: PUSH
42288: LD_INT 0
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 3
42309: NEG
42310: PUSH
42311: LD_INT 0
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 3
42320: NEG
42321: PUSH
42322: LD_INT 1
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: LD_INT 1
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 5
42342: NEG
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 5
42353: NEG
42354: PUSH
42355: LD_INT 1
42357: NEG
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 5
42365: NEG
42366: PUSH
42367: LD_INT 2
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: NEG
42378: PUSH
42379: LD_INT 2
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: LD_INT 4
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 2
42412: NEG
42413: PUSH
42414: LD_INT 3
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 2
42424: NEG
42425: PUSH
42426: LD_INT 2
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 3
42436: NEG
42437: PUSH
42438: LD_INT 2
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 4
42448: NEG
42449: PUSH
42450: LD_INT 3
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 4
42460: NEG
42461: PUSH
42462: LD_INT 4
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 2
42472: NEG
42473: PUSH
42474: LD_INT 4
42476: NEG
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 4
42484: NEG
42485: PUSH
42486: LD_INT 2
42488: NEG
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 0
42496: PUSH
42497: LD_INT 4
42499: NEG
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 5
42510: NEG
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: LD_INT 4
42521: NEG
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: LD_INT 3
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: LD_INT 3
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 4
42555: NEG
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 1
42563: NEG
42564: PUSH
42565: LD_INT 5
42567: NEG
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: LD_INT 3
42578: NEG
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 2
42586: NEG
42587: PUSH
42588: LD_INT 5
42590: NEG
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42643: LD_ADDR_VAR 0 31
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 4
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 1
42670: PUSH
42671: LD_INT 4
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: PUSH
42678: LD_INT 1
42680: PUSH
42681: LD_INT 5
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 0
42690: PUSH
42691: LD_INT 5
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 1
42700: NEG
42701: PUSH
42702: LD_INT 4
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: LD_INT 1
42711: NEG
42712: PUSH
42713: LD_INT 3
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 2
42722: PUSH
42723: LD_INT 5
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 2
42732: NEG
42733: PUSH
42734: LD_INT 3
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 3
42743: NEG
42744: PUSH
42745: LD_INT 0
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: LD_INT 1
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 2
42766: NEG
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: PUSH
42775: LD_INT 2
42777: NEG
42778: PUSH
42779: LD_INT 1
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 3
42788: NEG
42789: PUSH
42790: LD_INT 1
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 4
42799: NEG
42800: PUSH
42801: LD_INT 0
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 4
42810: NEG
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 4
42822: NEG
42823: PUSH
42824: LD_INT 2
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: LD_INT 2
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 4
42845: NEG
42846: PUSH
42847: LD_INT 4
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 4
42857: NEG
42858: PUSH
42859: LD_INT 5
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 3
42869: NEG
42870: PUSH
42871: LD_INT 4
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 3
42881: NEG
42882: PUSH
42883: LD_INT 3
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 4
42893: NEG
42894: PUSH
42895: LD_INT 3
42897: NEG
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 5
42905: NEG
42906: PUSH
42907: LD_INT 4
42909: NEG
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 5
42917: NEG
42918: PUSH
42919: LD_INT 5
42921: NEG
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 3
42929: NEG
42930: PUSH
42931: LD_INT 5
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 5
42941: NEG
42942: PUSH
42943: LD_INT 3
42945: NEG
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 0
42953: PUSH
42954: LD_INT 3
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 0
42964: PUSH
42965: LD_INT 4
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: LD_INT 3
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 1
42986: PUSH
42987: LD_INT 2
42989: NEG
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: LD_INT 2
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 1
43008: NEG
43009: PUSH
43010: LD_INT 3
43012: NEG
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 1
43020: NEG
43021: PUSH
43022: LD_INT 4
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 2
43032: PUSH
43033: LD_INT 2
43035: NEG
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 2
43043: NEG
43044: PUSH
43045: LD_INT 4
43047: NEG
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 4
43055: PUSH
43056: LD_INT 0
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 4
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 5
43076: PUSH
43077: LD_INT 0
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: PUSH
43084: LD_INT 5
43086: PUSH
43087: LD_INT 1
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 4
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 3
43106: PUSH
43107: LD_INT 0
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: LD_INT 3
43116: PUSH
43117: LD_INT 1
43119: NEG
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 3
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: PUSH
43136: LD_INT 5
43138: PUSH
43139: LD_INT 2
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: LIST
43150: LIST
43151: LIST
43152: LIST
43153: LIST
43154: LIST
43155: LIST
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: LIST
43166: LIST
43167: LIST
43168: LIST
43169: LIST
43170: LIST
43171: LIST
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43193: LD_ADDR_VAR 0 32
43197: PUSH
43198: LD_INT 4
43200: NEG
43201: PUSH
43202: LD_INT 0
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PUSH
43209: LD_INT 4
43211: NEG
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: NEG
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 3
43234: NEG
43235: PUSH
43236: LD_INT 1
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 4
43245: NEG
43246: PUSH
43247: LD_INT 1
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 5
43256: NEG
43257: PUSH
43258: LD_INT 0
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 5
43267: NEG
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 5
43279: NEG
43280: PUSH
43281: LD_INT 2
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 3
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: LD_INT 3
43306: NEG
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 3
43314: NEG
43315: PUSH
43316: LD_INT 4
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 2
43326: NEG
43327: PUSH
43328: LD_INT 3
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 2
43338: NEG
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: LD_INT 2
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 4
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 4
43374: NEG
43375: PUSH
43376: LD_INT 4
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 2
43386: NEG
43387: PUSH
43388: LD_INT 4
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 4
43398: NEG
43399: PUSH
43400: LD_INT 2
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: LD_INT 4
43413: NEG
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 0
43421: PUSH
43422: LD_INT 5
43424: NEG
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: LD_INT 4
43435: NEG
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 1
43443: PUSH
43444: LD_INT 3
43446: NEG
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 0
43454: PUSH
43455: LD_INT 3
43457: NEG
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: PUSH
43463: LD_INT 1
43465: NEG
43466: PUSH
43467: LD_INT 4
43469: NEG
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 1
43477: NEG
43478: PUSH
43479: LD_INT 5
43481: NEG
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 2
43489: PUSH
43490: LD_INT 3
43492: NEG
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 2
43500: NEG
43501: PUSH
43502: LD_INT 5
43504: NEG
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 3
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 3
43522: PUSH
43523: LD_INT 1
43525: NEG
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 4
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 4
43543: PUSH
43544: LD_INT 1
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 3
43553: PUSH
43554: LD_INT 1
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 2
43563: PUSH
43564: LD_INT 0
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 2
43573: PUSH
43574: LD_INT 1
43576: NEG
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 2
43584: PUSH
43585: LD_INT 2
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: LD_INT 4
43595: PUSH
43596: LD_INT 2
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 4
43605: PUSH
43606: LD_INT 4
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 4
43615: PUSH
43616: LD_INT 3
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 5
43625: PUSH
43626: LD_INT 4
43628: PUSH
43629: EMPTY
43630: LIST
43631: LIST
43632: PUSH
43633: LD_INT 5
43635: PUSH
43636: LD_INT 5
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: PUSH
43646: LD_INT 5
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 3
43655: PUSH
43656: LD_INT 4
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 3
43665: PUSH
43666: LD_INT 3
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 5
43675: PUSH
43676: LD_INT 3
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 3
43685: PUSH
43686: LD_INT 5
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: EMPTY
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43740: LD_ADDR_VAR 0 33
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: LD_INT 4
43751: NEG
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 4
43759: NEG
43760: PUSH
43761: LD_INT 5
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: LD_INT 4
43775: NEG
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 3
43783: NEG
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 4
43795: NEG
43796: PUSH
43797: LD_INT 3
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 5
43807: NEG
43808: PUSH
43809: LD_INT 4
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 5
43819: NEG
43820: PUSH
43821: LD_INT 5
43823: NEG
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 3
43831: NEG
43832: PUSH
43833: LD_INT 5
43835: NEG
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 5
43843: NEG
43844: PUSH
43845: LD_INT 3
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 0
43855: PUSH
43856: LD_INT 3
43858: NEG
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 0
43866: PUSH
43867: LD_INT 4
43869: NEG
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: LD_INT 3
43880: NEG
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: PUSH
43889: LD_INT 2
43891: NEG
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 0
43899: PUSH
43900: LD_INT 2
43902: NEG
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 1
43910: NEG
43911: PUSH
43912: LD_INT 3
43914: NEG
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 2
43934: PUSH
43935: LD_INT 2
43937: NEG
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 2
43945: NEG
43946: PUSH
43947: LD_INT 4
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 4
43957: PUSH
43958: LD_INT 0
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 4
43967: PUSH
43968: LD_INT 1
43970: NEG
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: PUSH
43976: LD_INT 5
43978: PUSH
43979: LD_INT 0
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: LD_INT 5
43988: PUSH
43989: LD_INT 1
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 4
43998: PUSH
43999: LD_INT 1
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 3
44008: PUSH
44009: LD_INT 0
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 3
44018: PUSH
44019: LD_INT 1
44021: NEG
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 3
44029: PUSH
44030: LD_INT 2
44032: NEG
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 5
44040: PUSH
44041: LD_INT 2
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 3
44050: PUSH
44051: LD_INT 3
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 3
44060: PUSH
44061: LD_INT 2
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 4
44070: PUSH
44071: LD_INT 3
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: LD_INT 4
44080: PUSH
44081: LD_INT 4
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 3
44090: PUSH
44091: LD_INT 4
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: PUSH
44101: LD_INT 3
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 2
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 4
44120: PUSH
44121: LD_INT 2
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 2
44130: PUSH
44131: LD_INT 4
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 0
44140: PUSH
44141: LD_INT 4
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 0
44150: PUSH
44151: LD_INT 3
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: PUSH
44158: LD_INT 1
44160: PUSH
44161: LD_INT 4
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 1
44170: PUSH
44171: LD_INT 5
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: LD_INT 5
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 1
44190: NEG
44191: PUSH
44192: LD_INT 4
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 1
44201: NEG
44202: PUSH
44203: LD_INT 3
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 2
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 2
44222: NEG
44223: PUSH
44224: LD_INT 3
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44278: LD_ADDR_VAR 0 34
44282: PUSH
44283: LD_INT 0
44285: PUSH
44286: LD_INT 4
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 0
44296: PUSH
44297: LD_INT 5
44299: NEG
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 1
44307: PUSH
44308: LD_INT 4
44310: NEG
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 1
44318: PUSH
44319: LD_INT 3
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 0
44329: PUSH
44330: LD_INT 3
44332: NEG
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 1
44340: NEG
44341: PUSH
44342: LD_INT 4
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 1
44352: NEG
44353: PUSH
44354: LD_INT 5
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 2
44364: PUSH
44365: LD_INT 3
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 2
44375: NEG
44376: PUSH
44377: LD_INT 5
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 3
44387: PUSH
44388: LD_INT 0
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 3
44397: PUSH
44398: LD_INT 1
44400: NEG
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 4
44408: PUSH
44409: LD_INT 0
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 4
44418: PUSH
44419: LD_INT 1
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 3
44428: PUSH
44429: LD_INT 1
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 2
44438: PUSH
44439: LD_INT 0
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 2
44448: PUSH
44449: LD_INT 1
44451: NEG
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 2
44459: PUSH
44460: LD_INT 2
44462: NEG
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: LD_INT 2
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 4
44480: PUSH
44481: LD_INT 4
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: LD_INT 3
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 5
44500: PUSH
44501: LD_INT 4
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 5
44510: PUSH
44511: LD_INT 5
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: LD_INT 5
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 3
44530: PUSH
44531: LD_INT 4
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: LD_INT 3
44540: PUSH
44541: LD_INT 3
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 5
44550: PUSH
44551: LD_INT 3
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 3
44560: PUSH
44561: LD_INT 5
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 0
44570: PUSH
44571: LD_INT 3
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 0
44580: PUSH
44581: LD_INT 2
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 1
44590: PUSH
44591: LD_INT 3
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 1
44600: PUSH
44601: LD_INT 4
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: LD_INT 4
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 1
44620: NEG
44621: PUSH
44622: LD_INT 3
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_INT 1
44631: NEG
44632: PUSH
44633: LD_INT 2
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 2
44642: PUSH
44643: LD_INT 4
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 2
44652: NEG
44653: PUSH
44654: LD_INT 2
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 4
44663: NEG
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 4
44674: NEG
44675: PUSH
44676: LD_INT 1
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 3
44686: NEG
44687: PUSH
44688: LD_INT 0
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 3
44697: NEG
44698: PUSH
44699: LD_INT 1
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PUSH
44706: LD_INT 4
44708: NEG
44709: PUSH
44710: LD_INT 1
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 5
44719: NEG
44720: PUSH
44721: LD_INT 0
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 5
44730: NEG
44731: PUSH
44732: LD_INT 1
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 5
44742: NEG
44743: PUSH
44744: LD_INT 2
44746: NEG
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: NEG
44755: PUSH
44756: LD_INT 2
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: ST_TO_ADDR
// end ; end ;
44810: GO 44813
44812: POP
// case btype of b_depot , b_warehouse :
44813: LD_VAR 0 1
44817: PUSH
44818: LD_INT 0
44820: DOUBLE
44821: EQUAL
44822: IFTRUE 44832
44824: LD_INT 1
44826: DOUBLE
44827: EQUAL
44828: IFTRUE 44832
44830: GO 45033
44832: POP
// case nation of nation_american :
44833: LD_VAR 0 5
44837: PUSH
44838: LD_INT 1
44840: DOUBLE
44841: EQUAL
44842: IFTRUE 44846
44844: GO 44902
44846: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44847: LD_ADDR_VAR 0 9
44851: PUSH
44852: LD_VAR 0 11
44856: PUSH
44857: LD_VAR 0 12
44861: PUSH
44862: LD_VAR 0 13
44866: PUSH
44867: LD_VAR 0 14
44871: PUSH
44872: LD_VAR 0 15
44876: PUSH
44877: LD_VAR 0 16
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: PUSH
44890: LD_VAR 0 4
44894: PUSH
44895: LD_INT 1
44897: PLUS
44898: ARRAY
44899: ST_TO_ADDR
44900: GO 45031
44902: LD_INT 2
44904: DOUBLE
44905: EQUAL
44906: IFTRUE 44910
44908: GO 44966
44910: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44911: LD_ADDR_VAR 0 9
44915: PUSH
44916: LD_VAR 0 17
44920: PUSH
44921: LD_VAR 0 18
44925: PUSH
44926: LD_VAR 0 19
44930: PUSH
44931: LD_VAR 0 20
44935: PUSH
44936: LD_VAR 0 21
44940: PUSH
44941: LD_VAR 0 22
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: PUSH
44954: LD_VAR 0 4
44958: PUSH
44959: LD_INT 1
44961: PLUS
44962: ARRAY
44963: ST_TO_ADDR
44964: GO 45031
44966: LD_INT 3
44968: DOUBLE
44969: EQUAL
44970: IFTRUE 44974
44972: GO 45030
44974: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44975: LD_ADDR_VAR 0 9
44979: PUSH
44980: LD_VAR 0 23
44984: PUSH
44985: LD_VAR 0 24
44989: PUSH
44990: LD_VAR 0 25
44994: PUSH
44995: LD_VAR 0 26
44999: PUSH
45000: LD_VAR 0 27
45004: PUSH
45005: LD_VAR 0 28
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: PUSH
45018: LD_VAR 0 4
45022: PUSH
45023: LD_INT 1
45025: PLUS
45026: ARRAY
45027: ST_TO_ADDR
45028: GO 45031
45030: POP
45031: GO 45586
45033: LD_INT 2
45035: DOUBLE
45036: EQUAL
45037: IFTRUE 45047
45039: LD_INT 3
45041: DOUBLE
45042: EQUAL
45043: IFTRUE 45047
45045: GO 45103
45047: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45048: LD_ADDR_VAR 0 9
45052: PUSH
45053: LD_VAR 0 29
45057: PUSH
45058: LD_VAR 0 30
45062: PUSH
45063: LD_VAR 0 31
45067: PUSH
45068: LD_VAR 0 32
45072: PUSH
45073: LD_VAR 0 33
45077: PUSH
45078: LD_VAR 0 34
45082: PUSH
45083: EMPTY
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: PUSH
45091: LD_VAR 0 4
45095: PUSH
45096: LD_INT 1
45098: PLUS
45099: ARRAY
45100: ST_TO_ADDR
45101: GO 45586
45103: LD_INT 16
45105: DOUBLE
45106: EQUAL
45107: IFTRUE 45165
45109: LD_INT 17
45111: DOUBLE
45112: EQUAL
45113: IFTRUE 45165
45115: LD_INT 18
45117: DOUBLE
45118: EQUAL
45119: IFTRUE 45165
45121: LD_INT 19
45123: DOUBLE
45124: EQUAL
45125: IFTRUE 45165
45127: LD_INT 22
45129: DOUBLE
45130: EQUAL
45131: IFTRUE 45165
45133: LD_INT 20
45135: DOUBLE
45136: EQUAL
45137: IFTRUE 45165
45139: LD_INT 21
45141: DOUBLE
45142: EQUAL
45143: IFTRUE 45165
45145: LD_INT 23
45147: DOUBLE
45148: EQUAL
45149: IFTRUE 45165
45151: LD_INT 24
45153: DOUBLE
45154: EQUAL
45155: IFTRUE 45165
45157: LD_INT 25
45159: DOUBLE
45160: EQUAL
45161: IFTRUE 45165
45163: GO 45221
45165: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45166: LD_ADDR_VAR 0 9
45170: PUSH
45171: LD_VAR 0 35
45175: PUSH
45176: LD_VAR 0 36
45180: PUSH
45181: LD_VAR 0 37
45185: PUSH
45186: LD_VAR 0 38
45190: PUSH
45191: LD_VAR 0 39
45195: PUSH
45196: LD_VAR 0 40
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: PUSH
45209: LD_VAR 0 4
45213: PUSH
45214: LD_INT 1
45216: PLUS
45217: ARRAY
45218: ST_TO_ADDR
45219: GO 45586
45221: LD_INT 6
45223: DOUBLE
45224: EQUAL
45225: IFTRUE 45277
45227: LD_INT 7
45229: DOUBLE
45230: EQUAL
45231: IFTRUE 45277
45233: LD_INT 8
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45277
45239: LD_INT 13
45241: DOUBLE
45242: EQUAL
45243: IFTRUE 45277
45245: LD_INT 12
45247: DOUBLE
45248: EQUAL
45249: IFTRUE 45277
45251: LD_INT 15
45253: DOUBLE
45254: EQUAL
45255: IFTRUE 45277
45257: LD_INT 11
45259: DOUBLE
45260: EQUAL
45261: IFTRUE 45277
45263: LD_INT 14
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45277
45269: LD_INT 10
45271: DOUBLE
45272: EQUAL
45273: IFTRUE 45277
45275: GO 45333
45277: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45278: LD_ADDR_VAR 0 9
45282: PUSH
45283: LD_VAR 0 41
45287: PUSH
45288: LD_VAR 0 42
45292: PUSH
45293: LD_VAR 0 43
45297: PUSH
45298: LD_VAR 0 44
45302: PUSH
45303: LD_VAR 0 45
45307: PUSH
45308: LD_VAR 0 46
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: PUSH
45321: LD_VAR 0 4
45325: PUSH
45326: LD_INT 1
45328: PLUS
45329: ARRAY
45330: ST_TO_ADDR
45331: GO 45586
45333: LD_INT 36
45335: DOUBLE
45336: EQUAL
45337: IFTRUE 45341
45339: GO 45397
45341: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45342: LD_ADDR_VAR 0 9
45346: PUSH
45347: LD_VAR 0 47
45351: PUSH
45352: LD_VAR 0 48
45356: PUSH
45357: LD_VAR 0 49
45361: PUSH
45362: LD_VAR 0 50
45366: PUSH
45367: LD_VAR 0 51
45371: PUSH
45372: LD_VAR 0 52
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: PUSH
45385: LD_VAR 0 4
45389: PUSH
45390: LD_INT 1
45392: PLUS
45393: ARRAY
45394: ST_TO_ADDR
45395: GO 45586
45397: LD_INT 4
45399: DOUBLE
45400: EQUAL
45401: IFTRUE 45423
45403: LD_INT 5
45405: DOUBLE
45406: EQUAL
45407: IFTRUE 45423
45409: LD_INT 34
45411: DOUBLE
45412: EQUAL
45413: IFTRUE 45423
45415: LD_INT 37
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45423
45421: GO 45479
45423: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45424: LD_ADDR_VAR 0 9
45428: PUSH
45429: LD_VAR 0 53
45433: PUSH
45434: LD_VAR 0 54
45438: PUSH
45439: LD_VAR 0 55
45443: PUSH
45444: LD_VAR 0 56
45448: PUSH
45449: LD_VAR 0 57
45453: PUSH
45454: LD_VAR 0 58
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: PUSH
45467: LD_VAR 0 4
45471: PUSH
45472: LD_INT 1
45474: PLUS
45475: ARRAY
45476: ST_TO_ADDR
45477: GO 45586
45479: LD_INT 31
45481: DOUBLE
45482: EQUAL
45483: IFTRUE 45529
45485: LD_INT 32
45487: DOUBLE
45488: EQUAL
45489: IFTRUE 45529
45491: LD_INT 33
45493: DOUBLE
45494: EQUAL
45495: IFTRUE 45529
45497: LD_INT 27
45499: DOUBLE
45500: EQUAL
45501: IFTRUE 45529
45503: LD_INT 26
45505: DOUBLE
45506: EQUAL
45507: IFTRUE 45529
45509: LD_INT 28
45511: DOUBLE
45512: EQUAL
45513: IFTRUE 45529
45515: LD_INT 29
45517: DOUBLE
45518: EQUAL
45519: IFTRUE 45529
45521: LD_INT 30
45523: DOUBLE
45524: EQUAL
45525: IFTRUE 45529
45527: GO 45585
45529: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45530: LD_ADDR_VAR 0 9
45534: PUSH
45535: LD_VAR 0 59
45539: PUSH
45540: LD_VAR 0 60
45544: PUSH
45545: LD_VAR 0 61
45549: PUSH
45550: LD_VAR 0 62
45554: PUSH
45555: LD_VAR 0 63
45559: PUSH
45560: LD_VAR 0 64
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: PUSH
45573: LD_VAR 0 4
45577: PUSH
45578: LD_INT 1
45580: PLUS
45581: ARRAY
45582: ST_TO_ADDR
45583: GO 45586
45585: POP
// temp_list2 = [ ] ;
45586: LD_ADDR_VAR 0 10
45590: PUSH
45591: EMPTY
45592: ST_TO_ADDR
// for i in temp_list do
45593: LD_ADDR_VAR 0 8
45597: PUSH
45598: LD_VAR 0 9
45602: PUSH
45603: FOR_IN
45604: IFFALSE 45656
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45606: LD_ADDR_VAR 0 10
45610: PUSH
45611: LD_VAR 0 10
45615: PUSH
45616: LD_VAR 0 8
45620: PUSH
45621: LD_INT 1
45623: ARRAY
45624: PUSH
45625: LD_VAR 0 2
45629: PLUS
45630: PUSH
45631: LD_VAR 0 8
45635: PUSH
45636: LD_INT 2
45638: ARRAY
45639: PUSH
45640: LD_VAR 0 3
45644: PLUS
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: EMPTY
45651: LIST
45652: ADD
45653: ST_TO_ADDR
45654: GO 45603
45656: POP
45657: POP
// result = temp_list2 ;
45658: LD_ADDR_VAR 0 7
45662: PUSH
45663: LD_VAR 0 10
45667: ST_TO_ADDR
// end ;
45668: LD_VAR 0 7
45672: RET
// export function EnemyInRange ( unit , dist ) ; begin
45673: LD_INT 0
45675: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45676: LD_ADDR_VAR 0 3
45680: PUSH
45681: LD_VAR 0 1
45685: PPUSH
45686: CALL_OW 255
45690: PPUSH
45691: LD_VAR 0 1
45695: PPUSH
45696: CALL_OW 250
45700: PPUSH
45701: LD_VAR 0 1
45705: PPUSH
45706: CALL_OW 251
45710: PPUSH
45711: LD_VAR 0 2
45715: PPUSH
45716: CALL 19444 0 4
45720: PUSH
45721: LD_INT 4
45723: ARRAY
45724: ST_TO_ADDR
// end ;
45725: LD_VAR 0 3
45729: RET
// export function PlayerSeeMe ( unit ) ; begin
45730: LD_INT 0
45732: PPUSH
// result := See ( your_side , unit ) ;
45733: LD_ADDR_VAR 0 2
45737: PUSH
45738: LD_OWVAR 2
45742: PPUSH
45743: LD_VAR 0 1
45747: PPUSH
45748: CALL_OW 292
45752: ST_TO_ADDR
// end ;
45753: LD_VAR 0 2
45757: RET
// export function ReverseDir ( unit ) ; begin
45758: LD_INT 0
45760: PPUSH
// if not unit then
45761: LD_VAR 0 1
45765: NOT
45766: IFFALSE 45770
// exit ;
45768: GO 45793
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45770: LD_ADDR_VAR 0 2
45774: PUSH
45775: LD_VAR 0 1
45779: PPUSH
45780: CALL_OW 254
45784: PUSH
45785: LD_INT 3
45787: PLUS
45788: PUSH
45789: LD_INT 6
45791: MOD
45792: ST_TO_ADDR
// end ;
45793: LD_VAR 0 2
45797: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45798: LD_INT 0
45800: PPUSH
45801: PPUSH
45802: PPUSH
45803: PPUSH
45804: PPUSH
// if not hexes then
45805: LD_VAR 0 2
45809: NOT
45810: IFFALSE 45814
// exit ;
45812: GO 45962
// dist := 9999 ;
45814: LD_ADDR_VAR 0 5
45818: PUSH
45819: LD_INT 9999
45821: ST_TO_ADDR
// for i = 1 to hexes do
45822: LD_ADDR_VAR 0 4
45826: PUSH
45827: DOUBLE
45828: LD_INT 1
45830: DEC
45831: ST_TO_ADDR
45832: LD_VAR 0 2
45836: PUSH
45837: FOR_TO
45838: IFFALSE 45950
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45840: LD_VAR 0 1
45844: PPUSH
45845: LD_VAR 0 2
45849: PUSH
45850: LD_VAR 0 4
45854: ARRAY
45855: PUSH
45856: LD_INT 1
45858: ARRAY
45859: PPUSH
45860: LD_VAR 0 2
45864: PUSH
45865: LD_VAR 0 4
45869: ARRAY
45870: PUSH
45871: LD_INT 2
45873: ARRAY
45874: PPUSH
45875: CALL_OW 297
45879: PUSH
45880: LD_VAR 0 5
45884: LESS
45885: IFFALSE 45948
// begin hex := hexes [ i ] ;
45887: LD_ADDR_VAR 0 7
45891: PUSH
45892: LD_VAR 0 2
45896: PUSH
45897: LD_VAR 0 4
45901: ARRAY
45902: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45903: LD_ADDR_VAR 0 5
45907: PUSH
45908: LD_VAR 0 1
45912: PPUSH
45913: LD_VAR 0 2
45917: PUSH
45918: LD_VAR 0 4
45922: ARRAY
45923: PUSH
45924: LD_INT 1
45926: ARRAY
45927: PPUSH
45928: LD_VAR 0 2
45932: PUSH
45933: LD_VAR 0 4
45937: ARRAY
45938: PUSH
45939: LD_INT 2
45941: ARRAY
45942: PPUSH
45943: CALL_OW 297
45947: ST_TO_ADDR
// end ; end ;
45948: GO 45837
45950: POP
45951: POP
// result := hex ;
45952: LD_ADDR_VAR 0 3
45956: PUSH
45957: LD_VAR 0 7
45961: ST_TO_ADDR
// end ;
45962: LD_VAR 0 3
45966: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45967: LD_INT 0
45969: PPUSH
45970: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45971: LD_VAR 0 1
45975: NOT
45976: PUSH
45977: LD_VAR 0 1
45981: PUSH
45982: LD_INT 21
45984: PUSH
45985: LD_INT 2
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 23
45994: PUSH
45995: LD_INT 2
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PPUSH
46006: CALL_OW 69
46010: IN
46011: NOT
46012: OR
46013: IFFALSE 46017
// exit ;
46015: GO 46064
// for i = 1 to 3 do
46017: LD_ADDR_VAR 0 3
46021: PUSH
46022: DOUBLE
46023: LD_INT 1
46025: DEC
46026: ST_TO_ADDR
46027: LD_INT 3
46029: PUSH
46030: FOR_TO
46031: IFFALSE 46062
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46033: LD_VAR 0 1
46037: PPUSH
46038: CALL_OW 250
46042: PPUSH
46043: LD_VAR 0 1
46047: PPUSH
46048: CALL_OW 251
46052: PPUSH
46053: LD_INT 1
46055: PPUSH
46056: CALL_OW 453
46060: GO 46030
46062: POP
46063: POP
// end ;
46064: LD_VAR 0 2
46068: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46069: LD_INT 0
46071: PPUSH
46072: PPUSH
46073: PPUSH
46074: PPUSH
46075: PPUSH
46076: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46077: LD_VAR 0 1
46081: NOT
46082: PUSH
46083: LD_VAR 0 2
46087: NOT
46088: OR
46089: PUSH
46090: LD_VAR 0 1
46094: PPUSH
46095: CALL_OW 314
46099: OR
46100: IFFALSE 46104
// exit ;
46102: GO 46545
// x := GetX ( enemy_unit ) ;
46104: LD_ADDR_VAR 0 7
46108: PUSH
46109: LD_VAR 0 2
46113: PPUSH
46114: CALL_OW 250
46118: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46119: LD_ADDR_VAR 0 8
46123: PUSH
46124: LD_VAR 0 2
46128: PPUSH
46129: CALL_OW 251
46133: ST_TO_ADDR
// if not x or not y then
46134: LD_VAR 0 7
46138: NOT
46139: PUSH
46140: LD_VAR 0 8
46144: NOT
46145: OR
46146: IFFALSE 46150
// exit ;
46148: GO 46545
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46150: LD_ADDR_VAR 0 6
46154: PUSH
46155: LD_VAR 0 7
46159: PPUSH
46160: LD_INT 0
46162: PPUSH
46163: LD_INT 4
46165: PPUSH
46166: CALL_OW 272
46170: PUSH
46171: LD_VAR 0 8
46175: PPUSH
46176: LD_INT 0
46178: PPUSH
46179: LD_INT 4
46181: PPUSH
46182: CALL_OW 273
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: LD_VAR 0 7
46195: PPUSH
46196: LD_INT 1
46198: PPUSH
46199: LD_INT 4
46201: PPUSH
46202: CALL_OW 272
46206: PUSH
46207: LD_VAR 0 8
46211: PPUSH
46212: LD_INT 1
46214: PPUSH
46215: LD_INT 4
46217: PPUSH
46218: CALL_OW 273
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: LD_VAR 0 7
46231: PPUSH
46232: LD_INT 2
46234: PPUSH
46235: LD_INT 4
46237: PPUSH
46238: CALL_OW 272
46242: PUSH
46243: LD_VAR 0 8
46247: PPUSH
46248: LD_INT 2
46250: PPUSH
46251: LD_INT 4
46253: PPUSH
46254: CALL_OW 273
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_VAR 0 7
46267: PPUSH
46268: LD_INT 3
46270: PPUSH
46271: LD_INT 4
46273: PPUSH
46274: CALL_OW 272
46278: PUSH
46279: LD_VAR 0 8
46283: PPUSH
46284: LD_INT 3
46286: PPUSH
46287: LD_INT 4
46289: PPUSH
46290: CALL_OW 273
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_VAR 0 7
46303: PPUSH
46304: LD_INT 4
46306: PPUSH
46307: LD_INT 4
46309: PPUSH
46310: CALL_OW 272
46314: PUSH
46315: LD_VAR 0 8
46319: PPUSH
46320: LD_INT 4
46322: PPUSH
46323: LD_INT 4
46325: PPUSH
46326: CALL_OW 273
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_VAR 0 7
46339: PPUSH
46340: LD_INT 5
46342: PPUSH
46343: LD_INT 4
46345: PPUSH
46346: CALL_OW 272
46350: PUSH
46351: LD_VAR 0 8
46355: PPUSH
46356: LD_INT 5
46358: PPUSH
46359: LD_INT 4
46361: PPUSH
46362: CALL_OW 273
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: EMPTY
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: ST_TO_ADDR
// for i = tmp downto 1 do
46379: LD_ADDR_VAR 0 4
46383: PUSH
46384: DOUBLE
46385: LD_VAR 0 6
46389: INC
46390: ST_TO_ADDR
46391: LD_INT 1
46393: PUSH
46394: FOR_DOWNTO
46395: IFFALSE 46496
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46397: LD_VAR 0 6
46401: PUSH
46402: LD_VAR 0 4
46406: ARRAY
46407: PUSH
46408: LD_INT 1
46410: ARRAY
46411: PPUSH
46412: LD_VAR 0 6
46416: PUSH
46417: LD_VAR 0 4
46421: ARRAY
46422: PUSH
46423: LD_INT 2
46425: ARRAY
46426: PPUSH
46427: CALL_OW 488
46431: NOT
46432: PUSH
46433: LD_VAR 0 6
46437: PUSH
46438: LD_VAR 0 4
46442: ARRAY
46443: PUSH
46444: LD_INT 1
46446: ARRAY
46447: PPUSH
46448: LD_VAR 0 6
46452: PUSH
46453: LD_VAR 0 4
46457: ARRAY
46458: PUSH
46459: LD_INT 2
46461: ARRAY
46462: PPUSH
46463: CALL_OW 428
46467: PUSH
46468: LD_INT 0
46470: NONEQUAL
46471: OR
46472: IFFALSE 46494
// tmp := Delete ( tmp , i ) ;
46474: LD_ADDR_VAR 0 6
46478: PUSH
46479: LD_VAR 0 6
46483: PPUSH
46484: LD_VAR 0 4
46488: PPUSH
46489: CALL_OW 3
46493: ST_TO_ADDR
46494: GO 46394
46496: POP
46497: POP
// j := GetClosestHex ( unit , tmp ) ;
46498: LD_ADDR_VAR 0 5
46502: PUSH
46503: LD_VAR 0 1
46507: PPUSH
46508: LD_VAR 0 6
46512: PPUSH
46513: CALL 45798 0 2
46517: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46518: LD_VAR 0 1
46522: PPUSH
46523: LD_VAR 0 5
46527: PUSH
46528: LD_INT 1
46530: ARRAY
46531: PPUSH
46532: LD_VAR 0 5
46536: PUSH
46537: LD_INT 2
46539: ARRAY
46540: PPUSH
46541: CALL_OW 111
// end ;
46545: LD_VAR 0 3
46549: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46550: LD_INT 0
46552: PPUSH
46553: PPUSH
46554: PPUSH
// uc_side = 0 ;
46555: LD_ADDR_OWVAR 20
46559: PUSH
46560: LD_INT 0
46562: ST_TO_ADDR
// uc_nation = 0 ;
46563: LD_ADDR_OWVAR 21
46567: PUSH
46568: LD_INT 0
46570: ST_TO_ADDR
// InitHc_All ( ) ;
46571: CALL_OW 584
// InitVc ;
46575: CALL_OW 20
// if mastodonts then
46579: LD_VAR 0 6
46583: IFFALSE 46650
// for i = 1 to mastodonts do
46585: LD_ADDR_VAR 0 11
46589: PUSH
46590: DOUBLE
46591: LD_INT 1
46593: DEC
46594: ST_TO_ADDR
46595: LD_VAR 0 6
46599: PUSH
46600: FOR_TO
46601: IFFALSE 46648
// begin vc_chassis := 31 ;
46603: LD_ADDR_OWVAR 37
46607: PUSH
46608: LD_INT 31
46610: ST_TO_ADDR
// vc_control := control_rider ;
46611: LD_ADDR_OWVAR 38
46615: PUSH
46616: LD_INT 4
46618: ST_TO_ADDR
// animal := CreateVehicle ;
46619: LD_ADDR_VAR 0 12
46623: PUSH
46624: CALL_OW 45
46628: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46629: LD_VAR 0 12
46633: PPUSH
46634: LD_VAR 0 8
46638: PPUSH
46639: LD_INT 0
46641: PPUSH
46642: CALL 48838 0 3
// end ;
46646: GO 46600
46648: POP
46649: POP
// if horses then
46650: LD_VAR 0 5
46654: IFFALSE 46721
// for i = 1 to horses do
46656: LD_ADDR_VAR 0 11
46660: PUSH
46661: DOUBLE
46662: LD_INT 1
46664: DEC
46665: ST_TO_ADDR
46666: LD_VAR 0 5
46670: PUSH
46671: FOR_TO
46672: IFFALSE 46719
// begin hc_class := 21 ;
46674: LD_ADDR_OWVAR 28
46678: PUSH
46679: LD_INT 21
46681: ST_TO_ADDR
// hc_gallery :=  ;
46682: LD_ADDR_OWVAR 33
46686: PUSH
46687: LD_STRING 
46689: ST_TO_ADDR
// animal := CreateHuman ;
46690: LD_ADDR_VAR 0 12
46694: PUSH
46695: CALL_OW 44
46699: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46700: LD_VAR 0 12
46704: PPUSH
46705: LD_VAR 0 8
46709: PPUSH
46710: LD_INT 0
46712: PPUSH
46713: CALL 48838 0 3
// end ;
46717: GO 46671
46719: POP
46720: POP
// if birds then
46721: LD_VAR 0 1
46725: IFFALSE 46792
// for i = 1 to birds do
46727: LD_ADDR_VAR 0 11
46731: PUSH
46732: DOUBLE
46733: LD_INT 1
46735: DEC
46736: ST_TO_ADDR
46737: LD_VAR 0 1
46741: PUSH
46742: FOR_TO
46743: IFFALSE 46790
// begin hc_class = 18 ;
46745: LD_ADDR_OWVAR 28
46749: PUSH
46750: LD_INT 18
46752: ST_TO_ADDR
// hc_gallery =  ;
46753: LD_ADDR_OWVAR 33
46757: PUSH
46758: LD_STRING 
46760: ST_TO_ADDR
// animal := CreateHuman ;
46761: LD_ADDR_VAR 0 12
46765: PUSH
46766: CALL_OW 44
46770: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46771: LD_VAR 0 12
46775: PPUSH
46776: LD_VAR 0 8
46780: PPUSH
46781: LD_INT 0
46783: PPUSH
46784: CALL 48838 0 3
// end ;
46788: GO 46742
46790: POP
46791: POP
// if tigers then
46792: LD_VAR 0 2
46796: IFFALSE 46880
// for i = 1 to tigers do
46798: LD_ADDR_VAR 0 11
46802: PUSH
46803: DOUBLE
46804: LD_INT 1
46806: DEC
46807: ST_TO_ADDR
46808: LD_VAR 0 2
46812: PUSH
46813: FOR_TO
46814: IFFALSE 46878
// begin hc_class = class_tiger ;
46816: LD_ADDR_OWVAR 28
46820: PUSH
46821: LD_INT 14
46823: ST_TO_ADDR
// hc_gallery =  ;
46824: LD_ADDR_OWVAR 33
46828: PUSH
46829: LD_STRING 
46831: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46832: LD_ADDR_OWVAR 35
46836: PUSH
46837: LD_INT 7
46839: NEG
46840: PPUSH
46841: LD_INT 7
46843: PPUSH
46844: CALL_OW 12
46848: ST_TO_ADDR
// animal := CreateHuman ;
46849: LD_ADDR_VAR 0 12
46853: PUSH
46854: CALL_OW 44
46858: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46859: LD_VAR 0 12
46863: PPUSH
46864: LD_VAR 0 8
46868: PPUSH
46869: LD_INT 0
46871: PPUSH
46872: CALL 48838 0 3
// end ;
46876: GO 46813
46878: POP
46879: POP
// if apemans then
46880: LD_VAR 0 3
46884: IFFALSE 47007
// for i = 1 to apemans do
46886: LD_ADDR_VAR 0 11
46890: PUSH
46891: DOUBLE
46892: LD_INT 1
46894: DEC
46895: ST_TO_ADDR
46896: LD_VAR 0 3
46900: PUSH
46901: FOR_TO
46902: IFFALSE 47005
// begin hc_class = class_apeman ;
46904: LD_ADDR_OWVAR 28
46908: PUSH
46909: LD_INT 12
46911: ST_TO_ADDR
// hc_gallery =  ;
46912: LD_ADDR_OWVAR 33
46916: PUSH
46917: LD_STRING 
46919: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46920: LD_ADDR_OWVAR 35
46924: PUSH
46925: LD_INT 5
46927: NEG
46928: PPUSH
46929: LD_INT 5
46931: PPUSH
46932: CALL_OW 12
46936: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46937: LD_ADDR_OWVAR 31
46941: PUSH
46942: LD_INT 1
46944: PPUSH
46945: LD_INT 3
46947: PPUSH
46948: CALL_OW 12
46952: PUSH
46953: LD_INT 1
46955: PPUSH
46956: LD_INT 3
46958: PPUSH
46959: CALL_OW 12
46963: PUSH
46964: LD_INT 0
46966: PUSH
46967: LD_INT 0
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: ST_TO_ADDR
// animal := CreateHuman ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 44
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 48838 0 3
// end ;
47003: GO 46901
47005: POP
47006: POP
// if enchidnas then
47007: LD_VAR 0 4
47011: IFFALSE 47078
// for i = 1 to enchidnas do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 4
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class = 13 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 13
47038: ST_TO_ADDR
// hc_gallery =  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 48838 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if fishes then
47078: LD_VAR 0 7
47082: IFFALSE 47149
// for i = 1 to fishes do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 7
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 20 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 20
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 9
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 48838 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// end ;
47149: LD_VAR 0 10
47153: RET
// export function WantHeal ( sci , unit ) ; begin
47154: LD_INT 0
47156: PPUSH
// if GetTaskList ( sci ) > 0 then
47157: LD_VAR 0 1
47161: PPUSH
47162: CALL_OW 437
47166: PUSH
47167: LD_INT 0
47169: GREATER
47170: IFFALSE 47240
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47172: LD_VAR 0 1
47176: PPUSH
47177: CALL_OW 437
47181: PUSH
47182: LD_INT 1
47184: ARRAY
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: PUSH
47190: LD_STRING l
47192: EQUAL
47193: PUSH
47194: LD_VAR 0 1
47198: PPUSH
47199: CALL_OW 437
47203: PUSH
47204: LD_INT 1
47206: ARRAY
47207: PUSH
47208: LD_INT 4
47210: ARRAY
47211: PUSH
47212: LD_VAR 0 2
47216: EQUAL
47217: AND
47218: IFFALSE 47230
// result := true else
47220: LD_ADDR_VAR 0 3
47224: PUSH
47225: LD_INT 1
47227: ST_TO_ADDR
47228: GO 47238
// result := false ;
47230: LD_ADDR_VAR 0 3
47234: PUSH
47235: LD_INT 0
47237: ST_TO_ADDR
// end else
47238: GO 47248
// result := false ;
47240: LD_ADDR_VAR 0 3
47244: PUSH
47245: LD_INT 0
47247: ST_TO_ADDR
// end ;
47248: LD_VAR 0 3
47252: RET
// export function HealTarget ( sci ) ; begin
47253: LD_INT 0
47255: PPUSH
// if not sci then
47256: LD_VAR 0 1
47260: NOT
47261: IFFALSE 47265
// exit ;
47263: GO 47330
// result := 0 ;
47265: LD_ADDR_VAR 0 2
47269: PUSH
47270: LD_INT 0
47272: ST_TO_ADDR
// if GetTaskList ( sci ) then
47273: LD_VAR 0 1
47277: PPUSH
47278: CALL_OW 437
47282: IFFALSE 47330
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47284: LD_VAR 0 1
47288: PPUSH
47289: CALL_OW 437
47293: PUSH
47294: LD_INT 1
47296: ARRAY
47297: PUSH
47298: LD_INT 1
47300: ARRAY
47301: PUSH
47302: LD_STRING l
47304: EQUAL
47305: IFFALSE 47330
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47307: LD_ADDR_VAR 0 2
47311: PUSH
47312: LD_VAR 0 1
47316: PPUSH
47317: CALL_OW 437
47321: PUSH
47322: LD_INT 1
47324: ARRAY
47325: PUSH
47326: LD_INT 4
47328: ARRAY
47329: ST_TO_ADDR
// end ;
47330: LD_VAR 0 2
47334: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47335: LD_INT 0
47337: PPUSH
47338: PPUSH
47339: PPUSH
47340: PPUSH
// if not base_units then
47341: LD_VAR 0 1
47345: NOT
47346: IFFALSE 47350
// exit ;
47348: GO 47437
// result := false ;
47350: LD_ADDR_VAR 0 2
47354: PUSH
47355: LD_INT 0
47357: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47358: LD_ADDR_VAR 0 5
47362: PUSH
47363: LD_VAR 0 1
47367: PPUSH
47368: LD_INT 21
47370: PUSH
47371: LD_INT 3
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PPUSH
47378: CALL_OW 72
47382: ST_TO_ADDR
// if not tmp then
47383: LD_VAR 0 5
47387: NOT
47388: IFFALSE 47392
// exit ;
47390: GO 47437
// for i in tmp do
47392: LD_ADDR_VAR 0 3
47396: PUSH
47397: LD_VAR 0 5
47401: PUSH
47402: FOR_IN
47403: IFFALSE 47435
// begin result := EnemyInRange ( i , 22 ) ;
47405: LD_ADDR_VAR 0 2
47409: PUSH
47410: LD_VAR 0 3
47414: PPUSH
47415: LD_INT 22
47417: PPUSH
47418: CALL 45673 0 2
47422: ST_TO_ADDR
// if result then
47423: LD_VAR 0 2
47427: IFFALSE 47433
// exit ;
47429: POP
47430: POP
47431: GO 47437
// end ;
47433: GO 47402
47435: POP
47436: POP
// end ;
47437: LD_VAR 0 2
47441: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47442: LD_INT 0
47444: PPUSH
47445: PPUSH
// if not units then
47446: LD_VAR 0 1
47450: NOT
47451: IFFALSE 47455
// exit ;
47453: GO 47525
// result := [ ] ;
47455: LD_ADDR_VAR 0 3
47459: PUSH
47460: EMPTY
47461: ST_TO_ADDR
// for i in units do
47462: LD_ADDR_VAR 0 4
47466: PUSH
47467: LD_VAR 0 1
47471: PUSH
47472: FOR_IN
47473: IFFALSE 47523
// if GetTag ( i ) = tag then
47475: LD_VAR 0 4
47479: PPUSH
47480: CALL_OW 110
47484: PUSH
47485: LD_VAR 0 2
47489: EQUAL
47490: IFFALSE 47521
// result := Insert ( result , result + 1 , i ) ;
47492: LD_ADDR_VAR 0 3
47496: PUSH
47497: LD_VAR 0 3
47501: PPUSH
47502: LD_VAR 0 3
47506: PUSH
47507: LD_INT 1
47509: PLUS
47510: PPUSH
47511: LD_VAR 0 4
47515: PPUSH
47516: CALL_OW 2
47520: ST_TO_ADDR
47521: GO 47472
47523: POP
47524: POP
// end ;
47525: LD_VAR 0 3
47529: RET
// export function IsDriver ( un ) ; begin
47530: LD_INT 0
47532: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47533: LD_ADDR_VAR 0 2
47537: PUSH
47538: LD_VAR 0 1
47542: PUSH
47543: LD_INT 55
47545: PUSH
47546: EMPTY
47547: LIST
47548: PPUSH
47549: CALL_OW 69
47553: IN
47554: ST_TO_ADDR
// end ;
47555: LD_VAR 0 2
47559: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47560: LD_INT 0
47562: PPUSH
47563: PPUSH
// list := [ ] ;
47564: LD_ADDR_VAR 0 5
47568: PUSH
47569: EMPTY
47570: ST_TO_ADDR
// case d of 0 :
47571: LD_VAR 0 3
47575: PUSH
47576: LD_INT 0
47578: DOUBLE
47579: EQUAL
47580: IFTRUE 47584
47582: GO 47717
47584: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47585: LD_ADDR_VAR 0 5
47589: PUSH
47590: LD_VAR 0 1
47594: PUSH
47595: LD_INT 4
47597: MINUS
47598: PUSH
47599: LD_VAR 0 2
47603: PUSH
47604: LD_INT 4
47606: MINUS
47607: PUSH
47608: LD_INT 2
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: LIST
47615: PUSH
47616: LD_VAR 0 1
47620: PUSH
47621: LD_INT 3
47623: MINUS
47624: PUSH
47625: LD_VAR 0 2
47629: PUSH
47630: LD_INT 1
47632: PUSH
47633: EMPTY
47634: LIST
47635: LIST
47636: LIST
47637: PUSH
47638: LD_VAR 0 1
47642: PUSH
47643: LD_INT 4
47645: PLUS
47646: PUSH
47647: LD_VAR 0 2
47651: PUSH
47652: LD_INT 4
47654: PUSH
47655: EMPTY
47656: LIST
47657: LIST
47658: LIST
47659: PUSH
47660: LD_VAR 0 1
47664: PUSH
47665: LD_INT 3
47667: PLUS
47668: PUSH
47669: LD_VAR 0 2
47673: PUSH
47674: LD_INT 3
47676: PLUS
47677: PUSH
47678: LD_INT 5
47680: PUSH
47681: EMPTY
47682: LIST
47683: LIST
47684: LIST
47685: PUSH
47686: LD_VAR 0 1
47690: PUSH
47691: LD_VAR 0 2
47695: PUSH
47696: LD_INT 4
47698: PLUS
47699: PUSH
47700: LD_INT 0
47702: PUSH
47703: EMPTY
47704: LIST
47705: LIST
47706: LIST
47707: PUSH
47708: EMPTY
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: ST_TO_ADDR
// end ; 1 :
47715: GO 48415
47717: LD_INT 1
47719: DOUBLE
47720: EQUAL
47721: IFTRUE 47725
47723: GO 47858
47725: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47726: LD_ADDR_VAR 0 5
47730: PUSH
47731: LD_VAR 0 1
47735: PUSH
47736: LD_VAR 0 2
47740: PUSH
47741: LD_INT 4
47743: MINUS
47744: PUSH
47745: LD_INT 3
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: LIST
47752: PUSH
47753: LD_VAR 0 1
47757: PUSH
47758: LD_INT 3
47760: MINUS
47761: PUSH
47762: LD_VAR 0 2
47766: PUSH
47767: LD_INT 3
47769: MINUS
47770: PUSH
47771: LD_INT 2
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: LIST
47778: PUSH
47779: LD_VAR 0 1
47783: PUSH
47784: LD_INT 4
47786: MINUS
47787: PUSH
47788: LD_VAR 0 2
47792: PUSH
47793: LD_INT 1
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: LIST
47800: PUSH
47801: LD_VAR 0 1
47805: PUSH
47806: LD_VAR 0 2
47810: PUSH
47811: LD_INT 3
47813: PLUS
47814: PUSH
47815: LD_INT 0
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: LIST
47822: PUSH
47823: LD_VAR 0 1
47827: PUSH
47828: LD_INT 4
47830: PLUS
47831: PUSH
47832: LD_VAR 0 2
47836: PUSH
47837: LD_INT 4
47839: PLUS
47840: PUSH
47841: LD_INT 5
47843: PUSH
47844: EMPTY
47845: LIST
47846: LIST
47847: LIST
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: ST_TO_ADDR
// end ; 2 :
47856: GO 48415
47858: LD_INT 2
47860: DOUBLE
47861: EQUAL
47862: IFTRUE 47866
47864: GO 47995
47866: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47867: LD_ADDR_VAR 0 5
47871: PUSH
47872: LD_VAR 0 1
47876: PUSH
47877: LD_VAR 0 2
47881: PUSH
47882: LD_INT 3
47884: MINUS
47885: PUSH
47886: LD_INT 3
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: LIST
47893: PUSH
47894: LD_VAR 0 1
47898: PUSH
47899: LD_INT 4
47901: PLUS
47902: PUSH
47903: LD_VAR 0 2
47907: PUSH
47908: LD_INT 4
47910: PUSH
47911: EMPTY
47912: LIST
47913: LIST
47914: LIST
47915: PUSH
47916: LD_VAR 0 1
47920: PUSH
47921: LD_VAR 0 2
47925: PUSH
47926: LD_INT 4
47928: PLUS
47929: PUSH
47930: LD_INT 0
47932: PUSH
47933: EMPTY
47934: LIST
47935: LIST
47936: LIST
47937: PUSH
47938: LD_VAR 0 1
47942: PUSH
47943: LD_INT 3
47945: MINUS
47946: PUSH
47947: LD_VAR 0 2
47951: PUSH
47952: LD_INT 1
47954: PUSH
47955: EMPTY
47956: LIST
47957: LIST
47958: LIST
47959: PUSH
47960: LD_VAR 0 1
47964: PUSH
47965: LD_INT 4
47967: MINUS
47968: PUSH
47969: LD_VAR 0 2
47973: PUSH
47974: LD_INT 4
47976: MINUS
47977: PUSH
47978: LD_INT 2
47980: PUSH
47981: EMPTY
47982: LIST
47983: LIST
47984: LIST
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// end ; 3 :
47993: GO 48415
47995: LD_INT 3
47997: DOUBLE
47998: EQUAL
47999: IFTRUE 48003
48001: GO 48136
48003: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48004: LD_ADDR_VAR 0 5
48008: PUSH
48009: LD_VAR 0 1
48013: PUSH
48014: LD_INT 3
48016: PLUS
48017: PUSH
48018: LD_VAR 0 2
48022: PUSH
48023: LD_INT 4
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: LIST
48030: PUSH
48031: LD_VAR 0 1
48035: PUSH
48036: LD_INT 4
48038: PLUS
48039: PUSH
48040: LD_VAR 0 2
48044: PUSH
48045: LD_INT 4
48047: PLUS
48048: PUSH
48049: LD_INT 5
48051: PUSH
48052: EMPTY
48053: LIST
48054: LIST
48055: LIST
48056: PUSH
48057: LD_VAR 0 1
48061: PUSH
48062: LD_INT 4
48064: MINUS
48065: PUSH
48066: LD_VAR 0 2
48070: PUSH
48071: LD_INT 1
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: LIST
48078: PUSH
48079: LD_VAR 0 1
48083: PUSH
48084: LD_VAR 0 2
48088: PUSH
48089: LD_INT 4
48091: MINUS
48092: PUSH
48093: LD_INT 3
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: LD_VAR 0 1
48105: PUSH
48106: LD_INT 3
48108: MINUS
48109: PUSH
48110: LD_VAR 0 2
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_INT 2
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: LIST
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: ST_TO_ADDR
// end ; 4 :
48134: GO 48415
48136: LD_INT 4
48138: DOUBLE
48139: EQUAL
48140: IFTRUE 48144
48142: GO 48277
48144: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48145: LD_ADDR_VAR 0 5
48149: PUSH
48150: LD_VAR 0 1
48154: PUSH
48155: LD_VAR 0 2
48159: PUSH
48160: LD_INT 4
48162: PLUS
48163: PUSH
48164: LD_INT 0
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: LIST
48171: PUSH
48172: LD_VAR 0 1
48176: PUSH
48177: LD_INT 3
48179: PLUS
48180: PUSH
48181: LD_VAR 0 2
48185: PUSH
48186: LD_INT 3
48188: PLUS
48189: PUSH
48190: LD_INT 5
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: LIST
48197: PUSH
48198: LD_VAR 0 1
48202: PUSH
48203: LD_INT 4
48205: PLUS
48206: PUSH
48207: LD_VAR 0 2
48211: PUSH
48212: LD_INT 4
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: LIST
48219: PUSH
48220: LD_VAR 0 1
48224: PUSH
48225: LD_VAR 0 2
48229: PUSH
48230: LD_INT 3
48232: MINUS
48233: PUSH
48234: LD_INT 3
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: LIST
48241: PUSH
48242: LD_VAR 0 1
48246: PUSH
48247: LD_INT 4
48249: MINUS
48250: PUSH
48251: LD_VAR 0 2
48255: PUSH
48256: LD_INT 4
48258: MINUS
48259: PUSH
48260: LD_INT 2
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: LIST
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: ST_TO_ADDR
// end ; 5 :
48275: GO 48415
48277: LD_INT 5
48279: DOUBLE
48280: EQUAL
48281: IFTRUE 48285
48283: GO 48414
48285: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48286: LD_ADDR_VAR 0 5
48290: PUSH
48291: LD_VAR 0 1
48295: PUSH
48296: LD_INT 4
48298: MINUS
48299: PUSH
48300: LD_VAR 0 2
48304: PUSH
48305: LD_INT 1
48307: PUSH
48308: EMPTY
48309: LIST
48310: LIST
48311: LIST
48312: PUSH
48313: LD_VAR 0 1
48317: PUSH
48318: LD_VAR 0 2
48322: PUSH
48323: LD_INT 4
48325: MINUS
48326: PUSH
48327: LD_INT 3
48329: PUSH
48330: EMPTY
48331: LIST
48332: LIST
48333: LIST
48334: PUSH
48335: LD_VAR 0 1
48339: PUSH
48340: LD_INT 4
48342: PLUS
48343: PUSH
48344: LD_VAR 0 2
48348: PUSH
48349: LD_INT 4
48351: PLUS
48352: PUSH
48353: LD_INT 5
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: LIST
48360: PUSH
48361: LD_VAR 0 1
48365: PUSH
48366: LD_INT 3
48368: PLUS
48369: PUSH
48370: LD_VAR 0 2
48374: PUSH
48375: LD_INT 4
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: PUSH
48383: LD_VAR 0 1
48387: PUSH
48388: LD_VAR 0 2
48392: PUSH
48393: LD_INT 3
48395: PLUS
48396: PUSH
48397: LD_INT 0
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: LIST
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: ST_TO_ADDR
// end ; end ;
48412: GO 48415
48414: POP
// result := list ;
48415: LD_ADDR_VAR 0 4
48419: PUSH
48420: LD_VAR 0 5
48424: ST_TO_ADDR
// end ;
48425: LD_VAR 0 4
48429: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48430: LD_INT 0
48432: PPUSH
48433: PPUSH
48434: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48435: LD_VAR 0 1
48439: NOT
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 1
48448: PUSH
48449: LD_INT 2
48451: PUSH
48452: LD_INT 3
48454: PUSH
48455: LD_INT 4
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: IN
48464: NOT
48465: OR
48466: IFFALSE 48470
// exit ;
48468: GO 48562
// tmp := [ ] ;
48470: LD_ADDR_VAR 0 5
48474: PUSH
48475: EMPTY
48476: ST_TO_ADDR
// for i in units do
48477: LD_ADDR_VAR 0 4
48481: PUSH
48482: LD_VAR 0 1
48486: PUSH
48487: FOR_IN
48488: IFFALSE 48531
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48490: LD_ADDR_VAR 0 5
48494: PUSH
48495: LD_VAR 0 5
48499: PPUSH
48500: LD_VAR 0 5
48504: PUSH
48505: LD_INT 1
48507: PLUS
48508: PPUSH
48509: LD_VAR 0 4
48513: PPUSH
48514: LD_VAR 0 2
48518: PPUSH
48519: CALL_OW 259
48523: PPUSH
48524: CALL_OW 2
48528: ST_TO_ADDR
48529: GO 48487
48531: POP
48532: POP
// if not tmp then
48533: LD_VAR 0 5
48537: NOT
48538: IFFALSE 48542
// exit ;
48540: GO 48562
// result := SortListByListDesc ( units , tmp ) ;
48542: LD_ADDR_VAR 0 3
48546: PUSH
48547: LD_VAR 0 1
48551: PPUSH
48552: LD_VAR 0 5
48556: PPUSH
48557: CALL_OW 77
48561: ST_TO_ADDR
// end ;
48562: LD_VAR 0 3
48566: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48567: LD_INT 0
48569: PPUSH
48570: PPUSH
48571: PPUSH
// result := false ;
48572: LD_ADDR_VAR 0 3
48576: PUSH
48577: LD_INT 0
48579: ST_TO_ADDR
// x := GetX ( building ) ;
48580: LD_ADDR_VAR 0 4
48584: PUSH
48585: LD_VAR 0 2
48589: PPUSH
48590: CALL_OW 250
48594: ST_TO_ADDR
// y := GetY ( building ) ;
48595: LD_ADDR_VAR 0 5
48599: PUSH
48600: LD_VAR 0 2
48604: PPUSH
48605: CALL_OW 251
48609: ST_TO_ADDR
// if not building or not x or not y then
48610: LD_VAR 0 2
48614: NOT
48615: PUSH
48616: LD_VAR 0 4
48620: NOT
48621: OR
48622: PUSH
48623: LD_VAR 0 5
48627: NOT
48628: OR
48629: IFFALSE 48633
// exit ;
48631: GO 48725
// if GetTaskList ( unit ) then
48633: LD_VAR 0 1
48637: PPUSH
48638: CALL_OW 437
48642: IFFALSE 48725
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48644: LD_STRING e
48646: PUSH
48647: LD_VAR 0 1
48651: PPUSH
48652: CALL_OW 437
48656: PUSH
48657: LD_INT 1
48659: ARRAY
48660: PUSH
48661: LD_INT 1
48663: ARRAY
48664: EQUAL
48665: PUSH
48666: LD_VAR 0 4
48670: PUSH
48671: LD_VAR 0 1
48675: PPUSH
48676: CALL_OW 437
48680: PUSH
48681: LD_INT 1
48683: ARRAY
48684: PUSH
48685: LD_INT 2
48687: ARRAY
48688: EQUAL
48689: AND
48690: PUSH
48691: LD_VAR 0 5
48695: PUSH
48696: LD_VAR 0 1
48700: PPUSH
48701: CALL_OW 437
48705: PUSH
48706: LD_INT 1
48708: ARRAY
48709: PUSH
48710: LD_INT 3
48712: ARRAY
48713: EQUAL
48714: AND
48715: IFFALSE 48725
// result := true end ;
48717: LD_ADDR_VAR 0 3
48721: PUSH
48722: LD_INT 1
48724: ST_TO_ADDR
// end ;
48725: LD_VAR 0 3
48729: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48730: LD_INT 0
48732: PPUSH
// result := false ;
48733: LD_ADDR_VAR 0 4
48737: PUSH
48738: LD_INT 0
48740: ST_TO_ADDR
// if GetTaskList ( unit ) then
48741: LD_VAR 0 1
48745: PPUSH
48746: CALL_OW 437
48750: IFFALSE 48833
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48752: LD_STRING M
48754: PUSH
48755: LD_VAR 0 1
48759: PPUSH
48760: CALL_OW 437
48764: PUSH
48765: LD_INT 1
48767: ARRAY
48768: PUSH
48769: LD_INT 1
48771: ARRAY
48772: EQUAL
48773: PUSH
48774: LD_VAR 0 2
48778: PUSH
48779: LD_VAR 0 1
48783: PPUSH
48784: CALL_OW 437
48788: PUSH
48789: LD_INT 1
48791: ARRAY
48792: PUSH
48793: LD_INT 2
48795: ARRAY
48796: EQUAL
48797: AND
48798: PUSH
48799: LD_VAR 0 3
48803: PUSH
48804: LD_VAR 0 1
48808: PPUSH
48809: CALL_OW 437
48813: PUSH
48814: LD_INT 1
48816: ARRAY
48817: PUSH
48818: LD_INT 3
48820: ARRAY
48821: EQUAL
48822: AND
48823: IFFALSE 48833
// result := true ;
48825: LD_ADDR_VAR 0 4
48829: PUSH
48830: LD_INT 1
48832: ST_TO_ADDR
// end ; end ;
48833: LD_VAR 0 4
48837: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48838: LD_INT 0
48840: PPUSH
48841: PPUSH
48842: PPUSH
48843: PPUSH
// if not unit or not area then
48844: LD_VAR 0 1
48848: NOT
48849: PUSH
48850: LD_VAR 0 2
48854: NOT
48855: OR
48856: IFFALSE 48860
// exit ;
48858: GO 49024
// tmp := AreaToList ( area , i ) ;
48860: LD_ADDR_VAR 0 6
48864: PUSH
48865: LD_VAR 0 2
48869: PPUSH
48870: LD_VAR 0 5
48874: PPUSH
48875: CALL_OW 517
48879: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48880: LD_ADDR_VAR 0 5
48884: PUSH
48885: DOUBLE
48886: LD_INT 1
48888: DEC
48889: ST_TO_ADDR
48890: LD_VAR 0 6
48894: PUSH
48895: LD_INT 1
48897: ARRAY
48898: PUSH
48899: FOR_TO
48900: IFFALSE 49022
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48902: LD_ADDR_VAR 0 7
48906: PUSH
48907: LD_VAR 0 6
48911: PUSH
48912: LD_INT 1
48914: ARRAY
48915: PUSH
48916: LD_VAR 0 5
48920: ARRAY
48921: PUSH
48922: LD_VAR 0 6
48926: PUSH
48927: LD_INT 2
48929: ARRAY
48930: PUSH
48931: LD_VAR 0 5
48935: ARRAY
48936: PUSH
48937: EMPTY
48938: LIST
48939: LIST
48940: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48941: LD_VAR 0 7
48945: PUSH
48946: LD_INT 1
48948: ARRAY
48949: PPUSH
48950: LD_VAR 0 7
48954: PUSH
48955: LD_INT 2
48957: ARRAY
48958: PPUSH
48959: CALL_OW 428
48963: PUSH
48964: LD_INT 0
48966: EQUAL
48967: IFFALSE 49020
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48969: LD_VAR 0 1
48973: PPUSH
48974: LD_VAR 0 7
48978: PUSH
48979: LD_INT 1
48981: ARRAY
48982: PPUSH
48983: LD_VAR 0 7
48987: PUSH
48988: LD_INT 2
48990: ARRAY
48991: PPUSH
48992: LD_VAR 0 3
48996: PPUSH
48997: CALL_OW 48
// result := IsPlaced ( unit ) ;
49001: LD_ADDR_VAR 0 4
49005: PUSH
49006: LD_VAR 0 1
49010: PPUSH
49011: CALL_OW 305
49015: ST_TO_ADDR
// exit ;
49016: POP
49017: POP
49018: GO 49024
// end ; end ;
49020: GO 48899
49022: POP
49023: POP
// end ;
49024: LD_VAR 0 4
49028: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49029: LD_INT 0
49031: PPUSH
49032: PPUSH
49033: PPUSH
// if not side or side > 8 then
49034: LD_VAR 0 1
49038: NOT
49039: PUSH
49040: LD_VAR 0 1
49044: PUSH
49045: LD_INT 8
49047: GREATER
49048: OR
49049: IFFALSE 49053
// exit ;
49051: GO 49240
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49053: LD_ADDR_VAR 0 4
49057: PUSH
49058: LD_INT 22
49060: PUSH
49061: LD_VAR 0 1
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PUSH
49070: LD_INT 21
49072: PUSH
49073: LD_INT 3
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: PUSH
49080: EMPTY
49081: LIST
49082: LIST
49083: PPUSH
49084: CALL_OW 69
49088: ST_TO_ADDR
// if not tmp then
49089: LD_VAR 0 4
49093: NOT
49094: IFFALSE 49098
// exit ;
49096: GO 49240
// enable_addtolog := true ;
49098: LD_ADDR_OWVAR 81
49102: PUSH
49103: LD_INT 1
49105: ST_TO_ADDR
// AddToLog ( [ ) ;
49106: LD_STRING [
49108: PPUSH
49109: CALL_OW 561
// for i in tmp do
49113: LD_ADDR_VAR 0 3
49117: PUSH
49118: LD_VAR 0 4
49122: PUSH
49123: FOR_IN
49124: IFFALSE 49231
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49126: LD_STRING [
49128: PUSH
49129: LD_VAR 0 3
49133: PPUSH
49134: CALL_OW 266
49138: STR
49139: PUSH
49140: LD_STRING , 
49142: STR
49143: PUSH
49144: LD_VAR 0 3
49148: PPUSH
49149: CALL_OW 250
49153: STR
49154: PUSH
49155: LD_STRING , 
49157: STR
49158: PUSH
49159: LD_VAR 0 3
49163: PPUSH
49164: CALL_OW 251
49168: STR
49169: PUSH
49170: LD_STRING , 
49172: STR
49173: PUSH
49174: LD_VAR 0 3
49178: PPUSH
49179: CALL_OW 254
49183: STR
49184: PUSH
49185: LD_STRING , 
49187: STR
49188: PUSH
49189: LD_VAR 0 3
49193: PPUSH
49194: LD_INT 1
49196: PPUSH
49197: CALL_OW 268
49201: STR
49202: PUSH
49203: LD_STRING , 
49205: STR
49206: PUSH
49207: LD_VAR 0 3
49211: PPUSH
49212: LD_INT 2
49214: PPUSH
49215: CALL_OW 268
49219: STR
49220: PUSH
49221: LD_STRING ],
49223: STR
49224: PPUSH
49225: CALL_OW 561
// end ;
49229: GO 49123
49231: POP
49232: POP
// AddToLog ( ]; ) ;
49233: LD_STRING ];
49235: PPUSH
49236: CALL_OW 561
// end ;
49240: LD_VAR 0 2
49244: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49245: LD_INT 0
49247: PPUSH
49248: PPUSH
49249: PPUSH
49250: PPUSH
49251: PPUSH
// if not area or not rate or not max then
49252: LD_VAR 0 1
49256: NOT
49257: PUSH
49258: LD_VAR 0 2
49262: NOT
49263: OR
49264: PUSH
49265: LD_VAR 0 4
49269: NOT
49270: OR
49271: IFFALSE 49275
// exit ;
49273: GO 49467
// while 1 do
49275: LD_INT 1
49277: IFFALSE 49467
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49279: LD_ADDR_VAR 0 9
49283: PUSH
49284: LD_VAR 0 1
49288: PPUSH
49289: LD_INT 1
49291: PPUSH
49292: CALL_OW 287
49296: PUSH
49297: LD_INT 10
49299: MUL
49300: ST_TO_ADDR
// r := rate / 10 ;
49301: LD_ADDR_VAR 0 7
49305: PUSH
49306: LD_VAR 0 2
49310: PUSH
49311: LD_INT 10
49313: DIVREAL
49314: ST_TO_ADDR
// time := 1 1$00 ;
49315: LD_ADDR_VAR 0 8
49319: PUSH
49320: LD_INT 2100
49322: ST_TO_ADDR
// if amount < min then
49323: LD_VAR 0 9
49327: PUSH
49328: LD_VAR 0 3
49332: LESS
49333: IFFALSE 49351
// r := r * 2 else
49335: LD_ADDR_VAR 0 7
49339: PUSH
49340: LD_VAR 0 7
49344: PUSH
49345: LD_INT 2
49347: MUL
49348: ST_TO_ADDR
49349: GO 49377
// if amount > max then
49351: LD_VAR 0 9
49355: PUSH
49356: LD_VAR 0 4
49360: GREATER
49361: IFFALSE 49377
// r := r / 2 ;
49363: LD_ADDR_VAR 0 7
49367: PUSH
49368: LD_VAR 0 7
49372: PUSH
49373: LD_INT 2
49375: DIVREAL
49376: ST_TO_ADDR
// time := time / r ;
49377: LD_ADDR_VAR 0 8
49381: PUSH
49382: LD_VAR 0 8
49386: PUSH
49387: LD_VAR 0 7
49391: DIVREAL
49392: ST_TO_ADDR
// if time < 0 then
49393: LD_VAR 0 8
49397: PUSH
49398: LD_INT 0
49400: LESS
49401: IFFALSE 49418
// time := time * - 1 ;
49403: LD_ADDR_VAR 0 8
49407: PUSH
49408: LD_VAR 0 8
49412: PUSH
49413: LD_INT 1
49415: NEG
49416: MUL
49417: ST_TO_ADDR
// wait ( time ) ;
49418: LD_VAR 0 8
49422: PPUSH
49423: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49427: LD_INT 35
49429: PPUSH
49430: LD_INT 875
49432: PPUSH
49433: CALL_OW 12
49437: PPUSH
49438: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49442: LD_INT 1
49444: PPUSH
49445: LD_INT 5
49447: PPUSH
49448: CALL_OW 12
49452: PPUSH
49453: LD_VAR 0 1
49457: PPUSH
49458: LD_INT 1
49460: PPUSH
49461: CALL_OW 55
// end ;
49465: GO 49275
// end ;
49467: LD_VAR 0 5
49471: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49472: LD_INT 0
49474: PPUSH
49475: PPUSH
49476: PPUSH
49477: PPUSH
49478: PPUSH
49479: PPUSH
49480: PPUSH
49481: PPUSH
// if not turrets or not factories then
49482: LD_VAR 0 1
49486: NOT
49487: PUSH
49488: LD_VAR 0 2
49492: NOT
49493: OR
49494: IFFALSE 49498
// exit ;
49496: GO 49805
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49498: LD_ADDR_VAR 0 10
49502: PUSH
49503: LD_INT 5
49505: PUSH
49506: LD_INT 6
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 2
49515: PUSH
49516: LD_INT 4
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: LD_INT 3
49525: PUSH
49526: LD_INT 5
49528: PUSH
49529: EMPTY
49530: LIST
49531: LIST
49532: PUSH
49533: EMPTY
49534: LIST
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 24
49540: PUSH
49541: LD_INT 25
49543: PUSH
49544: EMPTY
49545: LIST
49546: LIST
49547: PUSH
49548: LD_INT 23
49550: PUSH
49551: LD_INT 27
49553: PUSH
49554: EMPTY
49555: LIST
49556: LIST
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 42
49564: PUSH
49565: LD_INT 43
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 44
49574: PUSH
49575: LD_INT 46
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: LD_INT 45
49584: PUSH
49585: LD_INT 47
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: LIST
49596: PUSH
49597: EMPTY
49598: LIST
49599: LIST
49600: LIST
49601: ST_TO_ADDR
// result := [ ] ;
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: EMPTY
49608: ST_TO_ADDR
// for i in turrets do
49609: LD_ADDR_VAR 0 4
49613: PUSH
49614: LD_VAR 0 1
49618: PUSH
49619: FOR_IN
49620: IFFALSE 49803
// begin nat := GetNation ( i ) ;
49622: LD_ADDR_VAR 0 7
49626: PUSH
49627: LD_VAR 0 4
49631: PPUSH
49632: CALL_OW 248
49636: ST_TO_ADDR
// weapon := 0 ;
49637: LD_ADDR_VAR 0 8
49641: PUSH
49642: LD_INT 0
49644: ST_TO_ADDR
// if not nat then
49645: LD_VAR 0 7
49649: NOT
49650: IFFALSE 49654
// continue ;
49652: GO 49619
// for j in list [ nat ] do
49654: LD_ADDR_VAR 0 5
49658: PUSH
49659: LD_VAR 0 10
49663: PUSH
49664: LD_VAR 0 7
49668: ARRAY
49669: PUSH
49670: FOR_IN
49671: IFFALSE 49712
// if GetBWeapon ( i ) = j [ 1 ] then
49673: LD_VAR 0 4
49677: PPUSH
49678: CALL_OW 269
49682: PUSH
49683: LD_VAR 0 5
49687: PUSH
49688: LD_INT 1
49690: ARRAY
49691: EQUAL
49692: IFFALSE 49710
// begin weapon := j [ 2 ] ;
49694: LD_ADDR_VAR 0 8
49698: PUSH
49699: LD_VAR 0 5
49703: PUSH
49704: LD_INT 2
49706: ARRAY
49707: ST_TO_ADDR
// break ;
49708: GO 49712
// end ;
49710: GO 49670
49712: POP
49713: POP
// if not weapon then
49714: LD_VAR 0 8
49718: NOT
49719: IFFALSE 49723
// continue ;
49721: GO 49619
// for k in factories do
49723: LD_ADDR_VAR 0 6
49727: PUSH
49728: LD_VAR 0 2
49732: PUSH
49733: FOR_IN
49734: IFFALSE 49799
// begin weapons := AvailableWeaponList ( k ) ;
49736: LD_ADDR_VAR 0 9
49740: PUSH
49741: LD_VAR 0 6
49745: PPUSH
49746: CALL_OW 478
49750: ST_TO_ADDR
// if not weapons then
49751: LD_VAR 0 9
49755: NOT
49756: IFFALSE 49760
// continue ;
49758: GO 49733
// if weapon in weapons then
49760: LD_VAR 0 8
49764: PUSH
49765: LD_VAR 0 9
49769: IN
49770: IFFALSE 49797
// begin result := [ i , weapon ] ;
49772: LD_ADDR_VAR 0 3
49776: PUSH
49777: LD_VAR 0 4
49781: PUSH
49782: LD_VAR 0 8
49786: PUSH
49787: EMPTY
49788: LIST
49789: LIST
49790: ST_TO_ADDR
// exit ;
49791: POP
49792: POP
49793: POP
49794: POP
49795: GO 49805
// end ; end ;
49797: GO 49733
49799: POP
49800: POP
// end ;
49801: GO 49619
49803: POP
49804: POP
// end ;
49805: LD_VAR 0 3
49809: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49810: LD_INT 0
49812: PPUSH
// if not side or side > 8 then
49813: LD_VAR 0 3
49817: NOT
49818: PUSH
49819: LD_VAR 0 3
49823: PUSH
49824: LD_INT 8
49826: GREATER
49827: OR
49828: IFFALSE 49832
// exit ;
49830: GO 49891
// if not range then
49832: LD_VAR 0 4
49836: NOT
49837: IFFALSE 49848
// range := - 12 ;
49839: LD_ADDR_VAR 0 4
49843: PUSH
49844: LD_INT 12
49846: NEG
49847: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49848: LD_VAR 0 1
49852: PPUSH
49853: LD_VAR 0 2
49857: PPUSH
49858: LD_VAR 0 3
49862: PPUSH
49863: LD_VAR 0 4
49867: PPUSH
49868: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49872: LD_VAR 0 1
49876: PPUSH
49877: LD_VAR 0 2
49881: PPUSH
49882: LD_VAR 0 3
49886: PPUSH
49887: CALL_OW 331
// end ;
49891: LD_VAR 0 5
49895: RET
// export function Video ( mode ) ; begin
49896: LD_INT 0
49898: PPUSH
// ingame_video = mode ;
49899: LD_ADDR_OWVAR 52
49903: PUSH
49904: LD_VAR 0 1
49908: ST_TO_ADDR
// interface_hidden = mode ;
49909: LD_ADDR_OWVAR 54
49913: PUSH
49914: LD_VAR 0 1
49918: ST_TO_ADDR
// end ;
49919: LD_VAR 0 2
49923: RET
// export function Join ( array , element ) ; begin
49924: LD_INT 0
49926: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49927: LD_ADDR_VAR 0 3
49931: PUSH
49932: LD_VAR 0 1
49936: PPUSH
49937: LD_VAR 0 1
49941: PUSH
49942: LD_INT 1
49944: PLUS
49945: PPUSH
49946: LD_VAR 0 2
49950: PPUSH
49951: CALL_OW 1
49955: ST_TO_ADDR
// end ;
49956: LD_VAR 0 3
49960: RET
// export function JoinUnion ( array , element ) ; begin
49961: LD_INT 0
49963: PPUSH
// result := array union element ;
49964: LD_ADDR_VAR 0 3
49968: PUSH
49969: LD_VAR 0 1
49973: PUSH
49974: LD_VAR 0 2
49978: UNION
49979: ST_TO_ADDR
// end ;
49980: LD_VAR 0 3
49984: RET
// export function GetBehemoths ( side ) ; begin
49985: LD_INT 0
49987: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49988: LD_ADDR_VAR 0 2
49992: PUSH
49993: LD_INT 22
49995: PUSH
49996: LD_VAR 0 1
50000: PUSH
50001: EMPTY
50002: LIST
50003: LIST
50004: PUSH
50005: LD_INT 31
50007: PUSH
50008: LD_INT 25
50010: PUSH
50011: EMPTY
50012: LIST
50013: LIST
50014: PUSH
50015: EMPTY
50016: LIST
50017: LIST
50018: PPUSH
50019: CALL_OW 69
50023: ST_TO_ADDR
// end ;
50024: LD_VAR 0 2
50028: RET
// export function Shuffle ( array ) ; var i , index ; begin
50029: LD_INT 0
50031: PPUSH
50032: PPUSH
50033: PPUSH
// result := [ ] ;
50034: LD_ADDR_VAR 0 2
50038: PUSH
50039: EMPTY
50040: ST_TO_ADDR
// if not array then
50041: LD_VAR 0 1
50045: NOT
50046: IFFALSE 50050
// exit ;
50048: GO 50149
// Randomize ;
50050: CALL_OW 10
// for i = array downto 1 do
50054: LD_ADDR_VAR 0 3
50058: PUSH
50059: DOUBLE
50060: LD_VAR 0 1
50064: INC
50065: ST_TO_ADDR
50066: LD_INT 1
50068: PUSH
50069: FOR_DOWNTO
50070: IFFALSE 50147
// begin index := rand ( 1 , array ) ;
50072: LD_ADDR_VAR 0 4
50076: PUSH
50077: LD_INT 1
50079: PPUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 12
50089: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50090: LD_ADDR_VAR 0 2
50094: PUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: LD_VAR 0 2
50104: PUSH
50105: LD_INT 1
50107: PLUS
50108: PPUSH
50109: LD_VAR 0 1
50113: PUSH
50114: LD_VAR 0 4
50118: ARRAY
50119: PPUSH
50120: CALL_OW 2
50124: ST_TO_ADDR
// array := Delete ( array , index ) ;
50125: LD_ADDR_VAR 0 1
50129: PUSH
50130: LD_VAR 0 1
50134: PPUSH
50135: LD_VAR 0 4
50139: PPUSH
50140: CALL_OW 3
50144: ST_TO_ADDR
// end ;
50145: GO 50069
50147: POP
50148: POP
// end ;
50149: LD_VAR 0 2
50153: RET
// export function GetBaseMaterials ( base ) ; begin
50154: LD_INT 0
50156: PPUSH
// result := [ 0 , 0 , 0 ] ;
50157: LD_ADDR_VAR 0 2
50161: PUSH
50162: LD_INT 0
50164: PUSH
50165: LD_INT 0
50167: PUSH
50168: LD_INT 0
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: LIST
50175: ST_TO_ADDR
// if not base then
50176: LD_VAR 0 1
50180: NOT
50181: IFFALSE 50185
// exit ;
50183: GO 50234
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50185: LD_ADDR_VAR 0 2
50189: PUSH
50190: LD_VAR 0 1
50194: PPUSH
50195: LD_INT 1
50197: PPUSH
50198: CALL_OW 275
50202: PUSH
50203: LD_VAR 0 1
50207: PPUSH
50208: LD_INT 2
50210: PPUSH
50211: CALL_OW 275
50215: PUSH
50216: LD_VAR 0 1
50220: PPUSH
50221: LD_INT 3
50223: PPUSH
50224: CALL_OW 275
50228: PUSH
50229: EMPTY
50230: LIST
50231: LIST
50232: LIST
50233: ST_TO_ADDR
// end ;
50234: LD_VAR 0 2
50238: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50239: LD_INT 0
50241: PPUSH
50242: PPUSH
// result := array ;
50243: LD_ADDR_VAR 0 3
50247: PUSH
50248: LD_VAR 0 1
50252: ST_TO_ADDR
// if size > 0 then
50253: LD_VAR 0 2
50257: PUSH
50258: LD_INT 0
50260: GREATER
50261: IFFALSE 50307
// for i := array downto size do
50263: LD_ADDR_VAR 0 4
50267: PUSH
50268: DOUBLE
50269: LD_VAR 0 1
50273: INC
50274: ST_TO_ADDR
50275: LD_VAR 0 2
50279: PUSH
50280: FOR_DOWNTO
50281: IFFALSE 50305
// result := Delete ( result , result ) ;
50283: LD_ADDR_VAR 0 3
50287: PUSH
50288: LD_VAR 0 3
50292: PPUSH
50293: LD_VAR 0 3
50297: PPUSH
50298: CALL_OW 3
50302: ST_TO_ADDR
50303: GO 50280
50305: POP
50306: POP
// end ;
50307: LD_VAR 0 3
50311: RET
// export function ComExit ( unit ) ; var tmp ; begin
50312: LD_INT 0
50314: PPUSH
50315: PPUSH
// if not IsInUnit ( unit ) then
50316: LD_VAR 0 1
50320: PPUSH
50321: CALL_OW 310
50325: NOT
50326: IFFALSE 50330
// exit ;
50328: GO 50390
// tmp := IsInUnit ( unit ) ;
50330: LD_ADDR_VAR 0 3
50334: PUSH
50335: LD_VAR 0 1
50339: PPUSH
50340: CALL_OW 310
50344: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50345: LD_VAR 0 3
50349: PPUSH
50350: CALL_OW 247
50354: PUSH
50355: LD_INT 2
50357: EQUAL
50358: IFFALSE 50371
// ComExitVehicle ( unit ) else
50360: LD_VAR 0 1
50364: PPUSH
50365: CALL_OW 121
50369: GO 50380
// ComExitBuilding ( unit ) ;
50371: LD_VAR 0 1
50375: PPUSH
50376: CALL_OW 122
// result := tmp ;
50380: LD_ADDR_VAR 0 2
50384: PUSH
50385: LD_VAR 0 3
50389: ST_TO_ADDR
// end ;
50390: LD_VAR 0 2
50394: RET
// export function ComExitAll ( units ) ; var i ; begin
50395: LD_INT 0
50397: PPUSH
50398: PPUSH
// if not units then
50399: LD_VAR 0 1
50403: NOT
50404: IFFALSE 50408
// exit ;
50406: GO 50434
// for i in units do
50408: LD_ADDR_VAR 0 3
50412: PUSH
50413: LD_VAR 0 1
50417: PUSH
50418: FOR_IN
50419: IFFALSE 50432
// ComExit ( i ) ;
50421: LD_VAR 0 3
50425: PPUSH
50426: CALL 50312 0 1
50430: GO 50418
50432: POP
50433: POP
// end ;
50434: LD_VAR 0 2
50438: RET
// export function ResetHc ; begin
50439: LD_INT 0
50441: PPUSH
// InitHc ;
50442: CALL_OW 19
// hc_importance := 0 ;
50446: LD_ADDR_OWVAR 32
50450: PUSH
50451: LD_INT 0
50453: ST_TO_ADDR
// end ;
50454: LD_VAR 0 1
50458: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50459: LD_INT 0
50461: PPUSH
50462: PPUSH
50463: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50464: LD_ADDR_VAR 0 6
50468: PUSH
50469: LD_VAR 0 1
50473: PUSH
50474: LD_VAR 0 3
50478: PLUS
50479: PUSH
50480: LD_INT 2
50482: DIV
50483: ST_TO_ADDR
// if _x < 0 then
50484: LD_VAR 0 6
50488: PUSH
50489: LD_INT 0
50491: LESS
50492: IFFALSE 50509
// _x := _x * - 1 ;
50494: LD_ADDR_VAR 0 6
50498: PUSH
50499: LD_VAR 0 6
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: MUL
50508: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50509: LD_ADDR_VAR 0 7
50513: PUSH
50514: LD_VAR 0 2
50518: PUSH
50519: LD_VAR 0 4
50523: PLUS
50524: PUSH
50525: LD_INT 2
50527: DIV
50528: ST_TO_ADDR
// if _y < 0 then
50529: LD_VAR 0 7
50533: PUSH
50534: LD_INT 0
50536: LESS
50537: IFFALSE 50554
// _y := _y * - 1 ;
50539: LD_ADDR_VAR 0 7
50543: PUSH
50544: LD_VAR 0 7
50548: PUSH
50549: LD_INT 1
50551: NEG
50552: MUL
50553: ST_TO_ADDR
// result := [ _x , _y ] ;
50554: LD_ADDR_VAR 0 5
50558: PUSH
50559: LD_VAR 0 6
50563: PUSH
50564: LD_VAR 0 7
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: ST_TO_ADDR
// end ;
50573: LD_VAR 0 5
50577: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50578: LD_INT 0
50580: PPUSH
50581: PPUSH
50582: PPUSH
50583: PPUSH
// task := GetTaskList ( unit ) ;
50584: LD_ADDR_VAR 0 7
50588: PUSH
50589: LD_VAR 0 1
50593: PPUSH
50594: CALL_OW 437
50598: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50599: LD_VAR 0 7
50603: NOT
50604: PUSH
50605: LD_VAR 0 1
50609: PPUSH
50610: LD_VAR 0 2
50614: PPUSH
50615: CALL_OW 308
50619: NOT
50620: AND
50621: IFFALSE 50625
// exit ;
50623: GO 50743
// if IsInArea ( unit , area ) then
50625: LD_VAR 0 1
50629: PPUSH
50630: LD_VAR 0 2
50634: PPUSH
50635: CALL_OW 308
50639: IFFALSE 50657
// begin ComMoveToArea ( unit , goAway ) ;
50641: LD_VAR 0 1
50645: PPUSH
50646: LD_VAR 0 3
50650: PPUSH
50651: CALL_OW 113
// exit ;
50655: GO 50743
// end ; if task [ 1 ] [ 1 ] <> M then
50657: LD_VAR 0 7
50661: PUSH
50662: LD_INT 1
50664: ARRAY
50665: PUSH
50666: LD_INT 1
50668: ARRAY
50669: PUSH
50670: LD_STRING M
50672: NONEQUAL
50673: IFFALSE 50677
// exit ;
50675: GO 50743
// x := task [ 1 ] [ 2 ] ;
50677: LD_ADDR_VAR 0 5
50681: PUSH
50682: LD_VAR 0 7
50686: PUSH
50687: LD_INT 1
50689: ARRAY
50690: PUSH
50691: LD_INT 2
50693: ARRAY
50694: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50695: LD_ADDR_VAR 0 6
50699: PUSH
50700: LD_VAR 0 7
50704: PUSH
50705: LD_INT 1
50707: ARRAY
50708: PUSH
50709: LD_INT 3
50711: ARRAY
50712: ST_TO_ADDR
// if InArea ( x , y , area ) then
50713: LD_VAR 0 5
50717: PPUSH
50718: LD_VAR 0 6
50722: PPUSH
50723: LD_VAR 0 2
50727: PPUSH
50728: CALL_OW 309
50732: IFFALSE 50743
// ComStop ( unit ) ;
50734: LD_VAR 0 1
50738: PPUSH
50739: CALL_OW 141
// end ;
50743: LD_VAR 0 4
50747: RET
// export function Abs ( value ) ; begin
50748: LD_INT 0
50750: PPUSH
// result := value ;
50751: LD_ADDR_VAR 0 2
50755: PUSH
50756: LD_VAR 0 1
50760: ST_TO_ADDR
// if value < 0 then
50761: LD_VAR 0 1
50765: PUSH
50766: LD_INT 0
50768: LESS
50769: IFFALSE 50786
// result := value * - 1 ;
50771: LD_ADDR_VAR 0 2
50775: PUSH
50776: LD_VAR 0 1
50780: PUSH
50781: LD_INT 1
50783: NEG
50784: MUL
50785: ST_TO_ADDR
// end ;
50786: LD_VAR 0 2
50790: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
50791: LD_INT 0
50793: PPUSH
50794: PPUSH
50795: PPUSH
50796: PPUSH
50797: PPUSH
50798: PPUSH
50799: PPUSH
50800: PPUSH
// if not unit or not building then
50801: LD_VAR 0 1
50805: NOT
50806: PUSH
50807: LD_VAR 0 2
50811: NOT
50812: OR
50813: IFFALSE 50817
// exit ;
50815: GO 51043
// x := GetX ( building ) ;
50817: LD_ADDR_VAR 0 4
50821: PUSH
50822: LD_VAR 0 2
50826: PPUSH
50827: CALL_OW 250
50831: ST_TO_ADDR
// y := GetY ( building ) ;
50832: LD_ADDR_VAR 0 6
50836: PUSH
50837: LD_VAR 0 2
50841: PPUSH
50842: CALL_OW 251
50846: ST_TO_ADDR
// d := GetDir ( building ) ;
50847: LD_ADDR_VAR 0 8
50851: PUSH
50852: LD_VAR 0 2
50856: PPUSH
50857: CALL_OW 254
50861: ST_TO_ADDR
// r := 4 ;
50862: LD_ADDR_VAR 0 9
50866: PUSH
50867: LD_INT 4
50869: ST_TO_ADDR
// for i := 1 to 5 do
50870: LD_ADDR_VAR 0 10
50874: PUSH
50875: DOUBLE
50876: LD_INT 1
50878: DEC
50879: ST_TO_ADDR
50880: LD_INT 5
50882: PUSH
50883: FOR_TO
50884: IFFALSE 51041
// begin _x := ShiftX ( x , d , r + i ) ;
50886: LD_ADDR_VAR 0 5
50890: PUSH
50891: LD_VAR 0 4
50895: PPUSH
50896: LD_VAR 0 8
50900: PPUSH
50901: LD_VAR 0 9
50905: PUSH
50906: LD_VAR 0 10
50910: PLUS
50911: PPUSH
50912: CALL_OW 272
50916: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
50917: LD_ADDR_VAR 0 7
50921: PUSH
50922: LD_VAR 0 6
50926: PPUSH
50927: LD_VAR 0 8
50931: PPUSH
50932: LD_VAR 0 9
50936: PUSH
50937: LD_VAR 0 10
50941: PLUS
50942: PPUSH
50943: CALL_OW 273
50947: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
50948: LD_VAR 0 5
50952: PPUSH
50953: LD_VAR 0 7
50957: PPUSH
50958: CALL_OW 488
50962: PUSH
50963: LD_VAR 0 5
50967: PPUSH
50968: LD_VAR 0 7
50972: PPUSH
50973: CALL_OW 428
50977: PPUSH
50978: CALL_OW 247
50982: PUSH
50983: LD_INT 3
50985: PUSH
50986: LD_INT 2
50988: PUSH
50989: EMPTY
50990: LIST
50991: LIST
50992: IN
50993: NOT
50994: AND
50995: IFFALSE 51039
// begin ComMoveXY ( unit , _x , _y ) ;
50997: LD_VAR 0 1
51001: PPUSH
51002: LD_VAR 0 5
51006: PPUSH
51007: LD_VAR 0 7
51011: PPUSH
51012: CALL_OW 111
// result := [ _x , _y ] ;
51016: LD_ADDR_VAR 0 3
51020: PUSH
51021: LD_VAR 0 5
51025: PUSH
51026: LD_VAR 0 7
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: ST_TO_ADDR
// exit ;
51035: POP
51036: POP
51037: GO 51043
// end ; end ;
51039: GO 50883
51041: POP
51042: POP
// end ;
51043: LD_VAR 0 3
51047: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51048: LD_INT 0
51050: PPUSH
51051: PPUSH
51052: PPUSH
// result := 0 ;
51053: LD_ADDR_VAR 0 3
51057: PUSH
51058: LD_INT 0
51060: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51061: LD_VAR 0 1
51065: PUSH
51066: LD_INT 0
51068: LESS
51069: PUSH
51070: LD_VAR 0 1
51074: PUSH
51075: LD_INT 8
51077: GREATER
51078: OR
51079: PUSH
51080: LD_VAR 0 2
51084: PUSH
51085: LD_INT 0
51087: LESS
51088: OR
51089: PUSH
51090: LD_VAR 0 2
51094: PUSH
51095: LD_INT 8
51097: GREATER
51098: OR
51099: IFFALSE 51103
// exit ;
51101: GO 51178
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51103: LD_ADDR_VAR 0 4
51107: PUSH
51108: LD_INT 22
51110: PUSH
51111: LD_VAR 0 2
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PPUSH
51120: CALL_OW 69
51124: PUSH
51125: FOR_IN
51126: IFFALSE 51176
// begin un := UnitShoot ( i ) ;
51128: LD_ADDR_VAR 0 5
51132: PUSH
51133: LD_VAR 0 4
51137: PPUSH
51138: CALL_OW 504
51142: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51143: LD_VAR 0 5
51147: PPUSH
51148: CALL_OW 255
51152: PUSH
51153: LD_VAR 0 1
51157: EQUAL
51158: IFFALSE 51174
// begin result := un ;
51160: LD_ADDR_VAR 0 3
51164: PUSH
51165: LD_VAR 0 5
51169: ST_TO_ADDR
// exit ;
51170: POP
51171: POP
51172: GO 51178
// end ; end ;
51174: GO 51125
51176: POP
51177: POP
// end ;
51178: LD_VAR 0 3
51182: RET
// export function GetCargoBay ( units ) ; begin
51183: LD_INT 0
51185: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: LD_VAR 0 1
51195: PPUSH
51196: LD_INT 2
51198: PUSH
51199: LD_INT 34
51201: PUSH
51202: LD_INT 12
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: LD_INT 34
51211: PUSH
51212: LD_INT 51
51214: PUSH
51215: EMPTY
51216: LIST
51217: LIST
51218: PUSH
51219: LD_INT 34
51221: PUSH
51222: LD_INT 32
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: PUSH
51229: LD_INT 34
51231: PUSH
51232: LD_EXP 49
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PUSH
51241: EMPTY
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: PPUSH
51248: CALL_OW 72
51252: ST_TO_ADDR
// end ; end_of_file
51253: LD_VAR 0 2
51257: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
51258: LD_INT 0
51260: PPUSH
// ar_miner := 81 ;
51261: LD_ADDR_EXP 55
51265: PUSH
51266: LD_INT 81
51268: ST_TO_ADDR
// ar_crane := 88 ;
51269: LD_ADDR_EXP 54
51273: PUSH
51274: LD_INT 88
51276: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
51277: LD_ADDR_EXP 49
51281: PUSH
51282: LD_INT 89
51284: ST_TO_ADDR
// us_hack := 99 ;
51285: LD_ADDR_EXP 50
51289: PUSH
51290: LD_INT 99
51292: ST_TO_ADDR
// us_artillery := 97 ;
51293: LD_ADDR_EXP 51
51297: PUSH
51298: LD_INT 97
51300: ST_TO_ADDR
// ar_bio_bomb := 91 ;
51301: LD_ADDR_EXP 52
51305: PUSH
51306: LD_INT 91
51308: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
51309: LD_ADDR_EXP 53
51313: PUSH
51314: LD_INT 92
51316: ST_TO_ADDR
// ru_radar := 98 ;
51317: LD_ADDR_EXP 48
51321: PUSH
51322: LD_INT 98
51324: ST_TO_ADDR
// tech_Artillery := 80 ;
51325: LD_ADDR_EXP 56
51329: PUSH
51330: LD_INT 80
51332: ST_TO_ADDR
// tech_RadMat := 81 ;
51333: LD_ADDR_EXP 57
51337: PUSH
51338: LD_INT 81
51340: ST_TO_ADDR
// tech_BasicTools := 82 ;
51341: LD_ADDR_EXP 58
51345: PUSH
51346: LD_INT 82
51348: ST_TO_ADDR
// tech_Cargo := 83 ;
51349: LD_ADDR_EXP 59
51353: PUSH
51354: LD_INT 83
51356: ST_TO_ADDR
// tech_Track := 84 ;
51357: LD_ADDR_EXP 60
51361: PUSH
51362: LD_INT 84
51364: ST_TO_ADDR
// tech_Crane := 85 ;
51365: LD_ADDR_EXP 61
51369: PUSH
51370: LD_INT 85
51372: ST_TO_ADDR
// tech_Bulldozer := 86 ;
51373: LD_ADDR_EXP 62
51377: PUSH
51378: LD_INT 86
51380: ST_TO_ADDR
// tech_Hovercraft := 87 ;
51381: LD_ADDR_EXP 63
51385: PUSH
51386: LD_INT 87
51388: ST_TO_ADDR
// end ;
51389: LD_VAR 0 1
51393: RET
// every 1 do
51394: GO 51396
51396: DISABLE
// InitGlobalVariables ; end_of_file
51397: CALL 51258 0 0
51401: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
51402: LD_INT 0
51404: PPUSH
51405: PPUSH
// skirmish := false ;
51406: LD_ADDR_EXP 64
51410: PUSH
51411: LD_INT 0
51413: ST_TO_ADDR
// debug_mc := false ;
51414: LD_ADDR_EXP 65
51418: PUSH
51419: LD_INT 0
51421: ST_TO_ADDR
// mc_bases := [ ] ;
51422: LD_ADDR_EXP 66
51426: PUSH
51427: EMPTY
51428: ST_TO_ADDR
// mc_sides := [ ] ;
51429: LD_ADDR_EXP 92
51433: PUSH
51434: EMPTY
51435: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51436: LD_ADDR_EXP 67
51440: PUSH
51441: EMPTY
51442: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51443: LD_ADDR_EXP 68
51447: PUSH
51448: EMPTY
51449: ST_TO_ADDR
// mc_need_heal := [ ] ;
51450: LD_ADDR_EXP 69
51454: PUSH
51455: EMPTY
51456: ST_TO_ADDR
// mc_healers := [ ] ;
51457: LD_ADDR_EXP 70
51461: PUSH
51462: EMPTY
51463: ST_TO_ADDR
// mc_build_list := [ ] ;
51464: LD_ADDR_EXP 71
51468: PUSH
51469: EMPTY
51470: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51471: LD_ADDR_EXP 98
51475: PUSH
51476: EMPTY
51477: ST_TO_ADDR
// mc_builders := [ ] ;
51478: LD_ADDR_EXP 72
51482: PUSH
51483: EMPTY
51484: ST_TO_ADDR
// mc_construct_list := [ ] ;
51485: LD_ADDR_EXP 73
51489: PUSH
51490: EMPTY
51491: ST_TO_ADDR
// mc_turret_list := [ ] ;
51492: LD_ADDR_EXP 74
51496: PUSH
51497: EMPTY
51498: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51499: LD_ADDR_EXP 75
51503: PUSH
51504: EMPTY
51505: ST_TO_ADDR
// mc_miners := [ ] ;
51506: LD_ADDR_EXP 80
51510: PUSH
51511: EMPTY
51512: ST_TO_ADDR
// mc_mines := [ ] ;
51513: LD_ADDR_EXP 79
51517: PUSH
51518: EMPTY
51519: ST_TO_ADDR
// mc_minefields := [ ] ;
51520: LD_ADDR_EXP 81
51524: PUSH
51525: EMPTY
51526: ST_TO_ADDR
// mc_crates := [ ] ;
51527: LD_ADDR_EXP 82
51531: PUSH
51532: EMPTY
51533: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51534: LD_ADDR_EXP 83
51538: PUSH
51539: EMPTY
51540: ST_TO_ADDR
// mc_crates_area := [ ] ;
51541: LD_ADDR_EXP 84
51545: PUSH
51546: EMPTY
51547: ST_TO_ADDR
// mc_vehicles := [ ] ;
51548: LD_ADDR_EXP 85
51552: PUSH
51553: EMPTY
51554: ST_TO_ADDR
// mc_attack := [ ] ;
51555: LD_ADDR_EXP 86
51559: PUSH
51560: EMPTY
51561: ST_TO_ADDR
// mc_produce := [ ] ;
51562: LD_ADDR_EXP 87
51566: PUSH
51567: EMPTY
51568: ST_TO_ADDR
// mc_defender := [ ] ;
51569: LD_ADDR_EXP 88
51573: PUSH
51574: EMPTY
51575: ST_TO_ADDR
// mc_parking := [ ] ;
51576: LD_ADDR_EXP 90
51580: PUSH
51581: EMPTY
51582: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51583: LD_ADDR_EXP 76
51587: PUSH
51588: EMPTY
51589: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51590: LD_ADDR_EXP 78
51594: PUSH
51595: EMPTY
51596: ST_TO_ADDR
// mc_scan := [ ] ;
51597: LD_ADDR_EXP 89
51601: PUSH
51602: EMPTY
51603: ST_TO_ADDR
// mc_scan_area := [ ] ;
51604: LD_ADDR_EXP 91
51608: PUSH
51609: EMPTY
51610: ST_TO_ADDR
// mc_tech := [ ] ;
51611: LD_ADDR_EXP 93
51615: PUSH
51616: EMPTY
51617: ST_TO_ADDR
// mc_class := [ ] ;
51618: LD_ADDR_EXP 107
51622: PUSH
51623: EMPTY
51624: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51625: LD_ADDR_EXP 108
51629: PUSH
51630: EMPTY
51631: ST_TO_ADDR
// end ;
51632: LD_VAR 0 1
51636: RET
// export function MC_Kill ( base ) ; begin
51637: LD_INT 0
51639: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51640: LD_ADDR_EXP 66
51644: PUSH
51645: LD_EXP 66
51649: PPUSH
51650: LD_VAR 0 1
51654: PPUSH
51655: EMPTY
51656: PPUSH
51657: CALL_OW 1
51661: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51662: LD_ADDR_EXP 67
51666: PUSH
51667: LD_EXP 67
51671: PPUSH
51672: LD_VAR 0 1
51676: PPUSH
51677: EMPTY
51678: PPUSH
51679: CALL_OW 1
51683: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51684: LD_ADDR_EXP 68
51688: PUSH
51689: LD_EXP 68
51693: PPUSH
51694: LD_VAR 0 1
51698: PPUSH
51699: EMPTY
51700: PPUSH
51701: CALL_OW 1
51705: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51706: LD_ADDR_EXP 69
51710: PUSH
51711: LD_EXP 69
51715: PPUSH
51716: LD_VAR 0 1
51720: PPUSH
51721: EMPTY
51722: PPUSH
51723: CALL_OW 1
51727: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51728: LD_ADDR_EXP 70
51732: PUSH
51733: LD_EXP 70
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: EMPTY
51744: PPUSH
51745: CALL_OW 1
51749: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51750: LD_ADDR_EXP 71
51754: PUSH
51755: LD_EXP 71
51759: PPUSH
51760: LD_VAR 0 1
51764: PPUSH
51765: EMPTY
51766: PPUSH
51767: CALL_OW 1
51771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51772: LD_ADDR_EXP 72
51776: PUSH
51777: LD_EXP 72
51781: PPUSH
51782: LD_VAR 0 1
51786: PPUSH
51787: EMPTY
51788: PPUSH
51789: CALL_OW 1
51793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51794: LD_ADDR_EXP 73
51798: PUSH
51799: LD_EXP 73
51803: PPUSH
51804: LD_VAR 0 1
51808: PPUSH
51809: EMPTY
51810: PPUSH
51811: CALL_OW 1
51815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51816: LD_ADDR_EXP 74
51820: PUSH
51821: LD_EXP 74
51825: PPUSH
51826: LD_VAR 0 1
51830: PPUSH
51831: EMPTY
51832: PPUSH
51833: CALL_OW 1
51837: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51838: LD_ADDR_EXP 75
51842: PUSH
51843: LD_EXP 75
51847: PPUSH
51848: LD_VAR 0 1
51852: PPUSH
51853: EMPTY
51854: PPUSH
51855: CALL_OW 1
51859: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51860: LD_ADDR_EXP 76
51864: PUSH
51865: LD_EXP 76
51869: PPUSH
51870: LD_VAR 0 1
51874: PPUSH
51875: EMPTY
51876: PPUSH
51877: CALL_OW 1
51881: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51882: LD_ADDR_EXP 77
51886: PUSH
51887: LD_EXP 77
51891: PPUSH
51892: LD_VAR 0 1
51896: PPUSH
51897: LD_INT 0
51899: PPUSH
51900: CALL_OW 1
51904: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51905: LD_ADDR_EXP 78
51909: PUSH
51910: LD_EXP 78
51914: PPUSH
51915: LD_VAR 0 1
51919: PPUSH
51920: EMPTY
51921: PPUSH
51922: CALL_OW 1
51926: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51927: LD_ADDR_EXP 79
51931: PUSH
51932: LD_EXP 79
51936: PPUSH
51937: LD_VAR 0 1
51941: PPUSH
51942: EMPTY
51943: PPUSH
51944: CALL_OW 1
51948: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51949: LD_ADDR_EXP 80
51953: PUSH
51954: LD_EXP 80
51958: PPUSH
51959: LD_VAR 0 1
51963: PPUSH
51964: EMPTY
51965: PPUSH
51966: CALL_OW 1
51970: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51971: LD_ADDR_EXP 81
51975: PUSH
51976: LD_EXP 81
51980: PPUSH
51981: LD_VAR 0 1
51985: PPUSH
51986: EMPTY
51987: PPUSH
51988: CALL_OW 1
51992: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51993: LD_ADDR_EXP 82
51997: PUSH
51998: LD_EXP 82
52002: PPUSH
52003: LD_VAR 0 1
52007: PPUSH
52008: EMPTY
52009: PPUSH
52010: CALL_OW 1
52014: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52015: LD_ADDR_EXP 83
52019: PUSH
52020: LD_EXP 83
52024: PPUSH
52025: LD_VAR 0 1
52029: PPUSH
52030: EMPTY
52031: PPUSH
52032: CALL_OW 1
52036: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52037: LD_ADDR_EXP 84
52041: PUSH
52042: LD_EXP 84
52046: PPUSH
52047: LD_VAR 0 1
52051: PPUSH
52052: EMPTY
52053: PPUSH
52054: CALL_OW 1
52058: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52059: LD_ADDR_EXP 85
52063: PUSH
52064: LD_EXP 85
52068: PPUSH
52069: LD_VAR 0 1
52073: PPUSH
52074: EMPTY
52075: PPUSH
52076: CALL_OW 1
52080: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52081: LD_ADDR_EXP 86
52085: PUSH
52086: LD_EXP 86
52090: PPUSH
52091: LD_VAR 0 1
52095: PPUSH
52096: EMPTY
52097: PPUSH
52098: CALL_OW 1
52102: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52103: LD_ADDR_EXP 87
52107: PUSH
52108: LD_EXP 87
52112: PPUSH
52113: LD_VAR 0 1
52117: PPUSH
52118: EMPTY
52119: PPUSH
52120: CALL_OW 1
52124: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52125: LD_ADDR_EXP 88
52129: PUSH
52130: LD_EXP 88
52134: PPUSH
52135: LD_VAR 0 1
52139: PPUSH
52140: EMPTY
52141: PPUSH
52142: CALL_OW 1
52146: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52147: LD_ADDR_EXP 89
52151: PUSH
52152: LD_EXP 89
52156: PPUSH
52157: LD_VAR 0 1
52161: PPUSH
52162: EMPTY
52163: PPUSH
52164: CALL_OW 1
52168: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52169: LD_ADDR_EXP 90
52173: PUSH
52174: LD_EXP 90
52178: PPUSH
52179: LD_VAR 0 1
52183: PPUSH
52184: EMPTY
52185: PPUSH
52186: CALL_OW 1
52190: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52191: LD_ADDR_EXP 91
52195: PUSH
52196: LD_EXP 91
52200: PPUSH
52201: LD_VAR 0 1
52205: PPUSH
52206: EMPTY
52207: PPUSH
52208: CALL_OW 1
52212: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52213: LD_ADDR_EXP 93
52217: PUSH
52218: LD_EXP 93
52222: PPUSH
52223: LD_VAR 0 1
52227: PPUSH
52228: EMPTY
52229: PPUSH
52230: CALL_OW 1
52234: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52235: LD_ADDR_EXP 95
52239: PUSH
52240: LD_EXP 95
52244: PPUSH
52245: LD_VAR 0 1
52249: PPUSH
52250: EMPTY
52251: PPUSH
52252: CALL_OW 1
52256: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52257: LD_ADDR_EXP 96
52261: PUSH
52262: LD_EXP 96
52266: PPUSH
52267: LD_VAR 0 1
52271: PPUSH
52272: EMPTY
52273: PPUSH
52274: CALL_OW 1
52278: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52279: LD_ADDR_EXP 97
52283: PUSH
52284: LD_EXP 97
52288: PPUSH
52289: LD_VAR 0 1
52293: PPUSH
52294: EMPTY
52295: PPUSH
52296: CALL_OW 1
52300: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52301: LD_ADDR_EXP 98
52305: PUSH
52306: LD_EXP 98
52310: PPUSH
52311: LD_VAR 0 1
52315: PPUSH
52316: EMPTY
52317: PPUSH
52318: CALL_OW 1
52322: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52323: LD_ADDR_EXP 99
52327: PUSH
52328: LD_EXP 99
52332: PPUSH
52333: LD_VAR 0 1
52337: PPUSH
52338: EMPTY
52339: PPUSH
52340: CALL_OW 1
52344: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52345: LD_ADDR_EXP 100
52349: PUSH
52350: LD_EXP 100
52354: PPUSH
52355: LD_VAR 0 1
52359: PPUSH
52360: EMPTY
52361: PPUSH
52362: CALL_OW 1
52366: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52367: LD_ADDR_EXP 101
52371: PUSH
52372: LD_EXP 101
52376: PPUSH
52377: LD_VAR 0 1
52381: PPUSH
52382: EMPTY
52383: PPUSH
52384: CALL_OW 1
52388: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52389: LD_ADDR_EXP 102
52393: PUSH
52394: LD_EXP 102
52398: PPUSH
52399: LD_VAR 0 1
52403: PPUSH
52404: EMPTY
52405: PPUSH
52406: CALL_OW 1
52410: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52411: LD_ADDR_EXP 103
52415: PUSH
52416: LD_EXP 103
52420: PPUSH
52421: LD_VAR 0 1
52425: PPUSH
52426: EMPTY
52427: PPUSH
52428: CALL_OW 1
52432: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52433: LD_ADDR_EXP 104
52437: PUSH
52438: LD_EXP 104
52442: PPUSH
52443: LD_VAR 0 1
52447: PPUSH
52448: EMPTY
52449: PPUSH
52450: CALL_OW 1
52454: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52455: LD_ADDR_EXP 105
52459: PUSH
52460: LD_EXP 105
52464: PPUSH
52465: LD_VAR 0 1
52469: PPUSH
52470: EMPTY
52471: PPUSH
52472: CALL_OW 1
52476: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52477: LD_ADDR_EXP 106
52481: PUSH
52482: LD_EXP 106
52486: PPUSH
52487: LD_VAR 0 1
52491: PPUSH
52492: EMPTY
52493: PPUSH
52494: CALL_OW 1
52498: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52499: LD_ADDR_EXP 107
52503: PUSH
52504: LD_EXP 107
52508: PPUSH
52509: LD_VAR 0 1
52513: PPUSH
52514: EMPTY
52515: PPUSH
52516: CALL_OW 1
52520: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52521: LD_ADDR_EXP 108
52525: PUSH
52526: LD_EXP 108
52530: PPUSH
52531: LD_VAR 0 1
52535: PPUSH
52536: LD_INT 0
52538: PPUSH
52539: CALL_OW 1
52543: ST_TO_ADDR
// end ;
52544: LD_VAR 0 2
52548: RET
// export function MC_Add ( side , units ) ; var base ; begin
52549: LD_INT 0
52551: PPUSH
52552: PPUSH
// base := mc_bases + 1 ;
52553: LD_ADDR_VAR 0 4
52557: PUSH
52558: LD_EXP 66
52562: PUSH
52563: LD_INT 1
52565: PLUS
52566: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52567: LD_ADDR_EXP 92
52571: PUSH
52572: LD_EXP 92
52576: PPUSH
52577: LD_VAR 0 4
52581: PPUSH
52582: LD_VAR 0 1
52586: PPUSH
52587: CALL_OW 1
52591: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52592: LD_ADDR_EXP 66
52596: PUSH
52597: LD_EXP 66
52601: PPUSH
52602: LD_VAR 0 4
52606: PPUSH
52607: LD_VAR 0 2
52611: PPUSH
52612: CALL_OW 1
52616: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52617: LD_ADDR_EXP 67
52621: PUSH
52622: LD_EXP 67
52626: PPUSH
52627: LD_VAR 0 4
52631: PPUSH
52632: EMPTY
52633: PPUSH
52634: CALL_OW 1
52638: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52639: LD_ADDR_EXP 68
52643: PUSH
52644: LD_EXP 68
52648: PPUSH
52649: LD_VAR 0 4
52653: PPUSH
52654: EMPTY
52655: PPUSH
52656: CALL_OW 1
52660: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52661: LD_ADDR_EXP 69
52665: PUSH
52666: LD_EXP 69
52670: PPUSH
52671: LD_VAR 0 4
52675: PPUSH
52676: EMPTY
52677: PPUSH
52678: CALL_OW 1
52682: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52683: LD_ADDR_EXP 70
52687: PUSH
52688: LD_EXP 70
52692: PPUSH
52693: LD_VAR 0 4
52697: PPUSH
52698: EMPTY
52699: PPUSH
52700: CALL_OW 1
52704: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52705: LD_ADDR_EXP 71
52709: PUSH
52710: LD_EXP 71
52714: PPUSH
52715: LD_VAR 0 4
52719: PPUSH
52720: EMPTY
52721: PPUSH
52722: CALL_OW 1
52726: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52727: LD_ADDR_EXP 72
52731: PUSH
52732: LD_EXP 72
52736: PPUSH
52737: LD_VAR 0 4
52741: PPUSH
52742: EMPTY
52743: PPUSH
52744: CALL_OW 1
52748: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52749: LD_ADDR_EXP 73
52753: PUSH
52754: LD_EXP 73
52758: PPUSH
52759: LD_VAR 0 4
52763: PPUSH
52764: EMPTY
52765: PPUSH
52766: CALL_OW 1
52770: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52771: LD_ADDR_EXP 74
52775: PUSH
52776: LD_EXP 74
52780: PPUSH
52781: LD_VAR 0 4
52785: PPUSH
52786: EMPTY
52787: PPUSH
52788: CALL_OW 1
52792: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52793: LD_ADDR_EXP 75
52797: PUSH
52798: LD_EXP 75
52802: PPUSH
52803: LD_VAR 0 4
52807: PPUSH
52808: EMPTY
52809: PPUSH
52810: CALL_OW 1
52814: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52815: LD_ADDR_EXP 76
52819: PUSH
52820: LD_EXP 76
52824: PPUSH
52825: LD_VAR 0 4
52829: PPUSH
52830: EMPTY
52831: PPUSH
52832: CALL_OW 1
52836: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52837: LD_ADDR_EXP 77
52841: PUSH
52842: LD_EXP 77
52846: PPUSH
52847: LD_VAR 0 4
52851: PPUSH
52852: LD_INT 0
52854: PPUSH
52855: CALL_OW 1
52859: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52860: LD_ADDR_EXP 78
52864: PUSH
52865: LD_EXP 78
52869: PPUSH
52870: LD_VAR 0 4
52874: PPUSH
52875: EMPTY
52876: PPUSH
52877: CALL_OW 1
52881: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52882: LD_ADDR_EXP 79
52886: PUSH
52887: LD_EXP 79
52891: PPUSH
52892: LD_VAR 0 4
52896: PPUSH
52897: EMPTY
52898: PPUSH
52899: CALL_OW 1
52903: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52904: LD_ADDR_EXP 80
52908: PUSH
52909: LD_EXP 80
52913: PPUSH
52914: LD_VAR 0 4
52918: PPUSH
52919: EMPTY
52920: PPUSH
52921: CALL_OW 1
52925: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52926: LD_ADDR_EXP 81
52930: PUSH
52931: LD_EXP 81
52935: PPUSH
52936: LD_VAR 0 4
52940: PPUSH
52941: EMPTY
52942: PPUSH
52943: CALL_OW 1
52947: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52948: LD_ADDR_EXP 82
52952: PUSH
52953: LD_EXP 82
52957: PPUSH
52958: LD_VAR 0 4
52962: PPUSH
52963: EMPTY
52964: PPUSH
52965: CALL_OW 1
52969: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52970: LD_ADDR_EXP 83
52974: PUSH
52975: LD_EXP 83
52979: PPUSH
52980: LD_VAR 0 4
52984: PPUSH
52985: EMPTY
52986: PPUSH
52987: CALL_OW 1
52991: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52992: LD_ADDR_EXP 84
52996: PUSH
52997: LD_EXP 84
53001: PPUSH
53002: LD_VAR 0 4
53006: PPUSH
53007: EMPTY
53008: PPUSH
53009: CALL_OW 1
53013: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53014: LD_ADDR_EXP 85
53018: PUSH
53019: LD_EXP 85
53023: PPUSH
53024: LD_VAR 0 4
53028: PPUSH
53029: EMPTY
53030: PPUSH
53031: CALL_OW 1
53035: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53036: LD_ADDR_EXP 86
53040: PUSH
53041: LD_EXP 86
53045: PPUSH
53046: LD_VAR 0 4
53050: PPUSH
53051: EMPTY
53052: PPUSH
53053: CALL_OW 1
53057: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53058: LD_ADDR_EXP 87
53062: PUSH
53063: LD_EXP 87
53067: PPUSH
53068: LD_VAR 0 4
53072: PPUSH
53073: EMPTY
53074: PPUSH
53075: CALL_OW 1
53079: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53080: LD_ADDR_EXP 88
53084: PUSH
53085: LD_EXP 88
53089: PPUSH
53090: LD_VAR 0 4
53094: PPUSH
53095: EMPTY
53096: PPUSH
53097: CALL_OW 1
53101: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53102: LD_ADDR_EXP 89
53106: PUSH
53107: LD_EXP 89
53111: PPUSH
53112: LD_VAR 0 4
53116: PPUSH
53117: EMPTY
53118: PPUSH
53119: CALL_OW 1
53123: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53124: LD_ADDR_EXP 90
53128: PUSH
53129: LD_EXP 90
53133: PPUSH
53134: LD_VAR 0 4
53138: PPUSH
53139: EMPTY
53140: PPUSH
53141: CALL_OW 1
53145: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53146: LD_ADDR_EXP 91
53150: PUSH
53151: LD_EXP 91
53155: PPUSH
53156: LD_VAR 0 4
53160: PPUSH
53161: EMPTY
53162: PPUSH
53163: CALL_OW 1
53167: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53168: LD_ADDR_EXP 93
53172: PUSH
53173: LD_EXP 93
53177: PPUSH
53178: LD_VAR 0 4
53182: PPUSH
53183: EMPTY
53184: PPUSH
53185: CALL_OW 1
53189: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53190: LD_ADDR_EXP 95
53194: PUSH
53195: LD_EXP 95
53199: PPUSH
53200: LD_VAR 0 4
53204: PPUSH
53205: EMPTY
53206: PPUSH
53207: CALL_OW 1
53211: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53212: LD_ADDR_EXP 96
53216: PUSH
53217: LD_EXP 96
53221: PPUSH
53222: LD_VAR 0 4
53226: PPUSH
53227: EMPTY
53228: PPUSH
53229: CALL_OW 1
53233: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53234: LD_ADDR_EXP 97
53238: PUSH
53239: LD_EXP 97
53243: PPUSH
53244: LD_VAR 0 4
53248: PPUSH
53249: EMPTY
53250: PPUSH
53251: CALL_OW 1
53255: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53256: LD_ADDR_EXP 98
53260: PUSH
53261: LD_EXP 98
53265: PPUSH
53266: LD_VAR 0 4
53270: PPUSH
53271: EMPTY
53272: PPUSH
53273: CALL_OW 1
53277: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53278: LD_ADDR_EXP 99
53282: PUSH
53283: LD_EXP 99
53287: PPUSH
53288: LD_VAR 0 4
53292: PPUSH
53293: EMPTY
53294: PPUSH
53295: CALL_OW 1
53299: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53300: LD_ADDR_EXP 100
53304: PUSH
53305: LD_EXP 100
53309: PPUSH
53310: LD_VAR 0 4
53314: PPUSH
53315: EMPTY
53316: PPUSH
53317: CALL_OW 1
53321: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53322: LD_ADDR_EXP 101
53326: PUSH
53327: LD_EXP 101
53331: PPUSH
53332: LD_VAR 0 4
53336: PPUSH
53337: EMPTY
53338: PPUSH
53339: CALL_OW 1
53343: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53344: LD_ADDR_EXP 102
53348: PUSH
53349: LD_EXP 102
53353: PPUSH
53354: LD_VAR 0 4
53358: PPUSH
53359: EMPTY
53360: PPUSH
53361: CALL_OW 1
53365: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53366: LD_ADDR_EXP 103
53370: PUSH
53371: LD_EXP 103
53375: PPUSH
53376: LD_VAR 0 4
53380: PPUSH
53381: EMPTY
53382: PPUSH
53383: CALL_OW 1
53387: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53388: LD_ADDR_EXP 104
53392: PUSH
53393: LD_EXP 104
53397: PPUSH
53398: LD_VAR 0 4
53402: PPUSH
53403: EMPTY
53404: PPUSH
53405: CALL_OW 1
53409: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53410: LD_ADDR_EXP 105
53414: PUSH
53415: LD_EXP 105
53419: PPUSH
53420: LD_VAR 0 4
53424: PPUSH
53425: EMPTY
53426: PPUSH
53427: CALL_OW 1
53431: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53432: LD_ADDR_EXP 106
53436: PUSH
53437: LD_EXP 106
53441: PPUSH
53442: LD_VAR 0 4
53446: PPUSH
53447: EMPTY
53448: PPUSH
53449: CALL_OW 1
53453: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53454: LD_ADDR_EXP 107
53458: PUSH
53459: LD_EXP 107
53463: PPUSH
53464: LD_VAR 0 4
53468: PPUSH
53469: EMPTY
53470: PPUSH
53471: CALL_OW 1
53475: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53476: LD_ADDR_EXP 108
53480: PUSH
53481: LD_EXP 108
53485: PPUSH
53486: LD_VAR 0 4
53490: PPUSH
53491: LD_INT 0
53493: PPUSH
53494: CALL_OW 1
53498: ST_TO_ADDR
// result := base ;
53499: LD_ADDR_VAR 0 3
53503: PUSH
53504: LD_VAR 0 4
53508: ST_TO_ADDR
// end ;
53509: LD_VAR 0 3
53513: RET
// export function MC_Start ( ) ; var i ; begin
53514: LD_INT 0
53516: PPUSH
53517: PPUSH
// for i = 1 to mc_bases do
53518: LD_ADDR_VAR 0 2
53522: PUSH
53523: DOUBLE
53524: LD_INT 1
53526: DEC
53527: ST_TO_ADDR
53528: LD_EXP 66
53532: PUSH
53533: FOR_TO
53534: IFFALSE 54611
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53536: LD_ADDR_EXP 66
53540: PUSH
53541: LD_EXP 66
53545: PPUSH
53546: LD_VAR 0 2
53550: PPUSH
53551: LD_EXP 66
53555: PUSH
53556: LD_VAR 0 2
53560: ARRAY
53561: PUSH
53562: LD_INT 0
53564: DIFF
53565: PPUSH
53566: CALL_OW 1
53570: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53571: LD_ADDR_EXP 67
53575: PUSH
53576: LD_EXP 67
53580: PPUSH
53581: LD_VAR 0 2
53585: PPUSH
53586: EMPTY
53587: PPUSH
53588: CALL_OW 1
53592: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53593: LD_ADDR_EXP 68
53597: PUSH
53598: LD_EXP 68
53602: PPUSH
53603: LD_VAR 0 2
53607: PPUSH
53608: EMPTY
53609: PPUSH
53610: CALL_OW 1
53614: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53615: LD_ADDR_EXP 69
53619: PUSH
53620: LD_EXP 69
53624: PPUSH
53625: LD_VAR 0 2
53629: PPUSH
53630: EMPTY
53631: PPUSH
53632: CALL_OW 1
53636: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53637: LD_ADDR_EXP 70
53641: PUSH
53642: LD_EXP 70
53646: PPUSH
53647: LD_VAR 0 2
53651: PPUSH
53652: EMPTY
53653: PUSH
53654: EMPTY
53655: PUSH
53656: EMPTY
53657: LIST
53658: LIST
53659: PPUSH
53660: CALL_OW 1
53664: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53665: LD_ADDR_EXP 71
53669: PUSH
53670: LD_EXP 71
53674: PPUSH
53675: LD_VAR 0 2
53679: PPUSH
53680: EMPTY
53681: PPUSH
53682: CALL_OW 1
53686: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53687: LD_ADDR_EXP 98
53691: PUSH
53692: LD_EXP 98
53696: PPUSH
53697: LD_VAR 0 2
53701: PPUSH
53702: EMPTY
53703: PPUSH
53704: CALL_OW 1
53708: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53709: LD_ADDR_EXP 72
53713: PUSH
53714: LD_EXP 72
53718: PPUSH
53719: LD_VAR 0 2
53723: PPUSH
53724: EMPTY
53725: PPUSH
53726: CALL_OW 1
53730: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53731: LD_ADDR_EXP 73
53735: PUSH
53736: LD_EXP 73
53740: PPUSH
53741: LD_VAR 0 2
53745: PPUSH
53746: EMPTY
53747: PPUSH
53748: CALL_OW 1
53752: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53753: LD_ADDR_EXP 74
53757: PUSH
53758: LD_EXP 74
53762: PPUSH
53763: LD_VAR 0 2
53767: PPUSH
53768: LD_EXP 66
53772: PUSH
53773: LD_VAR 0 2
53777: ARRAY
53778: PPUSH
53779: LD_INT 2
53781: PUSH
53782: LD_INT 30
53784: PUSH
53785: LD_INT 32
53787: PUSH
53788: EMPTY
53789: LIST
53790: LIST
53791: PUSH
53792: LD_INT 30
53794: PUSH
53795: LD_INT 33
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: LIST
53806: PPUSH
53807: CALL_OW 72
53811: PPUSH
53812: CALL_OW 1
53816: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53817: LD_ADDR_EXP 75
53821: PUSH
53822: LD_EXP 75
53826: PPUSH
53827: LD_VAR 0 2
53831: PPUSH
53832: LD_EXP 66
53836: PUSH
53837: LD_VAR 0 2
53841: ARRAY
53842: PPUSH
53843: LD_INT 2
53845: PUSH
53846: LD_INT 30
53848: PUSH
53849: LD_INT 32
53851: PUSH
53852: EMPTY
53853: LIST
53854: LIST
53855: PUSH
53856: LD_INT 30
53858: PUSH
53859: LD_INT 31
53861: PUSH
53862: EMPTY
53863: LIST
53864: LIST
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: LIST
53870: PUSH
53871: LD_INT 58
53873: PUSH
53874: EMPTY
53875: LIST
53876: PUSH
53877: EMPTY
53878: LIST
53879: LIST
53880: PPUSH
53881: CALL_OW 72
53885: PPUSH
53886: CALL_OW 1
53890: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53891: LD_ADDR_EXP 76
53895: PUSH
53896: LD_EXP 76
53900: PPUSH
53901: LD_VAR 0 2
53905: PPUSH
53906: EMPTY
53907: PPUSH
53908: CALL_OW 1
53912: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53913: LD_ADDR_EXP 80
53917: PUSH
53918: LD_EXP 80
53922: PPUSH
53923: LD_VAR 0 2
53927: PPUSH
53928: EMPTY
53929: PPUSH
53930: CALL_OW 1
53934: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53935: LD_ADDR_EXP 79
53939: PUSH
53940: LD_EXP 79
53944: PPUSH
53945: LD_VAR 0 2
53949: PPUSH
53950: EMPTY
53951: PPUSH
53952: CALL_OW 1
53956: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53957: LD_ADDR_EXP 81
53961: PUSH
53962: LD_EXP 81
53966: PPUSH
53967: LD_VAR 0 2
53971: PPUSH
53972: EMPTY
53973: PPUSH
53974: CALL_OW 1
53978: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53979: LD_ADDR_EXP 82
53983: PUSH
53984: LD_EXP 82
53988: PPUSH
53989: LD_VAR 0 2
53993: PPUSH
53994: EMPTY
53995: PPUSH
53996: CALL_OW 1
54000: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54001: LD_ADDR_EXP 83
54005: PUSH
54006: LD_EXP 83
54010: PPUSH
54011: LD_VAR 0 2
54015: PPUSH
54016: EMPTY
54017: PPUSH
54018: CALL_OW 1
54022: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54023: LD_ADDR_EXP 84
54027: PUSH
54028: LD_EXP 84
54032: PPUSH
54033: LD_VAR 0 2
54037: PPUSH
54038: EMPTY
54039: PPUSH
54040: CALL_OW 1
54044: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54045: LD_ADDR_EXP 85
54049: PUSH
54050: LD_EXP 85
54054: PPUSH
54055: LD_VAR 0 2
54059: PPUSH
54060: EMPTY
54061: PPUSH
54062: CALL_OW 1
54066: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54067: LD_ADDR_EXP 86
54071: PUSH
54072: LD_EXP 86
54076: PPUSH
54077: LD_VAR 0 2
54081: PPUSH
54082: EMPTY
54083: PPUSH
54084: CALL_OW 1
54088: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54089: LD_ADDR_EXP 87
54093: PUSH
54094: LD_EXP 87
54098: PPUSH
54099: LD_VAR 0 2
54103: PPUSH
54104: EMPTY
54105: PPUSH
54106: CALL_OW 1
54110: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54111: LD_ADDR_EXP 88
54115: PUSH
54116: LD_EXP 88
54120: PPUSH
54121: LD_VAR 0 2
54125: PPUSH
54126: EMPTY
54127: PPUSH
54128: CALL_OW 1
54132: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54133: LD_ADDR_EXP 77
54137: PUSH
54138: LD_EXP 77
54142: PPUSH
54143: LD_VAR 0 2
54147: PPUSH
54148: LD_INT 0
54150: PPUSH
54151: CALL_OW 1
54155: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54156: LD_ADDR_EXP 90
54160: PUSH
54161: LD_EXP 90
54165: PPUSH
54166: LD_VAR 0 2
54170: PPUSH
54171: LD_INT 0
54173: PPUSH
54174: CALL_OW 1
54178: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54179: LD_ADDR_EXP 78
54183: PUSH
54184: LD_EXP 78
54188: PPUSH
54189: LD_VAR 0 2
54193: PPUSH
54194: EMPTY
54195: PPUSH
54196: CALL_OW 1
54200: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54201: LD_ADDR_EXP 89
54205: PUSH
54206: LD_EXP 89
54210: PPUSH
54211: LD_VAR 0 2
54215: PPUSH
54216: LD_INT 0
54218: PPUSH
54219: CALL_OW 1
54223: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54224: LD_ADDR_EXP 91
54228: PUSH
54229: LD_EXP 91
54233: PPUSH
54234: LD_VAR 0 2
54238: PPUSH
54239: EMPTY
54240: PPUSH
54241: CALL_OW 1
54245: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54246: LD_ADDR_EXP 94
54250: PUSH
54251: LD_EXP 94
54255: PPUSH
54256: LD_VAR 0 2
54260: PPUSH
54261: LD_INT 0
54263: PPUSH
54264: CALL_OW 1
54268: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54269: LD_ADDR_EXP 95
54273: PUSH
54274: LD_EXP 95
54278: PPUSH
54279: LD_VAR 0 2
54283: PPUSH
54284: EMPTY
54285: PPUSH
54286: CALL_OW 1
54290: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54291: LD_ADDR_EXP 96
54295: PUSH
54296: LD_EXP 96
54300: PPUSH
54301: LD_VAR 0 2
54305: PPUSH
54306: EMPTY
54307: PPUSH
54308: CALL_OW 1
54312: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54313: LD_ADDR_EXP 97
54317: PUSH
54318: LD_EXP 97
54322: PPUSH
54323: LD_VAR 0 2
54327: PPUSH
54328: EMPTY
54329: PPUSH
54330: CALL_OW 1
54334: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54335: LD_ADDR_EXP 99
54339: PUSH
54340: LD_EXP 99
54344: PPUSH
54345: LD_VAR 0 2
54349: PPUSH
54350: LD_EXP 66
54354: PUSH
54355: LD_VAR 0 2
54359: ARRAY
54360: PPUSH
54361: LD_INT 2
54363: PUSH
54364: LD_INT 30
54366: PUSH
54367: LD_INT 6
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PUSH
54374: LD_INT 30
54376: PUSH
54377: LD_INT 7
54379: PUSH
54380: EMPTY
54381: LIST
54382: LIST
54383: PUSH
54384: LD_INT 30
54386: PUSH
54387: LD_INT 8
54389: PUSH
54390: EMPTY
54391: LIST
54392: LIST
54393: PUSH
54394: EMPTY
54395: LIST
54396: LIST
54397: LIST
54398: LIST
54399: PPUSH
54400: CALL_OW 72
54404: PPUSH
54405: CALL_OW 1
54409: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54410: LD_ADDR_EXP 100
54414: PUSH
54415: LD_EXP 100
54419: PPUSH
54420: LD_VAR 0 2
54424: PPUSH
54425: EMPTY
54426: PPUSH
54427: CALL_OW 1
54431: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54432: LD_ADDR_EXP 101
54436: PUSH
54437: LD_EXP 101
54441: PPUSH
54442: LD_VAR 0 2
54446: PPUSH
54447: EMPTY
54448: PPUSH
54449: CALL_OW 1
54453: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54454: LD_ADDR_EXP 102
54458: PUSH
54459: LD_EXP 102
54463: PPUSH
54464: LD_VAR 0 2
54468: PPUSH
54469: EMPTY
54470: PPUSH
54471: CALL_OW 1
54475: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54476: LD_ADDR_EXP 103
54480: PUSH
54481: LD_EXP 103
54485: PPUSH
54486: LD_VAR 0 2
54490: PPUSH
54491: EMPTY
54492: PPUSH
54493: CALL_OW 1
54497: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54498: LD_ADDR_EXP 104
54502: PUSH
54503: LD_EXP 104
54507: PPUSH
54508: LD_VAR 0 2
54512: PPUSH
54513: EMPTY
54514: PPUSH
54515: CALL_OW 1
54519: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54520: LD_ADDR_EXP 105
54524: PUSH
54525: LD_EXP 105
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: EMPTY
54536: PPUSH
54537: CALL_OW 1
54541: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54542: LD_ADDR_EXP 106
54546: PUSH
54547: LD_EXP 106
54551: PPUSH
54552: LD_VAR 0 2
54556: PPUSH
54557: EMPTY
54558: PPUSH
54559: CALL_OW 1
54563: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54564: LD_ADDR_EXP 107
54568: PUSH
54569: LD_EXP 107
54573: PPUSH
54574: LD_VAR 0 2
54578: PPUSH
54579: EMPTY
54580: PPUSH
54581: CALL_OW 1
54585: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54586: LD_ADDR_EXP 108
54590: PUSH
54591: LD_EXP 108
54595: PPUSH
54596: LD_VAR 0 2
54600: PPUSH
54601: LD_INT 0
54603: PPUSH
54604: CALL_OW 1
54608: ST_TO_ADDR
// end ;
54609: GO 53533
54611: POP
54612: POP
// MC_InitSides ( ) ;
54613: CALL 54899 0 0
// MC_InitResearch ( ) ;
54617: CALL 54638 0 0
// CustomInitMacro ( ) ;
54621: CALL 5753 0 0
// skirmish := true ;
54625: LD_ADDR_EXP 64
54629: PUSH
54630: LD_INT 1
54632: ST_TO_ADDR
// end ;
54633: LD_VAR 0 1
54637: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54638: LD_INT 0
54640: PPUSH
54641: PPUSH
54642: PPUSH
54643: PPUSH
54644: PPUSH
54645: PPUSH
// if not mc_bases then
54646: LD_EXP 66
54650: NOT
54651: IFFALSE 54655
// exit ;
54653: GO 54894
// for i = 1 to 8 do
54655: LD_ADDR_VAR 0 2
54659: PUSH
54660: DOUBLE
54661: LD_INT 1
54663: DEC
54664: ST_TO_ADDR
54665: LD_INT 8
54667: PUSH
54668: FOR_TO
54669: IFFALSE 54695
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54671: LD_ADDR_EXP 93
54675: PUSH
54676: LD_EXP 93
54680: PPUSH
54681: LD_VAR 0 2
54685: PPUSH
54686: EMPTY
54687: PPUSH
54688: CALL_OW 1
54692: ST_TO_ADDR
54693: GO 54668
54695: POP
54696: POP
// tmp := [ ] ;
54697: LD_ADDR_VAR 0 5
54701: PUSH
54702: EMPTY
54703: ST_TO_ADDR
// for i = 1 to mc_sides do
54704: LD_ADDR_VAR 0 2
54708: PUSH
54709: DOUBLE
54710: LD_INT 1
54712: DEC
54713: ST_TO_ADDR
54714: LD_EXP 92
54718: PUSH
54719: FOR_TO
54720: IFFALSE 54778
// if not mc_sides [ i ] in tmp then
54722: LD_EXP 92
54726: PUSH
54727: LD_VAR 0 2
54731: ARRAY
54732: PUSH
54733: LD_VAR 0 5
54737: IN
54738: NOT
54739: IFFALSE 54776
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54741: LD_ADDR_VAR 0 5
54745: PUSH
54746: LD_VAR 0 5
54750: PPUSH
54751: LD_VAR 0 5
54755: PUSH
54756: LD_INT 1
54758: PLUS
54759: PPUSH
54760: LD_EXP 92
54764: PUSH
54765: LD_VAR 0 2
54769: ARRAY
54770: PPUSH
54771: CALL_OW 2
54775: ST_TO_ADDR
54776: GO 54719
54778: POP
54779: POP
// if not tmp then
54780: LD_VAR 0 5
54784: NOT
54785: IFFALSE 54789
// exit ;
54787: GO 54894
// for j in tmp do
54789: LD_ADDR_VAR 0 3
54793: PUSH
54794: LD_VAR 0 5
54798: PUSH
54799: FOR_IN
54800: IFFALSE 54892
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54802: LD_ADDR_VAR 0 6
54806: PUSH
54807: LD_INT 22
54809: PUSH
54810: LD_VAR 0 3
54814: PUSH
54815: EMPTY
54816: LIST
54817: LIST
54818: PPUSH
54819: CALL_OW 69
54823: ST_TO_ADDR
// if not un then
54824: LD_VAR 0 6
54828: NOT
54829: IFFALSE 54833
// continue ;
54831: GO 54799
// nation := GetNation ( un [ 1 ] ) ;
54833: LD_ADDR_VAR 0 4
54837: PUSH
54838: LD_VAR 0 6
54842: PUSH
54843: LD_INT 1
54845: ARRAY
54846: PPUSH
54847: CALL_OW 248
54851: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54852: LD_ADDR_EXP 93
54856: PUSH
54857: LD_EXP 93
54861: PPUSH
54862: LD_VAR 0 3
54866: PPUSH
54867: LD_VAR 0 3
54871: PPUSH
54872: LD_VAR 0 4
54876: PPUSH
54877: LD_INT 1
54879: PPUSH
54880: CALL 13665 0 3
54884: PPUSH
54885: CALL_OW 1
54889: ST_TO_ADDR
// end ;
54890: GO 54799
54892: POP
54893: POP
// end ;
54894: LD_VAR 0 1
54898: RET
// export function MC_InitSides ( ) ; var i ; begin
54899: LD_INT 0
54901: PPUSH
54902: PPUSH
// if not mc_bases then
54903: LD_EXP 66
54907: NOT
54908: IFFALSE 54912
// exit ;
54910: GO 54986
// for i = 1 to mc_bases do
54912: LD_ADDR_VAR 0 2
54916: PUSH
54917: DOUBLE
54918: LD_INT 1
54920: DEC
54921: ST_TO_ADDR
54922: LD_EXP 66
54926: PUSH
54927: FOR_TO
54928: IFFALSE 54984
// if mc_bases [ i ] then
54930: LD_EXP 66
54934: PUSH
54935: LD_VAR 0 2
54939: ARRAY
54940: IFFALSE 54982
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54942: LD_ADDR_EXP 92
54946: PUSH
54947: LD_EXP 92
54951: PPUSH
54952: LD_VAR 0 2
54956: PPUSH
54957: LD_EXP 66
54961: PUSH
54962: LD_VAR 0 2
54966: ARRAY
54967: PUSH
54968: LD_INT 1
54970: ARRAY
54971: PPUSH
54972: CALL_OW 255
54976: PPUSH
54977: CALL_OW 1
54981: ST_TO_ADDR
54982: GO 54927
54984: POP
54985: POP
// end ;
54986: LD_VAR 0 1
54990: RET
// every 0 0$03 trigger skirmish do
54991: LD_EXP 64
54995: IFFALSE 55149
54997: GO 54999
54999: DISABLE
// begin enable ;
55000: ENABLE
// MC_CheckBuildings ( ) ;
55001: CALL 59647 0 0
// MC_CheckPeopleLife ( ) ;
55005: CALL 59772 0 0
// RaiseSailEvent ( 100 ) ;
55009: LD_INT 100
55011: PPUSH
55012: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55016: LD_INT 103
55018: PPUSH
55019: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55023: LD_INT 104
55025: PPUSH
55026: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55030: LD_INT 105
55032: PPUSH
55033: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55037: LD_INT 106
55039: PPUSH
55040: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55044: LD_INT 107
55046: PPUSH
55047: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55051: LD_INT 108
55053: PPUSH
55054: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55058: LD_INT 109
55060: PPUSH
55061: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55065: LD_INT 110
55067: PPUSH
55068: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55072: LD_INT 111
55074: PPUSH
55075: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55079: LD_INT 112
55081: PPUSH
55082: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55086: LD_INT 113
55088: PPUSH
55089: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55093: LD_INT 120
55095: PPUSH
55096: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55100: LD_INT 121
55102: PPUSH
55103: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55107: LD_INT 122
55109: PPUSH
55110: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55114: LD_INT 123
55116: PPUSH
55117: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55121: LD_INT 124
55123: PPUSH
55124: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55128: LD_INT 125
55130: PPUSH
55131: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55135: LD_INT 126
55137: PPUSH
55138: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55142: LD_INT 200
55144: PPUSH
55145: CALL_OW 427
// end ;
55149: END
// on SailEvent ( event ) do begin if event < 100 then
55150: LD_VAR 0 1
55154: PUSH
55155: LD_INT 100
55157: LESS
55158: IFFALSE 55169
// CustomEvent ( event ) ;
55160: LD_VAR 0 1
55164: PPUSH
55165: CALL 5745 0 1
// if event = 100 then
55169: LD_VAR 0 1
55173: PUSH
55174: LD_INT 100
55176: EQUAL
55177: IFFALSE 55183
// MC_ClassManager ( ) ;
55179: CALL 55575 0 0
// if event = 101 then
55183: LD_VAR 0 1
55187: PUSH
55188: LD_INT 101
55190: EQUAL
55191: IFFALSE 55197
// MC_RepairBuildings ( ) ;
55193: CALL 60357 0 0
// if event = 102 then
55197: LD_VAR 0 1
55201: PUSH
55202: LD_INT 102
55204: EQUAL
55205: IFFALSE 55211
// MC_Heal ( ) ;
55207: CALL 61242 0 0
// if event = 103 then
55211: LD_VAR 0 1
55215: PUSH
55216: LD_INT 103
55218: EQUAL
55219: IFFALSE 55225
// MC_Build ( ) ;
55221: CALL 61664 0 0
// if event = 104 then
55225: LD_VAR 0 1
55229: PUSH
55230: LD_INT 104
55232: EQUAL
55233: IFFALSE 55239
// MC_TurretWeapon ( ) ;
55235: CALL 63305 0 0
// if event = 105 then
55239: LD_VAR 0 1
55243: PUSH
55244: LD_INT 105
55246: EQUAL
55247: IFFALSE 55253
// MC_BuildUpgrade ( ) ;
55249: CALL 62856 0 0
// if event = 106 then
55253: LD_VAR 0 1
55257: PUSH
55258: LD_INT 106
55260: EQUAL
55261: IFFALSE 55267
// MC_PlantMines ( ) ;
55263: CALL 63735 0 0
// if event = 107 then
55267: LD_VAR 0 1
55271: PUSH
55272: LD_INT 107
55274: EQUAL
55275: IFFALSE 55281
// MC_CollectCrates ( ) ;
55277: CALL 64526 0 0
// if event = 108 then
55281: LD_VAR 0 1
55285: PUSH
55286: LD_INT 108
55288: EQUAL
55289: IFFALSE 55295
// MC_LinkRemoteControl ( ) ;
55291: CALL 66302 0 0
// if event = 109 then
55295: LD_VAR 0 1
55299: PUSH
55300: LD_INT 109
55302: EQUAL
55303: IFFALSE 55309
// MC_ProduceVehicle ( ) ;
55305: CALL 66483 0 0
// if event = 110 then
55309: LD_VAR 0 1
55313: PUSH
55314: LD_INT 110
55316: EQUAL
55317: IFFALSE 55323
// MC_SendAttack ( ) ;
55319: CALL 66949 0 0
// if event = 111 then
55323: LD_VAR 0 1
55327: PUSH
55328: LD_INT 111
55330: EQUAL
55331: IFFALSE 55337
// MC_Defend ( ) ;
55333: CALL 67057 0 0
// if event = 112 then
55337: LD_VAR 0 1
55341: PUSH
55342: LD_INT 112
55344: EQUAL
55345: IFFALSE 55351
// MC_Research ( ) ;
55347: CALL 67684 0 0
// if event = 113 then
55351: LD_VAR 0 1
55355: PUSH
55356: LD_INT 113
55358: EQUAL
55359: IFFALSE 55365
// MC_MinesTrigger ( ) ;
55361: CALL 68798 0 0
// if event = 120 then
55365: LD_VAR 0 1
55369: PUSH
55370: LD_INT 120
55372: EQUAL
55373: IFFALSE 55379
// MC_RepairVehicle ( ) ;
55375: CALL 68897 0 0
// if event = 121 then
55379: LD_VAR 0 1
55383: PUSH
55384: LD_INT 121
55386: EQUAL
55387: IFFALSE 55393
// MC_TameApe ( ) ;
55389: CALL 69627 0 0
// if event = 122 then
55393: LD_VAR 0 1
55397: PUSH
55398: LD_INT 122
55400: EQUAL
55401: IFFALSE 55407
// MC_ChangeApeClass ( ) ;
55403: CALL 70456 0 0
// if event = 123 then
55407: LD_VAR 0 1
55411: PUSH
55412: LD_INT 123
55414: EQUAL
55415: IFFALSE 55421
// MC_Bazooka ( ) ;
55417: CALL 71106 0 0
// if event = 124 then
55421: LD_VAR 0 1
55425: PUSH
55426: LD_INT 124
55428: EQUAL
55429: IFFALSE 55435
// MC_TeleportExit ( ) ;
55431: CALL 71304 0 0
// if event = 125 then
55435: LD_VAR 0 1
55439: PUSH
55440: LD_INT 125
55442: EQUAL
55443: IFFALSE 55449
// MC_Deposits ( ) ;
55445: CALL 71951 0 0
// if event = 126 then
55449: LD_VAR 0 1
55453: PUSH
55454: LD_INT 126
55456: EQUAL
55457: IFFALSE 55463
// MC_RemoteDriver ( ) ;
55459: CALL 72576 0 0
// if event = 200 then
55463: LD_VAR 0 1
55467: PUSH
55468: LD_INT 200
55470: EQUAL
55471: IFFALSE 55477
// MC_Idle ( ) ;
55473: CALL 74525 0 0
// end ;
55477: PPOPN 1
55479: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55480: LD_INT 0
55482: PPUSH
55483: PPUSH
// if not mc_bases [ base ] or not tag then
55484: LD_EXP 66
55488: PUSH
55489: LD_VAR 0 1
55493: ARRAY
55494: NOT
55495: PUSH
55496: LD_VAR 0 2
55500: NOT
55501: OR
55502: IFFALSE 55506
// exit ;
55504: GO 55570
// for i in mc_bases [ base ] union mc_ape [ base ] do
55506: LD_ADDR_VAR 0 4
55510: PUSH
55511: LD_EXP 66
55515: PUSH
55516: LD_VAR 0 1
55520: ARRAY
55521: PUSH
55522: LD_EXP 95
55526: PUSH
55527: LD_VAR 0 1
55531: ARRAY
55532: UNION
55533: PUSH
55534: FOR_IN
55535: IFFALSE 55568
// if GetTag ( i ) = tag then
55537: LD_VAR 0 4
55541: PPUSH
55542: CALL_OW 110
55546: PUSH
55547: LD_VAR 0 2
55551: EQUAL
55552: IFFALSE 55566
// SetTag ( i , 0 ) ;
55554: LD_VAR 0 4
55558: PPUSH
55559: LD_INT 0
55561: PPUSH
55562: CALL_OW 109
55566: GO 55534
55568: POP
55569: POP
// end ;
55570: LD_VAR 0 3
55574: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55575: LD_INT 0
55577: PPUSH
55578: PPUSH
55579: PPUSH
55580: PPUSH
55581: PPUSH
55582: PPUSH
55583: PPUSH
55584: PPUSH
// if not mc_bases then
55585: LD_EXP 66
55589: NOT
55590: IFFALSE 55594
// exit ;
55592: GO 56052
// for i = 1 to mc_bases do
55594: LD_ADDR_VAR 0 2
55598: PUSH
55599: DOUBLE
55600: LD_INT 1
55602: DEC
55603: ST_TO_ADDR
55604: LD_EXP 66
55608: PUSH
55609: FOR_TO
55610: IFFALSE 56050
// begin tmp := MC_ClassCheckReq ( i ) ;
55612: LD_ADDR_VAR 0 4
55616: PUSH
55617: LD_VAR 0 2
55621: PPUSH
55622: CALL 56057 0 1
55626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55627: LD_ADDR_EXP 107
55631: PUSH
55632: LD_EXP 107
55636: PPUSH
55637: LD_VAR 0 2
55641: PPUSH
55642: LD_VAR 0 4
55646: PPUSH
55647: CALL_OW 1
55651: ST_TO_ADDR
// if not tmp then
55652: LD_VAR 0 4
55656: NOT
55657: IFFALSE 55661
// continue ;
55659: GO 55609
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55661: LD_ADDR_VAR 0 6
55665: PUSH
55666: LD_EXP 66
55670: PUSH
55671: LD_VAR 0 2
55675: ARRAY
55676: PPUSH
55677: LD_INT 2
55679: PUSH
55680: LD_INT 30
55682: PUSH
55683: LD_INT 4
55685: PUSH
55686: EMPTY
55687: LIST
55688: LIST
55689: PUSH
55690: LD_INT 30
55692: PUSH
55693: LD_INT 5
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: LIST
55704: PPUSH
55705: CALL_OW 72
55709: PUSH
55710: LD_EXP 66
55714: PUSH
55715: LD_VAR 0 2
55719: ARRAY
55720: PPUSH
55721: LD_INT 2
55723: PUSH
55724: LD_INT 30
55726: PUSH
55727: LD_INT 0
55729: PUSH
55730: EMPTY
55731: LIST
55732: LIST
55733: PUSH
55734: LD_INT 30
55736: PUSH
55737: LD_INT 1
55739: PUSH
55740: EMPTY
55741: LIST
55742: LIST
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: LIST
55748: PPUSH
55749: CALL_OW 72
55753: PUSH
55754: LD_EXP 66
55758: PUSH
55759: LD_VAR 0 2
55763: ARRAY
55764: PPUSH
55765: LD_INT 30
55767: PUSH
55768: LD_INT 3
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: PPUSH
55775: CALL_OW 72
55779: PUSH
55780: LD_EXP 66
55784: PUSH
55785: LD_VAR 0 2
55789: ARRAY
55790: PPUSH
55791: LD_INT 2
55793: PUSH
55794: LD_INT 30
55796: PUSH
55797: LD_INT 6
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PUSH
55804: LD_INT 30
55806: PUSH
55807: LD_INT 7
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: LD_INT 30
55816: PUSH
55817: LD_INT 8
55819: PUSH
55820: EMPTY
55821: LIST
55822: LIST
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: PPUSH
55830: CALL_OW 72
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: LIST
55839: LIST
55840: ST_TO_ADDR
// for j = 1 to 4 do
55841: LD_ADDR_VAR 0 3
55845: PUSH
55846: DOUBLE
55847: LD_INT 1
55849: DEC
55850: ST_TO_ADDR
55851: LD_INT 4
55853: PUSH
55854: FOR_TO
55855: IFFALSE 56046
// begin if not tmp [ j ] then
55857: LD_VAR 0 4
55861: PUSH
55862: LD_VAR 0 3
55866: ARRAY
55867: NOT
55868: IFFALSE 55872
// continue ;
55870: GO 55854
// for p in tmp [ j ] do
55872: LD_ADDR_VAR 0 5
55876: PUSH
55877: LD_VAR 0 4
55881: PUSH
55882: LD_VAR 0 3
55886: ARRAY
55887: PUSH
55888: FOR_IN
55889: IFFALSE 56042
// begin if not b [ j ] then
55891: LD_VAR 0 6
55895: PUSH
55896: LD_VAR 0 3
55900: ARRAY
55901: NOT
55902: IFFALSE 55906
// break ;
55904: GO 56042
// e := 0 ;
55906: LD_ADDR_VAR 0 7
55910: PUSH
55911: LD_INT 0
55913: ST_TO_ADDR
// for k in b [ j ] do
55914: LD_ADDR_VAR 0 8
55918: PUSH
55919: LD_VAR 0 6
55923: PUSH
55924: LD_VAR 0 3
55928: ARRAY
55929: PUSH
55930: FOR_IN
55931: IFFALSE 55958
// if IsNotFull ( k ) then
55933: LD_VAR 0 8
55937: PPUSH
55938: CALL 15814 0 1
55942: IFFALSE 55956
// begin e := k ;
55944: LD_ADDR_VAR 0 7
55948: PUSH
55949: LD_VAR 0 8
55953: ST_TO_ADDR
// break ;
55954: GO 55958
// end ;
55956: GO 55930
55958: POP
55959: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55960: LD_VAR 0 7
55964: PUSH
55965: LD_VAR 0 5
55969: PPUSH
55970: LD_VAR 0 7
55974: PPUSH
55975: CALL 48567 0 2
55979: NOT
55980: AND
55981: IFFALSE 56040
// begin if IsInUnit ( p ) then
55983: LD_VAR 0 5
55987: PPUSH
55988: CALL_OW 310
55992: IFFALSE 56003
// ComExitBuilding ( p ) ;
55994: LD_VAR 0 5
55998: PPUSH
55999: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56003: LD_VAR 0 5
56007: PPUSH
56008: LD_VAR 0 7
56012: PPUSH
56013: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56017: LD_VAR 0 5
56021: PPUSH
56022: LD_VAR 0 3
56026: PPUSH
56027: CALL_OW 183
// AddComExitBuilding ( p ) ;
56031: LD_VAR 0 5
56035: PPUSH
56036: CALL_OW 182
// end ; end ;
56040: GO 55888
56042: POP
56043: POP
// end ;
56044: GO 55854
56046: POP
56047: POP
// end ;
56048: GO 55609
56050: POP
56051: POP
// end ;
56052: LD_VAR 0 1
56056: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56057: LD_INT 0
56059: PPUSH
56060: PPUSH
56061: PPUSH
56062: PPUSH
56063: PPUSH
56064: PPUSH
56065: PPUSH
56066: PPUSH
56067: PPUSH
56068: PPUSH
56069: PPUSH
56070: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56071: LD_VAR 0 1
56075: NOT
56076: PUSH
56077: LD_EXP 66
56081: PUSH
56082: LD_VAR 0 1
56086: ARRAY
56087: NOT
56088: OR
56089: PUSH
56090: LD_EXP 66
56094: PUSH
56095: LD_VAR 0 1
56099: ARRAY
56100: PPUSH
56101: LD_INT 2
56103: PUSH
56104: LD_INT 30
56106: PUSH
56107: LD_INT 0
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: PUSH
56114: LD_INT 30
56116: PUSH
56117: LD_INT 1
56119: PUSH
56120: EMPTY
56121: LIST
56122: LIST
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: LIST
56128: PPUSH
56129: CALL_OW 72
56133: NOT
56134: OR
56135: IFFALSE 56139
// exit ;
56137: GO 59642
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56139: LD_ADDR_VAR 0 4
56143: PUSH
56144: LD_EXP 66
56148: PUSH
56149: LD_VAR 0 1
56153: ARRAY
56154: PPUSH
56155: LD_INT 2
56157: PUSH
56158: LD_INT 25
56160: PUSH
56161: LD_INT 1
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: PUSH
56168: LD_INT 25
56170: PUSH
56171: LD_INT 2
56173: PUSH
56174: EMPTY
56175: LIST
56176: LIST
56177: PUSH
56178: LD_INT 25
56180: PUSH
56181: LD_INT 3
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: PUSH
56188: LD_INT 25
56190: PUSH
56191: LD_INT 4
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: PUSH
56198: LD_INT 25
56200: PUSH
56201: LD_INT 5
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: PUSH
56208: LD_INT 25
56210: PUSH
56211: LD_INT 8
56213: PUSH
56214: EMPTY
56215: LIST
56216: LIST
56217: PUSH
56218: LD_INT 25
56220: PUSH
56221: LD_INT 9
56223: PUSH
56224: EMPTY
56225: LIST
56226: LIST
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: LIST
56234: LIST
56235: LIST
56236: LIST
56237: PPUSH
56238: CALL_OW 72
56242: ST_TO_ADDR
// if not tmp then
56243: LD_VAR 0 4
56247: NOT
56248: IFFALSE 56252
// exit ;
56250: GO 59642
// for i in tmp do
56252: LD_ADDR_VAR 0 3
56256: PUSH
56257: LD_VAR 0 4
56261: PUSH
56262: FOR_IN
56263: IFFALSE 56294
// if GetTag ( i ) then
56265: LD_VAR 0 3
56269: PPUSH
56270: CALL_OW 110
56274: IFFALSE 56292
// tmp := tmp diff i ;
56276: LD_ADDR_VAR 0 4
56280: PUSH
56281: LD_VAR 0 4
56285: PUSH
56286: LD_VAR 0 3
56290: DIFF
56291: ST_TO_ADDR
56292: GO 56262
56294: POP
56295: POP
// if not tmp then
56296: LD_VAR 0 4
56300: NOT
56301: IFFALSE 56305
// exit ;
56303: GO 59642
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56305: LD_ADDR_VAR 0 5
56309: PUSH
56310: LD_EXP 66
56314: PUSH
56315: LD_VAR 0 1
56319: ARRAY
56320: PPUSH
56321: LD_INT 2
56323: PUSH
56324: LD_INT 25
56326: PUSH
56327: LD_INT 1
56329: PUSH
56330: EMPTY
56331: LIST
56332: LIST
56333: PUSH
56334: LD_INT 25
56336: PUSH
56337: LD_INT 5
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PUSH
56344: LD_INT 25
56346: PUSH
56347: LD_INT 8
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PUSH
56354: LD_INT 25
56356: PUSH
56357: LD_INT 9
56359: PUSH
56360: EMPTY
56361: LIST
56362: LIST
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: LIST
56368: LIST
56369: LIST
56370: PPUSH
56371: CALL_OW 72
56375: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56376: LD_ADDR_VAR 0 6
56380: PUSH
56381: LD_EXP 66
56385: PUSH
56386: LD_VAR 0 1
56390: ARRAY
56391: PPUSH
56392: LD_INT 25
56394: PUSH
56395: LD_INT 2
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PPUSH
56402: CALL_OW 72
56406: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56407: LD_ADDR_VAR 0 7
56411: PUSH
56412: LD_EXP 66
56416: PUSH
56417: LD_VAR 0 1
56421: ARRAY
56422: PPUSH
56423: LD_INT 25
56425: PUSH
56426: LD_INT 3
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PPUSH
56433: CALL_OW 72
56437: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56438: LD_ADDR_VAR 0 8
56442: PUSH
56443: LD_EXP 66
56447: PUSH
56448: LD_VAR 0 1
56452: ARRAY
56453: PPUSH
56454: LD_INT 25
56456: PUSH
56457: LD_INT 4
56459: PUSH
56460: EMPTY
56461: LIST
56462: LIST
56463: PUSH
56464: LD_INT 24
56466: PUSH
56467: LD_INT 251
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: PPUSH
56478: CALL_OW 72
56482: ST_TO_ADDR
// if mc_scan [ base ] then
56483: LD_EXP 89
56487: PUSH
56488: LD_VAR 0 1
56492: ARRAY
56493: IFFALSE 56954
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56495: LD_ADDR_EXP 108
56499: PUSH
56500: LD_EXP 108
56504: PPUSH
56505: LD_VAR 0 1
56509: PPUSH
56510: LD_INT 4
56512: PPUSH
56513: CALL_OW 1
56517: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56518: LD_ADDR_VAR 0 12
56522: PUSH
56523: LD_EXP 66
56527: PUSH
56528: LD_VAR 0 1
56532: ARRAY
56533: PPUSH
56534: LD_INT 2
56536: PUSH
56537: LD_INT 30
56539: PUSH
56540: LD_INT 4
56542: PUSH
56543: EMPTY
56544: LIST
56545: LIST
56546: PUSH
56547: LD_INT 30
56549: PUSH
56550: LD_INT 5
56552: PUSH
56553: EMPTY
56554: LIST
56555: LIST
56556: PUSH
56557: EMPTY
56558: LIST
56559: LIST
56560: LIST
56561: PPUSH
56562: CALL_OW 72
56566: ST_TO_ADDR
// if not b then
56567: LD_VAR 0 12
56571: NOT
56572: IFFALSE 56576
// exit ;
56574: GO 59642
// p := [ ] ;
56576: LD_ADDR_VAR 0 11
56580: PUSH
56581: EMPTY
56582: ST_TO_ADDR
// if sci >= 2 then
56583: LD_VAR 0 8
56587: PUSH
56588: LD_INT 2
56590: GREATEREQUAL
56591: IFFALSE 56622
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56593: LD_ADDR_VAR 0 8
56597: PUSH
56598: LD_VAR 0 8
56602: PUSH
56603: LD_INT 1
56605: ARRAY
56606: PUSH
56607: LD_VAR 0 8
56611: PUSH
56612: LD_INT 2
56614: ARRAY
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: ST_TO_ADDR
56620: GO 56683
// if sci = 1 then
56622: LD_VAR 0 8
56626: PUSH
56627: LD_INT 1
56629: EQUAL
56630: IFFALSE 56651
// sci := [ sci [ 1 ] ] else
56632: LD_ADDR_VAR 0 8
56636: PUSH
56637: LD_VAR 0 8
56641: PUSH
56642: LD_INT 1
56644: ARRAY
56645: PUSH
56646: EMPTY
56647: LIST
56648: ST_TO_ADDR
56649: GO 56683
// if sci = 0 then
56651: LD_VAR 0 8
56655: PUSH
56656: LD_INT 0
56658: EQUAL
56659: IFFALSE 56683
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56661: LD_ADDR_VAR 0 11
56665: PUSH
56666: LD_VAR 0 4
56670: PPUSH
56671: LD_INT 4
56673: PPUSH
56674: CALL 48430 0 2
56678: PUSH
56679: LD_INT 1
56681: ARRAY
56682: ST_TO_ADDR
// if eng > 4 then
56683: LD_VAR 0 6
56687: PUSH
56688: LD_INT 4
56690: GREATER
56691: IFFALSE 56737
// for i = eng downto 4 do
56693: LD_ADDR_VAR 0 3
56697: PUSH
56698: DOUBLE
56699: LD_VAR 0 6
56703: INC
56704: ST_TO_ADDR
56705: LD_INT 4
56707: PUSH
56708: FOR_DOWNTO
56709: IFFALSE 56735
// eng := eng diff eng [ i ] ;
56711: LD_ADDR_VAR 0 6
56715: PUSH
56716: LD_VAR 0 6
56720: PUSH
56721: LD_VAR 0 6
56725: PUSH
56726: LD_VAR 0 3
56730: ARRAY
56731: DIFF
56732: ST_TO_ADDR
56733: GO 56708
56735: POP
56736: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56737: LD_ADDR_VAR 0 4
56741: PUSH
56742: LD_VAR 0 4
56746: PUSH
56747: LD_VAR 0 5
56751: PUSH
56752: LD_VAR 0 6
56756: UNION
56757: PUSH
56758: LD_VAR 0 7
56762: UNION
56763: PUSH
56764: LD_VAR 0 8
56768: UNION
56769: DIFF
56770: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56771: LD_ADDR_VAR 0 13
56775: PUSH
56776: LD_EXP 66
56780: PUSH
56781: LD_VAR 0 1
56785: ARRAY
56786: PPUSH
56787: LD_INT 2
56789: PUSH
56790: LD_INT 30
56792: PUSH
56793: LD_INT 32
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: LD_INT 30
56802: PUSH
56803: LD_INT 31
56805: PUSH
56806: EMPTY
56807: LIST
56808: LIST
56809: PUSH
56810: EMPTY
56811: LIST
56812: LIST
56813: LIST
56814: PPUSH
56815: CALL_OW 72
56819: PUSH
56820: LD_EXP 66
56824: PUSH
56825: LD_VAR 0 1
56829: ARRAY
56830: PPUSH
56831: LD_INT 2
56833: PUSH
56834: LD_INT 30
56836: PUSH
56837: LD_INT 4
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PUSH
56844: LD_INT 30
56846: PUSH
56847: LD_INT 5
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PUSH
56854: EMPTY
56855: LIST
56856: LIST
56857: LIST
56858: PPUSH
56859: CALL_OW 72
56863: PUSH
56864: LD_INT 6
56866: MUL
56867: PLUS
56868: ST_TO_ADDR
// if bcount < tmp then
56869: LD_VAR 0 13
56873: PUSH
56874: LD_VAR 0 4
56878: LESS
56879: IFFALSE 56925
// for i = tmp downto bcount do
56881: LD_ADDR_VAR 0 3
56885: PUSH
56886: DOUBLE
56887: LD_VAR 0 4
56891: INC
56892: ST_TO_ADDR
56893: LD_VAR 0 13
56897: PUSH
56898: FOR_DOWNTO
56899: IFFALSE 56923
// tmp := Delete ( tmp , tmp ) ;
56901: LD_ADDR_VAR 0 4
56905: PUSH
56906: LD_VAR 0 4
56910: PPUSH
56911: LD_VAR 0 4
56915: PPUSH
56916: CALL_OW 3
56920: ST_TO_ADDR
56921: GO 56898
56923: POP
56924: POP
// result := [ tmp , 0 , 0 , p ] ;
56925: LD_ADDR_VAR 0 2
56929: PUSH
56930: LD_VAR 0 4
56934: PUSH
56935: LD_INT 0
56937: PUSH
56938: LD_INT 0
56940: PUSH
56941: LD_VAR 0 11
56945: PUSH
56946: EMPTY
56947: LIST
56948: LIST
56949: LIST
56950: LIST
56951: ST_TO_ADDR
// exit ;
56952: GO 59642
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56954: LD_EXP 66
56958: PUSH
56959: LD_VAR 0 1
56963: ARRAY
56964: PPUSH
56965: LD_INT 2
56967: PUSH
56968: LD_INT 30
56970: PUSH
56971: LD_INT 6
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: PUSH
56978: LD_INT 30
56980: PUSH
56981: LD_INT 7
56983: PUSH
56984: EMPTY
56985: LIST
56986: LIST
56987: PUSH
56988: LD_INT 30
56990: PUSH
56991: LD_INT 8
56993: PUSH
56994: EMPTY
56995: LIST
56996: LIST
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: LIST
57002: LIST
57003: PPUSH
57004: CALL_OW 72
57008: NOT
57009: PUSH
57010: LD_EXP 66
57014: PUSH
57015: LD_VAR 0 1
57019: ARRAY
57020: PPUSH
57021: LD_INT 30
57023: PUSH
57024: LD_INT 3
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: PPUSH
57031: CALL_OW 72
57035: NOT
57036: AND
57037: IFFALSE 57109
// begin if eng = tmp then
57039: LD_VAR 0 6
57043: PUSH
57044: LD_VAR 0 4
57048: EQUAL
57049: IFFALSE 57053
// exit ;
57051: GO 59642
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57053: LD_ADDR_EXP 108
57057: PUSH
57058: LD_EXP 108
57062: PPUSH
57063: LD_VAR 0 1
57067: PPUSH
57068: LD_INT 1
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57076: LD_ADDR_VAR 0 2
57080: PUSH
57081: LD_INT 0
57083: PUSH
57084: LD_VAR 0 4
57088: PUSH
57089: LD_VAR 0 6
57093: DIFF
57094: PUSH
57095: LD_INT 0
57097: PUSH
57098: LD_INT 0
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: LIST
57105: LIST
57106: ST_TO_ADDR
// exit ;
57107: GO 59642
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57109: LD_EXP 93
57113: PUSH
57114: LD_EXP 92
57118: PUSH
57119: LD_VAR 0 1
57123: ARRAY
57124: ARRAY
57125: PUSH
57126: LD_EXP 66
57130: PUSH
57131: LD_VAR 0 1
57135: ARRAY
57136: PPUSH
57137: LD_INT 2
57139: PUSH
57140: LD_INT 30
57142: PUSH
57143: LD_INT 6
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PUSH
57150: LD_INT 30
57152: PUSH
57153: LD_INT 7
57155: PUSH
57156: EMPTY
57157: LIST
57158: LIST
57159: PUSH
57160: LD_INT 30
57162: PUSH
57163: LD_INT 8
57165: PUSH
57166: EMPTY
57167: LIST
57168: LIST
57169: PUSH
57170: EMPTY
57171: LIST
57172: LIST
57173: LIST
57174: LIST
57175: PPUSH
57176: CALL_OW 72
57180: AND
57181: PUSH
57182: LD_EXP 66
57186: PUSH
57187: LD_VAR 0 1
57191: ARRAY
57192: PPUSH
57193: LD_INT 30
57195: PUSH
57196: LD_INT 3
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: PPUSH
57203: CALL_OW 72
57207: NOT
57208: AND
57209: IFFALSE 57423
// begin if sci >= 6 then
57211: LD_VAR 0 8
57215: PUSH
57216: LD_INT 6
57218: GREATEREQUAL
57219: IFFALSE 57223
// exit ;
57221: GO 59642
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57223: LD_ADDR_EXP 108
57227: PUSH
57228: LD_EXP 108
57232: PPUSH
57233: LD_VAR 0 1
57237: PPUSH
57238: LD_INT 2
57240: PPUSH
57241: CALL_OW 1
57245: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57246: LD_ADDR_VAR 0 9
57250: PUSH
57251: LD_VAR 0 4
57255: PUSH
57256: LD_VAR 0 8
57260: DIFF
57261: PPUSH
57262: LD_INT 4
57264: PPUSH
57265: CALL 48430 0 2
57269: ST_TO_ADDR
// p := [ ] ;
57270: LD_ADDR_VAR 0 11
57274: PUSH
57275: EMPTY
57276: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57277: LD_VAR 0 8
57281: PUSH
57282: LD_INT 6
57284: LESS
57285: PUSH
57286: LD_VAR 0 9
57290: PUSH
57291: LD_INT 6
57293: GREATER
57294: AND
57295: IFFALSE 57376
// begin for i = 1 to 6 - sci do
57297: LD_ADDR_VAR 0 3
57301: PUSH
57302: DOUBLE
57303: LD_INT 1
57305: DEC
57306: ST_TO_ADDR
57307: LD_INT 6
57309: PUSH
57310: LD_VAR 0 8
57314: MINUS
57315: PUSH
57316: FOR_TO
57317: IFFALSE 57372
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57319: LD_ADDR_VAR 0 11
57323: PUSH
57324: LD_VAR 0 11
57328: PPUSH
57329: LD_VAR 0 11
57333: PUSH
57334: LD_INT 1
57336: PLUS
57337: PPUSH
57338: LD_VAR 0 9
57342: PUSH
57343: LD_INT 1
57345: ARRAY
57346: PPUSH
57347: CALL_OW 2
57351: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57352: LD_ADDR_VAR 0 9
57356: PUSH
57357: LD_VAR 0 9
57361: PPUSH
57362: LD_INT 1
57364: PPUSH
57365: CALL_OW 3
57369: ST_TO_ADDR
// end ;
57370: GO 57316
57372: POP
57373: POP
// end else
57374: GO 57396
// if sort then
57376: LD_VAR 0 9
57380: IFFALSE 57396
// p := sort [ 1 ] ;
57382: LD_ADDR_VAR 0 11
57386: PUSH
57387: LD_VAR 0 9
57391: PUSH
57392: LD_INT 1
57394: ARRAY
57395: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57396: LD_ADDR_VAR 0 2
57400: PUSH
57401: LD_INT 0
57403: PUSH
57404: LD_INT 0
57406: PUSH
57407: LD_INT 0
57409: PUSH
57410: LD_VAR 0 11
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: LIST
57419: LIST
57420: ST_TO_ADDR
// exit ;
57421: GO 59642
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57423: LD_EXP 93
57427: PUSH
57428: LD_EXP 92
57432: PUSH
57433: LD_VAR 0 1
57437: ARRAY
57438: ARRAY
57439: PUSH
57440: LD_EXP 66
57444: PUSH
57445: LD_VAR 0 1
57449: ARRAY
57450: PPUSH
57451: LD_INT 2
57453: PUSH
57454: LD_INT 30
57456: PUSH
57457: LD_INT 6
57459: PUSH
57460: EMPTY
57461: LIST
57462: LIST
57463: PUSH
57464: LD_INT 30
57466: PUSH
57467: LD_INT 7
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: PUSH
57474: LD_INT 30
57476: PUSH
57477: LD_INT 8
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: LIST
57488: LIST
57489: PPUSH
57490: CALL_OW 72
57494: AND
57495: PUSH
57496: LD_EXP 66
57500: PUSH
57501: LD_VAR 0 1
57505: ARRAY
57506: PPUSH
57507: LD_INT 30
57509: PUSH
57510: LD_INT 3
57512: PUSH
57513: EMPTY
57514: LIST
57515: LIST
57516: PPUSH
57517: CALL_OW 72
57521: AND
57522: IFFALSE 58256
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57524: LD_ADDR_EXP 108
57528: PUSH
57529: LD_EXP 108
57533: PPUSH
57534: LD_VAR 0 1
57538: PPUSH
57539: LD_INT 3
57541: PPUSH
57542: CALL_OW 1
57546: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57547: LD_ADDR_VAR 0 2
57551: PUSH
57552: LD_INT 0
57554: PUSH
57555: LD_INT 0
57557: PUSH
57558: LD_INT 0
57560: PUSH
57561: LD_INT 0
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: LIST
57568: LIST
57569: ST_TO_ADDR
// if not eng then
57570: LD_VAR 0 6
57574: NOT
57575: IFFALSE 57638
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57577: LD_ADDR_VAR 0 11
57581: PUSH
57582: LD_VAR 0 4
57586: PPUSH
57587: LD_INT 2
57589: PPUSH
57590: CALL 48430 0 2
57594: PUSH
57595: LD_INT 1
57597: ARRAY
57598: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57599: LD_ADDR_VAR 0 2
57603: PUSH
57604: LD_VAR 0 2
57608: PPUSH
57609: LD_INT 2
57611: PPUSH
57612: LD_VAR 0 11
57616: PPUSH
57617: CALL_OW 1
57621: ST_TO_ADDR
// tmp := tmp diff p ;
57622: LD_ADDR_VAR 0 4
57626: PUSH
57627: LD_VAR 0 4
57631: PUSH
57632: LD_VAR 0 11
57636: DIFF
57637: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57638: LD_VAR 0 4
57642: PUSH
57643: LD_VAR 0 8
57647: PUSH
57648: LD_INT 6
57650: LESS
57651: AND
57652: IFFALSE 57840
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57654: LD_ADDR_VAR 0 9
57658: PUSH
57659: LD_VAR 0 4
57663: PUSH
57664: LD_VAR 0 8
57668: PUSH
57669: LD_VAR 0 7
57673: UNION
57674: DIFF
57675: PPUSH
57676: LD_INT 4
57678: PPUSH
57679: CALL 48430 0 2
57683: ST_TO_ADDR
// p := [ ] ;
57684: LD_ADDR_VAR 0 11
57688: PUSH
57689: EMPTY
57690: ST_TO_ADDR
// if sort then
57691: LD_VAR 0 9
57695: IFFALSE 57811
// for i = 1 to 6 - sci do
57697: LD_ADDR_VAR 0 3
57701: PUSH
57702: DOUBLE
57703: LD_INT 1
57705: DEC
57706: ST_TO_ADDR
57707: LD_INT 6
57709: PUSH
57710: LD_VAR 0 8
57714: MINUS
57715: PUSH
57716: FOR_TO
57717: IFFALSE 57809
// begin if i = sort then
57719: LD_VAR 0 3
57723: PUSH
57724: LD_VAR 0 9
57728: EQUAL
57729: IFFALSE 57733
// break ;
57731: GO 57809
// if GetClass ( i ) = 4 then
57733: LD_VAR 0 3
57737: PPUSH
57738: CALL_OW 257
57742: PUSH
57743: LD_INT 4
57745: EQUAL
57746: IFFALSE 57750
// continue ;
57748: GO 57716
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57750: LD_ADDR_VAR 0 11
57754: PUSH
57755: LD_VAR 0 11
57759: PPUSH
57760: LD_VAR 0 11
57764: PUSH
57765: LD_INT 1
57767: PLUS
57768: PPUSH
57769: LD_VAR 0 9
57773: PUSH
57774: LD_VAR 0 3
57778: ARRAY
57779: PPUSH
57780: CALL_OW 2
57784: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57785: LD_ADDR_VAR 0 4
57789: PUSH
57790: LD_VAR 0 4
57794: PUSH
57795: LD_VAR 0 9
57799: PUSH
57800: LD_VAR 0 3
57804: ARRAY
57805: DIFF
57806: ST_TO_ADDR
// end ;
57807: GO 57716
57809: POP
57810: POP
// if p then
57811: LD_VAR 0 11
57815: IFFALSE 57840
// result := Replace ( result , 4 , p ) ;
57817: LD_ADDR_VAR 0 2
57821: PUSH
57822: LD_VAR 0 2
57826: PPUSH
57827: LD_INT 4
57829: PPUSH
57830: LD_VAR 0 11
57834: PPUSH
57835: CALL_OW 1
57839: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57840: LD_VAR 0 4
57844: PUSH
57845: LD_VAR 0 7
57849: PUSH
57850: LD_INT 6
57852: LESS
57853: AND
57854: IFFALSE 58042
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57856: LD_ADDR_VAR 0 9
57860: PUSH
57861: LD_VAR 0 4
57865: PUSH
57866: LD_VAR 0 8
57870: PUSH
57871: LD_VAR 0 7
57875: UNION
57876: DIFF
57877: PPUSH
57878: LD_INT 3
57880: PPUSH
57881: CALL 48430 0 2
57885: ST_TO_ADDR
// p := [ ] ;
57886: LD_ADDR_VAR 0 11
57890: PUSH
57891: EMPTY
57892: ST_TO_ADDR
// if sort then
57893: LD_VAR 0 9
57897: IFFALSE 58013
// for i = 1 to 6 - mech do
57899: LD_ADDR_VAR 0 3
57903: PUSH
57904: DOUBLE
57905: LD_INT 1
57907: DEC
57908: ST_TO_ADDR
57909: LD_INT 6
57911: PUSH
57912: LD_VAR 0 7
57916: MINUS
57917: PUSH
57918: FOR_TO
57919: IFFALSE 58011
// begin if i = sort then
57921: LD_VAR 0 3
57925: PUSH
57926: LD_VAR 0 9
57930: EQUAL
57931: IFFALSE 57935
// break ;
57933: GO 58011
// if GetClass ( i ) = 3 then
57935: LD_VAR 0 3
57939: PPUSH
57940: CALL_OW 257
57944: PUSH
57945: LD_INT 3
57947: EQUAL
57948: IFFALSE 57952
// continue ;
57950: GO 57918
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57952: LD_ADDR_VAR 0 11
57956: PUSH
57957: LD_VAR 0 11
57961: PPUSH
57962: LD_VAR 0 11
57966: PUSH
57967: LD_INT 1
57969: PLUS
57970: PPUSH
57971: LD_VAR 0 9
57975: PUSH
57976: LD_VAR 0 3
57980: ARRAY
57981: PPUSH
57982: CALL_OW 2
57986: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57987: LD_ADDR_VAR 0 4
57991: PUSH
57992: LD_VAR 0 4
57996: PUSH
57997: LD_VAR 0 9
58001: PUSH
58002: LD_VAR 0 3
58006: ARRAY
58007: DIFF
58008: ST_TO_ADDR
// end ;
58009: GO 57918
58011: POP
58012: POP
// if p then
58013: LD_VAR 0 11
58017: IFFALSE 58042
// result := Replace ( result , 3 , p ) ;
58019: LD_ADDR_VAR 0 2
58023: PUSH
58024: LD_VAR 0 2
58028: PPUSH
58029: LD_INT 3
58031: PPUSH
58032: LD_VAR 0 11
58036: PPUSH
58037: CALL_OW 1
58041: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58042: LD_VAR 0 4
58046: PUSH
58047: LD_INT 6
58049: GREATER
58050: PUSH
58051: LD_VAR 0 6
58055: PUSH
58056: LD_INT 6
58058: LESS
58059: AND
58060: IFFALSE 58254
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58062: LD_ADDR_VAR 0 9
58066: PUSH
58067: LD_VAR 0 4
58071: PUSH
58072: LD_VAR 0 8
58076: PUSH
58077: LD_VAR 0 7
58081: UNION
58082: PUSH
58083: LD_VAR 0 6
58087: UNION
58088: DIFF
58089: PPUSH
58090: LD_INT 2
58092: PPUSH
58093: CALL 48430 0 2
58097: ST_TO_ADDR
// p := [ ] ;
58098: LD_ADDR_VAR 0 11
58102: PUSH
58103: EMPTY
58104: ST_TO_ADDR
// if sort then
58105: LD_VAR 0 9
58109: IFFALSE 58225
// for i = 1 to 6 - eng do
58111: LD_ADDR_VAR 0 3
58115: PUSH
58116: DOUBLE
58117: LD_INT 1
58119: DEC
58120: ST_TO_ADDR
58121: LD_INT 6
58123: PUSH
58124: LD_VAR 0 6
58128: MINUS
58129: PUSH
58130: FOR_TO
58131: IFFALSE 58223
// begin if i = sort then
58133: LD_VAR 0 3
58137: PUSH
58138: LD_VAR 0 9
58142: EQUAL
58143: IFFALSE 58147
// break ;
58145: GO 58223
// if GetClass ( i ) = 2 then
58147: LD_VAR 0 3
58151: PPUSH
58152: CALL_OW 257
58156: PUSH
58157: LD_INT 2
58159: EQUAL
58160: IFFALSE 58164
// continue ;
58162: GO 58130
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58164: LD_ADDR_VAR 0 11
58168: PUSH
58169: LD_VAR 0 11
58173: PPUSH
58174: LD_VAR 0 11
58178: PUSH
58179: LD_INT 1
58181: PLUS
58182: PPUSH
58183: LD_VAR 0 9
58187: PUSH
58188: LD_VAR 0 3
58192: ARRAY
58193: PPUSH
58194: CALL_OW 2
58198: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58199: LD_ADDR_VAR 0 4
58203: PUSH
58204: LD_VAR 0 4
58208: PUSH
58209: LD_VAR 0 9
58213: PUSH
58214: LD_VAR 0 3
58218: ARRAY
58219: DIFF
58220: ST_TO_ADDR
// end ;
58221: GO 58130
58223: POP
58224: POP
// if p then
58225: LD_VAR 0 11
58229: IFFALSE 58254
// result := Replace ( result , 2 , p ) ;
58231: LD_ADDR_VAR 0 2
58235: PUSH
58236: LD_VAR 0 2
58240: PPUSH
58241: LD_INT 2
58243: PPUSH
58244: LD_VAR 0 11
58248: PPUSH
58249: CALL_OW 1
58253: ST_TO_ADDR
// end ; exit ;
58254: GO 59642
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58256: LD_EXP 93
58260: PUSH
58261: LD_EXP 92
58265: PUSH
58266: LD_VAR 0 1
58270: ARRAY
58271: ARRAY
58272: NOT
58273: PUSH
58274: LD_EXP 66
58278: PUSH
58279: LD_VAR 0 1
58283: ARRAY
58284: PPUSH
58285: LD_INT 30
58287: PUSH
58288: LD_INT 3
58290: PUSH
58291: EMPTY
58292: LIST
58293: LIST
58294: PPUSH
58295: CALL_OW 72
58299: AND
58300: PUSH
58301: LD_EXP 71
58305: PUSH
58306: LD_VAR 0 1
58310: ARRAY
58311: AND
58312: IFFALSE 58920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58314: LD_ADDR_EXP 108
58318: PUSH
58319: LD_EXP 108
58323: PPUSH
58324: LD_VAR 0 1
58328: PPUSH
58329: LD_INT 5
58331: PPUSH
58332: CALL_OW 1
58336: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58337: LD_ADDR_VAR 0 2
58341: PUSH
58342: LD_INT 0
58344: PUSH
58345: LD_INT 0
58347: PUSH
58348: LD_INT 0
58350: PUSH
58351: LD_INT 0
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: LIST
58358: LIST
58359: ST_TO_ADDR
// if sci > 1 then
58360: LD_VAR 0 8
58364: PUSH
58365: LD_INT 1
58367: GREATER
58368: IFFALSE 58396
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58370: LD_ADDR_VAR 0 4
58374: PUSH
58375: LD_VAR 0 4
58379: PUSH
58380: LD_VAR 0 8
58384: PUSH
58385: LD_VAR 0 8
58389: PUSH
58390: LD_INT 1
58392: ARRAY
58393: DIFF
58394: DIFF
58395: ST_TO_ADDR
// if tmp and not sci then
58396: LD_VAR 0 4
58400: PUSH
58401: LD_VAR 0 8
58405: NOT
58406: AND
58407: IFFALSE 58476
// begin sort := SortBySkill ( tmp , 4 ) ;
58409: LD_ADDR_VAR 0 9
58413: PUSH
58414: LD_VAR 0 4
58418: PPUSH
58419: LD_INT 4
58421: PPUSH
58422: CALL 48430 0 2
58426: ST_TO_ADDR
// if sort then
58427: LD_VAR 0 9
58431: IFFALSE 58447
// p := sort [ 1 ] ;
58433: LD_ADDR_VAR 0 11
58437: PUSH
58438: LD_VAR 0 9
58442: PUSH
58443: LD_INT 1
58445: ARRAY
58446: ST_TO_ADDR
// if p then
58447: LD_VAR 0 11
58451: IFFALSE 58476
// result := Replace ( result , 4 , p ) ;
58453: LD_ADDR_VAR 0 2
58457: PUSH
58458: LD_VAR 0 2
58462: PPUSH
58463: LD_INT 4
58465: PPUSH
58466: LD_VAR 0 11
58470: PPUSH
58471: CALL_OW 1
58475: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58476: LD_ADDR_VAR 0 4
58480: PUSH
58481: LD_VAR 0 4
58485: PUSH
58486: LD_VAR 0 7
58490: DIFF
58491: ST_TO_ADDR
// if tmp and mech < 6 then
58492: LD_VAR 0 4
58496: PUSH
58497: LD_VAR 0 7
58501: PUSH
58502: LD_INT 6
58504: LESS
58505: AND
58506: IFFALSE 58694
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58508: LD_ADDR_VAR 0 9
58512: PUSH
58513: LD_VAR 0 4
58517: PUSH
58518: LD_VAR 0 8
58522: PUSH
58523: LD_VAR 0 7
58527: UNION
58528: DIFF
58529: PPUSH
58530: LD_INT 3
58532: PPUSH
58533: CALL 48430 0 2
58537: ST_TO_ADDR
// p := [ ] ;
58538: LD_ADDR_VAR 0 11
58542: PUSH
58543: EMPTY
58544: ST_TO_ADDR
// if sort then
58545: LD_VAR 0 9
58549: IFFALSE 58665
// for i = 1 to 6 - mech do
58551: LD_ADDR_VAR 0 3
58555: PUSH
58556: DOUBLE
58557: LD_INT 1
58559: DEC
58560: ST_TO_ADDR
58561: LD_INT 6
58563: PUSH
58564: LD_VAR 0 7
58568: MINUS
58569: PUSH
58570: FOR_TO
58571: IFFALSE 58663
// begin if i = sort then
58573: LD_VAR 0 3
58577: PUSH
58578: LD_VAR 0 9
58582: EQUAL
58583: IFFALSE 58587
// break ;
58585: GO 58663
// if GetClass ( i ) = 3 then
58587: LD_VAR 0 3
58591: PPUSH
58592: CALL_OW 257
58596: PUSH
58597: LD_INT 3
58599: EQUAL
58600: IFFALSE 58604
// continue ;
58602: GO 58570
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58604: LD_ADDR_VAR 0 11
58608: PUSH
58609: LD_VAR 0 11
58613: PPUSH
58614: LD_VAR 0 11
58618: PUSH
58619: LD_INT 1
58621: PLUS
58622: PPUSH
58623: LD_VAR 0 9
58627: PUSH
58628: LD_VAR 0 3
58632: ARRAY
58633: PPUSH
58634: CALL_OW 2
58638: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58639: LD_ADDR_VAR 0 4
58643: PUSH
58644: LD_VAR 0 4
58648: PUSH
58649: LD_VAR 0 9
58653: PUSH
58654: LD_VAR 0 3
58658: ARRAY
58659: DIFF
58660: ST_TO_ADDR
// end ;
58661: GO 58570
58663: POP
58664: POP
// if p then
58665: LD_VAR 0 11
58669: IFFALSE 58694
// result := Replace ( result , 3 , p ) ;
58671: LD_ADDR_VAR 0 2
58675: PUSH
58676: LD_VAR 0 2
58680: PPUSH
58681: LD_INT 3
58683: PPUSH
58684: LD_VAR 0 11
58688: PPUSH
58689: CALL_OW 1
58693: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58694: LD_ADDR_VAR 0 4
58698: PUSH
58699: LD_VAR 0 4
58703: PUSH
58704: LD_VAR 0 6
58708: DIFF
58709: ST_TO_ADDR
// if tmp and eng < 6 then
58710: LD_VAR 0 4
58714: PUSH
58715: LD_VAR 0 6
58719: PUSH
58720: LD_INT 6
58722: LESS
58723: AND
58724: IFFALSE 58918
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58726: LD_ADDR_VAR 0 9
58730: PUSH
58731: LD_VAR 0 4
58735: PUSH
58736: LD_VAR 0 8
58740: PUSH
58741: LD_VAR 0 7
58745: UNION
58746: PUSH
58747: LD_VAR 0 6
58751: UNION
58752: DIFF
58753: PPUSH
58754: LD_INT 2
58756: PPUSH
58757: CALL 48430 0 2
58761: ST_TO_ADDR
// p := [ ] ;
58762: LD_ADDR_VAR 0 11
58766: PUSH
58767: EMPTY
58768: ST_TO_ADDR
// if sort then
58769: LD_VAR 0 9
58773: IFFALSE 58889
// for i = 1 to 6 - eng do
58775: LD_ADDR_VAR 0 3
58779: PUSH
58780: DOUBLE
58781: LD_INT 1
58783: DEC
58784: ST_TO_ADDR
58785: LD_INT 6
58787: PUSH
58788: LD_VAR 0 6
58792: MINUS
58793: PUSH
58794: FOR_TO
58795: IFFALSE 58887
// begin if i = sort then
58797: LD_VAR 0 3
58801: PUSH
58802: LD_VAR 0 9
58806: EQUAL
58807: IFFALSE 58811
// break ;
58809: GO 58887
// if GetClass ( i ) = 2 then
58811: LD_VAR 0 3
58815: PPUSH
58816: CALL_OW 257
58820: PUSH
58821: LD_INT 2
58823: EQUAL
58824: IFFALSE 58828
// continue ;
58826: GO 58794
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58828: LD_ADDR_VAR 0 11
58832: PUSH
58833: LD_VAR 0 11
58837: PPUSH
58838: LD_VAR 0 11
58842: PUSH
58843: LD_INT 1
58845: PLUS
58846: PPUSH
58847: LD_VAR 0 9
58851: PUSH
58852: LD_VAR 0 3
58856: ARRAY
58857: PPUSH
58858: CALL_OW 2
58862: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58863: LD_ADDR_VAR 0 4
58867: PUSH
58868: LD_VAR 0 4
58872: PUSH
58873: LD_VAR 0 9
58877: PUSH
58878: LD_VAR 0 3
58882: ARRAY
58883: DIFF
58884: ST_TO_ADDR
// end ;
58885: GO 58794
58887: POP
58888: POP
// if p then
58889: LD_VAR 0 11
58893: IFFALSE 58918
// result := Replace ( result , 2 , p ) ;
58895: LD_ADDR_VAR 0 2
58899: PUSH
58900: LD_VAR 0 2
58904: PPUSH
58905: LD_INT 2
58907: PPUSH
58908: LD_VAR 0 11
58912: PPUSH
58913: CALL_OW 1
58917: ST_TO_ADDR
// end ; exit ;
58918: GO 59642
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58920: LD_EXP 93
58924: PUSH
58925: LD_EXP 92
58929: PUSH
58930: LD_VAR 0 1
58934: ARRAY
58935: ARRAY
58936: NOT
58937: PUSH
58938: LD_EXP 66
58942: PUSH
58943: LD_VAR 0 1
58947: ARRAY
58948: PPUSH
58949: LD_INT 30
58951: PUSH
58952: LD_INT 3
58954: PUSH
58955: EMPTY
58956: LIST
58957: LIST
58958: PPUSH
58959: CALL_OW 72
58963: AND
58964: PUSH
58965: LD_EXP 71
58969: PUSH
58970: LD_VAR 0 1
58974: ARRAY
58975: NOT
58976: AND
58977: IFFALSE 59642
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58979: LD_ADDR_EXP 108
58983: PUSH
58984: LD_EXP 108
58988: PPUSH
58989: LD_VAR 0 1
58993: PPUSH
58994: LD_INT 6
58996: PPUSH
58997: CALL_OW 1
59001: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59002: LD_ADDR_VAR 0 2
59006: PUSH
59007: LD_INT 0
59009: PUSH
59010: LD_INT 0
59012: PUSH
59013: LD_INT 0
59015: PUSH
59016: LD_INT 0
59018: PUSH
59019: EMPTY
59020: LIST
59021: LIST
59022: LIST
59023: LIST
59024: ST_TO_ADDR
// if sci >= 1 then
59025: LD_VAR 0 8
59029: PUSH
59030: LD_INT 1
59032: GREATEREQUAL
59033: IFFALSE 59055
// tmp := tmp diff sci [ 1 ] ;
59035: LD_ADDR_VAR 0 4
59039: PUSH
59040: LD_VAR 0 4
59044: PUSH
59045: LD_VAR 0 8
59049: PUSH
59050: LD_INT 1
59052: ARRAY
59053: DIFF
59054: ST_TO_ADDR
// if tmp and not sci then
59055: LD_VAR 0 4
59059: PUSH
59060: LD_VAR 0 8
59064: NOT
59065: AND
59066: IFFALSE 59135
// begin sort := SortBySkill ( tmp , 4 ) ;
59068: LD_ADDR_VAR 0 9
59072: PUSH
59073: LD_VAR 0 4
59077: PPUSH
59078: LD_INT 4
59080: PPUSH
59081: CALL 48430 0 2
59085: ST_TO_ADDR
// if sort then
59086: LD_VAR 0 9
59090: IFFALSE 59106
// p := sort [ 1 ] ;
59092: LD_ADDR_VAR 0 11
59096: PUSH
59097: LD_VAR 0 9
59101: PUSH
59102: LD_INT 1
59104: ARRAY
59105: ST_TO_ADDR
// if p then
59106: LD_VAR 0 11
59110: IFFALSE 59135
// result := Replace ( result , 4 , p ) ;
59112: LD_ADDR_VAR 0 2
59116: PUSH
59117: LD_VAR 0 2
59121: PPUSH
59122: LD_INT 4
59124: PPUSH
59125: LD_VAR 0 11
59129: PPUSH
59130: CALL_OW 1
59134: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59135: LD_ADDR_VAR 0 4
59139: PUSH
59140: LD_VAR 0 4
59144: PUSH
59145: LD_VAR 0 7
59149: DIFF
59150: ST_TO_ADDR
// if tmp and mech < 6 then
59151: LD_VAR 0 4
59155: PUSH
59156: LD_VAR 0 7
59160: PUSH
59161: LD_INT 6
59163: LESS
59164: AND
59165: IFFALSE 59347
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59167: LD_ADDR_VAR 0 9
59171: PUSH
59172: LD_VAR 0 4
59176: PUSH
59177: LD_VAR 0 7
59181: DIFF
59182: PPUSH
59183: LD_INT 3
59185: PPUSH
59186: CALL 48430 0 2
59190: ST_TO_ADDR
// p := [ ] ;
59191: LD_ADDR_VAR 0 11
59195: PUSH
59196: EMPTY
59197: ST_TO_ADDR
// if sort then
59198: LD_VAR 0 9
59202: IFFALSE 59318
// for i = 1 to 6 - mech do
59204: LD_ADDR_VAR 0 3
59208: PUSH
59209: DOUBLE
59210: LD_INT 1
59212: DEC
59213: ST_TO_ADDR
59214: LD_INT 6
59216: PUSH
59217: LD_VAR 0 7
59221: MINUS
59222: PUSH
59223: FOR_TO
59224: IFFALSE 59316
// begin if i = sort then
59226: LD_VAR 0 3
59230: PUSH
59231: LD_VAR 0 9
59235: EQUAL
59236: IFFALSE 59240
// break ;
59238: GO 59316
// if GetClass ( i ) = 3 then
59240: LD_VAR 0 3
59244: PPUSH
59245: CALL_OW 257
59249: PUSH
59250: LD_INT 3
59252: EQUAL
59253: IFFALSE 59257
// continue ;
59255: GO 59223
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59257: LD_ADDR_VAR 0 11
59261: PUSH
59262: LD_VAR 0 11
59266: PPUSH
59267: LD_VAR 0 11
59271: PUSH
59272: LD_INT 1
59274: PLUS
59275: PPUSH
59276: LD_VAR 0 9
59280: PUSH
59281: LD_VAR 0 3
59285: ARRAY
59286: PPUSH
59287: CALL_OW 2
59291: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59292: LD_ADDR_VAR 0 4
59296: PUSH
59297: LD_VAR 0 4
59301: PUSH
59302: LD_VAR 0 9
59306: PUSH
59307: LD_VAR 0 3
59311: ARRAY
59312: DIFF
59313: ST_TO_ADDR
// end ;
59314: GO 59223
59316: POP
59317: POP
// if p then
59318: LD_VAR 0 11
59322: IFFALSE 59347
// result := Replace ( result , 3 , p ) ;
59324: LD_ADDR_VAR 0 2
59328: PUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: LD_INT 3
59336: PPUSH
59337: LD_VAR 0 11
59341: PPUSH
59342: CALL_OW 1
59346: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59347: LD_ADDR_VAR 0 4
59351: PUSH
59352: LD_VAR 0 4
59356: PUSH
59357: LD_VAR 0 6
59361: DIFF
59362: ST_TO_ADDR
// if tmp and eng < 4 then
59363: LD_VAR 0 4
59367: PUSH
59368: LD_VAR 0 6
59372: PUSH
59373: LD_INT 4
59375: LESS
59376: AND
59377: IFFALSE 59567
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59379: LD_ADDR_VAR 0 9
59383: PUSH
59384: LD_VAR 0 4
59388: PUSH
59389: LD_VAR 0 7
59393: PUSH
59394: LD_VAR 0 6
59398: UNION
59399: DIFF
59400: PPUSH
59401: LD_INT 2
59403: PPUSH
59404: CALL 48430 0 2
59408: ST_TO_ADDR
// p := [ ] ;
59409: LD_ADDR_VAR 0 11
59413: PUSH
59414: EMPTY
59415: ST_TO_ADDR
// if sort then
59416: LD_VAR 0 9
59420: IFFALSE 59536
// for i = 1 to 4 - eng do
59422: LD_ADDR_VAR 0 3
59426: PUSH
59427: DOUBLE
59428: LD_INT 1
59430: DEC
59431: ST_TO_ADDR
59432: LD_INT 4
59434: PUSH
59435: LD_VAR 0 6
59439: MINUS
59440: PUSH
59441: FOR_TO
59442: IFFALSE 59534
// begin if i = sort then
59444: LD_VAR 0 3
59448: PUSH
59449: LD_VAR 0 9
59453: EQUAL
59454: IFFALSE 59458
// break ;
59456: GO 59534
// if GetClass ( i ) = 2 then
59458: LD_VAR 0 3
59462: PPUSH
59463: CALL_OW 257
59467: PUSH
59468: LD_INT 2
59470: EQUAL
59471: IFFALSE 59475
// continue ;
59473: GO 59441
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59475: LD_ADDR_VAR 0 11
59479: PUSH
59480: LD_VAR 0 11
59484: PPUSH
59485: LD_VAR 0 11
59489: PUSH
59490: LD_INT 1
59492: PLUS
59493: PPUSH
59494: LD_VAR 0 9
59498: PUSH
59499: LD_VAR 0 3
59503: ARRAY
59504: PPUSH
59505: CALL_OW 2
59509: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59510: LD_ADDR_VAR 0 4
59514: PUSH
59515: LD_VAR 0 4
59519: PUSH
59520: LD_VAR 0 9
59524: PUSH
59525: LD_VAR 0 3
59529: ARRAY
59530: DIFF
59531: ST_TO_ADDR
// end ;
59532: GO 59441
59534: POP
59535: POP
// if p then
59536: LD_VAR 0 11
59540: IFFALSE 59565
// result := Replace ( result , 2 , p ) ;
59542: LD_ADDR_VAR 0 2
59546: PUSH
59547: LD_VAR 0 2
59551: PPUSH
59552: LD_INT 2
59554: PPUSH
59555: LD_VAR 0 11
59559: PPUSH
59560: CALL_OW 1
59564: ST_TO_ADDR
// end else
59565: GO 59611
// for i = eng downto 5 do
59567: LD_ADDR_VAR 0 3
59571: PUSH
59572: DOUBLE
59573: LD_VAR 0 6
59577: INC
59578: ST_TO_ADDR
59579: LD_INT 5
59581: PUSH
59582: FOR_DOWNTO
59583: IFFALSE 59609
// tmp := tmp union eng [ i ] ;
59585: LD_ADDR_VAR 0 4
59589: PUSH
59590: LD_VAR 0 4
59594: PUSH
59595: LD_VAR 0 6
59599: PUSH
59600: LD_VAR 0 3
59604: ARRAY
59605: UNION
59606: ST_TO_ADDR
59607: GO 59582
59609: POP
59610: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59611: LD_ADDR_VAR 0 2
59615: PUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: LD_INT 1
59623: PPUSH
59624: LD_VAR 0 4
59628: PUSH
59629: LD_VAR 0 5
59633: DIFF
59634: PPUSH
59635: CALL_OW 1
59639: ST_TO_ADDR
// exit ;
59640: GO 59642
// end ; end ;
59642: LD_VAR 0 2
59646: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59647: LD_INT 0
59649: PPUSH
59650: PPUSH
59651: PPUSH
// if not mc_bases then
59652: LD_EXP 66
59656: NOT
59657: IFFALSE 59661
// exit ;
59659: GO 59767
// for i = 1 to mc_bases do
59661: LD_ADDR_VAR 0 2
59665: PUSH
59666: DOUBLE
59667: LD_INT 1
59669: DEC
59670: ST_TO_ADDR
59671: LD_EXP 66
59675: PUSH
59676: FOR_TO
59677: IFFALSE 59758
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59679: LD_ADDR_VAR 0 3
59683: PUSH
59684: LD_EXP 66
59688: PUSH
59689: LD_VAR 0 2
59693: ARRAY
59694: PPUSH
59695: LD_INT 21
59697: PUSH
59698: LD_INT 3
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: LD_INT 3
59707: PUSH
59708: LD_INT 24
59710: PUSH
59711: LD_INT 1000
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: PPUSH
59726: CALL_OW 72
59730: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59731: LD_ADDR_EXP 67
59735: PUSH
59736: LD_EXP 67
59740: PPUSH
59741: LD_VAR 0 2
59745: PPUSH
59746: LD_VAR 0 3
59750: PPUSH
59751: CALL_OW 1
59755: ST_TO_ADDR
// end ;
59756: GO 59676
59758: POP
59759: POP
// RaiseSailEvent ( 101 ) ;
59760: LD_INT 101
59762: PPUSH
59763: CALL_OW 427
// end ;
59767: LD_VAR 0 1
59771: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59772: LD_INT 0
59774: PPUSH
59775: PPUSH
59776: PPUSH
59777: PPUSH
59778: PPUSH
59779: PPUSH
59780: PPUSH
// if not mc_bases then
59781: LD_EXP 66
59785: NOT
59786: IFFALSE 59790
// exit ;
59788: GO 60352
// for i = 1 to mc_bases do
59790: LD_ADDR_VAR 0 2
59794: PUSH
59795: DOUBLE
59796: LD_INT 1
59798: DEC
59799: ST_TO_ADDR
59800: LD_EXP 66
59804: PUSH
59805: FOR_TO
59806: IFFALSE 60343
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59808: LD_ADDR_VAR 0 5
59812: PUSH
59813: LD_EXP 66
59817: PUSH
59818: LD_VAR 0 2
59822: ARRAY
59823: PUSH
59824: LD_EXP 95
59828: PUSH
59829: LD_VAR 0 2
59833: ARRAY
59834: UNION
59835: PPUSH
59836: LD_INT 21
59838: PUSH
59839: LD_INT 1
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PUSH
59846: LD_INT 1
59848: PUSH
59849: LD_INT 3
59851: PUSH
59852: LD_INT 54
59854: PUSH
59855: EMPTY
59856: LIST
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: PUSH
59862: LD_INT 3
59864: PUSH
59865: LD_INT 24
59867: PUSH
59868: LD_INT 1000
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: LIST
59883: PUSH
59884: EMPTY
59885: LIST
59886: LIST
59887: PPUSH
59888: CALL_OW 72
59892: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59893: LD_ADDR_VAR 0 6
59897: PUSH
59898: LD_EXP 66
59902: PUSH
59903: LD_VAR 0 2
59907: ARRAY
59908: PPUSH
59909: LD_INT 21
59911: PUSH
59912: LD_INT 1
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 1
59921: PUSH
59922: LD_INT 3
59924: PUSH
59925: LD_INT 54
59927: PUSH
59928: EMPTY
59929: LIST
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: LD_INT 3
59937: PUSH
59938: LD_INT 24
59940: PUSH
59941: LD_INT 250
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PUSH
59952: EMPTY
59953: LIST
59954: LIST
59955: LIST
59956: PUSH
59957: EMPTY
59958: LIST
59959: LIST
59960: PPUSH
59961: CALL_OW 72
59965: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59966: LD_ADDR_VAR 0 7
59970: PUSH
59971: LD_VAR 0 5
59975: PUSH
59976: LD_VAR 0 6
59980: DIFF
59981: ST_TO_ADDR
// if not need_heal_1 then
59982: LD_VAR 0 6
59986: NOT
59987: IFFALSE 60020
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59989: LD_ADDR_EXP 69
59993: PUSH
59994: LD_EXP 69
59998: PPUSH
59999: LD_VAR 0 2
60003: PUSH
60004: LD_INT 1
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PPUSH
60011: EMPTY
60012: PPUSH
60013: CALL 18548 0 3
60017: ST_TO_ADDR
60018: GO 60090
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60020: LD_ADDR_EXP 69
60024: PUSH
60025: LD_EXP 69
60029: PPUSH
60030: LD_VAR 0 2
60034: PUSH
60035: LD_INT 1
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PPUSH
60042: LD_EXP 69
60046: PUSH
60047: LD_VAR 0 2
60051: ARRAY
60052: PUSH
60053: LD_INT 1
60055: ARRAY
60056: PPUSH
60057: LD_INT 3
60059: PUSH
60060: LD_INT 24
60062: PUSH
60063: LD_INT 1000
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PPUSH
60074: CALL_OW 72
60078: PUSH
60079: LD_VAR 0 6
60083: UNION
60084: PPUSH
60085: CALL 18548 0 3
60089: ST_TO_ADDR
// if not need_heal_2 then
60090: LD_VAR 0 7
60094: NOT
60095: IFFALSE 60128
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60097: LD_ADDR_EXP 69
60101: PUSH
60102: LD_EXP 69
60106: PPUSH
60107: LD_VAR 0 2
60111: PUSH
60112: LD_INT 2
60114: PUSH
60115: EMPTY
60116: LIST
60117: LIST
60118: PPUSH
60119: EMPTY
60120: PPUSH
60121: CALL 18548 0 3
60125: ST_TO_ADDR
60126: GO 60160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60128: LD_ADDR_EXP 69
60132: PUSH
60133: LD_EXP 69
60137: PPUSH
60138: LD_VAR 0 2
60142: PUSH
60143: LD_INT 2
60145: PUSH
60146: EMPTY
60147: LIST
60148: LIST
60149: PPUSH
60150: LD_VAR 0 7
60154: PPUSH
60155: CALL 18548 0 3
60159: ST_TO_ADDR
// if need_heal_2 then
60160: LD_VAR 0 7
60164: IFFALSE 60325
// for j in need_heal_2 do
60166: LD_ADDR_VAR 0 3
60170: PUSH
60171: LD_VAR 0 7
60175: PUSH
60176: FOR_IN
60177: IFFALSE 60323
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60179: LD_ADDR_VAR 0 5
60183: PUSH
60184: LD_EXP 66
60188: PUSH
60189: LD_VAR 0 2
60193: ARRAY
60194: PPUSH
60195: LD_INT 2
60197: PUSH
60198: LD_INT 30
60200: PUSH
60201: LD_INT 6
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: LD_INT 30
60210: PUSH
60211: LD_INT 7
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PUSH
60218: LD_INT 30
60220: PUSH
60221: LD_INT 8
60223: PUSH
60224: EMPTY
60225: LIST
60226: LIST
60227: PUSH
60228: LD_INT 30
60230: PUSH
60231: LD_INT 0
60233: PUSH
60234: EMPTY
60235: LIST
60236: LIST
60237: PUSH
60238: LD_INT 30
60240: PUSH
60241: LD_INT 1
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: LIST
60252: LIST
60253: LIST
60254: LIST
60255: PPUSH
60256: CALL_OW 72
60260: ST_TO_ADDR
// if tmp then
60261: LD_VAR 0 5
60265: IFFALSE 60321
// begin k := NearestUnitToUnit ( tmp , j ) ;
60267: LD_ADDR_VAR 0 4
60271: PUSH
60272: LD_VAR 0 5
60276: PPUSH
60277: LD_VAR 0 3
60281: PPUSH
60282: CALL_OW 74
60286: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60287: LD_VAR 0 3
60291: PPUSH
60292: LD_VAR 0 4
60296: PPUSH
60297: CALL_OW 296
60301: PUSH
60302: LD_INT 5
60304: GREATER
60305: IFFALSE 60321
// ComMoveToNearbyEntrance ( j , k ) ;
60307: LD_VAR 0 3
60311: PPUSH
60312: LD_VAR 0 4
60316: PPUSH
60317: CALL 50791 0 2
// end ; end ;
60321: GO 60176
60323: POP
60324: POP
// if not need_heal_1 and not need_heal_2 then
60325: LD_VAR 0 6
60329: NOT
60330: PUSH
60331: LD_VAR 0 7
60335: NOT
60336: AND
60337: IFFALSE 60341
// continue ;
60339: GO 59805
// end ;
60341: GO 59805
60343: POP
60344: POP
// RaiseSailEvent ( 102 ) ;
60345: LD_INT 102
60347: PPUSH
60348: CALL_OW 427
// end ;
60352: LD_VAR 0 1
60356: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60357: LD_INT 0
60359: PPUSH
60360: PPUSH
60361: PPUSH
60362: PPUSH
60363: PPUSH
60364: PPUSH
60365: PPUSH
60366: PPUSH
// if not mc_bases then
60367: LD_EXP 66
60371: NOT
60372: IFFALSE 60376
// exit ;
60374: GO 61237
// for i = 1 to mc_bases do
60376: LD_ADDR_VAR 0 2
60380: PUSH
60381: DOUBLE
60382: LD_INT 1
60384: DEC
60385: ST_TO_ADDR
60386: LD_EXP 66
60390: PUSH
60391: FOR_TO
60392: IFFALSE 61235
// begin if not mc_building_need_repair [ i ] then
60394: LD_EXP 67
60398: PUSH
60399: LD_VAR 0 2
60403: ARRAY
60404: NOT
60405: IFFALSE 60592
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60407: LD_ADDR_VAR 0 6
60411: PUSH
60412: LD_EXP 85
60416: PUSH
60417: LD_VAR 0 2
60421: ARRAY
60422: PPUSH
60423: LD_INT 3
60425: PUSH
60426: LD_INT 24
60428: PUSH
60429: LD_INT 1000
60431: PUSH
60432: EMPTY
60433: LIST
60434: LIST
60435: PUSH
60436: EMPTY
60437: LIST
60438: LIST
60439: PUSH
60440: LD_INT 2
60442: PUSH
60443: LD_INT 34
60445: PUSH
60446: LD_INT 13
60448: PUSH
60449: EMPTY
60450: LIST
60451: LIST
60452: PUSH
60453: LD_INT 34
60455: PUSH
60456: LD_INT 52
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: PUSH
60463: LD_INT 34
60465: PUSH
60466: LD_EXP 54
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: PUSH
60475: EMPTY
60476: LIST
60477: LIST
60478: LIST
60479: LIST
60480: PUSH
60481: EMPTY
60482: LIST
60483: LIST
60484: PPUSH
60485: CALL_OW 72
60489: ST_TO_ADDR
// if cranes then
60490: LD_VAR 0 6
60494: IFFALSE 60556
// for j in cranes do
60496: LD_ADDR_VAR 0 3
60500: PUSH
60501: LD_VAR 0 6
60505: PUSH
60506: FOR_IN
60507: IFFALSE 60554
// if not IsInArea ( j , mc_parking [ i ] ) then
60509: LD_VAR 0 3
60513: PPUSH
60514: LD_EXP 90
60518: PUSH
60519: LD_VAR 0 2
60523: ARRAY
60524: PPUSH
60525: CALL_OW 308
60529: NOT
60530: IFFALSE 60552
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60532: LD_VAR 0 3
60536: PPUSH
60537: LD_EXP 90
60541: PUSH
60542: LD_VAR 0 2
60546: ARRAY
60547: PPUSH
60548: CALL_OW 113
60552: GO 60506
60554: POP
60555: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60556: LD_ADDR_EXP 68
60560: PUSH
60561: LD_EXP 68
60565: PPUSH
60566: LD_VAR 0 2
60570: PPUSH
60571: EMPTY
60572: PPUSH
60573: CALL_OW 1
60577: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60578: LD_VAR 0 2
60582: PPUSH
60583: LD_INT 101
60585: PPUSH
60586: CALL 55480 0 2
// continue ;
60590: GO 60391
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60592: LD_ADDR_EXP 72
60596: PUSH
60597: LD_EXP 72
60601: PPUSH
60602: LD_VAR 0 2
60606: PPUSH
60607: EMPTY
60608: PPUSH
60609: CALL_OW 1
60613: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60614: LD_VAR 0 2
60618: PPUSH
60619: LD_INT 103
60621: PPUSH
60622: CALL 55480 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60626: LD_ADDR_VAR 0 5
60630: PUSH
60631: LD_EXP 66
60635: PUSH
60636: LD_VAR 0 2
60640: ARRAY
60641: PUSH
60642: LD_EXP 95
60646: PUSH
60647: LD_VAR 0 2
60651: ARRAY
60652: UNION
60653: PPUSH
60654: LD_INT 2
60656: PUSH
60657: LD_INT 25
60659: PUSH
60660: LD_INT 2
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: LD_INT 25
60669: PUSH
60670: LD_INT 16
60672: PUSH
60673: EMPTY
60674: LIST
60675: LIST
60676: PUSH
60677: EMPTY
60678: LIST
60679: LIST
60680: LIST
60681: PUSH
60682: EMPTY
60683: LIST
60684: PPUSH
60685: CALL_OW 72
60689: PUSH
60690: LD_EXP 69
60694: PUSH
60695: LD_VAR 0 2
60699: ARRAY
60700: PUSH
60701: LD_INT 1
60703: ARRAY
60704: PUSH
60705: LD_EXP 69
60709: PUSH
60710: LD_VAR 0 2
60714: ARRAY
60715: PUSH
60716: LD_INT 2
60718: ARRAY
60719: UNION
60720: DIFF
60721: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60722: LD_ADDR_VAR 0 6
60726: PUSH
60727: LD_EXP 85
60731: PUSH
60732: LD_VAR 0 2
60736: ARRAY
60737: PPUSH
60738: LD_INT 2
60740: PUSH
60741: LD_INT 34
60743: PUSH
60744: LD_INT 13
60746: PUSH
60747: EMPTY
60748: LIST
60749: LIST
60750: PUSH
60751: LD_INT 34
60753: PUSH
60754: LD_INT 52
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: PUSH
60761: LD_INT 34
60763: PUSH
60764: LD_EXP 54
60768: PUSH
60769: EMPTY
60770: LIST
60771: LIST
60772: PUSH
60773: EMPTY
60774: LIST
60775: LIST
60776: LIST
60777: LIST
60778: PPUSH
60779: CALL_OW 72
60783: ST_TO_ADDR
// if cranes then
60784: LD_VAR 0 6
60788: IFFALSE 60924
// begin for j in cranes do
60790: LD_ADDR_VAR 0 3
60794: PUSH
60795: LD_VAR 0 6
60799: PUSH
60800: FOR_IN
60801: IFFALSE 60922
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60803: LD_VAR 0 3
60807: PPUSH
60808: CALL_OW 256
60812: PUSH
60813: LD_INT 1000
60815: EQUAL
60816: PUSH
60817: LD_VAR 0 3
60821: PPUSH
60822: CALL_OW 314
60826: NOT
60827: AND
60828: IFFALSE 60862
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60830: LD_VAR 0 3
60834: PPUSH
60835: LD_EXP 67
60839: PUSH
60840: LD_VAR 0 2
60844: ARRAY
60845: PPUSH
60846: LD_VAR 0 3
60850: PPUSH
60851: CALL_OW 74
60855: PPUSH
60856: CALL_OW 130
60860: GO 60920
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60862: LD_VAR 0 3
60866: PPUSH
60867: CALL_OW 256
60871: PUSH
60872: LD_INT 500
60874: LESS
60875: PUSH
60876: LD_VAR 0 3
60880: PPUSH
60881: LD_EXP 90
60885: PUSH
60886: LD_VAR 0 2
60890: ARRAY
60891: PPUSH
60892: CALL_OW 308
60896: NOT
60897: AND
60898: IFFALSE 60920
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60900: LD_VAR 0 3
60904: PPUSH
60905: LD_EXP 90
60909: PUSH
60910: LD_VAR 0 2
60914: ARRAY
60915: PPUSH
60916: CALL_OW 113
// end ;
60920: GO 60800
60922: POP
60923: POP
// end ; if tmp > 3 then
60924: LD_VAR 0 5
60928: PUSH
60929: LD_INT 3
60931: GREATER
60932: IFFALSE 60952
// tmp := ShrinkArray ( tmp , 4 ) ;
60934: LD_ADDR_VAR 0 5
60938: PUSH
60939: LD_VAR 0 5
60943: PPUSH
60944: LD_INT 4
60946: PPUSH
60947: CALL 50239 0 2
60951: ST_TO_ADDR
// if not tmp then
60952: LD_VAR 0 5
60956: NOT
60957: IFFALSE 60961
// continue ;
60959: GO 60391
// for j in tmp do
60961: LD_ADDR_VAR 0 3
60965: PUSH
60966: LD_VAR 0 5
60970: PUSH
60971: FOR_IN
60972: IFFALSE 61231
// begin if IsInUnit ( j ) then
60974: LD_VAR 0 3
60978: PPUSH
60979: CALL_OW 310
60983: IFFALSE 60994
// ComExitBuilding ( j ) ;
60985: LD_VAR 0 3
60989: PPUSH
60990: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60994: LD_VAR 0 3
60998: PUSH
60999: LD_EXP 68
61003: PUSH
61004: LD_VAR 0 2
61008: ARRAY
61009: IN
61010: NOT
61011: IFFALSE 61069
// begin SetTag ( j , 101 ) ;
61013: LD_VAR 0 3
61017: PPUSH
61018: LD_INT 101
61020: PPUSH
61021: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61025: LD_ADDR_EXP 68
61029: PUSH
61030: LD_EXP 68
61034: PPUSH
61035: LD_VAR 0 2
61039: PUSH
61040: LD_EXP 68
61044: PUSH
61045: LD_VAR 0 2
61049: ARRAY
61050: PUSH
61051: LD_INT 1
61053: PLUS
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PPUSH
61059: LD_VAR 0 3
61063: PPUSH
61064: CALL 18548 0 3
61068: ST_TO_ADDR
// end ; wait ( 1 ) ;
61069: LD_INT 1
61071: PPUSH
61072: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61076: LD_ADDR_VAR 0 7
61080: PUSH
61081: LD_EXP 67
61085: PUSH
61086: LD_VAR 0 2
61090: ARRAY
61091: ST_TO_ADDR
// if mc_scan [ i ] then
61092: LD_EXP 89
61096: PUSH
61097: LD_VAR 0 2
61101: ARRAY
61102: IFFALSE 61164
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61104: LD_ADDR_VAR 0 7
61108: PUSH
61109: LD_EXP 67
61113: PUSH
61114: LD_VAR 0 2
61118: ARRAY
61119: PPUSH
61120: LD_INT 3
61122: PUSH
61123: LD_INT 30
61125: PUSH
61126: LD_INT 32
61128: PUSH
61129: EMPTY
61130: LIST
61131: LIST
61132: PUSH
61133: LD_INT 30
61135: PUSH
61136: LD_INT 33
61138: PUSH
61139: EMPTY
61140: LIST
61141: LIST
61142: PUSH
61143: LD_INT 30
61145: PUSH
61146: LD_INT 31
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PUSH
61153: EMPTY
61154: LIST
61155: LIST
61156: LIST
61157: LIST
61158: PPUSH
61159: CALL_OW 72
61163: ST_TO_ADDR
// if not to_repair_tmp then
61164: LD_VAR 0 7
61168: NOT
61169: IFFALSE 61173
// continue ;
61171: GO 60971
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61173: LD_ADDR_VAR 0 8
61177: PUSH
61178: LD_VAR 0 7
61182: PPUSH
61183: LD_VAR 0 3
61187: PPUSH
61188: CALL_OW 74
61192: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61193: LD_VAR 0 8
61197: PPUSH
61198: LD_INT 16
61200: PPUSH
61201: CALL 21141 0 2
61205: PUSH
61206: LD_INT 4
61208: ARRAY
61209: PUSH
61210: LD_INT 10
61212: LESS
61213: IFFALSE 61229
// ComRepairBuilding ( j , to_repair ) ;
61215: LD_VAR 0 3
61219: PPUSH
61220: LD_VAR 0 8
61224: PPUSH
61225: CALL_OW 130
// end ;
61229: GO 60971
61231: POP
61232: POP
// end ;
61233: GO 60391
61235: POP
61236: POP
// end ;
61237: LD_VAR 0 1
61241: RET
// export function MC_Heal ; var i , j , tmp ; begin
61242: LD_INT 0
61244: PPUSH
61245: PPUSH
61246: PPUSH
61247: PPUSH
// if not mc_bases then
61248: LD_EXP 66
61252: NOT
61253: IFFALSE 61257
// exit ;
61255: GO 61659
// for i = 1 to mc_bases do
61257: LD_ADDR_VAR 0 2
61261: PUSH
61262: DOUBLE
61263: LD_INT 1
61265: DEC
61266: ST_TO_ADDR
61267: LD_EXP 66
61271: PUSH
61272: FOR_TO
61273: IFFALSE 61657
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61275: LD_EXP 69
61279: PUSH
61280: LD_VAR 0 2
61284: ARRAY
61285: PUSH
61286: LD_INT 1
61288: ARRAY
61289: NOT
61290: PUSH
61291: LD_EXP 69
61295: PUSH
61296: LD_VAR 0 2
61300: ARRAY
61301: PUSH
61302: LD_INT 2
61304: ARRAY
61305: NOT
61306: AND
61307: IFFALSE 61345
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61309: LD_ADDR_EXP 70
61313: PUSH
61314: LD_EXP 70
61318: PPUSH
61319: LD_VAR 0 2
61323: PPUSH
61324: EMPTY
61325: PPUSH
61326: CALL_OW 1
61330: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61331: LD_VAR 0 2
61335: PPUSH
61336: LD_INT 102
61338: PPUSH
61339: CALL 55480 0 2
// continue ;
61343: GO 61272
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61345: LD_ADDR_VAR 0 4
61349: PUSH
61350: LD_EXP 66
61354: PUSH
61355: LD_VAR 0 2
61359: ARRAY
61360: PPUSH
61361: LD_INT 25
61363: PUSH
61364: LD_INT 4
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: PPUSH
61371: CALL_OW 72
61375: ST_TO_ADDR
// if not tmp then
61376: LD_VAR 0 4
61380: NOT
61381: IFFALSE 61385
// continue ;
61383: GO 61272
// if mc_taming [ i ] then
61385: LD_EXP 97
61389: PUSH
61390: LD_VAR 0 2
61394: ARRAY
61395: IFFALSE 61419
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61397: LD_ADDR_EXP 97
61401: PUSH
61402: LD_EXP 97
61406: PPUSH
61407: LD_VAR 0 2
61411: PPUSH
61412: EMPTY
61413: PPUSH
61414: CALL_OW 1
61418: ST_TO_ADDR
// for j in tmp do
61419: LD_ADDR_VAR 0 3
61423: PUSH
61424: LD_VAR 0 4
61428: PUSH
61429: FOR_IN
61430: IFFALSE 61653
// begin if IsInUnit ( j ) then
61432: LD_VAR 0 3
61436: PPUSH
61437: CALL_OW 310
61441: IFFALSE 61452
// ComExitBuilding ( j ) ;
61443: LD_VAR 0 3
61447: PPUSH
61448: CALL_OW 122
// if not j in mc_healers [ i ] then
61452: LD_VAR 0 3
61456: PUSH
61457: LD_EXP 70
61461: PUSH
61462: LD_VAR 0 2
61466: ARRAY
61467: IN
61468: NOT
61469: IFFALSE 61515
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61471: LD_ADDR_EXP 70
61475: PUSH
61476: LD_EXP 70
61480: PPUSH
61481: LD_VAR 0 2
61485: PUSH
61486: LD_EXP 70
61490: PUSH
61491: LD_VAR 0 2
61495: ARRAY
61496: PUSH
61497: LD_INT 1
61499: PLUS
61500: PUSH
61501: EMPTY
61502: LIST
61503: LIST
61504: PPUSH
61505: LD_VAR 0 3
61509: PPUSH
61510: CALL 18548 0 3
61514: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61515: LD_VAR 0 3
61519: PPUSH
61520: CALL_OW 110
61524: PUSH
61525: LD_INT 102
61527: NONEQUAL
61528: IFFALSE 61542
// SetTag ( j , 102 ) ;
61530: LD_VAR 0 3
61534: PPUSH
61535: LD_INT 102
61537: PPUSH
61538: CALL_OW 109
// Wait ( 3 ) ;
61542: LD_INT 3
61544: PPUSH
61545: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61549: LD_EXP 69
61553: PUSH
61554: LD_VAR 0 2
61558: ARRAY
61559: PUSH
61560: LD_INT 1
61562: ARRAY
61563: IFFALSE 61595
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61565: LD_VAR 0 3
61569: PPUSH
61570: LD_EXP 69
61574: PUSH
61575: LD_VAR 0 2
61579: ARRAY
61580: PUSH
61581: LD_INT 1
61583: ARRAY
61584: PUSH
61585: LD_INT 1
61587: ARRAY
61588: PPUSH
61589: CALL_OW 128
61593: GO 61651
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61595: LD_VAR 0 3
61599: PPUSH
61600: CALL_OW 314
61604: NOT
61605: PUSH
61606: LD_EXP 69
61610: PUSH
61611: LD_VAR 0 2
61615: ARRAY
61616: PUSH
61617: LD_INT 2
61619: ARRAY
61620: AND
61621: IFFALSE 61651
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61623: LD_VAR 0 3
61627: PPUSH
61628: LD_EXP 69
61632: PUSH
61633: LD_VAR 0 2
61637: ARRAY
61638: PUSH
61639: LD_INT 2
61641: ARRAY
61642: PUSH
61643: LD_INT 1
61645: ARRAY
61646: PPUSH
61647: CALL_OW 128
// end ;
61651: GO 61429
61653: POP
61654: POP
// end ;
61655: GO 61272
61657: POP
61658: POP
// end ;
61659: LD_VAR 0 1
61663: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61664: LD_INT 0
61666: PPUSH
61667: PPUSH
61668: PPUSH
61669: PPUSH
61670: PPUSH
// if not mc_bases then
61671: LD_EXP 66
61675: NOT
61676: IFFALSE 61680
// exit ;
61678: GO 62851
// for i = 1 to mc_bases do
61680: LD_ADDR_VAR 0 2
61684: PUSH
61685: DOUBLE
61686: LD_INT 1
61688: DEC
61689: ST_TO_ADDR
61690: LD_EXP 66
61694: PUSH
61695: FOR_TO
61696: IFFALSE 62849
// begin if mc_scan [ i ] then
61698: LD_EXP 89
61702: PUSH
61703: LD_VAR 0 2
61707: ARRAY
61708: IFFALSE 61712
// continue ;
61710: GO 61695
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61712: LD_EXP 71
61716: PUSH
61717: LD_VAR 0 2
61721: ARRAY
61722: NOT
61723: PUSH
61724: LD_EXP 73
61728: PUSH
61729: LD_VAR 0 2
61733: ARRAY
61734: NOT
61735: AND
61736: PUSH
61737: LD_EXP 72
61741: PUSH
61742: LD_VAR 0 2
61746: ARRAY
61747: AND
61748: IFFALSE 61786
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61750: LD_ADDR_EXP 72
61754: PUSH
61755: LD_EXP 72
61759: PPUSH
61760: LD_VAR 0 2
61764: PPUSH
61765: EMPTY
61766: PPUSH
61767: CALL_OW 1
61771: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61772: LD_VAR 0 2
61776: PPUSH
61777: LD_INT 103
61779: PPUSH
61780: CALL 55480 0 2
// continue ;
61784: GO 61695
// end ; if mc_construct_list [ i ] then
61786: LD_EXP 73
61790: PUSH
61791: LD_VAR 0 2
61795: ARRAY
61796: IFFALSE 62016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61798: LD_ADDR_VAR 0 4
61802: PUSH
61803: LD_EXP 66
61807: PUSH
61808: LD_VAR 0 2
61812: ARRAY
61813: PPUSH
61814: LD_INT 25
61816: PUSH
61817: LD_INT 2
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PPUSH
61824: CALL_OW 72
61828: PUSH
61829: LD_EXP 68
61833: PUSH
61834: LD_VAR 0 2
61838: ARRAY
61839: DIFF
61840: ST_TO_ADDR
// if not tmp then
61841: LD_VAR 0 4
61845: NOT
61846: IFFALSE 61850
// continue ;
61848: GO 61695
// for j in tmp do
61850: LD_ADDR_VAR 0 3
61854: PUSH
61855: LD_VAR 0 4
61859: PUSH
61860: FOR_IN
61861: IFFALSE 62012
// begin if not mc_builders [ i ] then
61863: LD_EXP 72
61867: PUSH
61868: LD_VAR 0 2
61872: ARRAY
61873: NOT
61874: IFFALSE 61932
// begin SetTag ( j , 103 ) ;
61876: LD_VAR 0 3
61880: PPUSH
61881: LD_INT 103
61883: PPUSH
61884: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61888: LD_ADDR_EXP 72
61892: PUSH
61893: LD_EXP 72
61897: PPUSH
61898: LD_VAR 0 2
61902: PUSH
61903: LD_EXP 72
61907: PUSH
61908: LD_VAR 0 2
61912: ARRAY
61913: PUSH
61914: LD_INT 1
61916: PLUS
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PPUSH
61922: LD_VAR 0 3
61926: PPUSH
61927: CALL 18548 0 3
61931: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61932: LD_VAR 0 3
61936: PPUSH
61937: CALL_OW 310
61941: IFFALSE 61952
// ComExitBuilding ( j ) ;
61943: LD_VAR 0 3
61947: PPUSH
61948: CALL_OW 122
// wait ( 3 ) ;
61952: LD_INT 3
61954: PPUSH
61955: CALL_OW 67
// if not mc_construct_list [ i ] then
61959: LD_EXP 73
61963: PUSH
61964: LD_VAR 0 2
61968: ARRAY
61969: NOT
61970: IFFALSE 61974
// break ;
61972: GO 62012
// if not HasTask ( j ) then
61974: LD_VAR 0 3
61978: PPUSH
61979: CALL_OW 314
61983: NOT
61984: IFFALSE 62010
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61986: LD_VAR 0 3
61990: PPUSH
61991: LD_EXP 73
61995: PUSH
61996: LD_VAR 0 2
62000: ARRAY
62001: PUSH
62002: LD_INT 1
62004: ARRAY
62005: PPUSH
62006: CALL 21405 0 2
// end ;
62010: GO 61860
62012: POP
62013: POP
// end else
62014: GO 62847
// if mc_build_list [ i ] then
62016: LD_EXP 71
62020: PUSH
62021: LD_VAR 0 2
62025: ARRAY
62026: IFFALSE 62847
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62028: LD_ADDR_VAR 0 5
62032: PUSH
62033: LD_EXP 66
62037: PUSH
62038: LD_VAR 0 2
62042: ARRAY
62043: PPUSH
62044: LD_INT 2
62046: PUSH
62047: LD_INT 30
62049: PUSH
62050: LD_INT 0
62052: PUSH
62053: EMPTY
62054: LIST
62055: LIST
62056: PUSH
62057: LD_INT 30
62059: PUSH
62060: LD_INT 1
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: LIST
62071: PPUSH
62072: CALL_OW 72
62076: ST_TO_ADDR
// if depot then
62077: LD_VAR 0 5
62081: IFFALSE 62099
// depot := depot [ 1 ] else
62083: LD_ADDR_VAR 0 5
62087: PUSH
62088: LD_VAR 0 5
62092: PUSH
62093: LD_INT 1
62095: ARRAY
62096: ST_TO_ADDR
62097: GO 62107
// depot := 0 ;
62099: LD_ADDR_VAR 0 5
62103: PUSH
62104: LD_INT 0
62106: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62107: LD_EXP 71
62111: PUSH
62112: LD_VAR 0 2
62116: ARRAY
62117: PUSH
62118: LD_INT 1
62120: ARRAY
62121: PUSH
62122: LD_INT 1
62124: ARRAY
62125: PPUSH
62126: CALL 21229 0 1
62130: PUSH
62131: LD_EXP 66
62135: PUSH
62136: LD_VAR 0 2
62140: ARRAY
62141: PPUSH
62142: LD_INT 2
62144: PUSH
62145: LD_INT 30
62147: PUSH
62148: LD_INT 2
62150: PUSH
62151: EMPTY
62152: LIST
62153: LIST
62154: PUSH
62155: LD_INT 30
62157: PUSH
62158: LD_INT 3
62160: PUSH
62161: EMPTY
62162: LIST
62163: LIST
62164: PUSH
62165: EMPTY
62166: LIST
62167: LIST
62168: LIST
62169: PPUSH
62170: CALL_OW 72
62174: NOT
62175: AND
62176: IFFALSE 62281
// begin for j = 1 to mc_build_list [ i ] do
62178: LD_ADDR_VAR 0 3
62182: PUSH
62183: DOUBLE
62184: LD_INT 1
62186: DEC
62187: ST_TO_ADDR
62188: LD_EXP 71
62192: PUSH
62193: LD_VAR 0 2
62197: ARRAY
62198: PUSH
62199: FOR_TO
62200: IFFALSE 62279
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62202: LD_EXP 71
62206: PUSH
62207: LD_VAR 0 2
62211: ARRAY
62212: PUSH
62213: LD_VAR 0 3
62217: ARRAY
62218: PUSH
62219: LD_INT 1
62221: ARRAY
62222: PUSH
62223: LD_INT 2
62225: EQUAL
62226: IFFALSE 62277
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62228: LD_ADDR_EXP 71
62232: PUSH
62233: LD_EXP 71
62237: PPUSH
62238: LD_VAR 0 2
62242: PPUSH
62243: LD_EXP 71
62247: PUSH
62248: LD_VAR 0 2
62252: ARRAY
62253: PPUSH
62254: LD_VAR 0 3
62258: PPUSH
62259: LD_INT 1
62261: PPUSH
62262: LD_INT 0
62264: PPUSH
62265: CALL 17966 0 4
62269: PPUSH
62270: CALL_OW 1
62274: ST_TO_ADDR
// break ;
62275: GO 62279
// end ;
62277: GO 62199
62279: POP
62280: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62281: LD_EXP 71
62285: PUSH
62286: LD_VAR 0 2
62290: ARRAY
62291: PUSH
62292: LD_INT 1
62294: ARRAY
62295: PUSH
62296: LD_INT 1
62298: ARRAY
62299: PUSH
62300: LD_INT 0
62302: EQUAL
62303: PUSH
62304: LD_VAR 0 5
62308: PUSH
62309: LD_VAR 0 5
62313: PPUSH
62314: LD_EXP 71
62318: PUSH
62319: LD_VAR 0 2
62323: ARRAY
62324: PUSH
62325: LD_INT 1
62327: ARRAY
62328: PUSH
62329: LD_INT 1
62331: ARRAY
62332: PPUSH
62333: LD_EXP 71
62337: PUSH
62338: LD_VAR 0 2
62342: ARRAY
62343: PUSH
62344: LD_INT 1
62346: ARRAY
62347: PUSH
62348: LD_INT 2
62350: ARRAY
62351: PPUSH
62352: LD_EXP 71
62356: PUSH
62357: LD_VAR 0 2
62361: ARRAY
62362: PUSH
62363: LD_INT 1
62365: ARRAY
62366: PUSH
62367: LD_INT 3
62369: ARRAY
62370: PPUSH
62371: LD_EXP 71
62375: PUSH
62376: LD_VAR 0 2
62380: ARRAY
62381: PUSH
62382: LD_INT 1
62384: ARRAY
62385: PUSH
62386: LD_INT 4
62388: ARRAY
62389: PPUSH
62390: CALL 26296 0 5
62394: AND
62395: OR
62396: IFFALSE 62677
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62398: LD_ADDR_VAR 0 4
62402: PUSH
62403: LD_EXP 66
62407: PUSH
62408: LD_VAR 0 2
62412: ARRAY
62413: PPUSH
62414: LD_INT 25
62416: PUSH
62417: LD_INT 2
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: PPUSH
62424: CALL_OW 72
62428: PUSH
62429: LD_EXP 68
62433: PUSH
62434: LD_VAR 0 2
62438: ARRAY
62439: DIFF
62440: ST_TO_ADDR
// if not tmp then
62441: LD_VAR 0 4
62445: NOT
62446: IFFALSE 62450
// continue ;
62448: GO 61695
// for j in tmp do
62450: LD_ADDR_VAR 0 3
62454: PUSH
62455: LD_VAR 0 4
62459: PUSH
62460: FOR_IN
62461: IFFALSE 62673
// begin if not mc_builders [ i ] then
62463: LD_EXP 72
62467: PUSH
62468: LD_VAR 0 2
62472: ARRAY
62473: NOT
62474: IFFALSE 62532
// begin SetTag ( j , 103 ) ;
62476: LD_VAR 0 3
62480: PPUSH
62481: LD_INT 103
62483: PPUSH
62484: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62488: LD_ADDR_EXP 72
62492: PUSH
62493: LD_EXP 72
62497: PPUSH
62498: LD_VAR 0 2
62502: PUSH
62503: LD_EXP 72
62507: PUSH
62508: LD_VAR 0 2
62512: ARRAY
62513: PUSH
62514: LD_INT 1
62516: PLUS
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PPUSH
62522: LD_VAR 0 3
62526: PPUSH
62527: CALL 18548 0 3
62531: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62532: LD_VAR 0 3
62536: PPUSH
62537: CALL_OW 310
62541: IFFALSE 62552
// ComExitBuilding ( j ) ;
62543: LD_VAR 0 3
62547: PPUSH
62548: CALL_OW 122
// wait ( 3 ) ;
62552: LD_INT 3
62554: PPUSH
62555: CALL_OW 67
// if not mc_build_list [ i ] then
62559: LD_EXP 71
62563: PUSH
62564: LD_VAR 0 2
62568: ARRAY
62569: NOT
62570: IFFALSE 62574
// break ;
62572: GO 62673
// if not HasTask ( j ) then
62574: LD_VAR 0 3
62578: PPUSH
62579: CALL_OW 314
62583: NOT
62584: IFFALSE 62671
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62586: LD_VAR 0 3
62590: PPUSH
62591: LD_EXP 71
62595: PUSH
62596: LD_VAR 0 2
62600: ARRAY
62601: PUSH
62602: LD_INT 1
62604: ARRAY
62605: PUSH
62606: LD_INT 1
62608: ARRAY
62609: PPUSH
62610: LD_EXP 71
62614: PUSH
62615: LD_VAR 0 2
62619: ARRAY
62620: PUSH
62621: LD_INT 1
62623: ARRAY
62624: PUSH
62625: LD_INT 2
62627: ARRAY
62628: PPUSH
62629: LD_EXP 71
62633: PUSH
62634: LD_VAR 0 2
62638: ARRAY
62639: PUSH
62640: LD_INT 1
62642: ARRAY
62643: PUSH
62644: LD_INT 3
62646: ARRAY
62647: PPUSH
62648: LD_EXP 71
62652: PUSH
62653: LD_VAR 0 2
62657: ARRAY
62658: PUSH
62659: LD_INT 1
62661: ARRAY
62662: PUSH
62663: LD_INT 4
62665: ARRAY
62666: PPUSH
62667: CALL_OW 145
// end ;
62671: GO 62460
62673: POP
62674: POP
// end else
62675: GO 62847
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62677: LD_EXP 66
62681: PUSH
62682: LD_VAR 0 2
62686: ARRAY
62687: PPUSH
62688: LD_EXP 71
62692: PUSH
62693: LD_VAR 0 2
62697: ARRAY
62698: PUSH
62699: LD_INT 1
62701: ARRAY
62702: PUSH
62703: LD_INT 1
62705: ARRAY
62706: PPUSH
62707: LD_EXP 71
62711: PUSH
62712: LD_VAR 0 2
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PUSH
62722: LD_INT 2
62724: ARRAY
62725: PPUSH
62726: LD_EXP 71
62730: PUSH
62731: LD_VAR 0 2
62735: ARRAY
62736: PUSH
62737: LD_INT 1
62739: ARRAY
62740: PUSH
62741: LD_INT 3
62743: ARRAY
62744: PPUSH
62745: LD_EXP 71
62749: PUSH
62750: LD_VAR 0 2
62754: ARRAY
62755: PUSH
62756: LD_INT 1
62758: ARRAY
62759: PUSH
62760: LD_INT 4
62762: ARRAY
62763: PPUSH
62764: LD_EXP 66
62768: PUSH
62769: LD_VAR 0 2
62773: ARRAY
62774: PPUSH
62775: LD_INT 21
62777: PUSH
62778: LD_INT 3
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: PPUSH
62785: CALL_OW 72
62789: PPUSH
62790: EMPTY
62791: PPUSH
62792: CALL 25426 0 7
62796: NOT
62797: IFFALSE 62847
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62799: LD_ADDR_EXP 71
62803: PUSH
62804: LD_EXP 71
62808: PPUSH
62809: LD_VAR 0 2
62813: PPUSH
62814: LD_EXP 71
62818: PUSH
62819: LD_VAR 0 2
62823: ARRAY
62824: PPUSH
62825: LD_INT 1
62827: PPUSH
62828: LD_INT 1
62830: NEG
62831: PPUSH
62832: LD_INT 0
62834: PPUSH
62835: CALL 17966 0 4
62839: PPUSH
62840: CALL_OW 1
62844: ST_TO_ADDR
// continue ;
62845: GO 61695
// end ; end ; end ;
62847: GO 61695
62849: POP
62850: POP
// end ;
62851: LD_VAR 0 1
62855: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62856: LD_INT 0
62858: PPUSH
62859: PPUSH
62860: PPUSH
62861: PPUSH
62862: PPUSH
62863: PPUSH
// if not mc_bases then
62864: LD_EXP 66
62868: NOT
62869: IFFALSE 62873
// exit ;
62871: GO 63300
// for i = 1 to mc_bases do
62873: LD_ADDR_VAR 0 2
62877: PUSH
62878: DOUBLE
62879: LD_INT 1
62881: DEC
62882: ST_TO_ADDR
62883: LD_EXP 66
62887: PUSH
62888: FOR_TO
62889: IFFALSE 63298
// begin tmp := mc_build_upgrade [ i ] ;
62891: LD_ADDR_VAR 0 4
62895: PUSH
62896: LD_EXP 98
62900: PUSH
62901: LD_VAR 0 2
62905: ARRAY
62906: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62907: LD_ADDR_VAR 0 6
62911: PUSH
62912: LD_EXP 99
62916: PUSH
62917: LD_VAR 0 2
62921: ARRAY
62922: PPUSH
62923: LD_INT 2
62925: PUSH
62926: LD_INT 30
62928: PUSH
62929: LD_INT 6
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: LD_INT 30
62938: PUSH
62939: LD_INT 7
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: LIST
62950: PPUSH
62951: CALL_OW 72
62955: ST_TO_ADDR
// if not tmp and not lab then
62956: LD_VAR 0 4
62960: NOT
62961: PUSH
62962: LD_VAR 0 6
62966: NOT
62967: AND
62968: IFFALSE 62972
// continue ;
62970: GO 62888
// if tmp then
62972: LD_VAR 0 4
62976: IFFALSE 63096
// for j in tmp do
62978: LD_ADDR_VAR 0 3
62982: PUSH
62983: LD_VAR 0 4
62987: PUSH
62988: FOR_IN
62989: IFFALSE 63094
// begin if UpgradeCost ( j ) then
62991: LD_VAR 0 3
62995: PPUSH
62996: CALL 25086 0 1
63000: IFFALSE 63092
// begin ComUpgrade ( j ) ;
63002: LD_VAR 0 3
63006: PPUSH
63007: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63011: LD_ADDR_EXP 98
63015: PUSH
63016: LD_EXP 98
63020: PPUSH
63021: LD_VAR 0 2
63025: PPUSH
63026: LD_EXP 98
63030: PUSH
63031: LD_VAR 0 2
63035: ARRAY
63036: PUSH
63037: LD_VAR 0 3
63041: DIFF
63042: PPUSH
63043: CALL_OW 1
63047: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63048: LD_ADDR_EXP 73
63052: PUSH
63053: LD_EXP 73
63057: PPUSH
63058: LD_VAR 0 2
63062: PUSH
63063: LD_EXP 73
63067: PUSH
63068: LD_VAR 0 2
63072: ARRAY
63073: PUSH
63074: LD_INT 1
63076: PLUS
63077: PUSH
63078: EMPTY
63079: LIST
63080: LIST
63081: PPUSH
63082: LD_VAR 0 3
63086: PPUSH
63087: CALL 18548 0 3
63091: ST_TO_ADDR
// end ; end ;
63092: GO 62988
63094: POP
63095: POP
// if not lab or not mc_lab_upgrade [ i ] then
63096: LD_VAR 0 6
63100: NOT
63101: PUSH
63102: LD_EXP 100
63106: PUSH
63107: LD_VAR 0 2
63111: ARRAY
63112: NOT
63113: OR
63114: IFFALSE 63118
// continue ;
63116: GO 62888
// for j in lab do
63118: LD_ADDR_VAR 0 3
63122: PUSH
63123: LD_VAR 0 6
63127: PUSH
63128: FOR_IN
63129: IFFALSE 63294
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63131: LD_VAR 0 3
63135: PPUSH
63136: CALL_OW 266
63140: PUSH
63141: LD_INT 6
63143: PUSH
63144: LD_INT 7
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: IN
63151: PUSH
63152: LD_VAR 0 3
63156: PPUSH
63157: CALL_OW 461
63161: PUSH
63162: LD_INT 1
63164: NONEQUAL
63165: AND
63166: IFFALSE 63292
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63168: LD_VAR 0 3
63172: PPUSH
63173: LD_EXP 100
63177: PUSH
63178: LD_VAR 0 2
63182: ARRAY
63183: PUSH
63184: LD_INT 1
63186: ARRAY
63187: PPUSH
63188: CALL 25291 0 2
63192: IFFALSE 63292
// begin ComCancel ( j ) ;
63194: LD_VAR 0 3
63198: PPUSH
63199: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63203: LD_VAR 0 3
63207: PPUSH
63208: LD_EXP 100
63212: PUSH
63213: LD_VAR 0 2
63217: ARRAY
63218: PUSH
63219: LD_INT 1
63221: ARRAY
63222: PPUSH
63223: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63227: LD_VAR 0 3
63231: PUSH
63232: LD_EXP 73
63236: PUSH
63237: LD_VAR 0 2
63241: ARRAY
63242: IN
63243: NOT
63244: IFFALSE 63290
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63246: LD_ADDR_EXP 73
63250: PUSH
63251: LD_EXP 73
63255: PPUSH
63256: LD_VAR 0 2
63260: PUSH
63261: LD_EXP 73
63265: PUSH
63266: LD_VAR 0 2
63270: ARRAY
63271: PUSH
63272: LD_INT 1
63274: PLUS
63275: PUSH
63276: EMPTY
63277: LIST
63278: LIST
63279: PPUSH
63280: LD_VAR 0 3
63284: PPUSH
63285: CALL 18548 0 3
63289: ST_TO_ADDR
// break ;
63290: GO 63294
// end ; end ; end ;
63292: GO 63128
63294: POP
63295: POP
// end ;
63296: GO 62888
63298: POP
63299: POP
// end ;
63300: LD_VAR 0 1
63304: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63305: LD_INT 0
63307: PPUSH
63308: PPUSH
63309: PPUSH
63310: PPUSH
63311: PPUSH
63312: PPUSH
63313: PPUSH
63314: PPUSH
63315: PPUSH
// if not mc_bases then
63316: LD_EXP 66
63320: NOT
63321: IFFALSE 63325
// exit ;
63323: GO 63730
// for i = 1 to mc_bases do
63325: LD_ADDR_VAR 0 2
63329: PUSH
63330: DOUBLE
63331: LD_INT 1
63333: DEC
63334: ST_TO_ADDR
63335: LD_EXP 66
63339: PUSH
63340: FOR_TO
63341: IFFALSE 63728
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63343: LD_EXP 74
63347: PUSH
63348: LD_VAR 0 2
63352: ARRAY
63353: NOT
63354: PUSH
63355: LD_EXP 66
63359: PUSH
63360: LD_VAR 0 2
63364: ARRAY
63365: PPUSH
63366: LD_INT 30
63368: PUSH
63369: LD_INT 3
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PPUSH
63376: CALL_OW 72
63380: NOT
63381: OR
63382: IFFALSE 63386
// continue ;
63384: GO 63340
// busy := false ;
63386: LD_ADDR_VAR 0 8
63390: PUSH
63391: LD_INT 0
63393: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63394: LD_ADDR_VAR 0 4
63398: PUSH
63399: LD_EXP 66
63403: PUSH
63404: LD_VAR 0 2
63408: ARRAY
63409: PPUSH
63410: LD_INT 30
63412: PUSH
63413: LD_INT 3
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: PPUSH
63420: CALL_OW 72
63424: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63425: LD_ADDR_VAR 0 6
63429: PUSH
63430: LD_EXP 74
63434: PUSH
63435: LD_VAR 0 2
63439: ARRAY
63440: PPUSH
63441: LD_INT 2
63443: PUSH
63444: LD_INT 30
63446: PUSH
63447: LD_INT 32
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PUSH
63454: LD_INT 30
63456: PUSH
63457: LD_INT 33
63459: PUSH
63460: EMPTY
63461: LIST
63462: LIST
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: LIST
63468: PPUSH
63469: CALL_OW 72
63473: ST_TO_ADDR
// if not t then
63474: LD_VAR 0 6
63478: NOT
63479: IFFALSE 63483
// continue ;
63481: GO 63340
// for j in tmp do
63483: LD_ADDR_VAR 0 3
63487: PUSH
63488: LD_VAR 0 4
63492: PUSH
63493: FOR_IN
63494: IFFALSE 63524
// if not BuildingStatus ( j ) = bs_idle then
63496: LD_VAR 0 3
63500: PPUSH
63501: CALL_OW 461
63505: PUSH
63506: LD_INT 2
63508: EQUAL
63509: NOT
63510: IFFALSE 63522
// begin busy := true ;
63512: LD_ADDR_VAR 0 8
63516: PUSH
63517: LD_INT 1
63519: ST_TO_ADDR
// break ;
63520: GO 63524
// end ;
63522: GO 63493
63524: POP
63525: POP
// if busy then
63526: LD_VAR 0 8
63530: IFFALSE 63534
// continue ;
63532: GO 63340
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63534: LD_ADDR_VAR 0 7
63538: PUSH
63539: LD_VAR 0 6
63543: PPUSH
63544: LD_INT 35
63546: PUSH
63547: LD_INT 0
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: PPUSH
63554: CALL_OW 72
63558: ST_TO_ADDR
// if tw then
63559: LD_VAR 0 7
63563: IFFALSE 63640
// begin tw := tw [ 1 ] ;
63565: LD_ADDR_VAR 0 7
63569: PUSH
63570: LD_VAR 0 7
63574: PUSH
63575: LD_INT 1
63577: ARRAY
63578: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63579: LD_ADDR_VAR 0 9
63583: PUSH
63584: LD_VAR 0 7
63588: PPUSH
63589: LD_EXP 91
63593: PUSH
63594: LD_VAR 0 2
63598: ARRAY
63599: PPUSH
63600: CALL 23553 0 2
63604: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63605: LD_EXP 105
63609: PUSH
63610: LD_VAR 0 2
63614: ARRAY
63615: IFFALSE 63638
// if not weapon in mc_allowed_tower_weapons [ i ] then
63617: LD_VAR 0 9
63621: PUSH
63622: LD_EXP 105
63626: PUSH
63627: LD_VAR 0 2
63631: ARRAY
63632: IN
63633: NOT
63634: IFFALSE 63638
// continue ;
63636: GO 63340
// end else
63638: GO 63703
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63640: LD_ADDR_VAR 0 5
63644: PUSH
63645: LD_EXP 74
63649: PUSH
63650: LD_VAR 0 2
63654: ARRAY
63655: PPUSH
63656: LD_VAR 0 4
63660: PPUSH
63661: CALL 49472 0 2
63665: ST_TO_ADDR
// if not tmp2 then
63666: LD_VAR 0 5
63670: NOT
63671: IFFALSE 63675
// continue ;
63673: GO 63340
// tw := tmp2 [ 1 ] ;
63675: LD_ADDR_VAR 0 7
63679: PUSH
63680: LD_VAR 0 5
63684: PUSH
63685: LD_INT 1
63687: ARRAY
63688: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63689: LD_ADDR_VAR 0 9
63693: PUSH
63694: LD_VAR 0 5
63698: PUSH
63699: LD_INT 2
63701: ARRAY
63702: ST_TO_ADDR
// end ; if not weapon then
63703: LD_VAR 0 9
63707: NOT
63708: IFFALSE 63712
// continue ;
63710: GO 63340
// ComPlaceWeapon ( tw , weapon ) ;
63712: LD_VAR 0 7
63716: PPUSH
63717: LD_VAR 0 9
63721: PPUSH
63722: CALL_OW 148
// end ;
63726: GO 63340
63728: POP
63729: POP
// end ;
63730: LD_VAR 0 1
63734: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63735: LD_INT 0
63737: PPUSH
63738: PPUSH
63739: PPUSH
63740: PPUSH
63741: PPUSH
63742: PPUSH
63743: PPUSH
// if not mc_bases then
63744: LD_EXP 66
63748: NOT
63749: IFFALSE 63753
// exit ;
63751: GO 64521
// for i = 1 to mc_bases do
63753: LD_ADDR_VAR 0 2
63757: PUSH
63758: DOUBLE
63759: LD_INT 1
63761: DEC
63762: ST_TO_ADDR
63763: LD_EXP 66
63767: PUSH
63768: FOR_TO
63769: IFFALSE 64519
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63771: LD_EXP 79
63775: PUSH
63776: LD_VAR 0 2
63780: ARRAY
63781: NOT
63782: PUSH
63783: LD_EXP 79
63787: PUSH
63788: LD_VAR 0 2
63792: ARRAY
63793: PUSH
63794: LD_EXP 80
63798: PUSH
63799: LD_VAR 0 2
63803: ARRAY
63804: EQUAL
63805: OR
63806: PUSH
63807: LD_EXP 89
63811: PUSH
63812: LD_VAR 0 2
63816: ARRAY
63817: OR
63818: IFFALSE 63822
// continue ;
63820: GO 63768
// if mc_miners [ i ] then
63822: LD_EXP 80
63826: PUSH
63827: LD_VAR 0 2
63831: ARRAY
63832: IFFALSE 64206
// begin for j = mc_miners [ i ] downto 1 do
63834: LD_ADDR_VAR 0 3
63838: PUSH
63839: DOUBLE
63840: LD_EXP 80
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: INC
63851: ST_TO_ADDR
63852: LD_INT 1
63854: PUSH
63855: FOR_DOWNTO
63856: IFFALSE 64204
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63858: LD_EXP 80
63862: PUSH
63863: LD_VAR 0 2
63867: ARRAY
63868: PUSH
63869: LD_VAR 0 3
63873: ARRAY
63874: PPUSH
63875: CALL_OW 301
63879: PUSH
63880: LD_EXP 80
63884: PUSH
63885: LD_VAR 0 2
63889: ARRAY
63890: PUSH
63891: LD_VAR 0 3
63895: ARRAY
63896: PPUSH
63897: CALL_OW 257
63901: PUSH
63902: LD_INT 1
63904: NONEQUAL
63905: OR
63906: IFFALSE 63969
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63908: LD_ADDR_VAR 0 5
63912: PUSH
63913: LD_EXP 80
63917: PUSH
63918: LD_VAR 0 2
63922: ARRAY
63923: PUSH
63924: LD_EXP 80
63928: PUSH
63929: LD_VAR 0 2
63933: ARRAY
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: DIFF
63941: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63942: LD_ADDR_EXP 80
63946: PUSH
63947: LD_EXP 80
63951: PPUSH
63952: LD_VAR 0 2
63956: PPUSH
63957: LD_VAR 0 5
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// continue ;
63967: GO 63855
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63969: LD_EXP 80
63973: PUSH
63974: LD_VAR 0 2
63978: ARRAY
63979: PUSH
63980: LD_VAR 0 3
63984: ARRAY
63985: PPUSH
63986: CALL_OW 257
63990: PUSH
63991: LD_INT 1
63993: EQUAL
63994: PUSH
63995: LD_EXP 80
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PUSH
64006: LD_VAR 0 3
64010: ARRAY
64011: PPUSH
64012: CALL_OW 459
64016: NOT
64017: AND
64018: PUSH
64019: LD_EXP 80
64023: PUSH
64024: LD_VAR 0 2
64028: ARRAY
64029: PUSH
64030: LD_VAR 0 3
64034: ARRAY
64035: PPUSH
64036: CALL_OW 314
64040: NOT
64041: AND
64042: IFFALSE 64202
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64044: LD_EXP 80
64048: PUSH
64049: LD_VAR 0 2
64053: ARRAY
64054: PUSH
64055: LD_VAR 0 3
64059: ARRAY
64060: PPUSH
64061: CALL_OW 310
64065: IFFALSE 64088
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64067: LD_EXP 80
64071: PUSH
64072: LD_VAR 0 2
64076: ARRAY
64077: PUSH
64078: LD_VAR 0 3
64082: ARRAY
64083: PPUSH
64084: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64088: LD_EXP 80
64092: PUSH
64093: LD_VAR 0 2
64097: ARRAY
64098: PUSH
64099: LD_VAR 0 3
64103: ARRAY
64104: PPUSH
64105: CALL_OW 314
64109: NOT
64110: IFFALSE 64202
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64112: LD_ADDR_VAR 0 7
64116: PUSH
64117: LD_INT 1
64119: PPUSH
64120: LD_EXP 79
64124: PUSH
64125: LD_VAR 0 2
64129: ARRAY
64130: PPUSH
64131: CALL_OW 12
64135: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64136: LD_EXP 80
64140: PUSH
64141: LD_VAR 0 2
64145: ARRAY
64146: PUSH
64147: LD_VAR 0 3
64151: ARRAY
64152: PPUSH
64153: LD_EXP 79
64157: PUSH
64158: LD_VAR 0 2
64162: ARRAY
64163: PUSH
64164: LD_VAR 0 7
64168: ARRAY
64169: PUSH
64170: LD_INT 1
64172: ARRAY
64173: PPUSH
64174: LD_EXP 79
64178: PUSH
64179: LD_VAR 0 2
64183: ARRAY
64184: PUSH
64185: LD_VAR 0 7
64189: ARRAY
64190: PUSH
64191: LD_INT 2
64193: ARRAY
64194: PPUSH
64195: LD_INT 0
64197: PPUSH
64198: CALL_OW 193
// end ; end ; end ;
64202: GO 63855
64204: POP
64205: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64206: LD_ADDR_VAR 0 5
64210: PUSH
64211: LD_EXP 66
64215: PUSH
64216: LD_VAR 0 2
64220: ARRAY
64221: PPUSH
64222: LD_INT 2
64224: PUSH
64225: LD_INT 30
64227: PUSH
64228: LD_INT 4
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: LD_INT 30
64237: PUSH
64238: LD_INT 5
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 30
64247: PUSH
64248: LD_INT 32
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: PPUSH
64261: CALL_OW 72
64265: ST_TO_ADDR
// if not tmp then
64266: LD_VAR 0 5
64270: NOT
64271: IFFALSE 64275
// continue ;
64273: GO 63768
// list := [ ] ;
64275: LD_ADDR_VAR 0 6
64279: PUSH
64280: EMPTY
64281: ST_TO_ADDR
// for j in tmp do
64282: LD_ADDR_VAR 0 3
64286: PUSH
64287: LD_VAR 0 5
64291: PUSH
64292: FOR_IN
64293: IFFALSE 64362
// begin for k in UnitsInside ( j ) do
64295: LD_ADDR_VAR 0 4
64299: PUSH
64300: LD_VAR 0 3
64304: PPUSH
64305: CALL_OW 313
64309: PUSH
64310: FOR_IN
64311: IFFALSE 64358
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64313: LD_VAR 0 4
64317: PPUSH
64318: CALL_OW 257
64322: PUSH
64323: LD_INT 1
64325: EQUAL
64326: PUSH
64327: LD_VAR 0 4
64331: PPUSH
64332: CALL_OW 459
64336: NOT
64337: AND
64338: IFFALSE 64356
// list := list ^ k ;
64340: LD_ADDR_VAR 0 6
64344: PUSH
64345: LD_VAR 0 6
64349: PUSH
64350: LD_VAR 0 4
64354: ADD
64355: ST_TO_ADDR
64356: GO 64310
64358: POP
64359: POP
// end ;
64360: GO 64292
64362: POP
64363: POP
// list := list diff mc_miners [ i ] ;
64364: LD_ADDR_VAR 0 6
64368: PUSH
64369: LD_VAR 0 6
64373: PUSH
64374: LD_EXP 80
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: DIFF
64385: ST_TO_ADDR
// if not list then
64386: LD_VAR 0 6
64390: NOT
64391: IFFALSE 64395
// continue ;
64393: GO 63768
// k := mc_mines [ i ] - mc_miners [ i ] ;
64395: LD_ADDR_VAR 0 4
64399: PUSH
64400: LD_EXP 79
64404: PUSH
64405: LD_VAR 0 2
64409: ARRAY
64410: PUSH
64411: LD_EXP 80
64415: PUSH
64416: LD_VAR 0 2
64420: ARRAY
64421: MINUS
64422: ST_TO_ADDR
// if k > list then
64423: LD_VAR 0 4
64427: PUSH
64428: LD_VAR 0 6
64432: GREATER
64433: IFFALSE 64445
// k := list ;
64435: LD_ADDR_VAR 0 4
64439: PUSH
64440: LD_VAR 0 6
64444: ST_TO_ADDR
// for j = 1 to k do
64445: LD_ADDR_VAR 0 3
64449: PUSH
64450: DOUBLE
64451: LD_INT 1
64453: DEC
64454: ST_TO_ADDR
64455: LD_VAR 0 4
64459: PUSH
64460: FOR_TO
64461: IFFALSE 64515
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64463: LD_ADDR_EXP 80
64467: PUSH
64468: LD_EXP 80
64472: PPUSH
64473: LD_VAR 0 2
64477: PUSH
64478: LD_EXP 80
64482: PUSH
64483: LD_VAR 0 2
64487: ARRAY
64488: PUSH
64489: LD_INT 1
64491: PLUS
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PPUSH
64497: LD_VAR 0 6
64501: PUSH
64502: LD_VAR 0 3
64506: ARRAY
64507: PPUSH
64508: CALL 18548 0 3
64512: ST_TO_ADDR
64513: GO 64460
64515: POP
64516: POP
// end ;
64517: GO 63768
64519: POP
64520: POP
// end ;
64521: LD_VAR 0 1
64525: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
64526: LD_INT 0
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
64536: PPUSH
64537: PPUSH
// if not mc_bases then
64538: LD_EXP 66
64542: NOT
64543: IFFALSE 64547
// exit ;
64545: GO 66297
// for i = 1 to mc_bases do
64547: LD_ADDR_VAR 0 2
64551: PUSH
64552: DOUBLE
64553: LD_INT 1
64555: DEC
64556: ST_TO_ADDR
64557: LD_EXP 66
64561: PUSH
64562: FOR_TO
64563: IFFALSE 66295
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64565: LD_EXP 66
64569: PUSH
64570: LD_VAR 0 2
64574: ARRAY
64575: NOT
64576: PUSH
64577: LD_EXP 73
64581: PUSH
64582: LD_VAR 0 2
64586: ARRAY
64587: OR
64588: IFFALSE 64592
// continue ;
64590: GO 64562
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64592: LD_EXP 82
64596: PUSH
64597: LD_VAR 0 2
64601: ARRAY
64602: NOT
64603: PUSH
64604: LD_EXP 83
64608: PUSH
64609: LD_VAR 0 2
64613: ARRAY
64614: AND
64615: IFFALSE 64653
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64617: LD_ADDR_EXP 83
64621: PUSH
64622: LD_EXP 83
64626: PPUSH
64627: LD_VAR 0 2
64631: PPUSH
64632: EMPTY
64633: PPUSH
64634: CALL_OW 1
64638: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64639: LD_VAR 0 2
64643: PPUSH
64644: LD_INT 107
64646: PPUSH
64647: CALL 55480 0 2
// continue ;
64651: GO 64562
// end ; target := [ ] ;
64653: LD_ADDR_VAR 0 6
64657: PUSH
64658: EMPTY
64659: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64660: LD_ADDR_VAR 0 3
64664: PUSH
64665: DOUBLE
64666: LD_EXP 82
64670: PUSH
64671: LD_VAR 0 2
64675: ARRAY
64676: INC
64677: ST_TO_ADDR
64678: LD_INT 1
64680: PUSH
64681: FOR_DOWNTO
64682: IFFALSE 64942
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64684: LD_EXP 82
64688: PUSH
64689: LD_VAR 0 2
64693: ARRAY
64694: PUSH
64695: LD_VAR 0 3
64699: ARRAY
64700: PUSH
64701: LD_INT 2
64703: ARRAY
64704: PPUSH
64705: LD_EXP 82
64709: PUSH
64710: LD_VAR 0 2
64714: ARRAY
64715: PUSH
64716: LD_VAR 0 3
64720: ARRAY
64721: PUSH
64722: LD_INT 3
64724: ARRAY
64725: PPUSH
64726: CALL_OW 488
64730: PUSH
64731: LD_EXP 82
64735: PUSH
64736: LD_VAR 0 2
64740: ARRAY
64741: PUSH
64742: LD_VAR 0 3
64746: ARRAY
64747: PUSH
64748: LD_INT 2
64750: ARRAY
64751: PPUSH
64752: LD_EXP 82
64756: PUSH
64757: LD_VAR 0 2
64761: ARRAY
64762: PUSH
64763: LD_VAR 0 3
64767: ARRAY
64768: PUSH
64769: LD_INT 3
64771: ARRAY
64772: PPUSH
64773: CALL_OW 284
64777: PUSH
64778: LD_INT 0
64780: EQUAL
64781: AND
64782: IFFALSE 64837
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64784: LD_ADDR_VAR 0 5
64788: PUSH
64789: LD_EXP 82
64793: PUSH
64794: LD_VAR 0 2
64798: ARRAY
64799: PPUSH
64800: LD_VAR 0 3
64804: PPUSH
64805: CALL_OW 3
64809: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64810: LD_ADDR_EXP 82
64814: PUSH
64815: LD_EXP 82
64819: PPUSH
64820: LD_VAR 0 2
64824: PPUSH
64825: LD_VAR 0 5
64829: PPUSH
64830: CALL_OW 1
64834: ST_TO_ADDR
// continue ;
64835: GO 64681
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64837: LD_EXP 66
64841: PUSH
64842: LD_VAR 0 2
64846: ARRAY
64847: PUSH
64848: LD_INT 1
64850: ARRAY
64851: PPUSH
64852: CALL_OW 255
64856: PPUSH
64857: LD_EXP 82
64861: PUSH
64862: LD_VAR 0 2
64866: ARRAY
64867: PUSH
64868: LD_VAR 0 3
64872: ARRAY
64873: PUSH
64874: LD_INT 2
64876: ARRAY
64877: PPUSH
64878: LD_EXP 82
64882: PUSH
64883: LD_VAR 0 2
64887: ARRAY
64888: PUSH
64889: LD_VAR 0 3
64893: ARRAY
64894: PUSH
64895: LD_INT 3
64897: ARRAY
64898: PPUSH
64899: LD_INT 30
64901: PPUSH
64902: CALL 19444 0 4
64906: PUSH
64907: LD_INT 4
64909: ARRAY
64910: PUSH
64911: LD_INT 0
64913: EQUAL
64914: IFFALSE 64940
// begin target := mc_crates [ i ] [ j ] ;
64916: LD_ADDR_VAR 0 6
64920: PUSH
64921: LD_EXP 82
64925: PUSH
64926: LD_VAR 0 2
64930: ARRAY
64931: PUSH
64932: LD_VAR 0 3
64936: ARRAY
64937: ST_TO_ADDR
// break ;
64938: GO 64942
// end ; end ;
64940: GO 64681
64942: POP
64943: POP
// if not target then
64944: LD_VAR 0 6
64948: NOT
64949: IFFALSE 64953
// continue ;
64951: GO 64562
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64953: LD_ADDR_VAR 0 7
64957: PUSH
64958: LD_EXP 85
64962: PUSH
64963: LD_VAR 0 2
64967: ARRAY
64968: PPUSH
64969: LD_INT 2
64971: PUSH
64972: LD_INT 3
64974: PUSH
64975: LD_INT 58
64977: PUSH
64978: EMPTY
64979: LIST
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 61
64987: PUSH
64988: EMPTY
64989: LIST
64990: PUSH
64991: LD_INT 33
64993: PUSH
64994: LD_INT 5
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PUSH
65001: LD_INT 33
65003: PUSH
65004: LD_INT 3
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 2
65020: PUSH
65021: LD_INT 34
65023: PUSH
65024: LD_INT 32
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 34
65033: PUSH
65034: LD_INT 51
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 34
65043: PUSH
65044: LD_INT 12
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: LIST
65055: LIST
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: PPUSH
65061: CALL_OW 72
65065: ST_TO_ADDR
// if not cargo then
65066: LD_VAR 0 7
65070: NOT
65071: IFFALSE 65714
// begin if mc_crates_collector [ i ] < 5 then
65073: LD_EXP 83
65077: PUSH
65078: LD_VAR 0 2
65082: ARRAY
65083: PUSH
65084: LD_INT 5
65086: LESS
65087: IFFALSE 65453
// begin if mc_ape [ i ] then
65089: LD_EXP 95
65093: PUSH
65094: LD_VAR 0 2
65098: ARRAY
65099: IFFALSE 65146
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65101: LD_ADDR_VAR 0 5
65105: PUSH
65106: LD_EXP 95
65110: PUSH
65111: LD_VAR 0 2
65115: ARRAY
65116: PPUSH
65117: LD_INT 25
65119: PUSH
65120: LD_INT 16
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: LD_INT 24
65129: PUSH
65130: LD_INT 750
65132: PUSH
65133: EMPTY
65134: LIST
65135: LIST
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PPUSH
65141: CALL_OW 72
65145: ST_TO_ADDR
// if not tmp then
65146: LD_VAR 0 5
65150: NOT
65151: IFFALSE 65198
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65153: LD_ADDR_VAR 0 5
65157: PUSH
65158: LD_EXP 66
65162: PUSH
65163: LD_VAR 0 2
65167: ARRAY
65168: PPUSH
65169: LD_INT 25
65171: PUSH
65172: LD_INT 2
65174: PUSH
65175: EMPTY
65176: LIST
65177: LIST
65178: PUSH
65179: LD_INT 24
65181: PUSH
65182: LD_INT 750
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PPUSH
65193: CALL_OW 72
65197: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65198: LD_EXP 95
65202: PUSH
65203: LD_VAR 0 2
65207: ARRAY
65208: PUSH
65209: LD_EXP 66
65213: PUSH
65214: LD_VAR 0 2
65218: ARRAY
65219: PPUSH
65220: LD_INT 25
65222: PUSH
65223: LD_INT 2
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 24
65232: PUSH
65233: LD_INT 750
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: PPUSH
65244: CALL_OW 72
65248: AND
65249: PUSH
65250: LD_VAR 0 5
65254: PUSH
65255: LD_INT 5
65257: LESS
65258: AND
65259: IFFALSE 65341
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65261: LD_ADDR_VAR 0 3
65265: PUSH
65266: LD_EXP 66
65270: PUSH
65271: LD_VAR 0 2
65275: ARRAY
65276: PPUSH
65277: LD_INT 25
65279: PUSH
65280: LD_INT 2
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 24
65289: PUSH
65290: LD_INT 750
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PPUSH
65301: CALL_OW 72
65305: PUSH
65306: FOR_IN
65307: IFFALSE 65339
// begin tmp := tmp union j ;
65309: LD_ADDR_VAR 0 5
65313: PUSH
65314: LD_VAR 0 5
65318: PUSH
65319: LD_VAR 0 3
65323: UNION
65324: ST_TO_ADDR
// if tmp >= 5 then
65325: LD_VAR 0 5
65329: PUSH
65330: LD_INT 5
65332: GREATEREQUAL
65333: IFFALSE 65337
// break ;
65335: GO 65339
// end ;
65337: GO 65306
65339: POP
65340: POP
// end ; if not tmp then
65341: LD_VAR 0 5
65345: NOT
65346: IFFALSE 65350
// continue ;
65348: GO 64562
// for j in tmp do
65350: LD_ADDR_VAR 0 3
65354: PUSH
65355: LD_VAR 0 5
65359: PUSH
65360: FOR_IN
65361: IFFALSE 65451
// if not GetTag ( j ) then
65363: LD_VAR 0 3
65367: PPUSH
65368: CALL_OW 110
65372: NOT
65373: IFFALSE 65449
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65375: LD_ADDR_EXP 83
65379: PUSH
65380: LD_EXP 83
65384: PPUSH
65385: LD_VAR 0 2
65389: PUSH
65390: LD_EXP 83
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: PUSH
65401: LD_INT 1
65403: PLUS
65404: PUSH
65405: EMPTY
65406: LIST
65407: LIST
65408: PPUSH
65409: LD_VAR 0 3
65413: PPUSH
65414: CALL 18548 0 3
65418: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65419: LD_VAR 0 3
65423: PPUSH
65424: LD_INT 107
65426: PPUSH
65427: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65431: LD_EXP 83
65435: PUSH
65436: LD_VAR 0 2
65440: ARRAY
65441: PUSH
65442: LD_INT 5
65444: GREATEREQUAL
65445: IFFALSE 65449
// break ;
65447: GO 65451
// end ;
65449: GO 65360
65451: POP
65452: POP
// end ; if mc_crates_collector [ i ] and target then
65453: LD_EXP 83
65457: PUSH
65458: LD_VAR 0 2
65462: ARRAY
65463: PUSH
65464: LD_VAR 0 6
65468: AND
65469: IFFALSE 65712
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65471: LD_EXP 83
65475: PUSH
65476: LD_VAR 0 2
65480: ARRAY
65481: PUSH
65482: LD_VAR 0 6
65486: PUSH
65487: LD_INT 1
65489: ARRAY
65490: LESS
65491: IFFALSE 65511
// tmp := mc_crates_collector [ i ] else
65493: LD_ADDR_VAR 0 5
65497: PUSH
65498: LD_EXP 83
65502: PUSH
65503: LD_VAR 0 2
65507: ARRAY
65508: ST_TO_ADDR
65509: GO 65525
// tmp := target [ 1 ] ;
65511: LD_ADDR_VAR 0 5
65515: PUSH
65516: LD_VAR 0 6
65520: PUSH
65521: LD_INT 1
65523: ARRAY
65524: ST_TO_ADDR
// k := 0 ;
65525: LD_ADDR_VAR 0 4
65529: PUSH
65530: LD_INT 0
65532: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65533: LD_ADDR_VAR 0 3
65537: PUSH
65538: LD_EXP 83
65542: PUSH
65543: LD_VAR 0 2
65547: ARRAY
65548: PUSH
65549: FOR_IN
65550: IFFALSE 65710
// begin k := k + 1 ;
65552: LD_ADDR_VAR 0 4
65556: PUSH
65557: LD_VAR 0 4
65561: PUSH
65562: LD_INT 1
65564: PLUS
65565: ST_TO_ADDR
// if k > tmp then
65566: LD_VAR 0 4
65570: PUSH
65571: LD_VAR 0 5
65575: GREATER
65576: IFFALSE 65580
// break ;
65578: GO 65710
// if not GetClass ( j ) in [ 2 , 16 ] then
65580: LD_VAR 0 3
65584: PPUSH
65585: CALL_OW 257
65589: PUSH
65590: LD_INT 2
65592: PUSH
65593: LD_INT 16
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: IN
65600: NOT
65601: IFFALSE 65654
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65603: LD_ADDR_EXP 83
65607: PUSH
65608: LD_EXP 83
65612: PPUSH
65613: LD_VAR 0 2
65617: PPUSH
65618: LD_EXP 83
65622: PUSH
65623: LD_VAR 0 2
65627: ARRAY
65628: PUSH
65629: LD_VAR 0 3
65633: DIFF
65634: PPUSH
65635: CALL_OW 1
65639: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65640: LD_VAR 0 3
65644: PPUSH
65645: LD_INT 0
65647: PPUSH
65648: CALL_OW 109
// continue ;
65652: GO 65549
// end ; if IsInUnit ( j ) then
65654: LD_VAR 0 3
65658: PPUSH
65659: CALL_OW 310
65663: IFFALSE 65674
// ComExitBuilding ( j ) ;
65665: LD_VAR 0 3
65669: PPUSH
65670: CALL_OW 122
// wait ( 3 ) ;
65674: LD_INT 3
65676: PPUSH
65677: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65681: LD_VAR 0 3
65685: PPUSH
65686: LD_VAR 0 6
65690: PUSH
65691: LD_INT 2
65693: ARRAY
65694: PPUSH
65695: LD_VAR 0 6
65699: PUSH
65700: LD_INT 3
65702: ARRAY
65703: PPUSH
65704: CALL_OW 117
// end ;
65708: GO 65549
65710: POP
65711: POP
// end ; end else
65712: GO 66293
// begin for j in cargo do
65714: LD_ADDR_VAR 0 3
65718: PUSH
65719: LD_VAR 0 7
65723: PUSH
65724: FOR_IN
65725: IFFALSE 66291
// begin if GetTag ( j ) <> 0 then
65727: LD_VAR 0 3
65731: PPUSH
65732: CALL_OW 110
65736: PUSH
65737: LD_INT 0
65739: NONEQUAL
65740: IFFALSE 65744
// continue ;
65742: GO 65724
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65744: LD_VAR 0 3
65748: PPUSH
65749: CALL_OW 256
65753: PUSH
65754: LD_INT 1000
65756: LESS
65757: PUSH
65758: LD_VAR 0 3
65762: PPUSH
65763: LD_EXP 90
65767: PUSH
65768: LD_VAR 0 2
65772: ARRAY
65773: PPUSH
65774: CALL_OW 308
65778: NOT
65779: AND
65780: IFFALSE 65802
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65782: LD_VAR 0 3
65786: PPUSH
65787: LD_EXP 90
65791: PUSH
65792: LD_VAR 0 2
65796: ARRAY
65797: PPUSH
65798: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65802: LD_VAR 0 3
65806: PPUSH
65807: CALL_OW 256
65811: PUSH
65812: LD_INT 1000
65814: LESS
65815: PUSH
65816: LD_VAR 0 3
65820: PPUSH
65821: LD_EXP 90
65825: PUSH
65826: LD_VAR 0 2
65830: ARRAY
65831: PPUSH
65832: CALL_OW 308
65836: AND
65837: IFFALSE 65841
// continue ;
65839: GO 65724
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65841: LD_VAR 0 3
65845: PPUSH
65846: CALL_OW 262
65850: PUSH
65851: LD_INT 2
65853: EQUAL
65854: PUSH
65855: LD_VAR 0 3
65859: PPUSH
65860: CALL_OW 261
65864: PUSH
65865: LD_INT 15
65867: LESS
65868: AND
65869: IFFALSE 65873
// continue ;
65871: GO 65724
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65873: LD_VAR 0 3
65877: PPUSH
65878: CALL_OW 262
65882: PUSH
65883: LD_INT 1
65885: EQUAL
65886: PUSH
65887: LD_VAR 0 3
65891: PPUSH
65892: CALL_OW 261
65896: PUSH
65897: LD_INT 10
65899: LESS
65900: AND
65901: IFFALSE 66230
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65903: LD_ADDR_VAR 0 8
65907: PUSH
65908: LD_EXP 66
65912: PUSH
65913: LD_VAR 0 2
65917: ARRAY
65918: PPUSH
65919: LD_INT 2
65921: PUSH
65922: LD_INT 30
65924: PUSH
65925: LD_INT 0
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 30
65934: PUSH
65935: LD_INT 1
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: EMPTY
65943: LIST
65944: LIST
65945: LIST
65946: PPUSH
65947: CALL_OW 72
65951: ST_TO_ADDR
// if not depot then
65952: LD_VAR 0 8
65956: NOT
65957: IFFALSE 65961
// continue ;
65959: GO 65724
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65961: LD_VAR 0 3
65965: PPUSH
65966: LD_VAR 0 8
65970: PPUSH
65971: LD_VAR 0 3
65975: PPUSH
65976: CALL_OW 74
65980: PPUSH
65981: CALL_OW 296
65985: PUSH
65986: LD_INT 6
65988: LESS
65989: IFFALSE 66005
// SetFuel ( j , 100 ) else
65991: LD_VAR 0 3
65995: PPUSH
65996: LD_INT 100
65998: PPUSH
65999: CALL_OW 240
66003: GO 66230
// if GetFuel ( j ) = 0 then
66005: LD_VAR 0 3
66009: PPUSH
66010: CALL_OW 261
66014: PUSH
66015: LD_INT 0
66017: EQUAL
66018: IFFALSE 66230
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66020: LD_ADDR_EXP 85
66024: PUSH
66025: LD_EXP 85
66029: PPUSH
66030: LD_VAR 0 2
66034: PPUSH
66035: LD_EXP 85
66039: PUSH
66040: LD_VAR 0 2
66044: ARRAY
66045: PUSH
66046: LD_VAR 0 3
66050: DIFF
66051: PPUSH
66052: CALL_OW 1
66056: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66057: LD_VAR 0 3
66061: PPUSH
66062: CALL_OW 263
66066: PUSH
66067: LD_INT 1
66069: EQUAL
66070: IFFALSE 66086
// ComExitVehicle ( IsInUnit ( j ) ) ;
66072: LD_VAR 0 3
66076: PPUSH
66077: CALL_OW 310
66081: PPUSH
66082: CALL_OW 121
// if GetControl ( j ) = control_remote then
66086: LD_VAR 0 3
66090: PPUSH
66091: CALL_OW 263
66095: PUSH
66096: LD_INT 2
66098: EQUAL
66099: IFFALSE 66110
// ComUnlink ( j ) ;
66101: LD_VAR 0 3
66105: PPUSH
66106: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66110: LD_ADDR_VAR 0 9
66114: PUSH
66115: LD_VAR 0 2
66119: PPUSH
66120: LD_INT 3
66122: PPUSH
66123: CALL 75605 0 2
66127: ST_TO_ADDR
// if fac then
66128: LD_VAR 0 9
66132: IFFALSE 66228
// begin for k in fac do
66134: LD_ADDR_VAR 0 4
66138: PUSH
66139: LD_VAR 0 9
66143: PUSH
66144: FOR_IN
66145: IFFALSE 66226
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66147: LD_ADDR_VAR 0 10
66151: PUSH
66152: LD_VAR 0 9
66156: PPUSH
66157: LD_VAR 0 3
66161: PPUSH
66162: CALL_OW 265
66166: PPUSH
66167: LD_VAR 0 3
66171: PPUSH
66172: CALL_OW 262
66176: PPUSH
66177: LD_VAR 0 3
66181: PPUSH
66182: CALL_OW 263
66186: PPUSH
66187: LD_VAR 0 3
66191: PPUSH
66192: CALL_OW 264
66196: PPUSH
66197: CALL 16080 0 5
66201: ST_TO_ADDR
// if components then
66202: LD_VAR 0 10
66206: IFFALSE 66224
// begin MC_InsertProduceList ( i , components ) ;
66208: LD_VAR 0 2
66212: PPUSH
66213: LD_VAR 0 10
66217: PPUSH
66218: CALL 75150 0 2
// break ;
66222: GO 66226
// end ; end ;
66224: GO 66144
66226: POP
66227: POP
// end ; continue ;
66228: GO 65724
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66230: LD_VAR 0 3
66234: PPUSH
66235: LD_INT 1
66237: PPUSH
66238: CALL_OW 289
66242: PUSH
66243: LD_INT 100
66245: LESS
66246: PUSH
66247: LD_VAR 0 3
66251: PPUSH
66252: CALL_OW 314
66256: NOT
66257: AND
66258: IFFALSE 66287
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66260: LD_VAR 0 3
66264: PPUSH
66265: LD_VAR 0 6
66269: PUSH
66270: LD_INT 2
66272: ARRAY
66273: PPUSH
66274: LD_VAR 0 6
66278: PUSH
66279: LD_INT 3
66281: ARRAY
66282: PPUSH
66283: CALL_OW 117
// break ;
66287: GO 66291
// end ;
66289: GO 65724
66291: POP
66292: POP
// end ; end ;
66293: GO 64562
66295: POP
66296: POP
// end ;
66297: LD_VAR 0 1
66301: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66302: LD_INT 0
66304: PPUSH
66305: PPUSH
66306: PPUSH
66307: PPUSH
// if not mc_bases then
66308: LD_EXP 66
66312: NOT
66313: IFFALSE 66317
// exit ;
66315: GO 66478
// for i = 1 to mc_bases do
66317: LD_ADDR_VAR 0 2
66321: PUSH
66322: DOUBLE
66323: LD_INT 1
66325: DEC
66326: ST_TO_ADDR
66327: LD_EXP 66
66331: PUSH
66332: FOR_TO
66333: IFFALSE 66476
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66335: LD_ADDR_VAR 0 4
66339: PUSH
66340: LD_EXP 85
66344: PUSH
66345: LD_VAR 0 2
66349: ARRAY
66350: PUSH
66351: LD_EXP 88
66355: PUSH
66356: LD_VAR 0 2
66360: ARRAY
66361: UNION
66362: PPUSH
66363: LD_INT 33
66365: PUSH
66366: LD_INT 2
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: PPUSH
66373: CALL_OW 72
66377: ST_TO_ADDR
// if tmp then
66378: LD_VAR 0 4
66382: IFFALSE 66474
// for j in tmp do
66384: LD_ADDR_VAR 0 3
66388: PUSH
66389: LD_VAR 0 4
66393: PUSH
66394: FOR_IN
66395: IFFALSE 66472
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66397: LD_VAR 0 3
66401: PPUSH
66402: CALL_OW 312
66406: NOT
66407: PUSH
66408: LD_VAR 0 3
66412: PPUSH
66413: CALL_OW 256
66417: PUSH
66418: LD_INT 250
66420: GREATEREQUAL
66421: AND
66422: IFFALSE 66435
// Connect ( j ) else
66424: LD_VAR 0 3
66428: PPUSH
66429: CALL 21513 0 1
66433: GO 66470
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66435: LD_VAR 0 3
66439: PPUSH
66440: CALL_OW 256
66444: PUSH
66445: LD_INT 250
66447: LESS
66448: PUSH
66449: LD_VAR 0 3
66453: PPUSH
66454: CALL_OW 312
66458: AND
66459: IFFALSE 66470
// ComUnlink ( j ) ;
66461: LD_VAR 0 3
66465: PPUSH
66466: CALL_OW 136
66470: GO 66394
66472: POP
66473: POP
// end ;
66474: GO 66332
66476: POP
66477: POP
// end ;
66478: LD_VAR 0 1
66482: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66483: LD_INT 0
66485: PPUSH
66486: PPUSH
66487: PPUSH
66488: PPUSH
66489: PPUSH
// if not mc_bases then
66490: LD_EXP 66
66494: NOT
66495: IFFALSE 66499
// exit ;
66497: GO 66944
// for i = 1 to mc_bases do
66499: LD_ADDR_VAR 0 2
66503: PUSH
66504: DOUBLE
66505: LD_INT 1
66507: DEC
66508: ST_TO_ADDR
66509: LD_EXP 66
66513: PUSH
66514: FOR_TO
66515: IFFALSE 66942
// begin if not mc_produce [ i ] then
66517: LD_EXP 87
66521: PUSH
66522: LD_VAR 0 2
66526: ARRAY
66527: NOT
66528: IFFALSE 66532
// continue ;
66530: GO 66514
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66532: LD_ADDR_VAR 0 5
66536: PUSH
66537: LD_EXP 66
66541: PUSH
66542: LD_VAR 0 2
66546: ARRAY
66547: PPUSH
66548: LD_INT 30
66550: PUSH
66551: LD_INT 3
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PPUSH
66558: CALL_OW 72
66562: ST_TO_ADDR
// if not fac then
66563: LD_VAR 0 5
66567: NOT
66568: IFFALSE 66572
// continue ;
66570: GO 66514
// for j in fac do
66572: LD_ADDR_VAR 0 3
66576: PUSH
66577: LD_VAR 0 5
66581: PUSH
66582: FOR_IN
66583: IFFALSE 66938
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66585: LD_VAR 0 3
66589: PPUSH
66590: CALL_OW 461
66594: PUSH
66595: LD_INT 2
66597: NONEQUAL
66598: PUSH
66599: LD_VAR 0 3
66603: PPUSH
66604: LD_INT 15
66606: PPUSH
66607: CALL 21141 0 2
66611: PUSH
66612: LD_INT 4
66614: ARRAY
66615: OR
66616: IFFALSE 66620
// continue ;
66618: GO 66582
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66620: LD_VAR 0 3
66624: PPUSH
66625: LD_EXP 87
66629: PUSH
66630: LD_VAR 0 2
66634: ARRAY
66635: PUSH
66636: LD_INT 1
66638: ARRAY
66639: PUSH
66640: LD_INT 1
66642: ARRAY
66643: PPUSH
66644: LD_EXP 87
66648: PUSH
66649: LD_VAR 0 2
66653: ARRAY
66654: PUSH
66655: LD_INT 1
66657: ARRAY
66658: PUSH
66659: LD_INT 2
66661: ARRAY
66662: PPUSH
66663: LD_EXP 87
66667: PUSH
66668: LD_VAR 0 2
66672: ARRAY
66673: PUSH
66674: LD_INT 1
66676: ARRAY
66677: PUSH
66678: LD_INT 3
66680: ARRAY
66681: PPUSH
66682: LD_EXP 87
66686: PUSH
66687: LD_VAR 0 2
66691: ARRAY
66692: PUSH
66693: LD_INT 1
66695: ARRAY
66696: PUSH
66697: LD_INT 4
66699: ARRAY
66700: PPUSH
66701: CALL_OW 448
66705: PUSH
66706: LD_VAR 0 3
66710: PPUSH
66711: LD_EXP 87
66715: PUSH
66716: LD_VAR 0 2
66720: ARRAY
66721: PUSH
66722: LD_INT 1
66724: ARRAY
66725: PUSH
66726: LD_INT 1
66728: ARRAY
66729: PUSH
66730: LD_EXP 87
66734: PUSH
66735: LD_VAR 0 2
66739: ARRAY
66740: PUSH
66741: LD_INT 1
66743: ARRAY
66744: PUSH
66745: LD_INT 2
66747: ARRAY
66748: PUSH
66749: LD_EXP 87
66753: PUSH
66754: LD_VAR 0 2
66758: ARRAY
66759: PUSH
66760: LD_INT 1
66762: ARRAY
66763: PUSH
66764: LD_INT 3
66766: ARRAY
66767: PUSH
66768: LD_EXP 87
66772: PUSH
66773: LD_VAR 0 2
66777: ARRAY
66778: PUSH
66779: LD_INT 1
66781: ARRAY
66782: PUSH
66783: LD_INT 4
66785: ARRAY
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: PPUSH
66793: CALL 24939 0 2
66797: AND
66798: IFFALSE 66936
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66800: LD_VAR 0 3
66804: PPUSH
66805: LD_EXP 87
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: PUSH
66816: LD_INT 1
66818: ARRAY
66819: PUSH
66820: LD_INT 1
66822: ARRAY
66823: PPUSH
66824: LD_EXP 87
66828: PUSH
66829: LD_VAR 0 2
66833: ARRAY
66834: PUSH
66835: LD_INT 1
66837: ARRAY
66838: PUSH
66839: LD_INT 2
66841: ARRAY
66842: PPUSH
66843: LD_EXP 87
66847: PUSH
66848: LD_VAR 0 2
66852: ARRAY
66853: PUSH
66854: LD_INT 1
66856: ARRAY
66857: PUSH
66858: LD_INT 3
66860: ARRAY
66861: PPUSH
66862: LD_EXP 87
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: PUSH
66873: LD_INT 1
66875: ARRAY
66876: PUSH
66877: LD_INT 4
66879: ARRAY
66880: PPUSH
66881: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66885: LD_ADDR_VAR 0 4
66889: PUSH
66890: LD_EXP 87
66894: PUSH
66895: LD_VAR 0 2
66899: ARRAY
66900: PPUSH
66901: LD_INT 1
66903: PPUSH
66904: CALL_OW 3
66908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66909: LD_ADDR_EXP 87
66913: PUSH
66914: LD_EXP 87
66918: PPUSH
66919: LD_VAR 0 2
66923: PPUSH
66924: LD_VAR 0 4
66928: PPUSH
66929: CALL_OW 1
66933: ST_TO_ADDR
// break ;
66934: GO 66938
// end ; end ;
66936: GO 66582
66938: POP
66939: POP
// end ;
66940: GO 66514
66942: POP
66943: POP
// end ;
66944: LD_VAR 0 1
66948: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66949: LD_INT 0
66951: PPUSH
66952: PPUSH
66953: PPUSH
// if not mc_bases then
66954: LD_EXP 66
66958: NOT
66959: IFFALSE 66963
// exit ;
66961: GO 67052
// for i = 1 to mc_bases do
66963: LD_ADDR_VAR 0 2
66967: PUSH
66968: DOUBLE
66969: LD_INT 1
66971: DEC
66972: ST_TO_ADDR
66973: LD_EXP 66
66977: PUSH
66978: FOR_TO
66979: IFFALSE 67050
// begin if mc_attack [ i ] then
66981: LD_EXP 86
66985: PUSH
66986: LD_VAR 0 2
66990: ARRAY
66991: IFFALSE 67048
// begin tmp := mc_attack [ i ] [ 1 ] ;
66993: LD_ADDR_VAR 0 3
66997: PUSH
66998: LD_EXP 86
67002: PUSH
67003: LD_VAR 0 2
67007: ARRAY
67008: PUSH
67009: LD_INT 1
67011: ARRAY
67012: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67013: LD_ADDR_EXP 86
67017: PUSH
67018: LD_EXP 86
67022: PPUSH
67023: LD_VAR 0 2
67027: PPUSH
67028: EMPTY
67029: PPUSH
67030: CALL_OW 1
67034: ST_TO_ADDR
// Attack ( tmp ) ;
67035: LD_VAR 0 3
67039: PPUSH
67040: CALL 98695 0 1
// exit ;
67044: POP
67045: POP
67046: GO 67052
// end ; end ;
67048: GO 66978
67050: POP
67051: POP
// end ;
67052: LD_VAR 0 1
67056: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67057: LD_INT 0
67059: PPUSH
67060: PPUSH
67061: PPUSH
67062: PPUSH
67063: PPUSH
67064: PPUSH
67065: PPUSH
// if not mc_bases then
67066: LD_EXP 66
67070: NOT
67071: IFFALSE 67075
// exit ;
67073: GO 67679
// for i = 1 to mc_bases do
67075: LD_ADDR_VAR 0 2
67079: PUSH
67080: DOUBLE
67081: LD_INT 1
67083: DEC
67084: ST_TO_ADDR
67085: LD_EXP 66
67089: PUSH
67090: FOR_TO
67091: IFFALSE 67677
// begin if not mc_bases [ i ] then
67093: LD_EXP 66
67097: PUSH
67098: LD_VAR 0 2
67102: ARRAY
67103: NOT
67104: IFFALSE 67108
// continue ;
67106: GO 67090
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67108: LD_ADDR_VAR 0 7
67112: PUSH
67113: LD_EXP 66
67117: PUSH
67118: LD_VAR 0 2
67122: ARRAY
67123: PUSH
67124: LD_INT 1
67126: ARRAY
67127: PPUSH
67128: CALL 15384 0 1
67132: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67133: LD_ADDR_EXP 89
67137: PUSH
67138: LD_EXP 89
67142: PPUSH
67143: LD_VAR 0 2
67147: PPUSH
67148: LD_EXP 66
67152: PUSH
67153: LD_VAR 0 2
67157: ARRAY
67158: PUSH
67159: LD_INT 1
67161: ARRAY
67162: PPUSH
67163: CALL_OW 255
67167: PPUSH
67168: LD_EXP 91
67172: PUSH
67173: LD_VAR 0 2
67177: ARRAY
67178: PPUSH
67179: CALL 15349 0 2
67183: PPUSH
67184: CALL_OW 1
67188: ST_TO_ADDR
// if not mc_scan [ i ] then
67189: LD_EXP 89
67193: PUSH
67194: LD_VAR 0 2
67198: ARRAY
67199: NOT
67200: IFFALSE 67355
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67202: LD_ADDR_VAR 0 4
67206: PUSH
67207: LD_EXP 66
67211: PUSH
67212: LD_VAR 0 2
67216: ARRAY
67217: PPUSH
67218: LD_INT 2
67220: PUSH
67221: LD_INT 25
67223: PUSH
67224: LD_INT 5
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 25
67233: PUSH
67234: LD_INT 8
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 25
67243: PUSH
67244: LD_INT 9
67246: PUSH
67247: EMPTY
67248: LIST
67249: LIST
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: LIST
67255: LIST
67256: PPUSH
67257: CALL_OW 72
67261: ST_TO_ADDR
// if not tmp then
67262: LD_VAR 0 4
67266: NOT
67267: IFFALSE 67271
// continue ;
67269: GO 67090
// for j in tmp do
67271: LD_ADDR_VAR 0 3
67275: PUSH
67276: LD_VAR 0 4
67280: PUSH
67281: FOR_IN
67282: IFFALSE 67353
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67284: LD_VAR 0 3
67288: PPUSH
67289: CALL_OW 310
67293: PPUSH
67294: CALL_OW 266
67298: PUSH
67299: LD_INT 5
67301: EQUAL
67302: PUSH
67303: LD_VAR 0 3
67307: PPUSH
67308: CALL_OW 257
67312: PUSH
67313: LD_INT 1
67315: EQUAL
67316: AND
67317: PUSH
67318: LD_VAR 0 3
67322: PPUSH
67323: CALL_OW 459
67327: NOT
67328: AND
67329: PUSH
67330: LD_VAR 0 7
67334: AND
67335: IFFALSE 67351
// ComChangeProfession ( j , class ) ;
67337: LD_VAR 0 3
67341: PPUSH
67342: LD_VAR 0 7
67346: PPUSH
67347: CALL_OW 123
67351: GO 67281
67353: POP
67354: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67355: LD_EXP 89
67359: PUSH
67360: LD_VAR 0 2
67364: ARRAY
67365: PUSH
67366: LD_EXP 88
67370: PUSH
67371: LD_VAR 0 2
67375: ARRAY
67376: NOT
67377: AND
67378: PUSH
67379: LD_EXP 66
67383: PUSH
67384: LD_VAR 0 2
67388: ARRAY
67389: PPUSH
67390: LD_INT 30
67392: PUSH
67393: LD_INT 32
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PPUSH
67400: CALL_OW 72
67404: NOT
67405: AND
67406: PUSH
67407: LD_EXP 66
67411: PUSH
67412: LD_VAR 0 2
67416: ARRAY
67417: PPUSH
67418: LD_INT 2
67420: PUSH
67421: LD_INT 30
67423: PUSH
67424: LD_INT 4
67426: PUSH
67427: EMPTY
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 30
67433: PUSH
67434: LD_INT 5
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: LIST
67445: PPUSH
67446: CALL_OW 72
67450: NOT
67451: AND
67452: IFFALSE 67584
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67454: LD_ADDR_VAR 0 4
67458: PUSH
67459: LD_EXP 66
67463: PUSH
67464: LD_VAR 0 2
67468: ARRAY
67469: PPUSH
67470: LD_INT 2
67472: PUSH
67473: LD_INT 25
67475: PUSH
67476: LD_INT 1
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: PUSH
67483: LD_INT 25
67485: PUSH
67486: LD_INT 5
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 25
67495: PUSH
67496: LD_INT 8
67498: PUSH
67499: EMPTY
67500: LIST
67501: LIST
67502: PUSH
67503: LD_INT 25
67505: PUSH
67506: LD_INT 9
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: PPUSH
67520: CALL_OW 72
67524: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67525: LD_ADDR_VAR 0 4
67529: PUSH
67530: LD_VAR 0 4
67534: PUSH
67535: LD_VAR 0 4
67539: PPUSH
67540: LD_INT 18
67542: PPUSH
67543: CALL 47442 0 2
67547: DIFF
67548: ST_TO_ADDR
// if tmp then
67549: LD_VAR 0 4
67553: IFFALSE 67584
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
67555: LD_VAR 0 2
67559: PPUSH
67560: LD_VAR 0 4
67564: PPUSH
67565: LD_EXP 91
67569: PUSH
67570: LD_VAR 0 2
67574: ARRAY
67575: PPUSH
67576: CALL 103404 0 3
// exit ;
67580: POP
67581: POP
67582: GO 67679
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
67584: LD_EXP 89
67588: PUSH
67589: LD_VAR 0 2
67593: ARRAY
67594: PUSH
67595: LD_EXP 88
67599: PUSH
67600: LD_VAR 0 2
67604: ARRAY
67605: AND
67606: IFFALSE 67675
// begin tmp := mc_defender [ i ] ;
67608: LD_ADDR_VAR 0 4
67612: PUSH
67613: LD_EXP 88
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67624: LD_ADDR_EXP 88
67628: PUSH
67629: LD_EXP 88
67633: PPUSH
67634: LD_VAR 0 2
67638: PPUSH
67639: EMPTY
67640: PPUSH
67641: CALL_OW 1
67645: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67646: LD_VAR 0 2
67650: PPUSH
67651: LD_VAR 0 4
67655: PPUSH
67656: LD_EXP 89
67660: PUSH
67661: LD_VAR 0 2
67665: ARRAY
67666: PPUSH
67667: CALL 103965 0 3
// exit ;
67671: POP
67672: POP
67673: GO 67679
// end ; end ;
67675: GO 67090
67677: POP
67678: POP
// end ;
67679: LD_VAR 0 1
67683: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67684: LD_INT 0
67686: PPUSH
67687: PPUSH
67688: PPUSH
67689: PPUSH
67690: PPUSH
67691: PPUSH
67692: PPUSH
67693: PPUSH
67694: PPUSH
67695: PPUSH
67696: PPUSH
// if not mc_bases then
67697: LD_EXP 66
67701: NOT
67702: IFFALSE 67706
// exit ;
67704: GO 68793
// for i = 1 to mc_bases do
67706: LD_ADDR_VAR 0 2
67710: PUSH
67711: DOUBLE
67712: LD_INT 1
67714: DEC
67715: ST_TO_ADDR
67716: LD_EXP 66
67720: PUSH
67721: FOR_TO
67722: IFFALSE 68791
// begin tmp := mc_lab [ i ] ;
67724: LD_ADDR_VAR 0 6
67728: PUSH
67729: LD_EXP 99
67733: PUSH
67734: LD_VAR 0 2
67738: ARRAY
67739: ST_TO_ADDR
// if not tmp then
67740: LD_VAR 0 6
67744: NOT
67745: IFFALSE 67749
// continue ;
67747: GO 67721
// idle_lab := 0 ;
67749: LD_ADDR_VAR 0 11
67753: PUSH
67754: LD_INT 0
67756: ST_TO_ADDR
// for j in tmp do
67757: LD_ADDR_VAR 0 3
67761: PUSH
67762: LD_VAR 0 6
67766: PUSH
67767: FOR_IN
67768: IFFALSE 68787
// begin researching := false ;
67770: LD_ADDR_VAR 0 10
67774: PUSH
67775: LD_INT 0
67777: ST_TO_ADDR
// side := GetSide ( j ) ;
67778: LD_ADDR_VAR 0 4
67782: PUSH
67783: LD_VAR 0 3
67787: PPUSH
67788: CALL_OW 255
67792: ST_TO_ADDR
// if not mc_tech [ side ] then
67793: LD_EXP 93
67797: PUSH
67798: LD_VAR 0 4
67802: ARRAY
67803: NOT
67804: IFFALSE 67808
// continue ;
67806: GO 67767
// if BuildingStatus ( j ) = bs_idle then
67808: LD_VAR 0 3
67812: PPUSH
67813: CALL_OW 461
67817: PUSH
67818: LD_INT 2
67820: EQUAL
67821: IFFALSE 68009
// begin if idle_lab and UnitsInside ( j ) < 6 then
67823: LD_VAR 0 11
67827: PUSH
67828: LD_VAR 0 3
67832: PPUSH
67833: CALL_OW 313
67837: PUSH
67838: LD_INT 6
67840: LESS
67841: AND
67842: IFFALSE 67913
// begin tmp2 := UnitsInside ( idle_lab ) ;
67844: LD_ADDR_VAR 0 9
67848: PUSH
67849: LD_VAR 0 11
67853: PPUSH
67854: CALL_OW 313
67858: ST_TO_ADDR
// if tmp2 then
67859: LD_VAR 0 9
67863: IFFALSE 67905
// for x in tmp2 do
67865: LD_ADDR_VAR 0 7
67869: PUSH
67870: LD_VAR 0 9
67874: PUSH
67875: FOR_IN
67876: IFFALSE 67903
// begin ComExitBuilding ( x ) ;
67878: LD_VAR 0 7
67882: PPUSH
67883: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67887: LD_VAR 0 7
67891: PPUSH
67892: LD_VAR 0 3
67896: PPUSH
67897: CALL_OW 180
// end ;
67901: GO 67875
67903: POP
67904: POP
// idle_lab := 0 ;
67905: LD_ADDR_VAR 0 11
67909: PUSH
67910: LD_INT 0
67912: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67913: LD_ADDR_VAR 0 5
67917: PUSH
67918: LD_EXP 93
67922: PUSH
67923: LD_VAR 0 4
67927: ARRAY
67928: PUSH
67929: FOR_IN
67930: IFFALSE 67990
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67932: LD_VAR 0 3
67936: PPUSH
67937: LD_VAR 0 5
67941: PPUSH
67942: CALL_OW 430
67946: PUSH
67947: LD_VAR 0 4
67951: PPUSH
67952: LD_VAR 0 5
67956: PPUSH
67957: CALL 14454 0 2
67961: AND
67962: IFFALSE 67988
// begin researching := true ;
67964: LD_ADDR_VAR 0 10
67968: PUSH
67969: LD_INT 1
67971: ST_TO_ADDR
// ComResearch ( j , t ) ;
67972: LD_VAR 0 3
67976: PPUSH
67977: LD_VAR 0 5
67981: PPUSH
67982: CALL_OW 124
// break ;
67986: GO 67990
// end ;
67988: GO 67929
67990: POP
67991: POP
// if not researching then
67992: LD_VAR 0 10
67996: NOT
67997: IFFALSE 68009
// idle_lab := j ;
67999: LD_ADDR_VAR 0 11
68003: PUSH
68004: LD_VAR 0 3
68008: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68009: LD_VAR 0 3
68013: PPUSH
68014: CALL_OW 461
68018: PUSH
68019: LD_INT 10
68021: EQUAL
68022: IFFALSE 68610
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68024: LD_EXP 95
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: NOT
68035: PUSH
68036: LD_EXP 96
68040: PUSH
68041: LD_VAR 0 2
68045: ARRAY
68046: NOT
68047: AND
68048: PUSH
68049: LD_EXP 93
68053: PUSH
68054: LD_VAR 0 4
68058: ARRAY
68059: PUSH
68060: LD_INT 1
68062: GREATER
68063: AND
68064: IFFALSE 68195
// begin ComCancel ( j ) ;
68066: LD_VAR 0 3
68070: PPUSH
68071: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68075: LD_ADDR_EXP 93
68079: PUSH
68080: LD_EXP 93
68084: PPUSH
68085: LD_VAR 0 4
68089: PPUSH
68090: LD_EXP 93
68094: PUSH
68095: LD_VAR 0 4
68099: ARRAY
68100: PPUSH
68101: LD_EXP 93
68105: PUSH
68106: LD_VAR 0 4
68110: ARRAY
68111: PUSH
68112: LD_INT 1
68114: MINUS
68115: PPUSH
68116: LD_EXP 93
68120: PUSH
68121: LD_VAR 0 4
68125: ARRAY
68126: PPUSH
68127: LD_INT 0
68129: PPUSH
68130: CALL 17966 0 4
68134: PPUSH
68135: CALL_OW 1
68139: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68140: LD_ADDR_EXP 93
68144: PUSH
68145: LD_EXP 93
68149: PPUSH
68150: LD_VAR 0 4
68154: PPUSH
68155: LD_EXP 93
68159: PUSH
68160: LD_VAR 0 4
68164: ARRAY
68165: PPUSH
68166: LD_EXP 93
68170: PUSH
68171: LD_VAR 0 4
68175: ARRAY
68176: PPUSH
68177: LD_INT 1
68179: PPUSH
68180: LD_INT 0
68182: PPUSH
68183: CALL 17966 0 4
68187: PPUSH
68188: CALL_OW 1
68192: ST_TO_ADDR
// continue ;
68193: GO 67767
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68195: LD_EXP 95
68199: PUSH
68200: LD_VAR 0 2
68204: ARRAY
68205: PUSH
68206: LD_EXP 96
68210: PUSH
68211: LD_VAR 0 2
68215: ARRAY
68216: NOT
68217: AND
68218: IFFALSE 68345
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68220: LD_ADDR_EXP 96
68224: PUSH
68225: LD_EXP 96
68229: PPUSH
68230: LD_VAR 0 2
68234: PUSH
68235: LD_EXP 96
68239: PUSH
68240: LD_VAR 0 2
68244: ARRAY
68245: PUSH
68246: LD_INT 1
68248: PLUS
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PPUSH
68254: LD_EXP 95
68258: PUSH
68259: LD_VAR 0 2
68263: ARRAY
68264: PUSH
68265: LD_INT 1
68267: ARRAY
68268: PPUSH
68269: CALL 18548 0 3
68273: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68274: LD_EXP 95
68278: PUSH
68279: LD_VAR 0 2
68283: ARRAY
68284: PUSH
68285: LD_INT 1
68287: ARRAY
68288: PPUSH
68289: LD_INT 112
68291: PPUSH
68292: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68296: LD_ADDR_VAR 0 9
68300: PUSH
68301: LD_EXP 95
68305: PUSH
68306: LD_VAR 0 2
68310: ARRAY
68311: PPUSH
68312: LD_INT 1
68314: PPUSH
68315: CALL_OW 3
68319: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68320: LD_ADDR_EXP 95
68324: PUSH
68325: LD_EXP 95
68329: PPUSH
68330: LD_VAR 0 2
68334: PPUSH
68335: LD_VAR 0 9
68339: PPUSH
68340: CALL_OW 1
68344: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68345: LD_EXP 95
68349: PUSH
68350: LD_VAR 0 2
68354: ARRAY
68355: PUSH
68356: LD_EXP 96
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: AND
68367: PUSH
68368: LD_EXP 96
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: PUSH
68379: LD_INT 1
68381: ARRAY
68382: PPUSH
68383: CALL_OW 310
68387: NOT
68388: AND
68389: PUSH
68390: LD_VAR 0 3
68394: PPUSH
68395: CALL_OW 313
68399: PUSH
68400: LD_INT 6
68402: EQUAL
68403: AND
68404: IFFALSE 68460
// begin tmp2 := UnitsInside ( j ) ;
68406: LD_ADDR_VAR 0 9
68410: PUSH
68411: LD_VAR 0 3
68415: PPUSH
68416: CALL_OW 313
68420: ST_TO_ADDR
// if tmp2 = 6 then
68421: LD_VAR 0 9
68425: PUSH
68426: LD_INT 6
68428: EQUAL
68429: IFFALSE 68460
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68431: LD_VAR 0 9
68435: PUSH
68436: LD_INT 1
68438: ARRAY
68439: PPUSH
68440: LD_INT 112
68442: PPUSH
68443: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68447: LD_VAR 0 9
68451: PUSH
68452: LD_INT 1
68454: ARRAY
68455: PPUSH
68456: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68460: LD_EXP 96
68464: PUSH
68465: LD_VAR 0 2
68469: ARRAY
68470: PUSH
68471: LD_EXP 96
68475: PUSH
68476: LD_VAR 0 2
68480: ARRAY
68481: PUSH
68482: LD_INT 1
68484: ARRAY
68485: PPUSH
68486: CALL_OW 314
68490: NOT
68491: AND
68492: PUSH
68493: LD_EXP 96
68497: PUSH
68498: LD_VAR 0 2
68502: ARRAY
68503: PUSH
68504: LD_INT 1
68506: ARRAY
68507: PPUSH
68508: CALL_OW 310
68512: NOT
68513: AND
68514: IFFALSE 68540
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68516: LD_EXP 96
68520: PUSH
68521: LD_VAR 0 2
68525: ARRAY
68526: PUSH
68527: LD_INT 1
68529: ARRAY
68530: PPUSH
68531: LD_VAR 0 3
68535: PPUSH
68536: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68540: LD_EXP 96
68544: PUSH
68545: LD_VAR 0 2
68549: ARRAY
68550: PUSH
68551: LD_INT 1
68553: ARRAY
68554: PPUSH
68555: CALL_OW 310
68559: PUSH
68560: LD_EXP 96
68564: PUSH
68565: LD_VAR 0 2
68569: ARRAY
68570: PUSH
68571: LD_INT 1
68573: ARRAY
68574: PPUSH
68575: CALL_OW 310
68579: PPUSH
68580: CALL_OW 461
68584: PUSH
68585: LD_INT 3
68587: NONEQUAL
68588: AND
68589: IFFALSE 68610
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68591: LD_EXP 96
68595: PUSH
68596: LD_VAR 0 2
68600: ARRAY
68601: PUSH
68602: LD_INT 1
68604: ARRAY
68605: PPUSH
68606: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68610: LD_VAR 0 3
68614: PPUSH
68615: CALL_OW 461
68619: PUSH
68620: LD_INT 6
68622: EQUAL
68623: PUSH
68624: LD_VAR 0 6
68628: PUSH
68629: LD_INT 1
68631: GREATER
68632: AND
68633: IFFALSE 68785
// begin sci := [ ] ;
68635: LD_ADDR_VAR 0 8
68639: PUSH
68640: EMPTY
68641: ST_TO_ADDR
// for x in ( tmp diff j ) do
68642: LD_ADDR_VAR 0 7
68646: PUSH
68647: LD_VAR 0 6
68651: PUSH
68652: LD_VAR 0 3
68656: DIFF
68657: PUSH
68658: FOR_IN
68659: IFFALSE 68711
// begin if sci = 6 then
68661: LD_VAR 0 8
68665: PUSH
68666: LD_INT 6
68668: EQUAL
68669: IFFALSE 68673
// break ;
68671: GO 68711
// if BuildingStatus ( x ) = bs_idle then
68673: LD_VAR 0 7
68677: PPUSH
68678: CALL_OW 461
68682: PUSH
68683: LD_INT 2
68685: EQUAL
68686: IFFALSE 68709
// sci := sci ^ UnitsInside ( x ) ;
68688: LD_ADDR_VAR 0 8
68692: PUSH
68693: LD_VAR 0 8
68697: PUSH
68698: LD_VAR 0 7
68702: PPUSH
68703: CALL_OW 313
68707: ADD
68708: ST_TO_ADDR
// end ;
68709: GO 68658
68711: POP
68712: POP
// if not sci then
68713: LD_VAR 0 8
68717: NOT
68718: IFFALSE 68722
// continue ;
68720: GO 67767
// for x in sci do
68722: LD_ADDR_VAR 0 7
68726: PUSH
68727: LD_VAR 0 8
68731: PUSH
68732: FOR_IN
68733: IFFALSE 68783
// if IsInUnit ( x ) and not HasTask ( x ) then
68735: LD_VAR 0 7
68739: PPUSH
68740: CALL_OW 310
68744: PUSH
68745: LD_VAR 0 7
68749: PPUSH
68750: CALL_OW 314
68754: NOT
68755: AND
68756: IFFALSE 68781
// begin ComExitBuilding ( x ) ;
68758: LD_VAR 0 7
68762: PPUSH
68763: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68767: LD_VAR 0 7
68771: PPUSH
68772: LD_VAR 0 3
68776: PPUSH
68777: CALL_OW 180
// end ;
68781: GO 68732
68783: POP
68784: POP
// end ; end ;
68785: GO 67767
68787: POP
68788: POP
// end ;
68789: GO 67721
68791: POP
68792: POP
// end ;
68793: LD_VAR 0 1
68797: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68798: LD_INT 0
68800: PPUSH
68801: PPUSH
// if not mc_bases then
68802: LD_EXP 66
68806: NOT
68807: IFFALSE 68811
// exit ;
68809: GO 68892
// for i = 1 to mc_bases do
68811: LD_ADDR_VAR 0 2
68815: PUSH
68816: DOUBLE
68817: LD_INT 1
68819: DEC
68820: ST_TO_ADDR
68821: LD_EXP 66
68825: PUSH
68826: FOR_TO
68827: IFFALSE 68890
// if mc_mines [ i ] and mc_miners [ i ] then
68829: LD_EXP 79
68833: PUSH
68834: LD_VAR 0 2
68838: ARRAY
68839: PUSH
68840: LD_EXP 80
68844: PUSH
68845: LD_VAR 0 2
68849: ARRAY
68850: AND
68851: IFFALSE 68888
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68853: LD_EXP 80
68857: PUSH
68858: LD_VAR 0 2
68862: ARRAY
68863: PUSH
68864: LD_INT 1
68866: ARRAY
68867: PPUSH
68868: CALL_OW 255
68872: PPUSH
68873: LD_EXP 79
68877: PUSH
68878: LD_VAR 0 2
68882: ARRAY
68883: PPUSH
68884: CALL 15537 0 2
68888: GO 68826
68890: POP
68891: POP
// end ;
68892: LD_VAR 0 1
68896: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68897: LD_INT 0
68899: PPUSH
68900: PPUSH
68901: PPUSH
68902: PPUSH
68903: PPUSH
68904: PPUSH
68905: PPUSH
68906: PPUSH
// if not mc_bases or not mc_parking then
68907: LD_EXP 66
68911: NOT
68912: PUSH
68913: LD_EXP 90
68917: NOT
68918: OR
68919: IFFALSE 68923
// exit ;
68921: GO 69622
// for i = 1 to mc_bases do
68923: LD_ADDR_VAR 0 2
68927: PUSH
68928: DOUBLE
68929: LD_INT 1
68931: DEC
68932: ST_TO_ADDR
68933: LD_EXP 66
68937: PUSH
68938: FOR_TO
68939: IFFALSE 69620
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68941: LD_EXP 66
68945: PUSH
68946: LD_VAR 0 2
68950: ARRAY
68951: NOT
68952: PUSH
68953: LD_EXP 90
68957: PUSH
68958: LD_VAR 0 2
68962: ARRAY
68963: NOT
68964: OR
68965: IFFALSE 68969
// continue ;
68967: GO 68938
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68969: LD_ADDR_VAR 0 5
68973: PUSH
68974: LD_EXP 66
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PUSH
68985: LD_INT 1
68987: ARRAY
68988: PPUSH
68989: CALL_OW 255
68993: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68994: LD_ADDR_VAR 0 6
68998: PUSH
68999: LD_EXP 66
69003: PUSH
69004: LD_VAR 0 2
69008: ARRAY
69009: PPUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 3
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PPUSH
69020: CALL_OW 72
69024: ST_TO_ADDR
// if not fac then
69025: LD_VAR 0 6
69029: NOT
69030: IFFALSE 69081
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69032: LD_ADDR_VAR 0 6
69036: PUSH
69037: LD_EXP 66
69041: PUSH
69042: LD_VAR 0 2
69046: ARRAY
69047: PPUSH
69048: LD_INT 2
69050: PUSH
69051: LD_INT 30
69053: PUSH
69054: LD_INT 0
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 30
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: LIST
69075: PPUSH
69076: CALL_OW 72
69080: ST_TO_ADDR
// if not fac then
69081: LD_VAR 0 6
69085: NOT
69086: IFFALSE 69090
// continue ;
69088: GO 68938
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69090: LD_ADDR_VAR 0 7
69094: PUSH
69095: LD_EXP 90
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: PPUSH
69106: LD_INT 22
69108: PUSH
69109: LD_VAR 0 5
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 21
69120: PUSH
69121: LD_INT 2
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 3
69130: PUSH
69131: LD_INT 24
69133: PUSH
69134: LD_INT 1000
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: LIST
69149: PPUSH
69150: CALL_OW 70
69154: ST_TO_ADDR
// for j in fac do
69155: LD_ADDR_VAR 0 3
69159: PUSH
69160: LD_VAR 0 6
69164: PUSH
69165: FOR_IN
69166: IFFALSE 69247
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69168: LD_ADDR_VAR 0 7
69172: PUSH
69173: LD_VAR 0 7
69177: PUSH
69178: LD_INT 22
69180: PUSH
69181: LD_VAR 0 5
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: PUSH
69190: LD_INT 91
69192: PUSH
69193: LD_VAR 0 3
69197: PUSH
69198: LD_INT 15
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: LIST
69205: PUSH
69206: LD_INT 21
69208: PUSH
69209: LD_INT 2
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 3
69218: PUSH
69219: LD_INT 24
69221: PUSH
69222: LD_INT 1000
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: PPUSH
69239: CALL_OW 69
69243: UNION
69244: ST_TO_ADDR
69245: GO 69165
69247: POP
69248: POP
// if not vehs then
69249: LD_VAR 0 7
69253: NOT
69254: IFFALSE 69280
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69256: LD_ADDR_EXP 78
69260: PUSH
69261: LD_EXP 78
69265: PPUSH
69266: LD_VAR 0 2
69270: PPUSH
69271: EMPTY
69272: PPUSH
69273: CALL_OW 1
69277: ST_TO_ADDR
// continue ;
69278: GO 68938
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69280: LD_ADDR_VAR 0 8
69284: PUSH
69285: LD_EXP 66
69289: PUSH
69290: LD_VAR 0 2
69294: ARRAY
69295: PPUSH
69296: LD_INT 30
69298: PUSH
69299: LD_INT 3
69301: PUSH
69302: EMPTY
69303: LIST
69304: LIST
69305: PPUSH
69306: CALL_OW 72
69310: ST_TO_ADDR
// if tmp then
69311: LD_VAR 0 8
69315: IFFALSE 69418
// begin for j in tmp do
69317: LD_ADDR_VAR 0 3
69321: PUSH
69322: LD_VAR 0 8
69326: PUSH
69327: FOR_IN
69328: IFFALSE 69416
// for k in UnitsInside ( j ) do
69330: LD_ADDR_VAR 0 4
69334: PUSH
69335: LD_VAR 0 3
69339: PPUSH
69340: CALL_OW 313
69344: PUSH
69345: FOR_IN
69346: IFFALSE 69412
// if k then
69348: LD_VAR 0 4
69352: IFFALSE 69410
// if not k in mc_repair_vehicle [ i ] then
69354: LD_VAR 0 4
69358: PUSH
69359: LD_EXP 78
69363: PUSH
69364: LD_VAR 0 2
69368: ARRAY
69369: IN
69370: NOT
69371: IFFALSE 69410
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69373: LD_ADDR_EXP 78
69377: PUSH
69378: LD_EXP 78
69382: PPUSH
69383: LD_VAR 0 2
69387: PPUSH
69388: LD_EXP 78
69392: PUSH
69393: LD_VAR 0 2
69397: ARRAY
69398: PUSH
69399: LD_VAR 0 4
69403: UNION
69404: PPUSH
69405: CALL_OW 1
69409: ST_TO_ADDR
69410: GO 69345
69412: POP
69413: POP
69414: GO 69327
69416: POP
69417: POP
// end ; if not mc_repair_vehicle [ i ] then
69418: LD_EXP 78
69422: PUSH
69423: LD_VAR 0 2
69427: ARRAY
69428: NOT
69429: IFFALSE 69433
// continue ;
69431: GO 68938
// for j in mc_repair_vehicle [ i ] do
69433: LD_ADDR_VAR 0 3
69437: PUSH
69438: LD_EXP 78
69442: PUSH
69443: LD_VAR 0 2
69447: ARRAY
69448: PUSH
69449: FOR_IN
69450: IFFALSE 69616
// begin if GetClass ( j ) <> 3 then
69452: LD_VAR 0 3
69456: PPUSH
69457: CALL_OW 257
69461: PUSH
69462: LD_INT 3
69464: NONEQUAL
69465: IFFALSE 69506
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69467: LD_ADDR_EXP 78
69471: PUSH
69472: LD_EXP 78
69476: PPUSH
69477: LD_VAR 0 2
69481: PPUSH
69482: LD_EXP 78
69486: PUSH
69487: LD_VAR 0 2
69491: ARRAY
69492: PUSH
69493: LD_VAR 0 3
69497: DIFF
69498: PPUSH
69499: CALL_OW 1
69503: ST_TO_ADDR
// continue ;
69504: GO 69449
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69506: LD_VAR 0 3
69510: PPUSH
69511: CALL_OW 311
69515: NOT
69516: PUSH
69517: LD_VAR 0 3
69521: PUSH
69522: LD_EXP 69
69526: PUSH
69527: LD_VAR 0 2
69531: ARRAY
69532: PUSH
69533: LD_INT 1
69535: ARRAY
69536: IN
69537: NOT
69538: AND
69539: PUSH
69540: LD_VAR 0 3
69544: PUSH
69545: LD_EXP 69
69549: PUSH
69550: LD_VAR 0 2
69554: ARRAY
69555: PUSH
69556: LD_INT 2
69558: ARRAY
69559: IN
69560: NOT
69561: AND
69562: IFFALSE 69614
// begin if IsInUnit ( j ) then
69564: LD_VAR 0 3
69568: PPUSH
69569: CALL_OW 310
69573: IFFALSE 69584
// ComExitBuilding ( j ) ;
69575: LD_VAR 0 3
69579: PPUSH
69580: CALL_OW 122
// if not HasTask ( j ) then
69584: LD_VAR 0 3
69588: PPUSH
69589: CALL_OW 314
69593: NOT
69594: IFFALSE 69614
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
69596: LD_VAR 0 3
69600: PPUSH
69601: LD_VAR 0 7
69605: PUSH
69606: LD_INT 1
69608: ARRAY
69609: PPUSH
69610: CALL_OW 189
// end ; end ;
69614: GO 69449
69616: POP
69617: POP
// end ;
69618: GO 68938
69620: POP
69621: POP
// end ;
69622: LD_VAR 0 1
69626: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69627: LD_INT 0
69629: PPUSH
69630: PPUSH
69631: PPUSH
69632: PPUSH
69633: PPUSH
69634: PPUSH
69635: PPUSH
69636: PPUSH
69637: PPUSH
69638: PPUSH
69639: PPUSH
// if not mc_bases then
69640: LD_EXP 66
69644: NOT
69645: IFFALSE 69649
// exit ;
69647: GO 70451
// for i = 1 to mc_bases do
69649: LD_ADDR_VAR 0 2
69653: PUSH
69654: DOUBLE
69655: LD_INT 1
69657: DEC
69658: ST_TO_ADDR
69659: LD_EXP 66
69663: PUSH
69664: FOR_TO
69665: IFFALSE 70449
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69667: LD_EXP 94
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: NOT
69678: PUSH
69679: LD_EXP 69
69683: PUSH
69684: LD_VAR 0 2
69688: ARRAY
69689: PUSH
69690: LD_INT 1
69692: ARRAY
69693: OR
69694: PUSH
69695: LD_EXP 69
69699: PUSH
69700: LD_VAR 0 2
69704: ARRAY
69705: PUSH
69706: LD_INT 2
69708: ARRAY
69709: OR
69710: PUSH
69711: LD_EXP 92
69715: PUSH
69716: LD_VAR 0 2
69720: ARRAY
69721: PPUSH
69722: LD_INT 1
69724: PPUSH
69725: CALL_OW 325
69729: NOT
69730: OR
69731: PUSH
69732: LD_EXP 89
69736: PUSH
69737: LD_VAR 0 2
69741: ARRAY
69742: OR
69743: IFFALSE 69747
// continue ;
69745: GO 69664
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69747: LD_ADDR_VAR 0 8
69751: PUSH
69752: LD_EXP 66
69756: PUSH
69757: LD_VAR 0 2
69761: ARRAY
69762: PPUSH
69763: LD_INT 25
69765: PUSH
69766: LD_INT 4
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 50
69775: PUSH
69776: EMPTY
69777: LIST
69778: PUSH
69779: LD_INT 3
69781: PUSH
69782: LD_INT 60
69784: PUSH
69785: EMPTY
69786: LIST
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: EMPTY
69793: LIST
69794: LIST
69795: LIST
69796: PPUSH
69797: CALL_OW 72
69801: PUSH
69802: LD_EXP 70
69806: PUSH
69807: LD_VAR 0 2
69811: ARRAY
69812: DIFF
69813: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69814: LD_ADDR_VAR 0 9
69818: PUSH
69819: LD_EXP 66
69823: PUSH
69824: LD_VAR 0 2
69828: ARRAY
69829: PPUSH
69830: LD_INT 2
69832: PUSH
69833: LD_INT 30
69835: PUSH
69836: LD_INT 0
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 30
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: LIST
69857: PPUSH
69858: CALL_OW 72
69862: ST_TO_ADDR
// if not tmp or not dep then
69863: LD_VAR 0 8
69867: NOT
69868: PUSH
69869: LD_VAR 0 9
69873: NOT
69874: OR
69875: IFFALSE 69879
// continue ;
69877: GO 69664
// side := GetSide ( tmp [ 1 ] ) ;
69879: LD_ADDR_VAR 0 11
69883: PUSH
69884: LD_VAR 0 8
69888: PUSH
69889: LD_INT 1
69891: ARRAY
69892: PPUSH
69893: CALL_OW 255
69897: ST_TO_ADDR
// dep := dep [ 1 ] ;
69898: LD_ADDR_VAR 0 9
69902: PUSH
69903: LD_VAR 0 9
69907: PUSH
69908: LD_INT 1
69910: ARRAY
69911: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69912: LD_ADDR_VAR 0 7
69916: PUSH
69917: LD_EXP 94
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: PPUSH
69928: LD_INT 22
69930: PUSH
69931: LD_INT 0
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: PUSH
69938: LD_INT 25
69940: PUSH
69941: LD_INT 12
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PPUSH
69952: CALL_OW 70
69956: PUSH
69957: LD_INT 22
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 25
69969: PUSH
69970: LD_INT 12
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 91
69979: PUSH
69980: LD_VAR 0 9
69984: PUSH
69985: LD_INT 20
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: LIST
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: LIST
69997: PPUSH
69998: CALL_OW 69
70002: UNION
70003: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70004: LD_ADDR_VAR 0 10
70008: PUSH
70009: LD_EXP 94
70013: PUSH
70014: LD_VAR 0 2
70018: ARRAY
70019: PPUSH
70020: LD_INT 81
70022: PUSH
70023: LD_VAR 0 11
70027: PUSH
70028: EMPTY
70029: LIST
70030: LIST
70031: PPUSH
70032: CALL_OW 70
70036: ST_TO_ADDR
// if not apes or danger_at_area then
70037: LD_VAR 0 7
70041: NOT
70042: PUSH
70043: LD_VAR 0 10
70047: OR
70048: IFFALSE 70098
// begin if mc_taming [ i ] then
70050: LD_EXP 97
70054: PUSH
70055: LD_VAR 0 2
70059: ARRAY
70060: IFFALSE 70096
// begin MC_Reset ( i , 121 ) ;
70062: LD_VAR 0 2
70066: PPUSH
70067: LD_INT 121
70069: PPUSH
70070: CALL 55480 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70074: LD_ADDR_EXP 97
70078: PUSH
70079: LD_EXP 97
70083: PPUSH
70084: LD_VAR 0 2
70088: PPUSH
70089: EMPTY
70090: PPUSH
70091: CALL_OW 1
70095: ST_TO_ADDR
// end ; continue ;
70096: GO 69664
// end ; for j in tmp do
70098: LD_ADDR_VAR 0 3
70102: PUSH
70103: LD_VAR 0 8
70107: PUSH
70108: FOR_IN
70109: IFFALSE 70445
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70111: LD_VAR 0 3
70115: PUSH
70116: LD_EXP 97
70120: PUSH
70121: LD_VAR 0 2
70125: ARRAY
70126: IN
70127: NOT
70128: PUSH
70129: LD_EXP 97
70133: PUSH
70134: LD_VAR 0 2
70138: ARRAY
70139: PUSH
70140: LD_INT 3
70142: LESS
70143: AND
70144: IFFALSE 70202
// begin SetTag ( j , 121 ) ;
70146: LD_VAR 0 3
70150: PPUSH
70151: LD_INT 121
70153: PPUSH
70154: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70158: LD_ADDR_EXP 97
70162: PUSH
70163: LD_EXP 97
70167: PPUSH
70168: LD_VAR 0 2
70172: PUSH
70173: LD_EXP 97
70177: PUSH
70178: LD_VAR 0 2
70182: ARRAY
70183: PUSH
70184: LD_INT 1
70186: PLUS
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: PPUSH
70192: LD_VAR 0 3
70196: PPUSH
70197: CALL 18548 0 3
70201: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70202: LD_VAR 0 3
70206: PUSH
70207: LD_EXP 97
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: IN
70218: IFFALSE 70443
// begin if GetClass ( j ) <> 4 then
70220: LD_VAR 0 3
70224: PPUSH
70225: CALL_OW 257
70229: PUSH
70230: LD_INT 4
70232: NONEQUAL
70233: IFFALSE 70286
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70235: LD_ADDR_EXP 97
70239: PUSH
70240: LD_EXP 97
70244: PPUSH
70245: LD_VAR 0 2
70249: PPUSH
70250: LD_EXP 97
70254: PUSH
70255: LD_VAR 0 2
70259: ARRAY
70260: PUSH
70261: LD_VAR 0 3
70265: DIFF
70266: PPUSH
70267: CALL_OW 1
70271: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70272: LD_VAR 0 3
70276: PPUSH
70277: LD_INT 0
70279: PPUSH
70280: CALL_OW 109
// continue ;
70284: GO 70108
// end ; if IsInUnit ( j ) then
70286: LD_VAR 0 3
70290: PPUSH
70291: CALL_OW 310
70295: IFFALSE 70306
// ComExitBuilding ( j ) ;
70297: LD_VAR 0 3
70301: PPUSH
70302: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70306: LD_ADDR_VAR 0 6
70310: PUSH
70311: LD_VAR 0 7
70315: PPUSH
70316: LD_VAR 0 3
70320: PPUSH
70321: CALL_OW 74
70325: ST_TO_ADDR
// if not ape then
70326: LD_VAR 0 6
70330: NOT
70331: IFFALSE 70335
// break ;
70333: GO 70445
// x := GetX ( ape ) ;
70335: LD_ADDR_VAR 0 4
70339: PUSH
70340: LD_VAR 0 6
70344: PPUSH
70345: CALL_OW 250
70349: ST_TO_ADDR
// y := GetY ( ape ) ;
70350: LD_ADDR_VAR 0 5
70354: PUSH
70355: LD_VAR 0 6
70359: PPUSH
70360: CALL_OW 251
70364: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70365: LD_VAR 0 4
70369: PPUSH
70370: LD_VAR 0 5
70374: PPUSH
70375: CALL_OW 488
70379: NOT
70380: PUSH
70381: LD_VAR 0 11
70385: PPUSH
70386: LD_VAR 0 4
70390: PPUSH
70391: LD_VAR 0 5
70395: PPUSH
70396: LD_INT 20
70398: PPUSH
70399: CALL 19444 0 4
70403: PUSH
70404: LD_INT 4
70406: ARRAY
70407: OR
70408: IFFALSE 70412
// break ;
70410: GO 70445
// if not HasTask ( j ) then
70412: LD_VAR 0 3
70416: PPUSH
70417: CALL_OW 314
70421: NOT
70422: IFFALSE 70443
// ComTameXY ( j , x , y ) ;
70424: LD_VAR 0 3
70428: PPUSH
70429: LD_VAR 0 4
70433: PPUSH
70434: LD_VAR 0 5
70438: PPUSH
70439: CALL_OW 131
// end ; end ;
70443: GO 70108
70445: POP
70446: POP
// end ;
70447: GO 69664
70449: POP
70450: POP
// end ;
70451: LD_VAR 0 1
70455: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70456: LD_INT 0
70458: PPUSH
70459: PPUSH
70460: PPUSH
70461: PPUSH
70462: PPUSH
70463: PPUSH
70464: PPUSH
70465: PPUSH
// if not mc_bases then
70466: LD_EXP 66
70470: NOT
70471: IFFALSE 70475
// exit ;
70473: GO 71101
// for i = 1 to mc_bases do
70475: LD_ADDR_VAR 0 2
70479: PUSH
70480: DOUBLE
70481: LD_INT 1
70483: DEC
70484: ST_TO_ADDR
70485: LD_EXP 66
70489: PUSH
70490: FOR_TO
70491: IFFALSE 71099
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70493: LD_EXP 95
70497: PUSH
70498: LD_VAR 0 2
70502: ARRAY
70503: NOT
70504: PUSH
70505: LD_EXP 95
70509: PUSH
70510: LD_VAR 0 2
70514: ARRAY
70515: PPUSH
70516: LD_INT 25
70518: PUSH
70519: LD_INT 12
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PPUSH
70526: CALL_OW 72
70530: NOT
70531: OR
70532: IFFALSE 70536
// continue ;
70534: GO 70490
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70536: LD_ADDR_VAR 0 5
70540: PUSH
70541: LD_EXP 95
70545: PUSH
70546: LD_VAR 0 2
70550: ARRAY
70551: PUSH
70552: LD_INT 1
70554: ARRAY
70555: PPUSH
70556: CALL_OW 255
70560: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70561: LD_VAR 0 5
70565: PPUSH
70566: LD_INT 2
70568: PPUSH
70569: CALL_OW 325
70573: IFFALSE 70826
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70575: LD_ADDR_VAR 0 4
70579: PUSH
70580: LD_EXP 95
70584: PUSH
70585: LD_VAR 0 2
70589: ARRAY
70590: PPUSH
70591: LD_INT 25
70593: PUSH
70594: LD_INT 16
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PPUSH
70601: CALL_OW 72
70605: ST_TO_ADDR
// if tmp < 6 then
70606: LD_VAR 0 4
70610: PUSH
70611: LD_INT 6
70613: LESS
70614: IFFALSE 70826
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70616: LD_ADDR_VAR 0 6
70620: PUSH
70621: LD_EXP 66
70625: PUSH
70626: LD_VAR 0 2
70630: ARRAY
70631: PPUSH
70632: LD_INT 2
70634: PUSH
70635: LD_INT 30
70637: PUSH
70638: LD_INT 0
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: PUSH
70645: LD_INT 30
70647: PUSH
70648: LD_INT 1
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: LIST
70659: PPUSH
70660: CALL_OW 72
70664: ST_TO_ADDR
// if depot then
70665: LD_VAR 0 6
70669: IFFALSE 70826
// begin selected := 0 ;
70671: LD_ADDR_VAR 0 7
70675: PUSH
70676: LD_INT 0
70678: ST_TO_ADDR
// for j in depot do
70679: LD_ADDR_VAR 0 3
70683: PUSH
70684: LD_VAR 0 6
70688: PUSH
70689: FOR_IN
70690: IFFALSE 70721
// begin if UnitsInside ( j ) < 6 then
70692: LD_VAR 0 3
70696: PPUSH
70697: CALL_OW 313
70701: PUSH
70702: LD_INT 6
70704: LESS
70705: IFFALSE 70719
// begin selected := j ;
70707: LD_ADDR_VAR 0 7
70711: PUSH
70712: LD_VAR 0 3
70716: ST_TO_ADDR
// break ;
70717: GO 70721
// end ; end ;
70719: GO 70689
70721: POP
70722: POP
// if selected then
70723: LD_VAR 0 7
70727: IFFALSE 70826
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70729: LD_ADDR_VAR 0 3
70733: PUSH
70734: LD_EXP 95
70738: PUSH
70739: LD_VAR 0 2
70743: ARRAY
70744: PPUSH
70745: LD_INT 25
70747: PUSH
70748: LD_INT 12
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PPUSH
70755: CALL_OW 72
70759: PUSH
70760: FOR_IN
70761: IFFALSE 70824
// if not HasTask ( j ) then
70763: LD_VAR 0 3
70767: PPUSH
70768: CALL_OW 314
70772: NOT
70773: IFFALSE 70822
// begin if not IsInUnit ( j ) then
70775: LD_VAR 0 3
70779: PPUSH
70780: CALL_OW 310
70784: NOT
70785: IFFALSE 70801
// ComEnterUnit ( j , selected ) ;
70787: LD_VAR 0 3
70791: PPUSH
70792: LD_VAR 0 7
70796: PPUSH
70797: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70801: LD_VAR 0 3
70805: PPUSH
70806: LD_INT 16
70808: PPUSH
70809: CALL_OW 183
// AddComExitBuilding ( j ) ;
70813: LD_VAR 0 3
70817: PPUSH
70818: CALL_OW 182
// end ;
70822: GO 70760
70824: POP
70825: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70826: LD_VAR 0 5
70830: PPUSH
70831: LD_INT 11
70833: PPUSH
70834: CALL_OW 325
70838: IFFALSE 71097
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70840: LD_ADDR_VAR 0 4
70844: PUSH
70845: LD_EXP 95
70849: PUSH
70850: LD_VAR 0 2
70854: ARRAY
70855: PPUSH
70856: LD_INT 25
70858: PUSH
70859: LD_INT 16
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PPUSH
70866: CALL_OW 72
70870: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70871: LD_VAR 0 4
70875: PUSH
70876: LD_INT 6
70878: GREATEREQUAL
70879: PUSH
70880: LD_VAR 0 5
70884: PPUSH
70885: LD_INT 2
70887: PPUSH
70888: CALL_OW 325
70892: NOT
70893: OR
70894: IFFALSE 71097
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70896: LD_ADDR_VAR 0 8
70900: PUSH
70901: LD_EXP 66
70905: PUSH
70906: LD_VAR 0 2
70910: ARRAY
70911: PPUSH
70912: LD_INT 2
70914: PUSH
70915: LD_INT 30
70917: PUSH
70918: LD_INT 4
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 30
70927: PUSH
70928: LD_INT 5
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: LIST
70939: PPUSH
70940: CALL_OW 72
70944: ST_TO_ADDR
// if barracks then
70945: LD_VAR 0 8
70949: IFFALSE 71097
// begin selected := 0 ;
70951: LD_ADDR_VAR 0 7
70955: PUSH
70956: LD_INT 0
70958: ST_TO_ADDR
// for j in barracks do
70959: LD_ADDR_VAR 0 3
70963: PUSH
70964: LD_VAR 0 8
70968: PUSH
70969: FOR_IN
70970: IFFALSE 71001
// begin if UnitsInside ( j ) < 6 then
70972: LD_VAR 0 3
70976: PPUSH
70977: CALL_OW 313
70981: PUSH
70982: LD_INT 6
70984: LESS
70985: IFFALSE 70999
// begin selected := j ;
70987: LD_ADDR_VAR 0 7
70991: PUSH
70992: LD_VAR 0 3
70996: ST_TO_ADDR
// break ;
70997: GO 71001
// end ; end ;
70999: GO 70969
71001: POP
71002: POP
// if selected then
71003: LD_VAR 0 7
71007: IFFALSE 71097
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71009: LD_ADDR_VAR 0 3
71013: PUSH
71014: LD_EXP 95
71018: PUSH
71019: LD_VAR 0 2
71023: ARRAY
71024: PPUSH
71025: LD_INT 25
71027: PUSH
71028: LD_INT 12
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PPUSH
71035: CALL_OW 72
71039: PUSH
71040: FOR_IN
71041: IFFALSE 71095
// if not IsInUnit ( j ) and not HasTask ( j ) then
71043: LD_VAR 0 3
71047: PPUSH
71048: CALL_OW 310
71052: NOT
71053: PUSH
71054: LD_VAR 0 3
71058: PPUSH
71059: CALL_OW 314
71063: NOT
71064: AND
71065: IFFALSE 71093
// begin ComEnterUnit ( j , selected ) ;
71067: LD_VAR 0 3
71071: PPUSH
71072: LD_VAR 0 7
71076: PPUSH
71077: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71081: LD_VAR 0 3
71085: PPUSH
71086: LD_INT 15
71088: PPUSH
71089: CALL_OW 183
// end ;
71093: GO 71040
71095: POP
71096: POP
// end ; end ; end ; end ; end ;
71097: GO 70490
71099: POP
71100: POP
// end ;
71101: LD_VAR 0 1
71105: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71106: LD_INT 0
71108: PPUSH
71109: PPUSH
71110: PPUSH
71111: PPUSH
// if not mc_bases then
71112: LD_EXP 66
71116: NOT
71117: IFFALSE 71121
// exit ;
71119: GO 71299
// for i = 1 to mc_bases do
71121: LD_ADDR_VAR 0 2
71125: PUSH
71126: DOUBLE
71127: LD_INT 1
71129: DEC
71130: ST_TO_ADDR
71131: LD_EXP 66
71135: PUSH
71136: FOR_TO
71137: IFFALSE 71297
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71139: LD_ADDR_VAR 0 4
71143: PUSH
71144: LD_EXP 66
71148: PUSH
71149: LD_VAR 0 2
71153: ARRAY
71154: PPUSH
71155: LD_INT 25
71157: PUSH
71158: LD_INT 9
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PPUSH
71165: CALL_OW 72
71169: ST_TO_ADDR
// if not tmp then
71170: LD_VAR 0 4
71174: NOT
71175: IFFALSE 71179
// continue ;
71177: GO 71136
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71179: LD_EXP 92
71183: PUSH
71184: LD_VAR 0 2
71188: ARRAY
71189: PPUSH
71190: LD_INT 29
71192: PPUSH
71193: CALL_OW 325
71197: NOT
71198: PUSH
71199: LD_EXP 92
71203: PUSH
71204: LD_VAR 0 2
71208: ARRAY
71209: PPUSH
71210: LD_INT 28
71212: PPUSH
71213: CALL_OW 325
71217: NOT
71218: AND
71219: IFFALSE 71223
// continue ;
71221: GO 71136
// for j in tmp do
71223: LD_ADDR_VAR 0 3
71227: PUSH
71228: LD_VAR 0 4
71232: PUSH
71233: FOR_IN
71234: IFFALSE 71293
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71236: LD_VAR 0 3
71240: PUSH
71241: LD_EXP 69
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: PUSH
71252: LD_INT 1
71254: ARRAY
71255: IN
71256: NOT
71257: PUSH
71258: LD_VAR 0 3
71262: PUSH
71263: LD_EXP 69
71267: PUSH
71268: LD_VAR 0 2
71272: ARRAY
71273: PUSH
71274: LD_INT 2
71276: ARRAY
71277: IN
71278: NOT
71279: AND
71280: IFFALSE 71291
// ComSpaceTimeShoot ( j ) ;
71282: LD_VAR 0 3
71286: PPUSH
71287: CALL 14545 0 1
71291: GO 71233
71293: POP
71294: POP
// end ;
71295: GO 71136
71297: POP
71298: POP
// end ;
71299: LD_VAR 0 1
71303: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71304: LD_INT 0
71306: PPUSH
71307: PPUSH
71308: PPUSH
71309: PPUSH
71310: PPUSH
71311: PPUSH
71312: PPUSH
71313: PPUSH
71314: PPUSH
// if not mc_bases then
71315: LD_EXP 66
71319: NOT
71320: IFFALSE 71324
// exit ;
71322: GO 71946
// for i = 1 to mc_bases do
71324: LD_ADDR_VAR 0 2
71328: PUSH
71329: DOUBLE
71330: LD_INT 1
71332: DEC
71333: ST_TO_ADDR
71334: LD_EXP 66
71338: PUSH
71339: FOR_TO
71340: IFFALSE 71944
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71342: LD_EXP 101
71346: PUSH
71347: LD_VAR 0 2
71351: ARRAY
71352: NOT
71353: PUSH
71354: LD_INT 38
71356: PPUSH
71357: LD_EXP 92
71361: PUSH
71362: LD_VAR 0 2
71366: ARRAY
71367: PPUSH
71368: CALL_OW 321
71372: PUSH
71373: LD_INT 2
71375: NONEQUAL
71376: OR
71377: IFFALSE 71381
// continue ;
71379: GO 71339
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71381: LD_ADDR_VAR 0 8
71385: PUSH
71386: LD_EXP 66
71390: PUSH
71391: LD_VAR 0 2
71395: ARRAY
71396: PPUSH
71397: LD_INT 30
71399: PUSH
71400: LD_INT 34
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PPUSH
71407: CALL_OW 72
71411: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71412: LD_ADDR_VAR 0 9
71416: PUSH
71417: LD_EXP 66
71421: PUSH
71422: LD_VAR 0 2
71426: ARRAY
71427: PPUSH
71428: LD_INT 25
71430: PUSH
71431: LD_INT 4
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PPUSH
71438: CALL_OW 72
71442: PPUSH
71443: LD_INT 0
71445: PPUSH
71446: CALL 47442 0 2
71450: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71451: LD_VAR 0 9
71455: NOT
71456: PUSH
71457: LD_VAR 0 8
71461: NOT
71462: OR
71463: PUSH
71464: LD_EXP 66
71468: PUSH
71469: LD_VAR 0 2
71473: ARRAY
71474: PPUSH
71475: LD_INT 124
71477: PPUSH
71478: CALL 47442 0 2
71482: OR
71483: IFFALSE 71487
// continue ;
71485: GO 71339
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71487: LD_EXP 102
71491: PUSH
71492: LD_VAR 0 2
71496: ARRAY
71497: PUSH
71498: LD_EXP 101
71502: PUSH
71503: LD_VAR 0 2
71507: ARRAY
71508: LESS
71509: PUSH
71510: LD_EXP 102
71514: PUSH
71515: LD_VAR 0 2
71519: ARRAY
71520: PUSH
71521: LD_VAR 0 8
71525: LESS
71526: AND
71527: IFFALSE 71942
// begin tmp := sci [ 1 ] ;
71529: LD_ADDR_VAR 0 7
71533: PUSH
71534: LD_VAR 0 9
71538: PUSH
71539: LD_INT 1
71541: ARRAY
71542: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71543: LD_VAR 0 7
71547: PPUSH
71548: LD_INT 124
71550: PPUSH
71551: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71555: LD_ADDR_VAR 0 3
71559: PUSH
71560: DOUBLE
71561: LD_EXP 101
71565: PUSH
71566: LD_VAR 0 2
71570: ARRAY
71571: INC
71572: ST_TO_ADDR
71573: LD_EXP 101
71577: PUSH
71578: LD_VAR 0 2
71582: ARRAY
71583: PUSH
71584: FOR_DOWNTO
71585: IFFALSE 71928
// begin if IsInUnit ( tmp ) then
71587: LD_VAR 0 7
71591: PPUSH
71592: CALL_OW 310
71596: IFFALSE 71607
// ComExitBuilding ( tmp ) ;
71598: LD_VAR 0 7
71602: PPUSH
71603: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71607: LD_INT 35
71609: PPUSH
71610: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71614: LD_VAR 0 7
71618: PPUSH
71619: CALL_OW 310
71623: NOT
71624: PUSH
71625: LD_VAR 0 7
71629: PPUSH
71630: CALL_OW 314
71634: NOT
71635: AND
71636: IFFALSE 71607
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71638: LD_ADDR_VAR 0 6
71642: PUSH
71643: LD_VAR 0 7
71647: PPUSH
71648: CALL_OW 250
71652: PUSH
71653: LD_VAR 0 7
71657: PPUSH
71658: CALL_OW 251
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71667: LD_INT 35
71669: PPUSH
71670: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71674: LD_ADDR_VAR 0 4
71678: PUSH
71679: LD_EXP 101
71683: PUSH
71684: LD_VAR 0 2
71688: ARRAY
71689: PUSH
71690: LD_VAR 0 3
71694: ARRAY
71695: PUSH
71696: LD_INT 1
71698: ARRAY
71699: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71700: LD_ADDR_VAR 0 5
71704: PUSH
71705: LD_EXP 101
71709: PUSH
71710: LD_VAR 0 2
71714: ARRAY
71715: PUSH
71716: LD_VAR 0 3
71720: ARRAY
71721: PUSH
71722: LD_INT 2
71724: ARRAY
71725: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71726: LD_VAR 0 7
71730: PPUSH
71731: LD_INT 10
71733: PPUSH
71734: CALL 21141 0 2
71738: PUSH
71739: LD_INT 4
71741: ARRAY
71742: IFFALSE 71780
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71744: LD_VAR 0 7
71748: PPUSH
71749: LD_VAR 0 6
71753: PUSH
71754: LD_INT 1
71756: ARRAY
71757: PPUSH
71758: LD_VAR 0 6
71762: PUSH
71763: LD_INT 2
71765: ARRAY
71766: PPUSH
71767: CALL_OW 111
// wait ( 0 0$10 ) ;
71771: LD_INT 350
71773: PPUSH
71774: CALL_OW 67
// end else
71778: GO 71806
// begin ComMoveXY ( tmp , x , y ) ;
71780: LD_VAR 0 7
71784: PPUSH
71785: LD_VAR 0 4
71789: PPUSH
71790: LD_VAR 0 5
71794: PPUSH
71795: CALL_OW 111
// wait ( 0 0$3 ) ;
71799: LD_INT 105
71801: PPUSH
71802: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71806: LD_VAR 0 7
71810: PPUSH
71811: LD_VAR 0 4
71815: PPUSH
71816: LD_VAR 0 5
71820: PPUSH
71821: CALL_OW 307
71825: IFFALSE 71667
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71827: LD_VAR 0 7
71831: PPUSH
71832: LD_VAR 0 4
71836: PPUSH
71837: LD_VAR 0 5
71841: PPUSH
71842: LD_VAR 0 8
71846: PUSH
71847: LD_VAR 0 3
71851: ARRAY
71852: PPUSH
71853: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71857: LD_INT 35
71859: PPUSH
71860: CALL_OW 67
// until not HasTask ( tmp ) ;
71864: LD_VAR 0 7
71868: PPUSH
71869: CALL_OW 314
71873: NOT
71874: IFFALSE 71857
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71876: LD_ADDR_EXP 102
71880: PUSH
71881: LD_EXP 102
71885: PPUSH
71886: LD_VAR 0 2
71890: PUSH
71891: LD_EXP 102
71895: PUSH
71896: LD_VAR 0 2
71900: ARRAY
71901: PUSH
71902: LD_INT 1
71904: PLUS
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PPUSH
71910: LD_VAR 0 8
71914: PUSH
71915: LD_VAR 0 3
71919: ARRAY
71920: PPUSH
71921: CALL 18548 0 3
71925: ST_TO_ADDR
// end ;
71926: GO 71584
71928: POP
71929: POP
// MC_Reset ( i , 124 ) ;
71930: LD_VAR 0 2
71934: PPUSH
71935: LD_INT 124
71937: PPUSH
71938: CALL 55480 0 2
// end ; end ;
71942: GO 71339
71944: POP
71945: POP
// end ;
71946: LD_VAR 0 1
71950: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71951: LD_INT 0
71953: PPUSH
71954: PPUSH
71955: PPUSH
// if not mc_bases then
71956: LD_EXP 66
71960: NOT
71961: IFFALSE 71965
// exit ;
71963: GO 72571
// for i = 1 to mc_bases do
71965: LD_ADDR_VAR 0 2
71969: PUSH
71970: DOUBLE
71971: LD_INT 1
71973: DEC
71974: ST_TO_ADDR
71975: LD_EXP 66
71979: PUSH
71980: FOR_TO
71981: IFFALSE 72569
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71983: LD_ADDR_VAR 0 3
71987: PUSH
71988: LD_EXP 66
71992: PUSH
71993: LD_VAR 0 2
71997: ARRAY
71998: PPUSH
71999: LD_INT 25
72001: PUSH
72002: LD_INT 4
72004: PUSH
72005: EMPTY
72006: LIST
72007: LIST
72008: PPUSH
72009: CALL_OW 72
72013: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72014: LD_VAR 0 3
72018: NOT
72019: PUSH
72020: LD_EXP 103
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: NOT
72031: OR
72032: PUSH
72033: LD_EXP 66
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: PPUSH
72044: LD_INT 2
72046: PUSH
72047: LD_INT 30
72049: PUSH
72050: LD_INT 0
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 30
72059: PUSH
72060: LD_INT 1
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: LIST
72071: PPUSH
72072: CALL_OW 72
72076: NOT
72077: OR
72078: IFFALSE 72128
// begin if mc_deposits_finder [ i ] then
72080: LD_EXP 104
72084: PUSH
72085: LD_VAR 0 2
72089: ARRAY
72090: IFFALSE 72126
// begin MC_Reset ( i , 125 ) ;
72092: LD_VAR 0 2
72096: PPUSH
72097: LD_INT 125
72099: PPUSH
72100: CALL 55480 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72104: LD_ADDR_EXP 104
72108: PUSH
72109: LD_EXP 104
72113: PPUSH
72114: LD_VAR 0 2
72118: PPUSH
72119: EMPTY
72120: PPUSH
72121: CALL_OW 1
72125: ST_TO_ADDR
// end ; continue ;
72126: GO 71980
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72128: LD_EXP 103
72132: PUSH
72133: LD_VAR 0 2
72137: ARRAY
72138: PUSH
72139: LD_INT 1
72141: ARRAY
72142: PUSH
72143: LD_INT 3
72145: ARRAY
72146: PUSH
72147: LD_INT 1
72149: EQUAL
72150: PUSH
72151: LD_INT 20
72153: PPUSH
72154: LD_EXP 92
72158: PUSH
72159: LD_VAR 0 2
72163: ARRAY
72164: PPUSH
72165: CALL_OW 321
72169: PUSH
72170: LD_INT 2
72172: NONEQUAL
72173: AND
72174: IFFALSE 72224
// begin if mc_deposits_finder [ i ] then
72176: LD_EXP 104
72180: PUSH
72181: LD_VAR 0 2
72185: ARRAY
72186: IFFALSE 72222
// begin MC_Reset ( i , 125 ) ;
72188: LD_VAR 0 2
72192: PPUSH
72193: LD_INT 125
72195: PPUSH
72196: CALL 55480 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72200: LD_ADDR_EXP 104
72204: PUSH
72205: LD_EXP 104
72209: PPUSH
72210: LD_VAR 0 2
72214: PPUSH
72215: EMPTY
72216: PPUSH
72217: CALL_OW 1
72221: ST_TO_ADDR
// end ; continue ;
72222: GO 71980
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72224: LD_EXP 103
72228: PUSH
72229: LD_VAR 0 2
72233: ARRAY
72234: PUSH
72235: LD_INT 1
72237: ARRAY
72238: PUSH
72239: LD_INT 1
72241: ARRAY
72242: PPUSH
72243: LD_EXP 103
72247: PUSH
72248: LD_VAR 0 2
72252: ARRAY
72253: PUSH
72254: LD_INT 1
72256: ARRAY
72257: PUSH
72258: LD_INT 2
72260: ARRAY
72261: PPUSH
72262: LD_EXP 92
72266: PUSH
72267: LD_VAR 0 2
72271: ARRAY
72272: PPUSH
72273: CALL_OW 440
72277: IFFALSE 72320
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72279: LD_ADDR_EXP 103
72283: PUSH
72284: LD_EXP 103
72288: PPUSH
72289: LD_VAR 0 2
72293: PPUSH
72294: LD_EXP 103
72298: PUSH
72299: LD_VAR 0 2
72303: ARRAY
72304: PPUSH
72305: LD_INT 1
72307: PPUSH
72308: CALL_OW 3
72312: PPUSH
72313: CALL_OW 1
72317: ST_TO_ADDR
72318: GO 72567
// begin if not mc_deposits_finder [ i ] then
72320: LD_EXP 104
72324: PUSH
72325: LD_VAR 0 2
72329: ARRAY
72330: NOT
72331: IFFALSE 72383
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72333: LD_ADDR_EXP 104
72337: PUSH
72338: LD_EXP 104
72342: PPUSH
72343: LD_VAR 0 2
72347: PPUSH
72348: LD_VAR 0 3
72352: PUSH
72353: LD_INT 1
72355: ARRAY
72356: PUSH
72357: EMPTY
72358: LIST
72359: PPUSH
72360: CALL_OW 1
72364: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72365: LD_VAR 0 3
72369: PUSH
72370: LD_INT 1
72372: ARRAY
72373: PPUSH
72374: LD_INT 125
72376: PPUSH
72377: CALL_OW 109
// end else
72381: GO 72567
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72383: LD_EXP 104
72387: PUSH
72388: LD_VAR 0 2
72392: ARRAY
72393: PUSH
72394: LD_INT 1
72396: ARRAY
72397: PPUSH
72398: CALL_OW 310
72402: IFFALSE 72425
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72404: LD_EXP 104
72408: PUSH
72409: LD_VAR 0 2
72413: ARRAY
72414: PUSH
72415: LD_INT 1
72417: ARRAY
72418: PPUSH
72419: CALL_OW 122
72423: GO 72567
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72425: LD_EXP 104
72429: PUSH
72430: LD_VAR 0 2
72434: ARRAY
72435: PUSH
72436: LD_INT 1
72438: ARRAY
72439: PPUSH
72440: CALL_OW 314
72444: NOT
72445: PUSH
72446: LD_EXP 104
72450: PUSH
72451: LD_VAR 0 2
72455: ARRAY
72456: PUSH
72457: LD_INT 1
72459: ARRAY
72460: PPUSH
72461: LD_EXP 103
72465: PUSH
72466: LD_VAR 0 2
72470: ARRAY
72471: PUSH
72472: LD_INT 1
72474: ARRAY
72475: PUSH
72476: LD_INT 1
72478: ARRAY
72479: PPUSH
72480: LD_EXP 103
72484: PUSH
72485: LD_VAR 0 2
72489: ARRAY
72490: PUSH
72491: LD_INT 1
72493: ARRAY
72494: PUSH
72495: LD_INT 2
72497: ARRAY
72498: PPUSH
72499: CALL_OW 297
72503: PUSH
72504: LD_INT 6
72506: GREATER
72507: AND
72508: IFFALSE 72567
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72510: LD_EXP 104
72514: PUSH
72515: LD_VAR 0 2
72519: ARRAY
72520: PUSH
72521: LD_INT 1
72523: ARRAY
72524: PPUSH
72525: LD_EXP 103
72529: PUSH
72530: LD_VAR 0 2
72534: ARRAY
72535: PUSH
72536: LD_INT 1
72538: ARRAY
72539: PUSH
72540: LD_INT 1
72542: ARRAY
72543: PPUSH
72544: LD_EXP 103
72548: PUSH
72549: LD_VAR 0 2
72553: ARRAY
72554: PUSH
72555: LD_INT 1
72557: ARRAY
72558: PUSH
72559: LD_INT 2
72561: ARRAY
72562: PPUSH
72563: CALL_OW 111
// end ; end ; end ;
72567: GO 71980
72569: POP
72570: POP
// end ;
72571: LD_VAR 0 1
72575: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72576: LD_INT 0
72578: PPUSH
72579: PPUSH
72580: PPUSH
72581: PPUSH
72582: PPUSH
72583: PPUSH
72584: PPUSH
72585: PPUSH
72586: PPUSH
72587: PPUSH
72588: PPUSH
// if not mc_bases then
72589: LD_EXP 66
72593: NOT
72594: IFFALSE 72598
// exit ;
72596: GO 73538
// for i = 1 to mc_bases do
72598: LD_ADDR_VAR 0 2
72602: PUSH
72603: DOUBLE
72604: LD_INT 1
72606: DEC
72607: ST_TO_ADDR
72608: LD_EXP 66
72612: PUSH
72613: FOR_TO
72614: IFFALSE 73536
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72616: LD_EXP 66
72620: PUSH
72621: LD_VAR 0 2
72625: ARRAY
72626: NOT
72627: PUSH
72628: LD_EXP 89
72632: PUSH
72633: LD_VAR 0 2
72637: ARRAY
72638: OR
72639: IFFALSE 72643
// continue ;
72641: GO 72613
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72643: LD_ADDR_VAR 0 7
72647: PUSH
72648: LD_EXP 66
72652: PUSH
72653: LD_VAR 0 2
72657: ARRAY
72658: PUSH
72659: LD_INT 1
72661: ARRAY
72662: PPUSH
72663: CALL_OW 248
72667: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72668: LD_VAR 0 7
72672: PUSH
72673: LD_INT 3
72675: EQUAL
72676: PUSH
72677: LD_EXP 85
72681: PUSH
72682: LD_VAR 0 2
72686: ARRAY
72687: PUSH
72688: LD_EXP 88
72692: PUSH
72693: LD_VAR 0 2
72697: ARRAY
72698: UNION
72699: PPUSH
72700: LD_INT 33
72702: PUSH
72703: LD_INT 2
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PPUSH
72710: CALL_OW 72
72714: NOT
72715: OR
72716: IFFALSE 72720
// continue ;
72718: GO 72613
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72720: LD_ADDR_VAR 0 9
72724: PUSH
72725: LD_EXP 66
72729: PUSH
72730: LD_VAR 0 2
72734: ARRAY
72735: PPUSH
72736: LD_INT 30
72738: PUSH
72739: LD_INT 36
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PPUSH
72746: CALL_OW 72
72750: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72751: LD_ADDR_VAR 0 10
72755: PUSH
72756: LD_EXP 85
72760: PUSH
72761: LD_VAR 0 2
72765: ARRAY
72766: PPUSH
72767: LD_INT 34
72769: PUSH
72770: LD_INT 31
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PPUSH
72777: CALL_OW 72
72781: ST_TO_ADDR
// if not cts and not mcts then
72782: LD_VAR 0 9
72786: NOT
72787: PUSH
72788: LD_VAR 0 10
72792: NOT
72793: AND
72794: IFFALSE 72798
// continue ;
72796: GO 72613
// x := cts ;
72798: LD_ADDR_VAR 0 11
72802: PUSH
72803: LD_VAR 0 9
72807: ST_TO_ADDR
// if not x then
72808: LD_VAR 0 11
72812: NOT
72813: IFFALSE 72825
// x := mcts ;
72815: LD_ADDR_VAR 0 11
72819: PUSH
72820: LD_VAR 0 10
72824: ST_TO_ADDR
// if not x then
72825: LD_VAR 0 11
72829: NOT
72830: IFFALSE 72834
// continue ;
72832: GO 72613
// if mc_remote_driver [ i ] then
72834: LD_EXP 106
72838: PUSH
72839: LD_VAR 0 2
72843: ARRAY
72844: IFFALSE 73231
// for j in mc_remote_driver [ i ] do
72846: LD_ADDR_VAR 0 3
72850: PUSH
72851: LD_EXP 106
72855: PUSH
72856: LD_VAR 0 2
72860: ARRAY
72861: PUSH
72862: FOR_IN
72863: IFFALSE 73229
// begin if GetClass ( j ) <> 3 then
72865: LD_VAR 0 3
72869: PPUSH
72870: CALL_OW 257
72874: PUSH
72875: LD_INT 3
72877: NONEQUAL
72878: IFFALSE 72931
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72880: LD_ADDR_EXP 106
72884: PUSH
72885: LD_EXP 106
72889: PPUSH
72890: LD_VAR 0 2
72894: PPUSH
72895: LD_EXP 106
72899: PUSH
72900: LD_VAR 0 2
72904: ARRAY
72905: PUSH
72906: LD_VAR 0 3
72910: DIFF
72911: PPUSH
72912: CALL_OW 1
72916: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72917: LD_VAR 0 3
72921: PPUSH
72922: LD_INT 0
72924: PPUSH
72925: CALL_OW 109
// continue ;
72929: GO 72862
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72931: LD_EXP 85
72935: PUSH
72936: LD_VAR 0 2
72940: ARRAY
72941: PPUSH
72942: LD_INT 34
72944: PUSH
72945: LD_INT 31
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 58
72954: PUSH
72955: EMPTY
72956: LIST
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PPUSH
72962: CALL_OW 72
72966: PUSH
72967: LD_VAR 0 3
72971: PPUSH
72972: CALL 47530 0 1
72976: NOT
72977: AND
72978: IFFALSE 73049
// begin if IsInUnit ( j ) then
72980: LD_VAR 0 3
72984: PPUSH
72985: CALL_OW 310
72989: IFFALSE 73000
// ComExitBuilding ( j ) ;
72991: LD_VAR 0 3
72995: PPUSH
72996: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73000: LD_VAR 0 3
73004: PPUSH
73005: LD_EXP 85
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: PPUSH
73016: LD_INT 34
73018: PUSH
73019: LD_INT 31
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 58
73028: PUSH
73029: EMPTY
73030: LIST
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PPUSH
73036: CALL_OW 72
73040: PUSH
73041: LD_INT 1
73043: ARRAY
73044: PPUSH
73045: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73049: LD_VAR 0 3
73053: PPUSH
73054: CALL_OW 310
73058: NOT
73059: PUSH
73060: LD_VAR 0 3
73064: PPUSH
73065: CALL_OW 310
73069: PPUSH
73070: CALL_OW 266
73074: PUSH
73075: LD_INT 36
73077: NONEQUAL
73078: PUSH
73079: LD_VAR 0 3
73083: PPUSH
73084: CALL 47530 0 1
73088: NOT
73089: AND
73090: OR
73091: IFFALSE 73227
// begin if IsInUnit ( j ) then
73093: LD_VAR 0 3
73097: PPUSH
73098: CALL_OW 310
73102: IFFALSE 73113
// ComExitBuilding ( j ) ;
73104: LD_VAR 0 3
73108: PPUSH
73109: CALL_OW 122
// ct := 0 ;
73113: LD_ADDR_VAR 0 8
73117: PUSH
73118: LD_INT 0
73120: ST_TO_ADDR
// for k in x do
73121: LD_ADDR_VAR 0 4
73125: PUSH
73126: LD_VAR 0 11
73130: PUSH
73131: FOR_IN
73132: IFFALSE 73205
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73134: LD_VAR 0 4
73138: PPUSH
73139: CALL_OW 264
73143: PUSH
73144: LD_INT 31
73146: EQUAL
73147: PUSH
73148: LD_VAR 0 4
73152: PPUSH
73153: CALL_OW 311
73157: NOT
73158: AND
73159: PUSH
73160: LD_VAR 0 4
73164: PPUSH
73165: CALL_OW 266
73169: PUSH
73170: LD_INT 36
73172: EQUAL
73173: PUSH
73174: LD_VAR 0 4
73178: PPUSH
73179: CALL_OW 313
73183: PUSH
73184: LD_INT 3
73186: LESS
73187: AND
73188: OR
73189: IFFALSE 73203
// begin ct := k ;
73191: LD_ADDR_VAR 0 8
73195: PUSH
73196: LD_VAR 0 4
73200: ST_TO_ADDR
// break ;
73201: GO 73205
// end ;
73203: GO 73131
73205: POP
73206: POP
// if ct then
73207: LD_VAR 0 8
73211: IFFALSE 73227
// ComEnterUnit ( j , ct ) ;
73213: LD_VAR 0 3
73217: PPUSH
73218: LD_VAR 0 8
73222: PPUSH
73223: CALL_OW 120
// end ; end ;
73227: GO 72862
73229: POP
73230: POP
// places := 0 ;
73231: LD_ADDR_VAR 0 5
73235: PUSH
73236: LD_INT 0
73238: ST_TO_ADDR
// for j = 1 to x do
73239: LD_ADDR_VAR 0 3
73243: PUSH
73244: DOUBLE
73245: LD_INT 1
73247: DEC
73248: ST_TO_ADDR
73249: LD_VAR 0 11
73253: PUSH
73254: FOR_TO
73255: IFFALSE 73331
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73257: LD_VAR 0 11
73261: PUSH
73262: LD_VAR 0 3
73266: ARRAY
73267: PPUSH
73268: CALL_OW 264
73272: PUSH
73273: LD_INT 31
73275: EQUAL
73276: IFFALSE 73294
// places := places + 1 else
73278: LD_ADDR_VAR 0 5
73282: PUSH
73283: LD_VAR 0 5
73287: PUSH
73288: LD_INT 1
73290: PLUS
73291: ST_TO_ADDR
73292: GO 73329
// if GetBType ( x [ j ] ) = b_control_tower then
73294: LD_VAR 0 11
73298: PUSH
73299: LD_VAR 0 3
73303: ARRAY
73304: PPUSH
73305: CALL_OW 266
73309: PUSH
73310: LD_INT 36
73312: EQUAL
73313: IFFALSE 73329
// places := places + 3 ;
73315: LD_ADDR_VAR 0 5
73319: PUSH
73320: LD_VAR 0 5
73324: PUSH
73325: LD_INT 3
73327: PLUS
73328: ST_TO_ADDR
73329: GO 73254
73331: POP
73332: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73333: LD_VAR 0 5
73337: PUSH
73338: LD_INT 0
73340: EQUAL
73341: PUSH
73342: LD_VAR 0 5
73346: PUSH
73347: LD_EXP 106
73351: PUSH
73352: LD_VAR 0 2
73356: ARRAY
73357: LESSEQUAL
73358: OR
73359: IFFALSE 73363
// continue ;
73361: GO 72613
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73363: LD_ADDR_VAR 0 6
73367: PUSH
73368: LD_EXP 66
73372: PUSH
73373: LD_VAR 0 2
73377: ARRAY
73378: PPUSH
73379: LD_INT 25
73381: PUSH
73382: LD_INT 3
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PPUSH
73389: CALL_OW 72
73393: PUSH
73394: LD_EXP 106
73398: PUSH
73399: LD_VAR 0 2
73403: ARRAY
73404: DIFF
73405: PPUSH
73406: LD_INT 3
73408: PPUSH
73409: CALL 48430 0 2
73413: ST_TO_ADDR
// for j in tmp do
73414: LD_ADDR_VAR 0 3
73418: PUSH
73419: LD_VAR 0 6
73423: PUSH
73424: FOR_IN
73425: IFFALSE 73460
// if GetTag ( j ) > 0 then
73427: LD_VAR 0 3
73431: PPUSH
73432: CALL_OW 110
73436: PUSH
73437: LD_INT 0
73439: GREATER
73440: IFFALSE 73458
// tmp := tmp diff j ;
73442: LD_ADDR_VAR 0 6
73446: PUSH
73447: LD_VAR 0 6
73451: PUSH
73452: LD_VAR 0 3
73456: DIFF
73457: ST_TO_ADDR
73458: GO 73424
73460: POP
73461: POP
// if not tmp then
73462: LD_VAR 0 6
73466: NOT
73467: IFFALSE 73471
// continue ;
73469: GO 72613
// if places then
73471: LD_VAR 0 5
73475: IFFALSE 73534
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73477: LD_ADDR_EXP 106
73481: PUSH
73482: LD_EXP 106
73486: PPUSH
73487: LD_VAR 0 2
73491: PPUSH
73492: LD_EXP 106
73496: PUSH
73497: LD_VAR 0 2
73501: ARRAY
73502: PUSH
73503: LD_VAR 0 6
73507: PUSH
73508: LD_INT 1
73510: ARRAY
73511: UNION
73512: PPUSH
73513: CALL_OW 1
73517: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73518: LD_VAR 0 6
73522: PUSH
73523: LD_INT 1
73525: ARRAY
73526: PPUSH
73527: LD_INT 126
73529: PPUSH
73530: CALL_OW 109
// end ; end ;
73534: GO 72613
73536: POP
73537: POP
// end ;
73538: LD_VAR 0 1
73542: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73543: LD_INT 0
73545: PPUSH
73546: PPUSH
73547: PPUSH
73548: PPUSH
73549: PPUSH
73550: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73551: LD_VAR 0 1
73555: NOT
73556: PUSH
73557: LD_VAR 0 2
73561: NOT
73562: OR
73563: PUSH
73564: LD_VAR 0 3
73568: NOT
73569: OR
73570: PUSH
73571: LD_VAR 0 4
73575: PUSH
73576: LD_INT 1
73578: PUSH
73579: LD_INT 2
73581: PUSH
73582: LD_INT 3
73584: PUSH
73585: LD_INT 4
73587: PUSH
73588: LD_INT 5
73590: PUSH
73591: LD_INT 8
73593: PUSH
73594: LD_INT 9
73596: PUSH
73597: LD_INT 15
73599: PUSH
73600: LD_INT 16
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: IN
73614: NOT
73615: OR
73616: IFFALSE 73620
// exit ;
73618: GO 74520
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73620: LD_ADDR_VAR 0 2
73624: PUSH
73625: LD_VAR 0 2
73629: PPUSH
73630: LD_INT 21
73632: PUSH
73633: LD_INT 3
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 24
73642: PUSH
73643: LD_INT 250
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PPUSH
73654: CALL_OW 72
73658: ST_TO_ADDR
// case class of 1 , 15 :
73659: LD_VAR 0 4
73663: PUSH
73664: LD_INT 1
73666: DOUBLE
73667: EQUAL
73668: IFTRUE 73678
73670: LD_INT 15
73672: DOUBLE
73673: EQUAL
73674: IFTRUE 73678
73676: GO 73763
73678: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73679: LD_ADDR_VAR 0 8
73683: PUSH
73684: LD_VAR 0 2
73688: PPUSH
73689: LD_INT 2
73691: PUSH
73692: LD_INT 30
73694: PUSH
73695: LD_INT 32
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 30
73704: PUSH
73705: LD_INT 31
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: LIST
73716: PPUSH
73717: CALL_OW 72
73721: PUSH
73722: LD_VAR 0 2
73726: PPUSH
73727: LD_INT 2
73729: PUSH
73730: LD_INT 30
73732: PUSH
73733: LD_INT 4
73735: PUSH
73736: EMPTY
73737: LIST
73738: LIST
73739: PUSH
73740: LD_INT 30
73742: PUSH
73743: LD_INT 5
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: LIST
73754: PPUSH
73755: CALL_OW 72
73759: ADD
73760: ST_TO_ADDR
73761: GO 74009
73763: LD_INT 2
73765: DOUBLE
73766: EQUAL
73767: IFTRUE 73777
73769: LD_INT 16
73771: DOUBLE
73772: EQUAL
73773: IFTRUE 73777
73775: GO 73823
73777: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73778: LD_ADDR_VAR 0 8
73782: PUSH
73783: LD_VAR 0 2
73787: PPUSH
73788: LD_INT 2
73790: PUSH
73791: LD_INT 30
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 30
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: LIST
73815: PPUSH
73816: CALL_OW 72
73820: ST_TO_ADDR
73821: GO 74009
73823: LD_INT 3
73825: DOUBLE
73826: EQUAL
73827: IFTRUE 73831
73829: GO 73877
73831: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73832: LD_ADDR_VAR 0 8
73836: PUSH
73837: LD_VAR 0 2
73841: PPUSH
73842: LD_INT 2
73844: PUSH
73845: LD_INT 30
73847: PUSH
73848: LD_INT 2
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 30
73857: PUSH
73858: LD_INT 3
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: LIST
73869: PPUSH
73870: CALL_OW 72
73874: ST_TO_ADDR
73875: GO 74009
73877: LD_INT 4
73879: DOUBLE
73880: EQUAL
73881: IFTRUE 73885
73883: GO 73942
73885: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73886: LD_ADDR_VAR 0 8
73890: PUSH
73891: LD_VAR 0 2
73895: PPUSH
73896: LD_INT 2
73898: PUSH
73899: LD_INT 30
73901: PUSH
73902: LD_INT 6
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 30
73911: PUSH
73912: LD_INT 7
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 30
73921: PUSH
73922: LD_INT 8
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: PPUSH
73935: CALL_OW 72
73939: ST_TO_ADDR
73940: GO 74009
73942: LD_INT 5
73944: DOUBLE
73945: EQUAL
73946: IFTRUE 73962
73948: LD_INT 8
73950: DOUBLE
73951: EQUAL
73952: IFTRUE 73962
73954: LD_INT 9
73956: DOUBLE
73957: EQUAL
73958: IFTRUE 73962
73960: GO 74008
73962: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73963: LD_ADDR_VAR 0 8
73967: PUSH
73968: LD_VAR 0 2
73972: PPUSH
73973: LD_INT 2
73975: PUSH
73976: LD_INT 30
73978: PUSH
73979: LD_INT 4
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 30
73988: PUSH
73989: LD_INT 5
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: LIST
74000: PPUSH
74001: CALL_OW 72
74005: ST_TO_ADDR
74006: GO 74009
74008: POP
// if not tmp then
74009: LD_VAR 0 8
74013: NOT
74014: IFFALSE 74018
// exit ;
74016: GO 74520
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74018: LD_VAR 0 4
74022: PUSH
74023: LD_INT 1
74025: PUSH
74026: LD_INT 15
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: IN
74033: PUSH
74034: LD_EXP 75
74038: PUSH
74039: LD_VAR 0 1
74043: ARRAY
74044: AND
74045: IFFALSE 74201
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74047: LD_ADDR_VAR 0 9
74051: PUSH
74052: LD_EXP 75
74056: PUSH
74057: LD_VAR 0 1
74061: ARRAY
74062: PUSH
74063: LD_INT 1
74065: ARRAY
74066: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74067: LD_VAR 0 9
74071: PUSH
74072: LD_EXP 76
74076: PUSH
74077: LD_VAR 0 1
74081: ARRAY
74082: IN
74083: NOT
74084: IFFALSE 74199
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74086: LD_ADDR_EXP 76
74090: PUSH
74091: LD_EXP 76
74095: PPUSH
74096: LD_VAR 0 1
74100: PUSH
74101: LD_EXP 76
74105: PUSH
74106: LD_VAR 0 1
74110: ARRAY
74111: PUSH
74112: LD_INT 1
74114: PLUS
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PPUSH
74120: LD_VAR 0 9
74124: PPUSH
74125: CALL 18548 0 3
74129: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74130: LD_ADDR_EXP 75
74134: PUSH
74135: LD_EXP 75
74139: PPUSH
74140: LD_VAR 0 1
74144: PPUSH
74145: LD_EXP 75
74149: PUSH
74150: LD_VAR 0 1
74154: ARRAY
74155: PUSH
74156: LD_VAR 0 9
74160: DIFF
74161: PPUSH
74162: CALL_OW 1
74166: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74167: LD_VAR 0 3
74171: PPUSH
74172: LD_EXP 76
74176: PUSH
74177: LD_VAR 0 1
74181: ARRAY
74182: PUSH
74183: LD_EXP 76
74187: PUSH
74188: LD_VAR 0 1
74192: ARRAY
74193: ARRAY
74194: PPUSH
74195: CALL_OW 120
// end ; exit ;
74199: GO 74520
// end ; if tmp > 1 then
74201: LD_VAR 0 8
74205: PUSH
74206: LD_INT 1
74208: GREATER
74209: IFFALSE 74313
// for i = 2 to tmp do
74211: LD_ADDR_VAR 0 6
74215: PUSH
74216: DOUBLE
74217: LD_INT 2
74219: DEC
74220: ST_TO_ADDR
74221: LD_VAR 0 8
74225: PUSH
74226: FOR_TO
74227: IFFALSE 74311
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74229: LD_VAR 0 8
74233: PUSH
74234: LD_VAR 0 6
74238: ARRAY
74239: PPUSH
74240: CALL_OW 461
74244: PUSH
74245: LD_INT 6
74247: EQUAL
74248: IFFALSE 74309
// begin x := tmp [ i ] ;
74250: LD_ADDR_VAR 0 9
74254: PUSH
74255: LD_VAR 0 8
74259: PUSH
74260: LD_VAR 0 6
74264: ARRAY
74265: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74266: LD_ADDR_VAR 0 8
74270: PUSH
74271: LD_VAR 0 8
74275: PPUSH
74276: LD_VAR 0 6
74280: PPUSH
74281: CALL_OW 3
74285: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74286: LD_ADDR_VAR 0 8
74290: PUSH
74291: LD_VAR 0 8
74295: PPUSH
74296: LD_INT 1
74298: PPUSH
74299: LD_VAR 0 9
74303: PPUSH
74304: CALL_OW 2
74308: ST_TO_ADDR
// end ;
74309: GO 74226
74311: POP
74312: POP
// for i in tmp do
74313: LD_ADDR_VAR 0 6
74317: PUSH
74318: LD_VAR 0 8
74322: PUSH
74323: FOR_IN
74324: IFFALSE 74393
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74326: LD_VAR 0 6
74330: PPUSH
74331: CALL_OW 313
74335: PUSH
74336: LD_INT 6
74338: LESS
74339: PUSH
74340: LD_VAR 0 6
74344: PPUSH
74345: CALL_OW 266
74349: PUSH
74350: LD_INT 31
74352: PUSH
74353: LD_INT 32
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: IN
74360: NOT
74361: AND
74362: PUSH
74363: LD_VAR 0 6
74367: PPUSH
74368: CALL_OW 313
74372: PUSH
74373: LD_INT 0
74375: EQUAL
74376: OR
74377: IFFALSE 74391
// begin j := i ;
74379: LD_ADDR_VAR 0 7
74383: PUSH
74384: LD_VAR 0 6
74388: ST_TO_ADDR
// break ;
74389: GO 74393
// end ; end ;
74391: GO 74323
74393: POP
74394: POP
// if j then
74395: LD_VAR 0 7
74399: IFFALSE 74417
// ComEnterUnit ( unit , j ) else
74401: LD_VAR 0 3
74405: PPUSH
74406: LD_VAR 0 7
74410: PPUSH
74411: CALL_OW 120
74415: GO 74520
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74417: LD_ADDR_VAR 0 10
74421: PUSH
74422: LD_VAR 0 2
74426: PPUSH
74427: LD_INT 2
74429: PUSH
74430: LD_INT 30
74432: PUSH
74433: LD_INT 0
74435: PUSH
74436: EMPTY
74437: LIST
74438: LIST
74439: PUSH
74440: LD_INT 30
74442: PUSH
74443: LD_INT 1
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: LIST
74454: PPUSH
74455: CALL_OW 72
74459: ST_TO_ADDR
// if depot then
74460: LD_VAR 0 10
74464: IFFALSE 74520
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74466: LD_ADDR_VAR 0 10
74470: PUSH
74471: LD_VAR 0 10
74475: PPUSH
74476: LD_VAR 0 3
74480: PPUSH
74481: CALL_OW 74
74485: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74486: LD_VAR 0 3
74490: PPUSH
74491: LD_VAR 0 10
74495: PPUSH
74496: CALL_OW 296
74500: PUSH
74501: LD_INT 10
74503: GREATER
74504: IFFALSE 74520
// ComStandNearbyBuilding ( unit , depot ) ;
74506: LD_VAR 0 3
74510: PPUSH
74511: LD_VAR 0 10
74515: PPUSH
74516: CALL 15162 0 2
// end ; end ; end ;
74520: LD_VAR 0 5
74524: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74525: LD_INT 0
74527: PPUSH
74528: PPUSH
74529: PPUSH
74530: PPUSH
// if not mc_bases then
74531: LD_EXP 66
74535: NOT
74536: IFFALSE 74540
// exit ;
74538: GO 74779
// for i = 1 to mc_bases do
74540: LD_ADDR_VAR 0 2
74544: PUSH
74545: DOUBLE
74546: LD_INT 1
74548: DEC
74549: ST_TO_ADDR
74550: LD_EXP 66
74554: PUSH
74555: FOR_TO
74556: IFFALSE 74777
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74558: LD_ADDR_VAR 0 4
74562: PUSH
74563: LD_EXP 66
74567: PUSH
74568: LD_VAR 0 2
74572: ARRAY
74573: PPUSH
74574: LD_INT 21
74576: PUSH
74577: LD_INT 1
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PPUSH
74584: CALL_OW 72
74588: PUSH
74589: LD_EXP 95
74593: PUSH
74594: LD_VAR 0 2
74598: ARRAY
74599: UNION
74600: ST_TO_ADDR
// if not tmp then
74601: LD_VAR 0 4
74605: NOT
74606: IFFALSE 74610
// continue ;
74608: GO 74555
// for j in tmp do
74610: LD_ADDR_VAR 0 3
74614: PUSH
74615: LD_VAR 0 4
74619: PUSH
74620: FOR_IN
74621: IFFALSE 74773
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74623: LD_VAR 0 3
74627: PPUSH
74628: CALL_OW 110
74632: NOT
74633: PUSH
74634: LD_VAR 0 3
74638: PPUSH
74639: CALL_OW 314
74643: NOT
74644: AND
74645: PUSH
74646: LD_VAR 0 3
74650: PPUSH
74651: CALL_OW 311
74655: NOT
74656: AND
74657: PUSH
74658: LD_VAR 0 3
74662: PPUSH
74663: CALL_OW 310
74667: NOT
74668: AND
74669: PUSH
74670: LD_VAR 0 3
74674: PUSH
74675: LD_EXP 69
74679: PUSH
74680: LD_VAR 0 2
74684: ARRAY
74685: PUSH
74686: LD_INT 1
74688: ARRAY
74689: IN
74690: NOT
74691: AND
74692: PUSH
74693: LD_VAR 0 3
74697: PUSH
74698: LD_EXP 69
74702: PUSH
74703: LD_VAR 0 2
74707: ARRAY
74708: PUSH
74709: LD_INT 2
74711: ARRAY
74712: IN
74713: NOT
74714: AND
74715: PUSH
74716: LD_VAR 0 3
74720: PUSH
74721: LD_EXP 78
74725: PUSH
74726: LD_VAR 0 2
74730: ARRAY
74731: IN
74732: NOT
74733: AND
74734: IFFALSE 74771
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74736: LD_VAR 0 2
74740: PPUSH
74741: LD_EXP 66
74745: PUSH
74746: LD_VAR 0 2
74750: ARRAY
74751: PPUSH
74752: LD_VAR 0 3
74756: PPUSH
74757: LD_VAR 0 3
74761: PPUSH
74762: CALL_OW 257
74766: PPUSH
74767: CALL 73543 0 4
// end ;
74771: GO 74620
74773: POP
74774: POP
// end ;
74775: GO 74555
74777: POP
74778: POP
// end ;
74779: LD_VAR 0 1
74783: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74784: LD_INT 0
74786: PPUSH
74787: PPUSH
74788: PPUSH
74789: PPUSH
74790: PPUSH
74791: PPUSH
// if not mc_bases [ base ] then
74792: LD_EXP 66
74796: PUSH
74797: LD_VAR 0 1
74801: ARRAY
74802: NOT
74803: IFFALSE 74807
// exit ;
74805: GO 74989
// tmp := [ ] ;
74807: LD_ADDR_VAR 0 6
74811: PUSH
74812: EMPTY
74813: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74814: LD_ADDR_VAR 0 7
74818: PUSH
74819: LD_VAR 0 3
74823: PPUSH
74824: LD_INT 0
74826: PPUSH
74827: CALL_OW 517
74831: ST_TO_ADDR
// if not list then
74832: LD_VAR 0 7
74836: NOT
74837: IFFALSE 74841
// exit ;
74839: GO 74989
// for i = 1 to amount do
74841: LD_ADDR_VAR 0 5
74845: PUSH
74846: DOUBLE
74847: LD_INT 1
74849: DEC
74850: ST_TO_ADDR
74851: LD_VAR 0 2
74855: PUSH
74856: FOR_TO
74857: IFFALSE 74937
// begin x := rand ( 1 , list [ 1 ] ) ;
74859: LD_ADDR_VAR 0 8
74863: PUSH
74864: LD_INT 1
74866: PPUSH
74867: LD_VAR 0 7
74871: PUSH
74872: LD_INT 1
74874: ARRAY
74875: PPUSH
74876: CALL_OW 12
74880: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74881: LD_ADDR_VAR 0 6
74885: PUSH
74886: LD_VAR 0 6
74890: PPUSH
74891: LD_VAR 0 5
74895: PPUSH
74896: LD_VAR 0 7
74900: PUSH
74901: LD_INT 1
74903: ARRAY
74904: PUSH
74905: LD_VAR 0 8
74909: ARRAY
74910: PUSH
74911: LD_VAR 0 7
74915: PUSH
74916: LD_INT 2
74918: ARRAY
74919: PUSH
74920: LD_VAR 0 8
74924: ARRAY
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PPUSH
74930: CALL_OW 1
74934: ST_TO_ADDR
// end ;
74935: GO 74856
74937: POP
74938: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74939: LD_ADDR_EXP 79
74943: PUSH
74944: LD_EXP 79
74948: PPUSH
74949: LD_VAR 0 1
74953: PPUSH
74954: LD_VAR 0 6
74958: PPUSH
74959: CALL_OW 1
74963: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74964: LD_ADDR_EXP 81
74968: PUSH
74969: LD_EXP 81
74973: PPUSH
74974: LD_VAR 0 1
74978: PPUSH
74979: LD_VAR 0 3
74983: PPUSH
74984: CALL_OW 1
74988: ST_TO_ADDR
// end ;
74989: LD_VAR 0 4
74993: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74994: LD_INT 0
74996: PPUSH
// if not mc_bases [ base ] then
74997: LD_EXP 66
75001: PUSH
75002: LD_VAR 0 1
75006: ARRAY
75007: NOT
75008: IFFALSE 75012
// exit ;
75010: GO 75037
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75012: LD_ADDR_EXP 71
75016: PUSH
75017: LD_EXP 71
75021: PPUSH
75022: LD_VAR 0 1
75026: PPUSH
75027: LD_VAR 0 2
75031: PPUSH
75032: CALL_OW 1
75036: ST_TO_ADDR
// end ;
75037: LD_VAR 0 3
75041: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75042: LD_INT 0
75044: PPUSH
// if not mc_bases [ base ] then
75045: LD_EXP 66
75049: PUSH
75050: LD_VAR 0 1
75054: ARRAY
75055: NOT
75056: IFFALSE 75060
// exit ;
75058: GO 75097
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75060: LD_ADDR_EXP 71
75064: PUSH
75065: LD_EXP 71
75069: PPUSH
75070: LD_VAR 0 1
75074: PPUSH
75075: LD_EXP 71
75079: PUSH
75080: LD_VAR 0 1
75084: ARRAY
75085: PUSH
75086: LD_VAR 0 2
75090: UNION
75091: PPUSH
75092: CALL_OW 1
75096: ST_TO_ADDR
// end ;
75097: LD_VAR 0 3
75101: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75102: LD_INT 0
75104: PPUSH
// if not mc_bases [ base ] then
75105: LD_EXP 66
75109: PUSH
75110: LD_VAR 0 1
75114: ARRAY
75115: NOT
75116: IFFALSE 75120
// exit ;
75118: GO 75145
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75120: LD_ADDR_EXP 87
75124: PUSH
75125: LD_EXP 87
75129: PPUSH
75130: LD_VAR 0 1
75134: PPUSH
75135: LD_VAR 0 2
75139: PPUSH
75140: CALL_OW 1
75144: ST_TO_ADDR
// end ;
75145: LD_VAR 0 3
75149: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75150: LD_INT 0
75152: PPUSH
// if not mc_bases [ base ] then
75153: LD_EXP 66
75157: PUSH
75158: LD_VAR 0 1
75162: ARRAY
75163: NOT
75164: IFFALSE 75168
// exit ;
75166: GO 75205
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75168: LD_ADDR_EXP 87
75172: PUSH
75173: LD_EXP 87
75177: PPUSH
75178: LD_VAR 0 1
75182: PPUSH
75183: LD_EXP 87
75187: PUSH
75188: LD_VAR 0 1
75192: ARRAY
75193: PUSH
75194: LD_VAR 0 2
75198: ADD
75199: PPUSH
75200: CALL_OW 1
75204: ST_TO_ADDR
// end ;
75205: LD_VAR 0 3
75209: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75210: LD_INT 0
75212: PPUSH
// if not mc_bases [ base ] then
75213: LD_EXP 66
75217: PUSH
75218: LD_VAR 0 1
75222: ARRAY
75223: NOT
75224: IFFALSE 75228
// exit ;
75226: GO 75282
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75228: LD_ADDR_EXP 88
75232: PUSH
75233: LD_EXP 88
75237: PPUSH
75238: LD_VAR 0 1
75242: PPUSH
75243: LD_VAR 0 2
75247: PPUSH
75248: CALL_OW 1
75252: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75253: LD_ADDR_EXP 77
75257: PUSH
75258: LD_EXP 77
75262: PPUSH
75263: LD_VAR 0 1
75267: PPUSH
75268: LD_VAR 0 2
75272: PUSH
75273: LD_INT 0
75275: PLUS
75276: PPUSH
75277: CALL_OW 1
75281: ST_TO_ADDR
// end ;
75282: LD_VAR 0 3
75286: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75287: LD_INT 0
75289: PPUSH
// if not mc_bases [ base ] then
75290: LD_EXP 66
75294: PUSH
75295: LD_VAR 0 1
75299: ARRAY
75300: NOT
75301: IFFALSE 75305
// exit ;
75303: GO 75330
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75305: LD_ADDR_EXP 77
75309: PUSH
75310: LD_EXP 77
75314: PPUSH
75315: LD_VAR 0 1
75319: PPUSH
75320: LD_VAR 0 2
75324: PPUSH
75325: CALL_OW 1
75329: ST_TO_ADDR
// end ;
75330: LD_VAR 0 3
75334: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75335: LD_INT 0
75337: PPUSH
75338: PPUSH
75339: PPUSH
75340: PPUSH
// if not mc_bases [ base ] then
75341: LD_EXP 66
75345: PUSH
75346: LD_VAR 0 1
75350: ARRAY
75351: NOT
75352: IFFALSE 75356
// exit ;
75354: GO 75421
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75356: LD_ADDR_EXP 86
75360: PUSH
75361: LD_EXP 86
75365: PPUSH
75366: LD_VAR 0 1
75370: PUSH
75371: LD_EXP 86
75375: PUSH
75376: LD_VAR 0 1
75380: ARRAY
75381: PUSH
75382: LD_INT 1
75384: PLUS
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PPUSH
75390: LD_VAR 0 1
75394: PUSH
75395: LD_VAR 0 2
75399: PUSH
75400: LD_VAR 0 3
75404: PUSH
75405: LD_VAR 0 4
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: PPUSH
75416: CALL 18548 0 3
75420: ST_TO_ADDR
// end ;
75421: LD_VAR 0 5
75425: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75426: LD_INT 0
75428: PPUSH
// if not mc_bases [ base ] then
75429: LD_EXP 66
75433: PUSH
75434: LD_VAR 0 1
75438: ARRAY
75439: NOT
75440: IFFALSE 75444
// exit ;
75442: GO 75469
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75444: LD_ADDR_EXP 103
75448: PUSH
75449: LD_EXP 103
75453: PPUSH
75454: LD_VAR 0 1
75458: PPUSH
75459: LD_VAR 0 2
75463: PPUSH
75464: CALL_OW 1
75468: ST_TO_ADDR
// end ;
75469: LD_VAR 0 3
75473: RET
// export function MC_GetMinesField ( base ) ; begin
75474: LD_INT 0
75476: PPUSH
// result := mc_mines [ base ] ;
75477: LD_ADDR_VAR 0 2
75481: PUSH
75482: LD_EXP 79
75486: PUSH
75487: LD_VAR 0 1
75491: ARRAY
75492: ST_TO_ADDR
// end ;
75493: LD_VAR 0 2
75497: RET
// export function MC_GetProduceList ( base ) ; begin
75498: LD_INT 0
75500: PPUSH
// result := mc_produce [ base ] ;
75501: LD_ADDR_VAR 0 2
75505: PUSH
75506: LD_EXP 87
75510: PUSH
75511: LD_VAR 0 1
75515: ARRAY
75516: ST_TO_ADDR
// end ;
75517: LD_VAR 0 2
75521: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75522: LD_INT 0
75524: PPUSH
75525: PPUSH
// if not mc_bases then
75526: LD_EXP 66
75530: NOT
75531: IFFALSE 75535
// exit ;
75533: GO 75600
// if mc_bases [ base ] then
75535: LD_EXP 66
75539: PUSH
75540: LD_VAR 0 1
75544: ARRAY
75545: IFFALSE 75600
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75547: LD_ADDR_VAR 0 3
75551: PUSH
75552: LD_EXP 66
75556: PUSH
75557: LD_VAR 0 1
75561: ARRAY
75562: PPUSH
75563: LD_INT 30
75565: PUSH
75566: LD_VAR 0 2
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PPUSH
75575: CALL_OW 72
75579: ST_TO_ADDR
// if result then
75580: LD_VAR 0 3
75584: IFFALSE 75600
// result := result [ 1 ] ;
75586: LD_ADDR_VAR 0 3
75590: PUSH
75591: LD_VAR 0 3
75595: PUSH
75596: LD_INT 1
75598: ARRAY
75599: ST_TO_ADDR
// end ; end ;
75600: LD_VAR 0 3
75604: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75605: LD_INT 0
75607: PPUSH
75608: PPUSH
// if not mc_bases then
75609: LD_EXP 66
75613: NOT
75614: IFFALSE 75618
// exit ;
75616: GO 75663
// if mc_bases [ base ] then
75618: LD_EXP 66
75622: PUSH
75623: LD_VAR 0 1
75627: ARRAY
75628: IFFALSE 75663
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75630: LD_ADDR_VAR 0 3
75634: PUSH
75635: LD_EXP 66
75639: PUSH
75640: LD_VAR 0 1
75644: ARRAY
75645: PPUSH
75646: LD_INT 30
75648: PUSH
75649: LD_VAR 0 2
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PPUSH
75658: CALL_OW 72
75662: ST_TO_ADDR
// end ;
75663: LD_VAR 0 3
75667: RET
// export function MC_SetTame ( base , area ) ; begin
75668: LD_INT 0
75670: PPUSH
// if not mc_bases or not base then
75671: LD_EXP 66
75675: NOT
75676: PUSH
75677: LD_VAR 0 1
75681: NOT
75682: OR
75683: IFFALSE 75687
// exit ;
75685: GO 75712
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75687: LD_ADDR_EXP 94
75691: PUSH
75692: LD_EXP 94
75696: PPUSH
75697: LD_VAR 0 1
75701: PPUSH
75702: LD_VAR 0 2
75706: PPUSH
75707: CALL_OW 1
75711: ST_TO_ADDR
// end ;
75712: LD_VAR 0 3
75716: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75717: LD_INT 0
75719: PPUSH
75720: PPUSH
// if not mc_bases or not base then
75721: LD_EXP 66
75725: NOT
75726: PUSH
75727: LD_VAR 0 1
75731: NOT
75732: OR
75733: IFFALSE 75737
// exit ;
75735: GO 75839
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75737: LD_ADDR_VAR 0 4
75741: PUSH
75742: LD_EXP 66
75746: PUSH
75747: LD_VAR 0 1
75751: ARRAY
75752: PPUSH
75753: LD_INT 30
75755: PUSH
75756: LD_VAR 0 2
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PPUSH
75765: CALL_OW 72
75769: ST_TO_ADDR
// if not tmp then
75770: LD_VAR 0 4
75774: NOT
75775: IFFALSE 75779
// exit ;
75777: GO 75839
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75779: LD_ADDR_EXP 98
75783: PUSH
75784: LD_EXP 98
75788: PPUSH
75789: LD_VAR 0 1
75793: PPUSH
75794: LD_EXP 98
75798: PUSH
75799: LD_VAR 0 1
75803: ARRAY
75804: PPUSH
75805: LD_EXP 98
75809: PUSH
75810: LD_VAR 0 1
75814: ARRAY
75815: PUSH
75816: LD_INT 1
75818: PLUS
75819: PPUSH
75820: LD_VAR 0 4
75824: PUSH
75825: LD_INT 1
75827: ARRAY
75828: PPUSH
75829: CALL_OW 2
75833: PPUSH
75834: CALL_OW 1
75838: ST_TO_ADDR
// end ;
75839: LD_VAR 0 3
75843: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75844: LD_INT 0
75846: PPUSH
75847: PPUSH
// if not mc_bases or not base or not kinds then
75848: LD_EXP 66
75852: NOT
75853: PUSH
75854: LD_VAR 0 1
75858: NOT
75859: OR
75860: PUSH
75861: LD_VAR 0 2
75865: NOT
75866: OR
75867: IFFALSE 75871
// exit ;
75869: GO 75932
// for i in kinds do
75871: LD_ADDR_VAR 0 4
75875: PUSH
75876: LD_VAR 0 2
75880: PUSH
75881: FOR_IN
75882: IFFALSE 75930
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75884: LD_ADDR_EXP 100
75888: PUSH
75889: LD_EXP 100
75893: PPUSH
75894: LD_VAR 0 1
75898: PUSH
75899: LD_EXP 100
75903: PUSH
75904: LD_VAR 0 1
75908: ARRAY
75909: PUSH
75910: LD_INT 1
75912: PLUS
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PPUSH
75918: LD_VAR 0 4
75922: PPUSH
75923: CALL 18548 0 3
75927: ST_TO_ADDR
75928: GO 75881
75930: POP
75931: POP
// end ;
75932: LD_VAR 0 3
75936: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75937: LD_INT 0
75939: PPUSH
// if not mc_bases or not base or not areas then
75940: LD_EXP 66
75944: NOT
75945: PUSH
75946: LD_VAR 0 1
75950: NOT
75951: OR
75952: PUSH
75953: LD_VAR 0 2
75957: NOT
75958: OR
75959: IFFALSE 75963
// exit ;
75961: GO 75988
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75963: LD_ADDR_EXP 84
75967: PUSH
75968: LD_EXP 84
75972: PPUSH
75973: LD_VAR 0 1
75977: PPUSH
75978: LD_VAR 0 2
75982: PPUSH
75983: CALL_OW 1
75987: ST_TO_ADDR
// end ;
75988: LD_VAR 0 3
75992: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75993: LD_INT 0
75995: PPUSH
// if not mc_bases or not base or not teleports_exit then
75996: LD_EXP 66
76000: NOT
76001: PUSH
76002: LD_VAR 0 1
76006: NOT
76007: OR
76008: PUSH
76009: LD_VAR 0 2
76013: NOT
76014: OR
76015: IFFALSE 76019
// exit ;
76017: GO 76044
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76019: LD_ADDR_EXP 101
76023: PUSH
76024: LD_EXP 101
76028: PPUSH
76029: LD_VAR 0 1
76033: PPUSH
76034: LD_VAR 0 2
76038: PPUSH
76039: CALL_OW 1
76043: ST_TO_ADDR
// end ;
76044: LD_VAR 0 3
76048: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76049: LD_INT 0
76051: PPUSH
76052: PPUSH
76053: PPUSH
// if not mc_bases or not base or not ext_list then
76054: LD_EXP 66
76058: NOT
76059: PUSH
76060: LD_VAR 0 1
76064: NOT
76065: OR
76066: PUSH
76067: LD_VAR 0 5
76071: NOT
76072: OR
76073: IFFALSE 76077
// exit ;
76075: GO 76250
// tmp := GetFacExtXYD ( x , y , d ) ;
76077: LD_ADDR_VAR 0 8
76081: PUSH
76082: LD_VAR 0 2
76086: PPUSH
76087: LD_VAR 0 3
76091: PPUSH
76092: LD_VAR 0 4
76096: PPUSH
76097: CALL 47560 0 3
76101: ST_TO_ADDR
// if not tmp then
76102: LD_VAR 0 8
76106: NOT
76107: IFFALSE 76111
// exit ;
76109: GO 76250
// for i in tmp do
76111: LD_ADDR_VAR 0 7
76115: PUSH
76116: LD_VAR 0 8
76120: PUSH
76121: FOR_IN
76122: IFFALSE 76248
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76124: LD_ADDR_EXP 71
76128: PUSH
76129: LD_EXP 71
76133: PPUSH
76134: LD_VAR 0 1
76138: PPUSH
76139: LD_EXP 71
76143: PUSH
76144: LD_VAR 0 1
76148: ARRAY
76149: PPUSH
76150: LD_EXP 71
76154: PUSH
76155: LD_VAR 0 1
76159: ARRAY
76160: PUSH
76161: LD_INT 1
76163: PLUS
76164: PPUSH
76165: LD_VAR 0 5
76169: PUSH
76170: LD_INT 1
76172: ARRAY
76173: PUSH
76174: LD_VAR 0 7
76178: PUSH
76179: LD_INT 1
76181: ARRAY
76182: PUSH
76183: LD_VAR 0 7
76187: PUSH
76188: LD_INT 2
76190: ARRAY
76191: PUSH
76192: LD_VAR 0 7
76196: PUSH
76197: LD_INT 3
76199: ARRAY
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: PPUSH
76207: CALL_OW 2
76211: PPUSH
76212: CALL_OW 1
76216: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76217: LD_ADDR_VAR 0 5
76221: PUSH
76222: LD_VAR 0 5
76226: PPUSH
76227: LD_INT 1
76229: PPUSH
76230: CALL_OW 3
76234: ST_TO_ADDR
// if not ext_list then
76235: LD_VAR 0 5
76239: NOT
76240: IFFALSE 76246
// exit ;
76242: POP
76243: POP
76244: GO 76250
// end ;
76246: GO 76121
76248: POP
76249: POP
// end ;
76250: LD_VAR 0 6
76254: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76255: LD_INT 0
76257: PPUSH
// if not mc_bases or not base or not weapon_list then
76258: LD_EXP 66
76262: NOT
76263: PUSH
76264: LD_VAR 0 1
76268: NOT
76269: OR
76270: PUSH
76271: LD_VAR 0 2
76275: NOT
76276: OR
76277: IFFALSE 76281
// exit ;
76279: GO 76306
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76281: LD_ADDR_EXP 105
76285: PUSH
76286: LD_EXP 105
76290: PPUSH
76291: LD_VAR 0 1
76295: PPUSH
76296: LD_VAR 0 2
76300: PPUSH
76301: CALL_OW 1
76305: ST_TO_ADDR
// end ;
76306: LD_VAR 0 3
76310: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76311: LD_INT 0
76313: PPUSH
// if not mc_bases or not base or not tech_list then
76314: LD_EXP 66
76318: NOT
76319: PUSH
76320: LD_VAR 0 1
76324: NOT
76325: OR
76326: PUSH
76327: LD_VAR 0 2
76331: NOT
76332: OR
76333: IFFALSE 76337
// exit ;
76335: GO 76362
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76337: LD_ADDR_EXP 93
76341: PUSH
76342: LD_EXP 93
76346: PPUSH
76347: LD_VAR 0 1
76351: PPUSH
76352: LD_VAR 0 2
76356: PPUSH
76357: CALL_OW 1
76361: ST_TO_ADDR
// end ;
76362: LD_VAR 0 3
76366: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76367: LD_INT 0
76369: PPUSH
// if not mc_bases or not parking_area or not base then
76370: LD_EXP 66
76374: NOT
76375: PUSH
76376: LD_VAR 0 2
76380: NOT
76381: OR
76382: PUSH
76383: LD_VAR 0 1
76387: NOT
76388: OR
76389: IFFALSE 76393
// exit ;
76391: GO 76418
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76393: LD_ADDR_EXP 90
76397: PUSH
76398: LD_EXP 90
76402: PPUSH
76403: LD_VAR 0 1
76407: PPUSH
76408: LD_VAR 0 2
76412: PPUSH
76413: CALL_OW 1
76417: ST_TO_ADDR
// end ;
76418: LD_VAR 0 3
76422: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76423: LD_INT 0
76425: PPUSH
// if not mc_bases or not base or not scan_area then
76426: LD_EXP 66
76430: NOT
76431: PUSH
76432: LD_VAR 0 1
76436: NOT
76437: OR
76438: PUSH
76439: LD_VAR 0 2
76443: NOT
76444: OR
76445: IFFALSE 76449
// exit ;
76447: GO 76474
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76449: LD_ADDR_EXP 91
76453: PUSH
76454: LD_EXP 91
76458: PPUSH
76459: LD_VAR 0 1
76463: PPUSH
76464: LD_VAR 0 2
76468: PPUSH
76469: CALL_OW 1
76473: ST_TO_ADDR
// end ;
76474: LD_VAR 0 3
76478: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76479: LD_INT 0
76481: PPUSH
76482: PPUSH
// if not mc_bases or not base then
76483: LD_EXP 66
76487: NOT
76488: PUSH
76489: LD_VAR 0 1
76493: NOT
76494: OR
76495: IFFALSE 76499
// exit ;
76497: GO 76563
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76499: LD_ADDR_VAR 0 3
76503: PUSH
76504: LD_INT 1
76506: PUSH
76507: LD_INT 2
76509: PUSH
76510: LD_INT 3
76512: PUSH
76513: LD_INT 4
76515: PUSH
76516: LD_INT 11
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76526: LD_ADDR_EXP 93
76530: PUSH
76531: LD_EXP 93
76535: PPUSH
76536: LD_VAR 0 1
76540: PPUSH
76541: LD_EXP 93
76545: PUSH
76546: LD_VAR 0 1
76550: ARRAY
76551: PUSH
76552: LD_VAR 0 3
76556: DIFF
76557: PPUSH
76558: CALL_OW 1
76562: ST_TO_ADDR
// end ;
76563: LD_VAR 0 2
76567: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76568: LD_INT 0
76570: PPUSH
// result := mc_vehicles [ base ] ;
76571: LD_ADDR_VAR 0 3
76575: PUSH
76576: LD_EXP 85
76580: PUSH
76581: LD_VAR 0 1
76585: ARRAY
76586: ST_TO_ADDR
// if onlyCombat then
76587: LD_VAR 0 2
76591: IFFALSE 76769
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76593: LD_ADDR_VAR 0 3
76597: PUSH
76598: LD_VAR 0 3
76602: PUSH
76603: LD_VAR 0 3
76607: PPUSH
76608: LD_INT 2
76610: PUSH
76611: LD_INT 34
76613: PUSH
76614: LD_INT 12
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 34
76623: PUSH
76624: LD_INT 51
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 34
76633: PUSH
76634: LD_EXP 49
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: PUSH
76643: LD_INT 34
76645: PUSH
76646: LD_INT 32
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: PUSH
76653: LD_INT 34
76655: PUSH
76656: LD_INT 13
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 34
76665: PUSH
76666: LD_INT 52
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 34
76675: PUSH
76676: LD_EXP 54
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 34
76687: PUSH
76688: LD_INT 14
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 34
76697: PUSH
76698: LD_INT 53
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 34
76707: PUSH
76708: LD_EXP 48
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 34
76719: PUSH
76720: LD_INT 31
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 34
76729: PUSH
76730: LD_INT 48
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 34
76739: PUSH
76740: LD_INT 8
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: PPUSH
76763: CALL_OW 72
76767: DIFF
76768: ST_TO_ADDR
// end ; end_of_file
76769: LD_VAR 0 3
76773: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76774: LD_INT 0
76776: PPUSH
76777: PPUSH
76778: PPUSH
// if not mc_bases or not skirmish then
76779: LD_EXP 66
76783: NOT
76784: PUSH
76785: LD_EXP 64
76789: NOT
76790: OR
76791: IFFALSE 76795
// exit ;
76793: GO 76960
// for i = 1 to mc_bases do
76795: LD_ADDR_VAR 0 4
76799: PUSH
76800: DOUBLE
76801: LD_INT 1
76803: DEC
76804: ST_TO_ADDR
76805: LD_EXP 66
76809: PUSH
76810: FOR_TO
76811: IFFALSE 76958
// begin if sci in mc_bases [ i ] then
76813: LD_VAR 0 2
76817: PUSH
76818: LD_EXP 66
76822: PUSH
76823: LD_VAR 0 4
76827: ARRAY
76828: IN
76829: IFFALSE 76956
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76831: LD_ADDR_EXP 95
76835: PUSH
76836: LD_EXP 95
76840: PPUSH
76841: LD_VAR 0 4
76845: PUSH
76846: LD_EXP 95
76850: PUSH
76851: LD_VAR 0 4
76855: ARRAY
76856: PUSH
76857: LD_INT 1
76859: PLUS
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PPUSH
76865: LD_VAR 0 1
76869: PPUSH
76870: CALL 18548 0 3
76874: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76875: LD_ADDR_VAR 0 5
76879: PUSH
76880: LD_EXP 66
76884: PUSH
76885: LD_VAR 0 4
76889: ARRAY
76890: PPUSH
76891: LD_INT 2
76893: PUSH
76894: LD_INT 30
76896: PUSH
76897: LD_INT 0
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 30
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: EMPTY
76911: LIST
76912: LIST
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: LIST
76918: PPUSH
76919: CALL_OW 72
76923: PPUSH
76924: LD_VAR 0 1
76928: PPUSH
76929: CALL_OW 74
76933: ST_TO_ADDR
// if tmp then
76934: LD_VAR 0 5
76938: IFFALSE 76954
// ComStandNearbyBuilding ( ape , tmp ) ;
76940: LD_VAR 0 1
76944: PPUSH
76945: LD_VAR 0 5
76949: PPUSH
76950: CALL 15162 0 2
// break ;
76954: GO 76958
// end ; end ;
76956: GO 76810
76958: POP
76959: POP
// end ;
76960: LD_VAR 0 3
76964: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76965: LD_INT 0
76967: PPUSH
76968: PPUSH
76969: PPUSH
// if not mc_bases or not skirmish then
76970: LD_EXP 66
76974: NOT
76975: PUSH
76976: LD_EXP 64
76980: NOT
76981: OR
76982: IFFALSE 76986
// exit ;
76984: GO 77075
// for i = 1 to mc_bases do
76986: LD_ADDR_VAR 0 4
76990: PUSH
76991: DOUBLE
76992: LD_INT 1
76994: DEC
76995: ST_TO_ADDR
76996: LD_EXP 66
77000: PUSH
77001: FOR_TO
77002: IFFALSE 77073
// begin if building in mc_busy_turret_list [ i ] then
77004: LD_VAR 0 1
77008: PUSH
77009: LD_EXP 76
77013: PUSH
77014: LD_VAR 0 4
77018: ARRAY
77019: IN
77020: IFFALSE 77071
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77022: LD_ADDR_VAR 0 5
77026: PUSH
77027: LD_EXP 76
77031: PUSH
77032: LD_VAR 0 4
77036: ARRAY
77037: PUSH
77038: LD_VAR 0 1
77042: DIFF
77043: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77044: LD_ADDR_EXP 76
77048: PUSH
77049: LD_EXP 76
77053: PPUSH
77054: LD_VAR 0 4
77058: PPUSH
77059: LD_VAR 0 5
77063: PPUSH
77064: CALL_OW 1
77068: ST_TO_ADDR
// break ;
77069: GO 77073
// end ; end ;
77071: GO 77001
77073: POP
77074: POP
// end ;
77075: LD_VAR 0 3
77079: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77080: LD_INT 0
77082: PPUSH
77083: PPUSH
77084: PPUSH
// if not mc_bases or not skirmish then
77085: LD_EXP 66
77089: NOT
77090: PUSH
77091: LD_EXP 64
77095: NOT
77096: OR
77097: IFFALSE 77101
// exit ;
77099: GO 77300
// for i = 1 to mc_bases do
77101: LD_ADDR_VAR 0 5
77105: PUSH
77106: DOUBLE
77107: LD_INT 1
77109: DEC
77110: ST_TO_ADDR
77111: LD_EXP 66
77115: PUSH
77116: FOR_TO
77117: IFFALSE 77298
// if building in mc_bases [ i ] then
77119: LD_VAR 0 1
77123: PUSH
77124: LD_EXP 66
77128: PUSH
77129: LD_VAR 0 5
77133: ARRAY
77134: IN
77135: IFFALSE 77296
// begin tmp := mc_bases [ i ] diff building ;
77137: LD_ADDR_VAR 0 6
77141: PUSH
77142: LD_EXP 66
77146: PUSH
77147: LD_VAR 0 5
77151: ARRAY
77152: PUSH
77153: LD_VAR 0 1
77157: DIFF
77158: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77159: LD_ADDR_EXP 66
77163: PUSH
77164: LD_EXP 66
77168: PPUSH
77169: LD_VAR 0 5
77173: PPUSH
77174: LD_VAR 0 6
77178: PPUSH
77179: CALL_OW 1
77183: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77184: LD_VAR 0 1
77188: PUSH
77189: LD_EXP 74
77193: PUSH
77194: LD_VAR 0 5
77198: ARRAY
77199: IN
77200: IFFALSE 77239
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77202: LD_ADDR_EXP 74
77206: PUSH
77207: LD_EXP 74
77211: PPUSH
77212: LD_VAR 0 5
77216: PPUSH
77217: LD_EXP 74
77221: PUSH
77222: LD_VAR 0 5
77226: ARRAY
77227: PUSH
77228: LD_VAR 0 1
77232: DIFF
77233: PPUSH
77234: CALL_OW 1
77238: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77239: LD_VAR 0 1
77243: PUSH
77244: LD_EXP 75
77248: PUSH
77249: LD_VAR 0 5
77253: ARRAY
77254: IN
77255: IFFALSE 77294
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77257: LD_ADDR_EXP 75
77261: PUSH
77262: LD_EXP 75
77266: PPUSH
77267: LD_VAR 0 5
77271: PPUSH
77272: LD_EXP 75
77276: PUSH
77277: LD_VAR 0 5
77281: ARRAY
77282: PUSH
77283: LD_VAR 0 1
77287: DIFF
77288: PPUSH
77289: CALL_OW 1
77293: ST_TO_ADDR
// break ;
77294: GO 77298
// end ;
77296: GO 77116
77298: POP
77299: POP
// end ;
77300: LD_VAR 0 4
77304: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77305: LD_INT 0
77307: PPUSH
77308: PPUSH
77309: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77310: LD_EXP 66
77314: NOT
77315: PUSH
77316: LD_EXP 64
77320: NOT
77321: OR
77322: PUSH
77323: LD_VAR 0 3
77327: PUSH
77328: LD_EXP 92
77332: IN
77333: NOT
77334: OR
77335: IFFALSE 77339
// exit ;
77337: GO 77462
// for i = 1 to mc_vehicles do
77339: LD_ADDR_VAR 0 6
77343: PUSH
77344: DOUBLE
77345: LD_INT 1
77347: DEC
77348: ST_TO_ADDR
77349: LD_EXP 85
77353: PUSH
77354: FOR_TO
77355: IFFALSE 77460
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77357: LD_VAR 0 2
77361: PUSH
77362: LD_EXP 85
77366: PUSH
77367: LD_VAR 0 6
77371: ARRAY
77372: IN
77373: PUSH
77374: LD_VAR 0 1
77378: PUSH
77379: LD_EXP 85
77383: PUSH
77384: LD_VAR 0 6
77388: ARRAY
77389: IN
77390: OR
77391: IFFALSE 77458
// begin tmp := mc_vehicles [ i ] diff old ;
77393: LD_ADDR_VAR 0 7
77397: PUSH
77398: LD_EXP 85
77402: PUSH
77403: LD_VAR 0 6
77407: ARRAY
77408: PUSH
77409: LD_VAR 0 2
77413: DIFF
77414: ST_TO_ADDR
// tmp := tmp diff new ;
77415: LD_ADDR_VAR 0 7
77419: PUSH
77420: LD_VAR 0 7
77424: PUSH
77425: LD_VAR 0 1
77429: DIFF
77430: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77431: LD_ADDR_EXP 85
77435: PUSH
77436: LD_EXP 85
77440: PPUSH
77441: LD_VAR 0 6
77445: PPUSH
77446: LD_VAR 0 7
77450: PPUSH
77451: CALL_OW 1
77455: ST_TO_ADDR
// break ;
77456: GO 77460
// end ;
77458: GO 77354
77460: POP
77461: POP
// end ;
77462: LD_VAR 0 5
77466: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77467: LD_INT 0
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
// if not mc_bases or not skirmish then
77473: LD_EXP 66
77477: NOT
77478: PUSH
77479: LD_EXP 64
77483: NOT
77484: OR
77485: IFFALSE 77489
// exit ;
77487: GO 77872
// side := GetSide ( vehicle ) ;
77489: LD_ADDR_VAR 0 5
77493: PUSH
77494: LD_VAR 0 1
77498: PPUSH
77499: CALL_OW 255
77503: ST_TO_ADDR
// for i = 1 to mc_bases do
77504: LD_ADDR_VAR 0 4
77508: PUSH
77509: DOUBLE
77510: LD_INT 1
77512: DEC
77513: ST_TO_ADDR
77514: LD_EXP 66
77518: PUSH
77519: FOR_TO
77520: IFFALSE 77870
// begin if factory in mc_bases [ i ] then
77522: LD_VAR 0 2
77526: PUSH
77527: LD_EXP 66
77531: PUSH
77532: LD_VAR 0 4
77536: ARRAY
77537: IN
77538: IFFALSE 77868
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77540: LD_EXP 88
77544: PUSH
77545: LD_VAR 0 4
77549: ARRAY
77550: PUSH
77551: LD_EXP 77
77555: PUSH
77556: LD_VAR 0 4
77560: ARRAY
77561: LESS
77562: PUSH
77563: LD_VAR 0 1
77567: PPUSH
77568: CALL_OW 264
77572: PUSH
77573: LD_INT 31
77575: PUSH
77576: LD_INT 32
77578: PUSH
77579: LD_INT 51
77581: PUSH
77582: LD_EXP 49
77586: PUSH
77587: LD_INT 12
77589: PUSH
77590: LD_INT 30
77592: PUSH
77593: LD_EXP 48
77597: PUSH
77598: LD_INT 11
77600: PUSH
77601: LD_INT 53
77603: PUSH
77604: LD_INT 14
77606: PUSH
77607: LD_EXP 52
77611: PUSH
77612: LD_INT 29
77614: PUSH
77615: LD_EXP 50
77619: PUSH
77620: LD_INT 13
77622: PUSH
77623: LD_INT 52
77625: PUSH
77626: LD_EXP 54
77630: PUSH
77631: LD_INT 48
77633: PUSH
77634: LD_INT 8
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: LIST
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: IN
77657: NOT
77658: AND
77659: IFFALSE 77707
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77661: LD_ADDR_EXP 88
77665: PUSH
77666: LD_EXP 88
77670: PPUSH
77671: LD_VAR 0 4
77675: PUSH
77676: LD_EXP 88
77680: PUSH
77681: LD_VAR 0 4
77685: ARRAY
77686: PUSH
77687: LD_INT 1
77689: PLUS
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PPUSH
77695: LD_VAR 0 1
77699: PPUSH
77700: CALL 18548 0 3
77704: ST_TO_ADDR
77705: GO 77751
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77707: LD_ADDR_EXP 85
77711: PUSH
77712: LD_EXP 85
77716: PPUSH
77717: LD_VAR 0 4
77721: PUSH
77722: LD_EXP 85
77726: PUSH
77727: LD_VAR 0 4
77731: ARRAY
77732: PUSH
77733: LD_INT 1
77735: PLUS
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: PPUSH
77741: LD_VAR 0 1
77745: PPUSH
77746: CALL 18548 0 3
77750: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77751: LD_VAR 0 1
77755: PPUSH
77756: CALL_OW 263
77760: PUSH
77761: LD_INT 2
77763: EQUAL
77764: IFFALSE 77784
// begin repeat wait ( 0 0$1 ) ;
77766: LD_INT 35
77768: PPUSH
77769: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77773: LD_VAR 0 1
77777: PPUSH
77778: CALL_OW 312
77782: IFFALSE 77766
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77784: LD_VAR 0 1
77788: PPUSH
77789: LD_EXP 90
77793: PUSH
77794: LD_VAR 0 4
77798: ARRAY
77799: PPUSH
77800: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77804: LD_VAR 0 1
77808: PPUSH
77809: CALL_OW 263
77813: PUSH
77814: LD_INT 1
77816: NONEQUAL
77817: IFFALSE 77821
// break ;
77819: GO 77870
// repeat wait ( 0 0$1 ) ;
77821: LD_INT 35
77823: PPUSH
77824: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77828: LD_VAR 0 1
77832: PPUSH
77833: LD_EXP 90
77837: PUSH
77838: LD_VAR 0 4
77842: ARRAY
77843: PPUSH
77844: CALL_OW 308
77848: IFFALSE 77821
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77850: LD_VAR 0 1
77854: PPUSH
77855: CALL_OW 311
77859: PPUSH
77860: CALL_OW 121
// exit ;
77864: POP
77865: POP
77866: GO 77872
// end ; end ;
77868: GO 77519
77870: POP
77871: POP
// end ;
77872: LD_VAR 0 3
77876: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77877: LD_INT 0
77879: PPUSH
77880: PPUSH
77881: PPUSH
77882: PPUSH
// if not mc_bases or not skirmish then
77883: LD_EXP 66
77887: NOT
77888: PUSH
77889: LD_EXP 64
77893: NOT
77894: OR
77895: IFFALSE 77899
// exit ;
77897: GO 78252
// repeat wait ( 0 0$1 ) ;
77899: LD_INT 35
77901: PPUSH
77902: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77906: LD_VAR 0 2
77910: PPUSH
77911: LD_VAR 0 3
77915: PPUSH
77916: CALL_OW 284
77920: IFFALSE 77899
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77922: LD_VAR 0 2
77926: PPUSH
77927: LD_VAR 0 3
77931: PPUSH
77932: CALL_OW 283
77936: PUSH
77937: LD_INT 4
77939: EQUAL
77940: IFFALSE 77944
// exit ;
77942: GO 78252
// for i = 1 to mc_bases do
77944: LD_ADDR_VAR 0 7
77948: PUSH
77949: DOUBLE
77950: LD_INT 1
77952: DEC
77953: ST_TO_ADDR
77954: LD_EXP 66
77958: PUSH
77959: FOR_TO
77960: IFFALSE 78250
// begin if mc_crates_area [ i ] then
77962: LD_EXP 84
77966: PUSH
77967: LD_VAR 0 7
77971: ARRAY
77972: IFFALSE 78083
// for j in mc_crates_area [ i ] do
77974: LD_ADDR_VAR 0 8
77978: PUSH
77979: LD_EXP 84
77983: PUSH
77984: LD_VAR 0 7
77988: ARRAY
77989: PUSH
77990: FOR_IN
77991: IFFALSE 78081
// if InArea ( x , y , j ) then
77993: LD_VAR 0 2
77997: PPUSH
77998: LD_VAR 0 3
78002: PPUSH
78003: LD_VAR 0 8
78007: PPUSH
78008: CALL_OW 309
78012: IFFALSE 78079
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78014: LD_ADDR_EXP 82
78018: PUSH
78019: LD_EXP 82
78023: PPUSH
78024: LD_VAR 0 7
78028: PUSH
78029: LD_EXP 82
78033: PUSH
78034: LD_VAR 0 7
78038: ARRAY
78039: PUSH
78040: LD_INT 1
78042: PLUS
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PPUSH
78048: LD_VAR 0 4
78052: PUSH
78053: LD_VAR 0 2
78057: PUSH
78058: LD_VAR 0 3
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: LIST
78067: PPUSH
78068: CALL 18548 0 3
78072: ST_TO_ADDR
// exit ;
78073: POP
78074: POP
78075: POP
78076: POP
78077: GO 78252
// end ;
78079: GO 77990
78081: POP
78082: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78083: LD_ADDR_VAR 0 9
78087: PUSH
78088: LD_EXP 66
78092: PUSH
78093: LD_VAR 0 7
78097: ARRAY
78098: PPUSH
78099: LD_INT 2
78101: PUSH
78102: LD_INT 30
78104: PUSH
78105: LD_INT 0
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PUSH
78112: LD_INT 30
78114: PUSH
78115: LD_INT 1
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: LIST
78126: PPUSH
78127: CALL_OW 72
78131: ST_TO_ADDR
// if not depot then
78132: LD_VAR 0 9
78136: NOT
78137: IFFALSE 78141
// continue ;
78139: GO 77959
// for j in depot do
78141: LD_ADDR_VAR 0 8
78145: PUSH
78146: LD_VAR 0 9
78150: PUSH
78151: FOR_IN
78152: IFFALSE 78246
// if GetDistUnitXY ( j , x , y ) < 30 then
78154: LD_VAR 0 8
78158: PPUSH
78159: LD_VAR 0 2
78163: PPUSH
78164: LD_VAR 0 3
78168: PPUSH
78169: CALL_OW 297
78173: PUSH
78174: LD_INT 30
78176: LESS
78177: IFFALSE 78244
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78179: LD_ADDR_EXP 82
78183: PUSH
78184: LD_EXP 82
78188: PPUSH
78189: LD_VAR 0 7
78193: PUSH
78194: LD_EXP 82
78198: PUSH
78199: LD_VAR 0 7
78203: ARRAY
78204: PUSH
78205: LD_INT 1
78207: PLUS
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PPUSH
78213: LD_VAR 0 4
78217: PUSH
78218: LD_VAR 0 2
78222: PUSH
78223: LD_VAR 0 3
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: LIST
78232: PPUSH
78233: CALL 18548 0 3
78237: ST_TO_ADDR
// exit ;
78238: POP
78239: POP
78240: POP
78241: POP
78242: GO 78252
// end ;
78244: GO 78151
78246: POP
78247: POP
// end ;
78248: GO 77959
78250: POP
78251: POP
// end ;
78252: LD_VAR 0 6
78256: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78257: LD_INT 0
78259: PPUSH
78260: PPUSH
78261: PPUSH
78262: PPUSH
// if not mc_bases or not skirmish then
78263: LD_EXP 66
78267: NOT
78268: PUSH
78269: LD_EXP 64
78273: NOT
78274: OR
78275: IFFALSE 78279
// exit ;
78277: GO 78556
// side := GetSide ( lab ) ;
78279: LD_ADDR_VAR 0 4
78283: PUSH
78284: LD_VAR 0 2
78288: PPUSH
78289: CALL_OW 255
78293: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78294: LD_VAR 0 4
78298: PUSH
78299: LD_EXP 92
78303: IN
78304: NOT
78305: PUSH
78306: LD_EXP 93
78310: NOT
78311: OR
78312: PUSH
78313: LD_EXP 66
78317: NOT
78318: OR
78319: IFFALSE 78323
// exit ;
78321: GO 78556
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78323: LD_ADDR_EXP 93
78327: PUSH
78328: LD_EXP 93
78332: PPUSH
78333: LD_VAR 0 4
78337: PPUSH
78338: LD_EXP 93
78342: PUSH
78343: LD_VAR 0 4
78347: ARRAY
78348: PUSH
78349: LD_VAR 0 1
78353: DIFF
78354: PPUSH
78355: CALL_OW 1
78359: ST_TO_ADDR
// for i = 1 to mc_bases do
78360: LD_ADDR_VAR 0 5
78364: PUSH
78365: DOUBLE
78366: LD_INT 1
78368: DEC
78369: ST_TO_ADDR
78370: LD_EXP 66
78374: PUSH
78375: FOR_TO
78376: IFFALSE 78554
// begin if lab in mc_bases [ i ] then
78378: LD_VAR 0 2
78382: PUSH
78383: LD_EXP 66
78387: PUSH
78388: LD_VAR 0 5
78392: ARRAY
78393: IN
78394: IFFALSE 78552
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78396: LD_VAR 0 1
78400: PUSH
78401: LD_INT 11
78403: PUSH
78404: LD_INT 4
78406: PUSH
78407: LD_INT 3
78409: PUSH
78410: LD_INT 2
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: IN
78419: PUSH
78420: LD_EXP 96
78424: PUSH
78425: LD_VAR 0 5
78429: ARRAY
78430: AND
78431: IFFALSE 78552
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78433: LD_ADDR_VAR 0 6
78437: PUSH
78438: LD_EXP 96
78442: PUSH
78443: LD_VAR 0 5
78447: ARRAY
78448: PUSH
78449: LD_INT 1
78451: ARRAY
78452: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78453: LD_ADDR_EXP 96
78457: PUSH
78458: LD_EXP 96
78462: PPUSH
78463: LD_VAR 0 5
78467: PPUSH
78468: EMPTY
78469: PPUSH
78470: CALL_OW 1
78474: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78475: LD_VAR 0 6
78479: PPUSH
78480: LD_INT 0
78482: PPUSH
78483: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78487: LD_VAR 0 6
78491: PPUSH
78492: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78496: LD_ADDR_EXP 95
78500: PUSH
78501: LD_EXP 95
78505: PPUSH
78506: LD_VAR 0 5
78510: PPUSH
78511: LD_EXP 95
78515: PUSH
78516: LD_VAR 0 5
78520: ARRAY
78521: PPUSH
78522: LD_INT 1
78524: PPUSH
78525: LD_VAR 0 6
78529: PPUSH
78530: CALL_OW 2
78534: PPUSH
78535: CALL_OW 1
78539: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78540: LD_VAR 0 5
78544: PPUSH
78545: LD_INT 112
78547: PPUSH
78548: CALL 55480 0 2
// end ; end ; end ;
78552: GO 78375
78554: POP
78555: POP
// end ;
78556: LD_VAR 0 3
78560: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78561: LD_INT 0
78563: PPUSH
78564: PPUSH
78565: PPUSH
78566: PPUSH
78567: PPUSH
78568: PPUSH
78569: PPUSH
78570: PPUSH
// if not mc_bases or not skirmish then
78571: LD_EXP 66
78575: NOT
78576: PUSH
78577: LD_EXP 64
78581: NOT
78582: OR
78583: IFFALSE 78587
// exit ;
78585: GO 79958
// for i = 1 to mc_bases do
78587: LD_ADDR_VAR 0 3
78591: PUSH
78592: DOUBLE
78593: LD_INT 1
78595: DEC
78596: ST_TO_ADDR
78597: LD_EXP 66
78601: PUSH
78602: FOR_TO
78603: IFFALSE 79956
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78605: LD_VAR 0 1
78609: PUSH
78610: LD_EXP 66
78614: PUSH
78615: LD_VAR 0 3
78619: ARRAY
78620: IN
78621: PUSH
78622: LD_VAR 0 1
78626: PUSH
78627: LD_EXP 73
78631: PUSH
78632: LD_VAR 0 3
78636: ARRAY
78637: IN
78638: OR
78639: PUSH
78640: LD_VAR 0 1
78644: PUSH
78645: LD_EXP 88
78649: PUSH
78650: LD_VAR 0 3
78654: ARRAY
78655: IN
78656: OR
78657: PUSH
78658: LD_VAR 0 1
78662: PUSH
78663: LD_EXP 85
78667: PUSH
78668: LD_VAR 0 3
78672: ARRAY
78673: IN
78674: OR
78675: PUSH
78676: LD_VAR 0 1
78680: PUSH
78681: LD_EXP 95
78685: PUSH
78686: LD_VAR 0 3
78690: ARRAY
78691: IN
78692: OR
78693: PUSH
78694: LD_VAR 0 1
78698: PUSH
78699: LD_EXP 96
78703: PUSH
78704: LD_VAR 0 3
78708: ARRAY
78709: IN
78710: OR
78711: IFFALSE 79954
// begin if un in mc_ape [ i ] then
78713: LD_VAR 0 1
78717: PUSH
78718: LD_EXP 95
78722: PUSH
78723: LD_VAR 0 3
78727: ARRAY
78728: IN
78729: IFFALSE 78768
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78731: LD_ADDR_EXP 95
78735: PUSH
78736: LD_EXP 95
78740: PPUSH
78741: LD_VAR 0 3
78745: PPUSH
78746: LD_EXP 95
78750: PUSH
78751: LD_VAR 0 3
78755: ARRAY
78756: PUSH
78757: LD_VAR 0 1
78761: DIFF
78762: PPUSH
78763: CALL_OW 1
78767: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78768: LD_VAR 0 1
78772: PUSH
78773: LD_EXP 96
78777: PUSH
78778: LD_VAR 0 3
78782: ARRAY
78783: IN
78784: IFFALSE 78808
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78786: LD_ADDR_EXP 96
78790: PUSH
78791: LD_EXP 96
78795: PPUSH
78796: LD_VAR 0 3
78800: PPUSH
78801: EMPTY
78802: PPUSH
78803: CALL_OW 1
78807: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78808: LD_VAR 0 1
78812: PPUSH
78813: CALL_OW 247
78817: PUSH
78818: LD_INT 2
78820: EQUAL
78821: PUSH
78822: LD_VAR 0 1
78826: PPUSH
78827: CALL_OW 110
78831: PUSH
78832: LD_INT 20
78834: EQUAL
78835: PUSH
78836: LD_VAR 0 1
78840: PUSH
78841: LD_EXP 88
78845: PUSH
78846: LD_VAR 0 3
78850: ARRAY
78851: IN
78852: OR
78853: PUSH
78854: LD_VAR 0 1
78858: PPUSH
78859: CALL_OW 264
78863: PUSH
78864: LD_INT 12
78866: PUSH
78867: LD_INT 51
78869: PUSH
78870: LD_EXP 49
78874: PUSH
78875: LD_INT 32
78877: PUSH
78878: LD_INT 13
78880: PUSH
78881: LD_INT 52
78883: PUSH
78884: LD_INT 31
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: LIST
78895: IN
78896: OR
78897: AND
78898: IFFALSE 79206
// begin if un in mc_defender [ i ] then
78900: LD_VAR 0 1
78904: PUSH
78905: LD_EXP 88
78909: PUSH
78910: LD_VAR 0 3
78914: ARRAY
78915: IN
78916: IFFALSE 78955
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78918: LD_ADDR_EXP 88
78922: PUSH
78923: LD_EXP 88
78927: PPUSH
78928: LD_VAR 0 3
78932: PPUSH
78933: LD_EXP 88
78937: PUSH
78938: LD_VAR 0 3
78942: ARRAY
78943: PUSH
78944: LD_VAR 0 1
78948: DIFF
78949: PPUSH
78950: CALL_OW 1
78954: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78955: LD_ADDR_VAR 0 8
78959: PUSH
78960: LD_VAR 0 3
78964: PPUSH
78965: LD_INT 3
78967: PPUSH
78968: CALL 75605 0 2
78972: ST_TO_ADDR
// if fac then
78973: LD_VAR 0 8
78977: IFFALSE 79206
// begin for j in fac do
78979: LD_ADDR_VAR 0 4
78983: PUSH
78984: LD_VAR 0 8
78988: PUSH
78989: FOR_IN
78990: IFFALSE 79204
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78992: LD_ADDR_VAR 0 9
78996: PUSH
78997: LD_VAR 0 8
79001: PPUSH
79002: LD_VAR 0 1
79006: PPUSH
79007: CALL_OW 265
79011: PPUSH
79012: LD_VAR 0 1
79016: PPUSH
79017: CALL_OW 262
79021: PPUSH
79022: LD_VAR 0 1
79026: PPUSH
79027: CALL_OW 263
79031: PPUSH
79032: LD_VAR 0 1
79036: PPUSH
79037: CALL_OW 264
79041: PPUSH
79042: CALL 16080 0 5
79046: ST_TO_ADDR
// if components then
79047: LD_VAR 0 9
79051: IFFALSE 79202
// begin if GetWeapon ( un ) = ar_control_tower then
79053: LD_VAR 0 1
79057: PPUSH
79058: CALL_OW 264
79062: PUSH
79063: LD_INT 31
79065: EQUAL
79066: IFFALSE 79183
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79068: LD_VAR 0 1
79072: PPUSH
79073: CALL_OW 311
79077: PPUSH
79078: LD_INT 0
79080: PPUSH
79081: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79085: LD_ADDR_EXP 106
79089: PUSH
79090: LD_EXP 106
79094: PPUSH
79095: LD_VAR 0 3
79099: PPUSH
79100: LD_EXP 106
79104: PUSH
79105: LD_VAR 0 3
79109: ARRAY
79110: PUSH
79111: LD_VAR 0 1
79115: PPUSH
79116: CALL_OW 311
79120: DIFF
79121: PPUSH
79122: CALL_OW 1
79126: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79127: LD_ADDR_VAR 0 7
79131: PUSH
79132: LD_EXP 87
79136: PUSH
79137: LD_VAR 0 3
79141: ARRAY
79142: PPUSH
79143: LD_INT 1
79145: PPUSH
79146: LD_VAR 0 9
79150: PPUSH
79151: CALL_OW 2
79155: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79156: LD_ADDR_EXP 87
79160: PUSH
79161: LD_EXP 87
79165: PPUSH
79166: LD_VAR 0 3
79170: PPUSH
79171: LD_VAR 0 7
79175: PPUSH
79176: CALL_OW 1
79180: ST_TO_ADDR
// end else
79181: GO 79200
// MC_InsertProduceList ( i , [ components ] ) ;
79183: LD_VAR 0 3
79187: PPUSH
79188: LD_VAR 0 9
79192: PUSH
79193: EMPTY
79194: LIST
79195: PPUSH
79196: CALL 75150 0 2
// break ;
79200: GO 79204
// end ; end ;
79202: GO 78989
79204: POP
79205: POP
// end ; end ; if GetType ( un ) = unit_building then
79206: LD_VAR 0 1
79210: PPUSH
79211: CALL_OW 247
79215: PUSH
79216: LD_INT 3
79218: EQUAL
79219: IFFALSE 79622
// begin btype := GetBType ( un ) ;
79221: LD_ADDR_VAR 0 5
79225: PUSH
79226: LD_VAR 0 1
79230: PPUSH
79231: CALL_OW 266
79235: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79236: LD_VAR 0 5
79240: PUSH
79241: LD_INT 29
79243: PUSH
79244: LD_INT 30
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: IN
79251: IFFALSE 79324
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79253: LD_VAR 0 1
79257: PPUSH
79258: CALL_OW 250
79262: PPUSH
79263: LD_VAR 0 1
79267: PPUSH
79268: CALL_OW 251
79272: PPUSH
79273: LD_VAR 0 1
79277: PPUSH
79278: CALL_OW 255
79282: PPUSH
79283: CALL_OW 440
79287: NOT
79288: IFFALSE 79324
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79290: LD_VAR 0 1
79294: PPUSH
79295: CALL_OW 250
79299: PPUSH
79300: LD_VAR 0 1
79304: PPUSH
79305: CALL_OW 251
79309: PPUSH
79310: LD_VAR 0 1
79314: PPUSH
79315: CALL_OW 255
79319: PPUSH
79320: CALL_OW 441
// end ; if btype = b_warehouse then
79324: LD_VAR 0 5
79328: PUSH
79329: LD_INT 1
79331: EQUAL
79332: IFFALSE 79350
// begin btype := b_depot ;
79334: LD_ADDR_VAR 0 5
79338: PUSH
79339: LD_INT 0
79341: ST_TO_ADDR
// pos := 1 ;
79342: LD_ADDR_VAR 0 6
79346: PUSH
79347: LD_INT 1
79349: ST_TO_ADDR
// end ; if btype = b_factory then
79350: LD_VAR 0 5
79354: PUSH
79355: LD_INT 3
79357: EQUAL
79358: IFFALSE 79376
// begin btype := b_workshop ;
79360: LD_ADDR_VAR 0 5
79364: PUSH
79365: LD_INT 2
79367: ST_TO_ADDR
// pos := 1 ;
79368: LD_ADDR_VAR 0 6
79372: PUSH
79373: LD_INT 1
79375: ST_TO_ADDR
// end ; if btype = b_barracks then
79376: LD_VAR 0 5
79380: PUSH
79381: LD_INT 5
79383: EQUAL
79384: IFFALSE 79394
// btype := b_armoury ;
79386: LD_ADDR_VAR 0 5
79390: PUSH
79391: LD_INT 4
79393: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79394: LD_VAR 0 5
79398: PUSH
79399: LD_INT 7
79401: PUSH
79402: LD_INT 8
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: IN
79409: IFFALSE 79419
// btype := b_lab ;
79411: LD_ADDR_VAR 0 5
79415: PUSH
79416: LD_INT 6
79418: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79419: LD_ADDR_EXP 71
79423: PUSH
79424: LD_EXP 71
79428: PPUSH
79429: LD_VAR 0 3
79433: PUSH
79434: LD_EXP 71
79438: PUSH
79439: LD_VAR 0 3
79443: ARRAY
79444: PUSH
79445: LD_INT 1
79447: PLUS
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PPUSH
79453: LD_VAR 0 5
79457: PUSH
79458: LD_VAR 0 1
79462: PPUSH
79463: CALL_OW 250
79467: PUSH
79468: LD_VAR 0 1
79472: PPUSH
79473: CALL_OW 251
79477: PUSH
79478: LD_VAR 0 1
79482: PPUSH
79483: CALL_OW 254
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: PPUSH
79494: CALL 18548 0 3
79498: ST_TO_ADDR
// if pos = 1 then
79499: LD_VAR 0 6
79503: PUSH
79504: LD_INT 1
79506: EQUAL
79507: IFFALSE 79622
// begin tmp := mc_build_list [ i ] ;
79509: LD_ADDR_VAR 0 7
79513: PUSH
79514: LD_EXP 71
79518: PUSH
79519: LD_VAR 0 3
79523: ARRAY
79524: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79525: LD_VAR 0 7
79529: PPUSH
79530: LD_INT 2
79532: PUSH
79533: LD_INT 30
79535: PUSH
79536: LD_INT 0
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 30
79545: PUSH
79546: LD_INT 1
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: LIST
79557: PPUSH
79558: CALL_OW 72
79562: IFFALSE 79572
// pos := 2 ;
79564: LD_ADDR_VAR 0 6
79568: PUSH
79569: LD_INT 2
79571: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79572: LD_ADDR_VAR 0 7
79576: PUSH
79577: LD_VAR 0 7
79581: PPUSH
79582: LD_VAR 0 6
79586: PPUSH
79587: LD_VAR 0 7
79591: PPUSH
79592: CALL 18874 0 3
79596: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79597: LD_ADDR_EXP 71
79601: PUSH
79602: LD_EXP 71
79606: PPUSH
79607: LD_VAR 0 3
79611: PPUSH
79612: LD_VAR 0 7
79616: PPUSH
79617: CALL_OW 1
79621: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79622: LD_VAR 0 1
79626: PUSH
79627: LD_EXP 66
79631: PUSH
79632: LD_VAR 0 3
79636: ARRAY
79637: IN
79638: IFFALSE 79677
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79640: LD_ADDR_EXP 66
79644: PUSH
79645: LD_EXP 66
79649: PPUSH
79650: LD_VAR 0 3
79654: PPUSH
79655: LD_EXP 66
79659: PUSH
79660: LD_VAR 0 3
79664: ARRAY
79665: PUSH
79666: LD_VAR 0 1
79670: DIFF
79671: PPUSH
79672: CALL_OW 1
79676: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79677: LD_VAR 0 1
79681: PUSH
79682: LD_EXP 73
79686: PUSH
79687: LD_VAR 0 3
79691: ARRAY
79692: IN
79693: IFFALSE 79732
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79695: LD_ADDR_EXP 73
79699: PUSH
79700: LD_EXP 73
79704: PPUSH
79705: LD_VAR 0 3
79709: PPUSH
79710: LD_EXP 73
79714: PUSH
79715: LD_VAR 0 3
79719: ARRAY
79720: PUSH
79721: LD_VAR 0 1
79725: DIFF
79726: PPUSH
79727: CALL_OW 1
79731: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79732: LD_VAR 0 1
79736: PUSH
79737: LD_EXP 85
79741: PUSH
79742: LD_VAR 0 3
79746: ARRAY
79747: IN
79748: IFFALSE 79787
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79750: LD_ADDR_EXP 85
79754: PUSH
79755: LD_EXP 85
79759: PPUSH
79760: LD_VAR 0 3
79764: PPUSH
79765: LD_EXP 85
79769: PUSH
79770: LD_VAR 0 3
79774: ARRAY
79775: PUSH
79776: LD_VAR 0 1
79780: DIFF
79781: PPUSH
79782: CALL_OW 1
79786: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79787: LD_VAR 0 1
79791: PUSH
79792: LD_EXP 88
79796: PUSH
79797: LD_VAR 0 3
79801: ARRAY
79802: IN
79803: IFFALSE 79842
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79805: LD_ADDR_EXP 88
79809: PUSH
79810: LD_EXP 88
79814: PPUSH
79815: LD_VAR 0 3
79819: PPUSH
79820: LD_EXP 88
79824: PUSH
79825: LD_VAR 0 3
79829: ARRAY
79830: PUSH
79831: LD_VAR 0 1
79835: DIFF
79836: PPUSH
79837: CALL_OW 1
79841: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79842: LD_VAR 0 1
79846: PUSH
79847: LD_EXP 75
79851: PUSH
79852: LD_VAR 0 3
79856: ARRAY
79857: IN
79858: IFFALSE 79897
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79860: LD_ADDR_EXP 75
79864: PUSH
79865: LD_EXP 75
79869: PPUSH
79870: LD_VAR 0 3
79874: PPUSH
79875: LD_EXP 75
79879: PUSH
79880: LD_VAR 0 3
79884: ARRAY
79885: PUSH
79886: LD_VAR 0 1
79890: DIFF
79891: PPUSH
79892: CALL_OW 1
79896: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79897: LD_VAR 0 1
79901: PUSH
79902: LD_EXP 74
79906: PUSH
79907: LD_VAR 0 3
79911: ARRAY
79912: IN
79913: IFFALSE 79952
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79915: LD_ADDR_EXP 74
79919: PUSH
79920: LD_EXP 74
79924: PPUSH
79925: LD_VAR 0 3
79929: PPUSH
79930: LD_EXP 74
79934: PUSH
79935: LD_VAR 0 3
79939: ARRAY
79940: PUSH
79941: LD_VAR 0 1
79945: DIFF
79946: PPUSH
79947: CALL_OW 1
79951: ST_TO_ADDR
// end ; break ;
79952: GO 79956
// end ;
79954: GO 78602
79956: POP
79957: POP
// end ;
79958: LD_VAR 0 2
79962: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79963: LD_INT 0
79965: PPUSH
79966: PPUSH
79967: PPUSH
// if not mc_bases or not skirmish then
79968: LD_EXP 66
79972: NOT
79973: PUSH
79974: LD_EXP 64
79978: NOT
79979: OR
79980: IFFALSE 79984
// exit ;
79982: GO 80199
// for i = 1 to mc_bases do
79984: LD_ADDR_VAR 0 3
79988: PUSH
79989: DOUBLE
79990: LD_INT 1
79992: DEC
79993: ST_TO_ADDR
79994: LD_EXP 66
79998: PUSH
79999: FOR_TO
80000: IFFALSE 80197
// begin if building in mc_construct_list [ i ] then
80002: LD_VAR 0 1
80006: PUSH
80007: LD_EXP 73
80011: PUSH
80012: LD_VAR 0 3
80016: ARRAY
80017: IN
80018: IFFALSE 80195
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80020: LD_ADDR_EXP 73
80024: PUSH
80025: LD_EXP 73
80029: PPUSH
80030: LD_VAR 0 3
80034: PPUSH
80035: LD_EXP 73
80039: PUSH
80040: LD_VAR 0 3
80044: ARRAY
80045: PUSH
80046: LD_VAR 0 1
80050: DIFF
80051: PPUSH
80052: CALL_OW 1
80056: ST_TO_ADDR
// if building in mc_lab [ i ] then
80057: LD_VAR 0 1
80061: PUSH
80062: LD_EXP 99
80066: PUSH
80067: LD_VAR 0 3
80071: ARRAY
80072: IN
80073: IFFALSE 80128
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80075: LD_ADDR_EXP 100
80079: PUSH
80080: LD_EXP 100
80084: PPUSH
80085: LD_VAR 0 3
80089: PPUSH
80090: LD_EXP 100
80094: PUSH
80095: LD_VAR 0 3
80099: ARRAY
80100: PPUSH
80101: LD_INT 1
80103: PPUSH
80104: LD_EXP 100
80108: PUSH
80109: LD_VAR 0 3
80113: ARRAY
80114: PPUSH
80115: LD_INT 0
80117: PPUSH
80118: CALL 17966 0 4
80122: PPUSH
80123: CALL_OW 1
80127: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80128: LD_VAR 0 1
80132: PUSH
80133: LD_EXP 66
80137: PUSH
80138: LD_VAR 0 3
80142: ARRAY
80143: IN
80144: NOT
80145: IFFALSE 80191
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80147: LD_ADDR_EXP 66
80151: PUSH
80152: LD_EXP 66
80156: PPUSH
80157: LD_VAR 0 3
80161: PUSH
80162: LD_EXP 66
80166: PUSH
80167: LD_VAR 0 3
80171: ARRAY
80172: PUSH
80173: LD_INT 1
80175: PLUS
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PPUSH
80181: LD_VAR 0 1
80185: PPUSH
80186: CALL 18548 0 3
80190: ST_TO_ADDR
// exit ;
80191: POP
80192: POP
80193: GO 80199
// end ; end ;
80195: GO 79999
80197: POP
80198: POP
// end ;
80199: LD_VAR 0 2
80203: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80204: LD_INT 0
80206: PPUSH
80207: PPUSH
80208: PPUSH
80209: PPUSH
80210: PPUSH
80211: PPUSH
80212: PPUSH
// if not mc_bases or not skirmish then
80213: LD_EXP 66
80217: NOT
80218: PUSH
80219: LD_EXP 64
80223: NOT
80224: OR
80225: IFFALSE 80229
// exit ;
80227: GO 80890
// for i = 1 to mc_bases do
80229: LD_ADDR_VAR 0 3
80233: PUSH
80234: DOUBLE
80235: LD_INT 1
80237: DEC
80238: ST_TO_ADDR
80239: LD_EXP 66
80243: PUSH
80244: FOR_TO
80245: IFFALSE 80888
// begin if building in mc_construct_list [ i ] then
80247: LD_VAR 0 1
80251: PUSH
80252: LD_EXP 73
80256: PUSH
80257: LD_VAR 0 3
80261: ARRAY
80262: IN
80263: IFFALSE 80886
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80265: LD_ADDR_EXP 73
80269: PUSH
80270: LD_EXP 73
80274: PPUSH
80275: LD_VAR 0 3
80279: PPUSH
80280: LD_EXP 73
80284: PUSH
80285: LD_VAR 0 3
80289: ARRAY
80290: PUSH
80291: LD_VAR 0 1
80295: DIFF
80296: PPUSH
80297: CALL_OW 1
80301: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80302: LD_ADDR_EXP 66
80306: PUSH
80307: LD_EXP 66
80311: PPUSH
80312: LD_VAR 0 3
80316: PUSH
80317: LD_EXP 66
80321: PUSH
80322: LD_VAR 0 3
80326: ARRAY
80327: PUSH
80328: LD_INT 1
80330: PLUS
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PPUSH
80336: LD_VAR 0 1
80340: PPUSH
80341: CALL 18548 0 3
80345: ST_TO_ADDR
// btype := GetBType ( building ) ;
80346: LD_ADDR_VAR 0 5
80350: PUSH
80351: LD_VAR 0 1
80355: PPUSH
80356: CALL_OW 266
80360: ST_TO_ADDR
// side := GetSide ( building ) ;
80361: LD_ADDR_VAR 0 8
80365: PUSH
80366: LD_VAR 0 1
80370: PPUSH
80371: CALL_OW 255
80375: ST_TO_ADDR
// if btype = b_lab then
80376: LD_VAR 0 5
80380: PUSH
80381: LD_INT 6
80383: EQUAL
80384: IFFALSE 80434
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80386: LD_ADDR_EXP 99
80390: PUSH
80391: LD_EXP 99
80395: PPUSH
80396: LD_VAR 0 3
80400: PUSH
80401: LD_EXP 99
80405: PUSH
80406: LD_VAR 0 3
80410: ARRAY
80411: PUSH
80412: LD_INT 1
80414: PLUS
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PPUSH
80420: LD_VAR 0 1
80424: PPUSH
80425: CALL 18548 0 3
80429: ST_TO_ADDR
// exit ;
80430: POP
80431: POP
80432: GO 80890
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80434: LD_VAR 0 5
80438: PUSH
80439: LD_INT 0
80441: PUSH
80442: LD_INT 2
80444: PUSH
80445: LD_INT 4
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: LIST
80452: IN
80453: IFFALSE 80577
// begin if btype = b_armoury then
80455: LD_VAR 0 5
80459: PUSH
80460: LD_INT 4
80462: EQUAL
80463: IFFALSE 80473
// btype := b_barracks ;
80465: LD_ADDR_VAR 0 5
80469: PUSH
80470: LD_INT 5
80472: ST_TO_ADDR
// if btype = b_depot then
80473: LD_VAR 0 5
80477: PUSH
80478: LD_INT 0
80480: EQUAL
80481: IFFALSE 80491
// btype := b_warehouse ;
80483: LD_ADDR_VAR 0 5
80487: PUSH
80488: LD_INT 1
80490: ST_TO_ADDR
// if btype = b_workshop then
80491: LD_VAR 0 5
80495: PUSH
80496: LD_INT 2
80498: EQUAL
80499: IFFALSE 80509
// btype := b_factory ;
80501: LD_ADDR_VAR 0 5
80505: PUSH
80506: LD_INT 3
80508: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80509: LD_VAR 0 5
80513: PPUSH
80514: LD_VAR 0 8
80518: PPUSH
80519: CALL_OW 323
80523: PUSH
80524: LD_INT 1
80526: EQUAL
80527: IFFALSE 80573
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80529: LD_ADDR_EXP 98
80533: PUSH
80534: LD_EXP 98
80538: PPUSH
80539: LD_VAR 0 3
80543: PUSH
80544: LD_EXP 98
80548: PUSH
80549: LD_VAR 0 3
80553: ARRAY
80554: PUSH
80555: LD_INT 1
80557: PLUS
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PPUSH
80563: LD_VAR 0 1
80567: PPUSH
80568: CALL 18548 0 3
80572: ST_TO_ADDR
// exit ;
80573: POP
80574: POP
80575: GO 80890
// end ; if btype in [ b_bunker , b_turret ] then
80577: LD_VAR 0 5
80581: PUSH
80582: LD_INT 32
80584: PUSH
80585: LD_INT 33
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: IN
80592: IFFALSE 80882
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80594: LD_ADDR_EXP 74
80598: PUSH
80599: LD_EXP 74
80603: PPUSH
80604: LD_VAR 0 3
80608: PUSH
80609: LD_EXP 74
80613: PUSH
80614: LD_VAR 0 3
80618: ARRAY
80619: PUSH
80620: LD_INT 1
80622: PLUS
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PPUSH
80628: LD_VAR 0 1
80632: PPUSH
80633: CALL 18548 0 3
80637: ST_TO_ADDR
// if btype = b_bunker then
80638: LD_VAR 0 5
80642: PUSH
80643: LD_INT 32
80645: EQUAL
80646: IFFALSE 80882
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80648: LD_ADDR_EXP 75
80652: PUSH
80653: LD_EXP 75
80657: PPUSH
80658: LD_VAR 0 3
80662: PUSH
80663: LD_EXP 75
80667: PUSH
80668: LD_VAR 0 3
80672: ARRAY
80673: PUSH
80674: LD_INT 1
80676: PLUS
80677: PUSH
80678: EMPTY
80679: LIST
80680: LIST
80681: PPUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL 18548 0 3
80691: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80692: LD_ADDR_VAR 0 6
80696: PUSH
80697: LD_EXP 66
80701: PUSH
80702: LD_VAR 0 3
80706: ARRAY
80707: PPUSH
80708: LD_INT 25
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 3
80720: PUSH
80721: LD_INT 54
80723: PUSH
80724: EMPTY
80725: LIST
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PPUSH
80735: CALL_OW 72
80739: ST_TO_ADDR
// if tmp then
80740: LD_VAR 0 6
80744: IFFALSE 80750
// exit ;
80746: POP
80747: POP
80748: GO 80890
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80750: LD_ADDR_VAR 0 6
80754: PUSH
80755: LD_EXP 66
80759: PUSH
80760: LD_VAR 0 3
80764: ARRAY
80765: PPUSH
80766: LD_INT 2
80768: PUSH
80769: LD_INT 30
80771: PUSH
80772: LD_INT 4
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: LD_INT 30
80781: PUSH
80782: LD_INT 5
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: LIST
80793: PPUSH
80794: CALL_OW 72
80798: ST_TO_ADDR
// if not tmp then
80799: LD_VAR 0 6
80803: NOT
80804: IFFALSE 80810
// exit ;
80806: POP
80807: POP
80808: GO 80890
// for j in tmp do
80810: LD_ADDR_VAR 0 4
80814: PUSH
80815: LD_VAR 0 6
80819: PUSH
80820: FOR_IN
80821: IFFALSE 80880
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80823: LD_ADDR_VAR 0 7
80827: PUSH
80828: LD_VAR 0 4
80832: PPUSH
80833: CALL_OW 313
80837: PPUSH
80838: LD_INT 25
80840: PUSH
80841: LD_INT 1
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PPUSH
80848: CALL_OW 72
80852: ST_TO_ADDR
// if units then
80853: LD_VAR 0 7
80857: IFFALSE 80878
// begin ComExitBuilding ( units [ 1 ] ) ;
80859: LD_VAR 0 7
80863: PUSH
80864: LD_INT 1
80866: ARRAY
80867: PPUSH
80868: CALL_OW 122
// exit ;
80872: POP
80873: POP
80874: POP
80875: POP
80876: GO 80890
// end ; end ;
80878: GO 80820
80880: POP
80881: POP
// end ; end ; exit ;
80882: POP
80883: POP
80884: GO 80890
// end ; end ;
80886: GO 80244
80888: POP
80889: POP
// end ;
80890: LD_VAR 0 2
80894: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80895: LD_INT 0
80897: PPUSH
80898: PPUSH
80899: PPUSH
80900: PPUSH
80901: PPUSH
80902: PPUSH
80903: PPUSH
// if not mc_bases or not skirmish then
80904: LD_EXP 66
80908: NOT
80909: PUSH
80910: LD_EXP 64
80914: NOT
80915: OR
80916: IFFALSE 80920
// exit ;
80918: GO 81151
// btype := GetBType ( building ) ;
80920: LD_ADDR_VAR 0 6
80924: PUSH
80925: LD_VAR 0 1
80929: PPUSH
80930: CALL_OW 266
80934: ST_TO_ADDR
// x := GetX ( building ) ;
80935: LD_ADDR_VAR 0 7
80939: PUSH
80940: LD_VAR 0 1
80944: PPUSH
80945: CALL_OW 250
80949: ST_TO_ADDR
// y := GetY ( building ) ;
80950: LD_ADDR_VAR 0 8
80954: PUSH
80955: LD_VAR 0 1
80959: PPUSH
80960: CALL_OW 251
80964: ST_TO_ADDR
// d := GetDir ( building ) ;
80965: LD_ADDR_VAR 0 9
80969: PUSH
80970: LD_VAR 0 1
80974: PPUSH
80975: CALL_OW 254
80979: ST_TO_ADDR
// for i = 1 to mc_bases do
80980: LD_ADDR_VAR 0 4
80984: PUSH
80985: DOUBLE
80986: LD_INT 1
80988: DEC
80989: ST_TO_ADDR
80990: LD_EXP 66
80994: PUSH
80995: FOR_TO
80996: IFFALSE 81149
// begin if not mc_build_list [ i ] then
80998: LD_EXP 71
81002: PUSH
81003: LD_VAR 0 4
81007: ARRAY
81008: NOT
81009: IFFALSE 81013
// continue ;
81011: GO 80995
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
81013: LD_VAR 0 6
81017: PUSH
81018: LD_VAR 0 7
81022: PUSH
81023: LD_VAR 0 8
81027: PUSH
81028: LD_VAR 0 9
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: PPUSH
81039: LD_EXP 71
81043: PUSH
81044: LD_VAR 0 4
81048: ARRAY
81049: PUSH
81050: LD_INT 1
81052: ARRAY
81053: PPUSH
81054: CALL 24755 0 2
81058: IFFALSE 81147
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81060: LD_ADDR_EXP 71
81064: PUSH
81065: LD_EXP 71
81069: PPUSH
81070: LD_VAR 0 4
81074: PPUSH
81075: LD_EXP 71
81079: PUSH
81080: LD_VAR 0 4
81084: ARRAY
81085: PPUSH
81086: LD_INT 1
81088: PPUSH
81089: CALL_OW 3
81093: PPUSH
81094: CALL_OW 1
81098: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81099: LD_ADDR_EXP 73
81103: PUSH
81104: LD_EXP 73
81108: PPUSH
81109: LD_VAR 0 4
81113: PUSH
81114: LD_EXP 73
81118: PUSH
81119: LD_VAR 0 4
81123: ARRAY
81124: PUSH
81125: LD_INT 1
81127: PLUS
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PPUSH
81133: LD_VAR 0 1
81137: PPUSH
81138: CALL 18548 0 3
81142: ST_TO_ADDR
// exit ;
81143: POP
81144: POP
81145: GO 81151
// end ; end ;
81147: GO 80995
81149: POP
81150: POP
// end ;
81151: LD_VAR 0 3
81155: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81156: LD_INT 0
81158: PPUSH
81159: PPUSH
81160: PPUSH
// if not mc_bases or not skirmish then
81161: LD_EXP 66
81165: NOT
81166: PUSH
81167: LD_EXP 64
81171: NOT
81172: OR
81173: IFFALSE 81177
// exit ;
81175: GO 81367
// for i = 1 to mc_bases do
81177: LD_ADDR_VAR 0 4
81181: PUSH
81182: DOUBLE
81183: LD_INT 1
81185: DEC
81186: ST_TO_ADDR
81187: LD_EXP 66
81191: PUSH
81192: FOR_TO
81193: IFFALSE 81280
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81195: LD_VAR 0 1
81199: PUSH
81200: LD_EXP 74
81204: PUSH
81205: LD_VAR 0 4
81209: ARRAY
81210: IN
81211: PUSH
81212: LD_VAR 0 1
81216: PUSH
81217: LD_EXP 75
81221: PUSH
81222: LD_VAR 0 4
81226: ARRAY
81227: IN
81228: NOT
81229: AND
81230: IFFALSE 81278
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81232: LD_ADDR_EXP 75
81236: PUSH
81237: LD_EXP 75
81241: PPUSH
81242: LD_VAR 0 4
81246: PUSH
81247: LD_EXP 75
81251: PUSH
81252: LD_VAR 0 4
81256: ARRAY
81257: PUSH
81258: LD_INT 1
81260: PLUS
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PPUSH
81266: LD_VAR 0 1
81270: PPUSH
81271: CALL 18548 0 3
81275: ST_TO_ADDR
// break ;
81276: GO 81280
// end ; end ;
81278: GO 81192
81280: POP
81281: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81282: LD_VAR 0 1
81286: PPUSH
81287: CALL_OW 257
81291: PUSH
81292: LD_EXP 92
81296: IN
81297: PUSH
81298: LD_VAR 0 1
81302: PPUSH
81303: CALL_OW 266
81307: PUSH
81308: LD_INT 5
81310: EQUAL
81311: AND
81312: PUSH
81313: LD_VAR 0 2
81317: PPUSH
81318: CALL_OW 110
81322: PUSH
81323: LD_INT 18
81325: NONEQUAL
81326: AND
81327: IFFALSE 81367
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81329: LD_VAR 0 2
81333: PPUSH
81334: CALL_OW 257
81338: PUSH
81339: LD_INT 5
81341: PUSH
81342: LD_INT 8
81344: PUSH
81345: LD_INT 9
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: LIST
81352: IN
81353: IFFALSE 81367
// SetClass ( unit , 1 ) ;
81355: LD_VAR 0 2
81359: PPUSH
81360: LD_INT 1
81362: PPUSH
81363: CALL_OW 336
// end ;
81367: LD_VAR 0 3
81371: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81372: LD_INT 0
81374: PPUSH
81375: PPUSH
// if not mc_bases or not skirmish then
81376: LD_EXP 66
81380: NOT
81381: PUSH
81382: LD_EXP 64
81386: NOT
81387: OR
81388: IFFALSE 81392
// exit ;
81390: GO 81508
// if GetLives ( abandoned_vehicle ) > 250 then
81392: LD_VAR 0 2
81396: PPUSH
81397: CALL_OW 256
81401: PUSH
81402: LD_INT 250
81404: GREATER
81405: IFFALSE 81409
// exit ;
81407: GO 81508
// for i = 1 to mc_bases do
81409: LD_ADDR_VAR 0 6
81413: PUSH
81414: DOUBLE
81415: LD_INT 1
81417: DEC
81418: ST_TO_ADDR
81419: LD_EXP 66
81423: PUSH
81424: FOR_TO
81425: IFFALSE 81506
// begin if driver in mc_bases [ i ] then
81427: LD_VAR 0 1
81431: PUSH
81432: LD_EXP 66
81436: PUSH
81437: LD_VAR 0 6
81441: ARRAY
81442: IN
81443: IFFALSE 81504
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81445: LD_VAR 0 1
81449: PPUSH
81450: LD_EXP 66
81454: PUSH
81455: LD_VAR 0 6
81459: ARRAY
81460: PPUSH
81461: LD_INT 2
81463: PUSH
81464: LD_INT 30
81466: PUSH
81467: LD_INT 0
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 30
81476: PUSH
81477: LD_INT 1
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: LIST
81488: PPUSH
81489: CALL_OW 72
81493: PUSH
81494: LD_INT 1
81496: ARRAY
81497: PPUSH
81498: CALL 50791 0 2
// break ;
81502: GO 81506
// end ; end ;
81504: GO 81424
81506: POP
81507: POP
// end ; end_of_file end_of_file
81508: LD_VAR 0 5
81512: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
81513: LD_VAR 0 2
81517: PUSH
81518: LD_INT 100
81520: EQUAL
81521: IFFALSE 82470
// begin if not StreamModeActive then
81523: LD_EXP 109
81527: NOT
81528: IFFALSE 81538
// StreamModeActive := true ;
81530: LD_ADDR_EXP 109
81534: PUSH
81535: LD_INT 1
81537: ST_TO_ADDR
// if p3 = 0 then
81538: LD_VAR 0 3
81542: PUSH
81543: LD_INT 0
81545: EQUAL
81546: IFFALSE 81552
// InitStreamMode ;
81548: CALL 82628 0 0
// if p3 = 1 then
81552: LD_VAR 0 3
81556: PUSH
81557: LD_INT 1
81559: EQUAL
81560: IFFALSE 81570
// sRocket := true ;
81562: LD_ADDR_EXP 114
81566: PUSH
81567: LD_INT 1
81569: ST_TO_ADDR
// if p3 = 2 then
81570: LD_VAR 0 3
81574: PUSH
81575: LD_INT 2
81577: EQUAL
81578: IFFALSE 81588
// sSpeed := true ;
81580: LD_ADDR_EXP 113
81584: PUSH
81585: LD_INT 1
81587: ST_TO_ADDR
// if p3 = 3 then
81588: LD_VAR 0 3
81592: PUSH
81593: LD_INT 3
81595: EQUAL
81596: IFFALSE 81606
// sEngine := true ;
81598: LD_ADDR_EXP 115
81602: PUSH
81603: LD_INT 1
81605: ST_TO_ADDR
// if p3 = 4 then
81606: LD_VAR 0 3
81610: PUSH
81611: LD_INT 4
81613: EQUAL
81614: IFFALSE 81624
// sSpec := true ;
81616: LD_ADDR_EXP 112
81620: PUSH
81621: LD_INT 1
81623: ST_TO_ADDR
// if p3 = 5 then
81624: LD_VAR 0 3
81628: PUSH
81629: LD_INT 5
81631: EQUAL
81632: IFFALSE 81642
// sLevel := true ;
81634: LD_ADDR_EXP 116
81638: PUSH
81639: LD_INT 1
81641: ST_TO_ADDR
// if p3 = 6 then
81642: LD_VAR 0 3
81646: PUSH
81647: LD_INT 6
81649: EQUAL
81650: IFFALSE 81660
// sArmoury := true ;
81652: LD_ADDR_EXP 117
81656: PUSH
81657: LD_INT 1
81659: ST_TO_ADDR
// if p3 = 7 then
81660: LD_VAR 0 3
81664: PUSH
81665: LD_INT 7
81667: EQUAL
81668: IFFALSE 81678
// sRadar := true ;
81670: LD_ADDR_EXP 118
81674: PUSH
81675: LD_INT 1
81677: ST_TO_ADDR
// if p3 = 8 then
81678: LD_VAR 0 3
81682: PUSH
81683: LD_INT 8
81685: EQUAL
81686: IFFALSE 81696
// sBunker := true ;
81688: LD_ADDR_EXP 119
81692: PUSH
81693: LD_INT 1
81695: ST_TO_ADDR
// if p3 = 9 then
81696: LD_VAR 0 3
81700: PUSH
81701: LD_INT 9
81703: EQUAL
81704: IFFALSE 81714
// sHack := true ;
81706: LD_ADDR_EXP 120
81710: PUSH
81711: LD_INT 1
81713: ST_TO_ADDR
// if p3 = 10 then
81714: LD_VAR 0 3
81718: PUSH
81719: LD_INT 10
81721: EQUAL
81722: IFFALSE 81732
// sFire := true ;
81724: LD_ADDR_EXP 121
81728: PUSH
81729: LD_INT 1
81731: ST_TO_ADDR
// if p3 = 11 then
81732: LD_VAR 0 3
81736: PUSH
81737: LD_INT 11
81739: EQUAL
81740: IFFALSE 81750
// sRefresh := true ;
81742: LD_ADDR_EXP 122
81746: PUSH
81747: LD_INT 1
81749: ST_TO_ADDR
// if p3 = 12 then
81750: LD_VAR 0 3
81754: PUSH
81755: LD_INT 12
81757: EQUAL
81758: IFFALSE 81768
// sExp := true ;
81760: LD_ADDR_EXP 123
81764: PUSH
81765: LD_INT 1
81767: ST_TO_ADDR
// if p3 = 13 then
81768: LD_VAR 0 3
81772: PUSH
81773: LD_INT 13
81775: EQUAL
81776: IFFALSE 81786
// sDepot := true ;
81778: LD_ADDR_EXP 124
81782: PUSH
81783: LD_INT 1
81785: ST_TO_ADDR
// if p3 = 14 then
81786: LD_VAR 0 3
81790: PUSH
81791: LD_INT 14
81793: EQUAL
81794: IFFALSE 81804
// sFlag := true ;
81796: LD_ADDR_EXP 125
81800: PUSH
81801: LD_INT 1
81803: ST_TO_ADDR
// if p3 = 15 then
81804: LD_VAR 0 3
81808: PUSH
81809: LD_INT 15
81811: EQUAL
81812: IFFALSE 81822
// sKamikadze := true ;
81814: LD_ADDR_EXP 133
81818: PUSH
81819: LD_INT 1
81821: ST_TO_ADDR
// if p3 = 16 then
81822: LD_VAR 0 3
81826: PUSH
81827: LD_INT 16
81829: EQUAL
81830: IFFALSE 81840
// sTroll := true ;
81832: LD_ADDR_EXP 134
81836: PUSH
81837: LD_INT 1
81839: ST_TO_ADDR
// if p3 = 17 then
81840: LD_VAR 0 3
81844: PUSH
81845: LD_INT 17
81847: EQUAL
81848: IFFALSE 81858
// sSlow := true ;
81850: LD_ADDR_EXP 135
81854: PUSH
81855: LD_INT 1
81857: ST_TO_ADDR
// if p3 = 18 then
81858: LD_VAR 0 3
81862: PUSH
81863: LD_INT 18
81865: EQUAL
81866: IFFALSE 81876
// sLack := true ;
81868: LD_ADDR_EXP 136
81872: PUSH
81873: LD_INT 1
81875: ST_TO_ADDR
// if p3 = 19 then
81876: LD_VAR 0 3
81880: PUSH
81881: LD_INT 19
81883: EQUAL
81884: IFFALSE 81894
// sTank := true ;
81886: LD_ADDR_EXP 138
81890: PUSH
81891: LD_INT 1
81893: ST_TO_ADDR
// if p3 = 20 then
81894: LD_VAR 0 3
81898: PUSH
81899: LD_INT 20
81901: EQUAL
81902: IFFALSE 81912
// sRemote := true ;
81904: LD_ADDR_EXP 139
81908: PUSH
81909: LD_INT 1
81911: ST_TO_ADDR
// if p3 = 21 then
81912: LD_VAR 0 3
81916: PUSH
81917: LD_INT 21
81919: EQUAL
81920: IFFALSE 81930
// sPowell := true ;
81922: LD_ADDR_EXP 140
81926: PUSH
81927: LD_INT 1
81929: ST_TO_ADDR
// if p3 = 22 then
81930: LD_VAR 0 3
81934: PUSH
81935: LD_INT 22
81937: EQUAL
81938: IFFALSE 81948
// sTeleport := true ;
81940: LD_ADDR_EXP 143
81944: PUSH
81945: LD_INT 1
81947: ST_TO_ADDR
// if p3 = 23 then
81948: LD_VAR 0 3
81952: PUSH
81953: LD_INT 23
81955: EQUAL
81956: IFFALSE 81966
// sOilTower := true ;
81958: LD_ADDR_EXP 145
81962: PUSH
81963: LD_INT 1
81965: ST_TO_ADDR
// if p3 = 24 then
81966: LD_VAR 0 3
81970: PUSH
81971: LD_INT 24
81973: EQUAL
81974: IFFALSE 81984
// sShovel := true ;
81976: LD_ADDR_EXP 146
81980: PUSH
81981: LD_INT 1
81983: ST_TO_ADDR
// if p3 = 25 then
81984: LD_VAR 0 3
81988: PUSH
81989: LD_INT 25
81991: EQUAL
81992: IFFALSE 82002
// sSheik := true ;
81994: LD_ADDR_EXP 147
81998: PUSH
81999: LD_INT 1
82001: ST_TO_ADDR
// if p3 = 26 then
82002: LD_VAR 0 3
82006: PUSH
82007: LD_INT 26
82009: EQUAL
82010: IFFALSE 82020
// sEarthquake := true ;
82012: LD_ADDR_EXP 149
82016: PUSH
82017: LD_INT 1
82019: ST_TO_ADDR
// if p3 = 27 then
82020: LD_VAR 0 3
82024: PUSH
82025: LD_INT 27
82027: EQUAL
82028: IFFALSE 82038
// sAI := true ;
82030: LD_ADDR_EXP 150
82034: PUSH
82035: LD_INT 1
82037: ST_TO_ADDR
// if p3 = 28 then
82038: LD_VAR 0 3
82042: PUSH
82043: LD_INT 28
82045: EQUAL
82046: IFFALSE 82056
// sCargo := true ;
82048: LD_ADDR_EXP 153
82052: PUSH
82053: LD_INT 1
82055: ST_TO_ADDR
// if p3 = 29 then
82056: LD_VAR 0 3
82060: PUSH
82061: LD_INT 29
82063: EQUAL
82064: IFFALSE 82074
// sDLaser := true ;
82066: LD_ADDR_EXP 154
82070: PUSH
82071: LD_INT 1
82073: ST_TO_ADDR
// if p3 = 30 then
82074: LD_VAR 0 3
82078: PUSH
82079: LD_INT 30
82081: EQUAL
82082: IFFALSE 82092
// sExchange := true ;
82084: LD_ADDR_EXP 155
82088: PUSH
82089: LD_INT 1
82091: ST_TO_ADDR
// if p3 = 31 then
82092: LD_VAR 0 3
82096: PUSH
82097: LD_INT 31
82099: EQUAL
82100: IFFALSE 82110
// sFac := true ;
82102: LD_ADDR_EXP 156
82106: PUSH
82107: LD_INT 1
82109: ST_TO_ADDR
// if p3 = 32 then
82110: LD_VAR 0 3
82114: PUSH
82115: LD_INT 32
82117: EQUAL
82118: IFFALSE 82128
// sPower := true ;
82120: LD_ADDR_EXP 157
82124: PUSH
82125: LD_INT 1
82127: ST_TO_ADDR
// if p3 = 33 then
82128: LD_VAR 0 3
82132: PUSH
82133: LD_INT 33
82135: EQUAL
82136: IFFALSE 82146
// sRandom := true ;
82138: LD_ADDR_EXP 158
82142: PUSH
82143: LD_INT 1
82145: ST_TO_ADDR
// if p3 = 34 then
82146: LD_VAR 0 3
82150: PUSH
82151: LD_INT 34
82153: EQUAL
82154: IFFALSE 82164
// sShield := true ;
82156: LD_ADDR_EXP 159
82160: PUSH
82161: LD_INT 1
82163: ST_TO_ADDR
// if p3 = 35 then
82164: LD_VAR 0 3
82168: PUSH
82169: LD_INT 35
82171: EQUAL
82172: IFFALSE 82182
// sTime := true ;
82174: LD_ADDR_EXP 160
82178: PUSH
82179: LD_INT 1
82181: ST_TO_ADDR
// if p3 = 36 then
82182: LD_VAR 0 3
82186: PUSH
82187: LD_INT 36
82189: EQUAL
82190: IFFALSE 82200
// sTools := true ;
82192: LD_ADDR_EXP 161
82196: PUSH
82197: LD_INT 1
82199: ST_TO_ADDR
// if p3 = 101 then
82200: LD_VAR 0 3
82204: PUSH
82205: LD_INT 101
82207: EQUAL
82208: IFFALSE 82218
// sSold := true ;
82210: LD_ADDR_EXP 126
82214: PUSH
82215: LD_INT 1
82217: ST_TO_ADDR
// if p3 = 102 then
82218: LD_VAR 0 3
82222: PUSH
82223: LD_INT 102
82225: EQUAL
82226: IFFALSE 82236
// sDiff := true ;
82228: LD_ADDR_EXP 127
82232: PUSH
82233: LD_INT 1
82235: ST_TO_ADDR
// if p3 = 103 then
82236: LD_VAR 0 3
82240: PUSH
82241: LD_INT 103
82243: EQUAL
82244: IFFALSE 82254
// sFog := true ;
82246: LD_ADDR_EXP 130
82250: PUSH
82251: LD_INT 1
82253: ST_TO_ADDR
// if p3 = 104 then
82254: LD_VAR 0 3
82258: PUSH
82259: LD_INT 104
82261: EQUAL
82262: IFFALSE 82272
// sReset := true ;
82264: LD_ADDR_EXP 131
82268: PUSH
82269: LD_INT 1
82271: ST_TO_ADDR
// if p3 = 105 then
82272: LD_VAR 0 3
82276: PUSH
82277: LD_INT 105
82279: EQUAL
82280: IFFALSE 82290
// sSun := true ;
82282: LD_ADDR_EXP 132
82286: PUSH
82287: LD_INT 1
82289: ST_TO_ADDR
// if p3 = 106 then
82290: LD_VAR 0 3
82294: PUSH
82295: LD_INT 106
82297: EQUAL
82298: IFFALSE 82308
// sTiger := true ;
82300: LD_ADDR_EXP 128
82304: PUSH
82305: LD_INT 1
82307: ST_TO_ADDR
// if p3 = 107 then
82308: LD_VAR 0 3
82312: PUSH
82313: LD_INT 107
82315: EQUAL
82316: IFFALSE 82326
// sBomb := true ;
82318: LD_ADDR_EXP 129
82322: PUSH
82323: LD_INT 1
82325: ST_TO_ADDR
// if p3 = 108 then
82326: LD_VAR 0 3
82330: PUSH
82331: LD_INT 108
82333: EQUAL
82334: IFFALSE 82344
// sWound := true ;
82336: LD_ADDR_EXP 137
82340: PUSH
82341: LD_INT 1
82343: ST_TO_ADDR
// if p3 = 109 then
82344: LD_VAR 0 3
82348: PUSH
82349: LD_INT 109
82351: EQUAL
82352: IFFALSE 82362
// sBetray := true ;
82354: LD_ADDR_EXP 141
82358: PUSH
82359: LD_INT 1
82361: ST_TO_ADDR
// if p3 = 110 then
82362: LD_VAR 0 3
82366: PUSH
82367: LD_INT 110
82369: EQUAL
82370: IFFALSE 82380
// sContamin := true ;
82372: LD_ADDR_EXP 142
82376: PUSH
82377: LD_INT 1
82379: ST_TO_ADDR
// if p3 = 111 then
82380: LD_VAR 0 3
82384: PUSH
82385: LD_INT 111
82387: EQUAL
82388: IFFALSE 82398
// sOil := true ;
82390: LD_ADDR_EXP 144
82394: PUSH
82395: LD_INT 1
82397: ST_TO_ADDR
// if p3 = 112 then
82398: LD_VAR 0 3
82402: PUSH
82403: LD_INT 112
82405: EQUAL
82406: IFFALSE 82416
// sStu := true ;
82408: LD_ADDR_EXP 148
82412: PUSH
82413: LD_INT 1
82415: ST_TO_ADDR
// if p3 = 113 then
82416: LD_VAR 0 3
82420: PUSH
82421: LD_INT 113
82423: EQUAL
82424: IFFALSE 82434
// sBazooka := true ;
82426: LD_ADDR_EXP 151
82430: PUSH
82431: LD_INT 1
82433: ST_TO_ADDR
// if p3 = 114 then
82434: LD_VAR 0 3
82438: PUSH
82439: LD_INT 114
82441: EQUAL
82442: IFFALSE 82452
// sMortar := true ;
82444: LD_ADDR_EXP 152
82448: PUSH
82449: LD_INT 1
82451: ST_TO_ADDR
// if p3 = 115 then
82452: LD_VAR 0 3
82456: PUSH
82457: LD_INT 115
82459: EQUAL
82460: IFFALSE 82470
// sRanger := true ;
82462: LD_ADDR_EXP 162
82466: PUSH
82467: LD_INT 1
82469: ST_TO_ADDR
// end ; if p2 = 101 then
82470: LD_VAR 0 2
82474: PUSH
82475: LD_INT 101
82477: EQUAL
82478: IFFALSE 82606
// begin case p3 of 1 :
82480: LD_VAR 0 3
82484: PUSH
82485: LD_INT 1
82487: DOUBLE
82488: EQUAL
82489: IFTRUE 82493
82491: GO 82500
82493: POP
// hHackUnlimitedResources ; 2 :
82494: CALL 93641 0 0
82498: GO 82606
82500: LD_INT 2
82502: DOUBLE
82503: EQUAL
82504: IFTRUE 82508
82506: GO 82515
82508: POP
// hHackSetLevel10 ; 3 :
82509: CALL 93774 0 0
82513: GO 82606
82515: LD_INT 3
82517: DOUBLE
82518: EQUAL
82519: IFTRUE 82523
82521: GO 82530
82523: POP
// hHackSetLevel10YourUnits ; 4 :
82524: CALL 93859 0 0
82528: GO 82606
82530: LD_INT 4
82532: DOUBLE
82533: EQUAL
82534: IFTRUE 82538
82536: GO 82545
82538: POP
// hHackInvincible ; 5 :
82539: CALL 94307 0 0
82543: GO 82606
82545: LD_INT 5
82547: DOUBLE
82548: EQUAL
82549: IFTRUE 82553
82551: GO 82560
82553: POP
// hHackInvisible ; 6 :
82554: CALL 94418 0 0
82558: GO 82606
82560: LD_INT 6
82562: DOUBLE
82563: EQUAL
82564: IFTRUE 82568
82566: GO 82575
82568: POP
// hHackChangeYourSide ; 7 :
82569: CALL 94475 0 0
82573: GO 82606
82575: LD_INT 7
82577: DOUBLE
82578: EQUAL
82579: IFTRUE 82583
82581: GO 82590
82583: POP
// hHackChangeUnitSide ; 8 :
82584: CALL 94517 0 0
82588: GO 82606
82590: LD_INT 8
82592: DOUBLE
82593: EQUAL
82594: IFTRUE 82598
82596: GO 82605
82598: POP
// hHackFog ; end ;
82599: CALL 94618 0 0
82603: GO 82606
82605: POP
// end ; end ;
82606: PPOPN 6
82608: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82609: GO 82611
82611: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82612: LD_STRING initStreamRollete();
82614: PPUSH
82615: CALL_OW 559
// InitStreamMode ;
82619: CALL 82628 0 0
// DefineStreamItems ( ) ;
82623: CALL 83068 0 0
// end ;
82627: END
// function InitStreamMode ; begin
82628: LD_INT 0
82630: PPUSH
// streamModeActive := false ;
82631: LD_ADDR_EXP 109
82635: PUSH
82636: LD_INT 0
82638: ST_TO_ADDR
// normalCounter := 36 ;
82639: LD_ADDR_EXP 110
82643: PUSH
82644: LD_INT 36
82646: ST_TO_ADDR
// hardcoreCounter := 16 ;
82647: LD_ADDR_EXP 111
82651: PUSH
82652: LD_INT 16
82654: ST_TO_ADDR
// sRocket := false ;
82655: LD_ADDR_EXP 114
82659: PUSH
82660: LD_INT 0
82662: ST_TO_ADDR
// sSpeed := false ;
82663: LD_ADDR_EXP 113
82667: PUSH
82668: LD_INT 0
82670: ST_TO_ADDR
// sEngine := false ;
82671: LD_ADDR_EXP 115
82675: PUSH
82676: LD_INT 0
82678: ST_TO_ADDR
// sSpec := false ;
82679: LD_ADDR_EXP 112
82683: PUSH
82684: LD_INT 0
82686: ST_TO_ADDR
// sLevel := false ;
82687: LD_ADDR_EXP 116
82691: PUSH
82692: LD_INT 0
82694: ST_TO_ADDR
// sArmoury := false ;
82695: LD_ADDR_EXP 117
82699: PUSH
82700: LD_INT 0
82702: ST_TO_ADDR
// sRadar := false ;
82703: LD_ADDR_EXP 118
82707: PUSH
82708: LD_INT 0
82710: ST_TO_ADDR
// sBunker := false ;
82711: LD_ADDR_EXP 119
82715: PUSH
82716: LD_INT 0
82718: ST_TO_ADDR
// sHack := false ;
82719: LD_ADDR_EXP 120
82723: PUSH
82724: LD_INT 0
82726: ST_TO_ADDR
// sFire := false ;
82727: LD_ADDR_EXP 121
82731: PUSH
82732: LD_INT 0
82734: ST_TO_ADDR
// sRefresh := false ;
82735: LD_ADDR_EXP 122
82739: PUSH
82740: LD_INT 0
82742: ST_TO_ADDR
// sExp := false ;
82743: LD_ADDR_EXP 123
82747: PUSH
82748: LD_INT 0
82750: ST_TO_ADDR
// sDepot := false ;
82751: LD_ADDR_EXP 124
82755: PUSH
82756: LD_INT 0
82758: ST_TO_ADDR
// sFlag := false ;
82759: LD_ADDR_EXP 125
82763: PUSH
82764: LD_INT 0
82766: ST_TO_ADDR
// sKamikadze := false ;
82767: LD_ADDR_EXP 133
82771: PUSH
82772: LD_INT 0
82774: ST_TO_ADDR
// sTroll := false ;
82775: LD_ADDR_EXP 134
82779: PUSH
82780: LD_INT 0
82782: ST_TO_ADDR
// sSlow := false ;
82783: LD_ADDR_EXP 135
82787: PUSH
82788: LD_INT 0
82790: ST_TO_ADDR
// sLack := false ;
82791: LD_ADDR_EXP 136
82795: PUSH
82796: LD_INT 0
82798: ST_TO_ADDR
// sTank := false ;
82799: LD_ADDR_EXP 138
82803: PUSH
82804: LD_INT 0
82806: ST_TO_ADDR
// sRemote := false ;
82807: LD_ADDR_EXP 139
82811: PUSH
82812: LD_INT 0
82814: ST_TO_ADDR
// sPowell := false ;
82815: LD_ADDR_EXP 140
82819: PUSH
82820: LD_INT 0
82822: ST_TO_ADDR
// sTeleport := false ;
82823: LD_ADDR_EXP 143
82827: PUSH
82828: LD_INT 0
82830: ST_TO_ADDR
// sOilTower := false ;
82831: LD_ADDR_EXP 145
82835: PUSH
82836: LD_INT 0
82838: ST_TO_ADDR
// sShovel := false ;
82839: LD_ADDR_EXP 146
82843: PUSH
82844: LD_INT 0
82846: ST_TO_ADDR
// sSheik := false ;
82847: LD_ADDR_EXP 147
82851: PUSH
82852: LD_INT 0
82854: ST_TO_ADDR
// sEarthquake := false ;
82855: LD_ADDR_EXP 149
82859: PUSH
82860: LD_INT 0
82862: ST_TO_ADDR
// sAI := false ;
82863: LD_ADDR_EXP 150
82867: PUSH
82868: LD_INT 0
82870: ST_TO_ADDR
// sCargo := false ;
82871: LD_ADDR_EXP 153
82875: PUSH
82876: LD_INT 0
82878: ST_TO_ADDR
// sDLaser := false ;
82879: LD_ADDR_EXP 154
82883: PUSH
82884: LD_INT 0
82886: ST_TO_ADDR
// sExchange := false ;
82887: LD_ADDR_EXP 155
82891: PUSH
82892: LD_INT 0
82894: ST_TO_ADDR
// sFac := false ;
82895: LD_ADDR_EXP 156
82899: PUSH
82900: LD_INT 0
82902: ST_TO_ADDR
// sPower := false ;
82903: LD_ADDR_EXP 157
82907: PUSH
82908: LD_INT 0
82910: ST_TO_ADDR
// sRandom := false ;
82911: LD_ADDR_EXP 158
82915: PUSH
82916: LD_INT 0
82918: ST_TO_ADDR
// sShield := false ;
82919: LD_ADDR_EXP 159
82923: PUSH
82924: LD_INT 0
82926: ST_TO_ADDR
// sTime := false ;
82927: LD_ADDR_EXP 160
82931: PUSH
82932: LD_INT 0
82934: ST_TO_ADDR
// sTools := false ;
82935: LD_ADDR_EXP 161
82939: PUSH
82940: LD_INT 0
82942: ST_TO_ADDR
// sSold := false ;
82943: LD_ADDR_EXP 126
82947: PUSH
82948: LD_INT 0
82950: ST_TO_ADDR
// sDiff := false ;
82951: LD_ADDR_EXP 127
82955: PUSH
82956: LD_INT 0
82958: ST_TO_ADDR
// sFog := false ;
82959: LD_ADDR_EXP 130
82963: PUSH
82964: LD_INT 0
82966: ST_TO_ADDR
// sReset := false ;
82967: LD_ADDR_EXP 131
82971: PUSH
82972: LD_INT 0
82974: ST_TO_ADDR
// sSun := false ;
82975: LD_ADDR_EXP 132
82979: PUSH
82980: LD_INT 0
82982: ST_TO_ADDR
// sTiger := false ;
82983: LD_ADDR_EXP 128
82987: PUSH
82988: LD_INT 0
82990: ST_TO_ADDR
// sBomb := false ;
82991: LD_ADDR_EXP 129
82995: PUSH
82996: LD_INT 0
82998: ST_TO_ADDR
// sWound := false ;
82999: LD_ADDR_EXP 137
83003: PUSH
83004: LD_INT 0
83006: ST_TO_ADDR
// sBetray := false ;
83007: LD_ADDR_EXP 141
83011: PUSH
83012: LD_INT 0
83014: ST_TO_ADDR
// sContamin := false ;
83015: LD_ADDR_EXP 142
83019: PUSH
83020: LD_INT 0
83022: ST_TO_ADDR
// sOil := false ;
83023: LD_ADDR_EXP 144
83027: PUSH
83028: LD_INT 0
83030: ST_TO_ADDR
// sStu := false ;
83031: LD_ADDR_EXP 148
83035: PUSH
83036: LD_INT 0
83038: ST_TO_ADDR
// sBazooka := false ;
83039: LD_ADDR_EXP 151
83043: PUSH
83044: LD_INT 0
83046: ST_TO_ADDR
// sMortar := false ;
83047: LD_ADDR_EXP 152
83051: PUSH
83052: LD_INT 0
83054: ST_TO_ADDR
// sRanger := false ;
83055: LD_ADDR_EXP 162
83059: PUSH
83060: LD_INT 0
83062: ST_TO_ADDR
// end ;
83063: LD_VAR 0 1
83067: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83068: LD_INT 0
83070: PPUSH
83071: PPUSH
83072: PPUSH
83073: PPUSH
83074: PPUSH
// result := [ ] ;
83075: LD_ADDR_VAR 0 1
83079: PUSH
83080: EMPTY
83081: ST_TO_ADDR
// if campaign_id = 1 then
83082: LD_OWVAR 69
83086: PUSH
83087: LD_INT 1
83089: EQUAL
83090: IFFALSE 86028
// begin case mission_number of 1 :
83092: LD_OWVAR 70
83096: PUSH
83097: LD_INT 1
83099: DOUBLE
83100: EQUAL
83101: IFTRUE 83105
83103: GO 83169
83105: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
83106: LD_ADDR_VAR 0 1
83110: PUSH
83111: LD_INT 2
83113: PUSH
83114: LD_INT 4
83116: PUSH
83117: LD_INT 11
83119: PUSH
83120: LD_INT 12
83122: PUSH
83123: LD_INT 15
83125: PUSH
83126: LD_INT 16
83128: PUSH
83129: LD_INT 22
83131: PUSH
83132: LD_INT 23
83134: PUSH
83135: LD_INT 26
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 101
83151: PUSH
83152: LD_INT 102
83154: PUSH
83155: LD_INT 106
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: LIST
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: ST_TO_ADDR
83167: GO 86026
83169: LD_INT 2
83171: DOUBLE
83172: EQUAL
83173: IFTRUE 83177
83175: GO 83249
83177: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
83178: LD_ADDR_VAR 0 1
83182: PUSH
83183: LD_INT 2
83185: PUSH
83186: LD_INT 4
83188: PUSH
83189: LD_INT 11
83191: PUSH
83192: LD_INT 12
83194: PUSH
83195: LD_INT 15
83197: PUSH
83198: LD_INT 16
83200: PUSH
83201: LD_INT 22
83203: PUSH
83204: LD_INT 23
83206: PUSH
83207: LD_INT 26
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 101
83223: PUSH
83224: LD_INT 102
83226: PUSH
83227: LD_INT 105
83229: PUSH
83230: LD_INT 106
83232: PUSH
83233: LD_INT 108
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: ST_TO_ADDR
83247: GO 86026
83249: LD_INT 3
83251: DOUBLE
83252: EQUAL
83253: IFTRUE 83257
83255: GO 83333
83257: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83258: LD_ADDR_VAR 0 1
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: LD_INT 4
83268: PUSH
83269: LD_INT 5
83271: PUSH
83272: LD_INT 11
83274: PUSH
83275: LD_INT 12
83277: PUSH
83278: LD_INT 15
83280: PUSH
83281: LD_INT 16
83283: PUSH
83284: LD_INT 22
83286: PUSH
83287: LD_INT 26
83289: PUSH
83290: LD_INT 36
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 101
83307: PUSH
83308: LD_INT 102
83310: PUSH
83311: LD_INT 105
83313: PUSH
83314: LD_INT 106
83316: PUSH
83317: LD_INT 108
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: ST_TO_ADDR
83331: GO 86026
83333: LD_INT 4
83335: DOUBLE
83336: EQUAL
83337: IFTRUE 83341
83339: GO 83425
83341: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
83342: LD_ADDR_VAR 0 1
83346: PUSH
83347: LD_INT 2
83349: PUSH
83350: LD_INT 4
83352: PUSH
83353: LD_INT 5
83355: PUSH
83356: LD_INT 8
83358: PUSH
83359: LD_INT 11
83361: PUSH
83362: LD_INT 12
83364: PUSH
83365: LD_INT 15
83367: PUSH
83368: LD_INT 16
83370: PUSH
83371: LD_INT 22
83373: PUSH
83374: LD_INT 23
83376: PUSH
83377: LD_INT 26
83379: PUSH
83380: LD_INT 36
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 101
83399: PUSH
83400: LD_INT 102
83402: PUSH
83403: LD_INT 105
83405: PUSH
83406: LD_INT 106
83408: PUSH
83409: LD_INT 108
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: ST_TO_ADDR
83423: GO 86026
83425: LD_INT 5
83427: DOUBLE
83428: EQUAL
83429: IFTRUE 83433
83431: GO 83533
83433: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
83434: LD_ADDR_VAR 0 1
83438: PUSH
83439: LD_INT 2
83441: PUSH
83442: LD_INT 4
83444: PUSH
83445: LD_INT 5
83447: PUSH
83448: LD_INT 6
83450: PUSH
83451: LD_INT 8
83453: PUSH
83454: LD_INT 11
83456: PUSH
83457: LD_INT 12
83459: PUSH
83460: LD_INT 15
83462: PUSH
83463: LD_INT 16
83465: PUSH
83466: LD_INT 22
83468: PUSH
83469: LD_INT 23
83471: PUSH
83472: LD_INT 25
83474: PUSH
83475: LD_INT 26
83477: PUSH
83478: LD_INT 36
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 101
83499: PUSH
83500: LD_INT 102
83502: PUSH
83503: LD_INT 105
83505: PUSH
83506: LD_INT 106
83508: PUSH
83509: LD_INT 108
83511: PUSH
83512: LD_INT 109
83514: PUSH
83515: LD_INT 112
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: ST_TO_ADDR
83531: GO 86026
83533: LD_INT 6
83535: DOUBLE
83536: EQUAL
83537: IFTRUE 83541
83539: GO 83661
83541: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
83542: LD_ADDR_VAR 0 1
83546: PUSH
83547: LD_INT 2
83549: PUSH
83550: LD_INT 4
83552: PUSH
83553: LD_INT 5
83555: PUSH
83556: LD_INT 6
83558: PUSH
83559: LD_INT 8
83561: PUSH
83562: LD_INT 11
83564: PUSH
83565: LD_INT 12
83567: PUSH
83568: LD_INT 15
83570: PUSH
83571: LD_INT 16
83573: PUSH
83574: LD_INT 20
83576: PUSH
83577: LD_INT 21
83579: PUSH
83580: LD_INT 22
83582: PUSH
83583: LD_INT 23
83585: PUSH
83586: LD_INT 25
83588: PUSH
83589: LD_INT 26
83591: PUSH
83592: LD_INT 30
83594: PUSH
83595: LD_INT 31
83597: PUSH
83598: LD_INT 32
83600: PUSH
83601: LD_INT 36
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 101
83627: PUSH
83628: LD_INT 102
83630: PUSH
83631: LD_INT 105
83633: PUSH
83634: LD_INT 106
83636: PUSH
83637: LD_INT 108
83639: PUSH
83640: LD_INT 109
83642: PUSH
83643: LD_INT 112
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: ST_TO_ADDR
83659: GO 86026
83661: LD_INT 7
83663: DOUBLE
83664: EQUAL
83665: IFTRUE 83669
83667: GO 83769
83669: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83670: LD_ADDR_VAR 0 1
83674: PUSH
83675: LD_INT 2
83677: PUSH
83678: LD_INT 4
83680: PUSH
83681: LD_INT 5
83683: PUSH
83684: LD_INT 7
83686: PUSH
83687: LD_INT 11
83689: PUSH
83690: LD_INT 12
83692: PUSH
83693: LD_INT 15
83695: PUSH
83696: LD_INT 16
83698: PUSH
83699: LD_INT 20
83701: PUSH
83702: LD_INT 21
83704: PUSH
83705: LD_INT 22
83707: PUSH
83708: LD_INT 23
83710: PUSH
83711: LD_INT 25
83713: PUSH
83714: LD_INT 26
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 101
83735: PUSH
83736: LD_INT 102
83738: PUSH
83739: LD_INT 103
83741: PUSH
83742: LD_INT 105
83744: PUSH
83745: LD_INT 106
83747: PUSH
83748: LD_INT 108
83750: PUSH
83751: LD_INT 112
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: ST_TO_ADDR
83767: GO 86026
83769: LD_INT 8
83771: DOUBLE
83772: EQUAL
83773: IFTRUE 83777
83775: GO 83905
83777: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83778: LD_ADDR_VAR 0 1
83782: PUSH
83783: LD_INT 2
83785: PUSH
83786: LD_INT 4
83788: PUSH
83789: LD_INT 5
83791: PUSH
83792: LD_INT 6
83794: PUSH
83795: LD_INT 7
83797: PUSH
83798: LD_INT 8
83800: PUSH
83801: LD_INT 11
83803: PUSH
83804: LD_INT 12
83806: PUSH
83807: LD_INT 15
83809: PUSH
83810: LD_INT 16
83812: PUSH
83813: LD_INT 20
83815: PUSH
83816: LD_INT 21
83818: PUSH
83819: LD_INT 22
83821: PUSH
83822: LD_INT 23
83824: PUSH
83825: LD_INT 25
83827: PUSH
83828: LD_INT 26
83830: PUSH
83831: LD_INT 30
83833: PUSH
83834: LD_INT 31
83836: PUSH
83837: LD_INT 32
83839: PUSH
83840: LD_INT 36
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 101
83867: PUSH
83868: LD_INT 102
83870: PUSH
83871: LD_INT 103
83873: PUSH
83874: LD_INT 105
83876: PUSH
83877: LD_INT 106
83879: PUSH
83880: LD_INT 108
83882: PUSH
83883: LD_INT 109
83885: PUSH
83886: LD_INT 112
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: ST_TO_ADDR
83903: GO 86026
83905: LD_INT 9
83907: DOUBLE
83908: EQUAL
83909: IFTRUE 83913
83911: GO 84049
83913: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
83914: LD_ADDR_VAR 0 1
83918: PUSH
83919: LD_INT 2
83921: PUSH
83922: LD_INT 4
83924: PUSH
83925: LD_INT 5
83927: PUSH
83928: LD_INT 6
83930: PUSH
83931: LD_INT 7
83933: PUSH
83934: LD_INT 8
83936: PUSH
83937: LD_INT 11
83939: PUSH
83940: LD_INT 12
83942: PUSH
83943: LD_INT 15
83945: PUSH
83946: LD_INT 16
83948: PUSH
83949: LD_INT 20
83951: PUSH
83952: LD_INT 21
83954: PUSH
83955: LD_INT 22
83957: PUSH
83958: LD_INT 23
83960: PUSH
83961: LD_INT 25
83963: PUSH
83964: LD_INT 26
83966: PUSH
83967: LD_INT 28
83969: PUSH
83970: LD_INT 30
83972: PUSH
83973: LD_INT 31
83975: PUSH
83976: LD_INT 32
83978: PUSH
83979: LD_INT 36
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 101
84007: PUSH
84008: LD_INT 102
84010: PUSH
84011: LD_INT 103
84013: PUSH
84014: LD_INT 105
84016: PUSH
84017: LD_INT 106
84019: PUSH
84020: LD_INT 108
84022: PUSH
84023: LD_INT 109
84025: PUSH
84026: LD_INT 112
84028: PUSH
84029: LD_INT 114
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: ST_TO_ADDR
84047: GO 86026
84049: LD_INT 10
84051: DOUBLE
84052: EQUAL
84053: IFTRUE 84057
84055: GO 84241
84057: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84058: LD_ADDR_VAR 0 1
84062: PUSH
84063: LD_INT 2
84065: PUSH
84066: LD_INT 4
84068: PUSH
84069: LD_INT 5
84071: PUSH
84072: LD_INT 6
84074: PUSH
84075: LD_INT 7
84077: PUSH
84078: LD_INT 8
84080: PUSH
84081: LD_INT 9
84083: PUSH
84084: LD_INT 10
84086: PUSH
84087: LD_INT 11
84089: PUSH
84090: LD_INT 12
84092: PUSH
84093: LD_INT 13
84095: PUSH
84096: LD_INT 14
84098: PUSH
84099: LD_INT 15
84101: PUSH
84102: LD_INT 16
84104: PUSH
84105: LD_INT 17
84107: PUSH
84108: LD_INT 18
84110: PUSH
84111: LD_INT 19
84113: PUSH
84114: LD_INT 20
84116: PUSH
84117: LD_INT 21
84119: PUSH
84120: LD_INT 22
84122: PUSH
84123: LD_INT 23
84125: PUSH
84126: LD_INT 24
84128: PUSH
84129: LD_INT 25
84131: PUSH
84132: LD_INT 26
84134: PUSH
84135: LD_INT 28
84137: PUSH
84138: LD_INT 30
84140: PUSH
84141: LD_INT 31
84143: PUSH
84144: LD_INT 32
84146: PUSH
84147: LD_INT 36
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 101
84183: PUSH
84184: LD_INT 102
84186: PUSH
84187: LD_INT 103
84189: PUSH
84190: LD_INT 104
84192: PUSH
84193: LD_INT 105
84195: PUSH
84196: LD_INT 106
84198: PUSH
84199: LD_INT 107
84201: PUSH
84202: LD_INT 108
84204: PUSH
84205: LD_INT 109
84207: PUSH
84208: LD_INT 110
84210: PUSH
84211: LD_INT 111
84213: PUSH
84214: LD_INT 112
84216: PUSH
84217: LD_INT 114
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: ST_TO_ADDR
84239: GO 86026
84241: LD_INT 11
84243: DOUBLE
84244: EQUAL
84245: IFTRUE 84249
84247: GO 84441
84249: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84250: LD_ADDR_VAR 0 1
84254: PUSH
84255: LD_INT 2
84257: PUSH
84258: LD_INT 3
84260: PUSH
84261: LD_INT 4
84263: PUSH
84264: LD_INT 5
84266: PUSH
84267: LD_INT 6
84269: PUSH
84270: LD_INT 7
84272: PUSH
84273: LD_INT 8
84275: PUSH
84276: LD_INT 9
84278: PUSH
84279: LD_INT 10
84281: PUSH
84282: LD_INT 11
84284: PUSH
84285: LD_INT 12
84287: PUSH
84288: LD_INT 13
84290: PUSH
84291: LD_INT 14
84293: PUSH
84294: LD_INT 15
84296: PUSH
84297: LD_INT 16
84299: PUSH
84300: LD_INT 17
84302: PUSH
84303: LD_INT 18
84305: PUSH
84306: LD_INT 19
84308: PUSH
84309: LD_INT 20
84311: PUSH
84312: LD_INT 21
84314: PUSH
84315: LD_INT 22
84317: PUSH
84318: LD_INT 23
84320: PUSH
84321: LD_INT 24
84323: PUSH
84324: LD_INT 25
84326: PUSH
84327: LD_INT 26
84329: PUSH
84330: LD_INT 28
84332: PUSH
84333: LD_INT 30
84335: PUSH
84336: LD_INT 31
84338: PUSH
84339: LD_INT 32
84341: PUSH
84342: LD_INT 34
84344: PUSH
84345: LD_INT 36
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 101
84383: PUSH
84384: LD_INT 102
84386: PUSH
84387: LD_INT 103
84389: PUSH
84390: LD_INT 104
84392: PUSH
84393: LD_INT 105
84395: PUSH
84396: LD_INT 106
84398: PUSH
84399: LD_INT 107
84401: PUSH
84402: LD_INT 108
84404: PUSH
84405: LD_INT 109
84407: PUSH
84408: LD_INT 110
84410: PUSH
84411: LD_INT 111
84413: PUSH
84414: LD_INT 112
84416: PUSH
84417: LD_INT 114
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: ST_TO_ADDR
84439: GO 86026
84441: LD_INT 12
84443: DOUBLE
84444: EQUAL
84445: IFTRUE 84449
84447: GO 84657
84449: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
84450: LD_ADDR_VAR 0 1
84454: PUSH
84455: LD_INT 1
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: LD_INT 3
84463: PUSH
84464: LD_INT 4
84466: PUSH
84467: LD_INT 5
84469: PUSH
84470: LD_INT 6
84472: PUSH
84473: LD_INT 7
84475: PUSH
84476: LD_INT 8
84478: PUSH
84479: LD_INT 9
84481: PUSH
84482: LD_INT 10
84484: PUSH
84485: LD_INT 11
84487: PUSH
84488: LD_INT 12
84490: PUSH
84491: LD_INT 13
84493: PUSH
84494: LD_INT 14
84496: PUSH
84497: LD_INT 15
84499: PUSH
84500: LD_INT 16
84502: PUSH
84503: LD_INT 17
84505: PUSH
84506: LD_INT 18
84508: PUSH
84509: LD_INT 19
84511: PUSH
84512: LD_INT 20
84514: PUSH
84515: LD_INT 21
84517: PUSH
84518: LD_INT 22
84520: PUSH
84521: LD_INT 23
84523: PUSH
84524: LD_INT 24
84526: PUSH
84527: LD_INT 25
84529: PUSH
84530: LD_INT 26
84532: PUSH
84533: LD_INT 27
84535: PUSH
84536: LD_INT 28
84538: PUSH
84539: LD_INT 30
84541: PUSH
84542: LD_INT 31
84544: PUSH
84545: LD_INT 32
84547: PUSH
84548: LD_INT 33
84550: PUSH
84551: LD_INT 34
84553: PUSH
84554: LD_INT 36
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 101
84595: PUSH
84596: LD_INT 102
84598: PUSH
84599: LD_INT 103
84601: PUSH
84602: LD_INT 104
84604: PUSH
84605: LD_INT 105
84607: PUSH
84608: LD_INT 106
84610: PUSH
84611: LD_INT 107
84613: PUSH
84614: LD_INT 108
84616: PUSH
84617: LD_INT 109
84619: PUSH
84620: LD_INT 110
84622: PUSH
84623: LD_INT 111
84625: PUSH
84626: LD_INT 112
84628: PUSH
84629: LD_INT 113
84631: PUSH
84632: LD_INT 114
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: ST_TO_ADDR
84655: GO 86026
84657: LD_INT 13
84659: DOUBLE
84660: EQUAL
84661: IFTRUE 84665
84663: GO 84861
84665: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84666: LD_ADDR_VAR 0 1
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: LD_INT 2
84676: PUSH
84677: LD_INT 3
84679: PUSH
84680: LD_INT 4
84682: PUSH
84683: LD_INT 5
84685: PUSH
84686: LD_INT 8
84688: PUSH
84689: LD_INT 9
84691: PUSH
84692: LD_INT 10
84694: PUSH
84695: LD_INT 11
84697: PUSH
84698: LD_INT 12
84700: PUSH
84701: LD_INT 14
84703: PUSH
84704: LD_INT 15
84706: PUSH
84707: LD_INT 16
84709: PUSH
84710: LD_INT 17
84712: PUSH
84713: LD_INT 18
84715: PUSH
84716: LD_INT 19
84718: PUSH
84719: LD_INT 20
84721: PUSH
84722: LD_INT 21
84724: PUSH
84725: LD_INT 22
84727: PUSH
84728: LD_INT 23
84730: PUSH
84731: LD_INT 24
84733: PUSH
84734: LD_INT 25
84736: PUSH
84737: LD_INT 26
84739: PUSH
84740: LD_INT 27
84742: PUSH
84743: LD_INT 28
84745: PUSH
84746: LD_INT 30
84748: PUSH
84749: LD_INT 31
84751: PUSH
84752: LD_INT 32
84754: PUSH
84755: LD_INT 33
84757: PUSH
84758: LD_INT 34
84760: PUSH
84761: LD_INT 36
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 101
84799: PUSH
84800: LD_INT 102
84802: PUSH
84803: LD_INT 103
84805: PUSH
84806: LD_INT 104
84808: PUSH
84809: LD_INT 105
84811: PUSH
84812: LD_INT 106
84814: PUSH
84815: LD_INT 107
84817: PUSH
84818: LD_INT 108
84820: PUSH
84821: LD_INT 109
84823: PUSH
84824: LD_INT 110
84826: PUSH
84827: LD_INT 111
84829: PUSH
84830: LD_INT 112
84832: PUSH
84833: LD_INT 113
84835: PUSH
84836: LD_INT 114
84838: PUSH
84839: EMPTY
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: ST_TO_ADDR
84859: GO 86026
84861: LD_INT 14
84863: DOUBLE
84864: EQUAL
84865: IFTRUE 84869
84867: GO 85081
84869: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84870: LD_ADDR_VAR 0 1
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 2
84880: PUSH
84881: LD_INT 3
84883: PUSH
84884: LD_INT 4
84886: PUSH
84887: LD_INT 5
84889: PUSH
84890: LD_INT 6
84892: PUSH
84893: LD_INT 7
84895: PUSH
84896: LD_INT 8
84898: PUSH
84899: LD_INT 9
84901: PUSH
84902: LD_INT 10
84904: PUSH
84905: LD_INT 11
84907: PUSH
84908: LD_INT 12
84910: PUSH
84911: LD_INT 13
84913: PUSH
84914: LD_INT 14
84916: PUSH
84917: LD_INT 15
84919: PUSH
84920: LD_INT 16
84922: PUSH
84923: LD_INT 17
84925: PUSH
84926: LD_INT 18
84928: PUSH
84929: LD_INT 19
84931: PUSH
84932: LD_INT 20
84934: PUSH
84935: LD_INT 21
84937: PUSH
84938: LD_INT 22
84940: PUSH
84941: LD_INT 23
84943: PUSH
84944: LD_INT 24
84946: PUSH
84947: LD_INT 25
84949: PUSH
84950: LD_INT 26
84952: PUSH
84953: LD_INT 27
84955: PUSH
84956: LD_INT 28
84958: PUSH
84959: LD_INT 29
84961: PUSH
84962: LD_INT 30
84964: PUSH
84965: LD_INT 31
84967: PUSH
84968: LD_INT 32
84970: PUSH
84971: LD_INT 33
84973: PUSH
84974: LD_INT 34
84976: PUSH
84977: LD_INT 36
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 101
85019: PUSH
85020: LD_INT 102
85022: PUSH
85023: LD_INT 103
85025: PUSH
85026: LD_INT 104
85028: PUSH
85029: LD_INT 105
85031: PUSH
85032: LD_INT 106
85034: PUSH
85035: LD_INT 107
85037: PUSH
85038: LD_INT 108
85040: PUSH
85041: LD_INT 109
85043: PUSH
85044: LD_INT 110
85046: PUSH
85047: LD_INT 111
85049: PUSH
85050: LD_INT 112
85052: PUSH
85053: LD_INT 113
85055: PUSH
85056: LD_INT 114
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: ST_TO_ADDR
85079: GO 86026
85081: LD_INT 15
85083: DOUBLE
85084: EQUAL
85085: IFTRUE 85089
85087: GO 85301
85089: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
85090: LD_ADDR_VAR 0 1
85094: PUSH
85095: LD_INT 1
85097: PUSH
85098: LD_INT 2
85100: PUSH
85101: LD_INT 3
85103: PUSH
85104: LD_INT 4
85106: PUSH
85107: LD_INT 5
85109: PUSH
85110: LD_INT 6
85112: PUSH
85113: LD_INT 7
85115: PUSH
85116: LD_INT 8
85118: PUSH
85119: LD_INT 9
85121: PUSH
85122: LD_INT 10
85124: PUSH
85125: LD_INT 11
85127: PUSH
85128: LD_INT 12
85130: PUSH
85131: LD_INT 13
85133: PUSH
85134: LD_INT 14
85136: PUSH
85137: LD_INT 15
85139: PUSH
85140: LD_INT 16
85142: PUSH
85143: LD_INT 17
85145: PUSH
85146: LD_INT 18
85148: PUSH
85149: LD_INT 19
85151: PUSH
85152: LD_INT 20
85154: PUSH
85155: LD_INT 21
85157: PUSH
85158: LD_INT 22
85160: PUSH
85161: LD_INT 23
85163: PUSH
85164: LD_INT 24
85166: PUSH
85167: LD_INT 25
85169: PUSH
85170: LD_INT 26
85172: PUSH
85173: LD_INT 27
85175: PUSH
85176: LD_INT 28
85178: PUSH
85179: LD_INT 29
85181: PUSH
85182: LD_INT 30
85184: PUSH
85185: LD_INT 31
85187: PUSH
85188: LD_INT 32
85190: PUSH
85191: LD_INT 33
85193: PUSH
85194: LD_INT 34
85196: PUSH
85197: LD_INT 36
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 101
85239: PUSH
85240: LD_INT 102
85242: PUSH
85243: LD_INT 103
85245: PUSH
85246: LD_INT 104
85248: PUSH
85249: LD_INT 105
85251: PUSH
85252: LD_INT 106
85254: PUSH
85255: LD_INT 107
85257: PUSH
85258: LD_INT 108
85260: PUSH
85261: LD_INT 109
85263: PUSH
85264: LD_INT 110
85266: PUSH
85267: LD_INT 111
85269: PUSH
85270: LD_INT 112
85272: PUSH
85273: LD_INT 113
85275: PUSH
85276: LD_INT 114
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: ST_TO_ADDR
85299: GO 86026
85301: LD_INT 16
85303: DOUBLE
85304: EQUAL
85305: IFTRUE 85309
85307: GO 85433
85309: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
85310: LD_ADDR_VAR 0 1
85314: PUSH
85315: LD_INT 2
85317: PUSH
85318: LD_INT 4
85320: PUSH
85321: LD_INT 5
85323: PUSH
85324: LD_INT 7
85326: PUSH
85327: LD_INT 11
85329: PUSH
85330: LD_INT 12
85332: PUSH
85333: LD_INT 15
85335: PUSH
85336: LD_INT 16
85338: PUSH
85339: LD_INT 20
85341: PUSH
85342: LD_INT 21
85344: PUSH
85345: LD_INT 22
85347: PUSH
85348: LD_INT 23
85350: PUSH
85351: LD_INT 25
85353: PUSH
85354: LD_INT 26
85356: PUSH
85357: LD_INT 30
85359: PUSH
85360: LD_INT 31
85362: PUSH
85363: LD_INT 32
85365: PUSH
85366: LD_INT 33
85368: PUSH
85369: LD_INT 34
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 101
85395: PUSH
85396: LD_INT 102
85398: PUSH
85399: LD_INT 103
85401: PUSH
85402: LD_INT 106
85404: PUSH
85405: LD_INT 108
85407: PUSH
85408: LD_INT 112
85410: PUSH
85411: LD_INT 113
85413: PUSH
85414: LD_INT 114
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: ST_TO_ADDR
85431: GO 86026
85433: LD_INT 17
85435: DOUBLE
85436: EQUAL
85437: IFTRUE 85441
85439: GO 85653
85441: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
85442: LD_ADDR_VAR 0 1
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: LD_INT 2
85452: PUSH
85453: LD_INT 3
85455: PUSH
85456: LD_INT 4
85458: PUSH
85459: LD_INT 5
85461: PUSH
85462: LD_INT 6
85464: PUSH
85465: LD_INT 7
85467: PUSH
85468: LD_INT 8
85470: PUSH
85471: LD_INT 9
85473: PUSH
85474: LD_INT 10
85476: PUSH
85477: LD_INT 11
85479: PUSH
85480: LD_INT 12
85482: PUSH
85483: LD_INT 13
85485: PUSH
85486: LD_INT 14
85488: PUSH
85489: LD_INT 15
85491: PUSH
85492: LD_INT 16
85494: PUSH
85495: LD_INT 17
85497: PUSH
85498: LD_INT 18
85500: PUSH
85501: LD_INT 19
85503: PUSH
85504: LD_INT 20
85506: PUSH
85507: LD_INT 21
85509: PUSH
85510: LD_INT 22
85512: PUSH
85513: LD_INT 23
85515: PUSH
85516: LD_INT 24
85518: PUSH
85519: LD_INT 25
85521: PUSH
85522: LD_INT 26
85524: PUSH
85525: LD_INT 27
85527: PUSH
85528: LD_INT 28
85530: PUSH
85531: LD_INT 29
85533: PUSH
85534: LD_INT 30
85536: PUSH
85537: LD_INT 31
85539: PUSH
85540: LD_INT 32
85542: PUSH
85543: LD_INT 33
85545: PUSH
85546: LD_INT 34
85548: PUSH
85549: LD_INT 36
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 101
85591: PUSH
85592: LD_INT 102
85594: PUSH
85595: LD_INT 103
85597: PUSH
85598: LD_INT 104
85600: PUSH
85601: LD_INT 105
85603: PUSH
85604: LD_INT 106
85606: PUSH
85607: LD_INT 107
85609: PUSH
85610: LD_INT 108
85612: PUSH
85613: LD_INT 109
85615: PUSH
85616: LD_INT 110
85618: PUSH
85619: LD_INT 111
85621: PUSH
85622: LD_INT 112
85624: PUSH
85625: LD_INT 113
85627: PUSH
85628: LD_INT 114
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: ST_TO_ADDR
85651: GO 86026
85653: LD_INT 18
85655: DOUBLE
85656: EQUAL
85657: IFTRUE 85661
85659: GO 85797
85661: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85662: LD_ADDR_VAR 0 1
85666: PUSH
85667: LD_INT 2
85669: PUSH
85670: LD_INT 4
85672: PUSH
85673: LD_INT 5
85675: PUSH
85676: LD_INT 7
85678: PUSH
85679: LD_INT 11
85681: PUSH
85682: LD_INT 12
85684: PUSH
85685: LD_INT 15
85687: PUSH
85688: LD_INT 16
85690: PUSH
85691: LD_INT 20
85693: PUSH
85694: LD_INT 21
85696: PUSH
85697: LD_INT 22
85699: PUSH
85700: LD_INT 23
85702: PUSH
85703: LD_INT 25
85705: PUSH
85706: LD_INT 26
85708: PUSH
85709: LD_INT 30
85711: PUSH
85712: LD_INT 31
85714: PUSH
85715: LD_INT 32
85717: PUSH
85718: LD_INT 33
85720: PUSH
85721: LD_INT 34
85723: PUSH
85724: LD_INT 35
85726: PUSH
85727: LD_INT 36
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 101
85755: PUSH
85756: LD_INT 102
85758: PUSH
85759: LD_INT 103
85761: PUSH
85762: LD_INT 106
85764: PUSH
85765: LD_INT 108
85767: PUSH
85768: LD_INT 112
85770: PUSH
85771: LD_INT 113
85773: PUSH
85774: LD_INT 114
85776: PUSH
85777: LD_INT 115
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: ST_TO_ADDR
85795: GO 86026
85797: LD_INT 19
85799: DOUBLE
85800: EQUAL
85801: IFTRUE 85805
85803: GO 86025
85805: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85806: LD_ADDR_VAR 0 1
85810: PUSH
85811: LD_INT 1
85813: PUSH
85814: LD_INT 2
85816: PUSH
85817: LD_INT 3
85819: PUSH
85820: LD_INT 4
85822: PUSH
85823: LD_INT 5
85825: PUSH
85826: LD_INT 6
85828: PUSH
85829: LD_INT 7
85831: PUSH
85832: LD_INT 8
85834: PUSH
85835: LD_INT 9
85837: PUSH
85838: LD_INT 10
85840: PUSH
85841: LD_INT 11
85843: PUSH
85844: LD_INT 12
85846: PUSH
85847: LD_INT 13
85849: PUSH
85850: LD_INT 14
85852: PUSH
85853: LD_INT 15
85855: PUSH
85856: LD_INT 16
85858: PUSH
85859: LD_INT 17
85861: PUSH
85862: LD_INT 18
85864: PUSH
85865: LD_INT 19
85867: PUSH
85868: LD_INT 20
85870: PUSH
85871: LD_INT 21
85873: PUSH
85874: LD_INT 22
85876: PUSH
85877: LD_INT 23
85879: PUSH
85880: LD_INT 24
85882: PUSH
85883: LD_INT 25
85885: PUSH
85886: LD_INT 26
85888: PUSH
85889: LD_INT 27
85891: PUSH
85892: LD_INT 28
85894: PUSH
85895: LD_INT 29
85897: PUSH
85898: LD_INT 30
85900: PUSH
85901: LD_INT 31
85903: PUSH
85904: LD_INT 32
85906: PUSH
85907: LD_INT 33
85909: PUSH
85910: LD_INT 34
85912: PUSH
85913: LD_INT 35
85915: PUSH
85916: LD_INT 36
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: PUSH
85957: LD_INT 101
85959: PUSH
85960: LD_INT 102
85962: PUSH
85963: LD_INT 103
85965: PUSH
85966: LD_INT 104
85968: PUSH
85969: LD_INT 105
85971: PUSH
85972: LD_INT 106
85974: PUSH
85975: LD_INT 107
85977: PUSH
85978: LD_INT 108
85980: PUSH
85981: LD_INT 109
85983: PUSH
85984: LD_INT 110
85986: PUSH
85987: LD_INT 111
85989: PUSH
85990: LD_INT 112
85992: PUSH
85993: LD_INT 113
85995: PUSH
85996: LD_INT 114
85998: PUSH
85999: LD_INT 115
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: ST_TO_ADDR
86023: GO 86026
86025: POP
// end else
86026: GO 86245
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86028: LD_ADDR_VAR 0 1
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: LD_INT 2
86038: PUSH
86039: LD_INT 3
86041: PUSH
86042: LD_INT 4
86044: PUSH
86045: LD_INT 5
86047: PUSH
86048: LD_INT 6
86050: PUSH
86051: LD_INT 7
86053: PUSH
86054: LD_INT 8
86056: PUSH
86057: LD_INT 9
86059: PUSH
86060: LD_INT 10
86062: PUSH
86063: LD_INT 11
86065: PUSH
86066: LD_INT 12
86068: PUSH
86069: LD_INT 13
86071: PUSH
86072: LD_INT 14
86074: PUSH
86075: LD_INT 15
86077: PUSH
86078: LD_INT 16
86080: PUSH
86081: LD_INT 17
86083: PUSH
86084: LD_INT 18
86086: PUSH
86087: LD_INT 19
86089: PUSH
86090: LD_INT 20
86092: PUSH
86093: LD_INT 21
86095: PUSH
86096: LD_INT 22
86098: PUSH
86099: LD_INT 23
86101: PUSH
86102: LD_INT 24
86104: PUSH
86105: LD_INT 25
86107: PUSH
86108: LD_INT 26
86110: PUSH
86111: LD_INT 27
86113: PUSH
86114: LD_INT 28
86116: PUSH
86117: LD_INT 29
86119: PUSH
86120: LD_INT 30
86122: PUSH
86123: LD_INT 31
86125: PUSH
86126: LD_INT 32
86128: PUSH
86129: LD_INT 33
86131: PUSH
86132: LD_INT 34
86134: PUSH
86135: LD_INT 35
86137: PUSH
86138: LD_INT 36
86140: PUSH
86141: EMPTY
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 101
86181: PUSH
86182: LD_INT 102
86184: PUSH
86185: LD_INT 103
86187: PUSH
86188: LD_INT 104
86190: PUSH
86191: LD_INT 105
86193: PUSH
86194: LD_INT 106
86196: PUSH
86197: LD_INT 107
86199: PUSH
86200: LD_INT 108
86202: PUSH
86203: LD_INT 109
86205: PUSH
86206: LD_INT 110
86208: PUSH
86209: LD_INT 111
86211: PUSH
86212: LD_INT 112
86214: PUSH
86215: LD_INT 113
86217: PUSH
86218: LD_INT 114
86220: PUSH
86221: LD_INT 115
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: ST_TO_ADDR
// if result then
86245: LD_VAR 0 1
86249: IFFALSE 86538
// begin normal :=  ;
86251: LD_ADDR_VAR 0 3
86255: PUSH
86256: LD_STRING 
86258: ST_TO_ADDR
// hardcore :=  ;
86259: LD_ADDR_VAR 0 4
86263: PUSH
86264: LD_STRING 
86266: ST_TO_ADDR
// for i = 1 to normalCounter do
86267: LD_ADDR_VAR 0 5
86271: PUSH
86272: DOUBLE
86273: LD_INT 1
86275: DEC
86276: ST_TO_ADDR
86277: LD_EXP 110
86281: PUSH
86282: FOR_TO
86283: IFFALSE 86384
// begin tmp := 0 ;
86285: LD_ADDR_VAR 0 2
86289: PUSH
86290: LD_STRING 0
86292: ST_TO_ADDR
// if result [ 1 ] then
86293: LD_VAR 0 1
86297: PUSH
86298: LD_INT 1
86300: ARRAY
86301: IFFALSE 86366
// if result [ 1 ] [ 1 ] = i then
86303: LD_VAR 0 1
86307: PUSH
86308: LD_INT 1
86310: ARRAY
86311: PUSH
86312: LD_INT 1
86314: ARRAY
86315: PUSH
86316: LD_VAR 0 5
86320: EQUAL
86321: IFFALSE 86366
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
86323: LD_ADDR_VAR 0 1
86327: PUSH
86328: LD_VAR 0 1
86332: PPUSH
86333: LD_INT 1
86335: PPUSH
86336: LD_VAR 0 1
86340: PUSH
86341: LD_INT 1
86343: ARRAY
86344: PPUSH
86345: LD_INT 1
86347: PPUSH
86348: CALL_OW 3
86352: PPUSH
86353: CALL_OW 1
86357: ST_TO_ADDR
// tmp := 1 ;
86358: LD_ADDR_VAR 0 2
86362: PUSH
86363: LD_STRING 1
86365: ST_TO_ADDR
// end ; normal := normal & tmp ;
86366: LD_ADDR_VAR 0 3
86370: PUSH
86371: LD_VAR 0 3
86375: PUSH
86376: LD_VAR 0 2
86380: STR
86381: ST_TO_ADDR
// end ;
86382: GO 86282
86384: POP
86385: POP
// for i = 1 to hardcoreCounter do
86386: LD_ADDR_VAR 0 5
86390: PUSH
86391: DOUBLE
86392: LD_INT 1
86394: DEC
86395: ST_TO_ADDR
86396: LD_EXP 111
86400: PUSH
86401: FOR_TO
86402: IFFALSE 86507
// begin tmp := 0 ;
86404: LD_ADDR_VAR 0 2
86408: PUSH
86409: LD_STRING 0
86411: ST_TO_ADDR
// if result [ 2 ] then
86412: LD_VAR 0 1
86416: PUSH
86417: LD_INT 2
86419: ARRAY
86420: IFFALSE 86489
// if result [ 2 ] [ 1 ] = 100 + i then
86422: LD_VAR 0 1
86426: PUSH
86427: LD_INT 2
86429: ARRAY
86430: PUSH
86431: LD_INT 1
86433: ARRAY
86434: PUSH
86435: LD_INT 100
86437: PUSH
86438: LD_VAR 0 5
86442: PLUS
86443: EQUAL
86444: IFFALSE 86489
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
86446: LD_ADDR_VAR 0 1
86450: PUSH
86451: LD_VAR 0 1
86455: PPUSH
86456: LD_INT 2
86458: PPUSH
86459: LD_VAR 0 1
86463: PUSH
86464: LD_INT 2
86466: ARRAY
86467: PPUSH
86468: LD_INT 1
86470: PPUSH
86471: CALL_OW 3
86475: PPUSH
86476: CALL_OW 1
86480: ST_TO_ADDR
// tmp := 1 ;
86481: LD_ADDR_VAR 0 2
86485: PUSH
86486: LD_STRING 1
86488: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
86489: LD_ADDR_VAR 0 4
86493: PUSH
86494: LD_VAR 0 4
86498: PUSH
86499: LD_VAR 0 2
86503: STR
86504: ST_TO_ADDR
// end ;
86505: GO 86401
86507: POP
86508: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
86509: LD_STRING getStreamItemsFromMission("
86511: PUSH
86512: LD_VAR 0 3
86516: STR
86517: PUSH
86518: LD_STRING ","
86520: STR
86521: PUSH
86522: LD_VAR 0 4
86526: STR
86527: PUSH
86528: LD_STRING ")
86530: STR
86531: PPUSH
86532: CALL_OW 559
// end else
86536: GO 86545
// ToLua ( getStreamItemsFromMission("","") ) ;
86538: LD_STRING getStreamItemsFromMission("","")
86540: PPUSH
86541: CALL_OW 559
// end ;
86545: LD_VAR 0 1
86549: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
86550: LD_EXP 109
86554: PUSH
86555: LD_EXP 114
86559: AND
86560: IFFALSE 86684
86562: GO 86564
86564: DISABLE
86565: LD_INT 0
86567: PPUSH
86568: PPUSH
// begin enable ;
86569: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
86570: LD_ADDR_VAR 0 2
86574: PUSH
86575: LD_INT 22
86577: PUSH
86578: LD_OWVAR 2
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 2
86589: PUSH
86590: LD_INT 34
86592: PUSH
86593: LD_INT 7
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 34
86602: PUSH
86603: LD_INT 45
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 34
86612: PUSH
86613: LD_INT 28
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PUSH
86620: LD_INT 34
86622: PUSH
86623: LD_INT 47
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PPUSH
86641: CALL_OW 69
86645: ST_TO_ADDR
// if not tmp then
86646: LD_VAR 0 2
86650: NOT
86651: IFFALSE 86655
// exit ;
86653: GO 86684
// for i in tmp do
86655: LD_ADDR_VAR 0 1
86659: PUSH
86660: LD_VAR 0 2
86664: PUSH
86665: FOR_IN
86666: IFFALSE 86682
// begin SetLives ( i , 0 ) ;
86668: LD_VAR 0 1
86672: PPUSH
86673: LD_INT 0
86675: PPUSH
86676: CALL_OW 234
// end ;
86680: GO 86665
86682: POP
86683: POP
// end ;
86684: PPOPN 2
86686: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86687: LD_EXP 109
86691: PUSH
86692: LD_EXP 115
86696: AND
86697: IFFALSE 86781
86699: GO 86701
86701: DISABLE
86702: LD_INT 0
86704: PPUSH
86705: PPUSH
// begin enable ;
86706: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86707: LD_ADDR_VAR 0 2
86711: PUSH
86712: LD_INT 22
86714: PUSH
86715: LD_OWVAR 2
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 32
86726: PUSH
86727: LD_INT 3
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PPUSH
86738: CALL_OW 69
86742: ST_TO_ADDR
// if not tmp then
86743: LD_VAR 0 2
86747: NOT
86748: IFFALSE 86752
// exit ;
86750: GO 86781
// for i in tmp do
86752: LD_ADDR_VAR 0 1
86756: PUSH
86757: LD_VAR 0 2
86761: PUSH
86762: FOR_IN
86763: IFFALSE 86779
// begin SetLives ( i , 0 ) ;
86765: LD_VAR 0 1
86769: PPUSH
86770: LD_INT 0
86772: PPUSH
86773: CALL_OW 234
// end ;
86777: GO 86762
86779: POP
86780: POP
// end ;
86781: PPOPN 2
86783: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86784: LD_EXP 109
86788: PUSH
86789: LD_EXP 112
86793: AND
86794: IFFALSE 86887
86796: GO 86798
86798: DISABLE
86799: LD_INT 0
86801: PPUSH
// begin enable ;
86802: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86803: LD_ADDR_VAR 0 1
86807: PUSH
86808: LD_INT 22
86810: PUSH
86811: LD_OWVAR 2
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: LD_INT 25
86825: PUSH
86826: LD_INT 5
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 25
86835: PUSH
86836: LD_INT 9
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 25
86845: PUSH
86846: LD_INT 8
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PPUSH
86863: CALL_OW 69
86867: PUSH
86868: FOR_IN
86869: IFFALSE 86885
// begin SetClass ( i , 1 ) ;
86871: LD_VAR 0 1
86875: PPUSH
86876: LD_INT 1
86878: PPUSH
86879: CALL_OW 336
// end ;
86883: GO 86868
86885: POP
86886: POP
// end ;
86887: PPOPN 1
86889: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86890: LD_EXP 109
86894: PUSH
86895: LD_EXP 113
86899: AND
86900: PUSH
86901: LD_OWVAR 65
86905: PUSH
86906: LD_INT 7
86908: LESS
86909: AND
86910: IFFALSE 86924
86912: GO 86914
86914: DISABLE
// begin enable ;
86915: ENABLE
// game_speed := 7 ;
86916: LD_ADDR_OWVAR 65
86920: PUSH
86921: LD_INT 7
86923: ST_TO_ADDR
// end ;
86924: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
86925: LD_EXP 109
86929: PUSH
86930: LD_EXP 116
86934: AND
86935: IFFALSE 87137
86937: GO 86939
86939: DISABLE
86940: LD_INT 0
86942: PPUSH
86943: PPUSH
86944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
86945: LD_ADDR_VAR 0 3
86949: PUSH
86950: LD_INT 81
86952: PUSH
86953: LD_OWVAR 2
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 21
86964: PUSH
86965: LD_INT 1
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PPUSH
86976: CALL_OW 69
86980: ST_TO_ADDR
// if not tmp then
86981: LD_VAR 0 3
86985: NOT
86986: IFFALSE 86990
// exit ;
86988: GO 87137
// if tmp > 5 then
86990: LD_VAR 0 3
86994: PUSH
86995: LD_INT 5
86997: GREATER
86998: IFFALSE 87010
// k := 5 else
87000: LD_ADDR_VAR 0 2
87004: PUSH
87005: LD_INT 5
87007: ST_TO_ADDR
87008: GO 87020
// k := tmp ;
87010: LD_ADDR_VAR 0 2
87014: PUSH
87015: LD_VAR 0 3
87019: ST_TO_ADDR
// for i := 1 to k do
87020: LD_ADDR_VAR 0 1
87024: PUSH
87025: DOUBLE
87026: LD_INT 1
87028: DEC
87029: ST_TO_ADDR
87030: LD_VAR 0 2
87034: PUSH
87035: FOR_TO
87036: IFFALSE 87135
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87038: LD_VAR 0 3
87042: PUSH
87043: LD_VAR 0 1
87047: ARRAY
87048: PPUSH
87049: LD_VAR 0 1
87053: PUSH
87054: LD_INT 4
87056: MOD
87057: PUSH
87058: LD_INT 1
87060: PLUS
87061: PPUSH
87062: CALL_OW 259
87066: PUSH
87067: LD_INT 10
87069: LESS
87070: IFFALSE 87133
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
87072: LD_VAR 0 3
87076: PUSH
87077: LD_VAR 0 1
87081: ARRAY
87082: PPUSH
87083: LD_VAR 0 1
87087: PUSH
87088: LD_INT 4
87090: MOD
87091: PUSH
87092: LD_INT 1
87094: PLUS
87095: PPUSH
87096: LD_VAR 0 3
87100: PUSH
87101: LD_VAR 0 1
87105: ARRAY
87106: PPUSH
87107: LD_VAR 0 1
87111: PUSH
87112: LD_INT 4
87114: MOD
87115: PUSH
87116: LD_INT 1
87118: PLUS
87119: PPUSH
87120: CALL_OW 259
87124: PUSH
87125: LD_INT 1
87127: PLUS
87128: PPUSH
87129: CALL_OW 237
87133: GO 87035
87135: POP
87136: POP
// end ;
87137: PPOPN 3
87139: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
87140: LD_EXP 109
87144: PUSH
87145: LD_EXP 117
87149: AND
87150: IFFALSE 87170
87152: GO 87154
87154: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
87155: LD_INT 4
87157: PPUSH
87158: LD_OWVAR 2
87162: PPUSH
87163: LD_INT 0
87165: PPUSH
87166: CALL_OW 324
87170: END
// every 0 0$1 trigger StreamModeActive and sShovel do
87171: LD_EXP 109
87175: PUSH
87176: LD_EXP 146
87180: AND
87181: IFFALSE 87201
87183: GO 87185
87185: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
87186: LD_INT 19
87188: PPUSH
87189: LD_OWVAR 2
87193: PPUSH
87194: LD_INT 0
87196: PPUSH
87197: CALL_OW 324
87201: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
87202: LD_EXP 109
87206: PUSH
87207: LD_EXP 118
87211: AND
87212: IFFALSE 87314
87214: GO 87216
87216: DISABLE
87217: LD_INT 0
87219: PPUSH
87220: PPUSH
// begin enable ;
87221: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
87222: LD_ADDR_VAR 0 2
87226: PUSH
87227: LD_INT 22
87229: PUSH
87230: LD_OWVAR 2
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 2
87241: PUSH
87242: LD_INT 34
87244: PUSH
87245: LD_INT 11
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 34
87254: PUSH
87255: LD_INT 30
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: LIST
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PPUSH
87271: CALL_OW 69
87275: ST_TO_ADDR
// if not tmp then
87276: LD_VAR 0 2
87280: NOT
87281: IFFALSE 87285
// exit ;
87283: GO 87314
// for i in tmp do
87285: LD_ADDR_VAR 0 1
87289: PUSH
87290: LD_VAR 0 2
87294: PUSH
87295: FOR_IN
87296: IFFALSE 87312
// begin SetLives ( i , 0 ) ;
87298: LD_VAR 0 1
87302: PPUSH
87303: LD_INT 0
87305: PPUSH
87306: CALL_OW 234
// end ;
87310: GO 87295
87312: POP
87313: POP
// end ;
87314: PPOPN 2
87316: END
// every 0 0$1 trigger StreamModeActive and sBunker do
87317: LD_EXP 109
87321: PUSH
87322: LD_EXP 119
87326: AND
87327: IFFALSE 87347
87329: GO 87331
87331: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
87332: LD_INT 32
87334: PPUSH
87335: LD_OWVAR 2
87339: PPUSH
87340: LD_INT 0
87342: PPUSH
87343: CALL_OW 324
87347: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
87348: LD_EXP 109
87352: PUSH
87353: LD_EXP 120
87357: AND
87358: IFFALSE 87539
87360: GO 87362
87362: DISABLE
87363: LD_INT 0
87365: PPUSH
87366: PPUSH
87367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
87368: LD_ADDR_VAR 0 2
87372: PUSH
87373: LD_INT 22
87375: PUSH
87376: LD_OWVAR 2
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 33
87387: PUSH
87388: LD_INT 3
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PPUSH
87399: CALL_OW 69
87403: ST_TO_ADDR
// if not tmp then
87404: LD_VAR 0 2
87408: NOT
87409: IFFALSE 87413
// exit ;
87411: GO 87539
// side := 0 ;
87413: LD_ADDR_VAR 0 3
87417: PUSH
87418: LD_INT 0
87420: ST_TO_ADDR
// for i := 1 to 8 do
87421: LD_ADDR_VAR 0 1
87425: PUSH
87426: DOUBLE
87427: LD_INT 1
87429: DEC
87430: ST_TO_ADDR
87431: LD_INT 8
87433: PUSH
87434: FOR_TO
87435: IFFALSE 87483
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
87437: LD_OWVAR 2
87441: PUSH
87442: LD_VAR 0 1
87446: NONEQUAL
87447: PUSH
87448: LD_OWVAR 2
87452: PPUSH
87453: LD_VAR 0 1
87457: PPUSH
87458: CALL_OW 81
87462: PUSH
87463: LD_INT 2
87465: EQUAL
87466: AND
87467: IFFALSE 87481
// begin side := i ;
87469: LD_ADDR_VAR 0 3
87473: PUSH
87474: LD_VAR 0 1
87478: ST_TO_ADDR
// break ;
87479: GO 87483
// end ;
87481: GO 87434
87483: POP
87484: POP
// if not side then
87485: LD_VAR 0 3
87489: NOT
87490: IFFALSE 87494
// exit ;
87492: GO 87539
// for i := 1 to tmp do
87494: LD_ADDR_VAR 0 1
87498: PUSH
87499: DOUBLE
87500: LD_INT 1
87502: DEC
87503: ST_TO_ADDR
87504: LD_VAR 0 2
87508: PUSH
87509: FOR_TO
87510: IFFALSE 87537
// if Prob ( 60 ) then
87512: LD_INT 60
87514: PPUSH
87515: CALL_OW 13
87519: IFFALSE 87535
// SetSide ( i , side ) ;
87521: LD_VAR 0 1
87525: PPUSH
87526: LD_VAR 0 3
87530: PPUSH
87531: CALL_OW 235
87535: GO 87509
87537: POP
87538: POP
// end ;
87539: PPOPN 3
87541: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
87542: LD_EXP 109
87546: PUSH
87547: LD_EXP 122
87551: AND
87552: IFFALSE 87671
87554: GO 87556
87556: DISABLE
87557: LD_INT 0
87559: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
87560: LD_ADDR_VAR 0 1
87564: PUSH
87565: LD_INT 22
87567: PUSH
87568: LD_OWVAR 2
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 21
87579: PUSH
87580: LD_INT 1
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 3
87589: PUSH
87590: LD_INT 23
87592: PUSH
87593: LD_INT 0
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: LIST
87608: PPUSH
87609: CALL_OW 69
87613: PUSH
87614: FOR_IN
87615: IFFALSE 87669
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87617: LD_VAR 0 1
87621: PPUSH
87622: CALL_OW 257
87626: PUSH
87627: LD_INT 1
87629: PUSH
87630: LD_INT 2
87632: PUSH
87633: LD_INT 3
87635: PUSH
87636: LD_INT 4
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: IN
87645: IFFALSE 87667
// SetClass ( un , rand ( 1 , 4 ) ) ;
87647: LD_VAR 0 1
87651: PPUSH
87652: LD_INT 1
87654: PPUSH
87655: LD_INT 4
87657: PPUSH
87658: CALL_OW 12
87662: PPUSH
87663: CALL_OW 336
87667: GO 87614
87669: POP
87670: POP
// end ;
87671: PPOPN 1
87673: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87674: LD_EXP 109
87678: PUSH
87679: LD_EXP 121
87683: AND
87684: IFFALSE 87763
87686: GO 87688
87688: DISABLE
87689: LD_INT 0
87691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87692: LD_ADDR_VAR 0 1
87696: PUSH
87697: LD_INT 22
87699: PUSH
87700: LD_OWVAR 2
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 21
87711: PUSH
87712: LD_INT 3
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PPUSH
87723: CALL_OW 69
87727: ST_TO_ADDR
// if not tmp then
87728: LD_VAR 0 1
87732: NOT
87733: IFFALSE 87737
// exit ;
87735: GO 87763
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87737: LD_VAR 0 1
87741: PUSH
87742: LD_INT 1
87744: PPUSH
87745: LD_VAR 0 1
87749: PPUSH
87750: CALL_OW 12
87754: ARRAY
87755: PPUSH
87756: LD_INT 100
87758: PPUSH
87759: CALL_OW 234
// end ;
87763: PPOPN 1
87765: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87766: LD_EXP 109
87770: PUSH
87771: LD_EXP 123
87775: AND
87776: IFFALSE 87874
87778: GO 87780
87780: DISABLE
87781: LD_INT 0
87783: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87784: LD_ADDR_VAR 0 1
87788: PUSH
87789: LD_INT 22
87791: PUSH
87792: LD_OWVAR 2
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 21
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PPUSH
87815: CALL_OW 69
87819: ST_TO_ADDR
// if not tmp then
87820: LD_VAR 0 1
87824: NOT
87825: IFFALSE 87829
// exit ;
87827: GO 87874
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87829: LD_VAR 0 1
87833: PUSH
87834: LD_INT 1
87836: PPUSH
87837: LD_VAR 0 1
87841: PPUSH
87842: CALL_OW 12
87846: ARRAY
87847: PPUSH
87848: LD_INT 1
87850: PPUSH
87851: LD_INT 4
87853: PPUSH
87854: CALL_OW 12
87858: PPUSH
87859: LD_INT 3000
87861: PPUSH
87862: LD_INT 9000
87864: PPUSH
87865: CALL_OW 12
87869: PPUSH
87870: CALL_OW 492
// end ;
87874: PPOPN 1
87876: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87877: LD_EXP 109
87881: PUSH
87882: LD_EXP 124
87886: AND
87887: IFFALSE 87907
87889: GO 87891
87891: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87892: LD_INT 1
87894: PPUSH
87895: LD_OWVAR 2
87899: PPUSH
87900: LD_INT 0
87902: PPUSH
87903: CALL_OW 324
87907: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
87908: LD_EXP 109
87912: PUSH
87913: LD_EXP 125
87917: AND
87918: IFFALSE 88001
87920: GO 87922
87922: DISABLE
87923: LD_INT 0
87925: PPUSH
87926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87927: LD_ADDR_VAR 0 2
87931: PUSH
87932: LD_INT 22
87934: PUSH
87935: LD_OWVAR 2
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 21
87946: PUSH
87947: LD_INT 3
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PPUSH
87958: CALL_OW 69
87962: ST_TO_ADDR
// if not tmp then
87963: LD_VAR 0 2
87967: NOT
87968: IFFALSE 87972
// exit ;
87970: GO 88001
// for i in tmp do
87972: LD_ADDR_VAR 0 1
87976: PUSH
87977: LD_VAR 0 2
87981: PUSH
87982: FOR_IN
87983: IFFALSE 87999
// SetBLevel ( i , 10 ) ;
87985: LD_VAR 0 1
87989: PPUSH
87990: LD_INT 10
87992: PPUSH
87993: CALL_OW 241
87997: GO 87982
87999: POP
88000: POP
// end ;
88001: PPOPN 2
88003: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88004: LD_EXP 109
88008: PUSH
88009: LD_EXP 126
88013: AND
88014: IFFALSE 88125
88016: GO 88018
88018: DISABLE
88019: LD_INT 0
88021: PPUSH
88022: PPUSH
88023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88024: LD_ADDR_VAR 0 3
88028: PUSH
88029: LD_INT 22
88031: PUSH
88032: LD_OWVAR 2
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 25
88043: PUSH
88044: LD_INT 1
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PPUSH
88055: CALL_OW 69
88059: ST_TO_ADDR
// if not tmp then
88060: LD_VAR 0 3
88064: NOT
88065: IFFALSE 88069
// exit ;
88067: GO 88125
// un := tmp [ rand ( 1 , tmp ) ] ;
88069: LD_ADDR_VAR 0 2
88073: PUSH
88074: LD_VAR 0 3
88078: PUSH
88079: LD_INT 1
88081: PPUSH
88082: LD_VAR 0 3
88086: PPUSH
88087: CALL_OW 12
88091: ARRAY
88092: ST_TO_ADDR
// if Crawls ( un ) then
88093: LD_VAR 0 2
88097: PPUSH
88098: CALL_OW 318
88102: IFFALSE 88113
// ComWalk ( un ) ;
88104: LD_VAR 0 2
88108: PPUSH
88109: CALL_OW 138
// SetClass ( un , class_sniper ) ;
88113: LD_VAR 0 2
88117: PPUSH
88118: LD_INT 5
88120: PPUSH
88121: CALL_OW 336
// end ;
88125: PPOPN 3
88127: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
88128: LD_EXP 109
88132: PUSH
88133: LD_EXP 127
88137: AND
88138: PUSH
88139: LD_OWVAR 67
88143: PUSH
88144: LD_INT 3
88146: LESS
88147: AND
88148: IFFALSE 88167
88150: GO 88152
88152: DISABLE
// Difficulty := Difficulty + 1 ;
88153: LD_ADDR_OWVAR 67
88157: PUSH
88158: LD_OWVAR 67
88162: PUSH
88163: LD_INT 1
88165: PLUS
88166: ST_TO_ADDR
88167: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
88168: LD_EXP 109
88172: PUSH
88173: LD_EXP 128
88177: AND
88178: IFFALSE 88281
88180: GO 88182
88182: DISABLE
88183: LD_INT 0
88185: PPUSH
// begin for i := 1 to 5 do
88186: LD_ADDR_VAR 0 1
88190: PUSH
88191: DOUBLE
88192: LD_INT 1
88194: DEC
88195: ST_TO_ADDR
88196: LD_INT 5
88198: PUSH
88199: FOR_TO
88200: IFFALSE 88279
// begin uc_nation := nation_nature ;
88202: LD_ADDR_OWVAR 21
88206: PUSH
88207: LD_INT 0
88209: ST_TO_ADDR
// uc_side := 0 ;
88210: LD_ADDR_OWVAR 20
88214: PUSH
88215: LD_INT 0
88217: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88218: LD_ADDR_OWVAR 29
88222: PUSH
88223: LD_INT 12
88225: PUSH
88226: LD_INT 12
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: ST_TO_ADDR
// hc_agressivity := 20 ;
88233: LD_ADDR_OWVAR 35
88237: PUSH
88238: LD_INT 20
88240: ST_TO_ADDR
// hc_class := class_tiger ;
88241: LD_ADDR_OWVAR 28
88245: PUSH
88246: LD_INT 14
88248: ST_TO_ADDR
// hc_gallery :=  ;
88249: LD_ADDR_OWVAR 33
88253: PUSH
88254: LD_STRING 
88256: ST_TO_ADDR
// hc_name :=  ;
88257: LD_ADDR_OWVAR 26
88261: PUSH
88262: LD_STRING 
88264: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
88265: CALL_OW 44
88269: PPUSH
88270: LD_INT 0
88272: PPUSH
88273: CALL_OW 51
// end ;
88277: GO 88199
88279: POP
88280: POP
// end ;
88281: PPOPN 1
88283: END
// every 0 0$1 trigger StreamModeActive and sBomb do
88284: LD_EXP 109
88288: PUSH
88289: LD_EXP 129
88293: AND
88294: IFFALSE 88303
88296: GO 88298
88298: DISABLE
// StreamSibBomb ;
88299: CALL 88304 0 0
88303: END
// export function StreamSibBomb ; var i , x , y ; begin
88304: LD_INT 0
88306: PPUSH
88307: PPUSH
88308: PPUSH
88309: PPUSH
// result := false ;
88310: LD_ADDR_VAR 0 1
88314: PUSH
88315: LD_INT 0
88317: ST_TO_ADDR
// for i := 1 to 16 do
88318: LD_ADDR_VAR 0 2
88322: PUSH
88323: DOUBLE
88324: LD_INT 1
88326: DEC
88327: ST_TO_ADDR
88328: LD_INT 16
88330: PUSH
88331: FOR_TO
88332: IFFALSE 88531
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88334: LD_ADDR_VAR 0 3
88338: PUSH
88339: LD_INT 10
88341: PUSH
88342: LD_INT 20
88344: PUSH
88345: LD_INT 30
88347: PUSH
88348: LD_INT 40
88350: PUSH
88351: LD_INT 50
88353: PUSH
88354: LD_INT 60
88356: PUSH
88357: LD_INT 70
88359: PUSH
88360: LD_INT 80
88362: PUSH
88363: LD_INT 90
88365: PUSH
88366: LD_INT 100
88368: PUSH
88369: LD_INT 110
88371: PUSH
88372: LD_INT 120
88374: PUSH
88375: LD_INT 130
88377: PUSH
88378: LD_INT 140
88380: PUSH
88381: LD_INT 150
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 1
88403: PPUSH
88404: LD_INT 15
88406: PPUSH
88407: CALL_OW 12
88411: ARRAY
88412: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88413: LD_ADDR_VAR 0 4
88417: PUSH
88418: LD_INT 10
88420: PUSH
88421: LD_INT 20
88423: PUSH
88424: LD_INT 30
88426: PUSH
88427: LD_INT 40
88429: PUSH
88430: LD_INT 50
88432: PUSH
88433: LD_INT 60
88435: PUSH
88436: LD_INT 70
88438: PUSH
88439: LD_INT 80
88441: PUSH
88442: LD_INT 90
88444: PUSH
88445: LD_INT 100
88447: PUSH
88448: LD_INT 110
88450: PUSH
88451: LD_INT 120
88453: PUSH
88454: LD_INT 130
88456: PUSH
88457: LD_INT 140
88459: PUSH
88460: LD_INT 150
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 1
88482: PPUSH
88483: LD_INT 15
88485: PPUSH
88486: CALL_OW 12
88490: ARRAY
88491: ST_TO_ADDR
// if ValidHex ( x , y ) then
88492: LD_VAR 0 3
88496: PPUSH
88497: LD_VAR 0 4
88501: PPUSH
88502: CALL_OW 488
88506: IFFALSE 88529
// begin result := [ x , y ] ;
88508: LD_ADDR_VAR 0 1
88512: PUSH
88513: LD_VAR 0 3
88517: PUSH
88518: LD_VAR 0 4
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: ST_TO_ADDR
// break ;
88527: GO 88531
// end ; end ;
88529: GO 88331
88531: POP
88532: POP
// if result then
88533: LD_VAR 0 1
88537: IFFALSE 88597
// begin ToLua ( playSibBomb() ) ;
88539: LD_STRING playSibBomb()
88541: PPUSH
88542: CALL_OW 559
// wait ( 0 0$14 ) ;
88546: LD_INT 490
88548: PPUSH
88549: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
88553: LD_VAR 0 1
88557: PUSH
88558: LD_INT 1
88560: ARRAY
88561: PPUSH
88562: LD_VAR 0 1
88566: PUSH
88567: LD_INT 2
88569: ARRAY
88570: PPUSH
88571: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
88575: LD_VAR 0 1
88579: PUSH
88580: LD_INT 1
88582: ARRAY
88583: PPUSH
88584: LD_VAR 0 1
88588: PUSH
88589: LD_INT 2
88591: ARRAY
88592: PPUSH
88593: CALL_OW 429
// end ; end ;
88597: LD_VAR 0 1
88601: RET
// every 0 0$1 trigger StreamModeActive and sReset do
88602: LD_EXP 109
88606: PUSH
88607: LD_EXP 131
88611: AND
88612: IFFALSE 88624
88614: GO 88616
88616: DISABLE
// YouLost (  ) ;
88617: LD_STRING 
88619: PPUSH
88620: CALL_OW 104
88624: END
// every 0 0$1 trigger StreamModeActive and sFog do
88625: LD_EXP 109
88629: PUSH
88630: LD_EXP 130
88634: AND
88635: IFFALSE 88649
88637: GO 88639
88639: DISABLE
// FogOff ( your_side ) ;
88640: LD_OWVAR 2
88644: PPUSH
88645: CALL_OW 344
88649: END
// every 0 0$1 trigger StreamModeActive and sSun do
88650: LD_EXP 109
88654: PUSH
88655: LD_EXP 132
88659: AND
88660: IFFALSE 88688
88662: GO 88664
88664: DISABLE
// begin solar_recharge_percent := 0 ;
88665: LD_ADDR_OWVAR 79
88669: PUSH
88670: LD_INT 0
88672: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88673: LD_INT 10500
88675: PPUSH
88676: CALL_OW 67
// solar_recharge_percent := 100 ;
88680: LD_ADDR_OWVAR 79
88684: PUSH
88685: LD_INT 100
88687: ST_TO_ADDR
// end ;
88688: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88689: LD_EXP 109
88693: PUSH
88694: LD_EXP 133
88698: AND
88699: IFFALSE 88938
88701: GO 88703
88703: DISABLE
88704: LD_INT 0
88706: PPUSH
88707: PPUSH
88708: PPUSH
// begin tmp := [ ] ;
88709: LD_ADDR_VAR 0 3
88713: PUSH
88714: EMPTY
88715: ST_TO_ADDR
// for i := 1 to 6 do
88716: LD_ADDR_VAR 0 1
88720: PUSH
88721: DOUBLE
88722: LD_INT 1
88724: DEC
88725: ST_TO_ADDR
88726: LD_INT 6
88728: PUSH
88729: FOR_TO
88730: IFFALSE 88835
// begin uc_nation := nation_nature ;
88732: LD_ADDR_OWVAR 21
88736: PUSH
88737: LD_INT 0
88739: ST_TO_ADDR
// uc_side := 0 ;
88740: LD_ADDR_OWVAR 20
88744: PUSH
88745: LD_INT 0
88747: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88748: LD_ADDR_OWVAR 29
88752: PUSH
88753: LD_INT 12
88755: PUSH
88756: LD_INT 12
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: ST_TO_ADDR
// hc_agressivity := 20 ;
88763: LD_ADDR_OWVAR 35
88767: PUSH
88768: LD_INT 20
88770: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88771: LD_ADDR_OWVAR 28
88775: PUSH
88776: LD_INT 17
88778: ST_TO_ADDR
// hc_gallery :=  ;
88779: LD_ADDR_OWVAR 33
88783: PUSH
88784: LD_STRING 
88786: ST_TO_ADDR
// hc_name :=  ;
88787: LD_ADDR_OWVAR 26
88791: PUSH
88792: LD_STRING 
88794: ST_TO_ADDR
// un := CreateHuman ;
88795: LD_ADDR_VAR 0 2
88799: PUSH
88800: CALL_OW 44
88804: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88805: LD_VAR 0 2
88809: PPUSH
88810: LD_INT 1
88812: PPUSH
88813: CALL_OW 51
// tmp := tmp ^ un ;
88817: LD_ADDR_VAR 0 3
88821: PUSH
88822: LD_VAR 0 3
88826: PUSH
88827: LD_VAR 0 2
88831: ADD
88832: ST_TO_ADDR
// end ;
88833: GO 88729
88835: POP
88836: POP
// repeat wait ( 0 0$1 ) ;
88837: LD_INT 35
88839: PPUSH
88840: CALL_OW 67
// for un in tmp do
88844: LD_ADDR_VAR 0 2
88848: PUSH
88849: LD_VAR 0 3
88853: PUSH
88854: FOR_IN
88855: IFFALSE 88929
// begin if IsDead ( un ) then
88857: LD_VAR 0 2
88861: PPUSH
88862: CALL_OW 301
88866: IFFALSE 88886
// begin tmp := tmp diff un ;
88868: LD_ADDR_VAR 0 3
88872: PUSH
88873: LD_VAR 0 3
88877: PUSH
88878: LD_VAR 0 2
88882: DIFF
88883: ST_TO_ADDR
// continue ;
88884: GO 88854
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88886: LD_VAR 0 2
88890: PPUSH
88891: LD_INT 3
88893: PUSH
88894: LD_INT 22
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PPUSH
88908: CALL_OW 69
88912: PPUSH
88913: LD_VAR 0 2
88917: PPUSH
88918: CALL_OW 74
88922: PPUSH
88923: CALL_OW 115
// end ;
88927: GO 88854
88929: POP
88930: POP
// until not tmp ;
88931: LD_VAR 0 3
88935: NOT
88936: IFFALSE 88837
// end ;
88938: PPOPN 3
88940: END
// every 0 0$1 trigger StreamModeActive and sTroll do
88941: LD_EXP 109
88945: PUSH
88946: LD_EXP 134
88950: AND
88951: IFFALSE 89005
88953: GO 88955
88955: DISABLE
// begin ToLua ( displayTroll(); ) ;
88956: LD_STRING displayTroll();
88958: PPUSH
88959: CALL_OW 559
// wait ( 3 3$00 ) ;
88963: LD_INT 6300
88965: PPUSH
88966: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88970: LD_STRING hideTroll();
88972: PPUSH
88973: CALL_OW 559
// wait ( 1 1$00 ) ;
88977: LD_INT 2100
88979: PPUSH
88980: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88984: LD_STRING displayTroll();
88986: PPUSH
88987: CALL_OW 559
// wait ( 1 1$00 ) ;
88991: LD_INT 2100
88993: PPUSH
88994: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88998: LD_STRING hideTroll();
89000: PPUSH
89001: CALL_OW 559
// end ;
89005: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89006: LD_EXP 109
89010: PUSH
89011: LD_EXP 135
89015: AND
89016: IFFALSE 89079
89018: GO 89020
89020: DISABLE
89021: LD_INT 0
89023: PPUSH
// begin p := 0 ;
89024: LD_ADDR_VAR 0 1
89028: PUSH
89029: LD_INT 0
89031: ST_TO_ADDR
// repeat game_speed := 1 ;
89032: LD_ADDR_OWVAR 65
89036: PUSH
89037: LD_INT 1
89039: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89040: LD_INT 35
89042: PPUSH
89043: CALL_OW 67
// p := p + 1 ;
89047: LD_ADDR_VAR 0 1
89051: PUSH
89052: LD_VAR 0 1
89056: PUSH
89057: LD_INT 1
89059: PLUS
89060: ST_TO_ADDR
// until p >= 60 ;
89061: LD_VAR 0 1
89065: PUSH
89066: LD_INT 60
89068: GREATEREQUAL
89069: IFFALSE 89032
// game_speed := 4 ;
89071: LD_ADDR_OWVAR 65
89075: PUSH
89076: LD_INT 4
89078: ST_TO_ADDR
// end ;
89079: PPOPN 1
89081: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
89082: LD_EXP 109
89086: PUSH
89087: LD_EXP 136
89091: AND
89092: IFFALSE 89238
89094: GO 89096
89096: DISABLE
89097: LD_INT 0
89099: PPUSH
89100: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89101: LD_ADDR_VAR 0 1
89105: PUSH
89106: LD_INT 22
89108: PUSH
89109: LD_OWVAR 2
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 2
89120: PUSH
89121: LD_INT 30
89123: PUSH
89124: LD_INT 0
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 30
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: LIST
89145: PUSH
89146: EMPTY
89147: LIST
89148: LIST
89149: PPUSH
89150: CALL_OW 69
89154: ST_TO_ADDR
// if not depot then
89155: LD_VAR 0 1
89159: NOT
89160: IFFALSE 89164
// exit ;
89162: GO 89238
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
89164: LD_ADDR_VAR 0 2
89168: PUSH
89169: LD_VAR 0 1
89173: PUSH
89174: LD_INT 1
89176: PPUSH
89177: LD_VAR 0 1
89181: PPUSH
89182: CALL_OW 12
89186: ARRAY
89187: PPUSH
89188: CALL_OW 274
89192: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
89193: LD_VAR 0 2
89197: PPUSH
89198: LD_INT 1
89200: PPUSH
89201: LD_INT 0
89203: PPUSH
89204: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
89208: LD_VAR 0 2
89212: PPUSH
89213: LD_INT 2
89215: PPUSH
89216: LD_INT 0
89218: PPUSH
89219: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
89223: LD_VAR 0 2
89227: PPUSH
89228: LD_INT 3
89230: PPUSH
89231: LD_INT 0
89233: PPUSH
89234: CALL_OW 277
// end ;
89238: PPOPN 2
89240: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
89241: LD_EXP 109
89245: PUSH
89246: LD_EXP 137
89250: AND
89251: IFFALSE 89348
89253: GO 89255
89255: DISABLE
89256: LD_INT 0
89258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89259: LD_ADDR_VAR 0 1
89263: PUSH
89264: LD_INT 22
89266: PUSH
89267: LD_OWVAR 2
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 21
89278: PUSH
89279: LD_INT 1
89281: PUSH
89282: EMPTY
89283: LIST
89284: LIST
89285: PUSH
89286: LD_INT 3
89288: PUSH
89289: LD_INT 23
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: LIST
89307: PPUSH
89308: CALL_OW 69
89312: ST_TO_ADDR
// if not tmp then
89313: LD_VAR 0 1
89317: NOT
89318: IFFALSE 89322
// exit ;
89320: GO 89348
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
89322: LD_VAR 0 1
89326: PUSH
89327: LD_INT 1
89329: PPUSH
89330: LD_VAR 0 1
89334: PPUSH
89335: CALL_OW 12
89339: ARRAY
89340: PPUSH
89341: LD_INT 200
89343: PPUSH
89344: CALL_OW 234
// end ;
89348: PPOPN 1
89350: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
89351: LD_EXP 109
89355: PUSH
89356: LD_EXP 138
89360: AND
89361: IFFALSE 89440
89363: GO 89365
89365: DISABLE
89366: LD_INT 0
89368: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
89369: LD_ADDR_VAR 0 1
89373: PUSH
89374: LD_INT 22
89376: PUSH
89377: LD_OWVAR 2
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 21
89388: PUSH
89389: LD_INT 2
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PPUSH
89400: CALL_OW 69
89404: ST_TO_ADDR
// if not tmp then
89405: LD_VAR 0 1
89409: NOT
89410: IFFALSE 89414
// exit ;
89412: GO 89440
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
89414: LD_VAR 0 1
89418: PUSH
89419: LD_INT 1
89421: PPUSH
89422: LD_VAR 0 1
89426: PPUSH
89427: CALL_OW 12
89431: ARRAY
89432: PPUSH
89433: LD_INT 60
89435: PPUSH
89436: CALL_OW 234
// end ;
89440: PPOPN 1
89442: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
89443: LD_EXP 109
89447: PUSH
89448: LD_EXP 139
89452: AND
89453: IFFALSE 89552
89455: GO 89457
89457: DISABLE
89458: LD_INT 0
89460: PPUSH
89461: PPUSH
// begin enable ;
89462: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
89463: LD_ADDR_VAR 0 1
89467: PUSH
89468: LD_INT 22
89470: PUSH
89471: LD_OWVAR 2
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 61
89482: PUSH
89483: EMPTY
89484: LIST
89485: PUSH
89486: LD_INT 33
89488: PUSH
89489: LD_INT 2
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: LIST
89500: PPUSH
89501: CALL_OW 69
89505: ST_TO_ADDR
// if not tmp then
89506: LD_VAR 0 1
89510: NOT
89511: IFFALSE 89515
// exit ;
89513: GO 89552
// for i in tmp do
89515: LD_ADDR_VAR 0 2
89519: PUSH
89520: LD_VAR 0 1
89524: PUSH
89525: FOR_IN
89526: IFFALSE 89550
// if IsControledBy ( i ) then
89528: LD_VAR 0 2
89532: PPUSH
89533: CALL_OW 312
89537: IFFALSE 89548
// ComUnlink ( i ) ;
89539: LD_VAR 0 2
89543: PPUSH
89544: CALL_OW 136
89548: GO 89525
89550: POP
89551: POP
// end ;
89552: PPOPN 2
89554: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
89555: LD_EXP 109
89559: PUSH
89560: LD_EXP 140
89564: AND
89565: IFFALSE 89705
89567: GO 89569
89569: DISABLE
89570: LD_INT 0
89572: PPUSH
89573: PPUSH
// begin ToLua ( displayPowell(); ) ;
89574: LD_STRING displayPowell();
89576: PPUSH
89577: CALL_OW 559
// uc_side := 0 ;
89581: LD_ADDR_OWVAR 20
89585: PUSH
89586: LD_INT 0
89588: ST_TO_ADDR
// uc_nation := 2 ;
89589: LD_ADDR_OWVAR 21
89593: PUSH
89594: LD_INT 2
89596: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
89597: LD_ADDR_OWVAR 37
89601: PUSH
89602: LD_INT 14
89604: ST_TO_ADDR
// vc_engine := engine_siberite ;
89605: LD_ADDR_OWVAR 39
89609: PUSH
89610: LD_INT 3
89612: ST_TO_ADDR
// vc_control := control_apeman ;
89613: LD_ADDR_OWVAR 38
89617: PUSH
89618: LD_INT 5
89620: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89621: LD_ADDR_OWVAR 40
89625: PUSH
89626: LD_INT 29
89628: ST_TO_ADDR
// un := CreateVehicle ;
89629: LD_ADDR_VAR 0 2
89633: PUSH
89634: CALL_OW 45
89638: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89639: LD_VAR 0 2
89643: PPUSH
89644: LD_INT 1
89646: PPUSH
89647: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89651: LD_INT 35
89653: PPUSH
89654: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89658: LD_VAR 0 2
89662: PPUSH
89663: LD_INT 22
89665: PUSH
89666: LD_OWVAR 2
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PPUSH
89675: CALL_OW 69
89679: PPUSH
89680: LD_VAR 0 2
89684: PPUSH
89685: CALL_OW 74
89689: PPUSH
89690: CALL_OW 115
// until IsDead ( un ) ;
89694: LD_VAR 0 2
89698: PPUSH
89699: CALL_OW 301
89703: IFFALSE 89651
// end ;
89705: PPOPN 2
89707: END
// every 0 0$1 trigger StreamModeActive and sStu do
89708: LD_EXP 109
89712: PUSH
89713: LD_EXP 148
89717: AND
89718: IFFALSE 89734
89720: GO 89722
89722: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89723: LD_STRING displayStucuk();
89725: PPUSH
89726: CALL_OW 559
// ResetFog ;
89730: CALL_OW 335
// end ;
89734: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89735: LD_EXP 109
89739: PUSH
89740: LD_EXP 141
89744: AND
89745: IFFALSE 89886
89747: GO 89749
89749: DISABLE
89750: LD_INT 0
89752: PPUSH
89753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89754: LD_ADDR_VAR 0 2
89758: PUSH
89759: LD_INT 22
89761: PUSH
89762: LD_OWVAR 2
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 21
89773: PUSH
89774: LD_INT 1
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PPUSH
89785: CALL_OW 69
89789: ST_TO_ADDR
// if not tmp then
89790: LD_VAR 0 2
89794: NOT
89795: IFFALSE 89799
// exit ;
89797: GO 89886
// un := tmp [ rand ( 1 , tmp ) ] ;
89799: LD_ADDR_VAR 0 1
89803: PUSH
89804: LD_VAR 0 2
89808: PUSH
89809: LD_INT 1
89811: PPUSH
89812: LD_VAR 0 2
89816: PPUSH
89817: CALL_OW 12
89821: ARRAY
89822: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89823: LD_VAR 0 1
89827: PPUSH
89828: LD_INT 0
89830: PPUSH
89831: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89835: LD_VAR 0 1
89839: PPUSH
89840: LD_OWVAR 3
89844: PUSH
89845: LD_VAR 0 1
89849: DIFF
89850: PPUSH
89851: LD_VAR 0 1
89855: PPUSH
89856: CALL_OW 74
89860: PPUSH
89861: CALL_OW 115
// wait ( 0 0$20 ) ;
89865: LD_INT 700
89867: PPUSH
89868: CALL_OW 67
// SetSide ( un , your_side ) ;
89872: LD_VAR 0 1
89876: PPUSH
89877: LD_OWVAR 2
89881: PPUSH
89882: CALL_OW 235
// end ;
89886: PPOPN 2
89888: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89889: LD_EXP 109
89893: PUSH
89894: LD_EXP 142
89898: AND
89899: IFFALSE 90005
89901: GO 89903
89903: DISABLE
89904: LD_INT 0
89906: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89907: LD_ADDR_VAR 0 1
89911: PUSH
89912: LD_INT 22
89914: PUSH
89915: LD_OWVAR 2
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 2
89926: PUSH
89927: LD_INT 30
89929: PUSH
89930: LD_INT 0
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 30
89939: PUSH
89940: LD_INT 1
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: LIST
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PPUSH
89956: CALL_OW 69
89960: ST_TO_ADDR
// if not depot then
89961: LD_VAR 0 1
89965: NOT
89966: IFFALSE 89970
// exit ;
89968: GO 90005
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
89970: LD_VAR 0 1
89974: PUSH
89975: LD_INT 1
89977: ARRAY
89978: PPUSH
89979: CALL_OW 250
89983: PPUSH
89984: LD_VAR 0 1
89988: PUSH
89989: LD_INT 1
89991: ARRAY
89992: PPUSH
89993: CALL_OW 251
89997: PPUSH
89998: LD_INT 70
90000: PPUSH
90001: CALL_OW 495
// end ;
90005: PPOPN 1
90007: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90008: LD_EXP 109
90012: PUSH
90013: LD_EXP 143
90017: AND
90018: IFFALSE 90229
90020: GO 90022
90022: DISABLE
90023: LD_INT 0
90025: PPUSH
90026: PPUSH
90027: PPUSH
90028: PPUSH
90029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90030: LD_ADDR_VAR 0 5
90034: PUSH
90035: LD_INT 22
90037: PUSH
90038: LD_OWVAR 2
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 21
90049: PUSH
90050: LD_INT 1
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PPUSH
90061: CALL_OW 69
90065: ST_TO_ADDR
// if not tmp then
90066: LD_VAR 0 5
90070: NOT
90071: IFFALSE 90075
// exit ;
90073: GO 90229
// for i in tmp do
90075: LD_ADDR_VAR 0 1
90079: PUSH
90080: LD_VAR 0 5
90084: PUSH
90085: FOR_IN
90086: IFFALSE 90227
// begin d := rand ( 0 , 5 ) ;
90088: LD_ADDR_VAR 0 4
90092: PUSH
90093: LD_INT 0
90095: PPUSH
90096: LD_INT 5
90098: PPUSH
90099: CALL_OW 12
90103: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
90104: LD_ADDR_VAR 0 2
90108: PUSH
90109: LD_VAR 0 1
90113: PPUSH
90114: CALL_OW 250
90118: PPUSH
90119: LD_VAR 0 4
90123: PPUSH
90124: LD_INT 3
90126: PPUSH
90127: LD_INT 12
90129: PPUSH
90130: CALL_OW 12
90134: PPUSH
90135: CALL_OW 272
90139: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
90140: LD_ADDR_VAR 0 3
90144: PUSH
90145: LD_VAR 0 1
90149: PPUSH
90150: CALL_OW 251
90154: PPUSH
90155: LD_VAR 0 4
90159: PPUSH
90160: LD_INT 3
90162: PPUSH
90163: LD_INT 12
90165: PPUSH
90166: CALL_OW 12
90170: PPUSH
90171: CALL_OW 273
90175: ST_TO_ADDR
// if ValidHex ( x , y ) then
90176: LD_VAR 0 2
90180: PPUSH
90181: LD_VAR 0 3
90185: PPUSH
90186: CALL_OW 488
90190: IFFALSE 90225
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
90192: LD_VAR 0 1
90196: PPUSH
90197: LD_VAR 0 2
90201: PPUSH
90202: LD_VAR 0 3
90206: PPUSH
90207: LD_INT 3
90209: PPUSH
90210: LD_INT 6
90212: PPUSH
90213: CALL_OW 12
90217: PPUSH
90218: LD_INT 1
90220: PPUSH
90221: CALL_OW 483
// end ;
90225: GO 90085
90227: POP
90228: POP
// end ;
90229: PPOPN 5
90231: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
90232: LD_EXP 109
90236: PUSH
90237: LD_EXP 144
90241: AND
90242: IFFALSE 90336
90244: GO 90246
90246: DISABLE
90247: LD_INT 0
90249: PPUSH
90250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90251: LD_ADDR_VAR 0 2
90255: PUSH
90256: LD_INT 22
90258: PUSH
90259: LD_OWVAR 2
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 32
90270: PUSH
90271: LD_INT 1
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 21
90280: PUSH
90281: LD_INT 2
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: LIST
90292: PPUSH
90293: CALL_OW 69
90297: ST_TO_ADDR
// if not tmp then
90298: LD_VAR 0 2
90302: NOT
90303: IFFALSE 90307
// exit ;
90305: GO 90336
// for i in tmp do
90307: LD_ADDR_VAR 0 1
90311: PUSH
90312: LD_VAR 0 2
90316: PUSH
90317: FOR_IN
90318: IFFALSE 90334
// SetFuel ( i , 0 ) ;
90320: LD_VAR 0 1
90324: PPUSH
90325: LD_INT 0
90327: PPUSH
90328: CALL_OW 240
90332: GO 90317
90334: POP
90335: POP
// end ;
90336: PPOPN 2
90338: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
90339: LD_EXP 109
90343: PUSH
90344: LD_EXP 145
90348: AND
90349: IFFALSE 90415
90351: GO 90353
90353: DISABLE
90354: LD_INT 0
90356: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90357: LD_ADDR_VAR 0 1
90361: PUSH
90362: LD_INT 22
90364: PUSH
90365: LD_OWVAR 2
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 30
90376: PUSH
90377: LD_INT 29
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PPUSH
90388: CALL_OW 69
90392: ST_TO_ADDR
// if not tmp then
90393: LD_VAR 0 1
90397: NOT
90398: IFFALSE 90402
// exit ;
90400: GO 90415
// DestroyUnit ( tmp [ 1 ] ) ;
90402: LD_VAR 0 1
90406: PUSH
90407: LD_INT 1
90409: ARRAY
90410: PPUSH
90411: CALL_OW 65
// end ;
90415: PPOPN 1
90417: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
90418: LD_EXP 109
90422: PUSH
90423: LD_EXP 147
90427: AND
90428: IFFALSE 90557
90430: GO 90432
90432: DISABLE
90433: LD_INT 0
90435: PPUSH
// begin uc_side := 0 ;
90436: LD_ADDR_OWVAR 20
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
// uc_nation := nation_arabian ;
90444: LD_ADDR_OWVAR 21
90448: PUSH
90449: LD_INT 2
90451: ST_TO_ADDR
// hc_gallery :=  ;
90452: LD_ADDR_OWVAR 33
90456: PUSH
90457: LD_STRING 
90459: ST_TO_ADDR
// hc_name :=  ;
90460: LD_ADDR_OWVAR 26
90464: PUSH
90465: LD_STRING 
90467: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
90468: LD_INT 1
90470: PPUSH
90471: LD_INT 11
90473: PPUSH
90474: LD_INT 10
90476: PPUSH
90477: CALL_OW 380
// un := CreateHuman ;
90481: LD_ADDR_VAR 0 1
90485: PUSH
90486: CALL_OW 44
90490: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90491: LD_VAR 0 1
90495: PPUSH
90496: LD_INT 1
90498: PPUSH
90499: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90503: LD_INT 35
90505: PPUSH
90506: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90510: LD_VAR 0 1
90514: PPUSH
90515: LD_INT 22
90517: PUSH
90518: LD_OWVAR 2
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PPUSH
90527: CALL_OW 69
90531: PPUSH
90532: LD_VAR 0 1
90536: PPUSH
90537: CALL_OW 74
90541: PPUSH
90542: CALL_OW 115
// until IsDead ( un ) ;
90546: LD_VAR 0 1
90550: PPUSH
90551: CALL_OW 301
90555: IFFALSE 90503
// end ;
90557: PPOPN 1
90559: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
90560: LD_EXP 109
90564: PUSH
90565: LD_EXP 149
90569: AND
90570: IFFALSE 90582
90572: GO 90574
90574: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
90575: LD_STRING earthquake(getX(game), 0, 32)
90577: PPUSH
90578: CALL_OW 559
90582: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
90583: LD_EXP 109
90587: PUSH
90588: LD_EXP 150
90592: AND
90593: IFFALSE 90684
90595: GO 90597
90597: DISABLE
90598: LD_INT 0
90600: PPUSH
// begin enable ;
90601: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
90602: LD_ADDR_VAR 0 1
90606: PUSH
90607: LD_INT 22
90609: PUSH
90610: LD_OWVAR 2
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 21
90621: PUSH
90622: LD_INT 2
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 33
90631: PUSH
90632: LD_INT 3
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: LIST
90643: PPUSH
90644: CALL_OW 69
90648: ST_TO_ADDR
// if not tmp then
90649: LD_VAR 0 1
90653: NOT
90654: IFFALSE 90658
// exit ;
90656: GO 90684
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90658: LD_VAR 0 1
90662: PUSH
90663: LD_INT 1
90665: PPUSH
90666: LD_VAR 0 1
90670: PPUSH
90671: CALL_OW 12
90675: ARRAY
90676: PPUSH
90677: LD_INT 1
90679: PPUSH
90680: CALL_OW 234
// end ;
90684: PPOPN 1
90686: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90687: LD_EXP 109
90691: PUSH
90692: LD_EXP 151
90696: AND
90697: IFFALSE 90838
90699: GO 90701
90701: DISABLE
90702: LD_INT 0
90704: PPUSH
90705: PPUSH
90706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90707: LD_ADDR_VAR 0 3
90711: PUSH
90712: LD_INT 22
90714: PUSH
90715: LD_OWVAR 2
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 25
90726: PUSH
90727: LD_INT 1
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PPUSH
90738: CALL_OW 69
90742: ST_TO_ADDR
// if not tmp then
90743: LD_VAR 0 3
90747: NOT
90748: IFFALSE 90752
// exit ;
90750: GO 90838
// un := tmp [ rand ( 1 , tmp ) ] ;
90752: LD_ADDR_VAR 0 2
90756: PUSH
90757: LD_VAR 0 3
90761: PUSH
90762: LD_INT 1
90764: PPUSH
90765: LD_VAR 0 3
90769: PPUSH
90770: CALL_OW 12
90774: ARRAY
90775: ST_TO_ADDR
// if Crawls ( un ) then
90776: LD_VAR 0 2
90780: PPUSH
90781: CALL_OW 318
90785: IFFALSE 90796
// ComWalk ( un ) ;
90787: LD_VAR 0 2
90791: PPUSH
90792: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90796: LD_VAR 0 2
90800: PPUSH
90801: LD_INT 9
90803: PPUSH
90804: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90808: LD_INT 28
90810: PPUSH
90811: LD_OWVAR 2
90815: PPUSH
90816: LD_INT 2
90818: PPUSH
90819: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90823: LD_INT 29
90825: PPUSH
90826: LD_OWVAR 2
90830: PPUSH
90831: LD_INT 2
90833: PPUSH
90834: CALL_OW 322
// end ;
90838: PPOPN 3
90840: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90841: LD_EXP 109
90845: PUSH
90846: LD_EXP 152
90850: AND
90851: IFFALSE 90962
90853: GO 90855
90855: DISABLE
90856: LD_INT 0
90858: PPUSH
90859: PPUSH
90860: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90861: LD_ADDR_VAR 0 3
90865: PUSH
90866: LD_INT 22
90868: PUSH
90869: LD_OWVAR 2
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 25
90880: PUSH
90881: LD_INT 1
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PPUSH
90892: CALL_OW 69
90896: ST_TO_ADDR
// if not tmp then
90897: LD_VAR 0 3
90901: NOT
90902: IFFALSE 90906
// exit ;
90904: GO 90962
// un := tmp [ rand ( 1 , tmp ) ] ;
90906: LD_ADDR_VAR 0 2
90910: PUSH
90911: LD_VAR 0 3
90915: PUSH
90916: LD_INT 1
90918: PPUSH
90919: LD_VAR 0 3
90923: PPUSH
90924: CALL_OW 12
90928: ARRAY
90929: ST_TO_ADDR
// if Crawls ( un ) then
90930: LD_VAR 0 2
90934: PPUSH
90935: CALL_OW 318
90939: IFFALSE 90950
// ComWalk ( un ) ;
90941: LD_VAR 0 2
90945: PPUSH
90946: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90950: LD_VAR 0 2
90954: PPUSH
90955: LD_INT 8
90957: PPUSH
90958: CALL_OW 336
// end ;
90962: PPOPN 3
90964: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
90965: LD_EXP 109
90969: PUSH
90970: LD_EXP 153
90974: AND
90975: IFFALSE 91119
90977: GO 90979
90979: DISABLE
90980: LD_INT 0
90982: PPUSH
90983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90984: LD_ADDR_VAR 0 2
90988: PUSH
90989: LD_INT 22
90991: PUSH
90992: LD_OWVAR 2
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 21
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 2
91013: PUSH
91014: LD_INT 34
91016: PUSH
91017: LD_INT 12
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: PUSH
91024: LD_INT 34
91026: PUSH
91027: LD_INT 51
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 34
91036: PUSH
91037: LD_INT 32
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: LIST
91054: PPUSH
91055: CALL_OW 69
91059: ST_TO_ADDR
// if not tmp then
91060: LD_VAR 0 2
91064: NOT
91065: IFFALSE 91069
// exit ;
91067: GO 91119
// for i in tmp do
91069: LD_ADDR_VAR 0 1
91073: PUSH
91074: LD_VAR 0 2
91078: PUSH
91079: FOR_IN
91080: IFFALSE 91117
// if GetCargo ( i , mat_artifact ) = 0 then
91082: LD_VAR 0 1
91086: PPUSH
91087: LD_INT 4
91089: PPUSH
91090: CALL_OW 289
91094: PUSH
91095: LD_INT 0
91097: EQUAL
91098: IFFALSE 91115
// SetCargo ( i , mat_siberit , 100 ) ;
91100: LD_VAR 0 1
91104: PPUSH
91105: LD_INT 3
91107: PPUSH
91108: LD_INT 100
91110: PPUSH
91111: CALL_OW 290
91115: GO 91079
91117: POP
91118: POP
// end ;
91119: PPOPN 2
91121: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
91122: LD_EXP 109
91126: PUSH
91127: LD_EXP 154
91131: AND
91132: IFFALSE 91315
91134: GO 91136
91136: DISABLE
91137: LD_INT 0
91139: PPUSH
91140: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
91141: LD_ADDR_VAR 0 2
91145: PUSH
91146: LD_INT 22
91148: PUSH
91149: LD_OWVAR 2
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PPUSH
91158: CALL_OW 69
91162: ST_TO_ADDR
// if not tmp then
91163: LD_VAR 0 2
91167: NOT
91168: IFFALSE 91172
// exit ;
91170: GO 91315
// for i := 1 to 2 do
91172: LD_ADDR_VAR 0 1
91176: PUSH
91177: DOUBLE
91178: LD_INT 1
91180: DEC
91181: ST_TO_ADDR
91182: LD_INT 2
91184: PUSH
91185: FOR_TO
91186: IFFALSE 91313
// begin uc_side := your_side ;
91188: LD_ADDR_OWVAR 20
91192: PUSH
91193: LD_OWVAR 2
91197: ST_TO_ADDR
// uc_nation := nation_american ;
91198: LD_ADDR_OWVAR 21
91202: PUSH
91203: LD_INT 1
91205: ST_TO_ADDR
// vc_chassis := us_morphling ;
91206: LD_ADDR_OWVAR 37
91210: PUSH
91211: LD_INT 5
91213: ST_TO_ADDR
// vc_engine := engine_siberite ;
91214: LD_ADDR_OWVAR 39
91218: PUSH
91219: LD_INT 3
91221: ST_TO_ADDR
// vc_control := control_computer ;
91222: LD_ADDR_OWVAR 38
91226: PUSH
91227: LD_INT 3
91229: ST_TO_ADDR
// vc_weapon := us_double_laser ;
91230: LD_ADDR_OWVAR 40
91234: PUSH
91235: LD_INT 10
91237: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
91238: LD_VAR 0 2
91242: PUSH
91243: LD_INT 1
91245: ARRAY
91246: PPUSH
91247: CALL_OW 310
91251: NOT
91252: IFFALSE 91299
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91254: CALL_OW 45
91258: PPUSH
91259: LD_VAR 0 2
91263: PUSH
91264: LD_INT 1
91266: ARRAY
91267: PPUSH
91268: CALL_OW 250
91272: PPUSH
91273: LD_VAR 0 2
91277: PUSH
91278: LD_INT 1
91280: ARRAY
91281: PPUSH
91282: CALL_OW 251
91286: PPUSH
91287: LD_INT 12
91289: PPUSH
91290: LD_INT 1
91292: PPUSH
91293: CALL_OW 50
91297: GO 91311
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
91299: CALL_OW 45
91303: PPUSH
91304: LD_INT 1
91306: PPUSH
91307: CALL_OW 51
// end ;
91311: GO 91185
91313: POP
91314: POP
// end ;
91315: PPOPN 2
91317: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
91318: LD_EXP 109
91322: PUSH
91323: LD_EXP 155
91327: AND
91328: IFFALSE 91550
91330: GO 91332
91332: DISABLE
91333: LD_INT 0
91335: PPUSH
91336: PPUSH
91337: PPUSH
91338: PPUSH
91339: PPUSH
91340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91341: LD_ADDR_VAR 0 6
91345: PUSH
91346: LD_INT 22
91348: PUSH
91349: LD_OWVAR 2
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 21
91360: PUSH
91361: LD_INT 1
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 3
91370: PUSH
91371: LD_INT 23
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: EMPTY
91382: LIST
91383: LIST
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: LIST
91389: PPUSH
91390: CALL_OW 69
91394: ST_TO_ADDR
// if not tmp then
91395: LD_VAR 0 6
91399: NOT
91400: IFFALSE 91404
// exit ;
91402: GO 91550
// s1 := rand ( 1 , 4 ) ;
91404: LD_ADDR_VAR 0 2
91408: PUSH
91409: LD_INT 1
91411: PPUSH
91412: LD_INT 4
91414: PPUSH
91415: CALL_OW 12
91419: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
91420: LD_ADDR_VAR 0 4
91424: PUSH
91425: LD_VAR 0 6
91429: PUSH
91430: LD_INT 1
91432: ARRAY
91433: PPUSH
91434: LD_VAR 0 2
91438: PPUSH
91439: CALL_OW 259
91443: ST_TO_ADDR
// if s1 = 1 then
91444: LD_VAR 0 2
91448: PUSH
91449: LD_INT 1
91451: EQUAL
91452: IFFALSE 91472
// s2 := rand ( 2 , 4 ) else
91454: LD_ADDR_VAR 0 3
91458: PUSH
91459: LD_INT 2
91461: PPUSH
91462: LD_INT 4
91464: PPUSH
91465: CALL_OW 12
91469: ST_TO_ADDR
91470: GO 91480
// s2 := 1 ;
91472: LD_ADDR_VAR 0 3
91476: PUSH
91477: LD_INT 1
91479: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
91480: LD_ADDR_VAR 0 5
91484: PUSH
91485: LD_VAR 0 6
91489: PUSH
91490: LD_INT 1
91492: ARRAY
91493: PPUSH
91494: LD_VAR 0 3
91498: PPUSH
91499: CALL_OW 259
91503: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
91504: LD_VAR 0 6
91508: PUSH
91509: LD_INT 1
91511: ARRAY
91512: PPUSH
91513: LD_VAR 0 2
91517: PPUSH
91518: LD_VAR 0 5
91522: PPUSH
91523: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
91527: LD_VAR 0 6
91531: PUSH
91532: LD_INT 1
91534: ARRAY
91535: PPUSH
91536: LD_VAR 0 3
91540: PPUSH
91541: LD_VAR 0 4
91545: PPUSH
91546: CALL_OW 237
// end ;
91550: PPOPN 6
91552: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
91553: LD_EXP 109
91557: PUSH
91558: LD_EXP 156
91562: AND
91563: IFFALSE 91642
91565: GO 91567
91567: DISABLE
91568: LD_INT 0
91570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
91571: LD_ADDR_VAR 0 1
91575: PUSH
91576: LD_INT 22
91578: PUSH
91579: LD_OWVAR 2
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 30
91590: PUSH
91591: LD_INT 3
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: PPUSH
91602: CALL_OW 69
91606: ST_TO_ADDR
// if not tmp then
91607: LD_VAR 0 1
91611: NOT
91612: IFFALSE 91616
// exit ;
91614: GO 91642
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91616: LD_VAR 0 1
91620: PUSH
91621: LD_INT 1
91623: PPUSH
91624: LD_VAR 0 1
91628: PPUSH
91629: CALL_OW 12
91633: ARRAY
91634: PPUSH
91635: LD_INT 1
91637: PPUSH
91638: CALL_OW 234
// end ;
91642: PPOPN 1
91644: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91645: LD_EXP 109
91649: PUSH
91650: LD_EXP 157
91654: AND
91655: IFFALSE 91767
91657: GO 91659
91659: DISABLE
91660: LD_INT 0
91662: PPUSH
91663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91664: LD_ADDR_VAR 0 2
91668: PUSH
91669: LD_INT 22
91671: PUSH
91672: LD_OWVAR 2
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 2
91683: PUSH
91684: LD_INT 30
91686: PUSH
91687: LD_INT 27
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 30
91696: PUSH
91697: LD_INT 26
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 30
91706: PUSH
91707: LD_INT 28
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PPUSH
91724: CALL_OW 69
91728: ST_TO_ADDR
// if not tmp then
91729: LD_VAR 0 2
91733: NOT
91734: IFFALSE 91738
// exit ;
91736: GO 91767
// for i in tmp do
91738: LD_ADDR_VAR 0 1
91742: PUSH
91743: LD_VAR 0 2
91747: PUSH
91748: FOR_IN
91749: IFFALSE 91765
// SetLives ( i , 1 ) ;
91751: LD_VAR 0 1
91755: PPUSH
91756: LD_INT 1
91758: PPUSH
91759: CALL_OW 234
91763: GO 91748
91765: POP
91766: POP
// end ;
91767: PPOPN 2
91769: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91770: LD_EXP 109
91774: PUSH
91775: LD_EXP 158
91779: AND
91780: IFFALSE 92054
91782: GO 91784
91784: DISABLE
91785: LD_INT 0
91787: PPUSH
91788: PPUSH
91789: PPUSH
// begin i := rand ( 1 , 7 ) ;
91790: LD_ADDR_VAR 0 1
91794: PUSH
91795: LD_INT 1
91797: PPUSH
91798: LD_INT 7
91800: PPUSH
91801: CALL_OW 12
91805: ST_TO_ADDR
// case i of 1 :
91806: LD_VAR 0 1
91810: PUSH
91811: LD_INT 1
91813: DOUBLE
91814: EQUAL
91815: IFTRUE 91819
91817: GO 91829
91819: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91820: LD_STRING earthquake(getX(game), 0, 32)
91822: PPUSH
91823: CALL_OW 559
91827: GO 92054
91829: LD_INT 2
91831: DOUBLE
91832: EQUAL
91833: IFTRUE 91837
91835: GO 91851
91837: POP
// begin ToLua ( displayStucuk(); ) ;
91838: LD_STRING displayStucuk();
91840: PPUSH
91841: CALL_OW 559
// ResetFog ;
91845: CALL_OW 335
// end ; 3 :
91849: GO 92054
91851: LD_INT 3
91853: DOUBLE
91854: EQUAL
91855: IFTRUE 91859
91857: GO 91963
91859: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91860: LD_ADDR_VAR 0 2
91864: PUSH
91865: LD_INT 22
91867: PUSH
91868: LD_OWVAR 2
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 25
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PPUSH
91891: CALL_OW 69
91895: ST_TO_ADDR
// if not tmp then
91896: LD_VAR 0 2
91900: NOT
91901: IFFALSE 91905
// exit ;
91903: GO 92054
// un := tmp [ rand ( 1 , tmp ) ] ;
91905: LD_ADDR_VAR 0 3
91909: PUSH
91910: LD_VAR 0 2
91914: PUSH
91915: LD_INT 1
91917: PPUSH
91918: LD_VAR 0 2
91922: PPUSH
91923: CALL_OW 12
91927: ARRAY
91928: ST_TO_ADDR
// if Crawls ( un ) then
91929: LD_VAR 0 3
91933: PPUSH
91934: CALL_OW 318
91938: IFFALSE 91949
// ComWalk ( un ) ;
91940: LD_VAR 0 3
91944: PPUSH
91945: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91949: LD_VAR 0 3
91953: PPUSH
91954: LD_INT 8
91956: PPUSH
91957: CALL_OW 336
// end ; 4 :
91961: GO 92054
91963: LD_INT 4
91965: DOUBLE
91966: EQUAL
91967: IFTRUE 91971
91969: GO 92032
91971: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91972: LD_ADDR_VAR 0 2
91976: PUSH
91977: LD_INT 22
91979: PUSH
91980: LD_OWVAR 2
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 30
91991: PUSH
91992: LD_INT 29
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PPUSH
92003: CALL_OW 69
92007: ST_TO_ADDR
// if not tmp then
92008: LD_VAR 0 2
92012: NOT
92013: IFFALSE 92017
// exit ;
92015: GO 92054
// DestroyUnit ( tmp [ 1 ] ) ;
92017: LD_VAR 0 2
92021: PUSH
92022: LD_INT 1
92024: ARRAY
92025: PPUSH
92026: CALL_OW 65
// end ; 5 .. 7 :
92030: GO 92054
92032: LD_INT 5
92034: DOUBLE
92035: GREATEREQUAL
92036: IFFALSE 92044
92038: LD_INT 7
92040: DOUBLE
92041: LESSEQUAL
92042: IFTRUE 92046
92044: GO 92053
92046: POP
// StreamSibBomb ; end ;
92047: CALL 88304 0 0
92051: GO 92054
92053: POP
// end ;
92054: PPOPN 3
92056: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92057: LD_EXP 109
92061: PUSH
92062: LD_EXP 159
92066: AND
92067: IFFALSE 92223
92069: GO 92071
92071: DISABLE
92072: LD_INT 0
92074: PPUSH
92075: PPUSH
92076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
92077: LD_ADDR_VAR 0 2
92081: PUSH
92082: LD_INT 81
92084: PUSH
92085: LD_OWVAR 2
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 2
92096: PUSH
92097: LD_INT 21
92099: PUSH
92100: LD_INT 1
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 21
92109: PUSH
92110: LD_INT 2
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: LIST
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PPUSH
92126: CALL_OW 69
92130: ST_TO_ADDR
// if not tmp then
92131: LD_VAR 0 2
92135: NOT
92136: IFFALSE 92140
// exit ;
92138: GO 92223
// p := 0 ;
92140: LD_ADDR_VAR 0 3
92144: PUSH
92145: LD_INT 0
92147: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92148: LD_INT 35
92150: PPUSH
92151: CALL_OW 67
// p := p + 1 ;
92155: LD_ADDR_VAR 0 3
92159: PUSH
92160: LD_VAR 0 3
92164: PUSH
92165: LD_INT 1
92167: PLUS
92168: ST_TO_ADDR
// for i in tmp do
92169: LD_ADDR_VAR 0 1
92173: PUSH
92174: LD_VAR 0 2
92178: PUSH
92179: FOR_IN
92180: IFFALSE 92211
// if GetLives ( i ) < 1000 then
92182: LD_VAR 0 1
92186: PPUSH
92187: CALL_OW 256
92191: PUSH
92192: LD_INT 1000
92194: LESS
92195: IFFALSE 92209
// SetLives ( i , 1000 ) ;
92197: LD_VAR 0 1
92201: PPUSH
92202: LD_INT 1000
92204: PPUSH
92205: CALL_OW 234
92209: GO 92179
92211: POP
92212: POP
// until p > 20 ;
92213: LD_VAR 0 3
92217: PUSH
92218: LD_INT 20
92220: GREATER
92221: IFFALSE 92148
// end ;
92223: PPOPN 3
92225: END
// every 0 0$1 trigger StreamModeActive and sTime do
92226: LD_EXP 109
92230: PUSH
92231: LD_EXP 160
92235: AND
92236: IFFALSE 92271
92238: GO 92240
92240: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
92241: LD_INT 28
92243: PPUSH
92244: LD_OWVAR 2
92248: PPUSH
92249: LD_INT 2
92251: PPUSH
92252: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92256: LD_INT 30
92258: PPUSH
92259: LD_OWVAR 2
92263: PPUSH
92264: LD_INT 2
92266: PPUSH
92267: CALL_OW 322
// end ;
92271: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
92272: LD_EXP 109
92276: PUSH
92277: LD_EXP 161
92281: AND
92282: IFFALSE 92403
92284: GO 92286
92286: DISABLE
92287: LD_INT 0
92289: PPUSH
92290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92291: LD_ADDR_VAR 0 2
92295: PUSH
92296: LD_INT 22
92298: PUSH
92299: LD_OWVAR 2
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 21
92310: PUSH
92311: LD_INT 1
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 3
92320: PUSH
92321: LD_INT 23
92323: PUSH
92324: LD_INT 0
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: LIST
92339: PPUSH
92340: CALL_OW 69
92344: ST_TO_ADDR
// if not tmp then
92345: LD_VAR 0 2
92349: NOT
92350: IFFALSE 92354
// exit ;
92352: GO 92403
// for i in tmp do
92354: LD_ADDR_VAR 0 1
92358: PUSH
92359: LD_VAR 0 2
92363: PUSH
92364: FOR_IN
92365: IFFALSE 92401
// begin if Crawls ( i ) then
92367: LD_VAR 0 1
92371: PPUSH
92372: CALL_OW 318
92376: IFFALSE 92387
// ComWalk ( i ) ;
92378: LD_VAR 0 1
92382: PPUSH
92383: CALL_OW 138
// SetClass ( i , 2 ) ;
92387: LD_VAR 0 1
92391: PPUSH
92392: LD_INT 2
92394: PPUSH
92395: CALL_OW 336
// end ;
92399: GO 92364
92401: POP
92402: POP
// end ;
92403: PPOPN 2
92405: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
92406: LD_EXP 109
92410: PUSH
92411: LD_EXP 162
92415: AND
92416: IFFALSE 92697
92418: GO 92420
92420: DISABLE
92421: LD_INT 0
92423: PPUSH
92424: PPUSH
92425: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
92426: LD_OWVAR 2
92430: PPUSH
92431: LD_INT 9
92433: PPUSH
92434: LD_INT 1
92436: PPUSH
92437: LD_INT 1
92439: PPUSH
92440: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
92444: LD_INT 9
92446: PPUSH
92447: LD_OWVAR 2
92451: PPUSH
92452: CALL_OW 343
// uc_side := 9 ;
92456: LD_ADDR_OWVAR 20
92460: PUSH
92461: LD_INT 9
92463: ST_TO_ADDR
// uc_nation := 2 ;
92464: LD_ADDR_OWVAR 21
92468: PUSH
92469: LD_INT 2
92471: ST_TO_ADDR
// hc_name := Dark Warrior ;
92472: LD_ADDR_OWVAR 26
92476: PUSH
92477: LD_STRING Dark Warrior
92479: ST_TO_ADDR
// hc_gallery :=  ;
92480: LD_ADDR_OWVAR 33
92484: PUSH
92485: LD_STRING 
92487: ST_TO_ADDR
// hc_noskilllimit := true ;
92488: LD_ADDR_OWVAR 76
92492: PUSH
92493: LD_INT 1
92495: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
92496: LD_ADDR_OWVAR 31
92500: PUSH
92501: LD_INT 30
92503: PUSH
92504: LD_INT 30
92506: PUSH
92507: LD_INT 30
92509: PUSH
92510: LD_INT 30
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: ST_TO_ADDR
// un := CreateHuman ;
92519: LD_ADDR_VAR 0 3
92523: PUSH
92524: CALL_OW 44
92528: ST_TO_ADDR
// hc_noskilllimit := false ;
92529: LD_ADDR_OWVAR 76
92533: PUSH
92534: LD_INT 0
92536: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92537: LD_VAR 0 3
92541: PPUSH
92542: LD_INT 1
92544: PPUSH
92545: CALL_OW 51
// p := 0 ;
92549: LD_ADDR_VAR 0 2
92553: PUSH
92554: LD_INT 0
92556: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92557: LD_INT 35
92559: PPUSH
92560: CALL_OW 67
// p := p + 1 ;
92564: LD_ADDR_VAR 0 2
92568: PUSH
92569: LD_VAR 0 2
92573: PUSH
92574: LD_INT 1
92576: PLUS
92577: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
92578: LD_VAR 0 3
92582: PPUSH
92583: CALL_OW 256
92587: PUSH
92588: LD_INT 1000
92590: LESS
92591: IFFALSE 92605
// SetLives ( un , 1000 ) ;
92593: LD_VAR 0 3
92597: PPUSH
92598: LD_INT 1000
92600: PPUSH
92601: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
92605: LD_VAR 0 3
92609: PPUSH
92610: LD_INT 81
92612: PUSH
92613: LD_OWVAR 2
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 91
92624: PUSH
92625: LD_VAR 0 3
92629: PUSH
92630: LD_INT 30
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: LIST
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PPUSH
92642: CALL_OW 69
92646: PPUSH
92647: LD_VAR 0 3
92651: PPUSH
92652: CALL_OW 74
92656: PPUSH
92657: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92661: LD_VAR 0 2
92665: PUSH
92666: LD_INT 60
92668: GREATER
92669: PUSH
92670: LD_VAR 0 3
92674: PPUSH
92675: CALL_OW 301
92679: OR
92680: IFFALSE 92557
// if un then
92682: LD_VAR 0 3
92686: IFFALSE 92697
// RemoveUnit ( un ) ;
92688: LD_VAR 0 3
92692: PPUSH
92693: CALL_OW 64
// end ;
92697: PPOPN 3
92699: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92700: LD_INT 0
92702: PPUSH
// case cmd of 301 :
92703: LD_VAR 0 1
92707: PUSH
92708: LD_INT 301
92710: DOUBLE
92711: EQUAL
92712: IFTRUE 92716
92714: GO 92748
92716: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92717: LD_VAR 0 6
92721: PPUSH
92722: LD_VAR 0 7
92726: PPUSH
92727: LD_VAR 0 8
92731: PPUSH
92732: LD_VAR 0 4
92736: PPUSH
92737: LD_VAR 0 5
92741: PPUSH
92742: CALL 93949 0 5
92746: GO 92869
92748: LD_INT 302
92750: DOUBLE
92751: EQUAL
92752: IFTRUE 92756
92754: GO 92793
92756: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92757: LD_VAR 0 6
92761: PPUSH
92762: LD_VAR 0 7
92766: PPUSH
92767: LD_VAR 0 8
92771: PPUSH
92772: LD_VAR 0 9
92776: PPUSH
92777: LD_VAR 0 4
92781: PPUSH
92782: LD_VAR 0 5
92786: PPUSH
92787: CALL 94040 0 6
92791: GO 92869
92793: LD_INT 303
92795: DOUBLE
92796: EQUAL
92797: IFTRUE 92801
92799: GO 92838
92801: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92802: LD_VAR 0 6
92806: PPUSH
92807: LD_VAR 0 7
92811: PPUSH
92812: LD_VAR 0 8
92816: PPUSH
92817: LD_VAR 0 9
92821: PPUSH
92822: LD_VAR 0 4
92826: PPUSH
92827: LD_VAR 0 5
92831: PPUSH
92832: CALL 92874 0 6
92836: GO 92869
92838: LD_INT 304
92840: DOUBLE
92841: EQUAL
92842: IFTRUE 92846
92844: GO 92868
92846: POP
// hHackTeleport ( unit , x , y ) ; end ;
92847: LD_VAR 0 2
92851: PPUSH
92852: LD_VAR 0 4
92856: PPUSH
92857: LD_VAR 0 5
92861: PPUSH
92862: CALL 94633 0 3
92866: GO 92869
92868: POP
// end ;
92869: LD_VAR 0 12
92873: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
92874: LD_INT 0
92876: PPUSH
92877: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
92878: LD_VAR 0 1
92882: PUSH
92883: LD_INT 1
92885: LESS
92886: PUSH
92887: LD_VAR 0 1
92891: PUSH
92892: LD_INT 3
92894: GREATER
92895: OR
92896: PUSH
92897: LD_VAR 0 5
92901: PPUSH
92902: LD_VAR 0 6
92906: PPUSH
92907: CALL_OW 428
92911: OR
92912: IFFALSE 92916
// exit ;
92914: GO 93636
// uc_side := your_side ;
92916: LD_ADDR_OWVAR 20
92920: PUSH
92921: LD_OWVAR 2
92925: ST_TO_ADDR
// uc_nation := nation ;
92926: LD_ADDR_OWVAR 21
92930: PUSH
92931: LD_VAR 0 1
92935: ST_TO_ADDR
// bc_level = 1 ;
92936: LD_ADDR_OWVAR 43
92940: PUSH
92941: LD_INT 1
92943: ST_TO_ADDR
// case btype of 1 :
92944: LD_VAR 0 2
92948: PUSH
92949: LD_INT 1
92951: DOUBLE
92952: EQUAL
92953: IFTRUE 92957
92955: GO 92968
92957: POP
// bc_type := b_depot ; 2 :
92958: LD_ADDR_OWVAR 42
92962: PUSH
92963: LD_INT 0
92965: ST_TO_ADDR
92966: GO 93580
92968: LD_INT 2
92970: DOUBLE
92971: EQUAL
92972: IFTRUE 92976
92974: GO 92987
92976: POP
// bc_type := b_warehouse ; 3 :
92977: LD_ADDR_OWVAR 42
92981: PUSH
92982: LD_INT 1
92984: ST_TO_ADDR
92985: GO 93580
92987: LD_INT 3
92989: DOUBLE
92990: EQUAL
92991: IFTRUE 92995
92993: GO 93006
92995: POP
// bc_type := b_lab ; 4 .. 9 :
92996: LD_ADDR_OWVAR 42
93000: PUSH
93001: LD_INT 6
93003: ST_TO_ADDR
93004: GO 93580
93006: LD_INT 4
93008: DOUBLE
93009: GREATEREQUAL
93010: IFFALSE 93018
93012: LD_INT 9
93014: DOUBLE
93015: LESSEQUAL
93016: IFTRUE 93020
93018: GO 93072
93020: POP
// begin bc_type := b_lab_half ;
93021: LD_ADDR_OWVAR 42
93025: PUSH
93026: LD_INT 7
93028: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93029: LD_ADDR_OWVAR 44
93033: PUSH
93034: LD_INT 10
93036: PUSH
93037: LD_INT 11
93039: PUSH
93040: LD_INT 12
93042: PUSH
93043: LD_INT 15
93045: PUSH
93046: LD_INT 14
93048: PUSH
93049: LD_INT 13
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: LIST
93056: LIST
93057: LIST
93058: LIST
93059: PUSH
93060: LD_VAR 0 2
93064: PUSH
93065: LD_INT 3
93067: MINUS
93068: ARRAY
93069: ST_TO_ADDR
// end ; 10 .. 13 :
93070: GO 93580
93072: LD_INT 10
93074: DOUBLE
93075: GREATEREQUAL
93076: IFFALSE 93084
93078: LD_INT 13
93080: DOUBLE
93081: LESSEQUAL
93082: IFTRUE 93086
93084: GO 93163
93086: POP
// begin bc_type := b_lab_full ;
93087: LD_ADDR_OWVAR 42
93091: PUSH
93092: LD_INT 8
93094: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
93095: LD_ADDR_OWVAR 44
93099: PUSH
93100: LD_INT 10
93102: PUSH
93103: LD_INT 12
93105: PUSH
93106: LD_INT 14
93108: PUSH
93109: LD_INT 13
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: PUSH
93118: LD_VAR 0 2
93122: PUSH
93123: LD_INT 9
93125: MINUS
93126: ARRAY
93127: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
93128: LD_ADDR_OWVAR 45
93132: PUSH
93133: LD_INT 11
93135: PUSH
93136: LD_INT 15
93138: PUSH
93139: LD_INT 12
93141: PUSH
93142: LD_INT 15
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: PUSH
93151: LD_VAR 0 2
93155: PUSH
93156: LD_INT 9
93158: MINUS
93159: ARRAY
93160: ST_TO_ADDR
// end ; 14 :
93161: GO 93580
93163: LD_INT 14
93165: DOUBLE
93166: EQUAL
93167: IFTRUE 93171
93169: GO 93182
93171: POP
// bc_type := b_workshop ; 15 :
93172: LD_ADDR_OWVAR 42
93176: PUSH
93177: LD_INT 2
93179: ST_TO_ADDR
93180: GO 93580
93182: LD_INT 15
93184: DOUBLE
93185: EQUAL
93186: IFTRUE 93190
93188: GO 93201
93190: POP
// bc_type := b_factory ; 16 :
93191: LD_ADDR_OWVAR 42
93195: PUSH
93196: LD_INT 3
93198: ST_TO_ADDR
93199: GO 93580
93201: LD_INT 16
93203: DOUBLE
93204: EQUAL
93205: IFTRUE 93209
93207: GO 93220
93209: POP
// bc_type := b_ext_gun ; 17 :
93210: LD_ADDR_OWVAR 42
93214: PUSH
93215: LD_INT 17
93217: ST_TO_ADDR
93218: GO 93580
93220: LD_INT 17
93222: DOUBLE
93223: EQUAL
93224: IFTRUE 93228
93226: GO 93256
93228: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
93229: LD_ADDR_OWVAR 42
93233: PUSH
93234: LD_INT 19
93236: PUSH
93237: LD_INT 23
93239: PUSH
93240: LD_INT 19
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: LIST
93247: PUSH
93248: LD_VAR 0 1
93252: ARRAY
93253: ST_TO_ADDR
93254: GO 93580
93256: LD_INT 18
93258: DOUBLE
93259: EQUAL
93260: IFTRUE 93264
93262: GO 93275
93264: POP
// bc_type := b_ext_radar ; 19 :
93265: LD_ADDR_OWVAR 42
93269: PUSH
93270: LD_INT 20
93272: ST_TO_ADDR
93273: GO 93580
93275: LD_INT 19
93277: DOUBLE
93278: EQUAL
93279: IFTRUE 93283
93281: GO 93294
93283: POP
// bc_type := b_ext_radio ; 20 :
93284: LD_ADDR_OWVAR 42
93288: PUSH
93289: LD_INT 22
93291: ST_TO_ADDR
93292: GO 93580
93294: LD_INT 20
93296: DOUBLE
93297: EQUAL
93298: IFTRUE 93302
93300: GO 93313
93302: POP
// bc_type := b_ext_siberium ; 21 :
93303: LD_ADDR_OWVAR 42
93307: PUSH
93308: LD_INT 21
93310: ST_TO_ADDR
93311: GO 93580
93313: LD_INT 21
93315: DOUBLE
93316: EQUAL
93317: IFTRUE 93321
93319: GO 93332
93321: POP
// bc_type := b_ext_computer ; 22 :
93322: LD_ADDR_OWVAR 42
93326: PUSH
93327: LD_INT 24
93329: ST_TO_ADDR
93330: GO 93580
93332: LD_INT 22
93334: DOUBLE
93335: EQUAL
93336: IFTRUE 93340
93338: GO 93351
93340: POP
// bc_type := b_ext_track ; 23 :
93341: LD_ADDR_OWVAR 42
93345: PUSH
93346: LD_INT 16
93348: ST_TO_ADDR
93349: GO 93580
93351: LD_INT 23
93353: DOUBLE
93354: EQUAL
93355: IFTRUE 93359
93357: GO 93370
93359: POP
// bc_type := b_ext_laser ; 24 :
93360: LD_ADDR_OWVAR 42
93364: PUSH
93365: LD_INT 25
93367: ST_TO_ADDR
93368: GO 93580
93370: LD_INT 24
93372: DOUBLE
93373: EQUAL
93374: IFTRUE 93378
93376: GO 93389
93378: POP
// bc_type := b_control_tower ; 25 :
93379: LD_ADDR_OWVAR 42
93383: PUSH
93384: LD_INT 36
93386: ST_TO_ADDR
93387: GO 93580
93389: LD_INT 25
93391: DOUBLE
93392: EQUAL
93393: IFTRUE 93397
93395: GO 93408
93397: POP
// bc_type := b_breastwork ; 26 :
93398: LD_ADDR_OWVAR 42
93402: PUSH
93403: LD_INT 31
93405: ST_TO_ADDR
93406: GO 93580
93408: LD_INT 26
93410: DOUBLE
93411: EQUAL
93412: IFTRUE 93416
93414: GO 93427
93416: POP
// bc_type := b_bunker ; 27 :
93417: LD_ADDR_OWVAR 42
93421: PUSH
93422: LD_INT 32
93424: ST_TO_ADDR
93425: GO 93580
93427: LD_INT 27
93429: DOUBLE
93430: EQUAL
93431: IFTRUE 93435
93433: GO 93446
93435: POP
// bc_type := b_turret ; 28 :
93436: LD_ADDR_OWVAR 42
93440: PUSH
93441: LD_INT 33
93443: ST_TO_ADDR
93444: GO 93580
93446: LD_INT 28
93448: DOUBLE
93449: EQUAL
93450: IFTRUE 93454
93452: GO 93465
93454: POP
// bc_type := b_armoury ; 29 :
93455: LD_ADDR_OWVAR 42
93459: PUSH
93460: LD_INT 4
93462: ST_TO_ADDR
93463: GO 93580
93465: LD_INT 29
93467: DOUBLE
93468: EQUAL
93469: IFTRUE 93473
93471: GO 93484
93473: POP
// bc_type := b_barracks ; 30 :
93474: LD_ADDR_OWVAR 42
93478: PUSH
93479: LD_INT 5
93481: ST_TO_ADDR
93482: GO 93580
93484: LD_INT 30
93486: DOUBLE
93487: EQUAL
93488: IFTRUE 93492
93490: GO 93503
93492: POP
// bc_type := b_solar_power ; 31 :
93493: LD_ADDR_OWVAR 42
93497: PUSH
93498: LD_INT 27
93500: ST_TO_ADDR
93501: GO 93580
93503: LD_INT 31
93505: DOUBLE
93506: EQUAL
93507: IFTRUE 93511
93509: GO 93522
93511: POP
// bc_type := b_oil_power ; 32 :
93512: LD_ADDR_OWVAR 42
93516: PUSH
93517: LD_INT 26
93519: ST_TO_ADDR
93520: GO 93580
93522: LD_INT 32
93524: DOUBLE
93525: EQUAL
93526: IFTRUE 93530
93528: GO 93541
93530: POP
// bc_type := b_siberite_power ; 33 :
93531: LD_ADDR_OWVAR 42
93535: PUSH
93536: LD_INT 28
93538: ST_TO_ADDR
93539: GO 93580
93541: LD_INT 33
93543: DOUBLE
93544: EQUAL
93545: IFTRUE 93549
93547: GO 93560
93549: POP
// bc_type := b_oil_mine ; 34 :
93550: LD_ADDR_OWVAR 42
93554: PUSH
93555: LD_INT 29
93557: ST_TO_ADDR
93558: GO 93580
93560: LD_INT 34
93562: DOUBLE
93563: EQUAL
93564: IFTRUE 93568
93566: GO 93579
93568: POP
// bc_type := b_siberite_mine ; end ;
93569: LD_ADDR_OWVAR 42
93573: PUSH
93574: LD_INT 30
93576: ST_TO_ADDR
93577: GO 93580
93579: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
93580: LD_ADDR_VAR 0 8
93584: PUSH
93585: LD_VAR 0 5
93589: PPUSH
93590: LD_VAR 0 6
93594: PPUSH
93595: LD_VAR 0 3
93599: PPUSH
93600: CALL_OW 47
93604: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
93605: LD_OWVAR 42
93609: PUSH
93610: LD_INT 32
93612: PUSH
93613: LD_INT 33
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: IN
93620: IFFALSE 93636
// PlaceWeaponTurret ( b , weapon ) ;
93622: LD_VAR 0 8
93626: PPUSH
93627: LD_VAR 0 4
93631: PPUSH
93632: CALL_OW 431
// end ;
93636: LD_VAR 0 7
93640: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93641: LD_INT 0
93643: PPUSH
93644: PPUSH
93645: PPUSH
93646: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93647: LD_ADDR_VAR 0 4
93651: PUSH
93652: LD_INT 22
93654: PUSH
93655: LD_OWVAR 2
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 2
93666: PUSH
93667: LD_INT 30
93669: PUSH
93670: LD_INT 0
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 30
93679: PUSH
93680: LD_INT 1
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: LIST
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PPUSH
93696: CALL_OW 69
93700: ST_TO_ADDR
// if not tmp then
93701: LD_VAR 0 4
93705: NOT
93706: IFFALSE 93710
// exit ;
93708: GO 93769
// for i in tmp do
93710: LD_ADDR_VAR 0 2
93714: PUSH
93715: LD_VAR 0 4
93719: PUSH
93720: FOR_IN
93721: IFFALSE 93767
// for j = 1 to 3 do
93723: LD_ADDR_VAR 0 3
93727: PUSH
93728: DOUBLE
93729: LD_INT 1
93731: DEC
93732: ST_TO_ADDR
93733: LD_INT 3
93735: PUSH
93736: FOR_TO
93737: IFFALSE 93763
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93739: LD_VAR 0 2
93743: PPUSH
93744: CALL_OW 274
93748: PPUSH
93749: LD_VAR 0 3
93753: PPUSH
93754: LD_INT 99999
93756: PPUSH
93757: CALL_OW 277
93761: GO 93736
93763: POP
93764: POP
93765: GO 93720
93767: POP
93768: POP
// end ;
93769: LD_VAR 0 1
93773: RET
// export function hHackSetLevel10 ; var i , j ; begin
93774: LD_INT 0
93776: PPUSH
93777: PPUSH
93778: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93779: LD_ADDR_VAR 0 2
93783: PUSH
93784: LD_INT 21
93786: PUSH
93787: LD_INT 1
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PPUSH
93794: CALL_OW 69
93798: PUSH
93799: FOR_IN
93800: IFFALSE 93852
// if IsSelected ( i ) then
93802: LD_VAR 0 2
93806: PPUSH
93807: CALL_OW 306
93811: IFFALSE 93850
// begin for j := 1 to 4 do
93813: LD_ADDR_VAR 0 3
93817: PUSH
93818: DOUBLE
93819: LD_INT 1
93821: DEC
93822: ST_TO_ADDR
93823: LD_INT 4
93825: PUSH
93826: FOR_TO
93827: IFFALSE 93848
// SetSkill ( i , j , 10 ) ;
93829: LD_VAR 0 2
93833: PPUSH
93834: LD_VAR 0 3
93838: PPUSH
93839: LD_INT 10
93841: PPUSH
93842: CALL_OW 237
93846: GO 93826
93848: POP
93849: POP
// end ;
93850: GO 93799
93852: POP
93853: POP
// end ;
93854: LD_VAR 0 1
93858: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
93859: LD_INT 0
93861: PPUSH
93862: PPUSH
93863: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
93864: LD_ADDR_VAR 0 2
93868: PUSH
93869: LD_INT 22
93871: PUSH
93872: LD_OWVAR 2
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 21
93883: PUSH
93884: LD_INT 1
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PPUSH
93895: CALL_OW 69
93899: PUSH
93900: FOR_IN
93901: IFFALSE 93942
// begin for j := 1 to 4 do
93903: LD_ADDR_VAR 0 3
93907: PUSH
93908: DOUBLE
93909: LD_INT 1
93911: DEC
93912: ST_TO_ADDR
93913: LD_INT 4
93915: PUSH
93916: FOR_TO
93917: IFFALSE 93938
// SetSkill ( i , j , 10 ) ;
93919: LD_VAR 0 2
93923: PPUSH
93924: LD_VAR 0 3
93928: PPUSH
93929: LD_INT 10
93931: PPUSH
93932: CALL_OW 237
93936: GO 93916
93938: POP
93939: POP
// end ;
93940: GO 93900
93942: POP
93943: POP
// end ;
93944: LD_VAR 0 1
93948: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
93949: LD_INT 0
93951: PPUSH
// uc_side := your_side ;
93952: LD_ADDR_OWVAR 20
93956: PUSH
93957: LD_OWVAR 2
93961: ST_TO_ADDR
// uc_nation := nation ;
93962: LD_ADDR_OWVAR 21
93966: PUSH
93967: LD_VAR 0 1
93971: ST_TO_ADDR
// InitHc ;
93972: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
93976: LD_INT 0
93978: PPUSH
93979: LD_VAR 0 2
93983: PPUSH
93984: LD_VAR 0 3
93988: PPUSH
93989: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
93993: LD_VAR 0 4
93997: PPUSH
93998: LD_VAR 0 5
94002: PPUSH
94003: CALL_OW 428
94007: PUSH
94008: LD_INT 0
94010: EQUAL
94011: IFFALSE 94035
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94013: CALL_OW 44
94017: PPUSH
94018: LD_VAR 0 4
94022: PPUSH
94023: LD_VAR 0 5
94027: PPUSH
94028: LD_INT 1
94030: PPUSH
94031: CALL_OW 48
// end ;
94035: LD_VAR 0 6
94039: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94040: LD_INT 0
94042: PPUSH
94043: PPUSH
// uc_side := your_side ;
94044: LD_ADDR_OWVAR 20
94048: PUSH
94049: LD_OWVAR 2
94053: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94054: LD_VAR 0 1
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: LD_INT 2
94064: PUSH
94065: LD_INT 3
94067: PUSH
94068: LD_INT 4
94070: PUSH
94071: LD_INT 5
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: IN
94081: IFFALSE 94093
// uc_nation := nation_american else
94083: LD_ADDR_OWVAR 21
94087: PUSH
94088: LD_INT 1
94090: ST_TO_ADDR
94091: GO 94136
// if chassis in [ 11 , 12 , 13 , 14 ] then
94093: LD_VAR 0 1
94097: PUSH
94098: LD_INT 11
94100: PUSH
94101: LD_INT 12
94103: PUSH
94104: LD_INT 13
94106: PUSH
94107: LD_INT 14
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: IN
94116: IFFALSE 94128
// uc_nation := nation_arabian else
94118: LD_ADDR_OWVAR 21
94122: PUSH
94123: LD_INT 2
94125: ST_TO_ADDR
94126: GO 94136
// uc_nation := nation_russian ;
94128: LD_ADDR_OWVAR 21
94132: PUSH
94133: LD_INT 3
94135: ST_TO_ADDR
// vc_chassis := chassis ;
94136: LD_ADDR_OWVAR 37
94140: PUSH
94141: LD_VAR 0 1
94145: ST_TO_ADDR
// vc_engine := engine ;
94146: LD_ADDR_OWVAR 39
94150: PUSH
94151: LD_VAR 0 2
94155: ST_TO_ADDR
// vc_control := control ;
94156: LD_ADDR_OWVAR 38
94160: PUSH
94161: LD_VAR 0 3
94165: ST_TO_ADDR
// vc_weapon := weapon ;
94166: LD_ADDR_OWVAR 40
94170: PUSH
94171: LD_VAR 0 4
94175: ST_TO_ADDR
// un := CreateVehicle ;
94176: LD_ADDR_VAR 0 8
94180: PUSH
94181: CALL_OW 45
94185: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
94186: LD_VAR 0 8
94190: PPUSH
94191: LD_INT 0
94193: PPUSH
94194: LD_INT 5
94196: PPUSH
94197: CALL_OW 12
94201: PPUSH
94202: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
94206: LD_VAR 0 8
94210: PPUSH
94211: LD_VAR 0 5
94215: PPUSH
94216: LD_VAR 0 6
94220: PPUSH
94221: LD_INT 1
94223: PPUSH
94224: CALL_OW 48
// end ;
94228: LD_VAR 0 7
94232: RET
// export hInvincible ; every 1 do
94233: GO 94235
94235: DISABLE
// hInvincible := [ ] ;
94236: LD_ADDR_EXP 163
94240: PUSH
94241: EMPTY
94242: ST_TO_ADDR
94243: END
// every 10 do var i ;
94244: GO 94246
94246: DISABLE
94247: LD_INT 0
94249: PPUSH
// begin enable ;
94250: ENABLE
// if not hInvincible then
94251: LD_EXP 163
94255: NOT
94256: IFFALSE 94260
// exit ;
94258: GO 94304
// for i in hInvincible do
94260: LD_ADDR_VAR 0 1
94264: PUSH
94265: LD_EXP 163
94269: PUSH
94270: FOR_IN
94271: IFFALSE 94302
// if GetLives ( i ) < 1000 then
94273: LD_VAR 0 1
94277: PPUSH
94278: CALL_OW 256
94282: PUSH
94283: LD_INT 1000
94285: LESS
94286: IFFALSE 94300
// SetLives ( i , 1000 ) ;
94288: LD_VAR 0 1
94292: PPUSH
94293: LD_INT 1000
94295: PPUSH
94296: CALL_OW 234
94300: GO 94270
94302: POP
94303: POP
// end ;
94304: PPOPN 1
94306: END
// export function hHackInvincible ; var i ; begin
94307: LD_INT 0
94309: PPUSH
94310: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
94311: LD_ADDR_VAR 0 2
94315: PUSH
94316: LD_INT 2
94318: PUSH
94319: LD_INT 21
94321: PUSH
94322: LD_INT 1
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 21
94331: PUSH
94332: LD_INT 2
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: LIST
94343: PPUSH
94344: CALL_OW 69
94348: PUSH
94349: FOR_IN
94350: IFFALSE 94411
// if IsSelected ( i ) then
94352: LD_VAR 0 2
94356: PPUSH
94357: CALL_OW 306
94361: IFFALSE 94409
// begin if i in hInvincible then
94363: LD_VAR 0 2
94367: PUSH
94368: LD_EXP 163
94372: IN
94373: IFFALSE 94393
// hInvincible := hInvincible diff i else
94375: LD_ADDR_EXP 163
94379: PUSH
94380: LD_EXP 163
94384: PUSH
94385: LD_VAR 0 2
94389: DIFF
94390: ST_TO_ADDR
94391: GO 94409
// hInvincible := hInvincible union i ;
94393: LD_ADDR_EXP 163
94397: PUSH
94398: LD_EXP 163
94402: PUSH
94403: LD_VAR 0 2
94407: UNION
94408: ST_TO_ADDR
// end ;
94409: GO 94349
94411: POP
94412: POP
// end ;
94413: LD_VAR 0 1
94417: RET
// export function hHackInvisible ; var i , j ; begin
94418: LD_INT 0
94420: PPUSH
94421: PPUSH
94422: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94423: LD_ADDR_VAR 0 2
94427: PUSH
94428: LD_INT 21
94430: PUSH
94431: LD_INT 1
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PPUSH
94438: CALL_OW 69
94442: PUSH
94443: FOR_IN
94444: IFFALSE 94468
// if IsSelected ( i ) then
94446: LD_VAR 0 2
94450: PPUSH
94451: CALL_OW 306
94455: IFFALSE 94466
// ComForceInvisible ( i ) ;
94457: LD_VAR 0 2
94461: PPUSH
94462: CALL_OW 496
94466: GO 94443
94468: POP
94469: POP
// end ;
94470: LD_VAR 0 1
94474: RET
// export function hHackChangeYourSide ; begin
94475: LD_INT 0
94477: PPUSH
// if your_side = 8 then
94478: LD_OWVAR 2
94482: PUSH
94483: LD_INT 8
94485: EQUAL
94486: IFFALSE 94498
// your_side := 0 else
94488: LD_ADDR_OWVAR 2
94492: PUSH
94493: LD_INT 0
94495: ST_TO_ADDR
94496: GO 94512
// your_side := your_side + 1 ;
94498: LD_ADDR_OWVAR 2
94502: PUSH
94503: LD_OWVAR 2
94507: PUSH
94508: LD_INT 1
94510: PLUS
94511: ST_TO_ADDR
// end ;
94512: LD_VAR 0 1
94516: RET
// export function hHackChangeUnitSide ; var i , j ; begin
94517: LD_INT 0
94519: PPUSH
94520: PPUSH
94521: PPUSH
// for i in all_units do
94522: LD_ADDR_VAR 0 2
94526: PUSH
94527: LD_OWVAR 3
94531: PUSH
94532: FOR_IN
94533: IFFALSE 94611
// if IsSelected ( i ) then
94535: LD_VAR 0 2
94539: PPUSH
94540: CALL_OW 306
94544: IFFALSE 94609
// begin j := GetSide ( i ) ;
94546: LD_ADDR_VAR 0 3
94550: PUSH
94551: LD_VAR 0 2
94555: PPUSH
94556: CALL_OW 255
94560: ST_TO_ADDR
// if j = 8 then
94561: LD_VAR 0 3
94565: PUSH
94566: LD_INT 8
94568: EQUAL
94569: IFFALSE 94581
// j := 0 else
94571: LD_ADDR_VAR 0 3
94575: PUSH
94576: LD_INT 0
94578: ST_TO_ADDR
94579: GO 94595
// j := j + 1 ;
94581: LD_ADDR_VAR 0 3
94585: PUSH
94586: LD_VAR 0 3
94590: PUSH
94591: LD_INT 1
94593: PLUS
94594: ST_TO_ADDR
// SetSide ( i , j ) ;
94595: LD_VAR 0 2
94599: PPUSH
94600: LD_VAR 0 3
94604: PPUSH
94605: CALL_OW 235
// end ;
94609: GO 94532
94611: POP
94612: POP
// end ;
94613: LD_VAR 0 1
94617: RET
// export function hHackFog ; begin
94618: LD_INT 0
94620: PPUSH
// FogOff ( true ) ;
94621: LD_INT 1
94623: PPUSH
94624: CALL_OW 344
// end ;
94628: LD_VAR 0 1
94632: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94633: LD_INT 0
94635: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94636: LD_VAR 0 1
94640: PPUSH
94641: LD_VAR 0 2
94645: PPUSH
94646: LD_VAR 0 3
94650: PPUSH
94651: LD_INT 1
94653: PPUSH
94654: LD_INT 1
94656: PPUSH
94657: CALL_OW 483
// CenterOnXY ( x , y ) ;
94661: LD_VAR 0 2
94665: PPUSH
94666: LD_VAR 0 3
94670: PPUSH
94671: CALL_OW 84
// end ; end_of_file
94675: LD_VAR 0 4
94679: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94680: LD_INT 0
94682: PPUSH
94683: PPUSH
94684: PPUSH
94685: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94686: LD_VAR 0 1
94690: PPUSH
94691: CALL_OW 264
94695: PUSH
94696: LD_EXP 52
94700: EQUAL
94701: IFFALSE 94773
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94703: LD_INT 68
94705: PPUSH
94706: LD_VAR 0 1
94710: PPUSH
94711: CALL_OW 255
94715: PPUSH
94716: CALL_OW 321
94720: PUSH
94721: LD_INT 2
94723: EQUAL
94724: IFFALSE 94736
// eff := 70 else
94726: LD_ADDR_VAR 0 4
94730: PUSH
94731: LD_INT 70
94733: ST_TO_ADDR
94734: GO 94744
// eff := 30 ;
94736: LD_ADDR_VAR 0 4
94740: PUSH
94741: LD_INT 30
94743: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94744: LD_VAR 0 1
94748: PPUSH
94749: CALL_OW 250
94753: PPUSH
94754: LD_VAR 0 1
94758: PPUSH
94759: CALL_OW 251
94763: PPUSH
94764: LD_VAR 0 4
94768: PPUSH
94769: CALL_OW 495
// end ; end ;
94773: LD_VAR 0 2
94777: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94778: LD_INT 0
94780: PPUSH
// end ;
94781: LD_VAR 0 4
94785: RET
// export function SOS_Command ( cmd ) ; begin
94786: LD_INT 0
94788: PPUSH
// end ;
94789: LD_VAR 0 2
94793: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
94794: LD_INT 0
94796: PPUSH
// if cmd = 121 then
94797: LD_VAR 0 1
94801: PUSH
94802: LD_INT 121
94804: EQUAL
94805: IFFALSE 94807
// end ;
94807: LD_VAR 0 6
94811: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94812: LD_INT 0
94814: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94815: LD_VAR 0 1
94819: PUSH
94820: LD_INT 250
94822: EQUAL
94823: PUSH
94824: LD_VAR 0 2
94828: PPUSH
94829: CALL_OW 264
94833: PUSH
94834: LD_EXP 55
94838: EQUAL
94839: AND
94840: IFFALSE 94861
// MinerPlaceMine ( unit , x , y ) ;
94842: LD_VAR 0 2
94846: PPUSH
94847: LD_VAR 0 4
94851: PPUSH
94852: LD_VAR 0 5
94856: PPUSH
94857: CALL 97210 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
94861: LD_VAR 0 1
94865: PUSH
94866: LD_INT 251
94868: EQUAL
94869: PUSH
94870: LD_VAR 0 2
94874: PPUSH
94875: CALL_OW 264
94879: PUSH
94880: LD_EXP 55
94884: EQUAL
94885: AND
94886: IFFALSE 94907
// MinerDetonateMine ( unit , x , y ) ;
94888: LD_VAR 0 2
94892: PPUSH
94893: LD_VAR 0 4
94897: PPUSH
94898: LD_VAR 0 5
94902: PPUSH
94903: CALL 97487 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94907: LD_VAR 0 1
94911: PUSH
94912: LD_INT 252
94914: EQUAL
94915: PUSH
94916: LD_VAR 0 2
94920: PPUSH
94921: CALL_OW 264
94925: PUSH
94926: LD_EXP 55
94930: EQUAL
94931: AND
94932: IFFALSE 94953
// MinerCreateMinefield ( unit , x , y ) ;
94934: LD_VAR 0 2
94938: PPUSH
94939: LD_VAR 0 4
94943: PPUSH
94944: LD_VAR 0 5
94948: PPUSH
94949: CALL 97904 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
94953: LD_VAR 0 1
94957: PUSH
94958: LD_INT 253
94960: EQUAL
94961: PUSH
94962: LD_VAR 0 2
94966: PPUSH
94967: CALL_OW 257
94971: PUSH
94972: LD_INT 5
94974: EQUAL
94975: AND
94976: IFFALSE 94997
// ComBinocular ( unit , x , y ) ;
94978: LD_VAR 0 2
94982: PPUSH
94983: LD_VAR 0 4
94987: PPUSH
94988: LD_VAR 0 5
94992: PPUSH
94993: CALL 98275 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94997: LD_VAR 0 1
95001: PUSH
95002: LD_INT 254
95004: EQUAL
95005: PUSH
95006: LD_VAR 0 2
95010: PPUSH
95011: CALL_OW 264
95015: PUSH
95016: LD_EXP 50
95020: EQUAL
95021: AND
95022: PUSH
95023: LD_VAR 0 3
95027: PPUSH
95028: CALL_OW 263
95032: PUSH
95033: LD_INT 3
95035: EQUAL
95036: AND
95037: IFFALSE 95053
// HackDestroyVehicle ( unit , selectedUnit ) ;
95039: LD_VAR 0 2
95043: PPUSH
95044: LD_VAR 0 3
95048: PPUSH
95049: CALL 96570 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95053: LD_VAR 0 1
95057: PUSH
95058: LD_INT 255
95060: EQUAL
95061: PUSH
95062: LD_VAR 0 2
95066: PPUSH
95067: CALL_OW 264
95071: PUSH
95072: LD_INT 14
95074: PUSH
95075: LD_INT 53
95077: PUSH
95078: EMPTY
95079: LIST
95080: LIST
95081: IN
95082: AND
95083: PUSH
95084: LD_VAR 0 4
95088: PPUSH
95089: LD_VAR 0 5
95093: PPUSH
95094: CALL_OW 488
95098: AND
95099: IFFALSE 95123
// CutTreeXYR ( unit , x , y , 12 ) ;
95101: LD_VAR 0 2
95105: PPUSH
95106: LD_VAR 0 4
95110: PPUSH
95111: LD_VAR 0 5
95115: PPUSH
95116: LD_INT 12
95118: PPUSH
95119: CALL 95136 0 4
// end ;
95123: LD_VAR 0 6
95127: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
95128: LD_INT 0
95130: PPUSH
// end ;
95131: LD_VAR 0 4
95135: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
95136: LD_INT 0
95138: PPUSH
95139: PPUSH
95140: PPUSH
95141: PPUSH
95142: PPUSH
95143: PPUSH
95144: PPUSH
95145: PPUSH
95146: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
95147: LD_VAR 0 1
95151: NOT
95152: PUSH
95153: LD_VAR 0 2
95157: PPUSH
95158: LD_VAR 0 3
95162: PPUSH
95163: CALL_OW 488
95167: NOT
95168: OR
95169: PUSH
95170: LD_VAR 0 4
95174: NOT
95175: OR
95176: IFFALSE 95180
// exit ;
95178: GO 95520
// list := [ ] ;
95180: LD_ADDR_VAR 0 13
95184: PUSH
95185: EMPTY
95186: ST_TO_ADDR
// if x - r < 0 then
95187: LD_VAR 0 2
95191: PUSH
95192: LD_VAR 0 4
95196: MINUS
95197: PUSH
95198: LD_INT 0
95200: LESS
95201: IFFALSE 95213
// min_x := 0 else
95203: LD_ADDR_VAR 0 7
95207: PUSH
95208: LD_INT 0
95210: ST_TO_ADDR
95211: GO 95229
// min_x := x - r ;
95213: LD_ADDR_VAR 0 7
95217: PUSH
95218: LD_VAR 0 2
95222: PUSH
95223: LD_VAR 0 4
95227: MINUS
95228: ST_TO_ADDR
// if y - r < 0 then
95229: LD_VAR 0 3
95233: PUSH
95234: LD_VAR 0 4
95238: MINUS
95239: PUSH
95240: LD_INT 0
95242: LESS
95243: IFFALSE 95255
// min_y := 0 else
95245: LD_ADDR_VAR 0 8
95249: PUSH
95250: LD_INT 0
95252: ST_TO_ADDR
95253: GO 95271
// min_y := y - r ;
95255: LD_ADDR_VAR 0 8
95259: PUSH
95260: LD_VAR 0 3
95264: PUSH
95265: LD_VAR 0 4
95269: MINUS
95270: ST_TO_ADDR
// max_x := x + r ;
95271: LD_ADDR_VAR 0 9
95275: PUSH
95276: LD_VAR 0 2
95280: PUSH
95281: LD_VAR 0 4
95285: PLUS
95286: ST_TO_ADDR
// max_y := y + r ;
95287: LD_ADDR_VAR 0 10
95291: PUSH
95292: LD_VAR 0 3
95296: PUSH
95297: LD_VAR 0 4
95301: PLUS
95302: ST_TO_ADDR
// for _x = min_x to max_x do
95303: LD_ADDR_VAR 0 11
95307: PUSH
95308: DOUBLE
95309: LD_VAR 0 7
95313: DEC
95314: ST_TO_ADDR
95315: LD_VAR 0 9
95319: PUSH
95320: FOR_TO
95321: IFFALSE 95438
// for _y = min_y to max_y do
95323: LD_ADDR_VAR 0 12
95327: PUSH
95328: DOUBLE
95329: LD_VAR 0 8
95333: DEC
95334: ST_TO_ADDR
95335: LD_VAR 0 10
95339: PUSH
95340: FOR_TO
95341: IFFALSE 95434
// begin if not ValidHex ( _x , _y ) then
95343: LD_VAR 0 11
95347: PPUSH
95348: LD_VAR 0 12
95352: PPUSH
95353: CALL_OW 488
95357: NOT
95358: IFFALSE 95362
// continue ;
95360: GO 95340
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95362: LD_VAR 0 11
95366: PPUSH
95367: LD_VAR 0 12
95371: PPUSH
95372: CALL_OW 351
95376: PUSH
95377: LD_VAR 0 11
95381: PPUSH
95382: LD_VAR 0 12
95386: PPUSH
95387: CALL_OW 554
95391: AND
95392: IFFALSE 95432
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95394: LD_ADDR_VAR 0 13
95398: PUSH
95399: LD_VAR 0 13
95403: PPUSH
95404: LD_VAR 0 13
95408: PUSH
95409: LD_INT 1
95411: PLUS
95412: PPUSH
95413: LD_VAR 0 11
95417: PUSH
95418: LD_VAR 0 12
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PPUSH
95427: CALL_OW 2
95431: ST_TO_ADDR
// end ;
95432: GO 95340
95434: POP
95435: POP
95436: GO 95320
95438: POP
95439: POP
// if not list then
95440: LD_VAR 0 13
95444: NOT
95445: IFFALSE 95449
// exit ;
95447: GO 95520
// for i in list do
95449: LD_ADDR_VAR 0 6
95453: PUSH
95454: LD_VAR 0 13
95458: PUSH
95459: FOR_IN
95460: IFFALSE 95518
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95462: LD_VAR 0 1
95466: PPUSH
95467: LD_STRING M
95469: PUSH
95470: LD_VAR 0 6
95474: PUSH
95475: LD_INT 1
95477: ARRAY
95478: PUSH
95479: LD_VAR 0 6
95483: PUSH
95484: LD_INT 2
95486: ARRAY
95487: PUSH
95488: LD_INT 0
95490: PUSH
95491: LD_INT 0
95493: PUSH
95494: LD_INT 0
95496: PUSH
95497: LD_INT 0
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: PUSH
95509: EMPTY
95510: LIST
95511: PPUSH
95512: CALL_OW 447
95516: GO 95459
95518: POP
95519: POP
// end ;
95520: LD_VAR 0 5
95524: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95525: LD_EXP 166
95529: NOT
95530: IFFALSE 95580
95532: GO 95534
95534: DISABLE
// begin initHack := true ;
95535: LD_ADDR_EXP 166
95539: PUSH
95540: LD_INT 1
95542: ST_TO_ADDR
// hackTanks := [ ] ;
95543: LD_ADDR_EXP 167
95547: PUSH
95548: EMPTY
95549: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95550: LD_ADDR_EXP 168
95554: PUSH
95555: EMPTY
95556: ST_TO_ADDR
// hackLimit := 3 ;
95557: LD_ADDR_EXP 169
95561: PUSH
95562: LD_INT 3
95564: ST_TO_ADDR
// hackDist := 12 ;
95565: LD_ADDR_EXP 170
95569: PUSH
95570: LD_INT 12
95572: ST_TO_ADDR
// hackCounter := [ ] ;
95573: LD_ADDR_EXP 171
95577: PUSH
95578: EMPTY
95579: ST_TO_ADDR
// end ;
95580: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95581: LD_EXP 166
95585: PUSH
95586: LD_INT 34
95588: PUSH
95589: LD_EXP 50
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PPUSH
95598: CALL_OW 69
95602: AND
95603: IFFALSE 95858
95605: GO 95607
95607: DISABLE
95608: LD_INT 0
95610: PPUSH
95611: PPUSH
// begin enable ;
95612: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95613: LD_ADDR_VAR 0 1
95617: PUSH
95618: LD_INT 34
95620: PUSH
95621: LD_EXP 50
95625: PUSH
95626: EMPTY
95627: LIST
95628: LIST
95629: PPUSH
95630: CALL_OW 69
95634: PUSH
95635: FOR_IN
95636: IFFALSE 95856
// begin if not i in hackTanks then
95638: LD_VAR 0 1
95642: PUSH
95643: LD_EXP 167
95647: IN
95648: NOT
95649: IFFALSE 95732
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95651: LD_ADDR_EXP 167
95655: PUSH
95656: LD_EXP 167
95660: PPUSH
95661: LD_EXP 167
95665: PUSH
95666: LD_INT 1
95668: PLUS
95669: PPUSH
95670: LD_VAR 0 1
95674: PPUSH
95675: CALL_OW 1
95679: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95680: LD_ADDR_EXP 168
95684: PUSH
95685: LD_EXP 168
95689: PPUSH
95690: LD_EXP 168
95694: PUSH
95695: LD_INT 1
95697: PLUS
95698: PPUSH
95699: EMPTY
95700: PPUSH
95701: CALL_OW 1
95705: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95706: LD_ADDR_EXP 171
95710: PUSH
95711: LD_EXP 171
95715: PPUSH
95716: LD_EXP 171
95720: PUSH
95721: LD_INT 1
95723: PLUS
95724: PPUSH
95725: EMPTY
95726: PPUSH
95727: CALL_OW 1
95731: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95732: LD_VAR 0 1
95736: PPUSH
95737: CALL_OW 302
95741: NOT
95742: IFFALSE 95755
// begin HackUnlinkAll ( i ) ;
95744: LD_VAR 0 1
95748: PPUSH
95749: CALL 95861 0 1
// continue ;
95753: GO 95635
// end ; HackCheckCapturedStatus ( i ) ;
95755: LD_VAR 0 1
95759: PPUSH
95760: CALL 96304 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95764: LD_ADDR_VAR 0 2
95768: PUSH
95769: LD_INT 81
95771: PUSH
95772: LD_VAR 0 1
95776: PPUSH
95777: CALL_OW 255
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 33
95788: PUSH
95789: LD_INT 3
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 91
95798: PUSH
95799: LD_VAR 0 1
95803: PUSH
95804: LD_EXP 170
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 50
95816: PUSH
95817: EMPTY
95818: LIST
95819: PUSH
95820: EMPTY
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: PPUSH
95826: CALL_OW 69
95830: ST_TO_ADDR
// if not tmp then
95831: LD_VAR 0 2
95835: NOT
95836: IFFALSE 95840
// continue ;
95838: GO 95635
// HackLink ( i , tmp ) ;
95840: LD_VAR 0 1
95844: PPUSH
95845: LD_VAR 0 2
95849: PPUSH
95850: CALL 95997 0 2
// end ;
95854: GO 95635
95856: POP
95857: POP
// end ;
95858: PPOPN 2
95860: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95861: LD_INT 0
95863: PPUSH
95864: PPUSH
95865: PPUSH
// if not hack in hackTanks then
95866: LD_VAR 0 1
95870: PUSH
95871: LD_EXP 167
95875: IN
95876: NOT
95877: IFFALSE 95881
// exit ;
95879: GO 95992
// index := GetElementIndex ( hackTanks , hack ) ;
95881: LD_ADDR_VAR 0 4
95885: PUSH
95886: LD_EXP 167
95890: PPUSH
95891: LD_VAR 0 1
95895: PPUSH
95896: CALL 18333 0 2
95900: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95901: LD_EXP 168
95905: PUSH
95906: LD_VAR 0 4
95910: ARRAY
95911: IFFALSE 95992
// begin for i in hackTanksCaptured [ index ] do
95913: LD_ADDR_VAR 0 3
95917: PUSH
95918: LD_EXP 168
95922: PUSH
95923: LD_VAR 0 4
95927: ARRAY
95928: PUSH
95929: FOR_IN
95930: IFFALSE 95956
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95932: LD_VAR 0 3
95936: PUSH
95937: LD_INT 1
95939: ARRAY
95940: PPUSH
95941: LD_VAR 0 3
95945: PUSH
95946: LD_INT 2
95948: ARRAY
95949: PPUSH
95950: CALL_OW 235
95954: GO 95929
95956: POP
95957: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95958: LD_ADDR_EXP 168
95962: PUSH
95963: LD_EXP 168
95967: PPUSH
95968: LD_VAR 0 4
95972: PPUSH
95973: EMPTY
95974: PPUSH
95975: CALL_OW 1
95979: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95980: LD_VAR 0 1
95984: PPUSH
95985: LD_INT 0
95987: PPUSH
95988: CALL_OW 505
// end ; end ;
95992: LD_VAR 0 2
95996: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95997: LD_INT 0
95999: PPUSH
96000: PPUSH
96001: PPUSH
// if not hack in hackTanks or not vehicles then
96002: LD_VAR 0 1
96006: PUSH
96007: LD_EXP 167
96011: IN
96012: NOT
96013: PUSH
96014: LD_VAR 0 2
96018: NOT
96019: OR
96020: IFFALSE 96024
// exit ;
96022: GO 96299
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96024: LD_ADDR_VAR 0 2
96028: PUSH
96029: LD_VAR 0 1
96033: PPUSH
96034: LD_VAR 0 2
96038: PPUSH
96039: LD_INT 1
96041: PPUSH
96042: LD_INT 1
96044: PPUSH
96045: CALL 18983 0 4
96049: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96050: LD_ADDR_VAR 0 5
96054: PUSH
96055: LD_EXP 167
96059: PPUSH
96060: LD_VAR 0 1
96064: PPUSH
96065: CALL 18333 0 2
96069: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96070: LD_EXP 168
96074: PUSH
96075: LD_VAR 0 5
96079: ARRAY
96080: PUSH
96081: LD_EXP 169
96085: LESS
96086: IFFALSE 96275
// begin for i := 1 to vehicles do
96088: LD_ADDR_VAR 0 4
96092: PUSH
96093: DOUBLE
96094: LD_INT 1
96096: DEC
96097: ST_TO_ADDR
96098: LD_VAR 0 2
96102: PUSH
96103: FOR_TO
96104: IFFALSE 96273
// begin if hackTanksCaptured [ index ] = hackLimit then
96106: LD_EXP 168
96110: PUSH
96111: LD_VAR 0 5
96115: ARRAY
96116: PUSH
96117: LD_EXP 169
96121: EQUAL
96122: IFFALSE 96126
// break ;
96124: GO 96273
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96126: LD_ADDR_EXP 171
96130: PUSH
96131: LD_EXP 171
96135: PPUSH
96136: LD_VAR 0 5
96140: PPUSH
96141: LD_EXP 171
96145: PUSH
96146: LD_VAR 0 5
96150: ARRAY
96151: PUSH
96152: LD_INT 1
96154: PLUS
96155: PPUSH
96156: CALL_OW 1
96160: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96161: LD_ADDR_EXP 168
96165: PUSH
96166: LD_EXP 168
96170: PPUSH
96171: LD_VAR 0 5
96175: PUSH
96176: LD_EXP 168
96180: PUSH
96181: LD_VAR 0 5
96185: ARRAY
96186: PUSH
96187: LD_INT 1
96189: PLUS
96190: PUSH
96191: EMPTY
96192: LIST
96193: LIST
96194: PPUSH
96195: LD_VAR 0 2
96199: PUSH
96200: LD_VAR 0 4
96204: ARRAY
96205: PUSH
96206: LD_VAR 0 2
96210: PUSH
96211: LD_VAR 0 4
96215: ARRAY
96216: PPUSH
96217: CALL_OW 255
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PPUSH
96226: CALL 18548 0 3
96230: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96231: LD_VAR 0 2
96235: PUSH
96236: LD_VAR 0 4
96240: ARRAY
96241: PPUSH
96242: LD_VAR 0 1
96246: PPUSH
96247: CALL_OW 255
96251: PPUSH
96252: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96256: LD_VAR 0 2
96260: PUSH
96261: LD_VAR 0 4
96265: ARRAY
96266: PPUSH
96267: CALL_OW 141
// end ;
96271: GO 96103
96273: POP
96274: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96275: LD_VAR 0 1
96279: PPUSH
96280: LD_EXP 168
96284: PUSH
96285: LD_VAR 0 5
96289: ARRAY
96290: PUSH
96291: LD_INT 0
96293: PLUS
96294: PPUSH
96295: CALL_OW 505
// end ;
96299: LD_VAR 0 3
96303: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96304: LD_INT 0
96306: PPUSH
96307: PPUSH
96308: PPUSH
96309: PPUSH
// if not hack in hackTanks then
96310: LD_VAR 0 1
96314: PUSH
96315: LD_EXP 167
96319: IN
96320: NOT
96321: IFFALSE 96325
// exit ;
96323: GO 96565
// index := GetElementIndex ( hackTanks , hack ) ;
96325: LD_ADDR_VAR 0 4
96329: PUSH
96330: LD_EXP 167
96334: PPUSH
96335: LD_VAR 0 1
96339: PPUSH
96340: CALL 18333 0 2
96344: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96345: LD_ADDR_VAR 0 3
96349: PUSH
96350: DOUBLE
96351: LD_EXP 168
96355: PUSH
96356: LD_VAR 0 4
96360: ARRAY
96361: INC
96362: ST_TO_ADDR
96363: LD_INT 1
96365: PUSH
96366: FOR_DOWNTO
96367: IFFALSE 96539
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96369: LD_ADDR_VAR 0 5
96373: PUSH
96374: LD_EXP 168
96378: PUSH
96379: LD_VAR 0 4
96383: ARRAY
96384: PUSH
96385: LD_VAR 0 3
96389: ARRAY
96390: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96391: LD_VAR 0 5
96395: PUSH
96396: LD_INT 1
96398: ARRAY
96399: PPUSH
96400: CALL_OW 302
96404: NOT
96405: PUSH
96406: LD_VAR 0 5
96410: PUSH
96411: LD_INT 1
96413: ARRAY
96414: PPUSH
96415: CALL_OW 255
96419: PUSH
96420: LD_VAR 0 1
96424: PPUSH
96425: CALL_OW 255
96429: NONEQUAL
96430: OR
96431: IFFALSE 96537
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96433: LD_VAR 0 5
96437: PUSH
96438: LD_INT 1
96440: ARRAY
96441: PPUSH
96442: CALL_OW 305
96446: PUSH
96447: LD_VAR 0 5
96451: PUSH
96452: LD_INT 1
96454: ARRAY
96455: PPUSH
96456: CALL_OW 255
96460: PUSH
96461: LD_VAR 0 1
96465: PPUSH
96466: CALL_OW 255
96470: EQUAL
96471: AND
96472: IFFALSE 96496
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96474: LD_VAR 0 5
96478: PUSH
96479: LD_INT 1
96481: ARRAY
96482: PPUSH
96483: LD_VAR 0 5
96487: PUSH
96488: LD_INT 2
96490: ARRAY
96491: PPUSH
96492: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96496: LD_ADDR_EXP 168
96500: PUSH
96501: LD_EXP 168
96505: PPUSH
96506: LD_VAR 0 4
96510: PPUSH
96511: LD_EXP 168
96515: PUSH
96516: LD_VAR 0 4
96520: ARRAY
96521: PPUSH
96522: LD_VAR 0 3
96526: PPUSH
96527: CALL_OW 3
96531: PPUSH
96532: CALL_OW 1
96536: ST_TO_ADDR
// end ; end ;
96537: GO 96366
96539: POP
96540: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96541: LD_VAR 0 1
96545: PPUSH
96546: LD_EXP 168
96550: PUSH
96551: LD_VAR 0 4
96555: ARRAY
96556: PUSH
96557: LD_INT 0
96559: PLUS
96560: PPUSH
96561: CALL_OW 505
// end ;
96565: LD_VAR 0 2
96569: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96570: LD_INT 0
96572: PPUSH
96573: PPUSH
96574: PPUSH
96575: PPUSH
// if not hack in hackTanks then
96576: LD_VAR 0 1
96580: PUSH
96581: LD_EXP 167
96585: IN
96586: NOT
96587: IFFALSE 96591
// exit ;
96589: GO 96676
// index := GetElementIndex ( hackTanks , hack ) ;
96591: LD_ADDR_VAR 0 5
96595: PUSH
96596: LD_EXP 167
96600: PPUSH
96601: LD_VAR 0 1
96605: PPUSH
96606: CALL 18333 0 2
96610: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96611: LD_ADDR_VAR 0 4
96615: PUSH
96616: DOUBLE
96617: LD_INT 1
96619: DEC
96620: ST_TO_ADDR
96621: LD_EXP 168
96625: PUSH
96626: LD_VAR 0 5
96630: ARRAY
96631: PUSH
96632: FOR_TO
96633: IFFALSE 96674
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96635: LD_EXP 168
96639: PUSH
96640: LD_VAR 0 5
96644: ARRAY
96645: PUSH
96646: LD_VAR 0 4
96650: ARRAY
96651: PUSH
96652: LD_INT 1
96654: ARRAY
96655: PUSH
96656: LD_VAR 0 2
96660: EQUAL
96661: IFFALSE 96672
// KillUnit ( vehicle ) ;
96663: LD_VAR 0 2
96667: PPUSH
96668: CALL_OW 66
96672: GO 96632
96674: POP
96675: POP
// end ;
96676: LD_VAR 0 3
96680: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96681: LD_EXP 172
96685: NOT
96686: IFFALSE 96721
96688: GO 96690
96690: DISABLE
// begin initMiner := true ;
96691: LD_ADDR_EXP 172
96695: PUSH
96696: LD_INT 1
96698: ST_TO_ADDR
// minersList := [ ] ;
96699: LD_ADDR_EXP 173
96703: PUSH
96704: EMPTY
96705: ST_TO_ADDR
// minerMinesList := [ ] ;
96706: LD_ADDR_EXP 174
96710: PUSH
96711: EMPTY
96712: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96713: LD_ADDR_EXP 175
96717: PUSH
96718: LD_INT 5
96720: ST_TO_ADDR
// end ;
96721: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96722: LD_EXP 172
96726: PUSH
96727: LD_INT 34
96729: PUSH
96730: LD_EXP 55
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PPUSH
96739: CALL_OW 69
96743: AND
96744: IFFALSE 97207
96746: GO 96748
96748: DISABLE
96749: LD_INT 0
96751: PPUSH
96752: PPUSH
96753: PPUSH
96754: PPUSH
// begin enable ;
96755: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96756: LD_ADDR_VAR 0 1
96760: PUSH
96761: LD_INT 34
96763: PUSH
96764: LD_EXP 55
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PPUSH
96773: CALL_OW 69
96777: PUSH
96778: FOR_IN
96779: IFFALSE 96851
// begin if not i in minersList then
96781: LD_VAR 0 1
96785: PUSH
96786: LD_EXP 173
96790: IN
96791: NOT
96792: IFFALSE 96849
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96794: LD_ADDR_EXP 173
96798: PUSH
96799: LD_EXP 173
96803: PPUSH
96804: LD_EXP 173
96808: PUSH
96809: LD_INT 1
96811: PLUS
96812: PPUSH
96813: LD_VAR 0 1
96817: PPUSH
96818: CALL_OW 1
96822: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96823: LD_ADDR_EXP 174
96827: PUSH
96828: LD_EXP 174
96832: PPUSH
96833: LD_EXP 174
96837: PUSH
96838: LD_INT 1
96840: PLUS
96841: PPUSH
96842: EMPTY
96843: PPUSH
96844: CALL_OW 1
96848: ST_TO_ADDR
// end end ;
96849: GO 96778
96851: POP
96852: POP
// for i := minerMinesList downto 1 do
96853: LD_ADDR_VAR 0 1
96857: PUSH
96858: DOUBLE
96859: LD_EXP 174
96863: INC
96864: ST_TO_ADDR
96865: LD_INT 1
96867: PUSH
96868: FOR_DOWNTO
96869: IFFALSE 97205
// begin if IsLive ( minersList [ i ] ) then
96871: LD_EXP 173
96875: PUSH
96876: LD_VAR 0 1
96880: ARRAY
96881: PPUSH
96882: CALL_OW 300
96886: IFFALSE 96914
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96888: LD_EXP 173
96892: PUSH
96893: LD_VAR 0 1
96897: ARRAY
96898: PPUSH
96899: LD_EXP 174
96903: PUSH
96904: LD_VAR 0 1
96908: ARRAY
96909: PPUSH
96910: CALL_OW 505
// if not minerMinesList [ i ] then
96914: LD_EXP 174
96918: PUSH
96919: LD_VAR 0 1
96923: ARRAY
96924: NOT
96925: IFFALSE 96929
// continue ;
96927: GO 96868
// for j := minerMinesList [ i ] downto 1 do
96929: LD_ADDR_VAR 0 2
96933: PUSH
96934: DOUBLE
96935: LD_EXP 174
96939: PUSH
96940: LD_VAR 0 1
96944: ARRAY
96945: INC
96946: ST_TO_ADDR
96947: LD_INT 1
96949: PUSH
96950: FOR_DOWNTO
96951: IFFALSE 97201
// begin side := GetSide ( minersList [ i ] ) ;
96953: LD_ADDR_VAR 0 3
96957: PUSH
96958: LD_EXP 173
96962: PUSH
96963: LD_VAR 0 1
96967: ARRAY
96968: PPUSH
96969: CALL_OW 255
96973: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
96974: LD_ADDR_VAR 0 4
96978: PUSH
96979: LD_EXP 174
96983: PUSH
96984: LD_VAR 0 1
96988: ARRAY
96989: PUSH
96990: LD_VAR 0 2
96994: ARRAY
96995: PUSH
96996: LD_INT 1
96998: ARRAY
96999: PPUSH
97000: LD_EXP 174
97004: PUSH
97005: LD_VAR 0 1
97009: ARRAY
97010: PUSH
97011: LD_VAR 0 2
97015: ARRAY
97016: PUSH
97017: LD_INT 2
97019: ARRAY
97020: PPUSH
97021: CALL_OW 428
97025: ST_TO_ADDR
// if not tmp then
97026: LD_VAR 0 4
97030: NOT
97031: IFFALSE 97035
// continue ;
97033: GO 96950
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97035: LD_VAR 0 4
97039: PUSH
97040: LD_INT 81
97042: PUSH
97043: LD_VAR 0 3
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PPUSH
97052: CALL_OW 69
97056: IN
97057: PUSH
97058: LD_EXP 174
97062: PUSH
97063: LD_VAR 0 1
97067: ARRAY
97068: PUSH
97069: LD_VAR 0 2
97073: ARRAY
97074: PUSH
97075: LD_INT 1
97077: ARRAY
97078: PPUSH
97079: LD_EXP 174
97083: PUSH
97084: LD_VAR 0 1
97088: ARRAY
97089: PUSH
97090: LD_VAR 0 2
97094: ARRAY
97095: PUSH
97096: LD_INT 2
97098: ARRAY
97099: PPUSH
97100: CALL_OW 458
97104: AND
97105: IFFALSE 97199
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97107: LD_EXP 174
97111: PUSH
97112: LD_VAR 0 1
97116: ARRAY
97117: PUSH
97118: LD_VAR 0 2
97122: ARRAY
97123: PUSH
97124: LD_INT 1
97126: ARRAY
97127: PPUSH
97128: LD_EXP 174
97132: PUSH
97133: LD_VAR 0 1
97137: ARRAY
97138: PUSH
97139: LD_VAR 0 2
97143: ARRAY
97144: PUSH
97145: LD_INT 2
97147: ARRAY
97148: PPUSH
97149: LD_VAR 0 3
97153: PPUSH
97154: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97158: LD_ADDR_EXP 174
97162: PUSH
97163: LD_EXP 174
97167: PPUSH
97168: LD_VAR 0 1
97172: PPUSH
97173: LD_EXP 174
97177: PUSH
97178: LD_VAR 0 1
97182: ARRAY
97183: PPUSH
97184: LD_VAR 0 2
97188: PPUSH
97189: CALL_OW 3
97193: PPUSH
97194: CALL_OW 1
97198: ST_TO_ADDR
// end ; end ;
97199: GO 96950
97201: POP
97202: POP
// end ;
97203: GO 96868
97205: POP
97206: POP
// end ;
97207: PPOPN 4
97209: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
97210: LD_INT 0
97212: PPUSH
97213: PPUSH
// result := false ;
97214: LD_ADDR_VAR 0 4
97218: PUSH
97219: LD_INT 0
97221: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97222: LD_VAR 0 1
97226: PPUSH
97227: CALL_OW 264
97231: PUSH
97232: LD_EXP 55
97236: EQUAL
97237: NOT
97238: IFFALSE 97242
// exit ;
97240: GO 97482
// index := GetElementIndex ( minersList , unit ) ;
97242: LD_ADDR_VAR 0 5
97246: PUSH
97247: LD_EXP 173
97251: PPUSH
97252: LD_VAR 0 1
97256: PPUSH
97257: CALL 18333 0 2
97261: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97262: LD_EXP 174
97266: PUSH
97267: LD_VAR 0 5
97271: ARRAY
97272: PUSH
97273: LD_EXP 175
97277: GREATEREQUAL
97278: IFFALSE 97282
// exit ;
97280: GO 97482
// ComMoveXY ( unit , x , y ) ;
97282: LD_VAR 0 1
97286: PPUSH
97287: LD_VAR 0 2
97291: PPUSH
97292: LD_VAR 0 3
97296: PPUSH
97297: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97301: LD_INT 35
97303: PPUSH
97304: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97308: LD_VAR 0 1
97312: PPUSH
97313: LD_VAR 0 2
97317: PPUSH
97318: LD_VAR 0 3
97322: PPUSH
97323: CALL 48730 0 3
97327: NOT
97328: PUSH
97329: LD_VAR 0 1
97333: PPUSH
97334: CALL_OW 314
97338: AND
97339: IFFALSE 97343
// exit ;
97341: GO 97482
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97343: LD_VAR 0 2
97347: PPUSH
97348: LD_VAR 0 3
97352: PPUSH
97353: CALL_OW 428
97357: PUSH
97358: LD_VAR 0 1
97362: EQUAL
97363: PUSH
97364: LD_VAR 0 1
97368: PPUSH
97369: CALL_OW 314
97373: NOT
97374: AND
97375: IFFALSE 97301
// PlaySoundXY ( x , y , PlantMine ) ;
97377: LD_VAR 0 2
97381: PPUSH
97382: LD_VAR 0 3
97386: PPUSH
97387: LD_STRING PlantMine
97389: PPUSH
97390: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97394: LD_VAR 0 2
97398: PPUSH
97399: LD_VAR 0 3
97403: PPUSH
97404: LD_VAR 0 1
97408: PPUSH
97409: CALL_OW 255
97413: PPUSH
97414: LD_INT 0
97416: PPUSH
97417: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97421: LD_ADDR_EXP 174
97425: PUSH
97426: LD_EXP 174
97430: PPUSH
97431: LD_VAR 0 5
97435: PUSH
97436: LD_EXP 174
97440: PUSH
97441: LD_VAR 0 5
97445: ARRAY
97446: PUSH
97447: LD_INT 1
97449: PLUS
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PPUSH
97455: LD_VAR 0 2
97459: PUSH
97460: LD_VAR 0 3
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PPUSH
97469: CALL 18548 0 3
97473: ST_TO_ADDR
// result := true ;
97474: LD_ADDR_VAR 0 4
97478: PUSH
97479: LD_INT 1
97481: ST_TO_ADDR
// end ;
97482: LD_VAR 0 4
97486: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97487: LD_INT 0
97489: PPUSH
97490: PPUSH
97491: PPUSH
// if not unit in minersList then
97492: LD_VAR 0 1
97496: PUSH
97497: LD_EXP 173
97501: IN
97502: NOT
97503: IFFALSE 97507
// exit ;
97505: GO 97899
// index := GetElementIndex ( minersList , unit ) ;
97507: LD_ADDR_VAR 0 6
97511: PUSH
97512: LD_EXP 173
97516: PPUSH
97517: LD_VAR 0 1
97521: PPUSH
97522: CALL 18333 0 2
97526: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97527: LD_ADDR_VAR 0 5
97531: PUSH
97532: DOUBLE
97533: LD_EXP 174
97537: PUSH
97538: LD_VAR 0 6
97542: ARRAY
97543: INC
97544: ST_TO_ADDR
97545: LD_INT 1
97547: PUSH
97548: FOR_DOWNTO
97549: IFFALSE 97710
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97551: LD_EXP 174
97555: PUSH
97556: LD_VAR 0 6
97560: ARRAY
97561: PUSH
97562: LD_VAR 0 5
97566: ARRAY
97567: PUSH
97568: LD_INT 1
97570: ARRAY
97571: PUSH
97572: LD_VAR 0 2
97576: EQUAL
97577: PUSH
97578: LD_EXP 174
97582: PUSH
97583: LD_VAR 0 6
97587: ARRAY
97588: PUSH
97589: LD_VAR 0 5
97593: ARRAY
97594: PUSH
97595: LD_INT 2
97597: ARRAY
97598: PUSH
97599: LD_VAR 0 3
97603: EQUAL
97604: AND
97605: IFFALSE 97708
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97607: LD_EXP 174
97611: PUSH
97612: LD_VAR 0 6
97616: ARRAY
97617: PUSH
97618: LD_VAR 0 5
97622: ARRAY
97623: PUSH
97624: LD_INT 1
97626: ARRAY
97627: PPUSH
97628: LD_EXP 174
97632: PUSH
97633: LD_VAR 0 6
97637: ARRAY
97638: PUSH
97639: LD_VAR 0 5
97643: ARRAY
97644: PUSH
97645: LD_INT 2
97647: ARRAY
97648: PPUSH
97649: LD_VAR 0 1
97653: PPUSH
97654: CALL_OW 255
97658: PPUSH
97659: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97663: LD_ADDR_EXP 174
97667: PUSH
97668: LD_EXP 174
97672: PPUSH
97673: LD_VAR 0 6
97677: PPUSH
97678: LD_EXP 174
97682: PUSH
97683: LD_VAR 0 6
97687: ARRAY
97688: PPUSH
97689: LD_VAR 0 5
97693: PPUSH
97694: CALL_OW 3
97698: PPUSH
97699: CALL_OW 1
97703: ST_TO_ADDR
// exit ;
97704: POP
97705: POP
97706: GO 97899
// end ; end ;
97708: GO 97548
97710: POP
97711: POP
// for i := minerMinesList [ index ] downto 1 do
97712: LD_ADDR_VAR 0 5
97716: PUSH
97717: DOUBLE
97718: LD_EXP 174
97722: PUSH
97723: LD_VAR 0 6
97727: ARRAY
97728: INC
97729: ST_TO_ADDR
97730: LD_INT 1
97732: PUSH
97733: FOR_DOWNTO
97734: IFFALSE 97897
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97736: LD_EXP 174
97740: PUSH
97741: LD_VAR 0 6
97745: ARRAY
97746: PUSH
97747: LD_VAR 0 5
97751: ARRAY
97752: PUSH
97753: LD_INT 1
97755: ARRAY
97756: PPUSH
97757: LD_EXP 174
97761: PUSH
97762: LD_VAR 0 6
97766: ARRAY
97767: PUSH
97768: LD_VAR 0 5
97772: ARRAY
97773: PUSH
97774: LD_INT 2
97776: ARRAY
97777: PPUSH
97778: LD_VAR 0 2
97782: PPUSH
97783: LD_VAR 0 3
97787: PPUSH
97788: CALL_OW 298
97792: PUSH
97793: LD_INT 6
97795: LESS
97796: IFFALSE 97895
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97798: LD_EXP 174
97802: PUSH
97803: LD_VAR 0 6
97807: ARRAY
97808: PUSH
97809: LD_VAR 0 5
97813: ARRAY
97814: PUSH
97815: LD_INT 1
97817: ARRAY
97818: PPUSH
97819: LD_EXP 174
97823: PUSH
97824: LD_VAR 0 6
97828: ARRAY
97829: PUSH
97830: LD_VAR 0 5
97834: ARRAY
97835: PUSH
97836: LD_INT 2
97838: ARRAY
97839: PPUSH
97840: LD_VAR 0 1
97844: PPUSH
97845: CALL_OW 255
97849: PPUSH
97850: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97854: LD_ADDR_EXP 174
97858: PUSH
97859: LD_EXP 174
97863: PPUSH
97864: LD_VAR 0 6
97868: PPUSH
97869: LD_EXP 174
97873: PUSH
97874: LD_VAR 0 6
97878: ARRAY
97879: PPUSH
97880: LD_VAR 0 5
97884: PPUSH
97885: CALL_OW 3
97889: PPUSH
97890: CALL_OW 1
97894: ST_TO_ADDR
// end ; end ;
97895: GO 97733
97897: POP
97898: POP
// end ;
97899: LD_VAR 0 4
97903: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97904: LD_INT 0
97906: PPUSH
97907: PPUSH
97908: PPUSH
97909: PPUSH
97910: PPUSH
97911: PPUSH
97912: PPUSH
97913: PPUSH
97914: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97915: LD_VAR 0 1
97919: PPUSH
97920: CALL_OW 264
97924: PUSH
97925: LD_EXP 55
97929: EQUAL
97930: NOT
97931: PUSH
97932: LD_VAR 0 1
97936: PUSH
97937: LD_EXP 173
97941: IN
97942: NOT
97943: OR
97944: IFFALSE 97948
// exit ;
97946: GO 98270
// index := GetElementIndex ( minersList , unit ) ;
97948: LD_ADDR_VAR 0 6
97952: PUSH
97953: LD_EXP 173
97957: PPUSH
97958: LD_VAR 0 1
97962: PPUSH
97963: CALL 18333 0 2
97967: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
97968: LD_ADDR_VAR 0 8
97972: PUSH
97973: LD_EXP 175
97977: PUSH
97978: LD_EXP 174
97982: PUSH
97983: LD_VAR 0 6
97987: ARRAY
97988: MINUS
97989: ST_TO_ADDR
// if not minesFreeAmount then
97990: LD_VAR 0 8
97994: NOT
97995: IFFALSE 97999
// exit ;
97997: GO 98270
// tmp := [ ] ;
97999: LD_ADDR_VAR 0 7
98003: PUSH
98004: EMPTY
98005: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98006: LD_ADDR_VAR 0 5
98010: PUSH
98011: DOUBLE
98012: LD_INT 1
98014: DEC
98015: ST_TO_ADDR
98016: LD_VAR 0 8
98020: PUSH
98021: FOR_TO
98022: IFFALSE 98217
// begin _d := rand ( 0 , 5 ) ;
98024: LD_ADDR_VAR 0 11
98028: PUSH
98029: LD_INT 0
98031: PPUSH
98032: LD_INT 5
98034: PPUSH
98035: CALL_OW 12
98039: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98040: LD_ADDR_VAR 0 12
98044: PUSH
98045: LD_INT 2
98047: PPUSH
98048: LD_INT 6
98050: PPUSH
98051: CALL_OW 12
98055: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98056: LD_ADDR_VAR 0 9
98060: PUSH
98061: LD_VAR 0 2
98065: PPUSH
98066: LD_VAR 0 11
98070: PPUSH
98071: LD_VAR 0 12
98075: PPUSH
98076: CALL_OW 272
98080: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98081: LD_ADDR_VAR 0 10
98085: PUSH
98086: LD_VAR 0 3
98090: PPUSH
98091: LD_VAR 0 11
98095: PPUSH
98096: LD_VAR 0 12
98100: PPUSH
98101: CALL_OW 273
98105: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98106: LD_VAR 0 9
98110: PPUSH
98111: LD_VAR 0 10
98115: PPUSH
98116: CALL_OW 488
98120: PUSH
98121: LD_VAR 0 9
98125: PUSH
98126: LD_VAR 0 10
98130: PUSH
98131: EMPTY
98132: LIST
98133: LIST
98134: PUSH
98135: LD_VAR 0 7
98139: IN
98140: NOT
98141: AND
98142: PUSH
98143: LD_VAR 0 9
98147: PPUSH
98148: LD_VAR 0 10
98152: PPUSH
98153: CALL_OW 458
98157: NOT
98158: AND
98159: IFFALSE 98201
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98161: LD_ADDR_VAR 0 7
98165: PUSH
98166: LD_VAR 0 7
98170: PPUSH
98171: LD_VAR 0 7
98175: PUSH
98176: LD_INT 1
98178: PLUS
98179: PPUSH
98180: LD_VAR 0 9
98184: PUSH
98185: LD_VAR 0 10
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PPUSH
98194: CALL_OW 1
98198: ST_TO_ADDR
98199: GO 98215
// i := i - 1 ;
98201: LD_ADDR_VAR 0 5
98205: PUSH
98206: LD_VAR 0 5
98210: PUSH
98211: LD_INT 1
98213: MINUS
98214: ST_TO_ADDR
// end ;
98215: GO 98021
98217: POP
98218: POP
// for i in tmp do
98219: LD_ADDR_VAR 0 5
98223: PUSH
98224: LD_VAR 0 7
98228: PUSH
98229: FOR_IN
98230: IFFALSE 98268
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98232: LD_VAR 0 1
98236: PPUSH
98237: LD_VAR 0 5
98241: PUSH
98242: LD_INT 1
98244: ARRAY
98245: PPUSH
98246: LD_VAR 0 5
98250: PUSH
98251: LD_INT 2
98253: ARRAY
98254: PPUSH
98255: CALL 97210 0 3
98259: NOT
98260: IFFALSE 98266
// exit ;
98262: POP
98263: POP
98264: GO 98270
98266: GO 98229
98268: POP
98269: POP
// end ;
98270: LD_VAR 0 4
98274: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
98275: LD_INT 0
98277: PPUSH
98278: PPUSH
98279: PPUSH
98280: PPUSH
98281: PPUSH
98282: PPUSH
98283: PPUSH
// if not GetClass ( unit ) = class_sniper then
98284: LD_VAR 0 1
98288: PPUSH
98289: CALL_OW 257
98293: PUSH
98294: LD_INT 5
98296: EQUAL
98297: NOT
98298: IFFALSE 98302
// exit ;
98300: GO 98690
// dist := 8 ;
98302: LD_ADDR_VAR 0 5
98306: PUSH
98307: LD_INT 8
98309: ST_TO_ADDR
// viewRange := 12 ;
98310: LD_ADDR_VAR 0 7
98314: PUSH
98315: LD_INT 12
98317: ST_TO_ADDR
// side := GetSide ( unit ) ;
98318: LD_ADDR_VAR 0 6
98322: PUSH
98323: LD_VAR 0 1
98327: PPUSH
98328: CALL_OW 255
98332: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98333: LD_INT 61
98335: PPUSH
98336: LD_VAR 0 6
98340: PPUSH
98341: CALL_OW 321
98345: PUSH
98346: LD_INT 2
98348: EQUAL
98349: IFFALSE 98359
// viewRange := 16 ;
98351: LD_ADDR_VAR 0 7
98355: PUSH
98356: LD_INT 16
98358: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98359: LD_VAR 0 1
98363: PPUSH
98364: LD_VAR 0 2
98368: PPUSH
98369: LD_VAR 0 3
98373: PPUSH
98374: CALL_OW 297
98378: PUSH
98379: LD_VAR 0 5
98383: GREATER
98384: IFFALSE 98463
// begin ComMoveXY ( unit , x , y ) ;
98386: LD_VAR 0 1
98390: PPUSH
98391: LD_VAR 0 2
98395: PPUSH
98396: LD_VAR 0 3
98400: PPUSH
98401: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98405: LD_INT 35
98407: PPUSH
98408: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98412: LD_VAR 0 1
98416: PPUSH
98417: LD_VAR 0 2
98421: PPUSH
98422: LD_VAR 0 3
98426: PPUSH
98427: CALL 48730 0 3
98431: NOT
98432: IFFALSE 98436
// exit ;
98434: GO 98690
// until GetDistUnitXY ( unit , x , y ) < dist ;
98436: LD_VAR 0 1
98440: PPUSH
98441: LD_VAR 0 2
98445: PPUSH
98446: LD_VAR 0 3
98450: PPUSH
98451: CALL_OW 297
98455: PUSH
98456: LD_VAR 0 5
98460: LESS
98461: IFFALSE 98405
// end ; ComTurnXY ( unit , x , y ) ;
98463: LD_VAR 0 1
98467: PPUSH
98468: LD_VAR 0 2
98472: PPUSH
98473: LD_VAR 0 3
98477: PPUSH
98478: CALL_OW 118
// wait ( 5 ) ;
98482: LD_INT 5
98484: PPUSH
98485: CALL_OW 67
// _d := GetDir ( unit ) ;
98489: LD_ADDR_VAR 0 10
98493: PUSH
98494: LD_VAR 0 1
98498: PPUSH
98499: CALL_OW 254
98503: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
98504: LD_ADDR_VAR 0 8
98508: PUSH
98509: LD_VAR 0 1
98513: PPUSH
98514: CALL_OW 250
98518: PPUSH
98519: LD_VAR 0 10
98523: PPUSH
98524: LD_VAR 0 5
98528: PPUSH
98529: CALL_OW 272
98533: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
98534: LD_ADDR_VAR 0 9
98538: PUSH
98539: LD_VAR 0 1
98543: PPUSH
98544: CALL_OW 251
98548: PPUSH
98549: LD_VAR 0 10
98553: PPUSH
98554: LD_VAR 0 5
98558: PPUSH
98559: CALL_OW 273
98563: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98564: LD_VAR 0 8
98568: PPUSH
98569: LD_VAR 0 9
98573: PPUSH
98574: CALL_OW 488
98578: NOT
98579: IFFALSE 98583
// exit ;
98581: GO 98690
// ComAnimCustom ( unit , 1 ) ;
98583: LD_VAR 0 1
98587: PPUSH
98588: LD_INT 1
98590: PPUSH
98591: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98595: LD_VAR 0 8
98599: PPUSH
98600: LD_VAR 0 9
98604: PPUSH
98605: LD_VAR 0 6
98609: PPUSH
98610: LD_VAR 0 7
98614: PPUSH
98615: CALL_OW 330
// repeat wait ( 1 ) ;
98619: LD_INT 1
98621: PPUSH
98622: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
98626: LD_VAR 0 1
98630: PPUSH
98631: CALL_OW 316
98635: PUSH
98636: LD_VAR 0 1
98640: PPUSH
98641: CALL_OW 314
98645: OR
98646: PUSH
98647: LD_VAR 0 1
98651: PPUSH
98652: CALL_OW 302
98656: NOT
98657: OR
98658: PUSH
98659: LD_VAR 0 1
98663: PPUSH
98664: CALL_OW 301
98668: OR
98669: IFFALSE 98619
// RemoveSeeing ( _x , _y , side ) ;
98671: LD_VAR 0 8
98675: PPUSH
98676: LD_VAR 0 9
98680: PPUSH
98681: LD_VAR 0 6
98685: PPUSH
98686: CALL_OW 331
// end ; end_of_file
98690: LD_VAR 0 4
98694: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98695: LD_INT 0
98697: PPUSH
98698: PPUSH
98699: PPUSH
98700: PPUSH
98701: PPUSH
98702: PPUSH
98703: PPUSH
98704: PPUSH
98705: PPUSH
98706: PPUSH
98707: PPUSH
98708: PPUSH
98709: PPUSH
98710: PPUSH
98711: PPUSH
98712: PPUSH
98713: PPUSH
98714: PPUSH
98715: PPUSH
98716: PPUSH
98717: PPUSH
98718: PPUSH
98719: PPUSH
98720: PPUSH
98721: PPUSH
98722: PPUSH
98723: PPUSH
98724: PPUSH
98725: PPUSH
98726: PPUSH
98727: PPUSH
98728: PPUSH
98729: PPUSH
98730: PPUSH
// if not list then
98731: LD_VAR 0 1
98735: NOT
98736: IFFALSE 98740
// exit ;
98738: GO 103399
// base := list [ 1 ] ;
98740: LD_ADDR_VAR 0 3
98744: PUSH
98745: LD_VAR 0 1
98749: PUSH
98750: LD_INT 1
98752: ARRAY
98753: ST_TO_ADDR
// group := list [ 2 ] ;
98754: LD_ADDR_VAR 0 4
98758: PUSH
98759: LD_VAR 0 1
98763: PUSH
98764: LD_INT 2
98766: ARRAY
98767: ST_TO_ADDR
// path := list [ 3 ] ;
98768: LD_ADDR_VAR 0 5
98772: PUSH
98773: LD_VAR 0 1
98777: PUSH
98778: LD_INT 3
98780: ARRAY
98781: ST_TO_ADDR
// flags := list [ 4 ] ;
98782: LD_ADDR_VAR 0 6
98786: PUSH
98787: LD_VAR 0 1
98791: PUSH
98792: LD_INT 4
98794: ARRAY
98795: ST_TO_ADDR
// mined := [ ] ;
98796: LD_ADDR_VAR 0 27
98800: PUSH
98801: EMPTY
98802: ST_TO_ADDR
// bombed := [ ] ;
98803: LD_ADDR_VAR 0 28
98807: PUSH
98808: EMPTY
98809: ST_TO_ADDR
// healers := [ ] ;
98810: LD_ADDR_VAR 0 31
98814: PUSH
98815: EMPTY
98816: ST_TO_ADDR
// to_heal := [ ] ;
98817: LD_ADDR_VAR 0 30
98821: PUSH
98822: EMPTY
98823: ST_TO_ADDR
// repairs := [ ] ;
98824: LD_ADDR_VAR 0 33
98828: PUSH
98829: EMPTY
98830: ST_TO_ADDR
// to_repair := [ ] ;
98831: LD_ADDR_VAR 0 32
98835: PUSH
98836: EMPTY
98837: ST_TO_ADDR
// if not group or not path then
98838: LD_VAR 0 4
98842: NOT
98843: PUSH
98844: LD_VAR 0 5
98848: NOT
98849: OR
98850: IFFALSE 98854
// exit ;
98852: GO 103399
// side := GetSide ( group [ 1 ] ) ;
98854: LD_ADDR_VAR 0 35
98858: PUSH
98859: LD_VAR 0 4
98863: PUSH
98864: LD_INT 1
98866: ARRAY
98867: PPUSH
98868: CALL_OW 255
98872: ST_TO_ADDR
// if flags then
98873: LD_VAR 0 6
98877: IFFALSE 99021
// begin f_ignore_area := flags [ 1 ] ;
98879: LD_ADDR_VAR 0 17
98883: PUSH
98884: LD_VAR 0 6
98888: PUSH
98889: LD_INT 1
98891: ARRAY
98892: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98893: LD_ADDR_VAR 0 18
98897: PUSH
98898: LD_VAR 0 6
98902: PUSH
98903: LD_INT 2
98905: ARRAY
98906: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98907: LD_ADDR_VAR 0 19
98911: PUSH
98912: LD_VAR 0 6
98916: PUSH
98917: LD_INT 3
98919: ARRAY
98920: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98921: LD_ADDR_VAR 0 20
98925: PUSH
98926: LD_VAR 0 6
98930: PUSH
98931: LD_INT 4
98933: ARRAY
98934: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98935: LD_ADDR_VAR 0 21
98939: PUSH
98940: LD_VAR 0 6
98944: PUSH
98945: LD_INT 5
98947: ARRAY
98948: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98949: LD_ADDR_VAR 0 22
98953: PUSH
98954: LD_VAR 0 6
98958: PUSH
98959: LD_INT 6
98961: ARRAY
98962: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98963: LD_ADDR_VAR 0 23
98967: PUSH
98968: LD_VAR 0 6
98972: PUSH
98973: LD_INT 7
98975: ARRAY
98976: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98977: LD_ADDR_VAR 0 24
98981: PUSH
98982: LD_VAR 0 6
98986: PUSH
98987: LD_INT 8
98989: ARRAY
98990: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98991: LD_ADDR_VAR 0 25
98995: PUSH
98996: LD_VAR 0 6
99000: PUSH
99001: LD_INT 9
99003: ARRAY
99004: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99005: LD_ADDR_VAR 0 26
99009: PUSH
99010: LD_VAR 0 6
99014: PUSH
99015: LD_INT 10
99017: ARRAY
99018: ST_TO_ADDR
// end else
99019: GO 99101
// begin f_ignore_area := false ;
99021: LD_ADDR_VAR 0 17
99025: PUSH
99026: LD_INT 0
99028: ST_TO_ADDR
// f_capture := false ;
99029: LD_ADDR_VAR 0 18
99033: PUSH
99034: LD_INT 0
99036: ST_TO_ADDR
// f_ignore_civ := false ;
99037: LD_ADDR_VAR 0 19
99041: PUSH
99042: LD_INT 0
99044: ST_TO_ADDR
// f_murder := false ;
99045: LD_ADDR_VAR 0 20
99049: PUSH
99050: LD_INT 0
99052: ST_TO_ADDR
// f_mines := false ;
99053: LD_ADDR_VAR 0 21
99057: PUSH
99058: LD_INT 0
99060: ST_TO_ADDR
// f_repair := false ;
99061: LD_ADDR_VAR 0 22
99065: PUSH
99066: LD_INT 0
99068: ST_TO_ADDR
// f_heal := false ;
99069: LD_ADDR_VAR 0 23
99073: PUSH
99074: LD_INT 0
99076: ST_TO_ADDR
// f_spacetime := false ;
99077: LD_ADDR_VAR 0 24
99081: PUSH
99082: LD_INT 0
99084: ST_TO_ADDR
// f_attack_depot := false ;
99085: LD_ADDR_VAR 0 25
99089: PUSH
99090: LD_INT 0
99092: ST_TO_ADDR
// f_crawl := false ;
99093: LD_ADDR_VAR 0 26
99097: PUSH
99098: LD_INT 0
99100: ST_TO_ADDR
// end ; if f_heal then
99101: LD_VAR 0 23
99105: IFFALSE 99132
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99107: LD_ADDR_VAR 0 31
99111: PUSH
99112: LD_VAR 0 4
99116: PPUSH
99117: LD_INT 25
99119: PUSH
99120: LD_INT 4
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PPUSH
99127: CALL_OW 72
99131: ST_TO_ADDR
// if f_repair then
99132: LD_VAR 0 22
99136: IFFALSE 99163
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99138: LD_ADDR_VAR 0 33
99142: PUSH
99143: LD_VAR 0 4
99147: PPUSH
99148: LD_INT 25
99150: PUSH
99151: LD_INT 3
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PPUSH
99158: CALL_OW 72
99162: ST_TO_ADDR
// units_path := [ ] ;
99163: LD_ADDR_VAR 0 16
99167: PUSH
99168: EMPTY
99169: ST_TO_ADDR
// for i = 1 to group do
99170: LD_ADDR_VAR 0 7
99174: PUSH
99175: DOUBLE
99176: LD_INT 1
99178: DEC
99179: ST_TO_ADDR
99180: LD_VAR 0 4
99184: PUSH
99185: FOR_TO
99186: IFFALSE 99215
// units_path := Replace ( units_path , i , path ) ;
99188: LD_ADDR_VAR 0 16
99192: PUSH
99193: LD_VAR 0 16
99197: PPUSH
99198: LD_VAR 0 7
99202: PPUSH
99203: LD_VAR 0 5
99207: PPUSH
99208: CALL_OW 1
99212: ST_TO_ADDR
99213: GO 99185
99215: POP
99216: POP
// repeat for i = group downto 1 do
99217: LD_ADDR_VAR 0 7
99221: PUSH
99222: DOUBLE
99223: LD_VAR 0 4
99227: INC
99228: ST_TO_ADDR
99229: LD_INT 1
99231: PUSH
99232: FOR_DOWNTO
99233: IFFALSE 103355
// begin wait ( 5 ) ;
99235: LD_INT 5
99237: PPUSH
99238: CALL_OW 67
// tmp := [ ] ;
99242: LD_ADDR_VAR 0 14
99246: PUSH
99247: EMPTY
99248: ST_TO_ADDR
// attacking := false ;
99249: LD_ADDR_VAR 0 29
99253: PUSH
99254: LD_INT 0
99256: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99257: LD_VAR 0 4
99261: PUSH
99262: LD_VAR 0 7
99266: ARRAY
99267: PPUSH
99268: CALL_OW 301
99272: PUSH
99273: LD_VAR 0 4
99277: PUSH
99278: LD_VAR 0 7
99282: ARRAY
99283: NOT
99284: OR
99285: IFFALSE 99394
// begin if GetType ( group [ i ] ) = unit_human then
99287: LD_VAR 0 4
99291: PUSH
99292: LD_VAR 0 7
99296: ARRAY
99297: PPUSH
99298: CALL_OW 247
99302: PUSH
99303: LD_INT 1
99305: EQUAL
99306: IFFALSE 99352
// begin to_heal := to_heal diff group [ i ] ;
99308: LD_ADDR_VAR 0 30
99312: PUSH
99313: LD_VAR 0 30
99317: PUSH
99318: LD_VAR 0 4
99322: PUSH
99323: LD_VAR 0 7
99327: ARRAY
99328: DIFF
99329: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99330: LD_ADDR_VAR 0 31
99334: PUSH
99335: LD_VAR 0 31
99339: PUSH
99340: LD_VAR 0 4
99344: PUSH
99345: LD_VAR 0 7
99349: ARRAY
99350: DIFF
99351: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99352: LD_ADDR_VAR 0 4
99356: PUSH
99357: LD_VAR 0 4
99361: PPUSH
99362: LD_VAR 0 7
99366: PPUSH
99367: CALL_OW 3
99371: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99372: LD_ADDR_VAR 0 16
99376: PUSH
99377: LD_VAR 0 16
99381: PPUSH
99382: LD_VAR 0 7
99386: PPUSH
99387: CALL_OW 3
99391: ST_TO_ADDR
// continue ;
99392: GO 99232
// end ; if f_repair then
99394: LD_VAR 0 22
99398: IFFALSE 99887
// begin if GetType ( group [ i ] ) = unit_vehicle then
99400: LD_VAR 0 4
99404: PUSH
99405: LD_VAR 0 7
99409: ARRAY
99410: PPUSH
99411: CALL_OW 247
99415: PUSH
99416: LD_INT 2
99418: EQUAL
99419: IFFALSE 99609
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99421: LD_VAR 0 4
99425: PUSH
99426: LD_VAR 0 7
99430: ARRAY
99431: PPUSH
99432: CALL_OW 256
99436: PUSH
99437: LD_INT 700
99439: LESS
99440: PUSH
99441: LD_VAR 0 4
99445: PUSH
99446: LD_VAR 0 7
99450: ARRAY
99451: PUSH
99452: LD_VAR 0 32
99456: IN
99457: NOT
99458: AND
99459: IFFALSE 99483
// to_repair := to_repair union group [ i ] ;
99461: LD_ADDR_VAR 0 32
99465: PUSH
99466: LD_VAR 0 32
99470: PUSH
99471: LD_VAR 0 4
99475: PUSH
99476: LD_VAR 0 7
99480: ARRAY
99481: UNION
99482: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99483: LD_VAR 0 4
99487: PUSH
99488: LD_VAR 0 7
99492: ARRAY
99493: PPUSH
99494: CALL_OW 256
99498: PUSH
99499: LD_INT 1000
99501: EQUAL
99502: PUSH
99503: LD_VAR 0 4
99507: PUSH
99508: LD_VAR 0 7
99512: ARRAY
99513: PUSH
99514: LD_VAR 0 32
99518: IN
99519: AND
99520: IFFALSE 99544
// to_repair := to_repair diff group [ i ] ;
99522: LD_ADDR_VAR 0 32
99526: PUSH
99527: LD_VAR 0 32
99531: PUSH
99532: LD_VAR 0 4
99536: PUSH
99537: LD_VAR 0 7
99541: ARRAY
99542: DIFF
99543: ST_TO_ADDR
// if group [ i ] in to_repair then
99544: LD_VAR 0 4
99548: PUSH
99549: LD_VAR 0 7
99553: ARRAY
99554: PUSH
99555: LD_VAR 0 32
99559: IN
99560: IFFALSE 99607
// begin if not IsInArea ( group [ i ] , f_repair ) then
99562: LD_VAR 0 4
99566: PUSH
99567: LD_VAR 0 7
99571: ARRAY
99572: PPUSH
99573: LD_VAR 0 22
99577: PPUSH
99578: CALL_OW 308
99582: NOT
99583: IFFALSE 99605
// ComMoveToArea ( group [ i ] , f_repair ) ;
99585: LD_VAR 0 4
99589: PUSH
99590: LD_VAR 0 7
99594: ARRAY
99595: PPUSH
99596: LD_VAR 0 22
99600: PPUSH
99601: CALL_OW 113
// continue ;
99605: GO 99232
// end ; end else
99607: GO 99887
// if group [ i ] in repairs then
99609: LD_VAR 0 4
99613: PUSH
99614: LD_VAR 0 7
99618: ARRAY
99619: PUSH
99620: LD_VAR 0 33
99624: IN
99625: IFFALSE 99887
// begin if IsInUnit ( group [ i ] ) then
99627: LD_VAR 0 4
99631: PUSH
99632: LD_VAR 0 7
99636: ARRAY
99637: PPUSH
99638: CALL_OW 310
99642: IFFALSE 99710
// begin z := IsInUnit ( group [ i ] ) ;
99644: LD_ADDR_VAR 0 13
99648: PUSH
99649: LD_VAR 0 4
99653: PUSH
99654: LD_VAR 0 7
99658: ARRAY
99659: PPUSH
99660: CALL_OW 310
99664: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99665: LD_VAR 0 13
99669: PUSH
99670: LD_VAR 0 32
99674: IN
99675: PUSH
99676: LD_VAR 0 13
99680: PPUSH
99681: LD_VAR 0 22
99685: PPUSH
99686: CALL_OW 308
99690: AND
99691: IFFALSE 99708
// ComExitVehicle ( group [ i ] ) ;
99693: LD_VAR 0 4
99697: PUSH
99698: LD_VAR 0 7
99702: ARRAY
99703: PPUSH
99704: CALL_OW 121
// end else
99708: GO 99887
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99710: LD_ADDR_VAR 0 13
99714: PUSH
99715: LD_VAR 0 4
99719: PPUSH
99720: LD_INT 95
99722: PUSH
99723: LD_VAR 0 22
99727: PUSH
99728: EMPTY
99729: LIST
99730: LIST
99731: PUSH
99732: LD_INT 58
99734: PUSH
99735: EMPTY
99736: LIST
99737: PUSH
99738: EMPTY
99739: LIST
99740: LIST
99741: PPUSH
99742: CALL_OW 72
99746: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99747: LD_VAR 0 4
99751: PUSH
99752: LD_VAR 0 7
99756: ARRAY
99757: PPUSH
99758: CALL_OW 314
99762: NOT
99763: IFFALSE 99885
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99765: LD_ADDR_VAR 0 10
99769: PUSH
99770: LD_VAR 0 13
99774: PPUSH
99775: LD_VAR 0 4
99779: PUSH
99780: LD_VAR 0 7
99784: ARRAY
99785: PPUSH
99786: CALL_OW 74
99790: ST_TO_ADDR
// if not x then
99791: LD_VAR 0 10
99795: NOT
99796: IFFALSE 99800
// continue ;
99798: GO 99232
// if GetLives ( x ) < 1000 then
99800: LD_VAR 0 10
99804: PPUSH
99805: CALL_OW 256
99809: PUSH
99810: LD_INT 1000
99812: LESS
99813: IFFALSE 99837
// ComRepairVehicle ( group [ i ] , x ) else
99815: LD_VAR 0 4
99819: PUSH
99820: LD_VAR 0 7
99824: ARRAY
99825: PPUSH
99826: LD_VAR 0 10
99830: PPUSH
99831: CALL_OW 129
99835: GO 99885
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99837: LD_VAR 0 23
99841: PUSH
99842: LD_VAR 0 4
99846: PUSH
99847: LD_VAR 0 7
99851: ARRAY
99852: PPUSH
99853: CALL_OW 256
99857: PUSH
99858: LD_INT 1000
99860: LESS
99861: AND
99862: NOT
99863: IFFALSE 99885
// ComEnterUnit ( group [ i ] , x ) ;
99865: LD_VAR 0 4
99869: PUSH
99870: LD_VAR 0 7
99874: ARRAY
99875: PPUSH
99876: LD_VAR 0 10
99880: PPUSH
99881: CALL_OW 120
// end ; continue ;
99885: GO 99232
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99887: LD_VAR 0 23
99891: PUSH
99892: LD_VAR 0 4
99896: PUSH
99897: LD_VAR 0 7
99901: ARRAY
99902: PPUSH
99903: CALL_OW 247
99907: PUSH
99908: LD_INT 1
99910: EQUAL
99911: AND
99912: IFFALSE 100390
// begin if group [ i ] in healers then
99914: LD_VAR 0 4
99918: PUSH
99919: LD_VAR 0 7
99923: ARRAY
99924: PUSH
99925: LD_VAR 0 31
99929: IN
99930: IFFALSE 100203
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99932: LD_VAR 0 4
99936: PUSH
99937: LD_VAR 0 7
99941: ARRAY
99942: PPUSH
99943: LD_VAR 0 23
99947: PPUSH
99948: CALL_OW 308
99952: NOT
99953: PUSH
99954: LD_VAR 0 4
99958: PUSH
99959: LD_VAR 0 7
99963: ARRAY
99964: PPUSH
99965: CALL_OW 314
99969: NOT
99970: AND
99971: IFFALSE 99995
// ComMoveToArea ( group [ i ] , f_heal ) else
99973: LD_VAR 0 4
99977: PUSH
99978: LD_VAR 0 7
99982: ARRAY
99983: PPUSH
99984: LD_VAR 0 23
99988: PPUSH
99989: CALL_OW 113
99993: GO 100201
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99995: LD_VAR 0 4
99999: PUSH
100000: LD_VAR 0 7
100004: ARRAY
100005: PPUSH
100006: CALL 47253 0 1
100010: PPUSH
100011: CALL_OW 256
100015: PUSH
100016: LD_INT 1000
100018: EQUAL
100019: IFFALSE 100038
// ComStop ( group [ i ] ) else
100021: LD_VAR 0 4
100025: PUSH
100026: LD_VAR 0 7
100030: ARRAY
100031: PPUSH
100032: CALL_OW 141
100036: GO 100201
// if not HasTask ( group [ i ] ) and to_heal then
100038: LD_VAR 0 4
100042: PUSH
100043: LD_VAR 0 7
100047: ARRAY
100048: PPUSH
100049: CALL_OW 314
100053: NOT
100054: PUSH
100055: LD_VAR 0 30
100059: AND
100060: IFFALSE 100201
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100062: LD_ADDR_VAR 0 13
100066: PUSH
100067: LD_VAR 0 30
100071: PPUSH
100072: LD_INT 3
100074: PUSH
100075: LD_INT 54
100077: PUSH
100078: EMPTY
100079: LIST
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: PPUSH
100085: CALL_OW 72
100089: PPUSH
100090: LD_VAR 0 4
100094: PUSH
100095: LD_VAR 0 7
100099: ARRAY
100100: PPUSH
100101: CALL_OW 74
100105: ST_TO_ADDR
// if z then
100106: LD_VAR 0 13
100110: IFFALSE 100201
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100112: LD_INT 91
100114: PUSH
100115: LD_VAR 0 13
100119: PUSH
100120: LD_INT 10
100122: PUSH
100123: EMPTY
100124: LIST
100125: LIST
100126: LIST
100127: PUSH
100128: LD_INT 81
100130: PUSH
100131: LD_VAR 0 13
100135: PPUSH
100136: CALL_OW 255
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: PUSH
100145: EMPTY
100146: LIST
100147: LIST
100148: PPUSH
100149: CALL_OW 69
100153: PUSH
100154: LD_INT 0
100156: EQUAL
100157: IFFALSE 100181
// ComHeal ( group [ i ] , z ) else
100159: LD_VAR 0 4
100163: PUSH
100164: LD_VAR 0 7
100168: ARRAY
100169: PPUSH
100170: LD_VAR 0 13
100174: PPUSH
100175: CALL_OW 128
100179: GO 100201
// ComMoveToArea ( group [ i ] , f_heal ) ;
100181: LD_VAR 0 4
100185: PUSH
100186: LD_VAR 0 7
100190: ARRAY
100191: PPUSH
100192: LD_VAR 0 23
100196: PPUSH
100197: CALL_OW 113
// end ; continue ;
100201: GO 99232
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100203: LD_VAR 0 4
100207: PUSH
100208: LD_VAR 0 7
100212: ARRAY
100213: PPUSH
100214: CALL_OW 256
100218: PUSH
100219: LD_INT 700
100221: LESS
100222: PUSH
100223: LD_VAR 0 4
100227: PUSH
100228: LD_VAR 0 7
100232: ARRAY
100233: PUSH
100234: LD_VAR 0 30
100238: IN
100239: NOT
100240: AND
100241: IFFALSE 100265
// to_heal := to_heal union group [ i ] ;
100243: LD_ADDR_VAR 0 30
100247: PUSH
100248: LD_VAR 0 30
100252: PUSH
100253: LD_VAR 0 4
100257: PUSH
100258: LD_VAR 0 7
100262: ARRAY
100263: UNION
100264: ST_TO_ADDR
// if group [ i ] in to_heal then
100265: LD_VAR 0 4
100269: PUSH
100270: LD_VAR 0 7
100274: ARRAY
100275: PUSH
100276: LD_VAR 0 30
100280: IN
100281: IFFALSE 100390
// begin if GetLives ( group [ i ] ) = 1000 then
100283: LD_VAR 0 4
100287: PUSH
100288: LD_VAR 0 7
100292: ARRAY
100293: PPUSH
100294: CALL_OW 256
100298: PUSH
100299: LD_INT 1000
100301: EQUAL
100302: IFFALSE 100328
// to_heal := to_heal diff group [ i ] else
100304: LD_ADDR_VAR 0 30
100308: PUSH
100309: LD_VAR 0 30
100313: PUSH
100314: LD_VAR 0 4
100318: PUSH
100319: LD_VAR 0 7
100323: ARRAY
100324: DIFF
100325: ST_TO_ADDR
100326: GO 100390
// begin if not IsInArea ( group [ i ] , to_heal ) then
100328: LD_VAR 0 4
100332: PUSH
100333: LD_VAR 0 7
100337: ARRAY
100338: PPUSH
100339: LD_VAR 0 30
100343: PPUSH
100344: CALL_OW 308
100348: NOT
100349: IFFALSE 100373
// ComMoveToArea ( group [ i ] , f_heal ) else
100351: LD_VAR 0 4
100355: PUSH
100356: LD_VAR 0 7
100360: ARRAY
100361: PPUSH
100362: LD_VAR 0 23
100366: PPUSH
100367: CALL_OW 113
100371: GO 100388
// ComHold ( group [ i ] ) ;
100373: LD_VAR 0 4
100377: PUSH
100378: LD_VAR 0 7
100382: ARRAY
100383: PPUSH
100384: CALL_OW 140
// continue ;
100388: GO 99232
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100390: LD_VAR 0 4
100394: PUSH
100395: LD_VAR 0 7
100399: ARRAY
100400: PPUSH
100401: LD_INT 10
100403: PPUSH
100404: CALL 45673 0 2
100408: NOT
100409: PUSH
100410: LD_VAR 0 16
100414: PUSH
100415: LD_VAR 0 7
100419: ARRAY
100420: PUSH
100421: EMPTY
100422: EQUAL
100423: NOT
100424: AND
100425: IFFALSE 100691
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100427: LD_VAR 0 4
100431: PUSH
100432: LD_VAR 0 7
100436: ARRAY
100437: PPUSH
100438: CALL_OW 262
100442: PUSH
100443: LD_INT 1
100445: PUSH
100446: LD_INT 2
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: IN
100453: IFFALSE 100494
// if GetFuel ( group [ i ] ) < 10 then
100455: LD_VAR 0 4
100459: PUSH
100460: LD_VAR 0 7
100464: ARRAY
100465: PPUSH
100466: CALL_OW 261
100470: PUSH
100471: LD_INT 10
100473: LESS
100474: IFFALSE 100494
// SetFuel ( group [ i ] , 12 ) ;
100476: LD_VAR 0 4
100480: PUSH
100481: LD_VAR 0 7
100485: ARRAY
100486: PPUSH
100487: LD_INT 12
100489: PPUSH
100490: CALL_OW 240
// if units_path [ i ] then
100494: LD_VAR 0 16
100498: PUSH
100499: LD_VAR 0 7
100503: ARRAY
100504: IFFALSE 100689
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100506: LD_VAR 0 4
100510: PUSH
100511: LD_VAR 0 7
100515: ARRAY
100516: PPUSH
100517: LD_VAR 0 16
100521: PUSH
100522: LD_VAR 0 7
100526: ARRAY
100527: PUSH
100528: LD_INT 1
100530: ARRAY
100531: PUSH
100532: LD_INT 1
100534: ARRAY
100535: PPUSH
100536: LD_VAR 0 16
100540: PUSH
100541: LD_VAR 0 7
100545: ARRAY
100546: PUSH
100547: LD_INT 1
100549: ARRAY
100550: PUSH
100551: LD_INT 2
100553: ARRAY
100554: PPUSH
100555: CALL_OW 297
100559: PUSH
100560: LD_INT 6
100562: GREATER
100563: IFFALSE 100638
// begin if not HasTask ( group [ i ] ) then
100565: LD_VAR 0 4
100569: PUSH
100570: LD_VAR 0 7
100574: ARRAY
100575: PPUSH
100576: CALL_OW 314
100580: NOT
100581: IFFALSE 100636
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100583: LD_VAR 0 4
100587: PUSH
100588: LD_VAR 0 7
100592: ARRAY
100593: PPUSH
100594: LD_VAR 0 16
100598: PUSH
100599: LD_VAR 0 7
100603: ARRAY
100604: PUSH
100605: LD_INT 1
100607: ARRAY
100608: PUSH
100609: LD_INT 1
100611: ARRAY
100612: PPUSH
100613: LD_VAR 0 16
100617: PUSH
100618: LD_VAR 0 7
100622: ARRAY
100623: PUSH
100624: LD_INT 1
100626: ARRAY
100627: PUSH
100628: LD_INT 2
100630: ARRAY
100631: PPUSH
100632: CALL_OW 114
// end else
100636: GO 100689
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100638: LD_ADDR_VAR 0 15
100642: PUSH
100643: LD_VAR 0 16
100647: PUSH
100648: LD_VAR 0 7
100652: ARRAY
100653: PPUSH
100654: LD_INT 1
100656: PPUSH
100657: CALL_OW 3
100661: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100662: LD_ADDR_VAR 0 16
100666: PUSH
100667: LD_VAR 0 16
100671: PPUSH
100672: LD_VAR 0 7
100676: PPUSH
100677: LD_VAR 0 15
100681: PPUSH
100682: CALL_OW 1
100686: ST_TO_ADDR
// continue ;
100687: GO 99232
// end ; end ; end else
100689: GO 103353
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100691: LD_ADDR_VAR 0 14
100695: PUSH
100696: LD_INT 81
100698: PUSH
100699: LD_VAR 0 4
100703: PUSH
100704: LD_VAR 0 7
100708: ARRAY
100709: PPUSH
100710: CALL_OW 255
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: PPUSH
100719: CALL_OW 69
100723: ST_TO_ADDR
// if not tmp then
100724: LD_VAR 0 14
100728: NOT
100729: IFFALSE 100733
// continue ;
100731: GO 99232
// if f_ignore_area then
100733: LD_VAR 0 17
100737: IFFALSE 100825
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100739: LD_ADDR_VAR 0 15
100743: PUSH
100744: LD_VAR 0 14
100748: PPUSH
100749: LD_INT 3
100751: PUSH
100752: LD_INT 92
100754: PUSH
100755: LD_VAR 0 17
100759: PUSH
100760: LD_INT 1
100762: ARRAY
100763: PUSH
100764: LD_VAR 0 17
100768: PUSH
100769: LD_INT 2
100771: ARRAY
100772: PUSH
100773: LD_VAR 0 17
100777: PUSH
100778: LD_INT 3
100780: ARRAY
100781: PUSH
100782: EMPTY
100783: LIST
100784: LIST
100785: LIST
100786: LIST
100787: PUSH
100788: EMPTY
100789: LIST
100790: LIST
100791: PPUSH
100792: CALL_OW 72
100796: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100797: LD_VAR 0 14
100801: PUSH
100802: LD_VAR 0 15
100806: DIFF
100807: IFFALSE 100825
// tmp := tmp diff tmp2 ;
100809: LD_ADDR_VAR 0 14
100813: PUSH
100814: LD_VAR 0 14
100818: PUSH
100819: LD_VAR 0 15
100823: DIFF
100824: ST_TO_ADDR
// end ; if not f_murder then
100825: LD_VAR 0 20
100829: NOT
100830: IFFALSE 100888
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100832: LD_ADDR_VAR 0 15
100836: PUSH
100837: LD_VAR 0 14
100841: PPUSH
100842: LD_INT 3
100844: PUSH
100845: LD_INT 50
100847: PUSH
100848: EMPTY
100849: LIST
100850: PUSH
100851: EMPTY
100852: LIST
100853: LIST
100854: PPUSH
100855: CALL_OW 72
100859: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100860: LD_VAR 0 14
100864: PUSH
100865: LD_VAR 0 15
100869: DIFF
100870: IFFALSE 100888
// tmp := tmp diff tmp2 ;
100872: LD_ADDR_VAR 0 14
100876: PUSH
100877: LD_VAR 0 14
100881: PUSH
100882: LD_VAR 0 15
100886: DIFF
100887: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100888: LD_ADDR_VAR 0 14
100892: PUSH
100893: LD_VAR 0 4
100897: PUSH
100898: LD_VAR 0 7
100902: ARRAY
100903: PPUSH
100904: LD_VAR 0 14
100908: PPUSH
100909: LD_INT 1
100911: PPUSH
100912: LD_INT 1
100914: PPUSH
100915: CALL 18983 0 4
100919: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100920: LD_VAR 0 4
100924: PUSH
100925: LD_VAR 0 7
100929: ARRAY
100930: PPUSH
100931: CALL_OW 257
100935: PUSH
100936: LD_INT 1
100938: EQUAL
100939: IFFALSE 101387
// begin if WantPlant ( group [ i ] ) then
100941: LD_VAR 0 4
100945: PUSH
100946: LD_VAR 0 7
100950: ARRAY
100951: PPUSH
100952: CALL 18484 0 1
100956: IFFALSE 100960
// continue ;
100958: GO 99232
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100960: LD_VAR 0 18
100964: PUSH
100965: LD_VAR 0 4
100969: PUSH
100970: LD_VAR 0 7
100974: ARRAY
100975: PPUSH
100976: CALL_OW 310
100980: NOT
100981: AND
100982: PUSH
100983: LD_VAR 0 14
100987: PUSH
100988: LD_INT 1
100990: ARRAY
100991: PUSH
100992: LD_VAR 0 14
100996: PPUSH
100997: LD_INT 21
100999: PUSH
101000: LD_INT 2
101002: PUSH
101003: EMPTY
101004: LIST
101005: LIST
101006: PUSH
101007: LD_INT 58
101009: PUSH
101010: EMPTY
101011: LIST
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PPUSH
101017: CALL_OW 72
101021: IN
101022: AND
101023: IFFALSE 101059
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101025: LD_VAR 0 4
101029: PUSH
101030: LD_VAR 0 7
101034: ARRAY
101035: PPUSH
101036: LD_VAR 0 14
101040: PUSH
101041: LD_INT 1
101043: ARRAY
101044: PPUSH
101045: CALL_OW 120
// attacking := true ;
101049: LD_ADDR_VAR 0 29
101053: PUSH
101054: LD_INT 1
101056: ST_TO_ADDR
// continue ;
101057: GO 99232
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101059: LD_VAR 0 26
101063: PUSH
101064: LD_VAR 0 4
101068: PUSH
101069: LD_VAR 0 7
101073: ARRAY
101074: PPUSH
101075: CALL_OW 257
101079: PUSH
101080: LD_INT 1
101082: EQUAL
101083: AND
101084: PUSH
101085: LD_VAR 0 4
101089: PUSH
101090: LD_VAR 0 7
101094: ARRAY
101095: PPUSH
101096: CALL_OW 256
101100: PUSH
101101: LD_INT 800
101103: LESS
101104: AND
101105: PUSH
101106: LD_VAR 0 4
101110: PUSH
101111: LD_VAR 0 7
101115: ARRAY
101116: PPUSH
101117: CALL_OW 318
101121: NOT
101122: AND
101123: IFFALSE 101140
// ComCrawl ( group [ i ] ) ;
101125: LD_VAR 0 4
101129: PUSH
101130: LD_VAR 0 7
101134: ARRAY
101135: PPUSH
101136: CALL_OW 137
// if f_mines then
101140: LD_VAR 0 21
101144: IFFALSE 101387
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101146: LD_VAR 0 14
101150: PUSH
101151: LD_INT 1
101153: ARRAY
101154: PPUSH
101155: CALL_OW 247
101159: PUSH
101160: LD_INT 3
101162: EQUAL
101163: PUSH
101164: LD_VAR 0 14
101168: PUSH
101169: LD_INT 1
101171: ARRAY
101172: PUSH
101173: LD_VAR 0 27
101177: IN
101178: NOT
101179: AND
101180: IFFALSE 101387
// begin x := GetX ( tmp [ 1 ] ) ;
101182: LD_ADDR_VAR 0 10
101186: PUSH
101187: LD_VAR 0 14
101191: PUSH
101192: LD_INT 1
101194: ARRAY
101195: PPUSH
101196: CALL_OW 250
101200: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101201: LD_ADDR_VAR 0 11
101205: PUSH
101206: LD_VAR 0 14
101210: PUSH
101211: LD_INT 1
101213: ARRAY
101214: PPUSH
101215: CALL_OW 251
101219: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101220: LD_ADDR_VAR 0 12
101224: PUSH
101225: LD_VAR 0 4
101229: PUSH
101230: LD_VAR 0 7
101234: ARRAY
101235: PPUSH
101236: CALL 45758 0 1
101240: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101241: LD_VAR 0 4
101245: PUSH
101246: LD_VAR 0 7
101250: ARRAY
101251: PPUSH
101252: LD_VAR 0 10
101256: PPUSH
101257: LD_VAR 0 11
101261: PPUSH
101262: LD_VAR 0 14
101266: PUSH
101267: LD_INT 1
101269: ARRAY
101270: PPUSH
101271: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101275: LD_VAR 0 4
101279: PUSH
101280: LD_VAR 0 7
101284: ARRAY
101285: PPUSH
101286: LD_VAR 0 10
101290: PPUSH
101291: LD_VAR 0 12
101295: PPUSH
101296: LD_INT 7
101298: PPUSH
101299: CALL_OW 272
101303: PPUSH
101304: LD_VAR 0 11
101308: PPUSH
101309: LD_VAR 0 12
101313: PPUSH
101314: LD_INT 7
101316: PPUSH
101317: CALL_OW 273
101321: PPUSH
101322: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101326: LD_VAR 0 4
101330: PUSH
101331: LD_VAR 0 7
101335: ARRAY
101336: PPUSH
101337: LD_INT 71
101339: PPUSH
101340: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101344: LD_ADDR_VAR 0 27
101348: PUSH
101349: LD_VAR 0 27
101353: PPUSH
101354: LD_VAR 0 27
101358: PUSH
101359: LD_INT 1
101361: PLUS
101362: PPUSH
101363: LD_VAR 0 14
101367: PUSH
101368: LD_INT 1
101370: ARRAY
101371: PPUSH
101372: CALL_OW 1
101376: ST_TO_ADDR
// attacking := true ;
101377: LD_ADDR_VAR 0 29
101381: PUSH
101382: LD_INT 1
101384: ST_TO_ADDR
// continue ;
101385: GO 99232
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101387: LD_VAR 0 4
101391: PUSH
101392: LD_VAR 0 7
101396: ARRAY
101397: PPUSH
101398: CALL_OW 257
101402: PUSH
101403: LD_INT 17
101405: EQUAL
101406: PUSH
101407: LD_VAR 0 4
101411: PUSH
101412: LD_VAR 0 7
101416: ARRAY
101417: PPUSH
101418: CALL_OW 110
101422: PUSH
101423: LD_INT 71
101425: EQUAL
101426: NOT
101427: AND
101428: IFFALSE 101574
// begin attacking := false ;
101430: LD_ADDR_VAR 0 29
101434: PUSH
101435: LD_INT 0
101437: ST_TO_ADDR
// k := 5 ;
101438: LD_ADDR_VAR 0 9
101442: PUSH
101443: LD_INT 5
101445: ST_TO_ADDR
// if tmp < k then
101446: LD_VAR 0 14
101450: PUSH
101451: LD_VAR 0 9
101455: LESS
101456: IFFALSE 101468
// k := tmp ;
101458: LD_ADDR_VAR 0 9
101462: PUSH
101463: LD_VAR 0 14
101467: ST_TO_ADDR
// for j = 1 to k do
101468: LD_ADDR_VAR 0 8
101472: PUSH
101473: DOUBLE
101474: LD_INT 1
101476: DEC
101477: ST_TO_ADDR
101478: LD_VAR 0 9
101482: PUSH
101483: FOR_TO
101484: IFFALSE 101572
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101486: LD_VAR 0 14
101490: PUSH
101491: LD_VAR 0 8
101495: ARRAY
101496: PUSH
101497: LD_VAR 0 14
101501: PPUSH
101502: LD_INT 58
101504: PUSH
101505: EMPTY
101506: LIST
101507: PPUSH
101508: CALL_OW 72
101512: IN
101513: NOT
101514: IFFALSE 101570
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101516: LD_VAR 0 4
101520: PUSH
101521: LD_VAR 0 7
101525: ARRAY
101526: PPUSH
101527: LD_VAR 0 14
101531: PUSH
101532: LD_VAR 0 8
101536: ARRAY
101537: PPUSH
101538: CALL_OW 115
// attacking := true ;
101542: LD_ADDR_VAR 0 29
101546: PUSH
101547: LD_INT 1
101549: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101550: LD_VAR 0 4
101554: PUSH
101555: LD_VAR 0 7
101559: ARRAY
101560: PPUSH
101561: LD_INT 71
101563: PPUSH
101564: CALL_OW 109
// continue ;
101568: GO 101483
// end ; end ;
101570: GO 101483
101572: POP
101573: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101574: LD_VAR 0 4
101578: PUSH
101579: LD_VAR 0 7
101583: ARRAY
101584: PPUSH
101585: CALL_OW 257
101589: PUSH
101590: LD_INT 8
101592: EQUAL
101593: PUSH
101594: LD_VAR 0 4
101598: PUSH
101599: LD_VAR 0 7
101603: ARRAY
101604: PPUSH
101605: CALL_OW 264
101609: PUSH
101610: LD_INT 28
101612: PUSH
101613: LD_INT 45
101615: PUSH
101616: LD_INT 7
101618: PUSH
101619: LD_INT 47
101621: PUSH
101622: EMPTY
101623: LIST
101624: LIST
101625: LIST
101626: LIST
101627: IN
101628: OR
101629: IFFALSE 101885
// begin attacking := false ;
101631: LD_ADDR_VAR 0 29
101635: PUSH
101636: LD_INT 0
101638: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101639: LD_VAR 0 14
101643: PUSH
101644: LD_INT 1
101646: ARRAY
101647: PPUSH
101648: CALL_OW 266
101652: PUSH
101653: LD_INT 32
101655: PUSH
101656: LD_INT 31
101658: PUSH
101659: LD_INT 33
101661: PUSH
101662: LD_INT 4
101664: PUSH
101665: LD_INT 5
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: LIST
101674: IN
101675: IFFALSE 101861
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101677: LD_ADDR_VAR 0 9
101681: PUSH
101682: LD_VAR 0 14
101686: PUSH
101687: LD_INT 1
101689: ARRAY
101690: PPUSH
101691: CALL_OW 266
101695: PPUSH
101696: LD_VAR 0 14
101700: PUSH
101701: LD_INT 1
101703: ARRAY
101704: PPUSH
101705: CALL_OW 250
101709: PPUSH
101710: LD_VAR 0 14
101714: PUSH
101715: LD_INT 1
101717: ARRAY
101718: PPUSH
101719: CALL_OW 251
101723: PPUSH
101724: LD_VAR 0 14
101728: PUSH
101729: LD_INT 1
101731: ARRAY
101732: PPUSH
101733: CALL_OW 254
101737: PPUSH
101738: LD_VAR 0 14
101742: PUSH
101743: LD_INT 1
101745: ARRAY
101746: PPUSH
101747: CALL_OW 248
101751: PPUSH
101752: LD_INT 0
101754: PPUSH
101755: CALL 27128 0 6
101759: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101760: LD_ADDR_VAR 0 8
101764: PUSH
101765: LD_VAR 0 4
101769: PUSH
101770: LD_VAR 0 7
101774: ARRAY
101775: PPUSH
101776: LD_VAR 0 9
101780: PPUSH
101781: CALL 45798 0 2
101785: ST_TO_ADDR
// if j then
101786: LD_VAR 0 8
101790: IFFALSE 101859
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101792: LD_VAR 0 8
101796: PUSH
101797: LD_INT 1
101799: ARRAY
101800: PPUSH
101801: LD_VAR 0 8
101805: PUSH
101806: LD_INT 2
101808: ARRAY
101809: PPUSH
101810: CALL_OW 488
101814: IFFALSE 101859
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101816: LD_VAR 0 4
101820: PUSH
101821: LD_VAR 0 7
101825: ARRAY
101826: PPUSH
101827: LD_VAR 0 8
101831: PUSH
101832: LD_INT 1
101834: ARRAY
101835: PPUSH
101836: LD_VAR 0 8
101840: PUSH
101841: LD_INT 2
101843: ARRAY
101844: PPUSH
101845: CALL_OW 116
// attacking := true ;
101849: LD_ADDR_VAR 0 29
101853: PUSH
101854: LD_INT 1
101856: ST_TO_ADDR
// continue ;
101857: GO 99232
// end ; end else
101859: GO 101885
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101861: LD_VAR 0 4
101865: PUSH
101866: LD_VAR 0 7
101870: ARRAY
101871: PPUSH
101872: LD_VAR 0 14
101876: PUSH
101877: LD_INT 1
101879: ARRAY
101880: PPUSH
101881: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101885: LD_VAR 0 4
101889: PUSH
101890: LD_VAR 0 7
101894: ARRAY
101895: PPUSH
101896: CALL_OW 265
101900: PUSH
101901: LD_INT 11
101903: EQUAL
101904: IFFALSE 102182
// begin k := 10 ;
101906: LD_ADDR_VAR 0 9
101910: PUSH
101911: LD_INT 10
101913: ST_TO_ADDR
// x := 0 ;
101914: LD_ADDR_VAR 0 10
101918: PUSH
101919: LD_INT 0
101921: ST_TO_ADDR
// if tmp < k then
101922: LD_VAR 0 14
101926: PUSH
101927: LD_VAR 0 9
101931: LESS
101932: IFFALSE 101944
// k := tmp ;
101934: LD_ADDR_VAR 0 9
101938: PUSH
101939: LD_VAR 0 14
101943: ST_TO_ADDR
// for j = k downto 1 do
101944: LD_ADDR_VAR 0 8
101948: PUSH
101949: DOUBLE
101950: LD_VAR 0 9
101954: INC
101955: ST_TO_ADDR
101956: LD_INT 1
101958: PUSH
101959: FOR_DOWNTO
101960: IFFALSE 102035
// begin if GetType ( tmp [ j ] ) = unit_human then
101962: LD_VAR 0 14
101966: PUSH
101967: LD_VAR 0 8
101971: ARRAY
101972: PPUSH
101973: CALL_OW 247
101977: PUSH
101978: LD_INT 1
101980: EQUAL
101981: IFFALSE 102033
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101983: LD_VAR 0 4
101987: PUSH
101988: LD_VAR 0 7
101992: ARRAY
101993: PPUSH
101994: LD_VAR 0 14
101998: PUSH
101999: LD_VAR 0 8
102003: ARRAY
102004: PPUSH
102005: CALL 46069 0 2
// x := tmp [ j ] ;
102009: LD_ADDR_VAR 0 10
102013: PUSH
102014: LD_VAR 0 14
102018: PUSH
102019: LD_VAR 0 8
102023: ARRAY
102024: ST_TO_ADDR
// attacking := true ;
102025: LD_ADDR_VAR 0 29
102029: PUSH
102030: LD_INT 1
102032: ST_TO_ADDR
// end ; end ;
102033: GO 101959
102035: POP
102036: POP
// if not x then
102037: LD_VAR 0 10
102041: NOT
102042: IFFALSE 102182
// begin attacking := true ;
102044: LD_ADDR_VAR 0 29
102048: PUSH
102049: LD_INT 1
102051: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102052: LD_VAR 0 4
102056: PUSH
102057: LD_VAR 0 7
102061: ARRAY
102062: PPUSH
102063: CALL_OW 250
102067: PPUSH
102068: LD_VAR 0 4
102072: PUSH
102073: LD_VAR 0 7
102077: ARRAY
102078: PPUSH
102079: CALL_OW 251
102083: PPUSH
102084: CALL_OW 546
102088: PUSH
102089: LD_INT 2
102091: ARRAY
102092: PUSH
102093: LD_VAR 0 14
102097: PUSH
102098: LD_INT 1
102100: ARRAY
102101: PPUSH
102102: CALL_OW 250
102106: PPUSH
102107: LD_VAR 0 14
102111: PUSH
102112: LD_INT 1
102114: ARRAY
102115: PPUSH
102116: CALL_OW 251
102120: PPUSH
102121: CALL_OW 546
102125: PUSH
102126: LD_INT 2
102128: ARRAY
102129: EQUAL
102130: IFFALSE 102158
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102132: LD_VAR 0 4
102136: PUSH
102137: LD_VAR 0 7
102141: ARRAY
102142: PPUSH
102143: LD_VAR 0 14
102147: PUSH
102148: LD_INT 1
102150: ARRAY
102151: PPUSH
102152: CALL 46069 0 2
102156: GO 102182
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102158: LD_VAR 0 4
102162: PUSH
102163: LD_VAR 0 7
102167: ARRAY
102168: PPUSH
102169: LD_VAR 0 14
102173: PUSH
102174: LD_INT 1
102176: ARRAY
102177: PPUSH
102178: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102182: LD_VAR 0 4
102186: PUSH
102187: LD_VAR 0 7
102191: ARRAY
102192: PPUSH
102193: CALL_OW 264
102197: PUSH
102198: LD_INT 29
102200: EQUAL
102201: IFFALSE 102567
// begin if WantsToAttack ( group [ i ] ) in bombed then
102203: LD_VAR 0 4
102207: PUSH
102208: LD_VAR 0 7
102212: ARRAY
102213: PPUSH
102214: CALL_OW 319
102218: PUSH
102219: LD_VAR 0 28
102223: IN
102224: IFFALSE 102228
// continue ;
102226: GO 99232
// k := 8 ;
102228: LD_ADDR_VAR 0 9
102232: PUSH
102233: LD_INT 8
102235: ST_TO_ADDR
// x := 0 ;
102236: LD_ADDR_VAR 0 10
102240: PUSH
102241: LD_INT 0
102243: ST_TO_ADDR
// if tmp < k then
102244: LD_VAR 0 14
102248: PUSH
102249: LD_VAR 0 9
102253: LESS
102254: IFFALSE 102266
// k := tmp ;
102256: LD_ADDR_VAR 0 9
102260: PUSH
102261: LD_VAR 0 14
102265: ST_TO_ADDR
// for j = 1 to k do
102266: LD_ADDR_VAR 0 8
102270: PUSH
102271: DOUBLE
102272: LD_INT 1
102274: DEC
102275: ST_TO_ADDR
102276: LD_VAR 0 9
102280: PUSH
102281: FOR_TO
102282: IFFALSE 102414
// begin if GetType ( tmp [ j ] ) = unit_building then
102284: LD_VAR 0 14
102288: PUSH
102289: LD_VAR 0 8
102293: ARRAY
102294: PPUSH
102295: CALL_OW 247
102299: PUSH
102300: LD_INT 3
102302: EQUAL
102303: IFFALSE 102412
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102305: LD_VAR 0 14
102309: PUSH
102310: LD_VAR 0 8
102314: ARRAY
102315: PUSH
102316: LD_VAR 0 28
102320: IN
102321: NOT
102322: PUSH
102323: LD_VAR 0 14
102327: PUSH
102328: LD_VAR 0 8
102332: ARRAY
102333: PPUSH
102334: CALL_OW 313
102338: AND
102339: IFFALSE 102412
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102341: LD_VAR 0 4
102345: PUSH
102346: LD_VAR 0 7
102350: ARRAY
102351: PPUSH
102352: LD_VAR 0 14
102356: PUSH
102357: LD_VAR 0 8
102361: ARRAY
102362: PPUSH
102363: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102367: LD_ADDR_VAR 0 28
102371: PUSH
102372: LD_VAR 0 28
102376: PPUSH
102377: LD_VAR 0 28
102381: PUSH
102382: LD_INT 1
102384: PLUS
102385: PPUSH
102386: LD_VAR 0 14
102390: PUSH
102391: LD_VAR 0 8
102395: ARRAY
102396: PPUSH
102397: CALL_OW 1
102401: ST_TO_ADDR
// attacking := true ;
102402: LD_ADDR_VAR 0 29
102406: PUSH
102407: LD_INT 1
102409: ST_TO_ADDR
// break ;
102410: GO 102414
// end ; end ;
102412: GO 102281
102414: POP
102415: POP
// if not attacking and f_attack_depot then
102416: LD_VAR 0 29
102420: NOT
102421: PUSH
102422: LD_VAR 0 25
102426: AND
102427: IFFALSE 102522
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102429: LD_ADDR_VAR 0 13
102433: PUSH
102434: LD_VAR 0 14
102438: PPUSH
102439: LD_INT 2
102441: PUSH
102442: LD_INT 30
102444: PUSH
102445: LD_INT 0
102447: PUSH
102448: EMPTY
102449: LIST
102450: LIST
102451: PUSH
102452: LD_INT 30
102454: PUSH
102455: LD_INT 1
102457: PUSH
102458: EMPTY
102459: LIST
102460: LIST
102461: PUSH
102462: EMPTY
102463: LIST
102464: LIST
102465: LIST
102466: PPUSH
102467: CALL_OW 72
102471: ST_TO_ADDR
// if z then
102472: LD_VAR 0 13
102476: IFFALSE 102522
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102478: LD_VAR 0 4
102482: PUSH
102483: LD_VAR 0 7
102487: ARRAY
102488: PPUSH
102489: LD_VAR 0 13
102493: PPUSH
102494: LD_VAR 0 4
102498: PUSH
102499: LD_VAR 0 7
102503: ARRAY
102504: PPUSH
102505: CALL_OW 74
102509: PPUSH
102510: CALL_OW 115
// attacking := true ;
102514: LD_ADDR_VAR 0 29
102518: PUSH
102519: LD_INT 1
102521: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102522: LD_VAR 0 4
102526: PUSH
102527: LD_VAR 0 7
102531: ARRAY
102532: PPUSH
102533: CALL_OW 256
102537: PUSH
102538: LD_INT 500
102540: LESS
102541: IFFALSE 102567
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102543: LD_VAR 0 4
102547: PUSH
102548: LD_VAR 0 7
102552: ARRAY
102553: PPUSH
102554: LD_VAR 0 14
102558: PUSH
102559: LD_INT 1
102561: ARRAY
102562: PPUSH
102563: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102567: LD_VAR 0 4
102571: PUSH
102572: LD_VAR 0 7
102576: ARRAY
102577: PPUSH
102578: CALL_OW 264
102582: PUSH
102583: LD_INT 49
102585: EQUAL
102586: IFFALSE 102707
// begin if not HasTask ( group [ i ] ) then
102588: LD_VAR 0 4
102592: PUSH
102593: LD_VAR 0 7
102597: ARRAY
102598: PPUSH
102599: CALL_OW 314
102603: NOT
102604: IFFALSE 102707
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102606: LD_ADDR_VAR 0 9
102610: PUSH
102611: LD_INT 81
102613: PUSH
102614: LD_VAR 0 4
102618: PUSH
102619: LD_VAR 0 7
102623: ARRAY
102624: PPUSH
102625: CALL_OW 255
102629: PUSH
102630: EMPTY
102631: LIST
102632: LIST
102633: PPUSH
102634: CALL_OW 69
102638: PPUSH
102639: LD_VAR 0 4
102643: PUSH
102644: LD_VAR 0 7
102648: ARRAY
102649: PPUSH
102650: CALL_OW 74
102654: ST_TO_ADDR
// if k then
102655: LD_VAR 0 9
102659: IFFALSE 102707
// if GetDistUnits ( group [ i ] , k ) > 10 then
102661: LD_VAR 0 4
102665: PUSH
102666: LD_VAR 0 7
102670: ARRAY
102671: PPUSH
102672: LD_VAR 0 9
102676: PPUSH
102677: CALL_OW 296
102681: PUSH
102682: LD_INT 10
102684: GREATER
102685: IFFALSE 102707
// ComMoveUnit ( group [ i ] , k ) ;
102687: LD_VAR 0 4
102691: PUSH
102692: LD_VAR 0 7
102696: ARRAY
102697: PPUSH
102698: LD_VAR 0 9
102702: PPUSH
102703: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102707: LD_VAR 0 4
102711: PUSH
102712: LD_VAR 0 7
102716: ARRAY
102717: PPUSH
102718: CALL_OW 256
102722: PUSH
102723: LD_INT 250
102725: LESS
102726: PUSH
102727: LD_VAR 0 4
102731: PUSH
102732: LD_VAR 0 7
102736: ARRAY
102737: PUSH
102738: LD_INT 21
102740: PUSH
102741: LD_INT 2
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: PUSH
102748: LD_INT 23
102750: PUSH
102751: LD_INT 2
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: PUSH
102758: EMPTY
102759: LIST
102760: LIST
102761: PPUSH
102762: CALL_OW 69
102766: IN
102767: AND
102768: IFFALSE 102893
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102770: LD_ADDR_VAR 0 9
102774: PUSH
102775: LD_OWVAR 3
102779: PUSH
102780: LD_VAR 0 4
102784: PUSH
102785: LD_VAR 0 7
102789: ARRAY
102790: DIFF
102791: PPUSH
102792: LD_VAR 0 4
102796: PUSH
102797: LD_VAR 0 7
102801: ARRAY
102802: PPUSH
102803: CALL_OW 74
102807: ST_TO_ADDR
// if not k then
102808: LD_VAR 0 9
102812: NOT
102813: IFFALSE 102817
// continue ;
102815: GO 99232
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102817: LD_VAR 0 9
102821: PUSH
102822: LD_INT 81
102824: PUSH
102825: LD_VAR 0 4
102829: PUSH
102830: LD_VAR 0 7
102834: ARRAY
102835: PPUSH
102836: CALL_OW 255
102840: PUSH
102841: EMPTY
102842: LIST
102843: LIST
102844: PPUSH
102845: CALL_OW 69
102849: IN
102850: PUSH
102851: LD_VAR 0 9
102855: PPUSH
102856: LD_VAR 0 4
102860: PUSH
102861: LD_VAR 0 7
102865: ARRAY
102866: PPUSH
102867: CALL_OW 296
102871: PUSH
102872: LD_INT 5
102874: LESS
102875: AND
102876: IFFALSE 102893
// ComAutodestruct ( group [ i ] ) ;
102878: LD_VAR 0 4
102882: PUSH
102883: LD_VAR 0 7
102887: ARRAY
102888: PPUSH
102889: CALL 45967 0 1
// end ; if f_attack_depot then
102893: LD_VAR 0 25
102897: IFFALSE 103009
// begin k := 6 ;
102899: LD_ADDR_VAR 0 9
102903: PUSH
102904: LD_INT 6
102906: ST_TO_ADDR
// if tmp < k then
102907: LD_VAR 0 14
102911: PUSH
102912: LD_VAR 0 9
102916: LESS
102917: IFFALSE 102929
// k := tmp ;
102919: LD_ADDR_VAR 0 9
102923: PUSH
102924: LD_VAR 0 14
102928: ST_TO_ADDR
// for j = 1 to k do
102929: LD_ADDR_VAR 0 8
102933: PUSH
102934: DOUBLE
102935: LD_INT 1
102937: DEC
102938: ST_TO_ADDR
102939: LD_VAR 0 9
102943: PUSH
102944: FOR_TO
102945: IFFALSE 103007
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102947: LD_VAR 0 8
102951: PPUSH
102952: CALL_OW 266
102956: PUSH
102957: LD_INT 0
102959: PUSH
102960: LD_INT 1
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: IN
102967: IFFALSE 103005
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102969: LD_VAR 0 4
102973: PUSH
102974: LD_VAR 0 7
102978: ARRAY
102979: PPUSH
102980: LD_VAR 0 14
102984: PUSH
102985: LD_VAR 0 8
102989: ARRAY
102990: PPUSH
102991: CALL_OW 115
// attacking := true ;
102995: LD_ADDR_VAR 0 29
102999: PUSH
103000: LD_INT 1
103002: ST_TO_ADDR
// break ;
103003: GO 103007
// end ;
103005: GO 102944
103007: POP
103008: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103009: LD_VAR 0 4
103013: PUSH
103014: LD_VAR 0 7
103018: ARRAY
103019: PPUSH
103020: CALL_OW 302
103024: PUSH
103025: LD_VAR 0 29
103029: NOT
103030: AND
103031: IFFALSE 103353
// begin if GetTag ( group [ i ] ) = 71 then
103033: LD_VAR 0 4
103037: PUSH
103038: LD_VAR 0 7
103042: ARRAY
103043: PPUSH
103044: CALL_OW 110
103048: PUSH
103049: LD_INT 71
103051: EQUAL
103052: IFFALSE 103093
// begin if HasTask ( group [ i ] ) then
103054: LD_VAR 0 4
103058: PUSH
103059: LD_VAR 0 7
103063: ARRAY
103064: PPUSH
103065: CALL_OW 314
103069: IFFALSE 103075
// continue else
103071: GO 99232
103073: GO 103093
// SetTag ( group [ i ] , 0 ) ;
103075: LD_VAR 0 4
103079: PUSH
103080: LD_VAR 0 7
103084: ARRAY
103085: PPUSH
103086: LD_INT 0
103088: PPUSH
103089: CALL_OW 109
// end ; k := 8 ;
103093: LD_ADDR_VAR 0 9
103097: PUSH
103098: LD_INT 8
103100: ST_TO_ADDR
// x := 0 ;
103101: LD_ADDR_VAR 0 10
103105: PUSH
103106: LD_INT 0
103108: ST_TO_ADDR
// if tmp < k then
103109: LD_VAR 0 14
103113: PUSH
103114: LD_VAR 0 9
103118: LESS
103119: IFFALSE 103131
// k := tmp ;
103121: LD_ADDR_VAR 0 9
103125: PUSH
103126: LD_VAR 0 14
103130: ST_TO_ADDR
// for j = 1 to k do
103131: LD_ADDR_VAR 0 8
103135: PUSH
103136: DOUBLE
103137: LD_INT 1
103139: DEC
103140: ST_TO_ADDR
103141: LD_VAR 0 9
103145: PUSH
103146: FOR_TO
103147: IFFALSE 103245
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103149: LD_VAR 0 14
103153: PUSH
103154: LD_VAR 0 8
103158: ARRAY
103159: PPUSH
103160: CALL_OW 247
103164: PUSH
103165: LD_INT 1
103167: EQUAL
103168: PUSH
103169: LD_VAR 0 14
103173: PUSH
103174: LD_VAR 0 8
103178: ARRAY
103179: PPUSH
103180: CALL_OW 256
103184: PUSH
103185: LD_INT 250
103187: LESS
103188: PUSH
103189: LD_VAR 0 20
103193: AND
103194: PUSH
103195: LD_VAR 0 20
103199: NOT
103200: PUSH
103201: LD_VAR 0 14
103205: PUSH
103206: LD_VAR 0 8
103210: ARRAY
103211: PPUSH
103212: CALL_OW 256
103216: PUSH
103217: LD_INT 250
103219: GREATEREQUAL
103220: AND
103221: OR
103222: AND
103223: IFFALSE 103243
// begin x := tmp [ j ] ;
103225: LD_ADDR_VAR 0 10
103229: PUSH
103230: LD_VAR 0 14
103234: PUSH
103235: LD_VAR 0 8
103239: ARRAY
103240: ST_TO_ADDR
// break ;
103241: GO 103245
// end ;
103243: GO 103146
103245: POP
103246: POP
// if x then
103247: LD_VAR 0 10
103251: IFFALSE 103275
// ComAttackUnit ( group [ i ] , x ) else
103253: LD_VAR 0 4
103257: PUSH
103258: LD_VAR 0 7
103262: ARRAY
103263: PPUSH
103264: LD_VAR 0 10
103268: PPUSH
103269: CALL_OW 115
103273: GO 103299
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103275: LD_VAR 0 4
103279: PUSH
103280: LD_VAR 0 7
103284: ARRAY
103285: PPUSH
103286: LD_VAR 0 14
103290: PUSH
103291: LD_INT 1
103293: ARRAY
103294: PPUSH
103295: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103299: LD_VAR 0 4
103303: PUSH
103304: LD_VAR 0 7
103308: ARRAY
103309: PPUSH
103310: CALL_OW 314
103314: NOT
103315: IFFALSE 103353
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103317: LD_VAR 0 4
103321: PUSH
103322: LD_VAR 0 7
103326: ARRAY
103327: PPUSH
103328: LD_VAR 0 14
103332: PPUSH
103333: LD_VAR 0 4
103337: PUSH
103338: LD_VAR 0 7
103342: ARRAY
103343: PPUSH
103344: CALL_OW 74
103348: PPUSH
103349: CALL_OW 115
// end ; end ; end ;
103353: GO 99232
103355: POP
103356: POP
// wait ( 0 0$2 ) ;
103357: LD_INT 70
103359: PPUSH
103360: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103364: LD_VAR 0 4
103368: NOT
103369: PUSH
103370: LD_VAR 0 4
103374: PUSH
103375: EMPTY
103376: EQUAL
103377: OR
103378: PUSH
103379: LD_INT 81
103381: PUSH
103382: LD_VAR 0 35
103386: PUSH
103387: EMPTY
103388: LIST
103389: LIST
103390: PPUSH
103391: CALL_OW 69
103395: NOT
103396: OR
103397: IFFALSE 99217
// end ;
103399: LD_VAR 0 2
103403: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103404: LD_INT 0
103406: PPUSH
103407: PPUSH
103408: PPUSH
103409: PPUSH
103410: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103411: LD_VAR 0 1
103415: NOT
103416: PUSH
103417: LD_EXP 66
103421: PUSH
103422: LD_VAR 0 1
103426: ARRAY
103427: NOT
103428: OR
103429: PUSH
103430: LD_VAR 0 2
103434: NOT
103435: OR
103436: PUSH
103437: LD_VAR 0 3
103441: NOT
103442: OR
103443: IFFALSE 103447
// exit ;
103445: GO 103960
// side := mc_sides [ base ] ;
103447: LD_ADDR_VAR 0 6
103451: PUSH
103452: LD_EXP 92
103456: PUSH
103457: LD_VAR 0 1
103461: ARRAY
103462: ST_TO_ADDR
// if not side then
103463: LD_VAR 0 6
103467: NOT
103468: IFFALSE 103472
// exit ;
103470: GO 103960
// for i in solds do
103472: LD_ADDR_VAR 0 7
103476: PUSH
103477: LD_VAR 0 2
103481: PUSH
103482: FOR_IN
103483: IFFALSE 103544
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103485: LD_VAR 0 7
103489: PPUSH
103490: CALL_OW 310
103494: PPUSH
103495: CALL_OW 266
103499: PUSH
103500: LD_INT 32
103502: PUSH
103503: LD_INT 31
103505: PUSH
103506: EMPTY
103507: LIST
103508: LIST
103509: IN
103510: IFFALSE 103530
// solds := solds diff i else
103512: LD_ADDR_VAR 0 2
103516: PUSH
103517: LD_VAR 0 2
103521: PUSH
103522: LD_VAR 0 7
103526: DIFF
103527: ST_TO_ADDR
103528: GO 103542
// SetTag ( i , 18 ) ;
103530: LD_VAR 0 7
103534: PPUSH
103535: LD_INT 18
103537: PPUSH
103538: CALL_OW 109
103542: GO 103482
103544: POP
103545: POP
// if not solds then
103546: LD_VAR 0 2
103550: NOT
103551: IFFALSE 103555
// exit ;
103553: GO 103960
// repeat wait ( 0 0$2 ) ;
103555: LD_INT 70
103557: PPUSH
103558: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103562: LD_ADDR_VAR 0 5
103566: PUSH
103567: LD_VAR 0 6
103571: PPUSH
103572: LD_VAR 0 3
103576: PPUSH
103577: CALL 15349 0 2
103581: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103582: LD_EXP 66
103586: PUSH
103587: LD_VAR 0 1
103591: ARRAY
103592: NOT
103593: PUSH
103594: LD_EXP 66
103598: PUSH
103599: LD_VAR 0 1
103603: ARRAY
103604: PUSH
103605: EMPTY
103606: EQUAL
103607: OR
103608: IFFALSE 103645
// begin for i in solds do
103610: LD_ADDR_VAR 0 7
103614: PUSH
103615: LD_VAR 0 2
103619: PUSH
103620: FOR_IN
103621: IFFALSE 103634
// ComStop ( i ) ;
103623: LD_VAR 0 7
103627: PPUSH
103628: CALL_OW 141
103632: GO 103620
103634: POP
103635: POP
// solds := [ ] ;
103636: LD_ADDR_VAR 0 2
103640: PUSH
103641: EMPTY
103642: ST_TO_ADDR
// exit ;
103643: GO 103960
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103645: LD_VAR 0 5
103649: NOT
103650: PUSH
103651: LD_VAR 0 5
103655: PUSH
103656: LD_INT 3
103658: GREATER
103659: OR
103660: PUSH
103661: LD_EXP 88
103665: PUSH
103666: LD_VAR 0 1
103670: ARRAY
103671: OR
103672: IFFALSE 103713
// begin for i in solds do
103674: LD_ADDR_VAR 0 7
103678: PUSH
103679: LD_VAR 0 2
103683: PUSH
103684: FOR_IN
103685: IFFALSE 103709
// if HasTask ( i ) then
103687: LD_VAR 0 7
103691: PPUSH
103692: CALL_OW 314
103696: IFFALSE 103707
// ComStop ( i ) ;
103698: LD_VAR 0 7
103702: PPUSH
103703: CALL_OW 141
103707: GO 103684
103709: POP
103710: POP
// break ;
103711: GO 103948
// end ; for i in solds do
103713: LD_ADDR_VAR 0 7
103717: PUSH
103718: LD_VAR 0 2
103722: PUSH
103723: FOR_IN
103724: IFFALSE 103940
// begin if IsInUnit ( i ) then
103726: LD_VAR 0 7
103730: PPUSH
103731: CALL_OW 310
103735: IFFALSE 103746
// ComExitBuilding ( i ) ;
103737: LD_VAR 0 7
103741: PPUSH
103742: CALL_OW 122
// if GetLives ( i ) > 333 then
103746: LD_VAR 0 7
103750: PPUSH
103751: CALL_OW 256
103755: PUSH
103756: LD_INT 333
103758: GREATER
103759: IFFALSE 103787
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103761: LD_VAR 0 7
103765: PPUSH
103766: LD_VAR 0 5
103770: PPUSH
103771: LD_VAR 0 7
103775: PPUSH
103776: CALL_OW 74
103780: PPUSH
103781: CALL_OW 115
103785: GO 103938
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103787: LD_ADDR_VAR 0 8
103791: PUSH
103792: LD_EXP 66
103796: PUSH
103797: LD_VAR 0 1
103801: ARRAY
103802: PPUSH
103803: LD_INT 2
103805: PUSH
103806: LD_INT 30
103808: PUSH
103809: LD_INT 0
103811: PUSH
103812: EMPTY
103813: LIST
103814: LIST
103815: PUSH
103816: LD_INT 30
103818: PUSH
103819: LD_INT 1
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: PUSH
103826: LD_INT 30
103828: PUSH
103829: LD_INT 6
103831: PUSH
103832: EMPTY
103833: LIST
103834: LIST
103835: PUSH
103836: EMPTY
103837: LIST
103838: LIST
103839: LIST
103840: LIST
103841: PPUSH
103842: CALL_OW 72
103846: PPUSH
103847: LD_VAR 0 7
103851: PPUSH
103852: CALL_OW 74
103856: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103857: LD_VAR 0 7
103861: PPUSH
103862: LD_VAR 0 8
103866: PPUSH
103867: CALL_OW 250
103871: PPUSH
103872: LD_INT 3
103874: PPUSH
103875: LD_INT 5
103877: PPUSH
103878: CALL_OW 272
103882: PPUSH
103883: LD_VAR 0 8
103887: PPUSH
103888: CALL_OW 251
103892: PPUSH
103893: LD_INT 3
103895: PPUSH
103896: LD_INT 5
103898: PPUSH
103899: CALL_OW 273
103903: PPUSH
103904: CALL_OW 111
// SetTag ( i , 0 ) ;
103908: LD_VAR 0 7
103912: PPUSH
103913: LD_INT 0
103915: PPUSH
103916: CALL_OW 109
// solds := solds diff i ;
103920: LD_ADDR_VAR 0 2
103924: PUSH
103925: LD_VAR 0 2
103929: PUSH
103930: LD_VAR 0 7
103934: DIFF
103935: ST_TO_ADDR
// continue ;
103936: GO 103723
// end ; end ;
103938: GO 103723
103940: POP
103941: POP
// until solds ;
103942: LD_VAR 0 2
103946: IFFALSE 103555
// MC_Reset ( base , 18 ) ;
103948: LD_VAR 0 1
103952: PPUSH
103953: LD_INT 18
103955: PPUSH
103956: CALL 55480 0 2
// end ;
103960: LD_VAR 0 4
103964: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
103965: LD_INT 0
103967: PPUSH
103968: PPUSH
103969: PPUSH
103970: PPUSH
103971: PPUSH
103972: PPUSH
103973: PPUSH
103974: PPUSH
103975: PPUSH
103976: PPUSH
103977: PPUSH
103978: PPUSH
103979: PPUSH
103980: PPUSH
103981: PPUSH
103982: PPUSH
103983: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
103984: LD_ADDR_VAR 0 13
103988: PUSH
103989: LD_EXP 66
103993: PUSH
103994: LD_VAR 0 1
103998: ARRAY
103999: PPUSH
104000: LD_INT 25
104002: PUSH
104003: LD_INT 3
104005: PUSH
104006: EMPTY
104007: LIST
104008: LIST
104009: PPUSH
104010: CALL_OW 72
104014: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104015: LD_EXP 106
104019: PUSH
104020: LD_VAR 0 1
104024: ARRAY
104025: IFFALSE 104049
// mechs := mechs diff mc_remote_driver [ base ] ;
104027: LD_ADDR_VAR 0 13
104031: PUSH
104032: LD_VAR 0 13
104036: PUSH
104037: LD_EXP 106
104041: PUSH
104042: LD_VAR 0 1
104046: ARRAY
104047: DIFF
104048: ST_TO_ADDR
// for i in mechs do
104049: LD_ADDR_VAR 0 5
104053: PUSH
104054: LD_VAR 0 13
104058: PUSH
104059: FOR_IN
104060: IFFALSE 104095
// if GetTag ( i ) > 0 then
104062: LD_VAR 0 5
104066: PPUSH
104067: CALL_OW 110
104071: PUSH
104072: LD_INT 0
104074: GREATER
104075: IFFALSE 104093
// mechs := mechs diff i ;
104077: LD_ADDR_VAR 0 13
104081: PUSH
104082: LD_VAR 0 13
104086: PUSH
104087: LD_VAR 0 5
104091: DIFF
104092: ST_TO_ADDR
104093: GO 104059
104095: POP
104096: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104097: LD_ADDR_VAR 0 9
104101: PUSH
104102: LD_EXP 66
104106: PUSH
104107: LD_VAR 0 1
104111: ARRAY
104112: PPUSH
104113: LD_INT 2
104115: PUSH
104116: LD_INT 25
104118: PUSH
104119: LD_INT 1
104121: PUSH
104122: EMPTY
104123: LIST
104124: LIST
104125: PUSH
104126: LD_INT 25
104128: PUSH
104129: LD_INT 5
104131: PUSH
104132: EMPTY
104133: LIST
104134: LIST
104135: PUSH
104136: LD_INT 25
104138: PUSH
104139: LD_INT 8
104141: PUSH
104142: EMPTY
104143: LIST
104144: LIST
104145: PUSH
104146: LD_INT 25
104148: PUSH
104149: LD_INT 9
104151: PUSH
104152: EMPTY
104153: LIST
104154: LIST
104155: PUSH
104156: EMPTY
104157: LIST
104158: LIST
104159: LIST
104160: LIST
104161: LIST
104162: PPUSH
104163: CALL_OW 72
104167: ST_TO_ADDR
// if not defenders and not solds then
104168: LD_VAR 0 2
104172: NOT
104173: PUSH
104174: LD_VAR 0 9
104178: NOT
104179: AND
104180: IFFALSE 104184
// exit ;
104182: GO 105874
// depot_under_attack := false ;
104184: LD_ADDR_VAR 0 17
104188: PUSH
104189: LD_INT 0
104191: ST_TO_ADDR
// sold_defenders := [ ] ;
104192: LD_ADDR_VAR 0 18
104196: PUSH
104197: EMPTY
104198: ST_TO_ADDR
// if mechs then
104199: LD_VAR 0 13
104203: IFFALSE 104356
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
104205: LD_ADDR_VAR 0 5
104209: PUSH
104210: LD_VAR 0 2
104214: PPUSH
104215: LD_INT 21
104217: PUSH
104218: LD_INT 2
104220: PUSH
104221: EMPTY
104222: LIST
104223: LIST
104224: PPUSH
104225: CALL_OW 72
104229: PUSH
104230: FOR_IN
104231: IFFALSE 104354
// begin if GetTag ( i ) <> 20 then
104233: LD_VAR 0 5
104237: PPUSH
104238: CALL_OW 110
104242: PUSH
104243: LD_INT 20
104245: NONEQUAL
104246: IFFALSE 104260
// SetTag ( i , 20 ) ;
104248: LD_VAR 0 5
104252: PPUSH
104253: LD_INT 20
104255: PPUSH
104256: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
104260: LD_VAR 0 5
104264: PPUSH
104265: CALL_OW 263
104269: PUSH
104270: LD_INT 1
104272: EQUAL
104273: PUSH
104274: LD_VAR 0 5
104278: PPUSH
104279: CALL_OW 311
104283: NOT
104284: AND
104285: IFFALSE 104352
// begin un := mechs [ 1 ] ;
104287: LD_ADDR_VAR 0 11
104291: PUSH
104292: LD_VAR 0 13
104296: PUSH
104297: LD_INT 1
104299: ARRAY
104300: ST_TO_ADDR
// ComExit ( un ) ;
104301: LD_VAR 0 11
104305: PPUSH
104306: CALL 50312 0 1
// AddComEnterUnit ( un , i ) ;
104310: LD_VAR 0 11
104314: PPUSH
104315: LD_VAR 0 5
104319: PPUSH
104320: CALL_OW 180
// SetTag ( un , 19 ) ;
104324: LD_VAR 0 11
104328: PPUSH
104329: LD_INT 19
104331: PPUSH
104332: CALL_OW 109
// mechs := mechs diff un ;
104336: LD_ADDR_VAR 0 13
104340: PUSH
104341: LD_VAR 0 13
104345: PUSH
104346: LD_VAR 0 11
104350: DIFF
104351: ST_TO_ADDR
// end ; end ;
104352: GO 104230
104354: POP
104355: POP
// if solds then
104356: LD_VAR 0 9
104360: IFFALSE 104419
// for i in solds do
104362: LD_ADDR_VAR 0 5
104366: PUSH
104367: LD_VAR 0 9
104371: PUSH
104372: FOR_IN
104373: IFFALSE 104417
// if not GetTag ( i ) then
104375: LD_VAR 0 5
104379: PPUSH
104380: CALL_OW 110
104384: NOT
104385: IFFALSE 104415
// begin defenders := defenders union i ;
104387: LD_ADDR_VAR 0 2
104391: PUSH
104392: LD_VAR 0 2
104396: PUSH
104397: LD_VAR 0 5
104401: UNION
104402: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104403: LD_VAR 0 5
104407: PPUSH
104408: LD_INT 18
104410: PPUSH
104411: CALL_OW 109
// end ;
104415: GO 104372
104417: POP
104418: POP
// repeat wait ( 0 0$2 ) ;
104419: LD_INT 70
104421: PPUSH
104422: CALL_OW 67
// enemy := mc_scan [ base ] ;
104426: LD_ADDR_VAR 0 3
104430: PUSH
104431: LD_EXP 89
104435: PUSH
104436: LD_VAR 0 1
104440: ARRAY
104441: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104442: LD_EXP 66
104446: PUSH
104447: LD_VAR 0 1
104451: ARRAY
104452: NOT
104453: PUSH
104454: LD_EXP 66
104458: PUSH
104459: LD_VAR 0 1
104463: ARRAY
104464: PUSH
104465: EMPTY
104466: EQUAL
104467: OR
104468: IFFALSE 104505
// begin for i in defenders do
104470: LD_ADDR_VAR 0 5
104474: PUSH
104475: LD_VAR 0 2
104479: PUSH
104480: FOR_IN
104481: IFFALSE 104494
// ComStop ( i ) ;
104483: LD_VAR 0 5
104487: PPUSH
104488: CALL_OW 141
104492: GO 104480
104494: POP
104495: POP
// defenders := [ ] ;
104496: LD_ADDR_VAR 0 2
104500: PUSH
104501: EMPTY
104502: ST_TO_ADDR
// exit ;
104503: GO 105874
// end ; for i in defenders do
104505: LD_ADDR_VAR 0 5
104509: PUSH
104510: LD_VAR 0 2
104514: PUSH
104515: FOR_IN
104516: IFFALSE 105334
// begin e := NearestUnitToUnit ( enemy , i ) ;
104518: LD_ADDR_VAR 0 14
104522: PUSH
104523: LD_VAR 0 3
104527: PPUSH
104528: LD_VAR 0 5
104532: PPUSH
104533: CALL_OW 74
104537: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104538: LD_ADDR_VAR 0 8
104542: PUSH
104543: LD_EXP 66
104547: PUSH
104548: LD_VAR 0 1
104552: ARRAY
104553: PPUSH
104554: LD_INT 2
104556: PUSH
104557: LD_INT 30
104559: PUSH
104560: LD_INT 0
104562: PUSH
104563: EMPTY
104564: LIST
104565: LIST
104566: PUSH
104567: LD_INT 30
104569: PUSH
104570: LD_INT 1
104572: PUSH
104573: EMPTY
104574: LIST
104575: LIST
104576: PUSH
104577: EMPTY
104578: LIST
104579: LIST
104580: LIST
104581: PPUSH
104582: CALL_OW 72
104586: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104587: LD_ADDR_VAR 0 17
104591: PUSH
104592: LD_VAR 0 8
104596: NOT
104597: PUSH
104598: LD_VAR 0 8
104602: PPUSH
104603: LD_INT 3
104605: PUSH
104606: LD_INT 24
104608: PUSH
104609: LD_INT 600
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: PUSH
104616: EMPTY
104617: LIST
104618: LIST
104619: PPUSH
104620: CALL_OW 72
104624: OR
104625: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104626: LD_VAR 0 5
104630: PPUSH
104631: CALL_OW 247
104635: PUSH
104636: LD_INT 2
104638: DOUBLE
104639: EQUAL
104640: IFTRUE 104644
104642: GO 105040
104644: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104645: LD_VAR 0 5
104649: PPUSH
104650: CALL_OW 256
104654: PUSH
104655: LD_INT 650
104657: GREATER
104658: PUSH
104659: LD_VAR 0 5
104663: PPUSH
104664: LD_VAR 0 14
104668: PPUSH
104669: CALL_OW 296
104673: PUSH
104674: LD_INT 40
104676: LESS
104677: PUSH
104678: LD_VAR 0 14
104682: PPUSH
104683: LD_EXP 91
104687: PUSH
104688: LD_VAR 0 1
104692: ARRAY
104693: PPUSH
104694: CALL_OW 308
104698: OR
104699: AND
104700: IFFALSE 104822
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104702: LD_VAR 0 5
104706: PPUSH
104707: CALL_OW 262
104711: PUSH
104712: LD_INT 1
104714: EQUAL
104715: PUSH
104716: LD_VAR 0 5
104720: PPUSH
104721: CALL_OW 261
104725: PUSH
104726: LD_INT 30
104728: LESS
104729: AND
104730: PUSH
104731: LD_VAR 0 8
104735: AND
104736: IFFALSE 104806
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104738: LD_VAR 0 5
104742: PPUSH
104743: LD_VAR 0 8
104747: PPUSH
104748: LD_VAR 0 5
104752: PPUSH
104753: CALL_OW 74
104757: PPUSH
104758: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104762: LD_VAR 0 5
104766: PPUSH
104767: LD_VAR 0 8
104771: PPUSH
104772: LD_VAR 0 5
104776: PPUSH
104777: CALL_OW 74
104781: PPUSH
104782: CALL_OW 296
104786: PUSH
104787: LD_INT 6
104789: LESS
104790: IFFALSE 104804
// SetFuel ( i , 100 ) ;
104792: LD_VAR 0 5
104796: PPUSH
104797: LD_INT 100
104799: PPUSH
104800: CALL_OW 240
// end else
104804: GO 104820
// ComAttackUnit ( i , e ) ;
104806: LD_VAR 0 5
104810: PPUSH
104811: LD_VAR 0 14
104815: PPUSH
104816: CALL_OW 115
// end else
104820: GO 104923
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104822: LD_VAR 0 14
104826: PPUSH
104827: LD_EXP 91
104831: PUSH
104832: LD_VAR 0 1
104836: ARRAY
104837: PPUSH
104838: CALL_OW 308
104842: NOT
104843: PUSH
104844: LD_VAR 0 5
104848: PPUSH
104849: LD_VAR 0 14
104853: PPUSH
104854: CALL_OW 296
104858: PUSH
104859: LD_INT 40
104861: GREATEREQUAL
104862: AND
104863: PUSH
104864: LD_VAR 0 5
104868: PPUSH
104869: CALL_OW 256
104873: PUSH
104874: LD_INT 650
104876: LESSEQUAL
104877: OR
104878: PUSH
104879: LD_VAR 0 5
104883: PPUSH
104884: LD_EXP 90
104888: PUSH
104889: LD_VAR 0 1
104893: ARRAY
104894: PPUSH
104895: CALL_OW 308
104899: NOT
104900: AND
104901: IFFALSE 104923
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104903: LD_VAR 0 5
104907: PPUSH
104908: LD_EXP 90
104912: PUSH
104913: LD_VAR 0 1
104917: ARRAY
104918: PPUSH
104919: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104923: LD_VAR 0 5
104927: PPUSH
104928: CALL_OW 256
104932: PUSH
104933: LD_INT 998
104935: LESS
104936: PUSH
104937: LD_VAR 0 5
104941: PPUSH
104942: CALL_OW 263
104946: PUSH
104947: LD_INT 1
104949: EQUAL
104950: AND
104951: PUSH
104952: LD_VAR 0 5
104956: PPUSH
104957: CALL_OW 311
104961: AND
104962: PUSH
104963: LD_VAR 0 5
104967: PPUSH
104968: LD_EXP 90
104972: PUSH
104973: LD_VAR 0 1
104977: ARRAY
104978: PPUSH
104979: CALL_OW 308
104983: AND
104984: IFFALSE 105038
// begin mech := IsDrivenBy ( i ) ;
104986: LD_ADDR_VAR 0 10
104990: PUSH
104991: LD_VAR 0 5
104995: PPUSH
104996: CALL_OW 311
105000: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105001: LD_VAR 0 10
105005: PPUSH
105006: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105010: LD_VAR 0 10
105014: PPUSH
105015: LD_VAR 0 5
105019: PPUSH
105020: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105024: LD_VAR 0 10
105028: PPUSH
105029: LD_VAR 0 5
105033: PPUSH
105034: CALL_OW 180
// end ; end ; unit_human :
105038: GO 105305
105040: LD_INT 1
105042: DOUBLE
105043: EQUAL
105044: IFTRUE 105048
105046: GO 105304
105048: POP
// begin b := IsInUnit ( i ) ;
105049: LD_ADDR_VAR 0 19
105053: PUSH
105054: LD_VAR 0 5
105058: PPUSH
105059: CALL_OW 310
105063: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105064: LD_ADDR_VAR 0 20
105068: PUSH
105069: LD_VAR 0 19
105073: NOT
105074: PUSH
105075: LD_VAR 0 19
105079: PPUSH
105080: CALL_OW 266
105084: PUSH
105085: LD_INT 32
105087: PUSH
105088: LD_INT 31
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: IN
105095: OR
105096: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
105097: LD_VAR 0 17
105101: PUSH
105102: LD_VAR 0 2
105106: PPUSH
105107: LD_INT 21
105109: PUSH
105110: LD_INT 2
105112: PUSH
105113: EMPTY
105114: LIST
105115: LIST
105116: PPUSH
105117: CALL_OW 72
105121: PUSH
105122: LD_INT 1
105124: LESSEQUAL
105125: OR
105126: PUSH
105127: LD_VAR 0 20
105131: AND
105132: PUSH
105133: LD_VAR 0 5
105137: PUSH
105138: LD_VAR 0 18
105142: IN
105143: NOT
105144: AND
105145: IFFALSE 105238
// begin if b then
105147: LD_VAR 0 19
105151: IFFALSE 105200
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
105153: LD_VAR 0 19
105157: PPUSH
105158: LD_VAR 0 3
105162: PPUSH
105163: LD_VAR 0 19
105167: PPUSH
105168: CALL_OW 74
105172: PPUSH
105173: CALL_OW 296
105177: PUSH
105178: LD_INT 10
105180: LESS
105181: PUSH
105182: LD_VAR 0 19
105186: PPUSH
105187: CALL_OW 461
105191: PUSH
105192: LD_INT 7
105194: NONEQUAL
105195: AND
105196: IFFALSE 105200
// continue ;
105198: GO 104515
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
105200: LD_ADDR_VAR 0 18
105204: PUSH
105205: LD_VAR 0 18
105209: PPUSH
105210: LD_VAR 0 18
105214: PUSH
105215: LD_INT 1
105217: PLUS
105218: PPUSH
105219: LD_VAR 0 5
105223: PPUSH
105224: CALL_OW 1
105228: ST_TO_ADDR
// ComExitBuilding ( i ) ;
105229: LD_VAR 0 5
105233: PPUSH
105234: CALL_OW 122
// end ; if sold_defenders then
105238: LD_VAR 0 18
105242: IFFALSE 105302
// if i in sold_defenders then
105244: LD_VAR 0 5
105248: PUSH
105249: LD_VAR 0 18
105253: IN
105254: IFFALSE 105302
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
105256: LD_VAR 0 5
105260: PPUSH
105261: CALL_OW 314
105265: NOT
105266: PUSH
105267: LD_VAR 0 5
105271: PPUSH
105272: LD_VAR 0 14
105276: PPUSH
105277: CALL_OW 296
105281: PUSH
105282: LD_INT 30
105284: LESS
105285: AND
105286: IFFALSE 105302
// ComAttackUnit ( i , e ) ;
105288: LD_VAR 0 5
105292: PPUSH
105293: LD_VAR 0 14
105297: PPUSH
105298: CALL_OW 115
// end ; end ; end ;
105302: GO 105305
105304: POP
// if IsDead ( i ) then
105305: LD_VAR 0 5
105309: PPUSH
105310: CALL_OW 301
105314: IFFALSE 105332
// defenders := defenders diff i ;
105316: LD_ADDR_VAR 0 2
105320: PUSH
105321: LD_VAR 0 2
105325: PUSH
105326: LD_VAR 0 5
105330: DIFF
105331: ST_TO_ADDR
// end ;
105332: GO 104515
105334: POP
105335: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105336: LD_VAR 0 3
105340: NOT
105341: PUSH
105342: LD_VAR 0 2
105346: NOT
105347: OR
105348: PUSH
105349: LD_EXP 66
105353: PUSH
105354: LD_VAR 0 1
105358: ARRAY
105359: NOT
105360: OR
105361: IFFALSE 104419
// MC_Reset ( base , 18 ) ;
105363: LD_VAR 0 1
105367: PPUSH
105368: LD_INT 18
105370: PPUSH
105371: CALL 55480 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105375: LD_ADDR_VAR 0 2
105379: PUSH
105380: LD_VAR 0 2
105384: PUSH
105385: LD_VAR 0 2
105389: PPUSH
105390: LD_INT 2
105392: PUSH
105393: LD_INT 25
105395: PUSH
105396: LD_INT 1
105398: PUSH
105399: EMPTY
105400: LIST
105401: LIST
105402: PUSH
105403: LD_INT 25
105405: PUSH
105406: LD_INT 5
105408: PUSH
105409: EMPTY
105410: LIST
105411: LIST
105412: PUSH
105413: LD_INT 25
105415: PUSH
105416: LD_INT 8
105418: PUSH
105419: EMPTY
105420: LIST
105421: LIST
105422: PUSH
105423: LD_INT 25
105425: PUSH
105426: LD_INT 9
105428: PUSH
105429: EMPTY
105430: LIST
105431: LIST
105432: PUSH
105433: EMPTY
105434: LIST
105435: LIST
105436: LIST
105437: LIST
105438: LIST
105439: PPUSH
105440: CALL_OW 72
105444: DIFF
105445: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105446: LD_VAR 0 3
105450: NOT
105451: PUSH
105452: LD_VAR 0 2
105456: PPUSH
105457: LD_INT 21
105459: PUSH
105460: LD_INT 2
105462: PUSH
105463: EMPTY
105464: LIST
105465: LIST
105466: PPUSH
105467: CALL_OW 72
105471: AND
105472: IFFALSE 105810
// begin tmp := FilterByTag ( defenders , 19 ) ;
105474: LD_ADDR_VAR 0 12
105478: PUSH
105479: LD_VAR 0 2
105483: PPUSH
105484: LD_INT 19
105486: PPUSH
105487: CALL 47442 0 2
105491: ST_TO_ADDR
// if tmp then
105492: LD_VAR 0 12
105496: IFFALSE 105566
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105498: LD_ADDR_VAR 0 12
105502: PUSH
105503: LD_VAR 0 12
105507: PPUSH
105508: LD_INT 25
105510: PUSH
105511: LD_INT 3
105513: PUSH
105514: EMPTY
105515: LIST
105516: LIST
105517: PPUSH
105518: CALL_OW 72
105522: ST_TO_ADDR
// if tmp then
105523: LD_VAR 0 12
105527: IFFALSE 105566
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105529: LD_ADDR_EXP 78
105533: PUSH
105534: LD_EXP 78
105538: PPUSH
105539: LD_VAR 0 1
105543: PPUSH
105544: LD_EXP 78
105548: PUSH
105549: LD_VAR 0 1
105553: ARRAY
105554: PUSH
105555: LD_VAR 0 12
105559: UNION
105560: PPUSH
105561: CALL_OW 1
105565: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105566: LD_VAR 0 1
105570: PPUSH
105571: LD_INT 19
105573: PPUSH
105574: CALL 55480 0 2
// repeat wait ( 0 0$1 ) ;
105578: LD_INT 35
105580: PPUSH
105581: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105585: LD_EXP 66
105589: PUSH
105590: LD_VAR 0 1
105594: ARRAY
105595: NOT
105596: PUSH
105597: LD_EXP 66
105601: PUSH
105602: LD_VAR 0 1
105606: ARRAY
105607: PUSH
105608: EMPTY
105609: EQUAL
105610: OR
105611: IFFALSE 105648
// begin for i in defenders do
105613: LD_ADDR_VAR 0 5
105617: PUSH
105618: LD_VAR 0 2
105622: PUSH
105623: FOR_IN
105624: IFFALSE 105637
// ComStop ( i ) ;
105626: LD_VAR 0 5
105630: PPUSH
105631: CALL_OW 141
105635: GO 105623
105637: POP
105638: POP
// defenders := [ ] ;
105639: LD_ADDR_VAR 0 2
105643: PUSH
105644: EMPTY
105645: ST_TO_ADDR
// exit ;
105646: GO 105874
// end ; for i in defenders do
105648: LD_ADDR_VAR 0 5
105652: PUSH
105653: LD_VAR 0 2
105657: PUSH
105658: FOR_IN
105659: IFFALSE 105748
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105661: LD_VAR 0 5
105665: PPUSH
105666: LD_EXP 90
105670: PUSH
105671: LD_VAR 0 1
105675: ARRAY
105676: PPUSH
105677: CALL_OW 308
105681: NOT
105682: IFFALSE 105706
// ComMoveToArea ( i , mc_parking [ base ] ) else
105684: LD_VAR 0 5
105688: PPUSH
105689: LD_EXP 90
105693: PUSH
105694: LD_VAR 0 1
105698: ARRAY
105699: PPUSH
105700: CALL_OW 113
105704: GO 105746
// if GetControl ( i ) = control_manual then
105706: LD_VAR 0 5
105710: PPUSH
105711: CALL_OW 263
105715: PUSH
105716: LD_INT 1
105718: EQUAL
105719: IFFALSE 105746
// if IsDrivenBy ( i ) then
105721: LD_VAR 0 5
105725: PPUSH
105726: CALL_OW 311
105730: IFFALSE 105746
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105732: LD_VAR 0 5
105736: PPUSH
105737: CALL_OW 311
105741: PPUSH
105742: CALL_OW 121
// end ;
105746: GO 105658
105748: POP
105749: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105750: LD_VAR 0 2
105754: PPUSH
105755: LD_INT 95
105757: PUSH
105758: LD_EXP 90
105762: PUSH
105763: LD_VAR 0 1
105767: ARRAY
105768: PUSH
105769: EMPTY
105770: LIST
105771: LIST
105772: PPUSH
105773: CALL_OW 72
105777: PUSH
105778: LD_VAR 0 2
105782: EQUAL
105783: PUSH
105784: LD_EXP 89
105788: PUSH
105789: LD_VAR 0 1
105793: ARRAY
105794: OR
105795: PUSH
105796: LD_EXP 66
105800: PUSH
105801: LD_VAR 0 1
105805: ARRAY
105806: NOT
105807: OR
105808: IFFALSE 105578
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
105810: LD_ADDR_EXP 88
105814: PUSH
105815: LD_EXP 88
105819: PPUSH
105820: LD_VAR 0 1
105824: PPUSH
105825: LD_VAR 0 2
105829: PPUSH
105830: LD_INT 21
105832: PUSH
105833: LD_INT 2
105835: PUSH
105836: EMPTY
105837: LIST
105838: LIST
105839: PPUSH
105840: CALL_OW 72
105844: PPUSH
105845: CALL_OW 1
105849: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
105850: LD_VAR 0 1
105854: PPUSH
105855: LD_INT 19
105857: PPUSH
105858: CALL 55480 0 2
// MC_Reset ( base , 20 ) ;
105862: LD_VAR 0 1
105866: PPUSH
105867: LD_INT 20
105869: PPUSH
105870: CALL 55480 0 2
// end ;
105874: LD_VAR 0 4
105878: RET
