// export MissionStart ; starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  11: LD_INT 1
  13: PPUSH
  14: LD_INT 8
  16: PPUSH
  17: CALL_OW 332
// GameType ;
  21: CALL 5207 0 0
// SetBName ( BetaA , beta ) ;
  25: LD_INT 1
  27: PPUSH
  28: LD_STRING beta
  30: PPUSH
  31: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  35: LD_INT 3
  37: PPUSH
  38: LD_STRING beta
  40: PPUSH
  41: CALL_OW 500
// PrepareHeroes ;
  45: CALL 2370 0 0
// PrepareBeta ;
  49: CALL 2759 0 0
// InGameOn ;
  53: CALL_OW 8
// CenterNowOnUnits ( Brighton ) ;
  57: LD_EXP 8
  61: PPUSH
  62: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
  66: LD_EXP 10
  70: PPUSH
  71: LD_INT 50
  73: PPUSH
  74: LD_INT 42
  76: PPUSH
  77: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
  81: LD_INT 35
  83: PPUSH
  84: CALL_OW 67
  88: LD_EXP 10
  92: PPUSH
  93: LD_EXP 8
  97: PPUSH
  98: CALL_OW 296
 102: PUSH
 103: LD_INT 3
 105: LESS
 106: IFFALSE 81
// ComTurnUnit ( Megan , Brighton ) ;
 108: LD_EXP 10
 112: PPUSH
 113: LD_EXP 8
 117: PPUSH
 118: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 122: LD_EXP 10
 126: PPUSH
 127: LD_STRING DMegan-1a
 129: PPUSH
 130: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 134: LD_INT 10
 136: PPUSH
 137: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 141: LD_EXP 8
 145: PPUSH
 146: LD_EXP 10
 150: PPUSH
 151: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 155: LD_EXP 8
 159: PPUSH
 160: LD_STRING DBrighton-1a
 162: PPUSH
 163: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 167: LD_EXP 10
 171: PPUSH
 172: LD_STRING DMegan-2a
 174: PPUSH
 175: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 179: LD_EXP 8
 183: PPUSH
 184: LD_STRING DBrighton-2a
 186: PPUSH
 187: CALL_OW 88
// Say ( Megan , DMegan-3a ) ;
 191: LD_EXP 10
 195: PPUSH
 196: LD_STRING DMegan-3a
 198: PPUSH
 199: CALL_OW 88
// Say ( Brighton , DBrighton-3a ) ;
 203: LD_EXP 8
 207: PPUSH
 208: LD_STRING DBrighton-3a
 210: PPUSH
 211: CALL_OW 88
// Say ( Megan , DMegan-4a ) ;
 215: LD_EXP 10
 219: PPUSH
 220: LD_STRING DMegan-4a
 222: PPUSH
 223: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 227: LD_EXP 10
 231: PPUSH
 232: LD_INT 40
 234: PPUSH
 235: LD_INT 37
 237: PPUSH
 238: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 242: LD_EXP 10
 246: PPUSH
 247: LD_EXP 8
 251: PPUSH
 252: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 256: LD_EXP 9
 260: PPUSH
 261: LD_INT 50
 263: PPUSH
 264: LD_INT 42
 266: PPUSH
 267: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 271: LD_INT 35
 273: PPUSH
 274: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 278: LD_EXP 8
 282: PPUSH
 283: LD_EXP 9
 287: PPUSH
 288: CALL_OW 296
 292: PUSH
 293: LD_INT 6
 295: LESS
 296: IFFALSE 271
// ComTurnUnit ( Brighton , Palmer ) ;
 298: LD_EXP 8
 302: PPUSH
 303: LD_EXP 9
 307: PPUSH
 308: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 312: LD_EXP 9
 316: PPUSH
 317: LD_EXP 8
 321: PPUSH
 322: CALL_OW 119
// Say ( Megan , DMegan-5a ) ;
 326: LD_EXP 10
 330: PPUSH
 331: LD_STRING DMegan-5a
 333: PPUSH
 334: CALL_OW 88
// Say ( Palmer , DPalmer-1 ) ;
 338: LD_EXP 9
 342: PPUSH
 343: LD_STRING DPalmer-1
 345: PPUSH
 346: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 350: LD_EXP 8
 354: PPUSH
 355: LD_STRING DBrighton-1
 357: PPUSH
 358: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 362: LD_EXP 9
 366: PPUSH
 367: LD_STRING DPalmer-2
 369: PPUSH
 370: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 374: LD_EXP 8
 378: PPUSH
 379: LD_STRING DBrighton-2
 381: PPUSH
 382: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 386: LD_EXP 9
 390: PPUSH
 391: LD_STRING DPalmer-3
 393: PPUSH
 394: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 398: LD_EXP 8
 402: PPUSH
 403: LD_STRING DBrighton-3
 405: PPUSH
 406: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 410: LD_EXP 9
 414: PPUSH
 415: LD_STRING DPalmer-4
 417: PPUSH
 418: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 422: LD_EXP 9
 426: PPUSH
 427: LD_INT 6
 429: PPUSH
 430: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 434: LD_INT 35
 436: PPUSH
 437: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 441: LD_EXP 9
 445: PPUSH
 446: CALL_OW 310
 450: PUSH
 451: LD_INT 6
 453: EQUAL
 454: IFFALSE 434
// SayRadio ( Palmer , DPalmer-5 ) ;
 456: LD_EXP 9
 460: PPUSH
 461: LD_STRING DPalmer-5
 463: PPUSH
 464: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 468: LD_EXP 8
 472: PPUSH
 473: LD_INT 59
 475: PPUSH
 476: LD_INT 36
 478: PPUSH
 479: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_INT 60
 490: PPUSH
 491: LD_INT 35
 493: PPUSH
 494: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 498: LD_EXP 9
 502: PPUSH
 503: LD_INT 60
 505: PPUSH
 506: LD_INT 34
 508: PPUSH
 509: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 513: LD_EXP 8
 517: PPUSH
 518: LD_INT 99
 520: PPUSH
 521: LD_INT 37
 523: PPUSH
 524: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 528: LD_EXP 10
 532: PPUSH
 533: LD_EXP 8
 537: PPUSH
 538: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 542: LD_EXP 9
 546: PPUSH
 547: LD_EXP 8
 551: PPUSH
 552: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 556: LD_INT 64
 558: PPUSH
 559: LD_INT 40
 561: PPUSH
 562: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 566: LD_EXP 11
 570: PPUSH
 571: LD_INT 13
 573: PPUSH
 574: CALL 10930 0 2
// wait ( 0 0$30 ) ;
 578: LD_INT 1050
 580: PPUSH
 581: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 585: LD_EXP 8
 589: PPUSH
 590: LD_STRING DBrighton-4
 592: PPUSH
 593: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 597: LD_EXP 8
 601: PPUSH
 602: LD_STRING DBrighton-5
 604: PPUSH
 605: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 609: LD_EXP 8
 613: PPUSH
 614: LD_EXP 10
 618: PPUSH
 619: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 623: LD_EXP 8
 627: PPUSH
 628: LD_STRING DBrighton-6
 630: PPUSH
 631: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_STRING DMegan-1
 642: PPUSH
 643: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 647: LD_EXP 8
 651: PPUSH
 652: LD_STRING DBrighton-7
 654: PPUSH
 655: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 659: LD_EXP 8
 663: PPUSH
 664: LD_INT 99
 666: PPUSH
 667: LD_INT 37
 669: PPUSH
 670: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 674: LD_EXP 8
 678: PPUSH
 679: LD_STRING DBrighton-8
 681: PPUSH
 682: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 686: LD_STRING C1
 688: PPUSH
 689: CALL_OW 337
// InGameOff ;
 693: CALL_OW 9
// SaveForQuickRestart ;
 697: CALL_OW 22
// MissionStart := true ;
 701: LD_ADDR_EXP 1
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// music_nat := 1 ;
 709: LD_ADDR_OWVAR 71
 713: PUSH
 714: LD_INT 1
 716: ST_TO_ADDR
// end ;
 717: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var tmp , i ;
 718: LD_EXP 1
 722: IFFALSE 1917
 724: GO 726
 726: DISABLE
 727: LD_INT 0
 729: PPUSH
 730: PPUSH
// begin wait ( ruArrival ) ;
 731: LD_EXP 41
 735: PPUSH
 736: CALL_OW 67
// PrepareRUArmada ;
 740: CALL 3341 0 0
// wait ( 0 0$3 ) ;
 744: LD_INT 105
 746: PPUSH
 747: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 751: LD_ADDR_VAR 0 1
 755: PUSH
 756: LD_INT 15
 758: PPUSH
 759: LD_INT 0
 761: PPUSH
 762: CALL_OW 517
 766: ST_TO_ADDR
// for i = 1 to RUArmada do
 767: LD_ADDR_VAR 0 2
 771: PUSH
 772: DOUBLE
 773: LD_INT 1
 775: DEC
 776: ST_TO_ADDR
 777: LD_EXP 16
 781: PUSH
 782: FOR_TO
 783: IFFALSE 832
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 785: LD_EXP 16
 789: PUSH
 790: LD_VAR 0 2
 794: ARRAY
 795: PPUSH
 796: LD_VAR 0 1
 800: PUSH
 801: LD_INT 1
 803: ARRAY
 804: PUSH
 805: LD_VAR 0 2
 809: ARRAY
 810: PPUSH
 811: LD_VAR 0 1
 815: PUSH
 816: LD_INT 2
 818: ARRAY
 819: PUSH
 820: LD_VAR 0 2
 824: ARRAY
 825: PPUSH
 826: CALL_OW 111
 830: GO 782
 832: POP
 833: POP
// ArmadaArrived := true ;
 834: LD_ADDR_EXP 2
 838: PUSH
 839: LD_INT 1
 841: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 842: LD_EXP 9
 846: PPUSH
 847: LD_STRING DPalmer-A1
 849: PPUSH
 850: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 854: LD_EXP 8
 858: PPUSH
 859: LD_STRING DBrighton-A1
 861: PPUSH
 862: CALL_OW 88
// wait ( 0 0$20 ) ;
 866: LD_INT 700
 868: PPUSH
 869: CALL_OW 67
// PrepareRUBase ;
 873: CALL 4066 0 0
// PrepareRUBase_v2 ;
 877: CALL 4482 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 881: LD_ADDR_EXP 52
 885: PUSH
 886: LD_EXP 52
 890: PPUSH
 891: LD_INT 1
 893: PPUSH
 894: LD_INT 22
 896: PUSH
 897: LD_INT 3
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: PPUSH
 904: CALL_OW 69
 908: PPUSH
 909: CALL_OW 1
 913: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 914: LD_ADDR_EXP 52
 918: PUSH
 919: LD_EXP 52
 923: PPUSH
 924: LD_INT 2
 926: PPUSH
 927: LD_EXP 35
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_Start ( ) ;
 937: CALL 56246 0 0
// wait ( 0 0$30 ) ;
 941: LD_INT 1050
 943: PPUSH
 944: CALL_OW 67
// PrepareRUBulldozers ;
 948: CALL 3953 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 952: LD_EXP 17
 956: PUSH
 957: LD_INT 1
 959: ARRAY
 960: PPUSH
 961: LD_INT 9
 963: PPUSH
 964: CALL 10787 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 968: LD_EXP 17
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_INT 11
 979: PPUSH
 980: CALL 10787 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
 984: LD_INT 1
 986: PPUSH
 987: LD_EXP 17
 991: PUSH
 992: LD_INT 1
 994: ARRAY
 995: PPUSH
 996: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1000: LD_INT 1
1002: PPUSH
1003: LD_EXP 17
1007: PUSH
1008: LD_INT 2
1010: ARRAY
1011: PPUSH
1012: CALL_OW 471
// wait ( 0 0$30 ) ;
1016: LD_INT 1050
1018: PPUSH
1019: CALL_OW 67
// InGameOn ;
1023: CALL_OW 8
// PlaceSeeing ( 95 , 93 , 1 , - 30 ) ;
1027: LD_INT 95
1029: PPUSH
1030: LD_INT 93
1032: PPUSH
1033: LD_INT 1
1035: PPUSH
1036: LD_INT 30
1038: NEG
1039: PPUSH
1040: CALL_OW 330
// ComMoveXY ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) , 63 , 39 ) ;
1044: LD_INT 10
1046: PPUSH
1047: LD_INT 22
1049: PUSH
1050: LD_INT 1
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL_OW 70
1061: PPUSH
1062: LD_INT 63
1064: PPUSH
1065: LD_INT 39
1067: PPUSH
1068: CALL_OW 111
// CenterOnXY ( 95 , 93 ) ;
1072: LD_INT 95
1074: PPUSH
1075: LD_INT 93
1077: PPUSH
1078: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
1082: LD_INT 35
1084: PPUSH
1085: CALL_OW 67
// if not HasTask ( Bulldozers [ 1 ] ) then
1089: LD_EXP 17
1093: PUSH
1094: LD_INT 1
1096: ARRAY
1097: PPUSH
1098: CALL_OW 314
1102: NOT
1103: IFFALSE 1121
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1105: LD_EXP 17
1109: PUSH
1110: LD_INT 1
1112: ARRAY
1113: PPUSH
1114: LD_INT 9
1116: PPUSH
1117: CALL 10787 0 2
// if not HasTask ( Bulldozers [ 2 ] ) then
1121: LD_EXP 17
1125: PUSH
1126: LD_INT 2
1128: ARRAY
1129: PPUSH
1130: CALL_OW 314
1134: NOT
1135: IFFALSE 1153
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1137: LD_EXP 17
1141: PUSH
1142: LD_INT 2
1144: ARRAY
1145: PPUSH
1146: LD_INT 11
1148: PPUSH
1149: CALL 10787 0 2
// until ListEnvironmentArea ( BulldozerArea ) < 2 or ListEnvironmentArea ( BulldozerArea2 ) < 2 or IsDead ( Bulldozers [ 1 ] ) ;
1153: LD_INT 9
1155: PPUSH
1156: CALL_OW 353
1160: PUSH
1161: LD_INT 2
1163: LESS
1164: PUSH
1165: LD_INT 11
1167: PPUSH
1168: CALL_OW 353
1172: PUSH
1173: LD_INT 2
1175: LESS
1176: OR
1177: PUSH
1178: LD_EXP 17
1182: PUSH
1183: LD_INT 1
1185: ARRAY
1186: PPUSH
1187: CALL_OW 301
1191: OR
1192: IFFALSE 1082
// if UnitFilter ( Bulldozers , [ f_ok ] ) then
1194: LD_EXP 17
1198: PPUSH
1199: LD_INT 50
1201: PUSH
1202: EMPTY
1203: LIST
1204: PPUSH
1205: CALL_OW 72
1209: IFFALSE 1262
// begin wait ( 0 0$10 ) ;
1211: LD_INT 350
1213: PPUSH
1214: CALL_OW 67
// ComMoveXY ( Bulldozers , 120 , 131 ) ;
1218: LD_EXP 17
1222: PPUSH
1223: LD_INT 120
1225: PPUSH
1226: LD_INT 131
1228: PPUSH
1229: CALL_OW 111
// for i in Bulldozers do
1233: LD_ADDR_VAR 0 2
1237: PUSH
1238: LD_EXP 17
1242: PUSH
1243: FOR_IN
1244: IFFALSE 1260
// NormalAttack ( 1 , i ) ;
1246: LD_INT 1
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: CALL_OW 472
1258: GO 1243
1260: POP
1261: POP
// end ; wait ( 0 0$10 ) ;
1262: LD_INT 350
1264: PPUSH
1265: CALL_OW 67
// RemoveSeeing ( 95 , 93 , 1 ) ;
1269: LD_INT 95
1271: PPUSH
1272: LD_INT 93
1274: PPUSH
1275: LD_INT 1
1277: PPUSH
1278: CALL_OW 331
// Say ( Yashin , DDeath-Yas-1 ) ;
1282: LD_EXP 12
1286: PPUSH
1287: LD_STRING DDeath-Yas-1
1289: PPUSH
1290: CALL_OW 88
// SayEffect ( DRuSol-A1 ) ;
1294: LD_STRING DRuSol-A1
1296: PPUSH
1297: CALL_OW 96
// wait ( 0 0$2 ) ;
1301: LD_INT 70
1303: PPUSH
1304: CALL_OW 67
// InGameOff ;
1308: CALL_OW 9
// ComMoveXY ( RUArmada , 66 , 40 ) ;
1312: LD_EXP 16
1316: PPUSH
1317: LD_INT 66
1319: PPUSH
1320: LD_INT 40
1322: PPUSH
1323: CALL_OW 111
// wait ( 0 0$2 ) ;
1327: LD_INT 70
1329: PPUSH
1330: CALL_OW 67
// Say ( Gaydar , DDeath-Gay-2 ) ;
1334: LD_EXP 14
1338: PPUSH
1339: LD_STRING DDeath-Gay-2
1341: PPUSH
1342: CALL_OW 88
// wait ( 0 0$20 ) ;
1346: LD_INT 700
1348: PPUSH
1349: CALL_OW 67
// AssaultStarted := true ;
1353: LD_ADDR_EXP 7
1357: PUSH
1358: LD_INT 1
1360: ST_TO_ADDR
// Say ( Popov , DDeath-Pop-1 ) ;
1361: LD_EXP 13
1365: PPUSH
1366: LD_STRING DDeath-Pop-1
1368: PPUSH
1369: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1373: LD_EXP 14
1377: PPUSH
1378: LD_STRING DDeath-Gay-1
1380: PPUSH
1381: CALL_OW 88
// wait ( 0 0$5 ) ;
1385: LD_INT 175
1387: PPUSH
1388: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1392: LD_EXP 15
1396: PPUSH
1397: LD_STRING DDeath-Vse-1
1399: PPUSH
1400: CALL_OW 88
// PriorityAttack ( 6 , BetaA ) ;
1404: LD_INT 6
1406: PPUSH
1407: LD_INT 1
1409: PPUSH
1410: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1414: LD_INT 6
1416: PPUSH
1417: LD_INT 3
1419: PPUSH
1420: CALL_OW 470
// repeat for i in RuArmada do
1424: LD_ADDR_VAR 0 2
1428: PUSH
1429: LD_EXP 16
1433: PUSH
1434: FOR_IN
1435: IFFALSE 1485
// if not HasTask ( i ) then
1437: LD_VAR 0 2
1441: PPUSH
1442: CALL_OW 314
1446: NOT
1447: IFFALSE 1483
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1449: LD_VAR 0 2
1453: PPUSH
1454: LD_INT 22
1456: PUSH
1457: LD_INT 1
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: PPUSH
1464: CALL_OW 69
1468: PPUSH
1469: LD_VAR 0 2
1473: PPUSH
1474: CALL_OW 74
1478: PPUSH
1479: CALL_OW 115
1483: GO 1434
1485: POP
1486: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1487: LD_INT 35
1489: PPUSH
1490: CALL_OW 67
1494: LD_INT 1
1496: PUSH
1497: LD_INT 22
1499: PUSH
1500: LD_INT 6
1502: PUSH
1503: EMPTY
1504: LIST
1505: LIST
1506: PUSH
1507: LD_INT 21
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: PPUSH
1522: CALL_OW 69
1526: PUSH
1527: LD_INT 10
1529: LESS
1530: PUSH
1531: LD_EXP 12
1535: PPUSH
1536: CALL_OW 301
1540: AND
1541: PUSH
1542: LD_EXP 13
1546: PPUSH
1547: CALL_OW 301
1551: AND
1552: PUSH
1553: LD_EXP 14
1557: PPUSH
1558: CALL_OW 301
1562: AND
1563: PUSH
1564: LD_EXP 15
1568: PPUSH
1569: CALL_OW 301
1573: AND
1574: IFFALSE 1424
// AssaultStarted := false ;
1576: LD_ADDR_EXP 7
1580: PUSH
1581: LD_INT 0
1583: ST_TO_ADDR
// ComMoveXY ( FilterAllUnits ( [ f_side , 6 ] ) , 120 , 131 ) ;
1584: LD_INT 22
1586: PUSH
1587: LD_INT 6
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: PPUSH
1599: LD_INT 120
1601: PPUSH
1602: LD_INT 131
1604: PPUSH
1605: CALL_OW 111
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1609: LD_ADDR_EXP 4
1613: PUSH
1614: LD_INT 1
1616: PUSH
1617: LD_INT 22
1619: PUSH
1620: LD_INT 6
1622: PUSH
1623: EMPTY
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 26
1629: PUSH
1630: LD_INT 1
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 1
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 24
1649: PUSH
1650: LD_INT 500
1652: PUSH
1653: EMPTY
1654: LIST
1655: LIST
1656: PUSH
1657: EMPTY
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: PPUSH
1664: CALL_OW 69
1668: ST_TO_ADDR
// if RuSpeaker then
1669: LD_EXP 4
1673: IFFALSE 1691
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1675: LD_EXP 4
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_STRING DRuSol-A2
1686: PPUSH
1687: CALL_OW 88
// wait ( 0 0$30 ) ;
1691: LD_INT 1050
1693: PPUSH
1694: CALL_OW 67
// DialogueOn ;
1698: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1702: LD_EXP 8
1706: PPUSH
1707: LD_STRING DBrighton-B1
1709: PPUSH
1710: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1714: LD_EXP 9
1718: PPUSH
1719: LD_STRING DPalmer-B1
1721: PPUSH
1722: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1726: LD_EXP 8
1730: PPUSH
1731: LD_STRING DBrighton-B2
1733: PPUSH
1734: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1738: LD_EXP 18
1742: PPUSH
1743: LD_STRING DBurlak-B1
1745: PPUSH
1746: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1750: LD_EXP 8
1754: PPUSH
1755: LD_STRING DBrighton-B3
1757: PPUSH
1758: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1762: LD_EXP 9
1766: PPUSH
1767: LD_STRING DPalmer-B2
1769: PPUSH
1770: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1774: LD_EXP 8
1778: PPUSH
1779: LD_STRING DBrighton-B4
1781: PPUSH
1782: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1786: LD_EXP 8
1790: PPUSH
1791: LD_STRING DBrighton-B5
1793: PPUSH
1794: CALL_OW 88
// DialogueOff ;
1798: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1802: LD_STRING C2
1804: PPUSH
1805: CALL_OW 337
// FirstAssaultRepelled := true ;
1809: LD_ADDR_EXP 3
1813: PUSH
1814: LD_INT 1
1816: ST_TO_ADDR
// RemoveUnit ( Bulldozers [ 1 ] ) ;
1817: LD_EXP 17
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: CALL_OW 64
// RemoveUnit ( Bulldozers [ 2 ] ) ;
1830: LD_EXP 17
1834: PUSH
1835: LD_INT 2
1837: ARRAY
1838: PPUSH
1839: CALL_OW 64
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1843: LD_INT 22
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: PPUSH
1853: CALL_OW 69
1857: PPUSH
1858: CALL_OW 181
// SetSide ( FilterAllUnits ( [ f_side , 6 ] ) , 3 ) ;
1862: LD_INT 22
1864: PUSH
1865: LD_INT 6
1867: PUSH
1868: EMPTY
1869: LIST
1870: LIST
1871: PPUSH
1872: CALL_OW 69
1876: PPUSH
1877: LD_INT 3
1879: PPUSH
1880: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1884: LD_ADDR_EXP 52
1888: PUSH
1889: LD_EXP 52
1893: PPUSH
1894: LD_INT 1
1896: PPUSH
1897: LD_INT 22
1899: PUSH
1900: LD_INT 3
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: PPUSH
1907: CALL_OW 69
1911: PPUSH
1912: CALL_OW 1
1916: ST_TO_ADDR
// end ;
1917: PPOPN 2
1919: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
1920: LD_EXP 3
1924: PUSH
1925: LD_EXP 40
1929: PUSH
1930: LD_INT 0
1932: GREATER
1933: AND
1934: IFFALSE 1954
1936: GO 1938
1938: DISABLE
// begin enable ;
1939: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
1940: LD_ADDR_EXP 40
1944: PUSH
1945: LD_EXP 40
1949: PUSH
1950: LD_INT 35
1952: MINUS
1953: ST_TO_ADDR
// end ;
1954: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
1955: LD_EXP 40
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 2048
1965: GO 1967
1967: DISABLE
// begin JMMReinforcement ;
1968: CALL 4810 0 0
// DialogueOn ;
1972: CALL_OW 6
// CenterOnUnits ( JMM ) ;
1976: LD_EXP 36
1980: PPUSH
1981: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
1985: LD_EXP 36
1989: PPUSH
1990: LD_STRING DJMM-F1
1992: PPUSH
1993: CALL_OW 88
// if RussiansDefeated then
1997: LD_EXP 42
2001: IFFALSE 2017
// Say ( Brighton , DBrighton-F1a ) else
2003: LD_EXP 8
2007: PPUSH
2008: LD_STRING DBrighton-F1a
2010: PPUSH
2011: CALL_OW 88
2015: GO 2036
// begin Say ( Brighton , DBrighton-F1 ) ;
2017: LD_EXP 8
2021: PPUSH
2022: LD_STRING DBrighton-F1
2024: PPUSH
2025: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2029: LD_STRING C3
2031: PPUSH
2032: CALL_OW 337
// end ; DialogueOff ;
2036: CALL_OW 7
// JMM_Arrived := true ;
2040: LD_ADDR_EXP 5
2044: PUSH
2045: LD_INT 1
2047: ST_TO_ADDR
// end ;
2048: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2049: LD_EXP 5
2053: PUSH
2054: LD_INT 1
2056: PPUSH
2057: LD_EXP 18
2061: PPUSH
2062: CALL_OW 292
2066: AND
2067: IFFALSE 2096
2069: GO 2071
2071: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2072: LD_EXP 18
2076: PPUSH
2077: LD_STRING DBurlak
2079: PPUSH
2080: CALL_OW 88
// Say ( JMM , DJMM ) ;
2084: LD_EXP 36
2088: PPUSH
2089: LD_STRING DJMM
2091: PPUSH
2092: CALL_OW 88
// end ;
2096: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2097: LD_INT 1
2099: PUSH
2100: LD_INT 22
2102: PUSH
2103: LD_INT 1
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 34
2115: PUSH
2116: LD_INT 9
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: LD_INT 35
2125: PUSH
2126: LD_INT 9
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: PUSH
2138: EMPTY
2139: LIST
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 69
2147: PUSH
2148: LD_INT 1
2150: GREATER
2151: IFFALSE 2164
2153: GO 2155
2155: DISABLE
// begin LaserBuilt := true ;
2156: LD_ADDR_EXP 6
2160: PUSH
2161: LD_INT 1
2163: ST_TO_ADDR
// end ;
2164: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2165: LD_EXP 7
2169: PUSH
2170: LD_INT 6
2172: PPUSH
2173: LD_INT 1
2175: PUSH
2176: LD_INT 22
2178: PUSH
2179: LD_INT 1
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: PUSH
2186: LD_INT 35
2188: PUSH
2189: LD_INT 9
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: PPUSH
2204: CALL_OW 69
2208: PPUSH
2209: LD_EXP 15
2213: PPUSH
2214: CALL_OW 310
2218: PPUSH
2219: CALL_OW 74
2223: PPUSH
2224: CALL_OW 292
2228: AND
2229: IFFALSE 2265
2231: GO 2233
2233: DISABLE
// begin wait ( 0 0$5 ) ;
2234: LD_INT 175
2236: PPUSH
2237: CALL_OW 67
// Say ( Sevi , DDeath-Vse-2 ) ;
2241: LD_EXP 15
2245: PPUSH
2246: LD_STRING DDeath-Vse-2
2248: PPUSH
2249: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2253: LD_EXP 12
2257: PPUSH
2258: LD_STRING DDeath-Yas-2
2260: PPUSH
2261: CALL_OW 88
// end ;
2265: END
// every 0 0$1 trigger AssaultStarted do
2266: LD_EXP 7
2270: IFFALSE 2294
2272: GO 2274
2274: DISABLE
// begin wait ( 0 0$20 ) ;
2275: LD_INT 700
2277: PPUSH
2278: CALL_OW 67
// Say ( Popov , DDeath-Pop-2 ) ;
2282: LD_EXP 13
2286: PPUSH
2287: LD_STRING DDeath-Pop-2
2289: PPUSH
2290: CALL_OW 88
// end ;
2294: END
// every 0 0$1 trigger MissionStart do
2295: LD_EXP 1
2299: IFFALSE 2341
2301: GO 2303
2303: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2304: LD_INT 1750
2306: PPUSH
2307: LD_INT 4900
2309: PPUSH
2310: CALL_OW 12
2314: PPUSH
2315: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2319: LD_INT 2
2321: PPUSH
2322: LD_INT 5
2324: PPUSH
2325: CALL_OW 12
2329: PPUSH
2330: LD_INT 12
2332: PPUSH
2333: LD_INT 1
2335: PPUSH
2336: CALL_OW 55
// enable ;
2340: ENABLE
// end ;
2341: END
// every 0 0$1 trigger MissionStart do
2342: LD_EXP 1
2346: IFFALSE 2369
2348: GO 2350
2350: DISABLE
// begin enable ;
2351: ENABLE
// display_Strings := [ #tick , tick ] ;
2352: LD_ADDR_OWVAR 47
2356: PUSH
2357: LD_STRING #tick
2359: PUSH
2360: LD_OWVAR 1
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: ST_TO_ADDR
// end ; end_of_file
2369: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2370: LD_INT 0
2372: PPUSH
// uc_side := 1 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 1
2380: ST_TO_ADDR
// hc_class = class_soldier ;
2381: LD_ADDR_OWVAR 28
2385: PUSH
2386: LD_INT 1
2388: ST_TO_ADDR
// uc_nation := nation_american ;
2389: LD_ADDR_OWVAR 21
2393: PUSH
2394: LD_INT 1
2396: ST_TO_ADDR
// hc_sex = sex_male ;
2397: LD_ADDR_OWVAR 27
2401: PUSH
2402: LD_INT 1
2404: ST_TO_ADDR
// hc_importance = 110 ;
2405: LD_ADDR_OWVAR 32
2409: PUSH
2410: LD_INT 110
2412: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2413: LD_ADDR_OWVAR 30
2417: PUSH
2418: LD_INT 5
2420: PUSH
2421: LD_INT 4
2423: PUSH
2424: LD_INT 5
2426: PUSH
2427: LD_INT 3
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2436: LD_ADDR_OWVAR 31
2440: PUSH
2441: LD_INT 9
2443: PUSH
2444: LD_INT 6
2446: PUSH
2447: LD_INT 7
2449: PUSH
2450: LD_INT 6
2452: PUSH
2453: EMPTY
2454: LIST
2455: LIST
2456: LIST
2457: LIST
2458: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2459: LD_ADDR_OWVAR 29
2463: PUSH
2464: LD_INT 12
2466: PUSH
2467: LD_INT 10
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2474: LD_ADDR_OWVAR 26
2478: PUSH
2479: LD_STRING Gerard Brighton
2481: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2482: LD_ADDR_OWVAR 33
2486: PUSH
2487: LD_STRING Beta_Skirmish
2489: ST_TO_ADDR
// hc_face_number := 1 ;
2490: LD_ADDR_OWVAR 34
2494: PUSH
2495: LD_INT 1
2497: ST_TO_ADDR
// Brighton := CreateHuman ;
2498: LD_ADDR_EXP 8
2502: PUSH
2503: CALL_OW 44
2507: ST_TO_ADDR
// uc_nation := nation_american ;
2508: LD_ADDR_OWVAR 21
2512: PUSH
2513: LD_INT 1
2515: ST_TO_ADDR
// hc_importance = 80 ;
2516: LD_ADDR_OWVAR 32
2520: PUSH
2521: LD_INT 80
2523: ST_TO_ADDR
// hc_sex = sex_male ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2532: LD_ADDR_OWVAR 30
2536: PUSH
2537: LD_INT 5
2539: PUSH
2540: LD_INT 5
2542: PUSH
2543: LD_INT 3
2545: PUSH
2546: LD_INT 1
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2555: LD_ADDR_OWVAR 31
2559: PUSH
2560: LD_INT 7
2562: PUSH
2563: LD_INT 6
2565: PUSH
2566: LD_INT 5
2568: PUSH
2569: LD_INT 3
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: LIST
2576: LIST
2577: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2578: LD_ADDR_OWVAR 29
2582: PUSH
2583: LD_INT 10
2585: PUSH
2586: LD_INT 10
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: ST_TO_ADDR
// hc_name := Brian Palmer ;
2593: LD_ADDR_OWVAR 26
2597: PUSH
2598: LD_STRING Brian Palmer
2600: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2601: LD_ADDR_OWVAR 33
2605: PUSH
2606: LD_STRING Beta_Skirmish
2608: ST_TO_ADDR
// hc_face_number := 3 ;
2609: LD_ADDR_OWVAR 34
2613: PUSH
2614: LD_INT 3
2616: ST_TO_ADDR
// Palmer := CreateHuman ;
2617: LD_ADDR_EXP 9
2621: PUSH
2622: CALL_OW 44
2626: ST_TO_ADDR
// hc_class = class_scientistic ;
2627: LD_ADDR_OWVAR 28
2631: PUSH
2632: LD_INT 4
2634: ST_TO_ADDR
// uc_nation := nation_american ;
2635: LD_ADDR_OWVAR 21
2639: PUSH
2640: LD_INT 1
2642: ST_TO_ADDR
// hc_importance = 70 ;
2643: LD_ADDR_OWVAR 32
2647: PUSH
2648: LD_INT 70
2650: ST_TO_ADDR
// hc_sex = sex_female ;
2651: LD_ADDR_OWVAR 27
2655: PUSH
2656: LD_INT 2
2658: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2659: LD_ADDR_OWVAR 30
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: LD_INT 2
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: LD_INT 6
2675: PUSH
2676: EMPTY
2677: LIST
2678: LIST
2679: LIST
2680: LIST
2681: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2682: LD_ADDR_OWVAR 31
2686: PUSH
2687: LD_INT 4
2689: PUSH
2690: LD_INT 2
2692: PUSH
2693: LD_INT 5
2695: PUSH
2696: LD_INT 8
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2705: LD_ADDR_OWVAR 29
2709: PUSH
2710: LD_INT 10
2712: PUSH
2713: LD_INT 10
2715: PUSH
2716: EMPTY
2717: LIST
2718: LIST
2719: ST_TO_ADDR
// hc_name := Megan Armitage ;
2720: LD_ADDR_OWVAR 26
2724: PUSH
2725: LD_STRING Megan Armitage
2727: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2728: LD_ADDR_OWVAR 33
2732: PUSH
2733: LD_STRING Beta_Skirmish
2735: ST_TO_ADDR
// hc_face_number := 4 ;
2736: LD_ADDR_OWVAR 34
2740: PUSH
2741: LD_INT 4
2743: ST_TO_ADDR
// Megan := CreateHuman ;
2744: LD_ADDR_EXP 10
2748: PUSH
2749: CALL_OW 44
2753: ST_TO_ADDR
// end ;
2754: LD_VAR 0 1
2758: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
2764: PPUSH
2765: PPUSH
// uc_side := 1 ;
2766: LD_ADDR_OWVAR 20
2770: PUSH
2771: LD_INT 1
2773: ST_TO_ADDR
// uc_nation := nation_american ;
2774: LD_ADDR_OWVAR 21
2778: PUSH
2779: LD_INT 1
2781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
2782: LD_ADDR_VAR 0 2
2786: PUSH
2787: LD_INT 22
2789: PUSH
2790: LD_INT 1
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: LD_INT 30
2799: PUSH
2800: LD_INT 32
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PPUSH
2811: CALL_OW 69
2815: PUSH
2816: FOR_IN
2817: IFFALSE 2872
// PlaceWeaponTurret ( i , [ us_machine_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 2
2826: PUSH
2827: LD_INT 3
2829: PUSH
2830: LD_INT 4
2832: PUSH
2833: LD_INT 5
2835: PUSH
2836: LD_INT 11
2838: PUSH
2839: LD_INT 3
2841: PUSH
2842: LD_INT 4
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: LIST
2853: PUSH
2854: LD_INT 1
2856: PPUSH
2857: LD_INT 7
2859: PPUSH
2860: CALL_OW 12
2864: ARRAY
2865: PPUSH
2866: CALL_OW 431
2870: GO 2816
2872: POP
2873: POP
// hc_name :=  ;
2874: LD_ADDR_OWVAR 26
2878: PUSH
2879: LD_STRING 
2881: ST_TO_ADDR
// hc_gallery :=  ;
2882: LD_ADDR_OWVAR 33
2886: PUSH
2887: LD_STRING 
2889: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
2890: LD_ADDR_VAR 0 2
2894: PUSH
2895: DOUBLE
2896: LD_INT 1
2898: DEC
2899: ST_TO_ADDR
2900: LD_INT 6
2902: PUSH
2903: LD_INT 5
2905: PUSH
2906: LD_INT 5
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: PUSH
2914: LD_OWVAR 67
2918: ARRAY
2919: PUSH
2920: FOR_TO
2921: IFFALSE 2979
// begin PrepareSoldier ( 1 , game_skill ) ;
2923: LD_INT 1
2925: PPUSH
2926: LD_EXP 38
2930: PPUSH
2931: CALL_OW 381
// un := CreateHuman ;
2935: LD_ADDR_VAR 0 4
2939: PUSH
2940: CALL_OW 44
2944: ST_TO_ADDR
// filter := filter ^ un ;
2945: LD_ADDR_VAR 0 3
2949: PUSH
2950: LD_VAR 0 3
2954: PUSH
2955: LD_VAR 0 4
2959: ADD
2960: ST_TO_ADDR
// soldiers := soldiers ^ un ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_VAR 0 4
2975: ADD
2976: ST_TO_ADDR
// end ;
2977: GO 2920
2979: POP
2980: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
2981: LD_ADDR_VAR 0 2
2985: PUSH
2986: DOUBLE
2987: LD_INT 1
2989: DEC
2990: ST_TO_ADDR
2991: LD_INT 3
2993: PUSH
2994: LD_INT 2
2996: PUSH
2997: LD_INT 2
2999: PUSH
3000: EMPTY
3001: LIST
3002: LIST
3003: LIST
3004: PUSH
3005: LD_OWVAR 67
3009: ARRAY
3010: PUSH
3011: FOR_TO
3012: IFFALSE 3066
// begin PrepareEngineer ( 0 , game_skill ) ;
3014: LD_INT 0
3016: PPUSH
3017: LD_EXP 38
3021: PPUSH
3022: CALL_OW 382
// un := CreateHuman ;
3026: LD_ADDR_VAR 0 4
3030: PUSH
3031: CALL_OW 44
3035: ST_TO_ADDR
// filter := filter ^ un ;
3036: LD_ADDR_VAR 0 3
3040: PUSH
3041: LD_VAR 0 3
3045: PUSH
3046: LD_VAR 0 4
3050: ADD
3051: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3052: LD_VAR 0 4
3056: PPUSH
3057: LD_INT 3
3059: PPUSH
3060: CALL_OW 52
// end ;
3064: GO 3011
3066: POP
3067: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: DOUBLE
3074: LD_INT 1
3076: DEC
3077: ST_TO_ADDR
3078: LD_INT 4
3080: PUSH
3081: LD_INT 3
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: FOR_TO
3099: IFFALSE 3153
// begin PrepareMechanic ( 0 , game_skill ) ;
3101: LD_INT 0
3103: PPUSH
3104: LD_EXP 38
3108: PPUSH
3109: CALL_OW 383
// un := CreateHuman ;
3113: LD_ADDR_VAR 0 4
3117: PUSH
3118: CALL_OW 44
3122: ST_TO_ADDR
// filter := filter ^ un ;
3123: LD_ADDR_VAR 0 3
3127: PUSH
3128: LD_VAR 0 3
3132: PUSH
3133: LD_VAR 0 4
3137: ADD
3138: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3139: LD_VAR 0 4
3143: PPUSH
3144: LD_INT 8
3146: PPUSH
3147: CALL_OW 52
// end ;
3151: GO 3098
3153: POP
3154: POP
// for i = 1 to 2 do
3155: LD_ADDR_VAR 0 2
3159: PUSH
3160: DOUBLE
3161: LD_INT 1
3163: DEC
3164: ST_TO_ADDR
3165: LD_INT 2
3167: PUSH
3168: FOR_TO
3169: IFFALSE 3223
// begin PrepareScientist ( 0 , game_skill ) ;
3171: LD_INT 0
3173: PPUSH
3174: LD_EXP 38
3178: PPUSH
3179: CALL_OW 384
// un := CreateHuman ;
3183: LD_ADDR_VAR 0 4
3187: PUSH
3188: CALL_OW 44
3192: ST_TO_ADDR
// filter := filter ^ un ;
3193: LD_ADDR_VAR 0 3
3197: PUSH
3198: LD_VAR 0 3
3202: PUSH
3203: LD_VAR 0 4
3207: ADD
3208: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3209: LD_VAR 0 4
3213: PPUSH
3214: LD_INT 14
3216: PPUSH
3217: CALL_OW 52
// end ;
3221: GO 3168
3223: POP
3224: POP
// for i = 1 to soldiers do
3225: LD_ADDR_VAR 0 2
3229: PUSH
3230: DOUBLE
3231: LD_INT 1
3233: DEC
3234: ST_TO_ADDR
3235: LD_VAR 0 5
3239: PUSH
3240: FOR_TO
3241: IFFALSE 3266
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3243: LD_VAR 0 5
3247: PUSH
3248: LD_VAR 0 2
3252: ARRAY
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 0
3259: PPUSH
3260: CALL_OW 49
3264: GO 3240
3266: POP
3267: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3268: LD_EXP 8
3272: PPUSH
3273: LD_INT 51
3275: PPUSH
3276: LD_INT 43
3278: PPUSH
3279: LD_INT 0
3281: PPUSH
3282: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3286: LD_EXP 9
3290: PPUSH
3291: LD_INT 55
3293: PPUSH
3294: LD_INT 58
3296: PPUSH
3297: LD_INT 0
3299: PPUSH
3300: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3304: LD_EXP 10
3308: PPUSH
3309: LD_INT 39
3311: PPUSH
3312: LD_INT 36
3314: PPUSH
3315: LD_INT 0
3317: PPUSH
3318: CALL_OW 48
// BetaSquad := filter diff 0 ;
3322: LD_ADDR_EXP 11
3326: PUSH
3327: LD_VAR 0 3
3331: PUSH
3332: LD_INT 0
3334: DIFF
3335: ST_TO_ADDR
// end ;
3336: LD_VAR 0 1
3340: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3341: LD_INT 0
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
3348: PPUSH
// uc_side := 6 ;
3349: LD_ADDR_OWVAR 20
3353: PUSH
3354: LD_INT 6
3356: ST_TO_ADDR
// uc_nation := nation_russian ;
3357: LD_ADDR_OWVAR 21
3361: PUSH
3362: LD_INT 3
3364: ST_TO_ADDR
// soldiers := [ ] ;
3365: LD_ADDR_VAR 0 4
3369: PUSH
3370: EMPTY
3371: ST_TO_ADDR
// vehs := [ ] ;
3372: LD_ADDR_VAR 0 6
3376: PUSH
3377: EMPTY
3378: ST_TO_ADDR
// RUArmada := [ ] ;
3379: LD_ADDR_EXP 16
3383: PUSH
3384: EMPTY
3385: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3386: LD_ADDR_EXP 12
3390: PUSH
3391: LD_STRING Yashin
3393: PPUSH
3394: CALL_OW 25
3398: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3399: LD_ADDR_EXP 13
3403: PUSH
3404: LD_STRING Popov
3406: PPUSH
3407: CALL_OW 25
3411: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3412: LD_ADDR_EXP 14
3416: PUSH
3417: LD_STRING Gaydar
3419: PPUSH
3420: CALL_OW 25
3424: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3425: LD_ADDR_EXP 15
3429: PUSH
3430: LD_STRING Vsevolod
3432: PPUSH
3433: CALL_OW 25
3437: ST_TO_ADDR
// for i = 1 to 16 do
3438: LD_ADDR_VAR 0 2
3442: PUSH
3443: DOUBLE
3444: LD_INT 1
3446: DEC
3447: ST_TO_ADDR
3448: LD_INT 16
3450: PUSH
3451: FOR_TO
3452: IFFALSE 3494
// begin PrepareSoldier ( 0 , game_eskill ) ;
3454: LD_INT 0
3456: PPUSH
3457: LD_EXP 39
3461: PPUSH
3462: CALL_OW 381
// un := CreateHuman ;
3466: LD_ADDR_VAR 0 5
3470: PUSH
3471: CALL_OW 44
3475: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3476: LD_ADDR_VAR 0 4
3480: PUSH
3481: LD_VAR 0 4
3485: PUSH
3486: LD_VAR 0 5
3490: ADD
3491: ST_TO_ADDR
// end ;
3492: GO 3451
3494: POP
3495: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3496: LD_ADDR_VAR 0 4
3500: PUSH
3501: LD_EXP 12
3505: PUSH
3506: LD_EXP 13
3510: ADD
3511: PUSH
3512: LD_EXP 14
3516: ADD
3517: PUSH
3518: LD_EXP 15
3522: ADD
3523: PUSH
3524: LD_VAR 0 4
3528: ADD
3529: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3530: LD_INT 24
3532: PPUSH
3533: LD_INT 3
3535: PPUSH
3536: LD_INT 1
3538: PPUSH
3539: LD_INT 46
3541: PPUSH
3542: LD_INT 100
3544: PPUSH
3545: CALL 18043 0 5
// for i = 1 to 8 do
3549: LD_ADDR_VAR 0 2
3553: PUSH
3554: DOUBLE
3555: LD_INT 1
3557: DEC
3558: ST_TO_ADDR
3559: LD_INT 8
3561: PUSH
3562: FOR_TO
3563: IFFALSE 3646
// begin vehicle := CreateVehicle ;
3565: LD_ADDR_VAR 0 3
3569: PUSH
3570: CALL_OW 45
3574: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3575: LD_VAR 0 4
3579: PUSH
3580: LD_INT 1
3582: ARRAY
3583: PPUSH
3584: LD_VAR 0 3
3588: PPUSH
3589: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3593: LD_ADDR_VAR 0 4
3597: PUSH
3598: LD_VAR 0 4
3602: PUSH
3603: LD_VAR 0 4
3607: PUSH
3608: LD_INT 1
3610: ARRAY
3611: DIFF
3612: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3613: LD_VAR 0 3
3617: PPUSH
3618: LD_INT 5
3620: PPUSH
3621: LD_INT 0
3623: PPUSH
3624: CALL_OW 49
// vehs := vehs ^ vehicle ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_VAR 0 3
3642: ADD
3643: ST_TO_ADDR
// end ;
3644: GO 3562
3646: POP
3647: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3648: LD_INT 24
3650: PPUSH
3651: LD_INT 3
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: LD_INT 43
3659: PPUSH
3660: LD_INT 100
3662: PPUSH
3663: CALL 18043 0 5
// for i = 1 to 8 do
3667: LD_ADDR_VAR 0 2
3671: PUSH
3672: DOUBLE
3673: LD_INT 1
3675: DEC
3676: ST_TO_ADDR
3677: LD_INT 8
3679: PUSH
3680: FOR_TO
3681: IFFALSE 3764
// begin vehicle := CreateVehicle ;
3683: LD_ADDR_VAR 0 3
3687: PUSH
3688: CALL_OW 45
3692: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3693: LD_VAR 0 4
3697: PUSH
3698: LD_INT 1
3700: ARRAY
3701: PPUSH
3702: LD_VAR 0 3
3706: PPUSH
3707: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3711: LD_ADDR_VAR 0 4
3715: PUSH
3716: LD_VAR 0 4
3720: PUSH
3721: LD_VAR 0 4
3725: PUSH
3726: LD_INT 1
3728: ARRAY
3729: DIFF
3730: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3731: LD_VAR 0 3
3735: PPUSH
3736: LD_INT 5
3738: PPUSH
3739: LD_INT 0
3741: PPUSH
3742: CALL_OW 49
// vehs := vehs ^ vehicle ;
3746: LD_ADDR_VAR 0 6
3750: PUSH
3751: LD_VAR 0 6
3755: PUSH
3756: LD_VAR 0 3
3760: ADD
3761: ST_TO_ADDR
// end ;
3762: GO 3680
3764: POP
3765: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
3766: LD_INT 22
3768: PPUSH
3769: LD_INT 3
3771: PPUSH
3772: LD_INT 1
3774: PPUSH
3775: LD_INT 44
3777: PPUSH
3778: LD_INT 100
3780: PPUSH
3781: CALL 18043 0 5
// for i = 1 to 4 do
3785: LD_ADDR_VAR 0 2
3789: PUSH
3790: DOUBLE
3791: LD_INT 1
3793: DEC
3794: ST_TO_ADDR
3795: LD_INT 4
3797: PUSH
3798: FOR_TO
3799: IFFALSE 3882
// begin vehicle := CreateVehicle ;
3801: LD_ADDR_VAR 0 3
3805: PUSH
3806: CALL_OW 45
3810: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3811: LD_VAR 0 4
3815: PUSH
3816: LD_INT 1
3818: ARRAY
3819: PPUSH
3820: LD_VAR 0 3
3824: PPUSH
3825: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3829: LD_ADDR_VAR 0 4
3833: PUSH
3834: LD_VAR 0 4
3838: PUSH
3839: LD_VAR 0 4
3843: PUSH
3844: LD_INT 1
3846: ARRAY
3847: DIFF
3848: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3849: LD_VAR 0 3
3853: PPUSH
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: CALL_OW 49
// vehs := vehs ^ vehicle ;
3864: LD_ADDR_VAR 0 6
3868: PUSH
3869: LD_VAR 0 6
3873: PUSH
3874: LD_VAR 0 3
3878: ADD
3879: ST_TO_ADDR
// end ;
3880: GO 3798
3882: POP
3883: POP
// RUArmada := vehs ;
3884: LD_ADDR_EXP 16
3888: PUSH
3889: LD_VAR 0 6
3893: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
3894: LD_EXP 12
3898: PPUSH
3899: CALL_OW 310
3903: PUSH
3904: LD_EXP 13
3908: PPUSH
3909: CALL_OW 310
3913: PUSH
3914: LD_EXP 14
3918: PPUSH
3919: CALL_OW 310
3923: PUSH
3924: LD_EXP 15
3928: PPUSH
3929: CALL_OW 310
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: PPUSH
3940: LD_INT 6
3942: NEG
3943: PPUSH
3944: CALL_OW 242
// end ;
3948: LD_VAR 0 1
3952: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
3953: LD_INT 0
3955: PPUSH
3956: PPUSH
3957: PPUSH
// uc_side := 6 ;
3958: LD_ADDR_OWVAR 20
3962: PUSH
3963: LD_INT 6
3965: ST_TO_ADDR
// uc_nation := nation_russian ;
3966: LD_ADDR_OWVAR 21
3970: PUSH
3971: LD_INT 3
3973: ST_TO_ADDR
// Bulldozers := [ ] ;
3974: LD_ADDR_EXP 17
3978: PUSH
3979: EMPTY
3980: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
3981: LD_INT 24
3983: PPUSH
3984: LD_INT 3
3986: PPUSH
3987: LD_INT 3
3989: PPUSH
3990: LD_INT 53
3992: PPUSH
3993: LD_INT 100
3995: PPUSH
3996: CALL 18043 0 5
// for i = 1 to 2 do
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: DOUBLE
4006: LD_INT 1
4008: DEC
4009: ST_TO_ADDR
4010: LD_INT 2
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4059
// begin vehicle := CreateVehicle ;
4016: LD_ADDR_VAR 0 3
4020: PUSH
4021: CALL_OW 45
4025: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4026: LD_VAR 0 3
4030: PPUSH
4031: LD_INT 5
4033: PPUSH
4034: LD_INT 0
4036: PPUSH
4037: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4041: LD_ADDR_EXP 17
4045: PUSH
4046: LD_EXP 17
4050: PUSH
4051: LD_VAR 0 3
4055: ADD
4056: ST_TO_ADDR
// end ;
4057: GO 4013
4059: POP
4060: POP
// end ;
4061: LD_VAR 0 1
4065: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4066: LD_INT 0
4068: PPUSH
4069: PPUSH
4070: PPUSH
4071: PPUSH
// uc_side := 3 ;
4072: LD_ADDR_OWVAR 20
4076: PUSH
4077: LD_INT 3
4079: ST_TO_ADDR
// uc_nation := nation_russian ;
4080: LD_ADDR_OWVAR 21
4084: PUSH
4085: LD_INT 3
4087: ST_TO_ADDR
// hc_name :=  ;
4088: LD_ADDR_OWVAR 26
4092: PUSH
4093: LD_STRING 
4095: ST_TO_ADDR
// hc_gallery :=  ;
4096: LD_ADDR_OWVAR 33
4100: PUSH
4101: LD_STRING 
4103: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4104: LD_ADDR_EXP 18
4108: PUSH
4109: LD_STRING Burlak
4111: PPUSH
4112: CALL_OW 25
4116: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4117: LD_ADDR_EXP 19
4121: PUSH
4122: LD_STRING Gleb
4124: PPUSH
4125: CALL_OW 25
4129: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4130: LD_ADDR_EXP 20
4134: PUSH
4135: LD_STRING Furmanov
4137: PPUSH
4138: CALL_OW 25
4142: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4143: LD_ADDR_EXP 21
4147: PUSH
4148: LD_STRING Titov
4150: PPUSH
4151: CALL_OW 25
4155: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4156: LD_ADDR_EXP 22
4160: PUSH
4161: LD_STRING Scholtze
4163: PPUSH
4164: CALL_OW 25
4168: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4169: LD_ADDR_EXP 23
4173: PUSH
4174: LD_STRING Dolgov
4176: PPUSH
4177: CALL_OW 25
4181: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4182: LD_ADDR_EXP 24
4186: PUSH
4187: LD_STRING Kapitsova
4189: PPUSH
4190: CALL_OW 25
4194: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4195: LD_ADDR_EXP 25
4199: PUSH
4200: LD_STRING Karamazov
4202: PPUSH
4203: CALL_OW 25
4207: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4208: LD_ADDR_EXP 26
4212: PUSH
4213: LD_STRING Kirlenkova
4215: PPUSH
4216: CALL_OW 25
4220: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4221: LD_ADDR_EXP 27
4225: PUSH
4226: LD_STRING Kovalyuk
4228: PPUSH
4229: CALL_OW 25
4233: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4234: LD_ADDR_EXP 28
4238: PUSH
4239: LD_STRING Kozlov
4241: PPUSH
4242: CALL_OW 25
4246: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4247: LD_ADDR_EXP 29
4251: PUSH
4252: LD_STRING Kuzmov
4254: PPUSH
4255: CALL_OW 25
4259: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4260: LD_ADDR_EXP 30
4264: PUSH
4265: LD_STRING Lipshchin
4267: PPUSH
4268: CALL_OW 25
4272: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4273: LD_ADDR_EXP 31
4277: PUSH
4278: LD_STRING Oblukov
4280: PPUSH
4281: CALL_OW 25
4285: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4286: LD_ADDR_EXP 32
4290: PUSH
4291: LD_STRING Xavier2
4293: PPUSH
4294: CALL_OW 25
4298: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4299: LD_ADDR_EXP 33
4303: PUSH
4304: LD_STRING Gnyevko
4306: PPUSH
4307: CALL_OW 25
4311: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4312: LD_ADDR_EXP 34
4316: PUSH
4317: LD_STRING Belkov
4319: PPUSH
4320: CALL_OW 25
4324: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4325: LD_ADDR_VAR 0 3
4329: PUSH
4330: LD_EXP 18
4334: PUSH
4335: LD_EXP 19
4339: PUSH
4340: LD_EXP 20
4344: PUSH
4345: LD_EXP 21
4349: PUSH
4350: LD_EXP 22
4354: PUSH
4355: LD_EXP 23
4359: PUSH
4360: LD_EXP 24
4364: PUSH
4365: LD_EXP 25
4369: PUSH
4370: LD_EXP 26
4374: PUSH
4375: LD_EXP 27
4379: PUSH
4380: LD_EXP 28
4384: PUSH
4385: LD_EXP 29
4389: PUSH
4390: LD_EXP 30
4394: PUSH
4395: LD_EXP 31
4399: PUSH
4400: LD_EXP 32
4404: PUSH
4405: LD_EXP 33
4409: PUSH
4410: LD_EXP 34
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: LIST
4424: LIST
4425: LIST
4426: LIST
4427: LIST
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: ST_TO_ADDR
// for i = 1 to filter do
4434: LD_ADDR_VAR 0 2
4438: PUSH
4439: DOUBLE
4440: LD_INT 1
4442: DEC
4443: ST_TO_ADDR
4444: LD_VAR 0 3
4448: PUSH
4449: FOR_TO
4450: IFFALSE 4475
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4452: LD_VAR 0 3
4456: PUSH
4457: LD_VAR 0 2
4461: ARRAY
4462: PPUSH
4463: LD_INT 6
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 49
4473: GO 4449
4475: POP
4476: POP
// end ;
4477: LD_VAR 0 1
4481: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4482: LD_INT 0
4484: PPUSH
4485: PPUSH
4486: PPUSH
4487: PPUSH
// uc_side := 3 ;
4488: LD_ADDR_OWVAR 20
4492: PUSH
4493: LD_INT 3
4495: ST_TO_ADDR
// uc_nation := nation_russian ;
4496: LD_ADDR_OWVAR 21
4500: PUSH
4501: LD_INT 3
4503: ST_TO_ADDR
// hc_name :=  ;
4504: LD_ADDR_OWVAR 26
4508: PUSH
4509: LD_STRING 
4511: ST_TO_ADDR
// hc_gallery :=  ;
4512: LD_ADDR_OWVAR 33
4516: PUSH
4517: LD_STRING 
4519: ST_TO_ADDR
// for i = 1 to 8 do
4520: LD_ADDR_VAR 0 2
4524: PUSH
4525: DOUBLE
4526: LD_INT 1
4528: DEC
4529: ST_TO_ADDR
4530: LD_INT 8
4532: PUSH
4533: FOR_TO
4534: IFFALSE 4576
// begin PrepareSoldier ( 0 , game_eskill ) ;
4536: LD_INT 0
4538: PPUSH
4539: LD_EXP 39
4543: PPUSH
4544: CALL_OW 381
// un := CreateHuman ;
4548: LD_ADDR_VAR 0 4
4552: PUSH
4553: CALL_OW 44
4557: ST_TO_ADDR
// filter := filter ^ un ;
4558: LD_ADDR_VAR 0 3
4562: PUSH
4563: LD_VAR 0 3
4567: PUSH
4568: LD_VAR 0 4
4572: ADD
4573: ST_TO_ADDR
// end ;
4574: GO 4533
4576: POP
4577: POP
// for i = 1 to 4 do
4578: LD_ADDR_VAR 0 2
4582: PUSH
4583: DOUBLE
4584: LD_INT 1
4586: DEC
4587: ST_TO_ADDR
4588: LD_INT 4
4590: PUSH
4591: FOR_TO
4592: IFFALSE 4634
// begin PrepareEngineer ( 0 , game_eskill ) ;
4594: LD_INT 0
4596: PPUSH
4597: LD_EXP 39
4601: PPUSH
4602: CALL_OW 382
// un := CreateHuman ;
4606: LD_ADDR_VAR 0 4
4610: PUSH
4611: CALL_OW 44
4615: ST_TO_ADDR
// filter := filter ^ un ;
4616: LD_ADDR_VAR 0 3
4620: PUSH
4621: LD_VAR 0 3
4625: PUSH
4626: LD_VAR 0 4
4630: ADD
4631: ST_TO_ADDR
// end ;
4632: GO 4591
4634: POP
4635: POP
// for i = 1 to 6 do
4636: LD_ADDR_VAR 0 2
4640: PUSH
4641: DOUBLE
4642: LD_INT 1
4644: DEC
4645: ST_TO_ADDR
4646: LD_INT 6
4648: PUSH
4649: FOR_TO
4650: IFFALSE 4692
// begin PrepareMechanic ( 0 , game_eskill ) ;
4652: LD_INT 0
4654: PPUSH
4655: LD_EXP 39
4659: PPUSH
4660: CALL_OW 383
// un := CreateHuman ;
4664: LD_ADDR_VAR 0 4
4668: PUSH
4669: CALL_OW 44
4673: ST_TO_ADDR
// filter := filter ^ un ;
4674: LD_ADDR_VAR 0 3
4678: PUSH
4679: LD_VAR 0 3
4683: PUSH
4684: LD_VAR 0 4
4688: ADD
4689: ST_TO_ADDR
// end ;
4690: GO 4649
4692: POP
4693: POP
// for i = 1 to 4 do
4694: LD_ADDR_VAR 0 2
4698: PUSH
4699: DOUBLE
4700: LD_INT 1
4702: DEC
4703: ST_TO_ADDR
4704: LD_INT 4
4706: PUSH
4707: FOR_TO
4708: IFFALSE 4750
// begin PrepareScientist ( 0 , game_eskill ) ;
4710: LD_INT 0
4712: PPUSH
4713: LD_EXP 39
4717: PPUSH
4718: CALL_OW 384
// un := CreateHuman ;
4722: LD_ADDR_VAR 0 4
4726: PUSH
4727: CALL_OW 44
4731: ST_TO_ADDR
// filter := filter ^ un ;
4732: LD_ADDR_VAR 0 3
4736: PUSH
4737: LD_VAR 0 3
4741: PUSH
4742: LD_VAR 0 4
4746: ADD
4747: ST_TO_ADDR
// end ;
4748: GO 4707
4750: POP
4751: POP
// for i = 1 to filter do
4752: LD_ADDR_VAR 0 2
4756: PUSH
4757: DOUBLE
4758: LD_INT 1
4760: DEC
4761: ST_TO_ADDR
4762: LD_VAR 0 3
4766: PUSH
4767: FOR_TO
4768: IFFALSE 4793
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4770: LD_VAR 0 3
4774: PUSH
4775: LD_VAR 0 2
4779: ARRAY
4780: PPUSH
4781: LD_INT 6
4783: PPUSH
4784: LD_INT 0
4786: PPUSH
4787: CALL_OW 49
4791: GO 4767
4793: POP
4794: POP
// RU_SecondPersonnel := filter ;
4795: LD_ADDR_EXP 35
4799: PUSH
4800: LD_VAR 0 3
4804: ST_TO_ADDR
// end ;
4805: LD_VAR 0 1
4809: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
4810: LD_INT 0
4812: PPUSH
4813: PPUSH
4814: PPUSH
4815: PPUSH
4816: PPUSH
4817: PPUSH
4818: PPUSH
// uc_side := 1 ;
4819: LD_ADDR_OWVAR 20
4823: PUSH
4824: LD_INT 1
4826: ST_TO_ADDR
// uc_nation := nation_american ;
4827: LD_ADDR_OWVAR 21
4831: PUSH
4832: LD_INT 1
4834: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
4835: LD_ADDR_EXP 36
4839: PUSH
4840: LD_STRING JMM
4842: PPUSH
4843: CALL_OW 25
4847: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
4848: LD_EXP 36
4852: PPUSH
4853: LD_INT 1
4855: PPUSH
4856: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
4860: LD_EXP 36
4864: PPUSH
4865: LD_INT 7
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 49
// mechs := [ ] ;
4875: LD_ADDR_VAR 0 7
4879: PUSH
4880: EMPTY
4881: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: DOUBLE
4888: LD_INT 1
4890: DEC
4891: ST_TO_ADDR
4892: LD_INT 4
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: LD_INT 3
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: LIST
4905: PUSH
4906: LD_OWVAR 67
4910: ARRAY
4911: PUSH
4912: FOR_TO
4913: IFFALSE 4974
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
4915: LD_INT 0
4917: PPUSH
4918: LD_EXP 38
4922: PUSH
4923: LD_INT 1
4925: PLUS
4926: PPUSH
4927: CALL_OW 381
// un := CreateHuman ;
4931: LD_ADDR_VAR 0 4
4935: PUSH
4936: CALL_OW 44
4940: ST_TO_ADDR
// soldiers := soldiers ^ un ;
4941: LD_ADDR_VAR 0 3
4945: PUSH
4946: LD_VAR 0 3
4950: PUSH
4951: LD_VAR 0 4
4955: ADD
4956: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
4957: LD_VAR 0 4
4961: PPUSH
4962: LD_INT 7
4964: PPUSH
4965: LD_INT 0
4967: PPUSH
4968: CALL_OW 49
// end ;
4972: GO 4912
4974: POP
4975: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
4976: LD_ADDR_VAR 0 2
4980: PUSH
4981: DOUBLE
4982: LD_INT 1
4984: DEC
4985: ST_TO_ADDR
4986: LD_INT 7
4988: PUSH
4989: LD_INT 6
4991: PUSH
4992: LD_INT 4
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: PUSH
5000: LD_OWVAR 67
5004: ARRAY
5005: PUSH
5006: FOR_TO
5007: IFFALSE 5053
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5009: LD_INT 0
5011: PPUSH
5012: LD_EXP 38
5016: PUSH
5017: LD_INT 1
5019: PLUS
5020: PPUSH
5021: CALL_OW 383
// un := CreateHuman ;
5025: LD_ADDR_VAR 0 4
5029: PUSH
5030: CALL_OW 44
5034: ST_TO_ADDR
// mechs := mechs ^ un ;
5035: LD_ADDR_VAR 0 7
5039: PUSH
5040: LD_VAR 0 7
5044: PUSH
5045: LD_VAR 0 4
5049: ADD
5050: ST_TO_ADDR
// end ;
5051: GO 5006
5053: POP
5054: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5055: LD_INT 3
5057: PPUSH
5058: LD_INT 3
5060: PPUSH
5061: LD_INT 1
5063: PPUSH
5064: LD_INT 5
5066: PPUSH
5067: LD_INT 100
5069: PPUSH
5070: CALL 18043 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5074: LD_ADDR_VAR 0 2
5078: PUSH
5079: DOUBLE
5080: LD_INT 1
5082: DEC
5083: ST_TO_ADDR
5084: LD_INT 7
5086: PUSH
5087: LD_INT 6
5089: PUSH
5090: LD_INT 4
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: LIST
5097: PUSH
5098: LD_OWVAR 67
5102: ARRAY
5103: PUSH
5104: FOR_TO
5105: IFFALSE 5200
// begin vehicle := CreateVehicle ;
5107: LD_ADDR_VAR 0 6
5111: PUSH
5112: CALL_OW 45
5116: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5117: LD_VAR 0 7
5121: PUSH
5122: LD_INT 1
5124: ARRAY
5125: PPUSH
5126: LD_VAR 0 6
5130: PPUSH
5131: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5135: LD_ADDR_VAR 0 7
5139: PUSH
5140: LD_VAR 0 7
5144: PUSH
5145: LD_VAR 0 7
5149: PUSH
5150: LD_INT 1
5152: ARRAY
5153: DIFF
5154: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5155: LD_VAR 0 6
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5167: LD_VAR 0 6
5171: PPUSH
5172: LD_INT 7
5174: PPUSH
5175: LD_INT 0
5177: PPUSH
5178: CALL_OW 49
// vehs := vehs ^ vehicle ;
5182: LD_ADDR_VAR 0 5
5186: PUSH
5187: LD_VAR 0 5
5191: PUSH
5192: LD_VAR 0 6
5196: ADD
5197: ST_TO_ADDR
// end ;
5198: GO 5104
5200: POP
5201: POP
// end ; end_of_file
5202: LD_VAR 0 1
5206: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export function GameType ; begin
5207: LD_INT 0
5209: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5210: LD_ADDR_OWVAR 67
5214: PUSH
5215: LD_INT 0
5217: PPUSH
5218: CALL_OW 426
5222: ST_TO_ADDR
// game_diff := Difficulty ;
5223: LD_ADDR_EXP 37
5227: PUSH
5228: LD_OWVAR 67
5232: ST_TO_ADDR
// game_skill := [ 7 , 6 , 6 ] [ game_diff ] ;
5233: LD_ADDR_EXP 38
5237: PUSH
5238: LD_INT 7
5240: PUSH
5241: LD_INT 6
5243: PUSH
5244: LD_INT 6
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: LIST
5251: PUSH
5252: LD_EXP 37
5256: ARRAY
5257: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5258: LD_ADDR_EXP 39
5262: PUSH
5263: LD_INT 6
5265: PUSH
5266: LD_INT 7
5268: PUSH
5269: LD_INT 8
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: PUSH
5277: LD_EXP 37
5281: ARRAY
5282: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$30 , 2 2$00 ] [ game_diff ] ;
5283: LD_ADDR_EXP 41
5287: PUSH
5288: LD_INT 6300
5290: PUSH
5291: LD_INT 5250
5293: PUSH
5294: LD_INT 4200
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: LIST
5301: PUSH
5302: LD_EXP 37
5306: ARRAY
5307: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5308: LD_ADDR_EXP 40
5312: PUSH
5313: LD_INT 73500
5315: PUSH
5316: LD_INT 94500
5318: PUSH
5319: LD_INT 115500
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: LIST
5326: PUSH
5327: LD_EXP 37
5331: ARRAY
5332: ST_TO_ADDR
// end ; end_of_file
5333: LD_VAR 0 1
5337: RET
// export function CustomEvent ( event ) ; begin
5338: LD_INT 0
5340: PPUSH
// end ;
5341: LD_VAR 0 2
5345: RET
// export function CustomInitMacro ( ) ; begin
5346: LD_INT 0
5348: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5349: LD_INT 1
5351: PPUSH
5352: LD_INT 3
5354: PPUSH
5355: CALL 78990 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5359: LD_INT 1
5361: PPUSH
5362: LD_INT 4
5364: PPUSH
5365: CALL 78934 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5369: LD_INT 1
5371: PPUSH
5372: LD_INT 136
5374: PUSH
5375: LD_INT 130
5377: PUSH
5378: LD_INT 0
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: LIST
5385: PUSH
5386: LD_INT 145
5388: PUSH
5389: LD_INT 123
5391: PUSH
5392: LD_INT 0
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL 77993 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5408: LD_INT 1
5410: PPUSH
5411: LD_INT 43
5413: PUSH
5414: LD_INT 46
5416: PUSH
5417: LD_INT 45
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: LIST
5424: PPUSH
5425: CALL 78822 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5429: LD_INT 1
5431: PPUSH
5432: LD_INT 3
5434: PPUSH
5435: CALL 78504 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5439: LD_INT 1
5441: PPUSH
5442: LD_INT 3
5444: PPUSH
5445: CALL 78235 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5449: LD_INT 1
5451: PPUSH
5452: LD_INT 8
5454: PPUSH
5455: CALL 77854 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5459: LD_INT 1
5461: PPUSH
5462: LD_INT 22
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 3
5470: PUSH
5471: LD_INT 43
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 22
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 3
5488: PUSH
5489: LD_INT 44
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: LD_INT 22
5500: PUSH
5501: LD_INT 1
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: LD_INT 45
5509: PUSH
5510: EMPTY
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 24
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: LD_INT 43
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: LIST
5533: PUSH
5534: LD_INT 24
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 3
5542: PUSH
5543: LD_INT 43
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_INT 24
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 3
5560: PUSH
5561: LD_INT 46
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 22
5572: PUSH
5573: LD_INT 1
5575: PUSH
5576: LD_INT 3
5578: PUSH
5579: LD_INT 43
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: LIST
5586: LIST
5587: PUSH
5588: LD_INT 22
5590: PUSH
5591: LD_INT 1
5593: PUSH
5594: LD_INT 3
5596: PUSH
5597: LD_INT 44
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: PPUSH
5616: CALL 77669 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
5620: LD_INT 1
5622: PPUSH
5623: LD_INT 0
5625: PUSH
5626: LD_INT 127
5628: PUSH
5629: LD_INT 125
5631: PUSH
5632: LD_INT 5
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: PUSH
5641: LD_INT 6
5643: PUSH
5644: LD_INT 124
5646: PUSH
5647: LD_INT 132
5649: PUSH
5650: LD_INT 0
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 29
5661: PUSH
5662: LD_INT 136
5664: PUSH
5665: LD_INT 130
5667: PUSH
5668: LD_INT 1
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: PUSH
5677: LD_INT 4
5679: PUSH
5680: LD_INT 118
5682: PUSH
5683: LD_INT 114
5685: PUSH
5686: LD_INT 2
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: LIST
5693: LIST
5694: PUSH
5695: LD_INT 29
5697: PUSH
5698: LD_INT 145
5700: PUSH
5701: LD_INT 123
5703: PUSH
5704: LD_INT 1
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 26
5715: PUSH
5716: LD_INT 150
5718: PUSH
5719: LD_INT 135
5721: PUSH
5722: LD_INT 1
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: LIST
5729: LIST
5730: PUSH
5731: LD_INT 26
5733: PUSH
5734: LD_INT 140
5736: PUSH
5737: LD_INT 134
5739: PUSH
5740: LD_INT 2
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: PUSH
5749: LD_INT 26
5751: PUSH
5752: LD_INT 137
5754: PUSH
5755: LD_INT 121
5757: PUSH
5758: LD_INT 5
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: LIST
5765: LIST
5766: PUSH
5767: LD_INT 2
5769: PUSH
5770: LD_INT 155
5772: PUSH
5773: LD_INT 130
5775: PUSH
5776: LD_INT 0
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: LIST
5784: PUSH
5785: LD_INT 32
5787: PUSH
5788: LD_INT 155
5790: PUSH
5791: LD_INT 130
5793: PUSH
5794: LD_INT 0
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 32
5805: PUSH
5806: LD_INT 130
5808: PUSH
5809: LD_INT 114
5811: PUSH
5812: LD_INT 3
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_INT 32
5823: PUSH
5824: LD_INT 142
5826: PUSH
5827: LD_INT 115
5829: PUSH
5830: LD_INT 3
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: LIST
5838: PUSH
5839: LD_INT 32
5841: PUSH
5842: LD_INT 153
5844: PUSH
5845: LD_INT 120
5847: PUSH
5848: LD_INT 3
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: PPUSH
5872: CALL 77561 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
5876: LD_INT 1
5878: PPUSH
5879: LD_INT 10
5881: PUSH
5882: LD_INT 12
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PPUSH
5889: CALL 78411 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
5893: LD_INT 1
5895: PPUSH
5896: LD_INT 155
5898: PPUSH
5899: LD_INT 130
5901: PPUSH
5902: LD_INT 0
5904: PPUSH
5905: LD_INT 24
5907: PUSH
5908: LD_INT 16
5910: PUSH
5911: LD_INT 17
5913: PUSH
5914: LD_INT 18
5916: PUSH
5917: LD_INT 21
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: PPUSH
5927: CALL 78616 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
5931: LD_INT 2
5933: PPUSH
5934: LD_INT 3
5936: PPUSH
5937: CALL 78990 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
5941: LD_INT 2
5943: PPUSH
5944: LD_INT 4
5946: PPUSH
5947: CALL 78934 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
5951: LD_INT 2
5953: PPUSH
5954: LD_INT 84
5956: PUSH
5957: LD_INT 125
5959: PUSH
5960: LD_INT 1
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: EMPTY
5969: LIST
5970: PPUSH
5971: CALL 77993 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5975: LD_INT 2
5977: PPUSH
5978: LD_INT 43
5980: PUSH
5981: LD_INT 46
5983: PUSH
5984: LD_INT 45
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: PPUSH
5992: CALL 78822 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
5996: LD_INT 2
5998: PPUSH
5999: LD_INT 3
6001: PPUSH
6002: CALL 78504 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6006: LD_INT 2
6008: PPUSH
6009: LD_INT 3
6011: PPUSH
6012: CALL 78235 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6016: LD_INT 2
6018: PPUSH
6019: LD_INT 8
6021: PPUSH
6022: CALL 77854 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6026: LD_INT 2
6028: PPUSH
6029: LD_INT 22
6031: PUSH
6032: LD_INT 3
6034: PUSH
6035: LD_INT 3
6037: PUSH
6038: LD_INT 43
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 22
6049: PUSH
6050: LD_INT 3
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 44
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 22
6067: PUSH
6068: LD_INT 3
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: LD_INT 45
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: PUSH
6083: LD_INT 24
6085: PUSH
6086: LD_INT 3
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: LD_INT 43
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 24
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 43
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: PUSH
6119: LD_INT 24
6121: PUSH
6122: LD_INT 3
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 46
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 22
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: LD_INT 3
6145: PUSH
6146: LD_INT 43
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 22
6157: PUSH
6158: LD_INT 3
6160: PUSH
6161: LD_INT 3
6163: PUSH
6164: LD_INT 44
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PPUSH
6183: CALL 77669 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6187: LD_INT 2
6189: PPUSH
6190: LD_INT 0
6192: PUSH
6193: LD_INT 96
6195: PUSH
6196: LD_INT 125
6198: PUSH
6199: LD_INT 0
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 6
6210: PUSH
6211: LD_INT 74
6213: PUSH
6214: LD_INT 122
6216: PUSH
6217: LD_INT 1
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 30
6228: PUSH
6229: LD_INT 84
6231: PUSH
6232: LD_INT 125
6234: PUSH
6235: LD_INT 1
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 28
6246: PUSH
6247: LD_INT 86
6249: PUSH
6250: LD_INT 128
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 28
6264: PUSH
6265: LD_INT 85
6267: PUSH
6268: LD_INT 130
6270: PUSH
6271: LD_INT 2
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 28
6282: PUSH
6283: LD_INT 88
6285: PUSH
6286: LD_INT 132
6288: PUSH
6289: LD_INT 5
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 2
6300: PUSH
6301: LD_INT 106
6303: PUSH
6304: LD_INT 130
6306: PUSH
6307: LD_INT 0
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 4
6318: PUSH
6319: LD_INT 99
6321: PUSH
6322: LD_INT 114
6324: PUSH
6325: LD_INT 3
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 32
6336: PUSH
6337: LD_INT 72
6339: PUSH
6340: LD_INT 112
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_INT 32
6354: PUSH
6355: LD_INT 78
6357: PUSH
6358: LD_INT 110
6360: PUSH
6361: LD_INT 3
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 32
6372: PUSH
6373: LD_INT 84
6375: PUSH
6376: LD_INT 110
6378: PUSH
6379: LD_INT 2
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 32
6390: PUSH
6391: LD_INT 105
6393: PUSH
6394: LD_INT 117
6396: PUSH
6397: LD_INT 3
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: LIST
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: PPUSH
6420: CALL 77561 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6424: LD_INT 2
6426: PPUSH
6427: LD_INT 14
6429: PUSH
6430: LD_INT 11
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PPUSH
6437: CALL 78411 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6441: LD_INT 2
6443: PPUSH
6444: LD_INT 106
6446: PPUSH
6447: LD_INT 130
6449: PPUSH
6450: LD_INT 0
6452: PPUSH
6453: LD_INT 24
6455: PUSH
6456: LD_INT 16
6458: PUSH
6459: LD_INT 17
6461: PUSH
6462: LD_INT 18
6464: PUSH
6465: LD_INT 21
6467: PUSH
6468: EMPTY
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL 78616 0 5
// end ;
6479: LD_VAR 0 1
6483: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6484: LD_INT 22
6486: PUSH
6487: LD_INT 3
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 30
6496: PUSH
6497: LD_INT 3
6499: PUSH
6500: EMPTY
6501: LIST
6502: LIST
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 69
6512: IFFALSE 7368
6514: GO 6516
6516: DISABLE
6517: LD_INT 0
6519: PPUSH
6520: PPUSH
6521: PPUSH
6522: PPUSH
6523: PPUSH
6524: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6525: LD_INT 6300
6527: PUSH
6528: LD_INT 4200
6530: PUSH
6531: LD_INT 2100
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: LIST
6538: PUSH
6539: LD_OWVAR 67
6543: ARRAY
6544: PPUSH
6545: CALL_OW 67
// base := 2 ;
6549: LD_ADDR_VAR 0 2
6553: PUSH
6554: LD_INT 2
6556: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6557: LD_INT 22
6559: PUSH
6560: LD_INT 3
6562: PUSH
6563: EMPTY
6564: LIST
6565: LIST
6566: PUSH
6567: LD_INT 30
6569: PUSH
6570: LD_INT 3
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PPUSH
6581: CALL_OW 69
6585: NOT
6586: IFFALSE 6590
// continue ;
6588: GO 6525
// case Rand ( 1 , 3 ) of 1 :
6590: LD_INT 1
6592: PPUSH
6593: LD_INT 3
6595: PPUSH
6596: CALL_OW 12
6600: PUSH
6601: LD_INT 1
6603: DOUBLE
6604: EQUAL
6605: IFTRUE 6609
6607: GO 6785
6609: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6610: LD_ADDR_VAR 0 3
6614: PUSH
6615: LD_INT 22
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 3
6623: PUSH
6624: LD_INT 43
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 24
6635: PUSH
6636: LD_INT 3
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 46
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 24
6653: PUSH
6654: LD_INT 3
6656: PUSH
6657: LD_INT 3
6659: PUSH
6660: LD_INT 43
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 24
6671: PUSH
6672: LD_INT 3
6674: PUSH
6675: LD_INT 3
6677: PUSH
6678: LD_INT 46
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_INT 3
6692: PUSH
6693: LD_INT 3
6695: PUSH
6696: LD_INT 45
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 22
6707: PUSH
6708: LD_INT 3
6710: PUSH
6711: LD_INT 3
6713: PUSH
6714: LD_INT 43
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 24
6725: PUSH
6726: LD_INT 3
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 22
6743: PUSH
6744: LD_INT 3
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 45
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: EMPTY
6760: LIST
6761: LIST
6762: LIST
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: LIST
6768: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6769: LD_VAR 0 2
6773: PPUSH
6774: LD_VAR 0 3
6778: PPUSH
6779: CALL 77717 0 2
// end ; 2 :
6783: GO 7116
6785: LD_INT 2
6787: DOUBLE
6788: EQUAL
6789: IFTRUE 6793
6791: GO 6931
6793: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6794: LD_ADDR_VAR 0 3
6798: PUSH
6799: LD_INT 24
6801: PUSH
6802: LD_INT 3
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 43
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: PUSH
6817: LD_INT 24
6819: PUSH
6820: LD_INT 3
6822: PUSH
6823: LD_INT 3
6825: PUSH
6826: LD_INT 46
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 24
6837: PUSH
6838: LD_INT 3
6840: PUSH
6841: LD_INT 3
6843: PUSH
6844: LD_INT 43
6846: PUSH
6847: EMPTY
6848: LIST
6849: LIST
6850: LIST
6851: LIST
6852: PUSH
6853: LD_INT 24
6855: PUSH
6856: LD_INT 3
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: LD_INT 46
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: LIST
6869: LIST
6870: PUSH
6871: LD_INT 22
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 3
6879: PUSH
6880: LD_INT 45
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: LIST
6887: LIST
6888: PUSH
6889: LD_INT 22
6891: PUSH
6892: LD_INT 3
6894: PUSH
6895: LD_INT 3
6897: PUSH
6898: LD_INT 45
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: LIST
6905: LIST
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: LIST
6912: LIST
6913: LIST
6914: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6915: LD_VAR 0 2
6919: PPUSH
6920: LD_VAR 0 3
6924: PPUSH
6925: CALL 77717 0 2
// end ; 3 :
6929: GO 7116
6931: LD_INT 3
6933: DOUBLE
6934: EQUAL
6935: IFTRUE 6939
6937: GO 7115
6939: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
6940: LD_ADDR_VAR 0 3
6944: PUSH
6945: LD_INT 22
6947: PUSH
6948: LD_INT 3
6950: PUSH
6951: LD_INT 3
6953: PUSH
6954: LD_INT 43
6956: PUSH
6957: EMPTY
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: PUSH
6963: LD_INT 24
6965: PUSH
6966: LD_INT 3
6968: PUSH
6969: LD_INT 3
6971: PUSH
6972: LD_INT 46
6974: PUSH
6975: EMPTY
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 22
6983: PUSH
6984: LD_INT 3
6986: PUSH
6987: LD_INT 3
6989: PUSH
6990: LD_INT 43
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 24
7001: PUSH
7002: LD_INT 3
7004: PUSH
7005: LD_INT 3
7007: PUSH
7008: LD_INT 46
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: PUSH
7017: LD_INT 22
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 3
7025: PUSH
7026: LD_INT 45
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 22
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: LD_INT 3
7043: PUSH
7044: LD_INT 43
7046: PUSH
7047: EMPTY
7048: LIST
7049: LIST
7050: LIST
7051: LIST
7052: PUSH
7053: LD_INT 24
7055: PUSH
7056: LD_INT 3
7058: PUSH
7059: LD_INT 3
7061: PUSH
7062: LD_INT 46
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: LIST
7069: LIST
7070: PUSH
7071: LD_INT 22
7073: PUSH
7074: LD_INT 3
7076: PUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 45
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: LIST
7093: LIST
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: CALL 77717 0 2
// end ; end ;
7113: GO 7116
7115: POP
// repeat wait ( 0 0$1 ) ;
7116: LD_INT 35
7118: PPUSH
7119: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7123: LD_VAR 0 2
7127: PPUSH
7128: CALL 78065 0 1
7132: PUSH
7133: LD_INT 0
7135: EQUAL
7136: IFFALSE 7116
// wait ( 0 0$30 ) ;
7138: LD_INT 1050
7140: PPUSH
7141: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7145: LD_ADDR_VAR 0 5
7149: PUSH
7150: LD_INT 86
7152: PUSH
7153: LD_INT 77
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: PUSH
7160: LD_INT 63
7162: PUSH
7163: LD_INT 38
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7174: LD_ADDR_VAR 0 4
7178: PUSH
7179: LD_INT 0
7181: PUSH
7182: LD_INT 0
7184: PUSH
7185: LD_INT 0
7187: PUSH
7188: LD_INT 1
7190: PUSH
7191: LD_INT 0
7193: PUSH
7194: LD_INT 0
7196: PUSH
7197: LD_INT 0
7199: PUSH
7200: LD_INT 0
7202: PUSH
7203: LD_INT 1
7205: PUSH
7206: LD_INT 0
7208: PUSH
7209: EMPTY
7210: LIST
7211: LIST
7212: LIST
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: LIST
7218: LIST
7219: LIST
7220: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7221: LD_ADDR_VAR 0 6
7225: PUSH
7226: LD_EXP 71
7230: PUSH
7231: LD_VAR 0 2
7235: ARRAY
7236: PUSH
7237: LD_EXP 74
7241: PUSH
7242: LD_VAR 0 2
7246: ARRAY
7247: DIFF
7248: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7249: LD_ADDR_EXP 71
7253: PUSH
7254: LD_EXP 71
7258: PPUSH
7259: LD_VAR 0 2
7263: PPUSH
7264: LD_EXP 71
7268: PUSH
7269: LD_VAR 0 2
7273: ARRAY
7274: PUSH
7275: LD_VAR 0 6
7279: DIFF
7280: PPUSH
7281: CALL_OW 1
7285: ST_TO_ADDR
// if not attackers then
7286: LD_VAR 0 6
7290: NOT
7291: IFFALSE 7295
// continue ;
7293: GO 6525
// repeat wait ( 0 0$1 ) ;
7295: LD_INT 35
7297: PPUSH
7298: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7302: LD_VAR 0 6
7306: PPUSH
7307: LD_INT 60
7309: PUSH
7310: EMPTY
7311: LIST
7312: PPUSH
7313: CALL_OW 72
7317: NOT
7318: IFFALSE 7295
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7320: LD_VAR 0 2
7324: PPUSH
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_VAR 0 5
7334: PPUSH
7335: LD_VAR 0 4
7339: PPUSH
7340: CALL 77902 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
7344: LD_EXP 52
7348: PUSH
7349: LD_VAR 0 2
7353: ARRAY
7354: PPUSH
7355: LD_INT 50
7357: PUSH
7358: EMPTY
7359: LIST
7360: PPUSH
7361: CALL_OW 72
7365: NOT
7366: IFFALSE 6525
// end ;
7368: PPOPN 6
7370: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
7371: LD_INT 22
7373: PUSH
7374: LD_INT 3
7376: PUSH
7377: EMPTY
7378: LIST
7379: LIST
7380: PUSH
7381: LD_INT 30
7383: PUSH
7384: LD_INT 3
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: PUSH
7391: EMPTY
7392: LIST
7393: LIST
7394: PPUSH
7395: CALL_OW 69
7399: IFFALSE 8296
7401: GO 7403
7403: DISABLE
7404: LD_INT 0
7406: PPUSH
7407: PPUSH
7408: PPUSH
7409: PPUSH
7410: PPUSH
7411: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
7412: LD_INT 6300
7414: PUSH
7415: LD_INT 4200
7417: PUSH
7418: LD_INT 2100
7420: PUSH
7421: EMPTY
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: CALL_OW 67
// base := 1 ;
7436: LD_ADDR_VAR 0 2
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7444: LD_INT 22
7446: PUSH
7447: LD_INT 3
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: LD_INT 30
7456: PUSH
7457: LD_INT 3
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: PUSH
7464: EMPTY
7465: LIST
7466: LIST
7467: PPUSH
7468: CALL_OW 69
7472: NOT
7473: IFFALSE 7477
// continue ;
7475: GO 7412
// case Rand ( 1 , 3 ) of 1 :
7477: LD_INT 1
7479: PPUSH
7480: LD_INT 3
7482: PPUSH
7483: CALL_OW 12
7487: PUSH
7488: LD_INT 1
7490: DOUBLE
7491: EQUAL
7492: IFTRUE 7496
7494: GO 7672
7496: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7497: LD_ADDR_VAR 0 3
7501: PUSH
7502: LD_INT 22
7504: PUSH
7505: LD_INT 1
7507: PUSH
7508: LD_INT 3
7510: PUSH
7511: LD_INT 43
7513: PUSH
7514: EMPTY
7515: LIST
7516: LIST
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 24
7522: PUSH
7523: LD_INT 1
7525: PUSH
7526: LD_INT 3
7528: PUSH
7529: LD_INT 46
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: LIST
7536: LIST
7537: PUSH
7538: LD_INT 24
7540: PUSH
7541: LD_INT 1
7543: PUSH
7544: LD_INT 3
7546: PUSH
7547: LD_INT 43
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 24
7558: PUSH
7559: LD_INT 1
7561: PUSH
7562: LD_INT 3
7564: PUSH
7565: LD_INT 46
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_INT 22
7576: PUSH
7577: LD_INT 1
7579: PUSH
7580: LD_INT 3
7582: PUSH
7583: LD_INT 45
7585: PUSH
7586: EMPTY
7587: LIST
7588: LIST
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 22
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 43
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 24
7612: PUSH
7613: LD_INT 1
7615: PUSH
7616: LD_INT 3
7618: PUSH
7619: LD_INT 46
7621: PUSH
7622: EMPTY
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 22
7630: PUSH
7631: LD_INT 1
7633: PUSH
7634: LD_INT 3
7636: PUSH
7637: LD_INT 45
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: LIST
7644: LIST
7645: PUSH
7646: EMPTY
7647: LIST
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7656: LD_VAR 0 2
7660: PPUSH
7661: LD_VAR 0 3
7665: PPUSH
7666: CALL 77717 0 2
// end ; 2 :
7670: GO 8041
7672: LD_INT 2
7674: DOUBLE
7675: EQUAL
7676: IFTRUE 7680
7678: GO 7856
7680: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 24
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 3
7694: PUSH
7695: LD_INT 43
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 24
7706: PUSH
7707: LD_INT 1
7709: PUSH
7710: LD_INT 3
7712: PUSH
7713: LD_INT 46
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 24
7724: PUSH
7725: LD_INT 1
7727: PUSH
7728: LD_INT 3
7730: PUSH
7731: LD_INT 43
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 24
7742: PUSH
7743: LD_INT 1
7745: PUSH
7746: LD_INT 3
7748: PUSH
7749: LD_INT 46
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: LIST
7756: LIST
7757: PUSH
7758: LD_INT 22
7760: PUSH
7761: LD_INT 1
7763: PUSH
7764: LD_INT 3
7766: PUSH
7767: LD_INT 45
7769: PUSH
7770: EMPTY
7771: LIST
7772: LIST
7773: LIST
7774: LIST
7775: PUSH
7776: LD_INT 22
7778: PUSH
7779: LD_INT 1
7781: PUSH
7782: LD_INT 3
7784: PUSH
7785: LD_INT 45
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: LIST
7792: LIST
7793: PUSH
7794: LD_INT 22
7796: PUSH
7797: LD_INT 1
7799: PUSH
7800: LD_INT 3
7802: PUSH
7803: LD_INT 45
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: PUSH
7812: LD_INT 22
7814: PUSH
7815: LD_INT 1
7817: PUSH
7818: LD_INT 3
7820: PUSH
7821: LD_INT 45
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: LIST
7834: LIST
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: LD_VAR 0 3
7849: PPUSH
7850: CALL 77717 0 2
// end ; 3 :
7854: GO 8041
7856: LD_INT 3
7858: DOUBLE
7859: EQUAL
7860: IFTRUE 7864
7862: GO 8040
7864: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
7865: LD_ADDR_VAR 0 3
7869: PUSH
7870: LD_INT 22
7872: PUSH
7873: LD_INT 1
7875: PUSH
7876: LD_INT 3
7878: PUSH
7879: LD_INT 43
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: LIST
7886: LIST
7887: PUSH
7888: LD_INT 24
7890: PUSH
7891: LD_INT 1
7893: PUSH
7894: LD_INT 3
7896: PUSH
7897: LD_INT 46
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 22
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 3
7914: PUSH
7915: LD_INT 43
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: LIST
7922: LIST
7923: PUSH
7924: LD_INT 24
7926: PUSH
7927: LD_INT 1
7929: PUSH
7930: LD_INT 3
7932: PUSH
7933: LD_INT 46
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 22
7944: PUSH
7945: LD_INT 1
7947: PUSH
7948: LD_INT 3
7950: PUSH
7951: LD_INT 45
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: LIST
7958: LIST
7959: PUSH
7960: LD_INT 22
7962: PUSH
7963: LD_INT 1
7965: PUSH
7966: LD_INT 3
7968: PUSH
7969: LD_INT 43
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 24
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 46
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: PUSH
7996: LD_INT 22
7998: PUSH
7999: LD_INT 1
8001: PUSH
8002: LD_INT 3
8004: PUSH
8005: LD_INT 45
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: LIST
8012: LIST
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: LIST
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8024: LD_VAR 0 2
8028: PPUSH
8029: LD_VAR 0 3
8033: PPUSH
8034: CALL 77717 0 2
// end ; end ;
8038: GO 8041
8040: POP
// repeat wait ( 0 0$1 ) ;
8041: LD_INT 35
8043: PPUSH
8044: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8048: LD_VAR 0 2
8052: PPUSH
8053: LD_INT 1
8055: PPUSH
8056: CALL 79135 0 2
8060: PUSH
8061: LD_INT 8
8063: GREATEREQUAL
8064: IFFALSE 8041
// wait ( 0 0$30 ) ;
8066: LD_INT 1050
8068: PPUSH
8069: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8073: LD_ADDR_VAR 0 5
8077: PUSH
8078: LD_INT 144
8080: PUSH
8081: LD_INT 65
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 63
8090: PUSH
8091: LD_INT 38
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: EMPTY
8099: LIST
8100: LIST
8101: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8102: LD_ADDR_VAR 0 4
8106: PUSH
8107: LD_INT 0
8109: PUSH
8110: LD_INT 0
8112: PUSH
8113: LD_INT 0
8115: PUSH
8116: LD_INT 1
8118: PUSH
8119: LD_INT 0
8121: PUSH
8122: LD_INT 0
8124: PUSH
8125: LD_INT 0
8127: PUSH
8128: LD_INT 0
8130: PUSH
8131: LD_INT 1
8133: PUSH
8134: LD_INT 0
8136: PUSH
8137: EMPTY
8138: LIST
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: LIST
8144: LIST
8145: LIST
8146: LIST
8147: LIST
8148: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8149: LD_ADDR_VAR 0 6
8153: PUSH
8154: LD_EXP 71
8158: PUSH
8159: LD_VAR 0 2
8163: ARRAY
8164: PUSH
8165: LD_EXP 74
8169: PUSH
8170: LD_VAR 0 2
8174: ARRAY
8175: DIFF
8176: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8177: LD_ADDR_EXP 71
8181: PUSH
8182: LD_EXP 71
8186: PPUSH
8187: LD_VAR 0 2
8191: PPUSH
8192: LD_EXP 71
8196: PUSH
8197: LD_VAR 0 2
8201: ARRAY
8202: PUSH
8203: LD_VAR 0 6
8207: DIFF
8208: PPUSH
8209: CALL_OW 1
8213: ST_TO_ADDR
// if not attackers then
8214: LD_VAR 0 6
8218: NOT
8219: IFFALSE 8223
// continue ;
8221: GO 7412
// repeat wait ( 0 0$1 ) ;
8223: LD_INT 35
8225: PPUSH
8226: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8230: LD_VAR 0 6
8234: PPUSH
8235: LD_INT 60
8237: PUSH
8238: EMPTY
8239: LIST
8240: PPUSH
8241: CALL_OW 72
8245: NOT
8246: IFFALSE 8223
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_VAR 0 6
8257: PPUSH
8258: LD_VAR 0 5
8262: PPUSH
8263: LD_VAR 0 4
8267: PPUSH
8268: CALL 77902 0 4
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8272: LD_EXP 52
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 50
8285: PUSH
8286: EMPTY
8287: LIST
8288: PPUSH
8289: CALL_OW 72
8293: NOT
8294: IFFALSE 7412
// end ;
8296: PPOPN 6
8298: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8299: LD_EXP 3
8303: PUSH
8304: LD_INT 22
8306: PUSH
8307: LD_INT 3
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: PUSH
8314: LD_INT 21
8316: PUSH
8317: LD_INT 1
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: PUSH
8324: EMPTY
8325: LIST
8326: LIST
8327: PPUSH
8328: CALL_OW 69
8332: PUSH
8333: LD_INT 0
8335: EQUAL
8336: AND
8337: IFFALSE 8350
8339: GO 8341
8341: DISABLE
// begin RussiansDefeated := true ;
8342: LD_ADDR_EXP 42
8346: PUSH
8347: LD_INT 1
8349: ST_TO_ADDR
// end ;
8350: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
8351: LD_EXP 3
8355: PUSH
8356: LD_EXP 5
8360: NOT
8361: AND
8362: IFFALSE 9335
8364: GO 8366
8366: DISABLE
8367: LD_INT 0
8369: PPUSH
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
8375: PPUSH
8376: PPUSH
8377: PPUSH
8378: PPUSH
8379: PPUSH
8380: PPUSH
// begin wait ( [ Rand ( 5 5$00 , 6 6$30 ) , Rand ( 4 4$30 , 5 5$30 ) , Rand ( 4 4$00 , 5 5$00 ) ] [ Difficulty ] ) ;
8381: LD_INT 10500
8383: PPUSH
8384: LD_INT 13650
8386: PPUSH
8387: CALL_OW 12
8391: PUSH
8392: LD_INT 9450
8394: PPUSH
8395: LD_INT 11550
8397: PPUSH
8398: CALL_OW 12
8402: PUSH
8403: LD_INT 8400
8405: PPUSH
8406: LD_INT 10500
8408: PPUSH
8409: CALL_OW 12
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: LIST
8418: PUSH
8419: LD_OWVAR 67
8423: ARRAY
8424: PPUSH
8425: CALL_OW 67
// filter := [ ] ;
8429: LD_ADDR_VAR 0 3
8433: PUSH
8434: EMPTY
8435: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8436: LD_ADDR_VAR 0 4
8440: PUSH
8441: LD_INT 2
8443: PPUSH
8444: LD_INT 3
8446: PPUSH
8447: CALL_OW 12
8451: PUSH
8452: LD_INT 3
8454: PPUSH
8455: LD_INT 4
8457: PPUSH
8458: CALL_OW 12
8462: PUSH
8463: LD_INT 3
8465: PPUSH
8466: LD_INT 5
8468: PPUSH
8469: CALL_OW 12
8473: PUSH
8474: EMPTY
8475: LIST
8476: LIST
8477: LIST
8478: PUSH
8479: LD_OWVAR 67
8483: ARRAY
8484: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
8485: LD_ADDR_VAR 0 5
8489: PUSH
8490: LD_INT 1
8492: PUSH
8493: LD_INT 1
8495: PPUSH
8496: LD_INT 2
8498: PPUSH
8499: CALL_OW 12
8503: PUSH
8504: LD_INT 2
8506: PPUSH
8507: LD_INT 3
8509: PPUSH
8510: CALL_OW 12
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: LIST
8519: PUSH
8520: LD_OWVAR 67
8524: ARRAY
8525: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
8526: LD_ADDR_VAR 0 6
8530: PUSH
8531: LD_INT 2
8533: PPUSH
8534: LD_INT 3
8536: PPUSH
8537: CALL_OW 12
8541: PUSH
8542: LD_INT 2
8544: PPUSH
8545: LD_INT 4
8547: PPUSH
8548: CALL_OW 12
8552: PUSH
8553: LD_INT 3
8555: PPUSH
8556: LD_INT 5
8558: PPUSH
8559: CALL_OW 12
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: PUSH
8569: LD_OWVAR 67
8573: ARRAY
8574: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
8575: LD_ADDR_VAR 0 8
8579: PUSH
8580: LD_INT 1
8582: PUSH
8583: LD_INT 2
8585: PUSH
8586: LD_INT 2
8588: PUSH
8589: EMPTY
8590: LIST
8591: LIST
8592: LIST
8593: PUSH
8594: LD_OWVAR 67
8598: ARRAY
8599: ST_TO_ADDR
// uc_side := 3 ;
8600: LD_ADDR_OWVAR 20
8604: PUSH
8605: LD_INT 3
8607: ST_TO_ADDR
// uc_nation := nation_russian ;
8608: LD_ADDR_OWVAR 21
8612: PUSH
8613: LD_INT 3
8615: ST_TO_ADDR
// for i = 1 to soldiers do
8616: LD_ADDR_VAR 0 1
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_VAR 0 4
8630: PUSH
8631: FOR_TO
8632: IFFALSE 8674
// begin PrepareSoldier ( 0 , game_eskill ) ;
8634: LD_INT 0
8636: PPUSH
8637: LD_EXP 39
8641: PPUSH
8642: CALL_OW 381
// un := CreateHuman ;
8646: LD_ADDR_VAR 0 2
8650: PUSH
8651: CALL_OW 44
8655: ST_TO_ADDR
// filter := filter ^ un ;
8656: LD_ADDR_VAR 0 3
8660: PUSH
8661: LD_VAR 0 3
8665: PUSH
8666: LD_VAR 0 2
8670: ADD
8671: ST_TO_ADDR
// end ;
8672: GO 8631
8674: POP
8675: POP
// for i = 1 to bazookas do
8676: LD_ADDR_VAR 0 1
8680: PUSH
8681: DOUBLE
8682: LD_INT 1
8684: DEC
8685: ST_TO_ADDR
8686: LD_VAR 0 5
8690: PUSH
8691: FOR_TO
8692: IFFALSE 8742
// begin PrepareSoldier ( 0 , game_eskill ) ;
8694: LD_INT 0
8696: PPUSH
8697: LD_EXP 39
8701: PPUSH
8702: CALL_OW 381
// hc_class := class_bazooker ;
8706: LD_ADDR_OWVAR 28
8710: PUSH
8711: LD_INT 9
8713: ST_TO_ADDR
// un := CreateHuman ;
8714: LD_ADDR_VAR 0 2
8718: PUSH
8719: CALL_OW 44
8723: ST_TO_ADDR
// filter := filter ^ un ;
8724: LD_ADDR_VAR 0 3
8728: PUSH
8729: LD_VAR 0 3
8733: PUSH
8734: LD_VAR 0 2
8738: ADD
8739: ST_TO_ADDR
// end ;
8740: GO 8691
8742: POP
8743: POP
// for i = 1 to medics do
8744: LD_ADDR_VAR 0 1
8748: PUSH
8749: DOUBLE
8750: LD_INT 1
8752: DEC
8753: ST_TO_ADDR
8754: LD_VAR 0 8
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8802
// begin PrepareScientist ( 0 , game_eskill ) ;
8762: LD_INT 0
8764: PPUSH
8765: LD_EXP 39
8769: PPUSH
8770: CALL_OW 384
// un := CreateHuman ;
8774: LD_ADDR_VAR 0 2
8778: PUSH
8779: CALL_OW 44
8783: ST_TO_ADDR
// filter := filter ^ un ;
8784: LD_ADDR_VAR 0 3
8788: PUSH
8789: LD_VAR 0 3
8793: PUSH
8794: LD_VAR 0 2
8798: ADD
8799: ST_TO_ADDR
// end ;
8800: GO 8759
8802: POP
8803: POP
// for i = 1 to vehs do
8804: LD_ADDR_VAR 0 1
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_VAR 0 6
8818: PUSH
8819: FOR_TO
8820: IFFALSE 9012
// begin case Rand ( 1 , 5 ) of 1 :
8822: LD_INT 1
8824: PPUSH
8825: LD_INT 5
8827: PPUSH
8828: CALL_OW 12
8832: PUSH
8833: LD_INT 1
8835: DOUBLE
8836: EQUAL
8837: IFTRUE 8841
8839: GO 8863
8841: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
8842: LD_INT 22
8844: PPUSH
8845: LD_INT 3
8847: PPUSH
8848: LD_INT 3
8850: PPUSH
8851: LD_INT 43
8853: PPUSH
8854: LD_INT 100
8856: PPUSH
8857: CALL 18043 0 5
8861: GO 8984
8863: LD_INT 2
8865: DOUBLE
8866: EQUAL
8867: IFTRUE 8871
8869: GO 8893
8871: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
8872: LD_INT 22
8874: PPUSH
8875: LD_INT 3
8877: PPUSH
8878: LD_INT 3
8880: PPUSH
8881: LD_INT 44
8883: PPUSH
8884: LD_INT 100
8886: PPUSH
8887: CALL 18043 0 5
8891: GO 8984
8893: LD_INT 3
8895: DOUBLE
8896: EQUAL
8897: IFTRUE 8901
8899: GO 8923
8901: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
8902: LD_INT 22
8904: PPUSH
8905: LD_INT 3
8907: PPUSH
8908: LD_INT 3
8910: PPUSH
8911: LD_INT 45
8913: PPUSH
8914: LD_INT 100
8916: PPUSH
8917: CALL 18043 0 5
8921: GO 8984
8923: LD_INT 4
8925: DOUBLE
8926: EQUAL
8927: IFTRUE 8931
8929: GO 8953
8931: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
8932: LD_INT 24
8934: PPUSH
8935: LD_INT 3
8937: PPUSH
8938: LD_INT 3
8940: PPUSH
8941: LD_INT 43
8943: PPUSH
8944: LD_INT 100
8946: PPUSH
8947: CALL 18043 0 5
8951: GO 8984
8953: LD_INT 5
8955: DOUBLE
8956: EQUAL
8957: IFTRUE 8961
8959: GO 8983
8961: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
8962: LD_INT 24
8964: PPUSH
8965: LD_INT 3
8967: PPUSH
8968: LD_INT 3
8970: PPUSH
8971: LD_INT 46
8973: PPUSH
8974: LD_INT 100
8976: PPUSH
8977: CALL 18043 0 5
8981: GO 8984
8983: POP
// vehicle := CreateVehicle ;
8984: LD_ADDR_VAR 0 7
8988: PUSH
8989: CALL_OW 45
8993: ST_TO_ADDR
// filter := filter ^ vehicle ;
8994: LD_ADDR_VAR 0 3
8998: PUSH
8999: LD_VAR 0 3
9003: PUSH
9004: LD_VAR 0 7
9008: ADD
9009: ST_TO_ADDR
// end ;
9010: GO 8819
9012: POP
9013: POP
// for i = 1 to filter do
9014: LD_ADDR_VAR 0 1
9018: PUSH
9019: DOUBLE
9020: LD_INT 1
9022: DEC
9023: ST_TO_ADDR
9024: LD_VAR 0 3
9028: PUSH
9029: FOR_TO
9030: IFFALSE 9055
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
9032: LD_VAR 0 3
9036: PUSH
9037: LD_VAR 0 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 14
9045: PPUSH
9046: LD_INT 0
9048: PPUSH
9049: CALL_OW 49
9053: GO 9029
9055: POP
9056: POP
// case Rand ( 1 , 3 ) of 1 :
9057: LD_INT 1
9059: PPUSH
9060: LD_INT 3
9062: PPUSH
9063: CALL_OW 12
9067: PUSH
9068: LD_INT 1
9070: DOUBLE
9071: EQUAL
9072: IFTRUE 9076
9074: GO 9130
9076: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
9077: LD_ADDR_VAR 0 11
9081: PUSH
9082: LD_INT 165
9084: PUSH
9085: LD_INT 114
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 104
9094: PUSH
9095: LD_INT 108
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 86
9104: PUSH
9105: LD_INT 77
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: LD_INT 63
9114: PUSH
9115: LD_INT 38
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: LIST
9126: LIST
9127: ST_TO_ADDR
9128: GO 9255
9130: LD_INT 2
9132: DOUBLE
9133: EQUAL
9134: IFTRUE 9138
9136: GO 9192
9138: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
9139: LD_ADDR_VAR 0 11
9143: PUSH
9144: LD_INT 165
9146: PUSH
9147: LD_INT 114
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: LD_INT 146
9156: PUSH
9157: LD_INT 71
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PUSH
9164: LD_INT 112
9166: PUSH
9167: LD_INT 41
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PUSH
9174: LD_INT 63
9176: PUSH
9177: LD_INT 38
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: LIST
9188: LIST
9189: ST_TO_ADDR
9190: GO 9255
9192: LD_INT 3
9194: DOUBLE
9195: EQUAL
9196: IFTRUE 9200
9198: GO 9254
9200: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
9201: LD_ADDR_VAR 0 11
9205: PUSH
9206: LD_INT 165
9208: PUSH
9209: LD_INT 114
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PUSH
9216: LD_INT 63
9218: PUSH
9219: LD_INT 99
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: LD_INT 55
9228: PUSH
9229: LD_INT 77
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PUSH
9236: LD_INT 63
9238: PUSH
9239: LD_INT 38
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: LIST
9250: LIST
9251: ST_TO_ADDR
9252: GO 9255
9254: POP
// attackers := filter ;
9255: LD_ADDR_VAR 0 10
9259: PUSH
9260: LD_VAR 0 3
9264: ST_TO_ADDR
// flags := [ 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 ] ;
9265: LD_ADDR_VAR 0 12
9269: PUSH
9270: LD_INT 0
9272: PUSH
9273: LD_INT 1
9275: PUSH
9276: LD_INT 0
9278: PUSH
9279: LD_INT 1
9281: PUSH
9282: LD_INT 1
9284: PUSH
9285: LD_INT 0
9287: PUSH
9288: LD_INT 0
9290: PUSH
9291: LD_INT 0
9293: PUSH
9294: LD_INT 1
9296: PUSH
9297: LD_INT 1
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: LIST
9307: LIST
9308: LIST
9309: LIST
9310: LIST
9311: ST_TO_ADDR
// MC_PrepareAttack ( 1 , attackers , _target , flags ) ;
9312: LD_INT 1
9314: PPUSH
9315: LD_VAR 0 10
9319: PPUSH
9320: LD_VAR 0 11
9324: PPUSH
9325: LD_VAR 0 12
9329: PPUSH
9330: CALL 77902 0 4
// enable ;
9334: ENABLE
// end ;
9335: PPOPN 12
9337: END
// every 0 0$1 do var i , tmp ;
9338: GO 9340
9340: DISABLE
9341: LD_INT 0
9343: PPUSH
9344: PPUSH
// begin enable ;
9345: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_INT 3
9353: PUSH
9354: LD_INT 22
9356: PUSH
9357: LD_INT 1
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PUSH
9368: LD_INT 32
9370: PUSH
9371: LD_INT 1
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PPUSH
9382: CALL_OW 69
9386: ST_TO_ADDR
// if tmp then
9387: LD_VAR 0 2
9391: IFFALSE 9437
// for i in tmp do
9393: LD_ADDR_VAR 0 1
9397: PUSH
9398: LD_VAR 0 2
9402: PUSH
9403: FOR_IN
9404: IFFALSE 9435
// if GetFuel ( i ) < 3 then
9406: LD_VAR 0 1
9410: PPUSH
9411: CALL_OW 261
9415: PUSH
9416: LD_INT 3
9418: LESS
9419: IFFALSE 9433
// SetFuel ( i , 3 ) ;
9421: LD_VAR 0 1
9425: PPUSH
9426: LD_INT 3
9428: PPUSH
9429: CALL_OW 240
9433: GO 9403
9435: POP
9436: POP
// end ;
9437: PPOPN 2
9439: END
// every 0 0$3 trigger FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) or FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) do var i , veh , tmp ;
9440: LD_INT 3
9442: PPUSH
9443: LD_INT 22
9445: PUSH
9446: LD_INT 1
9448: PUSH
9449: EMPTY
9450: LIST
9451: LIST
9452: PPUSH
9453: CALL_OW 70
9457: PUSH
9458: LD_INT 10
9460: PPUSH
9461: LD_INT 22
9463: PUSH
9464: LD_INT 1
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PPUSH
9471: CALL_OW 70
9475: OR
9476: IFFALSE 9742
9478: GO 9480
9480: DISABLE
9481: LD_INT 0
9483: PPUSH
9484: PPUSH
9485: PPUSH
// begin tmp := [ ] ;
9486: LD_ADDR_VAR 0 3
9490: PUSH
9491: EMPTY
9492: ST_TO_ADDR
// for i := 1 to 12 do
9493: LD_ADDR_VAR 0 1
9497: PUSH
9498: DOUBLE
9499: LD_INT 1
9501: DEC
9502: ST_TO_ADDR
9503: LD_INT 12
9505: PUSH
9506: FOR_TO
9507: IFFALSE 9646
// begin uc_side := 3 ;
9509: LD_ADDR_OWVAR 20
9513: PUSH
9514: LD_INT 3
9516: ST_TO_ADDR
// uc_nation := 3 ;
9517: LD_ADDR_OWVAR 21
9521: PUSH
9522: LD_INT 3
9524: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
9525: LD_INT 23
9527: PPUSH
9528: LD_INT 3
9530: PPUSH
9531: LD_INT 3
9533: PPUSH
9534: LD_INT 46
9536: PUSH
9537: LD_INT 43
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: PUSH
9544: LD_INT 1
9546: PPUSH
9547: LD_INT 2
9549: PPUSH
9550: CALL_OW 12
9554: ARRAY
9555: PPUSH
9556: LD_INT 100
9558: PPUSH
9559: CALL 18043 0 5
// veh := CreateVehicle ;
9563: LD_ADDR_VAR 0 2
9567: PUSH
9568: CALL_OW 45
9572: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
9573: LD_VAR 0 2
9577: PPUSH
9578: LD_INT 5
9580: PPUSH
9581: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
9585: LD_VAR 0 2
9589: PPUSH
9590: LD_INT 199
9592: PPUSH
9593: LD_INT 135
9595: PPUSH
9596: LD_INT 3
9598: PPUSH
9599: LD_INT 0
9601: PPUSH
9602: CALL_OW 50
// tmp := tmp ^ veh ;
9606: LD_ADDR_VAR 0 3
9610: PUSH
9611: LD_VAR 0 3
9615: PUSH
9616: LD_VAR 0 2
9620: ADD
9621: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
9622: LD_VAR 0 2
9626: PPUSH
9627: LD_INT 173
9629: PPUSH
9630: LD_INT 118
9632: PPUSH
9633: CALL_OW 111
// wait ( 0 0$2 ) ;
9637: LD_INT 70
9639: PPUSH
9640: CALL_OW 67
// end ;
9644: GO 9506
9646: POP
9647: POP
// repeat wait ( 0 0$1 ) ;
9648: LD_INT 35
9650: PPUSH
9651: CALL_OW 67
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 3
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9733
// if IsDead ( i ) then
9668: LD_VAR 0 1
9672: PPUSH
9673: CALL_OW 301
9677: IFFALSE 9697
// tmp := tmp diff i else
9679: LD_ADDR_VAR 0 3
9683: PUSH
9684: LD_VAR 0 3
9688: PUSH
9689: LD_VAR 0 1
9693: DIFF
9694: ST_TO_ADDR
9695: GO 9731
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
9697: LD_VAR 0 1
9701: PPUSH
9702: LD_INT 22
9704: PUSH
9705: LD_INT 1
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 69
9716: PPUSH
9717: LD_VAR 0 1
9721: PPUSH
9722: CALL_OW 74
9726: PPUSH
9727: CALL_OW 115
9731: GO 9665
9733: POP
9734: POP
// until not tmp ;
9735: LD_VAR 0 3
9739: NOT
9740: IFFALSE 9648
// end ; end_of_file
9742: PPOPN 3
9744: END
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
9745: LD_VAR 0 1
9749: PUSH
9750: LD_EXP 8
9754: EQUAL
9755: IFFALSE 9771
// begin wait ( 0 0$1 ) ;
9757: LD_INT 35
9759: PPUSH
9760: CALL_OW 67
// YouLost ( Brighton ) ;
9764: LD_STRING Brighton
9766: PPUSH
9767: CALL_OW 104
// end ; if un = JMM then
9771: LD_VAR 0 1
9775: PUSH
9776: LD_EXP 36
9780: EQUAL
9781: IFFALSE 9797
// begin wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// YouLost ( JMM ) ;
9790: LD_STRING JMM
9792: PPUSH
9793: CALL_OW 104
// end ; if un = Megan then
9797: LD_VAR 0 1
9801: PUSH
9802: LD_EXP 10
9806: EQUAL
9807: IFFALSE 9821
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
9809: LD_EXP 8
9813: PPUSH
9814: LD_STRING DBrighton-MeganDeath
9816: PPUSH
9817: CALL_OW 88
// end ; if un = Palmer then
9821: LD_VAR 0 1
9825: PUSH
9826: LD_EXP 9
9830: EQUAL
9831: IFFALSE 9845
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
9833: LD_EXP 8
9837: PPUSH
9838: LD_STRING DBrighton-PalmerDeath
9840: PPUSH
9841: CALL_OW 88
// end ; if un = Burlak then
9845: LD_VAR 0 1
9849: PUSH
9850: LD_EXP 18
9854: EQUAL
9855: IFFALSE 9887
// begin if JMM_Arrived then
9857: LD_EXP 5
9861: IFFALSE 9875
// Say ( JMM , DJMM-BurlakDead ) ;
9863: LD_EXP 36
9867: PPUSH
9868: LD_STRING DJMM-BurlakDead
9870: PPUSH
9871: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
9875: LD_EXP 9
9879: PPUSH
9880: LD_STRING DSol-BurlakDead
9882: PPUSH
9883: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
9887: LD_VAR 0 1
9891: PUSH
9892: LD_INT 1
9894: EQUAL
9895: PUSH
9896: LD_VAR 0 1
9900: PUSH
9901: LD_INT 3
9903: EQUAL
9904: OR
9905: IFFALSE 9921
// begin wait ( 0 0$1 ) ;
9907: LD_INT 35
9909: PPUSH
9910: CALL_OW 67
// YouLost ( Depot ) ;
9914: LD_STRING Depot
9916: PPUSH
9917: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
9921: LD_VAR 0 1
9925: PPUSH
9926: CALL_OW 255
9930: PUSH
9931: LD_INT 1
9933: EQUAL
9934: PUSH
9935: LD_VAR 0 1
9939: PPUSH
9940: CALL_OW 247
9944: PUSH
9945: LD_INT 1
9947: EQUAL
9948: AND
9949: IFFALSE 9965
// Losses := Losses + 1 ;
9951: LD_ADDR_EXP 43
9955: PUSH
9956: LD_EXP 43
9960: PUSH
9961: LD_INT 1
9963: PLUS
9964: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
9965: LD_VAR 0 1
9969: PPUSH
9970: CALL 81109 0 1
// end ;
9974: PPOPN 1
9976: END
// on UnitGoesToRed ( un ) do begin if un = Yashin then
9977: LD_VAR 0 1
9981: PUSH
9982: LD_EXP 12
9986: EQUAL
9987: IFFALSE 10001
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
9989: LD_EXP 12
9993: PPUSH
9994: LD_STRING DDeath-Yas-3
9996: PPUSH
9997: CALL_OW 91
// if un = Popov then
10001: LD_VAR 0 1
10005: PUSH
10006: LD_EXP 13
10010: EQUAL
10011: IFFALSE 10025
// ForceSay ( Popov , DDeath-Pop-3 ) ;
10013: LD_EXP 13
10017: PPUSH
10018: LD_STRING DDeath-Pop-3
10020: PPUSH
10021: CALL_OW 91
// if un = Gaydar then
10025: LD_VAR 0 1
10029: PUSH
10030: LD_EXP 14
10034: EQUAL
10035: IFFALSE 10049
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
10037: LD_EXP 14
10041: PPUSH
10042: LD_STRING DDeath-Gay-3
10044: PPUSH
10045: CALL_OW 91
// if un = Sevi then
10049: LD_VAR 0 1
10053: PUSH
10054: LD_EXP 15
10058: EQUAL
10059: IFFALSE 10073
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
10061: LD_EXP 15
10065: PPUSH
10066: LD_STRING DDeath-Vse-3
10068: PPUSH
10069: CALL_OW 91
// end ;
10073: PPOPN 1
10075: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
10076: LD_VAR 0 1
10080: PUSH
10081: LD_INT 10
10083: EQUAL
10084: IFFALSE 10122
// begin Say ( Brighton , DBrighton-C1 ) ;
10086: LD_EXP 8
10090: PPUSH
10091: LD_STRING DBrighton-C1
10093: PPUSH
10094: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
10098: LD_EXP 10
10102: PPUSH
10103: LD_STRING DMegan-C1
10105: PPUSH
10106: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
10110: LD_EXP 8
10114: PPUSH
10115: LD_STRING DBrighton-C2
10117: PPUSH
10118: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
10122: LD_VAR 0 1
10126: PPUSH
10127: LD_VAR 0 2
10131: PPUSH
10132: CALL 80805 0 2
// end ;
10136: PPOPN 2
10138: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_VAR 0 2
10148: PPUSH
10149: CALL 83309 0 2
// end ;
10153: PPOPN 2
10155: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10156: LD_VAR 0 1
10160: PPUSH
10161: CALL 82377 0 1
// end ;
10165: PPOPN 1
10167: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
10168: LD_VAR 0 1
10172: PPUSH
10173: CALL_OW 266
10177: PUSH
10178: LD_INT 0
10180: EQUAL
10181: PUSH
10182: LD_VAR 0 1
10186: PPUSH
10187: CALL_OW 255
10191: PUSH
10192: LD_INT 3
10194: EQUAL
10195: AND
10196: IFFALSE 10258
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
10198: LD_VAR 0 1
10202: PPUSH
10203: CALL_OW 274
10207: PPUSH
10208: LD_INT 1
10210: PPUSH
10211: LD_INT 10000
10213: PPUSH
10214: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
10218: LD_VAR 0 1
10222: PPUSH
10223: CALL_OW 274
10227: PPUSH
10228: LD_INT 2
10230: PPUSH
10231: LD_INT 250
10233: PPUSH
10234: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
10238: LD_VAR 0 1
10242: PPUSH
10243: CALL_OW 274
10247: PPUSH
10248: LD_INT 3
10250: PPUSH
10251: LD_INT 100
10253: PPUSH
10254: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
10258: LD_VAR 0 1
10262: PPUSH
10263: CALL 82618 0 1
// end ;
10267: PPOPN 1
10269: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10270: LD_VAR 0 1
10274: PPUSH
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_VAR 0 3
10284: PPUSH
10285: LD_VAR 0 4
10289: PPUSH
10290: LD_VAR 0 5
10294: PPUSH
10295: CALL 80425 0 5
// end ;
10299: PPOPN 5
10301: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10302: LD_VAR 0 1
10306: PPUSH
10307: LD_VAR 0 2
10311: PPUSH
10312: CALL 80021 0 2
// end ;
10316: PPOPN 2
10318: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10319: LD_VAR 0 1
10323: PPUSH
10324: LD_VAR 0 2
10328: PPUSH
10329: LD_VAR 0 3
10333: PPUSH
10334: LD_VAR 0 4
10338: PPUSH
10339: CALL 79859 0 4
// end ;
10343: PPOPN 4
10345: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10346: LD_VAR 0 1
10350: PPUSH
10351: LD_VAR 0 2
10355: PPUSH
10356: LD_VAR 0 3
10360: PPUSH
10361: CALL 79634 0 3
// end ;
10365: PPOPN 3
10367: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10368: LD_VAR 0 1
10372: PPUSH
10373: LD_VAR 0 2
10377: PPUSH
10378: CALL 79519 0 2
// end ;
10382: PPOPN 2
10384: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10385: LD_VAR 0 1
10389: PPUSH
10390: LD_VAR 0 2
10394: PPUSH
10395: CALL 83570 0 2
// end ;
10399: PPOPN 2
10401: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
10402: LD_VAR 0 1
10406: PPUSH
10407: CALL_OW 255
10411: PUSH
10412: LD_INT 6
10414: EQUAL
10415: IFFALSE 10545
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
10417: LD_VAR 0 1
10421: PUSH
10422: LD_EXP 12
10426: PUSH
10427: LD_EXP 15
10431: PUSH
10432: LD_EXP 14
10436: PUSH
10437: LD_EXP 13
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: LIST
10447: IN
10448: IFFALSE 10452
// exit ;
10450: GO 10569
// if AssaultStarted then
10452: LD_EXP 7
10456: IFFALSE 10530
// case Rand ( 1 , 4 ) of 1 .. 3 :
10458: LD_INT 1
10460: PPUSH
10461: LD_INT 4
10463: PPUSH
10464: CALL_OW 12
10468: PUSH
10469: LD_INT 1
10471: DOUBLE
10472: GREATEREQUAL
10473: IFFALSE 10481
10475: LD_INT 3
10477: DOUBLE
10478: LESSEQUAL
10479: IFTRUE 10483
10481: GO 10501
10483: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
10484: LD_VAR 0 1
10488: PPUSH
10489: LD_INT 67
10491: PPUSH
10492: LD_INT 37
10494: PPUSH
10495: CALL_OW 114
10499: GO 10528
10501: LD_INT 4
10503: DOUBLE
10504: EQUAL
10505: IFTRUE 10509
10507: GO 10527
10509: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
10510: LD_VAR 0 1
10514: PPUSH
10515: LD_INT 120
10517: PPUSH
10518: LD_INT 131
10520: PPUSH
10521: CALL_OW 111
10525: GO 10528
10527: POP
10528: GO 10545
// ComMoveXY ( driver , 120 , 131 ) ;
10530: LD_VAR 0 1
10534: PPUSH
10535: LD_INT 120
10537: PPUSH
10538: LD_INT 131
10540: PPUSH
10541: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10545: LD_VAR 0 1
10549: PPUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 3
10559: PPUSH
10560: LD_VAR 0 4
10564: PPUSH
10565: CALL 83786 0 4
// end ;
10569: PPOPN 4
10571: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10572: LD_VAR 0 1
10576: PPUSH
10577: LD_VAR 0 2
10581: PPUSH
10582: CALL 79328 0 2
// end ;
10586: PPOPN 2
10588: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10589: LD_VAR 0 1
10593: PPUSH
10594: CALL 84025 0 1
// end ; end_of_file
10598: PPOPN 1
10600: END
// every 0 0$1 trigger RussiansDefeated do
10601: LD_EXP 42
10605: IFFALSE 10786
10607: GO 10609
10609: DISABLE
// begin wait ( 0 0$2 ) ;
10610: LD_INT 70
10612: PPUSH
10613: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
10617: LD_EXP 8
10621: PPUSH
10622: LD_STRING DBrighton-G1
10624: PPUSH
10625: CALL_OW 88
// if Losses < 1 then
10629: LD_EXP 43
10633: PUSH
10634: LD_INT 1
10636: LESS
10637: IFFALSE 10651
// AddMedal ( Losses , 1 ) else
10639: LD_STRING Losses
10641: PPUSH
10642: LD_INT 1
10644: PPUSH
10645: CALL_OW 101
10649: GO 10684
// if Losses < 5 then
10651: LD_EXP 43
10655: PUSH
10656: LD_INT 5
10658: LESS
10659: IFFALSE 10673
// AddMedal ( Losses , 2 ) else
10661: LD_STRING Losses
10663: PPUSH
10664: LD_INT 2
10666: PPUSH
10667: CALL_OW 101
10671: GO 10684
// AddMedal ( Losses , - 1 ) ;
10673: LD_STRING Losses
10675: PPUSH
10676: LD_INT 1
10678: NEG
10679: PPUSH
10680: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10684: LD_EXP 6
10688: PUSH
10689: LD_INT 10
10691: PPUSH
10692: LD_INT 1
10694: PPUSH
10695: CALL_OW 321
10699: PUSH
10700: LD_INT 2
10702: EQUAL
10703: AND
10704: IFFALSE 10718
// AddMedal ( Laser , 1 ) else
10706: LD_STRING Laser
10708: PPUSH
10709: LD_INT 1
10711: PPUSH
10712: CALL_OW 101
10716: GO 10765
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
10718: LD_EXP 6
10722: NOT
10723: PUSH
10724: LD_INT 10
10726: PPUSH
10727: LD_INT 1
10729: PPUSH
10730: CALL_OW 321
10734: PUSH
10735: LD_INT 2
10737: EQUAL
10738: AND
10739: IFFALSE 10754
// AddMedal ( Laser , - 1 ) else
10741: LD_STRING Laser
10743: PPUSH
10744: LD_INT 1
10746: NEG
10747: PPUSH
10748: CALL_OW 101
10752: GO 10765
// AddMedal ( Laser , - 2 ) ;
10754: LD_STRING Laser
10756: PPUSH
10757: LD_INT 2
10759: NEG
10760: PPUSH
10761: CALL_OW 101
// AddMedal ( med3 , 1 ) ;
10765: LD_STRING med3
10767: PPUSH
10768: LD_INT 1
10770: PPUSH
10771: CALL_OW 101
// GiveMedals ( BaseMain ) ;
10775: LD_STRING BaseMain
10777: PPUSH
10778: CALL_OW 102
// YouWin ;
10782: CALL_OW 103
// end ; end_of_file
10786: END
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
10787: LD_INT 0
10789: PPUSH
10790: PPUSH
// area = ListEnvironmentArea ( area ) ;
10791: LD_ADDR_VAR 0 2
10795: PUSH
10796: LD_VAR 0 2
10800: PPUSH
10801: CALL_OW 353
10805: ST_TO_ADDR
// if bulldozer > 0 then
10806: LD_VAR 0 1
10810: PUSH
10811: LD_INT 0
10813: GREATER
10814: IFFALSE 10925
// for i = area downto 1 do
10816: LD_ADDR_VAR 0 4
10820: PUSH
10821: DOUBLE
10822: LD_VAR 0 2
10826: INC
10827: ST_TO_ADDR
10828: LD_INT 1
10830: PUSH
10831: FOR_DOWNTO
10832: IFFALSE 10923
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
10834: LD_VAR 0 2
10838: PUSH
10839: LD_VAR 0 4
10843: ARRAY
10844: PUSH
10845: LD_INT 1
10847: ARRAY
10848: PPUSH
10849: LD_VAR 0 2
10853: PUSH
10854: LD_VAR 0 4
10858: ARRAY
10859: PUSH
10860: LD_INT 2
10862: ARRAY
10863: PPUSH
10864: CALL_OW 351
10868: IFFALSE 10921
// if not HasTask ( bulldozer ) then
10870: LD_VAR 0 1
10874: PPUSH
10875: CALL_OW 314
10879: NOT
10880: IFFALSE 10921
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
10882: LD_VAR 0 1
10886: PPUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_VAR 0 4
10896: ARRAY
10897: PUSH
10898: LD_INT 1
10900: ARRAY
10901: PPUSH
10902: LD_VAR 0 2
10906: PUSH
10907: LD_VAR 0 4
10911: ARRAY
10912: PUSH
10913: LD_INT 2
10915: ARRAY
10916: PPUSH
10917: CALL_OW 171
10921: GO 10831
10923: POP
10924: POP
// end ;
10925: LD_VAR 0 3
10929: RET
// export function ComMeeting ( team , area ) ; var i , tmp ; begin
10930: LD_INT 0
10932: PPUSH
10933: PPUSH
10934: PPUSH
// tmp := AreaToList ( area , 0 ) ;
10935: LD_ADDR_VAR 0 5
10939: PUSH
10940: LD_VAR 0 2
10944: PPUSH
10945: LD_INT 0
10947: PPUSH
10948: CALL_OW 517
10952: ST_TO_ADDR
// for i = 1 to team do
10953: LD_ADDR_VAR 0 4
10957: PUSH
10958: DOUBLE
10959: LD_INT 1
10961: DEC
10962: ST_TO_ADDR
10963: LD_VAR 0 1
10967: PUSH
10968: FOR_TO
10969: IFFALSE 11070
// begin if IsInUnit ( team [ i ] ) then
10971: LD_VAR 0 1
10975: PUSH
10976: LD_VAR 0 4
10980: ARRAY
10981: PPUSH
10982: CALL_OW 310
10986: IFFALSE 11003
// ComExitBuilding ( team [ i ] ) ;
10988: LD_VAR 0 1
10992: PUSH
10993: LD_VAR 0 4
10997: ARRAY
10998: PPUSH
10999: CALL_OW 122
// AddComMoveXY ( team [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
11003: LD_VAR 0 1
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 5
11018: PUSH
11019: LD_INT 1
11021: ARRAY
11022: PUSH
11023: LD_VAR 0 4
11027: ARRAY
11028: PPUSH
11029: LD_VAR 0 5
11033: PUSH
11034: LD_INT 2
11036: ARRAY
11037: PUSH
11038: LD_VAR 0 4
11042: ARRAY
11043: PPUSH
11044: CALL_OW 171
// AddComTurnUnit ( team [ i ] , Brighton ) ;
11048: LD_VAR 0 1
11052: PUSH
11053: LD_VAR 0 4
11057: ARRAY
11058: PPUSH
11059: LD_EXP 8
11063: PPUSH
11064: CALL_OW 179
// end ;
11068: GO 10968
11070: POP
11071: POP
// end ; end_of_file
11072: LD_VAR 0 3
11076: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
// if exist_mode then
11081: LD_VAR 0 2
11085: IFFALSE 11110
// unit := CreateCharacter ( prefix & ident ) else
11087: LD_ADDR_VAR 0 5
11091: PUSH
11092: LD_VAR 0 3
11096: PUSH
11097: LD_VAR 0 1
11101: STR
11102: PPUSH
11103: CALL_OW 34
11107: ST_TO_ADDR
11108: GO 11125
// unit := NewCharacter ( ident ) ;
11110: LD_ADDR_VAR 0 5
11114: PUSH
11115: LD_VAR 0 1
11119: PPUSH
11120: CALL_OW 25
11124: ST_TO_ADDR
// result := unit ;
11125: LD_ADDR_VAR 0 4
11129: PUSH
11130: LD_VAR 0 5
11134: ST_TO_ADDR
// end ;
11135: LD_VAR 0 4
11139: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11140: LD_INT 0
11142: PPUSH
11143: PPUSH
// if not side or not nation then
11144: LD_VAR 0 1
11148: NOT
11149: PUSH
11150: LD_VAR 0 2
11154: NOT
11155: OR
11156: IFFALSE 11160
// exit ;
11158: GO 11804
// case nation of nation_american :
11160: LD_VAR 0 2
11164: PUSH
11165: LD_INT 1
11167: DOUBLE
11168: EQUAL
11169: IFTRUE 11173
11171: GO 11347
11173: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
11174: LD_ADDR_VAR 0 4
11178: PUSH
11179: LD_INT 35
11181: PUSH
11182: LD_INT 45
11184: PUSH
11185: LD_INT 46
11187: PUSH
11188: LD_INT 47
11190: PUSH
11191: LD_INT 1
11193: PUSH
11194: LD_INT 2
11196: PUSH
11197: LD_INT 6
11199: PUSH
11200: LD_INT 15
11202: PUSH
11203: LD_INT 16
11205: PUSH
11206: LD_INT 7
11208: PUSH
11209: LD_INT 12
11211: PUSH
11212: LD_INT 13
11214: PUSH
11215: LD_INT 10
11217: PUSH
11218: LD_INT 14
11220: PUSH
11221: LD_INT 20
11223: PUSH
11224: LD_INT 21
11226: PUSH
11227: LD_INT 22
11229: PUSH
11230: LD_INT 25
11232: PUSH
11233: LD_INT 32
11235: PUSH
11236: LD_INT 27
11238: PUSH
11239: LD_INT 36
11241: PUSH
11242: LD_INT 69
11244: PUSH
11245: LD_INT 39
11247: PUSH
11248: LD_INT 34
11250: PUSH
11251: LD_INT 40
11253: PUSH
11254: LD_INT 48
11256: PUSH
11257: LD_INT 49
11259: PUSH
11260: LD_INT 50
11262: PUSH
11263: LD_INT 51
11265: PUSH
11266: LD_INT 52
11268: PUSH
11269: LD_INT 53
11271: PUSH
11272: LD_INT 54
11274: PUSH
11275: LD_INT 55
11277: PUSH
11278: LD_INT 56
11280: PUSH
11281: LD_INT 57
11283: PUSH
11284: LD_INT 58
11286: PUSH
11287: LD_INT 59
11289: PUSH
11290: LD_INT 60
11292: PUSH
11293: LD_INT 61
11295: PUSH
11296: LD_INT 62
11298: PUSH
11299: LD_INT 80
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: LIST
11335: LIST
11336: LIST
11337: LIST
11338: LIST
11339: LIST
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: ST_TO_ADDR
11345: GO 11728
11347: LD_INT 2
11349: DOUBLE
11350: EQUAL
11351: IFTRUE 11355
11353: GO 11537
11355: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
11356: LD_ADDR_VAR 0 4
11360: PUSH
11361: LD_INT 35
11363: PUSH
11364: LD_INT 45
11366: PUSH
11367: LD_INT 46
11369: PUSH
11370: LD_INT 47
11372: PUSH
11373: LD_INT 70
11375: PUSH
11376: LD_INT 1
11378: PUSH
11379: LD_INT 11
11381: PUSH
11382: LD_INT 3
11384: PUSH
11385: LD_INT 4
11387: PUSH
11388: LD_INT 5
11390: PUSH
11391: LD_INT 6
11393: PUSH
11394: LD_INT 15
11396: PUSH
11397: LD_INT 18
11399: PUSH
11400: LD_INT 7
11402: PUSH
11403: LD_INT 17
11405: PUSH
11406: LD_INT 8
11408: PUSH
11409: LD_INT 20
11411: PUSH
11412: LD_INT 21
11414: PUSH
11415: LD_INT 22
11417: PUSH
11418: LD_INT 72
11420: PUSH
11421: LD_INT 26
11423: PUSH
11424: LD_INT 69
11426: PUSH
11427: LD_INT 39
11429: PUSH
11430: LD_INT 40
11432: PUSH
11433: LD_INT 41
11435: PUSH
11436: LD_INT 42
11438: PUSH
11439: LD_INT 43
11441: PUSH
11442: LD_INT 48
11444: PUSH
11445: LD_INT 49
11447: PUSH
11448: LD_INT 50
11450: PUSH
11451: LD_INT 51
11453: PUSH
11454: LD_INT 52
11456: PUSH
11457: LD_INT 53
11459: PUSH
11460: LD_INT 54
11462: PUSH
11463: LD_INT 55
11465: PUSH
11466: LD_INT 56
11468: PUSH
11469: LD_INT 60
11471: PUSH
11472: LD_INT 61
11474: PUSH
11475: LD_INT 62
11477: PUSH
11478: LD_INT 66
11480: PUSH
11481: LD_INT 67
11483: PUSH
11484: LD_INT 68
11486: PUSH
11487: LD_INT 81
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: ST_TO_ADDR
11535: GO 11728
11537: LD_INT 3
11539: DOUBLE
11540: EQUAL
11541: IFTRUE 11545
11543: GO 11727
11545: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
11546: LD_ADDR_VAR 0 4
11550: PUSH
11551: LD_INT 46
11553: PUSH
11554: LD_INT 47
11556: PUSH
11557: LD_INT 1
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: LD_INT 11
11565: PUSH
11566: LD_INT 9
11568: PUSH
11569: LD_INT 20
11571: PUSH
11572: LD_INT 19
11574: PUSH
11575: LD_INT 21
11577: PUSH
11578: LD_INT 24
11580: PUSH
11581: LD_INT 22
11583: PUSH
11584: LD_INT 25
11586: PUSH
11587: LD_INT 28
11589: PUSH
11590: LD_INT 29
11592: PUSH
11593: LD_INT 30
11595: PUSH
11596: LD_INT 31
11598: PUSH
11599: LD_INT 37
11601: PUSH
11602: LD_INT 38
11604: PUSH
11605: LD_INT 32
11607: PUSH
11608: LD_INT 27
11610: PUSH
11611: LD_INT 33
11613: PUSH
11614: LD_INT 69
11616: PUSH
11617: LD_INT 39
11619: PUSH
11620: LD_INT 34
11622: PUSH
11623: LD_INT 40
11625: PUSH
11626: LD_INT 71
11628: PUSH
11629: LD_INT 23
11631: PUSH
11632: LD_INT 44
11634: PUSH
11635: LD_INT 48
11637: PUSH
11638: LD_INT 49
11640: PUSH
11641: LD_INT 50
11643: PUSH
11644: LD_INT 51
11646: PUSH
11647: LD_INT 52
11649: PUSH
11650: LD_INT 53
11652: PUSH
11653: LD_INT 54
11655: PUSH
11656: LD_INT 55
11658: PUSH
11659: LD_INT 56
11661: PUSH
11662: LD_INT 57
11664: PUSH
11665: LD_INT 58
11667: PUSH
11668: LD_INT 59
11670: PUSH
11671: LD_INT 63
11673: PUSH
11674: LD_INT 64
11676: PUSH
11677: LD_INT 65
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: ST_TO_ADDR
11725: GO 11728
11727: POP
// if state > - 1 and state < 3 then
11728: LD_VAR 0 3
11732: PUSH
11733: LD_INT 1
11735: NEG
11736: GREATER
11737: PUSH
11738: LD_VAR 0 3
11742: PUSH
11743: LD_INT 3
11745: LESS
11746: AND
11747: IFFALSE 11804
// for i in result do
11749: LD_ADDR_VAR 0 5
11753: PUSH
11754: LD_VAR 0 4
11758: PUSH
11759: FOR_IN
11760: IFFALSE 11802
// if GetTech ( i , side ) <> state then
11762: LD_VAR 0 5
11766: PPUSH
11767: LD_VAR 0 1
11771: PPUSH
11772: CALL_OW 321
11776: PUSH
11777: LD_VAR 0 3
11781: NONEQUAL
11782: IFFALSE 11800
// result := result diff i ;
11784: LD_ADDR_VAR 0 4
11788: PUSH
11789: LD_VAR 0 4
11793: PUSH
11794: LD_VAR 0 5
11798: DIFF
11799: ST_TO_ADDR
11800: GO 11759
11802: POP
11803: POP
// end ;
11804: LD_VAR 0 4
11808: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11809: LD_INT 0
11811: PPUSH
11812: PPUSH
11813: PPUSH
// result := true ;
11814: LD_ADDR_VAR 0 3
11818: PUSH
11819: LD_INT 1
11821: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11822: LD_ADDR_VAR 0 5
11826: PUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: CALL_OW 480
11836: ST_TO_ADDR
// if not tmp then
11837: LD_VAR 0 5
11841: NOT
11842: IFFALSE 11846
// exit ;
11844: GO 11895
// for i in tmp do
11846: LD_ADDR_VAR 0 4
11850: PUSH
11851: LD_VAR 0 5
11855: PUSH
11856: FOR_IN
11857: IFFALSE 11893
// if GetTech ( i , side ) <> state_researched then
11859: LD_VAR 0 4
11863: PPUSH
11864: LD_VAR 0 1
11868: PPUSH
11869: CALL_OW 321
11873: PUSH
11874: LD_INT 2
11876: NONEQUAL
11877: IFFALSE 11891
// begin result := false ;
11879: LD_ADDR_VAR 0 3
11883: PUSH
11884: LD_INT 0
11886: ST_TO_ADDR
// exit ;
11887: POP
11888: POP
11889: GO 11895
// end ;
11891: GO 11856
11893: POP
11894: POP
// end ;
11895: LD_VAR 0 3
11899: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11900: LD_INT 0
11902: PPUSH
11903: PPUSH
11904: PPUSH
11905: PPUSH
11906: PPUSH
11907: PPUSH
11908: PPUSH
11909: PPUSH
11910: PPUSH
11911: PPUSH
11912: PPUSH
11913: PPUSH
11914: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11915: LD_VAR 0 1
11919: NOT
11920: PUSH
11921: LD_VAR 0 1
11925: PPUSH
11926: CALL_OW 257
11930: PUSH
11931: LD_INT 9
11933: NONEQUAL
11934: OR
11935: IFFALSE 11939
// exit ;
11937: GO 12512
// side := GetSide ( unit ) ;
11939: LD_ADDR_VAR 0 9
11943: PUSH
11944: LD_VAR 0 1
11948: PPUSH
11949: CALL_OW 255
11953: ST_TO_ADDR
// tech_space := tech_spacanom ;
11954: LD_ADDR_VAR 0 12
11958: PUSH
11959: LD_INT 29
11961: ST_TO_ADDR
// tech_time := tech_taurad ;
11962: LD_ADDR_VAR 0 13
11966: PUSH
11967: LD_INT 28
11969: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11970: LD_ADDR_VAR 0 11
11974: PUSH
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 310
11984: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
11985: LD_VAR 0 11
11989: PPUSH
11990: CALL_OW 247
11994: PUSH
11995: LD_INT 2
11997: EQUAL
11998: IFFALSE 12002
// exit ;
12000: GO 12512
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12002: LD_ADDR_VAR 0 8
12006: PUSH
12007: LD_INT 81
12009: PUSH
12010: LD_VAR 0 9
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: PUSH
12019: LD_INT 3
12021: PUSH
12022: LD_INT 21
12024: PUSH
12025: LD_INT 3
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: EMPTY
12033: LIST
12034: LIST
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PPUSH
12040: CALL_OW 69
12044: ST_TO_ADDR
// if not tmp then
12045: LD_VAR 0 8
12049: NOT
12050: IFFALSE 12054
// exit ;
12052: GO 12512
// if in_unit then
12054: LD_VAR 0 11
12058: IFFALSE 12082
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12060: LD_ADDR_VAR 0 10
12064: PUSH
12065: LD_VAR 0 8
12069: PPUSH
12070: LD_VAR 0 11
12074: PPUSH
12075: CALL_OW 74
12079: ST_TO_ADDR
12080: GO 12102
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12082: LD_ADDR_VAR 0 10
12086: PUSH
12087: LD_VAR 0 8
12091: PPUSH
12092: LD_VAR 0 1
12096: PPUSH
12097: CALL_OW 74
12101: ST_TO_ADDR
// if not enemy then
12102: LD_VAR 0 10
12106: NOT
12107: IFFALSE 12111
// exit ;
12109: GO 12512
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12111: LD_VAR 0 11
12115: PUSH
12116: LD_VAR 0 11
12120: PPUSH
12121: LD_VAR 0 10
12125: PPUSH
12126: CALL_OW 296
12130: PUSH
12131: LD_INT 13
12133: GREATER
12134: AND
12135: PUSH
12136: LD_VAR 0 1
12140: PPUSH
12141: LD_VAR 0 10
12145: PPUSH
12146: CALL_OW 296
12150: PUSH
12151: LD_INT 12
12153: GREATER
12154: OR
12155: IFFALSE 12159
// exit ;
12157: GO 12512
// missile := [ 1 ] ;
12159: LD_ADDR_VAR 0 14
12163: PUSH
12164: LD_INT 1
12166: PUSH
12167: EMPTY
12168: LIST
12169: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12170: LD_VAR 0 9
12174: PPUSH
12175: LD_VAR 0 12
12179: PPUSH
12180: CALL_OW 325
12184: IFFALSE 12213
// missile := Insert ( missile , missile + 1 , 2 ) ;
12186: LD_ADDR_VAR 0 14
12190: PUSH
12191: LD_VAR 0 14
12195: PPUSH
12196: LD_VAR 0 14
12200: PUSH
12201: LD_INT 1
12203: PLUS
12204: PPUSH
12205: LD_INT 2
12207: PPUSH
12208: CALL_OW 2
12212: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12213: LD_VAR 0 9
12217: PPUSH
12218: LD_VAR 0 13
12222: PPUSH
12223: CALL_OW 325
12227: PUSH
12228: LD_VAR 0 10
12232: PPUSH
12233: CALL_OW 255
12237: PPUSH
12238: LD_VAR 0 13
12242: PPUSH
12243: CALL_OW 325
12247: NOT
12248: AND
12249: IFFALSE 12278
// missile := Insert ( missile , missile + 1 , 3 ) ;
12251: LD_ADDR_VAR 0 14
12255: PUSH
12256: LD_VAR 0 14
12260: PPUSH
12261: LD_VAR 0 14
12265: PUSH
12266: LD_INT 1
12268: PLUS
12269: PPUSH
12270: LD_INT 3
12272: PPUSH
12273: CALL_OW 2
12277: ST_TO_ADDR
// if missile < 2 then
12278: LD_VAR 0 14
12282: PUSH
12283: LD_INT 2
12285: LESS
12286: IFFALSE 12290
// exit ;
12288: GO 12512
// x := GetX ( enemy ) ;
12290: LD_ADDR_VAR 0 4
12294: PUSH
12295: LD_VAR 0 10
12299: PPUSH
12300: CALL_OW 250
12304: ST_TO_ADDR
// y := GetY ( enemy ) ;
12305: LD_ADDR_VAR 0 5
12309: PUSH
12310: LD_VAR 0 10
12314: PPUSH
12315: CALL_OW 251
12319: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12320: LD_ADDR_VAR 0 6
12324: PUSH
12325: LD_VAR 0 4
12329: PUSH
12330: LD_INT 1
12332: NEG
12333: PPUSH
12334: LD_INT 1
12336: PPUSH
12337: CALL_OW 12
12341: PLUS
12342: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12343: LD_ADDR_VAR 0 7
12347: PUSH
12348: LD_VAR 0 5
12352: PUSH
12353: LD_INT 1
12355: NEG
12356: PPUSH
12357: LD_INT 1
12359: PPUSH
12360: CALL_OW 12
12364: PLUS
12365: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12366: LD_VAR 0 6
12370: PPUSH
12371: LD_VAR 0 7
12375: PPUSH
12376: CALL_OW 488
12380: NOT
12381: IFFALSE 12403
// begin _x := x ;
12383: LD_ADDR_VAR 0 6
12387: PUSH
12388: LD_VAR 0 4
12392: ST_TO_ADDR
// _y := y ;
12393: LD_ADDR_VAR 0 7
12397: PUSH
12398: LD_VAR 0 5
12402: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12403: LD_ADDR_VAR 0 3
12407: PUSH
12408: LD_INT 1
12410: PPUSH
12411: LD_VAR 0 14
12415: PPUSH
12416: CALL_OW 12
12420: ST_TO_ADDR
// case i of 1 :
12421: LD_VAR 0 3
12425: PUSH
12426: LD_INT 1
12428: DOUBLE
12429: EQUAL
12430: IFTRUE 12434
12432: GO 12451
12434: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12435: LD_VAR 0 1
12439: PPUSH
12440: LD_VAR 0 10
12444: PPUSH
12445: CALL_OW 115
12449: GO 12512
12451: LD_INT 2
12453: DOUBLE
12454: EQUAL
12455: IFTRUE 12459
12457: GO 12481
12459: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12460: LD_VAR 0 1
12464: PPUSH
12465: LD_VAR 0 6
12469: PPUSH
12470: LD_VAR 0 7
12474: PPUSH
12475: CALL_OW 153
12479: GO 12512
12481: LD_INT 3
12483: DOUBLE
12484: EQUAL
12485: IFTRUE 12489
12487: GO 12511
12489: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12490: LD_VAR 0 1
12494: PPUSH
12495: LD_VAR 0 6
12499: PPUSH
12500: LD_VAR 0 7
12504: PPUSH
12505: CALL_OW 154
12509: GO 12512
12511: POP
// end ;
12512: LD_VAR 0 2
12516: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12517: LD_INT 0
12519: PPUSH
12520: PPUSH
12521: PPUSH
12522: PPUSH
12523: PPUSH
12524: PPUSH
// if not unit or not building then
12525: LD_VAR 0 1
12529: NOT
12530: PUSH
12531: LD_VAR 0 2
12535: NOT
12536: OR
12537: IFFALSE 12541
// exit ;
12539: GO 12699
// x := GetX ( building ) ;
12541: LD_ADDR_VAR 0 5
12545: PUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: CALL_OW 250
12555: ST_TO_ADDR
// y := GetY ( building ) ;
12556: LD_ADDR_VAR 0 6
12560: PUSH
12561: LD_VAR 0 2
12565: PPUSH
12566: CALL_OW 251
12570: ST_TO_ADDR
// for i = 0 to 5 do
12571: LD_ADDR_VAR 0 4
12575: PUSH
12576: DOUBLE
12577: LD_INT 0
12579: DEC
12580: ST_TO_ADDR
12581: LD_INT 5
12583: PUSH
12584: FOR_TO
12585: IFFALSE 12697
// begin _x := ShiftX ( x , i , 3 ) ;
12587: LD_ADDR_VAR 0 7
12591: PUSH
12592: LD_VAR 0 5
12596: PPUSH
12597: LD_VAR 0 4
12601: PPUSH
12602: LD_INT 3
12604: PPUSH
12605: CALL_OW 272
12609: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12610: LD_ADDR_VAR 0 8
12614: PUSH
12615: LD_VAR 0 6
12619: PPUSH
12620: LD_VAR 0 4
12624: PPUSH
12625: LD_INT 3
12627: PPUSH
12628: CALL_OW 273
12632: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12633: LD_VAR 0 7
12637: PPUSH
12638: LD_VAR 0 8
12642: PPUSH
12643: CALL_OW 488
12647: NOT
12648: IFFALSE 12652
// continue ;
12650: GO 12584
// if HexInfo ( _x , _y ) = 0 then
12652: LD_VAR 0 7
12656: PPUSH
12657: LD_VAR 0 8
12661: PPUSH
12662: CALL_OW 428
12666: PUSH
12667: LD_INT 0
12669: EQUAL
12670: IFFALSE 12695
// begin ComMoveXY ( unit , _x , _y ) ;
12672: LD_VAR 0 1
12676: PPUSH
12677: LD_VAR 0 7
12681: PPUSH
12682: LD_VAR 0 8
12686: PPUSH
12687: CALL_OW 111
// exit ;
12691: POP
12692: POP
12693: GO 12699
// end ; end ;
12695: GO 12584
12697: POP
12698: POP
// end ;
12699: LD_VAR 0 3
12703: RET
// export function ScanBase ( side , base_area ) ; begin
12704: LD_INT 0
12706: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12707: LD_ADDR_VAR 0 3
12711: PUSH
12712: LD_VAR 0 2
12716: PPUSH
12717: LD_INT 81
12719: PUSH
12720: LD_VAR 0 1
12724: PUSH
12725: EMPTY
12726: LIST
12727: LIST
12728: PPUSH
12729: CALL_OW 70
12733: ST_TO_ADDR
// end ;
12734: LD_VAR 0 3
12738: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
12739: LD_INT 0
12741: PPUSH
12742: PPUSH
12743: PPUSH
12744: PPUSH
12745: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
12746: LD_VAR 0 1
12750: NOT
12751: PUSH
12752: LD_EXP 52
12756: PUSH
12757: LD_VAR 0 1
12761: ARRAY
12762: NOT
12763: OR
12764: PUSH
12765: LD_VAR 0 2
12769: NOT
12770: OR
12771: PUSH
12772: LD_VAR 0 3
12776: NOT
12777: OR
12778: IFFALSE 12782
// exit ;
12780: GO 13295
// side := mc_sides [ base ] ;
12782: LD_ADDR_VAR 0 6
12786: PUSH
12787: LD_EXP 78
12791: PUSH
12792: LD_VAR 0 1
12796: ARRAY
12797: ST_TO_ADDR
// if not side then
12798: LD_VAR 0 6
12802: NOT
12803: IFFALSE 12807
// exit ;
12805: GO 13295
// for i in solds do
12807: LD_ADDR_VAR 0 7
12811: PUSH
12812: LD_VAR 0 2
12816: PUSH
12817: FOR_IN
12818: IFFALSE 12879
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
12820: LD_VAR 0 7
12824: PPUSH
12825: CALL_OW 310
12829: PPUSH
12830: CALL_OW 266
12834: PUSH
12835: LD_INT 32
12837: PUSH
12838: LD_INT 31
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: IN
12845: IFFALSE 12865
// solds := solds diff i else
12847: LD_ADDR_VAR 0 2
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_VAR 0 7
12861: DIFF
12862: ST_TO_ADDR
12863: GO 12877
// SetTag ( i , 18 ) ;
12865: LD_VAR 0 7
12869: PPUSH
12870: LD_INT 18
12872: PPUSH
12873: CALL_OW 109
12877: GO 12817
12879: POP
12880: POP
// if not solds then
12881: LD_VAR 0 2
12885: NOT
12886: IFFALSE 12890
// exit ;
12888: GO 13295
// repeat wait ( 0 0$1 ) ;
12890: LD_INT 35
12892: PPUSH
12893: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
12897: LD_ADDR_VAR 0 5
12901: PUSH
12902: LD_VAR 0 6
12906: PPUSH
12907: LD_VAR 0 3
12911: PPUSH
12912: CALL 12704 0 2
12916: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
12917: LD_EXP 52
12921: PUSH
12922: LD_VAR 0 1
12926: ARRAY
12927: NOT
12928: PUSH
12929: LD_EXP 52
12933: PUSH
12934: LD_VAR 0 1
12938: ARRAY
12939: PUSH
12940: EMPTY
12941: EQUAL
12942: OR
12943: IFFALSE 12980
// begin for i in solds do
12945: LD_ADDR_VAR 0 7
12949: PUSH
12950: LD_VAR 0 2
12954: PUSH
12955: FOR_IN
12956: IFFALSE 12969
// ComStop ( i ) ;
12958: LD_VAR 0 7
12962: PPUSH
12963: CALL_OW 141
12967: GO 12955
12969: POP
12970: POP
// solds := [ ] ;
12971: LD_ADDR_VAR 0 2
12975: PUSH
12976: EMPTY
12977: ST_TO_ADDR
// exit ;
12978: GO 13295
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
12980: LD_VAR 0 5
12984: NOT
12985: PUSH
12986: LD_VAR 0 5
12990: PUSH
12991: LD_INT 3
12993: GREATER
12994: OR
12995: PUSH
12996: LD_EXP 74
13000: PUSH
13001: LD_VAR 0 1
13005: ARRAY
13006: OR
13007: IFFALSE 13048
// begin for i in solds do
13009: LD_ADDR_VAR 0 7
13013: PUSH
13014: LD_VAR 0 2
13018: PUSH
13019: FOR_IN
13020: IFFALSE 13044
// if HasTask ( i ) then
13022: LD_VAR 0 7
13026: PPUSH
13027: CALL_OW 314
13031: IFFALSE 13042
// ComStop ( i ) ;
13033: LD_VAR 0 7
13037: PPUSH
13038: CALL_OW 141
13042: GO 13019
13044: POP
13045: POP
// break ;
13046: GO 13283
// end ; for i in solds do
13048: LD_ADDR_VAR 0 7
13052: PUSH
13053: LD_VAR 0 2
13057: PUSH
13058: FOR_IN
13059: IFFALSE 13275
// begin if IsInUnit ( i ) then
13061: LD_VAR 0 7
13065: PPUSH
13066: CALL_OW 310
13070: IFFALSE 13081
// ComExitBuilding ( i ) ;
13072: LD_VAR 0 7
13076: PPUSH
13077: CALL_OW 122
// if GetLives ( i ) > 333 then
13081: LD_VAR 0 7
13085: PPUSH
13086: CALL_OW 256
13090: PUSH
13091: LD_INT 333
13093: GREATER
13094: IFFALSE 13122
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
13096: LD_VAR 0 7
13100: PPUSH
13101: LD_VAR 0 5
13105: PPUSH
13106: LD_VAR 0 7
13110: PPUSH
13111: CALL_OW 74
13115: PPUSH
13116: CALL_OW 115
13120: GO 13273
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
13122: LD_ADDR_VAR 0 8
13126: PUSH
13127: LD_EXP 52
13131: PUSH
13132: LD_VAR 0 1
13136: ARRAY
13137: PPUSH
13138: LD_INT 2
13140: PUSH
13141: LD_INT 30
13143: PUSH
13144: LD_INT 0
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: PUSH
13151: LD_INT 30
13153: PUSH
13154: LD_INT 1
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 30
13163: PUSH
13164: LD_INT 6
13166: PUSH
13167: EMPTY
13168: LIST
13169: LIST
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: PPUSH
13177: CALL_OW 72
13181: PPUSH
13182: LD_VAR 0 7
13186: PPUSH
13187: CALL_OW 74
13191: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
13192: LD_VAR 0 7
13196: PPUSH
13197: LD_VAR 0 8
13201: PPUSH
13202: CALL_OW 250
13206: PPUSH
13207: LD_INT 3
13209: PPUSH
13210: LD_INT 5
13212: PPUSH
13213: CALL_OW 272
13217: PPUSH
13218: LD_VAR 0 8
13222: PPUSH
13223: CALL_OW 251
13227: PPUSH
13228: LD_INT 3
13230: PPUSH
13231: LD_INT 5
13233: PPUSH
13234: CALL_OW 273
13238: PPUSH
13239: CALL_OW 111
// SetTag ( i , 0 ) ;
13243: LD_VAR 0 7
13247: PPUSH
13248: LD_INT 0
13250: PPUSH
13251: CALL_OW 109
// solds := solds diff i ;
13255: LD_ADDR_VAR 0 2
13259: PUSH
13260: LD_VAR 0 2
13264: PUSH
13265: LD_VAR 0 7
13269: DIFF
13270: ST_TO_ADDR
// continue ;
13271: GO 13058
// end ; end ;
13273: GO 13058
13275: POP
13276: POP
// until solds ;
13277: LD_VAR 0 2
13281: IFFALSE 12890
// MC_Reset ( base , 18 ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_INT 18
13290: PPUSH
13291: CALL 58212 0 2
// end ;
13295: LD_VAR 0 4
13299: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
13300: LD_INT 0
13302: PPUSH
13303: PPUSH
13304: PPUSH
13305: PPUSH
13306: PPUSH
13307: PPUSH
13308: PPUSH
13309: PPUSH
13310: PPUSH
13311: PPUSH
13312: PPUSH
13313: PPUSH
13314: PPUSH
13315: PPUSH
13316: PPUSH
13317: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
13318: LD_ADDR_VAR 0 12
13322: PUSH
13323: LD_EXP 52
13327: PUSH
13328: LD_VAR 0 1
13332: ARRAY
13333: PPUSH
13334: LD_INT 25
13336: PUSH
13337: LD_INT 3
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PPUSH
13344: CALL_OW 72
13348: ST_TO_ADDR
// if mc_remote_driver [ base ] then
13349: LD_EXP 92
13353: PUSH
13354: LD_VAR 0 1
13358: ARRAY
13359: IFFALSE 13383
// mechs := mechs diff mc_remote_driver [ base ] ;
13361: LD_ADDR_VAR 0 12
13365: PUSH
13366: LD_VAR 0 12
13370: PUSH
13371: LD_EXP 92
13375: PUSH
13376: LD_VAR 0 1
13380: ARRAY
13381: DIFF
13382: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
13383: LD_ADDR_VAR 0 8
13387: PUSH
13388: LD_EXP 52
13392: PUSH
13393: LD_VAR 0 1
13397: ARRAY
13398: PPUSH
13399: LD_INT 2
13401: PUSH
13402: LD_INT 25
13404: PUSH
13405: LD_INT 1
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: LD_INT 25
13414: PUSH
13415: LD_INT 5
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: LD_INT 25
13424: PUSH
13425: LD_INT 8
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 25
13434: PUSH
13435: LD_INT 9
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: PPUSH
13449: CALL_OW 72
13453: ST_TO_ADDR
// if not defenders and not solds then
13454: LD_VAR 0 2
13458: NOT
13459: PUSH
13460: LD_VAR 0 8
13464: NOT
13465: AND
13466: IFFALSE 13470
// exit ;
13468: GO 14996
// depot_under_attack := false ;
13470: LD_ADDR_VAR 0 16
13474: PUSH
13475: LD_INT 0
13477: ST_TO_ADDR
// sold_defenders := [ ] ;
13478: LD_ADDR_VAR 0 17
13482: PUSH
13483: EMPTY
13484: ST_TO_ADDR
// if mechs then
13485: LD_VAR 0 12
13489: IFFALSE 13618
// for i in defenders do
13491: LD_ADDR_VAR 0 5
13495: PUSH
13496: LD_VAR 0 2
13500: PUSH
13501: FOR_IN
13502: IFFALSE 13616
// begin SetTag ( i , 20 ) ;
13504: LD_VAR 0 5
13508: PPUSH
13509: LD_INT 20
13511: PPUSH
13512: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
13516: LD_VAR 0 5
13520: PPUSH
13521: CALL_OW 263
13525: PUSH
13526: LD_INT 1
13528: EQUAL
13529: PUSH
13530: LD_VAR 0 5
13534: PPUSH
13535: CALL_OW 311
13539: NOT
13540: AND
13541: PUSH
13542: LD_VAR 0 12
13546: AND
13547: IFFALSE 13614
// begin un := mechs [ 1 ] ;
13549: LD_ADDR_VAR 0 10
13553: PUSH
13554: LD_VAR 0 12
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: ST_TO_ADDR
// ComExitBuilding ( un ) ;
13563: LD_VAR 0 10
13567: PPUSH
13568: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
13572: LD_VAR 0 10
13576: PPUSH
13577: LD_VAR 0 5
13581: PPUSH
13582: CALL_OW 180
// SetTag ( un , 19 ) ;
13586: LD_VAR 0 10
13590: PPUSH
13591: LD_INT 19
13593: PPUSH
13594: CALL_OW 109
// mechs := mechs diff un ;
13598: LD_ADDR_VAR 0 12
13602: PUSH
13603: LD_VAR 0 12
13607: PUSH
13608: LD_VAR 0 10
13612: DIFF
13613: ST_TO_ADDR
// end ; end ;
13614: GO 13501
13616: POP
13617: POP
// if solds then
13618: LD_VAR 0 8
13622: IFFALSE 13681
// for i in solds do
13624: LD_ADDR_VAR 0 5
13628: PUSH
13629: LD_VAR 0 8
13633: PUSH
13634: FOR_IN
13635: IFFALSE 13679
// if not GetTag ( i ) then
13637: LD_VAR 0 5
13641: PPUSH
13642: CALL_OW 110
13646: NOT
13647: IFFALSE 13677
// begin defenders := defenders union i ;
13649: LD_ADDR_VAR 0 2
13653: PUSH
13654: LD_VAR 0 2
13658: PUSH
13659: LD_VAR 0 5
13663: UNION
13664: ST_TO_ADDR
// SetTag ( i , 18 ) ;
13665: LD_VAR 0 5
13669: PPUSH
13670: LD_INT 18
13672: PPUSH
13673: CALL_OW 109
// end ;
13677: GO 13634
13679: POP
13680: POP
// repeat wait ( 0 0$1 ) ;
13681: LD_INT 35
13683: PPUSH
13684: CALL_OW 67
// enemy := mc_scan [ base ] ;
13688: LD_ADDR_VAR 0 3
13692: PUSH
13693: LD_EXP 75
13697: PUSH
13698: LD_VAR 0 1
13702: ARRAY
13703: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
13704: LD_EXP 52
13708: PUSH
13709: LD_VAR 0 1
13713: ARRAY
13714: NOT
13715: PUSH
13716: LD_EXP 52
13720: PUSH
13721: LD_VAR 0 1
13725: ARRAY
13726: PUSH
13727: EMPTY
13728: EQUAL
13729: OR
13730: IFFALSE 13767
// begin for i in defenders do
13732: LD_ADDR_VAR 0 5
13736: PUSH
13737: LD_VAR 0 2
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13756
// ComStop ( i ) ;
13745: LD_VAR 0 5
13749: PPUSH
13750: CALL_OW 141
13754: GO 13742
13756: POP
13757: POP
// defenders := [ ] ;
13758: LD_ADDR_VAR 0 2
13762: PUSH
13763: EMPTY
13764: ST_TO_ADDR
// exit ;
13765: GO 14996
// end ; for i in defenders do
13767: LD_ADDR_VAR 0 5
13771: PUSH
13772: LD_VAR 0 2
13776: PUSH
13777: FOR_IN
13778: IFFALSE 14508
// begin e := NearestUnitToUnit ( enemy , i ) ;
13780: LD_ADDR_VAR 0 13
13784: PUSH
13785: LD_VAR 0 3
13789: PPUSH
13790: LD_VAR 0 5
13794: PPUSH
13795: CALL_OW 74
13799: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
13800: LD_ADDR_VAR 0 16
13804: PUSH
13805: LD_EXP 52
13809: PUSH
13810: LD_VAR 0 1
13814: ARRAY
13815: PPUSH
13816: LD_INT 2
13818: PUSH
13819: LD_INT 30
13821: PUSH
13822: LD_INT 0
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 30
13831: PUSH
13832: LD_INT 1
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PUSH
13839: EMPTY
13840: LIST
13841: LIST
13842: LIST
13843: PPUSH
13844: CALL_OW 72
13848: NOT
13849: PUSH
13850: LD_EXP 52
13854: PUSH
13855: LD_VAR 0 1
13859: ARRAY
13860: PPUSH
13861: LD_INT 2
13863: PUSH
13864: LD_INT 30
13866: PUSH
13867: LD_INT 0
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PUSH
13874: LD_INT 30
13876: PUSH
13877: LD_INT 1
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: LIST
13888: PPUSH
13889: CALL_OW 72
13893: PPUSH
13894: CALL_OW 256
13898: PUSH
13899: LD_INT 600
13901: LESS
13902: OR
13903: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
13904: LD_VAR 0 5
13908: PPUSH
13909: CALL_OW 247
13913: PUSH
13914: LD_INT 2
13916: DOUBLE
13917: EQUAL
13918: IFTRUE 13922
13920: GO 14214
13922: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
13923: LD_VAR 0 5
13927: PPUSH
13928: CALL_OW 256
13932: PUSH
13933: LD_INT 650
13935: GREATER
13936: PUSH
13937: LD_VAR 0 5
13941: PPUSH
13942: LD_VAR 0 13
13946: PPUSH
13947: CALL_OW 296
13951: PUSH
13952: LD_INT 40
13954: LESS
13955: PUSH
13956: LD_VAR 0 13
13960: PPUSH
13961: LD_EXP 77
13965: PUSH
13966: LD_VAR 0 1
13970: ARRAY
13971: PPUSH
13972: CALL_OW 308
13976: OR
13977: AND
13978: IFFALSE 13996
// ComAttackUnit ( i , e ) else
13980: LD_VAR 0 5
13984: PPUSH
13985: LD_VAR 0 13
13989: PPUSH
13990: CALL_OW 115
13994: GO 14097
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
13996: LD_VAR 0 13
14000: PPUSH
14001: LD_EXP 77
14005: PUSH
14006: LD_VAR 0 1
14010: ARRAY
14011: PPUSH
14012: CALL_OW 308
14016: NOT
14017: PUSH
14018: LD_VAR 0 5
14022: PPUSH
14023: LD_VAR 0 13
14027: PPUSH
14028: CALL_OW 296
14032: PUSH
14033: LD_INT 40
14035: GREATEREQUAL
14036: AND
14037: PUSH
14038: LD_VAR 0 5
14042: PPUSH
14043: CALL_OW 256
14047: PUSH
14048: LD_INT 650
14050: LESSEQUAL
14051: OR
14052: PUSH
14053: LD_VAR 0 5
14057: PPUSH
14058: LD_EXP 76
14062: PUSH
14063: LD_VAR 0 1
14067: ARRAY
14068: PPUSH
14069: CALL_OW 308
14073: NOT
14074: AND
14075: IFFALSE 14097
// ComMoveToArea ( i , mc_parking [ base ] ) ;
14077: LD_VAR 0 5
14081: PPUSH
14082: LD_EXP 76
14086: PUSH
14087: LD_VAR 0 1
14091: ARRAY
14092: PPUSH
14093: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
14097: LD_VAR 0 5
14101: PPUSH
14102: CALL_OW 256
14106: PUSH
14107: LD_INT 998
14109: LESS
14110: PUSH
14111: LD_VAR 0 5
14115: PPUSH
14116: CALL_OW 263
14120: PUSH
14121: LD_INT 1
14123: EQUAL
14124: AND
14125: PUSH
14126: LD_VAR 0 5
14130: PPUSH
14131: CALL_OW 311
14135: AND
14136: PUSH
14137: LD_VAR 0 5
14141: PPUSH
14142: LD_EXP 76
14146: PUSH
14147: LD_VAR 0 1
14151: ARRAY
14152: PPUSH
14153: CALL_OW 308
14157: AND
14158: IFFALSE 14212
// begin mech := IsDrivenBy ( i ) ;
14160: LD_ADDR_VAR 0 9
14164: PUSH
14165: LD_VAR 0 5
14169: PPUSH
14170: CALL_OW 311
14174: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
14175: LD_VAR 0 9
14179: PPUSH
14180: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
14184: LD_VAR 0 9
14188: PPUSH
14189: LD_VAR 0 5
14193: PPUSH
14194: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
14198: LD_VAR 0 9
14202: PPUSH
14203: LD_VAR 0 5
14207: PPUSH
14208: CALL_OW 180
// end ; end ; unit_human :
14212: GO 14479
14214: LD_INT 1
14216: DOUBLE
14217: EQUAL
14218: IFTRUE 14222
14220: GO 14478
14222: POP
// begin b := IsInUnit ( i ) ;
14223: LD_ADDR_VAR 0 18
14227: PUSH
14228: LD_VAR 0 5
14232: PPUSH
14233: CALL_OW 310
14237: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
14238: LD_ADDR_VAR 0 19
14242: PUSH
14243: LD_VAR 0 18
14247: NOT
14248: PUSH
14249: LD_VAR 0 18
14253: PPUSH
14254: CALL_OW 266
14258: PUSH
14259: LD_INT 32
14261: PUSH
14262: LD_INT 31
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: IN
14269: OR
14270: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
14271: LD_VAR 0 16
14275: PUSH
14276: LD_VAR 0 2
14280: PPUSH
14281: LD_INT 21
14283: PUSH
14284: LD_INT 2
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PPUSH
14291: CALL_OW 72
14295: PUSH
14296: LD_INT 1
14298: LESSEQUAL
14299: OR
14300: PUSH
14301: LD_VAR 0 19
14305: AND
14306: PUSH
14307: LD_VAR 0 5
14311: PUSH
14312: LD_VAR 0 17
14316: IN
14317: NOT
14318: AND
14319: IFFALSE 14412
// begin if b then
14321: LD_VAR 0 18
14325: IFFALSE 14374
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
14327: LD_VAR 0 18
14331: PPUSH
14332: LD_VAR 0 3
14336: PPUSH
14337: LD_VAR 0 18
14341: PPUSH
14342: CALL_OW 74
14346: PPUSH
14347: CALL_OW 296
14351: PUSH
14352: LD_INT 10
14354: LESS
14355: PUSH
14356: LD_VAR 0 18
14360: PPUSH
14361: CALL_OW 461
14365: PUSH
14366: LD_INT 7
14368: NONEQUAL
14369: AND
14370: IFFALSE 14374
// continue ;
14372: GO 13777
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
14374: LD_ADDR_VAR 0 17
14378: PUSH
14379: LD_VAR 0 17
14383: PPUSH
14384: LD_VAR 0 17
14388: PUSH
14389: LD_INT 1
14391: PLUS
14392: PPUSH
14393: LD_VAR 0 5
14397: PPUSH
14398: CALL_OW 1
14402: ST_TO_ADDR
// ComExitBuilding ( i ) ;
14403: LD_VAR 0 5
14407: PPUSH
14408: CALL_OW 122
// end ; if sold_defenders then
14412: LD_VAR 0 17
14416: IFFALSE 14476
// if i in sold_defenders then
14418: LD_VAR 0 5
14422: PUSH
14423: LD_VAR 0 17
14427: IN
14428: IFFALSE 14476
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
14430: LD_VAR 0 5
14434: PPUSH
14435: CALL_OW 314
14439: NOT
14440: PUSH
14441: LD_VAR 0 5
14445: PPUSH
14446: LD_VAR 0 13
14450: PPUSH
14451: CALL_OW 296
14455: PUSH
14456: LD_INT 30
14458: LESS
14459: AND
14460: IFFALSE 14476
// ComAttackUnit ( i , e ) ;
14462: LD_VAR 0 5
14466: PPUSH
14467: LD_VAR 0 13
14471: PPUSH
14472: CALL_OW 115
// end ; end ; end ;
14476: GO 14479
14478: POP
// if IsDead ( i ) then
14479: LD_VAR 0 5
14483: PPUSH
14484: CALL_OW 301
14488: IFFALSE 14506
// defenders := defenders diff i ;
14490: LD_ADDR_VAR 0 2
14494: PUSH
14495: LD_VAR 0 2
14499: PUSH
14500: LD_VAR 0 5
14504: DIFF
14505: ST_TO_ADDR
// end ;
14506: GO 13777
14508: POP
14509: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
14510: LD_VAR 0 3
14514: NOT
14515: PUSH
14516: LD_VAR 0 2
14520: NOT
14521: OR
14522: PUSH
14523: LD_EXP 52
14527: PUSH
14528: LD_VAR 0 1
14532: ARRAY
14533: NOT
14534: OR
14535: IFFALSE 13681
// MC_Reset ( base , 18 ) ;
14537: LD_VAR 0 1
14541: PPUSH
14542: LD_INT 18
14544: PPUSH
14545: CALL 58212 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
14549: LD_ADDR_VAR 0 2
14553: PUSH
14554: LD_VAR 0 2
14558: PUSH
14559: LD_VAR 0 2
14563: PPUSH
14564: LD_INT 2
14566: PUSH
14567: LD_INT 25
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: LD_INT 25
14579: PUSH
14580: LD_INT 5
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 25
14589: PUSH
14590: LD_INT 8
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: LD_INT 25
14599: PUSH
14600: LD_INT 9
14602: PUSH
14603: EMPTY
14604: LIST
14605: LIST
14606: PUSH
14607: EMPTY
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: PPUSH
14614: CALL_OW 72
14618: DIFF
14619: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
14620: LD_VAR 0 3
14624: NOT
14625: PUSH
14626: LD_VAR 0 2
14630: PPUSH
14631: LD_INT 21
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 72
14645: AND
14646: IFFALSE 14984
// begin tmp := FilterByTag ( defenders , 19 ) ;
14648: LD_ADDR_VAR 0 11
14652: PUSH
14653: LD_VAR 0 2
14657: PPUSH
14658: LD_INT 19
14660: PPUSH
14661: CALL 51425 0 2
14665: ST_TO_ADDR
// if tmp then
14666: LD_VAR 0 11
14670: IFFALSE 14740
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
14672: LD_ADDR_VAR 0 11
14676: PUSH
14677: LD_VAR 0 11
14681: PPUSH
14682: LD_INT 25
14684: PUSH
14685: LD_INT 3
14687: PUSH
14688: EMPTY
14689: LIST
14690: LIST
14691: PPUSH
14692: CALL_OW 72
14696: ST_TO_ADDR
// if tmp then
14697: LD_VAR 0 11
14701: IFFALSE 14740
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
14703: LD_ADDR_EXP 64
14707: PUSH
14708: LD_EXP 64
14712: PPUSH
14713: LD_VAR 0 1
14717: PPUSH
14718: LD_EXP 64
14722: PUSH
14723: LD_VAR 0 1
14727: ARRAY
14728: PUSH
14729: LD_VAR 0 11
14733: UNION
14734: PPUSH
14735: CALL_OW 1
14739: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_INT 19
14747: PPUSH
14748: CALL 58212 0 2
// repeat wait ( 0 0$1 ) ;
14752: LD_INT 35
14754: PPUSH
14755: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
14759: LD_EXP 52
14763: PUSH
14764: LD_VAR 0 1
14768: ARRAY
14769: NOT
14770: PUSH
14771: LD_EXP 52
14775: PUSH
14776: LD_VAR 0 1
14780: ARRAY
14781: PUSH
14782: EMPTY
14783: EQUAL
14784: OR
14785: IFFALSE 14822
// begin for i in defenders do
14787: LD_ADDR_VAR 0 5
14791: PUSH
14792: LD_VAR 0 2
14796: PUSH
14797: FOR_IN
14798: IFFALSE 14811
// ComStop ( i ) ;
14800: LD_VAR 0 5
14804: PPUSH
14805: CALL_OW 141
14809: GO 14797
14811: POP
14812: POP
// defenders := [ ] ;
14813: LD_ADDR_VAR 0 2
14817: PUSH
14818: EMPTY
14819: ST_TO_ADDR
// exit ;
14820: GO 14996
// end ; for i in defenders do
14822: LD_ADDR_VAR 0 5
14826: PUSH
14827: LD_VAR 0 2
14831: PUSH
14832: FOR_IN
14833: IFFALSE 14922
// begin if not IsInArea ( i , mc_parking [ base ] ) then
14835: LD_VAR 0 5
14839: PPUSH
14840: LD_EXP 76
14844: PUSH
14845: LD_VAR 0 1
14849: ARRAY
14850: PPUSH
14851: CALL_OW 308
14855: NOT
14856: IFFALSE 14880
// ComMoveToArea ( i , mc_parking [ base ] ) else
14858: LD_VAR 0 5
14862: PPUSH
14863: LD_EXP 76
14867: PUSH
14868: LD_VAR 0 1
14872: ARRAY
14873: PPUSH
14874: CALL_OW 113
14878: GO 14920
// if GetControl ( i ) = control_manual then
14880: LD_VAR 0 5
14884: PPUSH
14885: CALL_OW 263
14889: PUSH
14890: LD_INT 1
14892: EQUAL
14893: IFFALSE 14920
// if IsDrivenBy ( i ) then
14895: LD_VAR 0 5
14899: PPUSH
14900: CALL_OW 311
14904: IFFALSE 14920
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
14906: LD_VAR 0 5
14910: PPUSH
14911: CALL_OW 311
14915: PPUSH
14916: CALL_OW 121
// end ;
14920: GO 14832
14922: POP
14923: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
14924: LD_VAR 0 2
14928: PPUSH
14929: LD_INT 95
14931: PUSH
14932: LD_EXP 76
14936: PUSH
14937: LD_VAR 0 1
14941: ARRAY
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: PPUSH
14947: CALL_OW 72
14951: PUSH
14952: LD_VAR 0 2
14956: EQUAL
14957: PUSH
14958: LD_EXP 75
14962: PUSH
14963: LD_VAR 0 1
14967: ARRAY
14968: OR
14969: PUSH
14970: LD_EXP 52
14974: PUSH
14975: LD_VAR 0 1
14979: ARRAY
14980: NOT
14981: OR
14982: IFFALSE 14752
// end ; MC_Reset ( base , 20 ) ;
14984: LD_VAR 0 1
14988: PPUSH
14989: LD_INT 20
14991: PPUSH
14992: CALL 58212 0 2
// end ;
14996: LD_VAR 0 4
15000: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15001: LD_INT 0
15003: PPUSH
15004: PPUSH
15005: PPUSH
15006: PPUSH
// result := false ;
15007: LD_ADDR_VAR 0 2
15011: PUSH
15012: LD_INT 0
15014: ST_TO_ADDR
// side := GetSide ( unit ) ;
15015: LD_ADDR_VAR 0 3
15019: PUSH
15020: LD_VAR 0 1
15024: PPUSH
15025: CALL_OW 255
15029: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: LD_VAR 0 1
15039: PPUSH
15040: CALL_OW 248
15044: ST_TO_ADDR
// case nat of 1 :
15045: LD_VAR 0 4
15049: PUSH
15050: LD_INT 1
15052: DOUBLE
15053: EQUAL
15054: IFTRUE 15058
15056: GO 15069
15058: POP
// tech := tech_lassight ; 2 :
15059: LD_ADDR_VAR 0 5
15063: PUSH
15064: LD_INT 12
15066: ST_TO_ADDR
15067: GO 15108
15069: LD_INT 2
15071: DOUBLE
15072: EQUAL
15073: IFTRUE 15077
15075: GO 15088
15077: POP
// tech := tech_mortar ; 3 :
15078: LD_ADDR_VAR 0 5
15082: PUSH
15083: LD_INT 41
15085: ST_TO_ADDR
15086: GO 15108
15088: LD_INT 3
15090: DOUBLE
15091: EQUAL
15092: IFTRUE 15096
15094: GO 15107
15096: POP
// tech := tech_bazooka ; end ;
15097: LD_ADDR_VAR 0 5
15101: PUSH
15102: LD_INT 44
15104: ST_TO_ADDR
15105: GO 15108
15107: POP
// if Researched ( side , tech ) then
15108: LD_VAR 0 3
15112: PPUSH
15113: LD_VAR 0 5
15117: PPUSH
15118: CALL_OW 325
15122: IFFALSE 15149
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15124: LD_ADDR_VAR 0 2
15128: PUSH
15129: LD_INT 5
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: LD_INT 9
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: LIST
15142: PUSH
15143: LD_VAR 0 4
15147: ARRAY
15148: ST_TO_ADDR
// end ;
15149: LD_VAR 0 2
15153: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15154: LD_INT 0
15156: PPUSH
15157: PPUSH
15158: PPUSH
// if not mines then
15159: LD_VAR 0 2
15163: NOT
15164: IFFALSE 15168
// exit ;
15166: GO 15312
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15168: LD_ADDR_VAR 0 5
15172: PUSH
15173: LD_INT 81
15175: PUSH
15176: LD_VAR 0 1
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: PUSH
15185: LD_INT 3
15187: PUSH
15188: LD_INT 21
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: ST_TO_ADDR
// for i in mines do
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_VAR 0 2
15220: PUSH
15221: FOR_IN
15222: IFFALSE 15310
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15224: LD_VAR 0 4
15228: PUSH
15229: LD_INT 1
15231: ARRAY
15232: PPUSH
15233: LD_VAR 0 4
15237: PUSH
15238: LD_INT 2
15240: ARRAY
15241: PPUSH
15242: CALL_OW 458
15246: NOT
15247: IFFALSE 15251
// continue ;
15249: GO 15221
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15251: LD_VAR 0 4
15255: PUSH
15256: LD_INT 1
15258: ARRAY
15259: PPUSH
15260: LD_VAR 0 4
15264: PUSH
15265: LD_INT 2
15267: ARRAY
15268: PPUSH
15269: CALL_OW 428
15273: PUSH
15274: LD_VAR 0 5
15278: IN
15279: IFFALSE 15308
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15281: LD_VAR 0 4
15285: PUSH
15286: LD_INT 1
15288: ARRAY
15289: PPUSH
15290: LD_VAR 0 4
15294: PUSH
15295: LD_INT 2
15297: ARRAY
15298: PPUSH
15299: LD_VAR 0 1
15303: PPUSH
15304: CALL_OW 456
// end ;
15308: GO 15221
15310: POP
15311: POP
// end ;
15312: LD_VAR 0 3
15316: RET
// export function Count ( array ) ; var i ; begin
15317: LD_INT 0
15319: PPUSH
15320: PPUSH
// result := 0 ;
15321: LD_ADDR_VAR 0 2
15325: PUSH
15326: LD_INT 0
15328: ST_TO_ADDR
// for i in array do
15329: LD_ADDR_VAR 0 3
15333: PUSH
15334: LD_VAR 0 1
15338: PUSH
15339: FOR_IN
15340: IFFALSE 15364
// if i then
15342: LD_VAR 0 3
15346: IFFALSE 15362
// result := result + 1 ;
15348: LD_ADDR_VAR 0 2
15352: PUSH
15353: LD_VAR 0 2
15357: PUSH
15358: LD_INT 1
15360: PLUS
15361: ST_TO_ADDR
15362: GO 15339
15364: POP
15365: POP
// end ;
15366: LD_VAR 0 2
15370: RET
// export function IsEmpty ( building ) ; begin
15371: LD_INT 0
15373: PPUSH
// if not building then
15374: LD_VAR 0 1
15378: NOT
15379: IFFALSE 15383
// exit ;
15381: GO 15426
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15383: LD_ADDR_VAR 0 2
15387: PUSH
15388: LD_VAR 0 1
15392: PUSH
15393: LD_INT 22
15395: PUSH
15396: LD_VAR 0 1
15400: PPUSH
15401: CALL_OW 255
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PUSH
15410: LD_INT 58
15412: PUSH
15413: EMPTY
15414: LIST
15415: PUSH
15416: EMPTY
15417: LIST
15418: LIST
15419: PPUSH
15420: CALL_OW 69
15424: IN
15425: ST_TO_ADDR
// end ;
15426: LD_VAR 0 2
15430: RET
// export function IsNotFull ( building ) ; begin
15431: LD_INT 0
15433: PPUSH
// if not building then
15434: LD_VAR 0 1
15438: NOT
15439: IFFALSE 15443
// exit ;
15441: GO 15462
// result := UnitsInside ( building ) < 6 ;
15443: LD_ADDR_VAR 0 2
15447: PUSH
15448: LD_VAR 0 1
15452: PPUSH
15453: CALL_OW 313
15457: PUSH
15458: LD_INT 6
15460: LESS
15461: ST_TO_ADDR
// end ;
15462: LD_VAR 0 2
15466: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15467: LD_INT 0
15469: PPUSH
15470: PPUSH
15471: PPUSH
15472: PPUSH
// tmp := [ ] ;
15473: LD_ADDR_VAR 0 3
15477: PUSH
15478: EMPTY
15479: ST_TO_ADDR
// list := [ ] ;
15480: LD_ADDR_VAR 0 5
15484: PUSH
15485: EMPTY
15486: ST_TO_ADDR
// for i = 16 to 25 do
15487: LD_ADDR_VAR 0 4
15491: PUSH
15492: DOUBLE
15493: LD_INT 16
15495: DEC
15496: ST_TO_ADDR
15497: LD_INT 25
15499: PUSH
15500: FOR_TO
15501: IFFALSE 15574
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15503: LD_ADDR_VAR 0 3
15507: PUSH
15508: LD_VAR 0 3
15512: PUSH
15513: LD_INT 22
15515: PUSH
15516: LD_VAR 0 1
15520: PPUSH
15521: CALL_OW 255
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: LD_INT 91
15532: PUSH
15533: LD_VAR 0 1
15537: PUSH
15538: LD_INT 6
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: LIST
15545: PUSH
15546: LD_INT 30
15548: PUSH
15549: LD_VAR 0 4
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: LIST
15562: PUSH
15563: EMPTY
15564: LIST
15565: PPUSH
15566: CALL_OW 69
15570: ADD
15571: ST_TO_ADDR
15572: GO 15500
15574: POP
15575: POP
// for i = 1 to tmp do
15576: LD_ADDR_VAR 0 4
15580: PUSH
15581: DOUBLE
15582: LD_INT 1
15584: DEC
15585: ST_TO_ADDR
15586: LD_VAR 0 3
15590: PUSH
15591: FOR_TO
15592: IFFALSE 15680
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15594: LD_ADDR_VAR 0 5
15598: PUSH
15599: LD_VAR 0 5
15603: PUSH
15604: LD_VAR 0 3
15608: PUSH
15609: LD_VAR 0 4
15613: ARRAY
15614: PPUSH
15615: CALL_OW 266
15619: PUSH
15620: LD_VAR 0 3
15624: PUSH
15625: LD_VAR 0 4
15629: ARRAY
15630: PPUSH
15631: CALL_OW 250
15635: PUSH
15636: LD_VAR 0 3
15640: PUSH
15641: LD_VAR 0 4
15645: ARRAY
15646: PPUSH
15647: CALL_OW 251
15651: PUSH
15652: LD_VAR 0 3
15656: PUSH
15657: LD_VAR 0 4
15661: ARRAY
15662: PPUSH
15663: CALL_OW 254
15667: PUSH
15668: EMPTY
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: PUSH
15674: EMPTY
15675: LIST
15676: ADD
15677: ST_TO_ADDR
15678: GO 15591
15680: POP
15681: POP
// result := list ;
15682: LD_ADDR_VAR 0 2
15686: PUSH
15687: LD_VAR 0 5
15691: ST_TO_ADDR
// end ;
15692: LD_VAR 0 2
15696: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
15697: LD_INT 0
15699: PPUSH
15700: PPUSH
15701: PPUSH
15702: PPUSH
15703: PPUSH
15704: PPUSH
15705: PPUSH
// if not factory then
15706: LD_VAR 0 1
15710: NOT
15711: IFFALSE 15715
// exit ;
15713: GO 16308
// if control = control_apeman then
15715: LD_VAR 0 4
15719: PUSH
15720: LD_INT 5
15722: EQUAL
15723: IFFALSE 15832
// begin tmp := UnitsInside ( factory ) ;
15725: LD_ADDR_VAR 0 8
15729: PUSH
15730: LD_VAR 0 1
15734: PPUSH
15735: CALL_OW 313
15739: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
15740: LD_VAR 0 8
15744: PPUSH
15745: LD_INT 25
15747: PUSH
15748: LD_INT 12
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PPUSH
15755: CALL_OW 72
15759: NOT
15760: IFFALSE 15770
// control := control_manual ;
15762: LD_ADDR_VAR 0 4
15766: PUSH
15767: LD_INT 1
15769: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
15770: LD_ADDR_VAR 0 8
15774: PUSH
15775: LD_VAR 0 1
15779: PPUSH
15780: CALL 15467 0 1
15784: ST_TO_ADDR
// if tmp then
15785: LD_VAR 0 8
15789: IFFALSE 15832
// begin for i in tmp do
15791: LD_ADDR_VAR 0 7
15795: PUSH
15796: LD_VAR 0 8
15800: PUSH
15801: FOR_IN
15802: IFFALSE 15830
// if i [ 1 ] = b_ext_radio then
15804: LD_VAR 0 7
15808: PUSH
15809: LD_INT 1
15811: ARRAY
15812: PUSH
15813: LD_INT 22
15815: EQUAL
15816: IFFALSE 15828
// begin control := control_remote ;
15818: LD_ADDR_VAR 0 4
15822: PUSH
15823: LD_INT 2
15825: ST_TO_ADDR
// break ;
15826: GO 15830
// end ;
15828: GO 15801
15830: POP
15831: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
15832: LD_VAR 0 1
15836: PPUSH
15837: LD_VAR 0 2
15841: PPUSH
15842: LD_VAR 0 3
15846: PPUSH
15847: LD_VAR 0 4
15851: PPUSH
15852: LD_VAR 0 5
15856: PPUSH
15857: CALL_OW 448
15861: IFFALSE 15896
// begin result := [ chassis , engine , control , weapon ] ;
15863: LD_ADDR_VAR 0 6
15867: PUSH
15868: LD_VAR 0 2
15872: PUSH
15873: LD_VAR 0 3
15877: PUSH
15878: LD_VAR 0 4
15882: PUSH
15883: LD_VAR 0 5
15887: PUSH
15888: EMPTY
15889: LIST
15890: LIST
15891: LIST
15892: LIST
15893: ST_TO_ADDR
// exit ;
15894: GO 16308
// end ; _chassis := AvailableChassisList ( factory ) ;
15896: LD_ADDR_VAR 0 9
15900: PUSH
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 475
15910: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
15911: LD_ADDR_VAR 0 11
15915: PUSH
15916: LD_VAR 0 1
15920: PPUSH
15921: CALL_OW 476
15925: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
15926: LD_ADDR_VAR 0 12
15930: PUSH
15931: LD_VAR 0 1
15935: PPUSH
15936: CALL_OW 477
15940: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
15941: LD_ADDR_VAR 0 10
15945: PUSH
15946: LD_VAR 0 1
15950: PPUSH
15951: CALL_OW 478
15955: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
15956: LD_VAR 0 9
15960: NOT
15961: PUSH
15962: LD_VAR 0 11
15966: NOT
15967: OR
15968: PUSH
15969: LD_VAR 0 12
15973: NOT
15974: OR
15975: PUSH
15976: LD_VAR 0 10
15980: NOT
15981: OR
15982: IFFALSE 16017
// begin result := [ chassis , engine , control , weapon ] ;
15984: LD_ADDR_VAR 0 6
15988: PUSH
15989: LD_VAR 0 2
15993: PUSH
15994: LD_VAR 0 3
15998: PUSH
15999: LD_VAR 0 4
16003: PUSH
16004: LD_VAR 0 5
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: ST_TO_ADDR
// exit ;
16015: GO 16308
// end ; if not chassis in _chassis then
16017: LD_VAR 0 2
16021: PUSH
16022: LD_VAR 0 9
16026: IN
16027: NOT
16028: IFFALSE 16054
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16030: LD_ADDR_VAR 0 2
16034: PUSH
16035: LD_VAR 0 9
16039: PUSH
16040: LD_INT 1
16042: PPUSH
16043: LD_VAR 0 9
16047: PPUSH
16048: CALL_OW 12
16052: ARRAY
16053: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16054: LD_VAR 0 2
16058: PPUSH
16059: LD_VAR 0 3
16063: PPUSH
16064: CALL 16313 0 2
16068: NOT
16069: IFFALSE 16128
// repeat engine := _engine [ 1 ] ;
16071: LD_ADDR_VAR 0 3
16075: PUSH
16076: LD_VAR 0 11
16080: PUSH
16081: LD_INT 1
16083: ARRAY
16084: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16085: LD_ADDR_VAR 0 11
16089: PUSH
16090: LD_VAR 0 11
16094: PPUSH
16095: LD_INT 1
16097: PPUSH
16098: CALL_OW 3
16102: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16103: LD_VAR 0 2
16107: PPUSH
16108: LD_VAR 0 3
16112: PPUSH
16113: CALL 16313 0 2
16117: PUSH
16118: LD_VAR 0 11
16122: PUSH
16123: EMPTY
16124: EQUAL
16125: OR
16126: IFFALSE 16071
// if not control in _control then
16128: LD_VAR 0 4
16132: PUSH
16133: LD_VAR 0 12
16137: IN
16138: NOT
16139: IFFALSE 16165
// control := _control [ rand ( 1 , _control ) ] ;
16141: LD_ADDR_VAR 0 4
16145: PUSH
16146: LD_VAR 0 12
16150: PUSH
16151: LD_INT 1
16153: PPUSH
16154: LD_VAR 0 12
16158: PPUSH
16159: CALL_OW 12
16163: ARRAY
16164: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16165: LD_VAR 0 2
16169: PPUSH
16170: LD_VAR 0 5
16174: PPUSH
16175: CALL 16533 0 2
16179: NOT
16180: IFFALSE 16239
// repeat weapon := _weapon [ 1 ] ;
16182: LD_ADDR_VAR 0 5
16186: PUSH
16187: LD_VAR 0 10
16191: PUSH
16192: LD_INT 1
16194: ARRAY
16195: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16196: LD_ADDR_VAR 0 10
16200: PUSH
16201: LD_VAR 0 10
16205: PPUSH
16206: LD_INT 1
16208: PPUSH
16209: CALL_OW 3
16213: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16214: LD_VAR 0 2
16218: PPUSH
16219: LD_VAR 0 5
16223: PPUSH
16224: CALL 16533 0 2
16228: PUSH
16229: LD_VAR 0 10
16233: PUSH
16234: EMPTY
16235: EQUAL
16236: OR
16237: IFFALSE 16182
// result := [ ] ;
16239: LD_ADDR_VAR 0 6
16243: PUSH
16244: EMPTY
16245: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16246: LD_VAR 0 1
16250: PPUSH
16251: LD_VAR 0 2
16255: PPUSH
16256: LD_VAR 0 3
16260: PPUSH
16261: LD_VAR 0 4
16265: PPUSH
16266: LD_VAR 0 5
16270: PPUSH
16271: CALL_OW 448
16275: IFFALSE 16308
// result := [ chassis , engine , control , weapon ] ;
16277: LD_ADDR_VAR 0 6
16281: PUSH
16282: LD_VAR 0 2
16286: PUSH
16287: LD_VAR 0 3
16291: PUSH
16292: LD_VAR 0 4
16296: PUSH
16297: LD_VAR 0 5
16301: PUSH
16302: EMPTY
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: ST_TO_ADDR
// end ;
16308: LD_VAR 0 6
16312: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16313: LD_INT 0
16315: PPUSH
// if not chassis or not engine then
16316: LD_VAR 0 1
16320: NOT
16321: PUSH
16322: LD_VAR 0 2
16326: NOT
16327: OR
16328: IFFALSE 16332
// exit ;
16330: GO 16528
// case engine of engine_solar :
16332: LD_VAR 0 2
16336: PUSH
16337: LD_INT 2
16339: DOUBLE
16340: EQUAL
16341: IFTRUE 16345
16343: GO 16383
16345: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16346: LD_ADDR_VAR 0 3
16350: PUSH
16351: LD_INT 11
16353: PUSH
16354: LD_INT 12
16356: PUSH
16357: LD_INT 13
16359: PUSH
16360: LD_INT 14
16362: PUSH
16363: LD_INT 1
16365: PUSH
16366: LD_INT 2
16368: PUSH
16369: LD_INT 3
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: LIST
16376: LIST
16377: LIST
16378: LIST
16379: LIST
16380: ST_TO_ADDR
16381: GO 16512
16383: LD_INT 1
16385: DOUBLE
16386: EQUAL
16387: IFTRUE 16391
16389: GO 16453
16391: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16392: LD_ADDR_VAR 0 3
16396: PUSH
16397: LD_INT 11
16399: PUSH
16400: LD_INT 12
16402: PUSH
16403: LD_INT 13
16405: PUSH
16406: LD_INT 14
16408: PUSH
16409: LD_INT 1
16411: PUSH
16412: LD_INT 2
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: LD_INT 4
16420: PUSH
16421: LD_INT 5
16423: PUSH
16424: LD_INT 21
16426: PUSH
16427: LD_INT 23
16429: PUSH
16430: LD_INT 22
16432: PUSH
16433: LD_INT 24
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: LIST
16446: LIST
16447: LIST
16448: LIST
16449: LIST
16450: ST_TO_ADDR
16451: GO 16512
16453: LD_INT 3
16455: DOUBLE
16456: EQUAL
16457: IFTRUE 16461
16459: GO 16511
16461: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16462: LD_ADDR_VAR 0 3
16466: PUSH
16467: LD_INT 13
16469: PUSH
16470: LD_INT 14
16472: PUSH
16473: LD_INT 2
16475: PUSH
16476: LD_INT 3
16478: PUSH
16479: LD_INT 4
16481: PUSH
16482: LD_INT 5
16484: PUSH
16485: LD_INT 21
16487: PUSH
16488: LD_INT 22
16490: PUSH
16491: LD_INT 23
16493: PUSH
16494: LD_INT 24
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: LIST
16501: LIST
16502: LIST
16503: LIST
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: ST_TO_ADDR
16509: GO 16512
16511: POP
// result := ( chassis in result ) ;
16512: LD_ADDR_VAR 0 3
16516: PUSH
16517: LD_VAR 0 1
16521: PUSH
16522: LD_VAR 0 3
16526: IN
16527: ST_TO_ADDR
// end ;
16528: LD_VAR 0 3
16532: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16533: LD_INT 0
16535: PPUSH
// if not chassis or not weapon then
16536: LD_VAR 0 1
16540: NOT
16541: PUSH
16542: LD_VAR 0 2
16546: NOT
16547: OR
16548: IFFALSE 16552
// exit ;
16550: GO 17578
// case weapon of us_machine_gun :
16552: LD_VAR 0 2
16556: PUSH
16557: LD_INT 2
16559: DOUBLE
16560: EQUAL
16561: IFTRUE 16565
16563: GO 16595
16565: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16566: LD_ADDR_VAR 0 3
16570: PUSH
16571: LD_INT 1
16573: PUSH
16574: LD_INT 2
16576: PUSH
16577: LD_INT 3
16579: PUSH
16580: LD_INT 4
16582: PUSH
16583: LD_INT 5
16585: PUSH
16586: EMPTY
16587: LIST
16588: LIST
16589: LIST
16590: LIST
16591: LIST
16592: ST_TO_ADDR
16593: GO 17562
16595: LD_INT 3
16597: DOUBLE
16598: EQUAL
16599: IFTRUE 16603
16601: GO 16633
16603: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16604: LD_ADDR_VAR 0 3
16608: PUSH
16609: LD_INT 1
16611: PUSH
16612: LD_INT 2
16614: PUSH
16615: LD_INT 3
16617: PUSH
16618: LD_INT 4
16620: PUSH
16621: LD_INT 5
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: LIST
16629: LIST
16630: ST_TO_ADDR
16631: GO 17562
16633: LD_INT 11
16635: DOUBLE
16636: EQUAL
16637: IFTRUE 16641
16639: GO 16671
16641: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
16642: LD_ADDR_VAR 0 3
16646: PUSH
16647: LD_INT 1
16649: PUSH
16650: LD_INT 2
16652: PUSH
16653: LD_INT 3
16655: PUSH
16656: LD_INT 4
16658: PUSH
16659: LD_INT 5
16661: PUSH
16662: EMPTY
16663: LIST
16664: LIST
16665: LIST
16666: LIST
16667: LIST
16668: ST_TO_ADDR
16669: GO 17562
16671: LD_INT 4
16673: DOUBLE
16674: EQUAL
16675: IFTRUE 16679
16677: GO 16705
16679: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
16680: LD_ADDR_VAR 0 3
16684: PUSH
16685: LD_INT 2
16687: PUSH
16688: LD_INT 3
16690: PUSH
16691: LD_INT 4
16693: PUSH
16694: LD_INT 5
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: ST_TO_ADDR
16703: GO 17562
16705: LD_INT 5
16707: DOUBLE
16708: EQUAL
16709: IFTRUE 16713
16711: GO 16739
16713: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
16714: LD_ADDR_VAR 0 3
16718: PUSH
16719: LD_INT 2
16721: PUSH
16722: LD_INT 3
16724: PUSH
16725: LD_INT 4
16727: PUSH
16728: LD_INT 5
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: LIST
16735: LIST
16736: ST_TO_ADDR
16737: GO 17562
16739: LD_INT 9
16741: DOUBLE
16742: EQUAL
16743: IFTRUE 16747
16745: GO 16773
16747: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
16748: LD_ADDR_VAR 0 3
16752: PUSH
16753: LD_INT 2
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: LD_INT 4
16761: PUSH
16762: LD_INT 5
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: ST_TO_ADDR
16771: GO 17562
16773: LD_INT 7
16775: DOUBLE
16776: EQUAL
16777: IFTRUE 16781
16779: GO 16807
16781: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
16782: LD_ADDR_VAR 0 3
16786: PUSH
16787: LD_INT 2
16789: PUSH
16790: LD_INT 3
16792: PUSH
16793: LD_INT 4
16795: PUSH
16796: LD_INT 5
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: ST_TO_ADDR
16805: GO 17562
16807: LD_INT 12
16809: DOUBLE
16810: EQUAL
16811: IFTRUE 16815
16813: GO 16841
16815: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
16816: LD_ADDR_VAR 0 3
16820: PUSH
16821: LD_INT 2
16823: PUSH
16824: LD_INT 3
16826: PUSH
16827: LD_INT 4
16829: PUSH
16830: LD_INT 5
16832: PUSH
16833: EMPTY
16834: LIST
16835: LIST
16836: LIST
16837: LIST
16838: ST_TO_ADDR
16839: GO 17562
16841: LD_INT 13
16843: DOUBLE
16844: EQUAL
16845: IFTRUE 16849
16847: GO 16875
16849: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
16850: LD_ADDR_VAR 0 3
16854: PUSH
16855: LD_INT 2
16857: PUSH
16858: LD_INT 3
16860: PUSH
16861: LD_INT 4
16863: PUSH
16864: LD_INT 5
16866: PUSH
16867: EMPTY
16868: LIST
16869: LIST
16870: LIST
16871: LIST
16872: ST_TO_ADDR
16873: GO 17562
16875: LD_INT 14
16877: DOUBLE
16878: EQUAL
16879: IFTRUE 16883
16881: GO 16901
16883: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
16884: LD_ADDR_VAR 0 3
16888: PUSH
16889: LD_INT 4
16891: PUSH
16892: LD_INT 5
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: ST_TO_ADDR
16899: GO 17562
16901: LD_INT 6
16903: DOUBLE
16904: EQUAL
16905: IFTRUE 16909
16907: GO 16927
16909: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
16910: LD_ADDR_VAR 0 3
16914: PUSH
16915: LD_INT 4
16917: PUSH
16918: LD_INT 5
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: ST_TO_ADDR
16925: GO 17562
16927: LD_INT 10
16929: DOUBLE
16930: EQUAL
16931: IFTRUE 16935
16933: GO 16953
16935: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
16936: LD_ADDR_VAR 0 3
16940: PUSH
16941: LD_INT 4
16943: PUSH
16944: LD_INT 5
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: ST_TO_ADDR
16951: GO 17562
16953: LD_INT 22
16955: DOUBLE
16956: EQUAL
16957: IFTRUE 16961
16959: GO 16987
16961: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
16962: LD_ADDR_VAR 0 3
16966: PUSH
16967: LD_INT 11
16969: PUSH
16970: LD_INT 12
16972: PUSH
16973: LD_INT 13
16975: PUSH
16976: LD_INT 14
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: LIST
16983: LIST
16984: ST_TO_ADDR
16985: GO 17562
16987: LD_INT 23
16989: DOUBLE
16990: EQUAL
16991: IFTRUE 16995
16993: GO 17021
16995: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
16996: LD_ADDR_VAR 0 3
17000: PUSH
17001: LD_INT 11
17003: PUSH
17004: LD_INT 12
17006: PUSH
17007: LD_INT 13
17009: PUSH
17010: LD_INT 14
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: ST_TO_ADDR
17019: GO 17562
17021: LD_INT 24
17023: DOUBLE
17024: EQUAL
17025: IFTRUE 17029
17027: GO 17055
17029: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17030: LD_ADDR_VAR 0 3
17034: PUSH
17035: LD_INT 11
17037: PUSH
17038: LD_INT 12
17040: PUSH
17041: LD_INT 13
17043: PUSH
17044: LD_INT 14
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: ST_TO_ADDR
17053: GO 17562
17055: LD_INT 30
17057: DOUBLE
17058: EQUAL
17059: IFTRUE 17063
17061: GO 17089
17063: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17064: LD_ADDR_VAR 0 3
17068: PUSH
17069: LD_INT 11
17071: PUSH
17072: LD_INT 12
17074: PUSH
17075: LD_INT 13
17077: PUSH
17078: LD_INT 14
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: LIST
17085: LIST
17086: ST_TO_ADDR
17087: GO 17562
17089: LD_INT 25
17091: DOUBLE
17092: EQUAL
17093: IFTRUE 17097
17095: GO 17115
17097: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17098: LD_ADDR_VAR 0 3
17102: PUSH
17103: LD_INT 13
17105: PUSH
17106: LD_INT 14
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: ST_TO_ADDR
17113: GO 17562
17115: LD_INT 27
17117: DOUBLE
17118: EQUAL
17119: IFTRUE 17123
17121: GO 17141
17123: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17124: LD_ADDR_VAR 0 3
17128: PUSH
17129: LD_INT 13
17131: PUSH
17132: LD_INT 14
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: ST_TO_ADDR
17139: GO 17562
17141: LD_INT 28
17143: DOUBLE
17144: EQUAL
17145: IFTRUE 17149
17147: GO 17167
17149: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17150: LD_ADDR_VAR 0 3
17154: PUSH
17155: LD_INT 13
17157: PUSH
17158: LD_INT 14
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: ST_TO_ADDR
17165: GO 17562
17167: LD_INT 29
17169: DOUBLE
17170: EQUAL
17171: IFTRUE 17175
17173: GO 17193
17175: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17176: LD_ADDR_VAR 0 3
17180: PUSH
17181: LD_INT 13
17183: PUSH
17184: LD_INT 14
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: ST_TO_ADDR
17191: GO 17562
17193: LD_INT 31
17195: DOUBLE
17196: EQUAL
17197: IFTRUE 17201
17199: GO 17219
17201: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17202: LD_ADDR_VAR 0 3
17206: PUSH
17207: LD_INT 13
17209: PUSH
17210: LD_INT 14
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: ST_TO_ADDR
17217: GO 17562
17219: LD_INT 26
17221: DOUBLE
17222: EQUAL
17223: IFTRUE 17227
17225: GO 17245
17227: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17228: LD_ADDR_VAR 0 3
17232: PUSH
17233: LD_INT 13
17235: PUSH
17236: LD_INT 14
17238: PUSH
17239: EMPTY
17240: LIST
17241: LIST
17242: ST_TO_ADDR
17243: GO 17562
17245: LD_INT 42
17247: DOUBLE
17248: EQUAL
17249: IFTRUE 17253
17251: GO 17279
17253: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17254: LD_ADDR_VAR 0 3
17258: PUSH
17259: LD_INT 21
17261: PUSH
17262: LD_INT 22
17264: PUSH
17265: LD_INT 23
17267: PUSH
17268: LD_INT 24
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: LIST
17275: LIST
17276: ST_TO_ADDR
17277: GO 17562
17279: LD_INT 43
17281: DOUBLE
17282: EQUAL
17283: IFTRUE 17287
17285: GO 17313
17287: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17288: LD_ADDR_VAR 0 3
17292: PUSH
17293: LD_INT 21
17295: PUSH
17296: LD_INT 22
17298: PUSH
17299: LD_INT 23
17301: PUSH
17302: LD_INT 24
17304: PUSH
17305: EMPTY
17306: LIST
17307: LIST
17308: LIST
17309: LIST
17310: ST_TO_ADDR
17311: GO 17562
17313: LD_INT 44
17315: DOUBLE
17316: EQUAL
17317: IFTRUE 17321
17319: GO 17347
17321: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17322: LD_ADDR_VAR 0 3
17326: PUSH
17327: LD_INT 21
17329: PUSH
17330: LD_INT 22
17332: PUSH
17333: LD_INT 23
17335: PUSH
17336: LD_INT 24
17338: PUSH
17339: EMPTY
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: ST_TO_ADDR
17345: GO 17562
17347: LD_INT 45
17349: DOUBLE
17350: EQUAL
17351: IFTRUE 17355
17353: GO 17381
17355: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17356: LD_ADDR_VAR 0 3
17360: PUSH
17361: LD_INT 21
17363: PUSH
17364: LD_INT 22
17366: PUSH
17367: LD_INT 23
17369: PUSH
17370: LD_INT 24
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: LIST
17377: LIST
17378: ST_TO_ADDR
17379: GO 17562
17381: LD_INT 49
17383: DOUBLE
17384: EQUAL
17385: IFTRUE 17389
17387: GO 17415
17389: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: LD_INT 21
17397: PUSH
17398: LD_INT 22
17400: PUSH
17401: LD_INT 23
17403: PUSH
17404: LD_INT 24
17406: PUSH
17407: EMPTY
17408: LIST
17409: LIST
17410: LIST
17411: LIST
17412: ST_TO_ADDR
17413: GO 17562
17415: LD_INT 51
17417: DOUBLE
17418: EQUAL
17419: IFTRUE 17423
17421: GO 17449
17423: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17424: LD_ADDR_VAR 0 3
17428: PUSH
17429: LD_INT 21
17431: PUSH
17432: LD_INT 22
17434: PUSH
17435: LD_INT 23
17437: PUSH
17438: LD_INT 24
17440: PUSH
17441: EMPTY
17442: LIST
17443: LIST
17444: LIST
17445: LIST
17446: ST_TO_ADDR
17447: GO 17562
17449: LD_INT 52
17451: DOUBLE
17452: EQUAL
17453: IFTRUE 17457
17455: GO 17483
17457: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17458: LD_ADDR_VAR 0 3
17462: PUSH
17463: LD_INT 21
17465: PUSH
17466: LD_INT 22
17468: PUSH
17469: LD_INT 23
17471: PUSH
17472: LD_INT 24
17474: PUSH
17475: EMPTY
17476: LIST
17477: LIST
17478: LIST
17479: LIST
17480: ST_TO_ADDR
17481: GO 17562
17483: LD_INT 53
17485: DOUBLE
17486: EQUAL
17487: IFTRUE 17491
17489: GO 17509
17491: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17492: LD_ADDR_VAR 0 3
17496: PUSH
17497: LD_INT 23
17499: PUSH
17500: LD_INT 24
17502: PUSH
17503: EMPTY
17504: LIST
17505: LIST
17506: ST_TO_ADDR
17507: GO 17562
17509: LD_INT 46
17511: DOUBLE
17512: EQUAL
17513: IFTRUE 17517
17515: GO 17535
17517: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17518: LD_ADDR_VAR 0 3
17522: PUSH
17523: LD_INT 23
17525: PUSH
17526: LD_INT 24
17528: PUSH
17529: EMPTY
17530: LIST
17531: LIST
17532: ST_TO_ADDR
17533: GO 17562
17535: LD_INT 47
17537: DOUBLE
17538: EQUAL
17539: IFTRUE 17543
17541: GO 17561
17543: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17544: LD_ADDR_VAR 0 3
17548: PUSH
17549: LD_INT 23
17551: PUSH
17552: LD_INT 24
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: ST_TO_ADDR
17559: GO 17562
17561: POP
// result := ( chassis in result ) ;
17562: LD_ADDR_VAR 0 3
17566: PUSH
17567: LD_VAR 0 1
17571: PUSH
17572: LD_VAR 0 3
17576: IN
17577: ST_TO_ADDR
// end ;
17578: LD_VAR 0 3
17582: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17583: LD_INT 0
17585: PPUSH
17586: PPUSH
17587: PPUSH
17588: PPUSH
17589: PPUSH
17590: PPUSH
17591: PPUSH
// result := array ;
17592: LD_ADDR_VAR 0 5
17596: PUSH
17597: LD_VAR 0 1
17601: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
17602: LD_VAR 0 1
17606: NOT
17607: PUSH
17608: LD_VAR 0 2
17612: NOT
17613: OR
17614: PUSH
17615: LD_VAR 0 3
17619: NOT
17620: OR
17621: PUSH
17622: LD_VAR 0 2
17626: PUSH
17627: LD_VAR 0 1
17631: GREATER
17632: OR
17633: PUSH
17634: LD_VAR 0 3
17638: PUSH
17639: LD_VAR 0 1
17643: GREATER
17644: OR
17645: IFFALSE 17649
// exit ;
17647: GO 17945
// if direction then
17649: LD_VAR 0 4
17653: IFFALSE 17717
// begin d := 1 ;
17655: LD_ADDR_VAR 0 9
17659: PUSH
17660: LD_INT 1
17662: ST_TO_ADDR
// if i_from > i_to then
17663: LD_VAR 0 2
17667: PUSH
17668: LD_VAR 0 3
17672: GREATER
17673: IFFALSE 17699
// length := ( array - i_from ) + i_to else
17675: LD_ADDR_VAR 0 11
17679: PUSH
17680: LD_VAR 0 1
17684: PUSH
17685: LD_VAR 0 2
17689: MINUS
17690: PUSH
17691: LD_VAR 0 3
17695: PLUS
17696: ST_TO_ADDR
17697: GO 17715
// length := i_to - i_from ;
17699: LD_ADDR_VAR 0 11
17703: PUSH
17704: LD_VAR 0 3
17708: PUSH
17709: LD_VAR 0 2
17713: MINUS
17714: ST_TO_ADDR
// end else
17715: GO 17778
// begin d := - 1 ;
17717: LD_ADDR_VAR 0 9
17721: PUSH
17722: LD_INT 1
17724: NEG
17725: ST_TO_ADDR
// if i_from > i_to then
17726: LD_VAR 0 2
17730: PUSH
17731: LD_VAR 0 3
17735: GREATER
17736: IFFALSE 17756
// length := i_from - i_to else
17738: LD_ADDR_VAR 0 11
17742: PUSH
17743: LD_VAR 0 2
17747: PUSH
17748: LD_VAR 0 3
17752: MINUS
17753: ST_TO_ADDR
17754: GO 17778
// length := ( array - i_to ) + i_from ;
17756: LD_ADDR_VAR 0 11
17760: PUSH
17761: LD_VAR 0 1
17765: PUSH
17766: LD_VAR 0 3
17770: MINUS
17771: PUSH
17772: LD_VAR 0 2
17776: PLUS
17777: ST_TO_ADDR
// end ; if not length then
17778: LD_VAR 0 11
17782: NOT
17783: IFFALSE 17787
// exit ;
17785: GO 17945
// tmp := array ;
17787: LD_ADDR_VAR 0 10
17791: PUSH
17792: LD_VAR 0 1
17796: ST_TO_ADDR
// for i = 1 to length do
17797: LD_ADDR_VAR 0 6
17801: PUSH
17802: DOUBLE
17803: LD_INT 1
17805: DEC
17806: ST_TO_ADDR
17807: LD_VAR 0 11
17811: PUSH
17812: FOR_TO
17813: IFFALSE 17933
// begin for j = 1 to array do
17815: LD_ADDR_VAR 0 7
17819: PUSH
17820: DOUBLE
17821: LD_INT 1
17823: DEC
17824: ST_TO_ADDR
17825: LD_VAR 0 1
17829: PUSH
17830: FOR_TO
17831: IFFALSE 17919
// begin k := j + d ;
17833: LD_ADDR_VAR 0 8
17837: PUSH
17838: LD_VAR 0 7
17842: PUSH
17843: LD_VAR 0 9
17847: PLUS
17848: ST_TO_ADDR
// if k > array then
17849: LD_VAR 0 8
17853: PUSH
17854: LD_VAR 0 1
17858: GREATER
17859: IFFALSE 17869
// k := 1 ;
17861: LD_ADDR_VAR 0 8
17865: PUSH
17866: LD_INT 1
17868: ST_TO_ADDR
// if not k then
17869: LD_VAR 0 8
17873: NOT
17874: IFFALSE 17886
// k := array ;
17876: LD_ADDR_VAR 0 8
17880: PUSH
17881: LD_VAR 0 1
17885: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
17886: LD_ADDR_VAR 0 10
17890: PUSH
17891: LD_VAR 0 10
17895: PPUSH
17896: LD_VAR 0 8
17900: PPUSH
17901: LD_VAR 0 1
17905: PUSH
17906: LD_VAR 0 7
17910: ARRAY
17911: PPUSH
17912: CALL_OW 1
17916: ST_TO_ADDR
// end ;
17917: GO 17830
17919: POP
17920: POP
// array := tmp ;
17921: LD_ADDR_VAR 0 1
17925: PUSH
17926: LD_VAR 0 10
17930: ST_TO_ADDR
// end ;
17931: GO 17812
17933: POP
17934: POP
// result := array ;
17935: LD_ADDR_VAR 0 5
17939: PUSH
17940: LD_VAR 0 1
17944: ST_TO_ADDR
// end ;
17945: LD_VAR 0 5
17949: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
17950: LD_INT 0
17952: PPUSH
17953: PPUSH
// result := 0 ;
17954: LD_ADDR_VAR 0 3
17958: PUSH
17959: LD_INT 0
17961: ST_TO_ADDR
// if not array or not value in array then
17962: LD_VAR 0 1
17966: NOT
17967: PUSH
17968: LD_VAR 0 2
17972: PUSH
17973: LD_VAR 0 1
17977: IN
17978: NOT
17979: OR
17980: IFFALSE 17984
// exit ;
17982: GO 18038
// for i = 1 to array do
17984: LD_ADDR_VAR 0 4
17988: PUSH
17989: DOUBLE
17990: LD_INT 1
17992: DEC
17993: ST_TO_ADDR
17994: LD_VAR 0 1
17998: PUSH
17999: FOR_TO
18000: IFFALSE 18036
// if value = array [ i ] then
18002: LD_VAR 0 2
18006: PUSH
18007: LD_VAR 0 1
18011: PUSH
18012: LD_VAR 0 4
18016: ARRAY
18017: EQUAL
18018: IFFALSE 18034
// begin result := i ;
18020: LD_ADDR_VAR 0 3
18024: PUSH
18025: LD_VAR 0 4
18029: ST_TO_ADDR
// exit ;
18030: POP
18031: POP
18032: GO 18038
// end ;
18034: GO 17999
18036: POP
18037: POP
// end ;
18038: LD_VAR 0 3
18042: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18043: LD_INT 0
18045: PPUSH
// vc_chassis := chassis ;
18046: LD_ADDR_OWVAR 37
18050: PUSH
18051: LD_VAR 0 1
18055: ST_TO_ADDR
// vc_engine := engine ;
18056: LD_ADDR_OWVAR 39
18060: PUSH
18061: LD_VAR 0 2
18065: ST_TO_ADDR
// vc_control := control ;
18066: LD_ADDR_OWVAR 38
18070: PUSH
18071: LD_VAR 0 3
18075: ST_TO_ADDR
// vc_weapon := weapon ;
18076: LD_ADDR_OWVAR 40
18080: PUSH
18081: LD_VAR 0 4
18085: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18086: LD_ADDR_OWVAR 41
18090: PUSH
18091: LD_VAR 0 5
18095: ST_TO_ADDR
// end ;
18096: LD_VAR 0 6
18100: RET
// export function WantPlant ( unit ) ; var task ; begin
18101: LD_INT 0
18103: PPUSH
18104: PPUSH
// result := false ;
18105: LD_ADDR_VAR 0 2
18109: PUSH
18110: LD_INT 0
18112: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18113: LD_ADDR_VAR 0 3
18117: PUSH
18118: LD_VAR 0 1
18122: PPUSH
18123: CALL_OW 437
18127: ST_TO_ADDR
// if task then
18128: LD_VAR 0 3
18132: IFFALSE 18160
// if task [ 1 ] [ 1 ] = p then
18134: LD_VAR 0 3
18138: PUSH
18139: LD_INT 1
18141: ARRAY
18142: PUSH
18143: LD_INT 1
18145: ARRAY
18146: PUSH
18147: LD_STRING p
18149: EQUAL
18150: IFFALSE 18160
// result := true ;
18152: LD_ADDR_VAR 0 2
18156: PUSH
18157: LD_INT 1
18159: ST_TO_ADDR
// end ;
18160: LD_VAR 0 2
18164: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18165: LD_INT 0
18167: PPUSH
18168: PPUSH
18169: PPUSH
18170: PPUSH
// if pos < 1 then
18171: LD_VAR 0 2
18175: PUSH
18176: LD_INT 1
18178: LESS
18179: IFFALSE 18183
// exit ;
18181: GO 18486
// if pos = 1 then
18183: LD_VAR 0 2
18187: PUSH
18188: LD_INT 1
18190: EQUAL
18191: IFFALSE 18224
// result := Replace ( arr , pos [ 1 ] , value ) else
18193: LD_ADDR_VAR 0 4
18197: PUSH
18198: LD_VAR 0 1
18202: PPUSH
18203: LD_VAR 0 2
18207: PUSH
18208: LD_INT 1
18210: ARRAY
18211: PPUSH
18212: LD_VAR 0 3
18216: PPUSH
18217: CALL_OW 1
18221: ST_TO_ADDR
18222: GO 18486
// begin tmp := arr ;
18224: LD_ADDR_VAR 0 6
18228: PUSH
18229: LD_VAR 0 1
18233: ST_TO_ADDR
// s_arr := [ tmp ] ;
18234: LD_ADDR_VAR 0 7
18238: PUSH
18239: LD_VAR 0 6
18243: PUSH
18244: EMPTY
18245: LIST
18246: ST_TO_ADDR
// for i = 1 to pos - 1 do
18247: LD_ADDR_VAR 0 5
18251: PUSH
18252: DOUBLE
18253: LD_INT 1
18255: DEC
18256: ST_TO_ADDR
18257: LD_VAR 0 2
18261: PUSH
18262: LD_INT 1
18264: MINUS
18265: PUSH
18266: FOR_TO
18267: IFFALSE 18312
// begin tmp := tmp [ pos [ i ] ] ;
18269: LD_ADDR_VAR 0 6
18273: PUSH
18274: LD_VAR 0 6
18278: PUSH
18279: LD_VAR 0 2
18283: PUSH
18284: LD_VAR 0 5
18288: ARRAY
18289: ARRAY
18290: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18291: LD_ADDR_VAR 0 7
18295: PUSH
18296: LD_VAR 0 7
18300: PUSH
18301: LD_VAR 0 6
18305: PUSH
18306: EMPTY
18307: LIST
18308: ADD
18309: ST_TO_ADDR
// end ;
18310: GO 18266
18312: POP
18313: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18314: LD_ADDR_VAR 0 6
18318: PUSH
18319: LD_VAR 0 6
18323: PPUSH
18324: LD_VAR 0 2
18328: PUSH
18329: LD_VAR 0 2
18333: ARRAY
18334: PPUSH
18335: LD_VAR 0 3
18339: PPUSH
18340: CALL_OW 1
18344: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18345: LD_ADDR_VAR 0 7
18349: PUSH
18350: LD_VAR 0 7
18354: PPUSH
18355: LD_VAR 0 7
18359: PPUSH
18360: LD_VAR 0 6
18364: PPUSH
18365: CALL_OW 1
18369: ST_TO_ADDR
// for i = s_arr downto 2 do
18370: LD_ADDR_VAR 0 5
18374: PUSH
18375: DOUBLE
18376: LD_VAR 0 7
18380: INC
18381: ST_TO_ADDR
18382: LD_INT 2
18384: PUSH
18385: FOR_DOWNTO
18386: IFFALSE 18470
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18388: LD_ADDR_VAR 0 6
18392: PUSH
18393: LD_VAR 0 7
18397: PUSH
18398: LD_VAR 0 5
18402: PUSH
18403: LD_INT 1
18405: MINUS
18406: ARRAY
18407: PPUSH
18408: LD_VAR 0 2
18412: PUSH
18413: LD_VAR 0 5
18417: PUSH
18418: LD_INT 1
18420: MINUS
18421: ARRAY
18422: PPUSH
18423: LD_VAR 0 7
18427: PUSH
18428: LD_VAR 0 5
18432: ARRAY
18433: PPUSH
18434: CALL_OW 1
18438: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18439: LD_ADDR_VAR 0 7
18443: PUSH
18444: LD_VAR 0 7
18448: PPUSH
18449: LD_VAR 0 5
18453: PUSH
18454: LD_INT 1
18456: MINUS
18457: PPUSH
18458: LD_VAR 0 6
18462: PPUSH
18463: CALL_OW 1
18467: ST_TO_ADDR
// end ;
18468: GO 18385
18470: POP
18471: POP
// result := s_arr [ 1 ] ;
18472: LD_ADDR_VAR 0 4
18476: PUSH
18477: LD_VAR 0 7
18481: PUSH
18482: LD_INT 1
18484: ARRAY
18485: ST_TO_ADDR
// end ; end ;
18486: LD_VAR 0 4
18490: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18491: LD_INT 0
18493: PPUSH
18494: PPUSH
// if not list then
18495: LD_VAR 0 1
18499: NOT
18500: IFFALSE 18504
// exit ;
18502: GO 18595
// i := list [ pos1 ] ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_VAR 0 1
18513: PUSH
18514: LD_VAR 0 2
18518: ARRAY
18519: ST_TO_ADDR
// if not i then
18520: LD_VAR 0 5
18524: NOT
18525: IFFALSE 18529
// exit ;
18527: GO 18595
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18529: LD_ADDR_VAR 0 1
18533: PUSH
18534: LD_VAR 0 1
18538: PPUSH
18539: LD_VAR 0 2
18543: PPUSH
18544: LD_VAR 0 1
18548: PUSH
18549: LD_VAR 0 3
18553: ARRAY
18554: PPUSH
18555: CALL_OW 1
18559: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18560: LD_ADDR_VAR 0 1
18564: PUSH
18565: LD_VAR 0 1
18569: PPUSH
18570: LD_VAR 0 3
18574: PPUSH
18575: LD_VAR 0 5
18579: PPUSH
18580: CALL_OW 1
18584: ST_TO_ADDR
// result := list ;
18585: LD_ADDR_VAR 0 4
18589: PUSH
18590: LD_VAR 0 1
18594: ST_TO_ADDR
// end ;
18595: LD_VAR 0 4
18599: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
18600: LD_INT 0
18602: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
18603: LD_ADDR_VAR 0 5
18607: PUSH
18608: LD_VAR 0 1
18612: PPUSH
18613: CALL_OW 250
18617: PPUSH
18618: LD_VAR 0 1
18622: PPUSH
18623: CALL_OW 251
18627: PPUSH
18628: LD_VAR 0 2
18632: PPUSH
18633: LD_VAR 0 3
18637: PPUSH
18638: LD_VAR 0 4
18642: PPUSH
18643: CALL 18653 0 5
18647: ST_TO_ADDR
// end ;
18648: LD_VAR 0 5
18652: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
18653: LD_INT 0
18655: PPUSH
18656: PPUSH
18657: PPUSH
18658: PPUSH
// if not list then
18659: LD_VAR 0 3
18663: NOT
18664: IFFALSE 18668
// exit ;
18666: GO 19056
// result := [ ] ;
18668: LD_ADDR_VAR 0 6
18672: PUSH
18673: EMPTY
18674: ST_TO_ADDR
// for i in list do
18675: LD_ADDR_VAR 0 7
18679: PUSH
18680: LD_VAR 0 3
18684: PUSH
18685: FOR_IN
18686: IFFALSE 18888
// begin tmp := GetDistUnitXY ( i , x , y ) ;
18688: LD_ADDR_VAR 0 9
18692: PUSH
18693: LD_VAR 0 7
18697: PPUSH
18698: LD_VAR 0 1
18702: PPUSH
18703: LD_VAR 0 2
18707: PPUSH
18708: CALL_OW 297
18712: ST_TO_ADDR
// if not result then
18713: LD_VAR 0 6
18717: NOT
18718: IFFALSE 18744
// result := [ [ i , tmp ] ] else
18720: LD_ADDR_VAR 0 6
18724: PUSH
18725: LD_VAR 0 7
18729: PUSH
18730: LD_VAR 0 9
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: ST_TO_ADDR
18742: GO 18886
// begin if result [ result ] [ 2 ] < tmp then
18744: LD_VAR 0 6
18748: PUSH
18749: LD_VAR 0 6
18753: ARRAY
18754: PUSH
18755: LD_INT 2
18757: ARRAY
18758: PUSH
18759: LD_VAR 0 9
18763: LESS
18764: IFFALSE 18806
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
18766: LD_ADDR_VAR 0 6
18770: PUSH
18771: LD_VAR 0 6
18775: PPUSH
18776: LD_VAR 0 6
18780: PUSH
18781: LD_INT 1
18783: PLUS
18784: PPUSH
18785: LD_VAR 0 7
18789: PUSH
18790: LD_VAR 0 9
18794: PUSH
18795: EMPTY
18796: LIST
18797: LIST
18798: PPUSH
18799: CALL_OW 2
18803: ST_TO_ADDR
18804: GO 18886
// for j = 1 to result do
18806: LD_ADDR_VAR 0 8
18810: PUSH
18811: DOUBLE
18812: LD_INT 1
18814: DEC
18815: ST_TO_ADDR
18816: LD_VAR 0 6
18820: PUSH
18821: FOR_TO
18822: IFFALSE 18884
// begin if tmp < result [ j ] [ 2 ] then
18824: LD_VAR 0 9
18828: PUSH
18829: LD_VAR 0 6
18833: PUSH
18834: LD_VAR 0 8
18838: ARRAY
18839: PUSH
18840: LD_INT 2
18842: ARRAY
18843: LESS
18844: IFFALSE 18882
// begin result := Insert ( result , j , [ i , tmp ] ) ;
18846: LD_ADDR_VAR 0 6
18850: PUSH
18851: LD_VAR 0 6
18855: PPUSH
18856: LD_VAR 0 8
18860: PPUSH
18861: LD_VAR 0 7
18865: PUSH
18866: LD_VAR 0 9
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 2
18879: ST_TO_ADDR
// break ;
18880: GO 18884
// end ; end ;
18882: GO 18821
18884: POP
18885: POP
// end ; end ;
18886: GO 18685
18888: POP
18889: POP
// if result and not asc then
18890: LD_VAR 0 6
18894: PUSH
18895: LD_VAR 0 4
18899: NOT
18900: AND
18901: IFFALSE 18976
// begin tmp := result ;
18903: LD_ADDR_VAR 0 9
18907: PUSH
18908: LD_VAR 0 6
18912: ST_TO_ADDR
// for i = tmp downto 1 do
18913: LD_ADDR_VAR 0 7
18917: PUSH
18918: DOUBLE
18919: LD_VAR 0 9
18923: INC
18924: ST_TO_ADDR
18925: LD_INT 1
18927: PUSH
18928: FOR_DOWNTO
18929: IFFALSE 18974
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
18931: LD_ADDR_VAR 0 6
18935: PUSH
18936: LD_VAR 0 6
18940: PPUSH
18941: LD_VAR 0 9
18945: PUSH
18946: LD_VAR 0 7
18950: MINUS
18951: PUSH
18952: LD_INT 1
18954: PLUS
18955: PPUSH
18956: LD_VAR 0 9
18960: PUSH
18961: LD_VAR 0 7
18965: ARRAY
18966: PPUSH
18967: CALL_OW 1
18971: ST_TO_ADDR
18972: GO 18928
18974: POP
18975: POP
// end ; tmp := [ ] ;
18976: LD_ADDR_VAR 0 9
18980: PUSH
18981: EMPTY
18982: ST_TO_ADDR
// if mode then
18983: LD_VAR 0 5
18987: IFFALSE 19056
// begin for i = 1 to result do
18989: LD_ADDR_VAR 0 7
18993: PUSH
18994: DOUBLE
18995: LD_INT 1
18997: DEC
18998: ST_TO_ADDR
18999: LD_VAR 0 6
19003: PUSH
19004: FOR_TO
19005: IFFALSE 19044
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19007: LD_ADDR_VAR 0 9
19011: PUSH
19012: LD_VAR 0 9
19016: PPUSH
19017: LD_VAR 0 7
19021: PPUSH
19022: LD_VAR 0 6
19026: PUSH
19027: LD_VAR 0 7
19031: ARRAY
19032: PUSH
19033: LD_INT 1
19035: ARRAY
19036: PPUSH
19037: CALL_OW 1
19041: ST_TO_ADDR
19042: GO 19004
19044: POP
19045: POP
// result := tmp ;
19046: LD_ADDR_VAR 0 6
19050: PUSH
19051: LD_VAR 0 9
19055: ST_TO_ADDR
// end ; end ;
19056: LD_VAR 0 6
19060: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
19067: PPUSH
19068: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19069: LD_ADDR_VAR 0 5
19073: PUSH
19074: LD_INT 0
19076: PUSH
19077: LD_INT 0
19079: PUSH
19080: LD_INT 0
19082: PUSH
19083: EMPTY
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: LIST
19089: LIST
19090: ST_TO_ADDR
// if not x or not y then
19091: LD_VAR 0 2
19095: NOT
19096: PUSH
19097: LD_VAR 0 3
19101: NOT
19102: OR
19103: IFFALSE 19107
// exit ;
19105: GO 20753
// if not range then
19107: LD_VAR 0 4
19111: NOT
19112: IFFALSE 19122
// range := 10 ;
19114: LD_ADDR_VAR 0 4
19118: PUSH
19119: LD_INT 10
19121: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19122: LD_ADDR_VAR 0 8
19126: PUSH
19127: LD_INT 81
19129: PUSH
19130: LD_VAR 0 1
19134: PUSH
19135: EMPTY
19136: LIST
19137: LIST
19138: PUSH
19139: LD_INT 92
19141: PUSH
19142: LD_VAR 0 2
19146: PUSH
19147: LD_VAR 0 3
19151: PUSH
19152: LD_VAR 0 4
19156: PUSH
19157: EMPTY
19158: LIST
19159: LIST
19160: LIST
19161: LIST
19162: PUSH
19163: LD_INT 3
19165: PUSH
19166: LD_INT 21
19168: PUSH
19169: LD_INT 3
19171: PUSH
19172: EMPTY
19173: LIST
19174: LIST
19175: PUSH
19176: EMPTY
19177: LIST
19178: LIST
19179: PUSH
19180: EMPTY
19181: LIST
19182: LIST
19183: LIST
19184: PPUSH
19185: CALL_OW 69
19189: ST_TO_ADDR
// if not tmp then
19190: LD_VAR 0 8
19194: NOT
19195: IFFALSE 19199
// exit ;
19197: GO 20753
// for i in tmp do
19199: LD_ADDR_VAR 0 6
19203: PUSH
19204: LD_VAR 0 8
19208: PUSH
19209: FOR_IN
19210: IFFALSE 20728
// begin points := [ 0 , 0 , 0 ] ;
19212: LD_ADDR_VAR 0 9
19216: PUSH
19217: LD_INT 0
19219: PUSH
19220: LD_INT 0
19222: PUSH
19223: LD_INT 0
19225: PUSH
19226: EMPTY
19227: LIST
19228: LIST
19229: LIST
19230: ST_TO_ADDR
// bpoints := 1 ;
19231: LD_ADDR_VAR 0 10
19235: PUSH
19236: LD_INT 1
19238: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19239: LD_VAR 0 6
19243: PPUSH
19244: CALL_OW 247
19248: PUSH
19249: LD_INT 1
19251: DOUBLE
19252: EQUAL
19253: IFTRUE 19257
19255: GO 19835
19257: POP
// begin if GetClass ( i ) = 1 then
19258: LD_VAR 0 6
19262: PPUSH
19263: CALL_OW 257
19267: PUSH
19268: LD_INT 1
19270: EQUAL
19271: IFFALSE 19292
// points := [ 10 , 5 , 3 ] ;
19273: LD_ADDR_VAR 0 9
19277: PUSH
19278: LD_INT 10
19280: PUSH
19281: LD_INT 5
19283: PUSH
19284: LD_INT 3
19286: PUSH
19287: EMPTY
19288: LIST
19289: LIST
19290: LIST
19291: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19292: LD_VAR 0 6
19296: PPUSH
19297: CALL_OW 257
19301: PUSH
19302: LD_INT 2
19304: PUSH
19305: LD_INT 3
19307: PUSH
19308: LD_INT 4
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: IN
19316: IFFALSE 19337
// points := [ 3 , 2 , 1 ] ;
19318: LD_ADDR_VAR 0 9
19322: PUSH
19323: LD_INT 3
19325: PUSH
19326: LD_INT 2
19328: PUSH
19329: LD_INT 1
19331: PUSH
19332: EMPTY
19333: LIST
19334: LIST
19335: LIST
19336: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19337: LD_VAR 0 6
19341: PPUSH
19342: CALL_OW 257
19346: PUSH
19347: LD_INT 5
19349: EQUAL
19350: IFFALSE 19371
// points := [ 130 , 5 , 2 ] ;
19352: LD_ADDR_VAR 0 9
19356: PUSH
19357: LD_INT 130
19359: PUSH
19360: LD_INT 5
19362: PUSH
19363: LD_INT 2
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: LIST
19370: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19371: LD_VAR 0 6
19375: PPUSH
19376: CALL_OW 257
19380: PUSH
19381: LD_INT 8
19383: EQUAL
19384: IFFALSE 19405
// points := [ 35 , 35 , 30 ] ;
19386: LD_ADDR_VAR 0 9
19390: PUSH
19391: LD_INT 35
19393: PUSH
19394: LD_INT 35
19396: PUSH
19397: LD_INT 30
19399: PUSH
19400: EMPTY
19401: LIST
19402: LIST
19403: LIST
19404: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19405: LD_VAR 0 6
19409: PPUSH
19410: CALL_OW 257
19414: PUSH
19415: LD_INT 9
19417: EQUAL
19418: IFFALSE 19439
// points := [ 20 , 55 , 40 ] ;
19420: LD_ADDR_VAR 0 9
19424: PUSH
19425: LD_INT 20
19427: PUSH
19428: LD_INT 55
19430: PUSH
19431: LD_INT 40
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: LIST
19438: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19439: LD_VAR 0 6
19443: PPUSH
19444: CALL_OW 257
19448: PUSH
19449: LD_INT 12
19451: PUSH
19452: LD_INT 16
19454: PUSH
19455: EMPTY
19456: LIST
19457: LIST
19458: IN
19459: IFFALSE 19480
// points := [ 5 , 3 , 2 ] ;
19461: LD_ADDR_VAR 0 9
19465: PUSH
19466: LD_INT 5
19468: PUSH
19469: LD_INT 3
19471: PUSH
19472: LD_INT 2
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: LIST
19479: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19480: LD_VAR 0 6
19484: PPUSH
19485: CALL_OW 257
19489: PUSH
19490: LD_INT 17
19492: EQUAL
19493: IFFALSE 19514
// points := [ 100 , 50 , 75 ] ;
19495: LD_ADDR_VAR 0 9
19499: PUSH
19500: LD_INT 100
19502: PUSH
19503: LD_INT 50
19505: PUSH
19506: LD_INT 75
19508: PUSH
19509: EMPTY
19510: LIST
19511: LIST
19512: LIST
19513: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19514: LD_VAR 0 6
19518: PPUSH
19519: CALL_OW 257
19523: PUSH
19524: LD_INT 15
19526: EQUAL
19527: IFFALSE 19548
// points := [ 10 , 5 , 3 ] ;
19529: LD_ADDR_VAR 0 9
19533: PUSH
19534: LD_INT 10
19536: PUSH
19537: LD_INT 5
19539: PUSH
19540: LD_INT 3
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: LIST
19547: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19548: LD_VAR 0 6
19552: PPUSH
19553: CALL_OW 257
19557: PUSH
19558: LD_INT 14
19560: EQUAL
19561: IFFALSE 19582
// points := [ 10 , 0 , 0 ] ;
19563: LD_ADDR_VAR 0 9
19567: PUSH
19568: LD_INT 10
19570: PUSH
19571: LD_INT 0
19573: PUSH
19574: LD_INT 0
19576: PUSH
19577: EMPTY
19578: LIST
19579: LIST
19580: LIST
19581: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19582: LD_VAR 0 6
19586: PPUSH
19587: CALL_OW 257
19591: PUSH
19592: LD_INT 11
19594: EQUAL
19595: IFFALSE 19616
// points := [ 30 , 10 , 5 ] ;
19597: LD_ADDR_VAR 0 9
19601: PUSH
19602: LD_INT 30
19604: PUSH
19605: LD_INT 10
19607: PUSH
19608: LD_INT 5
19610: PUSH
19611: EMPTY
19612: LIST
19613: LIST
19614: LIST
19615: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
19616: LD_VAR 0 1
19620: PPUSH
19621: LD_INT 5
19623: PPUSH
19624: CALL_OW 321
19628: PUSH
19629: LD_INT 2
19631: EQUAL
19632: IFFALSE 19649
// bpoints := bpoints * 1.8 ;
19634: LD_ADDR_VAR 0 10
19638: PUSH
19639: LD_VAR 0 10
19643: PUSH
19644: LD_REAL  1.80000000000000E+0000
19647: MUL
19648: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
19649: LD_VAR 0 6
19653: PPUSH
19654: CALL_OW 257
19658: PUSH
19659: LD_INT 1
19661: PUSH
19662: LD_INT 2
19664: PUSH
19665: LD_INT 3
19667: PUSH
19668: LD_INT 4
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: IN
19677: PUSH
19678: LD_VAR 0 1
19682: PPUSH
19683: LD_INT 51
19685: PPUSH
19686: CALL_OW 321
19690: PUSH
19691: LD_INT 2
19693: EQUAL
19694: AND
19695: IFFALSE 19712
// bpoints := bpoints * 1.2 ;
19697: LD_ADDR_VAR 0 10
19701: PUSH
19702: LD_VAR 0 10
19706: PUSH
19707: LD_REAL  1.20000000000000E+0000
19710: MUL
19711: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
19712: LD_VAR 0 6
19716: PPUSH
19717: CALL_OW 257
19721: PUSH
19722: LD_INT 5
19724: PUSH
19725: LD_INT 7
19727: PUSH
19728: LD_INT 9
19730: PUSH
19731: EMPTY
19732: LIST
19733: LIST
19734: LIST
19735: IN
19736: PUSH
19737: LD_VAR 0 1
19741: PPUSH
19742: LD_INT 52
19744: PPUSH
19745: CALL_OW 321
19749: PUSH
19750: LD_INT 2
19752: EQUAL
19753: AND
19754: IFFALSE 19771
// bpoints := bpoints * 1.5 ;
19756: LD_ADDR_VAR 0 10
19760: PUSH
19761: LD_VAR 0 10
19765: PUSH
19766: LD_REAL  1.50000000000000E+0000
19769: MUL
19770: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_INT 66
19778: PPUSH
19779: CALL_OW 321
19783: PUSH
19784: LD_INT 2
19786: EQUAL
19787: IFFALSE 19804
// bpoints := bpoints * 1.1 ;
19789: LD_ADDR_VAR 0 10
19793: PUSH
19794: LD_VAR 0 10
19798: PUSH
19799: LD_REAL  1.10000000000000E+0000
19802: MUL
19803: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
19804: LD_ADDR_VAR 0 10
19808: PUSH
19809: LD_VAR 0 10
19813: PUSH
19814: LD_VAR 0 6
19818: PPUSH
19819: LD_INT 1
19821: PPUSH
19822: CALL_OW 259
19826: PUSH
19827: LD_REAL  1.15000000000000E+0000
19830: MUL
19831: MUL
19832: ST_TO_ADDR
// end ; unit_vehicle :
19833: GO 20657
19835: LD_INT 2
19837: DOUBLE
19838: EQUAL
19839: IFTRUE 19843
19841: GO 20645
19843: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
19844: LD_VAR 0 6
19848: PPUSH
19849: CALL_OW 264
19853: PUSH
19854: LD_INT 2
19856: PUSH
19857: LD_INT 42
19859: PUSH
19860: LD_INT 24
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: IN
19868: IFFALSE 19889
// points := [ 25 , 5 , 3 ] ;
19870: LD_ADDR_VAR 0 9
19874: PUSH
19875: LD_INT 25
19877: PUSH
19878: LD_INT 5
19880: PUSH
19881: LD_INT 3
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: LIST
19888: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
19889: LD_VAR 0 6
19893: PPUSH
19894: CALL_OW 264
19898: PUSH
19899: LD_INT 4
19901: PUSH
19902: LD_INT 43
19904: PUSH
19905: LD_INT 25
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: LIST
19912: IN
19913: IFFALSE 19934
// points := [ 40 , 15 , 5 ] ;
19915: LD_ADDR_VAR 0 9
19919: PUSH
19920: LD_INT 40
19922: PUSH
19923: LD_INT 15
19925: PUSH
19926: LD_INT 5
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: LIST
19933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
19934: LD_VAR 0 6
19938: PPUSH
19939: CALL_OW 264
19943: PUSH
19944: LD_INT 3
19946: PUSH
19947: LD_INT 23
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: IN
19954: IFFALSE 19975
// points := [ 7 , 25 , 8 ] ;
19956: LD_ADDR_VAR 0 9
19960: PUSH
19961: LD_INT 7
19963: PUSH
19964: LD_INT 25
19966: PUSH
19967: LD_INT 8
19969: PUSH
19970: EMPTY
19971: LIST
19972: LIST
19973: LIST
19974: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
19975: LD_VAR 0 6
19979: PPUSH
19980: CALL_OW 264
19984: PUSH
19985: LD_INT 5
19987: PUSH
19988: LD_INT 27
19990: PUSH
19991: LD_INT 44
19993: PUSH
19994: EMPTY
19995: LIST
19996: LIST
19997: LIST
19998: IN
19999: IFFALSE 20020
// points := [ 14 , 50 , 16 ] ;
20001: LD_ADDR_VAR 0 9
20005: PUSH
20006: LD_INT 14
20008: PUSH
20009: LD_INT 50
20011: PUSH
20012: LD_INT 16
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: LIST
20019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20020: LD_VAR 0 6
20024: PPUSH
20025: CALL_OW 264
20029: PUSH
20030: LD_INT 6
20032: PUSH
20033: LD_INT 46
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: IN
20040: IFFALSE 20061
// points := [ 32 , 120 , 70 ] ;
20042: LD_ADDR_VAR 0 9
20046: PUSH
20047: LD_INT 32
20049: PUSH
20050: LD_INT 120
20052: PUSH
20053: LD_INT 70
20055: PUSH
20056: EMPTY
20057: LIST
20058: LIST
20059: LIST
20060: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20061: LD_VAR 0 6
20065: PPUSH
20066: CALL_OW 264
20070: PUSH
20071: LD_INT 7
20073: PUSH
20074: LD_INT 28
20076: PUSH
20077: LD_INT 45
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: LIST
20084: IN
20085: IFFALSE 20106
// points := [ 35 , 20 , 45 ] ;
20087: LD_ADDR_VAR 0 9
20091: PUSH
20092: LD_INT 35
20094: PUSH
20095: LD_INT 20
20097: PUSH
20098: LD_INT 45
20100: PUSH
20101: EMPTY
20102: LIST
20103: LIST
20104: LIST
20105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20106: LD_VAR 0 6
20110: PPUSH
20111: CALL_OW 264
20115: PUSH
20116: LD_INT 47
20118: PUSH
20119: EMPTY
20120: LIST
20121: IN
20122: IFFALSE 20143
// points := [ 67 , 45 , 75 ] ;
20124: LD_ADDR_VAR 0 9
20128: PUSH
20129: LD_INT 67
20131: PUSH
20132: LD_INT 45
20134: PUSH
20135: LD_INT 75
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: LIST
20142: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20143: LD_VAR 0 6
20147: PPUSH
20148: CALL_OW 264
20152: PUSH
20153: LD_INT 26
20155: PUSH
20156: EMPTY
20157: LIST
20158: IN
20159: IFFALSE 20180
// points := [ 120 , 30 , 80 ] ;
20161: LD_ADDR_VAR 0 9
20165: PUSH
20166: LD_INT 120
20168: PUSH
20169: LD_INT 30
20171: PUSH
20172: LD_INT 80
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: LIST
20179: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20180: LD_VAR 0 6
20184: PPUSH
20185: CALL_OW 264
20189: PUSH
20190: LD_INT 22
20192: PUSH
20193: EMPTY
20194: LIST
20195: IN
20196: IFFALSE 20217
// points := [ 40 , 1 , 1 ] ;
20198: LD_ADDR_VAR 0 9
20202: PUSH
20203: LD_INT 40
20205: PUSH
20206: LD_INT 1
20208: PUSH
20209: LD_INT 1
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: LIST
20216: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20217: LD_VAR 0 6
20221: PPUSH
20222: CALL_OW 264
20226: PUSH
20227: LD_INT 29
20229: PUSH
20230: EMPTY
20231: LIST
20232: IN
20233: IFFALSE 20254
// points := [ 70 , 200 , 400 ] ;
20235: LD_ADDR_VAR 0 9
20239: PUSH
20240: LD_INT 70
20242: PUSH
20243: LD_INT 200
20245: PUSH
20246: LD_INT 400
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: LIST
20253: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20254: LD_VAR 0 6
20258: PPUSH
20259: CALL_OW 264
20263: PUSH
20264: LD_INT 14
20266: PUSH
20267: LD_INT 53
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: IN
20274: IFFALSE 20295
// points := [ 40 , 10 , 20 ] ;
20276: LD_ADDR_VAR 0 9
20280: PUSH
20281: LD_INT 40
20283: PUSH
20284: LD_INT 10
20286: PUSH
20287: LD_INT 20
20289: PUSH
20290: EMPTY
20291: LIST
20292: LIST
20293: LIST
20294: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20295: LD_VAR 0 6
20299: PPUSH
20300: CALL_OW 264
20304: PUSH
20305: LD_INT 9
20307: PUSH
20308: EMPTY
20309: LIST
20310: IN
20311: IFFALSE 20332
// points := [ 5 , 70 , 20 ] ;
20313: LD_ADDR_VAR 0 9
20317: PUSH
20318: LD_INT 5
20320: PUSH
20321: LD_INT 70
20323: PUSH
20324: LD_INT 20
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20332: LD_VAR 0 6
20336: PPUSH
20337: CALL_OW 264
20341: PUSH
20342: LD_INT 10
20344: PUSH
20345: EMPTY
20346: LIST
20347: IN
20348: IFFALSE 20369
// points := [ 35 , 110 , 70 ] ;
20350: LD_ADDR_VAR 0 9
20354: PUSH
20355: LD_INT 35
20357: PUSH
20358: LD_INT 110
20360: PUSH
20361: LD_INT 70
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: LIST
20368: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20369: LD_VAR 0 6
20373: PPUSH
20374: CALL_OW 265
20378: PUSH
20379: LD_INT 25
20381: EQUAL
20382: IFFALSE 20403
// points := [ 80 , 65 , 100 ] ;
20384: LD_ADDR_VAR 0 9
20388: PUSH
20389: LD_INT 80
20391: PUSH
20392: LD_INT 65
20394: PUSH
20395: LD_INT 100
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20403: LD_VAR 0 6
20407: PPUSH
20408: CALL_OW 263
20412: PUSH
20413: LD_INT 1
20415: EQUAL
20416: IFFALSE 20451
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20418: LD_ADDR_VAR 0 10
20422: PUSH
20423: LD_VAR 0 10
20427: PUSH
20428: LD_VAR 0 6
20432: PPUSH
20433: CALL_OW 311
20437: PPUSH
20438: LD_INT 3
20440: PPUSH
20441: CALL_OW 259
20445: PUSH
20446: LD_INT 4
20448: MUL
20449: MUL
20450: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20451: LD_VAR 0 6
20455: PPUSH
20456: CALL_OW 263
20460: PUSH
20461: LD_INT 2
20463: EQUAL
20464: IFFALSE 20515
// begin j := IsControledBy ( i ) ;
20466: LD_ADDR_VAR 0 7
20470: PUSH
20471: LD_VAR 0 6
20475: PPUSH
20476: CALL_OW 312
20480: ST_TO_ADDR
// if j then
20481: LD_VAR 0 7
20485: IFFALSE 20515
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20487: LD_ADDR_VAR 0 10
20491: PUSH
20492: LD_VAR 0 10
20496: PUSH
20497: LD_VAR 0 7
20501: PPUSH
20502: LD_INT 3
20504: PPUSH
20505: CALL_OW 259
20509: PUSH
20510: LD_INT 3
20512: MUL
20513: MUL
20514: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20515: LD_VAR 0 6
20519: PPUSH
20520: CALL_OW 264
20524: PUSH
20525: LD_INT 5
20527: PUSH
20528: LD_INT 6
20530: PUSH
20531: LD_INT 46
20533: PUSH
20534: LD_INT 44
20536: PUSH
20537: LD_INT 47
20539: PUSH
20540: LD_INT 45
20542: PUSH
20543: LD_INT 28
20545: PUSH
20546: LD_INT 7
20548: PUSH
20549: LD_INT 27
20551: PUSH
20552: LD_INT 29
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: IN
20567: PUSH
20568: LD_VAR 0 1
20572: PPUSH
20573: LD_INT 52
20575: PPUSH
20576: CALL_OW 321
20580: PUSH
20581: LD_INT 2
20583: EQUAL
20584: AND
20585: IFFALSE 20602
// bpoints := bpoints * 1.2 ;
20587: LD_ADDR_VAR 0 10
20591: PUSH
20592: LD_VAR 0 10
20596: PUSH
20597: LD_REAL  1.20000000000000E+0000
20600: MUL
20601: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
20602: LD_VAR 0 6
20606: PPUSH
20607: CALL_OW 264
20611: PUSH
20612: LD_INT 6
20614: PUSH
20615: LD_INT 46
20617: PUSH
20618: LD_INT 47
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: LIST
20625: IN
20626: IFFALSE 20643
// bpoints := bpoints * 1.2 ;
20628: LD_ADDR_VAR 0 10
20632: PUSH
20633: LD_VAR 0 10
20637: PUSH
20638: LD_REAL  1.20000000000000E+0000
20641: MUL
20642: ST_TO_ADDR
// end ; unit_building :
20643: GO 20657
20645: LD_INT 3
20647: DOUBLE
20648: EQUAL
20649: IFTRUE 20653
20651: GO 20656
20653: POP
// ; end ;
20654: GO 20657
20656: POP
// for j = 1 to 3 do
20657: LD_ADDR_VAR 0 7
20661: PUSH
20662: DOUBLE
20663: LD_INT 1
20665: DEC
20666: ST_TO_ADDR
20667: LD_INT 3
20669: PUSH
20670: FOR_TO
20671: IFFALSE 20724
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
20673: LD_ADDR_VAR 0 5
20677: PUSH
20678: LD_VAR 0 5
20682: PPUSH
20683: LD_VAR 0 7
20687: PPUSH
20688: LD_VAR 0 5
20692: PUSH
20693: LD_VAR 0 7
20697: ARRAY
20698: PUSH
20699: LD_VAR 0 9
20703: PUSH
20704: LD_VAR 0 7
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 10
20714: MUL
20715: PLUS
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
20722: GO 20670
20724: POP
20725: POP
// end ;
20726: GO 19209
20728: POP
20729: POP
// result := Replace ( result , 4 , tmp ) ;
20730: LD_ADDR_VAR 0 5
20734: PUSH
20735: LD_VAR 0 5
20739: PPUSH
20740: LD_INT 4
20742: PPUSH
20743: LD_VAR 0 8
20747: PPUSH
20748: CALL_OW 1
20752: ST_TO_ADDR
// end ;
20753: LD_VAR 0 5
20757: RET
// export function DangerAtRange ( unit , range ) ; begin
20758: LD_INT 0
20760: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
20761: LD_ADDR_VAR 0 3
20765: PUSH
20766: LD_VAR 0 1
20770: PPUSH
20771: CALL_OW 255
20775: PPUSH
20776: LD_VAR 0 1
20780: PPUSH
20781: CALL_OW 250
20785: PPUSH
20786: LD_VAR 0 1
20790: PPUSH
20791: CALL_OW 251
20795: PPUSH
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL 19061 0 4
20805: ST_TO_ADDR
// end ;
20806: LD_VAR 0 3
20810: RET
// export function DangerInArea ( side , area ) ; begin
20811: LD_INT 0
20813: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
20814: LD_ADDR_VAR 0 3
20818: PUSH
20819: LD_VAR 0 2
20823: PPUSH
20824: LD_INT 81
20826: PUSH
20827: LD_VAR 0 1
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PPUSH
20836: CALL_OW 70
20840: ST_TO_ADDR
// end ;
20841: LD_VAR 0 3
20845: RET
// export function IsExtension ( b ) ; begin
20846: LD_INT 0
20848: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
20849: LD_ADDR_VAR 0 2
20853: PUSH
20854: LD_VAR 0 1
20858: PUSH
20859: LD_INT 23
20861: PUSH
20862: LD_INT 20
20864: PUSH
20865: LD_INT 22
20867: PUSH
20868: LD_INT 17
20870: PUSH
20871: LD_INT 24
20873: PUSH
20874: LD_INT 21
20876: PUSH
20877: LD_INT 19
20879: PUSH
20880: LD_INT 16
20882: PUSH
20883: LD_INT 25
20885: PUSH
20886: LD_INT 18
20888: PUSH
20889: EMPTY
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: LIST
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: LIST
20900: IN
20901: ST_TO_ADDR
// end ;
20902: LD_VAR 0 2
20906: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
20907: LD_INT 0
20909: PPUSH
20910: PPUSH
20911: PPUSH
// result := [ ] ;
20912: LD_ADDR_VAR 0 3
20916: PUSH
20917: EMPTY
20918: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
20919: LD_ADDR_VAR 0 4
20923: PUSH
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 21
20931: PUSH
20932: LD_INT 3
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: PPUSH
20939: CALL_OW 70
20943: ST_TO_ADDR
// if not tmp then
20944: LD_VAR 0 4
20948: NOT
20949: IFFALSE 20953
// exit ;
20951: GO 21011
// for i in tmp do
20953: LD_ADDR_VAR 0 5
20957: PUSH
20958: LD_VAR 0 4
20962: PUSH
20963: FOR_IN
20964: IFFALSE 20999
// if GetBase ( i ) <> base then
20966: LD_VAR 0 5
20970: PPUSH
20971: CALL_OW 274
20975: PUSH
20976: LD_VAR 0 1
20980: NONEQUAL
20981: IFFALSE 20997
// ComLinkToBase ( base , i ) ;
20983: LD_VAR 0 1
20987: PPUSH
20988: LD_VAR 0 5
20992: PPUSH
20993: CALL_OW 169
20997: GO 20963
20999: POP
21000: POP
// result := tmp ;
21001: LD_ADDR_VAR 0 3
21005: PUSH
21006: LD_VAR 0 4
21010: ST_TO_ADDR
// end ;
21011: LD_VAR 0 3
21015: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21016: LD_INT 0
21018: PPUSH
21019: PPUSH
// if BuildingStatus ( b ) = bs_build then
21020: LD_VAR 0 2
21024: PPUSH
21025: CALL_OW 461
21029: PUSH
21030: LD_INT 1
21032: EQUAL
21033: IFFALSE 21093
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21035: LD_VAR 0 1
21039: PPUSH
21040: LD_STRING h
21042: PUSH
21043: LD_VAR 0 2
21047: PPUSH
21048: CALL_OW 250
21052: PUSH
21053: LD_VAR 0 2
21057: PPUSH
21058: CALL_OW 251
21062: PUSH
21063: LD_VAR 0 2
21067: PUSH
21068: LD_INT 0
21070: PUSH
21071: LD_INT 0
21073: PUSH
21074: LD_INT 0
21076: PUSH
21077: EMPTY
21078: LIST
21079: LIST
21080: LIST
21081: LIST
21082: LIST
21083: LIST
21084: LIST
21085: PUSH
21086: EMPTY
21087: LIST
21088: PPUSH
21089: CALL_OW 446
// end ;
21093: LD_VAR 0 3
21097: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21098: LD_INT 0
21100: PPUSH
21101: PPUSH
21102: PPUSH
21103: PPUSH
21104: PPUSH
21105: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21106: LD_VAR 0 1
21110: NOT
21111: PUSH
21112: LD_VAR 0 1
21116: PPUSH
21117: CALL_OW 263
21121: PUSH
21122: LD_INT 2
21124: EQUAL
21125: NOT
21126: OR
21127: IFFALSE 21131
// exit ;
21129: GO 21447
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21131: LD_ADDR_VAR 0 6
21135: PUSH
21136: LD_INT 22
21138: PUSH
21139: LD_VAR 0 1
21143: PPUSH
21144: CALL_OW 255
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: PUSH
21153: LD_INT 2
21155: PUSH
21156: LD_INT 30
21158: PUSH
21159: LD_INT 36
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: PUSH
21166: LD_INT 34
21168: PUSH
21169: LD_INT 31
21171: PUSH
21172: EMPTY
21173: LIST
21174: LIST
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: LIST
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: PPUSH
21185: CALL_OW 69
21189: ST_TO_ADDR
// if not tmp then
21190: LD_VAR 0 6
21194: NOT
21195: IFFALSE 21199
// exit ;
21197: GO 21447
// result := [ ] ;
21199: LD_ADDR_VAR 0 2
21203: PUSH
21204: EMPTY
21205: ST_TO_ADDR
// for i in tmp do
21206: LD_ADDR_VAR 0 3
21210: PUSH
21211: LD_VAR 0 6
21215: PUSH
21216: FOR_IN
21217: IFFALSE 21288
// begin t := UnitsInside ( i ) ;
21219: LD_ADDR_VAR 0 4
21223: PUSH
21224: LD_VAR 0 3
21228: PPUSH
21229: CALL_OW 313
21233: ST_TO_ADDR
// if t then
21234: LD_VAR 0 4
21238: IFFALSE 21286
// for j in t do
21240: LD_ADDR_VAR 0 7
21244: PUSH
21245: LD_VAR 0 4
21249: PUSH
21250: FOR_IN
21251: IFFALSE 21284
// result := Insert ( result , result + 1 , j ) ;
21253: LD_ADDR_VAR 0 2
21257: PUSH
21258: LD_VAR 0 2
21262: PPUSH
21263: LD_VAR 0 2
21267: PUSH
21268: LD_INT 1
21270: PLUS
21271: PPUSH
21272: LD_VAR 0 7
21276: PPUSH
21277: CALL_OW 2
21281: ST_TO_ADDR
21282: GO 21250
21284: POP
21285: POP
// end ;
21286: GO 21216
21288: POP
21289: POP
// if not result then
21290: LD_VAR 0 2
21294: NOT
21295: IFFALSE 21299
// exit ;
21297: GO 21447
// mech := result [ 1 ] ;
21299: LD_ADDR_VAR 0 5
21303: PUSH
21304: LD_VAR 0 2
21308: PUSH
21309: LD_INT 1
21311: ARRAY
21312: ST_TO_ADDR
// if result > 1 then
21313: LD_VAR 0 2
21317: PUSH
21318: LD_INT 1
21320: GREATER
21321: IFFALSE 21433
// for i = 2 to result do
21323: LD_ADDR_VAR 0 3
21327: PUSH
21328: DOUBLE
21329: LD_INT 2
21331: DEC
21332: ST_TO_ADDR
21333: LD_VAR 0 2
21337: PUSH
21338: FOR_TO
21339: IFFALSE 21431
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21341: LD_ADDR_VAR 0 4
21345: PUSH
21346: LD_VAR 0 2
21350: PUSH
21351: LD_VAR 0 3
21355: ARRAY
21356: PPUSH
21357: LD_INT 3
21359: PPUSH
21360: CALL_OW 259
21364: PUSH
21365: LD_VAR 0 2
21369: PUSH
21370: LD_VAR 0 3
21374: ARRAY
21375: PPUSH
21376: CALL_OW 432
21380: MINUS
21381: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21382: LD_VAR 0 4
21386: PUSH
21387: LD_VAR 0 5
21391: PPUSH
21392: LD_INT 3
21394: PPUSH
21395: CALL_OW 259
21399: PUSH
21400: LD_VAR 0 5
21404: PPUSH
21405: CALL_OW 432
21409: MINUS
21410: GREATEREQUAL
21411: IFFALSE 21429
// mech := result [ i ] ;
21413: LD_ADDR_VAR 0 5
21417: PUSH
21418: LD_VAR 0 2
21422: PUSH
21423: LD_VAR 0 3
21427: ARRAY
21428: ST_TO_ADDR
// end ;
21429: GO 21338
21431: POP
21432: POP
// ComLinkTo ( vehicle , mech ) ;
21433: LD_VAR 0 1
21437: PPUSH
21438: LD_VAR 0 5
21442: PPUSH
21443: CALL_OW 135
// end ;
21447: LD_VAR 0 2
21451: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21452: LD_INT 0
21454: PPUSH
21455: PPUSH
21456: PPUSH
21457: PPUSH
21458: PPUSH
21459: PPUSH
21460: PPUSH
21461: PPUSH
21462: PPUSH
21463: PPUSH
21464: PPUSH
21465: PPUSH
21466: PPUSH
// result := [ ] ;
21467: LD_ADDR_VAR 0 7
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21474: LD_VAR 0 1
21478: PPUSH
21479: CALL_OW 266
21483: PUSH
21484: LD_INT 0
21486: PUSH
21487: LD_INT 1
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: IN
21494: NOT
21495: IFFALSE 21499
// exit ;
21497: GO 23130
// if name then
21499: LD_VAR 0 3
21503: IFFALSE 21519
// SetBName ( base_dep , name ) ;
21505: LD_VAR 0 1
21509: PPUSH
21510: LD_VAR 0 3
21514: PPUSH
21515: CALL_OW 500
// base := GetBase ( base_dep ) ;
21519: LD_ADDR_VAR 0 15
21523: PUSH
21524: LD_VAR 0 1
21528: PPUSH
21529: CALL_OW 274
21533: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21534: LD_ADDR_VAR 0 16
21538: PUSH
21539: LD_VAR 0 1
21543: PPUSH
21544: CALL_OW 255
21548: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21549: LD_ADDR_VAR 0 17
21553: PUSH
21554: LD_VAR 0 1
21558: PPUSH
21559: CALL_OW 248
21563: ST_TO_ADDR
// if sources then
21564: LD_VAR 0 5
21568: IFFALSE 21615
// for i = 1 to 3 do
21570: LD_ADDR_VAR 0 8
21574: PUSH
21575: DOUBLE
21576: LD_INT 1
21578: DEC
21579: ST_TO_ADDR
21580: LD_INT 3
21582: PUSH
21583: FOR_TO
21584: IFFALSE 21613
// AddResourceType ( base , i , sources [ i ] ) ;
21586: LD_VAR 0 15
21590: PPUSH
21591: LD_VAR 0 8
21595: PPUSH
21596: LD_VAR 0 5
21600: PUSH
21601: LD_VAR 0 8
21605: ARRAY
21606: PPUSH
21607: CALL_OW 276
21611: GO 21583
21613: POP
21614: POP
// buildings := GetBaseBuildings ( base , area ) ;
21615: LD_ADDR_VAR 0 18
21619: PUSH
21620: LD_VAR 0 15
21624: PPUSH
21625: LD_VAR 0 2
21629: PPUSH
21630: CALL 20907 0 2
21634: ST_TO_ADDR
// InitHc ;
21635: CALL_OW 19
// InitUc ;
21639: CALL_OW 18
// uc_side := side ;
21643: LD_ADDR_OWVAR 20
21647: PUSH
21648: LD_VAR 0 16
21652: ST_TO_ADDR
// uc_nation := nation ;
21653: LD_ADDR_OWVAR 21
21657: PUSH
21658: LD_VAR 0 17
21662: ST_TO_ADDR
// if buildings then
21663: LD_VAR 0 18
21667: IFFALSE 22989
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
21669: LD_ADDR_VAR 0 19
21673: PUSH
21674: LD_VAR 0 18
21678: PPUSH
21679: LD_INT 2
21681: PUSH
21682: LD_INT 30
21684: PUSH
21685: LD_INT 29
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 30
21694: PUSH
21695: LD_INT 30
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: PUSH
21702: EMPTY
21703: LIST
21704: LIST
21705: LIST
21706: PPUSH
21707: CALL_OW 72
21711: ST_TO_ADDR
// if tmp then
21712: LD_VAR 0 19
21716: IFFALSE 21764
// for i in tmp do
21718: LD_ADDR_VAR 0 8
21722: PUSH
21723: LD_VAR 0 19
21727: PUSH
21728: FOR_IN
21729: IFFALSE 21762
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
21731: LD_VAR 0 8
21735: PPUSH
21736: CALL_OW 250
21740: PPUSH
21741: LD_VAR 0 8
21745: PPUSH
21746: CALL_OW 251
21750: PPUSH
21751: LD_VAR 0 16
21755: PPUSH
21756: CALL_OW 441
21760: GO 21728
21762: POP
21763: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
21764: LD_VAR 0 18
21768: PPUSH
21769: LD_INT 2
21771: PUSH
21772: LD_INT 30
21774: PUSH
21775: LD_INT 32
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: LD_INT 33
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: PPUSH
21797: CALL_OW 72
21801: IFFALSE 21889
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
21803: LD_ADDR_VAR 0 8
21807: PUSH
21808: LD_VAR 0 18
21812: PPUSH
21813: LD_INT 2
21815: PUSH
21816: LD_INT 30
21818: PUSH
21819: LD_INT 32
21821: PUSH
21822: EMPTY
21823: LIST
21824: LIST
21825: PUSH
21826: LD_INT 30
21828: PUSH
21829: LD_INT 33
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: LIST
21840: PPUSH
21841: CALL_OW 72
21845: PUSH
21846: FOR_IN
21847: IFFALSE 21887
// begin if not GetBWeapon ( i ) then
21849: LD_VAR 0 8
21853: PPUSH
21854: CALL_OW 269
21858: NOT
21859: IFFALSE 21885
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
21861: LD_VAR 0 8
21865: PPUSH
21866: LD_VAR 0 8
21870: PPUSH
21871: LD_VAR 0 2
21875: PPUSH
21876: CALL 23135 0 2
21880: PPUSH
21881: CALL_OW 431
// end ;
21885: GO 21846
21887: POP
21888: POP
// end ; for i = 1 to personel do
21889: LD_ADDR_VAR 0 8
21893: PUSH
21894: DOUBLE
21895: LD_INT 1
21897: DEC
21898: ST_TO_ADDR
21899: LD_VAR 0 6
21903: PUSH
21904: FOR_TO
21905: IFFALSE 22969
// begin if i > 4 then
21907: LD_VAR 0 8
21911: PUSH
21912: LD_INT 4
21914: GREATER
21915: IFFALSE 21919
// break ;
21917: GO 22969
// case i of 1 :
21919: LD_VAR 0 8
21923: PUSH
21924: LD_INT 1
21926: DOUBLE
21927: EQUAL
21928: IFTRUE 21932
21930: GO 22012
21932: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
21933: LD_ADDR_VAR 0 12
21937: PUSH
21938: LD_VAR 0 18
21942: PPUSH
21943: LD_INT 22
21945: PUSH
21946: LD_VAR 0 16
21950: PUSH
21951: EMPTY
21952: LIST
21953: LIST
21954: PUSH
21955: LD_INT 58
21957: PUSH
21958: EMPTY
21959: LIST
21960: PUSH
21961: LD_INT 2
21963: PUSH
21964: LD_INT 30
21966: PUSH
21967: LD_INT 32
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: LD_INT 30
21976: PUSH
21977: LD_INT 4
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: PUSH
21984: LD_INT 30
21986: PUSH
21987: LD_INT 5
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: PUSH
21994: EMPTY
21995: LIST
21996: LIST
21997: LIST
21998: LIST
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: PPUSH
22005: CALL_OW 72
22009: ST_TO_ADDR
22010: GO 22234
22012: LD_INT 2
22014: DOUBLE
22015: EQUAL
22016: IFTRUE 22020
22018: GO 22082
22020: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22021: LD_ADDR_VAR 0 12
22025: PUSH
22026: LD_VAR 0 18
22030: PPUSH
22031: LD_INT 22
22033: PUSH
22034: LD_VAR 0 16
22038: PUSH
22039: EMPTY
22040: LIST
22041: LIST
22042: PUSH
22043: LD_INT 2
22045: PUSH
22046: LD_INT 30
22048: PUSH
22049: LD_INT 0
22051: PUSH
22052: EMPTY
22053: LIST
22054: LIST
22055: PUSH
22056: LD_INT 30
22058: PUSH
22059: LD_INT 1
22061: PUSH
22062: EMPTY
22063: LIST
22064: LIST
22065: PUSH
22066: EMPTY
22067: LIST
22068: LIST
22069: LIST
22070: PUSH
22071: EMPTY
22072: LIST
22073: LIST
22074: PPUSH
22075: CALL_OW 72
22079: ST_TO_ADDR
22080: GO 22234
22082: LD_INT 3
22084: DOUBLE
22085: EQUAL
22086: IFTRUE 22090
22088: GO 22152
22090: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22091: LD_ADDR_VAR 0 12
22095: PUSH
22096: LD_VAR 0 18
22100: PPUSH
22101: LD_INT 22
22103: PUSH
22104: LD_VAR 0 16
22108: PUSH
22109: EMPTY
22110: LIST
22111: LIST
22112: PUSH
22113: LD_INT 2
22115: PUSH
22116: LD_INT 30
22118: PUSH
22119: LD_INT 2
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: LD_INT 30
22128: PUSH
22129: LD_INT 3
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: EMPTY
22137: LIST
22138: LIST
22139: LIST
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: PPUSH
22145: CALL_OW 72
22149: ST_TO_ADDR
22150: GO 22234
22152: LD_INT 4
22154: DOUBLE
22155: EQUAL
22156: IFTRUE 22160
22158: GO 22233
22160: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22161: LD_ADDR_VAR 0 12
22165: PUSH
22166: LD_VAR 0 18
22170: PPUSH
22171: LD_INT 22
22173: PUSH
22174: LD_VAR 0 16
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 2
22185: PUSH
22186: LD_INT 30
22188: PUSH
22189: LD_INT 6
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: LD_INT 30
22198: PUSH
22199: LD_INT 7
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: LD_INT 30
22208: PUSH
22209: LD_INT 8
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PUSH
22216: EMPTY
22217: LIST
22218: LIST
22219: LIST
22220: LIST
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PPUSH
22226: CALL_OW 72
22230: ST_TO_ADDR
22231: GO 22234
22233: POP
// if i = 1 then
22234: LD_VAR 0 8
22238: PUSH
22239: LD_INT 1
22241: EQUAL
22242: IFFALSE 22353
// begin tmp := [ ] ;
22244: LD_ADDR_VAR 0 19
22248: PUSH
22249: EMPTY
22250: ST_TO_ADDR
// for j in f do
22251: LD_ADDR_VAR 0 9
22255: PUSH
22256: LD_VAR 0 12
22260: PUSH
22261: FOR_IN
22262: IFFALSE 22335
// if GetBType ( j ) = b_bunker then
22264: LD_VAR 0 9
22268: PPUSH
22269: CALL_OW 266
22273: PUSH
22274: LD_INT 32
22276: EQUAL
22277: IFFALSE 22304
// tmp := Insert ( tmp , 1 , j ) else
22279: LD_ADDR_VAR 0 19
22283: PUSH
22284: LD_VAR 0 19
22288: PPUSH
22289: LD_INT 1
22291: PPUSH
22292: LD_VAR 0 9
22296: PPUSH
22297: CALL_OW 2
22301: ST_TO_ADDR
22302: GO 22333
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22304: LD_ADDR_VAR 0 19
22308: PUSH
22309: LD_VAR 0 19
22313: PPUSH
22314: LD_VAR 0 19
22318: PUSH
22319: LD_INT 1
22321: PLUS
22322: PPUSH
22323: LD_VAR 0 9
22327: PPUSH
22328: CALL_OW 2
22332: ST_TO_ADDR
22333: GO 22261
22335: POP
22336: POP
// if tmp then
22337: LD_VAR 0 19
22341: IFFALSE 22353
// f := tmp ;
22343: LD_ADDR_VAR 0 12
22347: PUSH
22348: LD_VAR 0 19
22352: ST_TO_ADDR
// end ; x := personel [ i ] ;
22353: LD_ADDR_VAR 0 13
22357: PUSH
22358: LD_VAR 0 6
22362: PUSH
22363: LD_VAR 0 8
22367: ARRAY
22368: ST_TO_ADDR
// if x = - 1 then
22369: LD_VAR 0 13
22373: PUSH
22374: LD_INT 1
22376: NEG
22377: EQUAL
22378: IFFALSE 22587
// begin for j in f do
22380: LD_ADDR_VAR 0 9
22384: PUSH
22385: LD_VAR 0 12
22389: PUSH
22390: FOR_IN
22391: IFFALSE 22583
// repeat InitHc ;
22393: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22397: LD_VAR 0 9
22401: PPUSH
22402: CALL_OW 266
22406: PUSH
22407: LD_INT 5
22409: EQUAL
22410: IFFALSE 22480
// begin if UnitsInside ( j ) < 3 then
22412: LD_VAR 0 9
22416: PPUSH
22417: CALL_OW 313
22421: PUSH
22422: LD_INT 3
22424: LESS
22425: IFFALSE 22461
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22427: LD_INT 0
22429: PPUSH
22430: LD_INT 5
22432: PUSH
22433: LD_INT 8
22435: PUSH
22436: LD_INT 9
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: LIST
22443: PUSH
22444: LD_VAR 0 17
22448: ARRAY
22449: PPUSH
22450: LD_VAR 0 4
22454: PPUSH
22455: CALL_OW 380
22459: GO 22478
// PrepareHuman ( false , i , skill ) ;
22461: LD_INT 0
22463: PPUSH
22464: LD_VAR 0 8
22468: PPUSH
22469: LD_VAR 0 4
22473: PPUSH
22474: CALL_OW 380
// end else
22478: GO 22497
// PrepareHuman ( false , i , skill ) ;
22480: LD_INT 0
22482: PPUSH
22483: LD_VAR 0 8
22487: PPUSH
22488: LD_VAR 0 4
22492: PPUSH
22493: CALL_OW 380
// un := CreateHuman ;
22497: LD_ADDR_VAR 0 14
22501: PUSH
22502: CALL_OW 44
22506: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22507: LD_ADDR_VAR 0 7
22511: PUSH
22512: LD_VAR 0 7
22516: PPUSH
22517: LD_INT 1
22519: PPUSH
22520: LD_VAR 0 14
22524: PPUSH
22525: CALL_OW 2
22529: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22530: LD_VAR 0 14
22534: PPUSH
22535: LD_VAR 0 9
22539: PPUSH
22540: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22544: LD_VAR 0 9
22548: PPUSH
22549: CALL_OW 313
22553: PUSH
22554: LD_INT 6
22556: EQUAL
22557: PUSH
22558: LD_VAR 0 9
22562: PPUSH
22563: CALL_OW 266
22567: PUSH
22568: LD_INT 32
22570: PUSH
22571: LD_INT 31
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: IN
22578: OR
22579: IFFALSE 22393
22581: GO 22390
22583: POP
22584: POP
// end else
22585: GO 22967
// for j = 1 to x do
22587: LD_ADDR_VAR 0 9
22591: PUSH
22592: DOUBLE
22593: LD_INT 1
22595: DEC
22596: ST_TO_ADDR
22597: LD_VAR 0 13
22601: PUSH
22602: FOR_TO
22603: IFFALSE 22965
// begin InitHc ;
22605: CALL_OW 19
// if not f then
22609: LD_VAR 0 12
22613: NOT
22614: IFFALSE 22703
// begin PrepareHuman ( false , i , skill ) ;
22616: LD_INT 0
22618: PPUSH
22619: LD_VAR 0 8
22623: PPUSH
22624: LD_VAR 0 4
22628: PPUSH
22629: CALL_OW 380
// un := CreateHuman ;
22633: LD_ADDR_VAR 0 14
22637: PUSH
22638: CALL_OW 44
22642: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22643: LD_ADDR_VAR 0 7
22647: PUSH
22648: LD_VAR 0 7
22652: PPUSH
22653: LD_INT 1
22655: PPUSH
22656: LD_VAR 0 14
22660: PPUSH
22661: CALL_OW 2
22665: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
22666: LD_VAR 0 14
22670: PPUSH
22671: LD_VAR 0 1
22675: PPUSH
22676: CALL_OW 250
22680: PPUSH
22681: LD_VAR 0 1
22685: PPUSH
22686: CALL_OW 251
22690: PPUSH
22691: LD_INT 10
22693: PPUSH
22694: LD_INT 0
22696: PPUSH
22697: CALL_OW 50
// continue ;
22701: GO 22602
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
22703: LD_VAR 0 12
22707: PUSH
22708: LD_INT 1
22710: ARRAY
22711: PPUSH
22712: CALL_OW 313
22716: PUSH
22717: LD_VAR 0 12
22721: PUSH
22722: LD_INT 1
22724: ARRAY
22725: PPUSH
22726: CALL_OW 266
22730: PUSH
22731: LD_INT 32
22733: PUSH
22734: LD_INT 31
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: IN
22741: AND
22742: PUSH
22743: LD_VAR 0 12
22747: PUSH
22748: LD_INT 1
22750: ARRAY
22751: PPUSH
22752: CALL_OW 313
22756: PUSH
22757: LD_INT 6
22759: EQUAL
22760: OR
22761: IFFALSE 22781
// f := Delete ( f , 1 ) ;
22763: LD_ADDR_VAR 0 12
22767: PUSH
22768: LD_VAR 0 12
22772: PPUSH
22773: LD_INT 1
22775: PPUSH
22776: CALL_OW 3
22780: ST_TO_ADDR
// if not f then
22781: LD_VAR 0 12
22785: NOT
22786: IFFALSE 22804
// begin x := x + 2 ;
22788: LD_ADDR_VAR 0 13
22792: PUSH
22793: LD_VAR 0 13
22797: PUSH
22798: LD_INT 2
22800: PLUS
22801: ST_TO_ADDR
// continue ;
22802: GO 22602
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
22804: LD_VAR 0 12
22808: PUSH
22809: LD_INT 1
22811: ARRAY
22812: PPUSH
22813: CALL_OW 266
22817: PUSH
22818: LD_INT 5
22820: EQUAL
22821: IFFALSE 22895
// begin if UnitsInside ( f [ 1 ] ) < 3 then
22823: LD_VAR 0 12
22827: PUSH
22828: LD_INT 1
22830: ARRAY
22831: PPUSH
22832: CALL_OW 313
22836: PUSH
22837: LD_INT 3
22839: LESS
22840: IFFALSE 22876
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22842: LD_INT 0
22844: PPUSH
22845: LD_INT 5
22847: PUSH
22848: LD_INT 8
22850: PUSH
22851: LD_INT 9
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: LIST
22858: PUSH
22859: LD_VAR 0 17
22863: ARRAY
22864: PPUSH
22865: LD_VAR 0 4
22869: PPUSH
22870: CALL_OW 380
22874: GO 22893
// PrepareHuman ( false , i , skill ) ;
22876: LD_INT 0
22878: PPUSH
22879: LD_VAR 0 8
22883: PPUSH
22884: LD_VAR 0 4
22888: PPUSH
22889: CALL_OW 380
// end else
22893: GO 22912
// PrepareHuman ( false , i , skill ) ;
22895: LD_INT 0
22897: PPUSH
22898: LD_VAR 0 8
22902: PPUSH
22903: LD_VAR 0 4
22907: PPUSH
22908: CALL_OW 380
// un := CreateHuman ;
22912: LD_ADDR_VAR 0 14
22916: PUSH
22917: CALL_OW 44
22921: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22922: LD_ADDR_VAR 0 7
22926: PUSH
22927: LD_VAR 0 7
22931: PPUSH
22932: LD_INT 1
22934: PPUSH
22935: LD_VAR 0 14
22939: PPUSH
22940: CALL_OW 2
22944: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
22945: LD_VAR 0 14
22949: PPUSH
22950: LD_VAR 0 12
22954: PUSH
22955: LD_INT 1
22957: ARRAY
22958: PPUSH
22959: CALL_OW 52
// end ;
22963: GO 22602
22965: POP
22966: POP
// end ;
22967: GO 21904
22969: POP
22970: POP
// result := result ^ buildings ;
22971: LD_ADDR_VAR 0 7
22975: PUSH
22976: LD_VAR 0 7
22980: PUSH
22981: LD_VAR 0 18
22985: ADD
22986: ST_TO_ADDR
// end else
22987: GO 23130
// begin for i = 1 to personel do
22989: LD_ADDR_VAR 0 8
22993: PUSH
22994: DOUBLE
22995: LD_INT 1
22997: DEC
22998: ST_TO_ADDR
22999: LD_VAR 0 6
23003: PUSH
23004: FOR_TO
23005: IFFALSE 23128
// begin if i > 4 then
23007: LD_VAR 0 8
23011: PUSH
23012: LD_INT 4
23014: GREATER
23015: IFFALSE 23019
// break ;
23017: GO 23128
// x := personel [ i ] ;
23019: LD_ADDR_VAR 0 13
23023: PUSH
23024: LD_VAR 0 6
23028: PUSH
23029: LD_VAR 0 8
23033: ARRAY
23034: ST_TO_ADDR
// if x = - 1 then
23035: LD_VAR 0 13
23039: PUSH
23040: LD_INT 1
23042: NEG
23043: EQUAL
23044: IFFALSE 23048
// continue ;
23046: GO 23004
// PrepareHuman ( false , i , skill ) ;
23048: LD_INT 0
23050: PPUSH
23051: LD_VAR 0 8
23055: PPUSH
23056: LD_VAR 0 4
23060: PPUSH
23061: CALL_OW 380
// un := CreateHuman ;
23065: LD_ADDR_VAR 0 14
23069: PUSH
23070: CALL_OW 44
23074: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23075: LD_VAR 0 14
23079: PPUSH
23080: LD_VAR 0 1
23084: PPUSH
23085: CALL_OW 250
23089: PPUSH
23090: LD_VAR 0 1
23094: PPUSH
23095: CALL_OW 251
23099: PPUSH
23100: LD_INT 10
23102: PPUSH
23103: LD_INT 0
23105: PPUSH
23106: CALL_OW 50
// result := result ^ un ;
23110: LD_ADDR_VAR 0 7
23114: PUSH
23115: LD_VAR 0 7
23119: PUSH
23120: LD_VAR 0 14
23124: ADD
23125: ST_TO_ADDR
// end ;
23126: GO 23004
23128: POP
23129: POP
// end ; end ;
23130: LD_VAR 0 7
23134: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23135: LD_INT 0
23137: PPUSH
23138: PPUSH
23139: PPUSH
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
23144: PPUSH
23145: PPUSH
23146: PPUSH
23147: PPUSH
23148: PPUSH
23149: PPUSH
23150: PPUSH
23151: PPUSH
23152: PPUSH
// result := false ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: LD_INT 0
23160: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23161: LD_VAR 0 1
23165: NOT
23166: PUSH
23167: LD_VAR 0 1
23171: PPUSH
23172: CALL_OW 266
23176: PUSH
23177: LD_INT 32
23179: PUSH
23180: LD_INT 33
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: IN
23187: NOT
23188: OR
23189: IFFALSE 23193
// exit ;
23191: GO 24329
// nat := GetNation ( tower ) ;
23193: LD_ADDR_VAR 0 12
23197: PUSH
23198: LD_VAR 0 1
23202: PPUSH
23203: CALL_OW 248
23207: ST_TO_ADDR
// side := GetSide ( tower ) ;
23208: LD_ADDR_VAR 0 16
23212: PUSH
23213: LD_VAR 0 1
23217: PPUSH
23218: CALL_OW 255
23222: ST_TO_ADDR
// x := GetX ( tower ) ;
23223: LD_ADDR_VAR 0 10
23227: PUSH
23228: LD_VAR 0 1
23232: PPUSH
23233: CALL_OW 250
23237: ST_TO_ADDR
// y := GetY ( tower ) ;
23238: LD_ADDR_VAR 0 11
23242: PUSH
23243: LD_VAR 0 1
23247: PPUSH
23248: CALL_OW 251
23252: ST_TO_ADDR
// if not x or not y then
23253: LD_VAR 0 10
23257: NOT
23258: PUSH
23259: LD_VAR 0 11
23263: NOT
23264: OR
23265: IFFALSE 23269
// exit ;
23267: GO 24329
// weapon := 0 ;
23269: LD_ADDR_VAR 0 18
23273: PUSH
23274: LD_INT 0
23276: ST_TO_ADDR
// fac_list := [ ] ;
23277: LD_ADDR_VAR 0 17
23281: PUSH
23282: EMPTY
23283: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23284: LD_ADDR_VAR 0 6
23288: PUSH
23289: LD_VAR 0 1
23293: PPUSH
23294: CALL_OW 274
23298: PPUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: CALL 20907 0 2
23308: PPUSH
23309: LD_INT 30
23311: PUSH
23312: LD_INT 3
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PPUSH
23319: CALL_OW 72
23323: ST_TO_ADDR
// if not factories then
23324: LD_VAR 0 6
23328: NOT
23329: IFFALSE 23333
// exit ;
23331: GO 24329
// for i in factories do
23333: LD_ADDR_VAR 0 8
23337: PUSH
23338: LD_VAR 0 6
23342: PUSH
23343: FOR_IN
23344: IFFALSE 23369
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23346: LD_ADDR_VAR 0 17
23350: PUSH
23351: LD_VAR 0 17
23355: PUSH
23356: LD_VAR 0 8
23360: PPUSH
23361: CALL_OW 478
23365: UNION
23366: ST_TO_ADDR
23367: GO 23343
23369: POP
23370: POP
// if not fac_list then
23371: LD_VAR 0 17
23375: NOT
23376: IFFALSE 23380
// exit ;
23378: GO 24329
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23380: LD_ADDR_VAR 0 5
23384: PUSH
23385: LD_INT 4
23387: PUSH
23388: LD_INT 5
23390: PUSH
23391: LD_INT 9
23393: PUSH
23394: LD_INT 10
23396: PUSH
23397: LD_INT 6
23399: PUSH
23400: LD_INT 7
23402: PUSH
23403: LD_INT 11
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: PUSH
23415: LD_INT 27
23417: PUSH
23418: LD_INT 28
23420: PUSH
23421: LD_INT 26
23423: PUSH
23424: LD_INT 30
23426: PUSH
23427: EMPTY
23428: LIST
23429: LIST
23430: LIST
23431: LIST
23432: PUSH
23433: LD_INT 43
23435: PUSH
23436: LD_INT 44
23438: PUSH
23439: LD_INT 46
23441: PUSH
23442: LD_INT 45
23444: PUSH
23445: LD_INT 47
23447: PUSH
23448: LD_INT 49
23450: PUSH
23451: EMPTY
23452: LIST
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: LIST
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: LIST
23463: PUSH
23464: LD_VAR 0 12
23468: ARRAY
23469: ST_TO_ADDR
// for i in list do
23470: LD_ADDR_VAR 0 8
23474: PUSH
23475: LD_VAR 0 5
23479: PUSH
23480: FOR_IN
23481: IFFALSE 23514
// if not i in fac_list then
23483: LD_VAR 0 8
23487: PUSH
23488: LD_VAR 0 17
23492: IN
23493: NOT
23494: IFFALSE 23512
// list := list diff i ;
23496: LD_ADDR_VAR 0 5
23500: PUSH
23501: LD_VAR 0 5
23505: PUSH
23506: LD_VAR 0 8
23510: DIFF
23511: ST_TO_ADDR
23512: GO 23480
23514: POP
23515: POP
// if not list then
23516: LD_VAR 0 5
23520: NOT
23521: IFFALSE 23525
// exit ;
23523: GO 24329
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23525: LD_VAR 0 12
23529: PUSH
23530: LD_INT 3
23532: EQUAL
23533: PUSH
23534: LD_INT 49
23536: PUSH
23537: LD_VAR 0 5
23541: IN
23542: AND
23543: PUSH
23544: LD_INT 31
23546: PPUSH
23547: LD_VAR 0 16
23551: PPUSH
23552: CALL_OW 321
23556: PUSH
23557: LD_INT 2
23559: EQUAL
23560: AND
23561: IFFALSE 23621
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23563: LD_INT 22
23565: PUSH
23566: LD_VAR 0 16
23570: PUSH
23571: EMPTY
23572: LIST
23573: LIST
23574: PUSH
23575: LD_INT 35
23577: PUSH
23578: LD_INT 49
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 91
23587: PUSH
23588: LD_VAR 0 1
23592: PUSH
23593: LD_INT 10
23595: PUSH
23596: EMPTY
23597: LIST
23598: LIST
23599: LIST
23600: PUSH
23601: EMPTY
23602: LIST
23603: LIST
23604: LIST
23605: PPUSH
23606: CALL_OW 69
23610: NOT
23611: IFFALSE 23621
// weapon := ru_time_lapser ;
23613: LD_ADDR_VAR 0 18
23617: PUSH
23618: LD_INT 49
23620: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
23621: LD_VAR 0 12
23625: PUSH
23626: LD_INT 1
23628: PUSH
23629: LD_INT 2
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: IN
23636: PUSH
23637: LD_INT 11
23639: PUSH
23640: LD_VAR 0 5
23644: IN
23645: PUSH
23646: LD_INT 30
23648: PUSH
23649: LD_VAR 0 5
23653: IN
23654: OR
23655: AND
23656: PUSH
23657: LD_INT 6
23659: PPUSH
23660: LD_VAR 0 16
23664: PPUSH
23665: CALL_OW 321
23669: PUSH
23670: LD_INT 2
23672: EQUAL
23673: AND
23674: IFFALSE 23839
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
23676: LD_INT 22
23678: PUSH
23679: LD_VAR 0 16
23683: PUSH
23684: EMPTY
23685: LIST
23686: LIST
23687: PUSH
23688: LD_INT 2
23690: PUSH
23691: LD_INT 35
23693: PUSH
23694: LD_INT 11
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: PUSH
23701: LD_INT 35
23703: PUSH
23704: LD_INT 30
23706: PUSH
23707: EMPTY
23708: LIST
23709: LIST
23710: PUSH
23711: EMPTY
23712: LIST
23713: LIST
23714: LIST
23715: PUSH
23716: LD_INT 91
23718: PUSH
23719: LD_VAR 0 1
23723: PUSH
23724: LD_INT 18
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: LIST
23731: PUSH
23732: EMPTY
23733: LIST
23734: LIST
23735: LIST
23736: PPUSH
23737: CALL_OW 69
23741: NOT
23742: PUSH
23743: LD_INT 22
23745: PUSH
23746: LD_VAR 0 16
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 2
23757: PUSH
23758: LD_INT 30
23760: PUSH
23761: LD_INT 32
23763: PUSH
23764: EMPTY
23765: LIST
23766: LIST
23767: PUSH
23768: LD_INT 30
23770: PUSH
23771: LD_INT 33
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: LIST
23782: PUSH
23783: LD_INT 91
23785: PUSH
23786: LD_VAR 0 1
23790: PUSH
23791: LD_INT 12
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: LIST
23798: PUSH
23799: EMPTY
23800: LIST
23801: LIST
23802: LIST
23803: PUSH
23804: EMPTY
23805: LIST
23806: PPUSH
23807: CALL_OW 69
23811: PUSH
23812: LD_INT 2
23814: GREATER
23815: AND
23816: IFFALSE 23839
// weapon := [ us_radar , ar_radar ] [ nat ] ;
23818: LD_ADDR_VAR 0 18
23822: PUSH
23823: LD_INT 11
23825: PUSH
23826: LD_INT 30
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_VAR 0 12
23837: ARRAY
23838: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
23839: LD_VAR 0 18
23843: NOT
23844: PUSH
23845: LD_INT 40
23847: PPUSH
23848: LD_VAR 0 16
23852: PPUSH
23853: CALL_OW 321
23857: PUSH
23858: LD_INT 2
23860: EQUAL
23861: AND
23862: PUSH
23863: LD_INT 7
23865: PUSH
23866: LD_VAR 0 5
23870: IN
23871: PUSH
23872: LD_INT 28
23874: PUSH
23875: LD_VAR 0 5
23879: IN
23880: OR
23881: PUSH
23882: LD_INT 45
23884: PUSH
23885: LD_VAR 0 5
23889: IN
23890: OR
23891: AND
23892: IFFALSE 24146
// begin hex := GetHexInfo ( x , y ) ;
23894: LD_ADDR_VAR 0 4
23898: PUSH
23899: LD_VAR 0 10
23903: PPUSH
23904: LD_VAR 0 11
23908: PPUSH
23909: CALL_OW 546
23913: ST_TO_ADDR
// if hex [ 1 ] then
23914: LD_VAR 0 4
23918: PUSH
23919: LD_INT 1
23921: ARRAY
23922: IFFALSE 23926
// exit ;
23924: GO 24329
// height := hex [ 2 ] ;
23926: LD_ADDR_VAR 0 15
23930: PUSH
23931: LD_VAR 0 4
23935: PUSH
23936: LD_INT 2
23938: ARRAY
23939: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
23940: LD_ADDR_VAR 0 14
23944: PUSH
23945: LD_INT 0
23947: PUSH
23948: LD_INT 2
23950: PUSH
23951: LD_INT 3
23953: PUSH
23954: LD_INT 5
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: LIST
23961: LIST
23962: ST_TO_ADDR
// for i in tmp do
23963: LD_ADDR_VAR 0 8
23967: PUSH
23968: LD_VAR 0 14
23972: PUSH
23973: FOR_IN
23974: IFFALSE 24144
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
23976: LD_ADDR_VAR 0 9
23980: PUSH
23981: LD_VAR 0 10
23985: PPUSH
23986: LD_VAR 0 8
23990: PPUSH
23991: LD_INT 5
23993: PPUSH
23994: CALL_OW 272
23998: PUSH
23999: LD_VAR 0 11
24003: PPUSH
24004: LD_VAR 0 8
24008: PPUSH
24009: LD_INT 5
24011: PPUSH
24012: CALL_OW 273
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24021: LD_VAR 0 9
24025: PUSH
24026: LD_INT 1
24028: ARRAY
24029: PPUSH
24030: LD_VAR 0 9
24034: PUSH
24035: LD_INT 2
24037: ARRAY
24038: PPUSH
24039: CALL_OW 488
24043: IFFALSE 24142
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24045: LD_ADDR_VAR 0 4
24049: PUSH
24050: LD_VAR 0 9
24054: PUSH
24055: LD_INT 1
24057: ARRAY
24058: PPUSH
24059: LD_VAR 0 9
24063: PUSH
24064: LD_INT 2
24066: ARRAY
24067: PPUSH
24068: CALL_OW 546
24072: ST_TO_ADDR
// if hex [ 1 ] then
24073: LD_VAR 0 4
24077: PUSH
24078: LD_INT 1
24080: ARRAY
24081: IFFALSE 24085
// continue ;
24083: GO 23973
// h := hex [ 2 ] ;
24085: LD_ADDR_VAR 0 13
24089: PUSH
24090: LD_VAR 0 4
24094: PUSH
24095: LD_INT 2
24097: ARRAY
24098: ST_TO_ADDR
// if h + 7 < height then
24099: LD_VAR 0 13
24103: PUSH
24104: LD_INT 7
24106: PLUS
24107: PUSH
24108: LD_VAR 0 15
24112: LESS
24113: IFFALSE 24142
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24115: LD_ADDR_VAR 0 18
24119: PUSH
24120: LD_INT 7
24122: PUSH
24123: LD_INT 28
24125: PUSH
24126: LD_INT 45
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: LIST
24133: PUSH
24134: LD_VAR 0 12
24138: ARRAY
24139: ST_TO_ADDR
// break ;
24140: GO 24144
// end ; end ; end ;
24142: GO 23973
24144: POP
24145: POP
// end ; if not weapon then
24146: LD_VAR 0 18
24150: NOT
24151: IFFALSE 24211
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24153: LD_ADDR_VAR 0 5
24157: PUSH
24158: LD_VAR 0 5
24162: PUSH
24163: LD_INT 11
24165: PUSH
24166: LD_INT 30
24168: PUSH
24169: LD_INT 49
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: LIST
24176: DIFF
24177: ST_TO_ADDR
// if not list then
24178: LD_VAR 0 5
24182: NOT
24183: IFFALSE 24187
// exit ;
24185: GO 24329
// weapon := list [ rand ( 1 , list ) ] ;
24187: LD_ADDR_VAR 0 18
24191: PUSH
24192: LD_VAR 0 5
24196: PUSH
24197: LD_INT 1
24199: PPUSH
24200: LD_VAR 0 5
24204: PPUSH
24205: CALL_OW 12
24209: ARRAY
24210: ST_TO_ADDR
// end ; if weapon then
24211: LD_VAR 0 18
24215: IFFALSE 24329
// begin tmp := CostOfWeapon ( weapon ) ;
24217: LD_ADDR_VAR 0 14
24221: PUSH
24222: LD_VAR 0 18
24226: PPUSH
24227: CALL_OW 451
24231: ST_TO_ADDR
// j := GetBase ( tower ) ;
24232: LD_ADDR_VAR 0 9
24236: PUSH
24237: LD_VAR 0 1
24241: PPUSH
24242: CALL_OW 274
24246: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24247: LD_VAR 0 9
24251: PPUSH
24252: LD_INT 1
24254: PPUSH
24255: CALL_OW 275
24259: PUSH
24260: LD_VAR 0 14
24264: PUSH
24265: LD_INT 1
24267: ARRAY
24268: GREATEREQUAL
24269: PUSH
24270: LD_VAR 0 9
24274: PPUSH
24275: LD_INT 2
24277: PPUSH
24278: CALL_OW 275
24282: PUSH
24283: LD_VAR 0 14
24287: PUSH
24288: LD_INT 2
24290: ARRAY
24291: GREATEREQUAL
24292: AND
24293: PUSH
24294: LD_VAR 0 9
24298: PPUSH
24299: LD_INT 3
24301: PPUSH
24302: CALL_OW 275
24306: PUSH
24307: LD_VAR 0 14
24311: PUSH
24312: LD_INT 3
24314: ARRAY
24315: GREATEREQUAL
24316: AND
24317: IFFALSE 24329
// result := weapon ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_VAR 0 18
24328: ST_TO_ADDR
// end ; end ;
24329: LD_VAR 0 3
24333: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24334: LD_INT 0
24336: PPUSH
24337: PPUSH
// result := true ;
24338: LD_ADDR_VAR 0 3
24342: PUSH
24343: LD_INT 1
24345: ST_TO_ADDR
// if array1 = array2 then
24346: LD_VAR 0 1
24350: PUSH
24351: LD_VAR 0 2
24355: EQUAL
24356: IFFALSE 24416
// begin for i = 1 to array1 do
24358: LD_ADDR_VAR 0 4
24362: PUSH
24363: DOUBLE
24364: LD_INT 1
24366: DEC
24367: ST_TO_ADDR
24368: LD_VAR 0 1
24372: PUSH
24373: FOR_TO
24374: IFFALSE 24412
// if array1 [ i ] <> array2 [ i ] then
24376: LD_VAR 0 1
24380: PUSH
24381: LD_VAR 0 4
24385: ARRAY
24386: PUSH
24387: LD_VAR 0 2
24391: PUSH
24392: LD_VAR 0 4
24396: ARRAY
24397: NONEQUAL
24398: IFFALSE 24410
// begin result := false ;
24400: LD_ADDR_VAR 0 3
24404: PUSH
24405: LD_INT 0
24407: ST_TO_ADDR
// break ;
24408: GO 24412
// end ;
24410: GO 24373
24412: POP
24413: POP
// end else
24414: GO 24424
// result := false ;
24416: LD_ADDR_VAR 0 3
24420: PUSH
24421: LD_INT 0
24423: ST_TO_ADDR
// end ;
24424: LD_VAR 0 3
24428: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24429: LD_INT 0
24431: PPUSH
24432: PPUSH
24433: PPUSH
// pom := GetBase ( fac ) ;
24434: LD_ADDR_VAR 0 5
24438: PUSH
24439: LD_VAR 0 1
24443: PPUSH
24444: CALL_OW 274
24448: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24449: LD_ADDR_VAR 0 4
24453: PUSH
24454: LD_VAR 0 2
24458: PUSH
24459: LD_INT 1
24461: ARRAY
24462: PPUSH
24463: LD_VAR 0 2
24467: PUSH
24468: LD_INT 2
24470: ARRAY
24471: PPUSH
24472: LD_VAR 0 2
24476: PUSH
24477: LD_INT 3
24479: ARRAY
24480: PPUSH
24481: LD_VAR 0 2
24485: PUSH
24486: LD_INT 4
24488: ARRAY
24489: PPUSH
24490: CALL_OW 449
24494: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24495: LD_ADDR_VAR 0 3
24499: PUSH
24500: LD_VAR 0 5
24504: PPUSH
24505: LD_INT 1
24507: PPUSH
24508: CALL_OW 275
24512: PUSH
24513: LD_VAR 0 4
24517: PUSH
24518: LD_INT 1
24520: ARRAY
24521: GREATEREQUAL
24522: PUSH
24523: LD_VAR 0 5
24527: PPUSH
24528: LD_INT 2
24530: PPUSH
24531: CALL_OW 275
24535: PUSH
24536: LD_VAR 0 4
24540: PUSH
24541: LD_INT 2
24543: ARRAY
24544: GREATEREQUAL
24545: AND
24546: PUSH
24547: LD_VAR 0 5
24551: PPUSH
24552: LD_INT 3
24554: PPUSH
24555: CALL_OW 275
24559: PUSH
24560: LD_VAR 0 4
24564: PUSH
24565: LD_INT 3
24567: ARRAY
24568: GREATEREQUAL
24569: AND
24570: ST_TO_ADDR
// end ;
24571: LD_VAR 0 3
24575: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24576: LD_INT 0
24578: PPUSH
24579: PPUSH
24580: PPUSH
24581: PPUSH
// pom := GetBase ( building ) ;
24582: LD_ADDR_VAR 0 3
24586: PUSH
24587: LD_VAR 0 1
24591: PPUSH
24592: CALL_OW 274
24596: ST_TO_ADDR
// if not pom then
24597: LD_VAR 0 3
24601: NOT
24602: IFFALSE 24606
// exit ;
24604: GO 24776
// btype := GetBType ( building ) ;
24606: LD_ADDR_VAR 0 5
24610: PUSH
24611: LD_VAR 0 1
24615: PPUSH
24616: CALL_OW 266
24620: ST_TO_ADDR
// if btype = b_armoury then
24621: LD_VAR 0 5
24625: PUSH
24626: LD_INT 4
24628: EQUAL
24629: IFFALSE 24639
// btype := b_barracks ;
24631: LD_ADDR_VAR 0 5
24635: PUSH
24636: LD_INT 5
24638: ST_TO_ADDR
// if btype = b_depot then
24639: LD_VAR 0 5
24643: PUSH
24644: LD_INT 0
24646: EQUAL
24647: IFFALSE 24657
// btype := b_warehouse ;
24649: LD_ADDR_VAR 0 5
24653: PUSH
24654: LD_INT 1
24656: ST_TO_ADDR
// if btype = b_workshop then
24657: LD_VAR 0 5
24661: PUSH
24662: LD_INT 2
24664: EQUAL
24665: IFFALSE 24675
// btype := b_factory ;
24667: LD_ADDR_VAR 0 5
24671: PUSH
24672: LD_INT 3
24674: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
24675: LD_ADDR_VAR 0 4
24679: PUSH
24680: LD_VAR 0 5
24684: PPUSH
24685: LD_VAR 0 1
24689: PPUSH
24690: CALL_OW 248
24694: PPUSH
24695: CALL_OW 450
24699: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24700: LD_ADDR_VAR 0 2
24704: PUSH
24705: LD_VAR 0 3
24709: PPUSH
24710: LD_INT 1
24712: PPUSH
24713: CALL_OW 275
24717: PUSH
24718: LD_VAR 0 4
24722: PUSH
24723: LD_INT 1
24725: ARRAY
24726: GREATEREQUAL
24727: PUSH
24728: LD_VAR 0 3
24732: PPUSH
24733: LD_INT 2
24735: PPUSH
24736: CALL_OW 275
24740: PUSH
24741: LD_VAR 0 4
24745: PUSH
24746: LD_INT 2
24748: ARRAY
24749: GREATEREQUAL
24750: AND
24751: PUSH
24752: LD_VAR 0 3
24756: PPUSH
24757: LD_INT 3
24759: PPUSH
24760: CALL_OW 275
24764: PUSH
24765: LD_VAR 0 4
24769: PUSH
24770: LD_INT 3
24772: ARRAY
24773: GREATEREQUAL
24774: AND
24775: ST_TO_ADDR
// end ;
24776: LD_VAR 0 2
24780: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
24781: LD_INT 0
24783: PPUSH
24784: PPUSH
24785: PPUSH
// pom := GetBase ( building ) ;
24786: LD_ADDR_VAR 0 4
24790: PUSH
24791: LD_VAR 0 1
24795: PPUSH
24796: CALL_OW 274
24800: ST_TO_ADDR
// if not pom then
24801: LD_VAR 0 4
24805: NOT
24806: IFFALSE 24810
// exit ;
24808: GO 24911
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
24810: LD_ADDR_VAR 0 5
24814: PUSH
24815: LD_VAR 0 2
24819: PPUSH
24820: LD_VAR 0 1
24824: PPUSH
24825: CALL_OW 248
24829: PPUSH
24830: CALL_OW 450
24834: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24835: LD_ADDR_VAR 0 3
24839: PUSH
24840: LD_VAR 0 4
24844: PPUSH
24845: LD_INT 1
24847: PPUSH
24848: CALL_OW 275
24852: PUSH
24853: LD_VAR 0 5
24857: PUSH
24858: LD_INT 1
24860: ARRAY
24861: GREATEREQUAL
24862: PUSH
24863: LD_VAR 0 4
24867: PPUSH
24868: LD_INT 2
24870: PPUSH
24871: CALL_OW 275
24875: PUSH
24876: LD_VAR 0 5
24880: PUSH
24881: LD_INT 2
24883: ARRAY
24884: GREATEREQUAL
24885: AND
24886: PUSH
24887: LD_VAR 0 4
24891: PPUSH
24892: LD_INT 3
24894: PPUSH
24895: CALL_OW 275
24899: PUSH
24900: LD_VAR 0 5
24904: PUSH
24905: LD_INT 3
24907: ARRAY
24908: GREATEREQUAL
24909: AND
24910: ST_TO_ADDR
// end ;
24911: LD_VAR 0 3
24915: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
24916: LD_INT 0
24918: PPUSH
24919: PPUSH
24920: PPUSH
24921: PPUSH
24922: PPUSH
24923: PPUSH
24924: PPUSH
24925: PPUSH
24926: PPUSH
24927: PPUSH
// result := false ;
24928: LD_ADDR_VAR 0 6
24932: PUSH
24933: LD_INT 0
24935: ST_TO_ADDR
// if not base or not btype or not x or not y then
24936: LD_VAR 0 1
24940: NOT
24941: PUSH
24942: LD_VAR 0 2
24946: NOT
24947: OR
24948: PUSH
24949: LD_VAR 0 3
24953: NOT
24954: OR
24955: PUSH
24956: LD_VAR 0 4
24960: NOT
24961: OR
24962: IFFALSE 24966
// exit ;
24964: GO 25575
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
24966: LD_ADDR_VAR 0 12
24970: PUSH
24971: LD_VAR 0 2
24975: PPUSH
24976: LD_VAR 0 3
24980: PPUSH
24981: LD_VAR 0 4
24985: PPUSH
24986: LD_VAR 0 5
24990: PPUSH
24991: LD_VAR 0 1
24995: PUSH
24996: LD_INT 1
24998: ARRAY
24999: PPUSH
25000: CALL_OW 248
25004: PPUSH
25005: LD_INT 0
25007: PPUSH
25008: CALL 26412 0 6
25012: ST_TO_ADDR
// if not hexes then
25013: LD_VAR 0 12
25017: NOT
25018: IFFALSE 25022
// exit ;
25020: GO 25575
// for i = 1 to hexes do
25022: LD_ADDR_VAR 0 7
25026: PUSH
25027: DOUBLE
25028: LD_INT 1
25030: DEC
25031: ST_TO_ADDR
25032: LD_VAR 0 12
25036: PUSH
25037: FOR_TO
25038: IFFALSE 25573
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25040: LD_ADDR_VAR 0 11
25044: PUSH
25045: LD_VAR 0 12
25049: PUSH
25050: LD_VAR 0 7
25054: ARRAY
25055: PUSH
25056: LD_INT 1
25058: ARRAY
25059: PPUSH
25060: LD_VAR 0 12
25064: PUSH
25065: LD_VAR 0 7
25069: ARRAY
25070: PUSH
25071: LD_INT 2
25073: ARRAY
25074: PPUSH
25075: CALL_OW 428
25079: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25080: LD_VAR 0 12
25084: PUSH
25085: LD_VAR 0 7
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PPUSH
25095: LD_VAR 0 12
25099: PUSH
25100: LD_VAR 0 7
25104: ARRAY
25105: PUSH
25106: LD_INT 2
25108: ARRAY
25109: PPUSH
25110: CALL_OW 351
25114: PUSH
25115: LD_VAR 0 12
25119: PUSH
25120: LD_VAR 0 7
25124: ARRAY
25125: PUSH
25126: LD_INT 1
25128: ARRAY
25129: PPUSH
25130: LD_VAR 0 12
25134: PUSH
25135: LD_VAR 0 7
25139: ARRAY
25140: PUSH
25141: LD_INT 2
25143: ARRAY
25144: PPUSH
25145: CALL_OW 488
25149: NOT
25150: OR
25151: PUSH
25152: LD_VAR 0 11
25156: PPUSH
25157: CALL_OW 247
25161: PUSH
25162: LD_INT 3
25164: EQUAL
25165: OR
25166: IFFALSE 25172
// exit ;
25168: POP
25169: POP
25170: GO 25575
// if not tmp or not tmp in base then
25172: LD_VAR 0 11
25176: NOT
25177: PUSH
25178: LD_VAR 0 11
25182: PUSH
25183: LD_VAR 0 1
25187: IN
25188: NOT
25189: OR
25190: IFFALSE 25194
// continue ;
25192: GO 25037
// result := true ;
25194: LD_ADDR_VAR 0 6
25198: PUSH
25199: LD_INT 1
25201: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25202: LD_ADDR_VAR 0 15
25206: PUSH
25207: LD_VAR 0 1
25211: PPUSH
25212: LD_INT 22
25214: PUSH
25215: LD_VAR 0 11
25219: PPUSH
25220: CALL_OW 255
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PUSH
25229: LD_INT 2
25231: PUSH
25232: LD_INT 30
25234: PUSH
25235: LD_INT 0
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: LD_INT 30
25244: PUSH
25245: LD_INT 1
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PUSH
25257: EMPTY
25258: LIST
25259: LIST
25260: PPUSH
25261: CALL_OW 72
25265: ST_TO_ADDR
// if dep then
25266: LD_VAR 0 15
25270: IFFALSE 25406
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25272: LD_ADDR_VAR 0 14
25276: PUSH
25277: LD_VAR 0 15
25281: PUSH
25282: LD_INT 1
25284: ARRAY
25285: PPUSH
25286: CALL_OW 250
25290: PPUSH
25291: LD_VAR 0 15
25295: PUSH
25296: LD_INT 1
25298: ARRAY
25299: PPUSH
25300: CALL_OW 254
25304: PPUSH
25305: LD_INT 5
25307: PPUSH
25308: CALL_OW 272
25312: PUSH
25313: LD_VAR 0 15
25317: PUSH
25318: LD_INT 1
25320: ARRAY
25321: PPUSH
25322: CALL_OW 251
25326: PPUSH
25327: LD_VAR 0 15
25331: PUSH
25332: LD_INT 1
25334: ARRAY
25335: PPUSH
25336: CALL_OW 254
25340: PPUSH
25341: LD_INT 5
25343: PPUSH
25344: CALL_OW 273
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25353: LD_VAR 0 14
25357: PUSH
25358: LD_INT 1
25360: ARRAY
25361: PPUSH
25362: LD_VAR 0 14
25366: PUSH
25367: LD_INT 2
25369: ARRAY
25370: PPUSH
25371: CALL_OW 488
25375: IFFALSE 25406
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25377: LD_VAR 0 11
25381: PPUSH
25382: LD_VAR 0 14
25386: PUSH
25387: LD_INT 1
25389: ARRAY
25390: PPUSH
25391: LD_VAR 0 14
25395: PUSH
25396: LD_INT 2
25398: ARRAY
25399: PPUSH
25400: CALL_OW 111
// continue ;
25404: GO 25037
// end ; end ; r := GetDir ( tmp ) ;
25406: LD_ADDR_VAR 0 13
25410: PUSH
25411: LD_VAR 0 11
25415: PPUSH
25416: CALL_OW 254
25420: ST_TO_ADDR
// if r = 5 then
25421: LD_VAR 0 13
25425: PUSH
25426: LD_INT 5
25428: EQUAL
25429: IFFALSE 25439
// r := 0 ;
25431: LD_ADDR_VAR 0 13
25435: PUSH
25436: LD_INT 0
25438: ST_TO_ADDR
// for j = r to 5 do
25439: LD_ADDR_VAR 0 8
25443: PUSH
25444: DOUBLE
25445: LD_VAR 0 13
25449: DEC
25450: ST_TO_ADDR
25451: LD_INT 5
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25569
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25457: LD_ADDR_VAR 0 9
25461: PUSH
25462: LD_VAR 0 11
25466: PPUSH
25467: CALL_OW 250
25471: PPUSH
25472: LD_VAR 0 8
25476: PPUSH
25477: LD_INT 2
25479: PPUSH
25480: CALL_OW 272
25484: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25485: LD_ADDR_VAR 0 10
25489: PUSH
25490: LD_VAR 0 11
25494: PPUSH
25495: CALL_OW 251
25499: PPUSH
25500: LD_VAR 0 8
25504: PPUSH
25505: LD_INT 2
25507: PPUSH
25508: CALL_OW 273
25512: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25513: LD_VAR 0 9
25517: PPUSH
25518: LD_VAR 0 10
25522: PPUSH
25523: CALL_OW 488
25527: PUSH
25528: LD_VAR 0 9
25532: PPUSH
25533: LD_VAR 0 10
25537: PPUSH
25538: CALL_OW 428
25542: NOT
25543: AND
25544: IFFALSE 25567
// begin ComMoveXY ( tmp , _x , _y ) ;
25546: LD_VAR 0 11
25550: PPUSH
25551: LD_VAR 0 9
25555: PPUSH
25556: LD_VAR 0 10
25560: PPUSH
25561: CALL_OW 111
// break ;
25565: GO 25569
// end ; end ;
25567: GO 25454
25569: POP
25570: POP
// end ;
25571: GO 25037
25573: POP
25574: POP
// end ;
25575: LD_VAR 0 6
25579: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25580: LD_INT 0
25582: PPUSH
25583: PPUSH
25584: PPUSH
25585: PPUSH
25586: PPUSH
25587: PPUSH
25588: PPUSH
25589: PPUSH
25590: PPUSH
25591: PPUSH
// result := false ;
25592: LD_ADDR_VAR 0 6
25596: PUSH
25597: LD_INT 0
25599: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
25600: LD_VAR 0 1
25604: NOT
25605: PUSH
25606: LD_VAR 0 1
25610: PPUSH
25611: CALL_OW 266
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 1
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: IN
25626: NOT
25627: OR
25628: PUSH
25629: LD_VAR 0 2
25633: NOT
25634: OR
25635: PUSH
25636: LD_VAR 0 5
25640: PUSH
25641: LD_INT 0
25643: PUSH
25644: LD_INT 1
25646: PUSH
25647: LD_INT 2
25649: PUSH
25650: LD_INT 3
25652: PUSH
25653: LD_INT 4
25655: PUSH
25656: LD_INT 5
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: IN
25667: NOT
25668: OR
25669: PUSH
25670: LD_VAR 0 3
25674: PPUSH
25675: LD_VAR 0 4
25679: PPUSH
25680: CALL_OW 488
25684: NOT
25685: OR
25686: IFFALSE 25690
// exit ;
25688: GO 26407
// pom := GetBase ( depot ) ;
25690: LD_ADDR_VAR 0 10
25694: PUSH
25695: LD_VAR 0 1
25699: PPUSH
25700: CALL_OW 274
25704: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
25705: LD_ADDR_VAR 0 11
25709: PUSH
25710: LD_VAR 0 2
25714: PPUSH
25715: LD_VAR 0 1
25719: PPUSH
25720: CALL_OW 248
25724: PPUSH
25725: CALL_OW 450
25729: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
25730: LD_VAR 0 10
25734: PPUSH
25735: LD_INT 1
25737: PPUSH
25738: CALL_OW 275
25742: PUSH
25743: LD_VAR 0 11
25747: PUSH
25748: LD_INT 1
25750: ARRAY
25751: GREATEREQUAL
25752: PUSH
25753: LD_VAR 0 10
25757: PPUSH
25758: LD_INT 2
25760: PPUSH
25761: CALL_OW 275
25765: PUSH
25766: LD_VAR 0 11
25770: PUSH
25771: LD_INT 2
25773: ARRAY
25774: GREATEREQUAL
25775: AND
25776: PUSH
25777: LD_VAR 0 10
25781: PPUSH
25782: LD_INT 3
25784: PPUSH
25785: CALL_OW 275
25789: PUSH
25790: LD_VAR 0 11
25794: PUSH
25795: LD_INT 3
25797: ARRAY
25798: GREATEREQUAL
25799: AND
25800: NOT
25801: IFFALSE 25805
// exit ;
25803: GO 26407
// if GetBType ( depot ) = b_depot then
25805: LD_VAR 0 1
25809: PPUSH
25810: CALL_OW 266
25814: PUSH
25815: LD_INT 0
25817: EQUAL
25818: IFFALSE 25830
// dist := 28 else
25820: LD_ADDR_VAR 0 14
25824: PUSH
25825: LD_INT 28
25827: ST_TO_ADDR
25828: GO 25838
// dist := 36 ;
25830: LD_ADDR_VAR 0 14
25834: PUSH
25835: LD_INT 36
25837: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_VAR 0 3
25847: PPUSH
25848: LD_VAR 0 4
25852: PPUSH
25853: CALL_OW 297
25857: PUSH
25858: LD_VAR 0 14
25862: GREATER
25863: IFFALSE 25867
// exit ;
25865: GO 26407
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
25867: LD_ADDR_VAR 0 12
25871: PUSH
25872: LD_VAR 0 2
25876: PPUSH
25877: LD_VAR 0 3
25881: PPUSH
25882: LD_VAR 0 4
25886: PPUSH
25887: LD_VAR 0 5
25891: PPUSH
25892: LD_VAR 0 1
25896: PPUSH
25897: CALL_OW 248
25901: PPUSH
25902: LD_INT 0
25904: PPUSH
25905: CALL 26412 0 6
25909: ST_TO_ADDR
// if not hexes then
25910: LD_VAR 0 12
25914: NOT
25915: IFFALSE 25919
// exit ;
25917: GO 26407
// hex := GetHexInfo ( x , y ) ;
25919: LD_ADDR_VAR 0 15
25923: PUSH
25924: LD_VAR 0 3
25928: PPUSH
25929: LD_VAR 0 4
25933: PPUSH
25934: CALL_OW 546
25938: ST_TO_ADDR
// if hex [ 1 ] then
25939: LD_VAR 0 15
25943: PUSH
25944: LD_INT 1
25946: ARRAY
25947: IFFALSE 25951
// exit ;
25949: GO 26407
// height := hex [ 2 ] ;
25951: LD_ADDR_VAR 0 13
25955: PUSH
25956: LD_VAR 0 15
25960: PUSH
25961: LD_INT 2
25963: ARRAY
25964: ST_TO_ADDR
// for i = 1 to hexes do
25965: LD_ADDR_VAR 0 7
25969: PUSH
25970: DOUBLE
25971: LD_INT 1
25973: DEC
25974: ST_TO_ADDR
25975: LD_VAR 0 12
25979: PUSH
25980: FOR_TO
25981: IFFALSE 26311
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25983: LD_VAR 0 12
25987: PUSH
25988: LD_VAR 0 7
25992: ARRAY
25993: PUSH
25994: LD_INT 1
25996: ARRAY
25997: PPUSH
25998: LD_VAR 0 12
26002: PUSH
26003: LD_VAR 0 7
26007: ARRAY
26008: PUSH
26009: LD_INT 2
26011: ARRAY
26012: PPUSH
26013: CALL_OW 488
26017: NOT
26018: PUSH
26019: LD_VAR 0 12
26023: PUSH
26024: LD_VAR 0 7
26028: ARRAY
26029: PUSH
26030: LD_INT 1
26032: ARRAY
26033: PPUSH
26034: LD_VAR 0 12
26038: PUSH
26039: LD_VAR 0 7
26043: ARRAY
26044: PUSH
26045: LD_INT 2
26047: ARRAY
26048: PPUSH
26049: CALL_OW 428
26053: PUSH
26054: LD_INT 0
26056: GREATER
26057: OR
26058: PUSH
26059: LD_VAR 0 12
26063: PUSH
26064: LD_VAR 0 7
26068: ARRAY
26069: PUSH
26070: LD_INT 1
26072: ARRAY
26073: PPUSH
26074: LD_VAR 0 12
26078: PUSH
26079: LD_VAR 0 7
26083: ARRAY
26084: PUSH
26085: LD_INT 2
26087: ARRAY
26088: PPUSH
26089: CALL_OW 351
26093: OR
26094: IFFALSE 26100
// exit ;
26096: POP
26097: POP
26098: GO 26407
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26100: LD_ADDR_VAR 0 8
26104: PUSH
26105: LD_VAR 0 12
26109: PUSH
26110: LD_VAR 0 7
26114: ARRAY
26115: PUSH
26116: LD_INT 1
26118: ARRAY
26119: PPUSH
26120: LD_VAR 0 12
26124: PUSH
26125: LD_VAR 0 7
26129: ARRAY
26130: PUSH
26131: LD_INT 2
26133: ARRAY
26134: PPUSH
26135: CALL_OW 546
26139: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26140: LD_VAR 0 8
26144: PUSH
26145: LD_INT 1
26147: ARRAY
26148: PUSH
26149: LD_VAR 0 8
26153: PUSH
26154: LD_INT 2
26156: ARRAY
26157: PUSH
26158: LD_VAR 0 13
26162: PUSH
26163: LD_INT 2
26165: PLUS
26166: GREATER
26167: OR
26168: PUSH
26169: LD_VAR 0 8
26173: PUSH
26174: LD_INT 2
26176: ARRAY
26177: PUSH
26178: LD_VAR 0 13
26182: PUSH
26183: LD_INT 2
26185: MINUS
26186: LESS
26187: OR
26188: PUSH
26189: LD_VAR 0 8
26193: PUSH
26194: LD_INT 3
26196: ARRAY
26197: PUSH
26198: LD_INT 0
26200: PUSH
26201: LD_INT 8
26203: PUSH
26204: LD_INT 9
26206: PUSH
26207: LD_INT 10
26209: PUSH
26210: LD_INT 11
26212: PUSH
26213: LD_INT 12
26215: PUSH
26216: LD_INT 13
26218: PUSH
26219: LD_INT 16
26221: PUSH
26222: LD_INT 17
26224: PUSH
26225: LD_INT 18
26227: PUSH
26228: LD_INT 19
26230: PUSH
26231: LD_INT 20
26233: PUSH
26234: LD_INT 21
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: LIST
26241: LIST
26242: LIST
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: IN
26252: NOT
26253: OR
26254: PUSH
26255: LD_VAR 0 8
26259: PUSH
26260: LD_INT 5
26262: ARRAY
26263: NOT
26264: OR
26265: PUSH
26266: LD_VAR 0 8
26270: PUSH
26271: LD_INT 6
26273: ARRAY
26274: PUSH
26275: LD_INT 1
26277: PUSH
26278: LD_INT 2
26280: PUSH
26281: LD_INT 7
26283: PUSH
26284: LD_INT 9
26286: PUSH
26287: LD_INT 10
26289: PUSH
26290: LD_INT 11
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: IN
26301: NOT
26302: OR
26303: IFFALSE 26309
// exit ;
26305: POP
26306: POP
26307: GO 26407
// end ;
26309: GO 25980
26311: POP
26312: POP
// side := GetSide ( depot ) ;
26313: LD_ADDR_VAR 0 9
26317: PUSH
26318: LD_VAR 0 1
26322: PPUSH
26323: CALL_OW 255
26327: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26328: LD_VAR 0 9
26332: PPUSH
26333: LD_VAR 0 3
26337: PPUSH
26338: LD_VAR 0 4
26342: PPUSH
26343: LD_INT 20
26345: PPUSH
26346: CALL 19061 0 4
26350: PUSH
26351: LD_INT 4
26353: ARRAY
26354: IFFALSE 26358
// exit ;
26356: GO 26407
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26358: LD_VAR 0 2
26362: PUSH
26363: LD_INT 29
26365: PUSH
26366: LD_INT 30
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: IN
26373: PUSH
26374: LD_VAR 0 3
26378: PPUSH
26379: LD_VAR 0 4
26383: PPUSH
26384: LD_VAR 0 9
26388: PPUSH
26389: CALL_OW 440
26393: NOT
26394: AND
26395: IFFALSE 26399
// exit ;
26397: GO 26407
// result := true ;
26399: LD_ADDR_VAR 0 6
26403: PUSH
26404: LD_INT 1
26406: ST_TO_ADDR
// end ;
26407: LD_VAR 0 6
26411: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
26412: LD_INT 0
26414: PPUSH
26415: PPUSH
26416: PPUSH
26417: PPUSH
26418: PPUSH
26419: PPUSH
26420: PPUSH
26421: PPUSH
26422: PPUSH
26423: PPUSH
26424: PPUSH
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
26429: PPUSH
26430: PPUSH
26431: PPUSH
26432: PPUSH
26433: PPUSH
26434: PPUSH
26435: PPUSH
26436: PPUSH
26437: PPUSH
26438: PPUSH
26439: PPUSH
26440: PPUSH
26441: PPUSH
26442: PPUSH
26443: PPUSH
26444: PPUSH
26445: PPUSH
26446: PPUSH
26447: PPUSH
26448: PPUSH
26449: PPUSH
26450: PPUSH
26451: PPUSH
26452: PPUSH
26453: PPUSH
26454: PPUSH
26455: PPUSH
26456: PPUSH
26457: PPUSH
26458: PPUSH
26459: PPUSH
26460: PPUSH
26461: PPUSH
26462: PPUSH
26463: PPUSH
26464: PPUSH
26465: PPUSH
26466: PPUSH
26467: PPUSH
26468: PPUSH
26469: PPUSH
26470: PPUSH
26471: PPUSH
// result = [ ] ;
26472: LD_ADDR_VAR 0 7
26476: PUSH
26477: EMPTY
26478: ST_TO_ADDR
// temp_list = [ ] ;
26479: LD_ADDR_VAR 0 9
26483: PUSH
26484: EMPTY
26485: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26486: LD_VAR 0 4
26490: PUSH
26491: LD_INT 0
26493: PUSH
26494: LD_INT 1
26496: PUSH
26497: LD_INT 2
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: LD_INT 4
26505: PUSH
26506: LD_INT 5
26508: PUSH
26509: EMPTY
26510: LIST
26511: LIST
26512: LIST
26513: LIST
26514: LIST
26515: LIST
26516: IN
26517: NOT
26518: PUSH
26519: LD_VAR 0 1
26523: PUSH
26524: LD_INT 0
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: IN
26534: PUSH
26535: LD_VAR 0 5
26539: PUSH
26540: LD_INT 1
26542: PUSH
26543: LD_INT 2
26545: PUSH
26546: LD_INT 3
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: IN
26554: NOT
26555: AND
26556: OR
26557: IFFALSE 26561
// exit ;
26559: GO 44952
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26561: LD_VAR 0 1
26565: PUSH
26566: LD_INT 6
26568: PUSH
26569: LD_INT 7
26571: PUSH
26572: LD_INT 8
26574: PUSH
26575: LD_INT 13
26577: PUSH
26578: LD_INT 12
26580: PUSH
26581: LD_INT 15
26583: PUSH
26584: LD_INT 11
26586: PUSH
26587: LD_INT 14
26589: PUSH
26590: LD_INT 10
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: IN
26604: IFFALSE 26614
// btype = b_lab ;
26606: LD_ADDR_VAR 0 1
26610: PUSH
26611: LD_INT 6
26613: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
26614: LD_VAR 0 6
26618: PUSH
26619: LD_INT 0
26621: PUSH
26622: LD_INT 1
26624: PUSH
26625: LD_INT 2
26627: PUSH
26628: EMPTY
26629: LIST
26630: LIST
26631: LIST
26632: IN
26633: NOT
26634: PUSH
26635: LD_VAR 0 1
26639: PUSH
26640: LD_INT 0
26642: PUSH
26643: LD_INT 1
26645: PUSH
26646: LD_INT 2
26648: PUSH
26649: LD_INT 3
26651: PUSH
26652: LD_INT 6
26654: PUSH
26655: LD_INT 36
26657: PUSH
26658: LD_INT 4
26660: PUSH
26661: LD_INT 5
26663: PUSH
26664: LD_INT 31
26666: PUSH
26667: LD_INT 32
26669: PUSH
26670: LD_INT 33
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: LIST
26683: LIST
26684: LIST
26685: IN
26686: NOT
26687: PUSH
26688: LD_VAR 0 6
26692: PUSH
26693: LD_INT 1
26695: EQUAL
26696: AND
26697: OR
26698: PUSH
26699: LD_VAR 0 1
26703: PUSH
26704: LD_INT 2
26706: PUSH
26707: LD_INT 3
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: IN
26714: NOT
26715: PUSH
26716: LD_VAR 0 6
26720: PUSH
26721: LD_INT 2
26723: EQUAL
26724: AND
26725: OR
26726: IFFALSE 26736
// mode = 0 ;
26728: LD_ADDR_VAR 0 6
26732: PUSH
26733: LD_INT 0
26735: ST_TO_ADDR
// case mode of 0 :
26736: LD_VAR 0 6
26740: PUSH
26741: LD_INT 0
26743: DOUBLE
26744: EQUAL
26745: IFTRUE 26749
26747: GO 38202
26749: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
26750: LD_ADDR_VAR 0 11
26754: PUSH
26755: LD_INT 0
26757: PUSH
26758: LD_INT 0
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: PUSH
26765: LD_INT 0
26767: PUSH
26768: LD_INT 1
26770: NEG
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 1
26778: PUSH
26779: LD_INT 0
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PUSH
26786: LD_INT 1
26788: PUSH
26789: LD_INT 1
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 0
26798: PUSH
26799: LD_INT 1
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 1
26808: NEG
26809: PUSH
26810: LD_INT 0
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 1
26819: NEG
26820: PUSH
26821: LD_INT 1
26823: NEG
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 1
26831: NEG
26832: PUSH
26833: LD_INT 2
26835: NEG
26836: PUSH
26837: EMPTY
26838: LIST
26839: LIST
26840: PUSH
26841: LD_INT 0
26843: PUSH
26844: LD_INT 2
26846: NEG
26847: PUSH
26848: EMPTY
26849: LIST
26850: LIST
26851: PUSH
26852: LD_INT 1
26854: PUSH
26855: LD_INT 1
26857: NEG
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: PUSH
26863: LD_INT 1
26865: PUSH
26866: LD_INT 2
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: PUSH
26873: LD_INT 0
26875: PUSH
26876: LD_INT 2
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 1
26885: NEG
26886: PUSH
26887: LD_INT 1
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PUSH
26894: LD_INT 1
26896: PUSH
26897: LD_INT 3
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PUSH
26904: LD_INT 0
26906: PUSH
26907: LD_INT 3
26909: PUSH
26910: EMPTY
26911: LIST
26912: LIST
26913: PUSH
26914: LD_INT 1
26916: NEG
26917: PUSH
26918: LD_INT 2
26920: PUSH
26921: EMPTY
26922: LIST
26923: LIST
26924: PUSH
26925: EMPTY
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26943: LD_ADDR_VAR 0 12
26947: PUSH
26948: LD_INT 0
26950: PUSH
26951: LD_INT 0
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: PUSH
26958: LD_INT 0
26960: PUSH
26961: LD_INT 1
26963: NEG
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 1
26971: PUSH
26972: LD_INT 0
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: PUSH
26979: LD_INT 1
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: PUSH
26989: LD_INT 0
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 1
27001: NEG
27002: PUSH
27003: LD_INT 0
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: LD_INT 1
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 1
27024: PUSH
27025: LD_INT 1
27027: NEG
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 2
27035: PUSH
27036: LD_INT 0
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: LD_INT 1
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 1
27055: NEG
27056: PUSH
27057: LD_INT 1
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 2
27066: NEG
27067: PUSH
27068: LD_INT 0
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 2
27077: NEG
27078: PUSH
27079: LD_INT 1
27081: NEG
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: LD_INT 1
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 3
27100: NEG
27101: PUSH
27102: LD_INT 0
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: PUSH
27109: LD_INT 3
27111: NEG
27112: PUSH
27113: LD_INT 1
27115: NEG
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: LIST
27138: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27139: LD_ADDR_VAR 0 13
27143: PUSH
27144: LD_INT 0
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PUSH
27154: LD_INT 0
27156: PUSH
27157: LD_INT 1
27159: NEG
27160: PUSH
27161: EMPTY
27162: LIST
27163: LIST
27164: PUSH
27165: LD_INT 1
27167: PUSH
27168: LD_INT 0
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: PUSH
27175: LD_INT 1
27177: PUSH
27178: LD_INT 1
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PUSH
27185: LD_INT 0
27187: PUSH
27188: LD_INT 1
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 1
27197: NEG
27198: PUSH
27199: LD_INT 0
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: LD_INT 1
27208: NEG
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 1
27220: NEG
27221: PUSH
27222: LD_INT 2
27224: NEG
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 2
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 2
27242: PUSH
27243: LD_INT 2
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PUSH
27250: LD_INT 1
27252: PUSH
27253: LD_INT 2
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: LD_INT 2
27262: NEG
27263: PUSH
27264: LD_INT 1
27266: NEG
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 2
27274: NEG
27275: PUSH
27276: LD_INT 2
27278: NEG
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 2
27286: NEG
27287: PUSH
27288: LD_INT 3
27290: NEG
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: LD_INT 3
27298: NEG
27299: PUSH
27300: LD_INT 2
27302: NEG
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 3
27310: NEG
27311: PUSH
27312: LD_INT 3
27314: NEG
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: LIST
27326: LIST
27327: LIST
27328: LIST
27329: LIST
27330: LIST
27331: LIST
27332: LIST
27333: LIST
27334: LIST
27335: LIST
27336: LIST
27337: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27338: LD_ADDR_VAR 0 14
27342: PUSH
27343: LD_INT 0
27345: PUSH
27346: LD_INT 0
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 0
27355: PUSH
27356: LD_INT 1
27358: NEG
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 1
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 1
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 0
27386: PUSH
27387: LD_INT 1
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 1
27396: NEG
27397: PUSH
27398: LD_INT 0
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 1
27407: NEG
27408: PUSH
27409: LD_INT 1
27411: NEG
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: NEG
27420: PUSH
27421: LD_INT 2
27423: NEG
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 0
27431: PUSH
27432: LD_INT 2
27434: NEG
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: LD_INT 1
27445: NEG
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: PUSH
27451: LD_INT 1
27453: PUSH
27454: LD_INT 2
27456: PUSH
27457: EMPTY
27458: LIST
27459: LIST
27460: PUSH
27461: LD_INT 0
27463: PUSH
27464: LD_INT 2
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 1
27473: NEG
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 1
27484: NEG
27485: PUSH
27486: LD_INT 3
27488: NEG
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 0
27496: PUSH
27497: LD_INT 3
27499: NEG
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 1
27507: PUSH
27508: LD_INT 2
27510: NEG
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: LIST
27523: LIST
27524: LIST
27525: LIST
27526: LIST
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27534: LD_ADDR_VAR 0 15
27538: PUSH
27539: LD_INT 0
27541: PUSH
27542: LD_INT 0
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: LD_INT 1
27554: NEG
27555: PUSH
27556: EMPTY
27557: LIST
27558: LIST
27559: PUSH
27560: LD_INT 1
27562: PUSH
27563: LD_INT 0
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 1
27572: PUSH
27573: LD_INT 1
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 0
27582: PUSH
27583: LD_INT 1
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 1
27592: NEG
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 1
27603: NEG
27604: PUSH
27605: LD_INT 1
27607: NEG
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 1
27618: NEG
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PUSH
27624: LD_INT 2
27626: PUSH
27627: LD_INT 0
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: PUSH
27634: LD_INT 2
27636: PUSH
27637: LD_INT 1
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 1
27646: NEG
27647: PUSH
27648: LD_INT 1
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: LD_INT 0
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 2
27668: NEG
27669: PUSH
27670: LD_INT 1
27672: NEG
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PUSH
27678: LD_INT 2
27680: PUSH
27681: LD_INT 1
27683: NEG
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: LD_INT 3
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 3
27701: PUSH
27702: LD_INT 1
27704: PUSH
27705: EMPTY
27706: LIST
27707: LIST
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: LIST
27719: LIST
27720: LIST
27721: LIST
27722: LIST
27723: LIST
27724: LIST
27725: LIST
27726: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
27727: LD_ADDR_VAR 0 16
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: LD_INT 0
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: LD_INT 1
27747: NEG
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 0
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: LD_INT 1
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 0
27775: PUSH
27776: LD_INT 1
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 1
27785: NEG
27786: PUSH
27787: LD_INT 0
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 1
27796: NEG
27797: PUSH
27798: LD_INT 1
27800: NEG
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 1
27808: NEG
27809: PUSH
27810: LD_INT 2
27812: NEG
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 2
27820: PUSH
27821: LD_INT 1
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 2
27830: PUSH
27831: LD_INT 2
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 1
27840: PUSH
27841: LD_INT 2
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: NEG
27851: PUSH
27852: LD_INT 1
27854: NEG
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 2
27862: NEG
27863: PUSH
27864: LD_INT 2
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 3
27874: PUSH
27875: LD_INT 2
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 3
27884: PUSH
27885: LD_INT 3
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: LD_INT 3
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27920: LD_ADDR_VAR 0 17
27924: PUSH
27925: LD_INT 0
27927: PUSH
27928: LD_INT 0
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 0
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 1
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 0
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 1
27978: NEG
27979: PUSH
27980: LD_INT 0
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 1
27993: NEG
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: LD_INT 1
28001: NEG
28002: PUSH
28003: LD_INT 2
28005: NEG
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: LD_INT 2
28016: NEG
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: PUSH
28025: LD_INT 1
28027: NEG
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 2
28035: PUSH
28036: LD_INT 0
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: PUSH
28043: LD_INT 2
28045: PUSH
28046: LD_INT 1
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: PUSH
28053: LD_INT 2
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: EMPTY
28060: LIST
28061: LIST
28062: PUSH
28063: LD_INT 1
28065: PUSH
28066: LD_INT 2
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: PUSH
28073: LD_INT 0
28075: PUSH
28076: LD_INT 2
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 1
28085: NEG
28086: PUSH
28087: LD_INT 1
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: PUSH
28094: LD_INT 2
28096: NEG
28097: PUSH
28098: LD_INT 0
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 2
28107: NEG
28108: PUSH
28109: LD_INT 1
28111: NEG
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 2
28119: NEG
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: LIST
28149: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28150: LD_ADDR_VAR 0 18
28154: PUSH
28155: LD_INT 0
28157: PUSH
28158: LD_INT 0
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: PUSH
28165: LD_INT 0
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 1
28178: PUSH
28179: LD_INT 0
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: LD_INT 1
28188: PUSH
28189: LD_INT 1
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 0
28198: PUSH
28199: LD_INT 1
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 1
28208: NEG
28209: PUSH
28210: LD_INT 0
28212: PUSH
28213: EMPTY
28214: LIST
28215: LIST
28216: PUSH
28217: LD_INT 1
28219: NEG
28220: PUSH
28221: LD_INT 1
28223: NEG
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: LD_INT 2
28235: NEG
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: LD_INT 2
28246: NEG
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 1
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 2
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 2
28285: PUSH
28286: LD_INT 2
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: LD_INT 2
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 0
28305: PUSH
28306: LD_INT 2
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 1
28315: NEG
28316: PUSH
28317: LD_INT 1
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PUSH
28324: LD_INT 2
28326: NEG
28327: PUSH
28328: LD_INT 0
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 2
28337: NEG
28338: PUSH
28339: LD_INT 1
28341: NEG
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PUSH
28347: LD_INT 2
28349: NEG
28350: PUSH
28351: LD_INT 2
28353: NEG
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: LIST
28363: LIST
28364: LIST
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28380: LD_ADDR_VAR 0 19
28384: PUSH
28385: LD_INT 0
28387: PUSH
28388: LD_INT 0
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: PUSH
28395: LD_INT 0
28397: PUSH
28398: LD_INT 1
28400: NEG
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 1
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 1
28418: PUSH
28419: LD_INT 1
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: NEG
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 1
28449: NEG
28450: PUSH
28451: LD_INT 1
28453: NEG
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: LD_INT 1
28461: NEG
28462: PUSH
28463: LD_INT 2
28465: NEG
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: LD_INT 2
28476: NEG
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 1
28484: PUSH
28485: LD_INT 1
28487: NEG
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 0
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 2
28505: PUSH
28506: LD_INT 1
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 2
28515: PUSH
28516: LD_INT 2
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 1
28525: PUSH
28526: LD_INT 2
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 0
28535: PUSH
28536: LD_INT 2
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: LD_INT 1
28545: NEG
28546: PUSH
28547: LD_INT 1
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PUSH
28554: LD_INT 2
28556: NEG
28557: PUSH
28558: LD_INT 0
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 2
28567: NEG
28568: PUSH
28569: LD_INT 1
28571: NEG
28572: PUSH
28573: EMPTY
28574: LIST
28575: LIST
28576: PUSH
28577: LD_INT 2
28579: NEG
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28610: LD_ADDR_VAR 0 20
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: LD_INT 0
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 0
28627: PUSH
28628: LD_INT 1
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: LD_INT 0
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: LD_INT 1
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: LD_INT 1
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: PUSH
28670: LD_INT 0
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 1
28679: NEG
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: NEG
28692: PUSH
28693: LD_INT 2
28695: NEG
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 0
28703: PUSH
28704: LD_INT 2
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: LD_INT 1
28717: NEG
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: PUSH
28723: LD_INT 2
28725: PUSH
28726: LD_INT 0
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: LD_INT 1
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: LD_INT 2
28745: PUSH
28746: LD_INT 2
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: LD_INT 2
28758: PUSH
28759: EMPTY
28760: LIST
28761: LIST
28762: PUSH
28763: LD_INT 0
28765: PUSH
28766: LD_INT 2
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 1
28775: NEG
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 2
28786: NEG
28787: PUSH
28788: LD_INT 0
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 2
28797: NEG
28798: PUSH
28799: LD_INT 1
28801: NEG
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: PUSH
28807: LD_INT 2
28809: NEG
28810: PUSH
28811: LD_INT 2
28813: NEG
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: LIST
28839: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28840: LD_ADDR_VAR 0 21
28844: PUSH
28845: LD_INT 0
28847: PUSH
28848: LD_INT 0
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 0
28857: PUSH
28858: LD_INT 1
28860: NEG
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: LD_INT 1
28868: PUSH
28869: LD_INT 0
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: LD_INT 1
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 0
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 1
28898: NEG
28899: PUSH
28900: LD_INT 0
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 1
28909: NEG
28910: PUSH
28911: LD_INT 1
28913: NEG
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: LD_INT 1
28921: NEG
28922: PUSH
28923: LD_INT 2
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 0
28933: PUSH
28934: LD_INT 2
28936: NEG
28937: PUSH
28938: EMPTY
28939: LIST
28940: LIST
28941: PUSH
28942: LD_INT 1
28944: PUSH
28945: LD_INT 1
28947: NEG
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: LD_INT 0
28958: PUSH
28959: EMPTY
28960: LIST
28961: LIST
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PUSH
28973: LD_INT 2
28975: PUSH
28976: LD_INT 2
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: LD_INT 2
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 0
28995: PUSH
28996: LD_INT 2
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: LD_INT 1
29005: NEG
29006: PUSH
29007: LD_INT 1
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 2
29016: NEG
29017: PUSH
29018: LD_INT 0
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: LD_INT 2
29027: NEG
29028: PUSH
29029: LD_INT 1
29031: NEG
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 2
29039: NEG
29040: PUSH
29041: LD_INT 2
29043: NEG
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: LIST
29062: LIST
29063: LIST
29064: LIST
29065: LIST
29066: LIST
29067: LIST
29068: LIST
29069: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29070: LD_ADDR_VAR 0 22
29074: PUSH
29075: LD_INT 0
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 0
29087: PUSH
29088: LD_INT 1
29090: NEG
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 1
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 0
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 1
29128: NEG
29129: PUSH
29130: LD_INT 0
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: NEG
29140: PUSH
29141: LD_INT 1
29143: NEG
29144: PUSH
29145: EMPTY
29146: LIST
29147: LIST
29148: PUSH
29149: LD_INT 1
29151: NEG
29152: PUSH
29153: LD_INT 2
29155: NEG
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 0
29163: PUSH
29164: LD_INT 2
29166: NEG
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 1
29174: PUSH
29175: LD_INT 1
29177: NEG
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PUSH
29203: LD_INT 2
29205: PUSH
29206: LD_INT 2
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 1
29215: PUSH
29216: LD_INT 2
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 0
29225: PUSH
29226: LD_INT 2
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 1
29235: NEG
29236: PUSH
29237: LD_INT 1
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: LD_INT 2
29246: NEG
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 2
29257: NEG
29258: PUSH
29259: LD_INT 1
29261: NEG
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: LD_INT 2
29269: NEG
29270: PUSH
29271: LD_INT 2
29273: NEG
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: LIST
29294: LIST
29295: LIST
29296: LIST
29297: LIST
29298: LIST
29299: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29300: LD_ADDR_VAR 0 23
29304: PUSH
29305: LD_INT 0
29307: PUSH
29308: LD_INT 0
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: LD_INT 0
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: NEG
29359: PUSH
29360: LD_INT 0
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: LD_INT 1
29373: NEG
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 1
29381: NEG
29382: PUSH
29383: LD_INT 2
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 0
29393: PUSH
29394: LD_INT 2
29396: NEG
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 1
29404: PUSH
29405: LD_INT 1
29407: NEG
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 2
29425: PUSH
29426: LD_INT 1
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: PUSH
29433: LD_INT 2
29435: PUSH
29436: LD_INT 2
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 1
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 0
29455: PUSH
29456: LD_INT 2
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: LD_INT 1
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 2
29476: NEG
29477: PUSH
29478: LD_INT 0
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 2
29487: NEG
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 2
29499: NEG
29500: PUSH
29501: LD_INT 2
29503: NEG
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 2
29511: NEG
29512: PUSH
29513: LD_INT 3
29515: NEG
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 1
29523: NEG
29524: PUSH
29525: LD_INT 3
29527: NEG
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 1
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 2
29546: PUSH
29547: LD_INT 1
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: LIST
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: LIST
29568: LIST
29569: LIST
29570: LIST
29571: LIST
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29580: LD_ADDR_VAR 0 24
29584: PUSH
29585: LD_INT 0
29587: PUSH
29588: LD_INT 0
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: PUSH
29609: LD_INT 0
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: PUSH
29619: LD_INT 1
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 1
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 1
29638: NEG
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: NEG
29650: PUSH
29651: LD_INT 1
29653: NEG
29654: PUSH
29655: EMPTY
29656: LIST
29657: LIST
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: LD_INT 2
29665: NEG
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 0
29673: PUSH
29674: LD_INT 2
29676: NEG
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 2
29695: PUSH
29696: LD_INT 0
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 2
29705: PUSH
29706: LD_INT 1
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 2
29715: PUSH
29716: LD_INT 2
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: LD_INT 2
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 0
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: NEG
29746: PUSH
29747: LD_INT 1
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 2
29756: NEG
29757: PUSH
29758: LD_INT 0
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: LD_INT 1
29771: NEG
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: LD_INT 2
29783: NEG
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: LD_INT 2
29794: NEG
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 2
29802: PUSH
29803: LD_INT 1
29805: NEG
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 3
29813: PUSH
29814: LD_INT 1
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 3
29823: PUSH
29824: LD_INT 2
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: LIST
29844: LIST
29845: LIST
29846: LIST
29847: LIST
29848: LIST
29849: LIST
29850: LIST
29851: LIST
29852: LIST
29853: LIST
29854: LIST
29855: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
29856: LD_ADDR_VAR 0 25
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 1
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 0
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: PUSH
29895: LD_INT 1
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: LD_INT 1
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: LD_INT 0
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: NEG
29926: PUSH
29927: LD_INT 1
29929: NEG
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 1
29937: NEG
29938: PUSH
29939: LD_INT 2
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 0
29949: PUSH
29950: LD_INT 2
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 1
29960: PUSH
29961: LD_INT 1
29963: NEG
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 2
29971: PUSH
29972: LD_INT 0
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 2
29991: PUSH
29992: LD_INT 2
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: LD_INT 2
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: LD_INT 2
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: LD_INT 0
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 2
30043: NEG
30044: PUSH
30045: LD_INT 1
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 2
30055: NEG
30056: PUSH
30057: LD_INT 2
30059: NEG
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 3
30067: PUSH
30068: LD_INT 1
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 3
30077: PUSH
30078: LD_INT 2
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 2
30087: PUSH
30088: LD_INT 3
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: PUSH
30098: LD_INT 3
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: LIST
30109: LIST
30110: LIST
30111: LIST
30112: LIST
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30130: LD_ADDR_VAR 0 26
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: LD_INT 0
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 0
30147: PUSH
30148: LD_INT 1
30150: NEG
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 1
30158: PUSH
30159: LD_INT 0
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 1
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: LD_INT 0
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 1
30199: NEG
30200: PUSH
30201: LD_INT 1
30203: NEG
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: LD_INT 1
30211: NEG
30212: PUSH
30213: LD_INT 2
30215: NEG
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 0
30223: PUSH
30224: LD_INT 2
30226: NEG
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PUSH
30243: LD_INT 2
30245: PUSH
30246: LD_INT 0
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PUSH
30253: LD_INT 2
30255: PUSH
30256: LD_INT 1
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 2
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: LD_INT 2
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 2
30306: NEG
30307: PUSH
30308: LD_INT 0
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: PUSH
30315: LD_INT 2
30317: NEG
30318: PUSH
30319: LD_INT 1
30321: NEG
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 2
30329: NEG
30330: PUSH
30331: LD_INT 2
30333: NEG
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 2
30341: PUSH
30342: LD_INT 3
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: LD_INT 3
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 1
30361: NEG
30362: PUSH
30363: LD_INT 2
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 2
30372: NEG
30373: PUSH
30374: LD_INT 1
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30406: LD_ADDR_VAR 0 27
30410: PUSH
30411: LD_INT 0
30413: PUSH
30414: LD_INT 0
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: PUSH
30421: LD_INT 0
30423: PUSH
30424: LD_INT 1
30426: NEG
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 1
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 1
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 0
30454: PUSH
30455: LD_INT 1
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 1
30464: NEG
30465: PUSH
30466: LD_INT 0
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: LD_INT 2
30491: NEG
30492: PUSH
30493: EMPTY
30494: LIST
30495: LIST
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 1
30510: PUSH
30511: LD_INT 1
30513: NEG
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: LD_INT 0
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 2
30541: PUSH
30542: LD_INT 2
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 1
30551: PUSH
30552: LD_INT 2
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: NEG
30572: PUSH
30573: LD_INT 1
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: NEG
30583: PUSH
30584: LD_INT 0
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 2
30593: NEG
30594: PUSH
30595: LD_INT 1
30597: NEG
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 2
30605: NEG
30606: PUSH
30607: LD_INT 2
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: LD_INT 2
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 2
30628: NEG
30629: PUSH
30630: LD_INT 1
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 3
30639: NEG
30640: PUSH
30641: LD_INT 1
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 3
30651: NEG
30652: PUSH
30653: LD_INT 2
30655: NEG
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30686: LD_ADDR_VAR 0 28
30690: PUSH
30691: LD_INT 0
30693: PUSH
30694: LD_INT 0
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: LD_INT 1
30706: NEG
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: LD_INT 0
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 1
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: LD_INT 1
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: LD_INT 2
30771: NEG
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 0
30779: PUSH
30780: LD_INT 2
30782: NEG
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 2
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 2
30821: PUSH
30822: LD_INT 2
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 1
30831: PUSH
30832: LD_INT 2
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 0
30841: PUSH
30842: LD_INT 2
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 1
30851: NEG
30852: PUSH
30853: LD_INT 1
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 2
30862: NEG
30863: PUSH
30864: LD_INT 0
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 2
30873: NEG
30874: PUSH
30875: LD_INT 1
30877: NEG
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 2
30885: NEG
30886: PUSH
30887: LD_INT 2
30889: NEG
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 2
30897: NEG
30898: PUSH
30899: LD_INT 3
30901: NEG
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PUSH
30907: LD_INT 1
30909: NEG
30910: PUSH
30911: LD_INT 3
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 3
30921: NEG
30922: PUSH
30923: LD_INT 1
30925: NEG
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 3
30933: NEG
30934: PUSH
30935: LD_INT 2
30937: NEG
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30968: LD_ADDR_VAR 0 29
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 0
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: LD_INT 1
30988: NEG
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 1
30996: PUSH
30997: LD_INT 0
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: PUSH
31004: LD_INT 1
31006: PUSH
31007: LD_INT 1
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: LD_INT 1
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 1
31026: NEG
31027: PUSH
31028: LD_INT 0
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 1
31037: NEG
31038: PUSH
31039: LD_INT 1
31041: NEG
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 1
31049: NEG
31050: PUSH
31051: LD_INT 2
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: LD_INT 2
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: LD_INT 1
31075: NEG
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 2
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: LD_INT 2
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 1
31103: PUSH
31104: LD_INT 2
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 0
31113: PUSH
31114: LD_INT 2
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 1
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 2
31134: NEG
31135: PUSH
31136: LD_INT 1
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 2
31146: NEG
31147: PUSH
31148: LD_INT 2
31150: NEG
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 2
31158: NEG
31159: PUSH
31160: LD_INT 3
31162: NEG
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: PUSH
31179: LD_INT 3
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: LD_INT 1
31191: PUSH
31192: LD_INT 3
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: NEG
31202: PUSH
31203: LD_INT 2
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 3
31212: NEG
31213: PUSH
31214: LD_INT 2
31216: NEG
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: LIST
31228: LIST
31229: LIST
31230: LIST
31231: LIST
31232: LIST
31233: LIST
31234: LIST
31235: LIST
31236: LIST
31237: LIST
31238: LIST
31239: LIST
31240: LIST
31241: LIST
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31247: LD_ADDR_VAR 0 30
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: LD_INT 0
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 0
31264: PUSH
31265: LD_INT 1
31267: NEG
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 1
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: LD_INT 1
31288: PUSH
31289: EMPTY
31290: LIST
31291: LIST
31292: PUSH
31293: LD_INT 0
31295: PUSH
31296: LD_INT 1
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 1
31305: NEG
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 1
31316: NEG
31317: PUSH
31318: LD_INT 1
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 1
31351: PUSH
31352: LD_INT 1
31354: NEG
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 2
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: PUSH
31373: LD_INT 1
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 2
31382: PUSH
31383: LD_INT 2
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: LD_INT 2
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: LD_INT 1
31406: PUSH
31407: EMPTY
31408: LIST
31409: LIST
31410: PUSH
31411: LD_INT 2
31413: NEG
31414: PUSH
31415: LD_INT 0
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 2
31424: NEG
31425: PUSH
31426: LD_INT 1
31428: NEG
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: PUSH
31434: LD_INT 1
31436: NEG
31437: PUSH
31438: LD_INT 3
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: LD_INT 2
31451: NEG
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 3
31459: PUSH
31460: LD_INT 2
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 2
31469: PUSH
31470: LD_INT 3
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 2
31479: NEG
31480: PUSH
31481: LD_INT 1
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 3
31490: NEG
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31525: LD_ADDR_VAR 0 31
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: LD_INT 0
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 1
31545: NEG
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 1
31553: PUSH
31554: LD_INT 0
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 1
31563: PUSH
31564: LD_INT 1
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 0
31573: PUSH
31574: LD_INT 1
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: NEG
31584: PUSH
31585: LD_INT 0
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 1
31594: NEG
31595: PUSH
31596: LD_INT 1
31598: NEG
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 2
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 2
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 3
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 2
31726: PUSH
31727: LD_INT 1
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 3
31737: PUSH
31738: LD_INT 1
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 1
31747: PUSH
31748: LD_INT 3
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: LD_INT 2
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 3
31768: NEG
31769: PUSH
31770: LD_INT 2
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: LIST
31784: LIST
31785: LIST
31786: LIST
31787: LIST
31788: LIST
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31803: LD_ADDR_VAR 0 32
31807: PUSH
31808: LD_INT 0
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: LD_INT 1
31823: NEG
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 1
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 1
31841: PUSH
31842: LD_INT 1
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 0
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 1
31861: NEG
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 1
31872: NEG
31873: PUSH
31874: LD_INT 1
31876: NEG
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 2
31888: NEG
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: LD_INT 2
31899: NEG
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 2
31928: PUSH
31929: LD_INT 2
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 0
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 0
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: LD_INT 1
31984: NEG
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 1
31992: NEG
31993: PUSH
31994: LD_INT 3
31996: NEG
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 1
32004: PUSH
32005: LD_INT 2
32007: NEG
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 3
32015: PUSH
32016: LD_INT 2
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 2
32025: PUSH
32026: LD_INT 3
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: LD_INT 1
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: LD_INT 3
32046: NEG
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: LIST
32072: LIST
32073: LIST
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32081: LD_ADDR_VAR 0 33
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 1
32101: NEG
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: LD_INT 0
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: LD_INT 1
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 0
32129: PUSH
32130: LD_INT 1
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 1
32150: NEG
32151: PUSH
32152: LD_INT 1
32154: NEG
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 1
32162: NEG
32163: PUSH
32164: LD_INT 2
32166: NEG
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 1
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 2
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 1
32205: PUSH
32206: LD_INT 2
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 0
32215: PUSH
32216: LD_INT 2
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: NEG
32226: PUSH
32227: LD_INT 1
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PUSH
32234: LD_INT 2
32236: NEG
32237: PUSH
32238: LD_INT 0
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 2
32247: NEG
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 2
32259: NEG
32260: PUSH
32261: LD_INT 2
32263: NEG
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 2
32271: NEG
32272: PUSH
32273: LD_INT 3
32275: NEG
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: PUSH
32281: LD_INT 2
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 3
32294: PUSH
32295: LD_INT 1
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 1
32314: NEG
32315: PUSH
32316: LD_INT 2
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 3
32325: NEG
32326: PUSH
32327: LD_INT 2
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: LIST
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32360: LD_ADDR_VAR 0 34
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: LD_INT 0
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: NEG
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 1
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 0
32408: PUSH
32409: LD_INT 1
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: LD_INT 0
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: LD_INT 1
32433: NEG
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: NEG
32442: PUSH
32443: LD_INT 2
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 0
32453: PUSH
32454: LD_INT 2
32456: NEG
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 2
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: LD_INT 2
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 1
32495: PUSH
32496: LD_INT 2
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 1
32505: NEG
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 2
32516: NEG
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 2
32527: NEG
32528: PUSH
32529: LD_INT 1
32531: NEG
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 2
32539: NEG
32540: PUSH
32541: LD_INT 2
32543: NEG
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 3
32555: NEG
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: PUSH
32564: LD_INT 2
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 3
32574: PUSH
32575: LD_INT 2
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 2
32584: PUSH
32585: LD_INT 3
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 2
32594: NEG
32595: PUSH
32596: LD_INT 1
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 3
32605: NEG
32606: PUSH
32607: LD_INT 1
32609: NEG
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32640: LD_ADDR_VAR 0 35
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: LD_INT 0
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 0
32657: PUSH
32658: LD_INT 1
32660: NEG
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 1
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 1
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PUSH
32696: LD_INT 1
32698: NEG
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 1
32709: NEG
32710: PUSH
32711: LD_INT 1
32713: NEG
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 2
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 2
32731: NEG
32732: PUSH
32733: LD_INT 1
32735: NEG
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: LIST
32750: LIST
32751: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32752: LD_ADDR_VAR 0 36
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: LD_INT 0
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 1
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: LD_INT 1
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: NEG
32822: PUSH
32823: LD_INT 1
32825: NEG
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 1
32833: NEG
32834: PUSH
32835: LD_INT 2
32837: NEG
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: LD_INT 2
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32864: LD_ADDR_VAR 0 37
32868: PUSH
32869: LD_INT 0
32871: PUSH
32872: LD_INT 0
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: LD_INT 1
32884: NEG
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: LD_INT 0
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: LD_INT 1
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: LD_INT 0
32912: PUSH
32913: LD_INT 1
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 1
32922: NEG
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: PUSH
32935: LD_INT 1
32937: NEG
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: LD_INT 1
32948: NEG
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: LD_INT 1
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32976: LD_ADDR_VAR 0 38
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 0
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: PUSH
33002: LD_INT 1
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 1
33014: PUSH
33015: LD_INT 1
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 1
33034: NEG
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: NEG
33046: PUSH
33047: LD_INT 1
33049: NEG
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 2
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: NEG
33068: PUSH
33069: LD_INT 1
33071: NEG
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33088: LD_ADDR_VAR 0 39
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: LD_INT 0
33098: PUSH
33099: EMPTY
33100: LIST
33101: LIST
33102: PUSH
33103: LD_INT 0
33105: PUSH
33106: LD_INT 1
33108: NEG
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 1
33116: PUSH
33117: LD_INT 0
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: PUSH
33127: LD_INT 1
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 0
33136: PUSH
33137: LD_INT 1
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 1
33146: NEG
33147: PUSH
33148: LD_INT 0
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: LD_INT 2
33173: NEG
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 1
33181: PUSH
33182: LD_INT 2
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33200: LD_ADDR_VAR 0 40
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 0
33217: PUSH
33218: LD_INT 1
33220: NEG
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 1
33228: PUSH
33229: LD_INT 0
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 1
33238: PUSH
33239: LD_INT 1
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 0
33248: PUSH
33249: LD_INT 1
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: NEG
33259: PUSH
33260: LD_INT 0
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 1
33269: NEG
33270: PUSH
33271: LD_INT 1
33273: NEG
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 1
33284: NEG
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 1
33292: NEG
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33312: LD_ADDR_VAR 0 41
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: LD_INT 0
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: LD_INT 1
33332: NEG
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 1
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: NEG
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 1
33393: NEG
33394: PUSH
33395: LD_INT 2
33397: NEG
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: LD_INT 1
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 2
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 2
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 2
33436: PUSH
33437: LD_INT 2
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 1
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 1
33456: NEG
33457: PUSH
33458: LD_INT 1
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 2
33467: NEG
33468: PUSH
33469: LD_INT 0
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: NEG
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 2
33490: NEG
33491: PUSH
33492: LD_INT 2
33494: NEG
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 2
33502: NEG
33503: PUSH
33504: LD_INT 3
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 1
33517: NEG
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 3
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 3
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 3
33545: PUSH
33546: LD_INT 2
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 3
33555: PUSH
33556: LD_INT 3
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: PUSH
33566: LD_INT 3
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 2
33575: NEG
33576: PUSH
33577: LD_INT 1
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 3
33586: NEG
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 3
33597: NEG
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 3
33609: NEG
33610: PUSH
33611: LD_INT 2
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 3
33621: NEG
33622: PUSH
33623: LD_INT 3
33625: NEG
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33662: LD_ADDR_VAR 0 42
33666: PUSH
33667: LD_INT 0
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 1
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: NEG
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 1
33731: NEG
33732: PUSH
33733: LD_INT 1
33735: NEG
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 1
33743: NEG
33744: PUSH
33745: LD_INT 2
33747: NEG
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 2
33758: NEG
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 2
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: LD_INT 2
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 0
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 2
33828: NEG
33829: PUSH
33830: LD_INT 1
33832: NEG
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: NEG
33841: PUSH
33842: LD_INT 2
33844: NEG
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: NEG
33853: PUSH
33854: LD_INT 3
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: LD_INT 3
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 3
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 2
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 3
33898: PUSH
33899: LD_INT 2
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 3
33908: PUSH
33909: LD_INT 3
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 3
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 3
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 2
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 3
33959: NEG
33960: PUSH
33961: LD_INT 2
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 3
33971: NEG
33972: PUSH
33973: LD_INT 3
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34012: LD_ADDR_VAR 0 43
34016: PUSH
34017: LD_INT 0
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 0
34029: PUSH
34030: LD_INT 1
34032: NEG
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 1
34040: PUSH
34041: LD_INT 0
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 1
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: LD_INT 1
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: LD_INT 0
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: NEG
34082: PUSH
34083: LD_INT 1
34085: NEG
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: LD_INT 2
34097: NEG
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 0
34105: PUSH
34106: LD_INT 2
34108: NEG
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 1
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 2
34127: PUSH
34128: LD_INT 0
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: LD_INT 2
34137: PUSH
34138: LD_INT 1
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: LD_INT 2
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 0
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: LD_INT 1
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 2
34178: NEG
34179: PUSH
34180: LD_INT 0
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 2
34189: NEG
34190: PUSH
34191: LD_INT 1
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 3
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: LD_INT 3
34216: NEG
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: LD_INT 2
34227: NEG
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 2
34235: PUSH
34236: LD_INT 1
34238: NEG
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 3
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 3
34256: PUSH
34257: LD_INT 1
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 3
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 3
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 2
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 3
34308: NEG
34309: PUSH
34310: LD_INT 0
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 3
34319: NEG
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34360: LD_ADDR_VAR 0 44
34364: PUSH
34365: LD_INT 0
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 0
34377: PUSH
34378: LD_INT 1
34380: NEG
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 1
34388: PUSH
34389: LD_INT 0
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 0
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 1
34429: NEG
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 2
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 1
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 2
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 2
34526: NEG
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: LD_INT 2
34542: NEG
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 2
34550: NEG
34551: PUSH
34552: LD_INT 3
34554: NEG
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 3
34573: PUSH
34574: LD_INT 0
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 3
34583: PUSH
34584: LD_INT 1
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 3
34593: PUSH
34594: LD_INT 2
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 3
34603: PUSH
34604: LD_INT 3
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 2
34613: PUSH
34614: LD_INT 3
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 2
34623: NEG
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 3
34634: NEG
34635: PUSH
34636: LD_INT 0
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 3
34645: NEG
34646: PUSH
34647: LD_INT 1
34649: NEG
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 3
34657: NEG
34658: PUSH
34659: LD_INT 2
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 3
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34710: LD_ADDR_VAR 0 45
34714: PUSH
34715: LD_INT 0
34717: PUSH
34718: LD_INT 0
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 0
34727: PUSH
34728: LD_INT 1
34730: NEG
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 1
34738: PUSH
34739: LD_INT 0
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: PUSH
34749: LD_INT 1
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: LD_INT 1
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: NEG
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: LD_INT 2
34806: NEG
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 1
34814: PUSH
34815: LD_INT 1
34817: NEG
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 2
34835: PUSH
34836: LD_INT 2
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 1
34845: PUSH
34846: LD_INT 2
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: LD_INT 2
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: NEG
34866: PUSH
34867: LD_INT 1
34869: PUSH
34870: EMPTY
34871: LIST
34872: LIST
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 2
34888: NEG
34889: PUSH
34890: LD_INT 2
34892: NEG
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 2
34900: NEG
34901: PUSH
34902: LD_INT 3
34904: NEG
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: LD_INT 3
34916: NEG
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 0
34924: PUSH
34925: LD_INT 3
34927: NEG
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: LD_INT 1
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 3
34946: PUSH
34947: LD_INT 2
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 3
34956: PUSH
34957: LD_INT 3
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 2
34966: PUSH
34967: LD_INT 3
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 1
34976: PUSH
34977: LD_INT 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PUSH
34984: LD_INT 0
34986: PUSH
34987: LD_INT 3
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 1
34996: NEG
34997: PUSH
34998: LD_INT 2
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 3
35007: NEG
35008: PUSH
35009: LD_INT 2
35011: NEG
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 3
35019: NEG
35020: PUSH
35021: LD_INT 3
35023: NEG
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35060: LD_ADDR_VAR 0 46
35064: PUSH
35065: LD_INT 0
35067: PUSH
35068: LD_INT 0
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: EMPTY
35083: LIST
35084: LIST
35085: PUSH
35086: LD_INT 1
35088: PUSH
35089: LD_INT 0
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 1
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: LD_INT 0
35108: PUSH
35109: LD_INT 1
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 1
35118: NEG
35119: PUSH
35120: LD_INT 0
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: NEG
35130: PUSH
35131: LD_INT 1
35133: NEG
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 1
35141: NEG
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: LD_INT 2
35156: NEG
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 1
35164: PUSH
35165: LD_INT 1
35167: NEG
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 2
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 2
35185: PUSH
35186: LD_INT 1
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: PUSH
35196: LD_INT 2
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: LD_INT 2
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 1
35215: NEG
35216: PUSH
35217: LD_INT 1
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 2
35226: NEG
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 2
35237: NEG
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 1
35249: NEG
35250: PUSH
35251: LD_INT 3
35253: NEG
35254: PUSH
35255: EMPTY
35256: LIST
35257: LIST
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 2
35275: NEG
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 2
35283: PUSH
35284: LD_INT 1
35286: NEG
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 3
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 3
35304: PUSH
35305: LD_INT 1
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 3
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 3
35356: NEG
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 3
35367: NEG
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35408: LD_ADDR_VAR 0 47
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: LD_INT 0
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: LD_INT 1
35428: NEG
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 0
35456: PUSH
35457: LD_INT 1
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 1
35466: NEG
35467: PUSH
35468: LD_INT 0
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: LD_INT 1
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: LD_INT 2
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 0
35501: PUSH
35502: LD_INT 2
35504: NEG
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: LD_INT 1
35515: NEG
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 2
35523: NEG
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: LD_INT 2
35535: NEG
35536: PUSH
35537: LD_INT 2
35539: NEG
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: LIST
35557: LIST
35558: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35559: LD_ADDR_VAR 0 48
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 0
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: LD_INT 0
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 0
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: LD_INT 0
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 1
35666: NEG
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 2
35684: PUSH
35685: LD_INT 1
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: LIST
35696: LIST
35697: LIST
35698: LIST
35699: LIST
35700: LIST
35701: LIST
35702: LIST
35703: LIST
35704: LIST
35705: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
35706: LD_ADDR_VAR 0 49
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: LD_INT 0
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 1
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 1
35744: PUSH
35745: LD_INT 1
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 0
35754: PUSH
35755: LD_INT 1
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: LD_INT 0
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 1
35775: NEG
35776: PUSH
35777: LD_INT 1
35779: NEG
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 2
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 2
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 2
35818: PUSH
35819: LD_INT 2
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 1
35828: PUSH
35829: LD_INT 2
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
35850: LD_ADDR_VAR 0 50
35854: PUSH
35855: LD_INT 0
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 0
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 1
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: NEG
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: LD_INT 1
35923: NEG
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: LD_INT 1
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 2
35941: PUSH
35942: LD_INT 2
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: LD_INT 2
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: LD_INT 1
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35994: LD_ADDR_VAR 0 51
35998: PUSH
35999: LD_INT 0
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 1
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 1
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 1
36032: PUSH
36033: LD_INT 1
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 0
36042: PUSH
36043: LD_INT 1
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 1
36052: NEG
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: LD_INT 1
36067: NEG
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: LD_INT 2
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 0
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 1
36095: NEG
36096: PUSH
36097: LD_INT 1
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 2
36106: NEG
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 2
36117: NEG
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36141: LD_ADDR_VAR 0 52
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 0
36158: PUSH
36159: LD_INT 1
36161: NEG
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 1
36169: PUSH
36170: LD_INT 0
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 1
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 0
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 1
36199: NEG
36200: PUSH
36201: LD_INT 0
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 1
36210: NEG
36211: PUSH
36212: LD_INT 1
36214: NEG
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 1
36222: NEG
36223: PUSH
36224: LD_INT 2
36226: NEG
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: NEG
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 2
36245: NEG
36246: PUSH
36247: LD_INT 0
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 2
36256: NEG
36257: PUSH
36258: LD_INT 1
36260: NEG
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 2
36268: NEG
36269: PUSH
36270: LD_INT 2
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36292: LD_ADDR_VAR 0 53
36296: PUSH
36297: LD_INT 0
36299: PUSH
36300: LD_INT 0
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 0
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: LD_INT 0
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 1
36330: PUSH
36331: LD_INT 1
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: LD_INT 0
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: LD_INT 0
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 1
36361: NEG
36362: PUSH
36363: LD_INT 1
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 2
36377: NEG
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 0
36385: PUSH
36386: LD_INT 2
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 1
36396: PUSH
36397: LD_INT 1
36399: NEG
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: LD_INT 1
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 2
36427: PUSH
36428: LD_INT 2
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: PUSH
36438: LD_INT 2
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 0
36447: PUSH
36448: LD_INT 2
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: NEG
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: NEG
36469: PUSH
36470: LD_INT 0
36472: PUSH
36473: EMPTY
36474: LIST
36475: LIST
36476: PUSH
36477: LD_INT 2
36479: NEG
36480: PUSH
36481: LD_INT 1
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 2
36491: NEG
36492: PUSH
36493: LD_INT 2
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36522: LD_ADDR_VAR 0 54
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 0
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 0
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 1
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: LD_INT 1
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 1
36580: NEG
36581: PUSH
36582: LD_INT 0
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: LD_INT 1
36595: NEG
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: LD_INT 2
36607: NEG
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 0
36615: PUSH
36616: LD_INT 2
36618: NEG
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 2
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 2
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 1
36667: PUSH
36668: LD_INT 2
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: LD_INT 2
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 2
36698: NEG
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 2
36709: NEG
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 2
36721: NEG
36722: PUSH
36723: LD_INT 2
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: EMPTY
36732: LIST
36733: LIST
36734: LIST
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36752: LD_ADDR_VAR 0 55
36756: PUSH
36757: LD_INT 0
36759: PUSH
36760: LD_INT 0
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 0
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 1
36780: PUSH
36781: LD_INT 0
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 0
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 1
36810: NEG
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 1
36821: NEG
36822: PUSH
36823: LD_INT 1
36825: NEG
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: LD_INT 1
36833: NEG
36834: PUSH
36835: LD_INT 2
36837: NEG
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 0
36845: PUSH
36846: LD_INT 2
36848: NEG
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 1
36856: PUSH
36857: LD_INT 1
36859: NEG
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 2
36867: PUSH
36868: LD_INT 0
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: LD_INT 2
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 1
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 2
36928: NEG
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 2
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 2
36951: NEG
36952: PUSH
36953: LD_INT 2
36955: NEG
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36982: LD_ADDR_VAR 0 56
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: LD_INT 0
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 0
36999: PUSH
37000: LD_INT 1
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 1
37020: PUSH
37021: LD_INT 1
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 0
37030: PUSH
37031: LD_INT 1
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 1
37051: NEG
37052: PUSH
37053: LD_INT 1
37055: NEG
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: LD_INT 2
37067: NEG
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 0
37075: PUSH
37076: LD_INT 2
37078: NEG
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 1
37086: PUSH
37087: LD_INT 1
37089: NEG
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 2
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: LD_INT 1
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: LD_INT 2
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 1
37127: PUSH
37128: LD_INT 2
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 0
37137: PUSH
37138: LD_INT 2
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 1
37147: NEG
37148: PUSH
37149: LD_INT 1
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: NEG
37159: PUSH
37160: LD_INT 0
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 1
37173: NEG
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 2
37181: NEG
37182: PUSH
37183: LD_INT 2
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: LIST
37199: LIST
37200: LIST
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37212: LD_ADDR_VAR 0 57
37216: PUSH
37217: LD_INT 0
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 0
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 1
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: PUSH
37251: LD_INT 1
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 0
37260: PUSH
37261: LD_INT 1
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: NEG
37271: PUSH
37272: LD_INT 0
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 1
37281: NEG
37282: PUSH
37283: LD_INT 1
37285: NEG
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 1
37293: NEG
37294: PUSH
37295: LD_INT 2
37297: NEG
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 0
37305: PUSH
37306: LD_INT 2
37308: NEG
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 1
37316: PUSH
37317: LD_INT 1
37319: NEG
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 2
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 2
37337: PUSH
37338: LD_INT 1
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: LD_INT 2
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 1
37357: PUSH
37358: LD_INT 2
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 0
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 1
37377: NEG
37378: PUSH
37379: LD_INT 1
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 2
37388: NEG
37389: PUSH
37390: LD_INT 0
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 1
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 2
37411: NEG
37412: PUSH
37413: LD_INT 2
37415: NEG
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: LIST
37439: LIST
37440: LIST
37441: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37442: LD_ADDR_VAR 0 58
37446: PUSH
37447: LD_INT 0
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 0
37459: PUSH
37460: LD_INT 1
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 1
37470: PUSH
37471: LD_INT 0
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: LD_INT 1
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 0
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 0
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: NEG
37524: PUSH
37525: LD_INT 2
37527: NEG
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 0
37535: PUSH
37536: LD_INT 2
37538: NEG
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 1
37546: PUSH
37547: LD_INT 1
37549: NEG
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: PUSH
37555: LD_INT 2
37557: PUSH
37558: LD_INT 0
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: LD_INT 2
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 2
37577: PUSH
37578: LD_INT 2
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 0
37597: PUSH
37598: LD_INT 2
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 1
37607: NEG
37608: PUSH
37609: LD_INT 1
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: LD_INT 0
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: PUSH
37627: LD_INT 2
37629: NEG
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 2
37641: NEG
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: LIST
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37672: LD_ADDR_VAR 0 59
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 0
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: LD_INT 0
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 1
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 0
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 1
37730: NEG
37731: PUSH
37732: LD_INT 0
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: LD_INT 1
37745: NEG
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: LIST
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37760: LD_ADDR_VAR 0 60
37764: PUSH
37765: LD_INT 0
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: LD_INT 1
37780: NEG
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 1
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: LD_INT 1
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 0
37808: PUSH
37809: LD_INT 1
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: NEG
37819: PUSH
37820: LD_INT 0
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 1
37829: NEG
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37848: LD_ADDR_VAR 0 61
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: LD_INT 0
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 0
37865: PUSH
37866: LD_INT 1
37868: NEG
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 1
37886: PUSH
37887: LD_INT 1
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 0
37896: PUSH
37897: LD_INT 1
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: LD_INT 1
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37936: LD_ADDR_VAR 0 62
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: LD_INT 1
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 1
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 1
37994: NEG
37995: PUSH
37996: LD_INT 0
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38024: LD_ADDR_VAR 0 63
38028: PUSH
38029: LD_INT 0
38031: PUSH
38032: LD_INT 0
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 0
38041: PUSH
38042: LD_INT 1
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 1
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: LD_INT 1
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: LD_INT 1
38082: NEG
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: LD_INT 1
38097: NEG
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38112: LD_ADDR_VAR 0 64
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: PUSH
38151: LD_INT 1
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 0
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 1
38170: NEG
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 1
38181: NEG
38182: PUSH
38183: LD_INT 1
38185: NEG
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: ST_TO_ADDR
// end ; 1 :
38200: GO 44097
38202: LD_INT 1
38204: DOUBLE
38205: EQUAL
38206: IFTRUE 38210
38208: GO 40833
38210: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38211: LD_ADDR_VAR 0 11
38215: PUSH
38216: LD_INT 1
38218: NEG
38219: PUSH
38220: LD_INT 3
38222: NEG
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 0
38230: PUSH
38231: LD_INT 3
38233: NEG
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: LIST
38254: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38255: LD_ADDR_VAR 0 12
38259: PUSH
38260: LD_INT 2
38262: PUSH
38263: LD_INT 1
38265: NEG
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 3
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 3
38283: PUSH
38284: LD_INT 1
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: LIST
38295: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38296: LD_ADDR_VAR 0 13
38300: PUSH
38301: LD_INT 3
38303: PUSH
38304: LD_INT 2
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 3
38313: PUSH
38314: LD_INT 3
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 2
38323: PUSH
38324: LD_INT 3
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: LIST
38335: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38336: LD_ADDR_VAR 0 14
38340: PUSH
38341: LD_INT 1
38343: PUSH
38344: LD_INT 3
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: LD_INT 3
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: LIST
38376: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38377: LD_ADDR_VAR 0 15
38381: PUSH
38382: LD_INT 2
38384: NEG
38385: PUSH
38386: LD_INT 1
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 3
38395: NEG
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 3
38406: NEG
38407: PUSH
38408: LD_INT 1
38410: NEG
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: LIST
38420: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38421: LD_ADDR_VAR 0 16
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: LD_INT 3
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 3
38440: NEG
38441: PUSH
38442: LD_INT 2
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 3
38452: NEG
38453: PUSH
38454: LD_INT 3
38456: NEG
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: LIST
38466: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38467: LD_ADDR_VAR 0 17
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: LD_INT 3
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: LD_INT 3
38489: NEG
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: LD_INT 2
38500: NEG
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: LIST
38510: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38511: LD_ADDR_VAR 0 18
38515: PUSH
38516: LD_INT 2
38518: PUSH
38519: LD_INT 1
38521: NEG
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 3
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 3
38539: PUSH
38540: LD_INT 1
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: LIST
38551: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38552: LD_ADDR_VAR 0 19
38556: PUSH
38557: LD_INT 3
38559: PUSH
38560: LD_INT 2
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 3
38569: PUSH
38570: LD_INT 3
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 2
38579: PUSH
38580: LD_INT 3
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: LIST
38591: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38592: LD_ADDR_VAR 0 20
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: LD_INT 3
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 0
38609: PUSH
38610: LD_INT 3
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: NEG
38620: PUSH
38621: LD_INT 2
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: LIST
38632: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38633: LD_ADDR_VAR 0 21
38637: PUSH
38638: LD_INT 2
38640: NEG
38641: PUSH
38642: LD_INT 1
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 3
38662: NEG
38663: PUSH
38664: LD_INT 1
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: LIST
38676: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38677: LD_ADDR_VAR 0 22
38681: PUSH
38682: LD_INT 2
38684: NEG
38685: PUSH
38686: LD_INT 3
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 3
38696: NEG
38697: PUSH
38698: LD_INT 2
38700: NEG
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 3
38708: NEG
38709: PUSH
38710: LD_INT 3
38712: NEG
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: LIST
38722: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
38723: LD_ADDR_VAR 0 23
38727: PUSH
38728: LD_INT 0
38730: PUSH
38731: LD_INT 3
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: LD_INT 4
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 1
38753: PUSH
38754: LD_INT 3
38756: NEG
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: LIST
38766: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
38767: LD_ADDR_VAR 0 24
38771: PUSH
38772: LD_INT 3
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 3
38784: PUSH
38785: LD_INT 1
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 4
38795: PUSH
38796: LD_INT 1
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: LIST
38807: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
38808: LD_ADDR_VAR 0 25
38812: PUSH
38813: LD_INT 3
38815: PUSH
38816: LD_INT 3
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 4
38825: PUSH
38826: LD_INT 3
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 3
38835: PUSH
38836: LD_INT 4
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: LIST
38847: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
38848: LD_ADDR_VAR 0 26
38852: PUSH
38853: LD_INT 0
38855: PUSH
38856: LD_INT 3
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 1
38865: PUSH
38866: LD_INT 4
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 1
38875: NEG
38876: PUSH
38877: LD_INT 3
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: LIST
38888: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
38889: LD_ADDR_VAR 0 27
38893: PUSH
38894: LD_INT 3
38896: NEG
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 3
38907: NEG
38908: PUSH
38909: LD_INT 1
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 4
38918: NEG
38919: PUSH
38920: LD_INT 1
38922: NEG
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: LIST
38932: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
38933: LD_ADDR_VAR 0 28
38937: PUSH
38938: LD_INT 3
38940: NEG
38941: PUSH
38942: LD_INT 3
38944: NEG
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: NEG
38953: PUSH
38954: LD_INT 4
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 4
38964: NEG
38965: PUSH
38966: LD_INT 3
38968: NEG
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
38979: LD_ADDR_VAR 0 29
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: LD_INT 3
38990: NEG
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 0
38998: PUSH
38999: LD_INT 3
39001: NEG
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 1
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: LD_INT 4
39024: NEG
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 0
39032: PUSH
39033: LD_INT 4
39035: NEG
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: LD_INT 1
39043: PUSH
39044: LD_INT 3
39046: NEG
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 1
39054: NEG
39055: PUSH
39056: LD_INT 5
39058: NEG
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: LD_INT 5
39069: NEG
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 1
39077: PUSH
39078: LD_INT 4
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: LD_INT 6
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: LD_INT 6
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 5
39114: NEG
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: LIST
39131: LIST
39132: LIST
39133: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39134: LD_ADDR_VAR 0 30
39138: PUSH
39139: LD_INT 2
39141: PUSH
39142: LD_INT 1
39144: NEG
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 3
39152: PUSH
39153: LD_INT 0
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 3
39162: PUSH
39163: LD_INT 1
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 3
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 4
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 4
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 4
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 5
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 5
39224: PUSH
39225: LD_INT 1
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 5
39234: PUSH
39235: LD_INT 1
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 6
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 6
39255: PUSH
39256: LD_INT 1
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39277: LD_ADDR_VAR 0 31
39281: PUSH
39282: LD_INT 3
39284: PUSH
39285: LD_INT 2
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 3
39294: PUSH
39295: LD_INT 3
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 2
39304: PUSH
39305: LD_INT 3
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 4
39314: PUSH
39315: LD_INT 3
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 4
39324: PUSH
39325: LD_INT 4
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 3
39334: PUSH
39335: LD_INT 4
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 5
39344: PUSH
39345: LD_INT 4
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 5
39354: PUSH
39355: LD_INT 5
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 4
39364: PUSH
39365: LD_INT 5
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 6
39374: PUSH
39375: LD_INT 5
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 6
39384: PUSH
39385: LD_INT 6
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 5
39394: PUSH
39395: LD_INT 6
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39416: LD_ADDR_VAR 0 32
39420: PUSH
39421: LD_INT 1
39423: PUSH
39424: LD_INT 3
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: LD_INT 3
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: NEG
39444: PUSH
39445: LD_INT 2
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 1
39454: PUSH
39455: LD_INT 4
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 0
39464: PUSH
39465: LD_INT 4
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: LD_INT 3
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 1
39485: PUSH
39486: LD_INT 5
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: LD_INT 5
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 1
39505: NEG
39506: PUSH
39507: LD_INT 4
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: PUSH
39517: LD_INT 6
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: LD_INT 6
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 1
39536: NEG
39537: PUSH
39538: LD_INT 5
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: LIST
39557: LIST
39558: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39559: LD_ADDR_VAR 0 33
39563: PUSH
39564: LD_INT 2
39566: NEG
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 3
39577: NEG
39578: PUSH
39579: LD_INT 0
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 3
39588: NEG
39589: PUSH
39590: LD_INT 1
39592: NEG
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PUSH
39598: LD_INT 3
39600: NEG
39601: PUSH
39602: LD_INT 1
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 4
39611: NEG
39612: PUSH
39613: LD_INT 0
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 4
39622: NEG
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: EMPTY
39629: LIST
39630: LIST
39631: PUSH
39632: LD_INT 4
39634: NEG
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 5
39645: NEG
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 5
39656: NEG
39657: PUSH
39658: LD_INT 1
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 5
39668: NEG
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 6
39679: NEG
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 6
39690: NEG
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
39714: LD_ADDR_VAR 0 34
39718: PUSH
39719: LD_INT 2
39721: NEG
39722: PUSH
39723: LD_INT 3
39725: NEG
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 3
39733: NEG
39734: PUSH
39735: LD_INT 2
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 3
39745: NEG
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 3
39757: NEG
39758: PUSH
39759: LD_INT 4
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 4
39769: NEG
39770: PUSH
39771: LD_INT 3
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 4
39781: NEG
39782: PUSH
39783: LD_INT 4
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 4
39793: NEG
39794: PUSH
39795: LD_INT 5
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 5
39805: NEG
39806: PUSH
39807: LD_INT 4
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 5
39817: NEG
39818: PUSH
39819: LD_INT 5
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 5
39829: NEG
39830: PUSH
39831: LD_INT 6
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 6
39841: NEG
39842: PUSH
39843: LD_INT 5
39845: NEG
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PUSH
39851: LD_INT 6
39853: NEG
39854: PUSH
39855: LD_INT 6
39857: NEG
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
39877: LD_ADDR_VAR 0 41
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: LD_INT 2
39887: NEG
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 1
39895: NEG
39896: PUSH
39897: LD_INT 3
39899: NEG
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 1
39907: PUSH
39908: LD_INT 2
39910: NEG
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
39921: LD_ADDR_VAR 0 42
39925: PUSH
39926: LD_INT 2
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 2
39938: PUSH
39939: LD_INT 1
39941: NEG
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: LD_INT 3
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
39962: LD_ADDR_VAR 0 43
39966: PUSH
39967: LD_INT 2
39969: PUSH
39970: LD_INT 2
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 3
39979: PUSH
39980: LD_INT 2
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 2
39989: PUSH
39990: LD_INT 3
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: LIST
40001: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40002: LD_ADDR_VAR 0 44
40006: PUSH
40007: LD_INT 0
40009: PUSH
40010: LD_INT 2
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 1
40019: PUSH
40020: LD_INT 3
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 1
40029: NEG
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: LIST
40042: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40043: LD_ADDR_VAR 0 45
40047: PUSH
40048: LD_INT 2
40050: NEG
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 2
40061: NEG
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 3
40072: NEG
40073: PUSH
40074: LD_INT 1
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: LIST
40086: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40087: LD_ADDR_VAR 0 46
40091: PUSH
40092: LD_INT 2
40094: NEG
40095: PUSH
40096: LD_INT 2
40098: NEG
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 2
40106: NEG
40107: PUSH
40108: LD_INT 3
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 3
40118: NEG
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: LIST
40132: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40133: LD_ADDR_VAR 0 47
40137: PUSH
40138: LD_INT 2
40140: NEG
40141: PUSH
40142: LD_INT 3
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 1
40152: NEG
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40166: LD_ADDR_VAR 0 48
40170: PUSH
40171: LD_INT 1
40173: PUSH
40174: LD_INT 2
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 2
40184: PUSH
40185: LD_INT 1
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40197: LD_ADDR_VAR 0 49
40201: PUSH
40202: LD_INT 3
40204: PUSH
40205: LD_INT 1
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 3
40214: PUSH
40215: LD_INT 2
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40226: LD_ADDR_VAR 0 50
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 3
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 3
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40255: LD_ADDR_VAR 0 51
40259: PUSH
40260: LD_INT 1
40262: NEG
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 2
40273: NEG
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40286: LD_ADDR_VAR 0 52
40290: PUSH
40291: LD_INT 3
40293: NEG
40294: PUSH
40295: LD_INT 1
40297: NEG
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: LD_INT 3
40305: NEG
40306: PUSH
40307: LD_INT 2
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40319: LD_ADDR_VAR 0 53
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: LD_INT 3
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: LD_INT 3
40341: NEG
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 1
40349: PUSH
40350: LD_INT 2
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: LIST
40362: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40363: LD_ADDR_VAR 0 54
40367: PUSH
40368: LD_INT 2
40370: PUSH
40371: LD_INT 1
40373: NEG
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: LD_INT 3
40381: PUSH
40382: LD_INT 0
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 3
40391: PUSH
40392: LD_INT 1
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: LIST
40403: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40404: LD_ADDR_VAR 0 55
40408: PUSH
40409: LD_INT 3
40411: PUSH
40412: LD_INT 2
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 3
40421: PUSH
40422: LD_INT 3
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 2
40431: PUSH
40432: LD_INT 3
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: LIST
40443: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40444: LD_ADDR_VAR 0 56
40448: PUSH
40449: LD_INT 1
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 0
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: LD_INT 2
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: LIST
40484: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40485: LD_ADDR_VAR 0 57
40489: PUSH
40490: LD_INT 2
40492: NEG
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 3
40503: NEG
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 3
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: NEG
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: LIST
40528: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40529: LD_ADDR_VAR 0 58
40533: PUSH
40534: LD_INT 2
40536: NEG
40537: PUSH
40538: LD_INT 3
40540: NEG
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 3
40548: NEG
40549: PUSH
40550: LD_INT 2
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 3
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: LIST
40574: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40575: LD_ADDR_VAR 0 59
40579: PUSH
40580: LD_INT 1
40582: NEG
40583: PUSH
40584: LD_INT 2
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 0
40594: PUSH
40595: LD_INT 2
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 1
40605: PUSH
40606: LD_INT 1
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: LIST
40618: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40619: LD_ADDR_VAR 0 60
40623: PUSH
40624: LD_INT 1
40626: PUSH
40627: LD_INT 1
40629: NEG
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 2
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 2
40647: PUSH
40648: LD_INT 1
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: LIST
40659: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40660: LD_ADDR_VAR 0 61
40664: PUSH
40665: LD_INT 2
40667: PUSH
40668: LD_INT 1
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 2
40677: PUSH
40678: LD_INT 2
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: LD_INT 2
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: LIST
40699: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40700: LD_ADDR_VAR 0 62
40704: PUSH
40705: LD_INT 1
40707: PUSH
40708: LD_INT 2
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: LD_INT 0
40717: PUSH
40718: LD_INT 2
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: LIST
40740: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40741: LD_ADDR_VAR 0 63
40745: PUSH
40746: LD_INT 1
40748: NEG
40749: PUSH
40750: LD_INT 1
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 2
40759: NEG
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 2
40770: NEG
40771: PUSH
40772: LD_INT 1
40774: NEG
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40785: LD_ADDR_VAR 0 64
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: LD_INT 2
40796: NEG
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 2
40804: NEG
40805: PUSH
40806: LD_INT 1
40808: NEG
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 2
40816: NEG
40817: PUSH
40818: LD_INT 2
40820: NEG
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: LIST
40830: ST_TO_ADDR
// end ; 2 :
40831: GO 44097
40833: LD_INT 2
40835: DOUBLE
40836: EQUAL
40837: IFTRUE 40841
40839: GO 44096
40841: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
40842: LD_ADDR_VAR 0 29
40846: PUSH
40847: LD_INT 4
40849: PUSH
40850: LD_INT 0
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 4
40859: PUSH
40860: LD_INT 1
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 5
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 5
40880: PUSH
40881: LD_INT 1
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 4
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 3
40900: PUSH
40901: LD_INT 0
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: LD_INT 1
40913: NEG
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PUSH
40919: LD_INT 3
40921: PUSH
40922: LD_INT 2
40924: NEG
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 5
40932: PUSH
40933: LD_INT 2
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 3
40942: PUSH
40943: LD_INT 3
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 3
40952: PUSH
40953: LD_INT 2
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 4
40962: PUSH
40963: LD_INT 3
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 4
40972: PUSH
40973: LD_INT 4
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 3
40982: PUSH
40983: LD_INT 4
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 2
40992: PUSH
40993: LD_INT 3
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 2
41002: PUSH
41003: LD_INT 2
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: PUSH
41010: LD_INT 4
41012: PUSH
41013: LD_INT 2
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 2
41022: PUSH
41023: LD_INT 4
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: LD_INT 4
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 0
41042: PUSH
41043: LD_INT 3
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 1
41052: PUSH
41053: LD_INT 4
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 1
41062: PUSH
41063: LD_INT 5
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: LD_INT 5
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 1
41082: NEG
41083: PUSH
41084: LD_INT 4
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 1
41093: NEG
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 2
41104: PUSH
41105: LD_INT 5
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 2
41114: NEG
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 3
41125: NEG
41126: PUSH
41127: LD_INT 0
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 3
41136: NEG
41137: PUSH
41138: LD_INT 1
41140: NEG
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 2
41148: NEG
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: LD_INT 1
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: LD_INT 1
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 4
41181: NEG
41182: PUSH
41183: LD_INT 0
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 4
41192: NEG
41193: PUSH
41194: LD_INT 1
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 4
41204: NEG
41205: PUSH
41206: LD_INT 2
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 2
41216: NEG
41217: PUSH
41218: LD_INT 2
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 4
41227: NEG
41228: PUSH
41229: LD_INT 4
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 4
41239: NEG
41240: PUSH
41241: LD_INT 5
41243: NEG
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: LD_INT 4
41255: NEG
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: LD_INT 3
41267: NEG
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 4
41275: NEG
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 5
41287: NEG
41288: PUSH
41289: LD_INT 4
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 5
41299: NEG
41300: PUSH
41301: LD_INT 5
41303: NEG
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 3
41311: NEG
41312: PUSH
41313: LD_INT 5
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 5
41323: NEG
41324: PUSH
41325: LD_INT 3
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: LIST
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: LIST
41344: LIST
41345: LIST
41346: LIST
41347: LIST
41348: LIST
41349: LIST
41350: LIST
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: LIST
41364: LIST
41365: LIST
41366: LIST
41367: LIST
41368: LIST
41369: LIST
41370: LIST
41371: LIST
41372: LIST
41373: LIST
41374: LIST
41375: LIST
41376: LIST
41377: LIST
41378: LIST
41379: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41380: LD_ADDR_VAR 0 30
41384: PUSH
41385: LD_INT 4
41387: PUSH
41388: LD_INT 4
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 4
41397: PUSH
41398: LD_INT 3
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 5
41407: PUSH
41408: LD_INT 4
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 5
41417: PUSH
41418: LD_INT 5
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 4
41427: PUSH
41428: LD_INT 5
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 3
41437: PUSH
41438: LD_INT 4
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 3
41447: PUSH
41448: LD_INT 3
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: LD_INT 5
41457: PUSH
41458: LD_INT 3
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PUSH
41465: LD_INT 3
41467: PUSH
41468: LD_INT 5
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 0
41477: PUSH
41478: LD_INT 3
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: LD_INT 2
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 1
41497: PUSH
41498: LD_INT 3
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 1
41507: PUSH
41508: LD_INT 4
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 0
41517: PUSH
41518: LD_INT 4
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: LD_INT 1
41527: NEG
41528: PUSH
41529: LD_INT 3
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 1
41538: NEG
41539: PUSH
41540: LD_INT 2
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 2
41549: PUSH
41550: LD_INT 4
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 2
41559: NEG
41560: PUSH
41561: LD_INT 2
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 4
41570: NEG
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 4
41581: NEG
41582: PUSH
41583: LD_INT 1
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 3
41593: NEG
41594: PUSH
41595: LD_INT 0
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 3
41604: NEG
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 4
41615: NEG
41616: PUSH
41617: LD_INT 1
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 5
41626: NEG
41627: PUSH
41628: LD_INT 0
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 5
41637: NEG
41638: PUSH
41639: LD_INT 1
41641: NEG
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 5
41649: NEG
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 3
41661: NEG
41662: PUSH
41663: LD_INT 2
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 3
41672: NEG
41673: PUSH
41674: LD_INT 3
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 3
41684: NEG
41685: PUSH
41686: LD_INT 4
41688: NEG
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 2
41696: NEG
41697: PUSH
41698: LD_INT 3
41700: NEG
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 2
41708: NEG
41709: PUSH
41710: LD_INT 2
41712: NEG
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 3
41720: NEG
41721: PUSH
41722: LD_INT 2
41724: NEG
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 4
41732: NEG
41733: PUSH
41734: LD_INT 3
41736: NEG
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 4
41744: NEG
41745: PUSH
41746: LD_INT 4
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 2
41756: NEG
41757: PUSH
41758: LD_INT 4
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 4
41768: NEG
41769: PUSH
41770: LD_INT 2
41772: NEG
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 0
41780: PUSH
41781: LD_INT 4
41783: NEG
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 0
41791: PUSH
41792: LD_INT 5
41794: NEG
41795: PUSH
41796: EMPTY
41797: LIST
41798: LIST
41799: PUSH
41800: LD_INT 1
41802: PUSH
41803: LD_INT 4
41805: NEG
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 1
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 0
41824: PUSH
41825: LD_INT 3
41827: NEG
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 1
41835: NEG
41836: PUSH
41837: LD_INT 4
41839: NEG
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: LD_INT 5
41851: NEG
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 2
41859: PUSH
41860: LD_INT 3
41862: NEG
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 2
41870: NEG
41871: PUSH
41872: LD_INT 5
41874: NEG
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: LIST
41884: LIST
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: LIST
41908: LIST
41909: LIST
41910: LIST
41911: LIST
41912: LIST
41913: LIST
41914: LIST
41915: LIST
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: LIST
41925: LIST
41926: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
41927: LD_ADDR_VAR 0 31
41931: PUSH
41932: LD_INT 0
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 0
41944: PUSH
41945: LD_INT 3
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 1
41954: PUSH
41955: LD_INT 4
41957: PUSH
41958: EMPTY
41959: LIST
41960: LIST
41961: PUSH
41962: LD_INT 1
41964: PUSH
41965: LD_INT 5
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 0
41974: PUSH
41975: LD_INT 5
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 1
41984: NEG
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 1
41995: NEG
41996: PUSH
41997: LD_INT 3
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 2
42006: PUSH
42007: LD_INT 5
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 2
42016: NEG
42017: PUSH
42018: LD_INT 3
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 3
42027: NEG
42028: PUSH
42029: LD_INT 0
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 3
42038: NEG
42039: PUSH
42040: LD_INT 1
42042: NEG
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 2
42050: NEG
42051: PUSH
42052: LD_INT 0
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 2
42061: NEG
42062: PUSH
42063: LD_INT 1
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 3
42072: NEG
42073: PUSH
42074: LD_INT 1
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 4
42083: NEG
42084: PUSH
42085: LD_INT 0
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: LD_INT 4
42094: NEG
42095: PUSH
42096: LD_INT 1
42098: NEG
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 4
42106: NEG
42107: PUSH
42108: LD_INT 2
42110: NEG
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PUSH
42116: LD_INT 2
42118: NEG
42119: PUSH
42120: LD_INT 2
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 4
42129: NEG
42130: PUSH
42131: LD_INT 4
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 4
42141: NEG
42142: PUSH
42143: LD_INT 5
42145: NEG
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 3
42153: NEG
42154: PUSH
42155: LD_INT 4
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 3
42165: NEG
42166: PUSH
42167: LD_INT 3
42169: NEG
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 4
42177: NEG
42178: PUSH
42179: LD_INT 3
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 5
42189: NEG
42190: PUSH
42191: LD_INT 4
42193: NEG
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: LD_INT 5
42201: NEG
42202: PUSH
42203: LD_INT 5
42205: NEG
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 3
42213: NEG
42214: PUSH
42215: LD_INT 5
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 5
42225: NEG
42226: PUSH
42227: LD_INT 3
42229: NEG
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 0
42237: PUSH
42238: LD_INT 3
42240: NEG
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 0
42248: PUSH
42249: LD_INT 4
42251: NEG
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 1
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 1
42270: PUSH
42271: LD_INT 2
42273: NEG
42274: PUSH
42275: EMPTY
42276: LIST
42277: LIST
42278: PUSH
42279: LD_INT 0
42281: PUSH
42282: LD_INT 2
42284: NEG
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: LD_INT 1
42292: NEG
42293: PUSH
42294: LD_INT 3
42296: NEG
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PUSH
42302: LD_INT 1
42304: NEG
42305: PUSH
42306: LD_INT 4
42308: NEG
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 2
42316: PUSH
42317: LD_INT 2
42319: NEG
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 2
42327: NEG
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 4
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 4
42349: PUSH
42350: LD_INT 1
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 5
42360: PUSH
42361: LD_INT 0
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 5
42370: PUSH
42371: LD_INT 1
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 4
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: LD_INT 0
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: PUSH
42401: LD_INT 1
42403: NEG
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 3
42411: PUSH
42412: LD_INT 2
42414: NEG
42415: PUSH
42416: EMPTY
42417: LIST
42418: LIST
42419: PUSH
42420: LD_INT 5
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42477: LD_ADDR_VAR 0 32
42481: PUSH
42482: LD_INT 4
42484: NEG
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 4
42495: NEG
42496: PUSH
42497: LD_INT 1
42499: NEG
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 3
42507: NEG
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 3
42518: NEG
42519: PUSH
42520: LD_INT 1
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 4
42529: NEG
42530: PUSH
42531: LD_INT 1
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 5
42540: NEG
42541: PUSH
42542: LD_INT 0
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 5
42551: NEG
42552: PUSH
42553: LD_INT 1
42555: NEG
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 5
42563: NEG
42564: PUSH
42565: LD_INT 2
42567: NEG
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 3
42575: NEG
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: NEG
42587: PUSH
42588: LD_INT 3
42590: NEG
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: LD_INT 3
42598: NEG
42599: PUSH
42600: LD_INT 4
42602: NEG
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: PUSH
42608: LD_INT 2
42610: NEG
42611: PUSH
42612: LD_INT 3
42614: NEG
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: LD_INT 2
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 3
42634: NEG
42635: PUSH
42636: LD_INT 2
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 4
42646: NEG
42647: PUSH
42648: LD_INT 3
42650: NEG
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 4
42658: NEG
42659: PUSH
42660: LD_INT 4
42662: NEG
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 2
42670: NEG
42671: PUSH
42672: LD_INT 4
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 4
42682: NEG
42683: PUSH
42684: LD_INT 2
42686: NEG
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 0
42694: PUSH
42695: LD_INT 4
42697: NEG
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: LD_INT 5
42708: NEG
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 1
42716: PUSH
42717: LD_INT 4
42719: NEG
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 1
42727: PUSH
42728: LD_INT 3
42730: NEG
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 3
42741: NEG
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 1
42749: NEG
42750: PUSH
42751: LD_INT 4
42753: NEG
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: LD_INT 1
42761: NEG
42762: PUSH
42763: LD_INT 5
42765: NEG
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: LD_INT 2
42773: PUSH
42774: LD_INT 3
42776: NEG
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 2
42784: NEG
42785: PUSH
42786: LD_INT 5
42788: NEG
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 3
42796: PUSH
42797: LD_INT 0
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 3
42806: PUSH
42807: LD_INT 1
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 4
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 4
42827: PUSH
42828: LD_INT 1
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 3
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 2
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 2
42857: PUSH
42858: LD_INT 1
42860: NEG
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 2
42868: PUSH
42869: LD_INT 2
42871: NEG
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: LD_INT 4
42879: PUSH
42880: LD_INT 2
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 4
42889: PUSH
42890: LD_INT 4
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 4
42899: PUSH
42900: LD_INT 3
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 5
42909: PUSH
42910: LD_INT 4
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 5
42919: PUSH
42920: LD_INT 5
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 4
42929: PUSH
42930: LD_INT 5
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: LD_INT 3
42939: PUSH
42940: LD_INT 4
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 3
42949: PUSH
42950: LD_INT 3
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 5
42959: PUSH
42960: LD_INT 3
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 3
42969: PUSH
42970: LD_INT 5
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: LIST
43000: LIST
43001: LIST
43002: LIST
43003: LIST
43004: LIST
43005: LIST
43006: LIST
43007: LIST
43008: LIST
43009: LIST
43010: LIST
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43024: LD_ADDR_VAR 0 33
43028: PUSH
43029: LD_INT 4
43031: NEG
43032: PUSH
43033: LD_INT 4
43035: NEG
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 4
43043: NEG
43044: PUSH
43045: LD_INT 5
43047: NEG
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 3
43055: NEG
43056: PUSH
43057: LD_INT 4
43059: NEG
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 3
43067: NEG
43068: PUSH
43069: LD_INT 3
43071: NEG
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 4
43079: NEG
43080: PUSH
43081: LD_INT 3
43083: NEG
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PUSH
43089: LD_INT 5
43091: NEG
43092: PUSH
43093: LD_INT 4
43095: NEG
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 5
43103: NEG
43104: PUSH
43105: LD_INT 5
43107: NEG
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 3
43115: NEG
43116: PUSH
43117: LD_INT 5
43119: NEG
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 5
43127: NEG
43128: PUSH
43129: LD_INT 3
43131: NEG
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 0
43139: PUSH
43140: LD_INT 3
43142: NEG
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: PUSH
43148: LD_INT 0
43150: PUSH
43151: LD_INT 4
43153: NEG
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: LD_INT 1
43161: PUSH
43162: LD_INT 3
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: LD_INT 1
43172: PUSH
43173: LD_INT 2
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 0
43183: PUSH
43184: LD_INT 2
43186: NEG
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PUSH
43192: LD_INT 1
43194: NEG
43195: PUSH
43196: LD_INT 3
43198: NEG
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: LD_INT 4
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 2
43218: PUSH
43219: LD_INT 2
43221: NEG
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 2
43229: NEG
43230: PUSH
43231: LD_INT 4
43233: NEG
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 4
43241: PUSH
43242: LD_INT 0
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 4
43251: PUSH
43252: LD_INT 1
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 5
43262: PUSH
43263: LD_INT 0
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 5
43272: PUSH
43273: LD_INT 1
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 4
43282: PUSH
43283: LD_INT 1
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 3
43292: PUSH
43293: LD_INT 0
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 3
43302: PUSH
43303: LD_INT 1
43305: NEG
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: LD_INT 2
43316: NEG
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 5
43324: PUSH
43325: LD_INT 2
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 3
43334: PUSH
43335: LD_INT 3
43337: PUSH
43338: EMPTY
43339: LIST
43340: LIST
43341: PUSH
43342: LD_INT 3
43344: PUSH
43345: LD_INT 2
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 4
43354: PUSH
43355: LD_INT 3
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: LD_INT 4
43364: PUSH
43365: LD_INT 4
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 3
43374: PUSH
43375: LD_INT 4
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: PUSH
43382: LD_INT 2
43384: PUSH
43385: LD_INT 3
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: LD_INT 2
43394: PUSH
43395: LD_INT 2
43397: PUSH
43398: EMPTY
43399: LIST
43400: LIST
43401: PUSH
43402: LD_INT 4
43404: PUSH
43405: LD_INT 2
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 2
43414: PUSH
43415: LD_INT 4
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 0
43424: PUSH
43425: LD_INT 4
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 0
43434: PUSH
43435: LD_INT 3
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 1
43444: PUSH
43445: LD_INT 4
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 1
43454: PUSH
43455: LD_INT 5
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 0
43464: PUSH
43465: LD_INT 5
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 1
43474: NEG
43475: PUSH
43476: LD_INT 4
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 1
43485: NEG
43486: PUSH
43487: LD_INT 3
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 2
43496: PUSH
43497: LD_INT 5
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 2
43506: NEG
43507: PUSH
43508: LD_INT 3
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43562: LD_ADDR_VAR 0 34
43566: PUSH
43567: LD_INT 0
43569: PUSH
43570: LD_INT 4
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 0
43580: PUSH
43581: LD_INT 5
43583: NEG
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: LD_INT 4
43594: NEG
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 1
43602: PUSH
43603: LD_INT 3
43605: NEG
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 0
43613: PUSH
43614: LD_INT 3
43616: NEG
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 1
43624: NEG
43625: PUSH
43626: LD_INT 4
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 1
43636: NEG
43637: PUSH
43638: LD_INT 5
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: PUSH
43649: LD_INT 3
43651: NEG
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 2
43659: NEG
43660: PUSH
43661: LD_INT 5
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: PUSH
43672: LD_INT 0
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 3
43681: PUSH
43682: LD_INT 1
43684: NEG
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 4
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 4
43702: PUSH
43703: LD_INT 1
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: LD_INT 3
43712: PUSH
43713: LD_INT 1
43715: PUSH
43716: EMPTY
43717: LIST
43718: LIST
43719: PUSH
43720: LD_INT 2
43722: PUSH
43723: LD_INT 0
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 2
43732: PUSH
43733: LD_INT 1
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 2
43743: PUSH
43744: LD_INT 2
43746: NEG
43747: PUSH
43748: EMPTY
43749: LIST
43750: LIST
43751: PUSH
43752: LD_INT 4
43754: PUSH
43755: LD_INT 2
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 4
43764: PUSH
43765: LD_INT 4
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: PUSH
43772: LD_INT 4
43774: PUSH
43775: LD_INT 3
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: LD_INT 5
43784: PUSH
43785: LD_INT 4
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: PUSH
43792: LD_INT 5
43794: PUSH
43795: LD_INT 5
43797: PUSH
43798: EMPTY
43799: LIST
43800: LIST
43801: PUSH
43802: LD_INT 4
43804: PUSH
43805: LD_INT 5
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 3
43814: PUSH
43815: LD_INT 4
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: LD_INT 3
43824: PUSH
43825: LD_INT 3
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 5
43834: PUSH
43835: LD_INT 3
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 3
43844: PUSH
43845: LD_INT 5
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: PUSH
43852: LD_INT 0
43854: PUSH
43855: LD_INT 3
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: LD_INT 0
43864: PUSH
43865: LD_INT 2
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 1
43874: PUSH
43875: LD_INT 3
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 1
43884: PUSH
43885: LD_INT 4
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 0
43894: PUSH
43895: LD_INT 4
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 1
43904: NEG
43905: PUSH
43906: LD_INT 3
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 1
43915: NEG
43916: PUSH
43917: LD_INT 2
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 2
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 2
43936: NEG
43937: PUSH
43938: LD_INT 2
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: PUSH
43945: LD_INT 4
43947: NEG
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: LD_INT 4
43958: NEG
43959: PUSH
43960: LD_INT 1
43962: NEG
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 3
43970: NEG
43971: PUSH
43972: LD_INT 0
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 3
43981: NEG
43982: PUSH
43983: LD_INT 1
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 4
43992: NEG
43993: PUSH
43994: LD_INT 1
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 5
44003: NEG
44004: PUSH
44005: LD_INT 0
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 5
44014: NEG
44015: PUSH
44016: LD_INT 1
44018: NEG
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 5
44026: NEG
44027: PUSH
44028: LD_INT 2
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 3
44038: NEG
44039: PUSH
44040: LD_INT 2
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: ST_TO_ADDR
// end ; end ;
44094: GO 44097
44096: POP
// case btype of b_depot , b_warehouse :
44097: LD_VAR 0 1
44101: PUSH
44102: LD_INT 0
44104: DOUBLE
44105: EQUAL
44106: IFTRUE 44116
44108: LD_INT 1
44110: DOUBLE
44111: EQUAL
44112: IFTRUE 44116
44114: GO 44317
44116: POP
// case nation of nation_american :
44117: LD_VAR 0 5
44121: PUSH
44122: LD_INT 1
44124: DOUBLE
44125: EQUAL
44126: IFTRUE 44130
44128: GO 44186
44130: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
44131: LD_ADDR_VAR 0 9
44135: PUSH
44136: LD_VAR 0 11
44140: PUSH
44141: LD_VAR 0 12
44145: PUSH
44146: LD_VAR 0 13
44150: PUSH
44151: LD_VAR 0 14
44155: PUSH
44156: LD_VAR 0 15
44160: PUSH
44161: LD_VAR 0 16
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: LIST
44172: LIST
44173: PUSH
44174: LD_VAR 0 4
44178: PUSH
44179: LD_INT 1
44181: PLUS
44182: ARRAY
44183: ST_TO_ADDR
44184: GO 44315
44186: LD_INT 2
44188: DOUBLE
44189: EQUAL
44190: IFTRUE 44194
44192: GO 44250
44194: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
44195: LD_ADDR_VAR 0 9
44199: PUSH
44200: LD_VAR 0 17
44204: PUSH
44205: LD_VAR 0 18
44209: PUSH
44210: LD_VAR 0 19
44214: PUSH
44215: LD_VAR 0 20
44219: PUSH
44220: LD_VAR 0 21
44224: PUSH
44225: LD_VAR 0 22
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: PUSH
44238: LD_VAR 0 4
44242: PUSH
44243: LD_INT 1
44245: PLUS
44246: ARRAY
44247: ST_TO_ADDR
44248: GO 44315
44250: LD_INT 3
44252: DOUBLE
44253: EQUAL
44254: IFTRUE 44258
44256: GO 44314
44258: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44259: LD_ADDR_VAR 0 9
44263: PUSH
44264: LD_VAR 0 23
44268: PUSH
44269: LD_VAR 0 24
44273: PUSH
44274: LD_VAR 0 25
44278: PUSH
44279: LD_VAR 0 26
44283: PUSH
44284: LD_VAR 0 27
44288: PUSH
44289: LD_VAR 0 28
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: PUSH
44302: LD_VAR 0 4
44306: PUSH
44307: LD_INT 1
44309: PLUS
44310: ARRAY
44311: ST_TO_ADDR
44312: GO 44315
44314: POP
44315: GO 44870
44317: LD_INT 2
44319: DOUBLE
44320: EQUAL
44321: IFTRUE 44331
44323: LD_INT 3
44325: DOUBLE
44326: EQUAL
44327: IFTRUE 44331
44329: GO 44387
44331: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44332: LD_ADDR_VAR 0 9
44336: PUSH
44337: LD_VAR 0 29
44341: PUSH
44342: LD_VAR 0 30
44346: PUSH
44347: LD_VAR 0 31
44351: PUSH
44352: LD_VAR 0 32
44356: PUSH
44357: LD_VAR 0 33
44361: PUSH
44362: LD_VAR 0 34
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: PUSH
44375: LD_VAR 0 4
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: ARRAY
44384: ST_TO_ADDR
44385: GO 44870
44387: LD_INT 16
44389: DOUBLE
44390: EQUAL
44391: IFTRUE 44449
44393: LD_INT 17
44395: DOUBLE
44396: EQUAL
44397: IFTRUE 44449
44399: LD_INT 18
44401: DOUBLE
44402: EQUAL
44403: IFTRUE 44449
44405: LD_INT 19
44407: DOUBLE
44408: EQUAL
44409: IFTRUE 44449
44411: LD_INT 22
44413: DOUBLE
44414: EQUAL
44415: IFTRUE 44449
44417: LD_INT 20
44419: DOUBLE
44420: EQUAL
44421: IFTRUE 44449
44423: LD_INT 21
44425: DOUBLE
44426: EQUAL
44427: IFTRUE 44449
44429: LD_INT 23
44431: DOUBLE
44432: EQUAL
44433: IFTRUE 44449
44435: LD_INT 24
44437: DOUBLE
44438: EQUAL
44439: IFTRUE 44449
44441: LD_INT 25
44443: DOUBLE
44444: EQUAL
44445: IFTRUE 44449
44447: GO 44505
44449: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44450: LD_ADDR_VAR 0 9
44454: PUSH
44455: LD_VAR 0 35
44459: PUSH
44460: LD_VAR 0 36
44464: PUSH
44465: LD_VAR 0 37
44469: PUSH
44470: LD_VAR 0 38
44474: PUSH
44475: LD_VAR 0 39
44479: PUSH
44480: LD_VAR 0 40
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: PUSH
44493: LD_VAR 0 4
44497: PUSH
44498: LD_INT 1
44500: PLUS
44501: ARRAY
44502: ST_TO_ADDR
44503: GO 44870
44505: LD_INT 6
44507: DOUBLE
44508: EQUAL
44509: IFTRUE 44561
44511: LD_INT 7
44513: DOUBLE
44514: EQUAL
44515: IFTRUE 44561
44517: LD_INT 8
44519: DOUBLE
44520: EQUAL
44521: IFTRUE 44561
44523: LD_INT 13
44525: DOUBLE
44526: EQUAL
44527: IFTRUE 44561
44529: LD_INT 12
44531: DOUBLE
44532: EQUAL
44533: IFTRUE 44561
44535: LD_INT 15
44537: DOUBLE
44538: EQUAL
44539: IFTRUE 44561
44541: LD_INT 11
44543: DOUBLE
44544: EQUAL
44545: IFTRUE 44561
44547: LD_INT 14
44549: DOUBLE
44550: EQUAL
44551: IFTRUE 44561
44553: LD_INT 10
44555: DOUBLE
44556: EQUAL
44557: IFTRUE 44561
44559: GO 44617
44561: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
44562: LD_ADDR_VAR 0 9
44566: PUSH
44567: LD_VAR 0 41
44571: PUSH
44572: LD_VAR 0 42
44576: PUSH
44577: LD_VAR 0 43
44581: PUSH
44582: LD_VAR 0 44
44586: PUSH
44587: LD_VAR 0 45
44591: PUSH
44592: LD_VAR 0 46
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: PUSH
44605: LD_VAR 0 4
44609: PUSH
44610: LD_INT 1
44612: PLUS
44613: ARRAY
44614: ST_TO_ADDR
44615: GO 44870
44617: LD_INT 36
44619: DOUBLE
44620: EQUAL
44621: IFTRUE 44625
44623: GO 44681
44625: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
44626: LD_ADDR_VAR 0 9
44630: PUSH
44631: LD_VAR 0 47
44635: PUSH
44636: LD_VAR 0 48
44640: PUSH
44641: LD_VAR 0 49
44645: PUSH
44646: LD_VAR 0 50
44650: PUSH
44651: LD_VAR 0 51
44655: PUSH
44656: LD_VAR 0 52
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: PUSH
44669: LD_VAR 0 4
44673: PUSH
44674: LD_INT 1
44676: PLUS
44677: ARRAY
44678: ST_TO_ADDR
44679: GO 44870
44681: LD_INT 4
44683: DOUBLE
44684: EQUAL
44685: IFTRUE 44707
44687: LD_INT 5
44689: DOUBLE
44690: EQUAL
44691: IFTRUE 44707
44693: LD_INT 34
44695: DOUBLE
44696: EQUAL
44697: IFTRUE 44707
44699: LD_INT 37
44701: DOUBLE
44702: EQUAL
44703: IFTRUE 44707
44705: GO 44763
44707: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
44708: LD_ADDR_VAR 0 9
44712: PUSH
44713: LD_VAR 0 53
44717: PUSH
44718: LD_VAR 0 54
44722: PUSH
44723: LD_VAR 0 55
44727: PUSH
44728: LD_VAR 0 56
44732: PUSH
44733: LD_VAR 0 57
44737: PUSH
44738: LD_VAR 0 58
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: PUSH
44751: LD_VAR 0 4
44755: PUSH
44756: LD_INT 1
44758: PLUS
44759: ARRAY
44760: ST_TO_ADDR
44761: GO 44870
44763: LD_INT 31
44765: DOUBLE
44766: EQUAL
44767: IFTRUE 44813
44769: LD_INT 32
44771: DOUBLE
44772: EQUAL
44773: IFTRUE 44813
44775: LD_INT 33
44777: DOUBLE
44778: EQUAL
44779: IFTRUE 44813
44781: LD_INT 27
44783: DOUBLE
44784: EQUAL
44785: IFTRUE 44813
44787: LD_INT 26
44789: DOUBLE
44790: EQUAL
44791: IFTRUE 44813
44793: LD_INT 28
44795: DOUBLE
44796: EQUAL
44797: IFTRUE 44813
44799: LD_INT 29
44801: DOUBLE
44802: EQUAL
44803: IFTRUE 44813
44805: LD_INT 30
44807: DOUBLE
44808: EQUAL
44809: IFTRUE 44813
44811: GO 44869
44813: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
44814: LD_ADDR_VAR 0 9
44818: PUSH
44819: LD_VAR 0 59
44823: PUSH
44824: LD_VAR 0 60
44828: PUSH
44829: LD_VAR 0 61
44833: PUSH
44834: LD_VAR 0 62
44838: PUSH
44839: LD_VAR 0 63
44843: PUSH
44844: LD_VAR 0 64
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: LIST
44853: LIST
44854: LIST
44855: LIST
44856: PUSH
44857: LD_VAR 0 4
44861: PUSH
44862: LD_INT 1
44864: PLUS
44865: ARRAY
44866: ST_TO_ADDR
44867: GO 44870
44869: POP
// temp_list2 = [ ] ;
44870: LD_ADDR_VAR 0 10
44874: PUSH
44875: EMPTY
44876: ST_TO_ADDR
// for i in temp_list do
44877: LD_ADDR_VAR 0 8
44881: PUSH
44882: LD_VAR 0 9
44886: PUSH
44887: FOR_IN
44888: IFFALSE 44940
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
44890: LD_ADDR_VAR 0 10
44894: PUSH
44895: LD_VAR 0 10
44899: PUSH
44900: LD_VAR 0 8
44904: PUSH
44905: LD_INT 1
44907: ARRAY
44908: PUSH
44909: LD_VAR 0 2
44913: PLUS
44914: PUSH
44915: LD_VAR 0 8
44919: PUSH
44920: LD_INT 2
44922: ARRAY
44923: PUSH
44924: LD_VAR 0 3
44928: PLUS
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: EMPTY
44935: LIST
44936: ADD
44937: ST_TO_ADDR
44938: GO 44887
44940: POP
44941: POP
// result = temp_list2 ;
44942: LD_ADDR_VAR 0 7
44946: PUSH
44947: LD_VAR 0 10
44951: ST_TO_ADDR
// end ;
44952: LD_VAR 0 7
44956: RET
// export function EnemyInRange ( unit , dist ) ; begin
44957: LD_INT 0
44959: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
44960: LD_ADDR_VAR 0 3
44964: PUSH
44965: LD_VAR 0 1
44969: PPUSH
44970: CALL_OW 255
44974: PPUSH
44975: LD_VAR 0 1
44979: PPUSH
44980: CALL_OW 250
44984: PPUSH
44985: LD_VAR 0 1
44989: PPUSH
44990: CALL_OW 251
44994: PPUSH
44995: LD_VAR 0 2
44999: PPUSH
45000: CALL 19061 0 4
45004: PUSH
45005: LD_INT 4
45007: ARRAY
45008: ST_TO_ADDR
// end ;
45009: LD_VAR 0 3
45013: RET
// export function PlayerSeeMe ( unit ) ; begin
45014: LD_INT 0
45016: PPUSH
// result := See ( your_side , unit ) ;
45017: LD_ADDR_VAR 0 2
45021: PUSH
45022: LD_OWVAR 2
45026: PPUSH
45027: LD_VAR 0 1
45031: PPUSH
45032: CALL_OW 292
45036: ST_TO_ADDR
// end ;
45037: LD_VAR 0 2
45041: RET
// export function ReverseDir ( unit ) ; begin
45042: LD_INT 0
45044: PPUSH
// if not unit then
45045: LD_VAR 0 1
45049: NOT
45050: IFFALSE 45054
// exit ;
45052: GO 45100
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
45054: LD_ADDR_VAR 0 2
45058: PUSH
45059: LD_INT 3
45061: PUSH
45062: LD_INT 4
45064: PUSH
45065: LD_INT 5
45067: PUSH
45068: LD_INT 0
45070: PUSH
45071: LD_INT 1
45073: PUSH
45074: LD_INT 2
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: PUSH
45085: LD_VAR 0 1
45089: PPUSH
45090: CALL_OW 254
45094: PUSH
45095: LD_INT 1
45097: PLUS
45098: ARRAY
45099: ST_TO_ADDR
// end ;
45100: LD_VAR 0 2
45104: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45105: LD_INT 0
45107: PPUSH
45108: PPUSH
45109: PPUSH
45110: PPUSH
45111: PPUSH
// if not hexes then
45112: LD_VAR 0 2
45116: NOT
45117: IFFALSE 45121
// exit ;
45119: GO 45269
// dist := 9999 ;
45121: LD_ADDR_VAR 0 5
45125: PUSH
45126: LD_INT 9999
45128: ST_TO_ADDR
// for i = 1 to hexes do
45129: LD_ADDR_VAR 0 4
45133: PUSH
45134: DOUBLE
45135: LD_INT 1
45137: DEC
45138: ST_TO_ADDR
45139: LD_VAR 0 2
45143: PUSH
45144: FOR_TO
45145: IFFALSE 45257
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45147: LD_VAR 0 1
45151: PPUSH
45152: LD_VAR 0 2
45156: PUSH
45157: LD_VAR 0 4
45161: ARRAY
45162: PUSH
45163: LD_INT 1
45165: ARRAY
45166: PPUSH
45167: LD_VAR 0 2
45171: PUSH
45172: LD_VAR 0 4
45176: ARRAY
45177: PUSH
45178: LD_INT 2
45180: ARRAY
45181: PPUSH
45182: CALL_OW 297
45186: PUSH
45187: LD_VAR 0 5
45191: LESS
45192: IFFALSE 45255
// begin hex := hexes [ i ] ;
45194: LD_ADDR_VAR 0 7
45198: PUSH
45199: LD_VAR 0 2
45203: PUSH
45204: LD_VAR 0 4
45208: ARRAY
45209: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45210: LD_ADDR_VAR 0 5
45214: PUSH
45215: LD_VAR 0 1
45219: PPUSH
45220: LD_VAR 0 2
45224: PUSH
45225: LD_VAR 0 4
45229: ARRAY
45230: PUSH
45231: LD_INT 1
45233: ARRAY
45234: PPUSH
45235: LD_VAR 0 2
45239: PUSH
45240: LD_VAR 0 4
45244: ARRAY
45245: PUSH
45246: LD_INT 2
45248: ARRAY
45249: PPUSH
45250: CALL_OW 297
45254: ST_TO_ADDR
// end ; end ;
45255: GO 45144
45257: POP
45258: POP
// result := hex ;
45259: LD_ADDR_VAR 0 3
45263: PUSH
45264: LD_VAR 0 7
45268: ST_TO_ADDR
// end ;
45269: LD_VAR 0 3
45273: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45274: LD_INT 0
45276: PPUSH
45277: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45278: LD_VAR 0 1
45282: NOT
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: LD_INT 21
45291: PUSH
45292: LD_INT 2
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 23
45301: PUSH
45302: LD_INT 2
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: PPUSH
45313: CALL_OW 69
45317: IN
45318: NOT
45319: OR
45320: IFFALSE 45324
// exit ;
45322: GO 45371
// for i = 1 to 3 do
45324: LD_ADDR_VAR 0 3
45328: PUSH
45329: DOUBLE
45330: LD_INT 1
45332: DEC
45333: ST_TO_ADDR
45334: LD_INT 3
45336: PUSH
45337: FOR_TO
45338: IFFALSE 45369
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45340: LD_VAR 0 1
45344: PPUSH
45345: CALL_OW 250
45349: PPUSH
45350: LD_VAR 0 1
45354: PPUSH
45355: CALL_OW 251
45359: PPUSH
45360: LD_INT 1
45362: PPUSH
45363: CALL_OW 453
45367: GO 45337
45369: POP
45370: POP
// end ;
45371: LD_VAR 0 2
45375: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45376: LD_INT 0
45378: PPUSH
45379: PPUSH
45380: PPUSH
45381: PPUSH
45382: PPUSH
45383: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45384: LD_VAR 0 1
45388: NOT
45389: PUSH
45390: LD_VAR 0 2
45394: NOT
45395: OR
45396: PUSH
45397: LD_VAR 0 1
45401: PPUSH
45402: CALL_OW 314
45406: OR
45407: IFFALSE 45411
// exit ;
45409: GO 45852
// x := GetX ( enemy_unit ) ;
45411: LD_ADDR_VAR 0 7
45415: PUSH
45416: LD_VAR 0 2
45420: PPUSH
45421: CALL_OW 250
45425: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45426: LD_ADDR_VAR 0 8
45430: PUSH
45431: LD_VAR 0 2
45435: PPUSH
45436: CALL_OW 251
45440: ST_TO_ADDR
// if not x or not y then
45441: LD_VAR 0 7
45445: NOT
45446: PUSH
45447: LD_VAR 0 8
45451: NOT
45452: OR
45453: IFFALSE 45457
// exit ;
45455: GO 45852
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45457: LD_ADDR_VAR 0 6
45461: PUSH
45462: LD_VAR 0 7
45466: PPUSH
45467: LD_INT 0
45469: PPUSH
45470: LD_INT 4
45472: PPUSH
45473: CALL_OW 272
45477: PUSH
45478: LD_VAR 0 8
45482: PPUSH
45483: LD_INT 0
45485: PPUSH
45486: LD_INT 4
45488: PPUSH
45489: CALL_OW 273
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_VAR 0 7
45502: PPUSH
45503: LD_INT 1
45505: PPUSH
45506: LD_INT 4
45508: PPUSH
45509: CALL_OW 272
45513: PUSH
45514: LD_VAR 0 8
45518: PPUSH
45519: LD_INT 1
45521: PPUSH
45522: LD_INT 4
45524: PPUSH
45525: CALL_OW 273
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_VAR 0 7
45538: PPUSH
45539: LD_INT 2
45541: PPUSH
45542: LD_INT 4
45544: PPUSH
45545: CALL_OW 272
45549: PUSH
45550: LD_VAR 0 8
45554: PPUSH
45555: LD_INT 2
45557: PPUSH
45558: LD_INT 4
45560: PPUSH
45561: CALL_OW 273
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_VAR 0 7
45574: PPUSH
45575: LD_INT 3
45577: PPUSH
45578: LD_INT 4
45580: PPUSH
45581: CALL_OW 272
45585: PUSH
45586: LD_VAR 0 8
45590: PPUSH
45591: LD_INT 3
45593: PPUSH
45594: LD_INT 4
45596: PPUSH
45597: CALL_OW 273
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_VAR 0 7
45610: PPUSH
45611: LD_INT 4
45613: PPUSH
45614: LD_INT 4
45616: PPUSH
45617: CALL_OW 272
45621: PUSH
45622: LD_VAR 0 8
45626: PPUSH
45627: LD_INT 4
45629: PPUSH
45630: LD_INT 4
45632: PPUSH
45633: CALL_OW 273
45637: PUSH
45638: EMPTY
45639: LIST
45640: LIST
45641: PUSH
45642: LD_VAR 0 7
45646: PPUSH
45647: LD_INT 5
45649: PPUSH
45650: LD_INT 4
45652: PPUSH
45653: CALL_OW 272
45657: PUSH
45658: LD_VAR 0 8
45662: PPUSH
45663: LD_INT 5
45665: PPUSH
45666: LD_INT 4
45668: PPUSH
45669: CALL_OW 273
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: ST_TO_ADDR
// for i = tmp downto 1 do
45686: LD_ADDR_VAR 0 4
45690: PUSH
45691: DOUBLE
45692: LD_VAR 0 6
45696: INC
45697: ST_TO_ADDR
45698: LD_INT 1
45700: PUSH
45701: FOR_DOWNTO
45702: IFFALSE 45803
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
45704: LD_VAR 0 6
45708: PUSH
45709: LD_VAR 0 4
45713: ARRAY
45714: PUSH
45715: LD_INT 1
45717: ARRAY
45718: PPUSH
45719: LD_VAR 0 6
45723: PUSH
45724: LD_VAR 0 4
45728: ARRAY
45729: PUSH
45730: LD_INT 2
45732: ARRAY
45733: PPUSH
45734: CALL_OW 488
45738: NOT
45739: PUSH
45740: LD_VAR 0 6
45744: PUSH
45745: LD_VAR 0 4
45749: ARRAY
45750: PUSH
45751: LD_INT 1
45753: ARRAY
45754: PPUSH
45755: LD_VAR 0 6
45759: PUSH
45760: LD_VAR 0 4
45764: ARRAY
45765: PUSH
45766: LD_INT 2
45768: ARRAY
45769: PPUSH
45770: CALL_OW 428
45774: PUSH
45775: LD_INT 0
45777: NONEQUAL
45778: OR
45779: IFFALSE 45801
// tmp := Delete ( tmp , i ) ;
45781: LD_ADDR_VAR 0 6
45785: PUSH
45786: LD_VAR 0 6
45790: PPUSH
45791: LD_VAR 0 4
45795: PPUSH
45796: CALL_OW 3
45800: ST_TO_ADDR
45801: GO 45701
45803: POP
45804: POP
// j := GetClosestHex ( unit , tmp ) ;
45805: LD_ADDR_VAR 0 5
45809: PUSH
45810: LD_VAR 0 1
45814: PPUSH
45815: LD_VAR 0 6
45819: PPUSH
45820: CALL 45105 0 2
45824: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
45825: LD_VAR 0 1
45829: PPUSH
45830: LD_VAR 0 5
45834: PUSH
45835: LD_INT 1
45837: ARRAY
45838: PPUSH
45839: LD_VAR 0 5
45843: PUSH
45844: LD_INT 2
45846: ARRAY
45847: PPUSH
45848: CALL_OW 111
// end ;
45852: LD_VAR 0 3
45856: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45857: LD_INT 0
45859: PPUSH
45860: PPUSH
45861: PPUSH
// uc_side = 0 ;
45862: LD_ADDR_OWVAR 20
45866: PUSH
45867: LD_INT 0
45869: ST_TO_ADDR
// uc_nation = 0 ;
45870: LD_ADDR_OWVAR 21
45874: PUSH
45875: LD_INT 0
45877: ST_TO_ADDR
// InitHc ;
45878: CALL_OW 19
// InitVc ;
45882: CALL_OW 20
// if mastodonts then
45886: LD_VAR 0 6
45890: IFFALSE 45957
// for i = 1 to mastodonts do
45892: LD_ADDR_VAR 0 11
45896: PUSH
45897: DOUBLE
45898: LD_INT 1
45900: DEC
45901: ST_TO_ADDR
45902: LD_VAR 0 6
45906: PUSH
45907: FOR_TO
45908: IFFALSE 45955
// begin vc_chassis := 31 ;
45910: LD_ADDR_OWVAR 37
45914: PUSH
45915: LD_INT 31
45917: ST_TO_ADDR
// vc_control := control_rider ;
45918: LD_ADDR_OWVAR 38
45922: PUSH
45923: LD_INT 4
45925: ST_TO_ADDR
// animal := CreateVehicle ;
45926: LD_ADDR_VAR 0 12
45930: PUSH
45931: CALL_OW 45
45935: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45936: LD_VAR 0 12
45940: PPUSH
45941: LD_VAR 0 8
45945: PPUSH
45946: LD_INT 0
45948: PPUSH
45949: CALL 52702 0 3
// end ;
45953: GO 45907
45955: POP
45956: POP
// if horses then
45957: LD_VAR 0 5
45961: IFFALSE 46028
// for i = 1 to horses do
45963: LD_ADDR_VAR 0 11
45967: PUSH
45968: DOUBLE
45969: LD_INT 1
45971: DEC
45972: ST_TO_ADDR
45973: LD_VAR 0 5
45977: PUSH
45978: FOR_TO
45979: IFFALSE 46026
// begin hc_class := 21 ;
45981: LD_ADDR_OWVAR 28
45985: PUSH
45986: LD_INT 21
45988: ST_TO_ADDR
// hc_gallery :=  ;
45989: LD_ADDR_OWVAR 33
45993: PUSH
45994: LD_STRING 
45996: ST_TO_ADDR
// animal := CreateHuman ;
45997: LD_ADDR_VAR 0 12
46001: PUSH
46002: CALL_OW 44
46006: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46007: LD_VAR 0 12
46011: PPUSH
46012: LD_VAR 0 8
46016: PPUSH
46017: LD_INT 0
46019: PPUSH
46020: CALL 52702 0 3
// end ;
46024: GO 45978
46026: POP
46027: POP
// if birds then
46028: LD_VAR 0 1
46032: IFFALSE 46099
// for i = 1 to birds do
46034: LD_ADDR_VAR 0 11
46038: PUSH
46039: DOUBLE
46040: LD_INT 1
46042: DEC
46043: ST_TO_ADDR
46044: LD_VAR 0 1
46048: PUSH
46049: FOR_TO
46050: IFFALSE 46097
// begin hc_class = 18 ;
46052: LD_ADDR_OWVAR 28
46056: PUSH
46057: LD_INT 18
46059: ST_TO_ADDR
// hc_gallery =  ;
46060: LD_ADDR_OWVAR 33
46064: PUSH
46065: LD_STRING 
46067: ST_TO_ADDR
// animal := CreateHuman ;
46068: LD_ADDR_VAR 0 12
46072: PUSH
46073: CALL_OW 44
46077: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46078: LD_VAR 0 12
46082: PPUSH
46083: LD_VAR 0 8
46087: PPUSH
46088: LD_INT 0
46090: PPUSH
46091: CALL 52702 0 3
// end ;
46095: GO 46049
46097: POP
46098: POP
// if tigers then
46099: LD_VAR 0 2
46103: IFFALSE 46187
// for i = 1 to tigers do
46105: LD_ADDR_VAR 0 11
46109: PUSH
46110: DOUBLE
46111: LD_INT 1
46113: DEC
46114: ST_TO_ADDR
46115: LD_VAR 0 2
46119: PUSH
46120: FOR_TO
46121: IFFALSE 46185
// begin hc_class = class_tiger ;
46123: LD_ADDR_OWVAR 28
46127: PUSH
46128: LD_INT 14
46130: ST_TO_ADDR
// hc_gallery =  ;
46131: LD_ADDR_OWVAR 33
46135: PUSH
46136: LD_STRING 
46138: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46139: LD_ADDR_OWVAR 35
46143: PUSH
46144: LD_INT 7
46146: NEG
46147: PPUSH
46148: LD_INT 7
46150: PPUSH
46151: CALL_OW 12
46155: ST_TO_ADDR
// animal := CreateHuman ;
46156: LD_ADDR_VAR 0 12
46160: PUSH
46161: CALL_OW 44
46165: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46166: LD_VAR 0 12
46170: PPUSH
46171: LD_VAR 0 8
46175: PPUSH
46176: LD_INT 0
46178: PPUSH
46179: CALL 52702 0 3
// end ;
46183: GO 46120
46185: POP
46186: POP
// if apemans then
46187: LD_VAR 0 3
46191: IFFALSE 46314
// for i = 1 to apemans do
46193: LD_ADDR_VAR 0 11
46197: PUSH
46198: DOUBLE
46199: LD_INT 1
46201: DEC
46202: ST_TO_ADDR
46203: LD_VAR 0 3
46207: PUSH
46208: FOR_TO
46209: IFFALSE 46312
// begin hc_class = class_apeman ;
46211: LD_ADDR_OWVAR 28
46215: PUSH
46216: LD_INT 12
46218: ST_TO_ADDR
// hc_gallery =  ;
46219: LD_ADDR_OWVAR 33
46223: PUSH
46224: LD_STRING 
46226: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46227: LD_ADDR_OWVAR 35
46231: PUSH
46232: LD_INT 5
46234: NEG
46235: PPUSH
46236: LD_INT 5
46238: PPUSH
46239: CALL_OW 12
46243: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46244: LD_ADDR_OWVAR 31
46248: PUSH
46249: LD_INT 1
46251: PPUSH
46252: LD_INT 3
46254: PPUSH
46255: CALL_OW 12
46259: PUSH
46260: LD_INT 1
46262: PPUSH
46263: LD_INT 3
46265: PPUSH
46266: CALL_OW 12
46270: PUSH
46271: LD_INT 0
46273: PUSH
46274: LD_INT 0
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: ST_TO_ADDR
// animal := CreateHuman ;
46283: LD_ADDR_VAR 0 12
46287: PUSH
46288: CALL_OW 44
46292: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46293: LD_VAR 0 12
46297: PPUSH
46298: LD_VAR 0 8
46302: PPUSH
46303: LD_INT 0
46305: PPUSH
46306: CALL 52702 0 3
// end ;
46310: GO 46208
46312: POP
46313: POP
// if enchidnas then
46314: LD_VAR 0 4
46318: IFFALSE 46385
// for i = 1 to enchidnas do
46320: LD_ADDR_VAR 0 11
46324: PUSH
46325: DOUBLE
46326: LD_INT 1
46328: DEC
46329: ST_TO_ADDR
46330: LD_VAR 0 4
46334: PUSH
46335: FOR_TO
46336: IFFALSE 46383
// begin hc_class = 13 ;
46338: LD_ADDR_OWVAR 28
46342: PUSH
46343: LD_INT 13
46345: ST_TO_ADDR
// hc_gallery =  ;
46346: LD_ADDR_OWVAR 33
46350: PUSH
46351: LD_STRING 
46353: ST_TO_ADDR
// animal := CreateHuman ;
46354: LD_ADDR_VAR 0 12
46358: PUSH
46359: CALL_OW 44
46363: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46364: LD_VAR 0 12
46368: PPUSH
46369: LD_VAR 0 8
46373: PPUSH
46374: LD_INT 0
46376: PPUSH
46377: CALL 52702 0 3
// end ;
46381: GO 46335
46383: POP
46384: POP
// if fishes then
46385: LD_VAR 0 7
46389: IFFALSE 46456
// for i = 1 to fishes do
46391: LD_ADDR_VAR 0 11
46395: PUSH
46396: DOUBLE
46397: LD_INT 1
46399: DEC
46400: ST_TO_ADDR
46401: LD_VAR 0 7
46405: PUSH
46406: FOR_TO
46407: IFFALSE 46454
// begin hc_class = 20 ;
46409: LD_ADDR_OWVAR 28
46413: PUSH
46414: LD_INT 20
46416: ST_TO_ADDR
// hc_gallery =  ;
46417: LD_ADDR_OWVAR 33
46421: PUSH
46422: LD_STRING 
46424: ST_TO_ADDR
// animal := CreateHuman ;
46425: LD_ADDR_VAR 0 12
46429: PUSH
46430: CALL_OW 44
46434: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46435: LD_VAR 0 12
46439: PPUSH
46440: LD_VAR 0 9
46444: PPUSH
46445: LD_INT 0
46447: PPUSH
46448: CALL 52702 0 3
// end ;
46452: GO 46406
46454: POP
46455: POP
// end ;
46456: LD_VAR 0 10
46460: RET
// export function WantHeal ( sci , unit ) ; begin
46461: LD_INT 0
46463: PPUSH
// if GetTaskList ( sci ) > 0 then
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 437
46473: PUSH
46474: LD_INT 0
46476: GREATER
46477: IFFALSE 46547
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46479: LD_VAR 0 1
46483: PPUSH
46484: CALL_OW 437
46488: PUSH
46489: LD_INT 1
46491: ARRAY
46492: PUSH
46493: LD_INT 1
46495: ARRAY
46496: PUSH
46497: LD_STRING l
46499: EQUAL
46500: PUSH
46501: LD_VAR 0 1
46505: PPUSH
46506: CALL_OW 437
46510: PUSH
46511: LD_INT 1
46513: ARRAY
46514: PUSH
46515: LD_INT 4
46517: ARRAY
46518: PUSH
46519: LD_VAR 0 2
46523: EQUAL
46524: AND
46525: IFFALSE 46537
// result := true else
46527: LD_ADDR_VAR 0 3
46531: PUSH
46532: LD_INT 1
46534: ST_TO_ADDR
46535: GO 46545
// result := false ;
46537: LD_ADDR_VAR 0 3
46541: PUSH
46542: LD_INT 0
46544: ST_TO_ADDR
// end else
46545: GO 46555
// result := false ;
46547: LD_ADDR_VAR 0 3
46551: PUSH
46552: LD_INT 0
46554: ST_TO_ADDR
// end ;
46555: LD_VAR 0 3
46559: RET
// export function HealTarget ( sci ) ; begin
46560: LD_INT 0
46562: PPUSH
// if not sci then
46563: LD_VAR 0 1
46567: NOT
46568: IFFALSE 46572
// exit ;
46570: GO 46637
// result := 0 ;
46572: LD_ADDR_VAR 0 2
46576: PUSH
46577: LD_INT 0
46579: ST_TO_ADDR
// if GetTaskList ( sci ) then
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 437
46589: IFFALSE 46637
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46591: LD_VAR 0 1
46595: PPUSH
46596: CALL_OW 437
46600: PUSH
46601: LD_INT 1
46603: ARRAY
46604: PUSH
46605: LD_INT 1
46607: ARRAY
46608: PUSH
46609: LD_STRING l
46611: EQUAL
46612: IFFALSE 46637
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46614: LD_ADDR_VAR 0 2
46618: PUSH
46619: LD_VAR 0 1
46623: PPUSH
46624: CALL_OW 437
46628: PUSH
46629: LD_INT 1
46631: ARRAY
46632: PUSH
46633: LD_INT 4
46635: ARRAY
46636: ST_TO_ADDR
// end ;
46637: LD_VAR 0 2
46641: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
46642: LD_INT 0
46644: PPUSH
46645: PPUSH
46646: PPUSH
46647: PPUSH
46648: PPUSH
46649: PPUSH
46650: PPUSH
46651: PPUSH
46652: PPUSH
46653: PPUSH
46654: PPUSH
46655: PPUSH
46656: PPUSH
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
46661: PPUSH
46662: PPUSH
46663: PPUSH
46664: PPUSH
46665: PPUSH
46666: PPUSH
46667: PPUSH
46668: PPUSH
46669: PPUSH
46670: PPUSH
46671: PPUSH
46672: PPUSH
46673: PPUSH
46674: PPUSH
46675: PPUSH
46676: PPUSH
46677: PPUSH
// if not list then
46678: LD_VAR 0 1
46682: NOT
46683: IFFALSE 46687
// exit ;
46685: GO 51313
// base := list [ 1 ] ;
46687: LD_ADDR_VAR 0 3
46691: PUSH
46692: LD_VAR 0 1
46696: PUSH
46697: LD_INT 1
46699: ARRAY
46700: ST_TO_ADDR
// group := list [ 2 ] ;
46701: LD_ADDR_VAR 0 4
46705: PUSH
46706: LD_VAR 0 1
46710: PUSH
46711: LD_INT 2
46713: ARRAY
46714: ST_TO_ADDR
// path := list [ 3 ] ;
46715: LD_ADDR_VAR 0 5
46719: PUSH
46720: LD_VAR 0 1
46724: PUSH
46725: LD_INT 3
46727: ARRAY
46728: ST_TO_ADDR
// flags := list [ 4 ] ;
46729: LD_ADDR_VAR 0 6
46733: PUSH
46734: LD_VAR 0 1
46738: PUSH
46739: LD_INT 4
46741: ARRAY
46742: ST_TO_ADDR
// mined := [ ] ;
46743: LD_ADDR_VAR 0 27
46747: PUSH
46748: EMPTY
46749: ST_TO_ADDR
// bombed := [ ] ;
46750: LD_ADDR_VAR 0 28
46754: PUSH
46755: EMPTY
46756: ST_TO_ADDR
// healers := [ ] ;
46757: LD_ADDR_VAR 0 31
46761: PUSH
46762: EMPTY
46763: ST_TO_ADDR
// to_heal := [ ] ;
46764: LD_ADDR_VAR 0 30
46768: PUSH
46769: EMPTY
46770: ST_TO_ADDR
// repairs := [ ] ;
46771: LD_ADDR_VAR 0 33
46775: PUSH
46776: EMPTY
46777: ST_TO_ADDR
// to_repair := [ ] ;
46778: LD_ADDR_VAR 0 32
46782: PUSH
46783: EMPTY
46784: ST_TO_ADDR
// if not group or not path then
46785: LD_VAR 0 4
46789: NOT
46790: PUSH
46791: LD_VAR 0 5
46795: NOT
46796: OR
46797: IFFALSE 46801
// exit ;
46799: GO 51313
// side := GetSide ( group [ 1 ] ) ;
46801: LD_ADDR_VAR 0 35
46805: PUSH
46806: LD_VAR 0 4
46810: PUSH
46811: LD_INT 1
46813: ARRAY
46814: PPUSH
46815: CALL_OW 255
46819: ST_TO_ADDR
// if flags then
46820: LD_VAR 0 6
46824: IFFALSE 46968
// begin f_ignore_area := flags [ 1 ] ;
46826: LD_ADDR_VAR 0 17
46830: PUSH
46831: LD_VAR 0 6
46835: PUSH
46836: LD_INT 1
46838: ARRAY
46839: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
46840: LD_ADDR_VAR 0 18
46844: PUSH
46845: LD_VAR 0 6
46849: PUSH
46850: LD_INT 2
46852: ARRAY
46853: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
46854: LD_ADDR_VAR 0 19
46858: PUSH
46859: LD_VAR 0 6
46863: PUSH
46864: LD_INT 3
46866: ARRAY
46867: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
46868: LD_ADDR_VAR 0 20
46872: PUSH
46873: LD_VAR 0 6
46877: PUSH
46878: LD_INT 4
46880: ARRAY
46881: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
46882: LD_ADDR_VAR 0 21
46886: PUSH
46887: LD_VAR 0 6
46891: PUSH
46892: LD_INT 5
46894: ARRAY
46895: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
46896: LD_ADDR_VAR 0 22
46900: PUSH
46901: LD_VAR 0 6
46905: PUSH
46906: LD_INT 6
46908: ARRAY
46909: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
46910: LD_ADDR_VAR 0 23
46914: PUSH
46915: LD_VAR 0 6
46919: PUSH
46920: LD_INT 7
46922: ARRAY
46923: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
46924: LD_ADDR_VAR 0 24
46928: PUSH
46929: LD_VAR 0 6
46933: PUSH
46934: LD_INT 8
46936: ARRAY
46937: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
46938: LD_ADDR_VAR 0 25
46942: PUSH
46943: LD_VAR 0 6
46947: PUSH
46948: LD_INT 9
46950: ARRAY
46951: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
46952: LD_ADDR_VAR 0 26
46956: PUSH
46957: LD_VAR 0 6
46961: PUSH
46962: LD_INT 10
46964: ARRAY
46965: ST_TO_ADDR
// end else
46966: GO 47048
// begin f_ignore_area := false ;
46968: LD_ADDR_VAR 0 17
46972: PUSH
46973: LD_INT 0
46975: ST_TO_ADDR
// f_capture := false ;
46976: LD_ADDR_VAR 0 18
46980: PUSH
46981: LD_INT 0
46983: ST_TO_ADDR
// f_ignore_civ := false ;
46984: LD_ADDR_VAR 0 19
46988: PUSH
46989: LD_INT 0
46991: ST_TO_ADDR
// f_murder := false ;
46992: LD_ADDR_VAR 0 20
46996: PUSH
46997: LD_INT 0
46999: ST_TO_ADDR
// f_mines := false ;
47000: LD_ADDR_VAR 0 21
47004: PUSH
47005: LD_INT 0
47007: ST_TO_ADDR
// f_repair := false ;
47008: LD_ADDR_VAR 0 22
47012: PUSH
47013: LD_INT 0
47015: ST_TO_ADDR
// f_heal := false ;
47016: LD_ADDR_VAR 0 23
47020: PUSH
47021: LD_INT 0
47023: ST_TO_ADDR
// f_spacetime := false ;
47024: LD_ADDR_VAR 0 24
47028: PUSH
47029: LD_INT 0
47031: ST_TO_ADDR
// f_attack_depot := false ;
47032: LD_ADDR_VAR 0 25
47036: PUSH
47037: LD_INT 0
47039: ST_TO_ADDR
// f_crawl := false ;
47040: LD_ADDR_VAR 0 26
47044: PUSH
47045: LD_INT 0
47047: ST_TO_ADDR
// end ; if f_heal then
47048: LD_VAR 0 23
47052: IFFALSE 47079
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
47054: LD_ADDR_VAR 0 31
47058: PUSH
47059: LD_VAR 0 4
47063: PPUSH
47064: LD_INT 25
47066: PUSH
47067: LD_INT 4
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PPUSH
47074: CALL_OW 72
47078: ST_TO_ADDR
// if f_repair then
47079: LD_VAR 0 22
47083: IFFALSE 47110
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
47085: LD_ADDR_VAR 0 33
47089: PUSH
47090: LD_VAR 0 4
47094: PPUSH
47095: LD_INT 25
47097: PUSH
47098: LD_INT 3
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PPUSH
47105: CALL_OW 72
47109: ST_TO_ADDR
// units_path := [ ] ;
47110: LD_ADDR_VAR 0 16
47114: PUSH
47115: EMPTY
47116: ST_TO_ADDR
// for i = 1 to group do
47117: LD_ADDR_VAR 0 7
47121: PUSH
47122: DOUBLE
47123: LD_INT 1
47125: DEC
47126: ST_TO_ADDR
47127: LD_VAR 0 4
47131: PUSH
47132: FOR_TO
47133: IFFALSE 47162
// units_path := Replace ( units_path , i , path ) ;
47135: LD_ADDR_VAR 0 16
47139: PUSH
47140: LD_VAR 0 16
47144: PPUSH
47145: LD_VAR 0 7
47149: PPUSH
47150: LD_VAR 0 5
47154: PPUSH
47155: CALL_OW 1
47159: ST_TO_ADDR
47160: GO 47132
47162: POP
47163: POP
// repeat for i = group downto 1 do
47164: LD_ADDR_VAR 0 7
47168: PUSH
47169: DOUBLE
47170: LD_VAR 0 4
47174: INC
47175: ST_TO_ADDR
47176: LD_INT 1
47178: PUSH
47179: FOR_DOWNTO
47180: IFFALSE 51276
// begin wait ( 5 ) ;
47182: LD_INT 5
47184: PPUSH
47185: CALL_OW 67
// tmp := [ ] ;
47189: LD_ADDR_VAR 0 14
47193: PUSH
47194: EMPTY
47195: ST_TO_ADDR
// attacking := false ;
47196: LD_ADDR_VAR 0 29
47200: PUSH
47201: LD_INT 0
47203: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
47204: LD_VAR 0 4
47208: PUSH
47209: LD_VAR 0 7
47213: ARRAY
47214: PPUSH
47215: CALL_OW 301
47219: PUSH
47220: LD_VAR 0 4
47224: PUSH
47225: LD_VAR 0 7
47229: ARRAY
47230: NOT
47231: OR
47232: IFFALSE 47341
// begin if GetType ( group [ i ] ) = unit_human then
47234: LD_VAR 0 4
47238: PUSH
47239: LD_VAR 0 7
47243: ARRAY
47244: PPUSH
47245: CALL_OW 247
47249: PUSH
47250: LD_INT 1
47252: EQUAL
47253: IFFALSE 47299
// begin to_heal := to_heal diff group [ i ] ;
47255: LD_ADDR_VAR 0 30
47259: PUSH
47260: LD_VAR 0 30
47264: PUSH
47265: LD_VAR 0 4
47269: PUSH
47270: LD_VAR 0 7
47274: ARRAY
47275: DIFF
47276: ST_TO_ADDR
// healers := healers diff group [ i ] ;
47277: LD_ADDR_VAR 0 31
47281: PUSH
47282: LD_VAR 0 31
47286: PUSH
47287: LD_VAR 0 4
47291: PUSH
47292: LD_VAR 0 7
47296: ARRAY
47297: DIFF
47298: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
47299: LD_ADDR_VAR 0 4
47303: PUSH
47304: LD_VAR 0 4
47308: PPUSH
47309: LD_VAR 0 7
47313: PPUSH
47314: CALL_OW 3
47318: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
47319: LD_ADDR_VAR 0 16
47323: PUSH
47324: LD_VAR 0 16
47328: PPUSH
47329: LD_VAR 0 7
47333: PPUSH
47334: CALL_OW 3
47338: ST_TO_ADDR
// continue ;
47339: GO 47179
// end ; if f_repair then
47341: LD_VAR 0 22
47345: IFFALSE 47834
// begin if GetType ( group [ i ] ) = unit_vehicle then
47347: LD_VAR 0 4
47351: PUSH
47352: LD_VAR 0 7
47356: ARRAY
47357: PPUSH
47358: CALL_OW 247
47362: PUSH
47363: LD_INT 2
47365: EQUAL
47366: IFFALSE 47556
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
47368: LD_VAR 0 4
47372: PUSH
47373: LD_VAR 0 7
47377: ARRAY
47378: PPUSH
47379: CALL_OW 256
47383: PUSH
47384: LD_INT 700
47386: LESS
47387: PUSH
47388: LD_VAR 0 4
47392: PUSH
47393: LD_VAR 0 7
47397: ARRAY
47398: PUSH
47399: LD_VAR 0 32
47403: IN
47404: NOT
47405: AND
47406: IFFALSE 47430
// to_repair := to_repair union group [ i ] ;
47408: LD_ADDR_VAR 0 32
47412: PUSH
47413: LD_VAR 0 32
47417: PUSH
47418: LD_VAR 0 4
47422: PUSH
47423: LD_VAR 0 7
47427: ARRAY
47428: UNION
47429: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
47430: LD_VAR 0 4
47434: PUSH
47435: LD_VAR 0 7
47439: ARRAY
47440: PPUSH
47441: CALL_OW 256
47445: PUSH
47446: LD_INT 1000
47448: EQUAL
47449: PUSH
47450: LD_VAR 0 4
47454: PUSH
47455: LD_VAR 0 7
47459: ARRAY
47460: PUSH
47461: LD_VAR 0 32
47465: IN
47466: AND
47467: IFFALSE 47491
// to_repair := to_repair diff group [ i ] ;
47469: LD_ADDR_VAR 0 32
47473: PUSH
47474: LD_VAR 0 32
47478: PUSH
47479: LD_VAR 0 4
47483: PUSH
47484: LD_VAR 0 7
47488: ARRAY
47489: DIFF
47490: ST_TO_ADDR
// if group [ i ] in to_repair then
47491: LD_VAR 0 4
47495: PUSH
47496: LD_VAR 0 7
47500: ARRAY
47501: PUSH
47502: LD_VAR 0 32
47506: IN
47507: IFFALSE 47554
// begin if not IsInArea ( group [ i ] , f_repair ) then
47509: LD_VAR 0 4
47513: PUSH
47514: LD_VAR 0 7
47518: ARRAY
47519: PPUSH
47520: LD_VAR 0 22
47524: PPUSH
47525: CALL_OW 308
47529: NOT
47530: IFFALSE 47552
// ComMoveToArea ( group [ i ] , f_repair ) ;
47532: LD_VAR 0 4
47536: PUSH
47537: LD_VAR 0 7
47541: ARRAY
47542: PPUSH
47543: LD_VAR 0 22
47547: PPUSH
47548: CALL_OW 113
// continue ;
47552: GO 47179
// end ; end else
47554: GO 47834
// if group [ i ] in repairs then
47556: LD_VAR 0 4
47560: PUSH
47561: LD_VAR 0 7
47565: ARRAY
47566: PUSH
47567: LD_VAR 0 33
47571: IN
47572: IFFALSE 47834
// begin if IsInUnit ( group [ i ] ) then
47574: LD_VAR 0 4
47578: PUSH
47579: LD_VAR 0 7
47583: ARRAY
47584: PPUSH
47585: CALL_OW 310
47589: IFFALSE 47657
// begin z := IsInUnit ( group [ i ] ) ;
47591: LD_ADDR_VAR 0 13
47595: PUSH
47596: LD_VAR 0 4
47600: PUSH
47601: LD_VAR 0 7
47605: ARRAY
47606: PPUSH
47607: CALL_OW 310
47611: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
47612: LD_VAR 0 13
47616: PUSH
47617: LD_VAR 0 32
47621: IN
47622: PUSH
47623: LD_VAR 0 13
47627: PPUSH
47628: LD_VAR 0 22
47632: PPUSH
47633: CALL_OW 308
47637: AND
47638: IFFALSE 47655
// ComExitVehicle ( group [ i ] ) ;
47640: LD_VAR 0 4
47644: PUSH
47645: LD_VAR 0 7
47649: ARRAY
47650: PPUSH
47651: CALL_OW 121
// end else
47655: GO 47834
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
47657: LD_ADDR_VAR 0 13
47661: PUSH
47662: LD_VAR 0 4
47666: PPUSH
47667: LD_INT 95
47669: PUSH
47670: LD_VAR 0 22
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: PUSH
47679: LD_INT 58
47681: PUSH
47682: EMPTY
47683: LIST
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: PPUSH
47689: CALL_OW 72
47693: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
47694: LD_VAR 0 4
47698: PUSH
47699: LD_VAR 0 7
47703: ARRAY
47704: PPUSH
47705: CALL_OW 314
47709: NOT
47710: IFFALSE 47832
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
47712: LD_ADDR_VAR 0 10
47716: PUSH
47717: LD_VAR 0 13
47721: PPUSH
47722: LD_VAR 0 4
47726: PUSH
47727: LD_VAR 0 7
47731: ARRAY
47732: PPUSH
47733: CALL_OW 74
47737: ST_TO_ADDR
// if not x then
47738: LD_VAR 0 10
47742: NOT
47743: IFFALSE 47747
// continue ;
47745: GO 47179
// if GetLives ( x ) < 1000 then
47747: LD_VAR 0 10
47751: PPUSH
47752: CALL_OW 256
47756: PUSH
47757: LD_INT 1000
47759: LESS
47760: IFFALSE 47784
// ComRepairVehicle ( group [ i ] , x ) else
47762: LD_VAR 0 4
47766: PUSH
47767: LD_VAR 0 7
47771: ARRAY
47772: PPUSH
47773: LD_VAR 0 10
47777: PPUSH
47778: CALL_OW 129
47782: GO 47832
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
47784: LD_VAR 0 23
47788: PUSH
47789: LD_VAR 0 4
47793: PUSH
47794: LD_VAR 0 7
47798: ARRAY
47799: PPUSH
47800: CALL_OW 256
47804: PUSH
47805: LD_INT 1000
47807: LESS
47808: AND
47809: NOT
47810: IFFALSE 47832
// ComEnterUnit ( group [ i ] , x ) ;
47812: LD_VAR 0 4
47816: PUSH
47817: LD_VAR 0 7
47821: ARRAY
47822: PPUSH
47823: LD_VAR 0 10
47827: PPUSH
47828: CALL_OW 120
// end ; continue ;
47832: GO 47179
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
47834: LD_VAR 0 23
47838: PUSH
47839: LD_VAR 0 4
47843: PUSH
47844: LD_VAR 0 7
47848: ARRAY
47849: PPUSH
47850: CALL_OW 247
47854: PUSH
47855: LD_INT 1
47857: EQUAL
47858: AND
47859: IFFALSE 48337
// begin if group [ i ] in healers then
47861: LD_VAR 0 4
47865: PUSH
47866: LD_VAR 0 7
47870: ARRAY
47871: PUSH
47872: LD_VAR 0 31
47876: IN
47877: IFFALSE 48150
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
47879: LD_VAR 0 4
47883: PUSH
47884: LD_VAR 0 7
47888: ARRAY
47889: PPUSH
47890: LD_VAR 0 23
47894: PPUSH
47895: CALL_OW 308
47899: NOT
47900: PUSH
47901: LD_VAR 0 4
47905: PUSH
47906: LD_VAR 0 7
47910: ARRAY
47911: PPUSH
47912: CALL_OW 314
47916: NOT
47917: AND
47918: IFFALSE 47942
// ComMoveToArea ( group [ i ] , f_heal ) else
47920: LD_VAR 0 4
47924: PUSH
47925: LD_VAR 0 7
47929: ARRAY
47930: PPUSH
47931: LD_VAR 0 23
47935: PPUSH
47936: CALL_OW 113
47940: GO 48148
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
47942: LD_VAR 0 4
47946: PUSH
47947: LD_VAR 0 7
47951: ARRAY
47952: PPUSH
47953: CALL 46560 0 1
47957: PPUSH
47958: CALL_OW 256
47962: PUSH
47963: LD_INT 1000
47965: EQUAL
47966: IFFALSE 47985
// ComStop ( group [ i ] ) else
47968: LD_VAR 0 4
47972: PUSH
47973: LD_VAR 0 7
47977: ARRAY
47978: PPUSH
47979: CALL_OW 141
47983: GO 48148
// if not HasTask ( group [ i ] ) and to_heal then
47985: LD_VAR 0 4
47989: PUSH
47990: LD_VAR 0 7
47994: ARRAY
47995: PPUSH
47996: CALL_OW 314
48000: NOT
48001: PUSH
48002: LD_VAR 0 30
48006: AND
48007: IFFALSE 48148
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
48009: LD_ADDR_VAR 0 13
48013: PUSH
48014: LD_VAR 0 30
48018: PPUSH
48019: LD_INT 3
48021: PUSH
48022: LD_INT 54
48024: PUSH
48025: EMPTY
48026: LIST
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: PPUSH
48032: CALL_OW 72
48036: PPUSH
48037: LD_VAR 0 4
48041: PUSH
48042: LD_VAR 0 7
48046: ARRAY
48047: PPUSH
48048: CALL_OW 74
48052: ST_TO_ADDR
// if z then
48053: LD_VAR 0 13
48057: IFFALSE 48148
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
48059: LD_INT 91
48061: PUSH
48062: LD_VAR 0 13
48066: PUSH
48067: LD_INT 10
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: LIST
48074: PUSH
48075: LD_INT 81
48077: PUSH
48078: LD_VAR 0 13
48082: PPUSH
48083: CALL_OW 255
48087: PUSH
48088: EMPTY
48089: LIST
48090: LIST
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PPUSH
48096: CALL_OW 69
48100: PUSH
48101: LD_INT 0
48103: EQUAL
48104: IFFALSE 48128
// ComHeal ( group [ i ] , z ) else
48106: LD_VAR 0 4
48110: PUSH
48111: LD_VAR 0 7
48115: ARRAY
48116: PPUSH
48117: LD_VAR 0 13
48121: PPUSH
48122: CALL_OW 128
48126: GO 48148
// ComMoveToArea ( group [ i ] , f_heal ) ;
48128: LD_VAR 0 4
48132: PUSH
48133: LD_VAR 0 7
48137: ARRAY
48138: PPUSH
48139: LD_VAR 0 23
48143: PPUSH
48144: CALL_OW 113
// end ; continue ;
48148: GO 47179
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
48150: LD_VAR 0 4
48154: PUSH
48155: LD_VAR 0 7
48159: ARRAY
48160: PPUSH
48161: CALL_OW 256
48165: PUSH
48166: LD_INT 700
48168: LESS
48169: PUSH
48170: LD_VAR 0 4
48174: PUSH
48175: LD_VAR 0 7
48179: ARRAY
48180: PUSH
48181: LD_VAR 0 30
48185: IN
48186: NOT
48187: AND
48188: IFFALSE 48212
// to_heal := to_heal union group [ i ] ;
48190: LD_ADDR_VAR 0 30
48194: PUSH
48195: LD_VAR 0 30
48199: PUSH
48200: LD_VAR 0 4
48204: PUSH
48205: LD_VAR 0 7
48209: ARRAY
48210: UNION
48211: ST_TO_ADDR
// if group [ i ] in to_heal then
48212: LD_VAR 0 4
48216: PUSH
48217: LD_VAR 0 7
48221: ARRAY
48222: PUSH
48223: LD_VAR 0 30
48227: IN
48228: IFFALSE 48337
// begin if GetLives ( group [ i ] ) = 1000 then
48230: LD_VAR 0 4
48234: PUSH
48235: LD_VAR 0 7
48239: ARRAY
48240: PPUSH
48241: CALL_OW 256
48245: PUSH
48246: LD_INT 1000
48248: EQUAL
48249: IFFALSE 48275
// to_heal := to_heal diff group [ i ] else
48251: LD_ADDR_VAR 0 30
48255: PUSH
48256: LD_VAR 0 30
48260: PUSH
48261: LD_VAR 0 4
48265: PUSH
48266: LD_VAR 0 7
48270: ARRAY
48271: DIFF
48272: ST_TO_ADDR
48273: GO 48337
// begin if not IsInArea ( group [ i ] , to_heal ) then
48275: LD_VAR 0 4
48279: PUSH
48280: LD_VAR 0 7
48284: ARRAY
48285: PPUSH
48286: LD_VAR 0 30
48290: PPUSH
48291: CALL_OW 308
48295: NOT
48296: IFFALSE 48320
// ComMoveToArea ( group [ i ] , f_heal ) else
48298: LD_VAR 0 4
48302: PUSH
48303: LD_VAR 0 7
48307: ARRAY
48308: PPUSH
48309: LD_VAR 0 23
48313: PPUSH
48314: CALL_OW 113
48318: GO 48335
// ComHold ( group [ i ] ) ;
48320: LD_VAR 0 4
48324: PUSH
48325: LD_VAR 0 7
48329: ARRAY
48330: PPUSH
48331: CALL_OW 140
// continue ;
48335: GO 47179
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
48337: LD_VAR 0 4
48341: PUSH
48342: LD_VAR 0 7
48346: ARRAY
48347: PPUSH
48348: LD_INT 10
48350: PPUSH
48351: CALL 44957 0 2
48355: NOT
48356: PUSH
48357: LD_VAR 0 16
48361: PUSH
48362: LD_VAR 0 7
48366: ARRAY
48367: PUSH
48368: EMPTY
48369: EQUAL
48370: NOT
48371: AND
48372: IFFALSE 48638
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
48374: LD_VAR 0 4
48378: PUSH
48379: LD_VAR 0 7
48383: ARRAY
48384: PPUSH
48385: CALL_OW 262
48389: PUSH
48390: LD_INT 1
48392: PUSH
48393: LD_INT 2
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: IN
48400: IFFALSE 48441
// if GetFuel ( group [ i ] ) < 10 then
48402: LD_VAR 0 4
48406: PUSH
48407: LD_VAR 0 7
48411: ARRAY
48412: PPUSH
48413: CALL_OW 261
48417: PUSH
48418: LD_INT 10
48420: LESS
48421: IFFALSE 48441
// SetFuel ( group [ i ] , 12 ) ;
48423: LD_VAR 0 4
48427: PUSH
48428: LD_VAR 0 7
48432: ARRAY
48433: PPUSH
48434: LD_INT 12
48436: PPUSH
48437: CALL_OW 240
// if units_path [ i ] then
48441: LD_VAR 0 16
48445: PUSH
48446: LD_VAR 0 7
48450: ARRAY
48451: IFFALSE 48636
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
48453: LD_VAR 0 4
48457: PUSH
48458: LD_VAR 0 7
48462: ARRAY
48463: PPUSH
48464: LD_VAR 0 16
48468: PUSH
48469: LD_VAR 0 7
48473: ARRAY
48474: PUSH
48475: LD_INT 1
48477: ARRAY
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PPUSH
48483: LD_VAR 0 16
48487: PUSH
48488: LD_VAR 0 7
48492: ARRAY
48493: PUSH
48494: LD_INT 1
48496: ARRAY
48497: PUSH
48498: LD_INT 2
48500: ARRAY
48501: PPUSH
48502: CALL_OW 297
48506: PUSH
48507: LD_INT 6
48509: GREATER
48510: IFFALSE 48585
// begin if not HasTask ( group [ i ] ) then
48512: LD_VAR 0 4
48516: PUSH
48517: LD_VAR 0 7
48521: ARRAY
48522: PPUSH
48523: CALL_OW 314
48527: NOT
48528: IFFALSE 48583
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
48530: LD_VAR 0 4
48534: PUSH
48535: LD_VAR 0 7
48539: ARRAY
48540: PPUSH
48541: LD_VAR 0 16
48545: PUSH
48546: LD_VAR 0 7
48550: ARRAY
48551: PUSH
48552: LD_INT 1
48554: ARRAY
48555: PUSH
48556: LD_INT 1
48558: ARRAY
48559: PPUSH
48560: LD_VAR 0 16
48564: PUSH
48565: LD_VAR 0 7
48569: ARRAY
48570: PUSH
48571: LD_INT 1
48573: ARRAY
48574: PUSH
48575: LD_INT 2
48577: ARRAY
48578: PPUSH
48579: CALL_OW 114
// end else
48583: GO 48636
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
48585: LD_ADDR_VAR 0 15
48589: PUSH
48590: LD_VAR 0 16
48594: PUSH
48595: LD_VAR 0 7
48599: ARRAY
48600: PPUSH
48601: LD_INT 1
48603: PPUSH
48604: CALL_OW 3
48608: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
48609: LD_ADDR_VAR 0 16
48613: PUSH
48614: LD_VAR 0 16
48618: PPUSH
48619: LD_VAR 0 7
48623: PPUSH
48624: LD_VAR 0 15
48628: PPUSH
48629: CALL_OW 1
48633: ST_TO_ADDR
// continue ;
48634: GO 47179
// end ; end ; end else
48636: GO 51274
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
48638: LD_ADDR_VAR 0 14
48642: PUSH
48643: LD_INT 81
48645: PUSH
48646: LD_VAR 0 4
48650: PUSH
48651: LD_VAR 0 7
48655: ARRAY
48656: PPUSH
48657: CALL_OW 255
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PPUSH
48666: CALL_OW 69
48670: ST_TO_ADDR
// if not tmp then
48671: LD_VAR 0 14
48675: NOT
48676: IFFALSE 48680
// continue ;
48678: GO 47179
// if f_ignore_area then
48680: LD_VAR 0 17
48684: IFFALSE 48772
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
48686: LD_ADDR_VAR 0 15
48690: PUSH
48691: LD_VAR 0 14
48695: PPUSH
48696: LD_INT 3
48698: PUSH
48699: LD_INT 92
48701: PUSH
48702: LD_VAR 0 17
48706: PUSH
48707: LD_INT 1
48709: ARRAY
48710: PUSH
48711: LD_VAR 0 17
48715: PUSH
48716: LD_INT 2
48718: ARRAY
48719: PUSH
48720: LD_VAR 0 17
48724: PUSH
48725: LD_INT 3
48727: ARRAY
48728: PUSH
48729: EMPTY
48730: LIST
48731: LIST
48732: LIST
48733: LIST
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PPUSH
48739: CALL_OW 72
48743: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
48744: LD_VAR 0 14
48748: PUSH
48749: LD_VAR 0 15
48753: DIFF
48754: IFFALSE 48772
// tmp := tmp diff tmp2 ;
48756: LD_ADDR_VAR 0 14
48760: PUSH
48761: LD_VAR 0 14
48765: PUSH
48766: LD_VAR 0 15
48770: DIFF
48771: ST_TO_ADDR
// end ; if not f_murder then
48772: LD_VAR 0 20
48776: NOT
48777: IFFALSE 48835
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
48779: LD_ADDR_VAR 0 15
48783: PUSH
48784: LD_VAR 0 14
48788: PPUSH
48789: LD_INT 3
48791: PUSH
48792: LD_INT 50
48794: PUSH
48795: EMPTY
48796: LIST
48797: PUSH
48798: EMPTY
48799: LIST
48800: LIST
48801: PPUSH
48802: CALL_OW 72
48806: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
48807: LD_VAR 0 14
48811: PUSH
48812: LD_VAR 0 15
48816: DIFF
48817: IFFALSE 48835
// tmp := tmp diff tmp2 ;
48819: LD_ADDR_VAR 0 14
48823: PUSH
48824: LD_VAR 0 14
48828: PUSH
48829: LD_VAR 0 15
48833: DIFF
48834: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
48835: LD_ADDR_VAR 0 14
48839: PUSH
48840: LD_VAR 0 4
48844: PUSH
48845: LD_VAR 0 7
48849: ARRAY
48850: PPUSH
48851: LD_VAR 0 14
48855: PPUSH
48856: LD_INT 1
48858: PPUSH
48859: LD_INT 1
48861: PPUSH
48862: CALL 18600 0 4
48866: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
48867: LD_VAR 0 4
48871: PUSH
48872: LD_VAR 0 7
48876: ARRAY
48877: PPUSH
48878: CALL_OW 257
48882: PUSH
48883: LD_INT 1
48885: EQUAL
48886: IFFALSE 49334
// begin if WantPlant ( group [ i ] ) then
48888: LD_VAR 0 4
48892: PUSH
48893: LD_VAR 0 7
48897: ARRAY
48898: PPUSH
48899: CALL 18101 0 1
48903: IFFALSE 48907
// continue ;
48905: GO 47179
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
48907: LD_VAR 0 18
48911: PUSH
48912: LD_VAR 0 4
48916: PUSH
48917: LD_VAR 0 7
48921: ARRAY
48922: PPUSH
48923: CALL_OW 310
48927: NOT
48928: AND
48929: PUSH
48930: LD_VAR 0 14
48934: PUSH
48935: LD_INT 1
48937: ARRAY
48938: PUSH
48939: LD_VAR 0 14
48943: PPUSH
48944: LD_INT 21
48946: PUSH
48947: LD_INT 2
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 58
48956: PUSH
48957: EMPTY
48958: LIST
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PPUSH
48964: CALL_OW 72
48968: IN
48969: AND
48970: IFFALSE 49006
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
48972: LD_VAR 0 4
48976: PUSH
48977: LD_VAR 0 7
48981: ARRAY
48982: PPUSH
48983: LD_VAR 0 14
48987: PUSH
48988: LD_INT 1
48990: ARRAY
48991: PPUSH
48992: CALL_OW 120
// attacking := true ;
48996: LD_ADDR_VAR 0 29
49000: PUSH
49001: LD_INT 1
49003: ST_TO_ADDR
// continue ;
49004: GO 47179
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
49006: LD_VAR 0 26
49010: PUSH
49011: LD_VAR 0 4
49015: PUSH
49016: LD_VAR 0 7
49020: ARRAY
49021: PPUSH
49022: CALL_OW 257
49026: PUSH
49027: LD_INT 1
49029: EQUAL
49030: AND
49031: PUSH
49032: LD_VAR 0 4
49036: PUSH
49037: LD_VAR 0 7
49041: ARRAY
49042: PPUSH
49043: CALL_OW 256
49047: PUSH
49048: LD_INT 800
49050: LESS
49051: AND
49052: PUSH
49053: LD_VAR 0 4
49057: PUSH
49058: LD_VAR 0 7
49062: ARRAY
49063: PPUSH
49064: CALL_OW 318
49068: NOT
49069: AND
49070: IFFALSE 49087
// ComCrawl ( group [ i ] ) ;
49072: LD_VAR 0 4
49076: PUSH
49077: LD_VAR 0 7
49081: ARRAY
49082: PPUSH
49083: CALL_OW 137
// if f_mines then
49087: LD_VAR 0 21
49091: IFFALSE 49334
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
49093: LD_VAR 0 14
49097: PUSH
49098: LD_INT 1
49100: ARRAY
49101: PPUSH
49102: CALL_OW 247
49106: PUSH
49107: LD_INT 3
49109: EQUAL
49110: PUSH
49111: LD_VAR 0 14
49115: PUSH
49116: LD_INT 1
49118: ARRAY
49119: PUSH
49120: LD_VAR 0 27
49124: IN
49125: NOT
49126: AND
49127: IFFALSE 49334
// begin x := GetX ( tmp [ 1 ] ) ;
49129: LD_ADDR_VAR 0 10
49133: PUSH
49134: LD_VAR 0 14
49138: PUSH
49139: LD_INT 1
49141: ARRAY
49142: PPUSH
49143: CALL_OW 250
49147: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
49148: LD_ADDR_VAR 0 11
49152: PUSH
49153: LD_VAR 0 14
49157: PUSH
49158: LD_INT 1
49160: ARRAY
49161: PPUSH
49162: CALL_OW 251
49166: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
49167: LD_ADDR_VAR 0 12
49171: PUSH
49172: LD_VAR 0 4
49176: PUSH
49177: LD_VAR 0 7
49181: ARRAY
49182: PPUSH
49183: CALL 45042 0 1
49187: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
49188: LD_VAR 0 4
49192: PUSH
49193: LD_VAR 0 7
49197: ARRAY
49198: PPUSH
49199: LD_VAR 0 10
49203: PPUSH
49204: LD_VAR 0 11
49208: PPUSH
49209: LD_VAR 0 14
49213: PUSH
49214: LD_INT 1
49216: ARRAY
49217: PPUSH
49218: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
49222: LD_VAR 0 4
49226: PUSH
49227: LD_VAR 0 7
49231: ARRAY
49232: PPUSH
49233: LD_VAR 0 10
49237: PPUSH
49238: LD_VAR 0 12
49242: PPUSH
49243: LD_INT 7
49245: PPUSH
49246: CALL_OW 272
49250: PPUSH
49251: LD_VAR 0 11
49255: PPUSH
49256: LD_VAR 0 12
49260: PPUSH
49261: LD_INT 7
49263: PPUSH
49264: CALL_OW 273
49268: PPUSH
49269: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
49273: LD_VAR 0 4
49277: PUSH
49278: LD_VAR 0 7
49282: ARRAY
49283: PPUSH
49284: LD_INT 71
49286: PPUSH
49287: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
49291: LD_ADDR_VAR 0 27
49295: PUSH
49296: LD_VAR 0 27
49300: PPUSH
49301: LD_VAR 0 27
49305: PUSH
49306: LD_INT 1
49308: PLUS
49309: PPUSH
49310: LD_VAR 0 14
49314: PUSH
49315: LD_INT 1
49317: ARRAY
49318: PPUSH
49319: CALL_OW 1
49323: ST_TO_ADDR
// attacking := true ;
49324: LD_ADDR_VAR 0 29
49328: PUSH
49329: LD_INT 1
49331: ST_TO_ADDR
// continue ;
49332: GO 47179
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
49334: LD_VAR 0 4
49338: PUSH
49339: LD_VAR 0 7
49343: ARRAY
49344: PPUSH
49345: CALL_OW 257
49349: PUSH
49350: LD_INT 17
49352: EQUAL
49353: PUSH
49354: LD_VAR 0 4
49358: PUSH
49359: LD_VAR 0 7
49363: ARRAY
49364: PPUSH
49365: CALL_OW 110
49369: PUSH
49370: LD_INT 71
49372: EQUAL
49373: NOT
49374: AND
49375: IFFALSE 49521
// begin attacking := false ;
49377: LD_ADDR_VAR 0 29
49381: PUSH
49382: LD_INT 0
49384: ST_TO_ADDR
// k := 5 ;
49385: LD_ADDR_VAR 0 9
49389: PUSH
49390: LD_INT 5
49392: ST_TO_ADDR
// if tmp < k then
49393: LD_VAR 0 14
49397: PUSH
49398: LD_VAR 0 9
49402: LESS
49403: IFFALSE 49415
// k := tmp ;
49405: LD_ADDR_VAR 0 9
49409: PUSH
49410: LD_VAR 0 14
49414: ST_TO_ADDR
// for j = 1 to k do
49415: LD_ADDR_VAR 0 8
49419: PUSH
49420: DOUBLE
49421: LD_INT 1
49423: DEC
49424: ST_TO_ADDR
49425: LD_VAR 0 9
49429: PUSH
49430: FOR_TO
49431: IFFALSE 49519
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
49433: LD_VAR 0 14
49437: PUSH
49438: LD_VAR 0 8
49442: ARRAY
49443: PUSH
49444: LD_VAR 0 14
49448: PPUSH
49449: LD_INT 58
49451: PUSH
49452: EMPTY
49453: LIST
49454: PPUSH
49455: CALL_OW 72
49459: IN
49460: NOT
49461: IFFALSE 49517
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
49463: LD_VAR 0 4
49467: PUSH
49468: LD_VAR 0 7
49472: ARRAY
49473: PPUSH
49474: LD_VAR 0 14
49478: PUSH
49479: LD_VAR 0 8
49483: ARRAY
49484: PPUSH
49485: CALL_OW 115
// attacking := true ;
49489: LD_ADDR_VAR 0 29
49493: PUSH
49494: LD_INT 1
49496: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
49497: LD_VAR 0 4
49501: PUSH
49502: LD_VAR 0 7
49506: ARRAY
49507: PPUSH
49508: LD_INT 71
49510: PPUSH
49511: CALL_OW 109
// continue ;
49515: GO 49430
// end ; end ;
49517: GO 49430
49519: POP
49520: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
49521: LD_VAR 0 4
49525: PUSH
49526: LD_VAR 0 7
49530: ARRAY
49531: PPUSH
49532: CALL_OW 257
49536: PUSH
49537: LD_INT 8
49539: EQUAL
49540: PUSH
49541: LD_VAR 0 4
49545: PUSH
49546: LD_VAR 0 7
49550: ARRAY
49551: PPUSH
49552: CALL_OW 264
49556: PUSH
49557: LD_INT 28
49559: PUSH
49560: LD_INT 45
49562: PUSH
49563: LD_INT 7
49565: PUSH
49566: LD_INT 47
49568: PUSH
49569: EMPTY
49570: LIST
49571: LIST
49572: LIST
49573: LIST
49574: IN
49575: OR
49576: IFFALSE 49806
// begin attacking := false ;
49578: LD_ADDR_VAR 0 29
49582: PUSH
49583: LD_INT 0
49585: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
49586: LD_VAR 0 14
49590: PUSH
49591: LD_INT 1
49593: ARRAY
49594: PPUSH
49595: CALL_OW 266
49599: PUSH
49600: LD_INT 32
49602: PUSH
49603: LD_INT 31
49605: PUSH
49606: LD_INT 33
49608: PUSH
49609: LD_INT 4
49611: PUSH
49612: LD_INT 5
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: IN
49622: IFFALSE 49806
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
49624: LD_ADDR_VAR 0 9
49628: PUSH
49629: LD_VAR 0 14
49633: PUSH
49634: LD_INT 1
49636: ARRAY
49637: PPUSH
49638: CALL_OW 266
49642: PPUSH
49643: LD_VAR 0 14
49647: PUSH
49648: LD_INT 1
49650: ARRAY
49651: PPUSH
49652: CALL_OW 250
49656: PPUSH
49657: LD_VAR 0 14
49661: PUSH
49662: LD_INT 1
49664: ARRAY
49665: PPUSH
49666: CALL_OW 251
49670: PPUSH
49671: LD_VAR 0 14
49675: PUSH
49676: LD_INT 1
49678: ARRAY
49679: PPUSH
49680: CALL_OW 254
49684: PPUSH
49685: LD_VAR 0 14
49689: PUSH
49690: LD_INT 1
49692: ARRAY
49693: PPUSH
49694: CALL_OW 248
49698: PPUSH
49699: LD_INT 0
49701: PPUSH
49702: CALL 26412 0 6
49706: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
49707: LD_ADDR_VAR 0 8
49711: PUSH
49712: LD_VAR 0 4
49716: PUSH
49717: LD_VAR 0 7
49721: ARRAY
49722: PPUSH
49723: LD_VAR 0 9
49727: PPUSH
49728: CALL 45105 0 2
49732: ST_TO_ADDR
// if j then
49733: LD_VAR 0 8
49737: IFFALSE 49806
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
49739: LD_VAR 0 8
49743: PUSH
49744: LD_INT 1
49746: ARRAY
49747: PPUSH
49748: LD_VAR 0 8
49752: PUSH
49753: LD_INT 2
49755: ARRAY
49756: PPUSH
49757: CALL_OW 488
49761: IFFALSE 49806
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
49763: LD_VAR 0 4
49767: PUSH
49768: LD_VAR 0 7
49772: ARRAY
49773: PPUSH
49774: LD_VAR 0 8
49778: PUSH
49779: LD_INT 1
49781: ARRAY
49782: PPUSH
49783: LD_VAR 0 8
49787: PUSH
49788: LD_INT 2
49790: ARRAY
49791: PPUSH
49792: CALL_OW 116
// attacking := true ;
49796: LD_ADDR_VAR 0 29
49800: PUSH
49801: LD_INT 1
49803: ST_TO_ADDR
// continue ;
49804: GO 47179
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
49806: LD_VAR 0 4
49810: PUSH
49811: LD_VAR 0 7
49815: ARRAY
49816: PPUSH
49817: CALL_OW 265
49821: PUSH
49822: LD_INT 11
49824: EQUAL
49825: IFFALSE 50103
// begin k := 10 ;
49827: LD_ADDR_VAR 0 9
49831: PUSH
49832: LD_INT 10
49834: ST_TO_ADDR
// x := 0 ;
49835: LD_ADDR_VAR 0 10
49839: PUSH
49840: LD_INT 0
49842: ST_TO_ADDR
// if tmp < k then
49843: LD_VAR 0 14
49847: PUSH
49848: LD_VAR 0 9
49852: LESS
49853: IFFALSE 49865
// k := tmp ;
49855: LD_ADDR_VAR 0 9
49859: PUSH
49860: LD_VAR 0 14
49864: ST_TO_ADDR
// for j = k downto 1 do
49865: LD_ADDR_VAR 0 8
49869: PUSH
49870: DOUBLE
49871: LD_VAR 0 9
49875: INC
49876: ST_TO_ADDR
49877: LD_INT 1
49879: PUSH
49880: FOR_DOWNTO
49881: IFFALSE 49956
// begin if GetType ( tmp [ j ] ) = unit_human then
49883: LD_VAR 0 14
49887: PUSH
49888: LD_VAR 0 8
49892: ARRAY
49893: PPUSH
49894: CALL_OW 247
49898: PUSH
49899: LD_INT 1
49901: EQUAL
49902: IFFALSE 49954
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
49904: LD_VAR 0 4
49908: PUSH
49909: LD_VAR 0 7
49913: ARRAY
49914: PPUSH
49915: LD_VAR 0 14
49919: PUSH
49920: LD_VAR 0 8
49924: ARRAY
49925: PPUSH
49926: CALL 45376 0 2
// x := tmp [ j ] ;
49930: LD_ADDR_VAR 0 10
49934: PUSH
49935: LD_VAR 0 14
49939: PUSH
49940: LD_VAR 0 8
49944: ARRAY
49945: ST_TO_ADDR
// attacking := true ;
49946: LD_ADDR_VAR 0 29
49950: PUSH
49951: LD_INT 1
49953: ST_TO_ADDR
// end ; end ;
49954: GO 49880
49956: POP
49957: POP
// if not x then
49958: LD_VAR 0 10
49962: NOT
49963: IFFALSE 50103
// begin attacking := true ;
49965: LD_ADDR_VAR 0 29
49969: PUSH
49970: LD_INT 1
49972: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
49973: LD_VAR 0 4
49977: PUSH
49978: LD_VAR 0 7
49982: ARRAY
49983: PPUSH
49984: CALL_OW 250
49988: PPUSH
49989: LD_VAR 0 4
49993: PUSH
49994: LD_VAR 0 7
49998: ARRAY
49999: PPUSH
50000: CALL_OW 251
50004: PPUSH
50005: CALL_OW 546
50009: PUSH
50010: LD_INT 2
50012: ARRAY
50013: PUSH
50014: LD_VAR 0 14
50018: PUSH
50019: LD_INT 1
50021: ARRAY
50022: PPUSH
50023: CALL_OW 250
50027: PPUSH
50028: LD_VAR 0 14
50032: PUSH
50033: LD_INT 1
50035: ARRAY
50036: PPUSH
50037: CALL_OW 251
50041: PPUSH
50042: CALL_OW 546
50046: PUSH
50047: LD_INT 2
50049: ARRAY
50050: EQUAL
50051: IFFALSE 50079
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
50053: LD_VAR 0 4
50057: PUSH
50058: LD_VAR 0 7
50062: ARRAY
50063: PPUSH
50064: LD_VAR 0 14
50068: PUSH
50069: LD_INT 1
50071: ARRAY
50072: PPUSH
50073: CALL 45376 0 2
50077: GO 50103
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50079: LD_VAR 0 4
50083: PUSH
50084: LD_VAR 0 7
50088: ARRAY
50089: PPUSH
50090: LD_VAR 0 14
50094: PUSH
50095: LD_INT 1
50097: ARRAY
50098: PPUSH
50099: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
50103: LD_VAR 0 4
50107: PUSH
50108: LD_VAR 0 7
50112: ARRAY
50113: PPUSH
50114: CALL_OW 264
50118: PUSH
50119: LD_INT 29
50121: EQUAL
50122: IFFALSE 50488
// begin if WantsToAttack ( group [ i ] ) in bombed then
50124: LD_VAR 0 4
50128: PUSH
50129: LD_VAR 0 7
50133: ARRAY
50134: PPUSH
50135: CALL_OW 319
50139: PUSH
50140: LD_VAR 0 28
50144: IN
50145: IFFALSE 50149
// continue ;
50147: GO 47179
// k := 8 ;
50149: LD_ADDR_VAR 0 9
50153: PUSH
50154: LD_INT 8
50156: ST_TO_ADDR
// x := 0 ;
50157: LD_ADDR_VAR 0 10
50161: PUSH
50162: LD_INT 0
50164: ST_TO_ADDR
// if tmp < k then
50165: LD_VAR 0 14
50169: PUSH
50170: LD_VAR 0 9
50174: LESS
50175: IFFALSE 50187
// k := tmp ;
50177: LD_ADDR_VAR 0 9
50181: PUSH
50182: LD_VAR 0 14
50186: ST_TO_ADDR
// for j = 1 to k do
50187: LD_ADDR_VAR 0 8
50191: PUSH
50192: DOUBLE
50193: LD_INT 1
50195: DEC
50196: ST_TO_ADDR
50197: LD_VAR 0 9
50201: PUSH
50202: FOR_TO
50203: IFFALSE 50335
// begin if GetType ( tmp [ j ] ) = unit_building then
50205: LD_VAR 0 14
50209: PUSH
50210: LD_VAR 0 8
50214: ARRAY
50215: PPUSH
50216: CALL_OW 247
50220: PUSH
50221: LD_INT 3
50223: EQUAL
50224: IFFALSE 50333
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
50226: LD_VAR 0 14
50230: PUSH
50231: LD_VAR 0 8
50235: ARRAY
50236: PUSH
50237: LD_VAR 0 28
50241: IN
50242: NOT
50243: PUSH
50244: LD_VAR 0 14
50248: PUSH
50249: LD_VAR 0 8
50253: ARRAY
50254: PPUSH
50255: CALL_OW 313
50259: AND
50260: IFFALSE 50333
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
50262: LD_VAR 0 4
50266: PUSH
50267: LD_VAR 0 7
50271: ARRAY
50272: PPUSH
50273: LD_VAR 0 14
50277: PUSH
50278: LD_VAR 0 8
50282: ARRAY
50283: PPUSH
50284: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
50288: LD_ADDR_VAR 0 28
50292: PUSH
50293: LD_VAR 0 28
50297: PPUSH
50298: LD_VAR 0 28
50302: PUSH
50303: LD_INT 1
50305: PLUS
50306: PPUSH
50307: LD_VAR 0 14
50311: PUSH
50312: LD_VAR 0 8
50316: ARRAY
50317: PPUSH
50318: CALL_OW 1
50322: ST_TO_ADDR
// attacking := true ;
50323: LD_ADDR_VAR 0 29
50327: PUSH
50328: LD_INT 1
50330: ST_TO_ADDR
// break ;
50331: GO 50335
// end ; end ;
50333: GO 50202
50335: POP
50336: POP
// if not attacking and f_attack_depot then
50337: LD_VAR 0 29
50341: NOT
50342: PUSH
50343: LD_VAR 0 25
50347: AND
50348: IFFALSE 50443
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50350: LD_ADDR_VAR 0 13
50354: PUSH
50355: LD_VAR 0 14
50359: PPUSH
50360: LD_INT 2
50362: PUSH
50363: LD_INT 30
50365: PUSH
50366: LD_INT 0
50368: PUSH
50369: EMPTY
50370: LIST
50371: LIST
50372: PUSH
50373: LD_INT 30
50375: PUSH
50376: LD_INT 1
50378: PUSH
50379: EMPTY
50380: LIST
50381: LIST
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: LIST
50387: PPUSH
50388: CALL_OW 72
50392: ST_TO_ADDR
// if z then
50393: LD_VAR 0 13
50397: IFFALSE 50443
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
50399: LD_VAR 0 4
50403: PUSH
50404: LD_VAR 0 7
50408: ARRAY
50409: PPUSH
50410: LD_VAR 0 13
50414: PPUSH
50415: LD_VAR 0 4
50419: PUSH
50420: LD_VAR 0 7
50424: ARRAY
50425: PPUSH
50426: CALL_OW 74
50430: PPUSH
50431: CALL_OW 115
// attacking := true ;
50435: LD_ADDR_VAR 0 29
50439: PUSH
50440: LD_INT 1
50442: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
50443: LD_VAR 0 4
50447: PUSH
50448: LD_VAR 0 7
50452: ARRAY
50453: PPUSH
50454: CALL_OW 256
50458: PUSH
50459: LD_INT 500
50461: LESS
50462: IFFALSE 50488
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
50464: LD_VAR 0 4
50468: PUSH
50469: LD_VAR 0 7
50473: ARRAY
50474: PPUSH
50475: LD_VAR 0 14
50479: PUSH
50480: LD_INT 1
50482: ARRAY
50483: PPUSH
50484: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
50488: LD_VAR 0 4
50492: PUSH
50493: LD_VAR 0 7
50497: ARRAY
50498: PPUSH
50499: CALL_OW 264
50503: PUSH
50504: LD_INT 49
50506: EQUAL
50507: IFFALSE 50628
// begin if not HasTask ( group [ i ] ) then
50509: LD_VAR 0 4
50513: PUSH
50514: LD_VAR 0 7
50518: ARRAY
50519: PPUSH
50520: CALL_OW 314
50524: NOT
50525: IFFALSE 50628
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
50527: LD_ADDR_VAR 0 9
50531: PUSH
50532: LD_INT 81
50534: PUSH
50535: LD_VAR 0 4
50539: PUSH
50540: LD_VAR 0 7
50544: ARRAY
50545: PPUSH
50546: CALL_OW 255
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PPUSH
50555: CALL_OW 69
50559: PPUSH
50560: LD_VAR 0 4
50564: PUSH
50565: LD_VAR 0 7
50569: ARRAY
50570: PPUSH
50571: CALL_OW 74
50575: ST_TO_ADDR
// if k then
50576: LD_VAR 0 9
50580: IFFALSE 50628
// if GetDistUnits ( group [ i ] , k ) > 10 then
50582: LD_VAR 0 4
50586: PUSH
50587: LD_VAR 0 7
50591: ARRAY
50592: PPUSH
50593: LD_VAR 0 9
50597: PPUSH
50598: CALL_OW 296
50602: PUSH
50603: LD_INT 10
50605: GREATER
50606: IFFALSE 50628
// ComMoveUnit ( group [ i ] , k ) ;
50608: LD_VAR 0 4
50612: PUSH
50613: LD_VAR 0 7
50617: ARRAY
50618: PPUSH
50619: LD_VAR 0 9
50623: PPUSH
50624: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50628: LD_VAR 0 4
50632: PUSH
50633: LD_VAR 0 7
50637: ARRAY
50638: PPUSH
50639: CALL_OW 256
50643: PUSH
50644: LD_INT 250
50646: LESS
50647: PUSH
50648: LD_VAR 0 4
50652: PUSH
50653: LD_VAR 0 7
50657: ARRAY
50658: PUSH
50659: LD_INT 21
50661: PUSH
50662: LD_INT 2
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PUSH
50669: LD_INT 23
50671: PUSH
50672: LD_INT 2
50674: PUSH
50675: EMPTY
50676: LIST
50677: LIST
50678: PUSH
50679: EMPTY
50680: LIST
50681: LIST
50682: PPUSH
50683: CALL_OW 69
50687: IN
50688: AND
50689: IFFALSE 50814
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
50691: LD_ADDR_VAR 0 9
50695: PUSH
50696: LD_OWVAR 3
50700: PUSH
50701: LD_VAR 0 4
50705: PUSH
50706: LD_VAR 0 7
50710: ARRAY
50711: DIFF
50712: PPUSH
50713: LD_VAR 0 4
50717: PUSH
50718: LD_VAR 0 7
50722: ARRAY
50723: PPUSH
50724: CALL_OW 74
50728: ST_TO_ADDR
// if not k then
50729: LD_VAR 0 9
50733: NOT
50734: IFFALSE 50738
// continue ;
50736: GO 47179
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
50738: LD_VAR 0 9
50742: PUSH
50743: LD_INT 81
50745: PUSH
50746: LD_VAR 0 4
50750: PUSH
50751: LD_VAR 0 7
50755: ARRAY
50756: PPUSH
50757: CALL_OW 255
50761: PUSH
50762: EMPTY
50763: LIST
50764: LIST
50765: PPUSH
50766: CALL_OW 69
50770: IN
50771: PUSH
50772: LD_VAR 0 9
50776: PPUSH
50777: LD_VAR 0 4
50781: PUSH
50782: LD_VAR 0 7
50786: ARRAY
50787: PPUSH
50788: CALL_OW 296
50792: PUSH
50793: LD_INT 5
50795: LESS
50796: AND
50797: IFFALSE 50814
// ComAutodestruct ( group [ i ] ) ;
50799: LD_VAR 0 4
50803: PUSH
50804: LD_VAR 0 7
50808: ARRAY
50809: PPUSH
50810: CALL 45274 0 1
// end ; if f_attack_depot then
50814: LD_VAR 0 25
50818: IFFALSE 50930
// begin k := 6 ;
50820: LD_ADDR_VAR 0 9
50824: PUSH
50825: LD_INT 6
50827: ST_TO_ADDR
// if tmp < k then
50828: LD_VAR 0 14
50832: PUSH
50833: LD_VAR 0 9
50837: LESS
50838: IFFALSE 50850
// k := tmp ;
50840: LD_ADDR_VAR 0 9
50844: PUSH
50845: LD_VAR 0 14
50849: ST_TO_ADDR
// for j = 1 to k do
50850: LD_ADDR_VAR 0 8
50854: PUSH
50855: DOUBLE
50856: LD_INT 1
50858: DEC
50859: ST_TO_ADDR
50860: LD_VAR 0 9
50864: PUSH
50865: FOR_TO
50866: IFFALSE 50928
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
50868: LD_VAR 0 8
50872: PPUSH
50873: CALL_OW 266
50877: PUSH
50878: LD_INT 0
50880: PUSH
50881: LD_INT 1
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: IN
50888: IFFALSE 50926
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
50890: LD_VAR 0 4
50894: PUSH
50895: LD_VAR 0 7
50899: ARRAY
50900: PPUSH
50901: LD_VAR 0 14
50905: PUSH
50906: LD_VAR 0 8
50910: ARRAY
50911: PPUSH
50912: CALL_OW 115
// attacking := true ;
50916: LD_ADDR_VAR 0 29
50920: PUSH
50921: LD_INT 1
50923: ST_TO_ADDR
// break ;
50924: GO 50928
// end ;
50926: GO 50865
50928: POP
50929: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
50930: LD_VAR 0 4
50934: PUSH
50935: LD_VAR 0 7
50939: ARRAY
50940: PPUSH
50941: CALL_OW 302
50945: PUSH
50946: LD_VAR 0 29
50950: NOT
50951: AND
50952: IFFALSE 51274
// begin if GetTag ( group [ i ] ) = 71 then
50954: LD_VAR 0 4
50958: PUSH
50959: LD_VAR 0 7
50963: ARRAY
50964: PPUSH
50965: CALL_OW 110
50969: PUSH
50970: LD_INT 71
50972: EQUAL
50973: IFFALSE 51014
// begin if HasTask ( group [ i ] ) then
50975: LD_VAR 0 4
50979: PUSH
50980: LD_VAR 0 7
50984: ARRAY
50985: PPUSH
50986: CALL_OW 314
50990: IFFALSE 50996
// continue else
50992: GO 47179
50994: GO 51014
// SetTag ( group [ i ] , 0 ) ;
50996: LD_VAR 0 4
51000: PUSH
51001: LD_VAR 0 7
51005: ARRAY
51006: PPUSH
51007: LD_INT 0
51009: PPUSH
51010: CALL_OW 109
// end ; k := 8 ;
51014: LD_ADDR_VAR 0 9
51018: PUSH
51019: LD_INT 8
51021: ST_TO_ADDR
// x := 0 ;
51022: LD_ADDR_VAR 0 10
51026: PUSH
51027: LD_INT 0
51029: ST_TO_ADDR
// if tmp < k then
51030: LD_VAR 0 14
51034: PUSH
51035: LD_VAR 0 9
51039: LESS
51040: IFFALSE 51052
// k := tmp ;
51042: LD_ADDR_VAR 0 9
51046: PUSH
51047: LD_VAR 0 14
51051: ST_TO_ADDR
// for j = 1 to k do
51052: LD_ADDR_VAR 0 8
51056: PUSH
51057: DOUBLE
51058: LD_INT 1
51060: DEC
51061: ST_TO_ADDR
51062: LD_VAR 0 9
51066: PUSH
51067: FOR_TO
51068: IFFALSE 51166
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
51070: LD_VAR 0 14
51074: PUSH
51075: LD_VAR 0 8
51079: ARRAY
51080: PPUSH
51081: CALL_OW 247
51085: PUSH
51086: LD_INT 1
51088: EQUAL
51089: PUSH
51090: LD_VAR 0 14
51094: PUSH
51095: LD_VAR 0 8
51099: ARRAY
51100: PPUSH
51101: CALL_OW 256
51105: PUSH
51106: LD_INT 250
51108: LESS
51109: PUSH
51110: LD_VAR 0 20
51114: AND
51115: PUSH
51116: LD_VAR 0 20
51120: NOT
51121: PUSH
51122: LD_VAR 0 14
51126: PUSH
51127: LD_VAR 0 8
51131: ARRAY
51132: PPUSH
51133: CALL_OW 256
51137: PUSH
51138: LD_INT 250
51140: GREATEREQUAL
51141: AND
51142: OR
51143: AND
51144: IFFALSE 51164
// begin x := tmp [ j ] ;
51146: LD_ADDR_VAR 0 10
51150: PUSH
51151: LD_VAR 0 14
51155: PUSH
51156: LD_VAR 0 8
51160: ARRAY
51161: ST_TO_ADDR
// break ;
51162: GO 51166
// end ;
51164: GO 51067
51166: POP
51167: POP
// if x then
51168: LD_VAR 0 10
51172: IFFALSE 51196
// ComAttackUnit ( group [ i ] , x ) else
51174: LD_VAR 0 4
51178: PUSH
51179: LD_VAR 0 7
51183: ARRAY
51184: PPUSH
51185: LD_VAR 0 10
51189: PPUSH
51190: CALL_OW 115
51194: GO 51220
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
51196: LD_VAR 0 4
51200: PUSH
51201: LD_VAR 0 7
51205: ARRAY
51206: PPUSH
51207: LD_VAR 0 14
51211: PUSH
51212: LD_INT 1
51214: ARRAY
51215: PPUSH
51216: CALL_OW 115
// if not HasTask ( group [ i ] ) then
51220: LD_VAR 0 4
51224: PUSH
51225: LD_VAR 0 7
51229: ARRAY
51230: PPUSH
51231: CALL_OW 314
51235: NOT
51236: IFFALSE 51274
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
51238: LD_VAR 0 4
51242: PUSH
51243: LD_VAR 0 7
51247: ARRAY
51248: PPUSH
51249: LD_VAR 0 14
51253: PPUSH
51254: LD_VAR 0 4
51258: PUSH
51259: LD_VAR 0 7
51263: ARRAY
51264: PPUSH
51265: CALL_OW 74
51269: PPUSH
51270: CALL_OW 115
// end ; end ; end ;
51274: GO 47179
51276: POP
51277: POP
// wait ( 0 0$1 ) ;
51278: LD_INT 35
51280: PPUSH
51281: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
51285: LD_VAR 0 4
51289: PUSH
51290: EMPTY
51291: EQUAL
51292: PUSH
51293: LD_INT 81
51295: PUSH
51296: LD_VAR 0 35
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: PPUSH
51305: CALL_OW 69
51309: NOT
51310: OR
51311: IFFALSE 47164
// end ;
51313: LD_VAR 0 2
51317: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51318: LD_INT 0
51320: PPUSH
51321: PPUSH
51322: PPUSH
51323: PPUSH
// if not base_units then
51324: LD_VAR 0 1
51328: NOT
51329: IFFALSE 51333
// exit ;
51331: GO 51420
// result := false ;
51333: LD_ADDR_VAR 0 2
51337: PUSH
51338: LD_INT 0
51340: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51341: LD_ADDR_VAR 0 5
51345: PUSH
51346: LD_VAR 0 1
51350: PPUSH
51351: LD_INT 21
51353: PUSH
51354: LD_INT 3
51356: PUSH
51357: EMPTY
51358: LIST
51359: LIST
51360: PPUSH
51361: CALL_OW 72
51365: ST_TO_ADDR
// if not tmp then
51366: LD_VAR 0 5
51370: NOT
51371: IFFALSE 51375
// exit ;
51373: GO 51420
// for i in tmp do
51375: LD_ADDR_VAR 0 3
51379: PUSH
51380: LD_VAR 0 5
51384: PUSH
51385: FOR_IN
51386: IFFALSE 51418
// begin result := EnemyInRange ( i , 22 ) ;
51388: LD_ADDR_VAR 0 2
51392: PUSH
51393: LD_VAR 0 3
51397: PPUSH
51398: LD_INT 22
51400: PPUSH
51401: CALL 44957 0 2
51405: ST_TO_ADDR
// if result then
51406: LD_VAR 0 2
51410: IFFALSE 51416
// exit ;
51412: POP
51413: POP
51414: GO 51420
// end ;
51416: GO 51385
51418: POP
51419: POP
// end ;
51420: LD_VAR 0 2
51424: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51425: LD_INT 0
51427: PPUSH
51428: PPUSH
// if not units then
51429: LD_VAR 0 1
51433: NOT
51434: IFFALSE 51438
// exit ;
51436: GO 51508
// result := [ ] ;
51438: LD_ADDR_VAR 0 3
51442: PUSH
51443: EMPTY
51444: ST_TO_ADDR
// for i in units do
51445: LD_ADDR_VAR 0 4
51449: PUSH
51450: LD_VAR 0 1
51454: PUSH
51455: FOR_IN
51456: IFFALSE 51506
// if GetTag ( i ) = tag then
51458: LD_VAR 0 4
51462: PPUSH
51463: CALL_OW 110
51467: PUSH
51468: LD_VAR 0 2
51472: EQUAL
51473: IFFALSE 51504
// result := Insert ( result , result + 1 , i ) ;
51475: LD_ADDR_VAR 0 3
51479: PUSH
51480: LD_VAR 0 3
51484: PPUSH
51485: LD_VAR 0 3
51489: PUSH
51490: LD_INT 1
51492: PLUS
51493: PPUSH
51494: LD_VAR 0 4
51498: PPUSH
51499: CALL_OW 2
51503: ST_TO_ADDR
51504: GO 51455
51506: POP
51507: POP
// end ;
51508: LD_VAR 0 3
51512: RET
// export function IsDriver ( un ) ; begin
51513: LD_INT 0
51515: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51516: LD_ADDR_VAR 0 2
51520: PUSH
51521: LD_VAR 0 1
51525: PUSH
51526: LD_INT 55
51528: PUSH
51529: EMPTY
51530: LIST
51531: PPUSH
51532: CALL_OW 69
51536: IN
51537: ST_TO_ADDR
// end ;
51538: LD_VAR 0 2
51542: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51543: LD_INT 0
51545: PPUSH
51546: PPUSH
// list := [ ] ;
51547: LD_ADDR_VAR 0 5
51551: PUSH
51552: EMPTY
51553: ST_TO_ADDR
// case d of 0 :
51554: LD_VAR 0 3
51558: PUSH
51559: LD_INT 0
51561: DOUBLE
51562: EQUAL
51563: IFTRUE 51567
51565: GO 51700
51567: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51568: LD_ADDR_VAR 0 5
51572: PUSH
51573: LD_VAR 0 1
51577: PUSH
51578: LD_INT 4
51580: MINUS
51581: PUSH
51582: LD_VAR 0 2
51586: PUSH
51587: LD_INT 4
51589: MINUS
51590: PUSH
51591: LD_INT 2
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: LIST
51598: PUSH
51599: LD_VAR 0 1
51603: PUSH
51604: LD_INT 3
51606: MINUS
51607: PUSH
51608: LD_VAR 0 2
51612: PUSH
51613: LD_INT 1
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: LIST
51620: PUSH
51621: LD_VAR 0 1
51625: PUSH
51626: LD_INT 4
51628: PLUS
51629: PUSH
51630: LD_VAR 0 2
51634: PUSH
51635: LD_INT 4
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: LIST
51642: PUSH
51643: LD_VAR 0 1
51647: PUSH
51648: LD_INT 3
51650: PLUS
51651: PUSH
51652: LD_VAR 0 2
51656: PUSH
51657: LD_INT 3
51659: PLUS
51660: PUSH
51661: LD_INT 5
51663: PUSH
51664: EMPTY
51665: LIST
51666: LIST
51667: LIST
51668: PUSH
51669: LD_VAR 0 1
51673: PUSH
51674: LD_VAR 0 2
51678: PUSH
51679: LD_INT 4
51681: PLUS
51682: PUSH
51683: LD_INT 0
51685: PUSH
51686: EMPTY
51687: LIST
51688: LIST
51689: LIST
51690: PUSH
51691: EMPTY
51692: LIST
51693: LIST
51694: LIST
51695: LIST
51696: LIST
51697: ST_TO_ADDR
// end ; 1 :
51698: GO 52398
51700: LD_INT 1
51702: DOUBLE
51703: EQUAL
51704: IFTRUE 51708
51706: GO 51841
51708: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51709: LD_ADDR_VAR 0 5
51713: PUSH
51714: LD_VAR 0 1
51718: PUSH
51719: LD_VAR 0 2
51723: PUSH
51724: LD_INT 4
51726: MINUS
51727: PUSH
51728: LD_INT 3
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: LIST
51735: PUSH
51736: LD_VAR 0 1
51740: PUSH
51741: LD_INT 3
51743: MINUS
51744: PUSH
51745: LD_VAR 0 2
51749: PUSH
51750: LD_INT 3
51752: MINUS
51753: PUSH
51754: LD_INT 2
51756: PUSH
51757: EMPTY
51758: LIST
51759: LIST
51760: LIST
51761: PUSH
51762: LD_VAR 0 1
51766: PUSH
51767: LD_INT 4
51769: MINUS
51770: PUSH
51771: LD_VAR 0 2
51775: PUSH
51776: LD_INT 1
51778: PUSH
51779: EMPTY
51780: LIST
51781: LIST
51782: LIST
51783: PUSH
51784: LD_VAR 0 1
51788: PUSH
51789: LD_VAR 0 2
51793: PUSH
51794: LD_INT 3
51796: PLUS
51797: PUSH
51798: LD_INT 0
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: LIST
51805: PUSH
51806: LD_VAR 0 1
51810: PUSH
51811: LD_INT 4
51813: PLUS
51814: PUSH
51815: LD_VAR 0 2
51819: PUSH
51820: LD_INT 4
51822: PLUS
51823: PUSH
51824: LD_INT 5
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: LIST
51831: PUSH
51832: EMPTY
51833: LIST
51834: LIST
51835: LIST
51836: LIST
51837: LIST
51838: ST_TO_ADDR
// end ; 2 :
51839: GO 52398
51841: LD_INT 2
51843: DOUBLE
51844: EQUAL
51845: IFTRUE 51849
51847: GO 51978
51849: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51850: LD_ADDR_VAR 0 5
51854: PUSH
51855: LD_VAR 0 1
51859: PUSH
51860: LD_VAR 0 2
51864: PUSH
51865: LD_INT 3
51867: MINUS
51868: PUSH
51869: LD_INT 3
51871: PUSH
51872: EMPTY
51873: LIST
51874: LIST
51875: LIST
51876: PUSH
51877: LD_VAR 0 1
51881: PUSH
51882: LD_INT 4
51884: PLUS
51885: PUSH
51886: LD_VAR 0 2
51890: PUSH
51891: LD_INT 4
51893: PUSH
51894: EMPTY
51895: LIST
51896: LIST
51897: LIST
51898: PUSH
51899: LD_VAR 0 1
51903: PUSH
51904: LD_VAR 0 2
51908: PUSH
51909: LD_INT 4
51911: PLUS
51912: PUSH
51913: LD_INT 0
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: LIST
51920: PUSH
51921: LD_VAR 0 1
51925: PUSH
51926: LD_INT 3
51928: MINUS
51929: PUSH
51930: LD_VAR 0 2
51934: PUSH
51935: LD_INT 1
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: LIST
51942: PUSH
51943: LD_VAR 0 1
51947: PUSH
51948: LD_INT 4
51950: MINUS
51951: PUSH
51952: LD_VAR 0 2
51956: PUSH
51957: LD_INT 4
51959: MINUS
51960: PUSH
51961: LD_INT 2
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: LIST
51968: PUSH
51969: EMPTY
51970: LIST
51971: LIST
51972: LIST
51973: LIST
51974: LIST
51975: ST_TO_ADDR
// end ; 3 :
51976: GO 52398
51978: LD_INT 3
51980: DOUBLE
51981: EQUAL
51982: IFTRUE 51986
51984: GO 52119
51986: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51987: LD_ADDR_VAR 0 5
51991: PUSH
51992: LD_VAR 0 1
51996: PUSH
51997: LD_INT 3
51999: PLUS
52000: PUSH
52001: LD_VAR 0 2
52005: PUSH
52006: LD_INT 4
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: LIST
52013: PUSH
52014: LD_VAR 0 1
52018: PUSH
52019: LD_INT 4
52021: PLUS
52022: PUSH
52023: LD_VAR 0 2
52027: PUSH
52028: LD_INT 4
52030: PLUS
52031: PUSH
52032: LD_INT 5
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: LIST
52039: PUSH
52040: LD_VAR 0 1
52044: PUSH
52045: LD_INT 4
52047: MINUS
52048: PUSH
52049: LD_VAR 0 2
52053: PUSH
52054: LD_INT 1
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: LIST
52061: PUSH
52062: LD_VAR 0 1
52066: PUSH
52067: LD_VAR 0 2
52071: PUSH
52072: LD_INT 4
52074: MINUS
52075: PUSH
52076: LD_INT 3
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: LIST
52083: PUSH
52084: LD_VAR 0 1
52088: PUSH
52089: LD_INT 3
52091: MINUS
52092: PUSH
52093: LD_VAR 0 2
52097: PUSH
52098: LD_INT 3
52100: MINUS
52101: PUSH
52102: LD_INT 2
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: PUSH
52110: EMPTY
52111: LIST
52112: LIST
52113: LIST
52114: LIST
52115: LIST
52116: ST_TO_ADDR
// end ; 4 :
52117: GO 52398
52119: LD_INT 4
52121: DOUBLE
52122: EQUAL
52123: IFTRUE 52127
52125: GO 52260
52127: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52128: LD_ADDR_VAR 0 5
52132: PUSH
52133: LD_VAR 0 1
52137: PUSH
52138: LD_VAR 0 2
52142: PUSH
52143: LD_INT 4
52145: PLUS
52146: PUSH
52147: LD_INT 0
52149: PUSH
52150: EMPTY
52151: LIST
52152: LIST
52153: LIST
52154: PUSH
52155: LD_VAR 0 1
52159: PUSH
52160: LD_INT 3
52162: PLUS
52163: PUSH
52164: LD_VAR 0 2
52168: PUSH
52169: LD_INT 3
52171: PLUS
52172: PUSH
52173: LD_INT 5
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: LIST
52180: PUSH
52181: LD_VAR 0 1
52185: PUSH
52186: LD_INT 4
52188: PLUS
52189: PUSH
52190: LD_VAR 0 2
52194: PUSH
52195: LD_INT 4
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: LIST
52202: PUSH
52203: LD_VAR 0 1
52207: PUSH
52208: LD_VAR 0 2
52212: PUSH
52213: LD_INT 3
52215: MINUS
52216: PUSH
52217: LD_INT 3
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: LIST
52224: PUSH
52225: LD_VAR 0 1
52229: PUSH
52230: LD_INT 4
52232: MINUS
52233: PUSH
52234: LD_VAR 0 2
52238: PUSH
52239: LD_INT 4
52241: MINUS
52242: PUSH
52243: LD_INT 2
52245: PUSH
52246: EMPTY
52247: LIST
52248: LIST
52249: LIST
52250: PUSH
52251: EMPTY
52252: LIST
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: ST_TO_ADDR
// end ; 5 :
52258: GO 52398
52260: LD_INT 5
52262: DOUBLE
52263: EQUAL
52264: IFTRUE 52268
52266: GO 52397
52268: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52269: LD_ADDR_VAR 0 5
52273: PUSH
52274: LD_VAR 0 1
52278: PUSH
52279: LD_INT 4
52281: MINUS
52282: PUSH
52283: LD_VAR 0 2
52287: PUSH
52288: LD_INT 1
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: LIST
52295: PUSH
52296: LD_VAR 0 1
52300: PUSH
52301: LD_VAR 0 2
52305: PUSH
52306: LD_INT 4
52308: MINUS
52309: PUSH
52310: LD_INT 3
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: LIST
52317: PUSH
52318: LD_VAR 0 1
52322: PUSH
52323: LD_INT 4
52325: PLUS
52326: PUSH
52327: LD_VAR 0 2
52331: PUSH
52332: LD_INT 4
52334: PLUS
52335: PUSH
52336: LD_INT 5
52338: PUSH
52339: EMPTY
52340: LIST
52341: LIST
52342: LIST
52343: PUSH
52344: LD_VAR 0 1
52348: PUSH
52349: LD_INT 3
52351: PLUS
52352: PUSH
52353: LD_VAR 0 2
52357: PUSH
52358: LD_INT 4
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: LIST
52365: PUSH
52366: LD_VAR 0 1
52370: PUSH
52371: LD_VAR 0 2
52375: PUSH
52376: LD_INT 3
52378: PLUS
52379: PUSH
52380: LD_INT 0
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: LIST
52387: PUSH
52388: EMPTY
52389: LIST
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: ST_TO_ADDR
// end ; end ;
52395: GO 52398
52397: POP
// result := list ;
52398: LD_ADDR_VAR 0 4
52402: PUSH
52403: LD_VAR 0 5
52407: ST_TO_ADDR
// end ;
52408: LD_VAR 0 4
52412: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52413: LD_INT 0
52415: PPUSH
52416: PPUSH
52417: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52418: LD_VAR 0 1
52422: NOT
52423: PUSH
52424: LD_VAR 0 2
52428: PUSH
52429: LD_INT 1
52431: PUSH
52432: LD_INT 2
52434: PUSH
52435: LD_INT 3
52437: PUSH
52438: LD_INT 4
52440: PUSH
52441: EMPTY
52442: LIST
52443: LIST
52444: LIST
52445: LIST
52446: IN
52447: NOT
52448: OR
52449: IFFALSE 52453
// exit ;
52451: GO 52545
// tmp := [ ] ;
52453: LD_ADDR_VAR 0 5
52457: PUSH
52458: EMPTY
52459: ST_TO_ADDR
// for i in units do
52460: LD_ADDR_VAR 0 4
52464: PUSH
52465: LD_VAR 0 1
52469: PUSH
52470: FOR_IN
52471: IFFALSE 52514
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52473: LD_ADDR_VAR 0 5
52477: PUSH
52478: LD_VAR 0 5
52482: PPUSH
52483: LD_VAR 0 5
52487: PUSH
52488: LD_INT 1
52490: PLUS
52491: PPUSH
52492: LD_VAR 0 4
52496: PPUSH
52497: LD_VAR 0 2
52501: PPUSH
52502: CALL_OW 259
52506: PPUSH
52507: CALL_OW 2
52511: ST_TO_ADDR
52512: GO 52470
52514: POP
52515: POP
// if not tmp then
52516: LD_VAR 0 5
52520: NOT
52521: IFFALSE 52525
// exit ;
52523: GO 52545
// result := SortListByListDesc ( units , tmp ) ;
52525: LD_ADDR_VAR 0 3
52529: PUSH
52530: LD_VAR 0 1
52534: PPUSH
52535: LD_VAR 0 5
52539: PPUSH
52540: CALL_OW 77
52544: ST_TO_ADDR
// end ;
52545: LD_VAR 0 3
52549: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52550: LD_INT 0
52552: PPUSH
52553: PPUSH
52554: PPUSH
// x := GetX ( building ) ;
52555: LD_ADDR_VAR 0 4
52559: PUSH
52560: LD_VAR 0 2
52564: PPUSH
52565: CALL_OW 250
52569: ST_TO_ADDR
// y := GetY ( building ) ;
52570: LD_ADDR_VAR 0 5
52574: PUSH
52575: LD_VAR 0 2
52579: PPUSH
52580: CALL_OW 251
52584: ST_TO_ADDR
// if GetTaskList ( unit ) then
52585: LD_VAR 0 1
52589: PPUSH
52590: CALL_OW 437
52594: IFFALSE 52689
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52596: LD_STRING e
52598: PUSH
52599: LD_VAR 0 1
52603: PPUSH
52604: CALL_OW 437
52608: PUSH
52609: LD_INT 1
52611: ARRAY
52612: PUSH
52613: LD_INT 1
52615: ARRAY
52616: EQUAL
52617: PUSH
52618: LD_VAR 0 4
52622: PUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: CALL_OW 437
52632: PUSH
52633: LD_INT 1
52635: ARRAY
52636: PUSH
52637: LD_INT 2
52639: ARRAY
52640: EQUAL
52641: AND
52642: PUSH
52643: LD_VAR 0 5
52647: PUSH
52648: LD_VAR 0 1
52652: PPUSH
52653: CALL_OW 437
52657: PUSH
52658: LD_INT 1
52660: ARRAY
52661: PUSH
52662: LD_INT 3
52664: ARRAY
52665: EQUAL
52666: AND
52667: IFFALSE 52679
// result := true else
52669: LD_ADDR_VAR 0 3
52673: PUSH
52674: LD_INT 1
52676: ST_TO_ADDR
52677: GO 52687
// result := false ;
52679: LD_ADDR_VAR 0 3
52683: PUSH
52684: LD_INT 0
52686: ST_TO_ADDR
// end else
52687: GO 52697
// result := false ;
52689: LD_ADDR_VAR 0 3
52693: PUSH
52694: LD_INT 0
52696: ST_TO_ADDR
// end ;
52697: LD_VAR 0 3
52701: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52702: LD_INT 0
52704: PPUSH
52705: PPUSH
52706: PPUSH
52707: PPUSH
// if not unit or not area then
52708: LD_VAR 0 1
52712: NOT
52713: PUSH
52714: LD_VAR 0 2
52718: NOT
52719: OR
52720: IFFALSE 52724
// exit ;
52722: GO 52888
// tmp := AreaToList ( area , i ) ;
52724: LD_ADDR_VAR 0 6
52728: PUSH
52729: LD_VAR 0 2
52733: PPUSH
52734: LD_VAR 0 5
52738: PPUSH
52739: CALL_OW 517
52743: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52744: LD_ADDR_VAR 0 5
52748: PUSH
52749: DOUBLE
52750: LD_INT 1
52752: DEC
52753: ST_TO_ADDR
52754: LD_VAR 0 6
52758: PUSH
52759: LD_INT 1
52761: ARRAY
52762: PUSH
52763: FOR_TO
52764: IFFALSE 52886
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52766: LD_ADDR_VAR 0 7
52770: PUSH
52771: LD_VAR 0 6
52775: PUSH
52776: LD_INT 1
52778: ARRAY
52779: PUSH
52780: LD_VAR 0 5
52784: ARRAY
52785: PUSH
52786: LD_VAR 0 6
52790: PUSH
52791: LD_INT 2
52793: ARRAY
52794: PUSH
52795: LD_VAR 0 5
52799: ARRAY
52800: PUSH
52801: EMPTY
52802: LIST
52803: LIST
52804: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
52805: LD_VAR 0 7
52809: PUSH
52810: LD_INT 1
52812: ARRAY
52813: PPUSH
52814: LD_VAR 0 7
52818: PUSH
52819: LD_INT 2
52821: ARRAY
52822: PPUSH
52823: CALL_OW 428
52827: PUSH
52828: LD_INT 0
52830: EQUAL
52831: IFFALSE 52884
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52833: LD_VAR 0 1
52837: PPUSH
52838: LD_VAR 0 7
52842: PUSH
52843: LD_INT 1
52845: ARRAY
52846: PPUSH
52847: LD_VAR 0 7
52851: PUSH
52852: LD_INT 2
52854: ARRAY
52855: PPUSH
52856: LD_VAR 0 3
52860: PPUSH
52861: CALL_OW 48
// result := IsPlaced ( unit ) ;
52865: LD_ADDR_VAR 0 4
52869: PUSH
52870: LD_VAR 0 1
52874: PPUSH
52875: CALL_OW 305
52879: ST_TO_ADDR
// exit ;
52880: POP
52881: POP
52882: GO 52888
// end ; end ;
52884: GO 52763
52886: POP
52887: POP
// end ;
52888: LD_VAR 0 4
52892: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52893: LD_INT 0
52895: PPUSH
52896: PPUSH
52897: PPUSH
// if not side or side > 8 then
52898: LD_VAR 0 1
52902: NOT
52903: PUSH
52904: LD_VAR 0 1
52908: PUSH
52909: LD_INT 8
52911: GREATER
52912: OR
52913: IFFALSE 52917
// exit ;
52915: GO 53104
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52917: LD_ADDR_VAR 0 4
52921: PUSH
52922: LD_INT 22
52924: PUSH
52925: LD_VAR 0 1
52929: PUSH
52930: EMPTY
52931: LIST
52932: LIST
52933: PUSH
52934: LD_INT 21
52936: PUSH
52937: LD_INT 3
52939: PUSH
52940: EMPTY
52941: LIST
52942: LIST
52943: PUSH
52944: EMPTY
52945: LIST
52946: LIST
52947: PPUSH
52948: CALL_OW 69
52952: ST_TO_ADDR
// if not tmp then
52953: LD_VAR 0 4
52957: NOT
52958: IFFALSE 52962
// exit ;
52960: GO 53104
// enable_addtolog := true ;
52962: LD_ADDR_OWVAR 81
52966: PUSH
52967: LD_INT 1
52969: ST_TO_ADDR
// AddToLog ( [ ) ;
52970: LD_STRING [
52972: PPUSH
52973: CALL_OW 561
// for i in tmp do
52977: LD_ADDR_VAR 0 3
52981: PUSH
52982: LD_VAR 0 4
52986: PUSH
52987: FOR_IN
52988: IFFALSE 53095
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52990: LD_STRING [
52992: PUSH
52993: LD_VAR 0 3
52997: PPUSH
52998: CALL_OW 266
53002: STR
53003: PUSH
53004: LD_STRING , 
53006: STR
53007: PUSH
53008: LD_VAR 0 3
53012: PPUSH
53013: CALL_OW 250
53017: STR
53018: PUSH
53019: LD_STRING , 
53021: STR
53022: PUSH
53023: LD_VAR 0 3
53027: PPUSH
53028: CALL_OW 251
53032: STR
53033: PUSH
53034: LD_STRING , 
53036: STR
53037: PUSH
53038: LD_VAR 0 3
53042: PPUSH
53043: CALL_OW 254
53047: STR
53048: PUSH
53049: LD_STRING , 
53051: STR
53052: PUSH
53053: LD_VAR 0 3
53057: PPUSH
53058: LD_INT 1
53060: PPUSH
53061: CALL_OW 268
53065: STR
53066: PUSH
53067: LD_STRING , 
53069: STR
53070: PUSH
53071: LD_VAR 0 3
53075: PPUSH
53076: LD_INT 2
53078: PPUSH
53079: CALL_OW 268
53083: STR
53084: PUSH
53085: LD_STRING ],
53087: STR
53088: PPUSH
53089: CALL_OW 561
// end ;
53093: GO 52987
53095: POP
53096: POP
// AddToLog ( ]; ) ;
53097: LD_STRING ];
53099: PPUSH
53100: CALL_OW 561
// end ;
53104: LD_VAR 0 2
53108: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53109: LD_INT 0
53111: PPUSH
53112: PPUSH
53113: PPUSH
53114: PPUSH
53115: PPUSH
// if not area or not rate or not max then
53116: LD_VAR 0 1
53120: NOT
53121: PUSH
53122: LD_VAR 0 2
53126: NOT
53127: OR
53128: PUSH
53129: LD_VAR 0 4
53133: NOT
53134: OR
53135: IFFALSE 53139
// exit ;
53137: GO 53331
// while 1 do
53139: LD_INT 1
53141: IFFALSE 53331
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53143: LD_ADDR_VAR 0 9
53147: PUSH
53148: LD_VAR 0 1
53152: PPUSH
53153: LD_INT 1
53155: PPUSH
53156: CALL_OW 287
53160: PUSH
53161: LD_INT 10
53163: MUL
53164: ST_TO_ADDR
// r := rate / 10 ;
53165: LD_ADDR_VAR 0 7
53169: PUSH
53170: LD_VAR 0 2
53174: PUSH
53175: LD_INT 10
53177: DIVREAL
53178: ST_TO_ADDR
// time := 1 1$00 ;
53179: LD_ADDR_VAR 0 8
53183: PUSH
53184: LD_INT 2100
53186: ST_TO_ADDR
// if amount < min then
53187: LD_VAR 0 9
53191: PUSH
53192: LD_VAR 0 3
53196: LESS
53197: IFFALSE 53215
// r := r * 2 else
53199: LD_ADDR_VAR 0 7
53203: PUSH
53204: LD_VAR 0 7
53208: PUSH
53209: LD_INT 2
53211: MUL
53212: ST_TO_ADDR
53213: GO 53241
// if amount > max then
53215: LD_VAR 0 9
53219: PUSH
53220: LD_VAR 0 4
53224: GREATER
53225: IFFALSE 53241
// r := r / 2 ;
53227: LD_ADDR_VAR 0 7
53231: PUSH
53232: LD_VAR 0 7
53236: PUSH
53237: LD_INT 2
53239: DIVREAL
53240: ST_TO_ADDR
// time := time / r ;
53241: LD_ADDR_VAR 0 8
53245: PUSH
53246: LD_VAR 0 8
53250: PUSH
53251: LD_VAR 0 7
53255: DIVREAL
53256: ST_TO_ADDR
// if time < 0 then
53257: LD_VAR 0 8
53261: PUSH
53262: LD_INT 0
53264: LESS
53265: IFFALSE 53282
// time := time * - 1 ;
53267: LD_ADDR_VAR 0 8
53271: PUSH
53272: LD_VAR 0 8
53276: PUSH
53277: LD_INT 1
53279: NEG
53280: MUL
53281: ST_TO_ADDR
// wait ( time ) ;
53282: LD_VAR 0 8
53286: PPUSH
53287: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
53291: LD_INT 35
53293: PPUSH
53294: LD_INT 875
53296: PPUSH
53297: CALL_OW 12
53301: PPUSH
53302: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53306: LD_INT 1
53308: PPUSH
53309: LD_INT 5
53311: PPUSH
53312: CALL_OW 12
53316: PPUSH
53317: LD_VAR 0 1
53321: PPUSH
53322: LD_INT 1
53324: PPUSH
53325: CALL_OW 55
// end ;
53329: GO 53139
// end ;
53331: LD_VAR 0 5
53335: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53336: LD_INT 0
53338: PPUSH
53339: PPUSH
53340: PPUSH
53341: PPUSH
53342: PPUSH
53343: PPUSH
53344: PPUSH
53345: PPUSH
// if not turrets or not factories then
53346: LD_VAR 0 1
53350: NOT
53351: PUSH
53352: LD_VAR 0 2
53356: NOT
53357: OR
53358: IFFALSE 53362
// exit ;
53360: GO 53669
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53362: LD_ADDR_VAR 0 10
53366: PUSH
53367: LD_INT 5
53369: PUSH
53370: LD_INT 6
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: LD_INT 2
53379: PUSH
53380: LD_INT 4
53382: PUSH
53383: EMPTY
53384: LIST
53385: LIST
53386: PUSH
53387: LD_INT 3
53389: PUSH
53390: LD_INT 5
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: LIST
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: LD_INT 25
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: PUSH
53412: LD_INT 23
53414: PUSH
53415: LD_INT 27
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PUSH
53426: LD_INT 42
53428: PUSH
53429: LD_INT 43
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: LD_INT 44
53438: PUSH
53439: LD_INT 46
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PUSH
53446: LD_INT 45
53448: PUSH
53449: LD_INT 47
53451: PUSH
53452: EMPTY
53453: LIST
53454: LIST
53455: PUSH
53456: EMPTY
53457: LIST
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: ST_TO_ADDR
// result := [ ] ;
53466: LD_ADDR_VAR 0 3
53470: PUSH
53471: EMPTY
53472: ST_TO_ADDR
// for i in turrets do
53473: LD_ADDR_VAR 0 4
53477: PUSH
53478: LD_VAR 0 1
53482: PUSH
53483: FOR_IN
53484: IFFALSE 53667
// begin nat := GetNation ( i ) ;
53486: LD_ADDR_VAR 0 7
53490: PUSH
53491: LD_VAR 0 4
53495: PPUSH
53496: CALL_OW 248
53500: ST_TO_ADDR
// weapon := 0 ;
53501: LD_ADDR_VAR 0 8
53505: PUSH
53506: LD_INT 0
53508: ST_TO_ADDR
// if not nat then
53509: LD_VAR 0 7
53513: NOT
53514: IFFALSE 53518
// continue ;
53516: GO 53483
// for j in list [ nat ] do
53518: LD_ADDR_VAR 0 5
53522: PUSH
53523: LD_VAR 0 10
53527: PUSH
53528: LD_VAR 0 7
53532: ARRAY
53533: PUSH
53534: FOR_IN
53535: IFFALSE 53576
// if GetBWeapon ( i ) = j [ 1 ] then
53537: LD_VAR 0 4
53541: PPUSH
53542: CALL_OW 269
53546: PUSH
53547: LD_VAR 0 5
53551: PUSH
53552: LD_INT 1
53554: ARRAY
53555: EQUAL
53556: IFFALSE 53574
// begin weapon := j [ 2 ] ;
53558: LD_ADDR_VAR 0 8
53562: PUSH
53563: LD_VAR 0 5
53567: PUSH
53568: LD_INT 2
53570: ARRAY
53571: ST_TO_ADDR
// break ;
53572: GO 53576
// end ;
53574: GO 53534
53576: POP
53577: POP
// if not weapon then
53578: LD_VAR 0 8
53582: NOT
53583: IFFALSE 53587
// continue ;
53585: GO 53483
// for k in factories do
53587: LD_ADDR_VAR 0 6
53591: PUSH
53592: LD_VAR 0 2
53596: PUSH
53597: FOR_IN
53598: IFFALSE 53663
// begin weapons := AvailableWeaponList ( k ) ;
53600: LD_ADDR_VAR 0 9
53604: PUSH
53605: LD_VAR 0 6
53609: PPUSH
53610: CALL_OW 478
53614: ST_TO_ADDR
// if not weapons then
53615: LD_VAR 0 9
53619: NOT
53620: IFFALSE 53624
// continue ;
53622: GO 53597
// if weapon in weapons then
53624: LD_VAR 0 8
53628: PUSH
53629: LD_VAR 0 9
53633: IN
53634: IFFALSE 53661
// begin result := [ i , weapon ] ;
53636: LD_ADDR_VAR 0 3
53640: PUSH
53641: LD_VAR 0 4
53645: PUSH
53646: LD_VAR 0 8
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: ST_TO_ADDR
// exit ;
53655: POP
53656: POP
53657: POP
53658: POP
53659: GO 53669
// end ; end ;
53661: GO 53597
53663: POP
53664: POP
// end ;
53665: GO 53483
53667: POP
53668: POP
// end ;
53669: LD_VAR 0 3
53673: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53674: LD_INT 0
53676: PPUSH
// if not side or side > 8 then
53677: LD_VAR 0 3
53681: NOT
53682: PUSH
53683: LD_VAR 0 3
53687: PUSH
53688: LD_INT 8
53690: GREATER
53691: OR
53692: IFFALSE 53696
// exit ;
53694: GO 53755
// if not range then
53696: LD_VAR 0 4
53700: NOT
53701: IFFALSE 53712
// range := - 12 ;
53703: LD_ADDR_VAR 0 4
53707: PUSH
53708: LD_INT 12
53710: NEG
53711: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53712: LD_VAR 0 1
53716: PPUSH
53717: LD_VAR 0 2
53721: PPUSH
53722: LD_VAR 0 3
53726: PPUSH
53727: LD_VAR 0 4
53731: PPUSH
53732: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53736: LD_VAR 0 1
53740: PPUSH
53741: LD_VAR 0 2
53745: PPUSH
53746: LD_VAR 0 3
53750: PPUSH
53751: CALL_OW 331
// end ;
53755: LD_VAR 0 5
53759: RET
// export function Video ( mode ) ; begin
53760: LD_INT 0
53762: PPUSH
// ingame_video = mode ;
53763: LD_ADDR_OWVAR 52
53767: PUSH
53768: LD_VAR 0 1
53772: ST_TO_ADDR
// interface_hidden = mode ;
53773: LD_ADDR_OWVAR 54
53777: PUSH
53778: LD_VAR 0 1
53782: ST_TO_ADDR
// end ;
53783: LD_VAR 0 2
53787: RET
// export function Join ( array , element ) ; begin
53788: LD_INT 0
53790: PPUSH
// result := array ^ element ;
53791: LD_ADDR_VAR 0 3
53795: PUSH
53796: LD_VAR 0 1
53800: PUSH
53801: LD_VAR 0 2
53805: ADD
53806: ST_TO_ADDR
// end ;
53807: LD_VAR 0 3
53811: RET
// export function JoinUnion ( array , element ) ; begin
53812: LD_INT 0
53814: PPUSH
// result := array union element ;
53815: LD_ADDR_VAR 0 3
53819: PUSH
53820: LD_VAR 0 1
53824: PUSH
53825: LD_VAR 0 2
53829: UNION
53830: ST_TO_ADDR
// end ;
53831: LD_VAR 0 3
53835: RET
// export function GetBehemoths ( side ) ; begin
53836: LD_INT 0
53838: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
53839: LD_ADDR_VAR 0 2
53843: PUSH
53844: LD_INT 22
53846: PUSH
53847: LD_VAR 0 1
53851: PUSH
53852: EMPTY
53853: LIST
53854: LIST
53855: PUSH
53856: LD_INT 31
53858: PUSH
53859: LD_INT 25
53861: PUSH
53862: EMPTY
53863: LIST
53864: LIST
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: PPUSH
53870: CALL_OW 69
53874: ST_TO_ADDR
// end ;
53875: LD_VAR 0 2
53879: RET
// export function Shuffle ( array ) ; var i , index ; begin
53880: LD_INT 0
53882: PPUSH
53883: PPUSH
53884: PPUSH
// result := [ ] ;
53885: LD_ADDR_VAR 0 2
53889: PUSH
53890: EMPTY
53891: ST_TO_ADDR
// if not array then
53892: LD_VAR 0 1
53896: NOT
53897: IFFALSE 53901
// exit ;
53899: GO 54000
// Randomize ;
53901: CALL_OW 10
// for i = array downto 1 do
53905: LD_ADDR_VAR 0 3
53909: PUSH
53910: DOUBLE
53911: LD_VAR 0 1
53915: INC
53916: ST_TO_ADDR
53917: LD_INT 1
53919: PUSH
53920: FOR_DOWNTO
53921: IFFALSE 53998
// begin index := rand ( 1 , array ) ;
53923: LD_ADDR_VAR 0 4
53927: PUSH
53928: LD_INT 1
53930: PPUSH
53931: LD_VAR 0 1
53935: PPUSH
53936: CALL_OW 12
53940: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53941: LD_ADDR_VAR 0 2
53945: PUSH
53946: LD_VAR 0 2
53950: PPUSH
53951: LD_VAR 0 2
53955: PUSH
53956: LD_INT 1
53958: PLUS
53959: PPUSH
53960: LD_VAR 0 1
53964: PUSH
53965: LD_VAR 0 4
53969: ARRAY
53970: PPUSH
53971: CALL_OW 2
53975: ST_TO_ADDR
// array := Delete ( array , index ) ;
53976: LD_ADDR_VAR 0 1
53980: PUSH
53981: LD_VAR 0 1
53985: PPUSH
53986: LD_VAR 0 4
53990: PPUSH
53991: CALL_OW 3
53995: ST_TO_ADDR
// end ;
53996: GO 53920
53998: POP
53999: POP
// end ;
54000: LD_VAR 0 2
54004: RET
// export function GetBaseMaterials ( base ) ; begin
54005: LD_INT 0
54007: PPUSH
// result := [ 0 , 0 , 0 ] ;
54008: LD_ADDR_VAR 0 2
54012: PUSH
54013: LD_INT 0
54015: PUSH
54016: LD_INT 0
54018: PUSH
54019: LD_INT 0
54021: PUSH
54022: EMPTY
54023: LIST
54024: LIST
54025: LIST
54026: ST_TO_ADDR
// if not base then
54027: LD_VAR 0 1
54031: NOT
54032: IFFALSE 54036
// exit ;
54034: GO 54085
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54036: LD_ADDR_VAR 0 2
54040: PUSH
54041: LD_VAR 0 1
54045: PPUSH
54046: LD_INT 1
54048: PPUSH
54049: CALL_OW 275
54053: PUSH
54054: LD_VAR 0 1
54058: PPUSH
54059: LD_INT 2
54061: PPUSH
54062: CALL_OW 275
54066: PUSH
54067: LD_VAR 0 1
54071: PPUSH
54072: LD_INT 3
54074: PPUSH
54075: CALL_OW 275
54079: PUSH
54080: EMPTY
54081: LIST
54082: LIST
54083: LIST
54084: ST_TO_ADDR
// end ; end_of_file
54085: LD_VAR 0 2
54089: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
54090: GO 54092
54092: DISABLE
// begin ru_radar := 98 ;
54093: LD_ADDR_EXP 45
54097: PUSH
54098: LD_INT 98
54100: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
54101: LD_ADDR_EXP 46
54105: PUSH
54106: LD_INT 89
54108: ST_TO_ADDR
// us_hack := 99 ;
54109: LD_ADDR_EXP 47
54113: PUSH
54114: LD_INT 99
54116: ST_TO_ADDR
// us_artillery := 97 ;
54117: LD_ADDR_EXP 48
54121: PUSH
54122: LD_INT 97
54124: ST_TO_ADDR
// ar_bio_bomb := 91 ;
54125: LD_ADDR_EXP 49
54129: PUSH
54130: LD_INT 91
54132: ST_TO_ADDR
// end ; end_of_file
54133: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
54134: LD_INT 0
54136: PPUSH
54137: PPUSH
// skirmish := false ;
54138: LD_ADDR_EXP 50
54142: PUSH
54143: LD_INT 0
54145: ST_TO_ADDR
// debug_mc := false ;
54146: LD_ADDR_EXP 51
54150: PUSH
54151: LD_INT 0
54153: ST_TO_ADDR
// mc_bases := [ ] ;
54154: LD_ADDR_EXP 52
54158: PUSH
54159: EMPTY
54160: ST_TO_ADDR
// mc_sides := [ ] ;
54161: LD_ADDR_EXP 78
54165: PUSH
54166: EMPTY
54167: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54168: LD_ADDR_EXP 53
54172: PUSH
54173: EMPTY
54174: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54175: LD_ADDR_EXP 54
54179: PUSH
54180: EMPTY
54181: ST_TO_ADDR
// mc_need_heal := [ ] ;
54182: LD_ADDR_EXP 55
54186: PUSH
54187: EMPTY
54188: ST_TO_ADDR
// mc_healers := [ ] ;
54189: LD_ADDR_EXP 56
54193: PUSH
54194: EMPTY
54195: ST_TO_ADDR
// mc_build_list := [ ] ;
54196: LD_ADDR_EXP 57
54200: PUSH
54201: EMPTY
54202: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54203: LD_ADDR_EXP 84
54207: PUSH
54208: EMPTY
54209: ST_TO_ADDR
// mc_builders := [ ] ;
54210: LD_ADDR_EXP 58
54214: PUSH
54215: EMPTY
54216: ST_TO_ADDR
// mc_construct_list := [ ] ;
54217: LD_ADDR_EXP 59
54221: PUSH
54222: EMPTY
54223: ST_TO_ADDR
// mc_turret_list := [ ] ;
54224: LD_ADDR_EXP 60
54228: PUSH
54229: EMPTY
54230: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54231: LD_ADDR_EXP 61
54235: PUSH
54236: EMPTY
54237: ST_TO_ADDR
// mc_miners := [ ] ;
54238: LD_ADDR_EXP 66
54242: PUSH
54243: EMPTY
54244: ST_TO_ADDR
// mc_mines := [ ] ;
54245: LD_ADDR_EXP 65
54249: PUSH
54250: EMPTY
54251: ST_TO_ADDR
// mc_minefields := [ ] ;
54252: LD_ADDR_EXP 67
54256: PUSH
54257: EMPTY
54258: ST_TO_ADDR
// mc_crates := [ ] ;
54259: LD_ADDR_EXP 68
54263: PUSH
54264: EMPTY
54265: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54266: LD_ADDR_EXP 69
54270: PUSH
54271: EMPTY
54272: ST_TO_ADDR
// mc_crates_area := [ ] ;
54273: LD_ADDR_EXP 70
54277: PUSH
54278: EMPTY
54279: ST_TO_ADDR
// mc_vehicles := [ ] ;
54280: LD_ADDR_EXP 71
54284: PUSH
54285: EMPTY
54286: ST_TO_ADDR
// mc_attack := [ ] ;
54287: LD_ADDR_EXP 72
54291: PUSH
54292: EMPTY
54293: ST_TO_ADDR
// mc_produce := [ ] ;
54294: LD_ADDR_EXP 73
54298: PUSH
54299: EMPTY
54300: ST_TO_ADDR
// mc_defender := [ ] ;
54301: LD_ADDR_EXP 74
54305: PUSH
54306: EMPTY
54307: ST_TO_ADDR
// mc_parking := [ ] ;
54308: LD_ADDR_EXP 76
54312: PUSH
54313: EMPTY
54314: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54315: LD_ADDR_EXP 62
54319: PUSH
54320: EMPTY
54321: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54322: LD_ADDR_EXP 64
54326: PUSH
54327: EMPTY
54328: ST_TO_ADDR
// mc_scan := [ ] ;
54329: LD_ADDR_EXP 75
54333: PUSH
54334: EMPTY
54335: ST_TO_ADDR
// mc_scan_area := [ ] ;
54336: LD_ADDR_EXP 77
54340: PUSH
54341: EMPTY
54342: ST_TO_ADDR
// mc_tech := [ ] ;
54343: LD_ADDR_EXP 79
54347: PUSH
54348: EMPTY
54349: ST_TO_ADDR
// mc_class := [ ] ;
54350: LD_ADDR_EXP 93
54354: PUSH
54355: EMPTY
54356: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54357: LD_ADDR_EXP 94
54361: PUSH
54362: EMPTY
54363: ST_TO_ADDR
// end ;
54364: LD_VAR 0 1
54368: RET
// export function MC_Kill ( base ) ; begin
54369: LD_INT 0
54371: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54372: LD_ADDR_EXP 52
54376: PUSH
54377: LD_EXP 52
54381: PPUSH
54382: LD_VAR 0 1
54386: PPUSH
54387: EMPTY
54388: PPUSH
54389: CALL_OW 1
54393: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54394: LD_ADDR_EXP 53
54398: PUSH
54399: LD_EXP 53
54403: PPUSH
54404: LD_VAR 0 1
54408: PPUSH
54409: EMPTY
54410: PPUSH
54411: CALL_OW 1
54415: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54416: LD_ADDR_EXP 54
54420: PUSH
54421: LD_EXP 54
54425: PPUSH
54426: LD_VAR 0 1
54430: PPUSH
54431: EMPTY
54432: PPUSH
54433: CALL_OW 1
54437: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54438: LD_ADDR_EXP 55
54442: PUSH
54443: LD_EXP 55
54447: PPUSH
54448: LD_VAR 0 1
54452: PPUSH
54453: EMPTY
54454: PPUSH
54455: CALL_OW 1
54459: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54460: LD_ADDR_EXP 56
54464: PUSH
54465: LD_EXP 56
54469: PPUSH
54470: LD_VAR 0 1
54474: PPUSH
54475: EMPTY
54476: PPUSH
54477: CALL_OW 1
54481: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54482: LD_ADDR_EXP 57
54486: PUSH
54487: LD_EXP 57
54491: PPUSH
54492: LD_VAR 0 1
54496: PPUSH
54497: EMPTY
54498: PPUSH
54499: CALL_OW 1
54503: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54504: LD_ADDR_EXP 58
54508: PUSH
54509: LD_EXP 58
54513: PPUSH
54514: LD_VAR 0 1
54518: PPUSH
54519: EMPTY
54520: PPUSH
54521: CALL_OW 1
54525: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54526: LD_ADDR_EXP 59
54530: PUSH
54531: LD_EXP 59
54535: PPUSH
54536: LD_VAR 0 1
54540: PPUSH
54541: EMPTY
54542: PPUSH
54543: CALL_OW 1
54547: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54548: LD_ADDR_EXP 60
54552: PUSH
54553: LD_EXP 60
54557: PPUSH
54558: LD_VAR 0 1
54562: PPUSH
54563: EMPTY
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54570: LD_ADDR_EXP 61
54574: PUSH
54575: LD_EXP 61
54579: PPUSH
54580: LD_VAR 0 1
54584: PPUSH
54585: EMPTY
54586: PPUSH
54587: CALL_OW 1
54591: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54592: LD_ADDR_EXP 62
54596: PUSH
54597: LD_EXP 62
54601: PPUSH
54602: LD_VAR 0 1
54606: PPUSH
54607: EMPTY
54608: PPUSH
54609: CALL_OW 1
54613: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54614: LD_ADDR_EXP 63
54618: PUSH
54619: LD_EXP 63
54623: PPUSH
54624: LD_VAR 0 1
54628: PPUSH
54629: LD_INT 0
54631: PPUSH
54632: CALL_OW 1
54636: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54637: LD_ADDR_EXP 64
54641: PUSH
54642: LD_EXP 64
54646: PPUSH
54647: LD_VAR 0 1
54651: PPUSH
54652: EMPTY
54653: PPUSH
54654: CALL_OW 1
54658: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54659: LD_ADDR_EXP 65
54663: PUSH
54664: LD_EXP 65
54668: PPUSH
54669: LD_VAR 0 1
54673: PPUSH
54674: EMPTY
54675: PPUSH
54676: CALL_OW 1
54680: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54681: LD_ADDR_EXP 66
54685: PUSH
54686: LD_EXP 66
54690: PPUSH
54691: LD_VAR 0 1
54695: PPUSH
54696: EMPTY
54697: PPUSH
54698: CALL_OW 1
54702: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54703: LD_ADDR_EXP 67
54707: PUSH
54708: LD_EXP 67
54712: PPUSH
54713: LD_VAR 0 1
54717: PPUSH
54718: EMPTY
54719: PPUSH
54720: CALL_OW 1
54724: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54725: LD_ADDR_EXP 68
54729: PUSH
54730: LD_EXP 68
54734: PPUSH
54735: LD_VAR 0 1
54739: PPUSH
54740: EMPTY
54741: PPUSH
54742: CALL_OW 1
54746: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54747: LD_ADDR_EXP 69
54751: PUSH
54752: LD_EXP 69
54756: PPUSH
54757: LD_VAR 0 1
54761: PPUSH
54762: EMPTY
54763: PPUSH
54764: CALL_OW 1
54768: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54769: LD_ADDR_EXP 70
54773: PUSH
54774: LD_EXP 70
54778: PPUSH
54779: LD_VAR 0 1
54783: PPUSH
54784: EMPTY
54785: PPUSH
54786: CALL_OW 1
54790: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54791: LD_ADDR_EXP 71
54795: PUSH
54796: LD_EXP 71
54800: PPUSH
54801: LD_VAR 0 1
54805: PPUSH
54806: EMPTY
54807: PPUSH
54808: CALL_OW 1
54812: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54813: LD_ADDR_EXP 72
54817: PUSH
54818: LD_EXP 72
54822: PPUSH
54823: LD_VAR 0 1
54827: PPUSH
54828: EMPTY
54829: PPUSH
54830: CALL_OW 1
54834: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54835: LD_ADDR_EXP 73
54839: PUSH
54840: LD_EXP 73
54844: PPUSH
54845: LD_VAR 0 1
54849: PPUSH
54850: EMPTY
54851: PPUSH
54852: CALL_OW 1
54856: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54857: LD_ADDR_EXP 74
54861: PUSH
54862: LD_EXP 74
54866: PPUSH
54867: LD_VAR 0 1
54871: PPUSH
54872: EMPTY
54873: PPUSH
54874: CALL_OW 1
54878: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54879: LD_ADDR_EXP 75
54883: PUSH
54884: LD_EXP 75
54888: PPUSH
54889: LD_VAR 0 1
54893: PPUSH
54894: EMPTY
54895: PPUSH
54896: CALL_OW 1
54900: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54901: LD_ADDR_EXP 76
54905: PUSH
54906: LD_EXP 76
54910: PPUSH
54911: LD_VAR 0 1
54915: PPUSH
54916: EMPTY
54917: PPUSH
54918: CALL_OW 1
54922: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54923: LD_ADDR_EXP 77
54927: PUSH
54928: LD_EXP 77
54932: PPUSH
54933: LD_VAR 0 1
54937: PPUSH
54938: EMPTY
54939: PPUSH
54940: CALL_OW 1
54944: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54945: LD_ADDR_EXP 79
54949: PUSH
54950: LD_EXP 79
54954: PPUSH
54955: LD_VAR 0 1
54959: PPUSH
54960: EMPTY
54961: PPUSH
54962: CALL_OW 1
54966: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54967: LD_ADDR_EXP 81
54971: PUSH
54972: LD_EXP 81
54976: PPUSH
54977: LD_VAR 0 1
54981: PPUSH
54982: EMPTY
54983: PPUSH
54984: CALL_OW 1
54988: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54989: LD_ADDR_EXP 82
54993: PUSH
54994: LD_EXP 82
54998: PPUSH
54999: LD_VAR 0 1
55003: PPUSH
55004: EMPTY
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55011: LD_ADDR_EXP 83
55015: PUSH
55016: LD_EXP 83
55020: PPUSH
55021: LD_VAR 0 1
55025: PPUSH
55026: EMPTY
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55033: LD_ADDR_EXP 84
55037: PUSH
55038: LD_EXP 84
55042: PPUSH
55043: LD_VAR 0 1
55047: PPUSH
55048: EMPTY
55049: PPUSH
55050: CALL_OW 1
55054: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55055: LD_ADDR_EXP 85
55059: PUSH
55060: LD_EXP 85
55064: PPUSH
55065: LD_VAR 0 1
55069: PPUSH
55070: EMPTY
55071: PPUSH
55072: CALL_OW 1
55076: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55077: LD_ADDR_EXP 86
55081: PUSH
55082: LD_EXP 86
55086: PPUSH
55087: LD_VAR 0 1
55091: PPUSH
55092: EMPTY
55093: PPUSH
55094: CALL_OW 1
55098: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55099: LD_ADDR_EXP 87
55103: PUSH
55104: LD_EXP 87
55108: PPUSH
55109: LD_VAR 0 1
55113: PPUSH
55114: EMPTY
55115: PPUSH
55116: CALL_OW 1
55120: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55121: LD_ADDR_EXP 88
55125: PUSH
55126: LD_EXP 88
55130: PPUSH
55131: LD_VAR 0 1
55135: PPUSH
55136: EMPTY
55137: PPUSH
55138: CALL_OW 1
55142: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55143: LD_ADDR_EXP 89
55147: PUSH
55148: LD_EXP 89
55152: PPUSH
55153: LD_VAR 0 1
55157: PPUSH
55158: EMPTY
55159: PPUSH
55160: CALL_OW 1
55164: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55165: LD_ADDR_EXP 90
55169: PUSH
55170: LD_EXP 90
55174: PPUSH
55175: LD_VAR 0 1
55179: PPUSH
55180: EMPTY
55181: PPUSH
55182: CALL_OW 1
55186: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55187: LD_ADDR_EXP 91
55191: PUSH
55192: LD_EXP 91
55196: PPUSH
55197: LD_VAR 0 1
55201: PPUSH
55202: EMPTY
55203: PPUSH
55204: CALL_OW 1
55208: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55209: LD_ADDR_EXP 92
55213: PUSH
55214: LD_EXP 92
55218: PPUSH
55219: LD_VAR 0 1
55223: PPUSH
55224: EMPTY
55225: PPUSH
55226: CALL_OW 1
55230: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55231: LD_ADDR_EXP 93
55235: PUSH
55236: LD_EXP 93
55240: PPUSH
55241: LD_VAR 0 1
55245: PPUSH
55246: EMPTY
55247: PPUSH
55248: CALL_OW 1
55252: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55253: LD_ADDR_EXP 94
55257: PUSH
55258: LD_EXP 94
55262: PPUSH
55263: LD_VAR 0 1
55267: PPUSH
55268: LD_INT 0
55270: PPUSH
55271: CALL_OW 1
55275: ST_TO_ADDR
// end ;
55276: LD_VAR 0 2
55280: RET
// export function MC_Add ( side , units ) ; var base ; begin
55281: LD_INT 0
55283: PPUSH
55284: PPUSH
// base := mc_bases + 1 ;
55285: LD_ADDR_VAR 0 4
55289: PUSH
55290: LD_EXP 52
55294: PUSH
55295: LD_INT 1
55297: PLUS
55298: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55299: LD_ADDR_EXP 78
55303: PUSH
55304: LD_EXP 78
55308: PPUSH
55309: LD_VAR 0 4
55313: PPUSH
55314: LD_VAR 0 1
55318: PPUSH
55319: CALL_OW 1
55323: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55324: LD_ADDR_EXP 52
55328: PUSH
55329: LD_EXP 52
55333: PPUSH
55334: LD_VAR 0 4
55338: PPUSH
55339: LD_VAR 0 2
55343: PPUSH
55344: CALL_OW 1
55348: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55349: LD_ADDR_EXP 53
55353: PUSH
55354: LD_EXP 53
55358: PPUSH
55359: LD_VAR 0 4
55363: PPUSH
55364: EMPTY
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55371: LD_ADDR_EXP 54
55375: PUSH
55376: LD_EXP 54
55380: PPUSH
55381: LD_VAR 0 4
55385: PPUSH
55386: EMPTY
55387: PPUSH
55388: CALL_OW 1
55392: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55393: LD_ADDR_EXP 55
55397: PUSH
55398: LD_EXP 55
55402: PPUSH
55403: LD_VAR 0 4
55407: PPUSH
55408: EMPTY
55409: PPUSH
55410: CALL_OW 1
55414: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55415: LD_ADDR_EXP 56
55419: PUSH
55420: LD_EXP 56
55424: PPUSH
55425: LD_VAR 0 4
55429: PPUSH
55430: EMPTY
55431: PPUSH
55432: CALL_OW 1
55436: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55437: LD_ADDR_EXP 57
55441: PUSH
55442: LD_EXP 57
55446: PPUSH
55447: LD_VAR 0 4
55451: PPUSH
55452: EMPTY
55453: PPUSH
55454: CALL_OW 1
55458: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55459: LD_ADDR_EXP 58
55463: PUSH
55464: LD_EXP 58
55468: PPUSH
55469: LD_VAR 0 4
55473: PPUSH
55474: EMPTY
55475: PPUSH
55476: CALL_OW 1
55480: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55481: LD_ADDR_EXP 59
55485: PUSH
55486: LD_EXP 59
55490: PPUSH
55491: LD_VAR 0 4
55495: PPUSH
55496: EMPTY
55497: PPUSH
55498: CALL_OW 1
55502: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55503: LD_ADDR_EXP 60
55507: PUSH
55508: LD_EXP 60
55512: PPUSH
55513: LD_VAR 0 4
55517: PPUSH
55518: EMPTY
55519: PPUSH
55520: CALL_OW 1
55524: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55525: LD_ADDR_EXP 61
55529: PUSH
55530: LD_EXP 61
55534: PPUSH
55535: LD_VAR 0 4
55539: PPUSH
55540: EMPTY
55541: PPUSH
55542: CALL_OW 1
55546: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55547: LD_ADDR_EXP 62
55551: PUSH
55552: LD_EXP 62
55556: PPUSH
55557: LD_VAR 0 4
55561: PPUSH
55562: EMPTY
55563: PPUSH
55564: CALL_OW 1
55568: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55569: LD_ADDR_EXP 63
55573: PUSH
55574: LD_EXP 63
55578: PPUSH
55579: LD_VAR 0 4
55583: PPUSH
55584: LD_INT 0
55586: PPUSH
55587: CALL_OW 1
55591: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55592: LD_ADDR_EXP 64
55596: PUSH
55597: LD_EXP 64
55601: PPUSH
55602: LD_VAR 0 4
55606: PPUSH
55607: EMPTY
55608: PPUSH
55609: CALL_OW 1
55613: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55614: LD_ADDR_EXP 65
55618: PUSH
55619: LD_EXP 65
55623: PPUSH
55624: LD_VAR 0 4
55628: PPUSH
55629: EMPTY
55630: PPUSH
55631: CALL_OW 1
55635: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55636: LD_ADDR_EXP 66
55640: PUSH
55641: LD_EXP 66
55645: PPUSH
55646: LD_VAR 0 4
55650: PPUSH
55651: EMPTY
55652: PPUSH
55653: CALL_OW 1
55657: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55658: LD_ADDR_EXP 67
55662: PUSH
55663: LD_EXP 67
55667: PPUSH
55668: LD_VAR 0 4
55672: PPUSH
55673: EMPTY
55674: PPUSH
55675: CALL_OW 1
55679: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55680: LD_ADDR_EXP 68
55684: PUSH
55685: LD_EXP 68
55689: PPUSH
55690: LD_VAR 0 4
55694: PPUSH
55695: EMPTY
55696: PPUSH
55697: CALL_OW 1
55701: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55702: LD_ADDR_EXP 69
55706: PUSH
55707: LD_EXP 69
55711: PPUSH
55712: LD_VAR 0 4
55716: PPUSH
55717: EMPTY
55718: PPUSH
55719: CALL_OW 1
55723: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55724: LD_ADDR_EXP 70
55728: PUSH
55729: LD_EXP 70
55733: PPUSH
55734: LD_VAR 0 4
55738: PPUSH
55739: EMPTY
55740: PPUSH
55741: CALL_OW 1
55745: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55746: LD_ADDR_EXP 71
55750: PUSH
55751: LD_EXP 71
55755: PPUSH
55756: LD_VAR 0 4
55760: PPUSH
55761: EMPTY
55762: PPUSH
55763: CALL_OW 1
55767: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55768: LD_ADDR_EXP 72
55772: PUSH
55773: LD_EXP 72
55777: PPUSH
55778: LD_VAR 0 4
55782: PPUSH
55783: EMPTY
55784: PPUSH
55785: CALL_OW 1
55789: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55790: LD_ADDR_EXP 73
55794: PUSH
55795: LD_EXP 73
55799: PPUSH
55800: LD_VAR 0 4
55804: PPUSH
55805: EMPTY
55806: PPUSH
55807: CALL_OW 1
55811: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55812: LD_ADDR_EXP 74
55816: PUSH
55817: LD_EXP 74
55821: PPUSH
55822: LD_VAR 0 4
55826: PPUSH
55827: EMPTY
55828: PPUSH
55829: CALL_OW 1
55833: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55834: LD_ADDR_EXP 75
55838: PUSH
55839: LD_EXP 75
55843: PPUSH
55844: LD_VAR 0 4
55848: PPUSH
55849: EMPTY
55850: PPUSH
55851: CALL_OW 1
55855: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55856: LD_ADDR_EXP 76
55860: PUSH
55861: LD_EXP 76
55865: PPUSH
55866: LD_VAR 0 4
55870: PPUSH
55871: EMPTY
55872: PPUSH
55873: CALL_OW 1
55877: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55878: LD_ADDR_EXP 77
55882: PUSH
55883: LD_EXP 77
55887: PPUSH
55888: LD_VAR 0 4
55892: PPUSH
55893: EMPTY
55894: PPUSH
55895: CALL_OW 1
55899: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55900: LD_ADDR_EXP 79
55904: PUSH
55905: LD_EXP 79
55909: PPUSH
55910: LD_VAR 0 4
55914: PPUSH
55915: EMPTY
55916: PPUSH
55917: CALL_OW 1
55921: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55922: LD_ADDR_EXP 81
55926: PUSH
55927: LD_EXP 81
55931: PPUSH
55932: LD_VAR 0 4
55936: PPUSH
55937: EMPTY
55938: PPUSH
55939: CALL_OW 1
55943: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55944: LD_ADDR_EXP 82
55948: PUSH
55949: LD_EXP 82
55953: PPUSH
55954: LD_VAR 0 4
55958: PPUSH
55959: EMPTY
55960: PPUSH
55961: CALL_OW 1
55965: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55966: LD_ADDR_EXP 83
55970: PUSH
55971: LD_EXP 83
55975: PPUSH
55976: LD_VAR 0 4
55980: PPUSH
55981: EMPTY
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55988: LD_ADDR_EXP 84
55992: PUSH
55993: LD_EXP 84
55997: PPUSH
55998: LD_VAR 0 4
56002: PPUSH
56003: EMPTY
56004: PPUSH
56005: CALL_OW 1
56009: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56010: LD_ADDR_EXP 85
56014: PUSH
56015: LD_EXP 85
56019: PPUSH
56020: LD_VAR 0 4
56024: PPUSH
56025: EMPTY
56026: PPUSH
56027: CALL_OW 1
56031: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56032: LD_ADDR_EXP 86
56036: PUSH
56037: LD_EXP 86
56041: PPUSH
56042: LD_VAR 0 4
56046: PPUSH
56047: EMPTY
56048: PPUSH
56049: CALL_OW 1
56053: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56054: LD_ADDR_EXP 87
56058: PUSH
56059: LD_EXP 87
56063: PPUSH
56064: LD_VAR 0 4
56068: PPUSH
56069: EMPTY
56070: PPUSH
56071: CALL_OW 1
56075: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56076: LD_ADDR_EXP 88
56080: PUSH
56081: LD_EXP 88
56085: PPUSH
56086: LD_VAR 0 4
56090: PPUSH
56091: EMPTY
56092: PPUSH
56093: CALL_OW 1
56097: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56098: LD_ADDR_EXP 89
56102: PUSH
56103: LD_EXP 89
56107: PPUSH
56108: LD_VAR 0 4
56112: PPUSH
56113: EMPTY
56114: PPUSH
56115: CALL_OW 1
56119: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56120: LD_ADDR_EXP 90
56124: PUSH
56125: LD_EXP 90
56129: PPUSH
56130: LD_VAR 0 4
56134: PPUSH
56135: EMPTY
56136: PPUSH
56137: CALL_OW 1
56141: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56142: LD_ADDR_EXP 91
56146: PUSH
56147: LD_EXP 91
56151: PPUSH
56152: LD_VAR 0 4
56156: PPUSH
56157: EMPTY
56158: PPUSH
56159: CALL_OW 1
56163: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56164: LD_ADDR_EXP 92
56168: PUSH
56169: LD_EXP 92
56173: PPUSH
56174: LD_VAR 0 4
56178: PPUSH
56179: EMPTY
56180: PPUSH
56181: CALL_OW 1
56185: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56186: LD_ADDR_EXP 93
56190: PUSH
56191: LD_EXP 93
56195: PPUSH
56196: LD_VAR 0 4
56200: PPUSH
56201: EMPTY
56202: PPUSH
56203: CALL_OW 1
56207: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56208: LD_ADDR_EXP 94
56212: PUSH
56213: LD_EXP 94
56217: PPUSH
56218: LD_VAR 0 4
56222: PPUSH
56223: LD_INT 0
56225: PPUSH
56226: CALL_OW 1
56230: ST_TO_ADDR
// result := base ;
56231: LD_ADDR_VAR 0 3
56235: PUSH
56236: LD_VAR 0 4
56240: ST_TO_ADDR
// end ;
56241: LD_VAR 0 3
56245: RET
// export function MC_Start ( ) ; var i ; begin
56246: LD_INT 0
56248: PPUSH
56249: PPUSH
// for i = 1 to mc_bases do
56250: LD_ADDR_VAR 0 2
56254: PUSH
56255: DOUBLE
56256: LD_INT 1
56258: DEC
56259: ST_TO_ADDR
56260: LD_EXP 52
56264: PUSH
56265: FOR_TO
56266: IFFALSE 57343
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56268: LD_ADDR_EXP 52
56272: PUSH
56273: LD_EXP 52
56277: PPUSH
56278: LD_VAR 0 2
56282: PPUSH
56283: LD_EXP 52
56287: PUSH
56288: LD_VAR 0 2
56292: ARRAY
56293: PUSH
56294: LD_INT 0
56296: DIFF
56297: PPUSH
56298: CALL_OW 1
56302: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56303: LD_ADDR_EXP 53
56307: PUSH
56308: LD_EXP 53
56312: PPUSH
56313: LD_VAR 0 2
56317: PPUSH
56318: EMPTY
56319: PPUSH
56320: CALL_OW 1
56324: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56325: LD_ADDR_EXP 54
56329: PUSH
56330: LD_EXP 54
56334: PPUSH
56335: LD_VAR 0 2
56339: PPUSH
56340: EMPTY
56341: PPUSH
56342: CALL_OW 1
56346: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56347: LD_ADDR_EXP 55
56351: PUSH
56352: LD_EXP 55
56356: PPUSH
56357: LD_VAR 0 2
56361: PPUSH
56362: EMPTY
56363: PPUSH
56364: CALL_OW 1
56368: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56369: LD_ADDR_EXP 56
56373: PUSH
56374: LD_EXP 56
56378: PPUSH
56379: LD_VAR 0 2
56383: PPUSH
56384: EMPTY
56385: PUSH
56386: EMPTY
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: PPUSH
56392: CALL_OW 1
56396: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56397: LD_ADDR_EXP 57
56401: PUSH
56402: LD_EXP 57
56406: PPUSH
56407: LD_VAR 0 2
56411: PPUSH
56412: EMPTY
56413: PPUSH
56414: CALL_OW 1
56418: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56419: LD_ADDR_EXP 84
56423: PUSH
56424: LD_EXP 84
56428: PPUSH
56429: LD_VAR 0 2
56433: PPUSH
56434: EMPTY
56435: PPUSH
56436: CALL_OW 1
56440: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56441: LD_ADDR_EXP 58
56445: PUSH
56446: LD_EXP 58
56450: PPUSH
56451: LD_VAR 0 2
56455: PPUSH
56456: EMPTY
56457: PPUSH
56458: CALL_OW 1
56462: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56463: LD_ADDR_EXP 59
56467: PUSH
56468: LD_EXP 59
56472: PPUSH
56473: LD_VAR 0 2
56477: PPUSH
56478: EMPTY
56479: PPUSH
56480: CALL_OW 1
56484: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56485: LD_ADDR_EXP 60
56489: PUSH
56490: LD_EXP 60
56494: PPUSH
56495: LD_VAR 0 2
56499: PPUSH
56500: LD_EXP 52
56504: PUSH
56505: LD_VAR 0 2
56509: ARRAY
56510: PPUSH
56511: LD_INT 2
56513: PUSH
56514: LD_INT 30
56516: PUSH
56517: LD_INT 32
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PUSH
56524: LD_INT 30
56526: PUSH
56527: LD_INT 33
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PUSH
56534: EMPTY
56535: LIST
56536: LIST
56537: LIST
56538: PPUSH
56539: CALL_OW 72
56543: PPUSH
56544: CALL_OW 1
56548: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56549: LD_ADDR_EXP 61
56553: PUSH
56554: LD_EXP 61
56558: PPUSH
56559: LD_VAR 0 2
56563: PPUSH
56564: LD_EXP 52
56568: PUSH
56569: LD_VAR 0 2
56573: ARRAY
56574: PPUSH
56575: LD_INT 2
56577: PUSH
56578: LD_INT 30
56580: PUSH
56581: LD_INT 32
56583: PUSH
56584: EMPTY
56585: LIST
56586: LIST
56587: PUSH
56588: LD_INT 30
56590: PUSH
56591: LD_INT 31
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: LIST
56602: PUSH
56603: LD_INT 58
56605: PUSH
56606: EMPTY
56607: LIST
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: PPUSH
56613: CALL_OW 72
56617: PPUSH
56618: CALL_OW 1
56622: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56623: LD_ADDR_EXP 62
56627: PUSH
56628: LD_EXP 62
56632: PPUSH
56633: LD_VAR 0 2
56637: PPUSH
56638: EMPTY
56639: PPUSH
56640: CALL_OW 1
56644: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56645: LD_ADDR_EXP 66
56649: PUSH
56650: LD_EXP 66
56654: PPUSH
56655: LD_VAR 0 2
56659: PPUSH
56660: EMPTY
56661: PPUSH
56662: CALL_OW 1
56666: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56667: LD_ADDR_EXP 65
56671: PUSH
56672: LD_EXP 65
56676: PPUSH
56677: LD_VAR 0 2
56681: PPUSH
56682: EMPTY
56683: PPUSH
56684: CALL_OW 1
56688: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56689: LD_ADDR_EXP 67
56693: PUSH
56694: LD_EXP 67
56698: PPUSH
56699: LD_VAR 0 2
56703: PPUSH
56704: EMPTY
56705: PPUSH
56706: CALL_OW 1
56710: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56711: LD_ADDR_EXP 68
56715: PUSH
56716: LD_EXP 68
56720: PPUSH
56721: LD_VAR 0 2
56725: PPUSH
56726: EMPTY
56727: PPUSH
56728: CALL_OW 1
56732: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56733: LD_ADDR_EXP 69
56737: PUSH
56738: LD_EXP 69
56742: PPUSH
56743: LD_VAR 0 2
56747: PPUSH
56748: EMPTY
56749: PPUSH
56750: CALL_OW 1
56754: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56755: LD_ADDR_EXP 70
56759: PUSH
56760: LD_EXP 70
56764: PPUSH
56765: LD_VAR 0 2
56769: PPUSH
56770: EMPTY
56771: PPUSH
56772: CALL_OW 1
56776: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56777: LD_ADDR_EXP 71
56781: PUSH
56782: LD_EXP 71
56786: PPUSH
56787: LD_VAR 0 2
56791: PPUSH
56792: EMPTY
56793: PPUSH
56794: CALL_OW 1
56798: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56799: LD_ADDR_EXP 72
56803: PUSH
56804: LD_EXP 72
56808: PPUSH
56809: LD_VAR 0 2
56813: PPUSH
56814: EMPTY
56815: PPUSH
56816: CALL_OW 1
56820: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56821: LD_ADDR_EXP 73
56825: PUSH
56826: LD_EXP 73
56830: PPUSH
56831: LD_VAR 0 2
56835: PPUSH
56836: EMPTY
56837: PPUSH
56838: CALL_OW 1
56842: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56843: LD_ADDR_EXP 74
56847: PUSH
56848: LD_EXP 74
56852: PPUSH
56853: LD_VAR 0 2
56857: PPUSH
56858: EMPTY
56859: PPUSH
56860: CALL_OW 1
56864: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56865: LD_ADDR_EXP 63
56869: PUSH
56870: LD_EXP 63
56874: PPUSH
56875: LD_VAR 0 2
56879: PPUSH
56880: LD_INT 0
56882: PPUSH
56883: CALL_OW 1
56887: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56888: LD_ADDR_EXP 76
56892: PUSH
56893: LD_EXP 76
56897: PPUSH
56898: LD_VAR 0 2
56902: PPUSH
56903: LD_INT 0
56905: PPUSH
56906: CALL_OW 1
56910: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56911: LD_ADDR_EXP 64
56915: PUSH
56916: LD_EXP 64
56920: PPUSH
56921: LD_VAR 0 2
56925: PPUSH
56926: EMPTY
56927: PPUSH
56928: CALL_OW 1
56932: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56933: LD_ADDR_EXP 75
56937: PUSH
56938: LD_EXP 75
56942: PPUSH
56943: LD_VAR 0 2
56947: PPUSH
56948: LD_INT 0
56950: PPUSH
56951: CALL_OW 1
56955: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56956: LD_ADDR_EXP 77
56960: PUSH
56961: LD_EXP 77
56965: PPUSH
56966: LD_VAR 0 2
56970: PPUSH
56971: EMPTY
56972: PPUSH
56973: CALL_OW 1
56977: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56978: LD_ADDR_EXP 80
56982: PUSH
56983: LD_EXP 80
56987: PPUSH
56988: LD_VAR 0 2
56992: PPUSH
56993: LD_INT 0
56995: PPUSH
56996: CALL_OW 1
57000: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57001: LD_ADDR_EXP 81
57005: PUSH
57006: LD_EXP 81
57010: PPUSH
57011: LD_VAR 0 2
57015: PPUSH
57016: EMPTY
57017: PPUSH
57018: CALL_OW 1
57022: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57023: LD_ADDR_EXP 82
57027: PUSH
57028: LD_EXP 82
57032: PPUSH
57033: LD_VAR 0 2
57037: PPUSH
57038: EMPTY
57039: PPUSH
57040: CALL_OW 1
57044: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57045: LD_ADDR_EXP 83
57049: PUSH
57050: LD_EXP 83
57054: PPUSH
57055: LD_VAR 0 2
57059: PPUSH
57060: EMPTY
57061: PPUSH
57062: CALL_OW 1
57066: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57067: LD_ADDR_EXP 85
57071: PUSH
57072: LD_EXP 85
57076: PPUSH
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_EXP 52
57086: PUSH
57087: LD_VAR 0 2
57091: ARRAY
57092: PPUSH
57093: LD_INT 2
57095: PUSH
57096: LD_INT 30
57098: PUSH
57099: LD_INT 6
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PUSH
57106: LD_INT 30
57108: PUSH
57109: LD_INT 7
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: PUSH
57116: LD_INT 30
57118: PUSH
57119: LD_INT 8
57121: PUSH
57122: EMPTY
57123: LIST
57124: LIST
57125: PUSH
57126: EMPTY
57127: LIST
57128: LIST
57129: LIST
57130: LIST
57131: PPUSH
57132: CALL_OW 72
57136: PPUSH
57137: CALL_OW 1
57141: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57142: LD_ADDR_EXP 86
57146: PUSH
57147: LD_EXP 86
57151: PPUSH
57152: LD_VAR 0 2
57156: PPUSH
57157: EMPTY
57158: PPUSH
57159: CALL_OW 1
57163: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57164: LD_ADDR_EXP 87
57168: PUSH
57169: LD_EXP 87
57173: PPUSH
57174: LD_VAR 0 2
57178: PPUSH
57179: EMPTY
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57186: LD_ADDR_EXP 88
57190: PUSH
57191: LD_EXP 88
57195: PPUSH
57196: LD_VAR 0 2
57200: PPUSH
57201: EMPTY
57202: PPUSH
57203: CALL_OW 1
57207: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57208: LD_ADDR_EXP 89
57212: PUSH
57213: LD_EXP 89
57217: PPUSH
57218: LD_VAR 0 2
57222: PPUSH
57223: EMPTY
57224: PPUSH
57225: CALL_OW 1
57229: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57230: LD_ADDR_EXP 90
57234: PUSH
57235: LD_EXP 90
57239: PPUSH
57240: LD_VAR 0 2
57244: PPUSH
57245: EMPTY
57246: PPUSH
57247: CALL_OW 1
57251: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57252: LD_ADDR_EXP 91
57256: PUSH
57257: LD_EXP 91
57261: PPUSH
57262: LD_VAR 0 2
57266: PPUSH
57267: EMPTY
57268: PPUSH
57269: CALL_OW 1
57273: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57274: LD_ADDR_EXP 92
57278: PUSH
57279: LD_EXP 92
57283: PPUSH
57284: LD_VAR 0 2
57288: PPUSH
57289: EMPTY
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57296: LD_ADDR_EXP 93
57300: PUSH
57301: LD_EXP 93
57305: PPUSH
57306: LD_VAR 0 2
57310: PPUSH
57311: EMPTY
57312: PPUSH
57313: CALL_OW 1
57317: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57318: LD_ADDR_EXP 94
57322: PUSH
57323: LD_EXP 94
57327: PPUSH
57328: LD_VAR 0 2
57332: PPUSH
57333: LD_INT 0
57335: PPUSH
57336: CALL_OW 1
57340: ST_TO_ADDR
// end ;
57341: GO 56265
57343: POP
57344: POP
// MC_InitSides ( ) ;
57345: CALL 57631 0 0
// MC_InitResearch ( ) ;
57349: CALL 57370 0 0
// CustomInitMacro ( ) ;
57353: CALL 5346 0 0
// skirmish := true ;
57357: LD_ADDR_EXP 50
57361: PUSH
57362: LD_INT 1
57364: ST_TO_ADDR
// end ;
57365: LD_VAR 0 1
57369: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57370: LD_INT 0
57372: PPUSH
57373: PPUSH
57374: PPUSH
57375: PPUSH
57376: PPUSH
57377: PPUSH
// if not mc_bases then
57378: LD_EXP 52
57382: NOT
57383: IFFALSE 57387
// exit ;
57385: GO 57626
// for i = 1 to 8 do
57387: LD_ADDR_VAR 0 2
57391: PUSH
57392: DOUBLE
57393: LD_INT 1
57395: DEC
57396: ST_TO_ADDR
57397: LD_INT 8
57399: PUSH
57400: FOR_TO
57401: IFFALSE 57427
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57403: LD_ADDR_EXP 79
57407: PUSH
57408: LD_EXP 79
57412: PPUSH
57413: LD_VAR 0 2
57417: PPUSH
57418: EMPTY
57419: PPUSH
57420: CALL_OW 1
57424: ST_TO_ADDR
57425: GO 57400
57427: POP
57428: POP
// tmp := [ ] ;
57429: LD_ADDR_VAR 0 5
57433: PUSH
57434: EMPTY
57435: ST_TO_ADDR
// for i = 1 to mc_sides do
57436: LD_ADDR_VAR 0 2
57440: PUSH
57441: DOUBLE
57442: LD_INT 1
57444: DEC
57445: ST_TO_ADDR
57446: LD_EXP 78
57450: PUSH
57451: FOR_TO
57452: IFFALSE 57510
// if not mc_sides [ i ] in tmp then
57454: LD_EXP 78
57458: PUSH
57459: LD_VAR 0 2
57463: ARRAY
57464: PUSH
57465: LD_VAR 0 5
57469: IN
57470: NOT
57471: IFFALSE 57508
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57473: LD_ADDR_VAR 0 5
57477: PUSH
57478: LD_VAR 0 5
57482: PPUSH
57483: LD_VAR 0 5
57487: PUSH
57488: LD_INT 1
57490: PLUS
57491: PPUSH
57492: LD_EXP 78
57496: PUSH
57497: LD_VAR 0 2
57501: ARRAY
57502: PPUSH
57503: CALL_OW 2
57507: ST_TO_ADDR
57508: GO 57451
57510: POP
57511: POP
// if not tmp then
57512: LD_VAR 0 5
57516: NOT
57517: IFFALSE 57521
// exit ;
57519: GO 57626
// for j in tmp do
57521: LD_ADDR_VAR 0 3
57525: PUSH
57526: LD_VAR 0 5
57530: PUSH
57531: FOR_IN
57532: IFFALSE 57624
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57534: LD_ADDR_VAR 0 6
57538: PUSH
57539: LD_INT 22
57541: PUSH
57542: LD_VAR 0 3
57546: PUSH
57547: EMPTY
57548: LIST
57549: LIST
57550: PPUSH
57551: CALL_OW 69
57555: ST_TO_ADDR
// if not un then
57556: LD_VAR 0 6
57560: NOT
57561: IFFALSE 57565
// continue ;
57563: GO 57531
// nation := GetNation ( un [ 1 ] ) ;
57565: LD_ADDR_VAR 0 4
57569: PUSH
57570: LD_VAR 0 6
57574: PUSH
57575: LD_INT 1
57577: ARRAY
57578: PPUSH
57579: CALL_OW 248
57583: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57584: LD_ADDR_EXP 79
57588: PUSH
57589: LD_EXP 79
57593: PPUSH
57594: LD_VAR 0 3
57598: PPUSH
57599: LD_VAR 0 3
57603: PPUSH
57604: LD_VAR 0 4
57608: PPUSH
57609: LD_INT 1
57611: PPUSH
57612: CALL 11140 0 3
57616: PPUSH
57617: CALL_OW 1
57621: ST_TO_ADDR
// end ;
57622: GO 57531
57624: POP
57625: POP
// end ;
57626: LD_VAR 0 1
57630: RET
// export function MC_InitSides ( ) ; var i ; begin
57631: LD_INT 0
57633: PPUSH
57634: PPUSH
// if not mc_bases then
57635: LD_EXP 52
57639: NOT
57640: IFFALSE 57644
// exit ;
57642: GO 57718
// for i = 1 to mc_bases do
57644: LD_ADDR_VAR 0 2
57648: PUSH
57649: DOUBLE
57650: LD_INT 1
57652: DEC
57653: ST_TO_ADDR
57654: LD_EXP 52
57658: PUSH
57659: FOR_TO
57660: IFFALSE 57716
// if mc_bases [ i ] then
57662: LD_EXP 52
57666: PUSH
57667: LD_VAR 0 2
57671: ARRAY
57672: IFFALSE 57714
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57674: LD_ADDR_EXP 78
57678: PUSH
57679: LD_EXP 78
57683: PPUSH
57684: LD_VAR 0 2
57688: PPUSH
57689: LD_EXP 52
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PUSH
57700: LD_INT 1
57702: ARRAY
57703: PPUSH
57704: CALL_OW 255
57708: PPUSH
57709: CALL_OW 1
57713: ST_TO_ADDR
57714: GO 57659
57716: POP
57717: POP
// end ;
57718: LD_VAR 0 1
57722: RET
// every 0 0$01 trigger skirmish do
57723: LD_EXP 50
57727: IFFALSE 57881
57729: GO 57731
57731: DISABLE
// begin enable ;
57732: ENABLE
// MC_CheckBuildings ( ) ;
57733: CALL 62379 0 0
// MC_CheckPeopleLife ( ) ;
57737: CALL 62504 0 0
// RaiseSailEvent ( 100 ) ;
57741: LD_INT 100
57743: PPUSH
57744: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57748: LD_INT 103
57750: PPUSH
57751: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57755: LD_INT 104
57757: PPUSH
57758: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57762: LD_INT 105
57764: PPUSH
57765: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57769: LD_INT 106
57771: PPUSH
57772: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57776: LD_INT 107
57778: PPUSH
57779: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57783: LD_INT 108
57785: PPUSH
57786: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57790: LD_INT 109
57792: PPUSH
57793: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57797: LD_INT 110
57799: PPUSH
57800: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57804: LD_INT 111
57806: PPUSH
57807: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57811: LD_INT 112
57813: PPUSH
57814: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57818: LD_INT 113
57820: PPUSH
57821: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57825: LD_INT 120
57827: PPUSH
57828: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57832: LD_INT 121
57834: PPUSH
57835: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57839: LD_INT 122
57841: PPUSH
57842: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57846: LD_INT 123
57848: PPUSH
57849: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57853: LD_INT 124
57855: PPUSH
57856: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57860: LD_INT 125
57862: PPUSH
57863: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57867: LD_INT 126
57869: PPUSH
57870: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57874: LD_INT 200
57876: PPUSH
57877: CALL_OW 427
// end ;
57881: END
// on SailEvent ( event ) do begin if event < 100 then
57882: LD_VAR 0 1
57886: PUSH
57887: LD_INT 100
57889: LESS
57890: IFFALSE 57901
// CustomEvent ( event ) ;
57892: LD_VAR 0 1
57896: PPUSH
57897: CALL 5338 0 1
// if event = 100 then
57901: LD_VAR 0 1
57905: PUSH
57906: LD_INT 100
57908: EQUAL
57909: IFFALSE 57915
// MC_ClassManager ( ) ;
57911: CALL 58307 0 0
// if event = 101 then
57915: LD_VAR 0 1
57919: PUSH
57920: LD_INT 101
57922: EQUAL
57923: IFFALSE 57929
// MC_RepairBuildings ( ) ;
57925: CALL 63100 0 0
// if event = 102 then
57929: LD_VAR 0 1
57933: PUSH
57934: LD_INT 102
57936: EQUAL
57937: IFFALSE 57943
// MC_Heal ( ) ;
57939: CALL 63832 0 0
// if event = 103 then
57943: LD_VAR 0 1
57947: PUSH
57948: LD_INT 103
57950: EQUAL
57951: IFFALSE 57957
// MC_Build ( ) ;
57953: CALL 64254 0 0
// if event = 104 then
57957: LD_VAR 0 1
57961: PUSH
57962: LD_INT 104
57964: EQUAL
57965: IFFALSE 57971
// MC_TurretWeapon ( ) ;
57967: CALL 65867 0 0
// if event = 105 then
57971: LD_VAR 0 1
57975: PUSH
57976: LD_INT 105
57978: EQUAL
57979: IFFALSE 57985
// MC_BuildUpgrade ( ) ;
57981: CALL 65418 0 0
// if event = 106 then
57985: LD_VAR 0 1
57989: PUSH
57990: LD_INT 106
57992: EQUAL
57993: IFFALSE 57999
// MC_PlantMines ( ) ;
57995: CALL 66297 0 0
// if event = 107 then
57999: LD_VAR 0 1
58003: PUSH
58004: LD_INT 107
58006: EQUAL
58007: IFFALSE 58013
// MC_CollectCrates ( ) ;
58009: CALL 67331 0 0
// if event = 108 then
58013: LD_VAR 0 1
58017: PUSH
58018: LD_INT 108
58020: EQUAL
58021: IFFALSE 58027
// MC_LinkRemoteControl ( ) ;
58023: CALL 69107 0 0
// if event = 109 then
58027: LD_VAR 0 1
58031: PUSH
58032: LD_INT 109
58034: EQUAL
58035: IFFALSE 58041
// MC_ProduceVehicle ( ) ;
58037: CALL 69288 0 0
// if event = 110 then
58041: LD_VAR 0 1
58045: PUSH
58046: LD_INT 110
58048: EQUAL
58049: IFFALSE 58055
// MC_SendAttack ( ) ;
58051: CALL 69754 0 0
// if event = 111 then
58055: LD_VAR 0 1
58059: PUSH
58060: LD_INT 111
58062: EQUAL
58063: IFFALSE 58069
// MC_Defend ( ) ;
58065: CALL 69862 0 0
// if event = 112 then
58069: LD_VAR 0 1
58073: PUSH
58074: LD_INT 112
58076: EQUAL
58077: IFFALSE 58083
// MC_Research ( ) ;
58079: CALL 70467 0 0
// if event = 113 then
58083: LD_VAR 0 1
58087: PUSH
58088: LD_INT 113
58090: EQUAL
58091: IFFALSE 58097
// MC_MinesTrigger ( ) ;
58093: CALL 71581 0 0
// if event = 120 then
58097: LD_VAR 0 1
58101: PUSH
58102: LD_INT 120
58104: EQUAL
58105: IFFALSE 58111
// MC_RepairVehicle ( ) ;
58107: CALL 71680 0 0
// if event = 121 then
58111: LD_VAR 0 1
58115: PUSH
58116: LD_INT 121
58118: EQUAL
58119: IFFALSE 58125
// MC_TameApe ( ) ;
58121: CALL 72410 0 0
// if event = 122 then
58125: LD_VAR 0 1
58129: PUSH
58130: LD_INT 122
58132: EQUAL
58133: IFFALSE 58139
// MC_ChangeApeClass ( ) ;
58135: CALL 73239 0 0
// if event = 123 then
58139: LD_VAR 0 1
58143: PUSH
58144: LD_INT 123
58146: EQUAL
58147: IFFALSE 58153
// MC_Bazooka ( ) ;
58149: CALL 73889 0 0
// if event = 124 then
58153: LD_VAR 0 1
58157: PUSH
58158: LD_INT 124
58160: EQUAL
58161: IFFALSE 58167
// MC_TeleportExit ( ) ;
58163: CALL 74087 0 0
// if event = 125 then
58167: LD_VAR 0 1
58171: PUSH
58172: LD_INT 125
58174: EQUAL
58175: IFFALSE 58181
// MC_Deposits ( ) ;
58177: CALL 74734 0 0
// if event = 126 then
58181: LD_VAR 0 1
58185: PUSH
58186: LD_INT 126
58188: EQUAL
58189: IFFALSE 58195
// MC_RemoteDriver ( ) ;
58191: CALL 75359 0 0
// if event = 200 then
58195: LD_VAR 0 1
58199: PUSH
58200: LD_INT 200
58202: EQUAL
58203: IFFALSE 58209
// MC_Idle ( ) ;
58205: CALL 77092 0 0
// end ;
58209: PPOPN 1
58211: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58212: LD_INT 0
58214: PPUSH
58215: PPUSH
// if not mc_bases [ base ] or not tag then
58216: LD_EXP 52
58220: PUSH
58221: LD_VAR 0 1
58225: ARRAY
58226: NOT
58227: PUSH
58228: LD_VAR 0 2
58232: NOT
58233: OR
58234: IFFALSE 58238
// exit ;
58236: GO 58302
// for i in mc_bases [ base ] union mc_ape [ base ] do
58238: LD_ADDR_VAR 0 4
58242: PUSH
58243: LD_EXP 52
58247: PUSH
58248: LD_VAR 0 1
58252: ARRAY
58253: PUSH
58254: LD_EXP 81
58258: PUSH
58259: LD_VAR 0 1
58263: ARRAY
58264: UNION
58265: PUSH
58266: FOR_IN
58267: IFFALSE 58300
// if GetTag ( i ) = tag then
58269: LD_VAR 0 4
58273: PPUSH
58274: CALL_OW 110
58278: PUSH
58279: LD_VAR 0 2
58283: EQUAL
58284: IFFALSE 58298
// SetTag ( i , 0 ) ;
58286: LD_VAR 0 4
58290: PPUSH
58291: LD_INT 0
58293: PPUSH
58294: CALL_OW 109
58298: GO 58266
58300: POP
58301: POP
// end ;
58302: LD_VAR 0 3
58306: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58307: LD_INT 0
58309: PPUSH
58310: PPUSH
58311: PPUSH
58312: PPUSH
58313: PPUSH
58314: PPUSH
58315: PPUSH
58316: PPUSH
// if not mc_bases then
58317: LD_EXP 52
58321: NOT
58322: IFFALSE 58326
// exit ;
58324: GO 58784
// for i = 1 to mc_bases do
58326: LD_ADDR_VAR 0 2
58330: PUSH
58331: DOUBLE
58332: LD_INT 1
58334: DEC
58335: ST_TO_ADDR
58336: LD_EXP 52
58340: PUSH
58341: FOR_TO
58342: IFFALSE 58782
// begin tmp := MC_ClassCheckReq ( i ) ;
58344: LD_ADDR_VAR 0 4
58348: PUSH
58349: LD_VAR 0 2
58353: PPUSH
58354: CALL 58789 0 1
58358: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58359: LD_ADDR_EXP 93
58363: PUSH
58364: LD_EXP 93
58368: PPUSH
58369: LD_VAR 0 2
58373: PPUSH
58374: LD_VAR 0 4
58378: PPUSH
58379: CALL_OW 1
58383: ST_TO_ADDR
// if not tmp then
58384: LD_VAR 0 4
58388: NOT
58389: IFFALSE 58393
// continue ;
58391: GO 58341
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58393: LD_ADDR_VAR 0 6
58397: PUSH
58398: LD_EXP 52
58402: PUSH
58403: LD_VAR 0 2
58407: ARRAY
58408: PPUSH
58409: LD_INT 2
58411: PUSH
58412: LD_INT 30
58414: PUSH
58415: LD_INT 4
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: PUSH
58422: LD_INT 30
58424: PUSH
58425: LD_INT 5
58427: PUSH
58428: EMPTY
58429: LIST
58430: LIST
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: PPUSH
58437: CALL_OW 72
58441: PUSH
58442: LD_EXP 52
58446: PUSH
58447: LD_VAR 0 2
58451: ARRAY
58452: PPUSH
58453: LD_INT 2
58455: PUSH
58456: LD_INT 30
58458: PUSH
58459: LD_INT 0
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: PUSH
58466: LD_INT 30
58468: PUSH
58469: LD_INT 1
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: LIST
58480: PPUSH
58481: CALL_OW 72
58485: PUSH
58486: LD_EXP 52
58490: PUSH
58491: LD_VAR 0 2
58495: ARRAY
58496: PPUSH
58497: LD_INT 30
58499: PUSH
58500: LD_INT 3
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: PPUSH
58507: CALL_OW 72
58511: PUSH
58512: LD_EXP 52
58516: PUSH
58517: LD_VAR 0 2
58521: ARRAY
58522: PPUSH
58523: LD_INT 2
58525: PUSH
58526: LD_INT 30
58528: PUSH
58529: LD_INT 6
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PUSH
58536: LD_INT 30
58538: PUSH
58539: LD_INT 7
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: PUSH
58546: LD_INT 30
58548: PUSH
58549: LD_INT 8
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: LIST
58560: LIST
58561: PPUSH
58562: CALL_OW 72
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: LIST
58571: LIST
58572: ST_TO_ADDR
// for j = 1 to 4 do
58573: LD_ADDR_VAR 0 3
58577: PUSH
58578: DOUBLE
58579: LD_INT 1
58581: DEC
58582: ST_TO_ADDR
58583: LD_INT 4
58585: PUSH
58586: FOR_TO
58587: IFFALSE 58778
// begin if not tmp [ j ] then
58589: LD_VAR 0 4
58593: PUSH
58594: LD_VAR 0 3
58598: ARRAY
58599: NOT
58600: IFFALSE 58604
// continue ;
58602: GO 58586
// for p in tmp [ j ] do
58604: LD_ADDR_VAR 0 5
58608: PUSH
58609: LD_VAR 0 4
58613: PUSH
58614: LD_VAR 0 3
58618: ARRAY
58619: PUSH
58620: FOR_IN
58621: IFFALSE 58774
// begin if not b [ j ] then
58623: LD_VAR 0 6
58627: PUSH
58628: LD_VAR 0 3
58632: ARRAY
58633: NOT
58634: IFFALSE 58638
// break ;
58636: GO 58774
// e := 0 ;
58638: LD_ADDR_VAR 0 7
58642: PUSH
58643: LD_INT 0
58645: ST_TO_ADDR
// for k in b [ j ] do
58646: LD_ADDR_VAR 0 8
58650: PUSH
58651: LD_VAR 0 6
58655: PUSH
58656: LD_VAR 0 3
58660: ARRAY
58661: PUSH
58662: FOR_IN
58663: IFFALSE 58690
// if IsNotFull ( k ) then
58665: LD_VAR 0 8
58669: PPUSH
58670: CALL 15431 0 1
58674: IFFALSE 58688
// begin e := k ;
58676: LD_ADDR_VAR 0 7
58680: PUSH
58681: LD_VAR 0 8
58685: ST_TO_ADDR
// break ;
58686: GO 58690
// end ;
58688: GO 58662
58690: POP
58691: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58692: LD_VAR 0 7
58696: PUSH
58697: LD_VAR 0 5
58701: PPUSH
58702: LD_VAR 0 7
58706: PPUSH
58707: CALL 52550 0 2
58711: NOT
58712: AND
58713: IFFALSE 58772
// begin if IsInUnit ( p ) then
58715: LD_VAR 0 5
58719: PPUSH
58720: CALL_OW 310
58724: IFFALSE 58735
// ComExitBuilding ( p ) ;
58726: LD_VAR 0 5
58730: PPUSH
58731: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58735: LD_VAR 0 5
58739: PPUSH
58740: LD_VAR 0 7
58744: PPUSH
58745: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58749: LD_VAR 0 5
58753: PPUSH
58754: LD_VAR 0 3
58758: PPUSH
58759: CALL_OW 183
// AddComExitBuilding ( p ) ;
58763: LD_VAR 0 5
58767: PPUSH
58768: CALL_OW 182
// end ; end ;
58772: GO 58620
58774: POP
58775: POP
// end ;
58776: GO 58586
58778: POP
58779: POP
// end ;
58780: GO 58341
58782: POP
58783: POP
// end ;
58784: LD_VAR 0 1
58788: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58789: LD_INT 0
58791: PPUSH
58792: PPUSH
58793: PPUSH
58794: PPUSH
58795: PPUSH
58796: PPUSH
58797: PPUSH
58798: PPUSH
58799: PPUSH
58800: PPUSH
58801: PPUSH
58802: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58803: LD_VAR 0 1
58807: NOT
58808: PUSH
58809: LD_EXP 52
58813: PUSH
58814: LD_VAR 0 1
58818: ARRAY
58819: NOT
58820: OR
58821: PUSH
58822: LD_EXP 52
58826: PUSH
58827: LD_VAR 0 1
58831: ARRAY
58832: PPUSH
58833: LD_INT 2
58835: PUSH
58836: LD_INT 30
58838: PUSH
58839: LD_INT 0
58841: PUSH
58842: EMPTY
58843: LIST
58844: LIST
58845: PUSH
58846: LD_INT 30
58848: PUSH
58849: LD_INT 1
58851: PUSH
58852: EMPTY
58853: LIST
58854: LIST
58855: PUSH
58856: EMPTY
58857: LIST
58858: LIST
58859: LIST
58860: PPUSH
58861: CALL_OW 72
58865: NOT
58866: OR
58867: IFFALSE 58871
// exit ;
58869: GO 62374
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58871: LD_ADDR_VAR 0 4
58875: PUSH
58876: LD_EXP 52
58880: PUSH
58881: LD_VAR 0 1
58885: ARRAY
58886: PPUSH
58887: LD_INT 2
58889: PUSH
58890: LD_INT 25
58892: PUSH
58893: LD_INT 1
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: PUSH
58900: LD_INT 25
58902: PUSH
58903: LD_INT 2
58905: PUSH
58906: EMPTY
58907: LIST
58908: LIST
58909: PUSH
58910: LD_INT 25
58912: PUSH
58913: LD_INT 3
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: PUSH
58920: LD_INT 25
58922: PUSH
58923: LD_INT 4
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: PUSH
58930: LD_INT 25
58932: PUSH
58933: LD_INT 5
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: PUSH
58940: LD_INT 25
58942: PUSH
58943: LD_INT 8
58945: PUSH
58946: EMPTY
58947: LIST
58948: LIST
58949: PUSH
58950: LD_INT 25
58952: PUSH
58953: LD_INT 9
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: LIST
58964: LIST
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: PPUSH
58970: CALL_OW 72
58974: ST_TO_ADDR
// if not tmp then
58975: LD_VAR 0 4
58979: NOT
58980: IFFALSE 58984
// exit ;
58982: GO 62374
// for i in tmp do
58984: LD_ADDR_VAR 0 3
58988: PUSH
58989: LD_VAR 0 4
58993: PUSH
58994: FOR_IN
58995: IFFALSE 59026
// if GetTag ( i ) then
58997: LD_VAR 0 3
59001: PPUSH
59002: CALL_OW 110
59006: IFFALSE 59024
// tmp := tmp diff i ;
59008: LD_ADDR_VAR 0 4
59012: PUSH
59013: LD_VAR 0 4
59017: PUSH
59018: LD_VAR 0 3
59022: DIFF
59023: ST_TO_ADDR
59024: GO 58994
59026: POP
59027: POP
// if not tmp then
59028: LD_VAR 0 4
59032: NOT
59033: IFFALSE 59037
// exit ;
59035: GO 62374
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59037: LD_ADDR_VAR 0 5
59041: PUSH
59042: LD_EXP 52
59046: PUSH
59047: LD_VAR 0 1
59051: ARRAY
59052: PPUSH
59053: LD_INT 2
59055: PUSH
59056: LD_INT 25
59058: PUSH
59059: LD_INT 1
59061: PUSH
59062: EMPTY
59063: LIST
59064: LIST
59065: PUSH
59066: LD_INT 25
59068: PUSH
59069: LD_INT 5
59071: PUSH
59072: EMPTY
59073: LIST
59074: LIST
59075: PUSH
59076: LD_INT 25
59078: PUSH
59079: LD_INT 8
59081: PUSH
59082: EMPTY
59083: LIST
59084: LIST
59085: PUSH
59086: LD_INT 25
59088: PUSH
59089: LD_INT 9
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: LIST
59100: LIST
59101: LIST
59102: PPUSH
59103: CALL_OW 72
59107: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59108: LD_ADDR_VAR 0 6
59112: PUSH
59113: LD_EXP 52
59117: PUSH
59118: LD_VAR 0 1
59122: ARRAY
59123: PPUSH
59124: LD_INT 25
59126: PUSH
59127: LD_INT 2
59129: PUSH
59130: EMPTY
59131: LIST
59132: LIST
59133: PPUSH
59134: CALL_OW 72
59138: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59139: LD_ADDR_VAR 0 7
59143: PUSH
59144: LD_EXP 52
59148: PUSH
59149: LD_VAR 0 1
59153: ARRAY
59154: PPUSH
59155: LD_INT 25
59157: PUSH
59158: LD_INT 3
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: PPUSH
59165: CALL_OW 72
59169: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59170: LD_ADDR_VAR 0 8
59174: PUSH
59175: LD_EXP 52
59179: PUSH
59180: LD_VAR 0 1
59184: ARRAY
59185: PPUSH
59186: LD_INT 25
59188: PUSH
59189: LD_INT 4
59191: PUSH
59192: EMPTY
59193: LIST
59194: LIST
59195: PUSH
59196: LD_INT 24
59198: PUSH
59199: LD_INT 251
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PPUSH
59210: CALL_OW 72
59214: ST_TO_ADDR
// if mc_scan [ base ] then
59215: LD_EXP 75
59219: PUSH
59220: LD_VAR 0 1
59224: ARRAY
59225: IFFALSE 59686
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59227: LD_ADDR_EXP 94
59231: PUSH
59232: LD_EXP 94
59236: PPUSH
59237: LD_VAR 0 1
59241: PPUSH
59242: LD_INT 4
59244: PPUSH
59245: CALL_OW 1
59249: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59250: LD_ADDR_VAR 0 12
59254: PUSH
59255: LD_EXP 52
59259: PUSH
59260: LD_VAR 0 1
59264: ARRAY
59265: PPUSH
59266: LD_INT 2
59268: PUSH
59269: LD_INT 30
59271: PUSH
59272: LD_INT 4
59274: PUSH
59275: EMPTY
59276: LIST
59277: LIST
59278: PUSH
59279: LD_INT 30
59281: PUSH
59282: LD_INT 5
59284: PUSH
59285: EMPTY
59286: LIST
59287: LIST
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: LIST
59293: PPUSH
59294: CALL_OW 72
59298: ST_TO_ADDR
// if not b then
59299: LD_VAR 0 12
59303: NOT
59304: IFFALSE 59308
// exit ;
59306: GO 62374
// p := [ ] ;
59308: LD_ADDR_VAR 0 11
59312: PUSH
59313: EMPTY
59314: ST_TO_ADDR
// if sci >= 2 then
59315: LD_VAR 0 8
59319: PUSH
59320: LD_INT 2
59322: GREATEREQUAL
59323: IFFALSE 59354
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59325: LD_ADDR_VAR 0 8
59329: PUSH
59330: LD_VAR 0 8
59334: PUSH
59335: LD_INT 1
59337: ARRAY
59338: PUSH
59339: LD_VAR 0 8
59343: PUSH
59344: LD_INT 2
59346: ARRAY
59347: PUSH
59348: EMPTY
59349: LIST
59350: LIST
59351: ST_TO_ADDR
59352: GO 59415
// if sci = 1 then
59354: LD_VAR 0 8
59358: PUSH
59359: LD_INT 1
59361: EQUAL
59362: IFFALSE 59383
// sci := [ sci [ 1 ] ] else
59364: LD_ADDR_VAR 0 8
59368: PUSH
59369: LD_VAR 0 8
59373: PUSH
59374: LD_INT 1
59376: ARRAY
59377: PUSH
59378: EMPTY
59379: LIST
59380: ST_TO_ADDR
59381: GO 59415
// if sci = 0 then
59383: LD_VAR 0 8
59387: PUSH
59388: LD_INT 0
59390: EQUAL
59391: IFFALSE 59415
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59393: LD_ADDR_VAR 0 11
59397: PUSH
59398: LD_VAR 0 4
59402: PPUSH
59403: LD_INT 4
59405: PPUSH
59406: CALL 52413 0 2
59410: PUSH
59411: LD_INT 1
59413: ARRAY
59414: ST_TO_ADDR
// if eng > 4 then
59415: LD_VAR 0 6
59419: PUSH
59420: LD_INT 4
59422: GREATER
59423: IFFALSE 59469
// for i = eng downto 4 do
59425: LD_ADDR_VAR 0 3
59429: PUSH
59430: DOUBLE
59431: LD_VAR 0 6
59435: INC
59436: ST_TO_ADDR
59437: LD_INT 4
59439: PUSH
59440: FOR_DOWNTO
59441: IFFALSE 59467
// eng := eng diff eng [ i ] ;
59443: LD_ADDR_VAR 0 6
59447: PUSH
59448: LD_VAR 0 6
59452: PUSH
59453: LD_VAR 0 6
59457: PUSH
59458: LD_VAR 0 3
59462: ARRAY
59463: DIFF
59464: ST_TO_ADDR
59465: GO 59440
59467: POP
59468: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59469: LD_ADDR_VAR 0 4
59473: PUSH
59474: LD_VAR 0 4
59478: PUSH
59479: LD_VAR 0 5
59483: PUSH
59484: LD_VAR 0 6
59488: UNION
59489: PUSH
59490: LD_VAR 0 7
59494: UNION
59495: PUSH
59496: LD_VAR 0 8
59500: UNION
59501: DIFF
59502: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59503: LD_ADDR_VAR 0 13
59507: PUSH
59508: LD_EXP 52
59512: PUSH
59513: LD_VAR 0 1
59517: ARRAY
59518: PPUSH
59519: LD_INT 2
59521: PUSH
59522: LD_INT 30
59524: PUSH
59525: LD_INT 32
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: PUSH
59532: LD_INT 30
59534: PUSH
59535: LD_INT 31
59537: PUSH
59538: EMPTY
59539: LIST
59540: LIST
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: LIST
59546: PPUSH
59547: CALL_OW 72
59551: PUSH
59552: LD_EXP 52
59556: PUSH
59557: LD_VAR 0 1
59561: ARRAY
59562: PPUSH
59563: LD_INT 2
59565: PUSH
59566: LD_INT 30
59568: PUSH
59569: LD_INT 4
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: LD_INT 30
59578: PUSH
59579: LD_INT 5
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: LIST
59590: PPUSH
59591: CALL_OW 72
59595: PUSH
59596: LD_INT 6
59598: MUL
59599: PLUS
59600: ST_TO_ADDR
// if bcount < tmp then
59601: LD_VAR 0 13
59605: PUSH
59606: LD_VAR 0 4
59610: LESS
59611: IFFALSE 59657
// for i = tmp downto bcount do
59613: LD_ADDR_VAR 0 3
59617: PUSH
59618: DOUBLE
59619: LD_VAR 0 4
59623: INC
59624: ST_TO_ADDR
59625: LD_VAR 0 13
59629: PUSH
59630: FOR_DOWNTO
59631: IFFALSE 59655
// tmp := Delete ( tmp , tmp ) ;
59633: LD_ADDR_VAR 0 4
59637: PUSH
59638: LD_VAR 0 4
59642: PPUSH
59643: LD_VAR 0 4
59647: PPUSH
59648: CALL_OW 3
59652: ST_TO_ADDR
59653: GO 59630
59655: POP
59656: POP
// result := [ tmp , 0 , 0 , p ] ;
59657: LD_ADDR_VAR 0 2
59661: PUSH
59662: LD_VAR 0 4
59666: PUSH
59667: LD_INT 0
59669: PUSH
59670: LD_INT 0
59672: PUSH
59673: LD_VAR 0 11
59677: PUSH
59678: EMPTY
59679: LIST
59680: LIST
59681: LIST
59682: LIST
59683: ST_TO_ADDR
// exit ;
59684: GO 62374
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59686: LD_EXP 52
59690: PUSH
59691: LD_VAR 0 1
59695: ARRAY
59696: PPUSH
59697: LD_INT 2
59699: PUSH
59700: LD_INT 30
59702: PUSH
59703: LD_INT 6
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: LD_INT 30
59712: PUSH
59713: LD_INT 7
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PUSH
59720: LD_INT 30
59722: PUSH
59723: LD_INT 8
59725: PUSH
59726: EMPTY
59727: LIST
59728: LIST
59729: PUSH
59730: EMPTY
59731: LIST
59732: LIST
59733: LIST
59734: LIST
59735: PPUSH
59736: CALL_OW 72
59740: NOT
59741: PUSH
59742: LD_EXP 52
59746: PUSH
59747: LD_VAR 0 1
59751: ARRAY
59752: PPUSH
59753: LD_INT 30
59755: PUSH
59756: LD_INT 3
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PPUSH
59763: CALL_OW 72
59767: NOT
59768: AND
59769: IFFALSE 59841
// begin if eng = tmp then
59771: LD_VAR 0 6
59775: PUSH
59776: LD_VAR 0 4
59780: EQUAL
59781: IFFALSE 59785
// exit ;
59783: GO 62374
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59785: LD_ADDR_EXP 94
59789: PUSH
59790: LD_EXP 94
59794: PPUSH
59795: LD_VAR 0 1
59799: PPUSH
59800: LD_INT 1
59802: PPUSH
59803: CALL_OW 1
59807: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59808: LD_ADDR_VAR 0 2
59812: PUSH
59813: LD_INT 0
59815: PUSH
59816: LD_VAR 0 4
59820: PUSH
59821: LD_VAR 0 6
59825: DIFF
59826: PUSH
59827: LD_INT 0
59829: PUSH
59830: LD_INT 0
59832: PUSH
59833: EMPTY
59834: LIST
59835: LIST
59836: LIST
59837: LIST
59838: ST_TO_ADDR
// exit ;
59839: GO 62374
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59841: LD_EXP 79
59845: PUSH
59846: LD_EXP 78
59850: PUSH
59851: LD_VAR 0 1
59855: ARRAY
59856: ARRAY
59857: PUSH
59858: LD_EXP 52
59862: PUSH
59863: LD_VAR 0 1
59867: ARRAY
59868: PPUSH
59869: LD_INT 2
59871: PUSH
59872: LD_INT 30
59874: PUSH
59875: LD_INT 6
59877: PUSH
59878: EMPTY
59879: LIST
59880: LIST
59881: PUSH
59882: LD_INT 30
59884: PUSH
59885: LD_INT 7
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: PUSH
59892: LD_INT 30
59894: PUSH
59895: LD_INT 8
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: PUSH
59902: EMPTY
59903: LIST
59904: LIST
59905: LIST
59906: LIST
59907: PPUSH
59908: CALL_OW 72
59912: AND
59913: PUSH
59914: LD_EXP 52
59918: PUSH
59919: LD_VAR 0 1
59923: ARRAY
59924: PPUSH
59925: LD_INT 30
59927: PUSH
59928: LD_INT 3
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PPUSH
59935: CALL_OW 72
59939: NOT
59940: AND
59941: IFFALSE 60155
// begin if sci >= 6 then
59943: LD_VAR 0 8
59947: PUSH
59948: LD_INT 6
59950: GREATEREQUAL
59951: IFFALSE 59955
// exit ;
59953: GO 62374
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59955: LD_ADDR_EXP 94
59959: PUSH
59960: LD_EXP 94
59964: PPUSH
59965: LD_VAR 0 1
59969: PPUSH
59970: LD_INT 2
59972: PPUSH
59973: CALL_OW 1
59977: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59978: LD_ADDR_VAR 0 9
59982: PUSH
59983: LD_VAR 0 4
59987: PUSH
59988: LD_VAR 0 8
59992: DIFF
59993: PPUSH
59994: LD_INT 4
59996: PPUSH
59997: CALL 52413 0 2
60001: ST_TO_ADDR
// p := [ ] ;
60002: LD_ADDR_VAR 0 11
60006: PUSH
60007: EMPTY
60008: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60009: LD_VAR 0 8
60013: PUSH
60014: LD_INT 6
60016: LESS
60017: PUSH
60018: LD_VAR 0 9
60022: PUSH
60023: LD_INT 6
60025: GREATER
60026: AND
60027: IFFALSE 60108
// begin for i = 1 to 6 - sci do
60029: LD_ADDR_VAR 0 3
60033: PUSH
60034: DOUBLE
60035: LD_INT 1
60037: DEC
60038: ST_TO_ADDR
60039: LD_INT 6
60041: PUSH
60042: LD_VAR 0 8
60046: MINUS
60047: PUSH
60048: FOR_TO
60049: IFFALSE 60104
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60051: LD_ADDR_VAR 0 11
60055: PUSH
60056: LD_VAR 0 11
60060: PPUSH
60061: LD_VAR 0 11
60065: PUSH
60066: LD_INT 1
60068: PLUS
60069: PPUSH
60070: LD_VAR 0 9
60074: PUSH
60075: LD_INT 1
60077: ARRAY
60078: PPUSH
60079: CALL_OW 2
60083: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60084: LD_ADDR_VAR 0 9
60088: PUSH
60089: LD_VAR 0 9
60093: PPUSH
60094: LD_INT 1
60096: PPUSH
60097: CALL_OW 3
60101: ST_TO_ADDR
// end ;
60102: GO 60048
60104: POP
60105: POP
// end else
60106: GO 60128
// if sort then
60108: LD_VAR 0 9
60112: IFFALSE 60128
// p := sort [ 1 ] ;
60114: LD_ADDR_VAR 0 11
60118: PUSH
60119: LD_VAR 0 9
60123: PUSH
60124: LD_INT 1
60126: ARRAY
60127: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60128: LD_ADDR_VAR 0 2
60132: PUSH
60133: LD_INT 0
60135: PUSH
60136: LD_INT 0
60138: PUSH
60139: LD_INT 0
60141: PUSH
60142: LD_VAR 0 11
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: LIST
60151: LIST
60152: ST_TO_ADDR
// exit ;
60153: GO 62374
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60155: LD_EXP 79
60159: PUSH
60160: LD_EXP 78
60164: PUSH
60165: LD_VAR 0 1
60169: ARRAY
60170: ARRAY
60171: PUSH
60172: LD_EXP 52
60176: PUSH
60177: LD_VAR 0 1
60181: ARRAY
60182: PPUSH
60183: LD_INT 2
60185: PUSH
60186: LD_INT 30
60188: PUSH
60189: LD_INT 6
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: LD_INT 30
60198: PUSH
60199: LD_INT 7
60201: PUSH
60202: EMPTY
60203: LIST
60204: LIST
60205: PUSH
60206: LD_INT 30
60208: PUSH
60209: LD_INT 8
60211: PUSH
60212: EMPTY
60213: LIST
60214: LIST
60215: PUSH
60216: EMPTY
60217: LIST
60218: LIST
60219: LIST
60220: LIST
60221: PPUSH
60222: CALL_OW 72
60226: AND
60227: PUSH
60228: LD_EXP 52
60232: PUSH
60233: LD_VAR 0 1
60237: ARRAY
60238: PPUSH
60239: LD_INT 30
60241: PUSH
60242: LD_INT 3
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: PPUSH
60249: CALL_OW 72
60253: AND
60254: IFFALSE 60988
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60256: LD_ADDR_EXP 94
60260: PUSH
60261: LD_EXP 94
60265: PPUSH
60266: LD_VAR 0 1
60270: PPUSH
60271: LD_INT 3
60273: PPUSH
60274: CALL_OW 1
60278: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60279: LD_ADDR_VAR 0 2
60283: PUSH
60284: LD_INT 0
60286: PUSH
60287: LD_INT 0
60289: PUSH
60290: LD_INT 0
60292: PUSH
60293: LD_INT 0
60295: PUSH
60296: EMPTY
60297: LIST
60298: LIST
60299: LIST
60300: LIST
60301: ST_TO_ADDR
// if not eng then
60302: LD_VAR 0 6
60306: NOT
60307: IFFALSE 60370
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60309: LD_ADDR_VAR 0 11
60313: PUSH
60314: LD_VAR 0 4
60318: PPUSH
60319: LD_INT 2
60321: PPUSH
60322: CALL 52413 0 2
60326: PUSH
60327: LD_INT 1
60329: ARRAY
60330: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60331: LD_ADDR_VAR 0 2
60335: PUSH
60336: LD_VAR 0 2
60340: PPUSH
60341: LD_INT 2
60343: PPUSH
60344: LD_VAR 0 11
60348: PPUSH
60349: CALL_OW 1
60353: ST_TO_ADDR
// tmp := tmp diff p ;
60354: LD_ADDR_VAR 0 4
60358: PUSH
60359: LD_VAR 0 4
60363: PUSH
60364: LD_VAR 0 11
60368: DIFF
60369: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60370: LD_VAR 0 4
60374: PUSH
60375: LD_VAR 0 8
60379: PUSH
60380: LD_INT 6
60382: LESS
60383: AND
60384: IFFALSE 60572
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60386: LD_ADDR_VAR 0 9
60390: PUSH
60391: LD_VAR 0 4
60395: PUSH
60396: LD_VAR 0 8
60400: PUSH
60401: LD_VAR 0 7
60405: UNION
60406: DIFF
60407: PPUSH
60408: LD_INT 4
60410: PPUSH
60411: CALL 52413 0 2
60415: ST_TO_ADDR
// p := [ ] ;
60416: LD_ADDR_VAR 0 11
60420: PUSH
60421: EMPTY
60422: ST_TO_ADDR
// if sort then
60423: LD_VAR 0 9
60427: IFFALSE 60543
// for i = 1 to 6 - sci do
60429: LD_ADDR_VAR 0 3
60433: PUSH
60434: DOUBLE
60435: LD_INT 1
60437: DEC
60438: ST_TO_ADDR
60439: LD_INT 6
60441: PUSH
60442: LD_VAR 0 8
60446: MINUS
60447: PUSH
60448: FOR_TO
60449: IFFALSE 60541
// begin if i = sort then
60451: LD_VAR 0 3
60455: PUSH
60456: LD_VAR 0 9
60460: EQUAL
60461: IFFALSE 60465
// break ;
60463: GO 60541
// if GetClass ( i ) = 4 then
60465: LD_VAR 0 3
60469: PPUSH
60470: CALL_OW 257
60474: PUSH
60475: LD_INT 4
60477: EQUAL
60478: IFFALSE 60482
// continue ;
60480: GO 60448
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60482: LD_ADDR_VAR 0 11
60486: PUSH
60487: LD_VAR 0 11
60491: PPUSH
60492: LD_VAR 0 11
60496: PUSH
60497: LD_INT 1
60499: PLUS
60500: PPUSH
60501: LD_VAR 0 9
60505: PUSH
60506: LD_VAR 0 3
60510: ARRAY
60511: PPUSH
60512: CALL_OW 2
60516: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60517: LD_ADDR_VAR 0 4
60521: PUSH
60522: LD_VAR 0 4
60526: PUSH
60527: LD_VAR 0 9
60531: PUSH
60532: LD_VAR 0 3
60536: ARRAY
60537: DIFF
60538: ST_TO_ADDR
// end ;
60539: GO 60448
60541: POP
60542: POP
// if p then
60543: LD_VAR 0 11
60547: IFFALSE 60572
// result := Replace ( result , 4 , p ) ;
60549: LD_ADDR_VAR 0 2
60553: PUSH
60554: LD_VAR 0 2
60558: PPUSH
60559: LD_INT 4
60561: PPUSH
60562: LD_VAR 0 11
60566: PPUSH
60567: CALL_OW 1
60571: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60572: LD_VAR 0 4
60576: PUSH
60577: LD_VAR 0 7
60581: PUSH
60582: LD_INT 6
60584: LESS
60585: AND
60586: IFFALSE 60774
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60588: LD_ADDR_VAR 0 9
60592: PUSH
60593: LD_VAR 0 4
60597: PUSH
60598: LD_VAR 0 8
60602: PUSH
60603: LD_VAR 0 7
60607: UNION
60608: DIFF
60609: PPUSH
60610: LD_INT 3
60612: PPUSH
60613: CALL 52413 0 2
60617: ST_TO_ADDR
// p := [ ] ;
60618: LD_ADDR_VAR 0 11
60622: PUSH
60623: EMPTY
60624: ST_TO_ADDR
// if sort then
60625: LD_VAR 0 9
60629: IFFALSE 60745
// for i = 1 to 6 - mech do
60631: LD_ADDR_VAR 0 3
60635: PUSH
60636: DOUBLE
60637: LD_INT 1
60639: DEC
60640: ST_TO_ADDR
60641: LD_INT 6
60643: PUSH
60644: LD_VAR 0 7
60648: MINUS
60649: PUSH
60650: FOR_TO
60651: IFFALSE 60743
// begin if i = sort then
60653: LD_VAR 0 3
60657: PUSH
60658: LD_VAR 0 9
60662: EQUAL
60663: IFFALSE 60667
// break ;
60665: GO 60743
// if GetClass ( i ) = 3 then
60667: LD_VAR 0 3
60671: PPUSH
60672: CALL_OW 257
60676: PUSH
60677: LD_INT 3
60679: EQUAL
60680: IFFALSE 60684
// continue ;
60682: GO 60650
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60684: LD_ADDR_VAR 0 11
60688: PUSH
60689: LD_VAR 0 11
60693: PPUSH
60694: LD_VAR 0 11
60698: PUSH
60699: LD_INT 1
60701: PLUS
60702: PPUSH
60703: LD_VAR 0 9
60707: PUSH
60708: LD_VAR 0 3
60712: ARRAY
60713: PPUSH
60714: CALL_OW 2
60718: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60719: LD_ADDR_VAR 0 4
60723: PUSH
60724: LD_VAR 0 4
60728: PUSH
60729: LD_VAR 0 9
60733: PUSH
60734: LD_VAR 0 3
60738: ARRAY
60739: DIFF
60740: ST_TO_ADDR
// end ;
60741: GO 60650
60743: POP
60744: POP
// if p then
60745: LD_VAR 0 11
60749: IFFALSE 60774
// result := Replace ( result , 3 , p ) ;
60751: LD_ADDR_VAR 0 2
60755: PUSH
60756: LD_VAR 0 2
60760: PPUSH
60761: LD_INT 3
60763: PPUSH
60764: LD_VAR 0 11
60768: PPUSH
60769: CALL_OW 1
60773: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60774: LD_VAR 0 4
60778: PUSH
60779: LD_INT 6
60781: GREATER
60782: PUSH
60783: LD_VAR 0 6
60787: PUSH
60788: LD_INT 6
60790: LESS
60791: AND
60792: IFFALSE 60986
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60794: LD_ADDR_VAR 0 9
60798: PUSH
60799: LD_VAR 0 4
60803: PUSH
60804: LD_VAR 0 8
60808: PUSH
60809: LD_VAR 0 7
60813: UNION
60814: PUSH
60815: LD_VAR 0 6
60819: UNION
60820: DIFF
60821: PPUSH
60822: LD_INT 2
60824: PPUSH
60825: CALL 52413 0 2
60829: ST_TO_ADDR
// p := [ ] ;
60830: LD_ADDR_VAR 0 11
60834: PUSH
60835: EMPTY
60836: ST_TO_ADDR
// if sort then
60837: LD_VAR 0 9
60841: IFFALSE 60957
// for i = 1 to 6 - eng do
60843: LD_ADDR_VAR 0 3
60847: PUSH
60848: DOUBLE
60849: LD_INT 1
60851: DEC
60852: ST_TO_ADDR
60853: LD_INT 6
60855: PUSH
60856: LD_VAR 0 6
60860: MINUS
60861: PUSH
60862: FOR_TO
60863: IFFALSE 60955
// begin if i = sort then
60865: LD_VAR 0 3
60869: PUSH
60870: LD_VAR 0 9
60874: EQUAL
60875: IFFALSE 60879
// break ;
60877: GO 60955
// if GetClass ( i ) = 2 then
60879: LD_VAR 0 3
60883: PPUSH
60884: CALL_OW 257
60888: PUSH
60889: LD_INT 2
60891: EQUAL
60892: IFFALSE 60896
// continue ;
60894: GO 60862
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60896: LD_ADDR_VAR 0 11
60900: PUSH
60901: LD_VAR 0 11
60905: PPUSH
60906: LD_VAR 0 11
60910: PUSH
60911: LD_INT 1
60913: PLUS
60914: PPUSH
60915: LD_VAR 0 9
60919: PUSH
60920: LD_VAR 0 3
60924: ARRAY
60925: PPUSH
60926: CALL_OW 2
60930: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60931: LD_ADDR_VAR 0 4
60935: PUSH
60936: LD_VAR 0 4
60940: PUSH
60941: LD_VAR 0 9
60945: PUSH
60946: LD_VAR 0 3
60950: ARRAY
60951: DIFF
60952: ST_TO_ADDR
// end ;
60953: GO 60862
60955: POP
60956: POP
// if p then
60957: LD_VAR 0 11
60961: IFFALSE 60986
// result := Replace ( result , 2 , p ) ;
60963: LD_ADDR_VAR 0 2
60967: PUSH
60968: LD_VAR 0 2
60972: PPUSH
60973: LD_INT 2
60975: PPUSH
60976: LD_VAR 0 11
60980: PPUSH
60981: CALL_OW 1
60985: ST_TO_ADDR
// end ; exit ;
60986: GO 62374
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60988: LD_EXP 79
60992: PUSH
60993: LD_EXP 78
60997: PUSH
60998: LD_VAR 0 1
61002: ARRAY
61003: ARRAY
61004: NOT
61005: PUSH
61006: LD_EXP 52
61010: PUSH
61011: LD_VAR 0 1
61015: ARRAY
61016: PPUSH
61017: LD_INT 30
61019: PUSH
61020: LD_INT 3
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PPUSH
61027: CALL_OW 72
61031: AND
61032: PUSH
61033: LD_EXP 57
61037: PUSH
61038: LD_VAR 0 1
61042: ARRAY
61043: AND
61044: IFFALSE 61652
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61046: LD_ADDR_EXP 94
61050: PUSH
61051: LD_EXP 94
61055: PPUSH
61056: LD_VAR 0 1
61060: PPUSH
61061: LD_INT 5
61063: PPUSH
61064: CALL_OW 1
61068: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61069: LD_ADDR_VAR 0 2
61073: PUSH
61074: LD_INT 0
61076: PUSH
61077: LD_INT 0
61079: PUSH
61080: LD_INT 0
61082: PUSH
61083: LD_INT 0
61085: PUSH
61086: EMPTY
61087: LIST
61088: LIST
61089: LIST
61090: LIST
61091: ST_TO_ADDR
// if sci > 1 then
61092: LD_VAR 0 8
61096: PUSH
61097: LD_INT 1
61099: GREATER
61100: IFFALSE 61128
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61102: LD_ADDR_VAR 0 4
61106: PUSH
61107: LD_VAR 0 4
61111: PUSH
61112: LD_VAR 0 8
61116: PUSH
61117: LD_VAR 0 8
61121: PUSH
61122: LD_INT 1
61124: ARRAY
61125: DIFF
61126: DIFF
61127: ST_TO_ADDR
// if tmp and not sci then
61128: LD_VAR 0 4
61132: PUSH
61133: LD_VAR 0 8
61137: NOT
61138: AND
61139: IFFALSE 61208
// begin sort := SortBySkill ( tmp , 4 ) ;
61141: LD_ADDR_VAR 0 9
61145: PUSH
61146: LD_VAR 0 4
61150: PPUSH
61151: LD_INT 4
61153: PPUSH
61154: CALL 52413 0 2
61158: ST_TO_ADDR
// if sort then
61159: LD_VAR 0 9
61163: IFFALSE 61179
// p := sort [ 1 ] ;
61165: LD_ADDR_VAR 0 11
61169: PUSH
61170: LD_VAR 0 9
61174: PUSH
61175: LD_INT 1
61177: ARRAY
61178: ST_TO_ADDR
// if p then
61179: LD_VAR 0 11
61183: IFFALSE 61208
// result := Replace ( result , 4 , p ) ;
61185: LD_ADDR_VAR 0 2
61189: PUSH
61190: LD_VAR 0 2
61194: PPUSH
61195: LD_INT 4
61197: PPUSH
61198: LD_VAR 0 11
61202: PPUSH
61203: CALL_OW 1
61207: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61208: LD_ADDR_VAR 0 4
61212: PUSH
61213: LD_VAR 0 4
61217: PUSH
61218: LD_VAR 0 7
61222: DIFF
61223: ST_TO_ADDR
// if tmp and mech < 6 then
61224: LD_VAR 0 4
61228: PUSH
61229: LD_VAR 0 7
61233: PUSH
61234: LD_INT 6
61236: LESS
61237: AND
61238: IFFALSE 61426
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61240: LD_ADDR_VAR 0 9
61244: PUSH
61245: LD_VAR 0 4
61249: PUSH
61250: LD_VAR 0 8
61254: PUSH
61255: LD_VAR 0 7
61259: UNION
61260: DIFF
61261: PPUSH
61262: LD_INT 3
61264: PPUSH
61265: CALL 52413 0 2
61269: ST_TO_ADDR
// p := [ ] ;
61270: LD_ADDR_VAR 0 11
61274: PUSH
61275: EMPTY
61276: ST_TO_ADDR
// if sort then
61277: LD_VAR 0 9
61281: IFFALSE 61397
// for i = 1 to 6 - mech do
61283: LD_ADDR_VAR 0 3
61287: PUSH
61288: DOUBLE
61289: LD_INT 1
61291: DEC
61292: ST_TO_ADDR
61293: LD_INT 6
61295: PUSH
61296: LD_VAR 0 7
61300: MINUS
61301: PUSH
61302: FOR_TO
61303: IFFALSE 61395
// begin if i = sort then
61305: LD_VAR 0 3
61309: PUSH
61310: LD_VAR 0 9
61314: EQUAL
61315: IFFALSE 61319
// break ;
61317: GO 61395
// if GetClass ( i ) = 3 then
61319: LD_VAR 0 3
61323: PPUSH
61324: CALL_OW 257
61328: PUSH
61329: LD_INT 3
61331: EQUAL
61332: IFFALSE 61336
// continue ;
61334: GO 61302
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61336: LD_ADDR_VAR 0 11
61340: PUSH
61341: LD_VAR 0 11
61345: PPUSH
61346: LD_VAR 0 11
61350: PUSH
61351: LD_INT 1
61353: PLUS
61354: PPUSH
61355: LD_VAR 0 9
61359: PUSH
61360: LD_VAR 0 3
61364: ARRAY
61365: PPUSH
61366: CALL_OW 2
61370: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61371: LD_ADDR_VAR 0 4
61375: PUSH
61376: LD_VAR 0 4
61380: PUSH
61381: LD_VAR 0 9
61385: PUSH
61386: LD_VAR 0 3
61390: ARRAY
61391: DIFF
61392: ST_TO_ADDR
// end ;
61393: GO 61302
61395: POP
61396: POP
// if p then
61397: LD_VAR 0 11
61401: IFFALSE 61426
// result := Replace ( result , 3 , p ) ;
61403: LD_ADDR_VAR 0 2
61407: PUSH
61408: LD_VAR 0 2
61412: PPUSH
61413: LD_INT 3
61415: PPUSH
61416: LD_VAR 0 11
61420: PPUSH
61421: CALL_OW 1
61425: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61426: LD_ADDR_VAR 0 4
61430: PUSH
61431: LD_VAR 0 4
61435: PUSH
61436: LD_VAR 0 6
61440: DIFF
61441: ST_TO_ADDR
// if tmp and eng < 6 then
61442: LD_VAR 0 4
61446: PUSH
61447: LD_VAR 0 6
61451: PUSH
61452: LD_INT 6
61454: LESS
61455: AND
61456: IFFALSE 61650
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61458: LD_ADDR_VAR 0 9
61462: PUSH
61463: LD_VAR 0 4
61467: PUSH
61468: LD_VAR 0 8
61472: PUSH
61473: LD_VAR 0 7
61477: UNION
61478: PUSH
61479: LD_VAR 0 6
61483: UNION
61484: DIFF
61485: PPUSH
61486: LD_INT 2
61488: PPUSH
61489: CALL 52413 0 2
61493: ST_TO_ADDR
// p := [ ] ;
61494: LD_ADDR_VAR 0 11
61498: PUSH
61499: EMPTY
61500: ST_TO_ADDR
// if sort then
61501: LD_VAR 0 9
61505: IFFALSE 61621
// for i = 1 to 6 - eng do
61507: LD_ADDR_VAR 0 3
61511: PUSH
61512: DOUBLE
61513: LD_INT 1
61515: DEC
61516: ST_TO_ADDR
61517: LD_INT 6
61519: PUSH
61520: LD_VAR 0 6
61524: MINUS
61525: PUSH
61526: FOR_TO
61527: IFFALSE 61619
// begin if i = sort then
61529: LD_VAR 0 3
61533: PUSH
61534: LD_VAR 0 9
61538: EQUAL
61539: IFFALSE 61543
// break ;
61541: GO 61619
// if GetClass ( i ) = 2 then
61543: LD_VAR 0 3
61547: PPUSH
61548: CALL_OW 257
61552: PUSH
61553: LD_INT 2
61555: EQUAL
61556: IFFALSE 61560
// continue ;
61558: GO 61526
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61560: LD_ADDR_VAR 0 11
61564: PUSH
61565: LD_VAR 0 11
61569: PPUSH
61570: LD_VAR 0 11
61574: PUSH
61575: LD_INT 1
61577: PLUS
61578: PPUSH
61579: LD_VAR 0 9
61583: PUSH
61584: LD_VAR 0 3
61588: ARRAY
61589: PPUSH
61590: CALL_OW 2
61594: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61595: LD_ADDR_VAR 0 4
61599: PUSH
61600: LD_VAR 0 4
61604: PUSH
61605: LD_VAR 0 9
61609: PUSH
61610: LD_VAR 0 3
61614: ARRAY
61615: DIFF
61616: ST_TO_ADDR
// end ;
61617: GO 61526
61619: POP
61620: POP
// if p then
61621: LD_VAR 0 11
61625: IFFALSE 61650
// result := Replace ( result , 2 , p ) ;
61627: LD_ADDR_VAR 0 2
61631: PUSH
61632: LD_VAR 0 2
61636: PPUSH
61637: LD_INT 2
61639: PPUSH
61640: LD_VAR 0 11
61644: PPUSH
61645: CALL_OW 1
61649: ST_TO_ADDR
// end ; exit ;
61650: GO 62374
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61652: LD_EXP 79
61656: PUSH
61657: LD_EXP 78
61661: PUSH
61662: LD_VAR 0 1
61666: ARRAY
61667: ARRAY
61668: NOT
61669: PUSH
61670: LD_EXP 52
61674: PUSH
61675: LD_VAR 0 1
61679: ARRAY
61680: PPUSH
61681: LD_INT 30
61683: PUSH
61684: LD_INT 3
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PPUSH
61691: CALL_OW 72
61695: AND
61696: PUSH
61697: LD_EXP 57
61701: PUSH
61702: LD_VAR 0 1
61706: ARRAY
61707: NOT
61708: AND
61709: IFFALSE 62374
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61711: LD_ADDR_EXP 94
61715: PUSH
61716: LD_EXP 94
61720: PPUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: LD_INT 6
61728: PPUSH
61729: CALL_OW 1
61733: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61734: LD_ADDR_VAR 0 2
61738: PUSH
61739: LD_INT 0
61741: PUSH
61742: LD_INT 0
61744: PUSH
61745: LD_INT 0
61747: PUSH
61748: LD_INT 0
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: ST_TO_ADDR
// if sci >= 1 then
61757: LD_VAR 0 8
61761: PUSH
61762: LD_INT 1
61764: GREATEREQUAL
61765: IFFALSE 61787
// tmp := tmp diff sci [ 1 ] ;
61767: LD_ADDR_VAR 0 4
61771: PUSH
61772: LD_VAR 0 4
61776: PUSH
61777: LD_VAR 0 8
61781: PUSH
61782: LD_INT 1
61784: ARRAY
61785: DIFF
61786: ST_TO_ADDR
// if tmp and not sci then
61787: LD_VAR 0 4
61791: PUSH
61792: LD_VAR 0 8
61796: NOT
61797: AND
61798: IFFALSE 61867
// begin sort := SortBySkill ( tmp , 4 ) ;
61800: LD_ADDR_VAR 0 9
61804: PUSH
61805: LD_VAR 0 4
61809: PPUSH
61810: LD_INT 4
61812: PPUSH
61813: CALL 52413 0 2
61817: ST_TO_ADDR
// if sort then
61818: LD_VAR 0 9
61822: IFFALSE 61838
// p := sort [ 1 ] ;
61824: LD_ADDR_VAR 0 11
61828: PUSH
61829: LD_VAR 0 9
61833: PUSH
61834: LD_INT 1
61836: ARRAY
61837: ST_TO_ADDR
// if p then
61838: LD_VAR 0 11
61842: IFFALSE 61867
// result := Replace ( result , 4 , p ) ;
61844: LD_ADDR_VAR 0 2
61848: PUSH
61849: LD_VAR 0 2
61853: PPUSH
61854: LD_INT 4
61856: PPUSH
61857: LD_VAR 0 11
61861: PPUSH
61862: CALL_OW 1
61866: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61867: LD_ADDR_VAR 0 4
61871: PUSH
61872: LD_VAR 0 4
61876: PUSH
61877: LD_VAR 0 7
61881: DIFF
61882: ST_TO_ADDR
// if tmp and mech < 6 then
61883: LD_VAR 0 4
61887: PUSH
61888: LD_VAR 0 7
61892: PUSH
61893: LD_INT 6
61895: LESS
61896: AND
61897: IFFALSE 62079
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61899: LD_ADDR_VAR 0 9
61903: PUSH
61904: LD_VAR 0 4
61908: PUSH
61909: LD_VAR 0 7
61913: DIFF
61914: PPUSH
61915: LD_INT 3
61917: PPUSH
61918: CALL 52413 0 2
61922: ST_TO_ADDR
// p := [ ] ;
61923: LD_ADDR_VAR 0 11
61927: PUSH
61928: EMPTY
61929: ST_TO_ADDR
// if sort then
61930: LD_VAR 0 9
61934: IFFALSE 62050
// for i = 1 to 6 - mech do
61936: LD_ADDR_VAR 0 3
61940: PUSH
61941: DOUBLE
61942: LD_INT 1
61944: DEC
61945: ST_TO_ADDR
61946: LD_INT 6
61948: PUSH
61949: LD_VAR 0 7
61953: MINUS
61954: PUSH
61955: FOR_TO
61956: IFFALSE 62048
// begin if i = sort then
61958: LD_VAR 0 3
61962: PUSH
61963: LD_VAR 0 9
61967: EQUAL
61968: IFFALSE 61972
// break ;
61970: GO 62048
// if GetClass ( i ) = 3 then
61972: LD_VAR 0 3
61976: PPUSH
61977: CALL_OW 257
61981: PUSH
61982: LD_INT 3
61984: EQUAL
61985: IFFALSE 61989
// continue ;
61987: GO 61955
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61989: LD_ADDR_VAR 0 11
61993: PUSH
61994: LD_VAR 0 11
61998: PPUSH
61999: LD_VAR 0 11
62003: PUSH
62004: LD_INT 1
62006: PLUS
62007: PPUSH
62008: LD_VAR 0 9
62012: PUSH
62013: LD_VAR 0 3
62017: ARRAY
62018: PPUSH
62019: CALL_OW 2
62023: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62024: LD_ADDR_VAR 0 4
62028: PUSH
62029: LD_VAR 0 4
62033: PUSH
62034: LD_VAR 0 9
62038: PUSH
62039: LD_VAR 0 3
62043: ARRAY
62044: DIFF
62045: ST_TO_ADDR
// end ;
62046: GO 61955
62048: POP
62049: POP
// if p then
62050: LD_VAR 0 11
62054: IFFALSE 62079
// result := Replace ( result , 3 , p ) ;
62056: LD_ADDR_VAR 0 2
62060: PUSH
62061: LD_VAR 0 2
62065: PPUSH
62066: LD_INT 3
62068: PPUSH
62069: LD_VAR 0 11
62073: PPUSH
62074: CALL_OW 1
62078: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62079: LD_ADDR_VAR 0 4
62083: PUSH
62084: LD_VAR 0 4
62088: PUSH
62089: LD_VAR 0 6
62093: DIFF
62094: ST_TO_ADDR
// if tmp and eng < 4 then
62095: LD_VAR 0 4
62099: PUSH
62100: LD_VAR 0 6
62104: PUSH
62105: LD_INT 4
62107: LESS
62108: AND
62109: IFFALSE 62299
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62111: LD_ADDR_VAR 0 9
62115: PUSH
62116: LD_VAR 0 4
62120: PUSH
62121: LD_VAR 0 7
62125: PUSH
62126: LD_VAR 0 6
62130: UNION
62131: DIFF
62132: PPUSH
62133: LD_INT 2
62135: PPUSH
62136: CALL 52413 0 2
62140: ST_TO_ADDR
// p := [ ] ;
62141: LD_ADDR_VAR 0 11
62145: PUSH
62146: EMPTY
62147: ST_TO_ADDR
// if sort then
62148: LD_VAR 0 9
62152: IFFALSE 62268
// for i = 1 to 4 - eng do
62154: LD_ADDR_VAR 0 3
62158: PUSH
62159: DOUBLE
62160: LD_INT 1
62162: DEC
62163: ST_TO_ADDR
62164: LD_INT 4
62166: PUSH
62167: LD_VAR 0 6
62171: MINUS
62172: PUSH
62173: FOR_TO
62174: IFFALSE 62266
// begin if i = sort then
62176: LD_VAR 0 3
62180: PUSH
62181: LD_VAR 0 9
62185: EQUAL
62186: IFFALSE 62190
// break ;
62188: GO 62266
// if GetClass ( i ) = 2 then
62190: LD_VAR 0 3
62194: PPUSH
62195: CALL_OW 257
62199: PUSH
62200: LD_INT 2
62202: EQUAL
62203: IFFALSE 62207
// continue ;
62205: GO 62173
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62207: LD_ADDR_VAR 0 11
62211: PUSH
62212: LD_VAR 0 11
62216: PPUSH
62217: LD_VAR 0 11
62221: PUSH
62222: LD_INT 1
62224: PLUS
62225: PPUSH
62226: LD_VAR 0 9
62230: PUSH
62231: LD_VAR 0 3
62235: ARRAY
62236: PPUSH
62237: CALL_OW 2
62241: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62242: LD_ADDR_VAR 0 4
62246: PUSH
62247: LD_VAR 0 4
62251: PUSH
62252: LD_VAR 0 9
62256: PUSH
62257: LD_VAR 0 3
62261: ARRAY
62262: DIFF
62263: ST_TO_ADDR
// end ;
62264: GO 62173
62266: POP
62267: POP
// if p then
62268: LD_VAR 0 11
62272: IFFALSE 62297
// result := Replace ( result , 2 , p ) ;
62274: LD_ADDR_VAR 0 2
62278: PUSH
62279: LD_VAR 0 2
62283: PPUSH
62284: LD_INT 2
62286: PPUSH
62287: LD_VAR 0 11
62291: PPUSH
62292: CALL_OW 1
62296: ST_TO_ADDR
// end else
62297: GO 62343
// for i = eng downto 5 do
62299: LD_ADDR_VAR 0 3
62303: PUSH
62304: DOUBLE
62305: LD_VAR 0 6
62309: INC
62310: ST_TO_ADDR
62311: LD_INT 5
62313: PUSH
62314: FOR_DOWNTO
62315: IFFALSE 62341
// tmp := tmp union eng [ i ] ;
62317: LD_ADDR_VAR 0 4
62321: PUSH
62322: LD_VAR 0 4
62326: PUSH
62327: LD_VAR 0 6
62331: PUSH
62332: LD_VAR 0 3
62336: ARRAY
62337: UNION
62338: ST_TO_ADDR
62339: GO 62314
62341: POP
62342: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62343: LD_ADDR_VAR 0 2
62347: PUSH
62348: LD_VAR 0 2
62352: PPUSH
62353: LD_INT 1
62355: PPUSH
62356: LD_VAR 0 4
62360: PUSH
62361: LD_VAR 0 5
62365: DIFF
62366: PPUSH
62367: CALL_OW 1
62371: ST_TO_ADDR
// exit ;
62372: GO 62374
// end ; end ;
62374: LD_VAR 0 2
62378: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62379: LD_INT 0
62381: PPUSH
62382: PPUSH
62383: PPUSH
// if not mc_bases then
62384: LD_EXP 52
62388: NOT
62389: IFFALSE 62393
// exit ;
62391: GO 62499
// for i = 1 to mc_bases do
62393: LD_ADDR_VAR 0 2
62397: PUSH
62398: DOUBLE
62399: LD_INT 1
62401: DEC
62402: ST_TO_ADDR
62403: LD_EXP 52
62407: PUSH
62408: FOR_TO
62409: IFFALSE 62490
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62411: LD_ADDR_VAR 0 3
62415: PUSH
62416: LD_EXP 52
62420: PUSH
62421: LD_VAR 0 2
62425: ARRAY
62426: PPUSH
62427: LD_INT 21
62429: PUSH
62430: LD_INT 3
62432: PUSH
62433: EMPTY
62434: LIST
62435: LIST
62436: PUSH
62437: LD_INT 3
62439: PUSH
62440: LD_INT 24
62442: PUSH
62443: LD_INT 1000
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PPUSH
62458: CALL_OW 72
62462: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62463: LD_ADDR_EXP 53
62467: PUSH
62468: LD_EXP 53
62472: PPUSH
62473: LD_VAR 0 2
62477: PPUSH
62478: LD_VAR 0 3
62482: PPUSH
62483: CALL_OW 1
62487: ST_TO_ADDR
// end ;
62488: GO 62408
62490: POP
62491: POP
// RaiseSailEvent ( 101 ) ;
62492: LD_INT 101
62494: PPUSH
62495: CALL_OW 427
// end ;
62499: LD_VAR 0 1
62503: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62504: LD_INT 0
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
62512: PPUSH
// if not mc_bases then
62513: LD_EXP 52
62517: NOT
62518: IFFALSE 62522
// exit ;
62520: GO 63095
// for i = 1 to mc_bases do
62522: LD_ADDR_VAR 0 2
62526: PUSH
62527: DOUBLE
62528: LD_INT 1
62530: DEC
62531: ST_TO_ADDR
62532: LD_EXP 52
62536: PUSH
62537: FOR_TO
62538: IFFALSE 63086
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
62540: LD_ADDR_VAR 0 5
62544: PUSH
62545: LD_EXP 52
62549: PUSH
62550: LD_VAR 0 2
62554: ARRAY
62555: PUSH
62556: LD_EXP 81
62560: PUSH
62561: LD_VAR 0 2
62565: ARRAY
62566: UNION
62567: PPUSH
62568: LD_INT 21
62570: PUSH
62571: LD_INT 1
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: PUSH
62578: LD_INT 1
62580: PUSH
62581: LD_INT 3
62583: PUSH
62584: LD_INT 54
62586: PUSH
62587: EMPTY
62588: LIST
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: LD_INT 3
62596: PUSH
62597: LD_INT 24
62599: PUSH
62600: LD_INT 800
62602: PUSH
62603: EMPTY
62604: LIST
62605: LIST
62606: PUSH
62607: EMPTY
62608: LIST
62609: LIST
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: LIST
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PPUSH
62620: CALL_OW 72
62624: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62625: LD_ADDR_VAR 0 6
62629: PUSH
62630: LD_EXP 52
62634: PUSH
62635: LD_VAR 0 2
62639: ARRAY
62640: PPUSH
62641: LD_INT 21
62643: PUSH
62644: LD_INT 1
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: PUSH
62651: LD_INT 1
62653: PUSH
62654: LD_INT 3
62656: PUSH
62657: LD_INT 54
62659: PUSH
62660: EMPTY
62661: LIST
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PUSH
62667: LD_INT 3
62669: PUSH
62670: LD_INT 24
62672: PUSH
62673: LD_INT 250
62675: PUSH
62676: EMPTY
62677: LIST
62678: LIST
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: LIST
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PPUSH
62693: CALL_OW 72
62697: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62698: LD_ADDR_VAR 0 7
62702: PUSH
62703: LD_VAR 0 5
62707: PUSH
62708: LD_VAR 0 6
62712: DIFF
62713: ST_TO_ADDR
// if not need_heal_1 then
62714: LD_VAR 0 6
62718: NOT
62719: IFFALSE 62752
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62721: LD_ADDR_EXP 55
62725: PUSH
62726: LD_EXP 55
62730: PPUSH
62731: LD_VAR 0 2
62735: PUSH
62736: LD_INT 1
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PPUSH
62743: EMPTY
62744: PPUSH
62745: CALL 18165 0 3
62749: ST_TO_ADDR
62750: GO 62822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62752: LD_ADDR_EXP 55
62756: PUSH
62757: LD_EXP 55
62761: PPUSH
62762: LD_VAR 0 2
62766: PUSH
62767: LD_INT 1
62769: PUSH
62770: EMPTY
62771: LIST
62772: LIST
62773: PPUSH
62774: LD_EXP 55
62778: PUSH
62779: LD_VAR 0 2
62783: ARRAY
62784: PUSH
62785: LD_INT 1
62787: ARRAY
62788: PPUSH
62789: LD_INT 3
62791: PUSH
62792: LD_INT 24
62794: PUSH
62795: LD_INT 1000
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: PUSH
62802: EMPTY
62803: LIST
62804: LIST
62805: PPUSH
62806: CALL_OW 72
62810: PUSH
62811: LD_VAR 0 6
62815: UNION
62816: PPUSH
62817: CALL 18165 0 3
62821: ST_TO_ADDR
// if not need_heal_2 then
62822: LD_VAR 0 7
62826: NOT
62827: IFFALSE 62860
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62829: LD_ADDR_EXP 55
62833: PUSH
62834: LD_EXP 55
62838: PPUSH
62839: LD_VAR 0 2
62843: PUSH
62844: LD_INT 2
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PPUSH
62851: EMPTY
62852: PPUSH
62853: CALL 18165 0 3
62857: ST_TO_ADDR
62858: GO 62892
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62860: LD_ADDR_EXP 55
62864: PUSH
62865: LD_EXP 55
62869: PPUSH
62870: LD_VAR 0 2
62874: PUSH
62875: LD_INT 2
62877: PUSH
62878: EMPTY
62879: LIST
62880: LIST
62881: PPUSH
62882: LD_VAR 0 7
62886: PPUSH
62887: CALL 18165 0 3
62891: ST_TO_ADDR
// if need_heal_2 then
62892: LD_VAR 0 7
62896: IFFALSE 63068
// for j in need_heal_2 do
62898: LD_ADDR_VAR 0 3
62902: PUSH
62903: LD_VAR 0 7
62907: PUSH
62908: FOR_IN
62909: IFFALSE 63066
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
62911: LD_ADDR_VAR 0 5
62915: PUSH
62916: LD_EXP 52
62920: PUSH
62921: LD_VAR 0 2
62925: ARRAY
62926: PPUSH
62927: LD_INT 2
62929: PUSH
62930: LD_INT 30
62932: PUSH
62933: LD_INT 6
62935: PUSH
62936: EMPTY
62937: LIST
62938: LIST
62939: PUSH
62940: LD_INT 30
62942: PUSH
62943: LD_INT 7
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: LD_INT 30
62952: PUSH
62953: LD_INT 8
62955: PUSH
62956: EMPTY
62957: LIST
62958: LIST
62959: PUSH
62960: LD_INT 30
62962: PUSH
62963: LD_INT 0
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: PUSH
62970: LD_INT 30
62972: PUSH
62973: LD_INT 1
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PUSH
62980: LD_INT 25
62982: PUSH
62983: LD_INT 4
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: PUSH
62990: EMPTY
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: LIST
62996: LIST
62997: LIST
62998: PPUSH
62999: CALL_OW 72
63003: ST_TO_ADDR
// if tmp then
63004: LD_VAR 0 5
63008: IFFALSE 63064
// begin k := NearestUnitToUnit ( tmp , j ) ;
63010: LD_ADDR_VAR 0 4
63014: PUSH
63015: LD_VAR 0 5
63019: PPUSH
63020: LD_VAR 0 3
63024: PPUSH
63025: CALL_OW 74
63029: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63030: LD_VAR 0 3
63034: PPUSH
63035: LD_VAR 0 4
63039: PPUSH
63040: CALL_OW 296
63044: PUSH
63045: LD_INT 7
63047: GREATER
63048: IFFALSE 63064
// ComMoveUnit ( j , k ) ;
63050: LD_VAR 0 3
63054: PPUSH
63055: LD_VAR 0 4
63059: PPUSH
63060: CALL_OW 112
// end ; end ;
63064: GO 62908
63066: POP
63067: POP
// if not need_heal_1 and not need_heal_2 then
63068: LD_VAR 0 6
63072: NOT
63073: PUSH
63074: LD_VAR 0 7
63078: NOT
63079: AND
63080: IFFALSE 63084
// continue ;
63082: GO 62537
// end ;
63084: GO 62537
63086: POP
63087: POP
// RaiseSailEvent ( 102 ) ;
63088: LD_INT 102
63090: PPUSH
63091: CALL_OW 427
// end ;
63095: LD_VAR 0 1
63099: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
63100: LD_INT 0
63102: PPUSH
63103: PPUSH
63104: PPUSH
63105: PPUSH
63106: PPUSH
63107: PPUSH
// if not mc_bases then
63108: LD_EXP 52
63112: NOT
63113: IFFALSE 63117
// exit ;
63115: GO 63827
// for i = 1 to mc_bases do
63117: LD_ADDR_VAR 0 2
63121: PUSH
63122: DOUBLE
63123: LD_INT 1
63125: DEC
63126: ST_TO_ADDR
63127: LD_EXP 52
63131: PUSH
63132: FOR_TO
63133: IFFALSE 63825
// begin if not mc_building_need_repair [ i ] then
63135: LD_EXP 53
63139: PUSH
63140: LD_VAR 0 2
63144: ARRAY
63145: NOT
63146: IFFALSE 63320
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
63148: LD_ADDR_VAR 0 6
63152: PUSH
63153: LD_EXP 71
63157: PUSH
63158: LD_VAR 0 2
63162: ARRAY
63163: PPUSH
63164: LD_INT 3
63166: PUSH
63167: LD_INT 24
63169: PUSH
63170: LD_INT 1000
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: LD_INT 2
63183: PUSH
63184: LD_INT 34
63186: PUSH
63187: LD_INT 13
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: PUSH
63194: LD_INT 34
63196: PUSH
63197: LD_INT 52
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: LIST
63208: PUSH
63209: EMPTY
63210: LIST
63211: LIST
63212: PPUSH
63213: CALL_OW 72
63217: ST_TO_ADDR
// if cranes then
63218: LD_VAR 0 6
63222: IFFALSE 63284
// for j in cranes do
63224: LD_ADDR_VAR 0 3
63228: PUSH
63229: LD_VAR 0 6
63233: PUSH
63234: FOR_IN
63235: IFFALSE 63282
// if not IsInArea ( j , mc_parking [ i ] ) then
63237: LD_VAR 0 3
63241: PPUSH
63242: LD_EXP 76
63246: PUSH
63247: LD_VAR 0 2
63251: ARRAY
63252: PPUSH
63253: CALL_OW 308
63257: NOT
63258: IFFALSE 63280
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63260: LD_VAR 0 3
63264: PPUSH
63265: LD_EXP 76
63269: PUSH
63270: LD_VAR 0 2
63274: ARRAY
63275: PPUSH
63276: CALL_OW 113
63280: GO 63234
63282: POP
63283: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63284: LD_ADDR_EXP 54
63288: PUSH
63289: LD_EXP 54
63293: PPUSH
63294: LD_VAR 0 2
63298: PPUSH
63299: EMPTY
63300: PPUSH
63301: CALL_OW 1
63305: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63306: LD_VAR 0 2
63310: PPUSH
63311: LD_INT 101
63313: PPUSH
63314: CALL 58212 0 2
// continue ;
63318: GO 63132
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63320: LD_ADDR_EXP 58
63324: PUSH
63325: LD_EXP 58
63329: PPUSH
63330: LD_VAR 0 2
63334: PPUSH
63335: EMPTY
63336: PPUSH
63337: CALL_OW 1
63341: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63342: LD_VAR 0 2
63346: PPUSH
63347: LD_INT 103
63349: PPUSH
63350: CALL 58212 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63354: LD_ADDR_VAR 0 5
63358: PUSH
63359: LD_EXP 52
63363: PUSH
63364: LD_VAR 0 2
63368: ARRAY
63369: PUSH
63370: LD_EXP 81
63374: PUSH
63375: LD_VAR 0 2
63379: ARRAY
63380: UNION
63381: PPUSH
63382: LD_INT 2
63384: PUSH
63385: LD_INT 25
63387: PUSH
63388: LD_INT 2
63390: PUSH
63391: EMPTY
63392: LIST
63393: LIST
63394: PUSH
63395: LD_INT 25
63397: PUSH
63398: LD_INT 16
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: LIST
63409: PUSH
63410: EMPTY
63411: LIST
63412: PPUSH
63413: CALL_OW 72
63417: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
63418: LD_ADDR_VAR 0 6
63422: PUSH
63423: LD_EXP 71
63427: PUSH
63428: LD_VAR 0 2
63432: ARRAY
63433: PPUSH
63434: LD_INT 2
63436: PUSH
63437: LD_INT 34
63439: PUSH
63440: LD_INT 13
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 34
63449: PUSH
63450: LD_INT 52
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: LIST
63461: PPUSH
63462: CALL_OW 72
63466: ST_TO_ADDR
// if cranes then
63467: LD_VAR 0 6
63471: IFFALSE 63607
// begin for j in cranes do
63473: LD_ADDR_VAR 0 3
63477: PUSH
63478: LD_VAR 0 6
63482: PUSH
63483: FOR_IN
63484: IFFALSE 63605
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
63486: LD_VAR 0 3
63490: PPUSH
63491: CALL_OW 256
63495: PUSH
63496: LD_INT 500
63498: GREATEREQUAL
63499: PUSH
63500: LD_VAR 0 3
63504: PPUSH
63505: CALL_OW 314
63509: NOT
63510: AND
63511: IFFALSE 63545
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63513: LD_VAR 0 3
63517: PPUSH
63518: LD_EXP 53
63522: PUSH
63523: LD_VAR 0 2
63527: ARRAY
63528: PPUSH
63529: LD_VAR 0 3
63533: PPUSH
63534: CALL_OW 74
63538: PPUSH
63539: CALL_OW 130
63543: GO 63603
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63545: LD_VAR 0 3
63549: PPUSH
63550: CALL_OW 256
63554: PUSH
63555: LD_INT 500
63557: LESS
63558: PUSH
63559: LD_VAR 0 3
63563: PPUSH
63564: LD_EXP 76
63568: PUSH
63569: LD_VAR 0 2
63573: ARRAY
63574: PPUSH
63575: CALL_OW 308
63579: NOT
63580: AND
63581: IFFALSE 63603
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63583: LD_VAR 0 3
63587: PPUSH
63588: LD_EXP 76
63592: PUSH
63593: LD_VAR 0 2
63597: ARRAY
63598: PPUSH
63599: CALL_OW 113
63603: GO 63483
63605: POP
63606: POP
// end ; if not tmp then
63607: LD_VAR 0 5
63611: NOT
63612: IFFALSE 63616
// continue ;
63614: GO 63132
// for j in tmp do
63616: LD_ADDR_VAR 0 3
63620: PUSH
63621: LD_VAR 0 5
63625: PUSH
63626: FOR_IN
63627: IFFALSE 63821
// begin if mc_need_heal [ i ] then
63629: LD_EXP 55
63633: PUSH
63634: LD_VAR 0 2
63638: ARRAY
63639: IFFALSE 63687
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63641: LD_VAR 0 3
63645: PUSH
63646: LD_EXP 55
63650: PUSH
63651: LD_VAR 0 2
63655: ARRAY
63656: PUSH
63657: LD_INT 1
63659: ARRAY
63660: IN
63661: PUSH
63662: LD_VAR 0 3
63666: PUSH
63667: LD_EXP 55
63671: PUSH
63672: LD_VAR 0 2
63676: ARRAY
63677: PUSH
63678: LD_INT 2
63680: ARRAY
63681: IN
63682: OR
63683: IFFALSE 63687
// continue ;
63685: GO 63626
// if IsInUnit ( j ) then
63687: LD_VAR 0 3
63691: PPUSH
63692: CALL_OW 310
63696: IFFALSE 63707
// ComExitBuilding ( j ) ;
63698: LD_VAR 0 3
63702: PPUSH
63703: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63707: LD_VAR 0 3
63711: PUSH
63712: LD_EXP 54
63716: PUSH
63717: LD_VAR 0 2
63721: ARRAY
63722: IN
63723: NOT
63724: IFFALSE 63782
// begin SetTag ( j , 101 ) ;
63726: LD_VAR 0 3
63730: PPUSH
63731: LD_INT 101
63733: PPUSH
63734: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63738: LD_ADDR_EXP 54
63742: PUSH
63743: LD_EXP 54
63747: PPUSH
63748: LD_VAR 0 2
63752: PUSH
63753: LD_EXP 54
63757: PUSH
63758: LD_VAR 0 2
63762: ARRAY
63763: PUSH
63764: LD_INT 1
63766: PLUS
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PPUSH
63772: LD_VAR 0 3
63776: PPUSH
63777: CALL 18165 0 3
63781: ST_TO_ADDR
// end ; wait ( 1 ) ;
63782: LD_INT 1
63784: PPUSH
63785: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63789: LD_VAR 0 3
63793: PPUSH
63794: LD_EXP 53
63798: PUSH
63799: LD_VAR 0 2
63803: ARRAY
63804: PPUSH
63805: LD_VAR 0 3
63809: PPUSH
63810: CALL_OW 74
63814: PPUSH
63815: CALL_OW 130
// end ;
63819: GO 63626
63821: POP
63822: POP
// end ;
63823: GO 63132
63825: POP
63826: POP
// end ;
63827: LD_VAR 0 1
63831: RET
// export function MC_Heal ; var i , j , tmp ; begin
63832: LD_INT 0
63834: PPUSH
63835: PPUSH
63836: PPUSH
63837: PPUSH
// if not mc_bases then
63838: LD_EXP 52
63842: NOT
63843: IFFALSE 63847
// exit ;
63845: GO 64249
// for i = 1 to mc_bases do
63847: LD_ADDR_VAR 0 2
63851: PUSH
63852: DOUBLE
63853: LD_INT 1
63855: DEC
63856: ST_TO_ADDR
63857: LD_EXP 52
63861: PUSH
63862: FOR_TO
63863: IFFALSE 64247
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63865: LD_EXP 55
63869: PUSH
63870: LD_VAR 0 2
63874: ARRAY
63875: PUSH
63876: LD_INT 1
63878: ARRAY
63879: NOT
63880: PUSH
63881: LD_EXP 55
63885: PUSH
63886: LD_VAR 0 2
63890: ARRAY
63891: PUSH
63892: LD_INT 2
63894: ARRAY
63895: NOT
63896: AND
63897: IFFALSE 63935
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63899: LD_ADDR_EXP 56
63903: PUSH
63904: LD_EXP 56
63908: PPUSH
63909: LD_VAR 0 2
63913: PPUSH
63914: EMPTY
63915: PPUSH
63916: CALL_OW 1
63920: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63921: LD_VAR 0 2
63925: PPUSH
63926: LD_INT 102
63928: PPUSH
63929: CALL 58212 0 2
// continue ;
63933: GO 63862
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63935: LD_ADDR_VAR 0 4
63939: PUSH
63940: LD_EXP 52
63944: PUSH
63945: LD_VAR 0 2
63949: ARRAY
63950: PPUSH
63951: LD_INT 25
63953: PUSH
63954: LD_INT 4
63956: PUSH
63957: EMPTY
63958: LIST
63959: LIST
63960: PPUSH
63961: CALL_OW 72
63965: ST_TO_ADDR
// if not tmp then
63966: LD_VAR 0 4
63970: NOT
63971: IFFALSE 63975
// continue ;
63973: GO 63862
// if mc_taming [ i ] then
63975: LD_EXP 83
63979: PUSH
63980: LD_VAR 0 2
63984: ARRAY
63985: IFFALSE 64009
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63987: LD_ADDR_EXP 83
63991: PUSH
63992: LD_EXP 83
63996: PPUSH
63997: LD_VAR 0 2
64001: PPUSH
64002: EMPTY
64003: PPUSH
64004: CALL_OW 1
64008: ST_TO_ADDR
// for j in tmp do
64009: LD_ADDR_VAR 0 3
64013: PUSH
64014: LD_VAR 0 4
64018: PUSH
64019: FOR_IN
64020: IFFALSE 64243
// begin if IsInUnit ( j ) then
64022: LD_VAR 0 3
64026: PPUSH
64027: CALL_OW 310
64031: IFFALSE 64042
// ComExitBuilding ( j ) ;
64033: LD_VAR 0 3
64037: PPUSH
64038: CALL_OW 122
// if not j in mc_healers [ i ] then
64042: LD_VAR 0 3
64046: PUSH
64047: LD_EXP 56
64051: PUSH
64052: LD_VAR 0 2
64056: ARRAY
64057: IN
64058: NOT
64059: IFFALSE 64105
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64061: LD_ADDR_EXP 56
64065: PUSH
64066: LD_EXP 56
64070: PPUSH
64071: LD_VAR 0 2
64075: PUSH
64076: LD_EXP 56
64080: PUSH
64081: LD_VAR 0 2
64085: ARRAY
64086: PUSH
64087: LD_INT 1
64089: PLUS
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PPUSH
64095: LD_VAR 0 3
64099: PPUSH
64100: CALL 18165 0 3
64104: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64105: LD_VAR 0 3
64109: PPUSH
64110: CALL_OW 110
64114: PUSH
64115: LD_INT 102
64117: NONEQUAL
64118: IFFALSE 64132
// SetTag ( j , 102 ) ;
64120: LD_VAR 0 3
64124: PPUSH
64125: LD_INT 102
64127: PPUSH
64128: CALL_OW 109
// Wait ( 3 ) ;
64132: LD_INT 3
64134: PPUSH
64135: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64139: LD_EXP 55
64143: PUSH
64144: LD_VAR 0 2
64148: ARRAY
64149: PUSH
64150: LD_INT 1
64152: ARRAY
64153: IFFALSE 64185
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64155: LD_VAR 0 3
64159: PPUSH
64160: LD_EXP 55
64164: PUSH
64165: LD_VAR 0 2
64169: ARRAY
64170: PUSH
64171: LD_INT 1
64173: ARRAY
64174: PUSH
64175: LD_INT 1
64177: ARRAY
64178: PPUSH
64179: CALL_OW 128
64183: GO 64241
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64185: LD_VAR 0 3
64189: PPUSH
64190: CALL_OW 314
64194: NOT
64195: PUSH
64196: LD_EXP 55
64200: PUSH
64201: LD_VAR 0 2
64205: ARRAY
64206: PUSH
64207: LD_INT 2
64209: ARRAY
64210: AND
64211: IFFALSE 64241
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64213: LD_VAR 0 3
64217: PPUSH
64218: LD_EXP 55
64222: PUSH
64223: LD_VAR 0 2
64227: ARRAY
64228: PUSH
64229: LD_INT 2
64231: ARRAY
64232: PUSH
64233: LD_INT 1
64235: ARRAY
64236: PPUSH
64237: CALL_OW 128
// end ;
64241: GO 64019
64243: POP
64244: POP
// end ;
64245: GO 63862
64247: POP
64248: POP
// end ;
64249: LD_VAR 0 1
64253: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64254: LD_INT 0
64256: PPUSH
64257: PPUSH
64258: PPUSH
64259: PPUSH
64260: PPUSH
// if not mc_bases then
64261: LD_EXP 52
64265: NOT
64266: IFFALSE 64270
// exit ;
64268: GO 65413
// for i = 1 to mc_bases do
64270: LD_ADDR_VAR 0 2
64274: PUSH
64275: DOUBLE
64276: LD_INT 1
64278: DEC
64279: ST_TO_ADDR
64280: LD_EXP 52
64284: PUSH
64285: FOR_TO
64286: IFFALSE 65411
// begin if mc_scan [ i ] then
64288: LD_EXP 75
64292: PUSH
64293: LD_VAR 0 2
64297: ARRAY
64298: IFFALSE 64302
// continue ;
64300: GO 64285
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64302: LD_EXP 57
64306: PUSH
64307: LD_VAR 0 2
64311: ARRAY
64312: NOT
64313: PUSH
64314: LD_EXP 59
64318: PUSH
64319: LD_VAR 0 2
64323: ARRAY
64324: NOT
64325: AND
64326: PUSH
64327: LD_EXP 58
64331: PUSH
64332: LD_VAR 0 2
64336: ARRAY
64337: AND
64338: IFFALSE 64376
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64340: LD_ADDR_EXP 58
64344: PUSH
64345: LD_EXP 58
64349: PPUSH
64350: LD_VAR 0 2
64354: PPUSH
64355: EMPTY
64356: PPUSH
64357: CALL_OW 1
64361: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64362: LD_VAR 0 2
64366: PPUSH
64367: LD_INT 103
64369: PPUSH
64370: CALL 58212 0 2
// continue ;
64374: GO 64285
// end ; if mc_construct_list [ i ] then
64376: LD_EXP 59
64380: PUSH
64381: LD_VAR 0 2
64385: ARRAY
64386: IFFALSE 64606
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64388: LD_ADDR_VAR 0 4
64392: PUSH
64393: LD_EXP 52
64397: PUSH
64398: LD_VAR 0 2
64402: ARRAY
64403: PPUSH
64404: LD_INT 25
64406: PUSH
64407: LD_INT 2
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: PPUSH
64414: CALL_OW 72
64418: PUSH
64419: LD_EXP 54
64423: PUSH
64424: LD_VAR 0 2
64428: ARRAY
64429: DIFF
64430: ST_TO_ADDR
// if not tmp then
64431: LD_VAR 0 4
64435: NOT
64436: IFFALSE 64440
// continue ;
64438: GO 64285
// for j in tmp do
64440: LD_ADDR_VAR 0 3
64444: PUSH
64445: LD_VAR 0 4
64449: PUSH
64450: FOR_IN
64451: IFFALSE 64602
// begin if not mc_builders [ i ] then
64453: LD_EXP 58
64457: PUSH
64458: LD_VAR 0 2
64462: ARRAY
64463: NOT
64464: IFFALSE 64522
// begin SetTag ( j , 103 ) ;
64466: LD_VAR 0 3
64470: PPUSH
64471: LD_INT 103
64473: PPUSH
64474: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64478: LD_ADDR_EXP 58
64482: PUSH
64483: LD_EXP 58
64487: PPUSH
64488: LD_VAR 0 2
64492: PUSH
64493: LD_EXP 58
64497: PUSH
64498: LD_VAR 0 2
64502: ARRAY
64503: PUSH
64504: LD_INT 1
64506: PLUS
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: PPUSH
64512: LD_VAR 0 3
64516: PPUSH
64517: CALL 18165 0 3
64521: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64522: LD_VAR 0 3
64526: PPUSH
64527: CALL_OW 310
64531: IFFALSE 64542
// ComExitBuilding ( j ) ;
64533: LD_VAR 0 3
64537: PPUSH
64538: CALL_OW 122
// wait ( 3 ) ;
64542: LD_INT 3
64544: PPUSH
64545: CALL_OW 67
// if not mc_construct_list [ i ] then
64549: LD_EXP 59
64553: PUSH
64554: LD_VAR 0 2
64558: ARRAY
64559: NOT
64560: IFFALSE 64564
// break ;
64562: GO 64602
// if not HasTask ( j ) then
64564: LD_VAR 0 3
64568: PPUSH
64569: CALL_OW 314
64573: NOT
64574: IFFALSE 64600
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64576: LD_VAR 0 3
64580: PPUSH
64581: LD_EXP 59
64585: PUSH
64586: LD_VAR 0 2
64590: ARRAY
64591: PUSH
64592: LD_INT 1
64594: ARRAY
64595: PPUSH
64596: CALL 21016 0 2
// end ;
64600: GO 64450
64602: POP
64603: POP
// end else
64604: GO 65409
// if mc_build_list [ i ] then
64606: LD_EXP 57
64610: PUSH
64611: LD_VAR 0 2
64615: ARRAY
64616: IFFALSE 65409
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64618: LD_ADDR_VAR 0 5
64622: PUSH
64623: LD_EXP 52
64627: PUSH
64628: LD_VAR 0 2
64632: ARRAY
64633: PPUSH
64634: LD_INT 2
64636: PUSH
64637: LD_INT 30
64639: PUSH
64640: LD_INT 0
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PUSH
64647: LD_INT 30
64649: PUSH
64650: LD_INT 1
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: LIST
64661: PPUSH
64662: CALL_OW 72
64666: ST_TO_ADDR
// if depot then
64667: LD_VAR 0 5
64671: IFFALSE 64689
// depot := depot [ 1 ] else
64673: LD_ADDR_VAR 0 5
64677: PUSH
64678: LD_VAR 0 5
64682: PUSH
64683: LD_INT 1
64685: ARRAY
64686: ST_TO_ADDR
64687: GO 64697
// depot := 0 ;
64689: LD_ADDR_VAR 0 5
64693: PUSH
64694: LD_INT 0
64696: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64697: LD_EXP 57
64701: PUSH
64702: LD_VAR 0 2
64706: ARRAY
64707: PUSH
64708: LD_INT 1
64710: ARRAY
64711: PUSH
64712: LD_INT 1
64714: ARRAY
64715: PPUSH
64716: CALL 20846 0 1
64720: PUSH
64721: LD_EXP 52
64725: PUSH
64726: LD_VAR 0 2
64730: ARRAY
64731: PPUSH
64732: LD_INT 2
64734: PUSH
64735: LD_INT 30
64737: PUSH
64738: LD_INT 2
64740: PUSH
64741: EMPTY
64742: LIST
64743: LIST
64744: PUSH
64745: LD_INT 30
64747: PUSH
64748: LD_INT 3
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: LIST
64759: PPUSH
64760: CALL_OW 72
64764: NOT
64765: AND
64766: IFFALSE 64871
// begin for j = 1 to mc_build_list [ i ] do
64768: LD_ADDR_VAR 0 3
64772: PUSH
64773: DOUBLE
64774: LD_INT 1
64776: DEC
64777: ST_TO_ADDR
64778: LD_EXP 57
64782: PUSH
64783: LD_VAR 0 2
64787: ARRAY
64788: PUSH
64789: FOR_TO
64790: IFFALSE 64869
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64792: LD_EXP 57
64796: PUSH
64797: LD_VAR 0 2
64801: ARRAY
64802: PUSH
64803: LD_VAR 0 3
64807: ARRAY
64808: PUSH
64809: LD_INT 1
64811: ARRAY
64812: PUSH
64813: LD_INT 2
64815: EQUAL
64816: IFFALSE 64867
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64818: LD_ADDR_EXP 57
64822: PUSH
64823: LD_EXP 57
64827: PPUSH
64828: LD_VAR 0 2
64832: PPUSH
64833: LD_EXP 57
64837: PUSH
64838: LD_VAR 0 2
64842: ARRAY
64843: PPUSH
64844: LD_VAR 0 3
64848: PPUSH
64849: LD_INT 1
64851: PPUSH
64852: LD_INT 0
64854: PPUSH
64855: CALL 17583 0 4
64859: PPUSH
64860: CALL_OW 1
64864: ST_TO_ADDR
// break ;
64865: GO 64869
// end ;
64867: GO 64789
64869: POP
64870: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64871: LD_EXP 57
64875: PUSH
64876: LD_VAR 0 2
64880: ARRAY
64881: PUSH
64882: LD_INT 1
64884: ARRAY
64885: PUSH
64886: LD_INT 1
64888: ARRAY
64889: PUSH
64890: LD_INT 0
64892: EQUAL
64893: PUSH
64894: LD_VAR 0 5
64898: PUSH
64899: LD_VAR 0 5
64903: PPUSH
64904: LD_EXP 57
64908: PUSH
64909: LD_VAR 0 2
64913: ARRAY
64914: PUSH
64915: LD_INT 1
64917: ARRAY
64918: PUSH
64919: LD_INT 1
64921: ARRAY
64922: PPUSH
64923: LD_EXP 57
64927: PUSH
64928: LD_VAR 0 2
64932: ARRAY
64933: PUSH
64934: LD_INT 1
64936: ARRAY
64937: PUSH
64938: LD_INT 2
64940: ARRAY
64941: PPUSH
64942: LD_EXP 57
64946: PUSH
64947: LD_VAR 0 2
64951: ARRAY
64952: PUSH
64953: LD_INT 1
64955: ARRAY
64956: PUSH
64957: LD_INT 3
64959: ARRAY
64960: PPUSH
64961: LD_EXP 57
64965: PUSH
64966: LD_VAR 0 2
64970: ARRAY
64971: PUSH
64972: LD_INT 1
64974: ARRAY
64975: PUSH
64976: LD_INT 4
64978: ARRAY
64979: PPUSH
64980: CALL 25580 0 5
64984: AND
64985: OR
64986: IFFALSE 65267
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64988: LD_ADDR_VAR 0 4
64992: PUSH
64993: LD_EXP 52
64997: PUSH
64998: LD_VAR 0 2
65002: ARRAY
65003: PPUSH
65004: LD_INT 25
65006: PUSH
65007: LD_INT 2
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PPUSH
65014: CALL_OW 72
65018: PUSH
65019: LD_EXP 54
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: DIFF
65030: ST_TO_ADDR
// if not tmp then
65031: LD_VAR 0 4
65035: NOT
65036: IFFALSE 65040
// continue ;
65038: GO 64285
// for j in tmp do
65040: LD_ADDR_VAR 0 3
65044: PUSH
65045: LD_VAR 0 4
65049: PUSH
65050: FOR_IN
65051: IFFALSE 65263
// begin if not mc_builders [ i ] then
65053: LD_EXP 58
65057: PUSH
65058: LD_VAR 0 2
65062: ARRAY
65063: NOT
65064: IFFALSE 65122
// begin SetTag ( j , 103 ) ;
65066: LD_VAR 0 3
65070: PPUSH
65071: LD_INT 103
65073: PPUSH
65074: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65078: LD_ADDR_EXP 58
65082: PUSH
65083: LD_EXP 58
65087: PPUSH
65088: LD_VAR 0 2
65092: PUSH
65093: LD_EXP 58
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: PUSH
65104: LD_INT 1
65106: PLUS
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PPUSH
65112: LD_VAR 0 3
65116: PPUSH
65117: CALL 18165 0 3
65121: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65122: LD_VAR 0 3
65126: PPUSH
65127: CALL_OW 310
65131: IFFALSE 65142
// ComExitBuilding ( j ) ;
65133: LD_VAR 0 3
65137: PPUSH
65138: CALL_OW 122
// wait ( 3 ) ;
65142: LD_INT 3
65144: PPUSH
65145: CALL_OW 67
// if not mc_build_list [ i ] then
65149: LD_EXP 57
65153: PUSH
65154: LD_VAR 0 2
65158: ARRAY
65159: NOT
65160: IFFALSE 65164
// break ;
65162: GO 65263
// if not HasTask ( j ) then
65164: LD_VAR 0 3
65168: PPUSH
65169: CALL_OW 314
65173: NOT
65174: IFFALSE 65261
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65176: LD_VAR 0 3
65180: PPUSH
65181: LD_EXP 57
65185: PUSH
65186: LD_VAR 0 2
65190: ARRAY
65191: PUSH
65192: LD_INT 1
65194: ARRAY
65195: PUSH
65196: LD_INT 1
65198: ARRAY
65199: PPUSH
65200: LD_EXP 57
65204: PUSH
65205: LD_VAR 0 2
65209: ARRAY
65210: PUSH
65211: LD_INT 1
65213: ARRAY
65214: PUSH
65215: LD_INT 2
65217: ARRAY
65218: PPUSH
65219: LD_EXP 57
65223: PUSH
65224: LD_VAR 0 2
65228: ARRAY
65229: PUSH
65230: LD_INT 1
65232: ARRAY
65233: PUSH
65234: LD_INT 3
65236: ARRAY
65237: PPUSH
65238: LD_EXP 57
65242: PUSH
65243: LD_VAR 0 2
65247: ARRAY
65248: PUSH
65249: LD_INT 1
65251: ARRAY
65252: PUSH
65253: LD_INT 4
65255: ARRAY
65256: PPUSH
65257: CALL_OW 145
// end ;
65261: GO 65050
65263: POP
65264: POP
// end else
65265: GO 65409
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65267: LD_EXP 52
65271: PUSH
65272: LD_VAR 0 2
65276: ARRAY
65277: PPUSH
65278: LD_EXP 57
65282: PUSH
65283: LD_VAR 0 2
65287: ARRAY
65288: PUSH
65289: LD_INT 1
65291: ARRAY
65292: PUSH
65293: LD_INT 1
65295: ARRAY
65296: PPUSH
65297: LD_EXP 57
65301: PUSH
65302: LD_VAR 0 2
65306: ARRAY
65307: PUSH
65308: LD_INT 1
65310: ARRAY
65311: PUSH
65312: LD_INT 2
65314: ARRAY
65315: PPUSH
65316: LD_EXP 57
65320: PUSH
65321: LD_VAR 0 2
65325: ARRAY
65326: PUSH
65327: LD_INT 1
65329: ARRAY
65330: PUSH
65331: LD_INT 3
65333: ARRAY
65334: PPUSH
65335: LD_EXP 57
65339: PUSH
65340: LD_VAR 0 2
65344: ARRAY
65345: PUSH
65346: LD_INT 1
65348: ARRAY
65349: PUSH
65350: LD_INT 4
65352: ARRAY
65353: PPUSH
65354: CALL 24916 0 5
65358: NOT
65359: IFFALSE 65409
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65361: LD_ADDR_EXP 57
65365: PUSH
65366: LD_EXP 57
65370: PPUSH
65371: LD_VAR 0 2
65375: PPUSH
65376: LD_EXP 57
65380: PUSH
65381: LD_VAR 0 2
65385: ARRAY
65386: PPUSH
65387: LD_INT 1
65389: PPUSH
65390: LD_INT 1
65392: NEG
65393: PPUSH
65394: LD_INT 0
65396: PPUSH
65397: CALL 17583 0 4
65401: PPUSH
65402: CALL_OW 1
65406: ST_TO_ADDR
// continue ;
65407: GO 64285
// end ; end ; end ;
65409: GO 64285
65411: POP
65412: POP
// end ;
65413: LD_VAR 0 1
65417: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65418: LD_INT 0
65420: PPUSH
65421: PPUSH
65422: PPUSH
65423: PPUSH
65424: PPUSH
65425: PPUSH
// if not mc_bases then
65426: LD_EXP 52
65430: NOT
65431: IFFALSE 65435
// exit ;
65433: GO 65862
// for i = 1 to mc_bases do
65435: LD_ADDR_VAR 0 2
65439: PUSH
65440: DOUBLE
65441: LD_INT 1
65443: DEC
65444: ST_TO_ADDR
65445: LD_EXP 52
65449: PUSH
65450: FOR_TO
65451: IFFALSE 65860
// begin tmp := mc_build_upgrade [ i ] ;
65453: LD_ADDR_VAR 0 4
65457: PUSH
65458: LD_EXP 84
65462: PUSH
65463: LD_VAR 0 2
65467: ARRAY
65468: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65469: LD_ADDR_VAR 0 6
65473: PUSH
65474: LD_EXP 85
65478: PUSH
65479: LD_VAR 0 2
65483: ARRAY
65484: PPUSH
65485: LD_INT 2
65487: PUSH
65488: LD_INT 30
65490: PUSH
65491: LD_INT 6
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 30
65500: PUSH
65501: LD_INT 7
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: LIST
65512: PPUSH
65513: CALL_OW 72
65517: ST_TO_ADDR
// if not tmp and not lab then
65518: LD_VAR 0 4
65522: NOT
65523: PUSH
65524: LD_VAR 0 6
65528: NOT
65529: AND
65530: IFFALSE 65534
// continue ;
65532: GO 65450
// if tmp then
65534: LD_VAR 0 4
65538: IFFALSE 65658
// for j in tmp do
65540: LD_ADDR_VAR 0 3
65544: PUSH
65545: LD_VAR 0 4
65549: PUSH
65550: FOR_IN
65551: IFFALSE 65656
// begin if UpgradeCost ( j ) then
65553: LD_VAR 0 3
65557: PPUSH
65558: CALL 24576 0 1
65562: IFFALSE 65654
// begin ComUpgrade ( j ) ;
65564: LD_VAR 0 3
65568: PPUSH
65569: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65573: LD_ADDR_EXP 84
65577: PUSH
65578: LD_EXP 84
65582: PPUSH
65583: LD_VAR 0 2
65587: PPUSH
65588: LD_EXP 84
65592: PUSH
65593: LD_VAR 0 2
65597: ARRAY
65598: PUSH
65599: LD_VAR 0 3
65603: DIFF
65604: PPUSH
65605: CALL_OW 1
65609: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65610: LD_ADDR_EXP 59
65614: PUSH
65615: LD_EXP 59
65619: PPUSH
65620: LD_VAR 0 2
65624: PUSH
65625: LD_EXP 59
65629: PUSH
65630: LD_VAR 0 2
65634: ARRAY
65635: PUSH
65636: LD_INT 1
65638: PLUS
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PPUSH
65644: LD_VAR 0 3
65648: PPUSH
65649: CALL 18165 0 3
65653: ST_TO_ADDR
// end ; end ;
65654: GO 65550
65656: POP
65657: POP
// if not lab or not mc_lab_upgrade [ i ] then
65658: LD_VAR 0 6
65662: NOT
65663: PUSH
65664: LD_EXP 86
65668: PUSH
65669: LD_VAR 0 2
65673: ARRAY
65674: NOT
65675: OR
65676: IFFALSE 65680
// continue ;
65678: GO 65450
// for j in lab do
65680: LD_ADDR_VAR 0 3
65684: PUSH
65685: LD_VAR 0 6
65689: PUSH
65690: FOR_IN
65691: IFFALSE 65856
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65693: LD_VAR 0 3
65697: PPUSH
65698: CALL_OW 266
65702: PUSH
65703: LD_INT 6
65705: PUSH
65706: LD_INT 7
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: IN
65713: PUSH
65714: LD_VAR 0 3
65718: PPUSH
65719: CALL_OW 461
65723: PUSH
65724: LD_INT 1
65726: NONEQUAL
65727: AND
65728: IFFALSE 65854
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65730: LD_VAR 0 3
65734: PPUSH
65735: LD_EXP 86
65739: PUSH
65740: LD_VAR 0 2
65744: ARRAY
65745: PUSH
65746: LD_INT 1
65748: ARRAY
65749: PPUSH
65750: CALL 24781 0 2
65754: IFFALSE 65854
// begin ComCancel ( j ) ;
65756: LD_VAR 0 3
65760: PPUSH
65761: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65765: LD_VAR 0 3
65769: PPUSH
65770: LD_EXP 86
65774: PUSH
65775: LD_VAR 0 2
65779: ARRAY
65780: PUSH
65781: LD_INT 1
65783: ARRAY
65784: PPUSH
65785: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65789: LD_VAR 0 3
65793: PUSH
65794: LD_EXP 59
65798: PUSH
65799: LD_VAR 0 2
65803: ARRAY
65804: IN
65805: NOT
65806: IFFALSE 65852
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65808: LD_ADDR_EXP 59
65812: PUSH
65813: LD_EXP 59
65817: PPUSH
65818: LD_VAR 0 2
65822: PUSH
65823: LD_EXP 59
65827: PUSH
65828: LD_VAR 0 2
65832: ARRAY
65833: PUSH
65834: LD_INT 1
65836: PLUS
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PPUSH
65842: LD_VAR 0 3
65846: PPUSH
65847: CALL 18165 0 3
65851: ST_TO_ADDR
// break ;
65852: GO 65856
// end ; end ; end ;
65854: GO 65690
65856: POP
65857: POP
// end ;
65858: GO 65450
65860: POP
65861: POP
// end ;
65862: LD_VAR 0 1
65866: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65867: LD_INT 0
65869: PPUSH
65870: PPUSH
65871: PPUSH
65872: PPUSH
65873: PPUSH
65874: PPUSH
65875: PPUSH
65876: PPUSH
65877: PPUSH
// if not mc_bases then
65878: LD_EXP 52
65882: NOT
65883: IFFALSE 65887
// exit ;
65885: GO 66292
// for i = 1 to mc_bases do
65887: LD_ADDR_VAR 0 2
65891: PUSH
65892: DOUBLE
65893: LD_INT 1
65895: DEC
65896: ST_TO_ADDR
65897: LD_EXP 52
65901: PUSH
65902: FOR_TO
65903: IFFALSE 66290
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65905: LD_EXP 60
65909: PUSH
65910: LD_VAR 0 2
65914: ARRAY
65915: NOT
65916: PUSH
65917: LD_EXP 52
65921: PUSH
65922: LD_VAR 0 2
65926: ARRAY
65927: PPUSH
65928: LD_INT 30
65930: PUSH
65931: LD_INT 3
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PPUSH
65938: CALL_OW 72
65942: NOT
65943: OR
65944: IFFALSE 65948
// continue ;
65946: GO 65902
// busy := false ;
65948: LD_ADDR_VAR 0 8
65952: PUSH
65953: LD_INT 0
65955: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65956: LD_ADDR_VAR 0 4
65960: PUSH
65961: LD_EXP 52
65965: PUSH
65966: LD_VAR 0 2
65970: ARRAY
65971: PPUSH
65972: LD_INT 30
65974: PUSH
65975: LD_INT 3
65977: PUSH
65978: EMPTY
65979: LIST
65980: LIST
65981: PPUSH
65982: CALL_OW 72
65986: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65987: LD_ADDR_VAR 0 6
65991: PUSH
65992: LD_EXP 60
65996: PUSH
65997: LD_VAR 0 2
66001: ARRAY
66002: PPUSH
66003: LD_INT 2
66005: PUSH
66006: LD_INT 30
66008: PUSH
66009: LD_INT 32
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 30
66018: PUSH
66019: LD_INT 33
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: LIST
66030: PPUSH
66031: CALL_OW 72
66035: ST_TO_ADDR
// if not t then
66036: LD_VAR 0 6
66040: NOT
66041: IFFALSE 66045
// continue ;
66043: GO 65902
// for j in tmp do
66045: LD_ADDR_VAR 0 3
66049: PUSH
66050: LD_VAR 0 4
66054: PUSH
66055: FOR_IN
66056: IFFALSE 66086
// if not BuildingStatus ( j ) = bs_idle then
66058: LD_VAR 0 3
66062: PPUSH
66063: CALL_OW 461
66067: PUSH
66068: LD_INT 2
66070: EQUAL
66071: NOT
66072: IFFALSE 66084
// begin busy := true ;
66074: LD_ADDR_VAR 0 8
66078: PUSH
66079: LD_INT 1
66081: ST_TO_ADDR
// break ;
66082: GO 66086
// end ;
66084: GO 66055
66086: POP
66087: POP
// if busy then
66088: LD_VAR 0 8
66092: IFFALSE 66096
// continue ;
66094: GO 65902
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66096: LD_ADDR_VAR 0 7
66100: PUSH
66101: LD_VAR 0 6
66105: PPUSH
66106: LD_INT 35
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PPUSH
66116: CALL_OW 72
66120: ST_TO_ADDR
// if tw then
66121: LD_VAR 0 7
66125: IFFALSE 66202
// begin tw := tw [ 1 ] ;
66127: LD_ADDR_VAR 0 7
66131: PUSH
66132: LD_VAR 0 7
66136: PUSH
66137: LD_INT 1
66139: ARRAY
66140: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66141: LD_ADDR_VAR 0 9
66145: PUSH
66146: LD_VAR 0 7
66150: PPUSH
66151: LD_EXP 77
66155: PUSH
66156: LD_VAR 0 2
66160: ARRAY
66161: PPUSH
66162: CALL 23135 0 2
66166: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66167: LD_EXP 91
66171: PUSH
66172: LD_VAR 0 2
66176: ARRAY
66177: IFFALSE 66200
// if not weapon in mc_allowed_tower_weapons [ i ] then
66179: LD_VAR 0 9
66183: PUSH
66184: LD_EXP 91
66188: PUSH
66189: LD_VAR 0 2
66193: ARRAY
66194: IN
66195: NOT
66196: IFFALSE 66200
// continue ;
66198: GO 65902
// end else
66200: GO 66265
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66202: LD_ADDR_VAR 0 5
66206: PUSH
66207: LD_EXP 60
66211: PUSH
66212: LD_VAR 0 2
66216: ARRAY
66217: PPUSH
66218: LD_VAR 0 4
66222: PPUSH
66223: CALL 53336 0 2
66227: ST_TO_ADDR
// if not tmp2 then
66228: LD_VAR 0 5
66232: NOT
66233: IFFALSE 66237
// continue ;
66235: GO 65902
// tw := tmp2 [ 1 ] ;
66237: LD_ADDR_VAR 0 7
66241: PUSH
66242: LD_VAR 0 5
66246: PUSH
66247: LD_INT 1
66249: ARRAY
66250: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66251: LD_ADDR_VAR 0 9
66255: PUSH
66256: LD_VAR 0 5
66260: PUSH
66261: LD_INT 2
66263: ARRAY
66264: ST_TO_ADDR
// end ; if not weapon then
66265: LD_VAR 0 9
66269: NOT
66270: IFFALSE 66274
// continue ;
66272: GO 65902
// ComPlaceWeapon ( tw , weapon ) ;
66274: LD_VAR 0 7
66278: PPUSH
66279: LD_VAR 0 9
66283: PPUSH
66284: CALL_OW 148
// end ;
66288: GO 65902
66290: POP
66291: POP
// end ;
66292: LD_VAR 0 1
66296: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66297: LD_INT 0
66299: PPUSH
66300: PPUSH
66301: PPUSH
66302: PPUSH
66303: PPUSH
66304: PPUSH
// if not mc_bases then
66305: LD_EXP 52
66309: NOT
66310: IFFALSE 66314
// exit ;
66312: GO 67326
// for i = 1 to mc_bases do
66314: LD_ADDR_VAR 0 2
66318: PUSH
66319: DOUBLE
66320: LD_INT 1
66322: DEC
66323: ST_TO_ADDR
66324: LD_EXP 52
66328: PUSH
66329: FOR_TO
66330: IFFALSE 67324
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66332: LD_EXP 65
66336: PUSH
66337: LD_VAR 0 2
66341: ARRAY
66342: NOT
66343: PUSH
66344: LD_EXP 65
66348: PUSH
66349: LD_VAR 0 2
66353: ARRAY
66354: PUSH
66355: LD_EXP 66
66359: PUSH
66360: LD_VAR 0 2
66364: ARRAY
66365: EQUAL
66366: OR
66367: IFFALSE 66371
// continue ;
66369: GO 66329
// if mc_miners [ i ] then
66371: LD_EXP 66
66375: PUSH
66376: LD_VAR 0 2
66380: ARRAY
66381: IFFALSE 67011
// begin k := 1 ;
66383: LD_ADDR_VAR 0 4
66387: PUSH
66388: LD_INT 1
66390: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66391: LD_ADDR_VAR 0 3
66395: PUSH
66396: DOUBLE
66397: LD_EXP 66
66401: PUSH
66402: LD_VAR 0 2
66406: ARRAY
66407: INC
66408: ST_TO_ADDR
66409: LD_INT 1
66411: PUSH
66412: FOR_DOWNTO
66413: IFFALSE 67009
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66415: LD_EXP 66
66419: PUSH
66420: LD_VAR 0 2
66424: ARRAY
66425: PUSH
66426: LD_VAR 0 3
66430: ARRAY
66431: PPUSH
66432: CALL_OW 301
66436: PUSH
66437: LD_EXP 66
66441: PUSH
66442: LD_VAR 0 2
66446: ARRAY
66447: PUSH
66448: LD_VAR 0 3
66452: ARRAY
66453: PPUSH
66454: CALL_OW 257
66458: PUSH
66459: LD_INT 1
66461: NONEQUAL
66462: OR
66463: IFFALSE 66526
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66465: LD_ADDR_VAR 0 5
66469: PUSH
66470: LD_EXP 66
66474: PUSH
66475: LD_VAR 0 2
66479: ARRAY
66480: PUSH
66481: LD_EXP 66
66485: PUSH
66486: LD_VAR 0 2
66490: ARRAY
66491: PUSH
66492: LD_VAR 0 3
66496: ARRAY
66497: DIFF
66498: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66499: LD_ADDR_EXP 66
66503: PUSH
66504: LD_EXP 66
66508: PPUSH
66509: LD_VAR 0 2
66513: PPUSH
66514: LD_VAR 0 5
66518: PPUSH
66519: CALL_OW 1
66523: ST_TO_ADDR
// continue ;
66524: GO 66412
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66526: LD_EXP 66
66530: PUSH
66531: LD_VAR 0 2
66535: ARRAY
66536: PUSH
66537: LD_VAR 0 3
66541: ARRAY
66542: PPUSH
66543: CALL 18101 0 1
66547: PUSH
66548: LD_EXP 66
66552: PUSH
66553: LD_VAR 0 2
66557: ARRAY
66558: PUSH
66559: LD_VAR 0 3
66563: ARRAY
66564: PPUSH
66565: CALL_OW 255
66569: PPUSH
66570: LD_EXP 65
66574: PUSH
66575: LD_VAR 0 2
66579: ARRAY
66580: PUSH
66581: LD_VAR 0 4
66585: ARRAY
66586: PUSH
66587: LD_INT 1
66589: ARRAY
66590: PPUSH
66591: LD_EXP 65
66595: PUSH
66596: LD_VAR 0 2
66600: ARRAY
66601: PUSH
66602: LD_VAR 0 4
66606: ARRAY
66607: PUSH
66608: LD_INT 2
66610: ARRAY
66611: PPUSH
66612: LD_INT 15
66614: PPUSH
66615: CALL 19061 0 4
66619: PUSH
66620: LD_INT 4
66622: ARRAY
66623: PUSH
66624: LD_EXP 66
66628: PUSH
66629: LD_VAR 0 2
66633: ARRAY
66634: PUSH
66635: LD_VAR 0 3
66639: ARRAY
66640: PPUSH
66641: LD_INT 10
66643: PPUSH
66644: CALL 20758 0 2
66648: PUSH
66649: LD_INT 4
66651: ARRAY
66652: OR
66653: AND
66654: IFFALSE 66677
// ComStop ( mc_miners [ i ] [ j ] ) ;
66656: LD_EXP 66
66660: PUSH
66661: LD_VAR 0 2
66665: ARRAY
66666: PUSH
66667: LD_VAR 0 3
66671: ARRAY
66672: PPUSH
66673: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66677: LD_EXP 66
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: PUSH
66688: LD_VAR 0 3
66692: ARRAY
66693: PPUSH
66694: CALL_OW 257
66698: PUSH
66699: LD_INT 1
66701: EQUAL
66702: PUSH
66703: LD_EXP 66
66707: PUSH
66708: LD_VAR 0 2
66712: ARRAY
66713: PUSH
66714: LD_VAR 0 3
66718: ARRAY
66719: PPUSH
66720: CALL_OW 459
66724: NOT
66725: AND
66726: PUSH
66727: LD_EXP 66
66731: PUSH
66732: LD_VAR 0 2
66736: ARRAY
66737: PUSH
66738: LD_VAR 0 3
66742: ARRAY
66743: PPUSH
66744: CALL_OW 255
66748: PPUSH
66749: LD_EXP 65
66753: PUSH
66754: LD_VAR 0 2
66758: ARRAY
66759: PUSH
66760: LD_VAR 0 4
66764: ARRAY
66765: PUSH
66766: LD_INT 1
66768: ARRAY
66769: PPUSH
66770: LD_EXP 65
66774: PUSH
66775: LD_VAR 0 2
66779: ARRAY
66780: PUSH
66781: LD_VAR 0 4
66785: ARRAY
66786: PUSH
66787: LD_INT 2
66789: ARRAY
66790: PPUSH
66791: LD_INT 15
66793: PPUSH
66794: CALL 19061 0 4
66798: PUSH
66799: LD_INT 4
66801: ARRAY
66802: PUSH
66803: LD_INT 0
66805: EQUAL
66806: AND
66807: PUSH
66808: LD_EXP 66
66812: PUSH
66813: LD_VAR 0 2
66817: ARRAY
66818: PUSH
66819: LD_VAR 0 3
66823: ARRAY
66824: PPUSH
66825: CALL_OW 314
66829: NOT
66830: AND
66831: IFFALSE 67007
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66833: LD_EXP 66
66837: PUSH
66838: LD_VAR 0 2
66842: ARRAY
66843: PUSH
66844: LD_VAR 0 3
66848: ARRAY
66849: PPUSH
66850: CALL_OW 310
66854: IFFALSE 66877
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66856: LD_EXP 66
66860: PUSH
66861: LD_VAR 0 2
66865: ARRAY
66866: PUSH
66867: LD_VAR 0 3
66871: ARRAY
66872: PPUSH
66873: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66877: LD_EXP 66
66881: PUSH
66882: LD_VAR 0 2
66886: ARRAY
66887: PUSH
66888: LD_VAR 0 3
66892: ARRAY
66893: PPUSH
66894: CALL_OW 314
66898: NOT
66899: IFFALSE 66967
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
66901: LD_EXP 66
66905: PUSH
66906: LD_VAR 0 2
66910: ARRAY
66911: PUSH
66912: LD_VAR 0 3
66916: ARRAY
66917: PPUSH
66918: LD_EXP 65
66922: PUSH
66923: LD_VAR 0 2
66927: ARRAY
66928: PUSH
66929: LD_VAR 0 4
66933: ARRAY
66934: PUSH
66935: LD_INT 1
66937: ARRAY
66938: PPUSH
66939: LD_EXP 65
66943: PUSH
66944: LD_VAR 0 2
66948: ARRAY
66949: PUSH
66950: LD_VAR 0 4
66954: ARRAY
66955: PUSH
66956: LD_INT 2
66958: ARRAY
66959: PPUSH
66960: LD_INT 0
66962: PPUSH
66963: CALL_OW 193
// k := k + 1 ;
66967: LD_ADDR_VAR 0 4
66971: PUSH
66972: LD_VAR 0 4
66976: PUSH
66977: LD_INT 1
66979: PLUS
66980: ST_TO_ADDR
// if k > mc_mines [ i ] then
66981: LD_VAR 0 4
66985: PUSH
66986: LD_EXP 65
66990: PUSH
66991: LD_VAR 0 2
66995: ARRAY
66996: GREATER
66997: IFFALSE 67007
// k := 1 ;
66999: LD_ADDR_VAR 0 4
67003: PUSH
67004: LD_INT 1
67006: ST_TO_ADDR
// end ; end ;
67007: GO 66412
67009: POP
67010: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67011: LD_ADDR_VAR 0 5
67015: PUSH
67016: LD_EXP 52
67020: PUSH
67021: LD_VAR 0 2
67025: ARRAY
67026: PPUSH
67027: LD_INT 2
67029: PUSH
67030: LD_INT 30
67032: PUSH
67033: LD_INT 4
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 30
67042: PUSH
67043: LD_INT 5
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 30
67052: PUSH
67053: LD_INT 32
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: PPUSH
67066: CALL_OW 72
67070: ST_TO_ADDR
// if not tmp then
67071: LD_VAR 0 5
67075: NOT
67076: IFFALSE 67080
// continue ;
67078: GO 66329
// list := [ ] ;
67080: LD_ADDR_VAR 0 6
67084: PUSH
67085: EMPTY
67086: ST_TO_ADDR
// for j in tmp do
67087: LD_ADDR_VAR 0 3
67091: PUSH
67092: LD_VAR 0 5
67096: PUSH
67097: FOR_IN
67098: IFFALSE 67167
// begin for k in UnitsInside ( j ) do
67100: LD_ADDR_VAR 0 4
67104: PUSH
67105: LD_VAR 0 3
67109: PPUSH
67110: CALL_OW 313
67114: PUSH
67115: FOR_IN
67116: IFFALSE 67163
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67118: LD_VAR 0 4
67122: PPUSH
67123: CALL_OW 257
67127: PUSH
67128: LD_INT 1
67130: EQUAL
67131: PUSH
67132: LD_VAR 0 4
67136: PPUSH
67137: CALL_OW 459
67141: NOT
67142: AND
67143: IFFALSE 67161
// list := list ^ k ;
67145: LD_ADDR_VAR 0 6
67149: PUSH
67150: LD_VAR 0 6
67154: PUSH
67155: LD_VAR 0 4
67159: ADD
67160: ST_TO_ADDR
67161: GO 67115
67163: POP
67164: POP
// end ;
67165: GO 67097
67167: POP
67168: POP
// list := list diff mc_miners [ i ] ;
67169: LD_ADDR_VAR 0 6
67173: PUSH
67174: LD_VAR 0 6
67178: PUSH
67179: LD_EXP 66
67183: PUSH
67184: LD_VAR 0 2
67188: ARRAY
67189: DIFF
67190: ST_TO_ADDR
// if not list then
67191: LD_VAR 0 6
67195: NOT
67196: IFFALSE 67200
// continue ;
67198: GO 66329
// k := mc_mines [ i ] - mc_miners [ i ] ;
67200: LD_ADDR_VAR 0 4
67204: PUSH
67205: LD_EXP 65
67209: PUSH
67210: LD_VAR 0 2
67214: ARRAY
67215: PUSH
67216: LD_EXP 66
67220: PUSH
67221: LD_VAR 0 2
67225: ARRAY
67226: MINUS
67227: ST_TO_ADDR
// if k > list then
67228: LD_VAR 0 4
67232: PUSH
67233: LD_VAR 0 6
67237: GREATER
67238: IFFALSE 67250
// k := list ;
67240: LD_ADDR_VAR 0 4
67244: PUSH
67245: LD_VAR 0 6
67249: ST_TO_ADDR
// for j = 1 to k do
67250: LD_ADDR_VAR 0 3
67254: PUSH
67255: DOUBLE
67256: LD_INT 1
67258: DEC
67259: ST_TO_ADDR
67260: LD_VAR 0 4
67264: PUSH
67265: FOR_TO
67266: IFFALSE 67320
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67268: LD_ADDR_EXP 66
67272: PUSH
67273: LD_EXP 66
67277: PPUSH
67278: LD_VAR 0 2
67282: PUSH
67283: LD_EXP 66
67287: PUSH
67288: LD_VAR 0 2
67292: ARRAY
67293: PUSH
67294: LD_INT 1
67296: PLUS
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PPUSH
67302: LD_VAR 0 6
67306: PUSH
67307: LD_VAR 0 3
67311: ARRAY
67312: PPUSH
67313: CALL 18165 0 3
67317: ST_TO_ADDR
67318: GO 67265
67320: POP
67321: POP
// end ;
67322: GO 66329
67324: POP
67325: POP
// end ;
67326: LD_VAR 0 1
67330: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67331: LD_INT 0
67333: PPUSH
67334: PPUSH
67335: PPUSH
67336: PPUSH
67337: PPUSH
67338: PPUSH
67339: PPUSH
67340: PPUSH
67341: PPUSH
67342: PPUSH
// if not mc_bases then
67343: LD_EXP 52
67347: NOT
67348: IFFALSE 67352
// exit ;
67350: GO 69102
// for i = 1 to mc_bases do
67352: LD_ADDR_VAR 0 2
67356: PUSH
67357: DOUBLE
67358: LD_INT 1
67360: DEC
67361: ST_TO_ADDR
67362: LD_EXP 52
67366: PUSH
67367: FOR_TO
67368: IFFALSE 69100
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67370: LD_EXP 52
67374: PUSH
67375: LD_VAR 0 2
67379: ARRAY
67380: NOT
67381: PUSH
67382: LD_EXP 59
67386: PUSH
67387: LD_VAR 0 2
67391: ARRAY
67392: OR
67393: IFFALSE 67397
// continue ;
67395: GO 67367
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67397: LD_EXP 68
67401: PUSH
67402: LD_VAR 0 2
67406: ARRAY
67407: NOT
67408: PUSH
67409: LD_EXP 69
67413: PUSH
67414: LD_VAR 0 2
67418: ARRAY
67419: AND
67420: IFFALSE 67458
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67422: LD_ADDR_EXP 69
67426: PUSH
67427: LD_EXP 69
67431: PPUSH
67432: LD_VAR 0 2
67436: PPUSH
67437: EMPTY
67438: PPUSH
67439: CALL_OW 1
67443: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67444: LD_VAR 0 2
67448: PPUSH
67449: LD_INT 107
67451: PPUSH
67452: CALL 58212 0 2
// continue ;
67456: GO 67367
// end ; target := [ ] ;
67458: LD_ADDR_VAR 0 6
67462: PUSH
67463: EMPTY
67464: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67465: LD_ADDR_VAR 0 3
67469: PUSH
67470: DOUBLE
67471: LD_EXP 68
67475: PUSH
67476: LD_VAR 0 2
67480: ARRAY
67481: INC
67482: ST_TO_ADDR
67483: LD_INT 1
67485: PUSH
67486: FOR_DOWNTO
67487: IFFALSE 67747
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67489: LD_EXP 68
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PUSH
67500: LD_VAR 0 3
67504: ARRAY
67505: PUSH
67506: LD_INT 2
67508: ARRAY
67509: PPUSH
67510: LD_EXP 68
67514: PUSH
67515: LD_VAR 0 2
67519: ARRAY
67520: PUSH
67521: LD_VAR 0 3
67525: ARRAY
67526: PUSH
67527: LD_INT 3
67529: ARRAY
67530: PPUSH
67531: CALL_OW 488
67535: PUSH
67536: LD_EXP 68
67540: PUSH
67541: LD_VAR 0 2
67545: ARRAY
67546: PUSH
67547: LD_VAR 0 3
67551: ARRAY
67552: PUSH
67553: LD_INT 2
67555: ARRAY
67556: PPUSH
67557: LD_EXP 68
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: PUSH
67568: LD_VAR 0 3
67572: ARRAY
67573: PUSH
67574: LD_INT 3
67576: ARRAY
67577: PPUSH
67578: CALL_OW 284
67582: PUSH
67583: LD_INT 0
67585: EQUAL
67586: AND
67587: IFFALSE 67642
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67589: LD_ADDR_VAR 0 5
67593: PUSH
67594: LD_EXP 68
67598: PUSH
67599: LD_VAR 0 2
67603: ARRAY
67604: PPUSH
67605: LD_VAR 0 3
67609: PPUSH
67610: CALL_OW 3
67614: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67615: LD_ADDR_EXP 68
67619: PUSH
67620: LD_EXP 68
67624: PPUSH
67625: LD_VAR 0 2
67629: PPUSH
67630: LD_VAR 0 5
67634: PPUSH
67635: CALL_OW 1
67639: ST_TO_ADDR
// continue ;
67640: GO 67486
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67642: LD_EXP 52
67646: PUSH
67647: LD_VAR 0 2
67651: ARRAY
67652: PUSH
67653: LD_INT 1
67655: ARRAY
67656: PPUSH
67657: CALL_OW 255
67661: PPUSH
67662: LD_EXP 68
67666: PUSH
67667: LD_VAR 0 2
67671: ARRAY
67672: PUSH
67673: LD_VAR 0 3
67677: ARRAY
67678: PUSH
67679: LD_INT 2
67681: ARRAY
67682: PPUSH
67683: LD_EXP 68
67687: PUSH
67688: LD_VAR 0 2
67692: ARRAY
67693: PUSH
67694: LD_VAR 0 3
67698: ARRAY
67699: PUSH
67700: LD_INT 3
67702: ARRAY
67703: PPUSH
67704: LD_INT 30
67706: PPUSH
67707: CALL 19061 0 4
67711: PUSH
67712: LD_INT 4
67714: ARRAY
67715: PUSH
67716: LD_INT 0
67718: EQUAL
67719: IFFALSE 67745
// begin target := mc_crates [ i ] [ j ] ;
67721: LD_ADDR_VAR 0 6
67725: PUSH
67726: LD_EXP 68
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_VAR 0 3
67741: ARRAY
67742: ST_TO_ADDR
// break ;
67743: GO 67747
// end ; end ;
67745: GO 67486
67747: POP
67748: POP
// if not target then
67749: LD_VAR 0 6
67753: NOT
67754: IFFALSE 67758
// continue ;
67756: GO 67367
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67758: LD_ADDR_VAR 0 7
67762: PUSH
67763: LD_EXP 71
67767: PUSH
67768: LD_VAR 0 2
67772: ARRAY
67773: PPUSH
67774: LD_INT 2
67776: PUSH
67777: LD_INT 3
67779: PUSH
67780: LD_INT 58
67782: PUSH
67783: EMPTY
67784: LIST
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PUSH
67790: LD_INT 61
67792: PUSH
67793: EMPTY
67794: LIST
67795: PUSH
67796: LD_INT 33
67798: PUSH
67799: LD_INT 5
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 33
67808: PUSH
67809: LD_INT 3
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: LD_INT 34
67828: PUSH
67829: LD_INT 32
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 34
67838: PUSH
67839: LD_INT 51
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 34
67848: PUSH
67849: LD_INT 12
67851: PUSH
67852: EMPTY
67853: LIST
67854: LIST
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PPUSH
67866: CALL_OW 72
67870: ST_TO_ADDR
// if not cargo then
67871: LD_VAR 0 7
67875: NOT
67876: IFFALSE 68519
// begin if mc_crates_collector [ i ] < 5 then
67878: LD_EXP 69
67882: PUSH
67883: LD_VAR 0 2
67887: ARRAY
67888: PUSH
67889: LD_INT 5
67891: LESS
67892: IFFALSE 68258
// begin if mc_ape [ i ] then
67894: LD_EXP 81
67898: PUSH
67899: LD_VAR 0 2
67903: ARRAY
67904: IFFALSE 67951
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67906: LD_ADDR_VAR 0 5
67910: PUSH
67911: LD_EXP 81
67915: PUSH
67916: LD_VAR 0 2
67920: ARRAY
67921: PPUSH
67922: LD_INT 25
67924: PUSH
67925: LD_INT 16
67927: PUSH
67928: EMPTY
67929: LIST
67930: LIST
67931: PUSH
67932: LD_INT 24
67934: PUSH
67935: LD_INT 750
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: PPUSH
67946: CALL_OW 72
67950: ST_TO_ADDR
// if not tmp then
67951: LD_VAR 0 5
67955: NOT
67956: IFFALSE 68003
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67958: LD_ADDR_VAR 0 5
67962: PUSH
67963: LD_EXP 52
67967: PUSH
67968: LD_VAR 0 2
67972: ARRAY
67973: PPUSH
67974: LD_INT 25
67976: PUSH
67977: LD_INT 2
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 24
67986: PUSH
67987: LD_INT 750
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: PPUSH
67998: CALL_OW 72
68002: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68003: LD_EXP 81
68007: PUSH
68008: LD_VAR 0 2
68012: ARRAY
68013: PUSH
68014: LD_EXP 52
68018: PUSH
68019: LD_VAR 0 2
68023: ARRAY
68024: PPUSH
68025: LD_INT 25
68027: PUSH
68028: LD_INT 2
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 24
68037: PUSH
68038: LD_INT 750
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PPUSH
68049: CALL_OW 72
68053: AND
68054: PUSH
68055: LD_VAR 0 5
68059: PUSH
68060: LD_INT 5
68062: LESS
68063: AND
68064: IFFALSE 68146
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68066: LD_ADDR_VAR 0 3
68070: PUSH
68071: LD_EXP 52
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: PPUSH
68082: LD_INT 25
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 24
68094: PUSH
68095: LD_INT 750
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: PPUSH
68106: CALL_OW 72
68110: PUSH
68111: FOR_IN
68112: IFFALSE 68144
// begin tmp := tmp union j ;
68114: LD_ADDR_VAR 0 5
68118: PUSH
68119: LD_VAR 0 5
68123: PUSH
68124: LD_VAR 0 3
68128: UNION
68129: ST_TO_ADDR
// if tmp >= 5 then
68130: LD_VAR 0 5
68134: PUSH
68135: LD_INT 5
68137: GREATEREQUAL
68138: IFFALSE 68142
// break ;
68140: GO 68144
// end ;
68142: GO 68111
68144: POP
68145: POP
// end ; if not tmp then
68146: LD_VAR 0 5
68150: NOT
68151: IFFALSE 68155
// continue ;
68153: GO 67367
// for j in tmp do
68155: LD_ADDR_VAR 0 3
68159: PUSH
68160: LD_VAR 0 5
68164: PUSH
68165: FOR_IN
68166: IFFALSE 68256
// if not GetTag ( j ) then
68168: LD_VAR 0 3
68172: PPUSH
68173: CALL_OW 110
68177: NOT
68178: IFFALSE 68254
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68180: LD_ADDR_EXP 69
68184: PUSH
68185: LD_EXP 69
68189: PPUSH
68190: LD_VAR 0 2
68194: PUSH
68195: LD_EXP 69
68199: PUSH
68200: LD_VAR 0 2
68204: ARRAY
68205: PUSH
68206: LD_INT 1
68208: PLUS
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PPUSH
68214: LD_VAR 0 3
68218: PPUSH
68219: CALL 18165 0 3
68223: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68224: LD_VAR 0 3
68228: PPUSH
68229: LD_INT 107
68231: PPUSH
68232: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68236: LD_EXP 69
68240: PUSH
68241: LD_VAR 0 2
68245: ARRAY
68246: PUSH
68247: LD_INT 5
68249: GREATEREQUAL
68250: IFFALSE 68254
// break ;
68252: GO 68256
// end ;
68254: GO 68165
68256: POP
68257: POP
// end ; if mc_crates_collector [ i ] and target then
68258: LD_EXP 69
68262: PUSH
68263: LD_VAR 0 2
68267: ARRAY
68268: PUSH
68269: LD_VAR 0 6
68273: AND
68274: IFFALSE 68517
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68276: LD_EXP 69
68280: PUSH
68281: LD_VAR 0 2
68285: ARRAY
68286: PUSH
68287: LD_VAR 0 6
68291: PUSH
68292: LD_INT 1
68294: ARRAY
68295: LESS
68296: IFFALSE 68316
// tmp := mc_crates_collector [ i ] else
68298: LD_ADDR_VAR 0 5
68302: PUSH
68303: LD_EXP 69
68307: PUSH
68308: LD_VAR 0 2
68312: ARRAY
68313: ST_TO_ADDR
68314: GO 68330
// tmp := target [ 1 ] ;
68316: LD_ADDR_VAR 0 5
68320: PUSH
68321: LD_VAR 0 6
68325: PUSH
68326: LD_INT 1
68328: ARRAY
68329: ST_TO_ADDR
// k := 0 ;
68330: LD_ADDR_VAR 0 4
68334: PUSH
68335: LD_INT 0
68337: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68338: LD_ADDR_VAR 0 3
68342: PUSH
68343: LD_EXP 69
68347: PUSH
68348: LD_VAR 0 2
68352: ARRAY
68353: PUSH
68354: FOR_IN
68355: IFFALSE 68515
// begin k := k + 1 ;
68357: LD_ADDR_VAR 0 4
68361: PUSH
68362: LD_VAR 0 4
68366: PUSH
68367: LD_INT 1
68369: PLUS
68370: ST_TO_ADDR
// if k > tmp then
68371: LD_VAR 0 4
68375: PUSH
68376: LD_VAR 0 5
68380: GREATER
68381: IFFALSE 68385
// break ;
68383: GO 68515
// if not GetClass ( j ) in [ 2 , 16 ] then
68385: LD_VAR 0 3
68389: PPUSH
68390: CALL_OW 257
68394: PUSH
68395: LD_INT 2
68397: PUSH
68398: LD_INT 16
68400: PUSH
68401: EMPTY
68402: LIST
68403: LIST
68404: IN
68405: NOT
68406: IFFALSE 68459
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68408: LD_ADDR_EXP 69
68412: PUSH
68413: LD_EXP 69
68417: PPUSH
68418: LD_VAR 0 2
68422: PPUSH
68423: LD_EXP 69
68427: PUSH
68428: LD_VAR 0 2
68432: ARRAY
68433: PUSH
68434: LD_VAR 0 3
68438: DIFF
68439: PPUSH
68440: CALL_OW 1
68444: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68445: LD_VAR 0 3
68449: PPUSH
68450: LD_INT 0
68452: PPUSH
68453: CALL_OW 109
// continue ;
68457: GO 68354
// end ; if IsInUnit ( j ) then
68459: LD_VAR 0 3
68463: PPUSH
68464: CALL_OW 310
68468: IFFALSE 68479
// ComExitBuilding ( j ) ;
68470: LD_VAR 0 3
68474: PPUSH
68475: CALL_OW 122
// wait ( 3 ) ;
68479: LD_INT 3
68481: PPUSH
68482: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68486: LD_VAR 0 3
68490: PPUSH
68491: LD_VAR 0 6
68495: PUSH
68496: LD_INT 2
68498: ARRAY
68499: PPUSH
68500: LD_VAR 0 6
68504: PUSH
68505: LD_INT 3
68507: ARRAY
68508: PPUSH
68509: CALL_OW 117
// end ;
68513: GO 68354
68515: POP
68516: POP
// end ; end else
68517: GO 69098
// begin for j in cargo do
68519: LD_ADDR_VAR 0 3
68523: PUSH
68524: LD_VAR 0 7
68528: PUSH
68529: FOR_IN
68530: IFFALSE 69096
// begin if GetTag ( j ) <> 0 then
68532: LD_VAR 0 3
68536: PPUSH
68537: CALL_OW 110
68541: PUSH
68542: LD_INT 0
68544: NONEQUAL
68545: IFFALSE 68549
// continue ;
68547: GO 68529
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68549: LD_VAR 0 3
68553: PPUSH
68554: CALL_OW 256
68558: PUSH
68559: LD_INT 1000
68561: LESS
68562: PUSH
68563: LD_VAR 0 3
68567: PPUSH
68568: LD_EXP 76
68572: PUSH
68573: LD_VAR 0 2
68577: ARRAY
68578: PPUSH
68579: CALL_OW 308
68583: NOT
68584: AND
68585: IFFALSE 68607
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68587: LD_VAR 0 3
68591: PPUSH
68592: LD_EXP 76
68596: PUSH
68597: LD_VAR 0 2
68601: ARRAY
68602: PPUSH
68603: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68607: LD_VAR 0 3
68611: PPUSH
68612: CALL_OW 256
68616: PUSH
68617: LD_INT 1000
68619: LESS
68620: PUSH
68621: LD_VAR 0 3
68625: PPUSH
68626: LD_EXP 76
68630: PUSH
68631: LD_VAR 0 2
68635: ARRAY
68636: PPUSH
68637: CALL_OW 308
68641: AND
68642: IFFALSE 68646
// continue ;
68644: GO 68529
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68646: LD_VAR 0 3
68650: PPUSH
68651: CALL_OW 262
68655: PUSH
68656: LD_INT 2
68658: EQUAL
68659: PUSH
68660: LD_VAR 0 3
68664: PPUSH
68665: CALL_OW 261
68669: PUSH
68670: LD_INT 15
68672: LESS
68673: AND
68674: IFFALSE 68678
// continue ;
68676: GO 68529
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68678: LD_VAR 0 3
68682: PPUSH
68683: CALL_OW 262
68687: PUSH
68688: LD_INT 1
68690: EQUAL
68691: PUSH
68692: LD_VAR 0 3
68696: PPUSH
68697: CALL_OW 261
68701: PUSH
68702: LD_INT 10
68704: LESS
68705: AND
68706: IFFALSE 69035
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68708: LD_ADDR_VAR 0 8
68712: PUSH
68713: LD_EXP 52
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: PPUSH
68724: LD_INT 2
68726: PUSH
68727: LD_INT 30
68729: PUSH
68730: LD_INT 0
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 30
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: LIST
68751: PPUSH
68752: CALL_OW 72
68756: ST_TO_ADDR
// if not depot then
68757: LD_VAR 0 8
68761: NOT
68762: IFFALSE 68766
// continue ;
68764: GO 68529
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68766: LD_VAR 0 3
68770: PPUSH
68771: LD_VAR 0 8
68775: PPUSH
68776: LD_VAR 0 3
68780: PPUSH
68781: CALL_OW 74
68785: PPUSH
68786: CALL_OW 296
68790: PUSH
68791: LD_INT 6
68793: LESS
68794: IFFALSE 68810
// SetFuel ( j , 100 ) else
68796: LD_VAR 0 3
68800: PPUSH
68801: LD_INT 100
68803: PPUSH
68804: CALL_OW 240
68808: GO 69035
// if GetFuel ( j ) = 0 then
68810: LD_VAR 0 3
68814: PPUSH
68815: CALL_OW 261
68819: PUSH
68820: LD_INT 0
68822: EQUAL
68823: IFFALSE 69035
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68825: LD_ADDR_EXP 71
68829: PUSH
68830: LD_EXP 71
68834: PPUSH
68835: LD_VAR 0 2
68839: PPUSH
68840: LD_EXP 71
68844: PUSH
68845: LD_VAR 0 2
68849: ARRAY
68850: PUSH
68851: LD_VAR 0 3
68855: DIFF
68856: PPUSH
68857: CALL_OW 1
68861: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68862: LD_VAR 0 3
68866: PPUSH
68867: CALL_OW 263
68871: PUSH
68872: LD_INT 1
68874: EQUAL
68875: IFFALSE 68891
// ComExitVehicle ( IsInUnit ( j ) ) ;
68877: LD_VAR 0 3
68881: PPUSH
68882: CALL_OW 310
68886: PPUSH
68887: CALL_OW 121
// if GetControl ( j ) = control_remote then
68891: LD_VAR 0 3
68895: PPUSH
68896: CALL_OW 263
68900: PUSH
68901: LD_INT 2
68903: EQUAL
68904: IFFALSE 68915
// ComUnlink ( j ) ;
68906: LD_VAR 0 3
68910: PPUSH
68911: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68915: LD_ADDR_VAR 0 9
68919: PUSH
68920: LD_VAR 0 2
68924: PPUSH
68925: LD_INT 3
68927: PPUSH
68928: CALL 78172 0 2
68932: ST_TO_ADDR
// if fac then
68933: LD_VAR 0 9
68937: IFFALSE 69033
// begin for k in fac do
68939: LD_ADDR_VAR 0 4
68943: PUSH
68944: LD_VAR 0 9
68948: PUSH
68949: FOR_IN
68950: IFFALSE 69031
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68952: LD_ADDR_VAR 0 10
68956: PUSH
68957: LD_VAR 0 9
68961: PPUSH
68962: LD_VAR 0 3
68966: PPUSH
68967: CALL_OW 265
68971: PPUSH
68972: LD_VAR 0 3
68976: PPUSH
68977: CALL_OW 262
68981: PPUSH
68982: LD_VAR 0 3
68986: PPUSH
68987: CALL_OW 263
68991: PPUSH
68992: LD_VAR 0 3
68996: PPUSH
68997: CALL_OW 264
69001: PPUSH
69002: CALL 15697 0 5
69006: ST_TO_ADDR
// if components then
69007: LD_VAR 0 10
69011: IFFALSE 69029
// begin MC_InsertProduceList ( i , components ) ;
69013: LD_VAR 0 2
69017: PPUSH
69018: LD_VAR 0 10
69022: PPUSH
69023: CALL 77717 0 2
// break ;
69027: GO 69031
// end ; end ;
69029: GO 68949
69031: POP
69032: POP
// end ; continue ;
69033: GO 68529
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69035: LD_VAR 0 3
69039: PPUSH
69040: LD_INT 1
69042: PPUSH
69043: CALL_OW 289
69047: PUSH
69048: LD_INT 100
69050: LESS
69051: PUSH
69052: LD_VAR 0 3
69056: PPUSH
69057: CALL_OW 314
69061: NOT
69062: AND
69063: IFFALSE 69092
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69065: LD_VAR 0 3
69069: PPUSH
69070: LD_VAR 0 6
69074: PUSH
69075: LD_INT 2
69077: ARRAY
69078: PPUSH
69079: LD_VAR 0 6
69083: PUSH
69084: LD_INT 3
69086: ARRAY
69087: PPUSH
69088: CALL_OW 117
// break ;
69092: GO 69096
// end ;
69094: GO 68529
69096: POP
69097: POP
// end ; end ;
69098: GO 67367
69100: POP
69101: POP
// end ;
69102: LD_VAR 0 1
69106: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69107: LD_INT 0
69109: PPUSH
69110: PPUSH
69111: PPUSH
69112: PPUSH
// if not mc_bases then
69113: LD_EXP 52
69117: NOT
69118: IFFALSE 69122
// exit ;
69120: GO 69283
// for i = 1 to mc_bases do
69122: LD_ADDR_VAR 0 2
69126: PUSH
69127: DOUBLE
69128: LD_INT 1
69130: DEC
69131: ST_TO_ADDR
69132: LD_EXP 52
69136: PUSH
69137: FOR_TO
69138: IFFALSE 69281
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69140: LD_ADDR_VAR 0 4
69144: PUSH
69145: LD_EXP 71
69149: PUSH
69150: LD_VAR 0 2
69154: ARRAY
69155: PUSH
69156: LD_EXP 74
69160: PUSH
69161: LD_VAR 0 2
69165: ARRAY
69166: UNION
69167: PPUSH
69168: LD_INT 33
69170: PUSH
69171: LD_INT 2
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PPUSH
69178: CALL_OW 72
69182: ST_TO_ADDR
// if tmp then
69183: LD_VAR 0 4
69187: IFFALSE 69279
// for j in tmp do
69189: LD_ADDR_VAR 0 3
69193: PUSH
69194: LD_VAR 0 4
69198: PUSH
69199: FOR_IN
69200: IFFALSE 69277
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69202: LD_VAR 0 3
69206: PPUSH
69207: CALL_OW 312
69211: NOT
69212: PUSH
69213: LD_VAR 0 3
69217: PPUSH
69218: CALL_OW 256
69222: PUSH
69223: LD_INT 250
69225: GREATEREQUAL
69226: AND
69227: IFFALSE 69240
// Connect ( j ) else
69229: LD_VAR 0 3
69233: PPUSH
69234: CALL 21098 0 1
69238: GO 69275
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69240: LD_VAR 0 3
69244: PPUSH
69245: CALL_OW 256
69249: PUSH
69250: LD_INT 250
69252: LESS
69253: PUSH
69254: LD_VAR 0 3
69258: PPUSH
69259: CALL_OW 312
69263: AND
69264: IFFALSE 69275
// ComUnlink ( j ) ;
69266: LD_VAR 0 3
69270: PPUSH
69271: CALL_OW 136
69275: GO 69199
69277: POP
69278: POP
// end ;
69279: GO 69137
69281: POP
69282: POP
// end ;
69283: LD_VAR 0 1
69287: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69288: LD_INT 0
69290: PPUSH
69291: PPUSH
69292: PPUSH
69293: PPUSH
69294: PPUSH
// if not mc_bases then
69295: LD_EXP 52
69299: NOT
69300: IFFALSE 69304
// exit ;
69302: GO 69749
// for i = 1 to mc_bases do
69304: LD_ADDR_VAR 0 2
69308: PUSH
69309: DOUBLE
69310: LD_INT 1
69312: DEC
69313: ST_TO_ADDR
69314: LD_EXP 52
69318: PUSH
69319: FOR_TO
69320: IFFALSE 69747
// begin if not mc_produce [ i ] then
69322: LD_EXP 73
69326: PUSH
69327: LD_VAR 0 2
69331: ARRAY
69332: NOT
69333: IFFALSE 69337
// continue ;
69335: GO 69319
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69337: LD_ADDR_VAR 0 5
69341: PUSH
69342: LD_EXP 52
69346: PUSH
69347: LD_VAR 0 2
69351: ARRAY
69352: PPUSH
69353: LD_INT 30
69355: PUSH
69356: LD_INT 3
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PPUSH
69363: CALL_OW 72
69367: ST_TO_ADDR
// if not fac then
69368: LD_VAR 0 5
69372: NOT
69373: IFFALSE 69377
// continue ;
69375: GO 69319
// for j in fac do
69377: LD_ADDR_VAR 0 3
69381: PUSH
69382: LD_VAR 0 5
69386: PUSH
69387: FOR_IN
69388: IFFALSE 69743
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69390: LD_VAR 0 3
69394: PPUSH
69395: CALL_OW 461
69399: PUSH
69400: LD_INT 2
69402: NONEQUAL
69403: PUSH
69404: LD_VAR 0 3
69408: PPUSH
69409: LD_INT 15
69411: PPUSH
69412: CALL 20758 0 2
69416: PUSH
69417: LD_INT 4
69419: ARRAY
69420: OR
69421: IFFALSE 69425
// continue ;
69423: GO 69387
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69425: LD_VAR 0 3
69429: PPUSH
69430: LD_EXP 73
69434: PUSH
69435: LD_VAR 0 2
69439: ARRAY
69440: PUSH
69441: LD_INT 1
69443: ARRAY
69444: PUSH
69445: LD_INT 1
69447: ARRAY
69448: PPUSH
69449: LD_EXP 73
69453: PUSH
69454: LD_VAR 0 2
69458: ARRAY
69459: PUSH
69460: LD_INT 1
69462: ARRAY
69463: PUSH
69464: LD_INT 2
69466: ARRAY
69467: PPUSH
69468: LD_EXP 73
69472: PUSH
69473: LD_VAR 0 2
69477: ARRAY
69478: PUSH
69479: LD_INT 1
69481: ARRAY
69482: PUSH
69483: LD_INT 3
69485: ARRAY
69486: PPUSH
69487: LD_EXP 73
69491: PUSH
69492: LD_VAR 0 2
69496: ARRAY
69497: PUSH
69498: LD_INT 1
69500: ARRAY
69501: PUSH
69502: LD_INT 4
69504: ARRAY
69505: PPUSH
69506: CALL_OW 448
69510: PUSH
69511: LD_VAR 0 3
69515: PPUSH
69516: LD_EXP 73
69520: PUSH
69521: LD_VAR 0 2
69525: ARRAY
69526: PUSH
69527: LD_INT 1
69529: ARRAY
69530: PUSH
69531: LD_INT 1
69533: ARRAY
69534: PUSH
69535: LD_EXP 73
69539: PUSH
69540: LD_VAR 0 2
69544: ARRAY
69545: PUSH
69546: LD_INT 1
69548: ARRAY
69549: PUSH
69550: LD_INT 2
69552: ARRAY
69553: PUSH
69554: LD_EXP 73
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: PUSH
69565: LD_INT 1
69567: ARRAY
69568: PUSH
69569: LD_INT 3
69571: ARRAY
69572: PUSH
69573: LD_EXP 73
69577: PUSH
69578: LD_VAR 0 2
69582: ARRAY
69583: PUSH
69584: LD_INT 1
69586: ARRAY
69587: PUSH
69588: LD_INT 4
69590: ARRAY
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: PPUSH
69598: CALL 24429 0 2
69602: AND
69603: IFFALSE 69741
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69605: LD_VAR 0 3
69609: PPUSH
69610: LD_EXP 73
69614: PUSH
69615: LD_VAR 0 2
69619: ARRAY
69620: PUSH
69621: LD_INT 1
69623: ARRAY
69624: PUSH
69625: LD_INT 1
69627: ARRAY
69628: PPUSH
69629: LD_EXP 73
69633: PUSH
69634: LD_VAR 0 2
69638: ARRAY
69639: PUSH
69640: LD_INT 1
69642: ARRAY
69643: PUSH
69644: LD_INT 2
69646: ARRAY
69647: PPUSH
69648: LD_EXP 73
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: PUSH
69659: LD_INT 1
69661: ARRAY
69662: PUSH
69663: LD_INT 3
69665: ARRAY
69666: PPUSH
69667: LD_EXP 73
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: PUSH
69678: LD_INT 1
69680: ARRAY
69681: PUSH
69682: LD_INT 4
69684: ARRAY
69685: PPUSH
69686: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69690: LD_ADDR_VAR 0 4
69694: PUSH
69695: LD_EXP 73
69699: PUSH
69700: LD_VAR 0 2
69704: ARRAY
69705: PPUSH
69706: LD_INT 1
69708: PPUSH
69709: CALL_OW 3
69713: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69714: LD_ADDR_EXP 73
69718: PUSH
69719: LD_EXP 73
69723: PPUSH
69724: LD_VAR 0 2
69728: PPUSH
69729: LD_VAR 0 4
69733: PPUSH
69734: CALL_OW 1
69738: ST_TO_ADDR
// break ;
69739: GO 69743
// end ; end ;
69741: GO 69387
69743: POP
69744: POP
// end ;
69745: GO 69319
69747: POP
69748: POP
// end ;
69749: LD_VAR 0 1
69753: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69754: LD_INT 0
69756: PPUSH
69757: PPUSH
69758: PPUSH
// if not mc_bases then
69759: LD_EXP 52
69763: NOT
69764: IFFALSE 69768
// exit ;
69766: GO 69857
// for i = 1 to mc_bases do
69768: LD_ADDR_VAR 0 2
69772: PUSH
69773: DOUBLE
69774: LD_INT 1
69776: DEC
69777: ST_TO_ADDR
69778: LD_EXP 52
69782: PUSH
69783: FOR_TO
69784: IFFALSE 69855
// begin if mc_attack [ i ] then
69786: LD_EXP 72
69790: PUSH
69791: LD_VAR 0 2
69795: ARRAY
69796: IFFALSE 69853
// begin tmp := mc_attack [ i ] [ 1 ] ;
69798: LD_ADDR_VAR 0 3
69802: PUSH
69803: LD_EXP 72
69807: PUSH
69808: LD_VAR 0 2
69812: ARRAY
69813: PUSH
69814: LD_INT 1
69816: ARRAY
69817: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69818: LD_ADDR_EXP 72
69822: PUSH
69823: LD_EXP 72
69827: PPUSH
69828: LD_VAR 0 2
69832: PPUSH
69833: EMPTY
69834: PPUSH
69835: CALL_OW 1
69839: ST_TO_ADDR
// Attack ( tmp ) ;
69840: LD_VAR 0 3
69844: PPUSH
69845: CALL 46642 0 1
// exit ;
69849: POP
69850: POP
69851: GO 69857
// end ; end ;
69853: GO 69783
69855: POP
69856: POP
// end ;
69857: LD_VAR 0 1
69861: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69862: LD_INT 0
69864: PPUSH
69865: PPUSH
69866: PPUSH
69867: PPUSH
69868: PPUSH
69869: PPUSH
69870: PPUSH
// if not mc_bases then
69871: LD_EXP 52
69875: NOT
69876: IFFALSE 69880
// exit ;
69878: GO 70462
// for i = 1 to mc_bases do
69880: LD_ADDR_VAR 0 2
69884: PUSH
69885: DOUBLE
69886: LD_INT 1
69888: DEC
69889: ST_TO_ADDR
69890: LD_EXP 52
69894: PUSH
69895: FOR_TO
69896: IFFALSE 70460
// begin if not mc_bases [ i ] then
69898: LD_EXP 52
69902: PUSH
69903: LD_VAR 0 2
69907: ARRAY
69908: NOT
69909: IFFALSE 69913
// continue ;
69911: GO 69895
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69913: LD_ADDR_VAR 0 7
69917: PUSH
69918: LD_EXP 52
69922: PUSH
69923: LD_VAR 0 2
69927: ARRAY
69928: PUSH
69929: LD_INT 1
69931: ARRAY
69932: PPUSH
69933: CALL 15001 0 1
69937: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69938: LD_ADDR_EXP 75
69942: PUSH
69943: LD_EXP 75
69947: PPUSH
69948: LD_VAR 0 2
69952: PPUSH
69953: LD_EXP 52
69957: PUSH
69958: LD_VAR 0 2
69962: ARRAY
69963: PUSH
69964: LD_INT 1
69966: ARRAY
69967: PPUSH
69968: CALL_OW 255
69972: PPUSH
69973: LD_EXP 77
69977: PUSH
69978: LD_VAR 0 2
69982: ARRAY
69983: PPUSH
69984: CALL 12704 0 2
69988: PPUSH
69989: CALL_OW 1
69993: ST_TO_ADDR
// if not mc_scan [ i ] then
69994: LD_EXP 75
69998: PUSH
69999: LD_VAR 0 2
70003: ARRAY
70004: NOT
70005: IFFALSE 70160
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: LD_EXP 52
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: PPUSH
70023: LD_INT 2
70025: PUSH
70026: LD_INT 25
70028: PUSH
70029: LD_INT 5
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 25
70038: PUSH
70039: LD_INT 8
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 25
70048: PUSH
70049: LD_INT 9
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: PPUSH
70062: CALL_OW 72
70066: ST_TO_ADDR
// if not tmp then
70067: LD_VAR 0 4
70071: NOT
70072: IFFALSE 70076
// continue ;
70074: GO 69895
// for j in tmp do
70076: LD_ADDR_VAR 0 3
70080: PUSH
70081: LD_VAR 0 4
70085: PUSH
70086: FOR_IN
70087: IFFALSE 70158
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70089: LD_VAR 0 3
70093: PPUSH
70094: CALL_OW 310
70098: PPUSH
70099: CALL_OW 266
70103: PUSH
70104: LD_INT 5
70106: EQUAL
70107: PUSH
70108: LD_VAR 0 3
70112: PPUSH
70113: CALL_OW 257
70117: PUSH
70118: LD_INT 1
70120: EQUAL
70121: AND
70122: PUSH
70123: LD_VAR 0 3
70127: PPUSH
70128: CALL_OW 459
70132: NOT
70133: AND
70134: PUSH
70135: LD_VAR 0 7
70139: AND
70140: IFFALSE 70156
// ComChangeProfession ( j , class ) ;
70142: LD_VAR 0 3
70146: PPUSH
70147: LD_VAR 0 7
70151: PPUSH
70152: CALL_OW 123
70156: GO 70086
70158: POP
70159: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70160: LD_EXP 75
70164: PUSH
70165: LD_VAR 0 2
70169: ARRAY
70170: PUSH
70171: LD_EXP 74
70175: PUSH
70176: LD_VAR 0 2
70180: ARRAY
70181: NOT
70182: AND
70183: PUSH
70184: LD_EXP 52
70188: PUSH
70189: LD_VAR 0 2
70193: ARRAY
70194: PPUSH
70195: LD_INT 30
70197: PUSH
70198: LD_INT 32
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PPUSH
70205: CALL_OW 72
70209: NOT
70210: AND
70211: PUSH
70212: LD_EXP 52
70216: PUSH
70217: LD_VAR 0 2
70221: ARRAY
70222: PPUSH
70223: LD_INT 2
70225: PUSH
70226: LD_INT 30
70228: PUSH
70229: LD_INT 4
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 30
70238: PUSH
70239: LD_INT 5
70241: PUSH
70242: EMPTY
70243: LIST
70244: LIST
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: LIST
70250: PPUSH
70251: CALL_OW 72
70255: NOT
70256: AND
70257: IFFALSE 70389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70259: LD_ADDR_VAR 0 4
70263: PUSH
70264: LD_EXP 52
70268: PUSH
70269: LD_VAR 0 2
70273: ARRAY
70274: PPUSH
70275: LD_INT 2
70277: PUSH
70278: LD_INT 25
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: LD_INT 25
70290: PUSH
70291: LD_INT 5
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 25
70300: PUSH
70301: LD_INT 8
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 25
70310: PUSH
70311: LD_INT 9
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: PPUSH
70325: CALL_OW 72
70329: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70330: LD_ADDR_VAR 0 4
70334: PUSH
70335: LD_VAR 0 4
70339: PUSH
70340: LD_VAR 0 4
70344: PPUSH
70345: LD_INT 18
70347: PPUSH
70348: CALL 51425 0 2
70352: DIFF
70353: ST_TO_ADDR
// if tmp then
70354: LD_VAR 0 4
70358: IFFALSE 70389
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70360: LD_VAR 0 2
70364: PPUSH
70365: LD_VAR 0 4
70369: PPUSH
70370: LD_EXP 77
70374: PUSH
70375: LD_VAR 0 2
70379: ARRAY
70380: PPUSH
70381: CALL 12739 0 3
// exit ;
70385: POP
70386: POP
70387: GO 70462
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70389: LD_EXP 75
70393: PUSH
70394: LD_VAR 0 2
70398: ARRAY
70399: PUSH
70400: LD_EXP 74
70404: PUSH
70405: LD_VAR 0 2
70409: ARRAY
70410: AND
70411: IFFALSE 70458
// begin tmp := mc_defender [ i ] ;
70413: LD_ADDR_VAR 0 4
70417: PUSH
70418: LD_EXP 74
70422: PUSH
70423: LD_VAR 0 2
70427: ARRAY
70428: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70429: LD_VAR 0 2
70433: PPUSH
70434: LD_VAR 0 4
70438: PPUSH
70439: LD_EXP 75
70443: PUSH
70444: LD_VAR 0 2
70448: ARRAY
70449: PPUSH
70450: CALL 13300 0 3
// exit ;
70454: POP
70455: POP
70456: GO 70462
// end ; end ;
70458: GO 69895
70460: POP
70461: POP
// end ;
70462: LD_VAR 0 1
70466: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70467: LD_INT 0
70469: PPUSH
70470: PPUSH
70471: PPUSH
70472: PPUSH
70473: PPUSH
70474: PPUSH
70475: PPUSH
70476: PPUSH
70477: PPUSH
70478: PPUSH
70479: PPUSH
// if not mc_bases then
70480: LD_EXP 52
70484: NOT
70485: IFFALSE 70489
// exit ;
70487: GO 71576
// for i = 1 to mc_bases do
70489: LD_ADDR_VAR 0 2
70493: PUSH
70494: DOUBLE
70495: LD_INT 1
70497: DEC
70498: ST_TO_ADDR
70499: LD_EXP 52
70503: PUSH
70504: FOR_TO
70505: IFFALSE 71574
// begin tmp := mc_lab [ i ] ;
70507: LD_ADDR_VAR 0 6
70511: PUSH
70512: LD_EXP 85
70516: PUSH
70517: LD_VAR 0 2
70521: ARRAY
70522: ST_TO_ADDR
// if not tmp then
70523: LD_VAR 0 6
70527: NOT
70528: IFFALSE 70532
// continue ;
70530: GO 70504
// idle_lab := 0 ;
70532: LD_ADDR_VAR 0 11
70536: PUSH
70537: LD_INT 0
70539: ST_TO_ADDR
// for j in tmp do
70540: LD_ADDR_VAR 0 3
70544: PUSH
70545: LD_VAR 0 6
70549: PUSH
70550: FOR_IN
70551: IFFALSE 71570
// begin researching := false ;
70553: LD_ADDR_VAR 0 10
70557: PUSH
70558: LD_INT 0
70560: ST_TO_ADDR
// side := GetSide ( j ) ;
70561: LD_ADDR_VAR 0 4
70565: PUSH
70566: LD_VAR 0 3
70570: PPUSH
70571: CALL_OW 255
70575: ST_TO_ADDR
// if not mc_tech [ side ] then
70576: LD_EXP 79
70580: PUSH
70581: LD_VAR 0 4
70585: ARRAY
70586: NOT
70587: IFFALSE 70591
// continue ;
70589: GO 70550
// if BuildingStatus ( j ) = bs_idle then
70591: LD_VAR 0 3
70595: PPUSH
70596: CALL_OW 461
70600: PUSH
70601: LD_INT 2
70603: EQUAL
70604: IFFALSE 70792
// begin if idle_lab and UnitsInside ( j ) < 6 then
70606: LD_VAR 0 11
70610: PUSH
70611: LD_VAR 0 3
70615: PPUSH
70616: CALL_OW 313
70620: PUSH
70621: LD_INT 6
70623: LESS
70624: AND
70625: IFFALSE 70696
// begin tmp2 := UnitsInside ( idle_lab ) ;
70627: LD_ADDR_VAR 0 9
70631: PUSH
70632: LD_VAR 0 11
70636: PPUSH
70637: CALL_OW 313
70641: ST_TO_ADDR
// if tmp2 then
70642: LD_VAR 0 9
70646: IFFALSE 70688
// for x in tmp2 do
70648: LD_ADDR_VAR 0 7
70652: PUSH
70653: LD_VAR 0 9
70657: PUSH
70658: FOR_IN
70659: IFFALSE 70686
// begin ComExitBuilding ( x ) ;
70661: LD_VAR 0 7
70665: PPUSH
70666: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70670: LD_VAR 0 7
70674: PPUSH
70675: LD_VAR 0 3
70679: PPUSH
70680: CALL_OW 180
// end ;
70684: GO 70658
70686: POP
70687: POP
// idle_lab := 0 ;
70688: LD_ADDR_VAR 0 11
70692: PUSH
70693: LD_INT 0
70695: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70696: LD_ADDR_VAR 0 5
70700: PUSH
70701: LD_EXP 79
70705: PUSH
70706: LD_VAR 0 4
70710: ARRAY
70711: PUSH
70712: FOR_IN
70713: IFFALSE 70773
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70715: LD_VAR 0 3
70719: PPUSH
70720: LD_VAR 0 5
70724: PPUSH
70725: CALL_OW 430
70729: PUSH
70730: LD_VAR 0 4
70734: PPUSH
70735: LD_VAR 0 5
70739: PPUSH
70740: CALL 11809 0 2
70744: AND
70745: IFFALSE 70771
// begin researching := true ;
70747: LD_ADDR_VAR 0 10
70751: PUSH
70752: LD_INT 1
70754: ST_TO_ADDR
// ComResearch ( j , t ) ;
70755: LD_VAR 0 3
70759: PPUSH
70760: LD_VAR 0 5
70764: PPUSH
70765: CALL_OW 124
// break ;
70769: GO 70773
// end ;
70771: GO 70712
70773: POP
70774: POP
// if not researching then
70775: LD_VAR 0 10
70779: NOT
70780: IFFALSE 70792
// idle_lab := j ;
70782: LD_ADDR_VAR 0 11
70786: PUSH
70787: LD_VAR 0 3
70791: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70792: LD_VAR 0 3
70796: PPUSH
70797: CALL_OW 461
70801: PUSH
70802: LD_INT 10
70804: EQUAL
70805: IFFALSE 71393
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70807: LD_EXP 81
70811: PUSH
70812: LD_VAR 0 2
70816: ARRAY
70817: NOT
70818: PUSH
70819: LD_EXP 82
70823: PUSH
70824: LD_VAR 0 2
70828: ARRAY
70829: NOT
70830: AND
70831: PUSH
70832: LD_EXP 79
70836: PUSH
70837: LD_VAR 0 4
70841: ARRAY
70842: PUSH
70843: LD_INT 1
70845: GREATER
70846: AND
70847: IFFALSE 70978
// begin ComCancel ( j ) ;
70849: LD_VAR 0 3
70853: PPUSH
70854: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70858: LD_ADDR_EXP 79
70862: PUSH
70863: LD_EXP 79
70867: PPUSH
70868: LD_VAR 0 4
70872: PPUSH
70873: LD_EXP 79
70877: PUSH
70878: LD_VAR 0 4
70882: ARRAY
70883: PPUSH
70884: LD_EXP 79
70888: PUSH
70889: LD_VAR 0 4
70893: ARRAY
70894: PUSH
70895: LD_INT 1
70897: MINUS
70898: PPUSH
70899: LD_EXP 79
70903: PUSH
70904: LD_VAR 0 4
70908: ARRAY
70909: PPUSH
70910: LD_INT 0
70912: PPUSH
70913: CALL 17583 0 4
70917: PPUSH
70918: CALL_OW 1
70922: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70923: LD_ADDR_EXP 79
70927: PUSH
70928: LD_EXP 79
70932: PPUSH
70933: LD_VAR 0 4
70937: PPUSH
70938: LD_EXP 79
70942: PUSH
70943: LD_VAR 0 4
70947: ARRAY
70948: PPUSH
70949: LD_EXP 79
70953: PUSH
70954: LD_VAR 0 4
70958: ARRAY
70959: PPUSH
70960: LD_INT 1
70962: PPUSH
70963: LD_INT 0
70965: PPUSH
70966: CALL 17583 0 4
70970: PPUSH
70971: CALL_OW 1
70975: ST_TO_ADDR
// continue ;
70976: GO 70550
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70978: LD_EXP 81
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PUSH
70989: LD_EXP 82
70993: PUSH
70994: LD_VAR 0 2
70998: ARRAY
70999: NOT
71000: AND
71001: IFFALSE 71128
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71003: LD_ADDR_EXP 82
71007: PUSH
71008: LD_EXP 82
71012: PPUSH
71013: LD_VAR 0 2
71017: PUSH
71018: LD_EXP 82
71022: PUSH
71023: LD_VAR 0 2
71027: ARRAY
71028: PUSH
71029: LD_INT 1
71031: PLUS
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PPUSH
71037: LD_EXP 81
71041: PUSH
71042: LD_VAR 0 2
71046: ARRAY
71047: PUSH
71048: LD_INT 1
71050: ARRAY
71051: PPUSH
71052: CALL 18165 0 3
71056: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71057: LD_EXP 81
71061: PUSH
71062: LD_VAR 0 2
71066: ARRAY
71067: PUSH
71068: LD_INT 1
71070: ARRAY
71071: PPUSH
71072: LD_INT 112
71074: PPUSH
71075: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71079: LD_ADDR_VAR 0 9
71083: PUSH
71084: LD_EXP 81
71088: PUSH
71089: LD_VAR 0 2
71093: ARRAY
71094: PPUSH
71095: LD_INT 1
71097: PPUSH
71098: CALL_OW 3
71102: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71103: LD_ADDR_EXP 81
71107: PUSH
71108: LD_EXP 81
71112: PPUSH
71113: LD_VAR 0 2
71117: PPUSH
71118: LD_VAR 0 9
71122: PPUSH
71123: CALL_OW 1
71127: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71128: LD_EXP 81
71132: PUSH
71133: LD_VAR 0 2
71137: ARRAY
71138: PUSH
71139: LD_EXP 82
71143: PUSH
71144: LD_VAR 0 2
71148: ARRAY
71149: AND
71150: PUSH
71151: LD_EXP 82
71155: PUSH
71156: LD_VAR 0 2
71160: ARRAY
71161: PUSH
71162: LD_INT 1
71164: ARRAY
71165: PPUSH
71166: CALL_OW 310
71170: NOT
71171: AND
71172: PUSH
71173: LD_VAR 0 3
71177: PPUSH
71178: CALL_OW 313
71182: PUSH
71183: LD_INT 6
71185: EQUAL
71186: AND
71187: IFFALSE 71243
// begin tmp2 := UnitsInside ( j ) ;
71189: LD_ADDR_VAR 0 9
71193: PUSH
71194: LD_VAR 0 3
71198: PPUSH
71199: CALL_OW 313
71203: ST_TO_ADDR
// if tmp2 = 6 then
71204: LD_VAR 0 9
71208: PUSH
71209: LD_INT 6
71211: EQUAL
71212: IFFALSE 71243
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71214: LD_VAR 0 9
71218: PUSH
71219: LD_INT 1
71221: ARRAY
71222: PPUSH
71223: LD_INT 112
71225: PPUSH
71226: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71230: LD_VAR 0 9
71234: PUSH
71235: LD_INT 1
71237: ARRAY
71238: PPUSH
71239: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71243: LD_EXP 82
71247: PUSH
71248: LD_VAR 0 2
71252: ARRAY
71253: PUSH
71254: LD_EXP 82
71258: PUSH
71259: LD_VAR 0 2
71263: ARRAY
71264: PUSH
71265: LD_INT 1
71267: ARRAY
71268: PPUSH
71269: CALL_OW 314
71273: NOT
71274: AND
71275: PUSH
71276: LD_EXP 82
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: PUSH
71287: LD_INT 1
71289: ARRAY
71290: PPUSH
71291: CALL_OW 310
71295: NOT
71296: AND
71297: IFFALSE 71323
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71299: LD_EXP 82
71303: PUSH
71304: LD_VAR 0 2
71308: ARRAY
71309: PUSH
71310: LD_INT 1
71312: ARRAY
71313: PPUSH
71314: LD_VAR 0 3
71318: PPUSH
71319: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71323: LD_EXP 82
71327: PUSH
71328: LD_VAR 0 2
71332: ARRAY
71333: PUSH
71334: LD_INT 1
71336: ARRAY
71337: PPUSH
71338: CALL_OW 310
71342: PUSH
71343: LD_EXP 82
71347: PUSH
71348: LD_VAR 0 2
71352: ARRAY
71353: PUSH
71354: LD_INT 1
71356: ARRAY
71357: PPUSH
71358: CALL_OW 310
71362: PPUSH
71363: CALL_OW 461
71367: PUSH
71368: LD_INT 3
71370: NONEQUAL
71371: AND
71372: IFFALSE 71393
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71374: LD_EXP 82
71378: PUSH
71379: LD_VAR 0 2
71383: ARRAY
71384: PUSH
71385: LD_INT 1
71387: ARRAY
71388: PPUSH
71389: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71393: LD_VAR 0 3
71397: PPUSH
71398: CALL_OW 461
71402: PUSH
71403: LD_INT 6
71405: EQUAL
71406: PUSH
71407: LD_VAR 0 6
71411: PUSH
71412: LD_INT 1
71414: GREATER
71415: AND
71416: IFFALSE 71568
// begin sci := [ ] ;
71418: LD_ADDR_VAR 0 8
71422: PUSH
71423: EMPTY
71424: ST_TO_ADDR
// for x in ( tmp diff j ) do
71425: LD_ADDR_VAR 0 7
71429: PUSH
71430: LD_VAR 0 6
71434: PUSH
71435: LD_VAR 0 3
71439: DIFF
71440: PUSH
71441: FOR_IN
71442: IFFALSE 71494
// begin if sci = 6 then
71444: LD_VAR 0 8
71448: PUSH
71449: LD_INT 6
71451: EQUAL
71452: IFFALSE 71456
// break ;
71454: GO 71494
// if BuildingStatus ( x ) = bs_idle then
71456: LD_VAR 0 7
71460: PPUSH
71461: CALL_OW 461
71465: PUSH
71466: LD_INT 2
71468: EQUAL
71469: IFFALSE 71492
// sci := sci ^ UnitsInside ( x ) ;
71471: LD_ADDR_VAR 0 8
71475: PUSH
71476: LD_VAR 0 8
71480: PUSH
71481: LD_VAR 0 7
71485: PPUSH
71486: CALL_OW 313
71490: ADD
71491: ST_TO_ADDR
// end ;
71492: GO 71441
71494: POP
71495: POP
// if not sci then
71496: LD_VAR 0 8
71500: NOT
71501: IFFALSE 71505
// continue ;
71503: GO 70550
// for x in sci do
71505: LD_ADDR_VAR 0 7
71509: PUSH
71510: LD_VAR 0 8
71514: PUSH
71515: FOR_IN
71516: IFFALSE 71566
// if IsInUnit ( x ) and not HasTask ( x ) then
71518: LD_VAR 0 7
71522: PPUSH
71523: CALL_OW 310
71527: PUSH
71528: LD_VAR 0 7
71532: PPUSH
71533: CALL_OW 314
71537: NOT
71538: AND
71539: IFFALSE 71564
// begin ComExitBuilding ( x ) ;
71541: LD_VAR 0 7
71545: PPUSH
71546: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71550: LD_VAR 0 7
71554: PPUSH
71555: LD_VAR 0 3
71559: PPUSH
71560: CALL_OW 180
// end ;
71564: GO 71515
71566: POP
71567: POP
// end ; end ;
71568: GO 70550
71570: POP
71571: POP
// end ;
71572: GO 70504
71574: POP
71575: POP
// end ;
71576: LD_VAR 0 1
71580: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71581: LD_INT 0
71583: PPUSH
71584: PPUSH
// if not mc_bases then
71585: LD_EXP 52
71589: NOT
71590: IFFALSE 71594
// exit ;
71592: GO 71675
// for i = 1 to mc_bases do
71594: LD_ADDR_VAR 0 2
71598: PUSH
71599: DOUBLE
71600: LD_INT 1
71602: DEC
71603: ST_TO_ADDR
71604: LD_EXP 52
71608: PUSH
71609: FOR_TO
71610: IFFALSE 71673
// if mc_mines [ i ] and mc_miners [ i ] then
71612: LD_EXP 65
71616: PUSH
71617: LD_VAR 0 2
71621: ARRAY
71622: PUSH
71623: LD_EXP 66
71627: PUSH
71628: LD_VAR 0 2
71632: ARRAY
71633: AND
71634: IFFALSE 71671
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71636: LD_EXP 66
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: PUSH
71647: LD_INT 1
71649: ARRAY
71650: PPUSH
71651: CALL_OW 255
71655: PPUSH
71656: LD_EXP 65
71660: PUSH
71661: LD_VAR 0 2
71665: ARRAY
71666: PPUSH
71667: CALL 15154 0 2
71671: GO 71609
71673: POP
71674: POP
// end ;
71675: LD_VAR 0 1
71679: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71680: LD_INT 0
71682: PPUSH
71683: PPUSH
71684: PPUSH
71685: PPUSH
71686: PPUSH
71687: PPUSH
71688: PPUSH
71689: PPUSH
// if not mc_bases or not mc_parking then
71690: LD_EXP 52
71694: NOT
71695: PUSH
71696: LD_EXP 76
71700: NOT
71701: OR
71702: IFFALSE 71706
// exit ;
71704: GO 72405
// for i = 1 to mc_bases do
71706: LD_ADDR_VAR 0 2
71710: PUSH
71711: DOUBLE
71712: LD_INT 1
71714: DEC
71715: ST_TO_ADDR
71716: LD_EXP 52
71720: PUSH
71721: FOR_TO
71722: IFFALSE 72403
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71724: LD_EXP 52
71728: PUSH
71729: LD_VAR 0 2
71733: ARRAY
71734: NOT
71735: PUSH
71736: LD_EXP 76
71740: PUSH
71741: LD_VAR 0 2
71745: ARRAY
71746: NOT
71747: OR
71748: IFFALSE 71752
// continue ;
71750: GO 71721
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71752: LD_ADDR_VAR 0 5
71756: PUSH
71757: LD_EXP 52
71761: PUSH
71762: LD_VAR 0 2
71766: ARRAY
71767: PUSH
71768: LD_INT 1
71770: ARRAY
71771: PPUSH
71772: CALL_OW 255
71776: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71777: LD_ADDR_VAR 0 6
71781: PUSH
71782: LD_EXP 52
71786: PUSH
71787: LD_VAR 0 2
71791: ARRAY
71792: PPUSH
71793: LD_INT 30
71795: PUSH
71796: LD_INT 3
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: PPUSH
71803: CALL_OW 72
71807: ST_TO_ADDR
// if not fac then
71808: LD_VAR 0 6
71812: NOT
71813: IFFALSE 71864
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71815: LD_ADDR_VAR 0 6
71819: PUSH
71820: LD_EXP 52
71824: PUSH
71825: LD_VAR 0 2
71829: ARRAY
71830: PPUSH
71831: LD_INT 2
71833: PUSH
71834: LD_INT 30
71836: PUSH
71837: LD_INT 0
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PUSH
71844: LD_INT 30
71846: PUSH
71847: LD_INT 1
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: LIST
71858: PPUSH
71859: CALL_OW 72
71863: ST_TO_ADDR
// if not fac then
71864: LD_VAR 0 6
71868: NOT
71869: IFFALSE 71873
// continue ;
71871: GO 71721
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71873: LD_ADDR_VAR 0 7
71877: PUSH
71878: LD_EXP 76
71882: PUSH
71883: LD_VAR 0 2
71887: ARRAY
71888: PPUSH
71889: LD_INT 22
71891: PUSH
71892: LD_VAR 0 5
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: LD_INT 21
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 3
71913: PUSH
71914: LD_INT 24
71916: PUSH
71917: LD_INT 1000
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: LIST
71932: PPUSH
71933: CALL_OW 70
71937: ST_TO_ADDR
// for j in fac do
71938: LD_ADDR_VAR 0 3
71942: PUSH
71943: LD_VAR 0 6
71947: PUSH
71948: FOR_IN
71949: IFFALSE 72030
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71951: LD_ADDR_VAR 0 7
71955: PUSH
71956: LD_VAR 0 7
71960: PUSH
71961: LD_INT 22
71963: PUSH
71964: LD_VAR 0 5
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 91
71975: PUSH
71976: LD_VAR 0 3
71980: PUSH
71981: LD_INT 15
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 21
71991: PUSH
71992: LD_INT 2
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 3
72001: PUSH
72002: LD_INT 24
72004: PUSH
72005: LD_INT 1000
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: LIST
72020: LIST
72021: PPUSH
72022: CALL_OW 69
72026: UNION
72027: ST_TO_ADDR
72028: GO 71948
72030: POP
72031: POP
// if not vehs then
72032: LD_VAR 0 7
72036: NOT
72037: IFFALSE 72063
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72039: LD_ADDR_EXP 64
72043: PUSH
72044: LD_EXP 64
72048: PPUSH
72049: LD_VAR 0 2
72053: PPUSH
72054: EMPTY
72055: PPUSH
72056: CALL_OW 1
72060: ST_TO_ADDR
// continue ;
72061: GO 71721
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72063: LD_ADDR_VAR 0 8
72067: PUSH
72068: LD_EXP 52
72072: PUSH
72073: LD_VAR 0 2
72077: ARRAY
72078: PPUSH
72079: LD_INT 30
72081: PUSH
72082: LD_INT 3
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PPUSH
72089: CALL_OW 72
72093: ST_TO_ADDR
// if tmp then
72094: LD_VAR 0 8
72098: IFFALSE 72201
// begin for j in tmp do
72100: LD_ADDR_VAR 0 3
72104: PUSH
72105: LD_VAR 0 8
72109: PUSH
72110: FOR_IN
72111: IFFALSE 72199
// for k in UnitsInside ( j ) do
72113: LD_ADDR_VAR 0 4
72117: PUSH
72118: LD_VAR 0 3
72122: PPUSH
72123: CALL_OW 313
72127: PUSH
72128: FOR_IN
72129: IFFALSE 72195
// if k then
72131: LD_VAR 0 4
72135: IFFALSE 72193
// if not k in mc_repair_vehicle [ i ] then
72137: LD_VAR 0 4
72141: PUSH
72142: LD_EXP 64
72146: PUSH
72147: LD_VAR 0 2
72151: ARRAY
72152: IN
72153: NOT
72154: IFFALSE 72193
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72156: LD_ADDR_EXP 64
72160: PUSH
72161: LD_EXP 64
72165: PPUSH
72166: LD_VAR 0 2
72170: PPUSH
72171: LD_EXP 64
72175: PUSH
72176: LD_VAR 0 2
72180: ARRAY
72181: PUSH
72182: LD_VAR 0 4
72186: UNION
72187: PPUSH
72188: CALL_OW 1
72192: ST_TO_ADDR
72193: GO 72128
72195: POP
72196: POP
72197: GO 72110
72199: POP
72200: POP
// end ; if not mc_repair_vehicle [ i ] then
72201: LD_EXP 64
72205: PUSH
72206: LD_VAR 0 2
72210: ARRAY
72211: NOT
72212: IFFALSE 72216
// continue ;
72214: GO 71721
// for j in mc_repair_vehicle [ i ] do
72216: LD_ADDR_VAR 0 3
72220: PUSH
72221: LD_EXP 64
72225: PUSH
72226: LD_VAR 0 2
72230: ARRAY
72231: PUSH
72232: FOR_IN
72233: IFFALSE 72399
// begin if GetClass ( j ) <> 3 then
72235: LD_VAR 0 3
72239: PPUSH
72240: CALL_OW 257
72244: PUSH
72245: LD_INT 3
72247: NONEQUAL
72248: IFFALSE 72289
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72250: LD_ADDR_EXP 64
72254: PUSH
72255: LD_EXP 64
72259: PPUSH
72260: LD_VAR 0 2
72264: PPUSH
72265: LD_EXP 64
72269: PUSH
72270: LD_VAR 0 2
72274: ARRAY
72275: PUSH
72276: LD_VAR 0 3
72280: DIFF
72281: PPUSH
72282: CALL_OW 1
72286: ST_TO_ADDR
// continue ;
72287: GO 72232
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72289: LD_VAR 0 3
72293: PPUSH
72294: CALL_OW 311
72298: NOT
72299: PUSH
72300: LD_VAR 0 3
72304: PUSH
72305: LD_EXP 55
72309: PUSH
72310: LD_VAR 0 2
72314: ARRAY
72315: PUSH
72316: LD_INT 1
72318: ARRAY
72319: IN
72320: NOT
72321: AND
72322: PUSH
72323: LD_VAR 0 3
72327: PUSH
72328: LD_EXP 55
72332: PUSH
72333: LD_VAR 0 2
72337: ARRAY
72338: PUSH
72339: LD_INT 2
72341: ARRAY
72342: IN
72343: NOT
72344: AND
72345: IFFALSE 72397
// begin if IsInUnit ( j ) then
72347: LD_VAR 0 3
72351: PPUSH
72352: CALL_OW 310
72356: IFFALSE 72367
// ComExitBuilding ( j ) ;
72358: LD_VAR 0 3
72362: PPUSH
72363: CALL_OW 122
// if not HasTask ( j ) then
72367: LD_VAR 0 3
72371: PPUSH
72372: CALL_OW 314
72376: NOT
72377: IFFALSE 72397
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72379: LD_VAR 0 3
72383: PPUSH
72384: LD_VAR 0 7
72388: PUSH
72389: LD_INT 1
72391: ARRAY
72392: PPUSH
72393: CALL_OW 189
// end ; end ;
72397: GO 72232
72399: POP
72400: POP
// end ;
72401: GO 71721
72403: POP
72404: POP
// end ;
72405: LD_VAR 0 1
72409: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72410: LD_INT 0
72412: PPUSH
72413: PPUSH
72414: PPUSH
72415: PPUSH
72416: PPUSH
72417: PPUSH
72418: PPUSH
72419: PPUSH
72420: PPUSH
72421: PPUSH
72422: PPUSH
// if not mc_bases then
72423: LD_EXP 52
72427: NOT
72428: IFFALSE 72432
// exit ;
72430: GO 73234
// for i = 1 to mc_bases do
72432: LD_ADDR_VAR 0 2
72436: PUSH
72437: DOUBLE
72438: LD_INT 1
72440: DEC
72441: ST_TO_ADDR
72442: LD_EXP 52
72446: PUSH
72447: FOR_TO
72448: IFFALSE 73232
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72450: LD_EXP 80
72454: PUSH
72455: LD_VAR 0 2
72459: ARRAY
72460: NOT
72461: PUSH
72462: LD_EXP 55
72466: PUSH
72467: LD_VAR 0 2
72471: ARRAY
72472: PUSH
72473: LD_INT 1
72475: ARRAY
72476: OR
72477: PUSH
72478: LD_EXP 55
72482: PUSH
72483: LD_VAR 0 2
72487: ARRAY
72488: PUSH
72489: LD_INT 2
72491: ARRAY
72492: OR
72493: PUSH
72494: LD_EXP 78
72498: PUSH
72499: LD_VAR 0 2
72503: ARRAY
72504: PPUSH
72505: LD_INT 1
72507: PPUSH
72508: CALL_OW 325
72512: NOT
72513: OR
72514: PUSH
72515: LD_EXP 75
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: OR
72526: IFFALSE 72530
// continue ;
72528: GO 72447
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72530: LD_ADDR_VAR 0 8
72534: PUSH
72535: LD_EXP 52
72539: PUSH
72540: LD_VAR 0 2
72544: ARRAY
72545: PPUSH
72546: LD_INT 25
72548: PUSH
72549: LD_INT 4
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 50
72558: PUSH
72559: EMPTY
72560: LIST
72561: PUSH
72562: LD_INT 3
72564: PUSH
72565: LD_INT 60
72567: PUSH
72568: EMPTY
72569: LIST
72570: PUSH
72571: EMPTY
72572: LIST
72573: LIST
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: LIST
72579: PPUSH
72580: CALL_OW 72
72584: PUSH
72585: LD_EXP 56
72589: PUSH
72590: LD_VAR 0 2
72594: ARRAY
72595: DIFF
72596: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72597: LD_ADDR_VAR 0 9
72601: PUSH
72602: LD_EXP 52
72606: PUSH
72607: LD_VAR 0 2
72611: ARRAY
72612: PPUSH
72613: LD_INT 2
72615: PUSH
72616: LD_INT 30
72618: PUSH
72619: LD_INT 0
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 30
72628: PUSH
72629: LD_INT 1
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: LIST
72640: PPUSH
72641: CALL_OW 72
72645: ST_TO_ADDR
// if not tmp or not dep then
72646: LD_VAR 0 8
72650: NOT
72651: PUSH
72652: LD_VAR 0 9
72656: NOT
72657: OR
72658: IFFALSE 72662
// continue ;
72660: GO 72447
// side := GetSide ( tmp [ 1 ] ) ;
72662: LD_ADDR_VAR 0 11
72666: PUSH
72667: LD_VAR 0 8
72671: PUSH
72672: LD_INT 1
72674: ARRAY
72675: PPUSH
72676: CALL_OW 255
72680: ST_TO_ADDR
// dep := dep [ 1 ] ;
72681: LD_ADDR_VAR 0 9
72685: PUSH
72686: LD_VAR 0 9
72690: PUSH
72691: LD_INT 1
72693: ARRAY
72694: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72695: LD_ADDR_VAR 0 7
72699: PUSH
72700: LD_EXP 80
72704: PUSH
72705: LD_VAR 0 2
72709: ARRAY
72710: PPUSH
72711: LD_INT 22
72713: PUSH
72714: LD_INT 0
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 25
72723: PUSH
72724: LD_INT 12
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PPUSH
72735: CALL_OW 70
72739: PUSH
72740: LD_INT 22
72742: PUSH
72743: LD_INT 0
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: PUSH
72750: LD_INT 25
72752: PUSH
72753: LD_INT 12
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: LD_INT 91
72762: PUSH
72763: LD_VAR 0 9
72767: PUSH
72768: LD_INT 20
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: LIST
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: LIST
72780: PPUSH
72781: CALL_OW 69
72785: UNION
72786: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72787: LD_ADDR_VAR 0 10
72791: PUSH
72792: LD_EXP 80
72796: PUSH
72797: LD_VAR 0 2
72801: ARRAY
72802: PPUSH
72803: LD_INT 81
72805: PUSH
72806: LD_VAR 0 11
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PPUSH
72815: CALL_OW 70
72819: ST_TO_ADDR
// if not apes or danger_at_area then
72820: LD_VAR 0 7
72824: NOT
72825: PUSH
72826: LD_VAR 0 10
72830: OR
72831: IFFALSE 72881
// begin if mc_taming [ i ] then
72833: LD_EXP 83
72837: PUSH
72838: LD_VAR 0 2
72842: ARRAY
72843: IFFALSE 72879
// begin MC_Reset ( i , 121 ) ;
72845: LD_VAR 0 2
72849: PPUSH
72850: LD_INT 121
72852: PPUSH
72853: CALL 58212 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72857: LD_ADDR_EXP 83
72861: PUSH
72862: LD_EXP 83
72866: PPUSH
72867: LD_VAR 0 2
72871: PPUSH
72872: EMPTY
72873: PPUSH
72874: CALL_OW 1
72878: ST_TO_ADDR
// end ; continue ;
72879: GO 72447
// end ; for j in tmp do
72881: LD_ADDR_VAR 0 3
72885: PUSH
72886: LD_VAR 0 8
72890: PUSH
72891: FOR_IN
72892: IFFALSE 73228
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72894: LD_VAR 0 3
72898: PUSH
72899: LD_EXP 83
72903: PUSH
72904: LD_VAR 0 2
72908: ARRAY
72909: IN
72910: NOT
72911: PUSH
72912: LD_EXP 83
72916: PUSH
72917: LD_VAR 0 2
72921: ARRAY
72922: PUSH
72923: LD_INT 3
72925: LESS
72926: AND
72927: IFFALSE 72985
// begin SetTag ( j , 121 ) ;
72929: LD_VAR 0 3
72933: PPUSH
72934: LD_INT 121
72936: PPUSH
72937: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72941: LD_ADDR_EXP 83
72945: PUSH
72946: LD_EXP 83
72950: PPUSH
72951: LD_VAR 0 2
72955: PUSH
72956: LD_EXP 83
72960: PUSH
72961: LD_VAR 0 2
72965: ARRAY
72966: PUSH
72967: LD_INT 1
72969: PLUS
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PPUSH
72975: LD_VAR 0 3
72979: PPUSH
72980: CALL 18165 0 3
72984: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72985: LD_VAR 0 3
72989: PUSH
72990: LD_EXP 83
72994: PUSH
72995: LD_VAR 0 2
72999: ARRAY
73000: IN
73001: IFFALSE 73226
// begin if GetClass ( j ) <> 4 then
73003: LD_VAR 0 3
73007: PPUSH
73008: CALL_OW 257
73012: PUSH
73013: LD_INT 4
73015: NONEQUAL
73016: IFFALSE 73069
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73018: LD_ADDR_EXP 83
73022: PUSH
73023: LD_EXP 83
73027: PPUSH
73028: LD_VAR 0 2
73032: PPUSH
73033: LD_EXP 83
73037: PUSH
73038: LD_VAR 0 2
73042: ARRAY
73043: PUSH
73044: LD_VAR 0 3
73048: DIFF
73049: PPUSH
73050: CALL_OW 1
73054: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73055: LD_VAR 0 3
73059: PPUSH
73060: LD_INT 0
73062: PPUSH
73063: CALL_OW 109
// continue ;
73067: GO 72891
// end ; if IsInUnit ( j ) then
73069: LD_VAR 0 3
73073: PPUSH
73074: CALL_OW 310
73078: IFFALSE 73089
// ComExitBuilding ( j ) ;
73080: LD_VAR 0 3
73084: PPUSH
73085: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73089: LD_ADDR_VAR 0 6
73093: PUSH
73094: LD_VAR 0 7
73098: PPUSH
73099: LD_VAR 0 3
73103: PPUSH
73104: CALL_OW 74
73108: ST_TO_ADDR
// if not ape then
73109: LD_VAR 0 6
73113: NOT
73114: IFFALSE 73118
// break ;
73116: GO 73228
// x := GetX ( ape ) ;
73118: LD_ADDR_VAR 0 4
73122: PUSH
73123: LD_VAR 0 6
73127: PPUSH
73128: CALL_OW 250
73132: ST_TO_ADDR
// y := GetY ( ape ) ;
73133: LD_ADDR_VAR 0 5
73137: PUSH
73138: LD_VAR 0 6
73142: PPUSH
73143: CALL_OW 251
73147: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73148: LD_VAR 0 4
73152: PPUSH
73153: LD_VAR 0 5
73157: PPUSH
73158: CALL_OW 488
73162: NOT
73163: PUSH
73164: LD_VAR 0 11
73168: PPUSH
73169: LD_VAR 0 4
73173: PPUSH
73174: LD_VAR 0 5
73178: PPUSH
73179: LD_INT 20
73181: PPUSH
73182: CALL 19061 0 4
73186: PUSH
73187: LD_INT 4
73189: ARRAY
73190: OR
73191: IFFALSE 73195
// break ;
73193: GO 73228
// if not HasTask ( j ) then
73195: LD_VAR 0 3
73199: PPUSH
73200: CALL_OW 314
73204: NOT
73205: IFFALSE 73226
// ComTameXY ( j , x , y ) ;
73207: LD_VAR 0 3
73211: PPUSH
73212: LD_VAR 0 4
73216: PPUSH
73217: LD_VAR 0 5
73221: PPUSH
73222: CALL_OW 131
// end ; end ;
73226: GO 72891
73228: POP
73229: POP
// end ;
73230: GO 72447
73232: POP
73233: POP
// end ;
73234: LD_VAR 0 1
73238: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73239: LD_INT 0
73241: PPUSH
73242: PPUSH
73243: PPUSH
73244: PPUSH
73245: PPUSH
73246: PPUSH
73247: PPUSH
73248: PPUSH
// if not mc_bases then
73249: LD_EXP 52
73253: NOT
73254: IFFALSE 73258
// exit ;
73256: GO 73884
// for i = 1 to mc_bases do
73258: LD_ADDR_VAR 0 2
73262: PUSH
73263: DOUBLE
73264: LD_INT 1
73266: DEC
73267: ST_TO_ADDR
73268: LD_EXP 52
73272: PUSH
73273: FOR_TO
73274: IFFALSE 73882
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73276: LD_EXP 81
73280: PUSH
73281: LD_VAR 0 2
73285: ARRAY
73286: NOT
73287: PUSH
73288: LD_EXP 81
73292: PUSH
73293: LD_VAR 0 2
73297: ARRAY
73298: PPUSH
73299: LD_INT 25
73301: PUSH
73302: LD_INT 12
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PPUSH
73309: CALL_OW 72
73313: NOT
73314: OR
73315: IFFALSE 73319
// continue ;
73317: GO 73273
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73319: LD_ADDR_VAR 0 5
73323: PUSH
73324: LD_EXP 81
73328: PUSH
73329: LD_VAR 0 2
73333: ARRAY
73334: PUSH
73335: LD_INT 1
73337: ARRAY
73338: PPUSH
73339: CALL_OW 255
73343: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73344: LD_VAR 0 5
73348: PPUSH
73349: LD_INT 2
73351: PPUSH
73352: CALL_OW 325
73356: IFFALSE 73609
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73358: LD_ADDR_VAR 0 4
73362: PUSH
73363: LD_EXP 81
73367: PUSH
73368: LD_VAR 0 2
73372: ARRAY
73373: PPUSH
73374: LD_INT 25
73376: PUSH
73377: LD_INT 16
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: PPUSH
73384: CALL_OW 72
73388: ST_TO_ADDR
// if tmp < 6 then
73389: LD_VAR 0 4
73393: PUSH
73394: LD_INT 6
73396: LESS
73397: IFFALSE 73609
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73399: LD_ADDR_VAR 0 6
73403: PUSH
73404: LD_EXP 52
73408: PUSH
73409: LD_VAR 0 2
73413: ARRAY
73414: PPUSH
73415: LD_INT 2
73417: PUSH
73418: LD_INT 30
73420: PUSH
73421: LD_INT 0
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 30
73430: PUSH
73431: LD_INT 1
73433: PUSH
73434: EMPTY
73435: LIST
73436: LIST
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: LIST
73442: PPUSH
73443: CALL_OW 72
73447: ST_TO_ADDR
// if depot then
73448: LD_VAR 0 6
73452: IFFALSE 73609
// begin selected := 0 ;
73454: LD_ADDR_VAR 0 7
73458: PUSH
73459: LD_INT 0
73461: ST_TO_ADDR
// for j in depot do
73462: LD_ADDR_VAR 0 3
73466: PUSH
73467: LD_VAR 0 6
73471: PUSH
73472: FOR_IN
73473: IFFALSE 73504
// begin if UnitsInside ( j ) < 6 then
73475: LD_VAR 0 3
73479: PPUSH
73480: CALL_OW 313
73484: PUSH
73485: LD_INT 6
73487: LESS
73488: IFFALSE 73502
// begin selected := j ;
73490: LD_ADDR_VAR 0 7
73494: PUSH
73495: LD_VAR 0 3
73499: ST_TO_ADDR
// break ;
73500: GO 73504
// end ; end ;
73502: GO 73472
73504: POP
73505: POP
// if selected then
73506: LD_VAR 0 7
73510: IFFALSE 73609
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73512: LD_ADDR_VAR 0 3
73516: PUSH
73517: LD_EXP 81
73521: PUSH
73522: LD_VAR 0 2
73526: ARRAY
73527: PPUSH
73528: LD_INT 25
73530: PUSH
73531: LD_INT 12
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PPUSH
73538: CALL_OW 72
73542: PUSH
73543: FOR_IN
73544: IFFALSE 73607
// if not HasTask ( j ) then
73546: LD_VAR 0 3
73550: PPUSH
73551: CALL_OW 314
73555: NOT
73556: IFFALSE 73605
// begin if not IsInUnit ( j ) then
73558: LD_VAR 0 3
73562: PPUSH
73563: CALL_OW 310
73567: NOT
73568: IFFALSE 73584
// ComEnterUnit ( j , selected ) ;
73570: LD_VAR 0 3
73574: PPUSH
73575: LD_VAR 0 7
73579: PPUSH
73580: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73584: LD_VAR 0 3
73588: PPUSH
73589: LD_INT 16
73591: PPUSH
73592: CALL_OW 183
// AddComExitBuilding ( j ) ;
73596: LD_VAR 0 3
73600: PPUSH
73601: CALL_OW 182
// end ;
73605: GO 73543
73607: POP
73608: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73609: LD_VAR 0 5
73613: PPUSH
73614: LD_INT 11
73616: PPUSH
73617: CALL_OW 325
73621: IFFALSE 73880
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73623: LD_ADDR_VAR 0 4
73627: PUSH
73628: LD_EXP 81
73632: PUSH
73633: LD_VAR 0 2
73637: ARRAY
73638: PPUSH
73639: LD_INT 25
73641: PUSH
73642: LD_INT 16
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PPUSH
73649: CALL_OW 72
73653: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73654: LD_VAR 0 4
73658: PUSH
73659: LD_INT 6
73661: GREATEREQUAL
73662: PUSH
73663: LD_VAR 0 5
73667: PPUSH
73668: LD_INT 2
73670: PPUSH
73671: CALL_OW 325
73675: NOT
73676: OR
73677: IFFALSE 73880
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73679: LD_ADDR_VAR 0 8
73683: PUSH
73684: LD_EXP 52
73688: PUSH
73689: LD_VAR 0 2
73693: ARRAY
73694: PPUSH
73695: LD_INT 2
73697: PUSH
73698: LD_INT 30
73700: PUSH
73701: LD_INT 4
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: PUSH
73708: LD_INT 30
73710: PUSH
73711: LD_INT 5
73713: PUSH
73714: EMPTY
73715: LIST
73716: LIST
73717: PUSH
73718: EMPTY
73719: LIST
73720: LIST
73721: LIST
73722: PPUSH
73723: CALL_OW 72
73727: ST_TO_ADDR
// if barracks then
73728: LD_VAR 0 8
73732: IFFALSE 73880
// begin selected := 0 ;
73734: LD_ADDR_VAR 0 7
73738: PUSH
73739: LD_INT 0
73741: ST_TO_ADDR
// for j in barracks do
73742: LD_ADDR_VAR 0 3
73746: PUSH
73747: LD_VAR 0 8
73751: PUSH
73752: FOR_IN
73753: IFFALSE 73784
// begin if UnitsInside ( j ) < 6 then
73755: LD_VAR 0 3
73759: PPUSH
73760: CALL_OW 313
73764: PUSH
73765: LD_INT 6
73767: LESS
73768: IFFALSE 73782
// begin selected := j ;
73770: LD_ADDR_VAR 0 7
73774: PUSH
73775: LD_VAR 0 3
73779: ST_TO_ADDR
// break ;
73780: GO 73784
// end ; end ;
73782: GO 73752
73784: POP
73785: POP
// if selected then
73786: LD_VAR 0 7
73790: IFFALSE 73880
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73792: LD_ADDR_VAR 0 3
73796: PUSH
73797: LD_EXP 81
73801: PUSH
73802: LD_VAR 0 2
73806: ARRAY
73807: PPUSH
73808: LD_INT 25
73810: PUSH
73811: LD_INT 12
73813: PUSH
73814: EMPTY
73815: LIST
73816: LIST
73817: PPUSH
73818: CALL_OW 72
73822: PUSH
73823: FOR_IN
73824: IFFALSE 73878
// if not IsInUnit ( j ) and not HasTask ( j ) then
73826: LD_VAR 0 3
73830: PPUSH
73831: CALL_OW 310
73835: NOT
73836: PUSH
73837: LD_VAR 0 3
73841: PPUSH
73842: CALL_OW 314
73846: NOT
73847: AND
73848: IFFALSE 73876
// begin ComEnterUnit ( j , selected ) ;
73850: LD_VAR 0 3
73854: PPUSH
73855: LD_VAR 0 7
73859: PPUSH
73860: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73864: LD_VAR 0 3
73868: PPUSH
73869: LD_INT 15
73871: PPUSH
73872: CALL_OW 183
// end ;
73876: GO 73823
73878: POP
73879: POP
// end ; end ; end ; end ; end ;
73880: GO 73273
73882: POP
73883: POP
// end ;
73884: LD_VAR 0 1
73888: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73889: LD_INT 0
73891: PPUSH
73892: PPUSH
73893: PPUSH
73894: PPUSH
// if not mc_bases then
73895: LD_EXP 52
73899: NOT
73900: IFFALSE 73904
// exit ;
73902: GO 74082
// for i = 1 to mc_bases do
73904: LD_ADDR_VAR 0 2
73908: PUSH
73909: DOUBLE
73910: LD_INT 1
73912: DEC
73913: ST_TO_ADDR
73914: LD_EXP 52
73918: PUSH
73919: FOR_TO
73920: IFFALSE 74080
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73922: LD_ADDR_VAR 0 4
73926: PUSH
73927: LD_EXP 52
73931: PUSH
73932: LD_VAR 0 2
73936: ARRAY
73937: PPUSH
73938: LD_INT 25
73940: PUSH
73941: LD_INT 9
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PPUSH
73948: CALL_OW 72
73952: ST_TO_ADDR
// if not tmp then
73953: LD_VAR 0 4
73957: NOT
73958: IFFALSE 73962
// continue ;
73960: GO 73919
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73962: LD_EXP 78
73966: PUSH
73967: LD_VAR 0 2
73971: ARRAY
73972: PPUSH
73973: LD_INT 29
73975: PPUSH
73976: CALL_OW 325
73980: NOT
73981: PUSH
73982: LD_EXP 78
73986: PUSH
73987: LD_VAR 0 2
73991: ARRAY
73992: PPUSH
73993: LD_INT 28
73995: PPUSH
73996: CALL_OW 325
74000: NOT
74001: AND
74002: IFFALSE 74006
// continue ;
74004: GO 73919
// for j in tmp do
74006: LD_ADDR_VAR 0 3
74010: PUSH
74011: LD_VAR 0 4
74015: PUSH
74016: FOR_IN
74017: IFFALSE 74076
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74019: LD_VAR 0 3
74023: PUSH
74024: LD_EXP 55
74028: PUSH
74029: LD_VAR 0 2
74033: ARRAY
74034: PUSH
74035: LD_INT 1
74037: ARRAY
74038: IN
74039: NOT
74040: PUSH
74041: LD_VAR 0 3
74045: PUSH
74046: LD_EXP 55
74050: PUSH
74051: LD_VAR 0 2
74055: ARRAY
74056: PUSH
74057: LD_INT 2
74059: ARRAY
74060: IN
74061: NOT
74062: AND
74063: IFFALSE 74074
// ComSpaceTimeShoot ( j ) ;
74065: LD_VAR 0 3
74069: PPUSH
74070: CALL 11900 0 1
74074: GO 74016
74076: POP
74077: POP
// end ;
74078: GO 73919
74080: POP
74081: POP
// end ;
74082: LD_VAR 0 1
74086: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74087: LD_INT 0
74089: PPUSH
74090: PPUSH
74091: PPUSH
74092: PPUSH
74093: PPUSH
74094: PPUSH
74095: PPUSH
74096: PPUSH
74097: PPUSH
// if not mc_bases then
74098: LD_EXP 52
74102: NOT
74103: IFFALSE 74107
// exit ;
74105: GO 74729
// for i = 1 to mc_bases do
74107: LD_ADDR_VAR 0 2
74111: PUSH
74112: DOUBLE
74113: LD_INT 1
74115: DEC
74116: ST_TO_ADDR
74117: LD_EXP 52
74121: PUSH
74122: FOR_TO
74123: IFFALSE 74727
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74125: LD_EXP 87
74129: PUSH
74130: LD_VAR 0 2
74134: ARRAY
74135: NOT
74136: PUSH
74137: LD_INT 38
74139: PPUSH
74140: LD_EXP 78
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: PPUSH
74151: CALL_OW 321
74155: PUSH
74156: LD_INT 2
74158: NONEQUAL
74159: OR
74160: IFFALSE 74164
// continue ;
74162: GO 74122
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74164: LD_ADDR_VAR 0 8
74168: PUSH
74169: LD_EXP 52
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: PPUSH
74180: LD_INT 30
74182: PUSH
74183: LD_INT 34
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PPUSH
74190: CALL_OW 72
74194: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74195: LD_ADDR_VAR 0 9
74199: PUSH
74200: LD_EXP 52
74204: PUSH
74205: LD_VAR 0 2
74209: ARRAY
74210: PPUSH
74211: LD_INT 25
74213: PUSH
74214: LD_INT 4
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: PPUSH
74221: CALL_OW 72
74225: PPUSH
74226: LD_INT 0
74228: PPUSH
74229: CALL 51425 0 2
74233: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74234: LD_VAR 0 9
74238: NOT
74239: PUSH
74240: LD_VAR 0 8
74244: NOT
74245: OR
74246: PUSH
74247: LD_EXP 52
74251: PUSH
74252: LD_VAR 0 2
74256: ARRAY
74257: PPUSH
74258: LD_INT 124
74260: PPUSH
74261: CALL 51425 0 2
74265: OR
74266: IFFALSE 74270
// continue ;
74268: GO 74122
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74270: LD_EXP 88
74274: PUSH
74275: LD_VAR 0 2
74279: ARRAY
74280: PUSH
74281: LD_EXP 87
74285: PUSH
74286: LD_VAR 0 2
74290: ARRAY
74291: LESS
74292: PUSH
74293: LD_EXP 88
74297: PUSH
74298: LD_VAR 0 2
74302: ARRAY
74303: PUSH
74304: LD_VAR 0 8
74308: LESS
74309: AND
74310: IFFALSE 74725
// begin tmp := sci [ 1 ] ;
74312: LD_ADDR_VAR 0 7
74316: PUSH
74317: LD_VAR 0 9
74321: PUSH
74322: LD_INT 1
74324: ARRAY
74325: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74326: LD_VAR 0 7
74330: PPUSH
74331: LD_INT 124
74333: PPUSH
74334: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74338: LD_ADDR_VAR 0 3
74342: PUSH
74343: DOUBLE
74344: LD_EXP 87
74348: PUSH
74349: LD_VAR 0 2
74353: ARRAY
74354: INC
74355: ST_TO_ADDR
74356: LD_EXP 87
74360: PUSH
74361: LD_VAR 0 2
74365: ARRAY
74366: PUSH
74367: FOR_DOWNTO
74368: IFFALSE 74711
// begin if IsInUnit ( tmp ) then
74370: LD_VAR 0 7
74374: PPUSH
74375: CALL_OW 310
74379: IFFALSE 74390
// ComExitBuilding ( tmp ) ;
74381: LD_VAR 0 7
74385: PPUSH
74386: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74390: LD_INT 35
74392: PPUSH
74393: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74397: LD_VAR 0 7
74401: PPUSH
74402: CALL_OW 310
74406: NOT
74407: PUSH
74408: LD_VAR 0 7
74412: PPUSH
74413: CALL_OW 314
74417: NOT
74418: AND
74419: IFFALSE 74390
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74421: LD_ADDR_VAR 0 6
74425: PUSH
74426: LD_VAR 0 7
74430: PPUSH
74431: CALL_OW 250
74435: PUSH
74436: LD_VAR 0 7
74440: PPUSH
74441: CALL_OW 251
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74450: LD_INT 35
74452: PPUSH
74453: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74457: LD_ADDR_VAR 0 4
74461: PUSH
74462: LD_EXP 87
74466: PUSH
74467: LD_VAR 0 2
74471: ARRAY
74472: PUSH
74473: LD_VAR 0 3
74477: ARRAY
74478: PUSH
74479: LD_INT 1
74481: ARRAY
74482: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74483: LD_ADDR_VAR 0 5
74487: PUSH
74488: LD_EXP 87
74492: PUSH
74493: LD_VAR 0 2
74497: ARRAY
74498: PUSH
74499: LD_VAR 0 3
74503: ARRAY
74504: PUSH
74505: LD_INT 2
74507: ARRAY
74508: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74509: LD_VAR 0 7
74513: PPUSH
74514: LD_INT 10
74516: PPUSH
74517: CALL 20758 0 2
74521: PUSH
74522: LD_INT 4
74524: ARRAY
74525: IFFALSE 74563
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74527: LD_VAR 0 7
74531: PPUSH
74532: LD_VAR 0 6
74536: PUSH
74537: LD_INT 1
74539: ARRAY
74540: PPUSH
74541: LD_VAR 0 6
74545: PUSH
74546: LD_INT 2
74548: ARRAY
74549: PPUSH
74550: CALL_OW 111
// wait ( 0 0$10 ) ;
74554: LD_INT 350
74556: PPUSH
74557: CALL_OW 67
// end else
74561: GO 74589
// begin ComMoveXY ( tmp , x , y ) ;
74563: LD_VAR 0 7
74567: PPUSH
74568: LD_VAR 0 4
74572: PPUSH
74573: LD_VAR 0 5
74577: PPUSH
74578: CALL_OW 111
// wait ( 0 0$3 ) ;
74582: LD_INT 105
74584: PPUSH
74585: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74589: LD_VAR 0 7
74593: PPUSH
74594: LD_VAR 0 4
74598: PPUSH
74599: LD_VAR 0 5
74603: PPUSH
74604: CALL_OW 307
74608: IFFALSE 74450
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74610: LD_VAR 0 7
74614: PPUSH
74615: LD_VAR 0 4
74619: PPUSH
74620: LD_VAR 0 5
74624: PPUSH
74625: LD_VAR 0 8
74629: PUSH
74630: LD_VAR 0 3
74634: ARRAY
74635: PPUSH
74636: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74640: LD_INT 35
74642: PPUSH
74643: CALL_OW 67
// until not HasTask ( tmp ) ;
74647: LD_VAR 0 7
74651: PPUSH
74652: CALL_OW 314
74656: NOT
74657: IFFALSE 74640
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74659: LD_ADDR_EXP 88
74663: PUSH
74664: LD_EXP 88
74668: PPUSH
74669: LD_VAR 0 2
74673: PUSH
74674: LD_EXP 88
74678: PUSH
74679: LD_VAR 0 2
74683: ARRAY
74684: PUSH
74685: LD_INT 1
74687: PLUS
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PPUSH
74693: LD_VAR 0 8
74697: PUSH
74698: LD_VAR 0 3
74702: ARRAY
74703: PPUSH
74704: CALL 18165 0 3
74708: ST_TO_ADDR
// end ;
74709: GO 74367
74711: POP
74712: POP
// MC_Reset ( i , 124 ) ;
74713: LD_VAR 0 2
74717: PPUSH
74718: LD_INT 124
74720: PPUSH
74721: CALL 58212 0 2
// end ; end ;
74725: GO 74122
74727: POP
74728: POP
// end ;
74729: LD_VAR 0 1
74733: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74734: LD_INT 0
74736: PPUSH
74737: PPUSH
74738: PPUSH
// if not mc_bases then
74739: LD_EXP 52
74743: NOT
74744: IFFALSE 74748
// exit ;
74746: GO 75354
// for i = 1 to mc_bases do
74748: LD_ADDR_VAR 0 2
74752: PUSH
74753: DOUBLE
74754: LD_INT 1
74756: DEC
74757: ST_TO_ADDR
74758: LD_EXP 52
74762: PUSH
74763: FOR_TO
74764: IFFALSE 75352
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74766: LD_ADDR_VAR 0 3
74770: PUSH
74771: LD_EXP 52
74775: PUSH
74776: LD_VAR 0 2
74780: ARRAY
74781: PPUSH
74782: LD_INT 25
74784: PUSH
74785: LD_INT 4
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: PPUSH
74792: CALL_OW 72
74796: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74797: LD_VAR 0 3
74801: NOT
74802: PUSH
74803: LD_EXP 89
74807: PUSH
74808: LD_VAR 0 2
74812: ARRAY
74813: NOT
74814: OR
74815: PUSH
74816: LD_EXP 52
74820: PUSH
74821: LD_VAR 0 2
74825: ARRAY
74826: PPUSH
74827: LD_INT 2
74829: PUSH
74830: LD_INT 30
74832: PUSH
74833: LD_INT 0
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 30
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: EMPTY
74851: LIST
74852: LIST
74853: LIST
74854: PPUSH
74855: CALL_OW 72
74859: NOT
74860: OR
74861: IFFALSE 74911
// begin if mc_deposits_finder [ i ] then
74863: LD_EXP 90
74867: PUSH
74868: LD_VAR 0 2
74872: ARRAY
74873: IFFALSE 74909
// begin MC_Reset ( i , 125 ) ;
74875: LD_VAR 0 2
74879: PPUSH
74880: LD_INT 125
74882: PPUSH
74883: CALL 58212 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74887: LD_ADDR_EXP 90
74891: PUSH
74892: LD_EXP 90
74896: PPUSH
74897: LD_VAR 0 2
74901: PPUSH
74902: EMPTY
74903: PPUSH
74904: CALL_OW 1
74908: ST_TO_ADDR
// end ; continue ;
74909: GO 74763
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74911: LD_EXP 89
74915: PUSH
74916: LD_VAR 0 2
74920: ARRAY
74921: PUSH
74922: LD_INT 1
74924: ARRAY
74925: PUSH
74926: LD_INT 3
74928: ARRAY
74929: PUSH
74930: LD_INT 1
74932: EQUAL
74933: PUSH
74934: LD_INT 20
74936: PPUSH
74937: LD_EXP 78
74941: PUSH
74942: LD_VAR 0 2
74946: ARRAY
74947: PPUSH
74948: CALL_OW 321
74952: PUSH
74953: LD_INT 2
74955: NONEQUAL
74956: AND
74957: IFFALSE 75007
// begin if mc_deposits_finder [ i ] then
74959: LD_EXP 90
74963: PUSH
74964: LD_VAR 0 2
74968: ARRAY
74969: IFFALSE 75005
// begin MC_Reset ( i , 125 ) ;
74971: LD_VAR 0 2
74975: PPUSH
74976: LD_INT 125
74978: PPUSH
74979: CALL 58212 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74983: LD_ADDR_EXP 90
74987: PUSH
74988: LD_EXP 90
74992: PPUSH
74993: LD_VAR 0 2
74997: PPUSH
74998: EMPTY
74999: PPUSH
75000: CALL_OW 1
75004: ST_TO_ADDR
// end ; continue ;
75005: GO 74763
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75007: LD_EXP 89
75011: PUSH
75012: LD_VAR 0 2
75016: ARRAY
75017: PUSH
75018: LD_INT 1
75020: ARRAY
75021: PUSH
75022: LD_INT 1
75024: ARRAY
75025: PPUSH
75026: LD_EXP 89
75030: PUSH
75031: LD_VAR 0 2
75035: ARRAY
75036: PUSH
75037: LD_INT 1
75039: ARRAY
75040: PUSH
75041: LD_INT 2
75043: ARRAY
75044: PPUSH
75045: LD_EXP 78
75049: PUSH
75050: LD_VAR 0 2
75054: ARRAY
75055: PPUSH
75056: CALL_OW 440
75060: IFFALSE 75103
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75062: LD_ADDR_EXP 89
75066: PUSH
75067: LD_EXP 89
75071: PPUSH
75072: LD_VAR 0 2
75076: PPUSH
75077: LD_EXP 89
75081: PUSH
75082: LD_VAR 0 2
75086: ARRAY
75087: PPUSH
75088: LD_INT 1
75090: PPUSH
75091: CALL_OW 3
75095: PPUSH
75096: CALL_OW 1
75100: ST_TO_ADDR
75101: GO 75350
// begin if not mc_deposits_finder [ i ] then
75103: LD_EXP 90
75107: PUSH
75108: LD_VAR 0 2
75112: ARRAY
75113: NOT
75114: IFFALSE 75166
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75116: LD_ADDR_EXP 90
75120: PUSH
75121: LD_EXP 90
75125: PPUSH
75126: LD_VAR 0 2
75130: PPUSH
75131: LD_VAR 0 3
75135: PUSH
75136: LD_INT 1
75138: ARRAY
75139: PUSH
75140: EMPTY
75141: LIST
75142: PPUSH
75143: CALL_OW 1
75147: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75148: LD_VAR 0 3
75152: PUSH
75153: LD_INT 1
75155: ARRAY
75156: PPUSH
75157: LD_INT 125
75159: PPUSH
75160: CALL_OW 109
// end else
75164: GO 75350
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75166: LD_EXP 90
75170: PUSH
75171: LD_VAR 0 2
75175: ARRAY
75176: PUSH
75177: LD_INT 1
75179: ARRAY
75180: PPUSH
75181: CALL_OW 310
75185: IFFALSE 75208
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75187: LD_EXP 90
75191: PUSH
75192: LD_VAR 0 2
75196: ARRAY
75197: PUSH
75198: LD_INT 1
75200: ARRAY
75201: PPUSH
75202: CALL_OW 122
75206: GO 75350
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75208: LD_EXP 90
75212: PUSH
75213: LD_VAR 0 2
75217: ARRAY
75218: PUSH
75219: LD_INT 1
75221: ARRAY
75222: PPUSH
75223: CALL_OW 314
75227: NOT
75228: PUSH
75229: LD_EXP 90
75233: PUSH
75234: LD_VAR 0 2
75238: ARRAY
75239: PUSH
75240: LD_INT 1
75242: ARRAY
75243: PPUSH
75244: LD_EXP 89
75248: PUSH
75249: LD_VAR 0 2
75253: ARRAY
75254: PUSH
75255: LD_INT 1
75257: ARRAY
75258: PUSH
75259: LD_INT 1
75261: ARRAY
75262: PPUSH
75263: LD_EXP 89
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: PUSH
75274: LD_INT 1
75276: ARRAY
75277: PUSH
75278: LD_INT 2
75280: ARRAY
75281: PPUSH
75282: CALL_OW 297
75286: PUSH
75287: LD_INT 6
75289: GREATER
75290: AND
75291: IFFALSE 75350
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75293: LD_EXP 90
75297: PUSH
75298: LD_VAR 0 2
75302: ARRAY
75303: PUSH
75304: LD_INT 1
75306: ARRAY
75307: PPUSH
75308: LD_EXP 89
75312: PUSH
75313: LD_VAR 0 2
75317: ARRAY
75318: PUSH
75319: LD_INT 1
75321: ARRAY
75322: PUSH
75323: LD_INT 1
75325: ARRAY
75326: PPUSH
75327: LD_EXP 89
75331: PUSH
75332: LD_VAR 0 2
75336: ARRAY
75337: PUSH
75338: LD_INT 1
75340: ARRAY
75341: PUSH
75342: LD_INT 2
75344: ARRAY
75345: PPUSH
75346: CALL_OW 111
// end ; end ; end ;
75350: GO 74763
75352: POP
75353: POP
// end ;
75354: LD_VAR 0 1
75358: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75359: LD_INT 0
75361: PPUSH
75362: PPUSH
75363: PPUSH
75364: PPUSH
75365: PPUSH
75366: PPUSH
75367: PPUSH
75368: PPUSH
75369: PPUSH
75370: PPUSH
75371: PPUSH
// if not mc_bases then
75372: LD_EXP 52
75376: NOT
75377: IFFALSE 75381
// exit ;
75379: GO 76105
// for i = 1 to mc_bases do
75381: LD_ADDR_VAR 0 2
75385: PUSH
75386: DOUBLE
75387: LD_INT 1
75389: DEC
75390: ST_TO_ADDR
75391: LD_EXP 52
75395: PUSH
75396: FOR_TO
75397: IFFALSE 76103
// begin if not mc_bases [ i ] then
75399: LD_EXP 52
75403: PUSH
75404: LD_VAR 0 2
75408: ARRAY
75409: NOT
75410: IFFALSE 75414
// continue ;
75412: GO 75396
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75414: LD_ADDR_VAR 0 7
75418: PUSH
75419: LD_EXP 52
75423: PUSH
75424: LD_VAR 0 2
75428: ARRAY
75429: PUSH
75430: LD_INT 1
75432: ARRAY
75433: PPUSH
75434: CALL_OW 248
75438: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75439: LD_VAR 0 7
75443: PUSH
75444: LD_INT 3
75446: EQUAL
75447: PUSH
75448: LD_EXP 71
75452: PUSH
75453: LD_VAR 0 2
75457: ARRAY
75458: PUSH
75459: LD_EXP 74
75463: PUSH
75464: LD_VAR 0 2
75468: ARRAY
75469: UNION
75470: PPUSH
75471: LD_INT 33
75473: PUSH
75474: LD_INT 2
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PPUSH
75481: CALL_OW 72
75485: NOT
75486: OR
75487: IFFALSE 75491
// continue ;
75489: GO 75396
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75491: LD_ADDR_VAR 0 9
75495: PUSH
75496: LD_EXP 52
75500: PUSH
75501: LD_VAR 0 2
75505: ARRAY
75506: PPUSH
75507: LD_INT 30
75509: PUSH
75510: LD_INT 36
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PPUSH
75517: CALL_OW 72
75521: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75522: LD_ADDR_VAR 0 10
75526: PUSH
75527: LD_EXP 71
75531: PUSH
75532: LD_VAR 0 2
75536: ARRAY
75537: PPUSH
75538: LD_INT 34
75540: PUSH
75541: LD_INT 31
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PPUSH
75548: CALL_OW 72
75552: ST_TO_ADDR
// if not cts and not mcts then
75553: LD_VAR 0 9
75557: NOT
75558: PUSH
75559: LD_VAR 0 10
75563: NOT
75564: AND
75565: IFFALSE 75569
// continue ;
75567: GO 75396
// x := cts ;
75569: LD_ADDR_VAR 0 11
75573: PUSH
75574: LD_VAR 0 9
75578: ST_TO_ADDR
// if not x then
75579: LD_VAR 0 11
75583: NOT
75584: IFFALSE 75596
// x := mcts ;
75586: LD_ADDR_VAR 0 11
75590: PUSH
75591: LD_VAR 0 10
75595: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75596: LD_EXP 92
75600: PUSH
75601: LD_VAR 0 2
75605: ARRAY
75606: IFFALSE 75875
// for j in mc_remote_driver [ i ] do
75608: LD_ADDR_VAR 0 3
75612: PUSH
75613: LD_EXP 92
75617: PUSH
75618: LD_VAR 0 2
75622: ARRAY
75623: PUSH
75624: FOR_IN
75625: IFFALSE 75873
// begin if GetClass ( j ) <> 3 then
75627: LD_VAR 0 3
75631: PPUSH
75632: CALL_OW 257
75636: PUSH
75637: LD_INT 3
75639: NONEQUAL
75640: IFFALSE 75693
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75642: LD_ADDR_EXP 92
75646: PUSH
75647: LD_EXP 92
75651: PPUSH
75652: LD_VAR 0 2
75656: PPUSH
75657: LD_EXP 92
75661: PUSH
75662: LD_VAR 0 2
75666: ARRAY
75667: PUSH
75668: LD_VAR 0 3
75672: DIFF
75673: PPUSH
75674: CALL_OW 1
75678: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75679: LD_VAR 0 3
75683: PPUSH
75684: LD_INT 0
75686: PPUSH
75687: CALL_OW 109
// continue ;
75691: GO 75624
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75693: LD_VAR 0 3
75697: PPUSH
75698: CALL_OW 310
75702: NOT
75703: PUSH
75704: LD_VAR 0 3
75708: PPUSH
75709: CALL_OW 310
75713: PPUSH
75714: CALL_OW 266
75718: PUSH
75719: LD_INT 36
75721: NONEQUAL
75722: PUSH
75723: LD_VAR 0 3
75727: PPUSH
75728: CALL 51513 0 1
75732: NOT
75733: AND
75734: OR
75735: IFFALSE 75871
// begin if IsInUnit ( j ) then
75737: LD_VAR 0 3
75741: PPUSH
75742: CALL_OW 310
75746: IFFALSE 75757
// ComExitBuilding ( j ) ;
75748: LD_VAR 0 3
75752: PPUSH
75753: CALL_OW 122
// ct := 0 ;
75757: LD_ADDR_VAR 0 8
75761: PUSH
75762: LD_INT 0
75764: ST_TO_ADDR
// for k in x do
75765: LD_ADDR_VAR 0 4
75769: PUSH
75770: LD_VAR 0 11
75774: PUSH
75775: FOR_IN
75776: IFFALSE 75849
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75778: LD_VAR 0 4
75782: PPUSH
75783: CALL_OW 264
75787: PUSH
75788: LD_INT 31
75790: EQUAL
75791: PUSH
75792: LD_VAR 0 4
75796: PPUSH
75797: CALL_OW 311
75801: NOT
75802: AND
75803: PUSH
75804: LD_VAR 0 4
75808: PPUSH
75809: CALL_OW 266
75813: PUSH
75814: LD_INT 36
75816: EQUAL
75817: PUSH
75818: LD_VAR 0 4
75822: PPUSH
75823: CALL_OW 313
75827: PUSH
75828: LD_INT 3
75830: LESS
75831: AND
75832: OR
75833: IFFALSE 75847
// begin ct := k ;
75835: LD_ADDR_VAR 0 8
75839: PUSH
75840: LD_VAR 0 4
75844: ST_TO_ADDR
// break ;
75845: GO 75849
// end ;
75847: GO 75775
75849: POP
75850: POP
// if ct then
75851: LD_VAR 0 8
75855: IFFALSE 75871
// ComEnterUnit ( j , ct ) ;
75857: LD_VAR 0 3
75861: PPUSH
75862: LD_VAR 0 8
75866: PPUSH
75867: CALL_OW 120
// end ; end ;
75871: GO 75624
75873: POP
75874: POP
// places := 0 ;
75875: LD_ADDR_VAR 0 5
75879: PUSH
75880: LD_INT 0
75882: ST_TO_ADDR
// for j = 1 to x do
75883: LD_ADDR_VAR 0 3
75887: PUSH
75888: DOUBLE
75889: LD_INT 1
75891: DEC
75892: ST_TO_ADDR
75893: LD_VAR 0 11
75897: PUSH
75898: FOR_TO
75899: IFFALSE 75954
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75901: LD_VAR 0 11
75905: PUSH
75906: LD_VAR 0 3
75910: ARRAY
75911: PPUSH
75912: CALL_OW 264
75916: PUSH
75917: LD_INT 31
75919: EQUAL
75920: IFFALSE 75938
// places := places + 1 else
75922: LD_ADDR_VAR 0 5
75926: PUSH
75927: LD_VAR 0 5
75931: PUSH
75932: LD_INT 1
75934: PLUS
75935: ST_TO_ADDR
75936: GO 75952
// places := places + 3 ;
75938: LD_ADDR_VAR 0 5
75942: PUSH
75943: LD_VAR 0 5
75947: PUSH
75948: LD_INT 3
75950: PLUS
75951: ST_TO_ADDR
75952: GO 75898
75954: POP
75955: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75956: LD_ADDR_VAR 0 6
75960: PUSH
75961: LD_EXP 52
75965: PUSH
75966: LD_VAR 0 2
75970: ARRAY
75971: PPUSH
75972: LD_INT 25
75974: PUSH
75975: LD_INT 3
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PPUSH
75982: CALL_OW 72
75986: PUSH
75987: LD_EXP 92
75991: PUSH
75992: LD_VAR 0 2
75996: ARRAY
75997: DIFF
75998: PPUSH
75999: LD_INT 3
76001: PPUSH
76002: CALL 52413 0 2
76006: ST_TO_ADDR
// if not tmp then
76007: LD_VAR 0 6
76011: NOT
76012: IFFALSE 76016
// continue ;
76014: GO 75396
// places := places - mc_remote_driver [ i ] ;
76016: LD_ADDR_VAR 0 5
76020: PUSH
76021: LD_VAR 0 5
76025: PUSH
76026: LD_EXP 92
76030: PUSH
76031: LD_VAR 0 2
76035: ARRAY
76036: MINUS
76037: ST_TO_ADDR
// if places then
76038: LD_VAR 0 5
76042: IFFALSE 76101
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76044: LD_ADDR_EXP 92
76048: PUSH
76049: LD_EXP 92
76053: PPUSH
76054: LD_VAR 0 2
76058: PPUSH
76059: LD_EXP 92
76063: PUSH
76064: LD_VAR 0 2
76068: ARRAY
76069: PUSH
76070: LD_VAR 0 6
76074: PUSH
76075: LD_INT 1
76077: ARRAY
76078: UNION
76079: PPUSH
76080: CALL_OW 1
76084: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76085: LD_VAR 0 6
76089: PUSH
76090: LD_INT 1
76092: ARRAY
76093: PPUSH
76094: LD_INT 126
76096: PPUSH
76097: CALL_OW 109
// end ; end ;
76101: GO 75396
76103: POP
76104: POP
// end ;
76105: LD_VAR 0 1
76109: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76110: LD_INT 0
76112: PPUSH
76113: PPUSH
76114: PPUSH
76115: PPUSH
76116: PPUSH
76117: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76118: LD_VAR 0 1
76122: NOT
76123: PUSH
76124: LD_VAR 0 2
76128: NOT
76129: OR
76130: PUSH
76131: LD_VAR 0 3
76135: NOT
76136: OR
76137: PUSH
76138: LD_VAR 0 4
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: LD_INT 2
76148: PUSH
76149: LD_INT 3
76151: PUSH
76152: LD_INT 4
76154: PUSH
76155: LD_INT 5
76157: PUSH
76158: LD_INT 8
76160: PUSH
76161: LD_INT 9
76163: PUSH
76164: LD_INT 15
76166: PUSH
76167: LD_INT 16
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: LIST
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: LIST
76179: LIST
76180: IN
76181: NOT
76182: OR
76183: IFFALSE 76187
// exit ;
76185: GO 77087
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76187: LD_ADDR_VAR 0 2
76191: PUSH
76192: LD_VAR 0 2
76196: PPUSH
76197: LD_INT 21
76199: PUSH
76200: LD_INT 3
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 24
76209: PUSH
76210: LD_INT 250
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PPUSH
76221: CALL_OW 72
76225: ST_TO_ADDR
// case class of 1 , 15 :
76226: LD_VAR 0 4
76230: PUSH
76231: LD_INT 1
76233: DOUBLE
76234: EQUAL
76235: IFTRUE 76245
76237: LD_INT 15
76239: DOUBLE
76240: EQUAL
76241: IFTRUE 76245
76243: GO 76330
76245: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76246: LD_ADDR_VAR 0 8
76250: PUSH
76251: LD_VAR 0 2
76255: PPUSH
76256: LD_INT 2
76258: PUSH
76259: LD_INT 30
76261: PUSH
76262: LD_INT 32
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: LD_INT 30
76271: PUSH
76272: LD_INT 31
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: LIST
76283: PPUSH
76284: CALL_OW 72
76288: PUSH
76289: LD_VAR 0 2
76293: PPUSH
76294: LD_INT 2
76296: PUSH
76297: LD_INT 30
76299: PUSH
76300: LD_INT 4
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 30
76309: PUSH
76310: LD_INT 5
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: LIST
76321: PPUSH
76322: CALL_OW 72
76326: ADD
76327: ST_TO_ADDR
76328: GO 76576
76330: LD_INT 2
76332: DOUBLE
76333: EQUAL
76334: IFTRUE 76344
76336: LD_INT 16
76338: DOUBLE
76339: EQUAL
76340: IFTRUE 76344
76342: GO 76390
76344: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76345: LD_ADDR_VAR 0 8
76349: PUSH
76350: LD_VAR 0 2
76354: PPUSH
76355: LD_INT 2
76357: PUSH
76358: LD_INT 30
76360: PUSH
76361: LD_INT 0
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 30
76370: PUSH
76371: LD_INT 1
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: LIST
76382: PPUSH
76383: CALL_OW 72
76387: ST_TO_ADDR
76388: GO 76576
76390: LD_INT 3
76392: DOUBLE
76393: EQUAL
76394: IFTRUE 76398
76396: GO 76444
76398: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76399: LD_ADDR_VAR 0 8
76403: PUSH
76404: LD_VAR 0 2
76408: PPUSH
76409: LD_INT 2
76411: PUSH
76412: LD_INT 30
76414: PUSH
76415: LD_INT 2
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: PUSH
76422: LD_INT 30
76424: PUSH
76425: LD_INT 3
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: LIST
76436: PPUSH
76437: CALL_OW 72
76441: ST_TO_ADDR
76442: GO 76576
76444: LD_INT 4
76446: DOUBLE
76447: EQUAL
76448: IFTRUE 76452
76450: GO 76509
76452: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76453: LD_ADDR_VAR 0 8
76457: PUSH
76458: LD_VAR 0 2
76462: PPUSH
76463: LD_INT 2
76465: PUSH
76466: LD_INT 30
76468: PUSH
76469: LD_INT 6
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 30
76478: PUSH
76479: LD_INT 7
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 30
76488: PUSH
76489: LD_INT 8
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: PPUSH
76502: CALL_OW 72
76506: ST_TO_ADDR
76507: GO 76576
76509: LD_INT 5
76511: DOUBLE
76512: EQUAL
76513: IFTRUE 76529
76515: LD_INT 8
76517: DOUBLE
76518: EQUAL
76519: IFTRUE 76529
76521: LD_INT 9
76523: DOUBLE
76524: EQUAL
76525: IFTRUE 76529
76527: GO 76575
76529: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76530: LD_ADDR_VAR 0 8
76534: PUSH
76535: LD_VAR 0 2
76539: PPUSH
76540: LD_INT 2
76542: PUSH
76543: LD_INT 30
76545: PUSH
76546: LD_INT 4
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 30
76555: PUSH
76556: LD_INT 5
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: LIST
76567: PPUSH
76568: CALL_OW 72
76572: ST_TO_ADDR
76573: GO 76576
76575: POP
// if not tmp then
76576: LD_VAR 0 8
76580: NOT
76581: IFFALSE 76585
// exit ;
76583: GO 77087
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76585: LD_VAR 0 4
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 15
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: IN
76600: PUSH
76601: LD_EXP 61
76605: PUSH
76606: LD_VAR 0 1
76610: ARRAY
76611: AND
76612: IFFALSE 76768
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76614: LD_ADDR_VAR 0 9
76618: PUSH
76619: LD_EXP 61
76623: PUSH
76624: LD_VAR 0 1
76628: ARRAY
76629: PUSH
76630: LD_INT 1
76632: ARRAY
76633: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76634: LD_VAR 0 9
76638: PUSH
76639: LD_EXP 62
76643: PUSH
76644: LD_VAR 0 1
76648: ARRAY
76649: IN
76650: NOT
76651: IFFALSE 76766
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76653: LD_ADDR_EXP 62
76657: PUSH
76658: LD_EXP 62
76662: PPUSH
76663: LD_VAR 0 1
76667: PUSH
76668: LD_EXP 62
76672: PUSH
76673: LD_VAR 0 1
76677: ARRAY
76678: PUSH
76679: LD_INT 1
76681: PLUS
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PPUSH
76687: LD_VAR 0 9
76691: PPUSH
76692: CALL 18165 0 3
76696: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76697: LD_ADDR_EXP 61
76701: PUSH
76702: LD_EXP 61
76706: PPUSH
76707: LD_VAR 0 1
76711: PPUSH
76712: LD_EXP 61
76716: PUSH
76717: LD_VAR 0 1
76721: ARRAY
76722: PUSH
76723: LD_VAR 0 9
76727: DIFF
76728: PPUSH
76729: CALL_OW 1
76733: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76734: LD_VAR 0 3
76738: PPUSH
76739: LD_EXP 62
76743: PUSH
76744: LD_VAR 0 1
76748: ARRAY
76749: PUSH
76750: LD_EXP 62
76754: PUSH
76755: LD_VAR 0 1
76759: ARRAY
76760: ARRAY
76761: PPUSH
76762: CALL_OW 120
// end ; exit ;
76766: GO 77087
// end ; if tmp > 1 then
76768: LD_VAR 0 8
76772: PUSH
76773: LD_INT 1
76775: GREATER
76776: IFFALSE 76880
// for i = 2 to tmp do
76778: LD_ADDR_VAR 0 6
76782: PUSH
76783: DOUBLE
76784: LD_INT 2
76786: DEC
76787: ST_TO_ADDR
76788: LD_VAR 0 8
76792: PUSH
76793: FOR_TO
76794: IFFALSE 76878
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76796: LD_VAR 0 8
76800: PUSH
76801: LD_VAR 0 6
76805: ARRAY
76806: PPUSH
76807: CALL_OW 461
76811: PUSH
76812: LD_INT 6
76814: EQUAL
76815: IFFALSE 76876
// begin x := tmp [ i ] ;
76817: LD_ADDR_VAR 0 9
76821: PUSH
76822: LD_VAR 0 8
76826: PUSH
76827: LD_VAR 0 6
76831: ARRAY
76832: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76833: LD_ADDR_VAR 0 8
76837: PUSH
76838: LD_VAR 0 8
76842: PPUSH
76843: LD_VAR 0 6
76847: PPUSH
76848: CALL_OW 3
76852: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76853: LD_ADDR_VAR 0 8
76857: PUSH
76858: LD_VAR 0 8
76862: PPUSH
76863: LD_INT 1
76865: PPUSH
76866: LD_VAR 0 9
76870: PPUSH
76871: CALL_OW 2
76875: ST_TO_ADDR
// end ;
76876: GO 76793
76878: POP
76879: POP
// for i in tmp do
76880: LD_ADDR_VAR 0 6
76884: PUSH
76885: LD_VAR 0 8
76889: PUSH
76890: FOR_IN
76891: IFFALSE 76960
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76893: LD_VAR 0 6
76897: PPUSH
76898: CALL_OW 313
76902: PUSH
76903: LD_INT 6
76905: LESS
76906: PUSH
76907: LD_VAR 0 6
76911: PPUSH
76912: CALL_OW 266
76916: PUSH
76917: LD_INT 31
76919: PUSH
76920: LD_INT 32
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: IN
76927: NOT
76928: AND
76929: PUSH
76930: LD_VAR 0 6
76934: PPUSH
76935: CALL_OW 313
76939: PUSH
76940: LD_INT 0
76942: EQUAL
76943: OR
76944: IFFALSE 76958
// begin j := i ;
76946: LD_ADDR_VAR 0 7
76950: PUSH
76951: LD_VAR 0 6
76955: ST_TO_ADDR
// break ;
76956: GO 76960
// end ; end ;
76958: GO 76890
76960: POP
76961: POP
// if j then
76962: LD_VAR 0 7
76966: IFFALSE 76984
// ComEnterUnit ( unit , j ) else
76968: LD_VAR 0 3
76972: PPUSH
76973: LD_VAR 0 7
76977: PPUSH
76978: CALL_OW 120
76982: GO 77087
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76984: LD_ADDR_VAR 0 10
76988: PUSH
76989: LD_VAR 0 2
76993: PPUSH
76994: LD_INT 2
76996: PUSH
76997: LD_INT 30
76999: PUSH
77000: LD_INT 0
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 30
77009: PUSH
77010: LD_INT 1
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: LIST
77021: PPUSH
77022: CALL_OW 72
77026: ST_TO_ADDR
// if depot then
77027: LD_VAR 0 10
77031: IFFALSE 77087
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77033: LD_ADDR_VAR 0 10
77037: PUSH
77038: LD_VAR 0 10
77042: PPUSH
77043: LD_VAR 0 3
77047: PPUSH
77048: CALL_OW 74
77052: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77053: LD_VAR 0 3
77057: PPUSH
77058: LD_VAR 0 10
77062: PPUSH
77063: CALL_OW 296
77067: PUSH
77068: LD_INT 10
77070: GREATER
77071: IFFALSE 77087
// ComStandNearbyBuilding ( unit , depot ) ;
77073: LD_VAR 0 3
77077: PPUSH
77078: LD_VAR 0 10
77082: PPUSH
77083: CALL 12517 0 2
// end ; end ; end ;
77087: LD_VAR 0 5
77091: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77092: LD_INT 0
77094: PPUSH
77095: PPUSH
77096: PPUSH
77097: PPUSH
// if not mc_bases then
77098: LD_EXP 52
77102: NOT
77103: IFFALSE 77107
// exit ;
77105: GO 77346
// for i = 1 to mc_bases do
77107: LD_ADDR_VAR 0 2
77111: PUSH
77112: DOUBLE
77113: LD_INT 1
77115: DEC
77116: ST_TO_ADDR
77117: LD_EXP 52
77121: PUSH
77122: FOR_TO
77123: IFFALSE 77344
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77125: LD_ADDR_VAR 0 4
77129: PUSH
77130: LD_EXP 52
77134: PUSH
77135: LD_VAR 0 2
77139: ARRAY
77140: PPUSH
77141: LD_INT 21
77143: PUSH
77144: LD_INT 1
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PPUSH
77151: CALL_OW 72
77155: PUSH
77156: LD_EXP 81
77160: PUSH
77161: LD_VAR 0 2
77165: ARRAY
77166: UNION
77167: ST_TO_ADDR
// if not tmp then
77168: LD_VAR 0 4
77172: NOT
77173: IFFALSE 77177
// continue ;
77175: GO 77122
// for j in tmp do
77177: LD_ADDR_VAR 0 3
77181: PUSH
77182: LD_VAR 0 4
77186: PUSH
77187: FOR_IN
77188: IFFALSE 77340
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77190: LD_VAR 0 3
77194: PPUSH
77195: CALL_OW 110
77199: NOT
77200: PUSH
77201: LD_VAR 0 3
77205: PPUSH
77206: CALL_OW 314
77210: NOT
77211: AND
77212: PUSH
77213: LD_VAR 0 3
77217: PPUSH
77218: CALL_OW 311
77222: NOT
77223: AND
77224: PUSH
77225: LD_VAR 0 3
77229: PPUSH
77230: CALL_OW 310
77234: NOT
77235: AND
77236: PUSH
77237: LD_VAR 0 3
77241: PUSH
77242: LD_EXP 55
77246: PUSH
77247: LD_VAR 0 2
77251: ARRAY
77252: PUSH
77253: LD_INT 1
77255: ARRAY
77256: IN
77257: NOT
77258: AND
77259: PUSH
77260: LD_VAR 0 3
77264: PUSH
77265: LD_EXP 55
77269: PUSH
77270: LD_VAR 0 2
77274: ARRAY
77275: PUSH
77276: LD_INT 2
77278: ARRAY
77279: IN
77280: NOT
77281: AND
77282: PUSH
77283: LD_VAR 0 3
77287: PUSH
77288: LD_EXP 64
77292: PUSH
77293: LD_VAR 0 2
77297: ARRAY
77298: IN
77299: NOT
77300: AND
77301: IFFALSE 77338
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77303: LD_VAR 0 2
77307: PPUSH
77308: LD_EXP 52
77312: PUSH
77313: LD_VAR 0 2
77317: ARRAY
77318: PPUSH
77319: LD_VAR 0 3
77323: PPUSH
77324: LD_VAR 0 3
77328: PPUSH
77329: CALL_OW 257
77333: PPUSH
77334: CALL 76110 0 4
// end ;
77338: GO 77187
77340: POP
77341: POP
// end ;
77342: GO 77122
77344: POP
77345: POP
// end ;
77346: LD_VAR 0 1
77350: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77351: LD_INT 0
77353: PPUSH
77354: PPUSH
77355: PPUSH
77356: PPUSH
77357: PPUSH
77358: PPUSH
// if not mc_bases [ base ] then
77359: LD_EXP 52
77363: PUSH
77364: LD_VAR 0 1
77368: ARRAY
77369: NOT
77370: IFFALSE 77374
// exit ;
77372: GO 77556
// tmp := [ ] ;
77374: LD_ADDR_VAR 0 6
77378: PUSH
77379: EMPTY
77380: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77381: LD_ADDR_VAR 0 7
77385: PUSH
77386: LD_VAR 0 3
77390: PPUSH
77391: LD_INT 0
77393: PPUSH
77394: CALL_OW 517
77398: ST_TO_ADDR
// if not list then
77399: LD_VAR 0 7
77403: NOT
77404: IFFALSE 77408
// exit ;
77406: GO 77556
// for i = 1 to amount do
77408: LD_ADDR_VAR 0 5
77412: PUSH
77413: DOUBLE
77414: LD_INT 1
77416: DEC
77417: ST_TO_ADDR
77418: LD_VAR 0 2
77422: PUSH
77423: FOR_TO
77424: IFFALSE 77504
// begin x := rand ( 1 , list [ 1 ] ) ;
77426: LD_ADDR_VAR 0 8
77430: PUSH
77431: LD_INT 1
77433: PPUSH
77434: LD_VAR 0 7
77438: PUSH
77439: LD_INT 1
77441: ARRAY
77442: PPUSH
77443: CALL_OW 12
77447: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77448: LD_ADDR_VAR 0 6
77452: PUSH
77453: LD_VAR 0 6
77457: PPUSH
77458: LD_VAR 0 5
77462: PPUSH
77463: LD_VAR 0 7
77467: PUSH
77468: LD_INT 1
77470: ARRAY
77471: PUSH
77472: LD_VAR 0 8
77476: ARRAY
77477: PUSH
77478: LD_VAR 0 7
77482: PUSH
77483: LD_INT 2
77485: ARRAY
77486: PUSH
77487: LD_VAR 0 8
77491: ARRAY
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PPUSH
77497: CALL_OW 1
77501: ST_TO_ADDR
// end ;
77502: GO 77423
77504: POP
77505: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77506: LD_ADDR_EXP 65
77510: PUSH
77511: LD_EXP 65
77515: PPUSH
77516: LD_VAR 0 1
77520: PPUSH
77521: LD_VAR 0 6
77525: PPUSH
77526: CALL_OW 1
77530: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77531: LD_ADDR_EXP 67
77535: PUSH
77536: LD_EXP 67
77540: PPUSH
77541: LD_VAR 0 1
77545: PPUSH
77546: LD_VAR 0 3
77550: PPUSH
77551: CALL_OW 1
77555: ST_TO_ADDR
// end ;
77556: LD_VAR 0 4
77560: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77561: LD_INT 0
77563: PPUSH
// if not mc_bases [ base ] then
77564: LD_EXP 52
77568: PUSH
77569: LD_VAR 0 1
77573: ARRAY
77574: NOT
77575: IFFALSE 77579
// exit ;
77577: GO 77604
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77579: LD_ADDR_EXP 57
77583: PUSH
77584: LD_EXP 57
77588: PPUSH
77589: LD_VAR 0 1
77593: PPUSH
77594: LD_VAR 0 2
77598: PPUSH
77599: CALL_OW 1
77603: ST_TO_ADDR
// end ;
77604: LD_VAR 0 3
77608: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77609: LD_INT 0
77611: PPUSH
// if not mc_bases [ base ] then
77612: LD_EXP 52
77616: PUSH
77617: LD_VAR 0 1
77621: ARRAY
77622: NOT
77623: IFFALSE 77627
// exit ;
77625: GO 77664
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77627: LD_ADDR_EXP 57
77631: PUSH
77632: LD_EXP 57
77636: PPUSH
77637: LD_VAR 0 1
77641: PPUSH
77642: LD_EXP 57
77646: PUSH
77647: LD_VAR 0 1
77651: ARRAY
77652: PUSH
77653: LD_VAR 0 2
77657: UNION
77658: PPUSH
77659: CALL_OW 1
77663: ST_TO_ADDR
// end ;
77664: LD_VAR 0 3
77668: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77669: LD_INT 0
77671: PPUSH
// if not mc_bases [ base ] then
77672: LD_EXP 52
77676: PUSH
77677: LD_VAR 0 1
77681: ARRAY
77682: NOT
77683: IFFALSE 77687
// exit ;
77685: GO 77712
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77687: LD_ADDR_EXP 73
77691: PUSH
77692: LD_EXP 73
77696: PPUSH
77697: LD_VAR 0 1
77701: PPUSH
77702: LD_VAR 0 2
77706: PPUSH
77707: CALL_OW 1
77711: ST_TO_ADDR
// end ;
77712: LD_VAR 0 3
77716: RET
// export function MC_InsertProduceList ( base , components ) ; begin
77717: LD_INT 0
77719: PPUSH
// if not mc_bases [ base ] then
77720: LD_EXP 52
77724: PUSH
77725: LD_VAR 0 1
77729: ARRAY
77730: NOT
77731: IFFALSE 77735
// exit ;
77733: GO 77772
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
77735: LD_ADDR_EXP 73
77739: PUSH
77740: LD_EXP 73
77744: PPUSH
77745: LD_VAR 0 1
77749: PPUSH
77750: LD_EXP 73
77754: PUSH
77755: LD_VAR 0 1
77759: ARRAY
77760: PUSH
77761: LD_VAR 0 2
77765: ADD
77766: PPUSH
77767: CALL_OW 1
77771: ST_TO_ADDR
// end ;
77772: LD_VAR 0 3
77776: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77777: LD_INT 0
77779: PPUSH
// if not mc_bases [ base ] then
77780: LD_EXP 52
77784: PUSH
77785: LD_VAR 0 1
77789: ARRAY
77790: NOT
77791: IFFALSE 77795
// exit ;
77793: GO 77849
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77795: LD_ADDR_EXP 74
77799: PUSH
77800: LD_EXP 74
77804: PPUSH
77805: LD_VAR 0 1
77809: PPUSH
77810: LD_VAR 0 2
77814: PPUSH
77815: CALL_OW 1
77819: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77820: LD_ADDR_EXP 63
77824: PUSH
77825: LD_EXP 63
77829: PPUSH
77830: LD_VAR 0 1
77834: PPUSH
77835: LD_VAR 0 2
77839: PUSH
77840: LD_INT 0
77842: PLUS
77843: PPUSH
77844: CALL_OW 1
77848: ST_TO_ADDR
// end ;
77849: LD_VAR 0 3
77853: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77854: LD_INT 0
77856: PPUSH
// if not mc_bases [ base ] then
77857: LD_EXP 52
77861: PUSH
77862: LD_VAR 0 1
77866: ARRAY
77867: NOT
77868: IFFALSE 77872
// exit ;
77870: GO 77897
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77872: LD_ADDR_EXP 63
77876: PUSH
77877: LD_EXP 63
77881: PPUSH
77882: LD_VAR 0 1
77886: PPUSH
77887: LD_VAR 0 2
77891: PPUSH
77892: CALL_OW 1
77896: ST_TO_ADDR
// end ;
77897: LD_VAR 0 3
77901: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77902: LD_INT 0
77904: PPUSH
77905: PPUSH
77906: PPUSH
77907: PPUSH
// if not mc_bases [ base ] then
77908: LD_EXP 52
77912: PUSH
77913: LD_VAR 0 1
77917: ARRAY
77918: NOT
77919: IFFALSE 77923
// exit ;
77921: GO 77988
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77923: LD_ADDR_EXP 72
77927: PUSH
77928: LD_EXP 72
77932: PPUSH
77933: LD_VAR 0 1
77937: PUSH
77938: LD_EXP 72
77942: PUSH
77943: LD_VAR 0 1
77947: ARRAY
77948: PUSH
77949: LD_INT 1
77951: PLUS
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PPUSH
77957: LD_VAR 0 1
77961: PUSH
77962: LD_VAR 0 2
77966: PUSH
77967: LD_VAR 0 3
77971: PUSH
77972: LD_VAR 0 4
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: PPUSH
77983: CALL 18165 0 3
77987: ST_TO_ADDR
// end ;
77988: LD_VAR 0 5
77992: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77993: LD_INT 0
77995: PPUSH
// if not mc_bases [ base ] then
77996: LD_EXP 52
78000: PUSH
78001: LD_VAR 0 1
78005: ARRAY
78006: NOT
78007: IFFALSE 78011
// exit ;
78009: GO 78036
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78011: LD_ADDR_EXP 89
78015: PUSH
78016: LD_EXP 89
78020: PPUSH
78021: LD_VAR 0 1
78025: PPUSH
78026: LD_VAR 0 2
78030: PPUSH
78031: CALL_OW 1
78035: ST_TO_ADDR
// end ;
78036: LD_VAR 0 3
78040: RET
// export function MC_GetMinesField ( base ) ; begin
78041: LD_INT 0
78043: PPUSH
// result := mc_mines [ base ] ;
78044: LD_ADDR_VAR 0 2
78048: PUSH
78049: LD_EXP 65
78053: PUSH
78054: LD_VAR 0 1
78058: ARRAY
78059: ST_TO_ADDR
// end ;
78060: LD_VAR 0 2
78064: RET
// export function MC_GetProduceList ( base ) ; begin
78065: LD_INT 0
78067: PPUSH
// result := mc_produce [ base ] ;
78068: LD_ADDR_VAR 0 2
78072: PUSH
78073: LD_EXP 73
78077: PUSH
78078: LD_VAR 0 1
78082: ARRAY
78083: ST_TO_ADDR
// end ;
78084: LD_VAR 0 2
78088: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78089: LD_INT 0
78091: PPUSH
78092: PPUSH
// if not mc_bases then
78093: LD_EXP 52
78097: NOT
78098: IFFALSE 78102
// exit ;
78100: GO 78167
// if mc_bases [ base ] then
78102: LD_EXP 52
78106: PUSH
78107: LD_VAR 0 1
78111: ARRAY
78112: IFFALSE 78167
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78114: LD_ADDR_VAR 0 3
78118: PUSH
78119: LD_EXP 52
78123: PUSH
78124: LD_VAR 0 1
78128: ARRAY
78129: PPUSH
78130: LD_INT 30
78132: PUSH
78133: LD_VAR 0 2
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PPUSH
78142: CALL_OW 72
78146: ST_TO_ADDR
// if result then
78147: LD_VAR 0 3
78151: IFFALSE 78167
// result := result [ 1 ] ;
78153: LD_ADDR_VAR 0 3
78157: PUSH
78158: LD_VAR 0 3
78162: PUSH
78163: LD_INT 1
78165: ARRAY
78166: ST_TO_ADDR
// end ; end ;
78167: LD_VAR 0 3
78171: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78172: LD_INT 0
78174: PPUSH
78175: PPUSH
// if not mc_bases then
78176: LD_EXP 52
78180: NOT
78181: IFFALSE 78185
// exit ;
78183: GO 78230
// if mc_bases [ base ] then
78185: LD_EXP 52
78189: PUSH
78190: LD_VAR 0 1
78194: ARRAY
78195: IFFALSE 78230
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78197: LD_ADDR_VAR 0 3
78201: PUSH
78202: LD_EXP 52
78206: PUSH
78207: LD_VAR 0 1
78211: ARRAY
78212: PPUSH
78213: LD_INT 30
78215: PUSH
78216: LD_VAR 0 2
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PPUSH
78225: CALL_OW 72
78229: ST_TO_ADDR
// end ;
78230: LD_VAR 0 3
78234: RET
// export function MC_SetTame ( base , area ) ; begin
78235: LD_INT 0
78237: PPUSH
// if not mc_bases or not base then
78238: LD_EXP 52
78242: NOT
78243: PUSH
78244: LD_VAR 0 1
78248: NOT
78249: OR
78250: IFFALSE 78254
// exit ;
78252: GO 78279
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78254: LD_ADDR_EXP 80
78258: PUSH
78259: LD_EXP 80
78263: PPUSH
78264: LD_VAR 0 1
78268: PPUSH
78269: LD_VAR 0 2
78273: PPUSH
78274: CALL_OW 1
78278: ST_TO_ADDR
// end ;
78279: LD_VAR 0 3
78283: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78284: LD_INT 0
78286: PPUSH
78287: PPUSH
// if not mc_bases or not base then
78288: LD_EXP 52
78292: NOT
78293: PUSH
78294: LD_VAR 0 1
78298: NOT
78299: OR
78300: IFFALSE 78304
// exit ;
78302: GO 78406
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78304: LD_ADDR_VAR 0 4
78308: PUSH
78309: LD_EXP 52
78313: PUSH
78314: LD_VAR 0 1
78318: ARRAY
78319: PPUSH
78320: LD_INT 30
78322: PUSH
78323: LD_VAR 0 2
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PPUSH
78332: CALL_OW 72
78336: ST_TO_ADDR
// if not tmp then
78337: LD_VAR 0 4
78341: NOT
78342: IFFALSE 78346
// exit ;
78344: GO 78406
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78346: LD_ADDR_EXP 84
78350: PUSH
78351: LD_EXP 84
78355: PPUSH
78356: LD_VAR 0 1
78360: PPUSH
78361: LD_EXP 84
78365: PUSH
78366: LD_VAR 0 1
78370: ARRAY
78371: PPUSH
78372: LD_EXP 84
78376: PUSH
78377: LD_VAR 0 1
78381: ARRAY
78382: PUSH
78383: LD_INT 1
78385: PLUS
78386: PPUSH
78387: LD_VAR 0 4
78391: PUSH
78392: LD_INT 1
78394: ARRAY
78395: PPUSH
78396: CALL_OW 2
78400: PPUSH
78401: CALL_OW 1
78405: ST_TO_ADDR
// end ;
78406: LD_VAR 0 3
78410: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78411: LD_INT 0
78413: PPUSH
78414: PPUSH
// if not mc_bases or not base or not kinds then
78415: LD_EXP 52
78419: NOT
78420: PUSH
78421: LD_VAR 0 1
78425: NOT
78426: OR
78427: PUSH
78428: LD_VAR 0 2
78432: NOT
78433: OR
78434: IFFALSE 78438
// exit ;
78436: GO 78499
// for i in kinds do
78438: LD_ADDR_VAR 0 4
78442: PUSH
78443: LD_VAR 0 2
78447: PUSH
78448: FOR_IN
78449: IFFALSE 78497
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78451: LD_ADDR_EXP 86
78455: PUSH
78456: LD_EXP 86
78460: PPUSH
78461: LD_VAR 0 1
78465: PUSH
78466: LD_EXP 86
78470: PUSH
78471: LD_VAR 0 1
78475: ARRAY
78476: PUSH
78477: LD_INT 1
78479: PLUS
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PPUSH
78485: LD_VAR 0 4
78489: PPUSH
78490: CALL 18165 0 3
78494: ST_TO_ADDR
78495: GO 78448
78497: POP
78498: POP
// end ;
78499: LD_VAR 0 3
78503: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78504: LD_INT 0
78506: PPUSH
// if not mc_bases or not base or not areas then
78507: LD_EXP 52
78511: NOT
78512: PUSH
78513: LD_VAR 0 1
78517: NOT
78518: OR
78519: PUSH
78520: LD_VAR 0 2
78524: NOT
78525: OR
78526: IFFALSE 78530
// exit ;
78528: GO 78555
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78530: LD_ADDR_EXP 70
78534: PUSH
78535: LD_EXP 70
78539: PPUSH
78540: LD_VAR 0 1
78544: PPUSH
78545: LD_VAR 0 2
78549: PPUSH
78550: CALL_OW 1
78554: ST_TO_ADDR
// end ;
78555: LD_VAR 0 3
78559: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78560: LD_INT 0
78562: PPUSH
// if not mc_bases or not base or not teleports_exit then
78563: LD_EXP 52
78567: NOT
78568: PUSH
78569: LD_VAR 0 1
78573: NOT
78574: OR
78575: PUSH
78576: LD_VAR 0 2
78580: NOT
78581: OR
78582: IFFALSE 78586
// exit ;
78584: GO 78611
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78586: LD_ADDR_EXP 87
78590: PUSH
78591: LD_EXP 87
78595: PPUSH
78596: LD_VAR 0 1
78600: PPUSH
78601: LD_VAR 0 2
78605: PPUSH
78606: CALL_OW 1
78610: ST_TO_ADDR
// end ;
78611: LD_VAR 0 3
78615: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78616: LD_INT 0
78618: PPUSH
78619: PPUSH
78620: PPUSH
// if not mc_bases or not base or not ext_list then
78621: LD_EXP 52
78625: NOT
78626: PUSH
78627: LD_VAR 0 1
78631: NOT
78632: OR
78633: PUSH
78634: LD_VAR 0 5
78638: NOT
78639: OR
78640: IFFALSE 78644
// exit ;
78642: GO 78817
// tmp := GetFacExtXYD ( x , y , d ) ;
78644: LD_ADDR_VAR 0 8
78648: PUSH
78649: LD_VAR 0 2
78653: PPUSH
78654: LD_VAR 0 3
78658: PPUSH
78659: LD_VAR 0 4
78663: PPUSH
78664: CALL 51543 0 3
78668: ST_TO_ADDR
// if not tmp then
78669: LD_VAR 0 8
78673: NOT
78674: IFFALSE 78678
// exit ;
78676: GO 78817
// for i in tmp do
78678: LD_ADDR_VAR 0 7
78682: PUSH
78683: LD_VAR 0 8
78687: PUSH
78688: FOR_IN
78689: IFFALSE 78815
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78691: LD_ADDR_EXP 57
78695: PUSH
78696: LD_EXP 57
78700: PPUSH
78701: LD_VAR 0 1
78705: PPUSH
78706: LD_EXP 57
78710: PUSH
78711: LD_VAR 0 1
78715: ARRAY
78716: PPUSH
78717: LD_EXP 57
78721: PUSH
78722: LD_VAR 0 1
78726: ARRAY
78727: PUSH
78728: LD_INT 1
78730: PLUS
78731: PPUSH
78732: LD_VAR 0 5
78736: PUSH
78737: LD_INT 1
78739: ARRAY
78740: PUSH
78741: LD_VAR 0 7
78745: PUSH
78746: LD_INT 1
78748: ARRAY
78749: PUSH
78750: LD_VAR 0 7
78754: PUSH
78755: LD_INT 2
78757: ARRAY
78758: PUSH
78759: LD_VAR 0 7
78763: PUSH
78764: LD_INT 3
78766: ARRAY
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: PPUSH
78774: CALL_OW 2
78778: PPUSH
78779: CALL_OW 1
78783: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78784: LD_ADDR_VAR 0 5
78788: PUSH
78789: LD_VAR 0 5
78793: PPUSH
78794: LD_INT 1
78796: PPUSH
78797: CALL_OW 3
78801: ST_TO_ADDR
// if not ext_list then
78802: LD_VAR 0 5
78806: NOT
78807: IFFALSE 78813
// exit ;
78809: POP
78810: POP
78811: GO 78817
// end ;
78813: GO 78688
78815: POP
78816: POP
// end ;
78817: LD_VAR 0 6
78821: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78822: LD_INT 0
78824: PPUSH
// if not mc_bases or not base or not weapon_list then
78825: LD_EXP 52
78829: NOT
78830: PUSH
78831: LD_VAR 0 1
78835: NOT
78836: OR
78837: PUSH
78838: LD_VAR 0 2
78842: NOT
78843: OR
78844: IFFALSE 78848
// exit ;
78846: GO 78873
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78848: LD_ADDR_EXP 91
78852: PUSH
78853: LD_EXP 91
78857: PPUSH
78858: LD_VAR 0 1
78862: PPUSH
78863: LD_VAR 0 2
78867: PPUSH
78868: CALL_OW 1
78872: ST_TO_ADDR
// end ;
78873: LD_VAR 0 3
78877: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78878: LD_INT 0
78880: PPUSH
// if not mc_bases or not base or not tech_list then
78881: LD_EXP 52
78885: NOT
78886: PUSH
78887: LD_VAR 0 1
78891: NOT
78892: OR
78893: PUSH
78894: LD_VAR 0 2
78898: NOT
78899: OR
78900: IFFALSE 78904
// exit ;
78902: GO 78929
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78904: LD_ADDR_EXP 79
78908: PUSH
78909: LD_EXP 79
78913: PPUSH
78914: LD_VAR 0 1
78918: PPUSH
78919: LD_VAR 0 2
78923: PPUSH
78924: CALL_OW 1
78928: ST_TO_ADDR
// end ;
78929: LD_VAR 0 3
78933: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78934: LD_INT 0
78936: PPUSH
// if not mc_bases or not parking_area or not base then
78937: LD_EXP 52
78941: NOT
78942: PUSH
78943: LD_VAR 0 2
78947: NOT
78948: OR
78949: PUSH
78950: LD_VAR 0 1
78954: NOT
78955: OR
78956: IFFALSE 78960
// exit ;
78958: GO 78985
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78960: LD_ADDR_EXP 76
78964: PUSH
78965: LD_EXP 76
78969: PPUSH
78970: LD_VAR 0 1
78974: PPUSH
78975: LD_VAR 0 2
78979: PPUSH
78980: CALL_OW 1
78984: ST_TO_ADDR
// end ;
78985: LD_VAR 0 3
78989: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78990: LD_INT 0
78992: PPUSH
// if not mc_bases or not base or not scan_area then
78993: LD_EXP 52
78997: NOT
78998: PUSH
78999: LD_VAR 0 1
79003: NOT
79004: OR
79005: PUSH
79006: LD_VAR 0 2
79010: NOT
79011: OR
79012: IFFALSE 79016
// exit ;
79014: GO 79041
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79016: LD_ADDR_EXP 77
79020: PUSH
79021: LD_EXP 77
79025: PPUSH
79026: LD_VAR 0 1
79030: PPUSH
79031: LD_VAR 0 2
79035: PPUSH
79036: CALL_OW 1
79040: ST_TO_ADDR
// end ;
79041: LD_VAR 0 3
79045: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79046: LD_INT 0
79048: PPUSH
79049: PPUSH
// if not mc_bases or not base then
79050: LD_EXP 52
79054: NOT
79055: PUSH
79056: LD_VAR 0 1
79060: NOT
79061: OR
79062: IFFALSE 79066
// exit ;
79064: GO 79130
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79066: LD_ADDR_VAR 0 3
79070: PUSH
79071: LD_INT 1
79073: PUSH
79074: LD_INT 2
79076: PUSH
79077: LD_INT 3
79079: PUSH
79080: LD_INT 4
79082: PUSH
79083: LD_INT 11
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79093: LD_ADDR_EXP 79
79097: PUSH
79098: LD_EXP 79
79102: PPUSH
79103: LD_VAR 0 1
79107: PPUSH
79108: LD_EXP 79
79112: PUSH
79113: LD_VAR 0 1
79117: ARRAY
79118: PUSH
79119: LD_VAR 0 3
79123: DIFF
79124: PPUSH
79125: CALL_OW 1
79129: ST_TO_ADDR
// end ;
79130: LD_VAR 0 2
79134: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79135: LD_INT 0
79137: PPUSH
// result := mc_vehicles [ base ] ;
79138: LD_ADDR_VAR 0 3
79142: PUSH
79143: LD_EXP 71
79147: PUSH
79148: LD_VAR 0 1
79152: ARRAY
79153: ST_TO_ADDR
// if onlyCombat then
79154: LD_VAR 0 2
79158: IFFALSE 79323
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79160: LD_ADDR_VAR 0 3
79164: PUSH
79165: LD_VAR 0 3
79169: PUSH
79170: LD_VAR 0 3
79174: PPUSH
79175: LD_INT 2
79177: PUSH
79178: LD_INT 34
79180: PUSH
79181: LD_INT 12
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 34
79190: PUSH
79191: LD_INT 51
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 34
79200: PUSH
79201: LD_EXP 46
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 34
79212: PUSH
79213: LD_INT 32
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 34
79222: PUSH
79223: LD_INT 13
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 34
79232: PUSH
79233: LD_INT 52
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PUSH
79240: LD_INT 34
79242: PUSH
79243: LD_INT 14
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 34
79252: PUSH
79253: LD_INT 53
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 34
79262: PUSH
79263: LD_EXP 45
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 34
79274: PUSH
79275: LD_INT 31
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 34
79284: PUSH
79285: LD_INT 48
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 34
79294: PUSH
79295: LD_INT 8
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: PPUSH
79317: CALL_OW 72
79321: DIFF
79322: ST_TO_ADDR
// end ; end_of_file
79323: LD_VAR 0 3
79327: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79328: LD_INT 0
79330: PPUSH
79331: PPUSH
79332: PPUSH
// if not mc_bases or not skirmish then
79333: LD_EXP 52
79337: NOT
79338: PUSH
79339: LD_EXP 50
79343: NOT
79344: OR
79345: IFFALSE 79349
// exit ;
79347: GO 79514
// for i = 1 to mc_bases do
79349: LD_ADDR_VAR 0 4
79353: PUSH
79354: DOUBLE
79355: LD_INT 1
79357: DEC
79358: ST_TO_ADDR
79359: LD_EXP 52
79363: PUSH
79364: FOR_TO
79365: IFFALSE 79512
// begin if sci in mc_bases [ i ] then
79367: LD_VAR 0 2
79371: PUSH
79372: LD_EXP 52
79376: PUSH
79377: LD_VAR 0 4
79381: ARRAY
79382: IN
79383: IFFALSE 79510
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79385: LD_ADDR_EXP 81
79389: PUSH
79390: LD_EXP 81
79394: PPUSH
79395: LD_VAR 0 4
79399: PUSH
79400: LD_EXP 81
79404: PUSH
79405: LD_VAR 0 4
79409: ARRAY
79410: PUSH
79411: LD_INT 1
79413: PLUS
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PPUSH
79419: LD_VAR 0 1
79423: PPUSH
79424: CALL 18165 0 3
79428: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79429: LD_ADDR_VAR 0 5
79433: PUSH
79434: LD_EXP 52
79438: PUSH
79439: LD_VAR 0 4
79443: ARRAY
79444: PPUSH
79445: LD_INT 2
79447: PUSH
79448: LD_INT 30
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 30
79460: PUSH
79461: LD_INT 1
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: EMPTY
79469: LIST
79470: LIST
79471: LIST
79472: PPUSH
79473: CALL_OW 72
79477: PPUSH
79478: LD_VAR 0 1
79482: PPUSH
79483: CALL_OW 74
79487: ST_TO_ADDR
// if tmp then
79488: LD_VAR 0 5
79492: IFFALSE 79508
// ComStandNearbyBuilding ( ape , tmp ) ;
79494: LD_VAR 0 1
79498: PPUSH
79499: LD_VAR 0 5
79503: PPUSH
79504: CALL 12517 0 2
// break ;
79508: GO 79512
// end ; end ;
79510: GO 79364
79512: POP
79513: POP
// end ;
79514: LD_VAR 0 3
79518: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79519: LD_INT 0
79521: PPUSH
79522: PPUSH
79523: PPUSH
// if not mc_bases or not skirmish then
79524: LD_EXP 52
79528: NOT
79529: PUSH
79530: LD_EXP 50
79534: NOT
79535: OR
79536: IFFALSE 79540
// exit ;
79538: GO 79629
// for i = 1 to mc_bases do
79540: LD_ADDR_VAR 0 4
79544: PUSH
79545: DOUBLE
79546: LD_INT 1
79548: DEC
79549: ST_TO_ADDR
79550: LD_EXP 52
79554: PUSH
79555: FOR_TO
79556: IFFALSE 79627
// begin if building in mc_busy_turret_list [ i ] then
79558: LD_VAR 0 1
79562: PUSH
79563: LD_EXP 62
79567: PUSH
79568: LD_VAR 0 4
79572: ARRAY
79573: IN
79574: IFFALSE 79625
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79576: LD_ADDR_VAR 0 5
79580: PUSH
79581: LD_EXP 62
79585: PUSH
79586: LD_VAR 0 4
79590: ARRAY
79591: PUSH
79592: LD_VAR 0 1
79596: DIFF
79597: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79598: LD_ADDR_EXP 62
79602: PUSH
79603: LD_EXP 62
79607: PPUSH
79608: LD_VAR 0 4
79612: PPUSH
79613: LD_VAR 0 5
79617: PPUSH
79618: CALL_OW 1
79622: ST_TO_ADDR
// break ;
79623: GO 79627
// end ; end ;
79625: GO 79555
79627: POP
79628: POP
// end ;
79629: LD_VAR 0 3
79633: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79634: LD_INT 0
79636: PPUSH
79637: PPUSH
79638: PPUSH
// if not mc_bases or not skirmish then
79639: LD_EXP 52
79643: NOT
79644: PUSH
79645: LD_EXP 50
79649: NOT
79650: OR
79651: IFFALSE 79655
// exit ;
79653: GO 79854
// for i = 1 to mc_bases do
79655: LD_ADDR_VAR 0 5
79659: PUSH
79660: DOUBLE
79661: LD_INT 1
79663: DEC
79664: ST_TO_ADDR
79665: LD_EXP 52
79669: PUSH
79670: FOR_TO
79671: IFFALSE 79852
// if building in mc_bases [ i ] then
79673: LD_VAR 0 1
79677: PUSH
79678: LD_EXP 52
79682: PUSH
79683: LD_VAR 0 5
79687: ARRAY
79688: IN
79689: IFFALSE 79850
// begin tmp := mc_bases [ i ] diff building ;
79691: LD_ADDR_VAR 0 6
79695: PUSH
79696: LD_EXP 52
79700: PUSH
79701: LD_VAR 0 5
79705: ARRAY
79706: PUSH
79707: LD_VAR 0 1
79711: DIFF
79712: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79713: LD_ADDR_EXP 52
79717: PUSH
79718: LD_EXP 52
79722: PPUSH
79723: LD_VAR 0 5
79727: PPUSH
79728: LD_VAR 0 6
79732: PPUSH
79733: CALL_OW 1
79737: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79738: LD_VAR 0 1
79742: PUSH
79743: LD_EXP 60
79747: PUSH
79748: LD_VAR 0 5
79752: ARRAY
79753: IN
79754: IFFALSE 79793
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79756: LD_ADDR_EXP 60
79760: PUSH
79761: LD_EXP 60
79765: PPUSH
79766: LD_VAR 0 5
79770: PPUSH
79771: LD_EXP 60
79775: PUSH
79776: LD_VAR 0 5
79780: ARRAY
79781: PUSH
79782: LD_VAR 0 1
79786: DIFF
79787: PPUSH
79788: CALL_OW 1
79792: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79793: LD_VAR 0 1
79797: PUSH
79798: LD_EXP 61
79802: PUSH
79803: LD_VAR 0 5
79807: ARRAY
79808: IN
79809: IFFALSE 79848
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79811: LD_ADDR_EXP 61
79815: PUSH
79816: LD_EXP 61
79820: PPUSH
79821: LD_VAR 0 5
79825: PPUSH
79826: LD_EXP 61
79830: PUSH
79831: LD_VAR 0 5
79835: ARRAY
79836: PUSH
79837: LD_VAR 0 1
79841: DIFF
79842: PPUSH
79843: CALL_OW 1
79847: ST_TO_ADDR
// break ;
79848: GO 79852
// end ;
79850: GO 79670
79852: POP
79853: POP
// end ;
79854: LD_VAR 0 4
79858: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79859: LD_INT 0
79861: PPUSH
79862: PPUSH
79863: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79864: LD_EXP 52
79868: NOT
79869: PUSH
79870: LD_EXP 50
79874: NOT
79875: OR
79876: PUSH
79877: LD_VAR 0 3
79881: PUSH
79882: LD_EXP 78
79886: IN
79887: NOT
79888: OR
79889: IFFALSE 79893
// exit ;
79891: GO 80016
// for i = 1 to mc_vehicles do
79893: LD_ADDR_VAR 0 6
79897: PUSH
79898: DOUBLE
79899: LD_INT 1
79901: DEC
79902: ST_TO_ADDR
79903: LD_EXP 71
79907: PUSH
79908: FOR_TO
79909: IFFALSE 80014
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79911: LD_VAR 0 2
79915: PUSH
79916: LD_EXP 71
79920: PUSH
79921: LD_VAR 0 6
79925: ARRAY
79926: IN
79927: PUSH
79928: LD_VAR 0 1
79932: PUSH
79933: LD_EXP 71
79937: PUSH
79938: LD_VAR 0 6
79942: ARRAY
79943: IN
79944: OR
79945: IFFALSE 80012
// begin tmp := mc_vehicles [ i ] diff old ;
79947: LD_ADDR_VAR 0 7
79951: PUSH
79952: LD_EXP 71
79956: PUSH
79957: LD_VAR 0 6
79961: ARRAY
79962: PUSH
79963: LD_VAR 0 2
79967: DIFF
79968: ST_TO_ADDR
// tmp := tmp diff new ;
79969: LD_ADDR_VAR 0 7
79973: PUSH
79974: LD_VAR 0 7
79978: PUSH
79979: LD_VAR 0 1
79983: DIFF
79984: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79985: LD_ADDR_EXP 71
79989: PUSH
79990: LD_EXP 71
79994: PPUSH
79995: LD_VAR 0 6
79999: PPUSH
80000: LD_VAR 0 7
80004: PPUSH
80005: CALL_OW 1
80009: ST_TO_ADDR
// break ;
80010: GO 80014
// end ;
80012: GO 79908
80014: POP
80015: POP
// end ;
80016: LD_VAR 0 5
80020: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80021: LD_INT 0
80023: PPUSH
80024: PPUSH
80025: PPUSH
80026: PPUSH
// if not mc_bases or not skirmish then
80027: LD_EXP 52
80031: NOT
80032: PUSH
80033: LD_EXP 50
80037: NOT
80038: OR
80039: IFFALSE 80043
// exit ;
80041: GO 80420
// side := GetSide ( vehicle ) ;
80043: LD_ADDR_VAR 0 5
80047: PUSH
80048: LD_VAR 0 1
80052: PPUSH
80053: CALL_OW 255
80057: ST_TO_ADDR
// for i = 1 to mc_bases do
80058: LD_ADDR_VAR 0 4
80062: PUSH
80063: DOUBLE
80064: LD_INT 1
80066: DEC
80067: ST_TO_ADDR
80068: LD_EXP 52
80072: PUSH
80073: FOR_TO
80074: IFFALSE 80418
// begin if factory in mc_bases [ i ] then
80076: LD_VAR 0 2
80080: PUSH
80081: LD_EXP 52
80085: PUSH
80086: LD_VAR 0 4
80090: ARRAY
80091: IN
80092: IFFALSE 80416
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80094: LD_EXP 74
80098: PUSH
80099: LD_VAR 0 4
80103: ARRAY
80104: PUSH
80105: LD_EXP 63
80109: PUSH
80110: LD_VAR 0 4
80114: ARRAY
80115: LESS
80116: PUSH
80117: LD_VAR 0 1
80121: PPUSH
80122: CALL_OW 264
80126: PUSH
80127: LD_INT 31
80129: PUSH
80130: LD_INT 32
80132: PUSH
80133: LD_INT 51
80135: PUSH
80136: LD_EXP 46
80140: PUSH
80141: LD_INT 12
80143: PUSH
80144: LD_INT 30
80146: PUSH
80147: LD_EXP 45
80151: PUSH
80152: LD_INT 11
80154: PUSH
80155: LD_INT 53
80157: PUSH
80158: LD_INT 14
80160: PUSH
80161: LD_EXP 49
80165: PUSH
80166: LD_INT 29
80168: PUSH
80169: LD_EXP 47
80173: PUSH
80174: LD_INT 13
80176: PUSH
80177: LD_INT 52
80179: PUSH
80180: LD_INT 48
80182: PUSH
80183: LD_INT 8
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: LIST
80202: LIST
80203: LIST
80204: IN
80205: NOT
80206: AND
80207: IFFALSE 80255
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80209: LD_ADDR_EXP 74
80213: PUSH
80214: LD_EXP 74
80218: PPUSH
80219: LD_VAR 0 4
80223: PUSH
80224: LD_EXP 74
80228: PUSH
80229: LD_VAR 0 4
80233: ARRAY
80234: PUSH
80235: LD_INT 1
80237: PLUS
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PPUSH
80243: LD_VAR 0 1
80247: PPUSH
80248: CALL 18165 0 3
80252: ST_TO_ADDR
80253: GO 80299
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80255: LD_ADDR_EXP 71
80259: PUSH
80260: LD_EXP 71
80264: PPUSH
80265: LD_VAR 0 4
80269: PUSH
80270: LD_EXP 71
80274: PUSH
80275: LD_VAR 0 4
80279: ARRAY
80280: PUSH
80281: LD_INT 1
80283: PLUS
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PPUSH
80289: LD_VAR 0 1
80293: PPUSH
80294: CALL 18165 0 3
80298: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80299: LD_VAR 0 1
80303: PPUSH
80304: CALL_OW 263
80308: PUSH
80309: LD_INT 2
80311: EQUAL
80312: IFFALSE 80332
// begin repeat wait ( 0 0$1 ) ;
80314: LD_INT 35
80316: PPUSH
80317: CALL_OW 67
// until IsControledBy ( vehicle ) ;
80321: LD_VAR 0 1
80325: PPUSH
80326: CALL_OW 312
80330: IFFALSE 80314
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80332: LD_VAR 0 1
80336: PPUSH
80337: LD_EXP 76
80341: PUSH
80342: LD_VAR 0 4
80346: ARRAY
80347: PPUSH
80348: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80352: LD_VAR 0 1
80356: PPUSH
80357: CALL_OW 263
80361: PUSH
80362: LD_INT 1
80364: NONEQUAL
80365: IFFALSE 80369
// break ;
80367: GO 80418
// repeat wait ( 0 0$1 ) ;
80369: LD_INT 35
80371: PPUSH
80372: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80376: LD_VAR 0 1
80380: PPUSH
80381: LD_EXP 76
80385: PUSH
80386: LD_VAR 0 4
80390: ARRAY
80391: PPUSH
80392: CALL_OW 308
80396: IFFALSE 80369
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80398: LD_VAR 0 1
80402: PPUSH
80403: CALL_OW 311
80407: PPUSH
80408: CALL_OW 121
// exit ;
80412: POP
80413: POP
80414: GO 80420
// end ; end ;
80416: GO 80073
80418: POP
80419: POP
// end ;
80420: LD_VAR 0 3
80424: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80425: LD_INT 0
80427: PPUSH
80428: PPUSH
80429: PPUSH
80430: PPUSH
// if not mc_bases or not skirmish then
80431: LD_EXP 52
80435: NOT
80436: PUSH
80437: LD_EXP 50
80441: NOT
80442: OR
80443: IFFALSE 80447
// exit ;
80445: GO 80800
// repeat wait ( 0 0$1 ) ;
80447: LD_INT 35
80449: PPUSH
80450: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80454: LD_VAR 0 2
80458: PPUSH
80459: LD_VAR 0 3
80463: PPUSH
80464: CALL_OW 284
80468: IFFALSE 80447
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80470: LD_VAR 0 2
80474: PPUSH
80475: LD_VAR 0 3
80479: PPUSH
80480: CALL_OW 283
80484: PUSH
80485: LD_INT 4
80487: EQUAL
80488: IFFALSE 80492
// exit ;
80490: GO 80800
// for i = 1 to mc_bases do
80492: LD_ADDR_VAR 0 7
80496: PUSH
80497: DOUBLE
80498: LD_INT 1
80500: DEC
80501: ST_TO_ADDR
80502: LD_EXP 52
80506: PUSH
80507: FOR_TO
80508: IFFALSE 80798
// begin if mc_crates_area [ i ] then
80510: LD_EXP 70
80514: PUSH
80515: LD_VAR 0 7
80519: ARRAY
80520: IFFALSE 80631
// for j in mc_crates_area [ i ] do
80522: LD_ADDR_VAR 0 8
80526: PUSH
80527: LD_EXP 70
80531: PUSH
80532: LD_VAR 0 7
80536: ARRAY
80537: PUSH
80538: FOR_IN
80539: IFFALSE 80629
// if InArea ( x , y , j ) then
80541: LD_VAR 0 2
80545: PPUSH
80546: LD_VAR 0 3
80550: PPUSH
80551: LD_VAR 0 8
80555: PPUSH
80556: CALL_OW 309
80560: IFFALSE 80627
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80562: LD_ADDR_EXP 68
80566: PUSH
80567: LD_EXP 68
80571: PPUSH
80572: LD_VAR 0 7
80576: PUSH
80577: LD_EXP 68
80581: PUSH
80582: LD_VAR 0 7
80586: ARRAY
80587: PUSH
80588: LD_INT 1
80590: PLUS
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PPUSH
80596: LD_VAR 0 4
80600: PUSH
80601: LD_VAR 0 2
80605: PUSH
80606: LD_VAR 0 3
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: LIST
80615: PPUSH
80616: CALL 18165 0 3
80620: ST_TO_ADDR
// exit ;
80621: POP
80622: POP
80623: POP
80624: POP
80625: GO 80800
// end ;
80627: GO 80538
80629: POP
80630: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80631: LD_ADDR_VAR 0 9
80635: PUSH
80636: LD_EXP 52
80640: PUSH
80641: LD_VAR 0 7
80645: ARRAY
80646: PPUSH
80647: LD_INT 2
80649: PUSH
80650: LD_INT 30
80652: PUSH
80653: LD_INT 0
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 30
80662: PUSH
80663: LD_INT 1
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: LIST
80674: PPUSH
80675: CALL_OW 72
80679: ST_TO_ADDR
// if not depot then
80680: LD_VAR 0 9
80684: NOT
80685: IFFALSE 80689
// continue ;
80687: GO 80507
// for j in depot do
80689: LD_ADDR_VAR 0 8
80693: PUSH
80694: LD_VAR 0 9
80698: PUSH
80699: FOR_IN
80700: IFFALSE 80794
// if GetDistUnitXY ( j , x , y ) < 30 then
80702: LD_VAR 0 8
80706: PPUSH
80707: LD_VAR 0 2
80711: PPUSH
80712: LD_VAR 0 3
80716: PPUSH
80717: CALL_OW 297
80721: PUSH
80722: LD_INT 30
80724: LESS
80725: IFFALSE 80792
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80727: LD_ADDR_EXP 68
80731: PUSH
80732: LD_EXP 68
80736: PPUSH
80737: LD_VAR 0 7
80741: PUSH
80742: LD_EXP 68
80746: PUSH
80747: LD_VAR 0 7
80751: ARRAY
80752: PUSH
80753: LD_INT 1
80755: PLUS
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PPUSH
80761: LD_VAR 0 4
80765: PUSH
80766: LD_VAR 0 2
80770: PUSH
80771: LD_VAR 0 3
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: LIST
80780: PPUSH
80781: CALL 18165 0 3
80785: ST_TO_ADDR
// exit ;
80786: POP
80787: POP
80788: POP
80789: POP
80790: GO 80800
// end ;
80792: GO 80699
80794: POP
80795: POP
// end ;
80796: GO 80507
80798: POP
80799: POP
// end ;
80800: LD_VAR 0 6
80804: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80805: LD_INT 0
80807: PPUSH
80808: PPUSH
80809: PPUSH
80810: PPUSH
// if not mc_bases or not skirmish then
80811: LD_EXP 52
80815: NOT
80816: PUSH
80817: LD_EXP 50
80821: NOT
80822: OR
80823: IFFALSE 80827
// exit ;
80825: GO 81104
// side := GetSide ( lab ) ;
80827: LD_ADDR_VAR 0 4
80831: PUSH
80832: LD_VAR 0 2
80836: PPUSH
80837: CALL_OW 255
80841: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80842: LD_VAR 0 4
80846: PUSH
80847: LD_EXP 78
80851: IN
80852: NOT
80853: PUSH
80854: LD_EXP 79
80858: NOT
80859: OR
80860: PUSH
80861: LD_EXP 52
80865: NOT
80866: OR
80867: IFFALSE 80871
// exit ;
80869: GO 81104
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80871: LD_ADDR_EXP 79
80875: PUSH
80876: LD_EXP 79
80880: PPUSH
80881: LD_VAR 0 4
80885: PPUSH
80886: LD_EXP 79
80890: PUSH
80891: LD_VAR 0 4
80895: ARRAY
80896: PUSH
80897: LD_VAR 0 1
80901: DIFF
80902: PPUSH
80903: CALL_OW 1
80907: ST_TO_ADDR
// for i = 1 to mc_bases do
80908: LD_ADDR_VAR 0 5
80912: PUSH
80913: DOUBLE
80914: LD_INT 1
80916: DEC
80917: ST_TO_ADDR
80918: LD_EXP 52
80922: PUSH
80923: FOR_TO
80924: IFFALSE 81102
// begin if lab in mc_bases [ i ] then
80926: LD_VAR 0 2
80930: PUSH
80931: LD_EXP 52
80935: PUSH
80936: LD_VAR 0 5
80940: ARRAY
80941: IN
80942: IFFALSE 81100
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80944: LD_VAR 0 1
80948: PUSH
80949: LD_INT 11
80951: PUSH
80952: LD_INT 4
80954: PUSH
80955: LD_INT 3
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: IN
80967: PUSH
80968: LD_EXP 82
80972: PUSH
80973: LD_VAR 0 5
80977: ARRAY
80978: AND
80979: IFFALSE 81100
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80981: LD_ADDR_VAR 0 6
80985: PUSH
80986: LD_EXP 82
80990: PUSH
80991: LD_VAR 0 5
80995: ARRAY
80996: PUSH
80997: LD_INT 1
80999: ARRAY
81000: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81001: LD_ADDR_EXP 82
81005: PUSH
81006: LD_EXP 82
81010: PPUSH
81011: LD_VAR 0 5
81015: PPUSH
81016: EMPTY
81017: PPUSH
81018: CALL_OW 1
81022: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81023: LD_VAR 0 6
81027: PPUSH
81028: LD_INT 0
81030: PPUSH
81031: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81035: LD_VAR 0 6
81039: PPUSH
81040: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81044: LD_ADDR_EXP 81
81048: PUSH
81049: LD_EXP 81
81053: PPUSH
81054: LD_VAR 0 5
81058: PPUSH
81059: LD_EXP 81
81063: PUSH
81064: LD_VAR 0 5
81068: ARRAY
81069: PPUSH
81070: LD_INT 1
81072: PPUSH
81073: LD_VAR 0 6
81077: PPUSH
81078: CALL_OW 2
81082: PPUSH
81083: CALL_OW 1
81087: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81088: LD_VAR 0 5
81092: PPUSH
81093: LD_INT 112
81095: PPUSH
81096: CALL 58212 0 2
// end ; end ; end ;
81100: GO 80923
81102: POP
81103: POP
// end ;
81104: LD_VAR 0 3
81108: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81109: LD_INT 0
81111: PPUSH
81112: PPUSH
81113: PPUSH
81114: PPUSH
81115: PPUSH
81116: PPUSH
81117: PPUSH
81118: PPUSH
// if not mc_bases or not skirmish then
81119: LD_EXP 52
81123: NOT
81124: PUSH
81125: LD_EXP 50
81129: NOT
81130: OR
81131: IFFALSE 81135
// exit ;
81133: GO 82372
// for i = 1 to mc_bases do
81135: LD_ADDR_VAR 0 3
81139: PUSH
81140: DOUBLE
81141: LD_INT 1
81143: DEC
81144: ST_TO_ADDR
81145: LD_EXP 52
81149: PUSH
81150: FOR_TO
81151: IFFALSE 82370
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81153: LD_VAR 0 1
81157: PUSH
81158: LD_EXP 52
81162: PUSH
81163: LD_VAR 0 3
81167: ARRAY
81168: IN
81169: PUSH
81170: LD_VAR 0 1
81174: PUSH
81175: LD_EXP 59
81179: PUSH
81180: LD_VAR 0 3
81184: ARRAY
81185: IN
81186: OR
81187: PUSH
81188: LD_VAR 0 1
81192: PUSH
81193: LD_EXP 74
81197: PUSH
81198: LD_VAR 0 3
81202: ARRAY
81203: IN
81204: OR
81205: PUSH
81206: LD_VAR 0 1
81210: PUSH
81211: LD_EXP 71
81215: PUSH
81216: LD_VAR 0 3
81220: ARRAY
81221: IN
81222: OR
81223: PUSH
81224: LD_VAR 0 1
81228: PUSH
81229: LD_EXP 81
81233: PUSH
81234: LD_VAR 0 3
81238: ARRAY
81239: IN
81240: OR
81241: PUSH
81242: LD_VAR 0 1
81246: PUSH
81247: LD_EXP 82
81251: PUSH
81252: LD_VAR 0 3
81256: ARRAY
81257: IN
81258: OR
81259: IFFALSE 82368
// begin if un in mc_ape [ i ] then
81261: LD_VAR 0 1
81265: PUSH
81266: LD_EXP 81
81270: PUSH
81271: LD_VAR 0 3
81275: ARRAY
81276: IN
81277: IFFALSE 81316
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81279: LD_ADDR_EXP 81
81283: PUSH
81284: LD_EXP 81
81288: PPUSH
81289: LD_VAR 0 3
81293: PPUSH
81294: LD_EXP 81
81298: PUSH
81299: LD_VAR 0 3
81303: ARRAY
81304: PUSH
81305: LD_VAR 0 1
81309: DIFF
81310: PPUSH
81311: CALL_OW 1
81315: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81316: LD_VAR 0 1
81320: PUSH
81321: LD_EXP 82
81325: PUSH
81326: LD_VAR 0 3
81330: ARRAY
81331: IN
81332: IFFALSE 81356
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81334: LD_ADDR_EXP 82
81338: PUSH
81339: LD_EXP 82
81343: PPUSH
81344: LD_VAR 0 3
81348: PPUSH
81349: EMPTY
81350: PPUSH
81351: CALL_OW 1
81355: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
81356: LD_VAR 0 1
81360: PPUSH
81361: CALL_OW 247
81365: PUSH
81366: LD_INT 2
81368: EQUAL
81369: PUSH
81370: LD_VAR 0 1
81374: PPUSH
81375: CALL_OW 110
81379: PUSH
81380: LD_INT 20
81382: EQUAL
81383: PUSH
81384: LD_VAR 0 1
81388: PUSH
81389: LD_EXP 74
81393: PUSH
81394: LD_VAR 0 3
81398: ARRAY
81399: IN
81400: OR
81401: PUSH
81402: LD_VAR 0 1
81406: PPUSH
81407: CALL_OW 264
81411: PUSH
81412: LD_INT 12
81414: PUSH
81415: LD_INT 51
81417: PUSH
81418: LD_EXP 46
81422: PUSH
81423: LD_INT 32
81425: PUSH
81426: LD_INT 13
81428: PUSH
81429: LD_INT 52
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: IN
81440: OR
81441: AND
81442: IFFALSE 81620
// begin if un in mc_defender [ i ] then
81444: LD_VAR 0 1
81448: PUSH
81449: LD_EXP 74
81453: PUSH
81454: LD_VAR 0 3
81458: ARRAY
81459: IN
81460: IFFALSE 81499
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81462: LD_ADDR_EXP 74
81466: PUSH
81467: LD_EXP 74
81471: PPUSH
81472: LD_VAR 0 3
81476: PPUSH
81477: LD_EXP 74
81481: PUSH
81482: LD_VAR 0 3
81486: ARRAY
81487: PUSH
81488: LD_VAR 0 1
81492: DIFF
81493: PPUSH
81494: CALL_OW 1
81498: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
81499: LD_ADDR_VAR 0 8
81503: PUSH
81504: LD_VAR 0 3
81508: PPUSH
81509: LD_INT 3
81511: PPUSH
81512: CALL 78172 0 2
81516: ST_TO_ADDR
// if fac then
81517: LD_VAR 0 8
81521: IFFALSE 81620
// begin for j in fac do
81523: LD_ADDR_VAR 0 4
81527: PUSH
81528: LD_VAR 0 8
81532: PUSH
81533: FOR_IN
81534: IFFALSE 81618
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81536: LD_ADDR_VAR 0 9
81540: PUSH
81541: LD_VAR 0 8
81545: PPUSH
81546: LD_VAR 0 1
81550: PPUSH
81551: CALL_OW 265
81555: PPUSH
81556: LD_VAR 0 1
81560: PPUSH
81561: CALL_OW 262
81565: PPUSH
81566: LD_VAR 0 1
81570: PPUSH
81571: CALL_OW 263
81575: PPUSH
81576: LD_VAR 0 1
81580: PPUSH
81581: CALL_OW 264
81585: PPUSH
81586: CALL 15697 0 5
81590: ST_TO_ADDR
// if components then
81591: LD_VAR 0 9
81595: IFFALSE 81616
// begin MC_InsertProduceList ( i , [ components ] ) ;
81597: LD_VAR 0 3
81601: PPUSH
81602: LD_VAR 0 9
81606: PUSH
81607: EMPTY
81608: LIST
81609: PPUSH
81610: CALL 77717 0 2
// break ;
81614: GO 81618
// end ; end ;
81616: GO 81533
81618: POP
81619: POP
// end ; end ; if GetType ( un ) = unit_building then
81620: LD_VAR 0 1
81624: PPUSH
81625: CALL_OW 247
81629: PUSH
81630: LD_INT 3
81632: EQUAL
81633: IFFALSE 82036
// begin btype := GetBType ( un ) ;
81635: LD_ADDR_VAR 0 5
81639: PUSH
81640: LD_VAR 0 1
81644: PPUSH
81645: CALL_OW 266
81649: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81650: LD_VAR 0 5
81654: PUSH
81655: LD_INT 29
81657: PUSH
81658: LD_INT 30
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: IN
81665: IFFALSE 81738
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81667: LD_VAR 0 1
81671: PPUSH
81672: CALL_OW 250
81676: PPUSH
81677: LD_VAR 0 1
81681: PPUSH
81682: CALL_OW 251
81686: PPUSH
81687: LD_VAR 0 1
81691: PPUSH
81692: CALL_OW 255
81696: PPUSH
81697: CALL_OW 440
81701: NOT
81702: IFFALSE 81738
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81704: LD_VAR 0 1
81708: PPUSH
81709: CALL_OW 250
81713: PPUSH
81714: LD_VAR 0 1
81718: PPUSH
81719: CALL_OW 251
81723: PPUSH
81724: LD_VAR 0 1
81728: PPUSH
81729: CALL_OW 255
81733: PPUSH
81734: CALL_OW 441
// end ; if btype = b_warehouse then
81738: LD_VAR 0 5
81742: PUSH
81743: LD_INT 1
81745: EQUAL
81746: IFFALSE 81764
// begin btype := b_depot ;
81748: LD_ADDR_VAR 0 5
81752: PUSH
81753: LD_INT 0
81755: ST_TO_ADDR
// pos := 1 ;
81756: LD_ADDR_VAR 0 6
81760: PUSH
81761: LD_INT 1
81763: ST_TO_ADDR
// end ; if btype = b_factory then
81764: LD_VAR 0 5
81768: PUSH
81769: LD_INT 3
81771: EQUAL
81772: IFFALSE 81790
// begin btype := b_workshop ;
81774: LD_ADDR_VAR 0 5
81778: PUSH
81779: LD_INT 2
81781: ST_TO_ADDR
// pos := 1 ;
81782: LD_ADDR_VAR 0 6
81786: PUSH
81787: LD_INT 1
81789: ST_TO_ADDR
// end ; if btype = b_barracks then
81790: LD_VAR 0 5
81794: PUSH
81795: LD_INT 5
81797: EQUAL
81798: IFFALSE 81808
// btype := b_armoury ;
81800: LD_ADDR_VAR 0 5
81804: PUSH
81805: LD_INT 4
81807: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81808: LD_VAR 0 5
81812: PUSH
81813: LD_INT 7
81815: PUSH
81816: LD_INT 8
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: IN
81823: IFFALSE 81833
// btype := b_lab ;
81825: LD_ADDR_VAR 0 5
81829: PUSH
81830: LD_INT 6
81832: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81833: LD_ADDR_EXP 57
81837: PUSH
81838: LD_EXP 57
81842: PPUSH
81843: LD_VAR 0 3
81847: PUSH
81848: LD_EXP 57
81852: PUSH
81853: LD_VAR 0 3
81857: ARRAY
81858: PUSH
81859: LD_INT 1
81861: PLUS
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PPUSH
81867: LD_VAR 0 5
81871: PUSH
81872: LD_VAR 0 1
81876: PPUSH
81877: CALL_OW 250
81881: PUSH
81882: LD_VAR 0 1
81886: PPUSH
81887: CALL_OW 251
81891: PUSH
81892: LD_VAR 0 1
81896: PPUSH
81897: CALL_OW 254
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: PPUSH
81908: CALL 18165 0 3
81912: ST_TO_ADDR
// if pos = 1 then
81913: LD_VAR 0 6
81917: PUSH
81918: LD_INT 1
81920: EQUAL
81921: IFFALSE 82036
// begin tmp := mc_build_list [ i ] ;
81923: LD_ADDR_VAR 0 7
81927: PUSH
81928: LD_EXP 57
81932: PUSH
81933: LD_VAR 0 3
81937: ARRAY
81938: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81939: LD_VAR 0 7
81943: PPUSH
81944: LD_INT 2
81946: PUSH
81947: LD_INT 30
81949: PUSH
81950: LD_INT 0
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 30
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: LIST
81971: PPUSH
81972: CALL_OW 72
81976: IFFALSE 81986
// pos := 2 ;
81978: LD_ADDR_VAR 0 6
81982: PUSH
81983: LD_INT 2
81985: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81986: LD_ADDR_VAR 0 7
81990: PUSH
81991: LD_VAR 0 7
81995: PPUSH
81996: LD_VAR 0 6
82000: PPUSH
82001: LD_VAR 0 7
82005: PPUSH
82006: CALL 18491 0 3
82010: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82011: LD_ADDR_EXP 57
82015: PUSH
82016: LD_EXP 57
82020: PPUSH
82021: LD_VAR 0 3
82025: PPUSH
82026: LD_VAR 0 7
82030: PPUSH
82031: CALL_OW 1
82035: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82036: LD_VAR 0 1
82040: PUSH
82041: LD_EXP 52
82045: PUSH
82046: LD_VAR 0 3
82050: ARRAY
82051: IN
82052: IFFALSE 82091
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82054: LD_ADDR_EXP 52
82058: PUSH
82059: LD_EXP 52
82063: PPUSH
82064: LD_VAR 0 3
82068: PPUSH
82069: LD_EXP 52
82073: PUSH
82074: LD_VAR 0 3
82078: ARRAY
82079: PUSH
82080: LD_VAR 0 1
82084: DIFF
82085: PPUSH
82086: CALL_OW 1
82090: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82091: LD_VAR 0 1
82095: PUSH
82096: LD_EXP 59
82100: PUSH
82101: LD_VAR 0 3
82105: ARRAY
82106: IN
82107: IFFALSE 82146
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82109: LD_ADDR_EXP 59
82113: PUSH
82114: LD_EXP 59
82118: PPUSH
82119: LD_VAR 0 3
82123: PPUSH
82124: LD_EXP 59
82128: PUSH
82129: LD_VAR 0 3
82133: ARRAY
82134: PUSH
82135: LD_VAR 0 1
82139: DIFF
82140: PPUSH
82141: CALL_OW 1
82145: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82146: LD_VAR 0 1
82150: PUSH
82151: LD_EXP 71
82155: PUSH
82156: LD_VAR 0 3
82160: ARRAY
82161: IN
82162: IFFALSE 82201
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82164: LD_ADDR_EXP 71
82168: PUSH
82169: LD_EXP 71
82173: PPUSH
82174: LD_VAR 0 3
82178: PPUSH
82179: LD_EXP 71
82183: PUSH
82184: LD_VAR 0 3
82188: ARRAY
82189: PUSH
82190: LD_VAR 0 1
82194: DIFF
82195: PPUSH
82196: CALL_OW 1
82200: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82201: LD_VAR 0 1
82205: PUSH
82206: LD_EXP 74
82210: PUSH
82211: LD_VAR 0 3
82215: ARRAY
82216: IN
82217: IFFALSE 82256
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82219: LD_ADDR_EXP 74
82223: PUSH
82224: LD_EXP 74
82228: PPUSH
82229: LD_VAR 0 3
82233: PPUSH
82234: LD_EXP 74
82238: PUSH
82239: LD_VAR 0 3
82243: ARRAY
82244: PUSH
82245: LD_VAR 0 1
82249: DIFF
82250: PPUSH
82251: CALL_OW 1
82255: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82256: LD_VAR 0 1
82260: PUSH
82261: LD_EXP 61
82265: PUSH
82266: LD_VAR 0 3
82270: ARRAY
82271: IN
82272: IFFALSE 82311
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82274: LD_ADDR_EXP 61
82278: PUSH
82279: LD_EXP 61
82283: PPUSH
82284: LD_VAR 0 3
82288: PPUSH
82289: LD_EXP 61
82293: PUSH
82294: LD_VAR 0 3
82298: ARRAY
82299: PUSH
82300: LD_VAR 0 1
82304: DIFF
82305: PPUSH
82306: CALL_OW 1
82310: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82311: LD_VAR 0 1
82315: PUSH
82316: LD_EXP 60
82320: PUSH
82321: LD_VAR 0 3
82325: ARRAY
82326: IN
82327: IFFALSE 82366
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82329: LD_ADDR_EXP 60
82333: PUSH
82334: LD_EXP 60
82338: PPUSH
82339: LD_VAR 0 3
82343: PPUSH
82344: LD_EXP 60
82348: PUSH
82349: LD_VAR 0 3
82353: ARRAY
82354: PUSH
82355: LD_VAR 0 1
82359: DIFF
82360: PPUSH
82361: CALL_OW 1
82365: ST_TO_ADDR
// end ; break ;
82366: GO 82370
// end ;
82368: GO 81150
82370: POP
82371: POP
// end ;
82372: LD_VAR 0 2
82376: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82377: LD_INT 0
82379: PPUSH
82380: PPUSH
82381: PPUSH
// if not mc_bases or not skirmish then
82382: LD_EXP 52
82386: NOT
82387: PUSH
82388: LD_EXP 50
82392: NOT
82393: OR
82394: IFFALSE 82398
// exit ;
82396: GO 82613
// for i = 1 to mc_bases do
82398: LD_ADDR_VAR 0 3
82402: PUSH
82403: DOUBLE
82404: LD_INT 1
82406: DEC
82407: ST_TO_ADDR
82408: LD_EXP 52
82412: PUSH
82413: FOR_TO
82414: IFFALSE 82611
// begin if building in mc_construct_list [ i ] then
82416: LD_VAR 0 1
82420: PUSH
82421: LD_EXP 59
82425: PUSH
82426: LD_VAR 0 3
82430: ARRAY
82431: IN
82432: IFFALSE 82609
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82434: LD_ADDR_EXP 59
82438: PUSH
82439: LD_EXP 59
82443: PPUSH
82444: LD_VAR 0 3
82448: PPUSH
82449: LD_EXP 59
82453: PUSH
82454: LD_VAR 0 3
82458: ARRAY
82459: PUSH
82460: LD_VAR 0 1
82464: DIFF
82465: PPUSH
82466: CALL_OW 1
82470: ST_TO_ADDR
// if building in mc_lab [ i ] then
82471: LD_VAR 0 1
82475: PUSH
82476: LD_EXP 85
82480: PUSH
82481: LD_VAR 0 3
82485: ARRAY
82486: IN
82487: IFFALSE 82542
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82489: LD_ADDR_EXP 86
82493: PUSH
82494: LD_EXP 86
82498: PPUSH
82499: LD_VAR 0 3
82503: PPUSH
82504: LD_EXP 86
82508: PUSH
82509: LD_VAR 0 3
82513: ARRAY
82514: PPUSH
82515: LD_INT 1
82517: PPUSH
82518: LD_EXP 86
82522: PUSH
82523: LD_VAR 0 3
82527: ARRAY
82528: PPUSH
82529: LD_INT 0
82531: PPUSH
82532: CALL 17583 0 4
82536: PPUSH
82537: CALL_OW 1
82541: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82542: LD_VAR 0 1
82546: PUSH
82547: LD_EXP 52
82551: PUSH
82552: LD_VAR 0 3
82556: ARRAY
82557: IN
82558: NOT
82559: IFFALSE 82605
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82561: LD_ADDR_EXP 52
82565: PUSH
82566: LD_EXP 52
82570: PPUSH
82571: LD_VAR 0 3
82575: PUSH
82576: LD_EXP 52
82580: PUSH
82581: LD_VAR 0 3
82585: ARRAY
82586: PUSH
82587: LD_INT 1
82589: PLUS
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PPUSH
82595: LD_VAR 0 1
82599: PPUSH
82600: CALL 18165 0 3
82604: ST_TO_ADDR
// exit ;
82605: POP
82606: POP
82607: GO 82613
// end ; end ;
82609: GO 82413
82611: POP
82612: POP
// end ;
82613: LD_VAR 0 2
82617: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82618: LD_INT 0
82620: PPUSH
82621: PPUSH
82622: PPUSH
82623: PPUSH
82624: PPUSH
82625: PPUSH
82626: PPUSH
// if not mc_bases or not skirmish then
82627: LD_EXP 52
82631: NOT
82632: PUSH
82633: LD_EXP 50
82637: NOT
82638: OR
82639: IFFALSE 82643
// exit ;
82641: GO 83304
// for i = 1 to mc_bases do
82643: LD_ADDR_VAR 0 3
82647: PUSH
82648: DOUBLE
82649: LD_INT 1
82651: DEC
82652: ST_TO_ADDR
82653: LD_EXP 52
82657: PUSH
82658: FOR_TO
82659: IFFALSE 83302
// begin if building in mc_construct_list [ i ] then
82661: LD_VAR 0 1
82665: PUSH
82666: LD_EXP 59
82670: PUSH
82671: LD_VAR 0 3
82675: ARRAY
82676: IN
82677: IFFALSE 83300
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82679: LD_ADDR_EXP 59
82683: PUSH
82684: LD_EXP 59
82688: PPUSH
82689: LD_VAR 0 3
82693: PPUSH
82694: LD_EXP 59
82698: PUSH
82699: LD_VAR 0 3
82703: ARRAY
82704: PUSH
82705: LD_VAR 0 1
82709: DIFF
82710: PPUSH
82711: CALL_OW 1
82715: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82716: LD_ADDR_EXP 52
82720: PUSH
82721: LD_EXP 52
82725: PPUSH
82726: LD_VAR 0 3
82730: PUSH
82731: LD_EXP 52
82735: PUSH
82736: LD_VAR 0 3
82740: ARRAY
82741: PUSH
82742: LD_INT 1
82744: PLUS
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PPUSH
82750: LD_VAR 0 1
82754: PPUSH
82755: CALL 18165 0 3
82759: ST_TO_ADDR
// btype := GetBType ( building ) ;
82760: LD_ADDR_VAR 0 5
82764: PUSH
82765: LD_VAR 0 1
82769: PPUSH
82770: CALL_OW 266
82774: ST_TO_ADDR
// side := GetSide ( building ) ;
82775: LD_ADDR_VAR 0 8
82779: PUSH
82780: LD_VAR 0 1
82784: PPUSH
82785: CALL_OW 255
82789: ST_TO_ADDR
// if btype = b_lab then
82790: LD_VAR 0 5
82794: PUSH
82795: LD_INT 6
82797: EQUAL
82798: IFFALSE 82848
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82800: LD_ADDR_EXP 85
82804: PUSH
82805: LD_EXP 85
82809: PPUSH
82810: LD_VAR 0 3
82814: PUSH
82815: LD_EXP 85
82819: PUSH
82820: LD_VAR 0 3
82824: ARRAY
82825: PUSH
82826: LD_INT 1
82828: PLUS
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PPUSH
82834: LD_VAR 0 1
82838: PPUSH
82839: CALL 18165 0 3
82843: ST_TO_ADDR
// exit ;
82844: POP
82845: POP
82846: GO 83304
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82848: LD_VAR 0 5
82852: PUSH
82853: LD_INT 0
82855: PUSH
82856: LD_INT 2
82858: PUSH
82859: LD_INT 4
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: LIST
82866: IN
82867: IFFALSE 82991
// begin if btype = b_armoury then
82869: LD_VAR 0 5
82873: PUSH
82874: LD_INT 4
82876: EQUAL
82877: IFFALSE 82887
// btype := b_barracks ;
82879: LD_ADDR_VAR 0 5
82883: PUSH
82884: LD_INT 5
82886: ST_TO_ADDR
// if btype = b_depot then
82887: LD_VAR 0 5
82891: PUSH
82892: LD_INT 0
82894: EQUAL
82895: IFFALSE 82905
// btype := b_warehouse ;
82897: LD_ADDR_VAR 0 5
82901: PUSH
82902: LD_INT 1
82904: ST_TO_ADDR
// if btype = b_workshop then
82905: LD_VAR 0 5
82909: PUSH
82910: LD_INT 2
82912: EQUAL
82913: IFFALSE 82923
// btype := b_factory ;
82915: LD_ADDR_VAR 0 5
82919: PUSH
82920: LD_INT 3
82922: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82923: LD_VAR 0 5
82927: PPUSH
82928: LD_VAR 0 8
82932: PPUSH
82933: CALL_OW 323
82937: PUSH
82938: LD_INT 1
82940: EQUAL
82941: IFFALSE 82987
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82943: LD_ADDR_EXP 84
82947: PUSH
82948: LD_EXP 84
82952: PPUSH
82953: LD_VAR 0 3
82957: PUSH
82958: LD_EXP 84
82962: PUSH
82963: LD_VAR 0 3
82967: ARRAY
82968: PUSH
82969: LD_INT 1
82971: PLUS
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PPUSH
82977: LD_VAR 0 1
82981: PPUSH
82982: CALL 18165 0 3
82986: ST_TO_ADDR
// exit ;
82987: POP
82988: POP
82989: GO 83304
// end ; if btype in [ b_bunker , b_turret ] then
82991: LD_VAR 0 5
82995: PUSH
82996: LD_INT 32
82998: PUSH
82999: LD_INT 33
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: IN
83006: IFFALSE 83296
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83008: LD_ADDR_EXP 60
83012: PUSH
83013: LD_EXP 60
83017: PPUSH
83018: LD_VAR 0 3
83022: PUSH
83023: LD_EXP 60
83027: PUSH
83028: LD_VAR 0 3
83032: ARRAY
83033: PUSH
83034: LD_INT 1
83036: PLUS
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PPUSH
83042: LD_VAR 0 1
83046: PPUSH
83047: CALL 18165 0 3
83051: ST_TO_ADDR
// if btype = b_bunker then
83052: LD_VAR 0 5
83056: PUSH
83057: LD_INT 32
83059: EQUAL
83060: IFFALSE 83296
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83062: LD_ADDR_EXP 61
83066: PUSH
83067: LD_EXP 61
83071: PPUSH
83072: LD_VAR 0 3
83076: PUSH
83077: LD_EXP 61
83081: PUSH
83082: LD_VAR 0 3
83086: ARRAY
83087: PUSH
83088: LD_INT 1
83090: PLUS
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PPUSH
83096: LD_VAR 0 1
83100: PPUSH
83101: CALL 18165 0 3
83105: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83106: LD_ADDR_VAR 0 6
83110: PUSH
83111: LD_EXP 52
83115: PUSH
83116: LD_VAR 0 3
83120: ARRAY
83121: PPUSH
83122: LD_INT 25
83124: PUSH
83125: LD_INT 1
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 3
83134: PUSH
83135: LD_INT 54
83137: PUSH
83138: EMPTY
83139: LIST
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PPUSH
83149: CALL_OW 72
83153: ST_TO_ADDR
// if tmp then
83154: LD_VAR 0 6
83158: IFFALSE 83164
// exit ;
83160: POP
83161: POP
83162: GO 83304
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83164: LD_ADDR_VAR 0 6
83168: PUSH
83169: LD_EXP 52
83173: PUSH
83174: LD_VAR 0 3
83178: ARRAY
83179: PPUSH
83180: LD_INT 2
83182: PUSH
83183: LD_INT 30
83185: PUSH
83186: LD_INT 4
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 30
83195: PUSH
83196: LD_INT 5
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: LIST
83207: PPUSH
83208: CALL_OW 72
83212: ST_TO_ADDR
// if not tmp then
83213: LD_VAR 0 6
83217: NOT
83218: IFFALSE 83224
// exit ;
83220: POP
83221: POP
83222: GO 83304
// for j in tmp do
83224: LD_ADDR_VAR 0 4
83228: PUSH
83229: LD_VAR 0 6
83233: PUSH
83234: FOR_IN
83235: IFFALSE 83294
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83237: LD_ADDR_VAR 0 7
83241: PUSH
83242: LD_VAR 0 4
83246: PPUSH
83247: CALL_OW 313
83251: PPUSH
83252: LD_INT 25
83254: PUSH
83255: LD_INT 1
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PPUSH
83262: CALL_OW 72
83266: ST_TO_ADDR
// if units then
83267: LD_VAR 0 7
83271: IFFALSE 83292
// begin ComExitBuilding ( units [ 1 ] ) ;
83273: LD_VAR 0 7
83277: PUSH
83278: LD_INT 1
83280: ARRAY
83281: PPUSH
83282: CALL_OW 122
// exit ;
83286: POP
83287: POP
83288: POP
83289: POP
83290: GO 83304
// end ; end ;
83292: GO 83234
83294: POP
83295: POP
// end ; end ; exit ;
83296: POP
83297: POP
83298: GO 83304
// end ; end ;
83300: GO 82658
83302: POP
83303: POP
// end ;
83304: LD_VAR 0 2
83308: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83309: LD_INT 0
83311: PPUSH
83312: PPUSH
83313: PPUSH
83314: PPUSH
83315: PPUSH
83316: PPUSH
83317: PPUSH
// if not mc_bases or not skirmish then
83318: LD_EXP 52
83322: NOT
83323: PUSH
83324: LD_EXP 50
83328: NOT
83329: OR
83330: IFFALSE 83334
// exit ;
83332: GO 83565
// btype := GetBType ( building ) ;
83334: LD_ADDR_VAR 0 6
83338: PUSH
83339: LD_VAR 0 1
83343: PPUSH
83344: CALL_OW 266
83348: ST_TO_ADDR
// x := GetX ( building ) ;
83349: LD_ADDR_VAR 0 7
83353: PUSH
83354: LD_VAR 0 1
83358: PPUSH
83359: CALL_OW 250
83363: ST_TO_ADDR
// y := GetY ( building ) ;
83364: LD_ADDR_VAR 0 8
83368: PUSH
83369: LD_VAR 0 1
83373: PPUSH
83374: CALL_OW 251
83378: ST_TO_ADDR
// d := GetDir ( building ) ;
83379: LD_ADDR_VAR 0 9
83383: PUSH
83384: LD_VAR 0 1
83388: PPUSH
83389: CALL_OW 254
83393: ST_TO_ADDR
// for i = 1 to mc_bases do
83394: LD_ADDR_VAR 0 4
83398: PUSH
83399: DOUBLE
83400: LD_INT 1
83402: DEC
83403: ST_TO_ADDR
83404: LD_EXP 52
83408: PUSH
83409: FOR_TO
83410: IFFALSE 83563
// begin if not mc_build_list [ i ] then
83412: LD_EXP 57
83416: PUSH
83417: LD_VAR 0 4
83421: ARRAY
83422: NOT
83423: IFFALSE 83427
// continue ;
83425: GO 83409
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
83427: LD_VAR 0 6
83431: PUSH
83432: LD_VAR 0 7
83436: PUSH
83437: LD_VAR 0 8
83441: PUSH
83442: LD_VAR 0 9
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: PPUSH
83453: LD_EXP 57
83457: PUSH
83458: LD_VAR 0 4
83462: ARRAY
83463: PUSH
83464: LD_INT 1
83466: ARRAY
83467: PPUSH
83468: CALL 24334 0 2
83472: IFFALSE 83561
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
83474: LD_ADDR_EXP 57
83478: PUSH
83479: LD_EXP 57
83483: PPUSH
83484: LD_VAR 0 4
83488: PPUSH
83489: LD_EXP 57
83493: PUSH
83494: LD_VAR 0 4
83498: ARRAY
83499: PPUSH
83500: LD_INT 1
83502: PPUSH
83503: CALL_OW 3
83507: PPUSH
83508: CALL_OW 1
83512: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83513: LD_ADDR_EXP 59
83517: PUSH
83518: LD_EXP 59
83522: PPUSH
83523: LD_VAR 0 4
83527: PUSH
83528: LD_EXP 59
83532: PUSH
83533: LD_VAR 0 4
83537: ARRAY
83538: PUSH
83539: LD_INT 1
83541: PLUS
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PPUSH
83547: LD_VAR 0 1
83551: PPUSH
83552: CALL 18165 0 3
83556: ST_TO_ADDR
// exit ;
83557: POP
83558: POP
83559: GO 83565
// end ; end ;
83561: GO 83409
83563: POP
83564: POP
// end ;
83565: LD_VAR 0 3
83569: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83570: LD_INT 0
83572: PPUSH
83573: PPUSH
83574: PPUSH
// if not mc_bases or not skirmish then
83575: LD_EXP 52
83579: NOT
83580: PUSH
83581: LD_EXP 50
83585: NOT
83586: OR
83587: IFFALSE 83591
// exit ;
83589: GO 83781
// for i = 1 to mc_bases do
83591: LD_ADDR_VAR 0 4
83595: PUSH
83596: DOUBLE
83597: LD_INT 1
83599: DEC
83600: ST_TO_ADDR
83601: LD_EXP 52
83605: PUSH
83606: FOR_TO
83607: IFFALSE 83694
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83609: LD_VAR 0 1
83613: PUSH
83614: LD_EXP 60
83618: PUSH
83619: LD_VAR 0 4
83623: ARRAY
83624: IN
83625: PUSH
83626: LD_VAR 0 1
83630: PUSH
83631: LD_EXP 61
83635: PUSH
83636: LD_VAR 0 4
83640: ARRAY
83641: IN
83642: NOT
83643: AND
83644: IFFALSE 83692
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83646: LD_ADDR_EXP 61
83650: PUSH
83651: LD_EXP 61
83655: PPUSH
83656: LD_VAR 0 4
83660: PUSH
83661: LD_EXP 61
83665: PUSH
83666: LD_VAR 0 4
83670: ARRAY
83671: PUSH
83672: LD_INT 1
83674: PLUS
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PPUSH
83680: LD_VAR 0 1
83684: PPUSH
83685: CALL 18165 0 3
83689: ST_TO_ADDR
// break ;
83690: GO 83694
// end ; end ;
83692: GO 83606
83694: POP
83695: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83696: LD_VAR 0 1
83700: PPUSH
83701: CALL_OW 257
83705: PUSH
83706: LD_EXP 78
83710: IN
83711: PUSH
83712: LD_VAR 0 1
83716: PPUSH
83717: CALL_OW 266
83721: PUSH
83722: LD_INT 5
83724: EQUAL
83725: AND
83726: PUSH
83727: LD_VAR 0 2
83731: PPUSH
83732: CALL_OW 110
83736: PUSH
83737: LD_INT 18
83739: NONEQUAL
83740: AND
83741: IFFALSE 83781
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83743: LD_VAR 0 2
83747: PPUSH
83748: CALL_OW 257
83752: PUSH
83753: LD_INT 5
83755: PUSH
83756: LD_INT 8
83758: PUSH
83759: LD_INT 9
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: LIST
83766: IN
83767: IFFALSE 83781
// SetClass ( unit , 1 ) ;
83769: LD_VAR 0 2
83773: PPUSH
83774: LD_INT 1
83776: PPUSH
83777: CALL_OW 336
// end ;
83781: LD_VAR 0 3
83785: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83786: LD_INT 0
83788: PPUSH
83789: PPUSH
// if not mc_bases or not skirmish then
83790: LD_EXP 52
83794: NOT
83795: PUSH
83796: LD_EXP 50
83800: NOT
83801: OR
83802: IFFALSE 83806
// exit ;
83804: GO 83922
// if GetLives ( abandoned_vehicle ) > 250 then
83806: LD_VAR 0 2
83810: PPUSH
83811: CALL_OW 256
83815: PUSH
83816: LD_INT 250
83818: GREATER
83819: IFFALSE 83823
// exit ;
83821: GO 83922
// for i = 1 to mc_bases do
83823: LD_ADDR_VAR 0 6
83827: PUSH
83828: DOUBLE
83829: LD_INT 1
83831: DEC
83832: ST_TO_ADDR
83833: LD_EXP 52
83837: PUSH
83838: FOR_TO
83839: IFFALSE 83920
// begin if driver in mc_bases [ i ] then
83841: LD_VAR 0 1
83845: PUSH
83846: LD_EXP 52
83850: PUSH
83851: LD_VAR 0 6
83855: ARRAY
83856: IN
83857: IFFALSE 83918
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83859: LD_VAR 0 1
83863: PPUSH
83864: LD_EXP 52
83868: PUSH
83869: LD_VAR 0 6
83873: ARRAY
83874: PPUSH
83875: LD_INT 2
83877: PUSH
83878: LD_INT 30
83880: PUSH
83881: LD_INT 0
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 30
83890: PUSH
83891: LD_INT 1
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: LIST
83902: PPUSH
83903: CALL_OW 72
83907: PUSH
83908: LD_INT 1
83910: ARRAY
83911: PPUSH
83912: CALL_OW 112
// break ;
83916: GO 83920
// end ; end ;
83918: GO 83838
83920: POP
83921: POP
// end ; end_of_file end_of_file end_of_file
83922: LD_VAR 0 5
83926: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
83927: LD_INT 0
83929: PPUSH
83930: PPUSH
83931: PPUSH
83932: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
83933: LD_VAR 0 1
83937: PPUSH
83938: CALL_OW 264
83942: PUSH
83943: LD_EXP 49
83947: EQUAL
83948: IFFALSE 84020
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
83950: LD_INT 68
83952: PPUSH
83953: LD_VAR 0 1
83957: PPUSH
83958: CALL_OW 255
83962: PPUSH
83963: CALL_OW 321
83967: PUSH
83968: LD_INT 2
83970: EQUAL
83971: IFFALSE 83983
// eff := 70 else
83973: LD_ADDR_VAR 0 6
83977: PUSH
83978: LD_INT 70
83980: ST_TO_ADDR
83981: GO 83991
// eff := 30 ;
83983: LD_ADDR_VAR 0 6
83987: PUSH
83988: LD_INT 30
83990: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
83991: LD_VAR 0 1
83995: PPUSH
83996: CALL_OW 250
84000: PPUSH
84001: LD_VAR 0 1
84005: PPUSH
84006: CALL_OW 251
84010: PPUSH
84011: LD_VAR 0 6
84015: PPUSH
84016: CALL_OW 495
// end ; end ;
84020: LD_VAR 0 4
84024: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
84025: LD_INT 0
84027: PPUSH
84028: PPUSH
84029: PPUSH
84030: PPUSH
84031: PPUSH
84032: PPUSH
// if cmd = 124 then
84033: LD_VAR 0 1
84037: PUSH
84038: LD_INT 124
84040: EQUAL
84041: IFFALSE 84247
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
84043: LD_ADDR_VAR 0 5
84047: PUSH
84048: LD_INT 2
84050: PUSH
84051: LD_INT 34
84053: PUSH
84054: LD_INT 53
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 34
84063: PUSH
84064: LD_INT 14
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: LIST
84075: PPUSH
84076: CALL_OW 69
84080: ST_TO_ADDR
// if not tmp then
84081: LD_VAR 0 5
84085: NOT
84086: IFFALSE 84090
// exit ;
84088: GO 84247
// for i in tmp do
84090: LD_ADDR_VAR 0 3
84094: PUSH
84095: LD_VAR 0 5
84099: PUSH
84100: FOR_IN
84101: IFFALSE 84245
// begin taskList := GetTaskList ( i ) ;
84103: LD_ADDR_VAR 0 6
84107: PUSH
84108: LD_VAR 0 3
84112: PPUSH
84113: CALL_OW 437
84117: ST_TO_ADDR
// if not taskList then
84118: LD_VAR 0 6
84122: NOT
84123: IFFALSE 84127
// continue ;
84125: GO 84100
// for j = 1 to taskList do
84127: LD_ADDR_VAR 0 4
84131: PUSH
84132: DOUBLE
84133: LD_INT 1
84135: DEC
84136: ST_TO_ADDR
84137: LD_VAR 0 6
84141: PUSH
84142: FOR_TO
84143: IFFALSE 84241
// if taskList [ j ] [ 1 ] = | then
84145: LD_VAR 0 6
84149: PUSH
84150: LD_VAR 0 4
84154: ARRAY
84155: PUSH
84156: LD_INT 1
84158: ARRAY
84159: PUSH
84160: LD_STRING |
84162: EQUAL
84163: IFFALSE 84239
// begin _taskList := Delete ( taskList , 1 ) ;
84165: LD_ADDR_VAR 0 7
84169: PUSH
84170: LD_VAR 0 6
84174: PPUSH
84175: LD_INT 1
84177: PPUSH
84178: CALL_OW 3
84182: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
84183: LD_VAR 0 3
84187: PPUSH
84188: LD_VAR 0 7
84192: PPUSH
84193: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
84197: LD_VAR 0 3
84201: PPUSH
84202: LD_VAR 0 6
84206: PUSH
84207: LD_VAR 0 4
84211: ARRAY
84212: PUSH
84213: LD_INT 2
84215: ARRAY
84216: PPUSH
84217: LD_VAR 0 6
84221: PUSH
84222: LD_VAR 0 4
84226: ARRAY
84227: PUSH
84228: LD_INT 3
84230: ARRAY
84231: PPUSH
84232: LD_INT 8
84234: PPUSH
84235: CALL 84252 0 4
// end ;
84239: GO 84142
84241: POP
84242: POP
// end ;
84243: GO 84100
84245: POP
84246: POP
// end ; end ;
84247: LD_VAR 0 2
84251: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
84252: LD_INT 0
84254: PPUSH
84255: PPUSH
84256: PPUSH
84257: PPUSH
84258: PPUSH
84259: PPUSH
84260: PPUSH
84261: PPUSH
84262: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
84263: LD_VAR 0 1
84267: NOT
84268: PUSH
84269: LD_VAR 0 2
84273: PPUSH
84274: LD_VAR 0 3
84278: PPUSH
84279: CALL_OW 488
84283: NOT
84284: OR
84285: PUSH
84286: LD_VAR 0 4
84290: NOT
84291: OR
84292: IFFALSE 84296
// exit ;
84294: GO 84636
// list := [ ] ;
84296: LD_ADDR_VAR 0 13
84300: PUSH
84301: EMPTY
84302: ST_TO_ADDR
// if x - r < 0 then
84303: LD_VAR 0 2
84307: PUSH
84308: LD_VAR 0 4
84312: MINUS
84313: PUSH
84314: LD_INT 0
84316: LESS
84317: IFFALSE 84329
// min_x := 0 else
84319: LD_ADDR_VAR 0 7
84323: PUSH
84324: LD_INT 0
84326: ST_TO_ADDR
84327: GO 84345
// min_x := x - r ;
84329: LD_ADDR_VAR 0 7
84333: PUSH
84334: LD_VAR 0 2
84338: PUSH
84339: LD_VAR 0 4
84343: MINUS
84344: ST_TO_ADDR
// if y - r < 0 then
84345: LD_VAR 0 3
84349: PUSH
84350: LD_VAR 0 4
84354: MINUS
84355: PUSH
84356: LD_INT 0
84358: LESS
84359: IFFALSE 84371
// min_y := 0 else
84361: LD_ADDR_VAR 0 8
84365: PUSH
84366: LD_INT 0
84368: ST_TO_ADDR
84369: GO 84387
// min_y := y - r ;
84371: LD_ADDR_VAR 0 8
84375: PUSH
84376: LD_VAR 0 3
84380: PUSH
84381: LD_VAR 0 4
84385: MINUS
84386: ST_TO_ADDR
// max_x := x + r ;
84387: LD_ADDR_VAR 0 9
84391: PUSH
84392: LD_VAR 0 2
84396: PUSH
84397: LD_VAR 0 4
84401: PLUS
84402: ST_TO_ADDR
// max_y := y + r ;
84403: LD_ADDR_VAR 0 10
84407: PUSH
84408: LD_VAR 0 3
84412: PUSH
84413: LD_VAR 0 4
84417: PLUS
84418: ST_TO_ADDR
// for _x = min_x to max_x do
84419: LD_ADDR_VAR 0 11
84423: PUSH
84424: DOUBLE
84425: LD_VAR 0 7
84429: DEC
84430: ST_TO_ADDR
84431: LD_VAR 0 9
84435: PUSH
84436: FOR_TO
84437: IFFALSE 84554
// for _y = min_y to max_y do
84439: LD_ADDR_VAR 0 12
84443: PUSH
84444: DOUBLE
84445: LD_VAR 0 8
84449: DEC
84450: ST_TO_ADDR
84451: LD_VAR 0 10
84455: PUSH
84456: FOR_TO
84457: IFFALSE 84550
// begin if not ValidHex ( _x , _y ) then
84459: LD_VAR 0 11
84463: PPUSH
84464: LD_VAR 0 12
84468: PPUSH
84469: CALL_OW 488
84473: NOT
84474: IFFALSE 84478
// continue ;
84476: GO 84456
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
84478: LD_VAR 0 11
84482: PPUSH
84483: LD_VAR 0 12
84487: PPUSH
84488: CALL_OW 351
84492: PUSH
84493: LD_VAR 0 11
84497: PPUSH
84498: LD_VAR 0 12
84502: PPUSH
84503: CALL_OW 554
84507: AND
84508: IFFALSE 84548
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
84510: LD_ADDR_VAR 0 13
84514: PUSH
84515: LD_VAR 0 13
84519: PPUSH
84520: LD_VAR 0 13
84524: PUSH
84525: LD_INT 1
84527: PLUS
84528: PPUSH
84529: LD_VAR 0 11
84533: PUSH
84534: LD_VAR 0 12
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: PPUSH
84543: CALL_OW 2
84547: ST_TO_ADDR
// end ;
84548: GO 84456
84550: POP
84551: POP
84552: GO 84436
84554: POP
84555: POP
// if not list then
84556: LD_VAR 0 13
84560: NOT
84561: IFFALSE 84565
// exit ;
84563: GO 84636
// for i in list do
84565: LD_ADDR_VAR 0 6
84569: PUSH
84570: LD_VAR 0 13
84574: PUSH
84575: FOR_IN
84576: IFFALSE 84634
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
84578: LD_VAR 0 1
84582: PPUSH
84583: LD_STRING M
84585: PUSH
84586: LD_VAR 0 6
84590: PUSH
84591: LD_INT 1
84593: ARRAY
84594: PUSH
84595: LD_VAR 0 6
84599: PUSH
84600: LD_INT 2
84602: ARRAY
84603: PUSH
84604: LD_INT 0
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: PUSH
84625: EMPTY
84626: LIST
84627: PPUSH
84628: CALL_OW 447
84632: GO 84575
84634: POP
84635: POP
// end ;
84636: LD_VAR 0 5
84640: RET
