// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12724 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 68
 744: PUSH
 745: LD_EXP 68
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 68
 777: PUSH
 778: LD_EXP 68
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 57152 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12581 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12581 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 68
1974: PUSH
1975: LD_EXP 68
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18628 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18628 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18628 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18628 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18628 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 80480 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 80424 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 79483 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 80312 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 79994 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 79725 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 79344 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 79159 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 79051 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 79901 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 80106 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 80480 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 80424 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 79483 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 80312 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 79994 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 79725 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 79344 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 79159 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 79051 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 79901 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 80106 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 79207 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 79207 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 79207 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 79555 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 87
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 90
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 87
7660: PUSH
7661: LD_EXP 87
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 87
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 68
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 79207 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 79207 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 79207 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 80625 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 87
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 90
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 87
8875: PUSH
8876: LD_EXP 87
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 87
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 68
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18628 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18628 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18628 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18628 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18628 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18628 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL 101264 0 1
// if un = Brighton then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_EXP 9
11276: EQUAL
11277: IFFALSE 11293
// begin wait ( 0 0$1 ) ;
11279: LD_INT 35
11281: PPUSH
11282: CALL_OW 67
// YouLost ( Brighton ) ;
11286: LD_STRING Brighton
11288: PPUSH
11289: CALL_OW 104
// end ; if un = JMM then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_EXP 37
11302: EQUAL
11303: IFFALSE 11319
// begin wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// YouLost ( JMM ) ;
11312: LD_STRING JMM
11314: PPUSH
11315: CALL_OW 104
// end ; if un = Megan then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_EXP 11
11328: EQUAL
11329: IFFALSE 11343
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11331: LD_EXP 9
11335: PPUSH
11336: LD_STRING DBrighton-MeganDeath
11338: PPUSH
11339: CALL_OW 88
// end ; if un = Palmer then
11343: LD_VAR 0 1
11347: PUSH
11348: LD_EXP 10
11352: EQUAL
11353: IFFALSE 11367
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING DBrighton-PalmerDeath
11362: PPUSH
11363: CALL_OW 88
// end ; if un = Burlak then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11409
// begin if JMM_Arrived then
11379: LD_EXP 6
11383: IFFALSE 11397
// Say ( JMM , DJMM-BurlakDead ) ;
11385: LD_EXP 37
11389: PPUSH
11390: LD_STRING DJMM-BurlakDead
11392: PPUSH
11393: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11397: LD_EXP 10
11401: PPUSH
11402: LD_STRING DSol-BurlakDead
11404: PPUSH
11405: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 1
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_INT 3
11425: EQUAL
11426: OR
11427: IFFALSE 11443
// begin wait ( 0 0$1 ) ;
11429: LD_INT 35
11431: PPUSH
11432: CALL_OW 67
// YouLost ( Depot ) ;
11436: LD_STRING Depot
11438: PPUSH
11439: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 255
11452: PUSH
11453: LD_INT 1
11455: EQUAL
11456: PUSH
11457: LD_VAR 0 1
11461: PPUSH
11462: CALL_OW 247
11466: PUSH
11467: LD_INT 1
11469: EQUAL
11470: AND
11471: IFFALSE 11487
// Losses := Losses + 1 ;
11473: LD_ADDR_EXP 45
11477: PUSH
11478: LD_EXP 45
11482: PUSH
11483: LD_INT 1
11485: PLUS
11486: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: CALL 82627 0 1
// end ;
11496: PPOPN 1
11498: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11499: LD_VAR 0 1
11503: PPUSH
11504: CALL_OW 247
11508: PUSH
11509: LD_INT 2
11511: EQUAL
11512: PUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_EXP 17
11522: IN
11523: AND
11524: IFFALSE 11538
// SetLives ( un , 0 ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: LD_INT 0
11533: PPUSH
11534: CALL_OW 234
// if un = Yashin then
11538: LD_VAR 0 1
11542: PUSH
11543: LD_EXP 13
11547: EQUAL
11548: IFFALSE 11562
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11550: LD_EXP 13
11554: PPUSH
11555: LD_STRING DDeath-Yas-3
11557: PPUSH
11558: CALL_OW 91
// if un = Popov then
11562: LD_VAR 0 1
11566: PUSH
11567: LD_EXP 14
11571: EQUAL
11572: IFFALSE 11586
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11574: LD_EXP 14
11578: PPUSH
11579: LD_STRING DDeath-Pop-3
11581: PPUSH
11582: CALL_OW 91
// if un = Gaydar then
11586: LD_VAR 0 1
11590: PUSH
11591: LD_EXP 15
11595: EQUAL
11596: IFFALSE 11610
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11598: LD_EXP 15
11602: PPUSH
11603: LD_STRING DDeath-Gay-3
11605: PPUSH
11606: CALL_OW 91
// if un = Sevi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 16
11619: EQUAL
11620: IFFALSE 11634
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11622: LD_EXP 16
11626: PPUSH
11627: LD_STRING DDeath-Vse-3
11629: PPUSH
11630: CALL_OW 91
// end ;
11634: PPOPN 1
11636: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11637: LD_VAR 0 1
11641: PUSH
11642: LD_INT 10
11644: EQUAL
11645: IFFALSE 11683
// begin Say ( Brighton , DBrighton-C1 ) ;
11647: LD_EXP 9
11651: PPUSH
11652: LD_STRING DBrighton-C1
11654: PPUSH
11655: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_STRING DMegan-C1
11666: PPUSH
11667: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11671: LD_EXP 9
11675: PPUSH
11676: LD_STRING DBrighton-C2
11678: PPUSH
11679: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: CALL 82323 0 2
// end ;
11697: PPOPN 2
11699: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_VAR 0 2
11709: PPUSH
11710: CALL 84961 0 2
// end ;
11714: PPOPN 2
11716: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11717: LD_VAR 0 1
11721: PPUSH
11722: CALL 84029 0 1
// end ;
11726: PPOPN 1
11728: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 266
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 1
11747: PPUSH
11748: CALL_OW 255
11752: PUSH
11753: LD_INT 3
11755: EQUAL
11756: AND
11757: IFFALSE 11819
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 274
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 10000
11774: PPUSH
11775: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 274
11788: PPUSH
11789: LD_INT 2
11791: PPUSH
11792: LD_INT 250
11794: PPUSH
11795: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 274
11808: PPUSH
11809: LD_INT 3
11811: PPUSH
11812: LD_INT 100
11814: PPUSH
11815: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL 84270 0 1
// end ;
11828: PPOPN 1
11830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_VAR 0 2
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: LD_VAR 0 5
11855: PPUSH
11856: CALL 81943 0 5
// end ;
11860: PPOPN 5
11862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11863: LD_VAR 0 1
11867: PPUSH
11868: LD_VAR 0 2
11872: PPUSH
11873: CALL 81524 0 2
// end ;
11877: PPOPN 2
11879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL 81362 0 4
// end ;
11904: PPOPN 4
11906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_VAR 0 2
11916: PPUSH
11917: LD_VAR 0 3
11921: PPUSH
11922: CALL 81137 0 3
// end ;
11926: PPOPN 3
11928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: CALL 81022 0 2
// end ;
11943: PPOPN 2
11945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_VAR 0 2
11955: PPUSH
11956: CALL 85256 0 2
// end ;
11960: PPOPN 2
11962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 255
11972: PUSH
11973: LD_INT 6
11975: EQUAL
11976: IFFALSE 12106
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_EXP 13
11987: PUSH
11988: LD_EXP 16
11992: PUSH
11993: LD_EXP 15
11997: PUSH
11998: LD_EXP 14
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: IN
12009: IFFALSE 12013
// exit ;
12011: GO 12130
// if AssaultStarted then
12013: LD_EXP 8
12017: IFFALSE 12091
// case Rand ( 1 , 4 ) of 1 .. 3 :
12019: LD_INT 1
12021: PPUSH
12022: LD_INT 4
12024: PPUSH
12025: CALL_OW 12
12029: PUSH
12030: LD_INT 1
12032: DOUBLE
12033: GREATEREQUAL
12034: IFFALSE 12042
12036: LD_INT 3
12038: DOUBLE
12039: LESSEQUAL
12040: IFTRUE 12044
12042: GO 12062
12044: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 67
12052: PPUSH
12053: LD_INT 37
12055: PPUSH
12056: CALL_OW 114
12060: GO 12089
12062: LD_INT 4
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12088
12070: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_INT 120
12078: PPUSH
12079: LD_INT 131
12081: PPUSH
12082: CALL_OW 111
12086: GO 12089
12088: POP
12089: GO 12106
// ComMoveXY ( driver , 120 , 131 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 120
12098: PPUSH
12099: LD_INT 131
12101: PPUSH
12102: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12106: LD_VAR 0 1
12110: PPUSH
12111: LD_VAR 0 2
12115: PPUSH
12116: LD_VAR 0 3
12120: PPUSH
12121: LD_VAR 0 4
12125: PPUSH
12126: CALL 85472 0 4
// end ;
12130: PPOPN 4
12132: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12133: LD_VAR 0 1
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 80831 0 2
// end ;
12147: PPOPN 2
12149: END
// on Command ( cmd ) do var i ;
12150: LD_INT 0
12152: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12153: LD_VAR 0 1
12157: PUSH
12158: LD_INT 77
12160: EQUAL
12161: PUSH
12162: LD_EXP 2
12166: AND
12167: IFFALSE 12243
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12169: LD_ADDR_VAR 0 2
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_INT 1
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 2
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 21
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PPUSH
12216: CALL_OW 69
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12241
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 20
12231: PPUSH
12232: LD_INT 19
12234: PPUSH
12235: CALL 51676 0 3
12239: GO 12221
12241: POP
12242: POP
// end ; SOS_Command ( cmd ) ;
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL 101370 0 1
// end ;
12252: PPOPN 2
12254: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12255: LD_EXP 2
12259: PUSH
12260: LD_INT 16
12262: PPUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 1
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 1
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 21
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 70
12309: AND
12310: IFFALSE 12396
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin enable ;
12318: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 16
12326: PPUSH
12327: LD_INT 22
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 2
12339: PUSH
12340: LD_INT 21
12342: PUSH
12343: LD_INT 1
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 2
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PPUSH
12369: CALL_OW 70
12373: PUSH
12374: FOR_IN
12375: IFFALSE 12394
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12377: LD_VAR 0 1
12381: PPUSH
12382: LD_INT 18
12384: PPUSH
12385: LD_INT 19
12387: PPUSH
12388: CALL 51676 0 3
12392: GO 12374
12394: POP
12395: POP
// end ; end_of_file
12396: PPOPN 1
12398: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12399: LD_EXP 6
12403: PUSH
12404: LD_EXP 44
12408: AND
12409: IFFALSE 12580
12411: GO 12413
12413: DISABLE
// begin wait ( 0 0$2 ) ;
12414: LD_INT 70
12416: PPUSH
12417: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12421: LD_EXP 9
12425: PPUSH
12426: LD_STRING DBrighton-G1
12428: PPUSH
12429: CALL_OW 88
// if Losses < 1 then
12433: LD_EXP 45
12437: PUSH
12438: LD_INT 1
12440: LESS
12441: IFFALSE 12455
// AddMedal ( Losses , 1 ) else
12443: LD_STRING Losses
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: CALL_OW 101
12453: GO 12488
// if Losses < 5 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 5
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 2 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 2
12470: PPUSH
12471: CALL_OW 101
12475: GO 12488
// AddMedal ( Losses , - 1 ) ;
12477: LD_STRING Losses
12479: PPUSH
12480: LD_INT 1
12482: NEG
12483: PPUSH
12484: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12488: LD_EXP 7
12492: PUSH
12493: LD_INT 10
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 321
12503: PUSH
12504: LD_INT 2
12506: EQUAL
12507: AND
12508: IFFALSE 12522
// AddMedal ( Laser , 1 ) else
12510: LD_STRING Laser
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 101
12520: GO 12569
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12522: LD_EXP 7
12526: NOT
12527: PUSH
12528: LD_INT 10
12530: PPUSH
12531: LD_INT 1
12533: PPUSH
12534: CALL_OW 321
12538: PUSH
12539: LD_INT 2
12541: EQUAL
12542: AND
12543: IFFALSE 12558
// AddMedal ( Laser , - 1 ) else
12545: LD_STRING Laser
12547: PPUSH
12548: LD_INT 1
12550: NEG
12551: PPUSH
12552: CALL_OW 101
12556: GO 12569
// AddMedal ( Laser , - 2 ) ;
12558: LD_STRING Laser
12560: PPUSH
12561: LD_INT 2
12563: NEG
12564: PPUSH
12565: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12569: LD_STRING BaseMain
12571: PPUSH
12572: CALL_OW 102
// YouWin ;
12576: CALL_OW 103
// end ; end_of_file
12580: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12581: LD_INT 0
12583: PPUSH
12584: PPUSH
// area = ListEnvironmentArea ( area ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: CALL_OW 353
12599: ST_TO_ADDR
// if bulldozer > 0 then
12600: LD_VAR 0 1
12604: PUSH
12605: LD_INT 0
12607: GREATER
12608: IFFALSE 12719
// for i = area downto 1 do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: DOUBLE
12616: LD_VAR 0 2
12620: INC
12621: ST_TO_ADDR
12622: LD_INT 1
12624: PUSH
12625: FOR_DOWNTO
12626: IFFALSE 12717
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 351
12662: IFFALSE 12715
// if not HasTask ( bulldozer ) then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 314
12673: NOT
12674: IFFALSE 12715
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PUSH
12692: LD_INT 1
12694: ARRAY
12695: PPUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PUSH
12707: LD_INT 2
12709: ARRAY
12710: PPUSH
12711: CALL_OW 171
12715: GO 12625
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
12732: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12733: LD_ADDR_VAR 0 8
12737: PUSH
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_INT 22
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 21
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: PPUSH
12778: CALL_OW 72
12782: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12783: LD_ADDR_VAR 0 9
12787: PUSH
12788: LD_VAR 0 1
12792: PPUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 21
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 3
12815: PUSH
12816: LD_INT 25
12818: PUSH
12819: LD_INT 1
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 72
12839: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12840: LD_ADDR_EXP 47
12844: PUSH
12845: LD_VAR 0 8
12849: PPUSH
12850: LD_VAR 0 9
12854: PPUSH
12855: CALL 13248 0 2
12859: ST_TO_ADDR
// offset = 0 ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// for i := 1 to sold_team do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 8
12882: PUSH
12883: FOR_TO
12884: IFFALSE 13015
// begin if IsInUnit ( sold_team [ i ] ) then
12886: LD_VAR 0 8
12890: PUSH
12891: LD_VAR 0 4
12895: ARRAY
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12918
// ComExitBuilding ( sold_team [ i ] ) ;
12903: LD_VAR 0 8
12907: PUSH
12908: LD_VAR 0 4
12912: ARRAY
12913: PPUSH
12914: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12918: LD_VAR 0 8
12922: PUSH
12923: LD_VAR 0 4
12927: ARRAY
12928: PPUSH
12929: LD_EXP 47
12933: PUSH
12934: LD_INT 1
12936: ARRAY
12937: PUSH
12938: LD_VAR 0 4
12942: PUSH
12943: LD_VAR 0 7
12947: PLUS
12948: ARRAY
12949: PPUSH
12950: LD_EXP 47
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: PUSH
12959: LD_VAR 0 4
12963: PUSH
12964: LD_INT 1
12966: PLUS
12967: PUSH
12968: LD_VAR 0 7
12972: PLUS
12973: ARRAY
12974: PPUSH
12975: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12979: LD_VAR 0 8
12983: PUSH
12984: LD_VAR 0 4
12988: ARRAY
12989: PPUSH
12990: LD_EXP 9
12994: PPUSH
12995: CALL_OW 179
// offset = offset + 1 ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 7
13008: PUSH
13009: LD_INT 1
13011: PLUS
13012: ST_TO_ADDR
// end ;
13013: GO 12883
13015: POP
13016: POP
// offset = 0 ;
13017: LD_ADDR_VAR 0 7
13021: PUSH
13022: LD_INT 0
13024: ST_TO_ADDR
// tmp = 1 ;
13025: LD_ADDR_VAR 0 6
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// for i := 2 to rows do
13033: LD_ADDR_VAR 0 4
13037: PUSH
13038: DOUBLE
13039: LD_INT 2
13041: DEC
13042: ST_TO_ADDR
13043: LD_EXP 47
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13241
// begin for x := 1 to sold_team do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13229
// begin if IsInUnit ( civil_team [ tmp ] ) then
13069: LD_VAR 0 9
13073: PUSH
13074: LD_VAR 0 6
13078: ARRAY
13079: PPUSH
13080: CALL_OW 310
13084: IFFALSE 13101
// ComExitBuilding ( civil_team [ tmp ] ) ;
13086: LD_VAR 0 9
13090: PUSH
13091: LD_VAR 0 6
13095: ARRAY
13096: PPUSH
13097: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13101: LD_VAR 0 9
13105: PUSH
13106: LD_VAR 0 6
13110: ARRAY
13111: PPUSH
13112: LD_EXP 47
13116: PUSH
13117: LD_VAR 0 4
13121: ARRAY
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: PLUS
13133: ARRAY
13134: PPUSH
13135: LD_EXP 47
13139: PUSH
13140: LD_VAR 0 4
13144: ARRAY
13145: PUSH
13146: LD_VAR 0 5
13150: PUSH
13151: LD_INT 1
13153: PLUS
13154: PUSH
13155: LD_VAR 0 7
13159: PLUS
13160: ARRAY
13161: PPUSH
13162: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13166: LD_VAR 0 9
13170: PUSH
13171: LD_VAR 0 6
13175: ARRAY
13176: PPUSH
13177: LD_EXP 9
13181: PPUSH
13182: CALL_OW 179
// offset = offset + 1 ;
13186: LD_ADDR_VAR 0 7
13190: PUSH
13191: LD_VAR 0 7
13195: PUSH
13196: LD_INT 1
13198: PLUS
13199: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13200: LD_VAR 0 6
13204: PUSH
13205: LD_VAR 0 9
13209: EQUAL
13210: NOT
13211: IFFALSE 13227
// tmp = tmp + 1 ;
13213: LD_ADDR_VAR 0 6
13217: PUSH
13218: LD_VAR 0 6
13222: PUSH
13223: LD_INT 1
13225: PLUS
13226: ST_TO_ADDR
// end ;
13227: GO 13066
13229: POP
13230: POP
// offset = 0 ;
13231: LD_ADDR_VAR 0 7
13235: PUSH
13236: LD_INT 0
13238: ST_TO_ADDR
// end ;
13239: GO 13048
13241: POP
13242: POP
// end ;
13243: LD_VAR 0 3
13247: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
// start_pos = [ 65 , 34 ] ;
13260: LD_ADDR_VAR 0 6
13264: PUSH
13265: LD_INT 65
13267: PUSH
13268: LD_INT 34
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
// row_size = 0 ;
13275: LD_ADDR_VAR 0 7
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// result_rows = [ ] ;
13283: LD_ADDR_VAR 0 9
13287: PUSH
13288: EMPTY
13289: ST_TO_ADDR
// new_row = [ ] ;
13290: LD_ADDR_VAR 0 8
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// for i := 1 to sold_team do
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: DOUBLE
13303: LD_INT 1
13305: DEC
13306: ST_TO_ADDR
13307: LD_VAR 0 1
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13367
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_VAR 0 8
13324: PUSH
13325: LD_VAR 0 6
13329: PUSH
13330: LD_INT 1
13332: ARRAY
13333: ADD
13334: PUSH
13335: LD_VAR 0 6
13339: PUSH
13340: LD_INT 2
13342: ARRAY
13343: PUSH
13344: LD_VAR 0 4
13348: PLUS
13349: ADD
13350: ST_TO_ADDR
// row_size = row_size + 1 ;
13351: LD_ADDR_VAR 0 7
13355: PUSH
13356: LD_VAR 0 7
13360: PUSH
13361: LD_INT 1
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13312
13367: POP
13368: POP
// result_rows = result_rows ^ [ new_row ] ;
13369: LD_ADDR_VAR 0 9
13373: PUSH
13374: LD_VAR 0 9
13378: PUSH
13379: LD_VAR 0 8
13383: PUSH
13384: EMPTY
13385: LIST
13386: ADD
13387: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13388: LD_ADDR_VAR 0 10
13392: PUSH
13393: LD_VAR 0 2
13397: PUSH
13398: LD_VAR 0 1
13402: DIV
13403: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13404: LD_VAR 0 10
13408: PUSH
13409: LD_VAR 0 1
13413: MOD
13414: PUSH
13415: LD_INT 0
13417: GREATER
13418: IFFALSE 13434
// civil_rows = civil_rows + 1 ;
13420: LD_ADDR_VAR 0 10
13424: PUSH
13425: LD_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ST_TO_ADDR
// offsetX = 2 ;
13434: LD_ADDR_VAR 0 11
13438: PUSH
13439: LD_INT 2
13441: ST_TO_ADDR
// offsetY = 1 ;
13442: LD_ADDR_VAR 0 12
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// for i := 1 to civil_rows do
13450: LD_ADDR_VAR 0 4
13454: PUSH
13455: DOUBLE
13456: LD_INT 1
13458: DEC
13459: ST_TO_ADDR
13460: LD_VAR 0 10
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13594
// begin new_row = [ ] ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: EMPTY
13474: ST_TO_ADDR
// for x := 1 to row_size do
13475: LD_ADDR_VAR 0 5
13479: PUSH
13480: DOUBLE
13481: LD_INT 1
13483: DEC
13484: ST_TO_ADDR
13485: LD_VAR 0 7
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13543
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13493: LD_ADDR_VAR 0 8
13497: PUSH
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 6
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_VAR 0 11
13516: PLUS
13517: ADD
13518: PUSH
13519: LD_VAR 0 6
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: PUSH
13528: LD_VAR 0 12
13532: PLUS
13533: PUSH
13534: LD_VAR 0 5
13538: PLUS
13539: ADD
13540: ST_TO_ADDR
// end ;
13541: GO 13490
13543: POP
13544: POP
// result_rows = result_rows ^ [ new_row ] ;
13545: LD_ADDR_VAR 0 9
13549: PUSH
13550: LD_VAR 0 9
13554: PUSH
13555: LD_VAR 0 8
13559: PUSH
13560: EMPTY
13561: LIST
13562: ADD
13563: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13564: LD_ADDR_VAR 0 11
13568: PUSH
13569: LD_VAR 0 11
13573: PUSH
13574: LD_INT 2
13576: PLUS
13577: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13578: LD_ADDR_VAR 0 12
13582: PUSH
13583: LD_VAR 0 12
13587: PUSH
13588: LD_INT 1
13590: PLUS
13591: ST_TO_ADDR
// end ;
13592: GO 13465
13594: POP
13595: POP
// result = result_rows ;
13596: LD_ADDR_VAR 0 3
13600: PUSH
13601: LD_VAR 0 9
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 3
13610: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
// if exist_mode then
13615: LD_VAR 0 2
13619: IFFALSE 13644
// unit := CreateCharacter ( prefix & ident ) else
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_VAR 0 3
13630: PUSH
13631: LD_VAR 0 1
13635: STR
13636: PPUSH
13637: CALL_OW 34
13641: ST_TO_ADDR
13642: GO 13659
// unit := NewCharacter ( ident ) ;
13644: LD_ADDR_VAR 0 5
13648: PUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 25
13658: ST_TO_ADDR
// result := unit ;
13659: LD_ADDR_VAR 0 4
13663: PUSH
13664: LD_VAR 0 5
13668: ST_TO_ADDR
// end ;
13669: LD_VAR 0 4
13673: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13674: LD_INT 0
13676: PPUSH
13677: PPUSH
// if not side or not nation then
13678: LD_VAR 0 1
13682: NOT
13683: PUSH
13684: LD_VAR 0 2
13688: NOT
13689: OR
13690: IFFALSE 13694
// exit ;
13692: GO 14462
// case nation of nation_american :
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 1
13701: DOUBLE
13702: EQUAL
13703: IFTRUE 13707
13705: GO 13921
13707: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13708: LD_ADDR_VAR 0 4
13712: PUSH
13713: LD_INT 35
13715: PUSH
13716: LD_INT 45
13718: PUSH
13719: LD_INT 46
13721: PUSH
13722: LD_INT 47
13724: PUSH
13725: LD_INT 82
13727: PUSH
13728: LD_INT 83
13730: PUSH
13731: LD_INT 84
13733: PUSH
13734: LD_INT 85
13736: PUSH
13737: LD_INT 86
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: LD_INT 2
13745: PUSH
13746: LD_INT 6
13748: PUSH
13749: LD_INT 15
13751: PUSH
13752: LD_INT 16
13754: PUSH
13755: LD_INT 7
13757: PUSH
13758: LD_INT 12
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: LD_INT 20
13772: PUSH
13773: LD_INT 21
13775: PUSH
13776: LD_INT 22
13778: PUSH
13779: LD_INT 25
13781: PUSH
13782: LD_INT 32
13784: PUSH
13785: LD_INT 27
13787: PUSH
13788: LD_INT 36
13790: PUSH
13791: LD_INT 69
13793: PUSH
13794: LD_INT 39
13796: PUSH
13797: LD_INT 34
13799: PUSH
13800: LD_INT 40
13802: PUSH
13803: LD_INT 48
13805: PUSH
13806: LD_INT 49
13808: PUSH
13809: LD_INT 50
13811: PUSH
13812: LD_INT 51
13814: PUSH
13815: LD_INT 52
13817: PUSH
13818: LD_INT 53
13820: PUSH
13821: LD_INT 54
13823: PUSH
13824: LD_INT 55
13826: PUSH
13827: LD_INT 56
13829: PUSH
13830: LD_INT 57
13832: PUSH
13833: LD_INT 58
13835: PUSH
13836: LD_INT 59
13838: PUSH
13839: LD_INT 60
13841: PUSH
13842: LD_INT 61
13844: PUSH
13845: LD_INT 62
13847: PUSH
13848: LD_INT 80
13850: PUSH
13851: LD_INT 82
13853: PUSH
13854: LD_INT 83
13856: PUSH
13857: LD_INT 84
13859: PUSH
13860: LD_INT 85
13862: PUSH
13863: LD_INT 86
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: ST_TO_ADDR
13919: GO 14386
13921: LD_INT 2
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 14155
13929: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_INT 35
13937: PUSH
13938: LD_INT 45
13940: PUSH
13941: LD_INT 46
13943: PUSH
13944: LD_INT 47
13946: PUSH
13947: LD_INT 82
13949: PUSH
13950: LD_INT 83
13952: PUSH
13953: LD_INT 84
13955: PUSH
13956: LD_INT 85
13958: PUSH
13959: LD_INT 87
13961: PUSH
13962: LD_INT 70
13964: PUSH
13965: LD_INT 1
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: LD_INT 5
13979: PUSH
13980: LD_INT 6
13982: PUSH
13983: LD_INT 15
13985: PUSH
13986: LD_INT 18
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: LD_INT 17
13994: PUSH
13995: LD_INT 8
13997: PUSH
13998: LD_INT 20
14000: PUSH
14001: LD_INT 21
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 72
14009: PUSH
14010: LD_INT 26
14012: PUSH
14013: LD_INT 69
14015: PUSH
14016: LD_INT 39
14018: PUSH
14019: LD_INT 40
14021: PUSH
14022: LD_INT 41
14024: PUSH
14025: LD_INT 42
14027: PUSH
14028: LD_INT 43
14030: PUSH
14031: LD_INT 48
14033: PUSH
14034: LD_INT 49
14036: PUSH
14037: LD_INT 50
14039: PUSH
14040: LD_INT 51
14042: PUSH
14043: LD_INT 52
14045: PUSH
14046: LD_INT 53
14048: PUSH
14049: LD_INT 54
14051: PUSH
14052: LD_INT 55
14054: PUSH
14055: LD_INT 56
14057: PUSH
14058: LD_INT 60
14060: PUSH
14061: LD_INT 61
14063: PUSH
14064: LD_INT 62
14066: PUSH
14067: LD_INT 66
14069: PUSH
14070: LD_INT 67
14072: PUSH
14073: LD_INT 68
14075: PUSH
14076: LD_INT 81
14078: PUSH
14079: LD_INT 82
14081: PUSH
14082: LD_INT 83
14084: PUSH
14085: LD_INT 84
14087: PUSH
14088: LD_INT 85
14090: PUSH
14091: LD_INT 87
14093: PUSH
14094: LD_INT 88
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14386
14155: LD_INT 3
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14385
14163: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14164: LD_ADDR_VAR 0 4
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: LD_INT 47
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 82
14183: PUSH
14184: LD_INT 83
14186: PUSH
14187: LD_INT 84
14189: PUSH
14190: LD_INT 85
14192: PUSH
14193: LD_INT 86
14195: PUSH
14196: LD_INT 11
14198: PUSH
14199: LD_INT 9
14201: PUSH
14202: LD_INT 20
14204: PUSH
14205: LD_INT 19
14207: PUSH
14208: LD_INT 21
14210: PUSH
14211: LD_INT 24
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 25
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: LD_INT 37
14234: PUSH
14235: LD_INT 38
14237: PUSH
14238: LD_INT 32
14240: PUSH
14241: LD_INT 27
14243: PUSH
14244: LD_INT 33
14246: PUSH
14247: LD_INT 69
14249: PUSH
14250: LD_INT 39
14252: PUSH
14253: LD_INT 34
14255: PUSH
14256: LD_INT 40
14258: PUSH
14259: LD_INT 71
14261: PUSH
14262: LD_INT 23
14264: PUSH
14265: LD_INT 44
14267: PUSH
14268: LD_INT 48
14270: PUSH
14271: LD_INT 49
14273: PUSH
14274: LD_INT 50
14276: PUSH
14277: LD_INT 51
14279: PUSH
14280: LD_INT 52
14282: PUSH
14283: LD_INT 53
14285: PUSH
14286: LD_INT 54
14288: PUSH
14289: LD_INT 55
14291: PUSH
14292: LD_INT 56
14294: PUSH
14295: LD_INT 57
14297: PUSH
14298: LD_INT 58
14300: PUSH
14301: LD_INT 59
14303: PUSH
14304: LD_INT 63
14306: PUSH
14307: LD_INT 64
14309: PUSH
14310: LD_INT 65
14312: PUSH
14313: LD_INT 82
14315: PUSH
14316: LD_INT 83
14318: PUSH
14319: LD_INT 84
14321: PUSH
14322: LD_INT 85
14324: PUSH
14325: LD_INT 86
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: ST_TO_ADDR
14383: GO 14386
14385: POP
// if state > - 1 and state < 3 then
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: NEG
14394: GREATER
14395: PUSH
14396: LD_VAR 0 3
14400: PUSH
14401: LD_INT 3
14403: LESS
14404: AND
14405: IFFALSE 14462
// for i in result do
14407: LD_ADDR_VAR 0 5
14411: PUSH
14412: LD_VAR 0 4
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14460
// if GetTech ( i , side ) <> state then
14420: LD_VAR 0 5
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 321
14434: PUSH
14435: LD_VAR 0 3
14439: NONEQUAL
14440: IFFALSE 14458
// result := result diff i ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: DIFF
14457: ST_TO_ADDR
14458: GO 14417
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// result := true ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: LD_INT 1
14479: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: LD_VAR 0 2
14489: PPUSH
14490: CALL_OW 480
14494: ST_TO_ADDR
// if not tmp then
14495: LD_VAR 0 5
14499: NOT
14500: IFFALSE 14504
// exit ;
14502: GO 14553
// for i in tmp do
14504: LD_ADDR_VAR 0 4
14508: PUSH
14509: LD_VAR 0 5
14513: PUSH
14514: FOR_IN
14515: IFFALSE 14551
// if GetTech ( i , side ) <> state_researched then
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 321
14531: PUSH
14532: LD_INT 2
14534: NONEQUAL
14535: IFFALSE 14549
// begin result := false ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 0
14544: ST_TO_ADDR
// exit ;
14545: POP
14546: POP
14547: GO 14553
// end ;
14549: GO 14514
14551: POP
14552: POP
// end ;
14553: LD_VAR 0 3
14557: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
14572: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14573: LD_VAR 0 1
14577: NOT
14578: PUSH
14579: LD_VAR 0 1
14583: PPUSH
14584: CALL_OW 257
14588: PUSH
14589: LD_INT 9
14591: NONEQUAL
14592: OR
14593: IFFALSE 14597
// exit ;
14595: GO 15170
// side := GetSide ( unit ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 255
14611: ST_TO_ADDR
// tech_space := tech_spacanom ;
14612: LD_ADDR_VAR 0 12
14616: PUSH
14617: LD_INT 29
14619: ST_TO_ADDR
// tech_time := tech_taurad ;
14620: LD_ADDR_VAR 0 13
14624: PUSH
14625: LD_INT 28
14627: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14628: LD_ADDR_VAR 0 11
14632: PUSH
14633: LD_VAR 0 1
14637: PPUSH
14638: CALL_OW 310
14642: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14643: LD_VAR 0 11
14647: PPUSH
14648: CALL_OW 247
14652: PUSH
14653: LD_INT 2
14655: EQUAL
14656: IFFALSE 14660
// exit ;
14658: GO 15170
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_INT 81
14667: PUSH
14668: LD_VAR 0 9
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: ST_TO_ADDR
// if not tmp then
14703: LD_VAR 0 8
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15170
// if in_unit then
14712: LD_VAR 0 11
14716: IFFALSE 14740
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14718: LD_ADDR_VAR 0 10
14722: PUSH
14723: LD_VAR 0 8
14727: PPUSH
14728: LD_VAR 0 11
14732: PPUSH
14733: CALL_OW 74
14737: ST_TO_ADDR
14738: GO 14760
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14740: LD_ADDR_VAR 0 10
14744: PUSH
14745: LD_VAR 0 8
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: ST_TO_ADDR
// if not enemy then
14760: LD_VAR 0 10
14764: NOT
14765: IFFALSE 14769
// exit ;
14767: GO 15170
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14769: LD_VAR 0 11
14773: PUSH
14774: LD_VAR 0 11
14778: PPUSH
14779: LD_VAR 0 10
14783: PPUSH
14784: CALL_OW 296
14788: PUSH
14789: LD_INT 13
14791: GREATER
14792: AND
14793: PUSH
14794: LD_VAR 0 1
14798: PPUSH
14799: LD_VAR 0 10
14803: PPUSH
14804: CALL_OW 296
14808: PUSH
14809: LD_INT 12
14811: GREATER
14812: OR
14813: IFFALSE 14817
// exit ;
14815: GO 15170
// missile := [ 1 ] ;
14817: LD_ADDR_VAR 0 14
14821: PUSH
14822: LD_INT 1
14824: PUSH
14825: EMPTY
14826: LIST
14827: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14828: LD_VAR 0 9
14832: PPUSH
14833: LD_VAR 0 12
14837: PPUSH
14838: CALL_OW 325
14842: IFFALSE 14871
// missile := Replace ( missile , missile + 1 , 2 ) ;
14844: LD_ADDR_VAR 0 14
14848: PUSH
14849: LD_VAR 0 14
14853: PPUSH
14854: LD_VAR 0 14
14858: PUSH
14859: LD_INT 1
14861: PLUS
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 1
14870: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 13
14880: PPUSH
14881: CALL_OW 325
14885: PUSH
14886: LD_VAR 0 10
14890: PPUSH
14891: CALL_OW 255
14895: PPUSH
14896: LD_VAR 0 13
14900: PPUSH
14901: CALL_OW 325
14905: NOT
14906: AND
14907: IFFALSE 14936
// missile := Replace ( missile , missile + 1 , 3 ) ;
14909: LD_ADDR_VAR 0 14
14913: PUSH
14914: LD_VAR 0 14
14918: PPUSH
14919: LD_VAR 0 14
14923: PUSH
14924: LD_INT 1
14926: PLUS
14927: PPUSH
14928: LD_INT 3
14930: PPUSH
14931: CALL_OW 1
14935: ST_TO_ADDR
// if missile < 2 then
14936: LD_VAR 0 14
14940: PUSH
14941: LD_INT 2
14943: LESS
14944: IFFALSE 14948
// exit ;
14946: GO 15170
// x := GetX ( enemy ) ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 250
14962: ST_TO_ADDR
// y := GetY ( enemy ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 10
14972: PPUSH
14973: CALL_OW 251
14977: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: NEG
14991: PPUSH
14992: LD_INT 1
14994: PPUSH
14995: CALL_OW 12
14999: PLUS
15000: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15001: LD_ADDR_VAR 0 7
15005: PUSH
15006: LD_VAR 0 5
15010: PUSH
15011: LD_INT 1
15013: NEG
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 12
15022: PLUS
15023: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15024: LD_VAR 0 6
15028: PPUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: CALL_OW 488
15038: NOT
15039: IFFALSE 15061
// begin _x := x ;
15041: LD_ADDR_VAR 0 6
15045: PUSH
15046: LD_VAR 0 4
15050: ST_TO_ADDR
// _y := y ;
15051: LD_ADDR_VAR 0 7
15055: PUSH
15056: LD_VAR 0 5
15060: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 1
15068: PPUSH
15069: LD_VAR 0 14
15073: PPUSH
15074: CALL_OW 12
15078: ST_TO_ADDR
// case i of 1 :
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: DOUBLE
15087: EQUAL
15088: IFTRUE 15092
15090: GO 15109
15092: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15093: LD_VAR 0 1
15097: PPUSH
15098: LD_VAR 0 10
15102: PPUSH
15103: CALL_OW 115
15107: GO 15170
15109: LD_INT 2
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15139
15117: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15118: LD_VAR 0 1
15122: PPUSH
15123: LD_VAR 0 6
15127: PPUSH
15128: LD_VAR 0 7
15132: PPUSH
15133: CALL_OW 153
15137: GO 15170
15139: LD_INT 3
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15169
15147: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 6
15157: PPUSH
15158: LD_VAR 0 7
15162: PPUSH
15163: CALL_OW 154
15167: GO 15170
15169: POP
// end ;
15170: LD_VAR 0 2
15174: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
// if not unit or not building then
15183: LD_VAR 0 1
15187: NOT
15188: PUSH
15189: LD_VAR 0 2
15193: NOT
15194: OR
15195: IFFALSE 15199
// exit ;
15197: GO 15357
// x := GetX ( building ) ;
15199: LD_ADDR_VAR 0 5
15203: PUSH
15204: LD_VAR 0 2
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// y := GetY ( building ) ;
15214: LD_ADDR_VAR 0 6
15218: PUSH
15219: LD_VAR 0 2
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// for i = 0 to 5 do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 0
15237: DEC
15238: ST_TO_ADDR
15239: LD_INT 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15355
// begin _x := ShiftX ( x , i , 3 ) ;
15245: LD_ADDR_VAR 0 7
15249: PUSH
15250: LD_VAR 0 5
15254: PPUSH
15255: LD_VAR 0 4
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 272
15267: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15268: LD_ADDR_VAR 0 8
15272: PUSH
15273: LD_VAR 0 6
15277: PPUSH
15278: LD_VAR 0 4
15282: PPUSH
15283: LD_INT 3
15285: PPUSH
15286: CALL_OW 273
15290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15291: LD_VAR 0 7
15295: PPUSH
15296: LD_VAR 0 8
15300: PPUSH
15301: CALL_OW 488
15305: NOT
15306: IFFALSE 15310
// continue ;
15308: GO 15242
// if HexInfo ( _x , _y ) = 0 then
15310: LD_VAR 0 7
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 428
15324: PUSH
15325: LD_INT 0
15327: EQUAL
15328: IFFALSE 15353
// begin ComMoveXY ( unit , _x , _y ) ;
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 7
15339: PPUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: CALL_OW 111
// exit ;
15349: POP
15350: POP
15351: GO 15357
// end ; end ;
15353: GO 15242
15355: POP
15356: POP
// end ;
15357: LD_VAR 0 3
15361: RET
// export function ScanBase ( side , base_area ) ; begin
15362: LD_INT 0
15364: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15365: LD_ADDR_VAR 0 3
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_INT 81
15377: PUSH
15378: LD_VAR 0 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 70
15391: ST_TO_ADDR
// end ;
15392: LD_VAR 0 3
15396: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15397: LD_INT 0
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// result := false ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// side := GetSide ( unit ) ;
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 255
15425: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15426: LD_ADDR_VAR 0 4
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 248
15440: ST_TO_ADDR
// case nat of 1 :
15441: LD_VAR 0 4
15445: PUSH
15446: LD_INT 1
15448: DOUBLE
15449: EQUAL
15450: IFTRUE 15454
15452: GO 15465
15454: POP
// tech := tech_lassight ; 2 :
15455: LD_ADDR_VAR 0 5
15459: PUSH
15460: LD_INT 12
15462: ST_TO_ADDR
15463: GO 15504
15465: LD_INT 2
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15484
15473: POP
// tech := tech_mortar ; 3 :
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_INT 41
15481: ST_TO_ADDR
15482: GO 15504
15484: LD_INT 3
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15503
15492: POP
// tech := tech_bazooka ; end ;
15493: LD_ADDR_VAR 0 5
15497: PUSH
15498: LD_INT 44
15500: ST_TO_ADDR
15501: GO 15504
15503: POP
// if Researched ( side , tech ) then
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_VAR 0 5
15513: PPUSH
15514: CALL_OW 325
15518: IFFALSE 15545
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15520: LD_ADDR_VAR 0 2
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 8
15530: PUSH
15531: LD_INT 9
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: PUSH
15539: LD_VAR 0 4
15543: ARRAY
15544: ST_TO_ADDR
// end ;
15545: LD_VAR 0 2
15549: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15550: LD_INT 0
15552: PPUSH
15553: PPUSH
15554: PPUSH
// if not mines then
15555: LD_VAR 0 2
15559: NOT
15560: IFFALSE 15564
// exit ;
15562: GO 15708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_INT 81
15571: PUSH
15572: LD_VAR 0 1
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 3
15583: PUSH
15584: LD_INT 21
15586: PUSH
15587: LD_INT 3
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: ST_TO_ADDR
// for i in mines do
15607: LD_ADDR_VAR 0 4
15611: PUSH
15612: LD_VAR 0 2
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15706
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: CALL_OW 458
15642: NOT
15643: IFFALSE 15647
// continue ;
15645: GO 15617
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: PPUSH
15656: LD_VAR 0 4
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: CALL_OW 428
15669: PUSH
15670: LD_VAR 0 5
15674: IN
15675: IFFALSE 15704
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 4
15690: PUSH
15691: LD_INT 2
15693: ARRAY
15694: PPUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 456
// end ;
15704: GO 15617
15706: POP
15707: POP
// end ;
15708: LD_VAR 0 3
15712: RET
// export function Count ( array ) ; var i ; begin
15713: LD_INT 0
15715: PPUSH
15716: PPUSH
// result := 0 ;
15717: LD_ADDR_VAR 0 2
15721: PUSH
15722: LD_INT 0
15724: ST_TO_ADDR
// for i in array do
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_VAR 0 1
15734: PUSH
15735: FOR_IN
15736: IFFALSE 15760
// if i then
15738: LD_VAR 0 3
15742: IFFALSE 15758
// result := result + 1 ;
15744: LD_ADDR_VAR 0 2
15748: PUSH
15749: LD_VAR 0 2
15753: PUSH
15754: LD_INT 1
15756: PLUS
15757: ST_TO_ADDR
15758: GO 15735
15760: POP
15761: POP
// end ;
15762: LD_VAR 0 2
15766: RET
// export function IsEmpty ( building ) ; begin
15767: LD_INT 0
15769: PPUSH
// if not building then
15770: LD_VAR 0 1
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 15822
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15779: LD_ADDR_VAR 0 2
15783: PUSH
15784: LD_VAR 0 1
15788: PUSH
15789: LD_INT 22
15791: PUSH
15792: LD_VAR 0 1
15796: PPUSH
15797: CALL_OW 255
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: PUSH
15806: LD_INT 58
15808: PUSH
15809: EMPTY
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PPUSH
15816: CALL_OW 69
15820: IN
15821: ST_TO_ADDR
// end ;
15822: LD_VAR 0 2
15826: RET
// export function IsNotFull ( building ) ; var places ; begin
15827: LD_INT 0
15829: PPUSH
15830: PPUSH
// if not building then
15831: LD_VAR 0 1
15835: NOT
15836: IFFALSE 15840
// exit ;
15838: GO 16011
// result := false ;
15840: LD_ADDR_VAR 0 2
15844: PUSH
15845: LD_INT 0
15847: ST_TO_ADDR
// places := 0 ;
15848: LD_ADDR_VAR 0 3
15852: PUSH
15853: LD_INT 0
15855: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
15856: LD_VAR 0 1
15860: PPUSH
15861: CALL_OW 266
15865: PUSH
15866: LD_INT 0
15868: DOUBLE
15869: EQUAL
15870: IFTRUE 15928
15872: LD_INT 1
15874: DOUBLE
15875: EQUAL
15876: IFTRUE 15928
15878: LD_INT 6
15880: DOUBLE
15881: EQUAL
15882: IFTRUE 15928
15884: LD_INT 7
15886: DOUBLE
15887: EQUAL
15888: IFTRUE 15928
15890: LD_INT 8
15892: DOUBLE
15893: EQUAL
15894: IFTRUE 15928
15896: LD_INT 4
15898: DOUBLE
15899: EQUAL
15900: IFTRUE 15928
15902: LD_INT 5
15904: DOUBLE
15905: EQUAL
15906: IFTRUE 15928
15908: LD_INT 2
15910: DOUBLE
15911: EQUAL
15912: IFTRUE 15928
15914: LD_INT 3
15916: DOUBLE
15917: EQUAL
15918: IFTRUE 15928
15920: LD_INT 35
15922: DOUBLE
15923: EQUAL
15924: IFTRUE 15928
15926: GO 15939
15928: POP
// places := 6 ; b_bunker , b_breastwork :
15929: LD_ADDR_VAR 0 3
15933: PUSH
15934: LD_INT 6
15936: ST_TO_ADDR
15937: GO 15984
15939: LD_INT 32
15941: DOUBLE
15942: EQUAL
15943: IFTRUE 15953
15945: LD_INT 31
15947: DOUBLE
15948: EQUAL
15949: IFTRUE 15953
15951: GO 15964
15953: POP
// places := 1 ; b_control_tower :
15954: LD_ADDR_VAR 0 3
15958: PUSH
15959: LD_INT 1
15961: ST_TO_ADDR
15962: GO 15984
15964: LD_INT 36
15966: DOUBLE
15967: EQUAL
15968: IFTRUE 15972
15970: GO 15983
15972: POP
// places := 3 ; end ;
15973: LD_ADDR_VAR 0 3
15977: PUSH
15978: LD_INT 3
15980: ST_TO_ADDR
15981: GO 15984
15983: POP
// if places then
15984: LD_VAR 0 3
15988: IFFALSE 16011
// result := UnitsInside ( building ) < places ;
15990: LD_ADDR_VAR 0 2
15994: PUSH
15995: LD_VAR 0 1
15999: PPUSH
16000: CALL_OW 313
16004: PUSH
16005: LD_VAR 0 3
16009: LESS
16010: ST_TO_ADDR
// end ;
16011: LD_VAR 0 2
16015: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16016: LD_INT 0
16018: PPUSH
16019: PPUSH
16020: PPUSH
16021: PPUSH
// tmp := [ ] ;
16022: LD_ADDR_VAR 0 3
16026: PUSH
16027: EMPTY
16028: ST_TO_ADDR
// list := [ ] ;
16029: LD_ADDR_VAR 0 5
16033: PUSH
16034: EMPTY
16035: ST_TO_ADDR
// for i = 16 to 25 do
16036: LD_ADDR_VAR 0 4
16040: PUSH
16041: DOUBLE
16042: LD_INT 16
16044: DEC
16045: ST_TO_ADDR
16046: LD_INT 25
16048: PUSH
16049: FOR_TO
16050: IFFALSE 16123
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16052: LD_ADDR_VAR 0 3
16056: PUSH
16057: LD_VAR 0 3
16061: PUSH
16062: LD_INT 22
16064: PUSH
16065: LD_VAR 0 1
16069: PPUSH
16070: CALL_OW 255
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 91
16081: PUSH
16082: LD_VAR 0 1
16086: PUSH
16087: LD_INT 6
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: LIST
16094: PUSH
16095: LD_INT 30
16097: PUSH
16098: LD_VAR 0 4
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: PUSH
16112: EMPTY
16113: LIST
16114: PPUSH
16115: CALL_OW 69
16119: ADD
16120: ST_TO_ADDR
16121: GO 16049
16123: POP
16124: POP
// for i = 1 to tmp do
16125: LD_ADDR_VAR 0 4
16129: PUSH
16130: DOUBLE
16131: LD_INT 1
16133: DEC
16134: ST_TO_ADDR
16135: LD_VAR 0 3
16139: PUSH
16140: FOR_TO
16141: IFFALSE 16229
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16143: LD_ADDR_VAR 0 5
16147: PUSH
16148: LD_VAR 0 5
16152: PUSH
16153: LD_VAR 0 3
16157: PUSH
16158: LD_VAR 0 4
16162: ARRAY
16163: PPUSH
16164: CALL_OW 266
16168: PUSH
16169: LD_VAR 0 3
16173: PUSH
16174: LD_VAR 0 4
16178: ARRAY
16179: PPUSH
16180: CALL_OW 250
16184: PUSH
16185: LD_VAR 0 3
16189: PUSH
16190: LD_VAR 0 4
16194: ARRAY
16195: PPUSH
16196: CALL_OW 251
16200: PUSH
16201: LD_VAR 0 3
16205: PUSH
16206: LD_VAR 0 4
16210: ARRAY
16211: PPUSH
16212: CALL_OW 254
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: ADD
16226: ST_TO_ADDR
16227: GO 16140
16229: POP
16230: POP
// result := list ;
16231: LD_ADDR_VAR 0 2
16235: PUSH
16236: LD_VAR 0 5
16240: ST_TO_ADDR
// end ;
16241: LD_VAR 0 2
16245: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16246: LD_INT 0
16248: PPUSH
16249: PPUSH
16250: PPUSH
16251: PPUSH
16252: PPUSH
16253: PPUSH
16254: PPUSH
// if not factory then
16255: LD_VAR 0 1
16259: NOT
16260: IFFALSE 16264
// exit ;
16262: GO 16857
// if control = control_apeman then
16264: LD_VAR 0 4
16268: PUSH
16269: LD_INT 5
16271: EQUAL
16272: IFFALSE 16381
// begin tmp := UnitsInside ( factory ) ;
16274: LD_ADDR_VAR 0 8
16278: PUSH
16279: LD_VAR 0 1
16283: PPUSH
16284: CALL_OW 313
16288: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16289: LD_VAR 0 8
16293: PPUSH
16294: LD_INT 25
16296: PUSH
16297: LD_INT 12
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 72
16308: NOT
16309: IFFALSE 16319
// control := control_manual ;
16311: LD_ADDR_VAR 0 4
16315: PUSH
16316: LD_INT 1
16318: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16319: LD_ADDR_VAR 0 8
16323: PUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: CALL 16016 0 1
16333: ST_TO_ADDR
// if tmp then
16334: LD_VAR 0 8
16338: IFFALSE 16381
// begin for i in tmp do
16340: LD_ADDR_VAR 0 7
16344: PUSH
16345: LD_VAR 0 8
16349: PUSH
16350: FOR_IN
16351: IFFALSE 16379
// if i [ 1 ] = b_ext_radio then
16353: LD_VAR 0 7
16357: PUSH
16358: LD_INT 1
16360: ARRAY
16361: PUSH
16362: LD_INT 22
16364: EQUAL
16365: IFFALSE 16377
// begin control := control_remote ;
16367: LD_ADDR_VAR 0 4
16371: PUSH
16372: LD_INT 2
16374: ST_TO_ADDR
// break ;
16375: GO 16379
// end ;
16377: GO 16350
16379: POP
16380: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16381: LD_VAR 0 1
16385: PPUSH
16386: LD_VAR 0 2
16390: PPUSH
16391: LD_VAR 0 3
16395: PPUSH
16396: LD_VAR 0 4
16400: PPUSH
16401: LD_VAR 0 5
16405: PPUSH
16406: CALL_OW 448
16410: IFFALSE 16445
// begin result := [ chassis , engine , control , weapon ] ;
16412: LD_ADDR_VAR 0 6
16416: PUSH
16417: LD_VAR 0 2
16421: PUSH
16422: LD_VAR 0 3
16426: PUSH
16427: LD_VAR 0 4
16431: PUSH
16432: LD_VAR 0 5
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: ST_TO_ADDR
// exit ;
16443: GO 16857
// end ; _chassis := AvailableChassisList ( factory ) ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 1
16454: PPUSH
16455: CALL_OW 475
16459: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16460: LD_ADDR_VAR 0 11
16464: PUSH
16465: LD_VAR 0 1
16469: PPUSH
16470: CALL_OW 476
16474: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16475: LD_ADDR_VAR 0 12
16479: PUSH
16480: LD_VAR 0 1
16484: PPUSH
16485: CALL_OW 477
16489: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16490: LD_ADDR_VAR 0 10
16494: PUSH
16495: LD_VAR 0 1
16499: PPUSH
16500: CALL_OW 478
16504: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16505: LD_VAR 0 9
16509: NOT
16510: PUSH
16511: LD_VAR 0 11
16515: NOT
16516: OR
16517: PUSH
16518: LD_VAR 0 12
16522: NOT
16523: OR
16524: PUSH
16525: LD_VAR 0 10
16529: NOT
16530: OR
16531: IFFALSE 16566
// begin result := [ chassis , engine , control , weapon ] ;
16533: LD_ADDR_VAR 0 6
16537: PUSH
16538: LD_VAR 0 2
16542: PUSH
16543: LD_VAR 0 3
16547: PUSH
16548: LD_VAR 0 4
16552: PUSH
16553: LD_VAR 0 5
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: LIST
16562: LIST
16563: ST_TO_ADDR
// exit ;
16564: GO 16857
// end ; if not chassis in _chassis then
16566: LD_VAR 0 2
16570: PUSH
16571: LD_VAR 0 9
16575: IN
16576: NOT
16577: IFFALSE 16603
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16579: LD_ADDR_VAR 0 2
16583: PUSH
16584: LD_VAR 0 9
16588: PUSH
16589: LD_INT 1
16591: PPUSH
16592: LD_VAR 0 9
16596: PPUSH
16597: CALL_OW 12
16601: ARRAY
16602: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16603: LD_VAR 0 2
16607: PPUSH
16608: LD_VAR 0 3
16612: PPUSH
16613: CALL 16862 0 2
16617: NOT
16618: IFFALSE 16677
// repeat engine := _engine [ 1 ] ;
16620: LD_ADDR_VAR 0 3
16624: PUSH
16625: LD_VAR 0 11
16629: PUSH
16630: LD_INT 1
16632: ARRAY
16633: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16634: LD_ADDR_VAR 0 11
16638: PUSH
16639: LD_VAR 0 11
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: CALL_OW 3
16651: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16652: LD_VAR 0 2
16656: PPUSH
16657: LD_VAR 0 3
16661: PPUSH
16662: CALL 16862 0 2
16666: PUSH
16667: LD_VAR 0 11
16671: PUSH
16672: EMPTY
16673: EQUAL
16674: OR
16675: IFFALSE 16620
// if not control in _control then
16677: LD_VAR 0 4
16681: PUSH
16682: LD_VAR 0 12
16686: IN
16687: NOT
16688: IFFALSE 16714
// control := _control [ rand ( 1 , _control ) ] ;
16690: LD_ADDR_VAR 0 4
16694: PUSH
16695: LD_VAR 0 12
16699: PUSH
16700: LD_INT 1
16702: PPUSH
16703: LD_VAR 0 12
16707: PPUSH
16708: CALL_OW 12
16712: ARRAY
16713: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16714: LD_VAR 0 2
16718: PPUSH
16719: LD_VAR 0 5
16723: PPUSH
16724: CALL 17082 0 2
16728: NOT
16729: IFFALSE 16788
// repeat weapon := _weapon [ 1 ] ;
16731: LD_ADDR_VAR 0 5
16735: PUSH
16736: LD_VAR 0 10
16740: PUSH
16741: LD_INT 1
16743: ARRAY
16744: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16745: LD_ADDR_VAR 0 10
16749: PUSH
16750: LD_VAR 0 10
16754: PPUSH
16755: LD_INT 1
16757: PPUSH
16758: CALL_OW 3
16762: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16763: LD_VAR 0 2
16767: PPUSH
16768: LD_VAR 0 5
16772: PPUSH
16773: CALL 17082 0 2
16777: PUSH
16778: LD_VAR 0 10
16782: PUSH
16783: EMPTY
16784: EQUAL
16785: OR
16786: IFFALSE 16731
// result := [ ] ;
16788: LD_ADDR_VAR 0 6
16792: PUSH
16793: EMPTY
16794: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16795: LD_VAR 0 1
16799: PPUSH
16800: LD_VAR 0 2
16804: PPUSH
16805: LD_VAR 0 3
16809: PPUSH
16810: LD_VAR 0 4
16814: PPUSH
16815: LD_VAR 0 5
16819: PPUSH
16820: CALL_OW 448
16824: IFFALSE 16857
// result := [ chassis , engine , control , weapon ] ;
16826: LD_ADDR_VAR 0 6
16830: PUSH
16831: LD_VAR 0 2
16835: PUSH
16836: LD_VAR 0 3
16840: PUSH
16841: LD_VAR 0 4
16845: PUSH
16846: LD_VAR 0 5
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: ST_TO_ADDR
// end ;
16857: LD_VAR 0 6
16861: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16862: LD_INT 0
16864: PPUSH
// if not chassis or not engine then
16865: LD_VAR 0 1
16869: NOT
16870: PUSH
16871: LD_VAR 0 2
16875: NOT
16876: OR
16877: IFFALSE 16881
// exit ;
16879: GO 17077
// case engine of engine_solar :
16881: LD_VAR 0 2
16885: PUSH
16886: LD_INT 2
16888: DOUBLE
16889: EQUAL
16890: IFTRUE 16894
16892: GO 16932
16894: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16895: LD_ADDR_VAR 0 3
16899: PUSH
16900: LD_INT 11
16902: PUSH
16903: LD_INT 12
16905: PUSH
16906: LD_INT 13
16908: PUSH
16909: LD_INT 14
16911: PUSH
16912: LD_INT 1
16914: PUSH
16915: LD_INT 2
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: LIST
16929: ST_TO_ADDR
16930: GO 17061
16932: LD_INT 1
16934: DOUBLE
16935: EQUAL
16936: IFTRUE 16940
16938: GO 17002
16940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16941: LD_ADDR_VAR 0 3
16945: PUSH
16946: LD_INT 11
16948: PUSH
16949: LD_INT 12
16951: PUSH
16952: LD_INT 13
16954: PUSH
16955: LD_INT 14
16957: PUSH
16958: LD_INT 1
16960: PUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 3
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: LD_INT 5
16972: PUSH
16973: LD_INT 21
16975: PUSH
16976: LD_INT 23
16978: PUSH
16979: LD_INT 22
16981: PUSH
16982: LD_INT 24
16984: PUSH
16985: EMPTY
16986: LIST
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: LIST
16992: LIST
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: LIST
16998: LIST
16999: ST_TO_ADDR
17000: GO 17061
17002: LD_INT 3
17004: DOUBLE
17005: EQUAL
17006: IFTRUE 17010
17008: GO 17060
17010: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17011: LD_ADDR_VAR 0 3
17015: PUSH
17016: LD_INT 13
17018: PUSH
17019: LD_INT 14
17021: PUSH
17022: LD_INT 2
17024: PUSH
17025: LD_INT 3
17027: PUSH
17028: LD_INT 4
17030: PUSH
17031: LD_INT 5
17033: PUSH
17034: LD_INT 21
17036: PUSH
17037: LD_INT 22
17039: PUSH
17040: LD_INT 23
17042: PUSH
17043: LD_INT 24
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: ST_TO_ADDR
17058: GO 17061
17060: POP
// result := ( chassis in result ) ;
17061: LD_ADDR_VAR 0 3
17065: PUSH
17066: LD_VAR 0 1
17070: PUSH
17071: LD_VAR 0 3
17075: IN
17076: ST_TO_ADDR
// end ;
17077: LD_VAR 0 3
17081: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17082: LD_INT 0
17084: PPUSH
// if not chassis or not weapon then
17085: LD_VAR 0 1
17089: NOT
17090: PUSH
17091: LD_VAR 0 2
17095: NOT
17096: OR
17097: IFFALSE 17101
// exit ;
17099: GO 18163
// case weapon of us_machine_gun :
17101: LD_VAR 0 2
17105: PUSH
17106: LD_INT 2
17108: DOUBLE
17109: EQUAL
17110: IFTRUE 17114
17112: GO 17144
17114: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17115: LD_ADDR_VAR 0 3
17119: PUSH
17120: LD_INT 1
17122: PUSH
17123: LD_INT 2
17125: PUSH
17126: LD_INT 3
17128: PUSH
17129: LD_INT 4
17131: PUSH
17132: LD_INT 5
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: LIST
17139: LIST
17140: LIST
17141: ST_TO_ADDR
17142: GO 18147
17144: LD_INT 3
17146: DOUBLE
17147: EQUAL
17148: IFTRUE 17152
17150: GO 17182
17152: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17153: LD_ADDR_VAR 0 3
17157: PUSH
17158: LD_INT 1
17160: PUSH
17161: LD_INT 2
17163: PUSH
17164: LD_INT 3
17166: PUSH
17167: LD_INT 4
17169: PUSH
17170: LD_INT 5
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: ST_TO_ADDR
17180: GO 18147
17182: LD_INT 11
17184: DOUBLE
17185: EQUAL
17186: IFTRUE 17190
17188: GO 17220
17190: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17191: LD_ADDR_VAR 0 3
17195: PUSH
17196: LD_INT 1
17198: PUSH
17199: LD_INT 2
17201: PUSH
17202: LD_INT 3
17204: PUSH
17205: LD_INT 4
17207: PUSH
17208: LD_INT 5
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: LIST
17215: LIST
17216: LIST
17217: ST_TO_ADDR
17218: GO 18147
17220: LD_INT 4
17222: DOUBLE
17223: EQUAL
17224: IFTRUE 17228
17226: GO 17254
17228: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17229: LD_ADDR_VAR 0 3
17233: PUSH
17234: LD_INT 2
17236: PUSH
17237: LD_INT 3
17239: PUSH
17240: LD_INT 4
17242: PUSH
17243: LD_INT 5
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: ST_TO_ADDR
17252: GO 18147
17254: LD_INT 5
17256: DOUBLE
17257: EQUAL
17258: IFTRUE 17262
17260: GO 17288
17262: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17263: LD_ADDR_VAR 0 3
17267: PUSH
17268: LD_INT 2
17270: PUSH
17271: LD_INT 3
17273: PUSH
17274: LD_INT 4
17276: PUSH
17277: LD_INT 5
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: LIST
17284: LIST
17285: ST_TO_ADDR
17286: GO 18147
17288: LD_INT 9
17290: DOUBLE
17291: EQUAL
17292: IFTRUE 17296
17294: GO 17322
17296: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17297: LD_ADDR_VAR 0 3
17301: PUSH
17302: LD_INT 2
17304: PUSH
17305: LD_INT 3
17307: PUSH
17308: LD_INT 4
17310: PUSH
17311: LD_INT 5
17313: PUSH
17314: EMPTY
17315: LIST
17316: LIST
17317: LIST
17318: LIST
17319: ST_TO_ADDR
17320: GO 18147
17322: LD_INT 7
17324: DOUBLE
17325: EQUAL
17326: IFTRUE 17330
17328: GO 17356
17330: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17331: LD_ADDR_VAR 0 3
17335: PUSH
17336: LD_INT 2
17338: PUSH
17339: LD_INT 3
17341: PUSH
17342: LD_INT 4
17344: PUSH
17345: LD_INT 5
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: LIST
17352: LIST
17353: ST_TO_ADDR
17354: GO 18147
17356: LD_INT 12
17358: DOUBLE
17359: EQUAL
17360: IFTRUE 17364
17362: GO 17390
17364: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17365: LD_ADDR_VAR 0 3
17369: PUSH
17370: LD_INT 2
17372: PUSH
17373: LD_INT 3
17375: PUSH
17376: LD_INT 4
17378: PUSH
17379: LD_INT 5
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: ST_TO_ADDR
17388: GO 18147
17390: LD_INT 13
17392: DOUBLE
17393: EQUAL
17394: IFTRUE 17398
17396: GO 17424
17398: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17399: LD_ADDR_VAR 0 3
17403: PUSH
17404: LD_INT 2
17406: PUSH
17407: LD_INT 3
17409: PUSH
17410: LD_INT 4
17412: PUSH
17413: LD_INT 5
17415: PUSH
17416: EMPTY
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: ST_TO_ADDR
17422: GO 18147
17424: LD_INT 14
17426: DOUBLE
17427: EQUAL
17428: IFTRUE 17432
17430: GO 17450
17432: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17433: LD_ADDR_VAR 0 3
17437: PUSH
17438: LD_INT 4
17440: PUSH
17441: LD_INT 5
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: ST_TO_ADDR
17448: GO 18147
17450: LD_INT 6
17452: DOUBLE
17453: EQUAL
17454: IFTRUE 17458
17456: GO 17476
17458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17459: LD_ADDR_VAR 0 3
17463: PUSH
17464: LD_INT 4
17466: PUSH
17467: LD_INT 5
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: ST_TO_ADDR
17474: GO 18147
17476: LD_INT 10
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17502
17484: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17485: LD_ADDR_VAR 0 3
17489: PUSH
17490: LD_INT 4
17492: PUSH
17493: LD_INT 5
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: ST_TO_ADDR
17500: GO 18147
17502: LD_INT 22
17504: DOUBLE
17505: EQUAL
17506: IFTRUE 17510
17508: GO 17536
17510: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17511: LD_ADDR_VAR 0 3
17515: PUSH
17516: LD_INT 11
17518: PUSH
17519: LD_INT 12
17521: PUSH
17522: LD_INT 13
17524: PUSH
17525: LD_INT 14
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: ST_TO_ADDR
17534: GO 18147
17536: LD_INT 23
17538: DOUBLE
17539: EQUAL
17540: IFTRUE 17544
17542: GO 17570
17544: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17545: LD_ADDR_VAR 0 3
17549: PUSH
17550: LD_INT 11
17552: PUSH
17553: LD_INT 12
17555: PUSH
17556: LD_INT 13
17558: PUSH
17559: LD_INT 14
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: ST_TO_ADDR
17568: GO 18147
17570: LD_INT 24
17572: DOUBLE
17573: EQUAL
17574: IFTRUE 17578
17576: GO 17604
17578: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17579: LD_ADDR_VAR 0 3
17583: PUSH
17584: LD_INT 11
17586: PUSH
17587: LD_INT 12
17589: PUSH
17590: LD_INT 13
17592: PUSH
17593: LD_INT 14
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: ST_TO_ADDR
17602: GO 18147
17604: LD_INT 30
17606: DOUBLE
17607: EQUAL
17608: IFTRUE 17612
17610: GO 17638
17612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17613: LD_ADDR_VAR 0 3
17617: PUSH
17618: LD_INT 11
17620: PUSH
17621: LD_INT 12
17623: PUSH
17624: LD_INT 13
17626: PUSH
17627: LD_INT 14
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: LIST
17634: LIST
17635: ST_TO_ADDR
17636: GO 18147
17638: LD_INT 25
17640: DOUBLE
17641: EQUAL
17642: IFTRUE 17646
17644: GO 17664
17646: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17647: LD_ADDR_VAR 0 3
17651: PUSH
17652: LD_INT 13
17654: PUSH
17655: LD_INT 14
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: ST_TO_ADDR
17662: GO 18147
17664: LD_INT 27
17666: DOUBLE
17667: EQUAL
17668: IFTRUE 17672
17670: GO 17690
17672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17673: LD_ADDR_VAR 0 3
17677: PUSH
17678: LD_INT 13
17680: PUSH
17681: LD_INT 14
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: ST_TO_ADDR
17688: GO 18147
17690: LD_EXP 53
17694: DOUBLE
17695: EQUAL
17696: IFTRUE 17700
17698: GO 17726
17700: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17701: LD_ADDR_VAR 0 3
17705: PUSH
17706: LD_INT 11
17708: PUSH
17709: LD_INT 12
17711: PUSH
17712: LD_INT 13
17714: PUSH
17715: LD_INT 14
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: ST_TO_ADDR
17724: GO 18147
17726: LD_INT 28
17728: DOUBLE
17729: EQUAL
17730: IFTRUE 17734
17732: GO 17752
17734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17735: LD_ADDR_VAR 0 3
17739: PUSH
17740: LD_INT 13
17742: PUSH
17743: LD_INT 14
17745: PUSH
17746: EMPTY
17747: LIST
17748: LIST
17749: ST_TO_ADDR
17750: GO 18147
17752: LD_INT 29
17754: DOUBLE
17755: EQUAL
17756: IFTRUE 17760
17758: GO 17778
17760: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17761: LD_ADDR_VAR 0 3
17765: PUSH
17766: LD_INT 13
17768: PUSH
17769: LD_INT 14
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18147
17778: LD_INT 31
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17804
17786: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 13
17794: PUSH
17795: LD_INT 14
17797: PUSH
17798: EMPTY
17799: LIST
17800: LIST
17801: ST_TO_ADDR
17802: GO 18147
17804: LD_INT 26
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17830
17812: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17813: LD_ADDR_VAR 0 3
17817: PUSH
17818: LD_INT 13
17820: PUSH
17821: LD_INT 14
17823: PUSH
17824: EMPTY
17825: LIST
17826: LIST
17827: ST_TO_ADDR
17828: GO 18147
17830: LD_INT 42
17832: DOUBLE
17833: EQUAL
17834: IFTRUE 17838
17836: GO 17864
17838: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17839: LD_ADDR_VAR 0 3
17843: PUSH
17844: LD_INT 21
17846: PUSH
17847: LD_INT 22
17849: PUSH
17850: LD_INT 23
17852: PUSH
17853: LD_INT 24
17855: PUSH
17856: EMPTY
17857: LIST
17858: LIST
17859: LIST
17860: LIST
17861: ST_TO_ADDR
17862: GO 18147
17864: LD_INT 43
17866: DOUBLE
17867: EQUAL
17868: IFTRUE 17872
17870: GO 17898
17872: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_INT 21
17880: PUSH
17881: LD_INT 22
17883: PUSH
17884: LD_INT 23
17886: PUSH
17887: LD_INT 24
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: ST_TO_ADDR
17896: GO 18147
17898: LD_INT 44
17900: DOUBLE
17901: EQUAL
17902: IFTRUE 17906
17904: GO 17932
17906: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17907: LD_ADDR_VAR 0 3
17911: PUSH
17912: LD_INT 21
17914: PUSH
17915: LD_INT 22
17917: PUSH
17918: LD_INT 23
17920: PUSH
17921: LD_INT 24
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: LIST
17928: LIST
17929: ST_TO_ADDR
17930: GO 18147
17932: LD_INT 45
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17966
17940: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17941: LD_ADDR_VAR 0 3
17945: PUSH
17946: LD_INT 21
17948: PUSH
17949: LD_INT 22
17951: PUSH
17952: LD_INT 23
17954: PUSH
17955: LD_INT 24
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: LIST
17963: ST_TO_ADDR
17964: GO 18147
17966: LD_INT 49
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 18000
17974: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17975: LD_ADDR_VAR 0 3
17979: PUSH
17980: LD_INT 21
17982: PUSH
17983: LD_INT 22
17985: PUSH
17986: LD_INT 23
17988: PUSH
17989: LD_INT 24
17991: PUSH
17992: EMPTY
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18147
18000: LD_INT 51
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18034
18008: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 21
18016: PUSH
18017: LD_INT 22
18019: PUSH
18020: LD_INT 23
18022: PUSH
18023: LD_INT 24
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: ST_TO_ADDR
18032: GO 18147
18034: LD_INT 52
18036: DOUBLE
18037: EQUAL
18038: IFTRUE 18042
18040: GO 18068
18042: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18043: LD_ADDR_VAR 0 3
18047: PUSH
18048: LD_INT 21
18050: PUSH
18051: LD_INT 22
18053: PUSH
18054: LD_INT 23
18056: PUSH
18057: LD_INT 24
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: LIST
18065: ST_TO_ADDR
18066: GO 18147
18068: LD_INT 53
18070: DOUBLE
18071: EQUAL
18072: IFTRUE 18076
18074: GO 18094
18076: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18077: LD_ADDR_VAR 0 3
18081: PUSH
18082: LD_INT 23
18084: PUSH
18085: LD_INT 24
18087: PUSH
18088: EMPTY
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18147
18094: LD_INT 46
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18120
18102: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 23
18110: PUSH
18111: LD_INT 24
18113: PUSH
18114: EMPTY
18115: LIST
18116: LIST
18117: ST_TO_ADDR
18118: GO 18147
18120: LD_INT 47
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18146
18128: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18129: LD_ADDR_VAR 0 3
18133: PUSH
18134: LD_INT 23
18136: PUSH
18137: LD_INT 24
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: ST_TO_ADDR
18144: GO 18147
18146: POP
// result := ( chassis in result ) ;
18147: LD_ADDR_VAR 0 3
18151: PUSH
18152: LD_VAR 0 1
18156: PUSH
18157: LD_VAR 0 3
18161: IN
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
18176: PPUSH
// result := array ;
18177: LD_ADDR_VAR 0 5
18181: PUSH
18182: LD_VAR 0 1
18186: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18187: LD_VAR 0 1
18191: NOT
18192: PUSH
18193: LD_VAR 0 2
18197: NOT
18198: OR
18199: PUSH
18200: LD_VAR 0 3
18204: NOT
18205: OR
18206: PUSH
18207: LD_VAR 0 2
18211: PUSH
18212: LD_VAR 0 1
18216: GREATER
18217: OR
18218: PUSH
18219: LD_VAR 0 3
18223: PUSH
18224: LD_VAR 0 1
18228: GREATER
18229: OR
18230: IFFALSE 18234
// exit ;
18232: GO 18530
// if direction then
18234: LD_VAR 0 4
18238: IFFALSE 18302
// begin d := 1 ;
18240: LD_ADDR_VAR 0 9
18244: PUSH
18245: LD_INT 1
18247: ST_TO_ADDR
// if i_from > i_to then
18248: LD_VAR 0 2
18252: PUSH
18253: LD_VAR 0 3
18257: GREATER
18258: IFFALSE 18284
// length := ( array - i_from ) + i_to else
18260: LD_ADDR_VAR 0 11
18264: PUSH
18265: LD_VAR 0 1
18269: PUSH
18270: LD_VAR 0 2
18274: MINUS
18275: PUSH
18276: LD_VAR 0 3
18280: PLUS
18281: ST_TO_ADDR
18282: GO 18300
// length := i_to - i_from ;
18284: LD_ADDR_VAR 0 11
18288: PUSH
18289: LD_VAR 0 3
18293: PUSH
18294: LD_VAR 0 2
18298: MINUS
18299: ST_TO_ADDR
// end else
18300: GO 18363
// begin d := - 1 ;
18302: LD_ADDR_VAR 0 9
18306: PUSH
18307: LD_INT 1
18309: NEG
18310: ST_TO_ADDR
// if i_from > i_to then
18311: LD_VAR 0 2
18315: PUSH
18316: LD_VAR 0 3
18320: GREATER
18321: IFFALSE 18341
// length := i_from - i_to else
18323: LD_ADDR_VAR 0 11
18327: PUSH
18328: LD_VAR 0 2
18332: PUSH
18333: LD_VAR 0 3
18337: MINUS
18338: ST_TO_ADDR
18339: GO 18363
// length := ( array - i_to ) + i_from ;
18341: LD_ADDR_VAR 0 11
18345: PUSH
18346: LD_VAR 0 1
18350: PUSH
18351: LD_VAR 0 3
18355: MINUS
18356: PUSH
18357: LD_VAR 0 2
18361: PLUS
18362: ST_TO_ADDR
// end ; if not length then
18363: LD_VAR 0 11
18367: NOT
18368: IFFALSE 18372
// exit ;
18370: GO 18530
// tmp := array ;
18372: LD_ADDR_VAR 0 10
18376: PUSH
18377: LD_VAR 0 1
18381: ST_TO_ADDR
// for i = 1 to length do
18382: LD_ADDR_VAR 0 6
18386: PUSH
18387: DOUBLE
18388: LD_INT 1
18390: DEC
18391: ST_TO_ADDR
18392: LD_VAR 0 11
18396: PUSH
18397: FOR_TO
18398: IFFALSE 18518
// begin for j = 1 to array do
18400: LD_ADDR_VAR 0 7
18404: PUSH
18405: DOUBLE
18406: LD_INT 1
18408: DEC
18409: ST_TO_ADDR
18410: LD_VAR 0 1
18414: PUSH
18415: FOR_TO
18416: IFFALSE 18504
// begin k := j + d ;
18418: LD_ADDR_VAR 0 8
18422: PUSH
18423: LD_VAR 0 7
18427: PUSH
18428: LD_VAR 0 9
18432: PLUS
18433: ST_TO_ADDR
// if k > array then
18434: LD_VAR 0 8
18438: PUSH
18439: LD_VAR 0 1
18443: GREATER
18444: IFFALSE 18454
// k := 1 ;
18446: LD_ADDR_VAR 0 8
18450: PUSH
18451: LD_INT 1
18453: ST_TO_ADDR
// if not k then
18454: LD_VAR 0 8
18458: NOT
18459: IFFALSE 18471
// k := array ;
18461: LD_ADDR_VAR 0 8
18465: PUSH
18466: LD_VAR 0 1
18470: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18471: LD_ADDR_VAR 0 10
18475: PUSH
18476: LD_VAR 0 10
18480: PPUSH
18481: LD_VAR 0 8
18485: PPUSH
18486: LD_VAR 0 1
18490: PUSH
18491: LD_VAR 0 7
18495: ARRAY
18496: PPUSH
18497: CALL_OW 1
18501: ST_TO_ADDR
// end ;
18502: GO 18415
18504: POP
18505: POP
// array := tmp ;
18506: LD_ADDR_VAR 0 1
18510: PUSH
18511: LD_VAR 0 10
18515: ST_TO_ADDR
// end ;
18516: GO 18397
18518: POP
18519: POP
// result := array ;
18520: LD_ADDR_VAR 0 5
18524: PUSH
18525: LD_VAR 0 1
18529: ST_TO_ADDR
// end ;
18530: LD_VAR 0 5
18534: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18535: LD_INT 0
18537: PPUSH
18538: PPUSH
// result := 0 ;
18539: LD_ADDR_VAR 0 3
18543: PUSH
18544: LD_INT 0
18546: ST_TO_ADDR
// if not array or not value in array then
18547: LD_VAR 0 1
18551: NOT
18552: PUSH
18553: LD_VAR 0 2
18557: PUSH
18558: LD_VAR 0 1
18562: IN
18563: NOT
18564: OR
18565: IFFALSE 18569
// exit ;
18567: GO 18623
// for i = 1 to array do
18569: LD_ADDR_VAR 0 4
18573: PUSH
18574: DOUBLE
18575: LD_INT 1
18577: DEC
18578: ST_TO_ADDR
18579: LD_VAR 0 1
18583: PUSH
18584: FOR_TO
18585: IFFALSE 18621
// if value = array [ i ] then
18587: LD_VAR 0 2
18591: PUSH
18592: LD_VAR 0 1
18596: PUSH
18597: LD_VAR 0 4
18601: ARRAY
18602: EQUAL
18603: IFFALSE 18619
// begin result := i ;
18605: LD_ADDR_VAR 0 3
18609: PUSH
18610: LD_VAR 0 4
18614: ST_TO_ADDR
// exit ;
18615: POP
18616: POP
18617: GO 18623
// end ;
18619: GO 18584
18621: POP
18622: POP
// end ;
18623: LD_VAR 0 3
18627: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18628: LD_INT 0
18630: PPUSH
// vc_chassis := chassis ;
18631: LD_ADDR_OWVAR 37
18635: PUSH
18636: LD_VAR 0 1
18640: ST_TO_ADDR
// vc_engine := engine ;
18641: LD_ADDR_OWVAR 39
18645: PUSH
18646: LD_VAR 0 2
18650: ST_TO_ADDR
// vc_control := control ;
18651: LD_ADDR_OWVAR 38
18655: PUSH
18656: LD_VAR 0 3
18660: ST_TO_ADDR
// vc_weapon := weapon ;
18661: LD_ADDR_OWVAR 40
18665: PUSH
18666: LD_VAR 0 4
18670: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18671: LD_ADDR_OWVAR 41
18675: PUSH
18676: LD_VAR 0 5
18680: ST_TO_ADDR
// end ;
18681: LD_VAR 0 6
18685: RET
// export function WantPlant ( unit ) ; var task ; begin
18686: LD_INT 0
18688: PPUSH
18689: PPUSH
// result := false ;
18690: LD_ADDR_VAR 0 2
18694: PUSH
18695: LD_INT 0
18697: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18698: LD_ADDR_VAR 0 3
18702: PUSH
18703: LD_VAR 0 1
18707: PPUSH
18708: CALL_OW 437
18712: ST_TO_ADDR
// if task then
18713: LD_VAR 0 3
18717: IFFALSE 18745
// if task [ 1 ] [ 1 ] = p then
18719: LD_VAR 0 3
18723: PUSH
18724: LD_INT 1
18726: ARRAY
18727: PUSH
18728: LD_INT 1
18730: ARRAY
18731: PUSH
18732: LD_STRING p
18734: EQUAL
18735: IFFALSE 18745
// result := true ;
18737: LD_ADDR_VAR 0 2
18741: PUSH
18742: LD_INT 1
18744: ST_TO_ADDR
// end ;
18745: LD_VAR 0 2
18749: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18750: LD_INT 0
18752: PPUSH
18753: PPUSH
18754: PPUSH
18755: PPUSH
// if pos < 1 then
18756: LD_VAR 0 2
18760: PUSH
18761: LD_INT 1
18763: LESS
18764: IFFALSE 18768
// exit ;
18766: GO 19071
// if pos = 1 then
18768: LD_VAR 0 2
18772: PUSH
18773: LD_INT 1
18775: EQUAL
18776: IFFALSE 18809
// result := Replace ( arr , pos [ 1 ] , value ) else
18778: LD_ADDR_VAR 0 4
18782: PUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: LD_VAR 0 2
18792: PUSH
18793: LD_INT 1
18795: ARRAY
18796: PPUSH
18797: LD_VAR 0 3
18801: PPUSH
18802: CALL_OW 1
18806: ST_TO_ADDR
18807: GO 19071
// begin tmp := arr ;
18809: LD_ADDR_VAR 0 6
18813: PUSH
18814: LD_VAR 0 1
18818: ST_TO_ADDR
// s_arr := [ tmp ] ;
18819: LD_ADDR_VAR 0 7
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: EMPTY
18830: LIST
18831: ST_TO_ADDR
// for i = 1 to pos - 1 do
18832: LD_ADDR_VAR 0 5
18836: PUSH
18837: DOUBLE
18838: LD_INT 1
18840: DEC
18841: ST_TO_ADDR
18842: LD_VAR 0 2
18846: PUSH
18847: LD_INT 1
18849: MINUS
18850: PUSH
18851: FOR_TO
18852: IFFALSE 18897
// begin tmp := tmp [ pos [ i ] ] ;
18854: LD_ADDR_VAR 0 6
18858: PUSH
18859: LD_VAR 0 6
18863: PUSH
18864: LD_VAR 0 2
18868: PUSH
18869: LD_VAR 0 5
18873: ARRAY
18874: ARRAY
18875: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18876: LD_ADDR_VAR 0 7
18880: PUSH
18881: LD_VAR 0 7
18885: PUSH
18886: LD_VAR 0 6
18890: PUSH
18891: EMPTY
18892: LIST
18893: ADD
18894: ST_TO_ADDR
// end ;
18895: GO 18851
18897: POP
18898: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18899: LD_ADDR_VAR 0 6
18903: PUSH
18904: LD_VAR 0 6
18908: PPUSH
18909: LD_VAR 0 2
18913: PUSH
18914: LD_VAR 0 2
18918: ARRAY
18919: PPUSH
18920: LD_VAR 0 3
18924: PPUSH
18925: CALL_OW 1
18929: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18930: LD_ADDR_VAR 0 7
18934: PUSH
18935: LD_VAR 0 7
18939: PPUSH
18940: LD_VAR 0 7
18944: PPUSH
18945: LD_VAR 0 6
18949: PPUSH
18950: CALL_OW 1
18954: ST_TO_ADDR
// for i = s_arr downto 2 do
18955: LD_ADDR_VAR 0 5
18959: PUSH
18960: DOUBLE
18961: LD_VAR 0 7
18965: INC
18966: ST_TO_ADDR
18967: LD_INT 2
18969: PUSH
18970: FOR_DOWNTO
18971: IFFALSE 19055
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18973: LD_ADDR_VAR 0 6
18977: PUSH
18978: LD_VAR 0 7
18982: PUSH
18983: LD_VAR 0 5
18987: PUSH
18988: LD_INT 1
18990: MINUS
18991: ARRAY
18992: PPUSH
18993: LD_VAR 0 2
18997: PUSH
18998: LD_VAR 0 5
19002: PUSH
19003: LD_INT 1
19005: MINUS
19006: ARRAY
19007: PPUSH
19008: LD_VAR 0 7
19012: PUSH
19013: LD_VAR 0 5
19017: ARRAY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19024: LD_ADDR_VAR 0 7
19028: PUSH
19029: LD_VAR 0 7
19033: PPUSH
19034: LD_VAR 0 5
19038: PUSH
19039: LD_INT 1
19041: MINUS
19042: PPUSH
19043: LD_VAR 0 6
19047: PPUSH
19048: CALL_OW 1
19052: ST_TO_ADDR
// end ;
19053: GO 18970
19055: POP
19056: POP
// result := s_arr [ 1 ] ;
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: LD_VAR 0 7
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: ST_TO_ADDR
// end ; end ;
19071: LD_VAR 0 4
19075: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19076: LD_INT 0
19078: PPUSH
19079: PPUSH
// if not list then
19080: LD_VAR 0 1
19084: NOT
19085: IFFALSE 19089
// exit ;
19087: GO 19180
// i := list [ pos1 ] ;
19089: LD_ADDR_VAR 0 5
19093: PUSH
19094: LD_VAR 0 1
19098: PUSH
19099: LD_VAR 0 2
19103: ARRAY
19104: ST_TO_ADDR
// if not i then
19105: LD_VAR 0 5
19109: NOT
19110: IFFALSE 19114
// exit ;
19112: GO 19180
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_VAR 0 1
19123: PPUSH
19124: LD_VAR 0 2
19128: PPUSH
19129: LD_VAR 0 1
19133: PUSH
19134: LD_VAR 0 3
19138: ARRAY
19139: PPUSH
19140: CALL_OW 1
19144: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19145: LD_ADDR_VAR 0 1
19149: PUSH
19150: LD_VAR 0 1
19154: PPUSH
19155: LD_VAR 0 3
19159: PPUSH
19160: LD_VAR 0 5
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// result := list ;
19170: LD_ADDR_VAR 0 4
19174: PUSH
19175: LD_VAR 0 1
19179: ST_TO_ADDR
// end ;
19180: LD_VAR 0 4
19184: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19185: LD_INT 0
19187: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19188: LD_ADDR_VAR 0 5
19192: PUSH
19193: LD_VAR 0 1
19197: PPUSH
19198: CALL_OW 250
19202: PPUSH
19203: LD_VAR 0 1
19207: PPUSH
19208: CALL_OW 251
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: LD_VAR 0 3
19222: PPUSH
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL 19238 0 5
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 5
19237: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if not list then
19244: LD_VAR 0 3
19248: NOT
19249: IFFALSE 19253
// exit ;
19251: GO 19641
// result := [ ] ;
19253: LD_ADDR_VAR 0 6
19257: PUSH
19258: EMPTY
19259: ST_TO_ADDR
// for i in list do
19260: LD_ADDR_VAR 0 7
19264: PUSH
19265: LD_VAR 0 3
19269: PUSH
19270: FOR_IN
19271: IFFALSE 19473
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19273: LD_ADDR_VAR 0 9
19277: PUSH
19278: LD_VAR 0 7
19282: PPUSH
19283: LD_VAR 0 1
19287: PPUSH
19288: LD_VAR 0 2
19292: PPUSH
19293: CALL_OW 297
19297: ST_TO_ADDR
// if not result then
19298: LD_VAR 0 6
19302: NOT
19303: IFFALSE 19329
// result := [ [ i , tmp ] ] else
19305: LD_ADDR_VAR 0 6
19309: PUSH
19310: LD_VAR 0 7
19314: PUSH
19315: LD_VAR 0 9
19319: PUSH
19320: EMPTY
19321: LIST
19322: LIST
19323: PUSH
19324: EMPTY
19325: LIST
19326: ST_TO_ADDR
19327: GO 19471
// begin if result [ result ] [ 2 ] < tmp then
19329: LD_VAR 0 6
19333: PUSH
19334: LD_VAR 0 6
19338: ARRAY
19339: PUSH
19340: LD_INT 2
19342: ARRAY
19343: PUSH
19344: LD_VAR 0 9
19348: LESS
19349: IFFALSE 19391
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19351: LD_ADDR_VAR 0 6
19355: PUSH
19356: LD_VAR 0 6
19360: PPUSH
19361: LD_VAR 0 6
19365: PUSH
19366: LD_INT 1
19368: PLUS
19369: PPUSH
19370: LD_VAR 0 7
19374: PUSH
19375: LD_VAR 0 9
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: PPUSH
19384: CALL_OW 2
19388: ST_TO_ADDR
19389: GO 19471
// for j = 1 to result do
19391: LD_ADDR_VAR 0 8
19395: PUSH
19396: DOUBLE
19397: LD_INT 1
19399: DEC
19400: ST_TO_ADDR
19401: LD_VAR 0 6
19405: PUSH
19406: FOR_TO
19407: IFFALSE 19469
// begin if tmp < result [ j ] [ 2 ] then
19409: LD_VAR 0 9
19413: PUSH
19414: LD_VAR 0 6
19418: PUSH
19419: LD_VAR 0 8
19423: ARRAY
19424: PUSH
19425: LD_INT 2
19427: ARRAY
19428: LESS
19429: IFFALSE 19467
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19431: LD_ADDR_VAR 0 6
19435: PUSH
19436: LD_VAR 0 6
19440: PPUSH
19441: LD_VAR 0 8
19445: PPUSH
19446: LD_VAR 0 7
19450: PUSH
19451: LD_VAR 0 9
19455: PUSH
19456: EMPTY
19457: LIST
19458: LIST
19459: PPUSH
19460: CALL_OW 2
19464: ST_TO_ADDR
// break ;
19465: GO 19469
// end ; end ;
19467: GO 19406
19469: POP
19470: POP
// end ; end ;
19471: GO 19270
19473: POP
19474: POP
// if result and not asc then
19475: LD_VAR 0 6
19479: PUSH
19480: LD_VAR 0 4
19484: NOT
19485: AND
19486: IFFALSE 19561
// begin tmp := result ;
19488: LD_ADDR_VAR 0 9
19492: PUSH
19493: LD_VAR 0 6
19497: ST_TO_ADDR
// for i = tmp downto 1 do
19498: LD_ADDR_VAR 0 7
19502: PUSH
19503: DOUBLE
19504: LD_VAR 0 9
19508: INC
19509: ST_TO_ADDR
19510: LD_INT 1
19512: PUSH
19513: FOR_DOWNTO
19514: IFFALSE 19559
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19516: LD_ADDR_VAR 0 6
19520: PUSH
19521: LD_VAR 0 6
19525: PPUSH
19526: LD_VAR 0 9
19530: PUSH
19531: LD_VAR 0 7
19535: MINUS
19536: PUSH
19537: LD_INT 1
19539: PLUS
19540: PPUSH
19541: LD_VAR 0 9
19545: PUSH
19546: LD_VAR 0 7
19550: ARRAY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
19557: GO 19513
19559: POP
19560: POP
// end ; tmp := [ ] ;
19561: LD_ADDR_VAR 0 9
19565: PUSH
19566: EMPTY
19567: ST_TO_ADDR
// if mode then
19568: LD_VAR 0 5
19572: IFFALSE 19641
// begin for i = 1 to result do
19574: LD_ADDR_VAR 0 7
19578: PUSH
19579: DOUBLE
19580: LD_INT 1
19582: DEC
19583: ST_TO_ADDR
19584: LD_VAR 0 6
19588: PUSH
19589: FOR_TO
19590: IFFALSE 19629
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19592: LD_ADDR_VAR 0 9
19596: PUSH
19597: LD_VAR 0 9
19601: PPUSH
19602: LD_VAR 0 7
19606: PPUSH
19607: LD_VAR 0 6
19611: PUSH
19612: LD_VAR 0 7
19616: ARRAY
19617: PUSH
19618: LD_INT 1
19620: ARRAY
19621: PPUSH
19622: CALL_OW 1
19626: ST_TO_ADDR
19627: GO 19589
19629: POP
19630: POP
// result := tmp ;
19631: LD_ADDR_VAR 0 6
19635: PUSH
19636: LD_VAR 0 9
19640: ST_TO_ADDR
// end ; end ;
19641: LD_VAR 0 6
19645: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19646: LD_INT 0
19648: PPUSH
19649: PPUSH
19650: PPUSH
19651: PPUSH
19652: PPUSH
19653: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19654: LD_ADDR_VAR 0 5
19658: PUSH
19659: LD_INT 0
19661: PUSH
19662: LD_INT 0
19664: PUSH
19665: LD_INT 0
19667: PUSH
19668: EMPTY
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: LIST
19674: LIST
19675: ST_TO_ADDR
// if not x or not y then
19676: LD_VAR 0 2
19680: NOT
19681: PUSH
19682: LD_VAR 0 3
19686: NOT
19687: OR
19688: IFFALSE 19692
// exit ;
19690: GO 21344
// if not range then
19692: LD_VAR 0 4
19696: NOT
19697: IFFALSE 19707
// range := 10 ;
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: LD_INT 10
19706: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19707: LD_ADDR_VAR 0 8
19711: PUSH
19712: LD_INT 81
19714: PUSH
19715: LD_VAR 0 1
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: LD_INT 92
19726: PUSH
19727: LD_VAR 0 2
19731: PUSH
19732: LD_VAR 0 3
19736: PUSH
19737: LD_VAR 0 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: LIST
19746: LIST
19747: PUSH
19748: LD_INT 3
19750: PUSH
19751: LD_INT 21
19753: PUSH
19754: LD_INT 3
19756: PUSH
19757: EMPTY
19758: LIST
19759: LIST
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: LIST
19769: PPUSH
19770: CALL_OW 69
19774: ST_TO_ADDR
// if not tmp then
19775: LD_VAR 0 8
19779: NOT
19780: IFFALSE 19784
// exit ;
19782: GO 21344
// for i in tmp do
19784: LD_ADDR_VAR 0 6
19788: PUSH
19789: LD_VAR 0 8
19793: PUSH
19794: FOR_IN
19795: IFFALSE 21319
// begin points := [ 0 , 0 , 0 ] ;
19797: LD_ADDR_VAR 0 9
19801: PUSH
19802: LD_INT 0
19804: PUSH
19805: LD_INT 0
19807: PUSH
19808: LD_INT 0
19810: PUSH
19811: EMPTY
19812: LIST
19813: LIST
19814: LIST
19815: ST_TO_ADDR
// bpoints := 1 ;
19816: LD_ADDR_VAR 0 10
19820: PUSH
19821: LD_INT 1
19823: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19824: LD_VAR 0 6
19828: PPUSH
19829: CALL_OW 247
19833: PUSH
19834: LD_INT 1
19836: DOUBLE
19837: EQUAL
19838: IFTRUE 19842
19840: GO 20420
19842: POP
// begin if GetClass ( i ) = 1 then
19843: LD_VAR 0 6
19847: PPUSH
19848: CALL_OW 257
19852: PUSH
19853: LD_INT 1
19855: EQUAL
19856: IFFALSE 19877
// points := [ 10 , 5 , 3 ] ;
19858: LD_ADDR_VAR 0 9
19862: PUSH
19863: LD_INT 10
19865: PUSH
19866: LD_INT 5
19868: PUSH
19869: LD_INT 3
19871: PUSH
19872: EMPTY
19873: LIST
19874: LIST
19875: LIST
19876: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19877: LD_VAR 0 6
19881: PPUSH
19882: CALL_OW 257
19886: PUSH
19887: LD_INT 2
19889: PUSH
19890: LD_INT 3
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: LIST
19900: IN
19901: IFFALSE 19922
// points := [ 3 , 2 , 1 ] ;
19903: LD_ADDR_VAR 0 9
19907: PUSH
19908: LD_INT 3
19910: PUSH
19911: LD_INT 2
19913: PUSH
19914: LD_INT 1
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: LIST
19921: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19922: LD_VAR 0 6
19926: PPUSH
19927: CALL_OW 257
19931: PUSH
19932: LD_INT 5
19934: EQUAL
19935: IFFALSE 19956
// points := [ 130 , 5 , 2 ] ;
19937: LD_ADDR_VAR 0 9
19941: PUSH
19942: LD_INT 130
19944: PUSH
19945: LD_INT 5
19947: PUSH
19948: LD_INT 2
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19956: LD_VAR 0 6
19960: PPUSH
19961: CALL_OW 257
19965: PUSH
19966: LD_INT 8
19968: EQUAL
19969: IFFALSE 19990
// points := [ 35 , 35 , 30 ] ;
19971: LD_ADDR_VAR 0 9
19975: PUSH
19976: LD_INT 35
19978: PUSH
19979: LD_INT 35
19981: PUSH
19982: LD_INT 30
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19990: LD_VAR 0 6
19994: PPUSH
19995: CALL_OW 257
19999: PUSH
20000: LD_INT 9
20002: EQUAL
20003: IFFALSE 20024
// points := [ 20 , 55 , 40 ] ;
20005: LD_ADDR_VAR 0 9
20009: PUSH
20010: LD_INT 20
20012: PUSH
20013: LD_INT 55
20015: PUSH
20016: LD_INT 40
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20024: LD_VAR 0 6
20028: PPUSH
20029: CALL_OW 257
20033: PUSH
20034: LD_INT 12
20036: PUSH
20037: LD_INT 16
20039: PUSH
20040: EMPTY
20041: LIST
20042: LIST
20043: IN
20044: IFFALSE 20065
// points := [ 5 , 3 , 2 ] ;
20046: LD_ADDR_VAR 0 9
20050: PUSH
20051: LD_INT 5
20053: PUSH
20054: LD_INT 3
20056: PUSH
20057: LD_INT 2
20059: PUSH
20060: EMPTY
20061: LIST
20062: LIST
20063: LIST
20064: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20065: LD_VAR 0 6
20069: PPUSH
20070: CALL_OW 257
20074: PUSH
20075: LD_INT 17
20077: EQUAL
20078: IFFALSE 20099
// points := [ 100 , 50 , 75 ] ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_INT 100
20087: PUSH
20088: LD_INT 50
20090: PUSH
20091: LD_INT 75
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: LIST
20098: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20099: LD_VAR 0 6
20103: PPUSH
20104: CALL_OW 257
20108: PUSH
20109: LD_INT 15
20111: EQUAL
20112: IFFALSE 20133
// points := [ 10 , 5 , 3 ] ;
20114: LD_ADDR_VAR 0 9
20118: PUSH
20119: LD_INT 10
20121: PUSH
20122: LD_INT 5
20124: PUSH
20125: LD_INT 3
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: LIST
20132: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20133: LD_VAR 0 6
20137: PPUSH
20138: CALL_OW 257
20142: PUSH
20143: LD_INT 14
20145: EQUAL
20146: IFFALSE 20167
// points := [ 10 , 0 , 0 ] ;
20148: LD_ADDR_VAR 0 9
20152: PUSH
20153: LD_INT 10
20155: PUSH
20156: LD_INT 0
20158: PUSH
20159: LD_INT 0
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: LIST
20166: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20167: LD_VAR 0 6
20171: PPUSH
20172: CALL_OW 257
20176: PUSH
20177: LD_INT 11
20179: EQUAL
20180: IFFALSE 20201
// points := [ 30 , 10 , 5 ] ;
20182: LD_ADDR_VAR 0 9
20186: PUSH
20187: LD_INT 30
20189: PUSH
20190: LD_INT 10
20192: PUSH
20193: LD_INT 5
20195: PUSH
20196: EMPTY
20197: LIST
20198: LIST
20199: LIST
20200: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20201: LD_VAR 0 1
20205: PPUSH
20206: LD_INT 5
20208: PPUSH
20209: CALL_OW 321
20213: PUSH
20214: LD_INT 2
20216: EQUAL
20217: IFFALSE 20234
// bpoints := bpoints * 1.8 ;
20219: LD_ADDR_VAR 0 10
20223: PUSH
20224: LD_VAR 0 10
20228: PUSH
20229: LD_REAL  1.80000000000000E+0000
20232: MUL
20233: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20234: LD_VAR 0 6
20238: PPUSH
20239: CALL_OW 257
20243: PUSH
20244: LD_INT 1
20246: PUSH
20247: LD_INT 2
20249: PUSH
20250: LD_INT 3
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: LIST
20260: LIST
20261: IN
20262: PUSH
20263: LD_VAR 0 1
20267: PPUSH
20268: LD_INT 51
20270: PPUSH
20271: CALL_OW 321
20275: PUSH
20276: LD_INT 2
20278: EQUAL
20279: AND
20280: IFFALSE 20297
// bpoints := bpoints * 1.2 ;
20282: LD_ADDR_VAR 0 10
20286: PUSH
20287: LD_VAR 0 10
20291: PUSH
20292: LD_REAL  1.20000000000000E+0000
20295: MUL
20296: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20297: LD_VAR 0 6
20301: PPUSH
20302: CALL_OW 257
20306: PUSH
20307: LD_INT 5
20309: PUSH
20310: LD_INT 7
20312: PUSH
20313: LD_INT 9
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: LIST
20320: IN
20321: PUSH
20322: LD_VAR 0 1
20326: PPUSH
20327: LD_INT 52
20329: PPUSH
20330: CALL_OW 321
20334: PUSH
20335: LD_INT 2
20337: EQUAL
20338: AND
20339: IFFALSE 20356
// bpoints := bpoints * 1.5 ;
20341: LD_ADDR_VAR 0 10
20345: PUSH
20346: LD_VAR 0 10
20350: PUSH
20351: LD_REAL  1.50000000000000E+0000
20354: MUL
20355: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20356: LD_VAR 0 1
20360: PPUSH
20361: LD_INT 66
20363: PPUSH
20364: CALL_OW 321
20368: PUSH
20369: LD_INT 2
20371: EQUAL
20372: IFFALSE 20389
// bpoints := bpoints * 1.1 ;
20374: LD_ADDR_VAR 0 10
20378: PUSH
20379: LD_VAR 0 10
20383: PUSH
20384: LD_REAL  1.10000000000000E+0000
20387: MUL
20388: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20389: LD_ADDR_VAR 0 10
20393: PUSH
20394: LD_VAR 0 10
20398: PUSH
20399: LD_VAR 0 6
20403: PPUSH
20404: LD_INT 1
20406: PPUSH
20407: CALL_OW 259
20411: PUSH
20412: LD_REAL  1.15000000000000E+0000
20415: MUL
20416: MUL
20417: ST_TO_ADDR
// end ; unit_vehicle :
20418: GO 21248
20420: LD_INT 2
20422: DOUBLE
20423: EQUAL
20424: IFTRUE 20428
20426: GO 21236
20428: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20429: LD_VAR 0 6
20433: PPUSH
20434: CALL_OW 264
20438: PUSH
20439: LD_INT 2
20441: PUSH
20442: LD_INT 42
20444: PUSH
20445: LD_INT 24
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: IN
20453: IFFALSE 20474
// points := [ 25 , 5 , 3 ] ;
20455: LD_ADDR_VAR 0 9
20459: PUSH
20460: LD_INT 25
20462: PUSH
20463: LD_INT 5
20465: PUSH
20466: LD_INT 3
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20474: LD_VAR 0 6
20478: PPUSH
20479: CALL_OW 264
20483: PUSH
20484: LD_INT 4
20486: PUSH
20487: LD_INT 43
20489: PUSH
20490: LD_INT 25
20492: PUSH
20493: EMPTY
20494: LIST
20495: LIST
20496: LIST
20497: IN
20498: IFFALSE 20519
// points := [ 40 , 15 , 5 ] ;
20500: LD_ADDR_VAR 0 9
20504: PUSH
20505: LD_INT 40
20507: PUSH
20508: LD_INT 15
20510: PUSH
20511: LD_INT 5
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: LIST
20518: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20519: LD_VAR 0 6
20523: PPUSH
20524: CALL_OW 264
20528: PUSH
20529: LD_INT 3
20531: PUSH
20532: LD_INT 23
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: IN
20539: IFFALSE 20560
// points := [ 7 , 25 , 8 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 7
20548: PUSH
20549: LD_INT 25
20551: PUSH
20552: LD_INT 8
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: LIST
20559: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20560: LD_VAR 0 6
20564: PPUSH
20565: CALL_OW 264
20569: PUSH
20570: LD_INT 5
20572: PUSH
20573: LD_INT 27
20575: PUSH
20576: LD_INT 44
20578: PUSH
20579: EMPTY
20580: LIST
20581: LIST
20582: LIST
20583: IN
20584: IFFALSE 20605
// points := [ 14 , 50 , 16 ] ;
20586: LD_ADDR_VAR 0 9
20590: PUSH
20591: LD_INT 14
20593: PUSH
20594: LD_INT 50
20596: PUSH
20597: LD_INT 16
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: LIST
20604: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20605: LD_VAR 0 6
20609: PPUSH
20610: CALL_OW 264
20614: PUSH
20615: LD_INT 6
20617: PUSH
20618: LD_INT 46
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: IN
20625: IFFALSE 20646
// points := [ 32 , 120 , 70 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 32
20634: PUSH
20635: LD_INT 120
20637: PUSH
20638: LD_INT 70
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 264
20655: PUSH
20656: LD_INT 7
20658: PUSH
20659: LD_INT 28
20661: PUSH
20662: LD_INT 45
20664: PUSH
20665: LD_EXP 53
20669: PUSH
20670: EMPTY
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: IN
20676: IFFALSE 20697
// points := [ 35 , 20 , 45 ] ;
20678: LD_ADDR_VAR 0 9
20682: PUSH
20683: LD_INT 35
20685: PUSH
20686: LD_INT 20
20688: PUSH
20689: LD_INT 45
20691: PUSH
20692: EMPTY
20693: LIST
20694: LIST
20695: LIST
20696: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20697: LD_VAR 0 6
20701: PPUSH
20702: CALL_OW 264
20706: PUSH
20707: LD_INT 47
20709: PUSH
20710: EMPTY
20711: LIST
20712: IN
20713: IFFALSE 20734
// points := [ 67 , 45 , 75 ] ;
20715: LD_ADDR_VAR 0 9
20719: PUSH
20720: LD_INT 67
20722: PUSH
20723: LD_INT 45
20725: PUSH
20726: LD_INT 75
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20734: LD_VAR 0 6
20738: PPUSH
20739: CALL_OW 264
20743: PUSH
20744: LD_INT 26
20746: PUSH
20747: EMPTY
20748: LIST
20749: IN
20750: IFFALSE 20771
// points := [ 120 , 30 , 80 ] ;
20752: LD_ADDR_VAR 0 9
20756: PUSH
20757: LD_INT 120
20759: PUSH
20760: LD_INT 30
20762: PUSH
20763: LD_INT 80
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: LIST
20770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20771: LD_VAR 0 6
20775: PPUSH
20776: CALL_OW 264
20780: PUSH
20781: LD_INT 22
20783: PUSH
20784: EMPTY
20785: LIST
20786: IN
20787: IFFALSE 20808
// points := [ 40 , 1 , 1 ] ;
20789: LD_ADDR_VAR 0 9
20793: PUSH
20794: LD_INT 40
20796: PUSH
20797: LD_INT 1
20799: PUSH
20800: LD_INT 1
20802: PUSH
20803: EMPTY
20804: LIST
20805: LIST
20806: LIST
20807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20808: LD_VAR 0 6
20812: PPUSH
20813: CALL_OW 264
20817: PUSH
20818: LD_INT 29
20820: PUSH
20821: EMPTY
20822: LIST
20823: IN
20824: IFFALSE 20845
// points := [ 70 , 200 , 400 ] ;
20826: LD_ADDR_VAR 0 9
20830: PUSH
20831: LD_INT 70
20833: PUSH
20834: LD_INT 200
20836: PUSH
20837: LD_INT 400
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: LIST
20844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20845: LD_VAR 0 6
20849: PPUSH
20850: CALL_OW 264
20854: PUSH
20855: LD_INT 14
20857: PUSH
20858: LD_INT 53
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: IN
20865: IFFALSE 20886
// points := [ 40 , 10 , 20 ] ;
20867: LD_ADDR_VAR 0 9
20871: PUSH
20872: LD_INT 40
20874: PUSH
20875: LD_INT 10
20877: PUSH
20878: LD_INT 20
20880: PUSH
20881: EMPTY
20882: LIST
20883: LIST
20884: LIST
20885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20886: LD_VAR 0 6
20890: PPUSH
20891: CALL_OW 264
20895: PUSH
20896: LD_INT 9
20898: PUSH
20899: EMPTY
20900: LIST
20901: IN
20902: IFFALSE 20923
// points := [ 5 , 70 , 20 ] ;
20904: LD_ADDR_VAR 0 9
20908: PUSH
20909: LD_INT 5
20911: PUSH
20912: LD_INT 70
20914: PUSH
20915: LD_INT 20
20917: PUSH
20918: EMPTY
20919: LIST
20920: LIST
20921: LIST
20922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20923: LD_VAR 0 6
20927: PPUSH
20928: CALL_OW 264
20932: PUSH
20933: LD_INT 10
20935: PUSH
20936: EMPTY
20937: LIST
20938: IN
20939: IFFALSE 20960
// points := [ 35 , 110 , 70 ] ;
20941: LD_ADDR_VAR 0 9
20945: PUSH
20946: LD_INT 35
20948: PUSH
20949: LD_INT 110
20951: PUSH
20952: LD_INT 70
20954: PUSH
20955: EMPTY
20956: LIST
20957: LIST
20958: LIST
20959: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20960: LD_VAR 0 6
20964: PPUSH
20965: CALL_OW 265
20969: PUSH
20970: LD_INT 25
20972: EQUAL
20973: IFFALSE 20994
// points := [ 80 , 65 , 100 ] ;
20975: LD_ADDR_VAR 0 9
20979: PUSH
20980: LD_INT 80
20982: PUSH
20983: LD_INT 65
20985: PUSH
20986: LD_INT 100
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: LIST
20993: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20994: LD_VAR 0 6
20998: PPUSH
20999: CALL_OW 263
21003: PUSH
21004: LD_INT 1
21006: EQUAL
21007: IFFALSE 21042
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21009: LD_ADDR_VAR 0 10
21013: PUSH
21014: LD_VAR 0 10
21018: PUSH
21019: LD_VAR 0 6
21023: PPUSH
21024: CALL_OW 311
21028: PPUSH
21029: LD_INT 3
21031: PPUSH
21032: CALL_OW 259
21036: PUSH
21037: LD_INT 4
21039: MUL
21040: MUL
21041: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21042: LD_VAR 0 6
21046: PPUSH
21047: CALL_OW 263
21051: PUSH
21052: LD_INT 2
21054: EQUAL
21055: IFFALSE 21106
// begin j := IsControledBy ( i ) ;
21057: LD_ADDR_VAR 0 7
21061: PUSH
21062: LD_VAR 0 6
21066: PPUSH
21067: CALL_OW 312
21071: ST_TO_ADDR
// if j then
21072: LD_VAR 0 7
21076: IFFALSE 21106
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21078: LD_ADDR_VAR 0 10
21082: PUSH
21083: LD_VAR 0 10
21087: PUSH
21088: LD_VAR 0 7
21092: PPUSH
21093: LD_INT 3
21095: PPUSH
21096: CALL_OW 259
21100: PUSH
21101: LD_INT 3
21103: MUL
21104: MUL
21105: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21106: LD_VAR 0 6
21110: PPUSH
21111: CALL_OW 264
21115: PUSH
21116: LD_INT 5
21118: PUSH
21119: LD_INT 6
21121: PUSH
21122: LD_INT 46
21124: PUSH
21125: LD_INT 44
21127: PUSH
21128: LD_INT 47
21130: PUSH
21131: LD_INT 45
21133: PUSH
21134: LD_INT 28
21136: PUSH
21137: LD_INT 7
21139: PUSH
21140: LD_INT 27
21142: PUSH
21143: LD_INT 29
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: LIST
21150: LIST
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: PUSH
21159: LD_VAR 0 1
21163: PPUSH
21164: LD_INT 52
21166: PPUSH
21167: CALL_OW 321
21171: PUSH
21172: LD_INT 2
21174: EQUAL
21175: AND
21176: IFFALSE 21193
// bpoints := bpoints * 1.2 ;
21178: LD_ADDR_VAR 0 10
21182: PUSH
21183: LD_VAR 0 10
21187: PUSH
21188: LD_REAL  1.20000000000000E+0000
21191: MUL
21192: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21193: LD_VAR 0 6
21197: PPUSH
21198: CALL_OW 264
21202: PUSH
21203: LD_INT 6
21205: PUSH
21206: LD_INT 46
21208: PUSH
21209: LD_INT 47
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: LIST
21216: IN
21217: IFFALSE 21234
// bpoints := bpoints * 1.2 ;
21219: LD_ADDR_VAR 0 10
21223: PUSH
21224: LD_VAR 0 10
21228: PUSH
21229: LD_REAL  1.20000000000000E+0000
21232: MUL
21233: ST_TO_ADDR
// end ; unit_building :
21234: GO 21248
21236: LD_INT 3
21238: DOUBLE
21239: EQUAL
21240: IFTRUE 21244
21242: GO 21247
21244: POP
// ; end ;
21245: GO 21248
21247: POP
// for j = 1 to 3 do
21248: LD_ADDR_VAR 0 7
21252: PUSH
21253: DOUBLE
21254: LD_INT 1
21256: DEC
21257: ST_TO_ADDR
21258: LD_INT 3
21260: PUSH
21261: FOR_TO
21262: IFFALSE 21315
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21264: LD_ADDR_VAR 0 5
21268: PUSH
21269: LD_VAR 0 5
21273: PPUSH
21274: LD_VAR 0 7
21278: PPUSH
21279: LD_VAR 0 5
21283: PUSH
21284: LD_VAR 0 7
21288: ARRAY
21289: PUSH
21290: LD_VAR 0 9
21294: PUSH
21295: LD_VAR 0 7
21299: ARRAY
21300: PUSH
21301: LD_VAR 0 10
21305: MUL
21306: PLUS
21307: PPUSH
21308: CALL_OW 1
21312: ST_TO_ADDR
21313: GO 21261
21315: POP
21316: POP
// end ;
21317: GO 19794
21319: POP
21320: POP
// result := Replace ( result , 4 , tmp ) ;
21321: LD_ADDR_VAR 0 5
21325: PUSH
21326: LD_VAR 0 5
21330: PPUSH
21331: LD_INT 4
21333: PPUSH
21334: LD_VAR 0 8
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// end ;
21344: LD_VAR 0 5
21348: RET
// export function DangerAtRange ( unit , range ) ; begin
21349: LD_INT 0
21351: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21352: LD_ADDR_VAR 0 3
21356: PUSH
21357: LD_VAR 0 1
21361: PPUSH
21362: CALL_OW 255
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: CALL_OW 250
21376: PPUSH
21377: LD_VAR 0 1
21381: PPUSH
21382: CALL_OW 251
21386: PPUSH
21387: LD_VAR 0 2
21391: PPUSH
21392: CALL 19646 0 4
21396: ST_TO_ADDR
// end ;
21397: LD_VAR 0 3
21401: RET
// export function DangerInArea ( side , area ) ; begin
21402: LD_INT 0
21404: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21405: LD_ADDR_VAR 0 3
21409: PUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: LD_INT 81
21417: PUSH
21418: LD_VAR 0 1
21422: PUSH
21423: EMPTY
21424: LIST
21425: LIST
21426: PPUSH
21427: CALL_OW 70
21431: ST_TO_ADDR
// end ;
21432: LD_VAR 0 3
21436: RET
// export function IsExtension ( b ) ; begin
21437: LD_INT 0
21439: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21440: LD_ADDR_VAR 0 2
21444: PUSH
21445: LD_VAR 0 1
21449: PUSH
21450: LD_INT 23
21452: PUSH
21453: LD_INT 20
21455: PUSH
21456: LD_INT 22
21458: PUSH
21459: LD_INT 17
21461: PUSH
21462: LD_INT 24
21464: PUSH
21465: LD_INT 21
21467: PUSH
21468: LD_INT 19
21470: PUSH
21471: LD_INT 16
21473: PUSH
21474: LD_INT 25
21476: PUSH
21477: LD_INT 18
21479: PUSH
21480: EMPTY
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: LIST
21487: LIST
21488: LIST
21489: LIST
21490: LIST
21491: IN
21492: ST_TO_ADDR
// end ;
21493: LD_VAR 0 2
21497: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21498: LD_INT 0
21500: PPUSH
21501: PPUSH
21502: PPUSH
// result := [ ] ;
21503: LD_ADDR_VAR 0 4
21507: PUSH
21508: EMPTY
21509: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21510: LD_ADDR_VAR 0 5
21514: PUSH
21515: LD_VAR 0 2
21519: PPUSH
21520: LD_INT 21
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: EMPTY
21527: LIST
21528: LIST
21529: PPUSH
21530: CALL_OW 70
21534: ST_TO_ADDR
// if not tmp then
21535: LD_VAR 0 5
21539: NOT
21540: IFFALSE 21544
// exit ;
21542: GO 21608
// if checkLink then
21544: LD_VAR 0 3
21548: IFFALSE 21598
// begin for i in tmp do
21550: LD_ADDR_VAR 0 6
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: FOR_IN
21561: IFFALSE 21596
// if GetBase ( i ) <> base then
21563: LD_VAR 0 6
21567: PPUSH
21568: CALL_OW 274
21572: PUSH
21573: LD_VAR 0 1
21577: NONEQUAL
21578: IFFALSE 21594
// ComLinkToBase ( base , i ) ;
21580: LD_VAR 0 1
21584: PPUSH
21585: LD_VAR 0 6
21589: PPUSH
21590: CALL_OW 169
21594: GO 21560
21596: POP
21597: POP
// end ; result := tmp ;
21598: LD_ADDR_VAR 0 4
21602: PUSH
21603: LD_VAR 0 5
21607: ST_TO_ADDR
// end ;
21608: LD_VAR 0 4
21612: RET
// export function ComComplete ( units , b ) ; var i ; begin
21613: LD_INT 0
21615: PPUSH
21616: PPUSH
// if not units then
21617: LD_VAR 0 1
21621: NOT
21622: IFFALSE 21626
// exit ;
21624: GO 21716
// for i in units do
21626: LD_ADDR_VAR 0 4
21630: PUSH
21631: LD_VAR 0 1
21635: PUSH
21636: FOR_IN
21637: IFFALSE 21714
// if BuildingStatus ( b ) = bs_build then
21639: LD_VAR 0 2
21643: PPUSH
21644: CALL_OW 461
21648: PUSH
21649: LD_INT 1
21651: EQUAL
21652: IFFALSE 21712
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21654: LD_VAR 0 4
21658: PPUSH
21659: LD_STRING h
21661: PUSH
21662: LD_VAR 0 2
21666: PPUSH
21667: CALL_OW 250
21671: PUSH
21672: LD_VAR 0 2
21676: PPUSH
21677: CALL_OW 251
21681: PUSH
21682: LD_VAR 0 2
21686: PUSH
21687: LD_INT 0
21689: PUSH
21690: LD_INT 0
21692: PUSH
21693: LD_INT 0
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: LIST
21700: LIST
21701: LIST
21702: LIST
21703: LIST
21704: PUSH
21705: EMPTY
21706: LIST
21707: PPUSH
21708: CALL_OW 446
21712: GO 21636
21714: POP
21715: POP
// end ;
21716: LD_VAR 0 3
21720: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21721: LD_INT 0
21723: PPUSH
21724: PPUSH
21725: PPUSH
21726: PPUSH
21727: PPUSH
21728: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21729: LD_VAR 0 1
21733: NOT
21734: PUSH
21735: LD_VAR 0 1
21739: PPUSH
21740: CALL_OW 263
21744: PUSH
21745: LD_INT 2
21747: NONEQUAL
21748: OR
21749: IFFALSE 21753
// exit ;
21751: GO 22069
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21753: LD_ADDR_VAR 0 6
21757: PUSH
21758: LD_INT 22
21760: PUSH
21761: LD_VAR 0 1
21765: PPUSH
21766: CALL_OW 255
21770: PUSH
21771: EMPTY
21772: LIST
21773: LIST
21774: PUSH
21775: LD_INT 2
21777: PUSH
21778: LD_INT 30
21780: PUSH
21781: LD_INT 36
21783: PUSH
21784: EMPTY
21785: LIST
21786: LIST
21787: PUSH
21788: LD_INT 34
21790: PUSH
21791: LD_INT 31
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: PUSH
21798: EMPTY
21799: LIST
21800: LIST
21801: LIST
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: PPUSH
21807: CALL_OW 69
21811: ST_TO_ADDR
// if not tmp then
21812: LD_VAR 0 6
21816: NOT
21817: IFFALSE 21821
// exit ;
21819: GO 22069
// result := [ ] ;
21821: LD_ADDR_VAR 0 2
21825: PUSH
21826: EMPTY
21827: ST_TO_ADDR
// for i in tmp do
21828: LD_ADDR_VAR 0 3
21832: PUSH
21833: LD_VAR 0 6
21837: PUSH
21838: FOR_IN
21839: IFFALSE 21910
// begin t := UnitsInside ( i ) ;
21841: LD_ADDR_VAR 0 4
21845: PUSH
21846: LD_VAR 0 3
21850: PPUSH
21851: CALL_OW 313
21855: ST_TO_ADDR
// if t then
21856: LD_VAR 0 4
21860: IFFALSE 21908
// for j in t do
21862: LD_ADDR_VAR 0 7
21866: PUSH
21867: LD_VAR 0 4
21871: PUSH
21872: FOR_IN
21873: IFFALSE 21906
// result := Replace ( result , result + 1 , j ) ;
21875: LD_ADDR_VAR 0 2
21879: PUSH
21880: LD_VAR 0 2
21884: PPUSH
21885: LD_VAR 0 2
21889: PUSH
21890: LD_INT 1
21892: PLUS
21893: PPUSH
21894: LD_VAR 0 7
21898: PPUSH
21899: CALL_OW 1
21903: ST_TO_ADDR
21904: GO 21872
21906: POP
21907: POP
// end ;
21908: GO 21838
21910: POP
21911: POP
// if not result then
21912: LD_VAR 0 2
21916: NOT
21917: IFFALSE 21921
// exit ;
21919: GO 22069
// mech := result [ 1 ] ;
21921: LD_ADDR_VAR 0 5
21925: PUSH
21926: LD_VAR 0 2
21930: PUSH
21931: LD_INT 1
21933: ARRAY
21934: ST_TO_ADDR
// if result > 1 then
21935: LD_VAR 0 2
21939: PUSH
21940: LD_INT 1
21942: GREATER
21943: IFFALSE 22055
// begin for i = 2 to result do
21945: LD_ADDR_VAR 0 3
21949: PUSH
21950: DOUBLE
21951: LD_INT 2
21953: DEC
21954: ST_TO_ADDR
21955: LD_VAR 0 2
21959: PUSH
21960: FOR_TO
21961: IFFALSE 22053
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21963: LD_ADDR_VAR 0 4
21967: PUSH
21968: LD_VAR 0 2
21972: PUSH
21973: LD_VAR 0 3
21977: ARRAY
21978: PPUSH
21979: LD_INT 3
21981: PPUSH
21982: CALL_OW 259
21986: PUSH
21987: LD_VAR 0 2
21991: PUSH
21992: LD_VAR 0 3
21996: ARRAY
21997: PPUSH
21998: CALL_OW 432
22002: MINUS
22003: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22004: LD_VAR 0 4
22008: PUSH
22009: LD_VAR 0 5
22013: PPUSH
22014: LD_INT 3
22016: PPUSH
22017: CALL_OW 259
22021: PUSH
22022: LD_VAR 0 5
22026: PPUSH
22027: CALL_OW 432
22031: MINUS
22032: GREATEREQUAL
22033: IFFALSE 22051
// mech := result [ i ] ;
22035: LD_ADDR_VAR 0 5
22039: PUSH
22040: LD_VAR 0 2
22044: PUSH
22045: LD_VAR 0 3
22049: ARRAY
22050: ST_TO_ADDR
// end ;
22051: GO 21960
22053: POP
22054: POP
// end ; ComLinkTo ( vehicle , mech ) ;
22055: LD_VAR 0 1
22059: PPUSH
22060: LD_VAR 0 5
22064: PPUSH
22065: CALL_OW 135
// end ;
22069: LD_VAR 0 2
22073: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22074: LD_INT 0
22076: PPUSH
22077: PPUSH
22078: PPUSH
22079: PPUSH
22080: PPUSH
22081: PPUSH
22082: PPUSH
22083: PPUSH
22084: PPUSH
22085: PPUSH
22086: PPUSH
22087: PPUSH
22088: PPUSH
// result := [ ] ;
22089: LD_ADDR_VAR 0 7
22093: PUSH
22094: EMPTY
22095: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22096: LD_VAR 0 1
22100: PPUSH
22101: CALL_OW 266
22105: PUSH
22106: LD_INT 0
22108: PUSH
22109: LD_INT 1
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: IN
22116: NOT
22117: IFFALSE 22121
// exit ;
22119: GO 23755
// if name then
22121: LD_VAR 0 3
22125: IFFALSE 22141
// SetBName ( base_dep , name ) ;
22127: LD_VAR 0 1
22131: PPUSH
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 500
// base := GetBase ( base_dep ) ;
22141: LD_ADDR_VAR 0 15
22145: PUSH
22146: LD_VAR 0 1
22150: PPUSH
22151: CALL_OW 274
22155: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22156: LD_ADDR_VAR 0 16
22160: PUSH
22161: LD_VAR 0 1
22165: PPUSH
22166: CALL_OW 255
22170: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22171: LD_ADDR_VAR 0 17
22175: PUSH
22176: LD_VAR 0 1
22180: PPUSH
22181: CALL_OW 248
22185: ST_TO_ADDR
// if sources then
22186: LD_VAR 0 5
22190: IFFALSE 22237
// for i = 1 to 3 do
22192: LD_ADDR_VAR 0 8
22196: PUSH
22197: DOUBLE
22198: LD_INT 1
22200: DEC
22201: ST_TO_ADDR
22202: LD_INT 3
22204: PUSH
22205: FOR_TO
22206: IFFALSE 22235
// AddResourceType ( base , i , sources [ i ] ) ;
22208: LD_VAR 0 15
22212: PPUSH
22213: LD_VAR 0 8
22217: PPUSH
22218: LD_VAR 0 5
22222: PUSH
22223: LD_VAR 0 8
22227: ARRAY
22228: PPUSH
22229: CALL_OW 276
22233: GO 22205
22235: POP
22236: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22237: LD_ADDR_VAR 0 18
22241: PUSH
22242: LD_VAR 0 15
22246: PPUSH
22247: LD_VAR 0 2
22251: PPUSH
22252: LD_INT 1
22254: PPUSH
22255: CALL 21498 0 3
22259: ST_TO_ADDR
// InitHc ;
22260: CALL_OW 19
// InitUc ;
22264: CALL_OW 18
// uc_side := side ;
22268: LD_ADDR_OWVAR 20
22272: PUSH
22273: LD_VAR 0 16
22277: ST_TO_ADDR
// uc_nation := nation ;
22278: LD_ADDR_OWVAR 21
22282: PUSH
22283: LD_VAR 0 17
22287: ST_TO_ADDR
// if buildings then
22288: LD_VAR 0 18
22292: IFFALSE 23614
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22294: LD_ADDR_VAR 0 19
22298: PUSH
22299: LD_VAR 0 18
22303: PPUSH
22304: LD_INT 2
22306: PUSH
22307: LD_INT 30
22309: PUSH
22310: LD_INT 29
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 30
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: EMPTY
22328: LIST
22329: LIST
22330: LIST
22331: PPUSH
22332: CALL_OW 72
22336: ST_TO_ADDR
// if tmp then
22337: LD_VAR 0 19
22341: IFFALSE 22389
// for i in tmp do
22343: LD_ADDR_VAR 0 8
22347: PUSH
22348: LD_VAR 0 19
22352: PUSH
22353: FOR_IN
22354: IFFALSE 22387
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22356: LD_VAR 0 8
22360: PPUSH
22361: CALL_OW 250
22365: PPUSH
22366: LD_VAR 0 8
22370: PPUSH
22371: CALL_OW 251
22375: PPUSH
22376: LD_VAR 0 16
22380: PPUSH
22381: CALL_OW 441
22385: GO 22353
22387: POP
22388: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22389: LD_VAR 0 18
22393: PPUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 30
22399: PUSH
22400: LD_INT 32
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 30
22409: PUSH
22410: LD_INT 33
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: LIST
22421: PPUSH
22422: CALL_OW 72
22426: IFFALSE 22514
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22428: LD_ADDR_VAR 0 8
22432: PUSH
22433: LD_VAR 0 18
22437: PPUSH
22438: LD_INT 2
22440: PUSH
22441: LD_INT 30
22443: PUSH
22444: LD_INT 32
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: LD_INT 30
22453: PUSH
22454: LD_INT 33
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: EMPTY
22462: LIST
22463: LIST
22464: LIST
22465: PPUSH
22466: CALL_OW 72
22470: PUSH
22471: FOR_IN
22472: IFFALSE 22512
// begin if not GetBWeapon ( i ) then
22474: LD_VAR 0 8
22478: PPUSH
22479: CALL_OW 269
22483: NOT
22484: IFFALSE 22510
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22486: LD_VAR 0 8
22490: PPUSH
22491: LD_VAR 0 8
22495: PPUSH
22496: LD_VAR 0 2
22500: PPUSH
22501: CALL 23760 0 2
22505: PPUSH
22506: CALL_OW 431
// end ;
22510: GO 22471
22512: POP
22513: POP
// end ; for i = 1 to personel do
22514: LD_ADDR_VAR 0 8
22518: PUSH
22519: DOUBLE
22520: LD_INT 1
22522: DEC
22523: ST_TO_ADDR
22524: LD_VAR 0 6
22528: PUSH
22529: FOR_TO
22530: IFFALSE 23594
// begin if i > 4 then
22532: LD_VAR 0 8
22536: PUSH
22537: LD_INT 4
22539: GREATER
22540: IFFALSE 22544
// break ;
22542: GO 23594
// case i of 1 :
22544: LD_VAR 0 8
22548: PUSH
22549: LD_INT 1
22551: DOUBLE
22552: EQUAL
22553: IFTRUE 22557
22555: GO 22637
22557: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22558: LD_ADDR_VAR 0 12
22562: PUSH
22563: LD_VAR 0 18
22567: PPUSH
22568: LD_INT 22
22570: PUSH
22571: LD_VAR 0 16
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: LD_INT 58
22582: PUSH
22583: EMPTY
22584: LIST
22585: PUSH
22586: LD_INT 2
22588: PUSH
22589: LD_INT 30
22591: PUSH
22592: LD_INT 32
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 30
22601: PUSH
22602: LD_INT 4
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: LD_INT 30
22611: PUSH
22612: LD_INT 5
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: PUSH
22625: EMPTY
22626: LIST
22627: LIST
22628: LIST
22629: PPUSH
22630: CALL_OW 72
22634: ST_TO_ADDR
22635: GO 22859
22637: LD_INT 2
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22707
22645: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22646: LD_ADDR_VAR 0 12
22650: PUSH
22651: LD_VAR 0 18
22655: PPUSH
22656: LD_INT 22
22658: PUSH
22659: LD_VAR 0 16
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 2
22670: PUSH
22671: LD_INT 30
22673: PUSH
22674: LD_INT 0
22676: PUSH
22677: EMPTY
22678: LIST
22679: LIST
22680: PUSH
22681: LD_INT 30
22683: PUSH
22684: LD_INT 1
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: EMPTY
22692: LIST
22693: LIST
22694: LIST
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: PPUSH
22700: CALL_OW 72
22704: ST_TO_ADDR
22705: GO 22859
22707: LD_INT 3
22709: DOUBLE
22710: EQUAL
22711: IFTRUE 22715
22713: GO 22777
22715: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22716: LD_ADDR_VAR 0 12
22720: PUSH
22721: LD_VAR 0 18
22725: PPUSH
22726: LD_INT 22
22728: PUSH
22729: LD_VAR 0 16
22733: PUSH
22734: EMPTY
22735: LIST
22736: LIST
22737: PUSH
22738: LD_INT 2
22740: PUSH
22741: LD_INT 30
22743: PUSH
22744: LD_INT 2
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 30
22753: PUSH
22754: LD_INT 3
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: LIST
22765: PUSH
22766: EMPTY
22767: LIST
22768: LIST
22769: PPUSH
22770: CALL_OW 72
22774: ST_TO_ADDR
22775: GO 22859
22777: LD_INT 4
22779: DOUBLE
22780: EQUAL
22781: IFTRUE 22785
22783: GO 22858
22785: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22786: LD_ADDR_VAR 0 12
22790: PUSH
22791: LD_VAR 0 18
22795: PPUSH
22796: LD_INT 22
22798: PUSH
22799: LD_VAR 0 16
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 2
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 6
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: LD_INT 30
22823: PUSH
22824: LD_INT 7
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: PUSH
22831: LD_INT 30
22833: PUSH
22834: LD_INT 8
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: EMPTY
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PPUSH
22851: CALL_OW 72
22855: ST_TO_ADDR
22856: GO 22859
22858: POP
// if i = 1 then
22859: LD_VAR 0 8
22863: PUSH
22864: LD_INT 1
22866: EQUAL
22867: IFFALSE 22978
// begin tmp := [ ] ;
22869: LD_ADDR_VAR 0 19
22873: PUSH
22874: EMPTY
22875: ST_TO_ADDR
// for j in f do
22876: LD_ADDR_VAR 0 9
22880: PUSH
22881: LD_VAR 0 12
22885: PUSH
22886: FOR_IN
22887: IFFALSE 22960
// if GetBType ( j ) = b_bunker then
22889: LD_VAR 0 9
22893: PPUSH
22894: CALL_OW 266
22898: PUSH
22899: LD_INT 32
22901: EQUAL
22902: IFFALSE 22929
// tmp := Insert ( tmp , 1 , j ) else
22904: LD_ADDR_VAR 0 19
22908: PUSH
22909: LD_VAR 0 19
22913: PPUSH
22914: LD_INT 1
22916: PPUSH
22917: LD_VAR 0 9
22921: PPUSH
22922: CALL_OW 2
22926: ST_TO_ADDR
22927: GO 22958
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22929: LD_ADDR_VAR 0 19
22933: PUSH
22934: LD_VAR 0 19
22938: PPUSH
22939: LD_VAR 0 19
22943: PUSH
22944: LD_INT 1
22946: PLUS
22947: PPUSH
22948: LD_VAR 0 9
22952: PPUSH
22953: CALL_OW 2
22957: ST_TO_ADDR
22958: GO 22886
22960: POP
22961: POP
// if tmp then
22962: LD_VAR 0 19
22966: IFFALSE 22978
// f := tmp ;
22968: LD_ADDR_VAR 0 12
22972: PUSH
22973: LD_VAR 0 19
22977: ST_TO_ADDR
// end ; x := personel [ i ] ;
22978: LD_ADDR_VAR 0 13
22982: PUSH
22983: LD_VAR 0 6
22987: PUSH
22988: LD_VAR 0 8
22992: ARRAY
22993: ST_TO_ADDR
// if x = - 1 then
22994: LD_VAR 0 13
22998: PUSH
22999: LD_INT 1
23001: NEG
23002: EQUAL
23003: IFFALSE 23212
// begin for j in f do
23005: LD_ADDR_VAR 0 9
23009: PUSH
23010: LD_VAR 0 12
23014: PUSH
23015: FOR_IN
23016: IFFALSE 23208
// repeat InitHc ;
23018: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23022: LD_VAR 0 9
23026: PPUSH
23027: CALL_OW 266
23031: PUSH
23032: LD_INT 5
23034: EQUAL
23035: IFFALSE 23105
// begin if UnitsInside ( j ) < 3 then
23037: LD_VAR 0 9
23041: PPUSH
23042: CALL_OW 313
23046: PUSH
23047: LD_INT 3
23049: LESS
23050: IFFALSE 23086
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23052: LD_INT 0
23054: PPUSH
23055: LD_INT 5
23057: PUSH
23058: LD_INT 8
23060: PUSH
23061: LD_INT 9
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: LIST
23068: PUSH
23069: LD_VAR 0 17
23073: ARRAY
23074: PPUSH
23075: LD_VAR 0 4
23079: PPUSH
23080: CALL_OW 380
23084: GO 23103
// PrepareHuman ( false , i , skill ) ;
23086: LD_INT 0
23088: PPUSH
23089: LD_VAR 0 8
23093: PPUSH
23094: LD_VAR 0 4
23098: PPUSH
23099: CALL_OW 380
// end else
23103: GO 23122
// PrepareHuman ( false , i , skill ) ;
23105: LD_INT 0
23107: PPUSH
23108: LD_VAR 0 8
23112: PPUSH
23113: LD_VAR 0 4
23117: PPUSH
23118: CALL_OW 380
// un := CreateHuman ;
23122: LD_ADDR_VAR 0 14
23126: PUSH
23127: CALL_OW 44
23131: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23132: LD_ADDR_VAR 0 7
23136: PUSH
23137: LD_VAR 0 7
23141: PPUSH
23142: LD_INT 1
23144: PPUSH
23145: LD_VAR 0 14
23149: PPUSH
23150: CALL_OW 2
23154: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23155: LD_VAR 0 14
23159: PPUSH
23160: LD_VAR 0 9
23164: PPUSH
23165: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23169: LD_VAR 0 9
23173: PPUSH
23174: CALL_OW 313
23178: PUSH
23179: LD_INT 6
23181: EQUAL
23182: PUSH
23183: LD_VAR 0 9
23187: PPUSH
23188: CALL_OW 266
23192: PUSH
23193: LD_INT 32
23195: PUSH
23196: LD_INT 31
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: IN
23203: OR
23204: IFFALSE 23018
23206: GO 23015
23208: POP
23209: POP
// end else
23210: GO 23592
// for j = 1 to x do
23212: LD_ADDR_VAR 0 9
23216: PUSH
23217: DOUBLE
23218: LD_INT 1
23220: DEC
23221: ST_TO_ADDR
23222: LD_VAR 0 13
23226: PUSH
23227: FOR_TO
23228: IFFALSE 23590
// begin InitHc ;
23230: CALL_OW 19
// if not f then
23234: LD_VAR 0 12
23238: NOT
23239: IFFALSE 23328
// begin PrepareHuman ( false , i , skill ) ;
23241: LD_INT 0
23243: PPUSH
23244: LD_VAR 0 8
23248: PPUSH
23249: LD_VAR 0 4
23253: PPUSH
23254: CALL_OW 380
// un := CreateHuman ;
23258: LD_ADDR_VAR 0 14
23262: PUSH
23263: CALL_OW 44
23267: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23268: LD_ADDR_VAR 0 7
23272: PUSH
23273: LD_VAR 0 7
23277: PPUSH
23278: LD_INT 1
23280: PPUSH
23281: LD_VAR 0 14
23285: PPUSH
23286: CALL_OW 2
23290: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23291: LD_VAR 0 14
23295: PPUSH
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 250
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 251
23315: PPUSH
23316: LD_INT 10
23318: PPUSH
23319: LD_INT 0
23321: PPUSH
23322: CALL_OW 50
// continue ;
23326: GO 23227
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23328: LD_VAR 0 12
23332: PUSH
23333: LD_INT 1
23335: ARRAY
23336: PPUSH
23337: CALL_OW 313
23341: PUSH
23342: LD_VAR 0 12
23346: PUSH
23347: LD_INT 1
23349: ARRAY
23350: PPUSH
23351: CALL_OW 266
23355: PUSH
23356: LD_INT 32
23358: PUSH
23359: LD_INT 31
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: IN
23366: AND
23367: PUSH
23368: LD_VAR 0 12
23372: PUSH
23373: LD_INT 1
23375: ARRAY
23376: PPUSH
23377: CALL_OW 313
23381: PUSH
23382: LD_INT 6
23384: EQUAL
23385: OR
23386: IFFALSE 23406
// f := Delete ( f , 1 ) ;
23388: LD_ADDR_VAR 0 12
23392: PUSH
23393: LD_VAR 0 12
23397: PPUSH
23398: LD_INT 1
23400: PPUSH
23401: CALL_OW 3
23405: ST_TO_ADDR
// if not f then
23406: LD_VAR 0 12
23410: NOT
23411: IFFALSE 23429
// begin x := x + 2 ;
23413: LD_ADDR_VAR 0 13
23417: PUSH
23418: LD_VAR 0 13
23422: PUSH
23423: LD_INT 2
23425: PLUS
23426: ST_TO_ADDR
// continue ;
23427: GO 23227
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23429: LD_VAR 0 12
23433: PUSH
23434: LD_INT 1
23436: ARRAY
23437: PPUSH
23438: CALL_OW 266
23442: PUSH
23443: LD_INT 5
23445: EQUAL
23446: IFFALSE 23520
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23448: LD_VAR 0 12
23452: PUSH
23453: LD_INT 1
23455: ARRAY
23456: PPUSH
23457: CALL_OW 313
23461: PUSH
23462: LD_INT 3
23464: LESS
23465: IFFALSE 23501
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23467: LD_INT 0
23469: PPUSH
23470: LD_INT 5
23472: PUSH
23473: LD_INT 8
23475: PUSH
23476: LD_INT 9
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: LIST
23483: PUSH
23484: LD_VAR 0 17
23488: ARRAY
23489: PPUSH
23490: LD_VAR 0 4
23494: PPUSH
23495: CALL_OW 380
23499: GO 23518
// PrepareHuman ( false , i , skill ) ;
23501: LD_INT 0
23503: PPUSH
23504: LD_VAR 0 8
23508: PPUSH
23509: LD_VAR 0 4
23513: PPUSH
23514: CALL_OW 380
// end else
23518: GO 23537
// PrepareHuman ( false , i , skill ) ;
23520: LD_INT 0
23522: PPUSH
23523: LD_VAR 0 8
23527: PPUSH
23528: LD_VAR 0 4
23532: PPUSH
23533: CALL_OW 380
// un := CreateHuman ;
23537: LD_ADDR_VAR 0 14
23541: PUSH
23542: CALL_OW 44
23546: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23547: LD_ADDR_VAR 0 7
23551: PUSH
23552: LD_VAR 0 7
23556: PPUSH
23557: LD_INT 1
23559: PPUSH
23560: LD_VAR 0 14
23564: PPUSH
23565: CALL_OW 2
23569: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23570: LD_VAR 0 14
23574: PPUSH
23575: LD_VAR 0 12
23579: PUSH
23580: LD_INT 1
23582: ARRAY
23583: PPUSH
23584: CALL_OW 52
// end ;
23588: GO 23227
23590: POP
23591: POP
// end ;
23592: GO 22529
23594: POP
23595: POP
// result := result ^ buildings ;
23596: LD_ADDR_VAR 0 7
23600: PUSH
23601: LD_VAR 0 7
23605: PUSH
23606: LD_VAR 0 18
23610: ADD
23611: ST_TO_ADDR
// end else
23612: GO 23755
// begin for i = 1 to personel do
23614: LD_ADDR_VAR 0 8
23618: PUSH
23619: DOUBLE
23620: LD_INT 1
23622: DEC
23623: ST_TO_ADDR
23624: LD_VAR 0 6
23628: PUSH
23629: FOR_TO
23630: IFFALSE 23753
// begin if i > 4 then
23632: LD_VAR 0 8
23636: PUSH
23637: LD_INT 4
23639: GREATER
23640: IFFALSE 23644
// break ;
23642: GO 23753
// x := personel [ i ] ;
23644: LD_ADDR_VAR 0 13
23648: PUSH
23649: LD_VAR 0 6
23653: PUSH
23654: LD_VAR 0 8
23658: ARRAY
23659: ST_TO_ADDR
// if x = - 1 then
23660: LD_VAR 0 13
23664: PUSH
23665: LD_INT 1
23667: NEG
23668: EQUAL
23669: IFFALSE 23673
// continue ;
23671: GO 23629
// PrepareHuman ( false , i , skill ) ;
23673: LD_INT 0
23675: PPUSH
23676: LD_VAR 0 8
23680: PPUSH
23681: LD_VAR 0 4
23685: PPUSH
23686: CALL_OW 380
// un := CreateHuman ;
23690: LD_ADDR_VAR 0 14
23694: PUSH
23695: CALL_OW 44
23699: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23700: LD_VAR 0 14
23704: PPUSH
23705: LD_VAR 0 1
23709: PPUSH
23710: CALL_OW 250
23714: PPUSH
23715: LD_VAR 0 1
23719: PPUSH
23720: CALL_OW 251
23724: PPUSH
23725: LD_INT 10
23727: PPUSH
23728: LD_INT 0
23730: PPUSH
23731: CALL_OW 50
// result := result ^ un ;
23735: LD_ADDR_VAR 0 7
23739: PUSH
23740: LD_VAR 0 7
23744: PUSH
23745: LD_VAR 0 14
23749: ADD
23750: ST_TO_ADDR
// end ;
23751: GO 23629
23753: POP
23754: POP
// end ; end ;
23755: LD_VAR 0 7
23759: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23760: LD_INT 0
23762: PPUSH
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
23776: PPUSH
23777: PPUSH
// result := false ;
23778: LD_ADDR_VAR 0 3
23782: PUSH
23783: LD_INT 0
23785: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23786: LD_VAR 0 1
23790: NOT
23791: PUSH
23792: LD_VAR 0 1
23796: PPUSH
23797: CALL_OW 266
23801: PUSH
23802: LD_INT 32
23804: PUSH
23805: LD_INT 33
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: IN
23812: NOT
23813: OR
23814: IFFALSE 23818
// exit ;
23816: GO 24927
// nat := GetNation ( tower ) ;
23818: LD_ADDR_VAR 0 12
23822: PUSH
23823: LD_VAR 0 1
23827: PPUSH
23828: CALL_OW 248
23832: ST_TO_ADDR
// side := GetSide ( tower ) ;
23833: LD_ADDR_VAR 0 16
23837: PUSH
23838: LD_VAR 0 1
23842: PPUSH
23843: CALL_OW 255
23847: ST_TO_ADDR
// x := GetX ( tower ) ;
23848: LD_ADDR_VAR 0 10
23852: PUSH
23853: LD_VAR 0 1
23857: PPUSH
23858: CALL_OW 250
23862: ST_TO_ADDR
// y := GetY ( tower ) ;
23863: LD_ADDR_VAR 0 11
23867: PUSH
23868: LD_VAR 0 1
23872: PPUSH
23873: CALL_OW 251
23877: ST_TO_ADDR
// if not x or not y then
23878: LD_VAR 0 10
23882: NOT
23883: PUSH
23884: LD_VAR 0 11
23888: NOT
23889: OR
23890: IFFALSE 23894
// exit ;
23892: GO 24927
// weapon := 0 ;
23894: LD_ADDR_VAR 0 18
23898: PUSH
23899: LD_INT 0
23901: ST_TO_ADDR
// fac_list := [ ] ;
23902: LD_ADDR_VAR 0 17
23906: PUSH
23907: EMPTY
23908: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23909: LD_ADDR_VAR 0 6
23913: PUSH
23914: LD_VAR 0 1
23918: PPUSH
23919: CALL_OW 274
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: LD_INT 0
23931: PPUSH
23932: CALL 21498 0 3
23936: PPUSH
23937: LD_INT 30
23939: PUSH
23940: LD_INT 3
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: PPUSH
23947: CALL_OW 72
23951: ST_TO_ADDR
// if not factories then
23952: LD_VAR 0 6
23956: NOT
23957: IFFALSE 23961
// exit ;
23959: GO 24927
// for i in factories do
23961: LD_ADDR_VAR 0 8
23965: PUSH
23966: LD_VAR 0 6
23970: PUSH
23971: FOR_IN
23972: IFFALSE 23997
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23974: LD_ADDR_VAR 0 17
23978: PUSH
23979: LD_VAR 0 17
23983: PUSH
23984: LD_VAR 0 8
23988: PPUSH
23989: CALL_OW 478
23993: UNION
23994: ST_TO_ADDR
23995: GO 23971
23997: POP
23998: POP
// if not fac_list then
23999: LD_VAR 0 17
24003: NOT
24004: IFFALSE 24008
// exit ;
24006: GO 24927
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24008: LD_ADDR_VAR 0 5
24012: PUSH
24013: LD_INT 4
24015: PUSH
24016: LD_INT 5
24018: PUSH
24019: LD_INT 9
24021: PUSH
24022: LD_INT 10
24024: PUSH
24025: LD_INT 6
24027: PUSH
24028: LD_INT 7
24030: PUSH
24031: LD_INT 11
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: LIST
24042: PUSH
24043: LD_INT 27
24045: PUSH
24046: LD_INT 28
24048: PUSH
24049: LD_INT 26
24051: PUSH
24052: LD_INT 30
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 43
24063: PUSH
24064: LD_INT 44
24066: PUSH
24067: LD_INT 46
24069: PUSH
24070: LD_INT 45
24072: PUSH
24073: LD_INT 47
24075: PUSH
24076: LD_INT 49
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: PUSH
24092: LD_VAR 0 12
24096: ARRAY
24097: ST_TO_ADDR
// list := list isect fac_list ;
24098: LD_ADDR_VAR 0 5
24102: PUSH
24103: LD_VAR 0 5
24107: PUSH
24108: LD_VAR 0 17
24112: ISECT
24113: ST_TO_ADDR
// if not list then
24114: LD_VAR 0 5
24118: NOT
24119: IFFALSE 24123
// exit ;
24121: GO 24927
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24123: LD_VAR 0 12
24127: PUSH
24128: LD_INT 3
24130: EQUAL
24131: PUSH
24132: LD_INT 49
24134: PUSH
24135: LD_VAR 0 5
24139: IN
24140: AND
24141: PUSH
24142: LD_INT 31
24144: PPUSH
24145: LD_VAR 0 16
24149: PPUSH
24150: CALL_OW 321
24154: PUSH
24155: LD_INT 2
24157: EQUAL
24158: AND
24159: IFFALSE 24219
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24161: LD_INT 22
24163: PUSH
24164: LD_VAR 0 16
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PUSH
24173: LD_INT 35
24175: PUSH
24176: LD_INT 49
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: LD_INT 91
24185: PUSH
24186: LD_VAR 0 1
24190: PUSH
24191: LD_INT 10
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: LIST
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: PPUSH
24204: CALL_OW 69
24208: NOT
24209: IFFALSE 24219
// weapon := ru_time_lapser ;
24211: LD_ADDR_VAR 0 18
24215: PUSH
24216: LD_INT 49
24218: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24219: LD_VAR 0 12
24223: PUSH
24224: LD_INT 1
24226: PUSH
24227: LD_INT 2
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: IN
24234: PUSH
24235: LD_INT 11
24237: PUSH
24238: LD_VAR 0 5
24242: IN
24243: PUSH
24244: LD_INT 30
24246: PUSH
24247: LD_VAR 0 5
24251: IN
24252: OR
24253: AND
24254: PUSH
24255: LD_INT 6
24257: PPUSH
24258: LD_VAR 0 16
24262: PPUSH
24263: CALL_OW 321
24267: PUSH
24268: LD_INT 2
24270: EQUAL
24271: AND
24272: IFFALSE 24437
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24274: LD_INT 22
24276: PUSH
24277: LD_VAR 0 16
24281: PUSH
24282: EMPTY
24283: LIST
24284: LIST
24285: PUSH
24286: LD_INT 2
24288: PUSH
24289: LD_INT 35
24291: PUSH
24292: LD_INT 11
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: PUSH
24299: LD_INT 35
24301: PUSH
24302: LD_INT 30
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PUSH
24309: EMPTY
24310: LIST
24311: LIST
24312: LIST
24313: PUSH
24314: LD_INT 91
24316: PUSH
24317: LD_VAR 0 1
24321: PUSH
24322: LD_INT 18
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: LIST
24329: PUSH
24330: EMPTY
24331: LIST
24332: LIST
24333: LIST
24334: PPUSH
24335: CALL_OW 69
24339: NOT
24340: PUSH
24341: LD_INT 22
24343: PUSH
24344: LD_VAR 0 16
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 2
24355: PUSH
24356: LD_INT 30
24358: PUSH
24359: LD_INT 32
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 30
24368: PUSH
24369: LD_INT 33
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 91
24383: PUSH
24384: LD_VAR 0 1
24388: PUSH
24389: LD_INT 12
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: LIST
24396: PUSH
24397: EMPTY
24398: LIST
24399: LIST
24400: LIST
24401: PUSH
24402: EMPTY
24403: LIST
24404: PPUSH
24405: CALL_OW 69
24409: PUSH
24410: LD_INT 2
24412: GREATER
24413: AND
24414: IFFALSE 24437
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24416: LD_ADDR_VAR 0 18
24420: PUSH
24421: LD_INT 11
24423: PUSH
24424: LD_INT 30
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_VAR 0 12
24435: ARRAY
24436: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24437: LD_VAR 0 18
24441: NOT
24442: PUSH
24443: LD_INT 40
24445: PPUSH
24446: LD_VAR 0 16
24450: PPUSH
24451: CALL_OW 321
24455: PUSH
24456: LD_INT 2
24458: EQUAL
24459: AND
24460: PUSH
24461: LD_INT 7
24463: PUSH
24464: LD_VAR 0 5
24468: IN
24469: PUSH
24470: LD_INT 28
24472: PUSH
24473: LD_VAR 0 5
24477: IN
24478: OR
24479: PUSH
24480: LD_INT 45
24482: PUSH
24483: LD_VAR 0 5
24487: IN
24488: OR
24489: AND
24490: IFFALSE 24744
// begin hex := GetHexInfo ( x , y ) ;
24492: LD_ADDR_VAR 0 4
24496: PUSH
24497: LD_VAR 0 10
24501: PPUSH
24502: LD_VAR 0 11
24506: PPUSH
24507: CALL_OW 546
24511: ST_TO_ADDR
// if hex [ 1 ] then
24512: LD_VAR 0 4
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: IFFALSE 24524
// exit ;
24522: GO 24927
// height := hex [ 2 ] ;
24524: LD_ADDR_VAR 0 15
24528: PUSH
24529: LD_VAR 0 4
24533: PUSH
24534: LD_INT 2
24536: ARRAY
24537: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24538: LD_ADDR_VAR 0 14
24542: PUSH
24543: LD_INT 0
24545: PUSH
24546: LD_INT 2
24548: PUSH
24549: LD_INT 3
24551: PUSH
24552: LD_INT 5
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: LIST
24560: ST_TO_ADDR
// for i in tmp do
24561: LD_ADDR_VAR 0 8
24565: PUSH
24566: LD_VAR 0 14
24570: PUSH
24571: FOR_IN
24572: IFFALSE 24742
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24574: LD_ADDR_VAR 0 9
24578: PUSH
24579: LD_VAR 0 10
24583: PPUSH
24584: LD_VAR 0 8
24588: PPUSH
24589: LD_INT 5
24591: PPUSH
24592: CALL_OW 272
24596: PUSH
24597: LD_VAR 0 11
24601: PPUSH
24602: LD_VAR 0 8
24606: PPUSH
24607: LD_INT 5
24609: PPUSH
24610: CALL_OW 273
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24619: LD_VAR 0 9
24623: PUSH
24624: LD_INT 1
24626: ARRAY
24627: PPUSH
24628: LD_VAR 0 9
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 488
24641: IFFALSE 24740
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24643: LD_ADDR_VAR 0 4
24647: PUSH
24648: LD_VAR 0 9
24652: PUSH
24653: LD_INT 1
24655: ARRAY
24656: PPUSH
24657: LD_VAR 0 9
24661: PUSH
24662: LD_INT 2
24664: ARRAY
24665: PPUSH
24666: CALL_OW 546
24670: ST_TO_ADDR
// if hex [ 1 ] then
24671: LD_VAR 0 4
24675: PUSH
24676: LD_INT 1
24678: ARRAY
24679: IFFALSE 24683
// continue ;
24681: GO 24571
// h := hex [ 2 ] ;
24683: LD_ADDR_VAR 0 13
24687: PUSH
24688: LD_VAR 0 4
24692: PUSH
24693: LD_INT 2
24695: ARRAY
24696: ST_TO_ADDR
// if h + 7 < height then
24697: LD_VAR 0 13
24701: PUSH
24702: LD_INT 7
24704: PLUS
24705: PUSH
24706: LD_VAR 0 15
24710: LESS
24711: IFFALSE 24740
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24713: LD_ADDR_VAR 0 18
24717: PUSH
24718: LD_INT 7
24720: PUSH
24721: LD_INT 28
24723: PUSH
24724: LD_INT 45
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: LIST
24731: PUSH
24732: LD_VAR 0 12
24736: ARRAY
24737: ST_TO_ADDR
// break ;
24738: GO 24742
// end ; end ; end ;
24740: GO 24571
24742: POP
24743: POP
// end ; if not weapon then
24744: LD_VAR 0 18
24748: NOT
24749: IFFALSE 24809
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24751: LD_ADDR_VAR 0 5
24755: PUSH
24756: LD_VAR 0 5
24760: PUSH
24761: LD_INT 11
24763: PUSH
24764: LD_INT 30
24766: PUSH
24767: LD_INT 49
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: LIST
24774: DIFF
24775: ST_TO_ADDR
// if not list then
24776: LD_VAR 0 5
24780: NOT
24781: IFFALSE 24785
// exit ;
24783: GO 24927
// weapon := list [ rand ( 1 , list ) ] ;
24785: LD_ADDR_VAR 0 18
24789: PUSH
24790: LD_VAR 0 5
24794: PUSH
24795: LD_INT 1
24797: PPUSH
24798: LD_VAR 0 5
24802: PPUSH
24803: CALL_OW 12
24807: ARRAY
24808: ST_TO_ADDR
// end ; if weapon then
24809: LD_VAR 0 18
24813: IFFALSE 24927
// begin tmp := CostOfWeapon ( weapon ) ;
24815: LD_ADDR_VAR 0 14
24819: PUSH
24820: LD_VAR 0 18
24824: PPUSH
24825: CALL_OW 451
24829: ST_TO_ADDR
// j := GetBase ( tower ) ;
24830: LD_ADDR_VAR 0 9
24834: PUSH
24835: LD_VAR 0 1
24839: PPUSH
24840: CALL_OW 274
24844: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24845: LD_VAR 0 9
24849: PPUSH
24850: LD_INT 1
24852: PPUSH
24853: CALL_OW 275
24857: PUSH
24858: LD_VAR 0 14
24862: PUSH
24863: LD_INT 1
24865: ARRAY
24866: GREATEREQUAL
24867: PUSH
24868: LD_VAR 0 9
24872: PPUSH
24873: LD_INT 2
24875: PPUSH
24876: CALL_OW 275
24880: PUSH
24881: LD_VAR 0 14
24885: PUSH
24886: LD_INT 2
24888: ARRAY
24889: GREATEREQUAL
24890: AND
24891: PUSH
24892: LD_VAR 0 9
24896: PPUSH
24897: LD_INT 3
24899: PPUSH
24900: CALL_OW 275
24904: PUSH
24905: LD_VAR 0 14
24909: PUSH
24910: LD_INT 3
24912: ARRAY
24913: GREATEREQUAL
24914: AND
24915: IFFALSE 24927
// result := weapon ;
24917: LD_ADDR_VAR 0 3
24921: PUSH
24922: LD_VAR 0 18
24926: ST_TO_ADDR
// end ; end ;
24927: LD_VAR 0 3
24931: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24932: LD_INT 0
24934: PPUSH
24935: PPUSH
// result := true ;
24936: LD_ADDR_VAR 0 3
24940: PUSH
24941: LD_INT 1
24943: ST_TO_ADDR
// if array1 = array2 then
24944: LD_VAR 0 1
24948: PUSH
24949: LD_VAR 0 2
24953: EQUAL
24954: IFFALSE 25014
// begin for i = 1 to array1 do
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: DOUBLE
24962: LD_INT 1
24964: DEC
24965: ST_TO_ADDR
24966: LD_VAR 0 1
24970: PUSH
24971: FOR_TO
24972: IFFALSE 25010
// if array1 [ i ] <> array2 [ i ] then
24974: LD_VAR 0 1
24978: PUSH
24979: LD_VAR 0 4
24983: ARRAY
24984: PUSH
24985: LD_VAR 0 2
24989: PUSH
24990: LD_VAR 0 4
24994: ARRAY
24995: NONEQUAL
24996: IFFALSE 25008
// begin result := false ;
24998: LD_ADDR_VAR 0 3
25002: PUSH
25003: LD_INT 0
25005: ST_TO_ADDR
// break ;
25006: GO 25010
// end ;
25008: GO 24971
25010: POP
25011: POP
// end else
25012: GO 25022
// result := false ;
25014: LD_ADDR_VAR 0 3
25018: PUSH
25019: LD_INT 0
25021: ST_TO_ADDR
// end ;
25022: LD_VAR 0 3
25026: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25027: LD_INT 0
25029: PPUSH
25030: PPUSH
// if not array1 or not array2 then
25031: LD_VAR 0 1
25035: NOT
25036: PUSH
25037: LD_VAR 0 2
25041: NOT
25042: OR
25043: IFFALSE 25047
// exit ;
25045: GO 25111
// result := true ;
25047: LD_ADDR_VAR 0 3
25051: PUSH
25052: LD_INT 1
25054: ST_TO_ADDR
// for i = 1 to array1 do
25055: LD_ADDR_VAR 0 4
25059: PUSH
25060: DOUBLE
25061: LD_INT 1
25063: DEC
25064: ST_TO_ADDR
25065: LD_VAR 0 1
25069: PUSH
25070: FOR_TO
25071: IFFALSE 25109
// if array1 [ i ] <> array2 [ i ] then
25073: LD_VAR 0 1
25077: PUSH
25078: LD_VAR 0 4
25082: ARRAY
25083: PUSH
25084: LD_VAR 0 2
25088: PUSH
25089: LD_VAR 0 4
25093: ARRAY
25094: NONEQUAL
25095: IFFALSE 25107
// begin result := false ;
25097: LD_ADDR_VAR 0 3
25101: PUSH
25102: LD_INT 0
25104: ST_TO_ADDR
// break ;
25105: GO 25109
// end ;
25107: GO 25070
25109: POP
25110: POP
// end ;
25111: LD_VAR 0 3
25115: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25116: LD_INT 0
25118: PPUSH
25119: PPUSH
25120: PPUSH
// pom := GetBase ( fac ) ;
25121: LD_ADDR_VAR 0 5
25125: PUSH
25126: LD_VAR 0 1
25130: PPUSH
25131: CALL_OW 274
25135: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25136: LD_ADDR_VAR 0 4
25140: PUSH
25141: LD_VAR 0 2
25145: PUSH
25146: LD_INT 1
25148: ARRAY
25149: PPUSH
25150: LD_VAR 0 2
25154: PUSH
25155: LD_INT 2
25157: ARRAY
25158: PPUSH
25159: LD_VAR 0 2
25163: PUSH
25164: LD_INT 3
25166: ARRAY
25167: PPUSH
25168: LD_VAR 0 2
25172: PUSH
25173: LD_INT 4
25175: ARRAY
25176: PPUSH
25177: CALL_OW 449
25181: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25182: LD_ADDR_VAR 0 3
25186: PUSH
25187: LD_VAR 0 5
25191: PPUSH
25192: LD_INT 1
25194: PPUSH
25195: CALL_OW 275
25199: PUSH
25200: LD_VAR 0 4
25204: PUSH
25205: LD_INT 1
25207: ARRAY
25208: GREATEREQUAL
25209: PUSH
25210: LD_VAR 0 5
25214: PPUSH
25215: LD_INT 2
25217: PPUSH
25218: CALL_OW 275
25222: PUSH
25223: LD_VAR 0 4
25227: PUSH
25228: LD_INT 2
25230: ARRAY
25231: GREATEREQUAL
25232: AND
25233: PUSH
25234: LD_VAR 0 5
25238: PPUSH
25239: LD_INT 3
25241: PPUSH
25242: CALL_OW 275
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_INT 3
25254: ARRAY
25255: GREATEREQUAL
25256: AND
25257: ST_TO_ADDR
// end ;
25258: LD_VAR 0 3
25262: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25263: LD_INT 0
25265: PPUSH
25266: PPUSH
25267: PPUSH
25268: PPUSH
// pom := GetBase ( building ) ;
25269: LD_ADDR_VAR 0 3
25273: PUSH
25274: LD_VAR 0 1
25278: PPUSH
25279: CALL_OW 274
25283: ST_TO_ADDR
// if not pom then
25284: LD_VAR 0 3
25288: NOT
25289: IFFALSE 25293
// exit ;
25291: GO 25463
// btype := GetBType ( building ) ;
25293: LD_ADDR_VAR 0 5
25297: PUSH
25298: LD_VAR 0 1
25302: PPUSH
25303: CALL_OW 266
25307: ST_TO_ADDR
// if btype = b_armoury then
25308: LD_VAR 0 5
25312: PUSH
25313: LD_INT 4
25315: EQUAL
25316: IFFALSE 25326
// btype := b_barracks ;
25318: LD_ADDR_VAR 0 5
25322: PUSH
25323: LD_INT 5
25325: ST_TO_ADDR
// if btype = b_depot then
25326: LD_VAR 0 5
25330: PUSH
25331: LD_INT 0
25333: EQUAL
25334: IFFALSE 25344
// btype := b_warehouse ;
25336: LD_ADDR_VAR 0 5
25340: PUSH
25341: LD_INT 1
25343: ST_TO_ADDR
// if btype = b_workshop then
25344: LD_VAR 0 5
25348: PUSH
25349: LD_INT 2
25351: EQUAL
25352: IFFALSE 25362
// btype := b_factory ;
25354: LD_ADDR_VAR 0 5
25358: PUSH
25359: LD_INT 3
25361: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25362: LD_ADDR_VAR 0 4
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_VAR 0 1
25376: PPUSH
25377: CALL_OW 248
25381: PPUSH
25382: CALL_OW 450
25386: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25387: LD_ADDR_VAR 0 2
25391: PUSH
25392: LD_VAR 0 3
25396: PPUSH
25397: LD_INT 1
25399: PPUSH
25400: CALL_OW 275
25404: PUSH
25405: LD_VAR 0 4
25409: PUSH
25410: LD_INT 1
25412: ARRAY
25413: GREATEREQUAL
25414: PUSH
25415: LD_VAR 0 3
25419: PPUSH
25420: LD_INT 2
25422: PPUSH
25423: CALL_OW 275
25427: PUSH
25428: LD_VAR 0 4
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: GREATEREQUAL
25437: AND
25438: PUSH
25439: LD_VAR 0 3
25443: PPUSH
25444: LD_INT 3
25446: PPUSH
25447: CALL_OW 275
25451: PUSH
25452: LD_VAR 0 4
25456: PUSH
25457: LD_INT 3
25459: ARRAY
25460: GREATEREQUAL
25461: AND
25462: ST_TO_ADDR
// end ;
25463: LD_VAR 0 2
25467: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25468: LD_INT 0
25470: PPUSH
25471: PPUSH
25472: PPUSH
// pom := GetBase ( building ) ;
25473: LD_ADDR_VAR 0 4
25477: PUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: CALL_OW 274
25487: ST_TO_ADDR
// if not pom then
25488: LD_VAR 0 4
25492: NOT
25493: IFFALSE 25497
// exit ;
25495: GO 25598
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25497: LD_ADDR_VAR 0 5
25501: PUSH
25502: LD_VAR 0 2
25506: PPUSH
25507: LD_VAR 0 1
25511: PPUSH
25512: CALL_OW 248
25516: PPUSH
25517: CALL_OW 450
25521: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25522: LD_ADDR_VAR 0 3
25526: PUSH
25527: LD_VAR 0 4
25531: PPUSH
25532: LD_INT 1
25534: PPUSH
25535: CALL_OW 275
25539: PUSH
25540: LD_VAR 0 5
25544: PUSH
25545: LD_INT 1
25547: ARRAY
25548: GREATEREQUAL
25549: PUSH
25550: LD_VAR 0 4
25554: PPUSH
25555: LD_INT 2
25557: PPUSH
25558: CALL_OW 275
25562: PUSH
25563: LD_VAR 0 5
25567: PUSH
25568: LD_INT 2
25570: ARRAY
25571: GREATEREQUAL
25572: AND
25573: PUSH
25574: LD_VAR 0 4
25578: PPUSH
25579: LD_INT 3
25581: PPUSH
25582: CALL_OW 275
25586: PUSH
25587: LD_VAR 0 5
25591: PUSH
25592: LD_INT 3
25594: ARRAY
25595: GREATEREQUAL
25596: AND
25597: ST_TO_ADDR
// end ;
25598: LD_VAR 0 3
25602: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25603: LD_INT 0
25605: PPUSH
25606: PPUSH
25607: PPUSH
25608: PPUSH
25609: PPUSH
25610: PPUSH
25611: PPUSH
25612: PPUSH
25613: PPUSH
25614: PPUSH
25615: PPUSH
// result := false ;
25616: LD_ADDR_VAR 0 8
25620: PUSH
25621: LD_INT 0
25623: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25624: LD_VAR 0 5
25628: NOT
25629: PUSH
25630: LD_VAR 0 1
25634: NOT
25635: OR
25636: PUSH
25637: LD_VAR 0 2
25641: NOT
25642: OR
25643: PUSH
25644: LD_VAR 0 3
25648: NOT
25649: OR
25650: IFFALSE 25654
// exit ;
25652: GO 26468
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25654: LD_ADDR_VAR 0 14
25658: PUSH
25659: LD_VAR 0 1
25663: PPUSH
25664: LD_VAR 0 2
25668: PPUSH
25669: LD_VAR 0 3
25673: PPUSH
25674: LD_VAR 0 4
25678: PPUSH
25679: LD_VAR 0 5
25683: PUSH
25684: LD_INT 1
25686: ARRAY
25687: PPUSH
25688: CALL_OW 248
25692: PPUSH
25693: LD_INT 0
25695: PPUSH
25696: CALL 27705 0 6
25700: ST_TO_ADDR
// if not hexes then
25701: LD_VAR 0 14
25705: NOT
25706: IFFALSE 25710
// exit ;
25708: GO 26468
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25710: LD_ADDR_VAR 0 17
25714: PUSH
25715: LD_VAR 0 5
25719: PPUSH
25720: LD_INT 22
25722: PUSH
25723: LD_VAR 0 13
25727: PPUSH
25728: CALL_OW 255
25732: PUSH
25733: EMPTY
25734: LIST
25735: LIST
25736: PUSH
25737: LD_INT 2
25739: PUSH
25740: LD_INT 30
25742: PUSH
25743: LD_INT 0
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 30
25752: PUSH
25753: LD_INT 1
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: LIST
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PPUSH
25769: CALL_OW 72
25773: ST_TO_ADDR
// for i = 1 to hexes do
25774: LD_ADDR_VAR 0 9
25778: PUSH
25779: DOUBLE
25780: LD_INT 1
25782: DEC
25783: ST_TO_ADDR
25784: LD_VAR 0 14
25788: PUSH
25789: FOR_TO
25790: IFFALSE 26466
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25792: LD_ADDR_VAR 0 13
25796: PUSH
25797: LD_VAR 0 14
25801: PUSH
25802: LD_VAR 0 9
25806: ARRAY
25807: PUSH
25808: LD_INT 1
25810: ARRAY
25811: PPUSH
25812: LD_VAR 0 14
25816: PUSH
25817: LD_VAR 0 9
25821: ARRAY
25822: PUSH
25823: LD_INT 2
25825: ARRAY
25826: PPUSH
25827: CALL_OW 428
25831: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25832: LD_VAR 0 14
25836: PUSH
25837: LD_VAR 0 9
25841: ARRAY
25842: PUSH
25843: LD_INT 1
25845: ARRAY
25846: PPUSH
25847: LD_VAR 0 14
25851: PUSH
25852: LD_VAR 0 9
25856: ARRAY
25857: PUSH
25858: LD_INT 2
25860: ARRAY
25861: PPUSH
25862: CALL_OW 351
25866: PUSH
25867: LD_VAR 0 14
25871: PUSH
25872: LD_VAR 0 9
25876: ARRAY
25877: PUSH
25878: LD_INT 1
25880: ARRAY
25881: PPUSH
25882: LD_VAR 0 14
25886: PUSH
25887: LD_VAR 0 9
25891: ARRAY
25892: PUSH
25893: LD_INT 2
25895: ARRAY
25896: PPUSH
25897: CALL_OW 488
25901: NOT
25902: OR
25903: PUSH
25904: LD_VAR 0 13
25908: PPUSH
25909: CALL_OW 247
25913: PUSH
25914: LD_INT 3
25916: EQUAL
25917: OR
25918: IFFALSE 25924
// exit ;
25920: POP
25921: POP
25922: GO 26468
// if not tmp then
25924: LD_VAR 0 13
25928: NOT
25929: IFFALSE 25933
// continue ;
25931: GO 25789
// result := true ;
25933: LD_ADDR_VAR 0 8
25937: PUSH
25938: LD_INT 1
25940: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25941: LD_VAR 0 6
25945: PUSH
25946: LD_VAR 0 13
25950: PPUSH
25951: CALL_OW 247
25955: PUSH
25956: LD_INT 2
25958: EQUAL
25959: AND
25960: PUSH
25961: LD_VAR 0 13
25965: PPUSH
25966: CALL_OW 263
25970: PUSH
25971: LD_INT 1
25973: EQUAL
25974: AND
25975: IFFALSE 26139
// begin if IsDrivenBy ( tmp ) then
25977: LD_VAR 0 13
25981: PPUSH
25982: CALL_OW 311
25986: IFFALSE 25990
// continue ;
25988: GO 25789
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25990: LD_VAR 0 6
25994: PPUSH
25995: LD_INT 3
25997: PUSH
25998: LD_INT 60
26000: PUSH
26001: EMPTY
26002: LIST
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 3
26010: PUSH
26011: LD_INT 55
26013: PUSH
26014: EMPTY
26015: LIST
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: EMPTY
26022: LIST
26023: LIST
26024: PPUSH
26025: CALL_OW 72
26029: IFFALSE 26137
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26031: LD_ADDR_VAR 0 18
26035: PUSH
26036: LD_VAR 0 6
26040: PPUSH
26041: LD_INT 3
26043: PUSH
26044: LD_INT 60
26046: PUSH
26047: EMPTY
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PUSH
26054: LD_INT 3
26056: PUSH
26057: LD_INT 55
26059: PUSH
26060: EMPTY
26061: LIST
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: PPUSH
26071: CALL_OW 72
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// if IsInUnit ( driver ) then
26080: LD_VAR 0 18
26084: PPUSH
26085: CALL_OW 310
26089: IFFALSE 26100
// ComExit ( driver ) ;
26091: LD_VAR 0 18
26095: PPUSH
26096: CALL 51410 0 1
// AddComEnterUnit ( driver , tmp ) ;
26100: LD_VAR 0 18
26104: PPUSH
26105: LD_VAR 0 13
26109: PPUSH
26110: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
26114: LD_VAR 0 18
26118: PPUSH
26119: LD_VAR 0 7
26123: PPUSH
26124: CALL_OW 173
// AddComExitVehicle ( driver ) ;
26128: LD_VAR 0 18
26132: PPUSH
26133: CALL_OW 181
// end ; continue ;
26137: GO 25789
// end ; if not cleaners or not tmp in cleaners then
26139: LD_VAR 0 6
26143: NOT
26144: PUSH
26145: LD_VAR 0 13
26149: PUSH
26150: LD_VAR 0 6
26154: IN
26155: NOT
26156: OR
26157: IFFALSE 26464
// begin if dep then
26159: LD_VAR 0 17
26163: IFFALSE 26299
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26165: LD_ADDR_VAR 0 16
26169: PUSH
26170: LD_VAR 0 17
26174: PUSH
26175: LD_INT 1
26177: ARRAY
26178: PPUSH
26179: CALL_OW 250
26183: PPUSH
26184: LD_VAR 0 17
26188: PUSH
26189: LD_INT 1
26191: ARRAY
26192: PPUSH
26193: CALL_OW 254
26197: PPUSH
26198: LD_INT 5
26200: PPUSH
26201: CALL_OW 272
26205: PUSH
26206: LD_VAR 0 17
26210: PUSH
26211: LD_INT 1
26213: ARRAY
26214: PPUSH
26215: CALL_OW 251
26219: PPUSH
26220: LD_VAR 0 17
26224: PUSH
26225: LD_INT 1
26227: ARRAY
26228: PPUSH
26229: CALL_OW 254
26233: PPUSH
26234: LD_INT 5
26236: PPUSH
26237: CALL_OW 273
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26246: LD_VAR 0 16
26250: PUSH
26251: LD_INT 1
26253: ARRAY
26254: PPUSH
26255: LD_VAR 0 16
26259: PUSH
26260: LD_INT 2
26262: ARRAY
26263: PPUSH
26264: CALL_OW 488
26268: IFFALSE 26299
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26270: LD_VAR 0 13
26274: PPUSH
26275: LD_VAR 0 16
26279: PUSH
26280: LD_INT 1
26282: ARRAY
26283: PPUSH
26284: LD_VAR 0 16
26288: PUSH
26289: LD_INT 2
26291: ARRAY
26292: PPUSH
26293: CALL_OW 111
// continue ;
26297: GO 25789
// end ; end ; r := GetDir ( tmp ) ;
26299: LD_ADDR_VAR 0 15
26303: PUSH
26304: LD_VAR 0 13
26308: PPUSH
26309: CALL_OW 254
26313: ST_TO_ADDR
// if r = 5 then
26314: LD_VAR 0 15
26318: PUSH
26319: LD_INT 5
26321: EQUAL
26322: IFFALSE 26332
// r := 0 ;
26324: LD_ADDR_VAR 0 15
26328: PUSH
26329: LD_INT 0
26331: ST_TO_ADDR
// for j = r to 5 do
26332: LD_ADDR_VAR 0 10
26336: PUSH
26337: DOUBLE
26338: LD_VAR 0 15
26342: DEC
26343: ST_TO_ADDR
26344: LD_INT 5
26346: PUSH
26347: FOR_TO
26348: IFFALSE 26462
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26350: LD_ADDR_VAR 0 11
26354: PUSH
26355: LD_VAR 0 13
26359: PPUSH
26360: CALL_OW 250
26364: PPUSH
26365: LD_VAR 0 10
26369: PPUSH
26370: LD_INT 2
26372: PPUSH
26373: CALL_OW 272
26377: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26378: LD_ADDR_VAR 0 12
26382: PUSH
26383: LD_VAR 0 13
26387: PPUSH
26388: CALL_OW 251
26392: PPUSH
26393: LD_VAR 0 10
26397: PPUSH
26398: LD_INT 2
26400: PPUSH
26401: CALL_OW 273
26405: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26406: LD_VAR 0 11
26410: PPUSH
26411: LD_VAR 0 12
26415: PPUSH
26416: CALL_OW 488
26420: PUSH
26421: LD_VAR 0 11
26425: PPUSH
26426: LD_VAR 0 12
26430: PPUSH
26431: CALL_OW 428
26435: NOT
26436: AND
26437: IFFALSE 26460
// begin ComMoveXY ( tmp , _x , _y ) ;
26439: LD_VAR 0 13
26443: PPUSH
26444: LD_VAR 0 11
26448: PPUSH
26449: LD_VAR 0 12
26453: PPUSH
26454: CALL_OW 111
// break ;
26458: GO 26462
// end ; end ;
26460: GO 26347
26462: POP
26463: POP
// end ; end ;
26464: GO 25789
26466: POP
26467: POP
// end ;
26468: LD_VAR 0 8
26472: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26473: LD_INT 0
26475: PPUSH
// result := true ;
26476: LD_ADDR_VAR 0 3
26480: PUSH
26481: LD_INT 1
26483: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26484: LD_VAR 0 2
26488: PUSH
26489: LD_INT 24
26491: DOUBLE
26492: EQUAL
26493: IFTRUE 26503
26495: LD_INT 33
26497: DOUBLE
26498: EQUAL
26499: IFTRUE 26503
26501: GO 26528
26503: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26504: LD_ADDR_VAR 0 3
26508: PUSH
26509: LD_INT 32
26511: PPUSH
26512: LD_VAR 0 1
26516: PPUSH
26517: CALL_OW 321
26521: PUSH
26522: LD_INT 2
26524: EQUAL
26525: ST_TO_ADDR
26526: GO 26848
26528: LD_INT 20
26530: DOUBLE
26531: EQUAL
26532: IFTRUE 26536
26534: GO 26561
26536: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26537: LD_ADDR_VAR 0 3
26541: PUSH
26542: LD_INT 6
26544: PPUSH
26545: LD_VAR 0 1
26549: PPUSH
26550: CALL_OW 321
26554: PUSH
26555: LD_INT 2
26557: EQUAL
26558: ST_TO_ADDR
26559: GO 26848
26561: LD_INT 22
26563: DOUBLE
26564: EQUAL
26565: IFTRUE 26575
26567: LD_INT 36
26569: DOUBLE
26570: EQUAL
26571: IFTRUE 26575
26573: GO 26600
26575: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26576: LD_ADDR_VAR 0 3
26580: PUSH
26581: LD_INT 15
26583: PPUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: CALL_OW 321
26593: PUSH
26594: LD_INT 2
26596: EQUAL
26597: ST_TO_ADDR
26598: GO 26848
26600: LD_INT 30
26602: DOUBLE
26603: EQUAL
26604: IFTRUE 26608
26606: GO 26633
26608: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26609: LD_ADDR_VAR 0 3
26613: PUSH
26614: LD_INT 20
26616: PPUSH
26617: LD_VAR 0 1
26621: PPUSH
26622: CALL_OW 321
26626: PUSH
26627: LD_INT 2
26629: EQUAL
26630: ST_TO_ADDR
26631: GO 26848
26633: LD_INT 28
26635: DOUBLE
26636: EQUAL
26637: IFTRUE 26647
26639: LD_INT 21
26641: DOUBLE
26642: EQUAL
26643: IFTRUE 26647
26645: GO 26672
26647: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26648: LD_ADDR_VAR 0 3
26652: PUSH
26653: LD_INT 21
26655: PPUSH
26656: LD_VAR 0 1
26660: PPUSH
26661: CALL_OW 321
26665: PUSH
26666: LD_INT 2
26668: EQUAL
26669: ST_TO_ADDR
26670: GO 26848
26672: LD_INT 16
26674: DOUBLE
26675: EQUAL
26676: IFTRUE 26680
26678: GO 26707
26680: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26681: LD_ADDR_VAR 0 3
26685: PUSH
26686: LD_EXP 61
26690: PPUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: CALL_OW 321
26700: PUSH
26701: LD_INT 2
26703: EQUAL
26704: ST_TO_ADDR
26705: GO 26848
26707: LD_INT 19
26709: DOUBLE
26710: EQUAL
26711: IFTRUE 26721
26713: LD_INT 23
26715: DOUBLE
26716: EQUAL
26717: IFTRUE 26721
26719: GO 26748
26721: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26722: LD_ADDR_VAR 0 3
26726: PUSH
26727: LD_EXP 60
26731: PPUSH
26732: LD_VAR 0 1
26736: PPUSH
26737: CALL_OW 321
26741: PUSH
26742: LD_INT 2
26744: EQUAL
26745: ST_TO_ADDR
26746: GO 26848
26748: LD_INT 17
26750: DOUBLE
26751: EQUAL
26752: IFTRUE 26756
26754: GO 26781
26756: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26757: LD_ADDR_VAR 0 3
26761: PUSH
26762: LD_INT 39
26764: PPUSH
26765: LD_VAR 0 1
26769: PPUSH
26770: CALL_OW 321
26774: PUSH
26775: LD_INT 2
26777: EQUAL
26778: ST_TO_ADDR
26779: GO 26848
26781: LD_INT 18
26783: DOUBLE
26784: EQUAL
26785: IFTRUE 26789
26787: GO 26814
26789: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26790: LD_ADDR_VAR 0 3
26794: PUSH
26795: LD_INT 40
26797: PPUSH
26798: LD_VAR 0 1
26802: PPUSH
26803: CALL_OW 321
26807: PUSH
26808: LD_INT 2
26810: EQUAL
26811: ST_TO_ADDR
26812: GO 26848
26814: LD_INT 27
26816: DOUBLE
26817: EQUAL
26818: IFTRUE 26822
26820: GO 26847
26822: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26823: LD_ADDR_VAR 0 3
26827: PUSH
26828: LD_INT 35
26830: PPUSH
26831: LD_VAR 0 1
26835: PPUSH
26836: CALL_OW 321
26840: PUSH
26841: LD_INT 2
26843: EQUAL
26844: ST_TO_ADDR
26845: GO 26848
26847: POP
// end ;
26848: LD_VAR 0 3
26852: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26853: LD_INT 0
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
// result := false ;
26866: LD_ADDR_VAR 0 6
26870: PUSH
26871: LD_INT 0
26873: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26874: LD_VAR 0 1
26878: NOT
26879: PUSH
26880: LD_VAR 0 1
26884: PPUSH
26885: CALL_OW 266
26889: PUSH
26890: LD_INT 0
26892: PUSH
26893: LD_INT 1
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: IN
26900: NOT
26901: OR
26902: PUSH
26903: LD_VAR 0 2
26907: NOT
26908: OR
26909: PUSH
26910: LD_VAR 0 5
26914: PUSH
26915: LD_INT 0
26917: PUSH
26918: LD_INT 1
26920: PUSH
26921: LD_INT 2
26923: PUSH
26924: LD_INT 3
26926: PUSH
26927: LD_INT 4
26929: PUSH
26930: LD_INT 5
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: IN
26941: NOT
26942: OR
26943: PUSH
26944: LD_VAR 0 3
26948: PPUSH
26949: LD_VAR 0 4
26953: PPUSH
26954: CALL_OW 488
26958: NOT
26959: OR
26960: IFFALSE 26964
// exit ;
26962: GO 27700
// side := GetSide ( depot ) ;
26964: LD_ADDR_VAR 0 9
26968: PUSH
26969: LD_VAR 0 1
26973: PPUSH
26974: CALL_OW 255
26978: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26979: LD_VAR 0 9
26983: PPUSH
26984: LD_VAR 0 2
26988: PPUSH
26989: CALL 26473 0 2
26993: NOT
26994: IFFALSE 26998
// exit ;
26996: GO 27700
// pom := GetBase ( depot ) ;
26998: LD_ADDR_VAR 0 10
27002: PUSH
27003: LD_VAR 0 1
27007: PPUSH
27008: CALL_OW 274
27012: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27013: LD_ADDR_VAR 0 11
27017: PUSH
27018: LD_VAR 0 2
27022: PPUSH
27023: LD_VAR 0 1
27027: PPUSH
27028: CALL_OW 248
27032: PPUSH
27033: CALL_OW 450
27037: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27038: LD_VAR 0 10
27042: PPUSH
27043: LD_INT 1
27045: PPUSH
27046: CALL_OW 275
27050: PUSH
27051: LD_VAR 0 11
27055: PUSH
27056: LD_INT 1
27058: ARRAY
27059: GREATEREQUAL
27060: PUSH
27061: LD_VAR 0 10
27065: PPUSH
27066: LD_INT 2
27068: PPUSH
27069: CALL_OW 275
27073: PUSH
27074: LD_VAR 0 11
27078: PUSH
27079: LD_INT 2
27081: ARRAY
27082: GREATEREQUAL
27083: AND
27084: PUSH
27085: LD_VAR 0 10
27089: PPUSH
27090: LD_INT 3
27092: PPUSH
27093: CALL_OW 275
27097: PUSH
27098: LD_VAR 0 11
27102: PUSH
27103: LD_INT 3
27105: ARRAY
27106: GREATEREQUAL
27107: AND
27108: NOT
27109: IFFALSE 27113
// exit ;
27111: GO 27700
// if GetBType ( depot ) = b_depot then
27113: LD_VAR 0 1
27117: PPUSH
27118: CALL_OW 266
27122: PUSH
27123: LD_INT 0
27125: EQUAL
27126: IFFALSE 27138
// dist := 28 else
27128: LD_ADDR_VAR 0 14
27132: PUSH
27133: LD_INT 28
27135: ST_TO_ADDR
27136: GO 27146
// dist := 36 ;
27138: LD_ADDR_VAR 0 14
27142: PUSH
27143: LD_INT 36
27145: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27146: LD_VAR 0 1
27150: PPUSH
27151: LD_VAR 0 3
27155: PPUSH
27156: LD_VAR 0 4
27160: PPUSH
27161: CALL_OW 297
27165: PUSH
27166: LD_VAR 0 14
27170: GREATER
27171: IFFALSE 27175
// exit ;
27173: GO 27700
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27175: LD_ADDR_VAR 0 12
27179: PUSH
27180: LD_VAR 0 2
27184: PPUSH
27185: LD_VAR 0 3
27189: PPUSH
27190: LD_VAR 0 4
27194: PPUSH
27195: LD_VAR 0 5
27199: PPUSH
27200: LD_VAR 0 1
27204: PPUSH
27205: CALL_OW 248
27209: PPUSH
27210: LD_INT 0
27212: PPUSH
27213: CALL 27705 0 6
27217: ST_TO_ADDR
// if not hexes then
27218: LD_VAR 0 12
27222: NOT
27223: IFFALSE 27227
// exit ;
27225: GO 27700
// hex := GetHexInfo ( x , y ) ;
27227: LD_ADDR_VAR 0 15
27231: PUSH
27232: LD_VAR 0 3
27236: PPUSH
27237: LD_VAR 0 4
27241: PPUSH
27242: CALL_OW 546
27246: ST_TO_ADDR
// if hex [ 1 ] then
27247: LD_VAR 0 15
27251: PUSH
27252: LD_INT 1
27254: ARRAY
27255: IFFALSE 27259
// exit ;
27257: GO 27700
// height := hex [ 2 ] ;
27259: LD_ADDR_VAR 0 13
27263: PUSH
27264: LD_VAR 0 15
27268: PUSH
27269: LD_INT 2
27271: ARRAY
27272: ST_TO_ADDR
// for i = 1 to hexes do
27273: LD_ADDR_VAR 0 7
27277: PUSH
27278: DOUBLE
27279: LD_INT 1
27281: DEC
27282: ST_TO_ADDR
27283: LD_VAR 0 12
27287: PUSH
27288: FOR_TO
27289: IFFALSE 27619
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27291: LD_VAR 0 12
27295: PUSH
27296: LD_VAR 0 7
27300: ARRAY
27301: PUSH
27302: LD_INT 1
27304: ARRAY
27305: PPUSH
27306: LD_VAR 0 12
27310: PUSH
27311: LD_VAR 0 7
27315: ARRAY
27316: PUSH
27317: LD_INT 2
27319: ARRAY
27320: PPUSH
27321: CALL_OW 488
27325: NOT
27326: PUSH
27327: LD_VAR 0 12
27331: PUSH
27332: LD_VAR 0 7
27336: ARRAY
27337: PUSH
27338: LD_INT 1
27340: ARRAY
27341: PPUSH
27342: LD_VAR 0 12
27346: PUSH
27347: LD_VAR 0 7
27351: ARRAY
27352: PUSH
27353: LD_INT 2
27355: ARRAY
27356: PPUSH
27357: CALL_OW 428
27361: PUSH
27362: LD_INT 0
27364: GREATER
27365: OR
27366: PUSH
27367: LD_VAR 0 12
27371: PUSH
27372: LD_VAR 0 7
27376: ARRAY
27377: PUSH
27378: LD_INT 1
27380: ARRAY
27381: PPUSH
27382: LD_VAR 0 12
27386: PUSH
27387: LD_VAR 0 7
27391: ARRAY
27392: PUSH
27393: LD_INT 2
27395: ARRAY
27396: PPUSH
27397: CALL_OW 351
27401: OR
27402: IFFALSE 27408
// exit ;
27404: POP
27405: POP
27406: GO 27700
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27408: LD_ADDR_VAR 0 8
27412: PUSH
27413: LD_VAR 0 12
27417: PUSH
27418: LD_VAR 0 7
27422: ARRAY
27423: PUSH
27424: LD_INT 1
27426: ARRAY
27427: PPUSH
27428: LD_VAR 0 12
27432: PUSH
27433: LD_VAR 0 7
27437: ARRAY
27438: PUSH
27439: LD_INT 2
27441: ARRAY
27442: PPUSH
27443: CALL_OW 546
27447: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27448: LD_VAR 0 8
27452: PUSH
27453: LD_INT 1
27455: ARRAY
27456: PUSH
27457: LD_VAR 0 8
27461: PUSH
27462: LD_INT 2
27464: ARRAY
27465: PUSH
27466: LD_VAR 0 13
27470: PUSH
27471: LD_INT 2
27473: PLUS
27474: GREATER
27475: OR
27476: PUSH
27477: LD_VAR 0 8
27481: PUSH
27482: LD_INT 2
27484: ARRAY
27485: PUSH
27486: LD_VAR 0 13
27490: PUSH
27491: LD_INT 2
27493: MINUS
27494: LESS
27495: OR
27496: PUSH
27497: LD_VAR 0 8
27501: PUSH
27502: LD_INT 3
27504: ARRAY
27505: PUSH
27506: LD_INT 0
27508: PUSH
27509: LD_INT 8
27511: PUSH
27512: LD_INT 9
27514: PUSH
27515: LD_INT 10
27517: PUSH
27518: LD_INT 11
27520: PUSH
27521: LD_INT 12
27523: PUSH
27524: LD_INT 13
27526: PUSH
27527: LD_INT 16
27529: PUSH
27530: LD_INT 17
27532: PUSH
27533: LD_INT 18
27535: PUSH
27536: LD_INT 19
27538: PUSH
27539: LD_INT 20
27541: PUSH
27542: LD_INT 21
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: LIST
27559: IN
27560: NOT
27561: OR
27562: PUSH
27563: LD_VAR 0 8
27567: PUSH
27568: LD_INT 5
27570: ARRAY
27571: NOT
27572: OR
27573: PUSH
27574: LD_VAR 0 8
27578: PUSH
27579: LD_INT 6
27581: ARRAY
27582: PUSH
27583: LD_INT 1
27585: PUSH
27586: LD_INT 2
27588: PUSH
27589: LD_INT 7
27591: PUSH
27592: LD_INT 9
27594: PUSH
27595: LD_INT 10
27597: PUSH
27598: LD_INT 11
27600: PUSH
27601: EMPTY
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: IN
27609: NOT
27610: OR
27611: IFFALSE 27617
// exit ;
27613: POP
27614: POP
27615: GO 27700
// end ;
27617: GO 27288
27619: POP
27620: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27621: LD_VAR 0 9
27625: PPUSH
27626: LD_VAR 0 3
27630: PPUSH
27631: LD_VAR 0 4
27635: PPUSH
27636: LD_INT 20
27638: PPUSH
27639: CALL 19646 0 4
27643: PUSH
27644: LD_INT 4
27646: ARRAY
27647: IFFALSE 27651
// exit ;
27649: GO 27700
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27651: LD_VAR 0 2
27655: PUSH
27656: LD_INT 29
27658: PUSH
27659: LD_INT 30
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: IN
27666: PUSH
27667: LD_VAR 0 3
27671: PPUSH
27672: LD_VAR 0 4
27676: PPUSH
27677: LD_VAR 0 9
27681: PPUSH
27682: CALL_OW 440
27686: NOT
27687: AND
27688: IFFALSE 27692
// exit ;
27690: GO 27700
// result := true ;
27692: LD_ADDR_VAR 0 6
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ;
27700: LD_VAR 0 6
27704: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27705: LD_INT 0
27707: PPUSH
27708: PPUSH
27709: PPUSH
27710: PPUSH
27711: PPUSH
27712: PPUSH
27713: PPUSH
27714: PPUSH
27715: PPUSH
27716: PPUSH
27717: PPUSH
27718: PPUSH
27719: PPUSH
27720: PPUSH
27721: PPUSH
27722: PPUSH
27723: PPUSH
27724: PPUSH
27725: PPUSH
27726: PPUSH
27727: PPUSH
27728: PPUSH
27729: PPUSH
27730: PPUSH
27731: PPUSH
27732: PPUSH
27733: PPUSH
27734: PPUSH
27735: PPUSH
27736: PPUSH
27737: PPUSH
27738: PPUSH
27739: PPUSH
27740: PPUSH
27741: PPUSH
27742: PPUSH
27743: PPUSH
27744: PPUSH
27745: PPUSH
27746: PPUSH
27747: PPUSH
27748: PPUSH
27749: PPUSH
27750: PPUSH
27751: PPUSH
27752: PPUSH
27753: PPUSH
27754: PPUSH
27755: PPUSH
27756: PPUSH
27757: PPUSH
27758: PPUSH
27759: PPUSH
27760: PPUSH
27761: PPUSH
27762: PPUSH
27763: PPUSH
27764: PPUSH
// result = [ ] ;
27765: LD_ADDR_VAR 0 7
27769: PUSH
27770: EMPTY
27771: ST_TO_ADDR
// temp_list = [ ] ;
27772: LD_ADDR_VAR 0 9
27776: PUSH
27777: EMPTY
27778: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27779: LD_VAR 0 4
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: LD_INT 1
27789: PUSH
27790: LD_INT 2
27792: PUSH
27793: LD_INT 3
27795: PUSH
27796: LD_INT 4
27798: PUSH
27799: LD_INT 5
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: IN
27810: NOT
27811: PUSH
27812: LD_VAR 0 1
27816: PUSH
27817: LD_INT 0
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: IN
27827: PUSH
27828: LD_VAR 0 5
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: LD_INT 2
27838: PUSH
27839: LD_INT 3
27841: PUSH
27842: EMPTY
27843: LIST
27844: LIST
27845: LIST
27846: IN
27847: NOT
27848: AND
27849: OR
27850: IFFALSE 27854
// exit ;
27852: GO 46245
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27854: LD_VAR 0 1
27858: PUSH
27859: LD_INT 6
27861: PUSH
27862: LD_INT 7
27864: PUSH
27865: LD_INT 8
27867: PUSH
27868: LD_INT 13
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: LD_INT 15
27876: PUSH
27877: LD_INT 11
27879: PUSH
27880: LD_INT 14
27882: PUSH
27883: LD_INT 10
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: LIST
27890: LIST
27891: LIST
27892: LIST
27893: LIST
27894: LIST
27895: LIST
27896: IN
27897: IFFALSE 27907
// btype = b_lab ;
27899: LD_ADDR_VAR 0 1
27903: PUSH
27904: LD_INT 6
27906: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27907: LD_VAR 0 6
27911: PUSH
27912: LD_INT 0
27914: PUSH
27915: LD_INT 1
27917: PUSH
27918: LD_INT 2
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: LIST
27925: IN
27926: NOT
27927: PUSH
27928: LD_VAR 0 1
27932: PUSH
27933: LD_INT 0
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: LD_INT 3
27944: PUSH
27945: LD_INT 6
27947: PUSH
27948: LD_INT 36
27950: PUSH
27951: LD_INT 4
27953: PUSH
27954: LD_INT 5
27956: PUSH
27957: LD_INT 31
27959: PUSH
27960: LD_INT 32
27962: PUSH
27963: LD_INT 33
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: IN
27979: NOT
27980: PUSH
27981: LD_VAR 0 6
27985: PUSH
27986: LD_INT 1
27988: EQUAL
27989: AND
27990: OR
27991: PUSH
27992: LD_VAR 0 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: LD_INT 3
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: IN
28007: NOT
28008: PUSH
28009: LD_VAR 0 6
28013: PUSH
28014: LD_INT 2
28016: EQUAL
28017: AND
28018: OR
28019: IFFALSE 28029
// mode = 0 ;
28021: LD_ADDR_VAR 0 6
28025: PUSH
28026: LD_INT 0
28028: ST_TO_ADDR
// case mode of 0 :
28029: LD_VAR 0 6
28033: PUSH
28034: LD_INT 0
28036: DOUBLE
28037: EQUAL
28038: IFTRUE 28042
28040: GO 39495
28042: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28043: LD_ADDR_VAR 0 11
28047: PUSH
28048: LD_INT 0
28050: PUSH
28051: LD_INT 0
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 0
28060: PUSH
28061: LD_INT 1
28063: NEG
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 1
28071: PUSH
28072: LD_INT 0
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 1
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: LD_INT 1
28101: NEG
28102: PUSH
28103: LD_INT 0
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 1
28116: NEG
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 2
28128: NEG
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: LD_INT 2
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 0
28168: PUSH
28169: LD_INT 2
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 1
28178: NEG
28179: PUSH
28180: LD_INT 1
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 1
28189: PUSH
28190: LD_INT 3
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 0
28199: PUSH
28200: LD_INT 3
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 1
28209: NEG
28210: PUSH
28211: LD_INT 2
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28236: LD_ADDR_VAR 0 12
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 0
28253: PUSH
28254: LD_INT 1
28256: NEG
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: EMPTY
28269: LIST
28270: LIST
28271: PUSH
28272: LD_INT 1
28274: PUSH
28275: LD_INT 1
28277: PUSH
28278: EMPTY
28279: LIST
28280: LIST
28281: PUSH
28282: LD_INT 0
28284: PUSH
28285: LD_INT 1
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 1
28294: NEG
28295: PUSH
28296: LD_INT 0
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: LD_INT 1
28309: NEG
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 1
28320: NEG
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 2
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 1
28348: NEG
28349: PUSH
28350: LD_INT 1
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 0
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PUSH
28368: LD_INT 2
28370: NEG
28371: PUSH
28372: LD_INT 1
28374: NEG
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 2
28382: NEG
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 3
28393: NEG
28394: PUSH
28395: LD_INT 0
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 3
28404: NEG
28405: PUSH
28406: LD_INT 1
28408: NEG
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: LIST
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28432: LD_ADDR_VAR 0 13
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 1
28460: PUSH
28461: LD_INT 0
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: PUSH
28471: LD_INT 1
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 0
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: PUSH
28488: LD_INT 1
28490: NEG
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: EMPTY
28496: LIST
28497: LIST
28498: PUSH
28499: LD_INT 1
28501: NEG
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: LD_INT 1
28513: NEG
28514: PUSH
28515: LD_INT 2
28517: NEG
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 2
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 2
28535: PUSH
28536: LD_INT 2
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: LD_INT 1
28545: PUSH
28546: LD_INT 2
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 2
28555: NEG
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 2
28567: NEG
28568: PUSH
28569: LD_INT 2
28571: NEG
28572: PUSH
28573: EMPTY
28574: LIST
28575: LIST
28576: PUSH
28577: LD_INT 2
28579: NEG
28580: PUSH
28581: LD_INT 3
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 3
28591: NEG
28592: PUSH
28593: LD_INT 2
28595: NEG
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 3
28603: NEG
28604: PUSH
28605: LD_INT 3
28607: NEG
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28631: LD_ADDR_VAR 0 14
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 0
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 0
28648: PUSH
28649: LD_INT 1
28651: NEG
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 1
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 1
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 0
28679: PUSH
28680: LD_INT 1
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PUSH
28687: LD_INT 1
28689: NEG
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: LD_INT 1
28704: NEG
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 1
28712: NEG
28713: PUSH
28714: LD_INT 2
28716: NEG
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 0
28724: PUSH
28725: LD_INT 2
28727: NEG
28728: PUSH
28729: EMPTY
28730: LIST
28731: LIST
28732: PUSH
28733: LD_INT 1
28735: PUSH
28736: LD_INT 1
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 1
28766: NEG
28767: PUSH
28768: LD_INT 1
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: LD_INT 3
28781: NEG
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 3
28792: NEG
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 1
28800: PUSH
28801: LD_INT 2
28803: NEG
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: LIST
28825: LIST
28826: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28827: LD_ADDR_VAR 0 15
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 1
28847: NEG
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 1
28855: PUSH
28856: LD_INT 0
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: LD_INT 1
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 1
28885: NEG
28886: PUSH
28887: LD_INT 0
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: NEG
28897: PUSH
28898: LD_INT 1
28900: NEG
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: LD_INT 1
28911: NEG
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 2
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 2
28950: NEG
28951: PUSH
28952: LD_INT 0
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 2
28961: NEG
28962: PUSH
28963: LD_INT 1
28965: NEG
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 2
28973: PUSH
28974: LD_INT 1
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 3
28994: PUSH
28995: LD_INT 1
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29020: LD_ADDR_VAR 0 16
29024: PUSH
29025: LD_INT 0
29027: PUSH
29028: LD_INT 0
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 1
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 1
29048: PUSH
29049: LD_INT 0
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: LD_INT 0
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: NEG
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 1
29101: NEG
29102: PUSH
29103: LD_INT 2
29105: NEG
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 2
29113: PUSH
29114: LD_INT 1
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 2
29123: PUSH
29124: LD_INT 2
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: PUSH
29134: LD_INT 2
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: LD_INT 1
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 2
29155: NEG
29156: PUSH
29157: LD_INT 2
29159: NEG
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 3
29167: PUSH
29168: LD_INT 2
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 3
29177: PUSH
29178: LD_INT 3
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: LD_INT 3
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29213: LD_ADDR_VAR 0 17
29217: PUSH
29218: LD_INT 0
29220: PUSH
29221: LD_INT 0
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 1
29233: NEG
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PUSH
29242: LD_INT 0
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 1
29294: NEG
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: LD_INT 2
29309: NEG
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 2
29328: PUSH
29329: LD_INT 0
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 2
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 0
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: NEG
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 2
29389: NEG
29390: PUSH
29391: LD_INT 0
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 2
29400: NEG
29401: PUSH
29402: LD_INT 1
29404: NEG
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 2
29412: NEG
29413: PUSH
29414: LD_INT 2
29416: NEG
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: LIST
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29443: LD_ADDR_VAR 0 18
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 1
29463: NEG
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 1
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 0
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 1
29512: NEG
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: LD_INT 2
29528: NEG
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 0
29536: PUSH
29537: LD_INT 2
29539: NEG
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: LD_INT 1
29550: NEG
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 0
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 1
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: LD_INT 1
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 2
29619: NEG
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: NEG
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29673: LD_ADDR_VAR 0 19
29677: PUSH
29678: LD_INT 0
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 1
29693: NEG
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 1
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 1
29731: NEG
29732: PUSH
29733: LD_INT 0
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: NEG
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 2
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 2
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: LD_INT 1
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 2
29788: PUSH
29789: LD_INT 0
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 2
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 2
29849: NEG
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 2
29860: NEG
29861: PUSH
29862: LD_INT 1
29864: NEG
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 2
29872: NEG
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29903: LD_ADDR_VAR 0 20
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 1
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 0
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 1
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 0
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: LD_INT 0
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PUSH
29970: LD_INT 1
29972: NEG
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: NEG
29985: PUSH
29986: LD_INT 2
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 2
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 0
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 2
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 1
30068: NEG
30069: PUSH
30070: LD_INT 1
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 2
30079: NEG
30080: PUSH
30081: LD_INT 0
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 2
30090: NEG
30091: PUSH
30092: LD_INT 1
30094: NEG
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 2
30102: NEG
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: LIST
30116: LIST
30117: LIST
30118: LIST
30119: LIST
30120: LIST
30121: LIST
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30133: LD_ADDR_VAR 0 21
30137: PUSH
30138: LD_INT 0
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 1
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 0
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 0
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 1
30191: NEG
30192: PUSH
30193: LD_INT 0
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: NEG
30203: PUSH
30204: LD_INT 1
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: LD_INT 2
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 2
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 1
30240: NEG
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 2
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 2
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 0
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 1
30298: NEG
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: NEG
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 2
30320: NEG
30321: PUSH
30322: LD_INT 1
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 2
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30363: LD_ADDR_VAR 0 22
30367: PUSH
30368: LD_INT 0
30370: PUSH
30371: LD_INT 0
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 1
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 0
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 0
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 1
30432: NEG
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 1
30444: NEG
30445: PUSH
30446: LD_INT 2
30448: NEG
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 0
30456: PUSH
30457: LD_INT 2
30459: NEG
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 2
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 1
30528: NEG
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 2
30539: NEG
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 2
30550: NEG
30551: PUSH
30552: LD_INT 1
30554: NEG
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 2
30562: NEG
30563: PUSH
30564: LD_INT 2
30566: NEG
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30593: LD_ADDR_VAR 0 23
30597: PUSH
30598: LD_INT 0
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 0
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: LD_INT 1
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 0
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: NEG
30652: PUSH
30653: LD_INT 0
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 1
30662: NEG
30663: PUSH
30664: LD_INT 1
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 0
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 2
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 1
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 2
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: LD_INT 3
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30873: LD_ADDR_VAR 0 24
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 0
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 0
30890: PUSH
30891: LD_INT 1
30893: NEG
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 1
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 1
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 0
30921: PUSH
30922: LD_INT 1
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 0
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: NEG
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 0
30966: PUSH
30967: LD_INT 2
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: LD_INT 1
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 2
30998: PUSH
30999: LD_INT 1
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 2
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: PUSH
31085: LD_INT 2
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: PUSH
31096: LD_INT 1
31098: NEG
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PUSH
31104: LD_INT 3
31106: PUSH
31107: LD_INT 1
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 3
31116: PUSH
31117: LD_INT 2
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31149: LD_ADDR_VAR 0 25
31153: PUSH
31154: LD_INT 0
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: LD_INT 1
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 0
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 1
31218: NEG
31219: PUSH
31220: LD_INT 1
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: LD_INT 2
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: LD_INT 0
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: LD_INT 1
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 2
31284: PUSH
31285: LD_INT 2
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 1
31294: PUSH
31295: LD_INT 2
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 0
31304: PUSH
31305: LD_INT 2
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 1
31314: NEG
31315: PUSH
31316: LD_INT 1
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: LD_INT 0
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 2
31336: NEG
31337: PUSH
31338: LD_INT 1
31340: NEG
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 2
31348: NEG
31349: PUSH
31350: LD_INT 2
31352: NEG
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 3
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 3
31370: PUSH
31371: LD_INT 2
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 2
31380: PUSH
31381: LD_INT 3
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: LD_INT 3
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31423: LD_ADDR_VAR 0 26
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: NEG
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 1
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: NEG
31493: PUSH
31494: LD_INT 1
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: LD_INT 2
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 2
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 2
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: LD_INT 2
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 0
31578: PUSH
31579: LD_INT 2
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 1
31588: NEG
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: LD_INT 2
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: PUSH
31635: LD_INT 3
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: NEG
31655: PUSH
31656: LD_INT 2
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 2
31665: NEG
31666: PUSH
31667: LD_INT 1
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31699: LD_ADDR_VAR 0 27
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 0
31716: PUSH
31717: LD_INT 1
31719: NEG
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: LD_INT 1
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: LD_INT 2
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 2
31814: PUSH
31815: LD_INT 0
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 2
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: LD_INT 2
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 1
31864: NEG
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 2
31875: NEG
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 2
31886: NEG
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 2
31898: NEG
31899: PUSH
31900: LD_INT 2
31902: NEG
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 2
31921: NEG
31922: PUSH
31923: LD_INT 1
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 3
31932: NEG
31933: PUSH
31934: LD_INT 1
31936: NEG
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 3
31944: NEG
31945: PUSH
31946: LD_INT 2
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: LIST
31974: LIST
31975: LIST
31976: LIST
31977: LIST
31978: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31979: LD_ADDR_VAR 0 28
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: LD_INT 0
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 0
31996: PUSH
31997: LD_INT 1
31999: NEG
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 1
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 0
32027: PUSH
32028: LD_INT 1
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: LD_INT 0
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 1
32048: NEG
32049: PUSH
32050: LD_INT 1
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: LD_INT 2
32064: NEG
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 1
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 2
32114: PUSH
32115: LD_INT 2
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: PUSH
32125: LD_INT 2
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 1
32144: NEG
32145: PUSH
32146: LD_INT 1
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: NEG
32167: PUSH
32168: LD_INT 1
32170: NEG
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 2
32178: NEG
32179: PUSH
32180: LD_INT 2
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 2
32190: NEG
32191: PUSH
32192: LD_INT 3
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: NEG
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: NEG
32215: PUSH
32216: LD_INT 1
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 3
32226: NEG
32227: PUSH
32228: LD_INT 2
32230: NEG
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32261: LD_ADDR_VAR 0 29
32265: PUSH
32266: LD_INT 0
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 0
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 0
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 0
32309: PUSH
32310: LD_INT 1
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: NEG
32320: PUSH
32321: LD_INT 0
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: NEG
32331: PUSH
32332: LD_INT 1
32334: NEG
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 1
32342: NEG
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: LD_INT 2
32357: NEG
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: PUSH
32366: LD_INT 1
32368: NEG
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: LD_INT 2
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: NEG
32440: PUSH
32441: LD_INT 2
32443: NEG
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: NEG
32452: PUSH
32453: LD_INT 3
32455: NEG
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: LD_INT 1
32466: NEG
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 1
32484: PUSH
32485: LD_INT 3
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: LD_INT 2
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 3
32505: NEG
32506: PUSH
32507: LD_INT 2
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32540: LD_ADDR_VAR 0 30
32544: PUSH
32545: LD_INT 0
32547: PUSH
32548: LD_INT 0
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: LD_INT 1
32560: NEG
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: LD_INT 0
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 0
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 1
32598: NEG
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 1
32609: NEG
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: LD_INT 2
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 2
32636: NEG
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 1
32644: PUSH
32645: LD_INT 1
32647: NEG
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: LD_INT 0
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 2
32665: PUSH
32666: LD_INT 1
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 2
32675: PUSH
32676: LD_INT 2
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 1
32685: PUSH
32686: LD_INT 2
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 2
32706: NEG
32707: PUSH
32708: LD_INT 0
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 2
32717: NEG
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 3
32733: NEG
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 1
32741: PUSH
32742: LD_INT 2
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 3
32752: PUSH
32753: LD_INT 2
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 2
32762: PUSH
32763: LD_INT 3
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 3
32783: NEG
32784: PUSH
32785: LD_INT 1
32787: NEG
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: LIST
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: LIST
32815: LIST
32816: LIST
32817: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32818: LD_ADDR_VAR 0 31
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: LD_INT 0
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 1
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 1
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 1
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 0
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 1
32887: NEG
32888: PUSH
32889: LD_INT 1
32891: NEG
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 1
32899: NEG
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: PUSH
32912: LD_INT 1
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 2
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 2
32932: PUSH
32933: LD_INT 1
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 2
32942: PUSH
32943: LD_INT 2
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: LD_INT 2
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 2
32983: NEG
32984: PUSH
32985: LD_INT 1
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: LD_INT 2
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: NEG
33008: PUSH
33009: LD_INT 3
33011: NEG
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 2
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 3
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 3
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 3
33061: NEG
33062: PUSH
33063: LD_INT 2
33065: NEG
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33096: LD_ADDR_VAR 0 32
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 1
33116: NEG
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 0
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 0
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: NEG
33155: PUSH
33156: LD_INT 0
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: LD_INT 2
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: LD_INT 2
33192: NEG
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: LD_INT 1
33203: NEG
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: PUSH
33222: LD_INT 2
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 1
33231: PUSH
33232: LD_INT 2
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: LD_INT 2
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 1
33251: NEG
33252: PUSH
33253: LD_INT 1
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 2
33262: NEG
33263: PUSH
33264: LD_INT 0
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 2
33273: NEG
33274: PUSH
33275: LD_INT 1
33277: NEG
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: NEG
33286: PUSH
33287: LD_INT 3
33289: NEG
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: LD_INT 2
33300: NEG
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 3
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 2
33318: PUSH
33319: LD_INT 3
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: LD_INT 1
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 3
33339: NEG
33340: PUSH
33341: LD_INT 1
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33374: LD_ADDR_VAR 0 33
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: LD_INT 2
33459: NEG
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 2
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 1
33498: PUSH
33499: LD_INT 2
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 2
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: PUSH
33516: LD_INT 1
33518: NEG
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 2
33540: NEG
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 2
33552: NEG
33553: PUSH
33554: LD_INT 2
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 2
33564: NEG
33565: PUSH
33566: LD_INT 3
33568: NEG
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 2
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 3
33587: PUSH
33588: LD_INT 1
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: LD_INT 3
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 1
33607: NEG
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 3
33618: NEG
33619: PUSH
33620: LD_INT 2
33622: NEG
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33653: LD_ADDR_VAR 0 34
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 0
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 1
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 0
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 1
33711: NEG
33712: PUSH
33713: LD_INT 0
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 1
33722: NEG
33723: PUSH
33724: LD_INT 1
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 1
33734: NEG
33735: PUSH
33736: LD_INT 2
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: LD_INT 2
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 1
33760: NEG
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: LD_INT 2
33778: PUSH
33779: LD_INT 2
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: LD_INT 2
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 2
33809: NEG
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: NEG
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: NEG
33833: PUSH
33834: LD_INT 2
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 3
33848: NEG
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 3
33867: PUSH
33868: LD_INT 2
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: LD_INT 3
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: LD_INT 1
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 3
33898: NEG
33899: PUSH
33900: LD_INT 1
33902: NEG
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33933: LD_ADDR_VAR 0 35
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 0
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: PUSH
33972: LD_INT 1
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 0
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 1
33991: NEG
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: NEG
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 2
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 2
34024: NEG
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34045: LD_ADDR_VAR 0 36
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 1
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: NEG
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 1
34126: NEG
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: LD_INT 2
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34157: LD_ADDR_VAR 0 37
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 0
34174: PUSH
34175: LD_INT 1
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 0
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 1
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 0
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: NEG
34216: PUSH
34217: LD_INT 0
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 1
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34269: LD_ADDR_VAR 0 38
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 0
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: LD_INT 1
34289: NEG
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: LD_INT 1
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 1
34327: NEG
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 2
34360: NEG
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34381: LD_ADDR_VAR 0 39
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: LD_INT 0
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 0
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 1
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 1
34462: NEG
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34493: LD_ADDR_VAR 0 40
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 1
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: NEG
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: NEG
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 1
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 1
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34605: LD_ADDR_VAR 0 41
34609: PUSH
34610: LD_INT 0
34612: PUSH
34613: LD_INT 0
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 0
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 1
34633: PUSH
34634: LD_INT 0
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: LD_INT 1
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 0
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: NEG
34664: PUSH
34665: LD_INT 0
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: LD_INT 1
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 1
34686: NEG
34687: PUSH
34688: LD_INT 2
34690: NEG
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 1
34698: PUSH
34699: LD_INT 1
34701: NEG
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 2
34709: PUSH
34710: LD_INT 0
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 2
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 2
34729: PUSH
34730: LD_INT 2
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: LD_INT 2
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 1
34749: NEG
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 2
34771: NEG
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 2
34783: NEG
34784: PUSH
34785: LD_INT 2
34787: NEG
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: LD_INT 3
34799: NEG
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 3
34818: PUSH
34819: LD_INT 0
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 3
34828: PUSH
34829: LD_INT 1
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 3
34838: PUSH
34839: LD_INT 2
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 3
34848: PUSH
34849: LD_INT 3
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 2
34858: PUSH
34859: LD_INT 3
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 2
34868: NEG
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 3
34879: NEG
34880: PUSH
34881: LD_INT 0
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 3
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 3
34902: NEG
34903: PUSH
34904: LD_INT 2
34906: NEG
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 3
34914: NEG
34915: PUSH
34916: LD_INT 3
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34955: LD_ADDR_VAR 0 42
34959: PUSH
34960: LD_INT 0
34962: PUSH
34963: LD_INT 0
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 1
34983: PUSH
34984: LD_INT 0
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: PUSH
34994: LD_INT 1
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 2
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: LD_INT 2
35051: NEG
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 2
35070: PUSH
35071: LD_INT 1
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 2
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 2
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 2
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 2
35121: NEG
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 2
35133: NEG
35134: PUSH
35135: LD_INT 2
35137: NEG
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 2
35145: NEG
35146: PUSH
35147: LD_INT 3
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: NEG
35158: PUSH
35159: LD_INT 3
35161: NEG
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 3
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 2
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 3
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 3
35201: PUSH
35202: LD_INT 3
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 2
35211: PUSH
35212: LD_INT 3
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: PUSH
35222: LD_INT 3
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: LD_INT 3
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 1
35241: NEG
35242: PUSH
35243: LD_INT 2
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 3
35252: NEG
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 3
35264: NEG
35265: PUSH
35266: LD_INT 3
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35305: LD_ADDR_VAR 0 43
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: LD_INT 1
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 0
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 1
35386: NEG
35387: PUSH
35388: LD_INT 2
35390: NEG
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: LD_INT 2
35401: NEG
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: NEG
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 2
35471: NEG
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 2
35482: NEG
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: LD_INT 3
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 3
35509: NEG
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 1
35517: PUSH
35518: LD_INT 2
35520: NEG
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 2
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 3
35539: PUSH
35540: LD_INT 0
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 3
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 1
35559: PUSH
35560: LD_INT 3
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: LD_INT 3
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: LD_INT 2
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 2
35590: NEG
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 3
35601: NEG
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 3
35612: NEG
35613: PUSH
35614: LD_INT 1
35616: NEG
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35653: LD_ADDR_VAR 0 44
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 1
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: PUSH
35682: LD_INT 0
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: LD_INT 1
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 1
35711: NEG
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 1
35734: NEG
35735: PUSH
35736: LD_INT 2
35738: NEG
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: LD_INT 1
35749: NEG
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 2
35757: PUSH
35758: LD_INT 0
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 2
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 1
35797: NEG
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 2
35819: NEG
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 2
35831: NEG
35832: PUSH
35833: LD_INT 2
35835: NEG
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: NEG
35844: PUSH
35845: LD_INT 3
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 2
35855: PUSH
35856: LD_INT 1
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 3
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 3
35876: PUSH
35877: LD_INT 1
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 3
35886: PUSH
35887: LD_INT 2
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 3
35896: PUSH
35897: LD_INT 3
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 2
35916: NEG
35917: PUSH
35918: LD_INT 1
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 3
35927: NEG
35928: PUSH
35929: LD_INT 0
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: NEG
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 3
35950: NEG
35951: PUSH
35952: LD_INT 2
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 3
35962: NEG
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36003: LD_ADDR_VAR 0 45
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 0
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 0
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 1
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 0
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 1
36061: NEG
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: NEG
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: LD_INT 1
36084: NEG
36085: PUSH
36086: LD_INT 2
36088: NEG
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 2
36099: NEG
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: PUSH
36108: LD_INT 1
36110: NEG
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 2
36181: NEG
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: LD_INT 3
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: LD_INT 3
36209: NEG
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 3
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 2
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 3
36239: PUSH
36240: LD_INT 2
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 3
36249: PUSH
36250: LD_INT 3
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 3
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 3
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 3
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 2
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 3
36300: NEG
36301: PUSH
36302: LD_INT 2
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 3
36312: NEG
36313: PUSH
36314: LD_INT 3
36316: NEG
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36353: LD_ADDR_VAR 0 46
36357: PUSH
36358: LD_INT 0
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 1
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 1
36391: PUSH
36392: LD_INT 1
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 0
36401: PUSH
36402: LD_INT 1
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 1
36411: NEG
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 1
36422: NEG
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 2
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 2
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 2
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: LD_INT 2
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 2
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 1
36508: NEG
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 2
36530: NEG
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: LD_INT 3
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 3
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 2
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 2
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 3
36597: PUSH
36598: LD_INT 1
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: LD_INT 3
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 0
36617: PUSH
36618: LD_INT 3
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: LD_INT 2
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 2
36638: NEG
36639: PUSH
36640: LD_INT 1
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 3
36649: NEG
36650: PUSH
36651: LD_INT 0
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: NEG
36661: PUSH
36662: LD_INT 1
36664: NEG
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36701: LD_ADDR_VAR 0 47
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 0
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 0
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: LD_INT 2
36797: NEG
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: NEG
36817: PUSH
36818: LD_INT 1
36820: NEG
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: NEG
36829: PUSH
36830: LD_INT 2
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36852: LD_ADDR_VAR 0 48
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: LD_INT 0
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: LD_INT 1
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 0
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: LD_INT 1
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: PUSH
36904: EMPTY
36905: LIST
36906: LIST
36907: PUSH
36908: LD_INT 1
36910: NEG
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: LD_INT 1
36925: NEG
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: NEG
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 2
36967: PUSH
36968: LD_INT 0
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 2
36977: PUSH
36978: LD_INT 1
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: LIST
36989: LIST
36990: LIST
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36999: LD_ADDR_VAR 0 49
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: LD_INT 0
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: LD_INT 0
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 1
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: LD_INT 0
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PUSH
37066: LD_INT 1
37068: NEG
37069: PUSH
37070: LD_INT 1
37072: NEG
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 1
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 2
37091: PUSH
37092: LD_INT 0
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 2
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 2
37111: PUSH
37112: LD_INT 2
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37143: LD_ADDR_VAR 0 50
37147: PUSH
37148: LD_INT 0
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: LD_INT 0
37160: PUSH
37161: LD_INT 1
37163: NEG
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: LD_INT 0
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 1
37201: NEG
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 2
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 2
37234: PUSH
37235: LD_INT 2
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 1
37244: PUSH
37245: LD_INT 2
37247: PUSH
37248: EMPTY
37249: LIST
37250: LIST
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: LD_INT 2
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 1
37264: NEG
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: LIST
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37287: LD_ADDR_VAR 0 51
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: LD_INT 0
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 0
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: LD_INT 1
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: LD_INT 1
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 1
37356: NEG
37357: PUSH
37358: LD_INT 1
37360: NEG
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: LD_INT 2
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 1
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 2
37399: NEG
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 2
37410: NEG
37411: PUSH
37412: LD_INT 1
37414: NEG
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: LIST
37431: LIST
37432: LIST
37433: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37434: LD_ADDR_VAR 0 52
37438: PUSH
37439: LD_INT 0
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 0
37451: PUSH
37452: LD_INT 1
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: LD_INT 0
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 1
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 0
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 0
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: NEG
37528: PUSH
37529: LD_INT 1
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: NEG
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 2
37549: NEG
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 2
37561: NEG
37562: PUSH
37563: LD_INT 2
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37585: LD_ADDR_VAR 0 53
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: LD_INT 0
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 1
37605: NEG
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 1
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 1
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 1
37643: NEG
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: NEG
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: LD_INT 2
37670: NEG
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: LD_INT 2
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 2
37700: PUSH
37701: LD_INT 0
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 2
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 1
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 0
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: NEG
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: NEG
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: NEG
37773: PUSH
37774: LD_INT 1
37776: NEG
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 2
37784: NEG
37785: PUSH
37786: LD_INT 2
37788: NEG
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37815: LD_ADDR_VAR 0 54
37819: PUSH
37820: LD_INT 0
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 1
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 0
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 1
37873: NEG
37874: PUSH
37875: LD_INT 0
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 1
37884: NEG
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 1
37896: NEG
37897: PUSH
37898: LD_INT 2
37900: NEG
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 0
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: LD_INT 1
37922: NEG
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 2
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 1
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 2
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 0
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: NEG
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 2
38002: NEG
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 2
38014: NEG
38015: PUSH
38016: LD_INT 2
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38045: LD_ADDR_VAR 0 55
38049: PUSH
38050: LD_INT 0
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: EMPTY
38057: LIST
38058: LIST
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 1
38065: NEG
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 1
38103: NEG
38104: PUSH
38105: LD_INT 0
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: LD_INT 1
38118: NEG
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 1
38126: NEG
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 2
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: PUSH
38150: LD_INT 1
38152: NEG
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PUSH
38158: LD_INT 2
38160: PUSH
38161: LD_INT 0
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 2
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 1
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: NEG
38211: PUSH
38212: LD_INT 1
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 2
38221: NEG
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: LD_INT 1
38236: NEG
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 2
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38275: LD_ADDR_VAR 0 56
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: LD_INT 0
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 1
38344: NEG
38345: PUSH
38346: LD_INT 1
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 1
38356: NEG
38357: PUSH
38358: LD_INT 2
38360: NEG
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 0
38368: PUSH
38369: LD_INT 2
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 1
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: NEG
38441: PUSH
38442: LD_INT 1
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 2
38451: NEG
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 2
38462: NEG
38463: PUSH
38464: LD_INT 1
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 2
38474: NEG
38475: PUSH
38476: LD_INT 2
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38505: LD_ADDR_VAR 0 57
38509: PUSH
38510: LD_INT 0
38512: PUSH
38513: LD_INT 0
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: NEG
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 1
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 0
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 1
38563: NEG
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 1
38574: NEG
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 1
38586: NEG
38587: PUSH
38588: LD_INT 2
38590: NEG
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 0
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: LD_INT 1
38612: NEG
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: PUSH
38621: LD_INT 0
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 2
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38735: LD_ADDR_VAR 0 58
38739: PUSH
38740: LD_INT 0
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 1
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 0
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 1
38793: NEG
38794: PUSH
38795: LD_INT 0
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 1
38804: NEG
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: LD_INT 2
38820: NEG
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 0
38828: PUSH
38829: LD_INT 2
38831: NEG
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: LD_INT 1
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 2
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 2
38860: PUSH
38861: LD_INT 1
38863: PUSH
38864: EMPTY
38865: LIST
38866: LIST
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: LD_INT 2
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: LD_INT 2
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 1
38900: NEG
38901: PUSH
38902: LD_INT 1
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 2
38922: NEG
38923: PUSH
38924: LD_INT 1
38926: NEG
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 2
38934: NEG
38935: PUSH
38936: LD_INT 2
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: LIST
38948: LIST
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38965: LD_ADDR_VAR 0 59
38969: PUSH
38970: LD_INT 0
38972: PUSH
38973: LD_INT 0
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 0
38982: PUSH
38983: LD_INT 1
38985: NEG
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: LD_INT 1
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 0
39013: PUSH
39014: LD_INT 1
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 1
39023: NEG
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 1
39034: NEG
39035: PUSH
39036: LD_INT 1
39038: NEG
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39053: LD_ADDR_VAR 0 60
39057: PUSH
39058: LD_INT 0
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 1
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 0
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 1
39122: NEG
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: LIST
39137: LIST
39138: LIST
39139: LIST
39140: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39141: LD_ADDR_VAR 0 61
39145: PUSH
39146: LD_INT 0
39148: PUSH
39149: LD_INT 0
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 0
39158: PUSH
39159: LD_INT 1
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: PUSH
39170: LD_INT 0
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 1
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 0
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 1
39199: NEG
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: LD_INT 1
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39229: LD_ADDR_VAR 0 62
39233: PUSH
39234: LD_INT 0
39236: PUSH
39237: LD_INT 0
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: LD_INT 1
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: LD_INT 1
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 1
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: LD_INT 0
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 1
39298: NEG
39299: PUSH
39300: LD_INT 1
39302: NEG
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39317: LD_ADDR_VAR 0 63
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 1
39345: PUSH
39346: LD_INT 0
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: PUSH
39356: LD_INT 1
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: LD_INT 1
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 0
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: NEG
39387: PUSH
39388: LD_INT 1
39390: NEG
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39405: LD_ADDR_VAR 0 64
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: LD_INT 1
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: LIST
39488: LIST
39489: LIST
39490: LIST
39491: LIST
39492: ST_TO_ADDR
// end ; 1 :
39493: GO 45390
39495: LD_INT 1
39497: DOUBLE
39498: EQUAL
39499: IFTRUE 39503
39501: GO 42126
39503: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39504: LD_ADDR_VAR 0 11
39508: PUSH
39509: LD_INT 1
39511: NEG
39512: PUSH
39513: LD_INT 3
39515: NEG
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 0
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 1
39534: PUSH
39535: LD_INT 2
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39548: LD_ADDR_VAR 0 12
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 3
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 3
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: LIST
39588: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39589: LD_ADDR_VAR 0 13
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 3
39606: PUSH
39607: LD_INT 3
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 3
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: LIST
39628: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39629: LD_ADDR_VAR 0 14
39633: PUSH
39634: LD_INT 1
39636: PUSH
39637: LD_INT 3
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: LD_INT 3
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 1
39656: NEG
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: LIST
39669: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39670: LD_ADDR_VAR 0 15
39674: PUSH
39675: LD_INT 2
39677: NEG
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 3
39688: NEG
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: NEG
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: LIST
39713: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39714: LD_ADDR_VAR 0 16
39718: PUSH
39719: LD_INT 2
39721: NEG
39722: PUSH
39723: LD_INT 3
39725: NEG
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 3
39733: NEG
39734: PUSH
39735: LD_INT 2
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 3
39745: NEG
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: LIST
39759: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39760: LD_ADDR_VAR 0 17
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: LD_INT 3
39771: NEG
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 0
39779: PUSH
39780: LD_INT 3
39782: NEG
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 1
39790: PUSH
39791: LD_INT 2
39793: NEG
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: LIST
39803: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39804: LD_ADDR_VAR 0 18
39808: PUSH
39809: LD_INT 2
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 3
39822: PUSH
39823: LD_INT 0
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 3
39832: PUSH
39833: LD_INT 1
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: LIST
39844: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39845: LD_ADDR_VAR 0 19
39849: PUSH
39850: LD_INT 3
39852: PUSH
39853: LD_INT 2
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: LD_INT 3
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 2
39872: PUSH
39873: LD_INT 3
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: LIST
39884: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39885: LD_ADDR_VAR 0 20
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: LD_INT 3
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: LD_INT 3
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 1
39912: NEG
39913: PUSH
39914: LD_INT 2
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39926: LD_ADDR_VAR 0 21
39930: PUSH
39931: LD_INT 2
39933: NEG
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 3
39944: NEG
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 3
39955: NEG
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: LIST
39969: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39970: LD_ADDR_VAR 0 22
39974: PUSH
39975: LD_INT 2
39977: NEG
39978: PUSH
39979: LD_INT 3
39981: NEG
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 3
39989: NEG
39990: PUSH
39991: LD_INT 2
39993: NEG
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 3
40001: NEG
40002: PUSH
40003: LD_INT 3
40005: NEG
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: LIST
40015: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40016: LD_ADDR_VAR 0 23
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 3
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 1
40034: NEG
40035: PUSH
40036: LD_INT 4
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: LD_INT 3
40049: NEG
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: LIST
40059: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40060: LD_ADDR_VAR 0 24
40064: PUSH
40065: LD_INT 3
40067: PUSH
40068: LD_INT 0
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 3
40077: PUSH
40078: LD_INT 1
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 4
40088: PUSH
40089: LD_INT 1
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: LIST
40100: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40101: LD_ADDR_VAR 0 25
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: LD_INT 3
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 4
40118: PUSH
40119: LD_INT 3
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 3
40128: PUSH
40129: LD_INT 4
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: LIST
40140: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40141: LD_ADDR_VAR 0 26
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: LD_INT 3
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 4
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: NEG
40169: PUSH
40170: LD_INT 3
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: LIST
40181: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40182: LD_ADDR_VAR 0 27
40186: PUSH
40187: LD_INT 3
40189: NEG
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 3
40200: NEG
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: LIST
40225: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40226: LD_ADDR_VAR 0 28
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: LD_INT 3
40237: NEG
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: NEG
40246: PUSH
40247: LD_INT 4
40249: NEG
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 4
40257: NEG
40258: PUSH
40259: LD_INT 3
40261: NEG
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: LIST
40271: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40272: LD_ADDR_VAR 0 29
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 3
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 0
40291: PUSH
40292: LD_INT 3
40294: NEG
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 1
40313: NEG
40314: PUSH
40315: LD_INT 4
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: LD_INT 4
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 1
40336: PUSH
40337: LD_INT 3
40339: NEG
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 1
40347: NEG
40348: PUSH
40349: LD_INT 5
40351: NEG
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: LD_INT 5
40362: NEG
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 1
40370: PUSH
40371: LD_INT 4
40373: NEG
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: LD_INT 1
40381: NEG
40382: PUSH
40383: LD_INT 6
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_INT 6
40396: NEG
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40427: LD_ADDR_VAR 0 30
40431: PUSH
40432: LD_INT 2
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 3
40445: PUSH
40446: LD_INT 0
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: PUSH
40456: LD_INT 1
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 3
40465: PUSH
40466: LD_INT 1
40468: NEG
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 4
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 4
40486: PUSH
40487: LD_INT 1
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 4
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 5
40507: PUSH
40508: LD_INT 0
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 5
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 5
40527: PUSH
40528: LD_INT 1
40530: NEG
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 6
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 6
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40570: LD_ADDR_VAR 0 31
40574: PUSH
40575: LD_INT 3
40577: PUSH
40578: LD_INT 2
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 3
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 2
40597: PUSH
40598: LD_INT 3
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: LD_INT 3
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 4
40617: PUSH
40618: LD_INT 4
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 4
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 5
40637: PUSH
40638: LD_INT 4
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 5
40647: PUSH
40648: LD_INT 5
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 4
40657: PUSH
40658: LD_INT 5
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 6
40667: PUSH
40668: LD_INT 5
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 6
40677: PUSH
40678: LD_INT 6
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 5
40687: PUSH
40688: LD_INT 6
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40709: LD_ADDR_VAR 0 32
40713: PUSH
40714: LD_INT 1
40716: PUSH
40717: LD_INT 3
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: LD_INT 3
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 1
40736: NEG
40737: PUSH
40738: LD_INT 2
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: LD_INT 4
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_INT 4
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: LD_INT 3
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: LD_INT 5
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: LD_INT 5
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 1
40798: NEG
40799: PUSH
40800: LD_INT 4
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 1
40809: PUSH
40810: LD_INT 6
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 6
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 1
40829: NEG
40830: PUSH
40831: LD_INT 5
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40852: LD_ADDR_VAR 0 33
40856: PUSH
40857: LD_INT 2
40859: NEG
40860: PUSH
40861: LD_INT 1
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 3
40870: NEG
40871: PUSH
40872: LD_INT 0
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 3
40893: NEG
40894: PUSH
40895: LD_INT 1
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 4
40904: NEG
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 4
40915: NEG
40916: PUSH
40917: LD_INT 1
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 4
40927: NEG
40928: PUSH
40929: LD_INT 1
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 5
40938: NEG
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 5
40949: NEG
40950: PUSH
40951: LD_INT 1
40953: NEG
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 5
40961: NEG
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: LD_INT 0
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 6
40983: NEG
40984: PUSH
40985: LD_INT 1
40987: NEG
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41007: LD_ADDR_VAR 0 34
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: LD_INT 3
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 3
41026: NEG
41027: PUSH
41028: LD_INT 2
41030: NEG
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 3
41038: NEG
41039: PUSH
41040: LD_INT 3
41042: NEG
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 3
41050: NEG
41051: PUSH
41052: LD_INT 4
41054: NEG
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 3
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 4
41074: NEG
41075: PUSH
41076: LD_INT 4
41078: NEG
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 4
41086: NEG
41087: PUSH
41088: LD_INT 5
41090: NEG
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 5
41098: NEG
41099: PUSH
41100: LD_INT 4
41102: NEG
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 5
41110: NEG
41111: PUSH
41112: LD_INT 5
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 5
41122: NEG
41123: PUSH
41124: LD_INT 6
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 6
41134: NEG
41135: PUSH
41136: LD_INT 5
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 6
41146: NEG
41147: PUSH
41148: LD_INT 6
41150: NEG
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: LIST
41169: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41170: LD_ADDR_VAR 0 41
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: LD_INT 2
41180: NEG
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: LD_INT 3
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 1
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: LIST
41213: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41214: LD_ADDR_VAR 0 42
41218: PUSH
41219: LD_INT 2
41221: PUSH
41222: LD_INT 0
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PUSH
41229: LD_INT 2
41231: PUSH
41232: LD_INT 1
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 3
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: LIST
41254: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41255: LD_ADDR_VAR 0 43
41259: PUSH
41260: LD_INT 2
41262: PUSH
41263: LD_INT 2
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 3
41272: PUSH
41273: LD_INT 2
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: LD_INT 3
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: LIST
41294: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41295: LD_ADDR_VAR 0 44
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: LD_INT 2
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: LD_INT 3
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 1
41322: NEG
41323: PUSH
41324: LD_INT 2
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: LIST
41335: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41336: LD_ADDR_VAR 0 45
41340: PUSH
41341: LD_INT 2
41343: NEG
41344: PUSH
41345: LD_INT 0
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 2
41354: NEG
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 3
41365: NEG
41366: PUSH
41367: LD_INT 1
41369: NEG
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: LIST
41379: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41380: LD_ADDR_VAR 0 46
41384: PUSH
41385: LD_INT 2
41387: NEG
41388: PUSH
41389: LD_INT 2
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 2
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 3
41411: NEG
41412: PUSH
41413: LD_INT 2
41415: NEG
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: LIST
41425: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41426: LD_ADDR_VAR 0 47
41430: PUSH
41431: LD_INT 2
41433: NEG
41434: PUSH
41435: LD_INT 3
41437: NEG
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 1
41445: NEG
41446: PUSH
41447: LD_INT 3
41449: NEG
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41459: LD_ADDR_VAR 0 48
41463: PUSH
41464: LD_INT 1
41466: PUSH
41467: LD_INT 2
41469: NEG
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 2
41477: PUSH
41478: LD_INT 1
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41490: LD_ADDR_VAR 0 49
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: LD_INT 1
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: LD_INT 2
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41519: LD_ADDR_VAR 0 50
41523: PUSH
41524: LD_INT 2
41526: PUSH
41527: LD_INT 3
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: PUSH
41537: LD_INT 3
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41548: LD_ADDR_VAR 0 51
41552: PUSH
41553: LD_INT 1
41555: NEG
41556: PUSH
41557: LD_INT 2
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 2
41566: NEG
41567: PUSH
41568: LD_INT 1
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41579: LD_ADDR_VAR 0 52
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: LD_INT 1
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 3
41598: NEG
41599: PUSH
41600: LD_INT 2
41602: NEG
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41612: LD_ADDR_VAR 0 53
41616: PUSH
41617: LD_INT 1
41619: NEG
41620: PUSH
41621: LD_INT 3
41623: NEG
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: PUSH
41629: LD_INT 0
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: LD_INT 2
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: LIST
41655: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41656: LD_ADDR_VAR 0 54
41660: PUSH
41661: LD_INT 2
41663: PUSH
41664: LD_INT 1
41666: NEG
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 3
41674: PUSH
41675: LD_INT 0
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 3
41684: PUSH
41685: LD_INT 1
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: LIST
41696: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41697: LD_ADDR_VAR 0 55
41701: PUSH
41702: LD_INT 3
41704: PUSH
41705: LD_INT 2
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 3
41714: PUSH
41715: LD_INT 3
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 2
41724: PUSH
41725: LD_INT 3
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: LIST
41736: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41737: LD_ADDR_VAR 0 56
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: LD_INT 3
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 0
41754: PUSH
41755: LD_INT 3
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 1
41764: NEG
41765: PUSH
41766: LD_INT 2
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: LIST
41777: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41778: LD_ADDR_VAR 0 57
41782: PUSH
41783: LD_INT 2
41785: NEG
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 3
41807: NEG
41808: PUSH
41809: LD_INT 1
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: LIST
41821: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41822: LD_ADDR_VAR 0 58
41826: PUSH
41827: LD_INT 2
41829: NEG
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: LD_INT 2
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: LD_INT 3
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: LIST
41867: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41868: LD_ADDR_VAR 0 59
41872: PUSH
41873: LD_INT 1
41875: NEG
41876: PUSH
41877: LD_INT 2
41879: NEG
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 0
41887: PUSH
41888: LD_INT 2
41890: NEG
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 1
41898: PUSH
41899: LD_INT 1
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: LIST
41911: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41912: LD_ADDR_VAR 0 60
41916: PUSH
41917: LD_INT 1
41919: PUSH
41920: LD_INT 1
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: LD_INT 1
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: LIST
41952: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41953: LD_ADDR_VAR 0 61
41957: PUSH
41958: LD_INT 2
41960: PUSH
41961: LD_INT 1
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 2
41970: PUSH
41971: LD_INT 2
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 1
41980: PUSH
41981: LD_INT 2
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: LIST
41992: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41993: LD_ADDR_VAR 0 62
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 2
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 2
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 1
42020: NEG
42021: PUSH
42022: LD_INT 1
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42034: LD_ADDR_VAR 0 63
42038: PUSH
42039: LD_INT 1
42041: NEG
42042: PUSH
42043: LD_INT 1
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 2
42052: NEG
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 2
42063: NEG
42064: PUSH
42065: LD_INT 1
42067: NEG
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: EMPTY
42074: LIST
42075: LIST
42076: LIST
42077: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42078: LD_ADDR_VAR 0 64
42082: PUSH
42083: LD_INT 1
42085: NEG
42086: PUSH
42087: LD_INT 2
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 2
42097: NEG
42098: PUSH
42099: LD_INT 1
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 2
42109: NEG
42110: PUSH
42111: LD_INT 2
42113: NEG
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: LIST
42123: ST_TO_ADDR
// end ; 2 :
42124: GO 45390
42126: LD_INT 2
42128: DOUBLE
42129: EQUAL
42130: IFTRUE 42134
42132: GO 45389
42134: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42135: LD_ADDR_VAR 0 29
42139: PUSH
42140: LD_INT 4
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 4
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 5
42163: PUSH
42164: LD_INT 0
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: LD_INT 1
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 4
42183: PUSH
42184: LD_INT 1
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 3
42193: PUSH
42194: LD_INT 0
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 3
42203: PUSH
42204: LD_INT 1
42206: NEG
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 2
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 5
42225: PUSH
42226: LD_INT 2
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 3
42235: PUSH
42236: LD_INT 3
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 2
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 4
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: PUSH
42266: LD_INT 4
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 3
42275: PUSH
42276: LD_INT 4
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 2
42285: PUSH
42286: LD_INT 3
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 2
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 4
42305: PUSH
42306: LD_INT 2
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 2
42315: PUSH
42316: LD_INT 4
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 0
42325: PUSH
42326: LD_INT 4
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 0
42335: PUSH
42336: LD_INT 3
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 1
42345: PUSH
42346: LD_INT 4
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: LD_INT 5
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 0
42365: PUSH
42366: LD_INT 5
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 1
42375: NEG
42376: PUSH
42377: LD_INT 4
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 1
42386: NEG
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 2
42397: PUSH
42398: LD_INT 5
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 2
42407: NEG
42408: PUSH
42409: LD_INT 3
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 3
42418: NEG
42419: PUSH
42420: LD_INT 0
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 3
42429: NEG
42430: PUSH
42431: LD_INT 1
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 2
42452: NEG
42453: PUSH
42454: LD_INT 1
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 3
42463: NEG
42464: PUSH
42465: LD_INT 1
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: LD_INT 4
42474: NEG
42475: PUSH
42476: LD_INT 0
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 4
42485: NEG
42486: PUSH
42487: LD_INT 1
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 4
42497: NEG
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: LD_INT 2
42509: NEG
42510: PUSH
42511: LD_INT 2
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 4
42520: NEG
42521: PUSH
42522: LD_INT 4
42524: NEG
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 4
42532: NEG
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: LD_INT 3
42544: NEG
42545: PUSH
42546: LD_INT 4
42548: NEG
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 3
42556: NEG
42557: PUSH
42558: LD_INT 3
42560: NEG
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 4
42568: NEG
42569: PUSH
42570: LD_INT 3
42572: NEG
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 5
42580: NEG
42581: PUSH
42582: LD_INT 4
42584: NEG
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: LD_INT 5
42592: NEG
42593: PUSH
42594: LD_INT 5
42596: NEG
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 3
42604: NEG
42605: PUSH
42606: LD_INT 5
42608: NEG
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 5
42616: NEG
42617: PUSH
42618: LD_INT 3
42620: NEG
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: LIST
42633: LIST
42634: LIST
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: LIST
42648: LIST
42649: LIST
42650: LIST
42651: LIST
42652: LIST
42653: LIST
42654: LIST
42655: LIST
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42673: LD_ADDR_VAR 0 30
42677: PUSH
42678: LD_INT 4
42680: PUSH
42681: LD_INT 4
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 4
42690: PUSH
42691: LD_INT 3
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 5
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: PUSH
42711: LD_INT 5
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 4
42720: PUSH
42721: LD_INT 5
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 3
42730: PUSH
42731: LD_INT 4
42733: PUSH
42734: EMPTY
42735: LIST
42736: LIST
42737: PUSH
42738: LD_INT 3
42740: PUSH
42741: LD_INT 3
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 5
42750: PUSH
42751: LD_INT 3
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: LD_INT 3
42760: PUSH
42761: LD_INT 5
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 0
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 0
42780: PUSH
42781: LD_INT 2
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 1
42790: PUSH
42791: LD_INT 3
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: LD_INT 1
42800: PUSH
42801: LD_INT 4
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: LD_INT 4
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 1
42820: NEG
42821: PUSH
42822: LD_INT 3
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: NEG
42832: PUSH
42833: LD_INT 2
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: LD_INT 2
42842: PUSH
42843: LD_INT 4
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 2
42852: NEG
42853: PUSH
42854: LD_INT 2
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 4
42863: NEG
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: LD_INT 4
42874: NEG
42875: PUSH
42876: LD_INT 1
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 3
42886: NEG
42887: PUSH
42888: LD_INT 0
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 3
42897: NEG
42898: PUSH
42899: LD_INT 1
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 4
42908: NEG
42909: PUSH
42910: LD_INT 1
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 5
42919: NEG
42920: PUSH
42921: LD_INT 0
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 5
42930: NEG
42931: PUSH
42932: LD_INT 1
42934: NEG
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 5
42942: NEG
42943: PUSH
42944: LD_INT 2
42946: NEG
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 3
42954: NEG
42955: PUSH
42956: LD_INT 2
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 3
42965: NEG
42966: PUSH
42967: LD_INT 3
42969: NEG
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 3
42977: NEG
42978: PUSH
42979: LD_INT 4
42981: NEG
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 2
42989: NEG
42990: PUSH
42991: LD_INT 3
42993: NEG
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 2
43001: NEG
43002: PUSH
43003: LD_INT 2
43005: NEG
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: LD_INT 3
43013: NEG
43014: PUSH
43015: LD_INT 2
43017: NEG
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 4
43025: NEG
43026: PUSH
43027: LD_INT 3
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 4
43037: NEG
43038: PUSH
43039: LD_INT 4
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 2
43049: NEG
43050: PUSH
43051: LD_INT 4
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 4
43061: NEG
43062: PUSH
43063: LD_INT 2
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 0
43084: PUSH
43085: LD_INT 5
43087: NEG
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 1
43095: PUSH
43096: LD_INT 4
43098: NEG
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 1
43106: PUSH
43107: LD_INT 3
43109: NEG
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: LD_INT 3
43120: NEG
43121: PUSH
43122: EMPTY
43123: LIST
43124: LIST
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 4
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: LD_INT 5
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 2
43152: PUSH
43153: LD_INT 3
43155: NEG
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: PUSH
43161: LD_INT 2
43163: NEG
43164: PUSH
43165: LD_INT 5
43167: NEG
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: LIST
43192: LIST
43193: LIST
43194: LIST
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: LIST
43202: LIST
43203: LIST
43204: LIST
43205: LIST
43206: LIST
43207: LIST
43208: LIST
43209: LIST
43210: LIST
43211: LIST
43212: LIST
43213: LIST
43214: LIST
43215: LIST
43216: LIST
43217: LIST
43218: LIST
43219: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43220: LD_ADDR_VAR 0 31
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: LD_INT 4
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 0
43237: PUSH
43238: LD_INT 3
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 1
43247: PUSH
43248: LD_INT 4
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 1
43257: PUSH
43258: LD_INT 5
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 0
43267: PUSH
43268: LD_INT 5
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 1
43277: NEG
43278: PUSH
43279: LD_INT 4
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 1
43288: NEG
43289: PUSH
43290: LD_INT 3
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 2
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: EMPTY
43304: LIST
43305: LIST
43306: PUSH
43307: LD_INT 2
43309: NEG
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 3
43320: NEG
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: LD_INT 3
43331: NEG
43332: PUSH
43333: LD_INT 1
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 2
43343: NEG
43344: PUSH
43345: LD_INT 0
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 2
43354: NEG
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 3
43365: NEG
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 4
43376: NEG
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 4
43387: NEG
43388: PUSH
43389: LD_INT 1
43391: NEG
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 4
43399: NEG
43400: PUSH
43401: LD_INT 2
43403: NEG
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 2
43411: NEG
43412: PUSH
43413: LD_INT 2
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: NEG
43423: PUSH
43424: LD_INT 4
43426: NEG
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 4
43434: NEG
43435: PUSH
43436: LD_INT 5
43438: NEG
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 3
43446: NEG
43447: PUSH
43448: LD_INT 4
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 3
43458: NEG
43459: PUSH
43460: LD_INT 3
43462: NEG
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 4
43470: NEG
43471: PUSH
43472: LD_INT 3
43474: NEG
43475: PUSH
43476: EMPTY
43477: LIST
43478: LIST
43479: PUSH
43480: LD_INT 5
43482: NEG
43483: PUSH
43484: LD_INT 4
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: NEG
43495: PUSH
43496: LD_INT 5
43498: NEG
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: NEG
43507: PUSH
43508: LD_INT 5
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 5
43518: NEG
43519: PUSH
43520: LD_INT 3
43522: NEG
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 0
43530: PUSH
43531: LD_INT 3
43533: NEG
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 0
43541: PUSH
43542: LD_INT 4
43544: NEG
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: LD_INT 1
43552: PUSH
43553: LD_INT 3
43555: NEG
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: LD_INT 2
43566: NEG
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: LD_INT 2
43577: NEG
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PUSH
43583: LD_INT 1
43585: NEG
43586: PUSH
43587: LD_INT 3
43589: NEG
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 1
43597: NEG
43598: PUSH
43599: LD_INT 4
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 2
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 2
43620: NEG
43621: PUSH
43622: LD_INT 4
43624: NEG
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: LD_INT 0
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PUSH
43640: LD_INT 4
43642: PUSH
43643: LD_INT 1
43645: NEG
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 5
43653: PUSH
43654: LD_INT 0
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 5
43663: PUSH
43664: LD_INT 1
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 4
43673: PUSH
43674: LD_INT 1
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 3
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 3
43693: PUSH
43694: LD_INT 1
43696: NEG
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 3
43704: PUSH
43705: LD_INT 2
43707: NEG
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 5
43715: PUSH
43716: LD_INT 2
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: EMPTY
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: LIST
43753: LIST
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: LIST
43762: LIST
43763: LIST
43764: LIST
43765: LIST
43766: LIST
43767: LIST
43768: LIST
43769: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43770: LD_ADDR_VAR 0 32
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 4
43788: NEG
43789: PUSH
43790: LD_INT 1
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: NEG
43801: PUSH
43802: LD_INT 0
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 3
43811: NEG
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 4
43822: NEG
43823: PUSH
43824: LD_INT 1
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 5
43833: NEG
43834: PUSH
43835: LD_INT 0
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 5
43844: NEG
43845: PUSH
43846: LD_INT 1
43848: NEG
43849: PUSH
43850: EMPTY
43851: LIST
43852: LIST
43853: PUSH
43854: LD_INT 5
43856: NEG
43857: PUSH
43858: LD_INT 2
43860: NEG
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 3
43868: NEG
43869: PUSH
43870: LD_INT 2
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: NEG
43880: PUSH
43881: LD_INT 3
43883: NEG
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 3
43891: NEG
43892: PUSH
43893: LD_INT 4
43895: NEG
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 2
43903: NEG
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 2
43915: NEG
43916: PUSH
43917: LD_INT 2
43919: NEG
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: PUSH
43925: LD_INT 3
43927: NEG
43928: PUSH
43929: LD_INT 2
43931: NEG
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 4
43939: NEG
43940: PUSH
43941: LD_INT 3
43943: NEG
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 4
43951: NEG
43952: PUSH
43953: LD_INT 4
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 2
43963: NEG
43964: PUSH
43965: LD_INT 4
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 4
43975: NEG
43976: PUSH
43977: LD_INT 2
43979: NEG
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 0
43987: PUSH
43988: LD_INT 4
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 0
43998: PUSH
43999: LD_INT 5
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: PUSH
44010: LD_INT 4
44012: NEG
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 1
44020: PUSH
44021: LD_INT 3
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 3
44034: NEG
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 1
44042: NEG
44043: PUSH
44044: LD_INT 4
44046: NEG
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 1
44054: NEG
44055: PUSH
44056: LD_INT 5
44058: NEG
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 2
44066: PUSH
44067: LD_INT 3
44069: NEG
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 2
44077: NEG
44078: PUSH
44079: LD_INT 5
44081: NEG
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 3
44089: PUSH
44090: LD_INT 0
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: LD_INT 3
44099: PUSH
44100: LD_INT 1
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 4
44110: PUSH
44111: LD_INT 0
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 4
44120: PUSH
44121: LD_INT 1
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: LD_INT 3
44130: PUSH
44131: LD_INT 1
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 2
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 2
44150: PUSH
44151: LD_INT 1
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 2
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 4
44172: PUSH
44173: LD_INT 2
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 4
44182: PUSH
44183: LD_INT 4
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 4
44192: PUSH
44193: LD_INT 3
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 5
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 5
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 4
44222: PUSH
44223: LD_INT 5
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 3
44232: PUSH
44233: LD_INT 4
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 3
44242: PUSH
44243: LD_INT 3
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 5
44252: PUSH
44253: LD_INT 3
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 3
44262: PUSH
44263: LD_INT 5
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: LIST
44300: LIST
44301: LIST
44302: LIST
44303: LIST
44304: LIST
44305: LIST
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: LIST
44311: LIST
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44317: LD_ADDR_VAR 0 33
44321: PUSH
44322: LD_INT 4
44324: NEG
44325: PUSH
44326: LD_INT 4
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 4
44336: NEG
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 3
44348: NEG
44349: PUSH
44350: LD_INT 4
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 3
44360: NEG
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: NEG
44373: PUSH
44374: LD_INT 3
44376: NEG
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 5
44384: NEG
44385: PUSH
44386: LD_INT 4
44388: NEG
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 5
44396: NEG
44397: PUSH
44398: LD_INT 5
44400: NEG
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 3
44408: NEG
44409: PUSH
44410: LD_INT 5
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 5
44420: NEG
44421: PUSH
44422: LD_INT 3
44424: NEG
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: LD_INT 3
44435: NEG
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 0
44443: PUSH
44444: LD_INT 4
44446: NEG
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 1
44454: PUSH
44455: LD_INT 3
44457: NEG
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: LD_INT 2
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 0
44476: PUSH
44477: LD_INT 2
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 1
44487: NEG
44488: PUSH
44489: LD_INT 3
44491: NEG
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PUSH
44497: LD_INT 1
44499: NEG
44500: PUSH
44501: LD_INT 4
44503: NEG
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 2
44511: PUSH
44512: LD_INT 2
44514: NEG
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 2
44522: NEG
44523: PUSH
44524: LD_INT 4
44526: NEG
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 4
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 4
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: LD_INT 0
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 5
44565: PUSH
44566: LD_INT 1
44568: PUSH
44569: EMPTY
44570: LIST
44571: LIST
44572: PUSH
44573: LD_INT 4
44575: PUSH
44576: LD_INT 1
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 3
44585: PUSH
44586: LD_INT 0
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 3
44595: PUSH
44596: LD_INT 1
44598: NEG
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 3
44606: PUSH
44607: LD_INT 2
44609: NEG
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: PUSH
44615: LD_INT 5
44617: PUSH
44618: LD_INT 2
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 3
44627: PUSH
44628: LD_INT 3
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 3
44637: PUSH
44638: LD_INT 2
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 4
44647: PUSH
44648: LD_INT 3
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 4
44657: PUSH
44658: LD_INT 4
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 3
44667: PUSH
44668: LD_INT 4
44670: PUSH
44671: EMPTY
44672: LIST
44673: LIST
44674: PUSH
44675: LD_INT 2
44677: PUSH
44678: LD_INT 3
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 2
44687: PUSH
44688: LD_INT 2
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 4
44697: PUSH
44698: LD_INT 2
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 2
44707: PUSH
44708: LD_INT 4
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 0
44717: PUSH
44718: LD_INT 4
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 0
44727: PUSH
44728: LD_INT 3
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 1
44737: PUSH
44738: LD_INT 4
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 1
44747: PUSH
44748: LD_INT 5
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 0
44757: PUSH
44758: LD_INT 5
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 1
44767: NEG
44768: PUSH
44769: LD_INT 4
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 1
44778: NEG
44779: PUSH
44780: LD_INT 3
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 2
44789: PUSH
44790: LD_INT 5
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 2
44799: NEG
44800: PUSH
44801: LD_INT 3
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: LIST
44847: LIST
44848: LIST
44849: LIST
44850: LIST
44851: LIST
44852: LIST
44853: LIST
44854: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44855: LD_ADDR_VAR 0 34
44859: PUSH
44860: LD_INT 0
44862: PUSH
44863: LD_INT 4
44865: NEG
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 0
44873: PUSH
44874: LD_INT 5
44876: NEG
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 1
44884: PUSH
44885: LD_INT 4
44887: NEG
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 1
44895: PUSH
44896: LD_INT 3
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 0
44906: PUSH
44907: LD_INT 3
44909: NEG
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 1
44917: NEG
44918: PUSH
44919: LD_INT 4
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 1
44929: NEG
44930: PUSH
44931: LD_INT 5
44933: NEG
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 2
44941: PUSH
44942: LD_INT 3
44944: NEG
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 2
44952: NEG
44953: PUSH
44954: LD_INT 5
44956: NEG
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 3
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: LD_INT 4
44985: PUSH
44986: LD_INT 0
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: LD_INT 1
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 3
45005: PUSH
45006: LD_INT 1
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 0
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 2
45025: PUSH
45026: LD_INT 1
45028: NEG
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 2
45036: PUSH
45037: LD_INT 2
45039: NEG
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 4
45057: PUSH
45058: LD_INT 4
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 4
45067: PUSH
45068: LD_INT 3
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: PUSH
45075: LD_INT 5
45077: PUSH
45078: LD_INT 4
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: PUSH
45088: LD_INT 5
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 4
45097: PUSH
45098: LD_INT 5
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 3
45107: PUSH
45108: LD_INT 4
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 3
45117: PUSH
45118: LD_INT 3
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 5
45127: PUSH
45128: LD_INT 3
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 3
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 0
45147: PUSH
45148: LD_INT 3
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 0
45157: PUSH
45158: LD_INT 2
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 1
45167: PUSH
45168: LD_INT 3
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 1
45177: PUSH
45178: LD_INT 4
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 4
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 1
45197: NEG
45198: PUSH
45199: LD_INT 3
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 1
45208: NEG
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 2
45219: PUSH
45220: LD_INT 4
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: NEG
45230: PUSH
45231: LD_INT 2
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 4
45240: NEG
45241: PUSH
45242: LD_INT 0
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 4
45251: NEG
45252: PUSH
45253: LD_INT 1
45255: NEG
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 3
45263: NEG
45264: PUSH
45265: LD_INT 0
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 3
45274: NEG
45275: PUSH
45276: LD_INT 1
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 4
45285: NEG
45286: PUSH
45287: LD_INT 1
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 5
45296: NEG
45297: PUSH
45298: LD_INT 0
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 5
45307: NEG
45308: PUSH
45309: LD_INT 1
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 5
45319: NEG
45320: PUSH
45321: LD_INT 2
45323: NEG
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 3
45331: NEG
45332: PUSH
45333: LD_INT 2
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: ST_TO_ADDR
// end ; end ;
45387: GO 45390
45389: POP
// case btype of b_depot , b_warehouse :
45390: LD_VAR 0 1
45394: PUSH
45395: LD_INT 0
45397: DOUBLE
45398: EQUAL
45399: IFTRUE 45409
45401: LD_INT 1
45403: DOUBLE
45404: EQUAL
45405: IFTRUE 45409
45407: GO 45610
45409: POP
// case nation of nation_american :
45410: LD_VAR 0 5
45414: PUSH
45415: LD_INT 1
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45423
45421: GO 45479
45423: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45424: LD_ADDR_VAR 0 9
45428: PUSH
45429: LD_VAR 0 11
45433: PUSH
45434: LD_VAR 0 12
45438: PUSH
45439: LD_VAR 0 13
45443: PUSH
45444: LD_VAR 0 14
45448: PUSH
45449: LD_VAR 0 15
45453: PUSH
45454: LD_VAR 0 16
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: PUSH
45467: LD_VAR 0 4
45471: PUSH
45472: LD_INT 1
45474: PLUS
45475: ARRAY
45476: ST_TO_ADDR
45477: GO 45608
45479: LD_INT 2
45481: DOUBLE
45482: EQUAL
45483: IFTRUE 45487
45485: GO 45543
45487: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45488: LD_ADDR_VAR 0 9
45492: PUSH
45493: LD_VAR 0 17
45497: PUSH
45498: LD_VAR 0 18
45502: PUSH
45503: LD_VAR 0 19
45507: PUSH
45508: LD_VAR 0 20
45512: PUSH
45513: LD_VAR 0 21
45517: PUSH
45518: LD_VAR 0 22
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: PUSH
45531: LD_VAR 0 4
45535: PUSH
45536: LD_INT 1
45538: PLUS
45539: ARRAY
45540: ST_TO_ADDR
45541: GO 45608
45543: LD_INT 3
45545: DOUBLE
45546: EQUAL
45547: IFTRUE 45551
45549: GO 45607
45551: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45552: LD_ADDR_VAR 0 9
45556: PUSH
45557: LD_VAR 0 23
45561: PUSH
45562: LD_VAR 0 24
45566: PUSH
45567: LD_VAR 0 25
45571: PUSH
45572: LD_VAR 0 26
45576: PUSH
45577: LD_VAR 0 27
45581: PUSH
45582: LD_VAR 0 28
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: PUSH
45595: LD_VAR 0 4
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: ARRAY
45604: ST_TO_ADDR
45605: GO 45608
45607: POP
45608: GO 46163
45610: LD_INT 2
45612: DOUBLE
45613: EQUAL
45614: IFTRUE 45624
45616: LD_INT 3
45618: DOUBLE
45619: EQUAL
45620: IFTRUE 45624
45622: GO 45680
45624: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45625: LD_ADDR_VAR 0 9
45629: PUSH
45630: LD_VAR 0 29
45634: PUSH
45635: LD_VAR 0 30
45639: PUSH
45640: LD_VAR 0 31
45644: PUSH
45645: LD_VAR 0 32
45649: PUSH
45650: LD_VAR 0 33
45654: PUSH
45655: LD_VAR 0 34
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: PUSH
45668: LD_VAR 0 4
45672: PUSH
45673: LD_INT 1
45675: PLUS
45676: ARRAY
45677: ST_TO_ADDR
45678: GO 46163
45680: LD_INT 16
45682: DOUBLE
45683: EQUAL
45684: IFTRUE 45742
45686: LD_INT 17
45688: DOUBLE
45689: EQUAL
45690: IFTRUE 45742
45692: LD_INT 18
45694: DOUBLE
45695: EQUAL
45696: IFTRUE 45742
45698: LD_INT 19
45700: DOUBLE
45701: EQUAL
45702: IFTRUE 45742
45704: LD_INT 22
45706: DOUBLE
45707: EQUAL
45708: IFTRUE 45742
45710: LD_INT 20
45712: DOUBLE
45713: EQUAL
45714: IFTRUE 45742
45716: LD_INT 21
45718: DOUBLE
45719: EQUAL
45720: IFTRUE 45742
45722: LD_INT 23
45724: DOUBLE
45725: EQUAL
45726: IFTRUE 45742
45728: LD_INT 24
45730: DOUBLE
45731: EQUAL
45732: IFTRUE 45742
45734: LD_INT 25
45736: DOUBLE
45737: EQUAL
45738: IFTRUE 45742
45740: GO 45798
45742: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45743: LD_ADDR_VAR 0 9
45747: PUSH
45748: LD_VAR 0 35
45752: PUSH
45753: LD_VAR 0 36
45757: PUSH
45758: LD_VAR 0 37
45762: PUSH
45763: LD_VAR 0 38
45767: PUSH
45768: LD_VAR 0 39
45772: PUSH
45773: LD_VAR 0 40
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: LIST
45782: LIST
45783: LIST
45784: LIST
45785: PUSH
45786: LD_VAR 0 4
45790: PUSH
45791: LD_INT 1
45793: PLUS
45794: ARRAY
45795: ST_TO_ADDR
45796: GO 46163
45798: LD_INT 6
45800: DOUBLE
45801: EQUAL
45802: IFTRUE 45854
45804: LD_INT 7
45806: DOUBLE
45807: EQUAL
45808: IFTRUE 45854
45810: LD_INT 8
45812: DOUBLE
45813: EQUAL
45814: IFTRUE 45854
45816: LD_INT 13
45818: DOUBLE
45819: EQUAL
45820: IFTRUE 45854
45822: LD_INT 12
45824: DOUBLE
45825: EQUAL
45826: IFTRUE 45854
45828: LD_INT 15
45830: DOUBLE
45831: EQUAL
45832: IFTRUE 45854
45834: LD_INT 11
45836: DOUBLE
45837: EQUAL
45838: IFTRUE 45854
45840: LD_INT 14
45842: DOUBLE
45843: EQUAL
45844: IFTRUE 45854
45846: LD_INT 10
45848: DOUBLE
45849: EQUAL
45850: IFTRUE 45854
45852: GO 45910
45854: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45855: LD_ADDR_VAR 0 9
45859: PUSH
45860: LD_VAR 0 41
45864: PUSH
45865: LD_VAR 0 42
45869: PUSH
45870: LD_VAR 0 43
45874: PUSH
45875: LD_VAR 0 44
45879: PUSH
45880: LD_VAR 0 45
45884: PUSH
45885: LD_VAR 0 46
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: PUSH
45898: LD_VAR 0 4
45902: PUSH
45903: LD_INT 1
45905: PLUS
45906: ARRAY
45907: ST_TO_ADDR
45908: GO 46163
45910: LD_INT 36
45912: DOUBLE
45913: EQUAL
45914: IFTRUE 45918
45916: GO 45974
45918: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45919: LD_ADDR_VAR 0 9
45923: PUSH
45924: LD_VAR 0 47
45928: PUSH
45929: LD_VAR 0 48
45933: PUSH
45934: LD_VAR 0 49
45938: PUSH
45939: LD_VAR 0 50
45943: PUSH
45944: LD_VAR 0 51
45948: PUSH
45949: LD_VAR 0 52
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: PUSH
45962: LD_VAR 0 4
45966: PUSH
45967: LD_INT 1
45969: PLUS
45970: ARRAY
45971: ST_TO_ADDR
45972: GO 46163
45974: LD_INT 4
45976: DOUBLE
45977: EQUAL
45978: IFTRUE 46000
45980: LD_INT 5
45982: DOUBLE
45983: EQUAL
45984: IFTRUE 46000
45986: LD_INT 34
45988: DOUBLE
45989: EQUAL
45990: IFTRUE 46000
45992: LD_INT 37
45994: DOUBLE
45995: EQUAL
45996: IFTRUE 46000
45998: GO 46056
46000: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46001: LD_ADDR_VAR 0 9
46005: PUSH
46006: LD_VAR 0 53
46010: PUSH
46011: LD_VAR 0 54
46015: PUSH
46016: LD_VAR 0 55
46020: PUSH
46021: LD_VAR 0 56
46025: PUSH
46026: LD_VAR 0 57
46030: PUSH
46031: LD_VAR 0 58
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: PUSH
46044: LD_VAR 0 4
46048: PUSH
46049: LD_INT 1
46051: PLUS
46052: ARRAY
46053: ST_TO_ADDR
46054: GO 46163
46056: LD_INT 31
46058: DOUBLE
46059: EQUAL
46060: IFTRUE 46106
46062: LD_INT 32
46064: DOUBLE
46065: EQUAL
46066: IFTRUE 46106
46068: LD_INT 33
46070: DOUBLE
46071: EQUAL
46072: IFTRUE 46106
46074: LD_INT 27
46076: DOUBLE
46077: EQUAL
46078: IFTRUE 46106
46080: LD_INT 26
46082: DOUBLE
46083: EQUAL
46084: IFTRUE 46106
46086: LD_INT 28
46088: DOUBLE
46089: EQUAL
46090: IFTRUE 46106
46092: LD_INT 29
46094: DOUBLE
46095: EQUAL
46096: IFTRUE 46106
46098: LD_INT 30
46100: DOUBLE
46101: EQUAL
46102: IFTRUE 46106
46104: GO 46162
46106: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46107: LD_ADDR_VAR 0 9
46111: PUSH
46112: LD_VAR 0 59
46116: PUSH
46117: LD_VAR 0 60
46121: PUSH
46122: LD_VAR 0 61
46126: PUSH
46127: LD_VAR 0 62
46131: PUSH
46132: LD_VAR 0 63
46136: PUSH
46137: LD_VAR 0 64
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: PUSH
46150: LD_VAR 0 4
46154: PUSH
46155: LD_INT 1
46157: PLUS
46158: ARRAY
46159: ST_TO_ADDR
46160: GO 46163
46162: POP
// temp_list2 = [ ] ;
46163: LD_ADDR_VAR 0 10
46167: PUSH
46168: EMPTY
46169: ST_TO_ADDR
// for i in temp_list do
46170: LD_ADDR_VAR 0 8
46174: PUSH
46175: LD_VAR 0 9
46179: PUSH
46180: FOR_IN
46181: IFFALSE 46233
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46183: LD_ADDR_VAR 0 10
46187: PUSH
46188: LD_VAR 0 10
46192: PUSH
46193: LD_VAR 0 8
46197: PUSH
46198: LD_INT 1
46200: ARRAY
46201: PUSH
46202: LD_VAR 0 2
46206: PLUS
46207: PUSH
46208: LD_VAR 0 8
46212: PUSH
46213: LD_INT 2
46215: ARRAY
46216: PUSH
46217: LD_VAR 0 3
46221: PLUS
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: EMPTY
46228: LIST
46229: ADD
46230: ST_TO_ADDR
46231: GO 46180
46233: POP
46234: POP
// result = temp_list2 ;
46235: LD_ADDR_VAR 0 7
46239: PUSH
46240: LD_VAR 0 10
46244: ST_TO_ADDR
// end ;
46245: LD_VAR 0 7
46249: RET
// export function EnemyInRange ( unit , dist ) ; begin
46250: LD_INT 0
46252: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46253: LD_ADDR_VAR 0 3
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 255
46267: PPUSH
46268: LD_VAR 0 1
46272: PPUSH
46273: CALL_OW 250
46277: PPUSH
46278: LD_VAR 0 1
46282: PPUSH
46283: CALL_OW 251
46287: PPUSH
46288: LD_VAR 0 2
46292: PPUSH
46293: CALL 19646 0 4
46297: PUSH
46298: LD_INT 4
46300: ARRAY
46301: ST_TO_ADDR
// end ;
46302: LD_VAR 0 3
46306: RET
// export function PlayerSeeMe ( unit ) ; begin
46307: LD_INT 0
46309: PPUSH
// result := See ( your_side , unit ) ;
46310: LD_ADDR_VAR 0 2
46314: PUSH
46315: LD_OWVAR 2
46319: PPUSH
46320: LD_VAR 0 1
46324: PPUSH
46325: CALL_OW 292
46329: ST_TO_ADDR
// end ;
46330: LD_VAR 0 2
46334: RET
// export function ReverseDir ( unit ) ; begin
46335: LD_INT 0
46337: PPUSH
// if not unit then
46338: LD_VAR 0 1
46342: NOT
46343: IFFALSE 46347
// exit ;
46345: GO 46370
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46347: LD_ADDR_VAR 0 2
46351: PUSH
46352: LD_VAR 0 1
46356: PPUSH
46357: CALL_OW 254
46361: PUSH
46362: LD_INT 3
46364: PLUS
46365: PUSH
46366: LD_INT 6
46368: MOD
46369: ST_TO_ADDR
// end ;
46370: LD_VAR 0 2
46374: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46375: LD_INT 0
46377: PPUSH
46378: PPUSH
46379: PPUSH
46380: PPUSH
46381: PPUSH
// if not hexes then
46382: LD_VAR 0 2
46386: NOT
46387: IFFALSE 46391
// exit ;
46389: GO 46539
// dist := 9999 ;
46391: LD_ADDR_VAR 0 5
46395: PUSH
46396: LD_INT 9999
46398: ST_TO_ADDR
// for i = 1 to hexes do
46399: LD_ADDR_VAR 0 4
46403: PUSH
46404: DOUBLE
46405: LD_INT 1
46407: DEC
46408: ST_TO_ADDR
46409: LD_VAR 0 2
46413: PUSH
46414: FOR_TO
46415: IFFALSE 46527
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46417: LD_VAR 0 1
46421: PPUSH
46422: LD_VAR 0 2
46426: PUSH
46427: LD_VAR 0 4
46431: ARRAY
46432: PUSH
46433: LD_INT 1
46435: ARRAY
46436: PPUSH
46437: LD_VAR 0 2
46441: PUSH
46442: LD_VAR 0 4
46446: ARRAY
46447: PUSH
46448: LD_INT 2
46450: ARRAY
46451: PPUSH
46452: CALL_OW 297
46456: PUSH
46457: LD_VAR 0 5
46461: LESS
46462: IFFALSE 46525
// begin hex := hexes [ i ] ;
46464: LD_ADDR_VAR 0 7
46468: PUSH
46469: LD_VAR 0 2
46473: PUSH
46474: LD_VAR 0 4
46478: ARRAY
46479: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46480: LD_ADDR_VAR 0 5
46484: PUSH
46485: LD_VAR 0 1
46489: PPUSH
46490: LD_VAR 0 2
46494: PUSH
46495: LD_VAR 0 4
46499: ARRAY
46500: PUSH
46501: LD_INT 1
46503: ARRAY
46504: PPUSH
46505: LD_VAR 0 2
46509: PUSH
46510: LD_VAR 0 4
46514: ARRAY
46515: PUSH
46516: LD_INT 2
46518: ARRAY
46519: PPUSH
46520: CALL_OW 297
46524: ST_TO_ADDR
// end ; end ;
46525: GO 46414
46527: POP
46528: POP
// result := hex ;
46529: LD_ADDR_VAR 0 3
46533: PUSH
46534: LD_VAR 0 7
46538: ST_TO_ADDR
// end ;
46539: LD_VAR 0 3
46543: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46544: LD_INT 0
46546: PPUSH
46547: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46548: LD_VAR 0 1
46552: NOT
46553: PUSH
46554: LD_VAR 0 1
46558: PUSH
46559: LD_INT 21
46561: PUSH
46562: LD_INT 2
46564: PUSH
46565: EMPTY
46566: LIST
46567: LIST
46568: PUSH
46569: LD_INT 23
46571: PUSH
46572: LD_INT 2
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PPUSH
46583: CALL_OW 69
46587: IN
46588: NOT
46589: OR
46590: IFFALSE 46594
// exit ;
46592: GO 46641
// for i = 1 to 3 do
46594: LD_ADDR_VAR 0 3
46598: PUSH
46599: DOUBLE
46600: LD_INT 1
46602: DEC
46603: ST_TO_ADDR
46604: LD_INT 3
46606: PUSH
46607: FOR_TO
46608: IFFALSE 46639
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46610: LD_VAR 0 1
46614: PPUSH
46615: CALL_OW 250
46619: PPUSH
46620: LD_VAR 0 1
46624: PPUSH
46625: CALL_OW 251
46629: PPUSH
46630: LD_INT 1
46632: PPUSH
46633: CALL_OW 453
46637: GO 46607
46639: POP
46640: POP
// end ;
46641: LD_VAR 0 2
46645: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46646: LD_INT 0
46648: PPUSH
46649: PPUSH
46650: PPUSH
46651: PPUSH
46652: PPUSH
46653: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46654: LD_VAR 0 1
46658: NOT
46659: PUSH
46660: LD_VAR 0 2
46664: NOT
46665: OR
46666: PUSH
46667: LD_VAR 0 1
46671: PPUSH
46672: CALL_OW 314
46676: OR
46677: IFFALSE 46681
// exit ;
46679: GO 47122
// x := GetX ( enemy_unit ) ;
46681: LD_ADDR_VAR 0 7
46685: PUSH
46686: LD_VAR 0 2
46690: PPUSH
46691: CALL_OW 250
46695: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46696: LD_ADDR_VAR 0 8
46700: PUSH
46701: LD_VAR 0 2
46705: PPUSH
46706: CALL_OW 251
46710: ST_TO_ADDR
// if not x or not y then
46711: LD_VAR 0 7
46715: NOT
46716: PUSH
46717: LD_VAR 0 8
46721: NOT
46722: OR
46723: IFFALSE 46727
// exit ;
46725: GO 47122
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46727: LD_ADDR_VAR 0 6
46731: PUSH
46732: LD_VAR 0 7
46736: PPUSH
46737: LD_INT 0
46739: PPUSH
46740: LD_INT 4
46742: PPUSH
46743: CALL_OW 272
46747: PUSH
46748: LD_VAR 0 8
46752: PPUSH
46753: LD_INT 0
46755: PPUSH
46756: LD_INT 4
46758: PPUSH
46759: CALL_OW 273
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_VAR 0 7
46772: PPUSH
46773: LD_INT 1
46775: PPUSH
46776: LD_INT 4
46778: PPUSH
46779: CALL_OW 272
46783: PUSH
46784: LD_VAR 0 8
46788: PPUSH
46789: LD_INT 1
46791: PPUSH
46792: LD_INT 4
46794: PPUSH
46795: CALL_OW 273
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: PUSH
46804: LD_VAR 0 7
46808: PPUSH
46809: LD_INT 2
46811: PPUSH
46812: LD_INT 4
46814: PPUSH
46815: CALL_OW 272
46819: PUSH
46820: LD_VAR 0 8
46824: PPUSH
46825: LD_INT 2
46827: PPUSH
46828: LD_INT 4
46830: PPUSH
46831: CALL_OW 273
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: PUSH
46840: LD_VAR 0 7
46844: PPUSH
46845: LD_INT 3
46847: PPUSH
46848: LD_INT 4
46850: PPUSH
46851: CALL_OW 272
46855: PUSH
46856: LD_VAR 0 8
46860: PPUSH
46861: LD_INT 3
46863: PPUSH
46864: LD_INT 4
46866: PPUSH
46867: CALL_OW 273
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_VAR 0 7
46880: PPUSH
46881: LD_INT 4
46883: PPUSH
46884: LD_INT 4
46886: PPUSH
46887: CALL_OW 272
46891: PUSH
46892: LD_VAR 0 8
46896: PPUSH
46897: LD_INT 4
46899: PPUSH
46900: LD_INT 4
46902: PPUSH
46903: CALL_OW 273
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: LD_VAR 0 7
46916: PPUSH
46917: LD_INT 5
46919: PPUSH
46920: LD_INT 4
46922: PPUSH
46923: CALL_OW 272
46927: PUSH
46928: LD_VAR 0 8
46932: PPUSH
46933: LD_INT 5
46935: PPUSH
46936: LD_INT 4
46938: PPUSH
46939: CALL_OW 273
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: ST_TO_ADDR
// for i = tmp downto 1 do
46956: LD_ADDR_VAR 0 4
46960: PUSH
46961: DOUBLE
46962: LD_VAR 0 6
46966: INC
46967: ST_TO_ADDR
46968: LD_INT 1
46970: PUSH
46971: FOR_DOWNTO
46972: IFFALSE 47073
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46974: LD_VAR 0 6
46978: PUSH
46979: LD_VAR 0 4
46983: ARRAY
46984: PUSH
46985: LD_INT 1
46987: ARRAY
46988: PPUSH
46989: LD_VAR 0 6
46993: PUSH
46994: LD_VAR 0 4
46998: ARRAY
46999: PUSH
47000: LD_INT 2
47002: ARRAY
47003: PPUSH
47004: CALL_OW 488
47008: NOT
47009: PUSH
47010: LD_VAR 0 6
47014: PUSH
47015: LD_VAR 0 4
47019: ARRAY
47020: PUSH
47021: LD_INT 1
47023: ARRAY
47024: PPUSH
47025: LD_VAR 0 6
47029: PUSH
47030: LD_VAR 0 4
47034: ARRAY
47035: PUSH
47036: LD_INT 2
47038: ARRAY
47039: PPUSH
47040: CALL_OW 428
47044: PUSH
47045: LD_INT 0
47047: NONEQUAL
47048: OR
47049: IFFALSE 47071
// tmp := Delete ( tmp , i ) ;
47051: LD_ADDR_VAR 0 6
47055: PUSH
47056: LD_VAR 0 6
47060: PPUSH
47061: LD_VAR 0 4
47065: PPUSH
47066: CALL_OW 3
47070: ST_TO_ADDR
47071: GO 46971
47073: POP
47074: POP
// j := GetClosestHex ( unit , tmp ) ;
47075: LD_ADDR_VAR 0 5
47079: PUSH
47080: LD_VAR 0 1
47084: PPUSH
47085: LD_VAR 0 6
47089: PPUSH
47090: CALL 46375 0 2
47094: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47095: LD_VAR 0 1
47099: PPUSH
47100: LD_VAR 0 5
47104: PUSH
47105: LD_INT 1
47107: ARRAY
47108: PPUSH
47109: LD_VAR 0 5
47113: PUSH
47114: LD_INT 2
47116: ARRAY
47117: PPUSH
47118: CALL_OW 111
// end ;
47122: LD_VAR 0 3
47126: RET
// export function PrepareApemanSoldier ( ) ; begin
47127: LD_INT 0
47129: PPUSH
// uc_nation := 0 ;
47130: LD_ADDR_OWVAR 21
47134: PUSH
47135: LD_INT 0
47137: ST_TO_ADDR
// hc_sex := sex_male ;
47138: LD_ADDR_OWVAR 27
47142: PUSH
47143: LD_INT 1
47145: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
47146: LD_ADDR_OWVAR 28
47150: PUSH
47151: LD_INT 15
47153: ST_TO_ADDR
// hc_gallery :=  ;
47154: LD_ADDR_OWVAR 33
47158: PUSH
47159: LD_STRING 
47161: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47162: LD_ADDR_OWVAR 31
47166: PUSH
47167: LD_INT 0
47169: PPUSH
47170: LD_INT 3
47172: PPUSH
47173: CALL_OW 12
47177: PUSH
47178: LD_INT 0
47180: PPUSH
47181: LD_INT 3
47183: PPUSH
47184: CALL_OW 12
47188: PUSH
47189: LD_INT 0
47191: PUSH
47192: LD_INT 0
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: ST_TO_ADDR
// end ;
47201: LD_VAR 0 1
47205: RET
// export function PrepareApemanEngineer ( ) ; begin
47206: LD_INT 0
47208: PPUSH
// uc_nation := 0 ;
47209: LD_ADDR_OWVAR 21
47213: PUSH
47214: LD_INT 0
47216: ST_TO_ADDR
// hc_sex := sex_male ;
47217: LD_ADDR_OWVAR 27
47221: PUSH
47222: LD_INT 1
47224: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
47225: LD_ADDR_OWVAR 28
47229: PUSH
47230: LD_INT 16
47232: ST_TO_ADDR
// hc_gallery :=  ;
47233: LD_ADDR_OWVAR 33
47237: PUSH
47238: LD_STRING 
47240: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47241: LD_ADDR_OWVAR 31
47245: PUSH
47246: LD_INT 0
47248: PPUSH
47249: LD_INT 3
47251: PPUSH
47252: CALL_OW 12
47256: PUSH
47257: LD_INT 0
47259: PPUSH
47260: LD_INT 3
47262: PPUSH
47263: CALL_OW 12
47267: PUSH
47268: LD_INT 0
47270: PUSH
47271: LD_INT 0
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: ST_TO_ADDR
// end ;
47280: LD_VAR 0 1
47284: RET
// export function PrepareApeman ( agressivity ) ; begin
47285: LD_INT 0
47287: PPUSH
// uc_side := 0 ;
47288: LD_ADDR_OWVAR 20
47292: PUSH
47293: LD_INT 0
47295: ST_TO_ADDR
// uc_nation := 0 ;
47296: LD_ADDR_OWVAR 21
47300: PUSH
47301: LD_INT 0
47303: ST_TO_ADDR
// hc_sex := sex_male ;
47304: LD_ADDR_OWVAR 27
47308: PUSH
47309: LD_INT 1
47311: ST_TO_ADDR
// hc_class := class_apeman ;
47312: LD_ADDR_OWVAR 28
47316: PUSH
47317: LD_INT 12
47319: ST_TO_ADDR
// hc_gallery :=  ;
47320: LD_ADDR_OWVAR 33
47324: PUSH
47325: LD_STRING 
47327: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47328: LD_ADDR_OWVAR 35
47332: PUSH
47333: LD_VAR 0 1
47337: NEG
47338: PPUSH
47339: LD_VAR 0 1
47343: PPUSH
47344: CALL_OW 12
47348: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47349: LD_ADDR_OWVAR 31
47353: PUSH
47354: LD_INT 0
47356: PPUSH
47357: LD_INT 3
47359: PPUSH
47360: CALL_OW 12
47364: PUSH
47365: LD_INT 0
47367: PPUSH
47368: LD_INT 3
47370: PPUSH
47371: CALL_OW 12
47375: PUSH
47376: LD_INT 0
47378: PUSH
47379: LD_INT 0
47381: PUSH
47382: EMPTY
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: ST_TO_ADDR
// end ;
47388: LD_VAR 0 2
47392: RET
// export function PrepareTiger ( agressivity ) ; begin
47393: LD_INT 0
47395: PPUSH
// uc_side := 0 ;
47396: LD_ADDR_OWVAR 20
47400: PUSH
47401: LD_INT 0
47403: ST_TO_ADDR
// uc_nation := 0 ;
47404: LD_ADDR_OWVAR 21
47408: PUSH
47409: LD_INT 0
47411: ST_TO_ADDR
// hc_class := class_tiger ;
47412: LD_ADDR_OWVAR 28
47416: PUSH
47417: LD_INT 14
47419: ST_TO_ADDR
// hc_gallery :=  ;
47420: LD_ADDR_OWVAR 33
47424: PUSH
47425: LD_STRING 
47427: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47428: LD_ADDR_OWVAR 35
47432: PUSH
47433: LD_VAR 0 1
47437: NEG
47438: PPUSH
47439: LD_VAR 0 1
47443: PPUSH
47444: CALL_OW 12
47448: ST_TO_ADDR
// end ;
47449: LD_VAR 0 2
47453: RET
// export function PrepareEnchidna ( ) ; begin
47454: LD_INT 0
47456: PPUSH
// uc_side := 0 ;
47457: LD_ADDR_OWVAR 20
47461: PUSH
47462: LD_INT 0
47464: ST_TO_ADDR
// uc_nation := 0 ;
47465: LD_ADDR_OWVAR 21
47469: PUSH
47470: LD_INT 0
47472: ST_TO_ADDR
// hc_class := class_baggie ;
47473: LD_ADDR_OWVAR 28
47477: PUSH
47478: LD_INT 13
47480: ST_TO_ADDR
// hc_gallery :=  ;
47481: LD_ADDR_OWVAR 33
47485: PUSH
47486: LD_STRING 
47488: ST_TO_ADDR
// end ;
47489: LD_VAR 0 1
47493: RET
// export function PrepareFrog ( ) ; begin
47494: LD_INT 0
47496: PPUSH
// uc_side := 0 ;
47497: LD_ADDR_OWVAR 20
47501: PUSH
47502: LD_INT 0
47504: ST_TO_ADDR
// uc_nation := 0 ;
47505: LD_ADDR_OWVAR 21
47509: PUSH
47510: LD_INT 0
47512: ST_TO_ADDR
// hc_class := class_frog ;
47513: LD_ADDR_OWVAR 28
47517: PUSH
47518: LD_INT 19
47520: ST_TO_ADDR
// hc_gallery :=  ;
47521: LD_ADDR_OWVAR 33
47525: PUSH
47526: LD_STRING 
47528: ST_TO_ADDR
// end ;
47529: LD_VAR 0 1
47533: RET
// export function PrepareFish ( ) ; begin
47534: LD_INT 0
47536: PPUSH
// uc_side := 0 ;
47537: LD_ADDR_OWVAR 20
47541: PUSH
47542: LD_INT 0
47544: ST_TO_ADDR
// uc_nation := 0 ;
47545: LD_ADDR_OWVAR 21
47549: PUSH
47550: LD_INT 0
47552: ST_TO_ADDR
// hc_class := class_fish ;
47553: LD_ADDR_OWVAR 28
47557: PUSH
47558: LD_INT 20
47560: ST_TO_ADDR
// hc_gallery :=  ;
47561: LD_ADDR_OWVAR 33
47565: PUSH
47566: LD_STRING 
47568: ST_TO_ADDR
// end ;
47569: LD_VAR 0 1
47573: RET
// export function PrepareBird ( ) ; begin
47574: LD_INT 0
47576: PPUSH
// uc_side := 0 ;
47577: LD_ADDR_OWVAR 20
47581: PUSH
47582: LD_INT 0
47584: ST_TO_ADDR
// uc_nation := 0 ;
47585: LD_ADDR_OWVAR 21
47589: PUSH
47590: LD_INT 0
47592: ST_TO_ADDR
// hc_class := class_phororhacos ;
47593: LD_ADDR_OWVAR 28
47597: PUSH
47598: LD_INT 18
47600: ST_TO_ADDR
// hc_gallery :=  ;
47601: LD_ADDR_OWVAR 33
47605: PUSH
47606: LD_STRING 
47608: ST_TO_ADDR
// end ;
47609: LD_VAR 0 1
47613: RET
// export function PrepareHorse ( ) ; begin
47614: LD_INT 0
47616: PPUSH
// uc_side := 0 ;
47617: LD_ADDR_OWVAR 20
47621: PUSH
47622: LD_INT 0
47624: ST_TO_ADDR
// uc_nation := 0 ;
47625: LD_ADDR_OWVAR 21
47629: PUSH
47630: LD_INT 0
47632: ST_TO_ADDR
// hc_class := class_horse ;
47633: LD_ADDR_OWVAR 28
47637: PUSH
47638: LD_INT 21
47640: ST_TO_ADDR
// hc_gallery :=  ;
47641: LD_ADDR_OWVAR 33
47645: PUSH
47646: LD_STRING 
47648: ST_TO_ADDR
// end ;
47649: LD_VAR 0 1
47653: RET
// export function PrepareMastodont ( ) ; begin
47654: LD_INT 0
47656: PPUSH
// uc_side := 0 ;
47657: LD_ADDR_OWVAR 20
47661: PUSH
47662: LD_INT 0
47664: ST_TO_ADDR
// uc_nation := 0 ;
47665: LD_ADDR_OWVAR 21
47669: PUSH
47670: LD_INT 0
47672: ST_TO_ADDR
// vc_chassis := class_mastodont ;
47673: LD_ADDR_OWVAR 37
47677: PUSH
47678: LD_INT 31
47680: ST_TO_ADDR
// vc_control := control_rider ;
47681: LD_ADDR_OWVAR 38
47685: PUSH
47686: LD_INT 4
47688: ST_TO_ADDR
// end ;
47689: LD_VAR 0 1
47693: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47694: LD_INT 0
47696: PPUSH
47697: PPUSH
47698: PPUSH
// uc_side = 0 ;
47699: LD_ADDR_OWVAR 20
47703: PUSH
47704: LD_INT 0
47706: ST_TO_ADDR
// uc_nation = 0 ;
47707: LD_ADDR_OWVAR 21
47711: PUSH
47712: LD_INT 0
47714: ST_TO_ADDR
// InitHc_All ( ) ;
47715: CALL_OW 584
// InitVc ;
47719: CALL_OW 20
// if mastodonts then
47723: LD_VAR 0 6
47727: IFFALSE 47794
// for i = 1 to mastodonts do
47729: LD_ADDR_VAR 0 11
47733: PUSH
47734: DOUBLE
47735: LD_INT 1
47737: DEC
47738: ST_TO_ADDR
47739: LD_VAR 0 6
47743: PUSH
47744: FOR_TO
47745: IFFALSE 47792
// begin vc_chassis := 31 ;
47747: LD_ADDR_OWVAR 37
47751: PUSH
47752: LD_INT 31
47754: ST_TO_ADDR
// vc_control := control_rider ;
47755: LD_ADDR_OWVAR 38
47759: PUSH
47760: LD_INT 4
47762: ST_TO_ADDR
// animal := CreateVehicle ;
47763: LD_ADDR_VAR 0 12
47767: PUSH
47768: CALL_OW 45
47772: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47773: LD_VAR 0 12
47777: PPUSH
47778: LD_VAR 0 8
47782: PPUSH
47783: LD_INT 0
47785: PPUSH
47786: CALL 49929 0 3
// end ;
47790: GO 47744
47792: POP
47793: POP
// if horses then
47794: LD_VAR 0 5
47798: IFFALSE 47865
// for i = 1 to horses do
47800: LD_ADDR_VAR 0 11
47804: PUSH
47805: DOUBLE
47806: LD_INT 1
47808: DEC
47809: ST_TO_ADDR
47810: LD_VAR 0 5
47814: PUSH
47815: FOR_TO
47816: IFFALSE 47863
// begin hc_class := 21 ;
47818: LD_ADDR_OWVAR 28
47822: PUSH
47823: LD_INT 21
47825: ST_TO_ADDR
// hc_gallery :=  ;
47826: LD_ADDR_OWVAR 33
47830: PUSH
47831: LD_STRING 
47833: ST_TO_ADDR
// animal := CreateHuman ;
47834: LD_ADDR_VAR 0 12
47838: PUSH
47839: CALL_OW 44
47843: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47844: LD_VAR 0 12
47848: PPUSH
47849: LD_VAR 0 8
47853: PPUSH
47854: LD_INT 0
47856: PPUSH
47857: CALL 49929 0 3
// end ;
47861: GO 47815
47863: POP
47864: POP
// if birds then
47865: LD_VAR 0 1
47869: IFFALSE 47936
// for i = 1 to birds do
47871: LD_ADDR_VAR 0 11
47875: PUSH
47876: DOUBLE
47877: LD_INT 1
47879: DEC
47880: ST_TO_ADDR
47881: LD_VAR 0 1
47885: PUSH
47886: FOR_TO
47887: IFFALSE 47934
// begin hc_class = 18 ;
47889: LD_ADDR_OWVAR 28
47893: PUSH
47894: LD_INT 18
47896: ST_TO_ADDR
// hc_gallery =  ;
47897: LD_ADDR_OWVAR 33
47901: PUSH
47902: LD_STRING 
47904: ST_TO_ADDR
// animal := CreateHuman ;
47905: LD_ADDR_VAR 0 12
47909: PUSH
47910: CALL_OW 44
47914: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47915: LD_VAR 0 12
47919: PPUSH
47920: LD_VAR 0 8
47924: PPUSH
47925: LD_INT 0
47927: PPUSH
47928: CALL 49929 0 3
// end ;
47932: GO 47886
47934: POP
47935: POP
// if tigers then
47936: LD_VAR 0 2
47940: IFFALSE 48024
// for i = 1 to tigers do
47942: LD_ADDR_VAR 0 11
47946: PUSH
47947: DOUBLE
47948: LD_INT 1
47950: DEC
47951: ST_TO_ADDR
47952: LD_VAR 0 2
47956: PUSH
47957: FOR_TO
47958: IFFALSE 48022
// begin hc_class = class_tiger ;
47960: LD_ADDR_OWVAR 28
47964: PUSH
47965: LD_INT 14
47967: ST_TO_ADDR
// hc_gallery =  ;
47968: LD_ADDR_OWVAR 33
47972: PUSH
47973: LD_STRING 
47975: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47976: LD_ADDR_OWVAR 35
47980: PUSH
47981: LD_INT 7
47983: NEG
47984: PPUSH
47985: LD_INT 7
47987: PPUSH
47988: CALL_OW 12
47992: ST_TO_ADDR
// animal := CreateHuman ;
47993: LD_ADDR_VAR 0 12
47997: PUSH
47998: CALL_OW 44
48002: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48003: LD_VAR 0 12
48007: PPUSH
48008: LD_VAR 0 8
48012: PPUSH
48013: LD_INT 0
48015: PPUSH
48016: CALL 49929 0 3
// end ;
48020: GO 47957
48022: POP
48023: POP
// if apemans then
48024: LD_VAR 0 3
48028: IFFALSE 48151
// for i = 1 to apemans do
48030: LD_ADDR_VAR 0 11
48034: PUSH
48035: DOUBLE
48036: LD_INT 1
48038: DEC
48039: ST_TO_ADDR
48040: LD_VAR 0 3
48044: PUSH
48045: FOR_TO
48046: IFFALSE 48149
// begin hc_class = class_apeman ;
48048: LD_ADDR_OWVAR 28
48052: PUSH
48053: LD_INT 12
48055: ST_TO_ADDR
// hc_gallery =  ;
48056: LD_ADDR_OWVAR 33
48060: PUSH
48061: LD_STRING 
48063: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48064: LD_ADDR_OWVAR 35
48068: PUSH
48069: LD_INT 2
48071: NEG
48072: PPUSH
48073: LD_INT 2
48075: PPUSH
48076: CALL_OW 12
48080: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48081: LD_ADDR_OWVAR 31
48085: PUSH
48086: LD_INT 1
48088: PPUSH
48089: LD_INT 3
48091: PPUSH
48092: CALL_OW 12
48096: PUSH
48097: LD_INT 1
48099: PPUSH
48100: LD_INT 3
48102: PPUSH
48103: CALL_OW 12
48107: PUSH
48108: LD_INT 0
48110: PUSH
48111: LD_INT 0
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: ST_TO_ADDR
// animal := CreateHuman ;
48120: LD_ADDR_VAR 0 12
48124: PUSH
48125: CALL_OW 44
48129: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48130: LD_VAR 0 12
48134: PPUSH
48135: LD_VAR 0 8
48139: PPUSH
48140: LD_INT 0
48142: PPUSH
48143: CALL 49929 0 3
// end ;
48147: GO 48045
48149: POP
48150: POP
// if enchidnas then
48151: LD_VAR 0 4
48155: IFFALSE 48222
// for i = 1 to enchidnas do
48157: LD_ADDR_VAR 0 11
48161: PUSH
48162: DOUBLE
48163: LD_INT 1
48165: DEC
48166: ST_TO_ADDR
48167: LD_VAR 0 4
48171: PUSH
48172: FOR_TO
48173: IFFALSE 48220
// begin hc_class = 13 ;
48175: LD_ADDR_OWVAR 28
48179: PUSH
48180: LD_INT 13
48182: ST_TO_ADDR
// hc_gallery =  ;
48183: LD_ADDR_OWVAR 33
48187: PUSH
48188: LD_STRING 
48190: ST_TO_ADDR
// animal := CreateHuman ;
48191: LD_ADDR_VAR 0 12
48195: PUSH
48196: CALL_OW 44
48200: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48201: LD_VAR 0 12
48205: PPUSH
48206: LD_VAR 0 8
48210: PPUSH
48211: LD_INT 0
48213: PPUSH
48214: CALL 49929 0 3
// end ;
48218: GO 48172
48220: POP
48221: POP
// if fishes then
48222: LD_VAR 0 7
48226: IFFALSE 48293
// for i = 1 to fishes do
48228: LD_ADDR_VAR 0 11
48232: PUSH
48233: DOUBLE
48234: LD_INT 1
48236: DEC
48237: ST_TO_ADDR
48238: LD_VAR 0 7
48242: PUSH
48243: FOR_TO
48244: IFFALSE 48291
// begin hc_class = 20 ;
48246: LD_ADDR_OWVAR 28
48250: PUSH
48251: LD_INT 20
48253: ST_TO_ADDR
// hc_gallery =  ;
48254: LD_ADDR_OWVAR 33
48258: PUSH
48259: LD_STRING 
48261: ST_TO_ADDR
// animal := CreateHuman ;
48262: LD_ADDR_VAR 0 12
48266: PUSH
48267: CALL_OW 44
48271: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48272: LD_VAR 0 12
48276: PPUSH
48277: LD_VAR 0 9
48281: PPUSH
48282: LD_INT 0
48284: PPUSH
48285: CALL 49929 0 3
// end ;
48289: GO 48243
48291: POP
48292: POP
// end ;
48293: LD_VAR 0 10
48297: RET
// export function WantHeal ( sci , unit ) ; begin
48298: LD_INT 0
48300: PPUSH
// if GetTaskList ( sci ) > 0 then
48301: LD_VAR 0 1
48305: PPUSH
48306: CALL_OW 437
48310: PUSH
48311: LD_INT 0
48313: GREATER
48314: IFFALSE 48384
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48316: LD_VAR 0 1
48320: PPUSH
48321: CALL_OW 437
48325: PUSH
48326: LD_INT 1
48328: ARRAY
48329: PUSH
48330: LD_INT 1
48332: ARRAY
48333: PUSH
48334: LD_STRING l
48336: EQUAL
48337: PUSH
48338: LD_VAR 0 1
48342: PPUSH
48343: CALL_OW 437
48347: PUSH
48348: LD_INT 1
48350: ARRAY
48351: PUSH
48352: LD_INT 4
48354: ARRAY
48355: PUSH
48356: LD_VAR 0 2
48360: EQUAL
48361: AND
48362: IFFALSE 48374
// result := true else
48364: LD_ADDR_VAR 0 3
48368: PUSH
48369: LD_INT 1
48371: ST_TO_ADDR
48372: GO 48382
// result := false ;
48374: LD_ADDR_VAR 0 3
48378: PUSH
48379: LD_INT 0
48381: ST_TO_ADDR
// end else
48382: GO 48392
// result := false ;
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_INT 0
48391: ST_TO_ADDR
// end ;
48392: LD_VAR 0 3
48396: RET
// export function HealTarget ( sci ) ; begin
48397: LD_INT 0
48399: PPUSH
// if not sci then
48400: LD_VAR 0 1
48404: NOT
48405: IFFALSE 48409
// exit ;
48407: GO 48474
// result := 0 ;
48409: LD_ADDR_VAR 0 2
48413: PUSH
48414: LD_INT 0
48416: ST_TO_ADDR
// if GetTaskList ( sci ) then
48417: LD_VAR 0 1
48421: PPUSH
48422: CALL_OW 437
48426: IFFALSE 48474
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48428: LD_VAR 0 1
48432: PPUSH
48433: CALL_OW 437
48437: PUSH
48438: LD_INT 1
48440: ARRAY
48441: PUSH
48442: LD_INT 1
48444: ARRAY
48445: PUSH
48446: LD_STRING l
48448: EQUAL
48449: IFFALSE 48474
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48451: LD_ADDR_VAR 0 2
48455: PUSH
48456: LD_VAR 0 1
48460: PPUSH
48461: CALL_OW 437
48465: PUSH
48466: LD_INT 1
48468: ARRAY
48469: PUSH
48470: LD_INT 4
48472: ARRAY
48473: ST_TO_ADDR
// end ;
48474: LD_VAR 0 2
48478: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48479: LD_INT 0
48481: PPUSH
48482: PPUSH
48483: PPUSH
48484: PPUSH
// if not base_units then
48485: LD_VAR 0 1
48489: NOT
48490: IFFALSE 48494
// exit ;
48492: GO 48581
// result := false ;
48494: LD_ADDR_VAR 0 2
48498: PUSH
48499: LD_INT 0
48501: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48502: LD_ADDR_VAR 0 5
48506: PUSH
48507: LD_VAR 0 1
48511: PPUSH
48512: LD_INT 21
48514: PUSH
48515: LD_INT 3
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: PPUSH
48522: CALL_OW 72
48526: ST_TO_ADDR
// if not tmp then
48527: LD_VAR 0 5
48531: NOT
48532: IFFALSE 48536
// exit ;
48534: GO 48581
// for i in tmp do
48536: LD_ADDR_VAR 0 3
48540: PUSH
48541: LD_VAR 0 5
48545: PUSH
48546: FOR_IN
48547: IFFALSE 48579
// begin result := EnemyInRange ( i , 22 ) ;
48549: LD_ADDR_VAR 0 2
48553: PUSH
48554: LD_VAR 0 3
48558: PPUSH
48559: LD_INT 22
48561: PPUSH
48562: CALL 46250 0 2
48566: ST_TO_ADDR
// if result then
48567: LD_VAR 0 2
48571: IFFALSE 48577
// exit ;
48573: POP
48574: POP
48575: GO 48581
// end ;
48577: GO 48546
48579: POP
48580: POP
// end ;
48581: LD_VAR 0 2
48585: RET
// export function FilterByTag ( units , tag ) ; begin
48586: LD_INT 0
48588: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
48589: LD_ADDR_VAR 0 3
48593: PUSH
48594: LD_VAR 0 1
48598: PPUSH
48599: LD_INT 120
48601: PUSH
48602: LD_VAR 0 2
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PPUSH
48611: CALL_OW 72
48615: ST_TO_ADDR
// end ;
48616: LD_VAR 0 3
48620: RET
// export function IsDriver ( un ) ; begin
48621: LD_INT 0
48623: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48624: LD_ADDR_VAR 0 2
48628: PUSH
48629: LD_VAR 0 1
48633: PUSH
48634: LD_INT 55
48636: PUSH
48637: EMPTY
48638: LIST
48639: PPUSH
48640: CALL_OW 69
48644: IN
48645: ST_TO_ADDR
// end ;
48646: LD_VAR 0 2
48650: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48651: LD_INT 0
48653: PPUSH
48654: PPUSH
// list := [ ] ;
48655: LD_ADDR_VAR 0 5
48659: PUSH
48660: EMPTY
48661: ST_TO_ADDR
// case d of 0 :
48662: LD_VAR 0 3
48666: PUSH
48667: LD_INT 0
48669: DOUBLE
48670: EQUAL
48671: IFTRUE 48675
48673: GO 48808
48675: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48676: LD_ADDR_VAR 0 5
48680: PUSH
48681: LD_VAR 0 1
48685: PUSH
48686: LD_INT 4
48688: MINUS
48689: PUSH
48690: LD_VAR 0 2
48694: PUSH
48695: LD_INT 4
48697: MINUS
48698: PUSH
48699: LD_INT 2
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: LIST
48706: PUSH
48707: LD_VAR 0 1
48711: PUSH
48712: LD_INT 3
48714: MINUS
48715: PUSH
48716: LD_VAR 0 2
48720: PUSH
48721: LD_INT 1
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: LIST
48728: PUSH
48729: LD_VAR 0 1
48733: PUSH
48734: LD_INT 4
48736: PLUS
48737: PUSH
48738: LD_VAR 0 2
48742: PUSH
48743: LD_INT 4
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: LIST
48750: PUSH
48751: LD_VAR 0 1
48755: PUSH
48756: LD_INT 3
48758: PLUS
48759: PUSH
48760: LD_VAR 0 2
48764: PUSH
48765: LD_INT 3
48767: PLUS
48768: PUSH
48769: LD_INT 5
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: LIST
48776: PUSH
48777: LD_VAR 0 1
48781: PUSH
48782: LD_VAR 0 2
48786: PUSH
48787: LD_INT 4
48789: PLUS
48790: PUSH
48791: LD_INT 0
48793: PUSH
48794: EMPTY
48795: LIST
48796: LIST
48797: LIST
48798: PUSH
48799: EMPTY
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: ST_TO_ADDR
// end ; 1 :
48806: GO 49506
48808: LD_INT 1
48810: DOUBLE
48811: EQUAL
48812: IFTRUE 48816
48814: GO 48949
48816: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_VAR 0 1
48826: PUSH
48827: LD_VAR 0 2
48831: PUSH
48832: LD_INT 4
48834: MINUS
48835: PUSH
48836: LD_INT 3
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: LIST
48843: PUSH
48844: LD_VAR 0 1
48848: PUSH
48849: LD_INT 3
48851: MINUS
48852: PUSH
48853: LD_VAR 0 2
48857: PUSH
48858: LD_INT 3
48860: MINUS
48861: PUSH
48862: LD_INT 2
48864: PUSH
48865: EMPTY
48866: LIST
48867: LIST
48868: LIST
48869: PUSH
48870: LD_VAR 0 1
48874: PUSH
48875: LD_INT 4
48877: MINUS
48878: PUSH
48879: LD_VAR 0 2
48883: PUSH
48884: LD_INT 1
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: LIST
48891: PUSH
48892: LD_VAR 0 1
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 3
48904: PLUS
48905: PUSH
48906: LD_INT 0
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: LIST
48913: PUSH
48914: LD_VAR 0 1
48918: PUSH
48919: LD_INT 4
48921: PLUS
48922: PUSH
48923: LD_VAR 0 2
48927: PUSH
48928: LD_INT 4
48930: PLUS
48931: PUSH
48932: LD_INT 5
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: LIST
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: ST_TO_ADDR
// end ; 2 :
48947: GO 49506
48949: LD_INT 2
48951: DOUBLE
48952: EQUAL
48953: IFTRUE 48957
48955: GO 49086
48957: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48958: LD_ADDR_VAR 0 5
48962: PUSH
48963: LD_VAR 0 1
48967: PUSH
48968: LD_VAR 0 2
48972: PUSH
48973: LD_INT 3
48975: MINUS
48976: PUSH
48977: LD_INT 3
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: LIST
48984: PUSH
48985: LD_VAR 0 1
48989: PUSH
48990: LD_INT 4
48992: PLUS
48993: PUSH
48994: LD_VAR 0 2
48998: PUSH
48999: LD_INT 4
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: LIST
49006: PUSH
49007: LD_VAR 0 1
49011: PUSH
49012: LD_VAR 0 2
49016: PUSH
49017: LD_INT 4
49019: PLUS
49020: PUSH
49021: LD_INT 0
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: LIST
49028: PUSH
49029: LD_VAR 0 1
49033: PUSH
49034: LD_INT 3
49036: MINUS
49037: PUSH
49038: LD_VAR 0 2
49042: PUSH
49043: LD_INT 1
49045: PUSH
49046: EMPTY
49047: LIST
49048: LIST
49049: LIST
49050: PUSH
49051: LD_VAR 0 1
49055: PUSH
49056: LD_INT 4
49058: MINUS
49059: PUSH
49060: LD_VAR 0 2
49064: PUSH
49065: LD_INT 4
49067: MINUS
49068: PUSH
49069: LD_INT 2
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: LIST
49076: PUSH
49077: EMPTY
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: ST_TO_ADDR
// end ; 3 :
49084: GO 49506
49086: LD_INT 3
49088: DOUBLE
49089: EQUAL
49090: IFTRUE 49094
49092: GO 49227
49094: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49095: LD_ADDR_VAR 0 5
49099: PUSH
49100: LD_VAR 0 1
49104: PUSH
49105: LD_INT 3
49107: PLUS
49108: PUSH
49109: LD_VAR 0 2
49113: PUSH
49114: LD_INT 4
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: LIST
49121: PUSH
49122: LD_VAR 0 1
49126: PUSH
49127: LD_INT 4
49129: PLUS
49130: PUSH
49131: LD_VAR 0 2
49135: PUSH
49136: LD_INT 4
49138: PLUS
49139: PUSH
49140: LD_INT 5
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: LIST
49147: PUSH
49148: LD_VAR 0 1
49152: PUSH
49153: LD_INT 4
49155: MINUS
49156: PUSH
49157: LD_VAR 0 2
49161: PUSH
49162: LD_INT 1
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: LIST
49169: PUSH
49170: LD_VAR 0 1
49174: PUSH
49175: LD_VAR 0 2
49179: PUSH
49180: LD_INT 4
49182: MINUS
49183: PUSH
49184: LD_INT 3
49186: PUSH
49187: EMPTY
49188: LIST
49189: LIST
49190: LIST
49191: PUSH
49192: LD_VAR 0 1
49196: PUSH
49197: LD_INT 3
49199: MINUS
49200: PUSH
49201: LD_VAR 0 2
49205: PUSH
49206: LD_INT 3
49208: MINUS
49209: PUSH
49210: LD_INT 2
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: LIST
49217: PUSH
49218: EMPTY
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: LIST
49224: ST_TO_ADDR
// end ; 4 :
49225: GO 49506
49227: LD_INT 4
49229: DOUBLE
49230: EQUAL
49231: IFTRUE 49235
49233: GO 49368
49235: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49236: LD_ADDR_VAR 0 5
49240: PUSH
49241: LD_VAR 0 1
49245: PUSH
49246: LD_VAR 0 2
49250: PUSH
49251: LD_INT 4
49253: PLUS
49254: PUSH
49255: LD_INT 0
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: LIST
49262: PUSH
49263: LD_VAR 0 1
49267: PUSH
49268: LD_INT 3
49270: PLUS
49271: PUSH
49272: LD_VAR 0 2
49276: PUSH
49277: LD_INT 3
49279: PLUS
49280: PUSH
49281: LD_INT 5
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: LIST
49288: PUSH
49289: LD_VAR 0 1
49293: PUSH
49294: LD_INT 4
49296: PLUS
49297: PUSH
49298: LD_VAR 0 2
49302: PUSH
49303: LD_INT 4
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: LIST
49310: PUSH
49311: LD_VAR 0 1
49315: PUSH
49316: LD_VAR 0 2
49320: PUSH
49321: LD_INT 3
49323: MINUS
49324: PUSH
49325: LD_INT 3
49327: PUSH
49328: EMPTY
49329: LIST
49330: LIST
49331: LIST
49332: PUSH
49333: LD_VAR 0 1
49337: PUSH
49338: LD_INT 4
49340: MINUS
49341: PUSH
49342: LD_VAR 0 2
49346: PUSH
49347: LD_INT 4
49349: MINUS
49350: PUSH
49351: LD_INT 2
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: LIST
49358: PUSH
49359: EMPTY
49360: LIST
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: ST_TO_ADDR
// end ; 5 :
49366: GO 49506
49368: LD_INT 5
49370: DOUBLE
49371: EQUAL
49372: IFTRUE 49376
49374: GO 49505
49376: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49377: LD_ADDR_VAR 0 5
49381: PUSH
49382: LD_VAR 0 1
49386: PUSH
49387: LD_INT 4
49389: MINUS
49390: PUSH
49391: LD_VAR 0 2
49395: PUSH
49396: LD_INT 1
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: LIST
49403: PUSH
49404: LD_VAR 0 1
49408: PUSH
49409: LD_VAR 0 2
49413: PUSH
49414: LD_INT 4
49416: MINUS
49417: PUSH
49418: LD_INT 3
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: LIST
49425: PUSH
49426: LD_VAR 0 1
49430: PUSH
49431: LD_INT 4
49433: PLUS
49434: PUSH
49435: LD_VAR 0 2
49439: PUSH
49440: LD_INT 4
49442: PLUS
49443: PUSH
49444: LD_INT 5
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: LIST
49451: PUSH
49452: LD_VAR 0 1
49456: PUSH
49457: LD_INT 3
49459: PLUS
49460: PUSH
49461: LD_VAR 0 2
49465: PUSH
49466: LD_INT 4
49468: PUSH
49469: EMPTY
49470: LIST
49471: LIST
49472: LIST
49473: PUSH
49474: LD_VAR 0 1
49478: PUSH
49479: LD_VAR 0 2
49483: PUSH
49484: LD_INT 3
49486: PLUS
49487: PUSH
49488: LD_INT 0
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: LIST
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: LIST
49500: LIST
49501: LIST
49502: ST_TO_ADDR
// end ; end ;
49503: GO 49506
49505: POP
// result := list ;
49506: LD_ADDR_VAR 0 4
49510: PUSH
49511: LD_VAR 0 5
49515: ST_TO_ADDR
// end ;
49516: LD_VAR 0 4
49520: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49521: LD_INT 0
49523: PPUSH
49524: PPUSH
49525: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49526: LD_VAR 0 1
49530: NOT
49531: PUSH
49532: LD_VAR 0 2
49536: PUSH
49537: LD_INT 1
49539: PUSH
49540: LD_INT 2
49542: PUSH
49543: LD_INT 3
49545: PUSH
49546: LD_INT 4
49548: PUSH
49549: EMPTY
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: IN
49555: NOT
49556: OR
49557: IFFALSE 49561
// exit ;
49559: GO 49653
// tmp := [ ] ;
49561: LD_ADDR_VAR 0 5
49565: PUSH
49566: EMPTY
49567: ST_TO_ADDR
// for i in units do
49568: LD_ADDR_VAR 0 4
49572: PUSH
49573: LD_VAR 0 1
49577: PUSH
49578: FOR_IN
49579: IFFALSE 49622
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49581: LD_ADDR_VAR 0 5
49585: PUSH
49586: LD_VAR 0 5
49590: PPUSH
49591: LD_VAR 0 5
49595: PUSH
49596: LD_INT 1
49598: PLUS
49599: PPUSH
49600: LD_VAR 0 4
49604: PPUSH
49605: LD_VAR 0 2
49609: PPUSH
49610: CALL_OW 259
49614: PPUSH
49615: CALL_OW 2
49619: ST_TO_ADDR
49620: GO 49578
49622: POP
49623: POP
// if not tmp then
49624: LD_VAR 0 5
49628: NOT
49629: IFFALSE 49633
// exit ;
49631: GO 49653
// result := SortListByListDesc ( units , tmp ) ;
49633: LD_ADDR_VAR 0 3
49637: PUSH
49638: LD_VAR 0 1
49642: PPUSH
49643: LD_VAR 0 5
49647: PPUSH
49648: CALL_OW 77
49652: ST_TO_ADDR
// end ;
49653: LD_VAR 0 3
49657: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49658: LD_INT 0
49660: PPUSH
49661: PPUSH
49662: PPUSH
// result := false ;
49663: LD_ADDR_VAR 0 3
49667: PUSH
49668: LD_INT 0
49670: ST_TO_ADDR
// x := GetX ( building ) ;
49671: LD_ADDR_VAR 0 4
49675: PUSH
49676: LD_VAR 0 2
49680: PPUSH
49681: CALL_OW 250
49685: ST_TO_ADDR
// y := GetY ( building ) ;
49686: LD_ADDR_VAR 0 5
49690: PUSH
49691: LD_VAR 0 2
49695: PPUSH
49696: CALL_OW 251
49700: ST_TO_ADDR
// if not building or not x or not y then
49701: LD_VAR 0 2
49705: NOT
49706: PUSH
49707: LD_VAR 0 4
49711: NOT
49712: OR
49713: PUSH
49714: LD_VAR 0 5
49718: NOT
49719: OR
49720: IFFALSE 49724
// exit ;
49722: GO 49816
// if GetTaskList ( unit ) then
49724: LD_VAR 0 1
49728: PPUSH
49729: CALL_OW 437
49733: IFFALSE 49816
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49735: LD_STRING e
49737: PUSH
49738: LD_VAR 0 1
49742: PPUSH
49743: CALL_OW 437
49747: PUSH
49748: LD_INT 1
49750: ARRAY
49751: PUSH
49752: LD_INT 1
49754: ARRAY
49755: EQUAL
49756: PUSH
49757: LD_VAR 0 4
49761: PUSH
49762: LD_VAR 0 1
49766: PPUSH
49767: CALL_OW 437
49771: PUSH
49772: LD_INT 1
49774: ARRAY
49775: PUSH
49776: LD_INT 2
49778: ARRAY
49779: EQUAL
49780: AND
49781: PUSH
49782: LD_VAR 0 5
49786: PUSH
49787: LD_VAR 0 1
49791: PPUSH
49792: CALL_OW 437
49796: PUSH
49797: LD_INT 1
49799: ARRAY
49800: PUSH
49801: LD_INT 3
49803: ARRAY
49804: EQUAL
49805: AND
49806: IFFALSE 49816
// result := true end ;
49808: LD_ADDR_VAR 0 3
49812: PUSH
49813: LD_INT 1
49815: ST_TO_ADDR
// end ;
49816: LD_VAR 0 3
49820: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49821: LD_INT 0
49823: PPUSH
// result := false ;
49824: LD_ADDR_VAR 0 4
49828: PUSH
49829: LD_INT 0
49831: ST_TO_ADDR
// if GetTaskList ( unit ) then
49832: LD_VAR 0 1
49836: PPUSH
49837: CALL_OW 437
49841: IFFALSE 49924
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49843: LD_STRING M
49845: PUSH
49846: LD_VAR 0 1
49850: PPUSH
49851: CALL_OW 437
49855: PUSH
49856: LD_INT 1
49858: ARRAY
49859: PUSH
49860: LD_INT 1
49862: ARRAY
49863: EQUAL
49864: PUSH
49865: LD_VAR 0 2
49869: PUSH
49870: LD_VAR 0 1
49874: PPUSH
49875: CALL_OW 437
49879: PUSH
49880: LD_INT 1
49882: ARRAY
49883: PUSH
49884: LD_INT 2
49886: ARRAY
49887: EQUAL
49888: AND
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_VAR 0 1
49899: PPUSH
49900: CALL_OW 437
49904: PUSH
49905: LD_INT 1
49907: ARRAY
49908: PUSH
49909: LD_INT 3
49911: ARRAY
49912: EQUAL
49913: AND
49914: IFFALSE 49924
// result := true ;
49916: LD_ADDR_VAR 0 4
49920: PUSH
49921: LD_INT 1
49923: ST_TO_ADDR
// end ; end ;
49924: LD_VAR 0 4
49928: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49929: LD_INT 0
49931: PPUSH
49932: PPUSH
49933: PPUSH
49934: PPUSH
// if not unit or not area then
49935: LD_VAR 0 1
49939: NOT
49940: PUSH
49941: LD_VAR 0 2
49945: NOT
49946: OR
49947: IFFALSE 49951
// exit ;
49949: GO 50115
// tmp := AreaToList ( area , i ) ;
49951: LD_ADDR_VAR 0 6
49955: PUSH
49956: LD_VAR 0 2
49960: PPUSH
49961: LD_VAR 0 5
49965: PPUSH
49966: CALL_OW 517
49970: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49971: LD_ADDR_VAR 0 5
49975: PUSH
49976: DOUBLE
49977: LD_INT 1
49979: DEC
49980: ST_TO_ADDR
49981: LD_VAR 0 6
49985: PUSH
49986: LD_INT 1
49988: ARRAY
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50113
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49993: LD_ADDR_VAR 0 7
49997: PUSH
49998: LD_VAR 0 6
50002: PUSH
50003: LD_INT 1
50005: ARRAY
50006: PUSH
50007: LD_VAR 0 5
50011: ARRAY
50012: PUSH
50013: LD_VAR 0 6
50017: PUSH
50018: LD_INT 2
50020: ARRAY
50021: PUSH
50022: LD_VAR 0 5
50026: ARRAY
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50032: LD_VAR 0 7
50036: PUSH
50037: LD_INT 1
50039: ARRAY
50040: PPUSH
50041: LD_VAR 0 7
50045: PUSH
50046: LD_INT 2
50048: ARRAY
50049: PPUSH
50050: CALL_OW 428
50054: PUSH
50055: LD_INT 0
50057: EQUAL
50058: IFFALSE 50111
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50060: LD_VAR 0 1
50064: PPUSH
50065: LD_VAR 0 7
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PPUSH
50074: LD_VAR 0 7
50078: PUSH
50079: LD_INT 2
50081: ARRAY
50082: PPUSH
50083: LD_VAR 0 3
50087: PPUSH
50088: CALL_OW 48
// result := IsPlaced ( unit ) ;
50092: LD_ADDR_VAR 0 4
50096: PUSH
50097: LD_VAR 0 1
50101: PPUSH
50102: CALL_OW 305
50106: ST_TO_ADDR
// exit ;
50107: POP
50108: POP
50109: GO 50115
// end ; end ;
50111: GO 49990
50113: POP
50114: POP
// end ;
50115: LD_VAR 0 4
50119: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50120: LD_INT 0
50122: PPUSH
50123: PPUSH
50124: PPUSH
// if not side or side > 8 then
50125: LD_VAR 0 1
50129: NOT
50130: PUSH
50131: LD_VAR 0 1
50135: PUSH
50136: LD_INT 8
50138: GREATER
50139: OR
50140: IFFALSE 50144
// exit ;
50142: GO 50331
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50144: LD_ADDR_VAR 0 4
50148: PUSH
50149: LD_INT 22
50151: PUSH
50152: LD_VAR 0 1
50156: PUSH
50157: EMPTY
50158: LIST
50159: LIST
50160: PUSH
50161: LD_INT 21
50163: PUSH
50164: LD_INT 3
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: EMPTY
50172: LIST
50173: LIST
50174: PPUSH
50175: CALL_OW 69
50179: ST_TO_ADDR
// if not tmp then
50180: LD_VAR 0 4
50184: NOT
50185: IFFALSE 50189
// exit ;
50187: GO 50331
// enable_addtolog := true ;
50189: LD_ADDR_OWVAR 81
50193: PUSH
50194: LD_INT 1
50196: ST_TO_ADDR
// AddToLog ( [ ) ;
50197: LD_STRING [
50199: PPUSH
50200: CALL_OW 561
// for i in tmp do
50204: LD_ADDR_VAR 0 3
50208: PUSH
50209: LD_VAR 0 4
50213: PUSH
50214: FOR_IN
50215: IFFALSE 50322
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50217: LD_STRING [
50219: PUSH
50220: LD_VAR 0 3
50224: PPUSH
50225: CALL_OW 266
50229: STR
50230: PUSH
50231: LD_STRING , 
50233: STR
50234: PUSH
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 250
50244: STR
50245: PUSH
50246: LD_STRING , 
50248: STR
50249: PUSH
50250: LD_VAR 0 3
50254: PPUSH
50255: CALL_OW 251
50259: STR
50260: PUSH
50261: LD_STRING , 
50263: STR
50264: PUSH
50265: LD_VAR 0 3
50269: PPUSH
50270: CALL_OW 254
50274: STR
50275: PUSH
50276: LD_STRING , 
50278: STR
50279: PUSH
50280: LD_VAR 0 3
50284: PPUSH
50285: LD_INT 1
50287: PPUSH
50288: CALL_OW 268
50292: STR
50293: PUSH
50294: LD_STRING , 
50296: STR
50297: PUSH
50298: LD_VAR 0 3
50302: PPUSH
50303: LD_INT 2
50305: PPUSH
50306: CALL_OW 268
50310: STR
50311: PUSH
50312: LD_STRING ],
50314: STR
50315: PPUSH
50316: CALL_OW 561
// end ;
50320: GO 50214
50322: POP
50323: POP
// AddToLog ( ]; ) ;
50324: LD_STRING ];
50326: PPUSH
50327: CALL_OW 561
// end ;
50331: LD_VAR 0 2
50335: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50336: LD_INT 0
50338: PPUSH
50339: PPUSH
50340: PPUSH
50341: PPUSH
50342: PPUSH
// if not area or not rate or not max then
50343: LD_VAR 0 1
50347: NOT
50348: PUSH
50349: LD_VAR 0 2
50353: NOT
50354: OR
50355: PUSH
50356: LD_VAR 0 4
50360: NOT
50361: OR
50362: IFFALSE 50366
// exit ;
50364: GO 50555
// while 1 do
50366: LD_INT 1
50368: IFFALSE 50555
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50370: LD_ADDR_VAR 0 9
50374: PUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: LD_INT 1
50382: PPUSH
50383: CALL_OW 287
50387: PUSH
50388: LD_INT 10
50390: MUL
50391: ST_TO_ADDR
// r := rate / 10 ;
50392: LD_ADDR_VAR 0 7
50396: PUSH
50397: LD_VAR 0 2
50401: PUSH
50402: LD_INT 10
50404: DIVREAL
50405: ST_TO_ADDR
// time := 1 1$00 ;
50406: LD_ADDR_VAR 0 8
50410: PUSH
50411: LD_INT 2100
50413: ST_TO_ADDR
// if amount < min then
50414: LD_VAR 0 9
50418: PUSH
50419: LD_VAR 0 3
50423: LESS
50424: IFFALSE 50442
// r := r * 2 else
50426: LD_ADDR_VAR 0 7
50430: PUSH
50431: LD_VAR 0 7
50435: PUSH
50436: LD_INT 2
50438: MUL
50439: ST_TO_ADDR
50440: GO 50468
// if amount > max then
50442: LD_VAR 0 9
50446: PUSH
50447: LD_VAR 0 4
50451: GREATER
50452: IFFALSE 50468
// r := r / 2 ;
50454: LD_ADDR_VAR 0 7
50458: PUSH
50459: LD_VAR 0 7
50463: PUSH
50464: LD_INT 2
50466: DIVREAL
50467: ST_TO_ADDR
// time := time / r ;
50468: LD_ADDR_VAR 0 8
50472: PUSH
50473: LD_VAR 0 8
50477: PUSH
50478: LD_VAR 0 7
50482: DIVREAL
50483: ST_TO_ADDR
// if time < 0 then
50484: LD_VAR 0 8
50488: PUSH
50489: LD_INT 0
50491: LESS
50492: IFFALSE 50509
// time := time * - 1 ;
50494: LD_ADDR_VAR 0 8
50498: PUSH
50499: LD_VAR 0 8
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: MUL
50508: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
50509: LD_VAR 0 8
50513: PUSH
50514: LD_INT 35
50516: PPUSH
50517: LD_INT 875
50519: PPUSH
50520: CALL_OW 12
50524: PLUS
50525: PPUSH
50526: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50530: LD_INT 1
50532: PPUSH
50533: LD_INT 5
50535: PPUSH
50536: CALL_OW 12
50540: PPUSH
50541: LD_VAR 0 1
50545: PPUSH
50546: LD_INT 1
50548: PPUSH
50549: CALL_OW 55
// end ;
50553: GO 50366
// end ;
50555: LD_VAR 0 5
50559: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50560: LD_INT 0
50562: PPUSH
50563: PPUSH
50564: PPUSH
50565: PPUSH
50566: PPUSH
50567: PPUSH
50568: PPUSH
50569: PPUSH
// if not turrets or not factories then
50570: LD_VAR 0 1
50574: NOT
50575: PUSH
50576: LD_VAR 0 2
50580: NOT
50581: OR
50582: IFFALSE 50586
// exit ;
50584: GO 50893
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50586: LD_ADDR_VAR 0 10
50590: PUSH
50591: LD_INT 5
50593: PUSH
50594: LD_INT 6
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PUSH
50601: LD_INT 2
50603: PUSH
50604: LD_INT 4
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 3
50613: PUSH
50614: LD_INT 5
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: PUSH
50621: EMPTY
50622: LIST
50623: LIST
50624: LIST
50625: PUSH
50626: LD_INT 24
50628: PUSH
50629: LD_INT 25
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: PUSH
50636: LD_INT 23
50638: PUSH
50639: LD_INT 27
50641: PUSH
50642: EMPTY
50643: LIST
50644: LIST
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PUSH
50650: LD_INT 42
50652: PUSH
50653: LD_INT 43
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PUSH
50660: LD_INT 44
50662: PUSH
50663: LD_INT 46
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: LD_INT 45
50672: PUSH
50673: LD_INT 47
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: EMPTY
50681: LIST
50682: LIST
50683: LIST
50684: PUSH
50685: EMPTY
50686: LIST
50687: LIST
50688: LIST
50689: ST_TO_ADDR
// result := [ ] ;
50690: LD_ADDR_VAR 0 3
50694: PUSH
50695: EMPTY
50696: ST_TO_ADDR
// for i in turrets do
50697: LD_ADDR_VAR 0 4
50701: PUSH
50702: LD_VAR 0 1
50706: PUSH
50707: FOR_IN
50708: IFFALSE 50891
// begin nat := GetNation ( i ) ;
50710: LD_ADDR_VAR 0 7
50714: PUSH
50715: LD_VAR 0 4
50719: PPUSH
50720: CALL_OW 248
50724: ST_TO_ADDR
// weapon := 0 ;
50725: LD_ADDR_VAR 0 8
50729: PUSH
50730: LD_INT 0
50732: ST_TO_ADDR
// if not nat then
50733: LD_VAR 0 7
50737: NOT
50738: IFFALSE 50742
// continue ;
50740: GO 50707
// for j in list [ nat ] do
50742: LD_ADDR_VAR 0 5
50746: PUSH
50747: LD_VAR 0 10
50751: PUSH
50752: LD_VAR 0 7
50756: ARRAY
50757: PUSH
50758: FOR_IN
50759: IFFALSE 50800
// if GetBWeapon ( i ) = j [ 1 ] then
50761: LD_VAR 0 4
50765: PPUSH
50766: CALL_OW 269
50770: PUSH
50771: LD_VAR 0 5
50775: PUSH
50776: LD_INT 1
50778: ARRAY
50779: EQUAL
50780: IFFALSE 50798
// begin weapon := j [ 2 ] ;
50782: LD_ADDR_VAR 0 8
50786: PUSH
50787: LD_VAR 0 5
50791: PUSH
50792: LD_INT 2
50794: ARRAY
50795: ST_TO_ADDR
// break ;
50796: GO 50800
// end ;
50798: GO 50758
50800: POP
50801: POP
// if not weapon then
50802: LD_VAR 0 8
50806: NOT
50807: IFFALSE 50811
// continue ;
50809: GO 50707
// for k in factories do
50811: LD_ADDR_VAR 0 6
50815: PUSH
50816: LD_VAR 0 2
50820: PUSH
50821: FOR_IN
50822: IFFALSE 50887
// begin weapons := AvailableWeaponList ( k ) ;
50824: LD_ADDR_VAR 0 9
50828: PUSH
50829: LD_VAR 0 6
50833: PPUSH
50834: CALL_OW 478
50838: ST_TO_ADDR
// if not weapons then
50839: LD_VAR 0 9
50843: NOT
50844: IFFALSE 50848
// continue ;
50846: GO 50821
// if weapon in weapons then
50848: LD_VAR 0 8
50852: PUSH
50853: LD_VAR 0 9
50857: IN
50858: IFFALSE 50885
// begin result := [ i , weapon ] ;
50860: LD_ADDR_VAR 0 3
50864: PUSH
50865: LD_VAR 0 4
50869: PUSH
50870: LD_VAR 0 8
50874: PUSH
50875: EMPTY
50876: LIST
50877: LIST
50878: ST_TO_ADDR
// exit ;
50879: POP
50880: POP
50881: POP
50882: POP
50883: GO 50893
// end ; end ;
50885: GO 50821
50887: POP
50888: POP
// end ;
50889: GO 50707
50891: POP
50892: POP
// end ;
50893: LD_VAR 0 3
50897: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50898: LD_INT 0
50900: PPUSH
// if not side or side > 8 then
50901: LD_VAR 0 3
50905: NOT
50906: PUSH
50907: LD_VAR 0 3
50911: PUSH
50912: LD_INT 8
50914: GREATER
50915: OR
50916: IFFALSE 50920
// exit ;
50918: GO 50979
// if not range then
50920: LD_VAR 0 4
50924: NOT
50925: IFFALSE 50936
// range := - 12 ;
50927: LD_ADDR_VAR 0 4
50931: PUSH
50932: LD_INT 12
50934: NEG
50935: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50936: LD_VAR 0 1
50940: PPUSH
50941: LD_VAR 0 2
50945: PPUSH
50946: LD_VAR 0 3
50950: PPUSH
50951: LD_VAR 0 4
50955: PPUSH
50956: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50960: LD_VAR 0 1
50964: PPUSH
50965: LD_VAR 0 2
50969: PPUSH
50970: LD_VAR 0 3
50974: PPUSH
50975: CALL_OW 331
// end ;
50979: LD_VAR 0 5
50983: RET
// export function Video ( mode ) ; begin
50984: LD_INT 0
50986: PPUSH
// ingame_video = mode ;
50987: LD_ADDR_OWVAR 52
50991: PUSH
50992: LD_VAR 0 1
50996: ST_TO_ADDR
// interface_hidden = mode ;
50997: LD_ADDR_OWVAR 54
51001: PUSH
51002: LD_VAR 0 1
51006: ST_TO_ADDR
// end ;
51007: LD_VAR 0 2
51011: RET
// export function Join ( array , element ) ; begin
51012: LD_INT 0
51014: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51015: LD_ADDR_VAR 0 3
51019: PUSH
51020: LD_VAR 0 1
51024: PPUSH
51025: LD_VAR 0 1
51029: PUSH
51030: LD_INT 1
51032: PLUS
51033: PPUSH
51034: LD_VAR 0 2
51038: PPUSH
51039: CALL_OW 1
51043: ST_TO_ADDR
// end ;
51044: LD_VAR 0 3
51048: RET
// export function JoinUnion ( array , element ) ; begin
51049: LD_INT 0
51051: PPUSH
// result := array union element ;
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: LD_VAR 0 1
51061: PUSH
51062: LD_VAR 0 2
51066: UNION
51067: ST_TO_ADDR
// end ;
51068: LD_VAR 0 3
51072: RET
// export function GetBehemoths ( side ) ; begin
51073: LD_INT 0
51075: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
51076: LD_ADDR_VAR 0 2
51080: PUSH
51081: LD_INT 22
51083: PUSH
51084: LD_VAR 0 1
51088: PUSH
51089: EMPTY
51090: LIST
51091: LIST
51092: PUSH
51093: LD_INT 31
51095: PUSH
51096: LD_INT 25
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: PPUSH
51107: CALL_OW 69
51111: ST_TO_ADDR
// end ;
51112: LD_VAR 0 2
51116: RET
// export function Shuffle ( array ) ; var i , index ; begin
51117: LD_INT 0
51119: PPUSH
51120: PPUSH
51121: PPUSH
// result := [ ] ;
51122: LD_ADDR_VAR 0 2
51126: PUSH
51127: EMPTY
51128: ST_TO_ADDR
// if not array then
51129: LD_VAR 0 1
51133: NOT
51134: IFFALSE 51138
// exit ;
51136: GO 51237
// Randomize ;
51138: CALL_OW 10
// for i = array downto 1 do
51142: LD_ADDR_VAR 0 3
51146: PUSH
51147: DOUBLE
51148: LD_VAR 0 1
51152: INC
51153: ST_TO_ADDR
51154: LD_INT 1
51156: PUSH
51157: FOR_DOWNTO
51158: IFFALSE 51235
// begin index := rand ( 1 , array ) ;
51160: LD_ADDR_VAR 0 4
51164: PUSH
51165: LD_INT 1
51167: PPUSH
51168: LD_VAR 0 1
51172: PPUSH
51173: CALL_OW 12
51177: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51178: LD_ADDR_VAR 0 2
51182: PUSH
51183: LD_VAR 0 2
51187: PPUSH
51188: LD_VAR 0 2
51192: PUSH
51193: LD_INT 1
51195: PLUS
51196: PPUSH
51197: LD_VAR 0 1
51201: PUSH
51202: LD_VAR 0 4
51206: ARRAY
51207: PPUSH
51208: CALL_OW 2
51212: ST_TO_ADDR
// array := Delete ( array , index ) ;
51213: LD_ADDR_VAR 0 1
51217: PUSH
51218: LD_VAR 0 1
51222: PPUSH
51223: LD_VAR 0 4
51227: PPUSH
51228: CALL_OW 3
51232: ST_TO_ADDR
// end ;
51233: GO 51157
51235: POP
51236: POP
// end ;
51237: LD_VAR 0 2
51241: RET
// export function GetBaseMaterials ( base ) ; begin
51242: LD_INT 0
51244: PPUSH
// result := [ 0 , 0 , 0 ] ;
51245: LD_ADDR_VAR 0 2
51249: PUSH
51250: LD_INT 0
51252: PUSH
51253: LD_INT 0
51255: PUSH
51256: LD_INT 0
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: LIST
51263: ST_TO_ADDR
// if not base then
51264: LD_VAR 0 1
51268: NOT
51269: IFFALSE 51273
// exit ;
51271: GO 51322
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51273: LD_ADDR_VAR 0 2
51277: PUSH
51278: LD_VAR 0 1
51282: PPUSH
51283: LD_INT 1
51285: PPUSH
51286: CALL_OW 275
51290: PUSH
51291: LD_VAR 0 1
51295: PPUSH
51296: LD_INT 2
51298: PPUSH
51299: CALL_OW 275
51303: PUSH
51304: LD_VAR 0 1
51308: PPUSH
51309: LD_INT 3
51311: PPUSH
51312: CALL_OW 275
51316: PUSH
51317: EMPTY
51318: LIST
51319: LIST
51320: LIST
51321: ST_TO_ADDR
// end ;
51322: LD_VAR 0 2
51326: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51327: LD_INT 0
51329: PPUSH
51330: PPUSH
// result := array ;
51331: LD_ADDR_VAR 0 3
51335: PUSH
51336: LD_VAR 0 1
51340: ST_TO_ADDR
// if size >= result then
51341: LD_VAR 0 2
51345: PUSH
51346: LD_VAR 0 3
51350: GREATEREQUAL
51351: IFFALSE 51355
// exit ;
51353: GO 51405
// if size then
51355: LD_VAR 0 2
51359: IFFALSE 51405
// for i := array downto size do
51361: LD_ADDR_VAR 0 4
51365: PUSH
51366: DOUBLE
51367: LD_VAR 0 1
51371: INC
51372: ST_TO_ADDR
51373: LD_VAR 0 2
51377: PUSH
51378: FOR_DOWNTO
51379: IFFALSE 51403
// result := Delete ( result , result ) ;
51381: LD_ADDR_VAR 0 3
51385: PUSH
51386: LD_VAR 0 3
51390: PPUSH
51391: LD_VAR 0 3
51395: PPUSH
51396: CALL_OW 3
51400: ST_TO_ADDR
51401: GO 51378
51403: POP
51404: POP
// end ;
51405: LD_VAR 0 3
51409: RET
// export function ComExit ( unit ) ; var tmp ; begin
51410: LD_INT 0
51412: PPUSH
51413: PPUSH
// if not IsInUnit ( unit ) then
51414: LD_VAR 0 1
51418: PPUSH
51419: CALL_OW 310
51423: NOT
51424: IFFALSE 51428
// exit ;
51426: GO 51488
// tmp := IsInUnit ( unit ) ;
51428: LD_ADDR_VAR 0 3
51432: PUSH
51433: LD_VAR 0 1
51437: PPUSH
51438: CALL_OW 310
51442: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51443: LD_VAR 0 3
51447: PPUSH
51448: CALL_OW 247
51452: PUSH
51453: LD_INT 2
51455: EQUAL
51456: IFFALSE 51469
// ComExitVehicle ( unit ) else
51458: LD_VAR 0 1
51462: PPUSH
51463: CALL_OW 121
51467: GO 51478
// ComExitBuilding ( unit ) ;
51469: LD_VAR 0 1
51473: PPUSH
51474: CALL_OW 122
// result := tmp ;
51478: LD_ADDR_VAR 0 2
51482: PUSH
51483: LD_VAR 0 3
51487: ST_TO_ADDR
// end ;
51488: LD_VAR 0 2
51492: RET
// export function ComExitAll ( units ) ; var i ; begin
51493: LD_INT 0
51495: PPUSH
51496: PPUSH
// if not units then
51497: LD_VAR 0 1
51501: NOT
51502: IFFALSE 51506
// exit ;
51504: GO 51532
// for i in units do
51506: LD_ADDR_VAR 0 3
51510: PUSH
51511: LD_VAR 0 1
51515: PUSH
51516: FOR_IN
51517: IFFALSE 51530
// ComExit ( i ) ;
51519: LD_VAR 0 3
51523: PPUSH
51524: CALL 51410 0 1
51528: GO 51516
51530: POP
51531: POP
// end ;
51532: LD_VAR 0 2
51536: RET
// export function ResetHc ; begin
51537: LD_INT 0
51539: PPUSH
// InitHc ;
51540: CALL_OW 19
// hc_importance := 0 ;
51544: LD_ADDR_OWVAR 32
51548: PUSH
51549: LD_INT 0
51551: ST_TO_ADDR
// end ;
51552: LD_VAR 0 1
51556: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51557: LD_INT 0
51559: PPUSH
51560: PPUSH
51561: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51562: LD_ADDR_VAR 0 6
51566: PUSH
51567: LD_VAR 0 1
51571: PUSH
51572: LD_VAR 0 3
51576: PLUS
51577: PUSH
51578: LD_INT 2
51580: DIV
51581: ST_TO_ADDR
// if _x < 0 then
51582: LD_VAR 0 6
51586: PUSH
51587: LD_INT 0
51589: LESS
51590: IFFALSE 51607
// _x := _x * - 1 ;
51592: LD_ADDR_VAR 0 6
51596: PUSH
51597: LD_VAR 0 6
51601: PUSH
51602: LD_INT 1
51604: NEG
51605: MUL
51606: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51607: LD_ADDR_VAR 0 7
51611: PUSH
51612: LD_VAR 0 2
51616: PUSH
51617: LD_VAR 0 4
51621: PLUS
51622: PUSH
51623: LD_INT 2
51625: DIV
51626: ST_TO_ADDR
// if _y < 0 then
51627: LD_VAR 0 7
51631: PUSH
51632: LD_INT 0
51634: LESS
51635: IFFALSE 51652
// _y := _y * - 1 ;
51637: LD_ADDR_VAR 0 7
51641: PUSH
51642: LD_VAR 0 7
51646: PUSH
51647: LD_INT 1
51649: NEG
51650: MUL
51651: ST_TO_ADDR
// result := [ _x , _y ] ;
51652: LD_ADDR_VAR 0 5
51656: PUSH
51657: LD_VAR 0 6
51661: PUSH
51662: LD_VAR 0 7
51666: PUSH
51667: EMPTY
51668: LIST
51669: LIST
51670: ST_TO_ADDR
// end ;
51671: LD_VAR 0 5
51675: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51676: LD_INT 0
51678: PPUSH
51679: PPUSH
51680: PPUSH
51681: PPUSH
// task := GetTaskList ( unit ) ;
51682: LD_ADDR_VAR 0 7
51686: PUSH
51687: LD_VAR 0 1
51691: PPUSH
51692: CALL_OW 437
51696: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51697: LD_VAR 0 7
51701: NOT
51702: PUSH
51703: LD_VAR 0 1
51707: PPUSH
51708: LD_VAR 0 2
51712: PPUSH
51713: CALL_OW 308
51717: NOT
51718: AND
51719: IFFALSE 51723
// exit ;
51721: GO 51841
// if IsInArea ( unit , area ) then
51723: LD_VAR 0 1
51727: PPUSH
51728: LD_VAR 0 2
51732: PPUSH
51733: CALL_OW 308
51737: IFFALSE 51755
// begin ComMoveToArea ( unit , goAway ) ;
51739: LD_VAR 0 1
51743: PPUSH
51744: LD_VAR 0 3
51748: PPUSH
51749: CALL_OW 113
// exit ;
51753: GO 51841
// end ; if task [ 1 ] [ 1 ] <> M then
51755: LD_VAR 0 7
51759: PUSH
51760: LD_INT 1
51762: ARRAY
51763: PUSH
51764: LD_INT 1
51766: ARRAY
51767: PUSH
51768: LD_STRING M
51770: NONEQUAL
51771: IFFALSE 51775
// exit ;
51773: GO 51841
// x := task [ 1 ] [ 2 ] ;
51775: LD_ADDR_VAR 0 5
51779: PUSH
51780: LD_VAR 0 7
51784: PUSH
51785: LD_INT 1
51787: ARRAY
51788: PUSH
51789: LD_INT 2
51791: ARRAY
51792: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51793: LD_ADDR_VAR 0 6
51797: PUSH
51798: LD_VAR 0 7
51802: PUSH
51803: LD_INT 1
51805: ARRAY
51806: PUSH
51807: LD_INT 3
51809: ARRAY
51810: ST_TO_ADDR
// if InArea ( x , y , area ) then
51811: LD_VAR 0 5
51815: PPUSH
51816: LD_VAR 0 6
51820: PPUSH
51821: LD_VAR 0 2
51825: PPUSH
51826: CALL_OW 309
51830: IFFALSE 51841
// ComStop ( unit ) ;
51832: LD_VAR 0 1
51836: PPUSH
51837: CALL_OW 141
// end ;
51841: LD_VAR 0 4
51845: RET
// export function Abs ( value ) ; begin
51846: LD_INT 0
51848: PPUSH
// result := value ;
51849: LD_ADDR_VAR 0 2
51853: PUSH
51854: LD_VAR 0 1
51858: ST_TO_ADDR
// if value < 0 then
51859: LD_VAR 0 1
51863: PUSH
51864: LD_INT 0
51866: LESS
51867: IFFALSE 51884
// result := value * - 1 ;
51869: LD_ADDR_VAR 0 2
51873: PUSH
51874: LD_VAR 0 1
51878: PUSH
51879: LD_INT 1
51881: NEG
51882: MUL
51883: ST_TO_ADDR
// end ;
51884: LD_VAR 0 2
51888: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51889: LD_INT 0
51891: PPUSH
51892: PPUSH
51893: PPUSH
51894: PPUSH
51895: PPUSH
51896: PPUSH
51897: PPUSH
51898: PPUSH
// if not unit or not building then
51899: LD_VAR 0 1
51903: NOT
51904: PUSH
51905: LD_VAR 0 2
51909: NOT
51910: OR
51911: IFFALSE 51915
// exit ;
51913: GO 52141
// x := GetX ( building ) ;
51915: LD_ADDR_VAR 0 4
51919: PUSH
51920: LD_VAR 0 2
51924: PPUSH
51925: CALL_OW 250
51929: ST_TO_ADDR
// y := GetY ( building ) ;
51930: LD_ADDR_VAR 0 6
51934: PUSH
51935: LD_VAR 0 2
51939: PPUSH
51940: CALL_OW 251
51944: ST_TO_ADDR
// d := GetDir ( building ) ;
51945: LD_ADDR_VAR 0 8
51949: PUSH
51950: LD_VAR 0 2
51954: PPUSH
51955: CALL_OW 254
51959: ST_TO_ADDR
// r := 4 ;
51960: LD_ADDR_VAR 0 9
51964: PUSH
51965: LD_INT 4
51967: ST_TO_ADDR
// for i := 1 to 5 do
51968: LD_ADDR_VAR 0 10
51972: PUSH
51973: DOUBLE
51974: LD_INT 1
51976: DEC
51977: ST_TO_ADDR
51978: LD_INT 5
51980: PUSH
51981: FOR_TO
51982: IFFALSE 52139
// begin _x := ShiftX ( x , d , r + i ) ;
51984: LD_ADDR_VAR 0 5
51988: PUSH
51989: LD_VAR 0 4
51993: PPUSH
51994: LD_VAR 0 8
51998: PPUSH
51999: LD_VAR 0 9
52003: PUSH
52004: LD_VAR 0 10
52008: PLUS
52009: PPUSH
52010: CALL_OW 272
52014: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52015: LD_ADDR_VAR 0 7
52019: PUSH
52020: LD_VAR 0 6
52024: PPUSH
52025: LD_VAR 0 8
52029: PPUSH
52030: LD_VAR 0 9
52034: PUSH
52035: LD_VAR 0 10
52039: PLUS
52040: PPUSH
52041: CALL_OW 273
52045: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52046: LD_VAR 0 5
52050: PPUSH
52051: LD_VAR 0 7
52055: PPUSH
52056: CALL_OW 488
52060: PUSH
52061: LD_VAR 0 5
52065: PPUSH
52066: LD_VAR 0 7
52070: PPUSH
52071: CALL_OW 428
52075: PPUSH
52076: CALL_OW 247
52080: PUSH
52081: LD_INT 3
52083: PUSH
52084: LD_INT 2
52086: PUSH
52087: EMPTY
52088: LIST
52089: LIST
52090: IN
52091: NOT
52092: AND
52093: IFFALSE 52137
// begin ComMoveXY ( unit , _x , _y ) ;
52095: LD_VAR 0 1
52099: PPUSH
52100: LD_VAR 0 5
52104: PPUSH
52105: LD_VAR 0 7
52109: PPUSH
52110: CALL_OW 111
// result := [ _x , _y ] ;
52114: LD_ADDR_VAR 0 3
52118: PUSH
52119: LD_VAR 0 5
52123: PUSH
52124: LD_VAR 0 7
52128: PUSH
52129: EMPTY
52130: LIST
52131: LIST
52132: ST_TO_ADDR
// exit ;
52133: POP
52134: POP
52135: GO 52141
// end ; end ;
52137: GO 51981
52139: POP
52140: POP
// end ;
52141: LD_VAR 0 3
52145: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52146: LD_INT 0
52148: PPUSH
52149: PPUSH
52150: PPUSH
// result := 0 ;
52151: LD_ADDR_VAR 0 3
52155: PUSH
52156: LD_INT 0
52158: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52159: LD_VAR 0 1
52163: PUSH
52164: LD_INT 0
52166: LESS
52167: PUSH
52168: LD_VAR 0 1
52172: PUSH
52173: LD_INT 8
52175: GREATER
52176: OR
52177: PUSH
52178: LD_VAR 0 2
52182: PUSH
52183: LD_INT 0
52185: LESS
52186: OR
52187: PUSH
52188: LD_VAR 0 2
52192: PUSH
52193: LD_INT 8
52195: GREATER
52196: OR
52197: IFFALSE 52201
// exit ;
52199: GO 52276
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52201: LD_ADDR_VAR 0 4
52205: PUSH
52206: LD_INT 22
52208: PUSH
52209: LD_VAR 0 2
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: PPUSH
52218: CALL_OW 69
52222: PUSH
52223: FOR_IN
52224: IFFALSE 52274
// begin un := UnitShoot ( i ) ;
52226: LD_ADDR_VAR 0 5
52230: PUSH
52231: LD_VAR 0 4
52235: PPUSH
52236: CALL_OW 504
52240: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52241: LD_VAR 0 5
52245: PPUSH
52246: CALL_OW 255
52250: PUSH
52251: LD_VAR 0 1
52255: EQUAL
52256: IFFALSE 52272
// begin result := un ;
52258: LD_ADDR_VAR 0 3
52262: PUSH
52263: LD_VAR 0 5
52267: ST_TO_ADDR
// exit ;
52268: POP
52269: POP
52270: GO 52276
// end ; end ;
52272: GO 52223
52274: POP
52275: POP
// end ;
52276: LD_VAR 0 3
52280: RET
// export function GetCargoBay ( units ) ; begin
52281: LD_INT 0
52283: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52284: LD_ADDR_VAR 0 2
52288: PUSH
52289: LD_VAR 0 1
52293: PPUSH
52294: LD_INT 2
52296: PUSH
52297: LD_INT 34
52299: PUSH
52300: LD_INT 12
52302: PUSH
52303: EMPTY
52304: LIST
52305: LIST
52306: PUSH
52307: LD_INT 34
52309: PUSH
52310: LD_INT 51
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: PUSH
52317: LD_INT 34
52319: PUSH
52320: LD_INT 32
52322: PUSH
52323: EMPTY
52324: LIST
52325: LIST
52326: PUSH
52327: LD_INT 34
52329: PUSH
52330: LD_EXP 49
52334: PUSH
52335: EMPTY
52336: LIST
52337: LIST
52338: PUSH
52339: EMPTY
52340: LIST
52341: LIST
52342: LIST
52343: LIST
52344: LIST
52345: PPUSH
52346: CALL_OW 72
52350: ST_TO_ADDR
// end ;
52351: LD_VAR 0 2
52355: RET
// export function Negate ( value ) ; begin
52356: LD_INT 0
52358: PPUSH
// result := not value ;
52359: LD_ADDR_VAR 0 2
52363: PUSH
52364: LD_VAR 0 1
52368: NOT
52369: ST_TO_ADDR
// end ;
52370: LD_VAR 0 2
52374: RET
// export function Inc ( value ) ; begin
52375: LD_INT 0
52377: PPUSH
// result := value + 1 ;
52378: LD_ADDR_VAR 0 2
52382: PUSH
52383: LD_VAR 0 1
52387: PUSH
52388: LD_INT 1
52390: PLUS
52391: ST_TO_ADDR
// end ;
52392: LD_VAR 0 2
52396: RET
// export function Dec ( value ) ; begin
52397: LD_INT 0
52399: PPUSH
// result := value - 1 ;
52400: LD_ADDR_VAR 0 2
52404: PUSH
52405: LD_VAR 0 1
52409: PUSH
52410: LD_INT 1
52412: MINUS
52413: ST_TO_ADDR
// end ;
52414: LD_VAR 0 2
52418: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52419: LD_INT 0
52421: PPUSH
52422: PPUSH
52423: PPUSH
52424: PPUSH
52425: PPUSH
52426: PPUSH
52427: PPUSH
52428: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52429: LD_VAR 0 1
52433: PPUSH
52434: LD_VAR 0 2
52438: PPUSH
52439: CALL_OW 488
52443: NOT
52444: PUSH
52445: LD_VAR 0 3
52449: PPUSH
52450: LD_VAR 0 4
52454: PPUSH
52455: CALL_OW 488
52459: NOT
52460: OR
52461: IFFALSE 52474
// begin result := - 1 ;
52463: LD_ADDR_VAR 0 5
52467: PUSH
52468: LD_INT 1
52470: NEG
52471: ST_TO_ADDR
// exit ;
52472: GO 52709
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
52474: LD_ADDR_VAR 0 12
52478: PUSH
52479: LD_VAR 0 1
52483: PPUSH
52484: LD_VAR 0 2
52488: PPUSH
52489: LD_VAR 0 3
52493: PPUSH
52494: LD_VAR 0 4
52498: PPUSH
52499: CALL 51557 0 4
52503: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
52504: LD_ADDR_VAR 0 11
52508: PUSH
52509: LD_VAR 0 1
52513: PPUSH
52514: LD_VAR 0 2
52518: PPUSH
52519: LD_VAR 0 12
52523: PUSH
52524: LD_INT 1
52526: ARRAY
52527: PPUSH
52528: LD_VAR 0 12
52532: PUSH
52533: LD_INT 2
52535: ARRAY
52536: PPUSH
52537: CALL_OW 298
52541: ST_TO_ADDR
// distance := 9999 ;
52542: LD_ADDR_VAR 0 10
52546: PUSH
52547: LD_INT 9999
52549: ST_TO_ADDR
// for i := 0 to 5 do
52550: LD_ADDR_VAR 0 6
52554: PUSH
52555: DOUBLE
52556: LD_INT 0
52558: DEC
52559: ST_TO_ADDR
52560: LD_INT 5
52562: PUSH
52563: FOR_TO
52564: IFFALSE 52707
// begin _x := ShiftX ( x1 , i , centerDist ) ;
52566: LD_ADDR_VAR 0 7
52570: PUSH
52571: LD_VAR 0 1
52575: PPUSH
52576: LD_VAR 0 6
52580: PPUSH
52581: LD_VAR 0 11
52585: PPUSH
52586: CALL_OW 272
52590: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
52591: LD_ADDR_VAR 0 8
52595: PUSH
52596: LD_VAR 0 2
52600: PPUSH
52601: LD_VAR 0 6
52605: PPUSH
52606: LD_VAR 0 11
52610: PPUSH
52611: CALL_OW 273
52615: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52616: LD_VAR 0 7
52620: PPUSH
52621: LD_VAR 0 8
52625: PPUSH
52626: CALL_OW 488
52630: NOT
52631: IFFALSE 52635
// continue ;
52633: GO 52563
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
52635: LD_ADDR_VAR 0 9
52639: PUSH
52640: LD_VAR 0 12
52644: PUSH
52645: LD_INT 1
52647: ARRAY
52648: PPUSH
52649: LD_VAR 0 12
52653: PUSH
52654: LD_INT 2
52656: ARRAY
52657: PPUSH
52658: LD_VAR 0 7
52662: PPUSH
52663: LD_VAR 0 8
52667: PPUSH
52668: CALL_OW 298
52672: ST_TO_ADDR
// if tmp < distance then
52673: LD_VAR 0 9
52677: PUSH
52678: LD_VAR 0 10
52682: LESS
52683: IFFALSE 52705
// begin result := i ;
52685: LD_ADDR_VAR 0 5
52689: PUSH
52690: LD_VAR 0 6
52694: ST_TO_ADDR
// distance := tmp ;
52695: LD_ADDR_VAR 0 10
52699: PUSH
52700: LD_VAR 0 9
52704: ST_TO_ADDR
// end ; end ;
52705: GO 52563
52707: POP
52708: POP
// end ;
52709: LD_VAR 0 5
52713: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52714: LD_INT 0
52716: PPUSH
52717: PPUSH
// if not driver or not IsInUnit ( driver ) then
52718: LD_VAR 0 1
52722: NOT
52723: PUSH
52724: LD_VAR 0 1
52728: PPUSH
52729: CALL_OW 310
52733: NOT
52734: OR
52735: IFFALSE 52739
// exit ;
52737: GO 52829
// vehicle := IsInUnit ( driver ) ;
52739: LD_ADDR_VAR 0 3
52743: PUSH
52744: LD_VAR 0 1
52748: PPUSH
52749: CALL_OW 310
52753: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52754: LD_VAR 0 1
52758: PPUSH
52759: LD_STRING \
52761: PUSH
52762: LD_INT 0
52764: PUSH
52765: LD_INT 0
52767: PUSH
52768: LD_INT 0
52770: PUSH
52771: LD_INT 0
52773: PUSH
52774: LD_INT 0
52776: PUSH
52777: LD_INT 0
52779: PUSH
52780: EMPTY
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: PUSH
52789: LD_STRING E
52791: PUSH
52792: LD_INT 0
52794: PUSH
52795: LD_INT 0
52797: PUSH
52798: LD_VAR 0 3
52802: PUSH
52803: LD_INT 0
52805: PUSH
52806: LD_INT 0
52808: PUSH
52809: LD_INT 0
52811: PUSH
52812: EMPTY
52813: LIST
52814: LIST
52815: LIST
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: PPUSH
52825: CALL_OW 446
// end ;
52829: LD_VAR 0 2
52833: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52834: LD_INT 0
52836: PPUSH
52837: PPUSH
// if not driver or not IsInUnit ( driver ) then
52838: LD_VAR 0 1
52842: NOT
52843: PUSH
52844: LD_VAR 0 1
52848: PPUSH
52849: CALL_OW 310
52853: NOT
52854: OR
52855: IFFALSE 52859
// exit ;
52857: GO 52949
// vehicle := IsInUnit ( driver ) ;
52859: LD_ADDR_VAR 0 3
52863: PUSH
52864: LD_VAR 0 1
52868: PPUSH
52869: CALL_OW 310
52873: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52874: LD_VAR 0 1
52878: PPUSH
52879: LD_STRING \
52881: PUSH
52882: LD_INT 0
52884: PUSH
52885: LD_INT 0
52887: PUSH
52888: LD_INT 0
52890: PUSH
52891: LD_INT 0
52893: PUSH
52894: LD_INT 0
52896: PUSH
52897: LD_INT 0
52899: PUSH
52900: EMPTY
52901: LIST
52902: LIST
52903: LIST
52904: LIST
52905: LIST
52906: LIST
52907: LIST
52908: PUSH
52909: LD_STRING E
52911: PUSH
52912: LD_INT 0
52914: PUSH
52915: LD_INT 0
52917: PUSH
52918: LD_VAR 0 3
52922: PUSH
52923: LD_INT 0
52925: PUSH
52926: LD_INT 0
52928: PUSH
52929: LD_INT 0
52931: PUSH
52932: EMPTY
52933: LIST
52934: LIST
52935: LIST
52936: LIST
52937: LIST
52938: LIST
52939: LIST
52940: PUSH
52941: EMPTY
52942: LIST
52943: LIST
52944: PPUSH
52945: CALL_OW 447
// end ;
52949: LD_VAR 0 2
52953: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52954: LD_INT 0
52956: PPUSH
52957: PPUSH
52958: PPUSH
// tmp := [ ] ;
52959: LD_ADDR_VAR 0 5
52963: PUSH
52964: EMPTY
52965: ST_TO_ADDR
// for i in units do
52966: LD_ADDR_VAR 0 4
52970: PUSH
52971: LD_VAR 0 1
52975: PUSH
52976: FOR_IN
52977: IFFALSE 53015
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52979: LD_ADDR_VAR 0 5
52983: PUSH
52984: LD_VAR 0 5
52988: PPUSH
52989: LD_VAR 0 5
52993: PUSH
52994: LD_INT 1
52996: PLUS
52997: PPUSH
52998: LD_VAR 0 4
53002: PPUSH
53003: CALL_OW 256
53007: PPUSH
53008: CALL_OW 2
53012: ST_TO_ADDR
53013: GO 52976
53015: POP
53016: POP
// if not tmp then
53017: LD_VAR 0 5
53021: NOT
53022: IFFALSE 53026
// exit ;
53024: GO 53074
// if asc then
53026: LD_VAR 0 2
53030: IFFALSE 53054
// result := SortListByListAsc ( units , tmp ) else
53032: LD_ADDR_VAR 0 3
53036: PUSH
53037: LD_VAR 0 1
53041: PPUSH
53042: LD_VAR 0 5
53046: PPUSH
53047: CALL_OW 76
53051: ST_TO_ADDR
53052: GO 53074
// result := SortListByListDesc ( units , tmp ) ;
53054: LD_ADDR_VAR 0 3
53058: PUSH
53059: LD_VAR 0 1
53063: PPUSH
53064: LD_VAR 0 5
53068: PPUSH
53069: CALL_OW 77
53073: ST_TO_ADDR
// end ;
53074: LD_VAR 0 3
53078: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53079: LD_INT 0
53081: PPUSH
53082: PPUSH
// task := GetTaskList ( mech ) ;
53083: LD_ADDR_VAR 0 4
53087: PUSH
53088: LD_VAR 0 1
53092: PPUSH
53093: CALL_OW 437
53097: ST_TO_ADDR
// if not task then
53098: LD_VAR 0 4
53102: NOT
53103: IFFALSE 53107
// exit ;
53105: GO 53149
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53107: LD_ADDR_VAR 0 3
53111: PUSH
53112: LD_VAR 0 4
53116: PUSH
53117: LD_INT 1
53119: ARRAY
53120: PUSH
53121: LD_INT 1
53123: ARRAY
53124: PUSH
53125: LD_STRING r
53127: EQUAL
53128: PUSH
53129: LD_VAR 0 4
53133: PUSH
53134: LD_INT 1
53136: ARRAY
53137: PUSH
53138: LD_INT 4
53140: ARRAY
53141: PUSH
53142: LD_VAR 0 2
53146: EQUAL
53147: AND
53148: ST_TO_ADDR
// end ;
53149: LD_VAR 0 3
53153: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53154: LD_INT 0
53156: PPUSH
// SetDir ( unit , d ) ;
53157: LD_VAR 0 1
53161: PPUSH
53162: LD_VAR 0 4
53166: PPUSH
53167: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53171: LD_VAR 0 1
53175: PPUSH
53176: LD_VAR 0 2
53180: PPUSH
53181: LD_VAR 0 3
53185: PPUSH
53186: LD_VAR 0 5
53190: PPUSH
53191: CALL_OW 48
// end ;
53195: LD_VAR 0 6
53199: RET
// export function ToNaturalNumber ( number ) ; begin
53200: LD_INT 0
53202: PPUSH
// result := number div 1 ;
53203: LD_ADDR_VAR 0 2
53207: PUSH
53208: LD_VAR 0 1
53212: PUSH
53213: LD_INT 1
53215: DIV
53216: ST_TO_ADDR
// if number < 0 then
53217: LD_VAR 0 1
53221: PUSH
53222: LD_INT 0
53224: LESS
53225: IFFALSE 53235
// result := 0 ;
53227: LD_ADDR_VAR 0 2
53231: PUSH
53232: LD_INT 0
53234: ST_TO_ADDR
// end ;
53235: LD_VAR 0 2
53239: RET
// export function SortByClass ( units , class ) ; var un ; begin
53240: LD_INT 0
53242: PPUSH
53243: PPUSH
// if not units or not class then
53244: LD_VAR 0 1
53248: NOT
53249: PUSH
53250: LD_VAR 0 2
53254: NOT
53255: OR
53256: IFFALSE 53260
// exit ;
53258: GO 53355
// result := [ ] ;
53260: LD_ADDR_VAR 0 3
53264: PUSH
53265: EMPTY
53266: ST_TO_ADDR
// for un in units do
53267: LD_ADDR_VAR 0 4
53271: PUSH
53272: LD_VAR 0 1
53276: PUSH
53277: FOR_IN
53278: IFFALSE 53353
// if GetClass ( un ) = class then
53280: LD_VAR 0 4
53284: PPUSH
53285: CALL_OW 257
53289: PUSH
53290: LD_VAR 0 2
53294: EQUAL
53295: IFFALSE 53322
// result := Insert ( result , 1 , un ) else
53297: LD_ADDR_VAR 0 3
53301: PUSH
53302: LD_VAR 0 3
53306: PPUSH
53307: LD_INT 1
53309: PPUSH
53310: LD_VAR 0 4
53314: PPUSH
53315: CALL_OW 2
53319: ST_TO_ADDR
53320: GO 53351
// result := Replace ( result , result + 1 , un ) ;
53322: LD_ADDR_VAR 0 3
53326: PUSH
53327: LD_VAR 0 3
53331: PPUSH
53332: LD_VAR 0 3
53336: PUSH
53337: LD_INT 1
53339: PLUS
53340: PPUSH
53341: LD_VAR 0 4
53345: PPUSH
53346: CALL_OW 1
53350: ST_TO_ADDR
53351: GO 53277
53353: POP
53354: POP
// end ;
53355: LD_VAR 0 3
53359: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53360: LD_INT 0
53362: PPUSH
53363: PPUSH
53364: PPUSH
53365: PPUSH
53366: PPUSH
53367: PPUSH
53368: PPUSH
// result := [ ] ;
53369: LD_ADDR_VAR 0 4
53373: PUSH
53374: EMPTY
53375: ST_TO_ADDR
// if x - r < 0 then
53376: LD_VAR 0 1
53380: PUSH
53381: LD_VAR 0 3
53385: MINUS
53386: PUSH
53387: LD_INT 0
53389: LESS
53390: IFFALSE 53402
// min_x := 0 else
53392: LD_ADDR_VAR 0 8
53396: PUSH
53397: LD_INT 0
53399: ST_TO_ADDR
53400: GO 53418
// min_x := x - r ;
53402: LD_ADDR_VAR 0 8
53406: PUSH
53407: LD_VAR 0 1
53411: PUSH
53412: LD_VAR 0 3
53416: MINUS
53417: ST_TO_ADDR
// if y - r < 0 then
53418: LD_VAR 0 2
53422: PUSH
53423: LD_VAR 0 3
53427: MINUS
53428: PUSH
53429: LD_INT 0
53431: LESS
53432: IFFALSE 53444
// min_y := 0 else
53434: LD_ADDR_VAR 0 7
53438: PUSH
53439: LD_INT 0
53441: ST_TO_ADDR
53442: GO 53460
// min_y := y - r ;
53444: LD_ADDR_VAR 0 7
53448: PUSH
53449: LD_VAR 0 2
53453: PUSH
53454: LD_VAR 0 3
53458: MINUS
53459: ST_TO_ADDR
// max_x := x + r ;
53460: LD_ADDR_VAR 0 9
53464: PUSH
53465: LD_VAR 0 1
53469: PUSH
53470: LD_VAR 0 3
53474: PLUS
53475: ST_TO_ADDR
// max_y := y + r ;
53476: LD_ADDR_VAR 0 10
53480: PUSH
53481: LD_VAR 0 2
53485: PUSH
53486: LD_VAR 0 3
53490: PLUS
53491: ST_TO_ADDR
// for _x = min_x to max_x do
53492: LD_ADDR_VAR 0 5
53496: PUSH
53497: DOUBLE
53498: LD_VAR 0 8
53502: DEC
53503: ST_TO_ADDR
53504: LD_VAR 0 9
53508: PUSH
53509: FOR_TO
53510: IFFALSE 53611
// for _y = min_y to max_y do
53512: LD_ADDR_VAR 0 6
53516: PUSH
53517: DOUBLE
53518: LD_VAR 0 7
53522: DEC
53523: ST_TO_ADDR
53524: LD_VAR 0 10
53528: PUSH
53529: FOR_TO
53530: IFFALSE 53607
// begin if not ValidHex ( _x , _y ) then
53532: LD_VAR 0 5
53536: PPUSH
53537: LD_VAR 0 6
53541: PPUSH
53542: CALL_OW 488
53546: NOT
53547: IFFALSE 53551
// continue ;
53549: GO 53529
// if GetResourceTypeXY ( _x , _y ) then
53551: LD_VAR 0 5
53555: PPUSH
53556: LD_VAR 0 6
53560: PPUSH
53561: CALL_OW 283
53565: IFFALSE 53605
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53567: LD_ADDR_VAR 0 4
53571: PUSH
53572: LD_VAR 0 4
53576: PPUSH
53577: LD_VAR 0 4
53581: PUSH
53582: LD_INT 1
53584: PLUS
53585: PPUSH
53586: LD_VAR 0 5
53590: PUSH
53591: LD_VAR 0 6
53595: PUSH
53596: EMPTY
53597: LIST
53598: LIST
53599: PPUSH
53600: CALL_OW 1
53604: ST_TO_ADDR
// end ;
53605: GO 53529
53607: POP
53608: POP
53609: GO 53509
53611: POP
53612: POP
// end ;
53613: LD_VAR 0 4
53617: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
53618: LD_INT 0
53620: PPUSH
53621: PPUSH
53622: PPUSH
53623: PPUSH
53624: PPUSH
53625: PPUSH
53626: PPUSH
53627: PPUSH
// if not units then
53628: LD_VAR 0 1
53632: NOT
53633: IFFALSE 53637
// exit ;
53635: GO 54163
// result := UnitFilter ( units , [ f_ok ] ) ;
53637: LD_ADDR_VAR 0 3
53641: PUSH
53642: LD_VAR 0 1
53646: PPUSH
53647: LD_INT 50
53649: PUSH
53650: EMPTY
53651: LIST
53652: PPUSH
53653: CALL_OW 72
53657: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53658: LD_ADDR_VAR 0 8
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_INT 1
53670: ARRAY
53671: PPUSH
53672: CALL_OW 255
53676: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
53677: LD_ADDR_VAR 0 10
53681: PUSH
53682: LD_INT 29
53684: PUSH
53685: LD_EXP 52
53689: PUSH
53690: LD_INT 49
53692: PUSH
53693: EMPTY
53694: LIST
53695: LIST
53696: LIST
53697: ST_TO_ADDR
// if not result then
53698: LD_VAR 0 3
53702: NOT
53703: IFFALSE 53707
// exit ;
53705: GO 54163
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53707: LD_ADDR_VAR 0 5
53711: PUSH
53712: LD_INT 81
53714: PUSH
53715: LD_VAR 0 8
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: PPUSH
53724: CALL_OW 69
53728: ST_TO_ADDR
// for i in result do
53729: LD_ADDR_VAR 0 4
53733: PUSH
53734: LD_VAR 0 3
53738: PUSH
53739: FOR_IN
53740: IFFALSE 54161
// begin tag := GetTag ( i ) + 1 ;
53742: LD_ADDR_VAR 0 9
53746: PUSH
53747: LD_VAR 0 4
53751: PPUSH
53752: CALL_OW 110
53756: PUSH
53757: LD_INT 1
53759: PLUS
53760: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53761: LD_ADDR_VAR 0 7
53765: PUSH
53766: LD_VAR 0 4
53770: PPUSH
53771: CALL_OW 250
53775: PPUSH
53776: LD_VAR 0 4
53780: PPUSH
53781: CALL_OW 251
53785: PPUSH
53786: LD_INT 6
53788: PPUSH
53789: CALL 53360 0 3
53793: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53794: LD_VAR 0 4
53798: PPUSH
53799: CALL_OW 247
53803: PUSH
53804: LD_INT 2
53806: EQUAL
53807: PUSH
53808: LD_VAR 0 7
53812: AND
53813: PUSH
53814: LD_VAR 0 4
53818: PPUSH
53819: CALL_OW 264
53823: PUSH
53824: LD_VAR 0 10
53828: IN
53829: NOT
53830: AND
53831: IFFALSE 53870
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53833: LD_VAR 0 4
53837: PPUSH
53838: LD_VAR 0 7
53842: PUSH
53843: LD_INT 1
53845: ARRAY
53846: PUSH
53847: LD_INT 1
53849: ARRAY
53850: PPUSH
53851: LD_VAR 0 7
53855: PUSH
53856: LD_INT 1
53858: ARRAY
53859: PUSH
53860: LD_INT 2
53862: ARRAY
53863: PPUSH
53864: CALL_OW 116
53868: GO 54159
// if path > tag then
53870: LD_VAR 0 2
53874: PUSH
53875: LD_VAR 0 9
53879: GREATER
53880: IFFALSE 54088
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
53882: LD_ADDR_VAR 0 6
53886: PUSH
53887: LD_VAR 0 5
53891: PPUSH
53892: LD_INT 91
53894: PUSH
53895: LD_VAR 0 4
53899: PUSH
53900: LD_INT 8
53902: PUSH
53903: EMPTY
53904: LIST
53905: LIST
53906: LIST
53907: PPUSH
53908: CALL_OW 72
53912: ST_TO_ADDR
// if nearEnemy then
53913: LD_VAR 0 6
53917: IFFALSE 53986
// begin if GetWeapon ( i ) = ru_time_lapser then
53919: LD_VAR 0 4
53923: PPUSH
53924: CALL_OW 264
53928: PUSH
53929: LD_INT 49
53931: EQUAL
53932: IFFALSE 53960
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53934: LD_VAR 0 4
53938: PPUSH
53939: LD_VAR 0 6
53943: PPUSH
53944: LD_VAR 0 4
53948: PPUSH
53949: CALL_OW 74
53953: PPUSH
53954: CALL_OW 112
53958: GO 53984
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
53960: LD_VAR 0 4
53964: PPUSH
53965: LD_VAR 0 6
53969: PPUSH
53970: LD_VAR 0 4
53974: PPUSH
53975: CALL_OW 74
53979: PPUSH
53980: CALL_OW 115
// end else
53984: GO 54086
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53986: LD_VAR 0 4
53990: PPUSH
53991: LD_VAR 0 2
53995: PUSH
53996: LD_VAR 0 9
54000: ARRAY
54001: PUSH
54002: LD_INT 1
54004: ARRAY
54005: PPUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_VAR 0 9
54015: ARRAY
54016: PUSH
54017: LD_INT 2
54019: ARRAY
54020: PPUSH
54021: CALL_OW 297
54025: PUSH
54026: LD_INT 6
54028: GREATER
54029: IFFALSE 54072
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54031: LD_VAR 0 4
54035: PPUSH
54036: LD_VAR 0 2
54040: PUSH
54041: LD_VAR 0 9
54045: ARRAY
54046: PUSH
54047: LD_INT 1
54049: ARRAY
54050: PPUSH
54051: LD_VAR 0 2
54055: PUSH
54056: LD_VAR 0 9
54060: ARRAY
54061: PUSH
54062: LD_INT 2
54064: ARRAY
54065: PPUSH
54066: CALL_OW 114
54070: GO 54086
// SetTag ( i , tag ) ;
54072: LD_VAR 0 4
54076: PPUSH
54077: LD_VAR 0 9
54081: PPUSH
54082: CALL_OW 109
// end else
54086: GO 54159
// if enemy then
54088: LD_VAR 0 5
54092: IFFALSE 54159
// begin if GetWeapon ( i ) = ru_time_lapser then
54094: LD_VAR 0 4
54098: PPUSH
54099: CALL_OW 264
54103: PUSH
54104: LD_INT 49
54106: EQUAL
54107: IFFALSE 54135
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54109: LD_VAR 0 4
54113: PPUSH
54114: LD_VAR 0 5
54118: PPUSH
54119: LD_VAR 0 4
54123: PPUSH
54124: CALL_OW 74
54128: PPUSH
54129: CALL_OW 112
54133: GO 54159
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54135: LD_VAR 0 4
54139: PPUSH
54140: LD_VAR 0 5
54144: PPUSH
54145: LD_VAR 0 4
54149: PPUSH
54150: CALL_OW 74
54154: PPUSH
54155: CALL_OW 115
// end ; end ;
54159: GO 53739
54161: POP
54162: POP
// end ;
54163: LD_VAR 0 3
54167: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54168: LD_INT 0
54170: PPUSH
54171: PPUSH
54172: PPUSH
// if not unit or IsInUnit ( unit ) then
54173: LD_VAR 0 1
54177: NOT
54178: PUSH
54179: LD_VAR 0 1
54183: PPUSH
54184: CALL_OW 310
54188: OR
54189: IFFALSE 54193
// exit ;
54191: GO 54284
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54193: LD_ADDR_VAR 0 4
54197: PUSH
54198: LD_VAR 0 1
54202: PPUSH
54203: CALL_OW 250
54207: PPUSH
54208: LD_VAR 0 2
54212: PPUSH
54213: LD_INT 1
54215: PPUSH
54216: CALL_OW 272
54220: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54221: LD_ADDR_VAR 0 5
54225: PUSH
54226: LD_VAR 0 1
54230: PPUSH
54231: CALL_OW 251
54235: PPUSH
54236: LD_VAR 0 2
54240: PPUSH
54241: LD_INT 1
54243: PPUSH
54244: CALL_OW 273
54248: ST_TO_ADDR
// if ValidHex ( x , y ) then
54249: LD_VAR 0 4
54253: PPUSH
54254: LD_VAR 0 5
54258: PPUSH
54259: CALL_OW 488
54263: IFFALSE 54284
// ComTurnXY ( unit , x , y ) ;
54265: LD_VAR 0 1
54269: PPUSH
54270: LD_VAR 0 4
54274: PPUSH
54275: LD_VAR 0 5
54279: PPUSH
54280: CALL_OW 118
// end ;
54284: LD_VAR 0 3
54288: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54289: LD_INT 0
54291: PPUSH
54292: PPUSH
// result := false ;
54293: LD_ADDR_VAR 0 3
54297: PUSH
54298: LD_INT 0
54300: ST_TO_ADDR
// if not units then
54301: LD_VAR 0 2
54305: NOT
54306: IFFALSE 54310
// exit ;
54308: GO 54355
// for i in units do
54310: LD_ADDR_VAR 0 4
54314: PUSH
54315: LD_VAR 0 2
54319: PUSH
54320: FOR_IN
54321: IFFALSE 54353
// if See ( side , i ) then
54323: LD_VAR 0 1
54327: PPUSH
54328: LD_VAR 0 4
54332: PPUSH
54333: CALL_OW 292
54337: IFFALSE 54351
// begin result := true ;
54339: LD_ADDR_VAR 0 3
54343: PUSH
54344: LD_INT 1
54346: ST_TO_ADDR
// exit ;
54347: POP
54348: POP
54349: GO 54355
// end ;
54351: GO 54320
54353: POP
54354: POP
// end ;
54355: LD_VAR 0 3
54359: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54360: LD_INT 0
54362: PPUSH
54363: PPUSH
54364: PPUSH
54365: PPUSH
// if not unit or not points then
54366: LD_VAR 0 1
54370: NOT
54371: PUSH
54372: LD_VAR 0 2
54376: NOT
54377: OR
54378: IFFALSE 54382
// exit ;
54380: GO 54472
// dist := 99999 ;
54382: LD_ADDR_VAR 0 5
54386: PUSH
54387: LD_INT 99999
54389: ST_TO_ADDR
// for i in points do
54390: LD_ADDR_VAR 0 4
54394: PUSH
54395: LD_VAR 0 2
54399: PUSH
54400: FOR_IN
54401: IFFALSE 54470
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54403: LD_ADDR_VAR 0 6
54407: PUSH
54408: LD_VAR 0 1
54412: PPUSH
54413: LD_VAR 0 4
54417: PUSH
54418: LD_INT 1
54420: ARRAY
54421: PPUSH
54422: LD_VAR 0 4
54426: PUSH
54427: LD_INT 2
54429: ARRAY
54430: PPUSH
54431: CALL_OW 297
54435: ST_TO_ADDR
// if tmpDist < dist then
54436: LD_VAR 0 6
54440: PUSH
54441: LD_VAR 0 5
54445: LESS
54446: IFFALSE 54468
// begin result := i ;
54448: LD_ADDR_VAR 0 3
54452: PUSH
54453: LD_VAR 0 4
54457: ST_TO_ADDR
// dist := tmpDist ;
54458: LD_ADDR_VAR 0 5
54462: PUSH
54463: LD_VAR 0 6
54467: ST_TO_ADDR
// end ; end ;
54468: GO 54400
54470: POP
54471: POP
// end ;
54472: LD_VAR 0 3
54476: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
54477: LD_INT 0
54479: PPUSH
// uc_side := side ;
54480: LD_ADDR_OWVAR 20
54484: PUSH
54485: LD_VAR 0 1
54489: ST_TO_ADDR
// uc_nation := 3 ;
54490: LD_ADDR_OWVAR 21
54494: PUSH
54495: LD_INT 3
54497: ST_TO_ADDR
// vc_chassis := 25 ;
54498: LD_ADDR_OWVAR 37
54502: PUSH
54503: LD_INT 25
54505: ST_TO_ADDR
// vc_engine := engine_siberite ;
54506: LD_ADDR_OWVAR 39
54510: PUSH
54511: LD_INT 3
54513: ST_TO_ADDR
// vc_control := control_computer ;
54514: LD_ADDR_OWVAR 38
54518: PUSH
54519: LD_INT 3
54521: ST_TO_ADDR
// vc_weapon := 59 ;
54522: LD_ADDR_OWVAR 40
54526: PUSH
54527: LD_INT 59
54529: ST_TO_ADDR
// result := CreateVehicle ;
54530: LD_ADDR_VAR 0 5
54534: PUSH
54535: CALL_OW 45
54539: ST_TO_ADDR
// SetDir ( result , d ) ;
54540: LD_VAR 0 5
54544: PPUSH
54545: LD_VAR 0 4
54549: PPUSH
54550: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
54554: LD_VAR 0 5
54558: PPUSH
54559: LD_VAR 0 2
54563: PPUSH
54564: LD_VAR 0 3
54568: PPUSH
54569: LD_INT 0
54571: PPUSH
54572: CALL_OW 48
// end ;
54576: LD_VAR 0 5
54580: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
54581: LD_INT 0
54583: PPUSH
54584: PPUSH
54585: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
54586: LD_ADDR_VAR 0 2
54590: PUSH
54591: LD_INT 0
54593: PUSH
54594: LD_INT 0
54596: PUSH
54597: LD_INT 0
54599: PUSH
54600: LD_INT 0
54602: PUSH
54603: EMPTY
54604: LIST
54605: LIST
54606: LIST
54607: LIST
54608: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
54609: LD_VAR 0 1
54613: NOT
54614: PUSH
54615: LD_VAR 0 1
54619: PPUSH
54620: CALL_OW 264
54624: PUSH
54625: LD_INT 12
54627: PUSH
54628: LD_INT 51
54630: PUSH
54631: LD_INT 32
54633: PUSH
54634: LD_EXP 49
54638: PUSH
54639: EMPTY
54640: LIST
54641: LIST
54642: LIST
54643: LIST
54644: IN
54645: NOT
54646: OR
54647: IFFALSE 54651
// exit ;
54649: GO 54749
// for i := 1 to 3 do
54651: LD_ADDR_VAR 0 3
54655: PUSH
54656: DOUBLE
54657: LD_INT 1
54659: DEC
54660: ST_TO_ADDR
54661: LD_INT 3
54663: PUSH
54664: FOR_TO
54665: IFFALSE 54747
// begin tmp := GetCargo ( cargo , i ) ;
54667: LD_ADDR_VAR 0 4
54671: PUSH
54672: LD_VAR 0 1
54676: PPUSH
54677: LD_VAR 0 3
54681: PPUSH
54682: CALL_OW 289
54686: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
54687: LD_ADDR_VAR 0 2
54691: PUSH
54692: LD_VAR 0 2
54696: PPUSH
54697: LD_VAR 0 3
54701: PPUSH
54702: LD_VAR 0 4
54706: PPUSH
54707: CALL_OW 1
54711: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
54712: LD_ADDR_VAR 0 2
54716: PUSH
54717: LD_VAR 0 2
54721: PPUSH
54722: LD_INT 4
54724: PPUSH
54725: LD_VAR 0 2
54729: PUSH
54730: LD_INT 4
54732: ARRAY
54733: PUSH
54734: LD_VAR 0 4
54738: PLUS
54739: PPUSH
54740: CALL_OW 1
54744: ST_TO_ADDR
// end ;
54745: GO 54664
54747: POP
54748: POP
// end ;
54749: LD_VAR 0 2
54753: RET
// export function Length ( array ) ; begin
54754: LD_INT 0
54756: PPUSH
// result := array + 0 ;
54757: LD_ADDR_VAR 0 2
54761: PUSH
54762: LD_VAR 0 1
54766: PUSH
54767: LD_INT 0
54769: PLUS
54770: ST_TO_ADDR
// end ;
54771: LD_VAR 0 2
54775: RET
// export function PrepareArray ( array ) ; begin
54776: LD_INT 0
54778: PPUSH
// result := array diff 0 ;
54779: LD_ADDR_VAR 0 2
54783: PUSH
54784: LD_VAR 0 1
54788: PUSH
54789: LD_INT 0
54791: DIFF
54792: ST_TO_ADDR
// if not result [ 1 ] then
54793: LD_VAR 0 2
54797: PUSH
54798: LD_INT 1
54800: ARRAY
54801: NOT
54802: IFFALSE 54822
// result := Delete ( result , 1 ) ;
54804: LD_ADDR_VAR 0 2
54808: PUSH
54809: LD_VAR 0 2
54813: PPUSH
54814: LD_INT 1
54816: PPUSH
54817: CALL_OW 3
54821: ST_TO_ADDR
// end ; end_of_file
54822: LD_VAR 0 2
54826: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
54827: LD_INT 0
54829: PPUSH
// ar_miner := 81 ;
54830: LD_ADDR_EXP 55
54834: PUSH
54835: LD_INT 81
54837: ST_TO_ADDR
// ar_crane := 88 ;
54838: LD_ADDR_EXP 54
54842: PUSH
54843: LD_INT 88
54845: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
54846: LD_ADDR_EXP 49
54850: PUSH
54851: LD_INT 89
54853: ST_TO_ADDR
// us_hack := 99 ;
54854: LD_ADDR_EXP 50
54858: PUSH
54859: LD_INT 99
54861: ST_TO_ADDR
// us_artillery := 97 ;
54862: LD_ADDR_EXP 51
54866: PUSH
54867: LD_INT 97
54869: ST_TO_ADDR
// ar_bio_bomb := 91 ;
54870: LD_ADDR_EXP 52
54874: PUSH
54875: LD_INT 91
54877: ST_TO_ADDR
// ar_mortar := 92 ;
54878: LD_ADDR_EXP 53
54882: PUSH
54883: LD_INT 92
54885: ST_TO_ADDR
// ru_flamethrower := 93 ;
54886: LD_ADDR_EXP 56
54890: PUSH
54891: LD_INT 93
54893: ST_TO_ADDR
// ru_radar := 98 ;
54894: LD_ADDR_EXP 48
54898: PUSH
54899: LD_INT 98
54901: ST_TO_ADDR
// tech_Artillery := 80 ;
54902: LD_ADDR_EXP 57
54906: PUSH
54907: LD_INT 80
54909: ST_TO_ADDR
// tech_RadMat := 81 ;
54910: LD_ADDR_EXP 58
54914: PUSH
54915: LD_INT 81
54917: ST_TO_ADDR
// tech_BasicTools := 82 ;
54918: LD_ADDR_EXP 59
54922: PUSH
54923: LD_INT 82
54925: ST_TO_ADDR
// tech_Cargo := 83 ;
54926: LD_ADDR_EXP 60
54930: PUSH
54931: LD_INT 83
54933: ST_TO_ADDR
// tech_Track := 84 ;
54934: LD_ADDR_EXP 61
54938: PUSH
54939: LD_INT 84
54941: ST_TO_ADDR
// tech_Crane := 85 ;
54942: LD_ADDR_EXP 62
54946: PUSH
54947: LD_INT 85
54949: ST_TO_ADDR
// tech_Bulldozer := 86 ;
54950: LD_ADDR_EXP 63
54954: PUSH
54955: LD_INT 86
54957: ST_TO_ADDR
// tech_Hovercraft := 87 ;
54958: LD_ADDR_EXP 64
54962: PUSH
54963: LD_INT 87
54965: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
54966: LD_ADDR_EXP 65
54970: PUSH
54971: LD_INT 88
54973: ST_TO_ADDR
// end ;
54974: LD_VAR 0 1
54978: RET
// every 1 do
54979: GO 54981
54981: DISABLE
// InitGlobalVariables ; end_of_file
54982: CALL 54827 0 0
54986: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54987: LD_INT 0
54989: PPUSH
54990: PPUSH
// skirmish := false ;
54991: LD_ADDR_EXP 66
54995: PUSH
54996: LD_INT 0
54998: ST_TO_ADDR
// debug_mc := false ;
54999: LD_ADDR_EXP 67
55003: PUSH
55004: LD_INT 0
55006: ST_TO_ADDR
// mc_bases := [ ] ;
55007: LD_ADDR_EXP 68
55011: PUSH
55012: EMPTY
55013: ST_TO_ADDR
// mc_sides := [ ] ;
55014: LD_ADDR_EXP 94
55018: PUSH
55019: EMPTY
55020: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55021: LD_ADDR_EXP 69
55025: PUSH
55026: EMPTY
55027: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55028: LD_ADDR_EXP 70
55032: PUSH
55033: EMPTY
55034: ST_TO_ADDR
// mc_need_heal := [ ] ;
55035: LD_ADDR_EXP 71
55039: PUSH
55040: EMPTY
55041: ST_TO_ADDR
// mc_healers := [ ] ;
55042: LD_ADDR_EXP 72
55046: PUSH
55047: EMPTY
55048: ST_TO_ADDR
// mc_build_list := [ ] ;
55049: LD_ADDR_EXP 73
55053: PUSH
55054: EMPTY
55055: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55056: LD_ADDR_EXP 100
55060: PUSH
55061: EMPTY
55062: ST_TO_ADDR
// mc_builders := [ ] ;
55063: LD_ADDR_EXP 74
55067: PUSH
55068: EMPTY
55069: ST_TO_ADDR
// mc_construct_list := [ ] ;
55070: LD_ADDR_EXP 75
55074: PUSH
55075: EMPTY
55076: ST_TO_ADDR
// mc_turret_list := [ ] ;
55077: LD_ADDR_EXP 76
55081: PUSH
55082: EMPTY
55083: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55084: LD_ADDR_EXP 77
55088: PUSH
55089: EMPTY
55090: ST_TO_ADDR
// mc_miners := [ ] ;
55091: LD_ADDR_EXP 82
55095: PUSH
55096: EMPTY
55097: ST_TO_ADDR
// mc_mines := [ ] ;
55098: LD_ADDR_EXP 81
55102: PUSH
55103: EMPTY
55104: ST_TO_ADDR
// mc_minefields := [ ] ;
55105: LD_ADDR_EXP 83
55109: PUSH
55110: EMPTY
55111: ST_TO_ADDR
// mc_crates := [ ] ;
55112: LD_ADDR_EXP 84
55116: PUSH
55117: EMPTY
55118: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55119: LD_ADDR_EXP 85
55123: PUSH
55124: EMPTY
55125: ST_TO_ADDR
// mc_crates_area := [ ] ;
55126: LD_ADDR_EXP 86
55130: PUSH
55131: EMPTY
55132: ST_TO_ADDR
// mc_vehicles := [ ] ;
55133: LD_ADDR_EXP 87
55137: PUSH
55138: EMPTY
55139: ST_TO_ADDR
// mc_attack := [ ] ;
55140: LD_ADDR_EXP 88
55144: PUSH
55145: EMPTY
55146: ST_TO_ADDR
// mc_produce := [ ] ;
55147: LD_ADDR_EXP 89
55151: PUSH
55152: EMPTY
55153: ST_TO_ADDR
// mc_defender := [ ] ;
55154: LD_ADDR_EXP 90
55158: PUSH
55159: EMPTY
55160: ST_TO_ADDR
// mc_parking := [ ] ;
55161: LD_ADDR_EXP 92
55165: PUSH
55166: EMPTY
55167: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55168: LD_ADDR_EXP 78
55172: PUSH
55173: EMPTY
55174: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55175: LD_ADDR_EXP 80
55179: PUSH
55180: EMPTY
55181: ST_TO_ADDR
// mc_scan := [ ] ;
55182: LD_ADDR_EXP 91
55186: PUSH
55187: EMPTY
55188: ST_TO_ADDR
// mc_scan_area := [ ] ;
55189: LD_ADDR_EXP 93
55193: PUSH
55194: EMPTY
55195: ST_TO_ADDR
// mc_tech := [ ] ;
55196: LD_ADDR_EXP 95
55200: PUSH
55201: EMPTY
55202: ST_TO_ADDR
// mc_class := [ ] ;
55203: LD_ADDR_EXP 109
55207: PUSH
55208: EMPTY
55209: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55210: LD_ADDR_EXP 110
55214: PUSH
55215: EMPTY
55216: ST_TO_ADDR
// mc_is_defending := [ ] ;
55217: LD_ADDR_EXP 111
55221: PUSH
55222: EMPTY
55223: ST_TO_ADDR
// end ;
55224: LD_VAR 0 1
55228: RET
// export function MC_Kill ( base ) ; begin
55229: LD_INT 0
55231: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55232: LD_ADDR_EXP 68
55236: PUSH
55237: LD_EXP 68
55241: PPUSH
55242: LD_VAR 0 1
55246: PPUSH
55247: EMPTY
55248: PPUSH
55249: CALL_OW 1
55253: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55254: LD_ADDR_EXP 69
55258: PUSH
55259: LD_EXP 69
55263: PPUSH
55264: LD_VAR 0 1
55268: PPUSH
55269: EMPTY
55270: PPUSH
55271: CALL_OW 1
55275: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55276: LD_ADDR_EXP 70
55280: PUSH
55281: LD_EXP 70
55285: PPUSH
55286: LD_VAR 0 1
55290: PPUSH
55291: EMPTY
55292: PPUSH
55293: CALL_OW 1
55297: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55298: LD_ADDR_EXP 71
55302: PUSH
55303: LD_EXP 71
55307: PPUSH
55308: LD_VAR 0 1
55312: PPUSH
55313: EMPTY
55314: PPUSH
55315: CALL_OW 1
55319: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55320: LD_ADDR_EXP 72
55324: PUSH
55325: LD_EXP 72
55329: PPUSH
55330: LD_VAR 0 1
55334: PPUSH
55335: EMPTY
55336: PPUSH
55337: CALL_OW 1
55341: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55342: LD_ADDR_EXP 73
55346: PUSH
55347: LD_EXP 73
55351: PPUSH
55352: LD_VAR 0 1
55356: PPUSH
55357: EMPTY
55358: PPUSH
55359: CALL_OW 1
55363: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55364: LD_ADDR_EXP 74
55368: PUSH
55369: LD_EXP 74
55373: PPUSH
55374: LD_VAR 0 1
55378: PPUSH
55379: EMPTY
55380: PPUSH
55381: CALL_OW 1
55385: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55386: LD_ADDR_EXP 75
55390: PUSH
55391: LD_EXP 75
55395: PPUSH
55396: LD_VAR 0 1
55400: PPUSH
55401: EMPTY
55402: PPUSH
55403: CALL_OW 1
55407: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55408: LD_ADDR_EXP 76
55412: PUSH
55413: LD_EXP 76
55417: PPUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: EMPTY
55424: PPUSH
55425: CALL_OW 1
55429: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55430: LD_ADDR_EXP 77
55434: PUSH
55435: LD_EXP 77
55439: PPUSH
55440: LD_VAR 0 1
55444: PPUSH
55445: EMPTY
55446: PPUSH
55447: CALL_OW 1
55451: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55452: LD_ADDR_EXP 78
55456: PUSH
55457: LD_EXP 78
55461: PPUSH
55462: LD_VAR 0 1
55466: PPUSH
55467: EMPTY
55468: PPUSH
55469: CALL_OW 1
55473: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55474: LD_ADDR_EXP 79
55478: PUSH
55479: LD_EXP 79
55483: PPUSH
55484: LD_VAR 0 1
55488: PPUSH
55489: LD_INT 0
55491: PPUSH
55492: CALL_OW 1
55496: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55497: LD_ADDR_EXP 80
55501: PUSH
55502: LD_EXP 80
55506: PPUSH
55507: LD_VAR 0 1
55511: PPUSH
55512: EMPTY
55513: PPUSH
55514: CALL_OW 1
55518: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55519: LD_ADDR_EXP 81
55523: PUSH
55524: LD_EXP 81
55528: PPUSH
55529: LD_VAR 0 1
55533: PPUSH
55534: EMPTY
55535: PPUSH
55536: CALL_OW 1
55540: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55541: LD_ADDR_EXP 82
55545: PUSH
55546: LD_EXP 82
55550: PPUSH
55551: LD_VAR 0 1
55555: PPUSH
55556: EMPTY
55557: PPUSH
55558: CALL_OW 1
55562: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55563: LD_ADDR_EXP 83
55567: PUSH
55568: LD_EXP 83
55572: PPUSH
55573: LD_VAR 0 1
55577: PPUSH
55578: EMPTY
55579: PPUSH
55580: CALL_OW 1
55584: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55585: LD_ADDR_EXP 84
55589: PUSH
55590: LD_EXP 84
55594: PPUSH
55595: LD_VAR 0 1
55599: PPUSH
55600: EMPTY
55601: PPUSH
55602: CALL_OW 1
55606: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55607: LD_ADDR_EXP 85
55611: PUSH
55612: LD_EXP 85
55616: PPUSH
55617: LD_VAR 0 1
55621: PPUSH
55622: EMPTY
55623: PPUSH
55624: CALL_OW 1
55628: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55629: LD_ADDR_EXP 86
55633: PUSH
55634: LD_EXP 86
55638: PPUSH
55639: LD_VAR 0 1
55643: PPUSH
55644: EMPTY
55645: PPUSH
55646: CALL_OW 1
55650: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55651: LD_ADDR_EXP 87
55655: PUSH
55656: LD_EXP 87
55660: PPUSH
55661: LD_VAR 0 1
55665: PPUSH
55666: EMPTY
55667: PPUSH
55668: CALL_OW 1
55672: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55673: LD_ADDR_EXP 88
55677: PUSH
55678: LD_EXP 88
55682: PPUSH
55683: LD_VAR 0 1
55687: PPUSH
55688: EMPTY
55689: PPUSH
55690: CALL_OW 1
55694: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55695: LD_ADDR_EXP 89
55699: PUSH
55700: LD_EXP 89
55704: PPUSH
55705: LD_VAR 0 1
55709: PPUSH
55710: EMPTY
55711: PPUSH
55712: CALL_OW 1
55716: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55717: LD_ADDR_EXP 90
55721: PUSH
55722: LD_EXP 90
55726: PPUSH
55727: LD_VAR 0 1
55731: PPUSH
55732: EMPTY
55733: PPUSH
55734: CALL_OW 1
55738: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55739: LD_ADDR_EXP 91
55743: PUSH
55744: LD_EXP 91
55748: PPUSH
55749: LD_VAR 0 1
55753: PPUSH
55754: EMPTY
55755: PPUSH
55756: CALL_OW 1
55760: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55761: LD_ADDR_EXP 92
55765: PUSH
55766: LD_EXP 92
55770: PPUSH
55771: LD_VAR 0 1
55775: PPUSH
55776: EMPTY
55777: PPUSH
55778: CALL_OW 1
55782: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55783: LD_ADDR_EXP 93
55787: PUSH
55788: LD_EXP 93
55792: PPUSH
55793: LD_VAR 0 1
55797: PPUSH
55798: EMPTY
55799: PPUSH
55800: CALL_OW 1
55804: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55805: LD_ADDR_EXP 95
55809: PUSH
55810: LD_EXP 95
55814: PPUSH
55815: LD_VAR 0 1
55819: PPUSH
55820: EMPTY
55821: PPUSH
55822: CALL_OW 1
55826: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55827: LD_ADDR_EXP 97
55831: PUSH
55832: LD_EXP 97
55836: PPUSH
55837: LD_VAR 0 1
55841: PPUSH
55842: EMPTY
55843: PPUSH
55844: CALL_OW 1
55848: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55849: LD_ADDR_EXP 98
55853: PUSH
55854: LD_EXP 98
55858: PPUSH
55859: LD_VAR 0 1
55863: PPUSH
55864: EMPTY
55865: PPUSH
55866: CALL_OW 1
55870: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55871: LD_ADDR_EXP 99
55875: PUSH
55876: LD_EXP 99
55880: PPUSH
55881: LD_VAR 0 1
55885: PPUSH
55886: EMPTY
55887: PPUSH
55888: CALL_OW 1
55892: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55893: LD_ADDR_EXP 100
55897: PUSH
55898: LD_EXP 100
55902: PPUSH
55903: LD_VAR 0 1
55907: PPUSH
55908: EMPTY
55909: PPUSH
55910: CALL_OW 1
55914: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55915: LD_ADDR_EXP 101
55919: PUSH
55920: LD_EXP 101
55924: PPUSH
55925: LD_VAR 0 1
55929: PPUSH
55930: EMPTY
55931: PPUSH
55932: CALL_OW 1
55936: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55937: LD_ADDR_EXP 102
55941: PUSH
55942: LD_EXP 102
55946: PPUSH
55947: LD_VAR 0 1
55951: PPUSH
55952: EMPTY
55953: PPUSH
55954: CALL_OW 1
55958: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55959: LD_ADDR_EXP 103
55963: PUSH
55964: LD_EXP 103
55968: PPUSH
55969: LD_VAR 0 1
55973: PPUSH
55974: EMPTY
55975: PPUSH
55976: CALL_OW 1
55980: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55981: LD_ADDR_EXP 104
55985: PUSH
55986: LD_EXP 104
55990: PPUSH
55991: LD_VAR 0 1
55995: PPUSH
55996: EMPTY
55997: PPUSH
55998: CALL_OW 1
56002: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56003: LD_ADDR_EXP 105
56007: PUSH
56008: LD_EXP 105
56012: PPUSH
56013: LD_VAR 0 1
56017: PPUSH
56018: EMPTY
56019: PPUSH
56020: CALL_OW 1
56024: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56025: LD_ADDR_EXP 106
56029: PUSH
56030: LD_EXP 106
56034: PPUSH
56035: LD_VAR 0 1
56039: PPUSH
56040: EMPTY
56041: PPUSH
56042: CALL_OW 1
56046: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56047: LD_ADDR_EXP 107
56051: PUSH
56052: LD_EXP 107
56056: PPUSH
56057: LD_VAR 0 1
56061: PPUSH
56062: EMPTY
56063: PPUSH
56064: CALL_OW 1
56068: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56069: LD_ADDR_EXP 108
56073: PUSH
56074: LD_EXP 108
56078: PPUSH
56079: LD_VAR 0 1
56083: PPUSH
56084: EMPTY
56085: PPUSH
56086: CALL_OW 1
56090: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56091: LD_ADDR_EXP 109
56095: PUSH
56096: LD_EXP 109
56100: PPUSH
56101: LD_VAR 0 1
56105: PPUSH
56106: EMPTY
56107: PPUSH
56108: CALL_OW 1
56112: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56113: LD_ADDR_EXP 110
56117: PUSH
56118: LD_EXP 110
56122: PPUSH
56123: LD_VAR 0 1
56127: PPUSH
56128: LD_INT 0
56130: PPUSH
56131: CALL_OW 1
56135: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56136: LD_ADDR_EXP 111
56140: PUSH
56141: LD_EXP 111
56145: PPUSH
56146: LD_VAR 0 1
56150: PPUSH
56151: LD_INT 0
56153: PPUSH
56154: CALL_OW 1
56158: ST_TO_ADDR
// end ;
56159: LD_VAR 0 2
56163: RET
// export function MC_Add ( side , units ) ; var base ; begin
56164: LD_INT 0
56166: PPUSH
56167: PPUSH
// base := mc_bases + 1 ;
56168: LD_ADDR_VAR 0 4
56172: PUSH
56173: LD_EXP 68
56177: PUSH
56178: LD_INT 1
56180: PLUS
56181: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56182: LD_ADDR_EXP 94
56186: PUSH
56187: LD_EXP 94
56191: PPUSH
56192: LD_VAR 0 4
56196: PPUSH
56197: LD_VAR 0 1
56201: PPUSH
56202: CALL_OW 1
56206: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56207: LD_ADDR_EXP 68
56211: PUSH
56212: LD_EXP 68
56216: PPUSH
56217: LD_VAR 0 4
56221: PPUSH
56222: LD_VAR 0 2
56226: PPUSH
56227: CALL_OW 1
56231: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56232: LD_ADDR_EXP 69
56236: PUSH
56237: LD_EXP 69
56241: PPUSH
56242: LD_VAR 0 4
56246: PPUSH
56247: EMPTY
56248: PPUSH
56249: CALL_OW 1
56253: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56254: LD_ADDR_EXP 70
56258: PUSH
56259: LD_EXP 70
56263: PPUSH
56264: LD_VAR 0 4
56268: PPUSH
56269: EMPTY
56270: PPUSH
56271: CALL_OW 1
56275: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56276: LD_ADDR_EXP 71
56280: PUSH
56281: LD_EXP 71
56285: PPUSH
56286: LD_VAR 0 4
56290: PPUSH
56291: EMPTY
56292: PPUSH
56293: CALL_OW 1
56297: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56298: LD_ADDR_EXP 72
56302: PUSH
56303: LD_EXP 72
56307: PPUSH
56308: LD_VAR 0 4
56312: PPUSH
56313: EMPTY
56314: PPUSH
56315: CALL_OW 1
56319: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56320: LD_ADDR_EXP 73
56324: PUSH
56325: LD_EXP 73
56329: PPUSH
56330: LD_VAR 0 4
56334: PPUSH
56335: EMPTY
56336: PPUSH
56337: CALL_OW 1
56341: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56342: LD_ADDR_EXP 74
56346: PUSH
56347: LD_EXP 74
56351: PPUSH
56352: LD_VAR 0 4
56356: PPUSH
56357: EMPTY
56358: PPUSH
56359: CALL_OW 1
56363: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56364: LD_ADDR_EXP 75
56368: PUSH
56369: LD_EXP 75
56373: PPUSH
56374: LD_VAR 0 4
56378: PPUSH
56379: EMPTY
56380: PPUSH
56381: CALL_OW 1
56385: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56386: LD_ADDR_EXP 76
56390: PUSH
56391: LD_EXP 76
56395: PPUSH
56396: LD_VAR 0 4
56400: PPUSH
56401: EMPTY
56402: PPUSH
56403: CALL_OW 1
56407: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56408: LD_ADDR_EXP 77
56412: PUSH
56413: LD_EXP 77
56417: PPUSH
56418: LD_VAR 0 4
56422: PPUSH
56423: EMPTY
56424: PPUSH
56425: CALL_OW 1
56429: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56430: LD_ADDR_EXP 78
56434: PUSH
56435: LD_EXP 78
56439: PPUSH
56440: LD_VAR 0 4
56444: PPUSH
56445: EMPTY
56446: PPUSH
56447: CALL_OW 1
56451: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56452: LD_ADDR_EXP 79
56456: PUSH
56457: LD_EXP 79
56461: PPUSH
56462: LD_VAR 0 4
56466: PPUSH
56467: LD_INT 0
56469: PPUSH
56470: CALL_OW 1
56474: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56475: LD_ADDR_EXP 80
56479: PUSH
56480: LD_EXP 80
56484: PPUSH
56485: LD_VAR 0 4
56489: PPUSH
56490: EMPTY
56491: PPUSH
56492: CALL_OW 1
56496: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56497: LD_ADDR_EXP 81
56501: PUSH
56502: LD_EXP 81
56506: PPUSH
56507: LD_VAR 0 4
56511: PPUSH
56512: EMPTY
56513: PPUSH
56514: CALL_OW 1
56518: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56519: LD_ADDR_EXP 82
56523: PUSH
56524: LD_EXP 82
56528: PPUSH
56529: LD_VAR 0 4
56533: PPUSH
56534: EMPTY
56535: PPUSH
56536: CALL_OW 1
56540: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56541: LD_ADDR_EXP 83
56545: PUSH
56546: LD_EXP 83
56550: PPUSH
56551: LD_VAR 0 4
56555: PPUSH
56556: EMPTY
56557: PPUSH
56558: CALL_OW 1
56562: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56563: LD_ADDR_EXP 84
56567: PUSH
56568: LD_EXP 84
56572: PPUSH
56573: LD_VAR 0 4
56577: PPUSH
56578: EMPTY
56579: PPUSH
56580: CALL_OW 1
56584: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56585: LD_ADDR_EXP 85
56589: PUSH
56590: LD_EXP 85
56594: PPUSH
56595: LD_VAR 0 4
56599: PPUSH
56600: EMPTY
56601: PPUSH
56602: CALL_OW 1
56606: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56607: LD_ADDR_EXP 86
56611: PUSH
56612: LD_EXP 86
56616: PPUSH
56617: LD_VAR 0 4
56621: PPUSH
56622: EMPTY
56623: PPUSH
56624: CALL_OW 1
56628: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56629: LD_ADDR_EXP 87
56633: PUSH
56634: LD_EXP 87
56638: PPUSH
56639: LD_VAR 0 4
56643: PPUSH
56644: EMPTY
56645: PPUSH
56646: CALL_OW 1
56650: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56651: LD_ADDR_EXP 88
56655: PUSH
56656: LD_EXP 88
56660: PPUSH
56661: LD_VAR 0 4
56665: PPUSH
56666: EMPTY
56667: PPUSH
56668: CALL_OW 1
56672: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56673: LD_ADDR_EXP 89
56677: PUSH
56678: LD_EXP 89
56682: PPUSH
56683: LD_VAR 0 4
56687: PPUSH
56688: EMPTY
56689: PPUSH
56690: CALL_OW 1
56694: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56695: LD_ADDR_EXP 90
56699: PUSH
56700: LD_EXP 90
56704: PPUSH
56705: LD_VAR 0 4
56709: PPUSH
56710: EMPTY
56711: PPUSH
56712: CALL_OW 1
56716: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56717: LD_ADDR_EXP 91
56721: PUSH
56722: LD_EXP 91
56726: PPUSH
56727: LD_VAR 0 4
56731: PPUSH
56732: EMPTY
56733: PPUSH
56734: CALL_OW 1
56738: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56739: LD_ADDR_EXP 92
56743: PUSH
56744: LD_EXP 92
56748: PPUSH
56749: LD_VAR 0 4
56753: PPUSH
56754: EMPTY
56755: PPUSH
56756: CALL_OW 1
56760: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56761: LD_ADDR_EXP 93
56765: PUSH
56766: LD_EXP 93
56770: PPUSH
56771: LD_VAR 0 4
56775: PPUSH
56776: EMPTY
56777: PPUSH
56778: CALL_OW 1
56782: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56783: LD_ADDR_EXP 95
56787: PUSH
56788: LD_EXP 95
56792: PPUSH
56793: LD_VAR 0 4
56797: PPUSH
56798: EMPTY
56799: PPUSH
56800: CALL_OW 1
56804: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56805: LD_ADDR_EXP 97
56809: PUSH
56810: LD_EXP 97
56814: PPUSH
56815: LD_VAR 0 4
56819: PPUSH
56820: EMPTY
56821: PPUSH
56822: CALL_OW 1
56826: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56827: LD_ADDR_EXP 98
56831: PUSH
56832: LD_EXP 98
56836: PPUSH
56837: LD_VAR 0 4
56841: PPUSH
56842: EMPTY
56843: PPUSH
56844: CALL_OW 1
56848: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56849: LD_ADDR_EXP 99
56853: PUSH
56854: LD_EXP 99
56858: PPUSH
56859: LD_VAR 0 4
56863: PPUSH
56864: EMPTY
56865: PPUSH
56866: CALL_OW 1
56870: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56871: LD_ADDR_EXP 100
56875: PUSH
56876: LD_EXP 100
56880: PPUSH
56881: LD_VAR 0 4
56885: PPUSH
56886: EMPTY
56887: PPUSH
56888: CALL_OW 1
56892: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56893: LD_ADDR_EXP 101
56897: PUSH
56898: LD_EXP 101
56902: PPUSH
56903: LD_VAR 0 4
56907: PPUSH
56908: EMPTY
56909: PPUSH
56910: CALL_OW 1
56914: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56915: LD_ADDR_EXP 102
56919: PUSH
56920: LD_EXP 102
56924: PPUSH
56925: LD_VAR 0 4
56929: PPUSH
56930: EMPTY
56931: PPUSH
56932: CALL_OW 1
56936: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56937: LD_ADDR_EXP 103
56941: PUSH
56942: LD_EXP 103
56946: PPUSH
56947: LD_VAR 0 4
56951: PPUSH
56952: EMPTY
56953: PPUSH
56954: CALL_OW 1
56958: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56959: LD_ADDR_EXP 104
56963: PUSH
56964: LD_EXP 104
56968: PPUSH
56969: LD_VAR 0 4
56973: PPUSH
56974: EMPTY
56975: PPUSH
56976: CALL_OW 1
56980: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56981: LD_ADDR_EXP 105
56985: PUSH
56986: LD_EXP 105
56990: PPUSH
56991: LD_VAR 0 4
56995: PPUSH
56996: EMPTY
56997: PPUSH
56998: CALL_OW 1
57002: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57003: LD_ADDR_EXP 106
57007: PUSH
57008: LD_EXP 106
57012: PPUSH
57013: LD_VAR 0 4
57017: PPUSH
57018: EMPTY
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57025: LD_ADDR_EXP 107
57029: PUSH
57030: LD_EXP 107
57034: PPUSH
57035: LD_VAR 0 4
57039: PPUSH
57040: EMPTY
57041: PPUSH
57042: CALL_OW 1
57046: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57047: LD_ADDR_EXP 108
57051: PUSH
57052: LD_EXP 108
57056: PPUSH
57057: LD_VAR 0 4
57061: PPUSH
57062: EMPTY
57063: PPUSH
57064: CALL_OW 1
57068: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57069: LD_ADDR_EXP 109
57073: PUSH
57074: LD_EXP 109
57078: PPUSH
57079: LD_VAR 0 4
57083: PPUSH
57084: EMPTY
57085: PPUSH
57086: CALL_OW 1
57090: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57091: LD_ADDR_EXP 110
57095: PUSH
57096: LD_EXP 110
57100: PPUSH
57101: LD_VAR 0 4
57105: PPUSH
57106: LD_INT 0
57108: PPUSH
57109: CALL_OW 1
57113: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57114: LD_ADDR_EXP 111
57118: PUSH
57119: LD_EXP 111
57123: PPUSH
57124: LD_VAR 0 4
57128: PPUSH
57129: LD_INT 0
57131: PPUSH
57132: CALL_OW 1
57136: ST_TO_ADDR
// result := base ;
57137: LD_ADDR_VAR 0 3
57141: PUSH
57142: LD_VAR 0 4
57146: ST_TO_ADDR
// end ;
57147: LD_VAR 0 3
57151: RET
// export function MC_Start ( ) ; var i ; begin
57152: LD_INT 0
57154: PPUSH
57155: PPUSH
// for i = 1 to mc_bases do
57156: LD_ADDR_VAR 0 2
57160: PUSH
57161: DOUBLE
57162: LD_INT 1
57164: DEC
57165: ST_TO_ADDR
57166: LD_EXP 68
57170: PUSH
57171: FOR_TO
57172: IFFALSE 58272
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57174: LD_ADDR_EXP 68
57178: PUSH
57179: LD_EXP 68
57183: PPUSH
57184: LD_VAR 0 2
57188: PPUSH
57189: LD_EXP 68
57193: PUSH
57194: LD_VAR 0 2
57198: ARRAY
57199: PUSH
57200: LD_INT 0
57202: DIFF
57203: PPUSH
57204: CALL_OW 1
57208: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57209: LD_ADDR_EXP 69
57213: PUSH
57214: LD_EXP 69
57218: PPUSH
57219: LD_VAR 0 2
57223: PPUSH
57224: EMPTY
57225: PPUSH
57226: CALL_OW 1
57230: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57231: LD_ADDR_EXP 70
57235: PUSH
57236: LD_EXP 70
57240: PPUSH
57241: LD_VAR 0 2
57245: PPUSH
57246: EMPTY
57247: PPUSH
57248: CALL_OW 1
57252: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57253: LD_ADDR_EXP 71
57257: PUSH
57258: LD_EXP 71
57262: PPUSH
57263: LD_VAR 0 2
57267: PPUSH
57268: EMPTY
57269: PPUSH
57270: CALL_OW 1
57274: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57275: LD_ADDR_EXP 72
57279: PUSH
57280: LD_EXP 72
57284: PPUSH
57285: LD_VAR 0 2
57289: PPUSH
57290: EMPTY
57291: PUSH
57292: EMPTY
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: PPUSH
57298: CALL_OW 1
57302: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57303: LD_ADDR_EXP 73
57307: PUSH
57308: LD_EXP 73
57312: PPUSH
57313: LD_VAR 0 2
57317: PPUSH
57318: EMPTY
57319: PPUSH
57320: CALL_OW 1
57324: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57325: LD_ADDR_EXP 100
57329: PUSH
57330: LD_EXP 100
57334: PPUSH
57335: LD_VAR 0 2
57339: PPUSH
57340: EMPTY
57341: PPUSH
57342: CALL_OW 1
57346: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57347: LD_ADDR_EXP 74
57351: PUSH
57352: LD_EXP 74
57356: PPUSH
57357: LD_VAR 0 2
57361: PPUSH
57362: EMPTY
57363: PPUSH
57364: CALL_OW 1
57368: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57369: LD_ADDR_EXP 75
57373: PUSH
57374: LD_EXP 75
57378: PPUSH
57379: LD_VAR 0 2
57383: PPUSH
57384: EMPTY
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57391: LD_ADDR_EXP 76
57395: PUSH
57396: LD_EXP 76
57400: PPUSH
57401: LD_VAR 0 2
57405: PPUSH
57406: LD_EXP 68
57410: PUSH
57411: LD_VAR 0 2
57415: ARRAY
57416: PPUSH
57417: LD_INT 2
57419: PUSH
57420: LD_INT 30
57422: PUSH
57423: LD_INT 32
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: PUSH
57430: LD_INT 30
57432: PUSH
57433: LD_INT 33
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: LIST
57444: PPUSH
57445: CALL_OW 72
57449: PPUSH
57450: CALL_OW 1
57454: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57455: LD_ADDR_EXP 77
57459: PUSH
57460: LD_EXP 77
57464: PPUSH
57465: LD_VAR 0 2
57469: PPUSH
57470: LD_EXP 68
57474: PUSH
57475: LD_VAR 0 2
57479: ARRAY
57480: PPUSH
57481: LD_INT 2
57483: PUSH
57484: LD_INT 30
57486: PUSH
57487: LD_INT 32
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: PUSH
57494: LD_INT 30
57496: PUSH
57497: LD_INT 31
57499: PUSH
57500: EMPTY
57501: LIST
57502: LIST
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: LIST
57508: PUSH
57509: LD_INT 58
57511: PUSH
57512: EMPTY
57513: LIST
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: PPUSH
57519: CALL_OW 72
57523: PPUSH
57524: CALL_OW 1
57528: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57529: LD_ADDR_EXP 78
57533: PUSH
57534: LD_EXP 78
57538: PPUSH
57539: LD_VAR 0 2
57543: PPUSH
57544: EMPTY
57545: PPUSH
57546: CALL_OW 1
57550: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57551: LD_ADDR_EXP 82
57555: PUSH
57556: LD_EXP 82
57560: PPUSH
57561: LD_VAR 0 2
57565: PPUSH
57566: EMPTY
57567: PPUSH
57568: CALL_OW 1
57572: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57573: LD_ADDR_EXP 81
57577: PUSH
57578: LD_EXP 81
57582: PPUSH
57583: LD_VAR 0 2
57587: PPUSH
57588: EMPTY
57589: PPUSH
57590: CALL_OW 1
57594: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57595: LD_ADDR_EXP 83
57599: PUSH
57600: LD_EXP 83
57604: PPUSH
57605: LD_VAR 0 2
57609: PPUSH
57610: EMPTY
57611: PPUSH
57612: CALL_OW 1
57616: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57617: LD_ADDR_EXP 84
57621: PUSH
57622: LD_EXP 84
57626: PPUSH
57627: LD_VAR 0 2
57631: PPUSH
57632: EMPTY
57633: PPUSH
57634: CALL_OW 1
57638: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57639: LD_ADDR_EXP 85
57643: PUSH
57644: LD_EXP 85
57648: PPUSH
57649: LD_VAR 0 2
57653: PPUSH
57654: EMPTY
57655: PPUSH
57656: CALL_OW 1
57660: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57661: LD_ADDR_EXP 86
57665: PUSH
57666: LD_EXP 86
57670: PPUSH
57671: LD_VAR 0 2
57675: PPUSH
57676: EMPTY
57677: PPUSH
57678: CALL_OW 1
57682: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57683: LD_ADDR_EXP 87
57687: PUSH
57688: LD_EXP 87
57692: PPUSH
57693: LD_VAR 0 2
57697: PPUSH
57698: EMPTY
57699: PPUSH
57700: CALL_OW 1
57704: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57705: LD_ADDR_EXP 88
57709: PUSH
57710: LD_EXP 88
57714: PPUSH
57715: LD_VAR 0 2
57719: PPUSH
57720: EMPTY
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57727: LD_ADDR_EXP 89
57731: PUSH
57732: LD_EXP 89
57736: PPUSH
57737: LD_VAR 0 2
57741: PPUSH
57742: EMPTY
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57749: LD_ADDR_EXP 90
57753: PUSH
57754: LD_EXP 90
57758: PPUSH
57759: LD_VAR 0 2
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57771: LD_ADDR_EXP 79
57775: PUSH
57776: LD_EXP 79
57780: PPUSH
57781: LD_VAR 0 2
57785: PPUSH
57786: LD_INT 0
57788: PPUSH
57789: CALL_OW 1
57793: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57794: LD_ADDR_EXP 92
57798: PUSH
57799: LD_EXP 92
57803: PPUSH
57804: LD_VAR 0 2
57808: PPUSH
57809: LD_INT 0
57811: PPUSH
57812: CALL_OW 1
57816: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57817: LD_ADDR_EXP 80
57821: PUSH
57822: LD_EXP 80
57826: PPUSH
57827: LD_VAR 0 2
57831: PPUSH
57832: EMPTY
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57839: LD_ADDR_EXP 91
57843: PUSH
57844: LD_EXP 91
57848: PPUSH
57849: LD_VAR 0 2
57853: PPUSH
57854: LD_INT 0
57856: PPUSH
57857: CALL_OW 1
57861: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57862: LD_ADDR_EXP 93
57866: PUSH
57867: LD_EXP 93
57871: PPUSH
57872: LD_VAR 0 2
57876: PPUSH
57877: EMPTY
57878: PPUSH
57879: CALL_OW 1
57883: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57884: LD_ADDR_EXP 96
57888: PUSH
57889: LD_EXP 96
57893: PPUSH
57894: LD_VAR 0 2
57898: PPUSH
57899: LD_INT 0
57901: PPUSH
57902: CALL_OW 1
57906: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57907: LD_ADDR_EXP 97
57911: PUSH
57912: LD_EXP 97
57916: PPUSH
57917: LD_VAR 0 2
57921: PPUSH
57922: EMPTY
57923: PPUSH
57924: CALL_OW 1
57928: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57929: LD_ADDR_EXP 98
57933: PUSH
57934: LD_EXP 98
57938: PPUSH
57939: LD_VAR 0 2
57943: PPUSH
57944: EMPTY
57945: PPUSH
57946: CALL_OW 1
57950: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57951: LD_ADDR_EXP 99
57955: PUSH
57956: LD_EXP 99
57960: PPUSH
57961: LD_VAR 0 2
57965: PPUSH
57966: EMPTY
57967: PPUSH
57968: CALL_OW 1
57972: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57973: LD_ADDR_EXP 101
57977: PUSH
57978: LD_EXP 101
57982: PPUSH
57983: LD_VAR 0 2
57987: PPUSH
57988: LD_EXP 68
57992: PUSH
57993: LD_VAR 0 2
57997: ARRAY
57998: PPUSH
57999: LD_INT 2
58001: PUSH
58002: LD_INT 30
58004: PUSH
58005: LD_INT 6
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: PUSH
58012: LD_INT 30
58014: PUSH
58015: LD_INT 7
58017: PUSH
58018: EMPTY
58019: LIST
58020: LIST
58021: PUSH
58022: LD_INT 30
58024: PUSH
58025: LD_INT 8
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: LIST
58036: LIST
58037: PPUSH
58038: CALL_OW 72
58042: PPUSH
58043: CALL_OW 1
58047: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58048: LD_ADDR_EXP 102
58052: PUSH
58053: LD_EXP 102
58057: PPUSH
58058: LD_VAR 0 2
58062: PPUSH
58063: EMPTY
58064: PPUSH
58065: CALL_OW 1
58069: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58070: LD_ADDR_EXP 103
58074: PUSH
58075: LD_EXP 103
58079: PPUSH
58080: LD_VAR 0 2
58084: PPUSH
58085: EMPTY
58086: PPUSH
58087: CALL_OW 1
58091: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58092: LD_ADDR_EXP 104
58096: PUSH
58097: LD_EXP 104
58101: PPUSH
58102: LD_VAR 0 2
58106: PPUSH
58107: EMPTY
58108: PPUSH
58109: CALL_OW 1
58113: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58114: LD_ADDR_EXP 105
58118: PUSH
58119: LD_EXP 105
58123: PPUSH
58124: LD_VAR 0 2
58128: PPUSH
58129: EMPTY
58130: PPUSH
58131: CALL_OW 1
58135: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58136: LD_ADDR_EXP 106
58140: PUSH
58141: LD_EXP 106
58145: PPUSH
58146: LD_VAR 0 2
58150: PPUSH
58151: EMPTY
58152: PPUSH
58153: CALL_OW 1
58157: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58158: LD_ADDR_EXP 107
58162: PUSH
58163: LD_EXP 107
58167: PPUSH
58168: LD_VAR 0 2
58172: PPUSH
58173: EMPTY
58174: PPUSH
58175: CALL_OW 1
58179: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58180: LD_ADDR_EXP 108
58184: PUSH
58185: LD_EXP 108
58189: PPUSH
58190: LD_VAR 0 2
58194: PPUSH
58195: EMPTY
58196: PPUSH
58197: CALL_OW 1
58201: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58202: LD_ADDR_EXP 109
58206: PUSH
58207: LD_EXP 109
58211: PPUSH
58212: LD_VAR 0 2
58216: PPUSH
58217: EMPTY
58218: PPUSH
58219: CALL_OW 1
58223: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58224: LD_ADDR_EXP 110
58228: PUSH
58229: LD_EXP 110
58233: PPUSH
58234: LD_VAR 0 2
58238: PPUSH
58239: LD_INT 0
58241: PPUSH
58242: CALL_OW 1
58246: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58247: LD_ADDR_EXP 111
58251: PUSH
58252: LD_EXP 111
58256: PPUSH
58257: LD_VAR 0 2
58261: PPUSH
58262: LD_INT 0
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// end ;
58270: GO 57171
58272: POP
58273: POP
// MC_InitSides ( ) ;
58274: CALL 58560 0 0
// MC_InitResearch ( ) ;
58278: CALL 58299 0 0
// CustomInitMacro ( ) ;
58282: CALL 5753 0 0
// skirmish := true ;
58286: LD_ADDR_EXP 66
58290: PUSH
58291: LD_INT 1
58293: ST_TO_ADDR
// end ;
58294: LD_VAR 0 1
58298: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58299: LD_INT 0
58301: PPUSH
58302: PPUSH
58303: PPUSH
58304: PPUSH
58305: PPUSH
58306: PPUSH
// if not mc_bases then
58307: LD_EXP 68
58311: NOT
58312: IFFALSE 58316
// exit ;
58314: GO 58555
// for i = 1 to 8 do
58316: LD_ADDR_VAR 0 2
58320: PUSH
58321: DOUBLE
58322: LD_INT 1
58324: DEC
58325: ST_TO_ADDR
58326: LD_INT 8
58328: PUSH
58329: FOR_TO
58330: IFFALSE 58356
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58332: LD_ADDR_EXP 95
58336: PUSH
58337: LD_EXP 95
58341: PPUSH
58342: LD_VAR 0 2
58346: PPUSH
58347: EMPTY
58348: PPUSH
58349: CALL_OW 1
58353: ST_TO_ADDR
58354: GO 58329
58356: POP
58357: POP
// tmp := [ ] ;
58358: LD_ADDR_VAR 0 5
58362: PUSH
58363: EMPTY
58364: ST_TO_ADDR
// for i = 1 to mc_sides do
58365: LD_ADDR_VAR 0 2
58369: PUSH
58370: DOUBLE
58371: LD_INT 1
58373: DEC
58374: ST_TO_ADDR
58375: LD_EXP 94
58379: PUSH
58380: FOR_TO
58381: IFFALSE 58439
// if not mc_sides [ i ] in tmp then
58383: LD_EXP 94
58387: PUSH
58388: LD_VAR 0 2
58392: ARRAY
58393: PUSH
58394: LD_VAR 0 5
58398: IN
58399: NOT
58400: IFFALSE 58437
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58402: LD_ADDR_VAR 0 5
58406: PUSH
58407: LD_VAR 0 5
58411: PPUSH
58412: LD_VAR 0 5
58416: PUSH
58417: LD_INT 1
58419: PLUS
58420: PPUSH
58421: LD_EXP 94
58425: PUSH
58426: LD_VAR 0 2
58430: ARRAY
58431: PPUSH
58432: CALL_OW 2
58436: ST_TO_ADDR
58437: GO 58380
58439: POP
58440: POP
// if not tmp then
58441: LD_VAR 0 5
58445: NOT
58446: IFFALSE 58450
// exit ;
58448: GO 58555
// for j in tmp do
58450: LD_ADDR_VAR 0 3
58454: PUSH
58455: LD_VAR 0 5
58459: PUSH
58460: FOR_IN
58461: IFFALSE 58553
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58463: LD_ADDR_VAR 0 6
58467: PUSH
58468: LD_INT 22
58470: PUSH
58471: LD_VAR 0 3
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: PPUSH
58480: CALL_OW 69
58484: ST_TO_ADDR
// if not un then
58485: LD_VAR 0 6
58489: NOT
58490: IFFALSE 58494
// continue ;
58492: GO 58460
// nation := GetNation ( un [ 1 ] ) ;
58494: LD_ADDR_VAR 0 4
58498: PUSH
58499: LD_VAR 0 6
58503: PUSH
58504: LD_INT 1
58506: ARRAY
58507: PPUSH
58508: CALL_OW 248
58512: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58513: LD_ADDR_EXP 95
58517: PUSH
58518: LD_EXP 95
58522: PPUSH
58523: LD_VAR 0 3
58527: PPUSH
58528: LD_VAR 0 3
58532: PPUSH
58533: LD_VAR 0 4
58537: PPUSH
58538: LD_INT 1
58540: PPUSH
58541: CALL 13674 0 3
58545: PPUSH
58546: CALL_OW 1
58550: ST_TO_ADDR
// end ;
58551: GO 58460
58553: POP
58554: POP
// end ;
58555: LD_VAR 0 1
58559: RET
// export function MC_InitSides ( ) ; var i ; begin
58560: LD_INT 0
58562: PPUSH
58563: PPUSH
// if not mc_bases then
58564: LD_EXP 68
58568: NOT
58569: IFFALSE 58573
// exit ;
58571: GO 58647
// for i = 1 to mc_bases do
58573: LD_ADDR_VAR 0 2
58577: PUSH
58578: DOUBLE
58579: LD_INT 1
58581: DEC
58582: ST_TO_ADDR
58583: LD_EXP 68
58587: PUSH
58588: FOR_TO
58589: IFFALSE 58645
// if mc_bases [ i ] then
58591: LD_EXP 68
58595: PUSH
58596: LD_VAR 0 2
58600: ARRAY
58601: IFFALSE 58643
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58603: LD_ADDR_EXP 94
58607: PUSH
58608: LD_EXP 94
58612: PPUSH
58613: LD_VAR 0 2
58617: PPUSH
58618: LD_EXP 68
58622: PUSH
58623: LD_VAR 0 2
58627: ARRAY
58628: PUSH
58629: LD_INT 1
58631: ARRAY
58632: PPUSH
58633: CALL_OW 255
58637: PPUSH
58638: CALL_OW 1
58642: ST_TO_ADDR
58643: GO 58588
58645: POP
58646: POP
// end ;
58647: LD_VAR 0 1
58651: RET
// every 0 0$03 trigger skirmish do
58652: LD_EXP 66
58656: IFFALSE 58810
58658: GO 58660
58660: DISABLE
// begin enable ;
58661: ENABLE
// MC_CheckBuildings ( ) ;
58662: CALL 63308 0 0
// MC_CheckPeopleLife ( ) ;
58666: CALL 63469 0 0
// RaiseSailEvent ( 100 ) ;
58670: LD_INT 100
58672: PPUSH
58673: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58677: LD_INT 103
58679: PPUSH
58680: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58684: LD_INT 104
58686: PPUSH
58687: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58691: LD_INT 105
58693: PPUSH
58694: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58698: LD_INT 106
58700: PPUSH
58701: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58705: LD_INT 107
58707: PPUSH
58708: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58712: LD_INT 108
58714: PPUSH
58715: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58719: LD_INT 109
58721: PPUSH
58722: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58726: LD_INT 110
58728: PPUSH
58729: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58733: LD_INT 111
58735: PPUSH
58736: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58740: LD_INT 112
58742: PPUSH
58743: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58747: LD_INT 113
58749: PPUSH
58750: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58754: LD_INT 120
58756: PPUSH
58757: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58761: LD_INT 121
58763: PPUSH
58764: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58768: LD_INT 122
58770: PPUSH
58771: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58775: LD_INT 123
58777: PPUSH
58778: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58782: LD_INT 124
58784: PPUSH
58785: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58789: LD_INT 125
58791: PPUSH
58792: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58796: LD_INT 126
58798: PPUSH
58799: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58803: LD_INT 200
58805: PPUSH
58806: CALL_OW 427
// end ;
58810: END
// on SailEvent ( event ) do begin if event < 100 then
58811: LD_VAR 0 1
58815: PUSH
58816: LD_INT 100
58818: LESS
58819: IFFALSE 58830
// CustomEvent ( event ) ;
58821: LD_VAR 0 1
58825: PPUSH
58826: CALL 5745 0 1
// if event = 100 then
58830: LD_VAR 0 1
58834: PUSH
58835: LD_INT 100
58837: EQUAL
58838: IFFALSE 58844
// MC_ClassManager ( ) ;
58840: CALL 59236 0 0
// if event = 101 then
58844: LD_VAR 0 1
58848: PUSH
58849: LD_INT 101
58851: EQUAL
58852: IFFALSE 58858
// MC_RepairBuildings ( ) ;
58854: CALL 64054 0 0
// if event = 102 then
58858: LD_VAR 0 1
58862: PUSH
58863: LD_INT 102
58865: EQUAL
58866: IFFALSE 58872
// MC_Heal ( ) ;
58868: CALL 64961 0 0
// if event = 103 then
58872: LD_VAR 0 1
58876: PUSH
58877: LD_INT 103
58879: EQUAL
58880: IFFALSE 58886
// MC_Build ( ) ;
58882: CALL 65383 0 0
// if event = 104 then
58886: LD_VAR 0 1
58890: PUSH
58891: LD_INT 104
58893: EQUAL
58894: IFFALSE 58900
// MC_TurretWeapon ( ) ;
58896: CALL 67024 0 0
// if event = 105 then
58900: LD_VAR 0 1
58904: PUSH
58905: LD_INT 105
58907: EQUAL
58908: IFFALSE 58914
// MC_BuildUpgrade ( ) ;
58910: CALL 66575 0 0
// if event = 106 then
58914: LD_VAR 0 1
58918: PUSH
58919: LD_INT 106
58921: EQUAL
58922: IFFALSE 58928
// MC_PlantMines ( ) ;
58924: CALL 67454 0 0
// if event = 107 then
58928: LD_VAR 0 1
58932: PUSH
58933: LD_INT 107
58935: EQUAL
58936: IFFALSE 58942
// MC_CollectCrates ( ) ;
58938: CALL 68245 0 0
// if event = 108 then
58942: LD_VAR 0 1
58946: PUSH
58947: LD_INT 108
58949: EQUAL
58950: IFFALSE 58956
// MC_LinkRemoteControl ( ) ;
58952: CALL 70095 0 0
// if event = 109 then
58956: LD_VAR 0 1
58960: PUSH
58961: LD_INT 109
58963: EQUAL
58964: IFFALSE 58970
// MC_ProduceVehicle ( ) ;
58966: CALL 70276 0 0
// if event = 110 then
58970: LD_VAR 0 1
58974: PUSH
58975: LD_INT 110
58977: EQUAL
58978: IFFALSE 58984
// MC_SendAttack ( ) ;
58980: CALL 70742 0 0
// if event = 111 then
58984: LD_VAR 0 1
58988: PUSH
58989: LD_INT 111
58991: EQUAL
58992: IFFALSE 58998
// MC_Defend ( ) ;
58994: CALL 70850 0 0
// if event = 112 then
58998: LD_VAR 0 1
59002: PUSH
59003: LD_INT 112
59005: EQUAL
59006: IFFALSE 59012
// MC_Research ( ) ;
59008: CALL 71730 0 0
// if event = 113 then
59012: LD_VAR 0 1
59016: PUSH
59017: LD_INT 113
59019: EQUAL
59020: IFFALSE 59026
// MC_MinesTrigger ( ) ;
59022: CALL 72844 0 0
// if event = 120 then
59026: LD_VAR 0 1
59030: PUSH
59031: LD_INT 120
59033: EQUAL
59034: IFFALSE 59040
// MC_RepairVehicle ( ) ;
59036: CALL 72943 0 0
// if event = 121 then
59040: LD_VAR 0 1
59044: PUSH
59045: LD_INT 121
59047: EQUAL
59048: IFFALSE 59054
// MC_TameApe ( ) ;
59050: CALL 73684 0 0
// if event = 122 then
59054: LD_VAR 0 1
59058: PUSH
59059: LD_INT 122
59061: EQUAL
59062: IFFALSE 59068
// MC_ChangeApeClass ( ) ;
59064: CALL 74513 0 0
// if event = 123 then
59068: LD_VAR 0 1
59072: PUSH
59073: LD_INT 123
59075: EQUAL
59076: IFFALSE 59082
// MC_Bazooka ( ) ;
59078: CALL 75163 0 0
// if event = 124 then
59082: LD_VAR 0 1
59086: PUSH
59087: LD_INT 124
59089: EQUAL
59090: IFFALSE 59096
// MC_TeleportExit ( ) ;
59092: CALL 75361 0 0
// if event = 125 then
59096: LD_VAR 0 1
59100: PUSH
59101: LD_INT 125
59103: EQUAL
59104: IFFALSE 59110
// MC_Deposits ( ) ;
59106: CALL 76008 0 0
// if event = 126 then
59110: LD_VAR 0 1
59114: PUSH
59115: LD_INT 126
59117: EQUAL
59118: IFFALSE 59124
// MC_RemoteDriver ( ) ;
59120: CALL 76633 0 0
// if event = 200 then
59124: LD_VAR 0 1
59128: PUSH
59129: LD_INT 200
59131: EQUAL
59132: IFFALSE 59138
// MC_Idle ( ) ;
59134: CALL 78582 0 0
// end ;
59138: PPOPN 1
59140: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59141: LD_INT 0
59143: PPUSH
59144: PPUSH
// if not mc_bases [ base ] or not tag then
59145: LD_EXP 68
59149: PUSH
59150: LD_VAR 0 1
59154: ARRAY
59155: NOT
59156: PUSH
59157: LD_VAR 0 2
59161: NOT
59162: OR
59163: IFFALSE 59167
// exit ;
59165: GO 59231
// for i in mc_bases [ base ] union mc_ape [ base ] do
59167: LD_ADDR_VAR 0 4
59171: PUSH
59172: LD_EXP 68
59176: PUSH
59177: LD_VAR 0 1
59181: ARRAY
59182: PUSH
59183: LD_EXP 97
59187: PUSH
59188: LD_VAR 0 1
59192: ARRAY
59193: UNION
59194: PUSH
59195: FOR_IN
59196: IFFALSE 59229
// if GetTag ( i ) = tag then
59198: LD_VAR 0 4
59202: PPUSH
59203: CALL_OW 110
59207: PUSH
59208: LD_VAR 0 2
59212: EQUAL
59213: IFFALSE 59227
// SetTag ( i , 0 ) ;
59215: LD_VAR 0 4
59219: PPUSH
59220: LD_INT 0
59222: PPUSH
59223: CALL_OW 109
59227: GO 59195
59229: POP
59230: POP
// end ;
59231: LD_VAR 0 3
59235: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59236: LD_INT 0
59238: PPUSH
59239: PPUSH
59240: PPUSH
59241: PPUSH
59242: PPUSH
59243: PPUSH
59244: PPUSH
59245: PPUSH
// if not mc_bases then
59246: LD_EXP 68
59250: NOT
59251: IFFALSE 59255
// exit ;
59253: GO 59713
// for i = 1 to mc_bases do
59255: LD_ADDR_VAR 0 2
59259: PUSH
59260: DOUBLE
59261: LD_INT 1
59263: DEC
59264: ST_TO_ADDR
59265: LD_EXP 68
59269: PUSH
59270: FOR_TO
59271: IFFALSE 59711
// begin tmp := MC_ClassCheckReq ( i ) ;
59273: LD_ADDR_VAR 0 4
59277: PUSH
59278: LD_VAR 0 2
59282: PPUSH
59283: CALL 59718 0 1
59287: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59288: LD_ADDR_EXP 109
59292: PUSH
59293: LD_EXP 109
59297: PPUSH
59298: LD_VAR 0 2
59302: PPUSH
59303: LD_VAR 0 4
59307: PPUSH
59308: CALL_OW 1
59312: ST_TO_ADDR
// if not tmp then
59313: LD_VAR 0 4
59317: NOT
59318: IFFALSE 59322
// continue ;
59320: GO 59270
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59322: LD_ADDR_VAR 0 6
59326: PUSH
59327: LD_EXP 68
59331: PUSH
59332: LD_VAR 0 2
59336: ARRAY
59337: PPUSH
59338: LD_INT 2
59340: PUSH
59341: LD_INT 30
59343: PUSH
59344: LD_INT 4
59346: PUSH
59347: EMPTY
59348: LIST
59349: LIST
59350: PUSH
59351: LD_INT 30
59353: PUSH
59354: LD_INT 5
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: LIST
59365: PPUSH
59366: CALL_OW 72
59370: PUSH
59371: LD_EXP 68
59375: PUSH
59376: LD_VAR 0 2
59380: ARRAY
59381: PPUSH
59382: LD_INT 2
59384: PUSH
59385: LD_INT 30
59387: PUSH
59388: LD_INT 0
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: PUSH
59395: LD_INT 30
59397: PUSH
59398: LD_INT 1
59400: PUSH
59401: EMPTY
59402: LIST
59403: LIST
59404: PUSH
59405: EMPTY
59406: LIST
59407: LIST
59408: LIST
59409: PPUSH
59410: CALL_OW 72
59414: PUSH
59415: LD_EXP 68
59419: PUSH
59420: LD_VAR 0 2
59424: ARRAY
59425: PPUSH
59426: LD_INT 30
59428: PUSH
59429: LD_INT 3
59431: PUSH
59432: EMPTY
59433: LIST
59434: LIST
59435: PPUSH
59436: CALL_OW 72
59440: PUSH
59441: LD_EXP 68
59445: PUSH
59446: LD_VAR 0 2
59450: ARRAY
59451: PPUSH
59452: LD_INT 2
59454: PUSH
59455: LD_INT 30
59457: PUSH
59458: LD_INT 6
59460: PUSH
59461: EMPTY
59462: LIST
59463: LIST
59464: PUSH
59465: LD_INT 30
59467: PUSH
59468: LD_INT 7
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: PUSH
59475: LD_INT 30
59477: PUSH
59478: LD_INT 8
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: LIST
59489: LIST
59490: PPUSH
59491: CALL_OW 72
59495: PUSH
59496: EMPTY
59497: LIST
59498: LIST
59499: LIST
59500: LIST
59501: ST_TO_ADDR
// for j = 1 to 4 do
59502: LD_ADDR_VAR 0 3
59506: PUSH
59507: DOUBLE
59508: LD_INT 1
59510: DEC
59511: ST_TO_ADDR
59512: LD_INT 4
59514: PUSH
59515: FOR_TO
59516: IFFALSE 59707
// begin if not tmp [ j ] then
59518: LD_VAR 0 4
59522: PUSH
59523: LD_VAR 0 3
59527: ARRAY
59528: NOT
59529: IFFALSE 59533
// continue ;
59531: GO 59515
// for p in tmp [ j ] do
59533: LD_ADDR_VAR 0 5
59537: PUSH
59538: LD_VAR 0 4
59542: PUSH
59543: LD_VAR 0 3
59547: ARRAY
59548: PUSH
59549: FOR_IN
59550: IFFALSE 59703
// begin if not b [ j ] then
59552: LD_VAR 0 6
59556: PUSH
59557: LD_VAR 0 3
59561: ARRAY
59562: NOT
59563: IFFALSE 59567
// break ;
59565: GO 59703
// e := 0 ;
59567: LD_ADDR_VAR 0 7
59571: PUSH
59572: LD_INT 0
59574: ST_TO_ADDR
// for k in b [ j ] do
59575: LD_ADDR_VAR 0 8
59579: PUSH
59580: LD_VAR 0 6
59584: PUSH
59585: LD_VAR 0 3
59589: ARRAY
59590: PUSH
59591: FOR_IN
59592: IFFALSE 59619
// if IsNotFull ( k ) then
59594: LD_VAR 0 8
59598: PPUSH
59599: CALL 15827 0 1
59603: IFFALSE 59617
// begin e := k ;
59605: LD_ADDR_VAR 0 7
59609: PUSH
59610: LD_VAR 0 8
59614: ST_TO_ADDR
// break ;
59615: GO 59619
// end ;
59617: GO 59591
59619: POP
59620: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59621: LD_VAR 0 7
59625: PUSH
59626: LD_VAR 0 5
59630: PPUSH
59631: LD_VAR 0 7
59635: PPUSH
59636: CALL 49658 0 2
59640: NOT
59641: AND
59642: IFFALSE 59701
// begin if IsInUnit ( p ) then
59644: LD_VAR 0 5
59648: PPUSH
59649: CALL_OW 310
59653: IFFALSE 59664
// ComExitBuilding ( p ) ;
59655: LD_VAR 0 5
59659: PPUSH
59660: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59664: LD_VAR 0 5
59668: PPUSH
59669: LD_VAR 0 7
59673: PPUSH
59674: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59678: LD_VAR 0 5
59682: PPUSH
59683: LD_VAR 0 3
59687: PPUSH
59688: CALL_OW 183
// AddComExitBuilding ( p ) ;
59692: LD_VAR 0 5
59696: PPUSH
59697: CALL_OW 182
// end ; end ;
59701: GO 59549
59703: POP
59704: POP
// end ;
59705: GO 59515
59707: POP
59708: POP
// end ;
59709: GO 59270
59711: POP
59712: POP
// end ;
59713: LD_VAR 0 1
59717: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59718: LD_INT 0
59720: PPUSH
59721: PPUSH
59722: PPUSH
59723: PPUSH
59724: PPUSH
59725: PPUSH
59726: PPUSH
59727: PPUSH
59728: PPUSH
59729: PPUSH
59730: PPUSH
59731: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59732: LD_VAR 0 1
59736: NOT
59737: PUSH
59738: LD_EXP 68
59742: PUSH
59743: LD_VAR 0 1
59747: ARRAY
59748: NOT
59749: OR
59750: PUSH
59751: LD_EXP 68
59755: PUSH
59756: LD_VAR 0 1
59760: ARRAY
59761: PPUSH
59762: LD_INT 2
59764: PUSH
59765: LD_INT 30
59767: PUSH
59768: LD_INT 0
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: LD_INT 30
59777: PUSH
59778: LD_INT 1
59780: PUSH
59781: EMPTY
59782: LIST
59783: LIST
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: LIST
59789: PPUSH
59790: CALL_OW 72
59794: NOT
59795: OR
59796: IFFALSE 59800
// exit ;
59798: GO 63303
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59800: LD_ADDR_VAR 0 4
59804: PUSH
59805: LD_EXP 68
59809: PUSH
59810: LD_VAR 0 1
59814: ARRAY
59815: PPUSH
59816: LD_INT 2
59818: PUSH
59819: LD_INT 25
59821: PUSH
59822: LD_INT 1
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: PUSH
59829: LD_INT 25
59831: PUSH
59832: LD_INT 2
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: PUSH
59839: LD_INT 25
59841: PUSH
59842: LD_INT 3
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: LD_INT 25
59851: PUSH
59852: LD_INT 4
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: LD_INT 25
59861: PUSH
59862: LD_INT 5
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: PUSH
59869: LD_INT 25
59871: PUSH
59872: LD_INT 8
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PUSH
59879: LD_INT 25
59881: PUSH
59882: LD_INT 9
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: EMPTY
59890: LIST
59891: LIST
59892: LIST
59893: LIST
59894: LIST
59895: LIST
59896: LIST
59897: LIST
59898: PPUSH
59899: CALL_OW 72
59903: ST_TO_ADDR
// if not tmp then
59904: LD_VAR 0 4
59908: NOT
59909: IFFALSE 59913
// exit ;
59911: GO 63303
// for i in tmp do
59913: LD_ADDR_VAR 0 3
59917: PUSH
59918: LD_VAR 0 4
59922: PUSH
59923: FOR_IN
59924: IFFALSE 59955
// if GetTag ( i ) then
59926: LD_VAR 0 3
59930: PPUSH
59931: CALL_OW 110
59935: IFFALSE 59953
// tmp := tmp diff i ;
59937: LD_ADDR_VAR 0 4
59941: PUSH
59942: LD_VAR 0 4
59946: PUSH
59947: LD_VAR 0 3
59951: DIFF
59952: ST_TO_ADDR
59953: GO 59923
59955: POP
59956: POP
// if not tmp then
59957: LD_VAR 0 4
59961: NOT
59962: IFFALSE 59966
// exit ;
59964: GO 63303
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59966: LD_ADDR_VAR 0 5
59970: PUSH
59971: LD_EXP 68
59975: PUSH
59976: LD_VAR 0 1
59980: ARRAY
59981: PPUSH
59982: LD_INT 2
59984: PUSH
59985: LD_INT 25
59987: PUSH
59988: LD_INT 1
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: PUSH
59995: LD_INT 25
59997: PUSH
59998: LD_INT 5
60000: PUSH
60001: EMPTY
60002: LIST
60003: LIST
60004: PUSH
60005: LD_INT 25
60007: PUSH
60008: LD_INT 8
60010: PUSH
60011: EMPTY
60012: LIST
60013: LIST
60014: PUSH
60015: LD_INT 25
60017: PUSH
60018: LD_INT 9
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PUSH
60025: EMPTY
60026: LIST
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: PPUSH
60032: CALL_OW 72
60036: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60037: LD_ADDR_VAR 0 6
60041: PUSH
60042: LD_EXP 68
60046: PUSH
60047: LD_VAR 0 1
60051: ARRAY
60052: PPUSH
60053: LD_INT 25
60055: PUSH
60056: LD_INT 2
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PPUSH
60063: CALL_OW 72
60067: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60068: LD_ADDR_VAR 0 7
60072: PUSH
60073: LD_EXP 68
60077: PUSH
60078: LD_VAR 0 1
60082: ARRAY
60083: PPUSH
60084: LD_INT 25
60086: PUSH
60087: LD_INT 3
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PPUSH
60094: CALL_OW 72
60098: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60099: LD_ADDR_VAR 0 8
60103: PUSH
60104: LD_EXP 68
60108: PUSH
60109: LD_VAR 0 1
60113: ARRAY
60114: PPUSH
60115: LD_INT 25
60117: PUSH
60118: LD_INT 4
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PUSH
60125: LD_INT 24
60127: PUSH
60128: LD_INT 251
60130: PUSH
60131: EMPTY
60132: LIST
60133: LIST
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PPUSH
60139: CALL_OW 72
60143: ST_TO_ADDR
// if mc_is_defending [ base ] then
60144: LD_EXP 111
60148: PUSH
60149: LD_VAR 0 1
60153: ARRAY
60154: IFFALSE 60615
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60156: LD_ADDR_EXP 110
60160: PUSH
60161: LD_EXP 110
60165: PPUSH
60166: LD_VAR 0 1
60170: PPUSH
60171: LD_INT 4
60173: PPUSH
60174: CALL_OW 1
60178: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60179: LD_ADDR_VAR 0 12
60183: PUSH
60184: LD_EXP 68
60188: PUSH
60189: LD_VAR 0 1
60193: ARRAY
60194: PPUSH
60195: LD_INT 2
60197: PUSH
60198: LD_INT 30
60200: PUSH
60201: LD_INT 4
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: LD_INT 30
60210: PUSH
60211: LD_INT 5
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: LIST
60222: PPUSH
60223: CALL_OW 72
60227: ST_TO_ADDR
// if not b then
60228: LD_VAR 0 12
60232: NOT
60233: IFFALSE 60237
// exit ;
60235: GO 63303
// p := [ ] ;
60237: LD_ADDR_VAR 0 11
60241: PUSH
60242: EMPTY
60243: ST_TO_ADDR
// if sci >= 2 then
60244: LD_VAR 0 8
60248: PUSH
60249: LD_INT 2
60251: GREATEREQUAL
60252: IFFALSE 60283
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60254: LD_ADDR_VAR 0 8
60258: PUSH
60259: LD_VAR 0 8
60263: PUSH
60264: LD_INT 1
60266: ARRAY
60267: PUSH
60268: LD_VAR 0 8
60272: PUSH
60273: LD_INT 2
60275: ARRAY
60276: PUSH
60277: EMPTY
60278: LIST
60279: LIST
60280: ST_TO_ADDR
60281: GO 60344
// if sci = 1 then
60283: LD_VAR 0 8
60287: PUSH
60288: LD_INT 1
60290: EQUAL
60291: IFFALSE 60312
// sci := [ sci [ 1 ] ] else
60293: LD_ADDR_VAR 0 8
60297: PUSH
60298: LD_VAR 0 8
60302: PUSH
60303: LD_INT 1
60305: ARRAY
60306: PUSH
60307: EMPTY
60308: LIST
60309: ST_TO_ADDR
60310: GO 60344
// if sci = 0 then
60312: LD_VAR 0 8
60316: PUSH
60317: LD_INT 0
60319: EQUAL
60320: IFFALSE 60344
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60322: LD_ADDR_VAR 0 11
60326: PUSH
60327: LD_VAR 0 4
60331: PPUSH
60332: LD_INT 4
60334: PPUSH
60335: CALL 49521 0 2
60339: PUSH
60340: LD_INT 1
60342: ARRAY
60343: ST_TO_ADDR
// if eng > 4 then
60344: LD_VAR 0 6
60348: PUSH
60349: LD_INT 4
60351: GREATER
60352: IFFALSE 60398
// for i = eng downto 4 do
60354: LD_ADDR_VAR 0 3
60358: PUSH
60359: DOUBLE
60360: LD_VAR 0 6
60364: INC
60365: ST_TO_ADDR
60366: LD_INT 4
60368: PUSH
60369: FOR_DOWNTO
60370: IFFALSE 60396
// eng := eng diff eng [ i ] ;
60372: LD_ADDR_VAR 0 6
60376: PUSH
60377: LD_VAR 0 6
60381: PUSH
60382: LD_VAR 0 6
60386: PUSH
60387: LD_VAR 0 3
60391: ARRAY
60392: DIFF
60393: ST_TO_ADDR
60394: GO 60369
60396: POP
60397: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60398: LD_ADDR_VAR 0 4
60402: PUSH
60403: LD_VAR 0 4
60407: PUSH
60408: LD_VAR 0 5
60412: PUSH
60413: LD_VAR 0 6
60417: UNION
60418: PUSH
60419: LD_VAR 0 7
60423: UNION
60424: PUSH
60425: LD_VAR 0 8
60429: UNION
60430: DIFF
60431: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60432: LD_ADDR_VAR 0 13
60436: PUSH
60437: LD_EXP 68
60441: PUSH
60442: LD_VAR 0 1
60446: ARRAY
60447: PPUSH
60448: LD_INT 2
60450: PUSH
60451: LD_INT 30
60453: PUSH
60454: LD_INT 32
60456: PUSH
60457: EMPTY
60458: LIST
60459: LIST
60460: PUSH
60461: LD_INT 30
60463: PUSH
60464: LD_INT 31
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: LIST
60475: PPUSH
60476: CALL_OW 72
60480: PUSH
60481: LD_EXP 68
60485: PUSH
60486: LD_VAR 0 1
60490: ARRAY
60491: PPUSH
60492: LD_INT 2
60494: PUSH
60495: LD_INT 30
60497: PUSH
60498: LD_INT 4
60500: PUSH
60501: EMPTY
60502: LIST
60503: LIST
60504: PUSH
60505: LD_INT 30
60507: PUSH
60508: LD_INT 5
60510: PUSH
60511: EMPTY
60512: LIST
60513: LIST
60514: PUSH
60515: EMPTY
60516: LIST
60517: LIST
60518: LIST
60519: PPUSH
60520: CALL_OW 72
60524: PUSH
60525: LD_INT 6
60527: MUL
60528: PLUS
60529: ST_TO_ADDR
// if bcount < tmp then
60530: LD_VAR 0 13
60534: PUSH
60535: LD_VAR 0 4
60539: LESS
60540: IFFALSE 60586
// for i = tmp downto bcount do
60542: LD_ADDR_VAR 0 3
60546: PUSH
60547: DOUBLE
60548: LD_VAR 0 4
60552: INC
60553: ST_TO_ADDR
60554: LD_VAR 0 13
60558: PUSH
60559: FOR_DOWNTO
60560: IFFALSE 60584
// tmp := Delete ( tmp , tmp ) ;
60562: LD_ADDR_VAR 0 4
60566: PUSH
60567: LD_VAR 0 4
60571: PPUSH
60572: LD_VAR 0 4
60576: PPUSH
60577: CALL_OW 3
60581: ST_TO_ADDR
60582: GO 60559
60584: POP
60585: POP
// result := [ tmp , 0 , 0 , p ] ;
60586: LD_ADDR_VAR 0 2
60590: PUSH
60591: LD_VAR 0 4
60595: PUSH
60596: LD_INT 0
60598: PUSH
60599: LD_INT 0
60601: PUSH
60602: LD_VAR 0 11
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: LIST
60611: LIST
60612: ST_TO_ADDR
// exit ;
60613: GO 63303
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60615: LD_EXP 68
60619: PUSH
60620: LD_VAR 0 1
60624: ARRAY
60625: PPUSH
60626: LD_INT 2
60628: PUSH
60629: LD_INT 30
60631: PUSH
60632: LD_INT 6
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PUSH
60639: LD_INT 30
60641: PUSH
60642: LD_INT 7
60644: PUSH
60645: EMPTY
60646: LIST
60647: LIST
60648: PUSH
60649: LD_INT 30
60651: PUSH
60652: LD_INT 8
60654: PUSH
60655: EMPTY
60656: LIST
60657: LIST
60658: PUSH
60659: EMPTY
60660: LIST
60661: LIST
60662: LIST
60663: LIST
60664: PPUSH
60665: CALL_OW 72
60669: NOT
60670: PUSH
60671: LD_EXP 68
60675: PUSH
60676: LD_VAR 0 1
60680: ARRAY
60681: PPUSH
60682: LD_INT 30
60684: PUSH
60685: LD_INT 3
60687: PUSH
60688: EMPTY
60689: LIST
60690: LIST
60691: PPUSH
60692: CALL_OW 72
60696: NOT
60697: AND
60698: IFFALSE 60770
// begin if eng = tmp then
60700: LD_VAR 0 6
60704: PUSH
60705: LD_VAR 0 4
60709: EQUAL
60710: IFFALSE 60714
// exit ;
60712: GO 63303
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60714: LD_ADDR_EXP 110
60718: PUSH
60719: LD_EXP 110
60723: PPUSH
60724: LD_VAR 0 1
60728: PPUSH
60729: LD_INT 1
60731: PPUSH
60732: CALL_OW 1
60736: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60737: LD_ADDR_VAR 0 2
60741: PUSH
60742: LD_INT 0
60744: PUSH
60745: LD_VAR 0 4
60749: PUSH
60750: LD_VAR 0 6
60754: DIFF
60755: PUSH
60756: LD_INT 0
60758: PUSH
60759: LD_INT 0
60761: PUSH
60762: EMPTY
60763: LIST
60764: LIST
60765: LIST
60766: LIST
60767: ST_TO_ADDR
// exit ;
60768: GO 63303
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60770: LD_EXP 95
60774: PUSH
60775: LD_EXP 94
60779: PUSH
60780: LD_VAR 0 1
60784: ARRAY
60785: ARRAY
60786: PUSH
60787: LD_EXP 68
60791: PUSH
60792: LD_VAR 0 1
60796: ARRAY
60797: PPUSH
60798: LD_INT 2
60800: PUSH
60801: LD_INT 30
60803: PUSH
60804: LD_INT 6
60806: PUSH
60807: EMPTY
60808: LIST
60809: LIST
60810: PUSH
60811: LD_INT 30
60813: PUSH
60814: LD_INT 7
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: LD_INT 30
60823: PUSH
60824: LD_INT 8
60826: PUSH
60827: EMPTY
60828: LIST
60829: LIST
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: LIST
60835: LIST
60836: PPUSH
60837: CALL_OW 72
60841: AND
60842: PUSH
60843: LD_EXP 68
60847: PUSH
60848: LD_VAR 0 1
60852: ARRAY
60853: PPUSH
60854: LD_INT 30
60856: PUSH
60857: LD_INT 3
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PPUSH
60864: CALL_OW 72
60868: NOT
60869: AND
60870: IFFALSE 61084
// begin if sci >= 6 then
60872: LD_VAR 0 8
60876: PUSH
60877: LD_INT 6
60879: GREATEREQUAL
60880: IFFALSE 60884
// exit ;
60882: GO 63303
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60884: LD_ADDR_EXP 110
60888: PUSH
60889: LD_EXP 110
60893: PPUSH
60894: LD_VAR 0 1
60898: PPUSH
60899: LD_INT 2
60901: PPUSH
60902: CALL_OW 1
60906: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60907: LD_ADDR_VAR 0 9
60911: PUSH
60912: LD_VAR 0 4
60916: PUSH
60917: LD_VAR 0 8
60921: DIFF
60922: PPUSH
60923: LD_INT 4
60925: PPUSH
60926: CALL 49521 0 2
60930: ST_TO_ADDR
// p := [ ] ;
60931: LD_ADDR_VAR 0 11
60935: PUSH
60936: EMPTY
60937: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60938: LD_VAR 0 8
60942: PUSH
60943: LD_INT 6
60945: LESS
60946: PUSH
60947: LD_VAR 0 9
60951: PUSH
60952: LD_INT 6
60954: GREATER
60955: AND
60956: IFFALSE 61037
// begin for i = 1 to 6 - sci do
60958: LD_ADDR_VAR 0 3
60962: PUSH
60963: DOUBLE
60964: LD_INT 1
60966: DEC
60967: ST_TO_ADDR
60968: LD_INT 6
60970: PUSH
60971: LD_VAR 0 8
60975: MINUS
60976: PUSH
60977: FOR_TO
60978: IFFALSE 61033
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60980: LD_ADDR_VAR 0 11
60984: PUSH
60985: LD_VAR 0 11
60989: PPUSH
60990: LD_VAR 0 11
60994: PUSH
60995: LD_INT 1
60997: PLUS
60998: PPUSH
60999: LD_VAR 0 9
61003: PUSH
61004: LD_INT 1
61006: ARRAY
61007: PPUSH
61008: CALL_OW 2
61012: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61013: LD_ADDR_VAR 0 9
61017: PUSH
61018: LD_VAR 0 9
61022: PPUSH
61023: LD_INT 1
61025: PPUSH
61026: CALL_OW 3
61030: ST_TO_ADDR
// end ;
61031: GO 60977
61033: POP
61034: POP
// end else
61035: GO 61057
// if sort then
61037: LD_VAR 0 9
61041: IFFALSE 61057
// p := sort [ 1 ] ;
61043: LD_ADDR_VAR 0 11
61047: PUSH
61048: LD_VAR 0 9
61052: PUSH
61053: LD_INT 1
61055: ARRAY
61056: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61057: LD_ADDR_VAR 0 2
61061: PUSH
61062: LD_INT 0
61064: PUSH
61065: LD_INT 0
61067: PUSH
61068: LD_INT 0
61070: PUSH
61071: LD_VAR 0 11
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: LIST
61080: LIST
61081: ST_TO_ADDR
// exit ;
61082: GO 63303
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61084: LD_EXP 95
61088: PUSH
61089: LD_EXP 94
61093: PUSH
61094: LD_VAR 0 1
61098: ARRAY
61099: ARRAY
61100: PUSH
61101: LD_EXP 68
61105: PUSH
61106: LD_VAR 0 1
61110: ARRAY
61111: PPUSH
61112: LD_INT 2
61114: PUSH
61115: LD_INT 30
61117: PUSH
61118: LD_INT 6
61120: PUSH
61121: EMPTY
61122: LIST
61123: LIST
61124: PUSH
61125: LD_INT 30
61127: PUSH
61128: LD_INT 7
61130: PUSH
61131: EMPTY
61132: LIST
61133: LIST
61134: PUSH
61135: LD_INT 30
61137: PUSH
61138: LD_INT 8
61140: PUSH
61141: EMPTY
61142: LIST
61143: LIST
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: LIST
61149: LIST
61150: PPUSH
61151: CALL_OW 72
61155: AND
61156: PUSH
61157: LD_EXP 68
61161: PUSH
61162: LD_VAR 0 1
61166: ARRAY
61167: PPUSH
61168: LD_INT 30
61170: PUSH
61171: LD_INT 3
61173: PUSH
61174: EMPTY
61175: LIST
61176: LIST
61177: PPUSH
61178: CALL_OW 72
61182: AND
61183: IFFALSE 61917
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61185: LD_ADDR_EXP 110
61189: PUSH
61190: LD_EXP 110
61194: PPUSH
61195: LD_VAR 0 1
61199: PPUSH
61200: LD_INT 3
61202: PPUSH
61203: CALL_OW 1
61207: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61208: LD_ADDR_VAR 0 2
61212: PUSH
61213: LD_INT 0
61215: PUSH
61216: LD_INT 0
61218: PUSH
61219: LD_INT 0
61221: PUSH
61222: LD_INT 0
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: ST_TO_ADDR
// if not eng then
61231: LD_VAR 0 6
61235: NOT
61236: IFFALSE 61299
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61238: LD_ADDR_VAR 0 11
61242: PUSH
61243: LD_VAR 0 4
61247: PPUSH
61248: LD_INT 2
61250: PPUSH
61251: CALL 49521 0 2
61255: PUSH
61256: LD_INT 1
61258: ARRAY
61259: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61260: LD_ADDR_VAR 0 2
61264: PUSH
61265: LD_VAR 0 2
61269: PPUSH
61270: LD_INT 2
61272: PPUSH
61273: LD_VAR 0 11
61277: PPUSH
61278: CALL_OW 1
61282: ST_TO_ADDR
// tmp := tmp diff p ;
61283: LD_ADDR_VAR 0 4
61287: PUSH
61288: LD_VAR 0 4
61292: PUSH
61293: LD_VAR 0 11
61297: DIFF
61298: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61299: LD_VAR 0 4
61303: PUSH
61304: LD_VAR 0 8
61308: PUSH
61309: LD_INT 6
61311: LESS
61312: AND
61313: IFFALSE 61501
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61315: LD_ADDR_VAR 0 9
61319: PUSH
61320: LD_VAR 0 4
61324: PUSH
61325: LD_VAR 0 8
61329: PUSH
61330: LD_VAR 0 7
61334: UNION
61335: DIFF
61336: PPUSH
61337: LD_INT 4
61339: PPUSH
61340: CALL 49521 0 2
61344: ST_TO_ADDR
// p := [ ] ;
61345: LD_ADDR_VAR 0 11
61349: PUSH
61350: EMPTY
61351: ST_TO_ADDR
// if sort then
61352: LD_VAR 0 9
61356: IFFALSE 61472
// for i = 1 to 6 - sci do
61358: LD_ADDR_VAR 0 3
61362: PUSH
61363: DOUBLE
61364: LD_INT 1
61366: DEC
61367: ST_TO_ADDR
61368: LD_INT 6
61370: PUSH
61371: LD_VAR 0 8
61375: MINUS
61376: PUSH
61377: FOR_TO
61378: IFFALSE 61470
// begin if i = sort then
61380: LD_VAR 0 3
61384: PUSH
61385: LD_VAR 0 9
61389: EQUAL
61390: IFFALSE 61394
// break ;
61392: GO 61470
// if GetClass ( i ) = 4 then
61394: LD_VAR 0 3
61398: PPUSH
61399: CALL_OW 257
61403: PUSH
61404: LD_INT 4
61406: EQUAL
61407: IFFALSE 61411
// continue ;
61409: GO 61377
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61411: LD_ADDR_VAR 0 11
61415: PUSH
61416: LD_VAR 0 11
61420: PPUSH
61421: LD_VAR 0 11
61425: PUSH
61426: LD_INT 1
61428: PLUS
61429: PPUSH
61430: LD_VAR 0 9
61434: PUSH
61435: LD_VAR 0 3
61439: ARRAY
61440: PPUSH
61441: CALL_OW 2
61445: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61446: LD_ADDR_VAR 0 4
61450: PUSH
61451: LD_VAR 0 4
61455: PUSH
61456: LD_VAR 0 9
61460: PUSH
61461: LD_VAR 0 3
61465: ARRAY
61466: DIFF
61467: ST_TO_ADDR
// end ;
61468: GO 61377
61470: POP
61471: POP
// if p then
61472: LD_VAR 0 11
61476: IFFALSE 61501
// result := Replace ( result , 4 , p ) ;
61478: LD_ADDR_VAR 0 2
61482: PUSH
61483: LD_VAR 0 2
61487: PPUSH
61488: LD_INT 4
61490: PPUSH
61491: LD_VAR 0 11
61495: PPUSH
61496: CALL_OW 1
61500: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61501: LD_VAR 0 4
61505: PUSH
61506: LD_VAR 0 7
61510: PUSH
61511: LD_INT 6
61513: LESS
61514: AND
61515: IFFALSE 61703
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61517: LD_ADDR_VAR 0 9
61521: PUSH
61522: LD_VAR 0 4
61526: PUSH
61527: LD_VAR 0 8
61531: PUSH
61532: LD_VAR 0 7
61536: UNION
61537: DIFF
61538: PPUSH
61539: LD_INT 3
61541: PPUSH
61542: CALL 49521 0 2
61546: ST_TO_ADDR
// p := [ ] ;
61547: LD_ADDR_VAR 0 11
61551: PUSH
61552: EMPTY
61553: ST_TO_ADDR
// if sort then
61554: LD_VAR 0 9
61558: IFFALSE 61674
// for i = 1 to 6 - mech do
61560: LD_ADDR_VAR 0 3
61564: PUSH
61565: DOUBLE
61566: LD_INT 1
61568: DEC
61569: ST_TO_ADDR
61570: LD_INT 6
61572: PUSH
61573: LD_VAR 0 7
61577: MINUS
61578: PUSH
61579: FOR_TO
61580: IFFALSE 61672
// begin if i = sort then
61582: LD_VAR 0 3
61586: PUSH
61587: LD_VAR 0 9
61591: EQUAL
61592: IFFALSE 61596
// break ;
61594: GO 61672
// if GetClass ( i ) = 3 then
61596: LD_VAR 0 3
61600: PPUSH
61601: CALL_OW 257
61605: PUSH
61606: LD_INT 3
61608: EQUAL
61609: IFFALSE 61613
// continue ;
61611: GO 61579
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61613: LD_ADDR_VAR 0 11
61617: PUSH
61618: LD_VAR 0 11
61622: PPUSH
61623: LD_VAR 0 11
61627: PUSH
61628: LD_INT 1
61630: PLUS
61631: PPUSH
61632: LD_VAR 0 9
61636: PUSH
61637: LD_VAR 0 3
61641: ARRAY
61642: PPUSH
61643: CALL_OW 2
61647: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61648: LD_ADDR_VAR 0 4
61652: PUSH
61653: LD_VAR 0 4
61657: PUSH
61658: LD_VAR 0 9
61662: PUSH
61663: LD_VAR 0 3
61667: ARRAY
61668: DIFF
61669: ST_TO_ADDR
// end ;
61670: GO 61579
61672: POP
61673: POP
// if p then
61674: LD_VAR 0 11
61678: IFFALSE 61703
// result := Replace ( result , 3 , p ) ;
61680: LD_ADDR_VAR 0 2
61684: PUSH
61685: LD_VAR 0 2
61689: PPUSH
61690: LD_INT 3
61692: PPUSH
61693: LD_VAR 0 11
61697: PPUSH
61698: CALL_OW 1
61702: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61703: LD_VAR 0 4
61707: PUSH
61708: LD_INT 6
61710: GREATER
61711: PUSH
61712: LD_VAR 0 6
61716: PUSH
61717: LD_INT 6
61719: LESS
61720: AND
61721: IFFALSE 61915
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61723: LD_ADDR_VAR 0 9
61727: PUSH
61728: LD_VAR 0 4
61732: PUSH
61733: LD_VAR 0 8
61737: PUSH
61738: LD_VAR 0 7
61742: UNION
61743: PUSH
61744: LD_VAR 0 6
61748: UNION
61749: DIFF
61750: PPUSH
61751: LD_INT 2
61753: PPUSH
61754: CALL 49521 0 2
61758: ST_TO_ADDR
// p := [ ] ;
61759: LD_ADDR_VAR 0 11
61763: PUSH
61764: EMPTY
61765: ST_TO_ADDR
// if sort then
61766: LD_VAR 0 9
61770: IFFALSE 61886
// for i = 1 to 6 - eng do
61772: LD_ADDR_VAR 0 3
61776: PUSH
61777: DOUBLE
61778: LD_INT 1
61780: DEC
61781: ST_TO_ADDR
61782: LD_INT 6
61784: PUSH
61785: LD_VAR 0 6
61789: MINUS
61790: PUSH
61791: FOR_TO
61792: IFFALSE 61884
// begin if i = sort then
61794: LD_VAR 0 3
61798: PUSH
61799: LD_VAR 0 9
61803: EQUAL
61804: IFFALSE 61808
// break ;
61806: GO 61884
// if GetClass ( i ) = 2 then
61808: LD_VAR 0 3
61812: PPUSH
61813: CALL_OW 257
61817: PUSH
61818: LD_INT 2
61820: EQUAL
61821: IFFALSE 61825
// continue ;
61823: GO 61791
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61825: LD_ADDR_VAR 0 11
61829: PUSH
61830: LD_VAR 0 11
61834: PPUSH
61835: LD_VAR 0 11
61839: PUSH
61840: LD_INT 1
61842: PLUS
61843: PPUSH
61844: LD_VAR 0 9
61848: PUSH
61849: LD_VAR 0 3
61853: ARRAY
61854: PPUSH
61855: CALL_OW 2
61859: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61860: LD_ADDR_VAR 0 4
61864: PUSH
61865: LD_VAR 0 4
61869: PUSH
61870: LD_VAR 0 9
61874: PUSH
61875: LD_VAR 0 3
61879: ARRAY
61880: DIFF
61881: ST_TO_ADDR
// end ;
61882: GO 61791
61884: POP
61885: POP
// if p then
61886: LD_VAR 0 11
61890: IFFALSE 61915
// result := Replace ( result , 2 , p ) ;
61892: LD_ADDR_VAR 0 2
61896: PUSH
61897: LD_VAR 0 2
61901: PPUSH
61902: LD_INT 2
61904: PPUSH
61905: LD_VAR 0 11
61909: PPUSH
61910: CALL_OW 1
61914: ST_TO_ADDR
// end ; exit ;
61915: GO 63303
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61917: LD_EXP 95
61921: PUSH
61922: LD_EXP 94
61926: PUSH
61927: LD_VAR 0 1
61931: ARRAY
61932: ARRAY
61933: NOT
61934: PUSH
61935: LD_EXP 68
61939: PUSH
61940: LD_VAR 0 1
61944: ARRAY
61945: PPUSH
61946: LD_INT 30
61948: PUSH
61949: LD_INT 3
61951: PUSH
61952: EMPTY
61953: LIST
61954: LIST
61955: PPUSH
61956: CALL_OW 72
61960: AND
61961: PUSH
61962: LD_EXP 73
61966: PUSH
61967: LD_VAR 0 1
61971: ARRAY
61972: AND
61973: IFFALSE 62581
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61975: LD_ADDR_EXP 110
61979: PUSH
61980: LD_EXP 110
61984: PPUSH
61985: LD_VAR 0 1
61989: PPUSH
61990: LD_INT 5
61992: PPUSH
61993: CALL_OW 1
61997: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61998: LD_ADDR_VAR 0 2
62002: PUSH
62003: LD_INT 0
62005: PUSH
62006: LD_INT 0
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: LD_INT 0
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: LIST
62019: LIST
62020: ST_TO_ADDR
// if sci > 1 then
62021: LD_VAR 0 8
62025: PUSH
62026: LD_INT 1
62028: GREATER
62029: IFFALSE 62057
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62031: LD_ADDR_VAR 0 4
62035: PUSH
62036: LD_VAR 0 4
62040: PUSH
62041: LD_VAR 0 8
62045: PUSH
62046: LD_VAR 0 8
62050: PUSH
62051: LD_INT 1
62053: ARRAY
62054: DIFF
62055: DIFF
62056: ST_TO_ADDR
// if tmp and not sci then
62057: LD_VAR 0 4
62061: PUSH
62062: LD_VAR 0 8
62066: NOT
62067: AND
62068: IFFALSE 62137
// begin sort := SortBySkill ( tmp , 4 ) ;
62070: LD_ADDR_VAR 0 9
62074: PUSH
62075: LD_VAR 0 4
62079: PPUSH
62080: LD_INT 4
62082: PPUSH
62083: CALL 49521 0 2
62087: ST_TO_ADDR
// if sort then
62088: LD_VAR 0 9
62092: IFFALSE 62108
// p := sort [ 1 ] ;
62094: LD_ADDR_VAR 0 11
62098: PUSH
62099: LD_VAR 0 9
62103: PUSH
62104: LD_INT 1
62106: ARRAY
62107: ST_TO_ADDR
// if p then
62108: LD_VAR 0 11
62112: IFFALSE 62137
// result := Replace ( result , 4 , p ) ;
62114: LD_ADDR_VAR 0 2
62118: PUSH
62119: LD_VAR 0 2
62123: PPUSH
62124: LD_INT 4
62126: PPUSH
62127: LD_VAR 0 11
62131: PPUSH
62132: CALL_OW 1
62136: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62137: LD_ADDR_VAR 0 4
62141: PUSH
62142: LD_VAR 0 4
62146: PUSH
62147: LD_VAR 0 7
62151: DIFF
62152: ST_TO_ADDR
// if tmp and mech < 6 then
62153: LD_VAR 0 4
62157: PUSH
62158: LD_VAR 0 7
62162: PUSH
62163: LD_INT 6
62165: LESS
62166: AND
62167: IFFALSE 62355
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62169: LD_ADDR_VAR 0 9
62173: PUSH
62174: LD_VAR 0 4
62178: PUSH
62179: LD_VAR 0 8
62183: PUSH
62184: LD_VAR 0 7
62188: UNION
62189: DIFF
62190: PPUSH
62191: LD_INT 3
62193: PPUSH
62194: CALL 49521 0 2
62198: ST_TO_ADDR
// p := [ ] ;
62199: LD_ADDR_VAR 0 11
62203: PUSH
62204: EMPTY
62205: ST_TO_ADDR
// if sort then
62206: LD_VAR 0 9
62210: IFFALSE 62326
// for i = 1 to 6 - mech do
62212: LD_ADDR_VAR 0 3
62216: PUSH
62217: DOUBLE
62218: LD_INT 1
62220: DEC
62221: ST_TO_ADDR
62222: LD_INT 6
62224: PUSH
62225: LD_VAR 0 7
62229: MINUS
62230: PUSH
62231: FOR_TO
62232: IFFALSE 62324
// begin if i = sort then
62234: LD_VAR 0 3
62238: PUSH
62239: LD_VAR 0 9
62243: EQUAL
62244: IFFALSE 62248
// break ;
62246: GO 62324
// if GetClass ( i ) = 3 then
62248: LD_VAR 0 3
62252: PPUSH
62253: CALL_OW 257
62257: PUSH
62258: LD_INT 3
62260: EQUAL
62261: IFFALSE 62265
// continue ;
62263: GO 62231
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62265: LD_ADDR_VAR 0 11
62269: PUSH
62270: LD_VAR 0 11
62274: PPUSH
62275: LD_VAR 0 11
62279: PUSH
62280: LD_INT 1
62282: PLUS
62283: PPUSH
62284: LD_VAR 0 9
62288: PUSH
62289: LD_VAR 0 3
62293: ARRAY
62294: PPUSH
62295: CALL_OW 2
62299: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62300: LD_ADDR_VAR 0 4
62304: PUSH
62305: LD_VAR 0 4
62309: PUSH
62310: LD_VAR 0 9
62314: PUSH
62315: LD_VAR 0 3
62319: ARRAY
62320: DIFF
62321: ST_TO_ADDR
// end ;
62322: GO 62231
62324: POP
62325: POP
// if p then
62326: LD_VAR 0 11
62330: IFFALSE 62355
// result := Replace ( result , 3 , p ) ;
62332: LD_ADDR_VAR 0 2
62336: PUSH
62337: LD_VAR 0 2
62341: PPUSH
62342: LD_INT 3
62344: PPUSH
62345: LD_VAR 0 11
62349: PPUSH
62350: CALL_OW 1
62354: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62355: LD_ADDR_VAR 0 4
62359: PUSH
62360: LD_VAR 0 4
62364: PUSH
62365: LD_VAR 0 6
62369: DIFF
62370: ST_TO_ADDR
// if tmp and eng < 6 then
62371: LD_VAR 0 4
62375: PUSH
62376: LD_VAR 0 6
62380: PUSH
62381: LD_INT 6
62383: LESS
62384: AND
62385: IFFALSE 62579
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62387: LD_ADDR_VAR 0 9
62391: PUSH
62392: LD_VAR 0 4
62396: PUSH
62397: LD_VAR 0 8
62401: PUSH
62402: LD_VAR 0 7
62406: UNION
62407: PUSH
62408: LD_VAR 0 6
62412: UNION
62413: DIFF
62414: PPUSH
62415: LD_INT 2
62417: PPUSH
62418: CALL 49521 0 2
62422: ST_TO_ADDR
// p := [ ] ;
62423: LD_ADDR_VAR 0 11
62427: PUSH
62428: EMPTY
62429: ST_TO_ADDR
// if sort then
62430: LD_VAR 0 9
62434: IFFALSE 62550
// for i = 1 to 6 - eng do
62436: LD_ADDR_VAR 0 3
62440: PUSH
62441: DOUBLE
62442: LD_INT 1
62444: DEC
62445: ST_TO_ADDR
62446: LD_INT 6
62448: PUSH
62449: LD_VAR 0 6
62453: MINUS
62454: PUSH
62455: FOR_TO
62456: IFFALSE 62548
// begin if i = sort then
62458: LD_VAR 0 3
62462: PUSH
62463: LD_VAR 0 9
62467: EQUAL
62468: IFFALSE 62472
// break ;
62470: GO 62548
// if GetClass ( i ) = 2 then
62472: LD_VAR 0 3
62476: PPUSH
62477: CALL_OW 257
62481: PUSH
62482: LD_INT 2
62484: EQUAL
62485: IFFALSE 62489
// continue ;
62487: GO 62455
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62489: LD_ADDR_VAR 0 11
62493: PUSH
62494: LD_VAR 0 11
62498: PPUSH
62499: LD_VAR 0 11
62503: PUSH
62504: LD_INT 1
62506: PLUS
62507: PPUSH
62508: LD_VAR 0 9
62512: PUSH
62513: LD_VAR 0 3
62517: ARRAY
62518: PPUSH
62519: CALL_OW 2
62523: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62524: LD_ADDR_VAR 0 4
62528: PUSH
62529: LD_VAR 0 4
62533: PUSH
62534: LD_VAR 0 9
62538: PUSH
62539: LD_VAR 0 3
62543: ARRAY
62544: DIFF
62545: ST_TO_ADDR
// end ;
62546: GO 62455
62548: POP
62549: POP
// if p then
62550: LD_VAR 0 11
62554: IFFALSE 62579
// result := Replace ( result , 2 , p ) ;
62556: LD_ADDR_VAR 0 2
62560: PUSH
62561: LD_VAR 0 2
62565: PPUSH
62566: LD_INT 2
62568: PPUSH
62569: LD_VAR 0 11
62573: PPUSH
62574: CALL_OW 1
62578: ST_TO_ADDR
// end ; exit ;
62579: GO 63303
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62581: LD_EXP 95
62585: PUSH
62586: LD_EXP 94
62590: PUSH
62591: LD_VAR 0 1
62595: ARRAY
62596: ARRAY
62597: NOT
62598: PUSH
62599: LD_EXP 68
62603: PUSH
62604: LD_VAR 0 1
62608: ARRAY
62609: PPUSH
62610: LD_INT 30
62612: PUSH
62613: LD_INT 3
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PPUSH
62620: CALL_OW 72
62624: AND
62625: PUSH
62626: LD_EXP 73
62630: PUSH
62631: LD_VAR 0 1
62635: ARRAY
62636: NOT
62637: AND
62638: IFFALSE 63303
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62640: LD_ADDR_EXP 110
62644: PUSH
62645: LD_EXP 110
62649: PPUSH
62650: LD_VAR 0 1
62654: PPUSH
62655: LD_INT 6
62657: PPUSH
62658: CALL_OW 1
62662: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62663: LD_ADDR_VAR 0 2
62667: PUSH
62668: LD_INT 0
62670: PUSH
62671: LD_INT 0
62673: PUSH
62674: LD_INT 0
62676: PUSH
62677: LD_INT 0
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: ST_TO_ADDR
// if sci >= 1 then
62686: LD_VAR 0 8
62690: PUSH
62691: LD_INT 1
62693: GREATEREQUAL
62694: IFFALSE 62716
// tmp := tmp diff sci [ 1 ] ;
62696: LD_ADDR_VAR 0 4
62700: PUSH
62701: LD_VAR 0 4
62705: PUSH
62706: LD_VAR 0 8
62710: PUSH
62711: LD_INT 1
62713: ARRAY
62714: DIFF
62715: ST_TO_ADDR
// if tmp and not sci then
62716: LD_VAR 0 4
62720: PUSH
62721: LD_VAR 0 8
62725: NOT
62726: AND
62727: IFFALSE 62796
// begin sort := SortBySkill ( tmp , 4 ) ;
62729: LD_ADDR_VAR 0 9
62733: PUSH
62734: LD_VAR 0 4
62738: PPUSH
62739: LD_INT 4
62741: PPUSH
62742: CALL 49521 0 2
62746: ST_TO_ADDR
// if sort then
62747: LD_VAR 0 9
62751: IFFALSE 62767
// p := sort [ 1 ] ;
62753: LD_ADDR_VAR 0 11
62757: PUSH
62758: LD_VAR 0 9
62762: PUSH
62763: LD_INT 1
62765: ARRAY
62766: ST_TO_ADDR
// if p then
62767: LD_VAR 0 11
62771: IFFALSE 62796
// result := Replace ( result , 4 , p ) ;
62773: LD_ADDR_VAR 0 2
62777: PUSH
62778: LD_VAR 0 2
62782: PPUSH
62783: LD_INT 4
62785: PPUSH
62786: LD_VAR 0 11
62790: PPUSH
62791: CALL_OW 1
62795: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62796: LD_ADDR_VAR 0 4
62800: PUSH
62801: LD_VAR 0 4
62805: PUSH
62806: LD_VAR 0 7
62810: DIFF
62811: ST_TO_ADDR
// if tmp and mech < 6 then
62812: LD_VAR 0 4
62816: PUSH
62817: LD_VAR 0 7
62821: PUSH
62822: LD_INT 6
62824: LESS
62825: AND
62826: IFFALSE 63008
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62828: LD_ADDR_VAR 0 9
62832: PUSH
62833: LD_VAR 0 4
62837: PUSH
62838: LD_VAR 0 7
62842: DIFF
62843: PPUSH
62844: LD_INT 3
62846: PPUSH
62847: CALL 49521 0 2
62851: ST_TO_ADDR
// p := [ ] ;
62852: LD_ADDR_VAR 0 11
62856: PUSH
62857: EMPTY
62858: ST_TO_ADDR
// if sort then
62859: LD_VAR 0 9
62863: IFFALSE 62979
// for i = 1 to 6 - mech do
62865: LD_ADDR_VAR 0 3
62869: PUSH
62870: DOUBLE
62871: LD_INT 1
62873: DEC
62874: ST_TO_ADDR
62875: LD_INT 6
62877: PUSH
62878: LD_VAR 0 7
62882: MINUS
62883: PUSH
62884: FOR_TO
62885: IFFALSE 62977
// begin if i = sort then
62887: LD_VAR 0 3
62891: PUSH
62892: LD_VAR 0 9
62896: EQUAL
62897: IFFALSE 62901
// break ;
62899: GO 62977
// if GetClass ( i ) = 3 then
62901: LD_VAR 0 3
62905: PPUSH
62906: CALL_OW 257
62910: PUSH
62911: LD_INT 3
62913: EQUAL
62914: IFFALSE 62918
// continue ;
62916: GO 62884
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62918: LD_ADDR_VAR 0 11
62922: PUSH
62923: LD_VAR 0 11
62927: PPUSH
62928: LD_VAR 0 11
62932: PUSH
62933: LD_INT 1
62935: PLUS
62936: PPUSH
62937: LD_VAR 0 9
62941: PUSH
62942: LD_VAR 0 3
62946: ARRAY
62947: PPUSH
62948: CALL_OW 2
62952: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62953: LD_ADDR_VAR 0 4
62957: PUSH
62958: LD_VAR 0 4
62962: PUSH
62963: LD_VAR 0 9
62967: PUSH
62968: LD_VAR 0 3
62972: ARRAY
62973: DIFF
62974: ST_TO_ADDR
// end ;
62975: GO 62884
62977: POP
62978: POP
// if p then
62979: LD_VAR 0 11
62983: IFFALSE 63008
// result := Replace ( result , 3 , p ) ;
62985: LD_ADDR_VAR 0 2
62989: PUSH
62990: LD_VAR 0 2
62994: PPUSH
62995: LD_INT 3
62997: PPUSH
62998: LD_VAR 0 11
63002: PPUSH
63003: CALL_OW 1
63007: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63008: LD_ADDR_VAR 0 4
63012: PUSH
63013: LD_VAR 0 4
63017: PUSH
63018: LD_VAR 0 6
63022: DIFF
63023: ST_TO_ADDR
// if tmp and eng < 4 then
63024: LD_VAR 0 4
63028: PUSH
63029: LD_VAR 0 6
63033: PUSH
63034: LD_INT 4
63036: LESS
63037: AND
63038: IFFALSE 63228
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63040: LD_ADDR_VAR 0 9
63044: PUSH
63045: LD_VAR 0 4
63049: PUSH
63050: LD_VAR 0 7
63054: PUSH
63055: LD_VAR 0 6
63059: UNION
63060: DIFF
63061: PPUSH
63062: LD_INT 2
63064: PPUSH
63065: CALL 49521 0 2
63069: ST_TO_ADDR
// p := [ ] ;
63070: LD_ADDR_VAR 0 11
63074: PUSH
63075: EMPTY
63076: ST_TO_ADDR
// if sort then
63077: LD_VAR 0 9
63081: IFFALSE 63197
// for i = 1 to 4 - eng do
63083: LD_ADDR_VAR 0 3
63087: PUSH
63088: DOUBLE
63089: LD_INT 1
63091: DEC
63092: ST_TO_ADDR
63093: LD_INT 4
63095: PUSH
63096: LD_VAR 0 6
63100: MINUS
63101: PUSH
63102: FOR_TO
63103: IFFALSE 63195
// begin if i = sort then
63105: LD_VAR 0 3
63109: PUSH
63110: LD_VAR 0 9
63114: EQUAL
63115: IFFALSE 63119
// break ;
63117: GO 63195
// if GetClass ( i ) = 2 then
63119: LD_VAR 0 3
63123: PPUSH
63124: CALL_OW 257
63128: PUSH
63129: LD_INT 2
63131: EQUAL
63132: IFFALSE 63136
// continue ;
63134: GO 63102
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63136: LD_ADDR_VAR 0 11
63140: PUSH
63141: LD_VAR 0 11
63145: PPUSH
63146: LD_VAR 0 11
63150: PUSH
63151: LD_INT 1
63153: PLUS
63154: PPUSH
63155: LD_VAR 0 9
63159: PUSH
63160: LD_VAR 0 3
63164: ARRAY
63165: PPUSH
63166: CALL_OW 2
63170: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63171: LD_ADDR_VAR 0 4
63175: PUSH
63176: LD_VAR 0 4
63180: PUSH
63181: LD_VAR 0 9
63185: PUSH
63186: LD_VAR 0 3
63190: ARRAY
63191: DIFF
63192: ST_TO_ADDR
// end ;
63193: GO 63102
63195: POP
63196: POP
// if p then
63197: LD_VAR 0 11
63201: IFFALSE 63226
// result := Replace ( result , 2 , p ) ;
63203: LD_ADDR_VAR 0 2
63207: PUSH
63208: LD_VAR 0 2
63212: PPUSH
63213: LD_INT 2
63215: PPUSH
63216: LD_VAR 0 11
63220: PPUSH
63221: CALL_OW 1
63225: ST_TO_ADDR
// end else
63226: GO 63272
// for i = eng downto 5 do
63228: LD_ADDR_VAR 0 3
63232: PUSH
63233: DOUBLE
63234: LD_VAR 0 6
63238: INC
63239: ST_TO_ADDR
63240: LD_INT 5
63242: PUSH
63243: FOR_DOWNTO
63244: IFFALSE 63270
// tmp := tmp union eng [ i ] ;
63246: LD_ADDR_VAR 0 4
63250: PUSH
63251: LD_VAR 0 4
63255: PUSH
63256: LD_VAR 0 6
63260: PUSH
63261: LD_VAR 0 3
63265: ARRAY
63266: UNION
63267: ST_TO_ADDR
63268: GO 63243
63270: POP
63271: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63272: LD_ADDR_VAR 0 2
63276: PUSH
63277: LD_VAR 0 2
63281: PPUSH
63282: LD_INT 1
63284: PPUSH
63285: LD_VAR 0 4
63289: PUSH
63290: LD_VAR 0 5
63294: DIFF
63295: PPUSH
63296: CALL_OW 1
63300: ST_TO_ADDR
// exit ;
63301: GO 63303
// end ; end ;
63303: LD_VAR 0 2
63307: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63308: LD_INT 0
63310: PPUSH
63311: PPUSH
63312: PPUSH
// if not mc_bases then
63313: LD_EXP 68
63317: NOT
63318: IFFALSE 63322
// exit ;
63320: GO 63464
// for i = 1 to mc_bases do
63322: LD_ADDR_VAR 0 2
63326: PUSH
63327: DOUBLE
63328: LD_INT 1
63330: DEC
63331: ST_TO_ADDR
63332: LD_EXP 68
63336: PUSH
63337: FOR_TO
63338: IFFALSE 63455
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63340: LD_ADDR_VAR 0 3
63344: PUSH
63345: LD_EXP 68
63349: PUSH
63350: LD_VAR 0 2
63354: ARRAY
63355: PPUSH
63356: LD_INT 21
63358: PUSH
63359: LD_INT 3
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PUSH
63366: LD_INT 3
63368: PUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 30
63374: PUSH
63375: LD_INT 29
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PUSH
63382: LD_INT 30
63384: PUSH
63385: LD_INT 30
63387: PUSH
63388: EMPTY
63389: LIST
63390: LIST
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: LIST
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 3
63403: PUSH
63404: LD_INT 24
63406: PUSH
63407: LD_INT 1000
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: PUSH
63414: EMPTY
63415: LIST
63416: LIST
63417: PUSH
63418: EMPTY
63419: LIST
63420: LIST
63421: LIST
63422: PPUSH
63423: CALL_OW 72
63427: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63428: LD_ADDR_EXP 69
63432: PUSH
63433: LD_EXP 69
63437: PPUSH
63438: LD_VAR 0 2
63442: PPUSH
63443: LD_VAR 0 3
63447: PPUSH
63448: CALL_OW 1
63452: ST_TO_ADDR
// end ;
63453: GO 63337
63455: POP
63456: POP
// RaiseSailEvent ( 101 ) ;
63457: LD_INT 101
63459: PPUSH
63460: CALL_OW 427
// end ;
63464: LD_VAR 0 1
63468: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63469: LD_INT 0
63471: PPUSH
63472: PPUSH
63473: PPUSH
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
// if not mc_bases then
63478: LD_EXP 68
63482: NOT
63483: IFFALSE 63487
// exit ;
63485: GO 64049
// for i = 1 to mc_bases do
63487: LD_ADDR_VAR 0 2
63491: PUSH
63492: DOUBLE
63493: LD_INT 1
63495: DEC
63496: ST_TO_ADDR
63497: LD_EXP 68
63501: PUSH
63502: FOR_TO
63503: IFFALSE 64040
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63505: LD_ADDR_VAR 0 5
63509: PUSH
63510: LD_EXP 68
63514: PUSH
63515: LD_VAR 0 2
63519: ARRAY
63520: PUSH
63521: LD_EXP 97
63525: PUSH
63526: LD_VAR 0 2
63530: ARRAY
63531: UNION
63532: PPUSH
63533: LD_INT 21
63535: PUSH
63536: LD_INT 1
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 1
63545: PUSH
63546: LD_INT 3
63548: PUSH
63549: LD_INT 54
63551: PUSH
63552: EMPTY
63553: LIST
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: PUSH
63559: LD_INT 3
63561: PUSH
63562: LD_INT 24
63564: PUSH
63565: LD_INT 1000
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: EMPTY
63577: LIST
63578: LIST
63579: LIST
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: PPUSH
63585: CALL_OW 72
63589: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63590: LD_ADDR_VAR 0 6
63594: PUSH
63595: LD_EXP 68
63599: PUSH
63600: LD_VAR 0 2
63604: ARRAY
63605: PPUSH
63606: LD_INT 21
63608: PUSH
63609: LD_INT 1
63611: PUSH
63612: EMPTY
63613: LIST
63614: LIST
63615: PUSH
63616: LD_INT 1
63618: PUSH
63619: LD_INT 3
63621: PUSH
63622: LD_INT 54
63624: PUSH
63625: EMPTY
63626: LIST
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 3
63634: PUSH
63635: LD_INT 24
63637: PUSH
63638: LD_INT 250
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: PUSH
63645: EMPTY
63646: LIST
63647: LIST
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: LIST
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PPUSH
63658: CALL_OW 72
63662: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63663: LD_ADDR_VAR 0 7
63667: PUSH
63668: LD_VAR 0 5
63672: PUSH
63673: LD_VAR 0 6
63677: DIFF
63678: ST_TO_ADDR
// if not need_heal_1 then
63679: LD_VAR 0 6
63683: NOT
63684: IFFALSE 63717
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63686: LD_ADDR_EXP 71
63690: PUSH
63691: LD_EXP 71
63695: PPUSH
63696: LD_VAR 0 2
63700: PUSH
63701: LD_INT 1
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PPUSH
63708: EMPTY
63709: PPUSH
63710: CALL 18750 0 3
63714: ST_TO_ADDR
63715: GO 63787
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63717: LD_ADDR_EXP 71
63721: PUSH
63722: LD_EXP 71
63726: PPUSH
63727: LD_VAR 0 2
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PPUSH
63739: LD_EXP 71
63743: PUSH
63744: LD_VAR 0 2
63748: ARRAY
63749: PUSH
63750: LD_INT 1
63752: ARRAY
63753: PPUSH
63754: LD_INT 3
63756: PUSH
63757: LD_INT 24
63759: PUSH
63760: LD_INT 1000
63762: PUSH
63763: EMPTY
63764: LIST
63765: LIST
63766: PUSH
63767: EMPTY
63768: LIST
63769: LIST
63770: PPUSH
63771: CALL_OW 72
63775: PUSH
63776: LD_VAR 0 6
63780: UNION
63781: PPUSH
63782: CALL 18750 0 3
63786: ST_TO_ADDR
// if not need_heal_2 then
63787: LD_VAR 0 7
63791: NOT
63792: IFFALSE 63825
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63794: LD_ADDR_EXP 71
63798: PUSH
63799: LD_EXP 71
63803: PPUSH
63804: LD_VAR 0 2
63808: PUSH
63809: LD_INT 2
63811: PUSH
63812: EMPTY
63813: LIST
63814: LIST
63815: PPUSH
63816: EMPTY
63817: PPUSH
63818: CALL 18750 0 3
63822: ST_TO_ADDR
63823: GO 63857
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63825: LD_ADDR_EXP 71
63829: PUSH
63830: LD_EXP 71
63834: PPUSH
63835: LD_VAR 0 2
63839: PUSH
63840: LD_INT 2
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PPUSH
63847: LD_VAR 0 7
63851: PPUSH
63852: CALL 18750 0 3
63856: ST_TO_ADDR
// if need_heal_2 then
63857: LD_VAR 0 7
63861: IFFALSE 64022
// for j in need_heal_2 do
63863: LD_ADDR_VAR 0 3
63867: PUSH
63868: LD_VAR 0 7
63872: PUSH
63873: FOR_IN
63874: IFFALSE 64020
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63876: LD_ADDR_VAR 0 5
63880: PUSH
63881: LD_EXP 68
63885: PUSH
63886: LD_VAR 0 2
63890: ARRAY
63891: PPUSH
63892: LD_INT 2
63894: PUSH
63895: LD_INT 30
63897: PUSH
63898: LD_INT 6
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 30
63907: PUSH
63908: LD_INT 7
63910: PUSH
63911: EMPTY
63912: LIST
63913: LIST
63914: PUSH
63915: LD_INT 30
63917: PUSH
63918: LD_INT 8
63920: PUSH
63921: EMPTY
63922: LIST
63923: LIST
63924: PUSH
63925: LD_INT 30
63927: PUSH
63928: LD_INT 0
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PUSH
63935: LD_INT 30
63937: PUSH
63938: LD_INT 1
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: PPUSH
63953: CALL_OW 72
63957: ST_TO_ADDR
// if tmp then
63958: LD_VAR 0 5
63962: IFFALSE 64018
// begin k := NearestUnitToUnit ( tmp , j ) ;
63964: LD_ADDR_VAR 0 4
63968: PUSH
63969: LD_VAR 0 5
63973: PPUSH
63974: LD_VAR 0 3
63978: PPUSH
63979: CALL_OW 74
63983: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63984: LD_VAR 0 3
63988: PPUSH
63989: LD_VAR 0 4
63993: PPUSH
63994: CALL_OW 296
63998: PUSH
63999: LD_INT 5
64001: GREATER
64002: IFFALSE 64018
// ComMoveToNearbyEntrance ( j , k ) ;
64004: LD_VAR 0 3
64008: PPUSH
64009: LD_VAR 0 4
64013: PPUSH
64014: CALL 51889 0 2
// end ; end ;
64018: GO 63873
64020: POP
64021: POP
// if not need_heal_1 and not need_heal_2 then
64022: LD_VAR 0 6
64026: NOT
64027: PUSH
64028: LD_VAR 0 7
64032: NOT
64033: AND
64034: IFFALSE 64038
// continue ;
64036: GO 63502
// end ;
64038: GO 63502
64040: POP
64041: POP
// RaiseSailEvent ( 102 ) ;
64042: LD_INT 102
64044: PPUSH
64045: CALL_OW 427
// end ;
64049: LD_VAR 0 1
64053: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
64054: LD_INT 0
64056: PPUSH
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
64061: PPUSH
64062: PPUSH
64063: PPUSH
// if not mc_bases then
64064: LD_EXP 68
64068: NOT
64069: IFFALSE 64073
// exit ;
64071: GO 64956
// for i = 1 to mc_bases do
64073: LD_ADDR_VAR 0 2
64077: PUSH
64078: DOUBLE
64079: LD_INT 1
64081: DEC
64082: ST_TO_ADDR
64083: LD_EXP 68
64087: PUSH
64088: FOR_TO
64089: IFFALSE 64954
// begin if not mc_building_need_repair [ i ] then
64091: LD_EXP 69
64095: PUSH
64096: LD_VAR 0 2
64100: ARRAY
64101: NOT
64102: IFFALSE 64289
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64104: LD_ADDR_VAR 0 6
64108: PUSH
64109: LD_EXP 87
64113: PUSH
64114: LD_VAR 0 2
64118: ARRAY
64119: PPUSH
64120: LD_INT 3
64122: PUSH
64123: LD_INT 24
64125: PUSH
64126: LD_INT 1000
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 2
64139: PUSH
64140: LD_INT 34
64142: PUSH
64143: LD_INT 13
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 34
64152: PUSH
64153: LD_INT 52
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 34
64162: PUSH
64163: LD_EXP 54
64167: PUSH
64168: EMPTY
64169: LIST
64170: LIST
64171: PUSH
64172: EMPTY
64173: LIST
64174: LIST
64175: LIST
64176: LIST
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PPUSH
64182: CALL_OW 72
64186: ST_TO_ADDR
// if cranes then
64187: LD_VAR 0 6
64191: IFFALSE 64253
// for j in cranes do
64193: LD_ADDR_VAR 0 3
64197: PUSH
64198: LD_VAR 0 6
64202: PUSH
64203: FOR_IN
64204: IFFALSE 64251
// if not IsInArea ( j , mc_parking [ i ] ) then
64206: LD_VAR 0 3
64210: PPUSH
64211: LD_EXP 92
64215: PUSH
64216: LD_VAR 0 2
64220: ARRAY
64221: PPUSH
64222: CALL_OW 308
64226: NOT
64227: IFFALSE 64249
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64229: LD_VAR 0 3
64233: PPUSH
64234: LD_EXP 92
64238: PUSH
64239: LD_VAR 0 2
64243: ARRAY
64244: PPUSH
64245: CALL_OW 113
64249: GO 64203
64251: POP
64252: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64253: LD_ADDR_EXP 70
64257: PUSH
64258: LD_EXP 70
64262: PPUSH
64263: LD_VAR 0 2
64267: PPUSH
64268: EMPTY
64269: PPUSH
64270: CALL_OW 1
64274: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64275: LD_VAR 0 2
64279: PPUSH
64280: LD_INT 101
64282: PPUSH
64283: CALL 59141 0 2
// continue ;
64287: GO 64088
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64289: LD_ADDR_EXP 74
64293: PUSH
64294: LD_EXP 74
64298: PPUSH
64299: LD_VAR 0 2
64303: PPUSH
64304: EMPTY
64305: PPUSH
64306: CALL_OW 1
64310: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64311: LD_VAR 0 2
64315: PPUSH
64316: LD_INT 103
64318: PPUSH
64319: CALL 59141 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64323: LD_ADDR_VAR 0 5
64327: PUSH
64328: LD_EXP 68
64332: PUSH
64333: LD_VAR 0 2
64337: ARRAY
64338: PUSH
64339: LD_EXP 97
64343: PUSH
64344: LD_VAR 0 2
64348: ARRAY
64349: UNION
64350: PPUSH
64351: LD_INT 2
64353: PUSH
64354: LD_INT 25
64356: PUSH
64357: LD_INT 2
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: PUSH
64364: LD_INT 25
64366: PUSH
64367: LD_INT 16
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: LIST
64378: PUSH
64379: EMPTY
64380: LIST
64381: PPUSH
64382: CALL_OW 72
64386: ST_TO_ADDR
// if mc_need_heal [ i ] then
64387: LD_EXP 71
64391: PUSH
64392: LD_VAR 0 2
64396: ARRAY
64397: IFFALSE 64441
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64399: LD_ADDR_VAR 0 5
64403: PUSH
64404: LD_VAR 0 5
64408: PUSH
64409: LD_EXP 71
64413: PUSH
64414: LD_VAR 0 2
64418: ARRAY
64419: PUSH
64420: LD_INT 1
64422: ARRAY
64423: PUSH
64424: LD_EXP 71
64428: PUSH
64429: LD_VAR 0 2
64433: ARRAY
64434: PUSH
64435: LD_INT 2
64437: ARRAY
64438: UNION
64439: DIFF
64440: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64441: LD_ADDR_VAR 0 6
64445: PUSH
64446: LD_EXP 87
64450: PUSH
64451: LD_VAR 0 2
64455: ARRAY
64456: PPUSH
64457: LD_INT 2
64459: PUSH
64460: LD_INT 34
64462: PUSH
64463: LD_INT 13
64465: PUSH
64466: EMPTY
64467: LIST
64468: LIST
64469: PUSH
64470: LD_INT 34
64472: PUSH
64473: LD_INT 52
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: LD_INT 34
64482: PUSH
64483: LD_EXP 54
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: PPUSH
64498: CALL_OW 72
64502: ST_TO_ADDR
// if cranes then
64503: LD_VAR 0 6
64507: IFFALSE 64643
// begin for j in cranes do
64509: LD_ADDR_VAR 0 3
64513: PUSH
64514: LD_VAR 0 6
64518: PUSH
64519: FOR_IN
64520: IFFALSE 64641
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64522: LD_VAR 0 3
64526: PPUSH
64527: CALL_OW 256
64531: PUSH
64532: LD_INT 1000
64534: EQUAL
64535: PUSH
64536: LD_VAR 0 3
64540: PPUSH
64541: CALL_OW 314
64545: NOT
64546: AND
64547: IFFALSE 64581
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
64549: LD_VAR 0 3
64553: PPUSH
64554: LD_EXP 69
64558: PUSH
64559: LD_VAR 0 2
64563: ARRAY
64564: PPUSH
64565: LD_VAR 0 3
64569: PPUSH
64570: CALL_OW 74
64574: PPUSH
64575: CALL_OW 130
64579: GO 64639
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64581: LD_VAR 0 3
64585: PPUSH
64586: CALL_OW 256
64590: PUSH
64591: LD_INT 500
64593: LESS
64594: PUSH
64595: LD_VAR 0 3
64599: PPUSH
64600: LD_EXP 92
64604: PUSH
64605: LD_VAR 0 2
64609: ARRAY
64610: PPUSH
64611: CALL_OW 308
64615: NOT
64616: AND
64617: IFFALSE 64639
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64619: LD_VAR 0 3
64623: PPUSH
64624: LD_EXP 92
64628: PUSH
64629: LD_VAR 0 2
64633: ARRAY
64634: PPUSH
64635: CALL_OW 113
// end ;
64639: GO 64519
64641: POP
64642: POP
// end ; if tmp > 3 then
64643: LD_VAR 0 5
64647: PUSH
64648: LD_INT 3
64650: GREATER
64651: IFFALSE 64671
// tmp := ShrinkArray ( tmp , 4 ) ;
64653: LD_ADDR_VAR 0 5
64657: PUSH
64658: LD_VAR 0 5
64662: PPUSH
64663: LD_INT 4
64665: PPUSH
64666: CALL 51327 0 2
64670: ST_TO_ADDR
// if not tmp then
64671: LD_VAR 0 5
64675: NOT
64676: IFFALSE 64680
// continue ;
64678: GO 64088
// for j in tmp do
64680: LD_ADDR_VAR 0 3
64684: PUSH
64685: LD_VAR 0 5
64689: PUSH
64690: FOR_IN
64691: IFFALSE 64950
// begin if IsInUnit ( j ) then
64693: LD_VAR 0 3
64697: PPUSH
64698: CALL_OW 310
64702: IFFALSE 64713
// ComExitBuilding ( j ) ;
64704: LD_VAR 0 3
64708: PPUSH
64709: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64713: LD_VAR 0 3
64717: PUSH
64718: LD_EXP 70
64722: PUSH
64723: LD_VAR 0 2
64727: ARRAY
64728: IN
64729: NOT
64730: IFFALSE 64788
// begin SetTag ( j , 101 ) ;
64732: LD_VAR 0 3
64736: PPUSH
64737: LD_INT 101
64739: PPUSH
64740: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64744: LD_ADDR_EXP 70
64748: PUSH
64749: LD_EXP 70
64753: PPUSH
64754: LD_VAR 0 2
64758: PUSH
64759: LD_EXP 70
64763: PUSH
64764: LD_VAR 0 2
64768: ARRAY
64769: PUSH
64770: LD_INT 1
64772: PLUS
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: PPUSH
64778: LD_VAR 0 3
64782: PPUSH
64783: CALL 18750 0 3
64787: ST_TO_ADDR
// end ; wait ( 1 ) ;
64788: LD_INT 1
64790: PPUSH
64791: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64795: LD_ADDR_VAR 0 7
64799: PUSH
64800: LD_EXP 69
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: ST_TO_ADDR
// if mc_scan [ i ] then
64811: LD_EXP 91
64815: PUSH
64816: LD_VAR 0 2
64820: ARRAY
64821: IFFALSE 64883
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64823: LD_ADDR_VAR 0 7
64827: PUSH
64828: LD_EXP 69
64832: PUSH
64833: LD_VAR 0 2
64837: ARRAY
64838: PPUSH
64839: LD_INT 3
64841: PUSH
64842: LD_INT 30
64844: PUSH
64845: LD_INT 32
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: PUSH
64852: LD_INT 30
64854: PUSH
64855: LD_INT 33
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 30
64864: PUSH
64865: LD_INT 31
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: PPUSH
64878: CALL_OW 72
64882: ST_TO_ADDR
// if not to_repair_tmp then
64883: LD_VAR 0 7
64887: NOT
64888: IFFALSE 64892
// continue ;
64890: GO 64690
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64892: LD_ADDR_VAR 0 8
64896: PUSH
64897: LD_VAR 0 7
64901: PPUSH
64902: LD_VAR 0 3
64906: PPUSH
64907: CALL_OW 74
64911: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64912: LD_VAR 0 8
64916: PPUSH
64917: LD_INT 16
64919: PPUSH
64920: CALL 21349 0 2
64924: PUSH
64925: LD_INT 4
64927: ARRAY
64928: PUSH
64929: LD_INT 10
64931: LESS
64932: IFFALSE 64948
// ComRepairBuilding ( j , to_repair ) ;
64934: LD_VAR 0 3
64938: PPUSH
64939: LD_VAR 0 8
64943: PPUSH
64944: CALL_OW 130
// end ;
64948: GO 64690
64950: POP
64951: POP
// end ;
64952: GO 64088
64954: POP
64955: POP
// end ;
64956: LD_VAR 0 1
64960: RET
// export function MC_Heal ; var i , j , tmp ; begin
64961: LD_INT 0
64963: PPUSH
64964: PPUSH
64965: PPUSH
64966: PPUSH
// if not mc_bases then
64967: LD_EXP 68
64971: NOT
64972: IFFALSE 64976
// exit ;
64974: GO 65378
// for i = 1 to mc_bases do
64976: LD_ADDR_VAR 0 2
64980: PUSH
64981: DOUBLE
64982: LD_INT 1
64984: DEC
64985: ST_TO_ADDR
64986: LD_EXP 68
64990: PUSH
64991: FOR_TO
64992: IFFALSE 65376
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64994: LD_EXP 71
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PUSH
65005: LD_INT 1
65007: ARRAY
65008: NOT
65009: PUSH
65010: LD_EXP 71
65014: PUSH
65015: LD_VAR 0 2
65019: ARRAY
65020: PUSH
65021: LD_INT 2
65023: ARRAY
65024: NOT
65025: AND
65026: IFFALSE 65064
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65028: LD_ADDR_EXP 72
65032: PUSH
65033: LD_EXP 72
65037: PPUSH
65038: LD_VAR 0 2
65042: PPUSH
65043: EMPTY
65044: PPUSH
65045: CALL_OW 1
65049: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65050: LD_VAR 0 2
65054: PPUSH
65055: LD_INT 102
65057: PPUSH
65058: CALL 59141 0 2
// continue ;
65062: GO 64991
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65064: LD_ADDR_VAR 0 4
65068: PUSH
65069: LD_EXP 68
65073: PUSH
65074: LD_VAR 0 2
65078: ARRAY
65079: PPUSH
65080: LD_INT 25
65082: PUSH
65083: LD_INT 4
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PPUSH
65090: CALL_OW 72
65094: ST_TO_ADDR
// if not tmp then
65095: LD_VAR 0 4
65099: NOT
65100: IFFALSE 65104
// continue ;
65102: GO 64991
// if mc_taming [ i ] then
65104: LD_EXP 99
65108: PUSH
65109: LD_VAR 0 2
65113: ARRAY
65114: IFFALSE 65138
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65116: LD_ADDR_EXP 99
65120: PUSH
65121: LD_EXP 99
65125: PPUSH
65126: LD_VAR 0 2
65130: PPUSH
65131: EMPTY
65132: PPUSH
65133: CALL_OW 1
65137: ST_TO_ADDR
// for j in tmp do
65138: LD_ADDR_VAR 0 3
65142: PUSH
65143: LD_VAR 0 4
65147: PUSH
65148: FOR_IN
65149: IFFALSE 65372
// begin if IsInUnit ( j ) then
65151: LD_VAR 0 3
65155: PPUSH
65156: CALL_OW 310
65160: IFFALSE 65171
// ComExitBuilding ( j ) ;
65162: LD_VAR 0 3
65166: PPUSH
65167: CALL_OW 122
// if not j in mc_healers [ i ] then
65171: LD_VAR 0 3
65175: PUSH
65176: LD_EXP 72
65180: PUSH
65181: LD_VAR 0 2
65185: ARRAY
65186: IN
65187: NOT
65188: IFFALSE 65234
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65190: LD_ADDR_EXP 72
65194: PUSH
65195: LD_EXP 72
65199: PPUSH
65200: LD_VAR 0 2
65204: PUSH
65205: LD_EXP 72
65209: PUSH
65210: LD_VAR 0 2
65214: ARRAY
65215: PUSH
65216: LD_INT 1
65218: PLUS
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PPUSH
65224: LD_VAR 0 3
65228: PPUSH
65229: CALL 18750 0 3
65233: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65234: LD_VAR 0 3
65238: PPUSH
65239: CALL_OW 110
65243: PUSH
65244: LD_INT 102
65246: NONEQUAL
65247: IFFALSE 65261
// SetTag ( j , 102 ) ;
65249: LD_VAR 0 3
65253: PPUSH
65254: LD_INT 102
65256: PPUSH
65257: CALL_OW 109
// Wait ( 3 ) ;
65261: LD_INT 3
65263: PPUSH
65264: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65268: LD_EXP 71
65272: PUSH
65273: LD_VAR 0 2
65277: ARRAY
65278: PUSH
65279: LD_INT 1
65281: ARRAY
65282: IFFALSE 65314
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65284: LD_VAR 0 3
65288: PPUSH
65289: LD_EXP 71
65293: PUSH
65294: LD_VAR 0 2
65298: ARRAY
65299: PUSH
65300: LD_INT 1
65302: ARRAY
65303: PUSH
65304: LD_INT 1
65306: ARRAY
65307: PPUSH
65308: CALL_OW 128
65312: GO 65370
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65314: LD_VAR 0 3
65318: PPUSH
65319: CALL_OW 314
65323: NOT
65324: PUSH
65325: LD_EXP 71
65329: PUSH
65330: LD_VAR 0 2
65334: ARRAY
65335: PUSH
65336: LD_INT 2
65338: ARRAY
65339: AND
65340: IFFALSE 65370
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65342: LD_VAR 0 3
65346: PPUSH
65347: LD_EXP 71
65351: PUSH
65352: LD_VAR 0 2
65356: ARRAY
65357: PUSH
65358: LD_INT 2
65360: ARRAY
65361: PUSH
65362: LD_INT 1
65364: ARRAY
65365: PPUSH
65366: CALL_OW 128
// end ;
65370: GO 65148
65372: POP
65373: POP
// end ;
65374: GO 64991
65376: POP
65377: POP
// end ;
65378: LD_VAR 0 1
65382: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65383: LD_INT 0
65385: PPUSH
65386: PPUSH
65387: PPUSH
65388: PPUSH
65389: PPUSH
// if not mc_bases then
65390: LD_EXP 68
65394: NOT
65395: IFFALSE 65399
// exit ;
65397: GO 66570
// for i = 1 to mc_bases do
65399: LD_ADDR_VAR 0 2
65403: PUSH
65404: DOUBLE
65405: LD_INT 1
65407: DEC
65408: ST_TO_ADDR
65409: LD_EXP 68
65413: PUSH
65414: FOR_TO
65415: IFFALSE 66568
// begin if mc_scan [ i ] then
65417: LD_EXP 91
65421: PUSH
65422: LD_VAR 0 2
65426: ARRAY
65427: IFFALSE 65431
// continue ;
65429: GO 65414
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65431: LD_EXP 73
65435: PUSH
65436: LD_VAR 0 2
65440: ARRAY
65441: NOT
65442: PUSH
65443: LD_EXP 75
65447: PUSH
65448: LD_VAR 0 2
65452: ARRAY
65453: NOT
65454: AND
65455: PUSH
65456: LD_EXP 74
65460: PUSH
65461: LD_VAR 0 2
65465: ARRAY
65466: AND
65467: IFFALSE 65505
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65469: LD_ADDR_EXP 74
65473: PUSH
65474: LD_EXP 74
65478: PPUSH
65479: LD_VAR 0 2
65483: PPUSH
65484: EMPTY
65485: PPUSH
65486: CALL_OW 1
65490: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65491: LD_VAR 0 2
65495: PPUSH
65496: LD_INT 103
65498: PPUSH
65499: CALL 59141 0 2
// continue ;
65503: GO 65414
// end ; if mc_construct_list [ i ] then
65505: LD_EXP 75
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: IFFALSE 65735
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65517: LD_ADDR_VAR 0 4
65521: PUSH
65522: LD_EXP 68
65526: PUSH
65527: LD_VAR 0 2
65531: ARRAY
65532: PPUSH
65533: LD_INT 25
65535: PUSH
65536: LD_INT 2
65538: PUSH
65539: EMPTY
65540: LIST
65541: LIST
65542: PPUSH
65543: CALL_OW 72
65547: PUSH
65548: LD_EXP 70
65552: PUSH
65553: LD_VAR 0 2
65557: ARRAY
65558: DIFF
65559: ST_TO_ADDR
// if not tmp then
65560: LD_VAR 0 4
65564: NOT
65565: IFFALSE 65569
// continue ;
65567: GO 65414
// for j in tmp do
65569: LD_ADDR_VAR 0 3
65573: PUSH
65574: LD_VAR 0 4
65578: PUSH
65579: FOR_IN
65580: IFFALSE 65731
// begin if not mc_builders [ i ] then
65582: LD_EXP 74
65586: PUSH
65587: LD_VAR 0 2
65591: ARRAY
65592: NOT
65593: IFFALSE 65651
// begin SetTag ( j , 103 ) ;
65595: LD_VAR 0 3
65599: PPUSH
65600: LD_INT 103
65602: PPUSH
65603: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65607: LD_ADDR_EXP 74
65611: PUSH
65612: LD_EXP 74
65616: PPUSH
65617: LD_VAR 0 2
65621: PUSH
65622: LD_EXP 74
65626: PUSH
65627: LD_VAR 0 2
65631: ARRAY
65632: PUSH
65633: LD_INT 1
65635: PLUS
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PPUSH
65641: LD_VAR 0 3
65645: PPUSH
65646: CALL 18750 0 3
65650: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65651: LD_VAR 0 3
65655: PPUSH
65656: CALL_OW 310
65660: IFFALSE 65671
// ComExitBuilding ( j ) ;
65662: LD_VAR 0 3
65666: PPUSH
65667: CALL_OW 122
// wait ( 3 ) ;
65671: LD_INT 3
65673: PPUSH
65674: CALL_OW 67
// if not mc_construct_list [ i ] then
65678: LD_EXP 75
65682: PUSH
65683: LD_VAR 0 2
65687: ARRAY
65688: NOT
65689: IFFALSE 65693
// break ;
65691: GO 65731
// if not HasTask ( j ) then
65693: LD_VAR 0 3
65697: PPUSH
65698: CALL_OW 314
65702: NOT
65703: IFFALSE 65729
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65705: LD_VAR 0 3
65709: PPUSH
65710: LD_EXP 75
65714: PUSH
65715: LD_VAR 0 2
65719: ARRAY
65720: PUSH
65721: LD_INT 1
65723: ARRAY
65724: PPUSH
65725: CALL 21613 0 2
// end ;
65729: GO 65579
65731: POP
65732: POP
// end else
65733: GO 66566
// if mc_build_list [ i ] then
65735: LD_EXP 73
65739: PUSH
65740: LD_VAR 0 2
65744: ARRAY
65745: IFFALSE 66566
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65747: LD_ADDR_VAR 0 5
65751: PUSH
65752: LD_EXP 68
65756: PUSH
65757: LD_VAR 0 2
65761: ARRAY
65762: PPUSH
65763: LD_INT 2
65765: PUSH
65766: LD_INT 30
65768: PUSH
65769: LD_INT 0
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: PUSH
65776: LD_INT 30
65778: PUSH
65779: LD_INT 1
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: LIST
65790: PPUSH
65791: CALL_OW 72
65795: ST_TO_ADDR
// if depot then
65796: LD_VAR 0 5
65800: IFFALSE 65818
// depot := depot [ 1 ] else
65802: LD_ADDR_VAR 0 5
65806: PUSH
65807: LD_VAR 0 5
65811: PUSH
65812: LD_INT 1
65814: ARRAY
65815: ST_TO_ADDR
65816: GO 65826
// depot := 0 ;
65818: LD_ADDR_VAR 0 5
65822: PUSH
65823: LD_INT 0
65825: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65826: LD_EXP 73
65830: PUSH
65831: LD_VAR 0 2
65835: ARRAY
65836: PUSH
65837: LD_INT 1
65839: ARRAY
65840: PUSH
65841: LD_INT 1
65843: ARRAY
65844: PPUSH
65845: CALL 21437 0 1
65849: PUSH
65850: LD_EXP 68
65854: PUSH
65855: LD_VAR 0 2
65859: ARRAY
65860: PPUSH
65861: LD_INT 2
65863: PUSH
65864: LD_INT 30
65866: PUSH
65867: LD_INT 2
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PUSH
65874: LD_INT 30
65876: PUSH
65877: LD_INT 3
65879: PUSH
65880: EMPTY
65881: LIST
65882: LIST
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: LIST
65888: PPUSH
65889: CALL_OW 72
65893: NOT
65894: AND
65895: IFFALSE 66000
// begin for j = 1 to mc_build_list [ i ] do
65897: LD_ADDR_VAR 0 3
65901: PUSH
65902: DOUBLE
65903: LD_INT 1
65905: DEC
65906: ST_TO_ADDR
65907: LD_EXP 73
65911: PUSH
65912: LD_VAR 0 2
65916: ARRAY
65917: PUSH
65918: FOR_TO
65919: IFFALSE 65998
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65921: LD_EXP 73
65925: PUSH
65926: LD_VAR 0 2
65930: ARRAY
65931: PUSH
65932: LD_VAR 0 3
65936: ARRAY
65937: PUSH
65938: LD_INT 1
65940: ARRAY
65941: PUSH
65942: LD_INT 2
65944: EQUAL
65945: IFFALSE 65996
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65947: LD_ADDR_EXP 73
65951: PUSH
65952: LD_EXP 73
65956: PPUSH
65957: LD_VAR 0 2
65961: PPUSH
65962: LD_EXP 73
65966: PUSH
65967: LD_VAR 0 2
65971: ARRAY
65972: PPUSH
65973: LD_VAR 0 3
65977: PPUSH
65978: LD_INT 1
65980: PPUSH
65981: LD_INT 0
65983: PPUSH
65984: CALL 18168 0 4
65988: PPUSH
65989: CALL_OW 1
65993: ST_TO_ADDR
// break ;
65994: GO 65998
// end ;
65996: GO 65918
65998: POP
65999: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66000: LD_EXP 73
66004: PUSH
66005: LD_VAR 0 2
66009: ARRAY
66010: PUSH
66011: LD_INT 1
66013: ARRAY
66014: PUSH
66015: LD_INT 1
66017: ARRAY
66018: PUSH
66019: LD_INT 0
66021: EQUAL
66022: PUSH
66023: LD_VAR 0 5
66027: PUSH
66028: LD_VAR 0 5
66032: PPUSH
66033: LD_EXP 73
66037: PUSH
66038: LD_VAR 0 2
66042: ARRAY
66043: PUSH
66044: LD_INT 1
66046: ARRAY
66047: PUSH
66048: LD_INT 1
66050: ARRAY
66051: PPUSH
66052: LD_EXP 73
66056: PUSH
66057: LD_VAR 0 2
66061: ARRAY
66062: PUSH
66063: LD_INT 1
66065: ARRAY
66066: PUSH
66067: LD_INT 2
66069: ARRAY
66070: PPUSH
66071: LD_EXP 73
66075: PUSH
66076: LD_VAR 0 2
66080: ARRAY
66081: PUSH
66082: LD_INT 1
66084: ARRAY
66085: PUSH
66086: LD_INT 3
66088: ARRAY
66089: PPUSH
66090: LD_EXP 73
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: PUSH
66101: LD_INT 1
66103: ARRAY
66104: PUSH
66105: LD_INT 4
66107: ARRAY
66108: PPUSH
66109: CALL 26853 0 5
66113: AND
66114: OR
66115: IFFALSE 66396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66117: LD_ADDR_VAR 0 4
66121: PUSH
66122: LD_EXP 68
66126: PUSH
66127: LD_VAR 0 2
66131: ARRAY
66132: PPUSH
66133: LD_INT 25
66135: PUSH
66136: LD_INT 2
66138: PUSH
66139: EMPTY
66140: LIST
66141: LIST
66142: PPUSH
66143: CALL_OW 72
66147: PUSH
66148: LD_EXP 70
66152: PUSH
66153: LD_VAR 0 2
66157: ARRAY
66158: DIFF
66159: ST_TO_ADDR
// if not tmp then
66160: LD_VAR 0 4
66164: NOT
66165: IFFALSE 66169
// continue ;
66167: GO 65414
// for j in tmp do
66169: LD_ADDR_VAR 0 3
66173: PUSH
66174: LD_VAR 0 4
66178: PUSH
66179: FOR_IN
66180: IFFALSE 66392
// begin if not mc_builders [ i ] then
66182: LD_EXP 74
66186: PUSH
66187: LD_VAR 0 2
66191: ARRAY
66192: NOT
66193: IFFALSE 66251
// begin SetTag ( j , 103 ) ;
66195: LD_VAR 0 3
66199: PPUSH
66200: LD_INT 103
66202: PPUSH
66203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66207: LD_ADDR_EXP 74
66211: PUSH
66212: LD_EXP 74
66216: PPUSH
66217: LD_VAR 0 2
66221: PUSH
66222: LD_EXP 74
66226: PUSH
66227: LD_VAR 0 2
66231: ARRAY
66232: PUSH
66233: LD_INT 1
66235: PLUS
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PPUSH
66241: LD_VAR 0 3
66245: PPUSH
66246: CALL 18750 0 3
66250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66251: LD_VAR 0 3
66255: PPUSH
66256: CALL_OW 310
66260: IFFALSE 66271
// ComExitBuilding ( j ) ;
66262: LD_VAR 0 3
66266: PPUSH
66267: CALL_OW 122
// wait ( 3 ) ;
66271: LD_INT 3
66273: PPUSH
66274: CALL_OW 67
// if not mc_build_list [ i ] then
66278: LD_EXP 73
66282: PUSH
66283: LD_VAR 0 2
66287: ARRAY
66288: NOT
66289: IFFALSE 66293
// break ;
66291: GO 66392
// if not HasTask ( j ) then
66293: LD_VAR 0 3
66297: PPUSH
66298: CALL_OW 314
66302: NOT
66303: IFFALSE 66390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66305: LD_VAR 0 3
66309: PPUSH
66310: LD_EXP 73
66314: PUSH
66315: LD_VAR 0 2
66319: ARRAY
66320: PUSH
66321: LD_INT 1
66323: ARRAY
66324: PUSH
66325: LD_INT 1
66327: ARRAY
66328: PPUSH
66329: LD_EXP 73
66333: PUSH
66334: LD_VAR 0 2
66338: ARRAY
66339: PUSH
66340: LD_INT 1
66342: ARRAY
66343: PUSH
66344: LD_INT 2
66346: ARRAY
66347: PPUSH
66348: LD_EXP 73
66352: PUSH
66353: LD_VAR 0 2
66357: ARRAY
66358: PUSH
66359: LD_INT 1
66361: ARRAY
66362: PUSH
66363: LD_INT 3
66365: ARRAY
66366: PPUSH
66367: LD_EXP 73
66371: PUSH
66372: LD_VAR 0 2
66376: ARRAY
66377: PUSH
66378: LD_INT 1
66380: ARRAY
66381: PUSH
66382: LD_INT 4
66384: ARRAY
66385: PPUSH
66386: CALL_OW 145
// end ;
66390: GO 66179
66392: POP
66393: POP
// end else
66394: GO 66566
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66396: LD_EXP 68
66400: PUSH
66401: LD_VAR 0 2
66405: ARRAY
66406: PPUSH
66407: LD_EXP 73
66411: PUSH
66412: LD_VAR 0 2
66416: ARRAY
66417: PUSH
66418: LD_INT 1
66420: ARRAY
66421: PUSH
66422: LD_INT 1
66424: ARRAY
66425: PPUSH
66426: LD_EXP 73
66430: PUSH
66431: LD_VAR 0 2
66435: ARRAY
66436: PUSH
66437: LD_INT 1
66439: ARRAY
66440: PUSH
66441: LD_INT 2
66443: ARRAY
66444: PPUSH
66445: LD_EXP 73
66449: PUSH
66450: LD_VAR 0 2
66454: ARRAY
66455: PUSH
66456: LD_INT 1
66458: ARRAY
66459: PUSH
66460: LD_INT 3
66462: ARRAY
66463: PPUSH
66464: LD_EXP 73
66468: PUSH
66469: LD_VAR 0 2
66473: ARRAY
66474: PUSH
66475: LD_INT 1
66477: ARRAY
66478: PUSH
66479: LD_INT 4
66481: ARRAY
66482: PPUSH
66483: LD_EXP 68
66487: PUSH
66488: LD_VAR 0 2
66492: ARRAY
66493: PPUSH
66494: LD_INT 21
66496: PUSH
66497: LD_INT 3
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PPUSH
66504: CALL_OW 72
66508: PPUSH
66509: EMPTY
66510: PPUSH
66511: CALL 25603 0 7
66515: NOT
66516: IFFALSE 66566
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66518: LD_ADDR_EXP 73
66522: PUSH
66523: LD_EXP 73
66527: PPUSH
66528: LD_VAR 0 2
66532: PPUSH
66533: LD_EXP 73
66537: PUSH
66538: LD_VAR 0 2
66542: ARRAY
66543: PPUSH
66544: LD_INT 1
66546: PPUSH
66547: LD_INT 1
66549: NEG
66550: PPUSH
66551: LD_INT 0
66553: PPUSH
66554: CALL 18168 0 4
66558: PPUSH
66559: CALL_OW 1
66563: ST_TO_ADDR
// continue ;
66564: GO 65414
// end ; end ; end ;
66566: GO 65414
66568: POP
66569: POP
// end ;
66570: LD_VAR 0 1
66574: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66575: LD_INT 0
66577: PPUSH
66578: PPUSH
66579: PPUSH
66580: PPUSH
66581: PPUSH
66582: PPUSH
// if not mc_bases then
66583: LD_EXP 68
66587: NOT
66588: IFFALSE 66592
// exit ;
66590: GO 67019
// for i = 1 to mc_bases do
66592: LD_ADDR_VAR 0 2
66596: PUSH
66597: DOUBLE
66598: LD_INT 1
66600: DEC
66601: ST_TO_ADDR
66602: LD_EXP 68
66606: PUSH
66607: FOR_TO
66608: IFFALSE 67017
// begin tmp := mc_build_upgrade [ i ] ;
66610: LD_ADDR_VAR 0 4
66614: PUSH
66615: LD_EXP 100
66619: PUSH
66620: LD_VAR 0 2
66624: ARRAY
66625: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66626: LD_ADDR_VAR 0 6
66630: PUSH
66631: LD_EXP 101
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: PPUSH
66642: LD_INT 2
66644: PUSH
66645: LD_INT 30
66647: PUSH
66648: LD_INT 6
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 30
66657: PUSH
66658: LD_INT 7
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: LIST
66669: PPUSH
66670: CALL_OW 72
66674: ST_TO_ADDR
// if not tmp and not lab then
66675: LD_VAR 0 4
66679: NOT
66680: PUSH
66681: LD_VAR 0 6
66685: NOT
66686: AND
66687: IFFALSE 66691
// continue ;
66689: GO 66607
// if tmp then
66691: LD_VAR 0 4
66695: IFFALSE 66815
// for j in tmp do
66697: LD_ADDR_VAR 0 3
66701: PUSH
66702: LD_VAR 0 4
66706: PUSH
66707: FOR_IN
66708: IFFALSE 66813
// begin if UpgradeCost ( j ) then
66710: LD_VAR 0 3
66714: PPUSH
66715: CALL 25263 0 1
66719: IFFALSE 66811
// begin ComUpgrade ( j ) ;
66721: LD_VAR 0 3
66725: PPUSH
66726: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66730: LD_ADDR_EXP 100
66734: PUSH
66735: LD_EXP 100
66739: PPUSH
66740: LD_VAR 0 2
66744: PPUSH
66745: LD_EXP 100
66749: PUSH
66750: LD_VAR 0 2
66754: ARRAY
66755: PUSH
66756: LD_VAR 0 3
66760: DIFF
66761: PPUSH
66762: CALL_OW 1
66766: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66767: LD_ADDR_EXP 75
66771: PUSH
66772: LD_EXP 75
66776: PPUSH
66777: LD_VAR 0 2
66781: PUSH
66782: LD_EXP 75
66786: PUSH
66787: LD_VAR 0 2
66791: ARRAY
66792: PUSH
66793: LD_INT 1
66795: PLUS
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PPUSH
66801: LD_VAR 0 3
66805: PPUSH
66806: CALL 18750 0 3
66810: ST_TO_ADDR
// end ; end ;
66811: GO 66707
66813: POP
66814: POP
// if not lab or not mc_lab_upgrade [ i ] then
66815: LD_VAR 0 6
66819: NOT
66820: PUSH
66821: LD_EXP 102
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: NOT
66832: OR
66833: IFFALSE 66837
// continue ;
66835: GO 66607
// for j in lab do
66837: LD_ADDR_VAR 0 3
66841: PUSH
66842: LD_VAR 0 6
66846: PUSH
66847: FOR_IN
66848: IFFALSE 67013
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66850: LD_VAR 0 3
66854: PPUSH
66855: CALL_OW 266
66859: PUSH
66860: LD_INT 6
66862: PUSH
66863: LD_INT 7
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: IN
66870: PUSH
66871: LD_VAR 0 3
66875: PPUSH
66876: CALL_OW 461
66880: PUSH
66881: LD_INT 1
66883: NONEQUAL
66884: AND
66885: IFFALSE 67011
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66887: LD_VAR 0 3
66891: PPUSH
66892: LD_EXP 102
66896: PUSH
66897: LD_VAR 0 2
66901: ARRAY
66902: PUSH
66903: LD_INT 1
66905: ARRAY
66906: PPUSH
66907: CALL 25468 0 2
66911: IFFALSE 67011
// begin ComCancel ( j ) ;
66913: LD_VAR 0 3
66917: PPUSH
66918: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66922: LD_VAR 0 3
66926: PPUSH
66927: LD_EXP 102
66931: PUSH
66932: LD_VAR 0 2
66936: ARRAY
66937: PUSH
66938: LD_INT 1
66940: ARRAY
66941: PPUSH
66942: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66946: LD_VAR 0 3
66950: PUSH
66951: LD_EXP 75
66955: PUSH
66956: LD_VAR 0 2
66960: ARRAY
66961: IN
66962: NOT
66963: IFFALSE 67009
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66965: LD_ADDR_EXP 75
66969: PUSH
66970: LD_EXP 75
66974: PPUSH
66975: LD_VAR 0 2
66979: PUSH
66980: LD_EXP 75
66984: PUSH
66985: LD_VAR 0 2
66989: ARRAY
66990: PUSH
66991: LD_INT 1
66993: PLUS
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PPUSH
66999: LD_VAR 0 3
67003: PPUSH
67004: CALL 18750 0 3
67008: ST_TO_ADDR
// break ;
67009: GO 67013
// end ; end ; end ;
67011: GO 66847
67013: POP
67014: POP
// end ;
67015: GO 66607
67017: POP
67018: POP
// end ;
67019: LD_VAR 0 1
67023: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67024: LD_INT 0
67026: PPUSH
67027: PPUSH
67028: PPUSH
67029: PPUSH
67030: PPUSH
67031: PPUSH
67032: PPUSH
67033: PPUSH
67034: PPUSH
// if not mc_bases then
67035: LD_EXP 68
67039: NOT
67040: IFFALSE 67044
// exit ;
67042: GO 67449
// for i = 1 to mc_bases do
67044: LD_ADDR_VAR 0 2
67048: PUSH
67049: DOUBLE
67050: LD_INT 1
67052: DEC
67053: ST_TO_ADDR
67054: LD_EXP 68
67058: PUSH
67059: FOR_TO
67060: IFFALSE 67447
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67062: LD_EXP 76
67066: PUSH
67067: LD_VAR 0 2
67071: ARRAY
67072: NOT
67073: PUSH
67074: LD_EXP 68
67078: PUSH
67079: LD_VAR 0 2
67083: ARRAY
67084: PPUSH
67085: LD_INT 30
67087: PUSH
67088: LD_INT 3
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PPUSH
67095: CALL_OW 72
67099: NOT
67100: OR
67101: IFFALSE 67105
// continue ;
67103: GO 67059
// busy := false ;
67105: LD_ADDR_VAR 0 8
67109: PUSH
67110: LD_INT 0
67112: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67113: LD_ADDR_VAR 0 4
67117: PUSH
67118: LD_EXP 68
67122: PUSH
67123: LD_VAR 0 2
67127: ARRAY
67128: PPUSH
67129: LD_INT 30
67131: PUSH
67132: LD_INT 3
67134: PUSH
67135: EMPTY
67136: LIST
67137: LIST
67138: PPUSH
67139: CALL_OW 72
67143: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67144: LD_ADDR_VAR 0 6
67148: PUSH
67149: LD_EXP 76
67153: PUSH
67154: LD_VAR 0 2
67158: ARRAY
67159: PPUSH
67160: LD_INT 2
67162: PUSH
67163: LD_INT 30
67165: PUSH
67166: LD_INT 32
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 30
67175: PUSH
67176: LD_INT 33
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: LIST
67187: PPUSH
67188: CALL_OW 72
67192: ST_TO_ADDR
// if not t then
67193: LD_VAR 0 6
67197: NOT
67198: IFFALSE 67202
// continue ;
67200: GO 67059
// for j in tmp do
67202: LD_ADDR_VAR 0 3
67206: PUSH
67207: LD_VAR 0 4
67211: PUSH
67212: FOR_IN
67213: IFFALSE 67243
// if not BuildingStatus ( j ) = bs_idle then
67215: LD_VAR 0 3
67219: PPUSH
67220: CALL_OW 461
67224: PUSH
67225: LD_INT 2
67227: EQUAL
67228: NOT
67229: IFFALSE 67241
// begin busy := true ;
67231: LD_ADDR_VAR 0 8
67235: PUSH
67236: LD_INT 1
67238: ST_TO_ADDR
// break ;
67239: GO 67243
// end ;
67241: GO 67212
67243: POP
67244: POP
// if busy then
67245: LD_VAR 0 8
67249: IFFALSE 67253
// continue ;
67251: GO 67059
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67253: LD_ADDR_VAR 0 7
67257: PUSH
67258: LD_VAR 0 6
67262: PPUSH
67263: LD_INT 35
67265: PUSH
67266: LD_INT 0
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PPUSH
67273: CALL_OW 72
67277: ST_TO_ADDR
// if tw then
67278: LD_VAR 0 7
67282: IFFALSE 67359
// begin tw := tw [ 1 ] ;
67284: LD_ADDR_VAR 0 7
67288: PUSH
67289: LD_VAR 0 7
67293: PUSH
67294: LD_INT 1
67296: ARRAY
67297: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67298: LD_ADDR_VAR 0 9
67302: PUSH
67303: LD_VAR 0 7
67307: PPUSH
67308: LD_EXP 93
67312: PUSH
67313: LD_VAR 0 2
67317: ARRAY
67318: PPUSH
67319: CALL 23760 0 2
67323: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67324: LD_EXP 107
67328: PUSH
67329: LD_VAR 0 2
67333: ARRAY
67334: IFFALSE 67357
// if not weapon in mc_allowed_tower_weapons [ i ] then
67336: LD_VAR 0 9
67340: PUSH
67341: LD_EXP 107
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: IN
67352: NOT
67353: IFFALSE 67357
// continue ;
67355: GO 67059
// end else
67357: GO 67422
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67359: LD_ADDR_VAR 0 5
67363: PUSH
67364: LD_EXP 76
67368: PUSH
67369: LD_VAR 0 2
67373: ARRAY
67374: PPUSH
67375: LD_VAR 0 4
67379: PPUSH
67380: CALL 50560 0 2
67384: ST_TO_ADDR
// if not tmp2 then
67385: LD_VAR 0 5
67389: NOT
67390: IFFALSE 67394
// continue ;
67392: GO 67059
// tw := tmp2 [ 1 ] ;
67394: LD_ADDR_VAR 0 7
67398: PUSH
67399: LD_VAR 0 5
67403: PUSH
67404: LD_INT 1
67406: ARRAY
67407: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67408: LD_ADDR_VAR 0 9
67412: PUSH
67413: LD_VAR 0 5
67417: PUSH
67418: LD_INT 2
67420: ARRAY
67421: ST_TO_ADDR
// end ; if not weapon then
67422: LD_VAR 0 9
67426: NOT
67427: IFFALSE 67431
// continue ;
67429: GO 67059
// ComPlaceWeapon ( tw , weapon ) ;
67431: LD_VAR 0 7
67435: PPUSH
67436: LD_VAR 0 9
67440: PPUSH
67441: CALL_OW 148
// end ;
67445: GO 67059
67447: POP
67448: POP
// end ;
67449: LD_VAR 0 1
67453: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67454: LD_INT 0
67456: PPUSH
67457: PPUSH
67458: PPUSH
67459: PPUSH
67460: PPUSH
67461: PPUSH
67462: PPUSH
// if not mc_bases then
67463: LD_EXP 68
67467: NOT
67468: IFFALSE 67472
// exit ;
67470: GO 68240
// for i = 1 to mc_bases do
67472: LD_ADDR_VAR 0 2
67476: PUSH
67477: DOUBLE
67478: LD_INT 1
67480: DEC
67481: ST_TO_ADDR
67482: LD_EXP 68
67486: PUSH
67487: FOR_TO
67488: IFFALSE 68238
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67490: LD_EXP 81
67494: PUSH
67495: LD_VAR 0 2
67499: ARRAY
67500: NOT
67501: PUSH
67502: LD_EXP 81
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: PUSH
67513: LD_EXP 82
67517: PUSH
67518: LD_VAR 0 2
67522: ARRAY
67523: EQUAL
67524: OR
67525: PUSH
67526: LD_EXP 91
67530: PUSH
67531: LD_VAR 0 2
67535: ARRAY
67536: OR
67537: IFFALSE 67541
// continue ;
67539: GO 67487
// if mc_miners [ i ] then
67541: LD_EXP 82
67545: PUSH
67546: LD_VAR 0 2
67550: ARRAY
67551: IFFALSE 67925
// begin for j = mc_miners [ i ] downto 1 do
67553: LD_ADDR_VAR 0 3
67557: PUSH
67558: DOUBLE
67559: LD_EXP 82
67563: PUSH
67564: LD_VAR 0 2
67568: ARRAY
67569: INC
67570: ST_TO_ADDR
67571: LD_INT 1
67573: PUSH
67574: FOR_DOWNTO
67575: IFFALSE 67923
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67577: LD_EXP 82
67581: PUSH
67582: LD_VAR 0 2
67586: ARRAY
67587: PUSH
67588: LD_VAR 0 3
67592: ARRAY
67593: PPUSH
67594: CALL_OW 301
67598: PUSH
67599: LD_EXP 82
67603: PUSH
67604: LD_VAR 0 2
67608: ARRAY
67609: PUSH
67610: LD_VAR 0 3
67614: ARRAY
67615: PPUSH
67616: CALL_OW 257
67620: PUSH
67621: LD_INT 1
67623: NONEQUAL
67624: OR
67625: IFFALSE 67688
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67627: LD_ADDR_VAR 0 5
67631: PUSH
67632: LD_EXP 82
67636: PUSH
67637: LD_VAR 0 2
67641: ARRAY
67642: PUSH
67643: LD_EXP 82
67647: PUSH
67648: LD_VAR 0 2
67652: ARRAY
67653: PUSH
67654: LD_VAR 0 3
67658: ARRAY
67659: DIFF
67660: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67661: LD_ADDR_EXP 82
67665: PUSH
67666: LD_EXP 82
67670: PPUSH
67671: LD_VAR 0 2
67675: PPUSH
67676: LD_VAR 0 5
67680: PPUSH
67681: CALL_OW 1
67685: ST_TO_ADDR
// continue ;
67686: GO 67574
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67688: LD_EXP 82
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: PUSH
67699: LD_VAR 0 3
67703: ARRAY
67704: PPUSH
67705: CALL_OW 257
67709: PUSH
67710: LD_INT 1
67712: EQUAL
67713: PUSH
67714: LD_EXP 82
67718: PUSH
67719: LD_VAR 0 2
67723: ARRAY
67724: PUSH
67725: LD_VAR 0 3
67729: ARRAY
67730: PPUSH
67731: CALL_OW 459
67735: NOT
67736: AND
67737: PUSH
67738: LD_EXP 82
67742: PUSH
67743: LD_VAR 0 2
67747: ARRAY
67748: PUSH
67749: LD_VAR 0 3
67753: ARRAY
67754: PPUSH
67755: CALL_OW 314
67759: NOT
67760: AND
67761: IFFALSE 67921
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67763: LD_EXP 82
67767: PUSH
67768: LD_VAR 0 2
67772: ARRAY
67773: PUSH
67774: LD_VAR 0 3
67778: ARRAY
67779: PPUSH
67780: CALL_OW 310
67784: IFFALSE 67807
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67786: LD_EXP 82
67790: PUSH
67791: LD_VAR 0 2
67795: ARRAY
67796: PUSH
67797: LD_VAR 0 3
67801: ARRAY
67802: PPUSH
67803: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67807: LD_EXP 82
67811: PUSH
67812: LD_VAR 0 2
67816: ARRAY
67817: PUSH
67818: LD_VAR 0 3
67822: ARRAY
67823: PPUSH
67824: CALL_OW 314
67828: NOT
67829: IFFALSE 67921
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67831: LD_ADDR_VAR 0 7
67835: PUSH
67836: LD_INT 1
67838: PPUSH
67839: LD_EXP 81
67843: PUSH
67844: LD_VAR 0 2
67848: ARRAY
67849: PPUSH
67850: CALL_OW 12
67854: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67855: LD_EXP 82
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: PUSH
67866: LD_VAR 0 3
67870: ARRAY
67871: PPUSH
67872: LD_EXP 81
67876: PUSH
67877: LD_VAR 0 2
67881: ARRAY
67882: PUSH
67883: LD_VAR 0 7
67887: ARRAY
67888: PUSH
67889: LD_INT 1
67891: ARRAY
67892: PPUSH
67893: LD_EXP 81
67897: PUSH
67898: LD_VAR 0 2
67902: ARRAY
67903: PUSH
67904: LD_VAR 0 7
67908: ARRAY
67909: PUSH
67910: LD_INT 2
67912: ARRAY
67913: PPUSH
67914: LD_INT 0
67916: PPUSH
67917: CALL_OW 193
// end ; end ; end ;
67921: GO 67574
67923: POP
67924: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67925: LD_ADDR_VAR 0 5
67929: PUSH
67930: LD_EXP 68
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: PPUSH
67941: LD_INT 2
67943: PUSH
67944: LD_INT 30
67946: PUSH
67947: LD_INT 4
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PUSH
67954: LD_INT 30
67956: PUSH
67957: LD_INT 5
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 30
67966: PUSH
67967: LD_INT 32
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: PPUSH
67980: CALL_OW 72
67984: ST_TO_ADDR
// if not tmp then
67985: LD_VAR 0 5
67989: NOT
67990: IFFALSE 67994
// continue ;
67992: GO 67487
// list := [ ] ;
67994: LD_ADDR_VAR 0 6
67998: PUSH
67999: EMPTY
68000: ST_TO_ADDR
// for j in tmp do
68001: LD_ADDR_VAR 0 3
68005: PUSH
68006: LD_VAR 0 5
68010: PUSH
68011: FOR_IN
68012: IFFALSE 68081
// begin for k in UnitsInside ( j ) do
68014: LD_ADDR_VAR 0 4
68018: PUSH
68019: LD_VAR 0 3
68023: PPUSH
68024: CALL_OW 313
68028: PUSH
68029: FOR_IN
68030: IFFALSE 68077
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68032: LD_VAR 0 4
68036: PPUSH
68037: CALL_OW 257
68041: PUSH
68042: LD_INT 1
68044: EQUAL
68045: PUSH
68046: LD_VAR 0 4
68050: PPUSH
68051: CALL_OW 459
68055: NOT
68056: AND
68057: IFFALSE 68075
// list := list ^ k ;
68059: LD_ADDR_VAR 0 6
68063: PUSH
68064: LD_VAR 0 6
68068: PUSH
68069: LD_VAR 0 4
68073: ADD
68074: ST_TO_ADDR
68075: GO 68029
68077: POP
68078: POP
// end ;
68079: GO 68011
68081: POP
68082: POP
// list := list diff mc_miners [ i ] ;
68083: LD_ADDR_VAR 0 6
68087: PUSH
68088: LD_VAR 0 6
68092: PUSH
68093: LD_EXP 82
68097: PUSH
68098: LD_VAR 0 2
68102: ARRAY
68103: DIFF
68104: ST_TO_ADDR
// if not list then
68105: LD_VAR 0 6
68109: NOT
68110: IFFALSE 68114
// continue ;
68112: GO 67487
// k := mc_mines [ i ] - mc_miners [ i ] ;
68114: LD_ADDR_VAR 0 4
68118: PUSH
68119: LD_EXP 81
68123: PUSH
68124: LD_VAR 0 2
68128: ARRAY
68129: PUSH
68130: LD_EXP 82
68134: PUSH
68135: LD_VAR 0 2
68139: ARRAY
68140: MINUS
68141: ST_TO_ADDR
// if k > list then
68142: LD_VAR 0 4
68146: PUSH
68147: LD_VAR 0 6
68151: GREATER
68152: IFFALSE 68164
// k := list ;
68154: LD_ADDR_VAR 0 4
68158: PUSH
68159: LD_VAR 0 6
68163: ST_TO_ADDR
// for j = 1 to k do
68164: LD_ADDR_VAR 0 3
68168: PUSH
68169: DOUBLE
68170: LD_INT 1
68172: DEC
68173: ST_TO_ADDR
68174: LD_VAR 0 4
68178: PUSH
68179: FOR_TO
68180: IFFALSE 68234
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68182: LD_ADDR_EXP 82
68186: PUSH
68187: LD_EXP 82
68191: PPUSH
68192: LD_VAR 0 2
68196: PUSH
68197: LD_EXP 82
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: PUSH
68208: LD_INT 1
68210: PLUS
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PPUSH
68216: LD_VAR 0 6
68220: PUSH
68221: LD_VAR 0 3
68225: ARRAY
68226: PPUSH
68227: CALL 18750 0 3
68231: ST_TO_ADDR
68232: GO 68179
68234: POP
68235: POP
// end ;
68236: GO 67487
68238: POP
68239: POP
// end ;
68240: LD_VAR 0 1
68244: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68245: LD_INT 0
68247: PPUSH
68248: PPUSH
68249: PPUSH
68250: PPUSH
68251: PPUSH
68252: PPUSH
68253: PPUSH
68254: PPUSH
68255: PPUSH
68256: PPUSH
68257: PPUSH
// if not mc_bases then
68258: LD_EXP 68
68262: NOT
68263: IFFALSE 68267
// exit ;
68265: GO 70090
// for i = 1 to mc_bases do
68267: LD_ADDR_VAR 0 2
68271: PUSH
68272: DOUBLE
68273: LD_INT 1
68275: DEC
68276: ST_TO_ADDR
68277: LD_EXP 68
68281: PUSH
68282: FOR_TO
68283: IFFALSE 70088
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68285: LD_EXP 68
68289: PUSH
68290: LD_VAR 0 2
68294: ARRAY
68295: NOT
68296: PUSH
68297: LD_EXP 75
68301: PUSH
68302: LD_VAR 0 2
68306: ARRAY
68307: OR
68308: IFFALSE 68312
// continue ;
68310: GO 68282
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68312: LD_EXP 84
68316: PUSH
68317: LD_VAR 0 2
68321: ARRAY
68322: NOT
68323: PUSH
68324: LD_EXP 85
68328: PUSH
68329: LD_VAR 0 2
68333: ARRAY
68334: AND
68335: IFFALSE 68373
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68337: LD_ADDR_EXP 85
68341: PUSH
68342: LD_EXP 85
68346: PPUSH
68347: LD_VAR 0 2
68351: PPUSH
68352: EMPTY
68353: PPUSH
68354: CALL_OW 1
68358: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68359: LD_VAR 0 2
68363: PPUSH
68364: LD_INT 107
68366: PPUSH
68367: CALL 59141 0 2
// continue ;
68371: GO 68282
// end ; target := [ ] ;
68373: LD_ADDR_VAR 0 7
68377: PUSH
68378: EMPTY
68379: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68380: LD_ADDR_VAR 0 6
68384: PUSH
68385: LD_EXP 68
68389: PUSH
68390: LD_VAR 0 2
68394: ARRAY
68395: PUSH
68396: LD_INT 1
68398: ARRAY
68399: PPUSH
68400: CALL_OW 255
68404: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68405: LD_ADDR_VAR 0 9
68409: PUSH
68410: LD_EXP 68
68414: PUSH
68415: LD_VAR 0 2
68419: ARRAY
68420: PPUSH
68421: LD_INT 2
68423: PUSH
68424: LD_INT 30
68426: PUSH
68427: LD_INT 0
68429: PUSH
68430: EMPTY
68431: LIST
68432: LIST
68433: PUSH
68434: LD_INT 30
68436: PUSH
68437: LD_INT 1
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: LIST
68448: PPUSH
68449: CALL_OW 72
68453: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68454: LD_ADDR_VAR 0 3
68458: PUSH
68459: DOUBLE
68460: LD_EXP 84
68464: PUSH
68465: LD_VAR 0 2
68469: ARRAY
68470: INC
68471: ST_TO_ADDR
68472: LD_INT 1
68474: PUSH
68475: FOR_DOWNTO
68476: IFFALSE 68721
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68478: LD_EXP 84
68482: PUSH
68483: LD_VAR 0 2
68487: ARRAY
68488: PUSH
68489: LD_VAR 0 3
68493: ARRAY
68494: PUSH
68495: LD_INT 2
68497: ARRAY
68498: PPUSH
68499: LD_EXP 84
68503: PUSH
68504: LD_VAR 0 2
68508: ARRAY
68509: PUSH
68510: LD_VAR 0 3
68514: ARRAY
68515: PUSH
68516: LD_INT 3
68518: ARRAY
68519: PPUSH
68520: CALL_OW 488
68524: PUSH
68525: LD_EXP 84
68529: PUSH
68530: LD_VAR 0 2
68534: ARRAY
68535: PUSH
68536: LD_VAR 0 3
68540: ARRAY
68541: PUSH
68542: LD_INT 2
68544: ARRAY
68545: PPUSH
68546: LD_EXP 84
68550: PUSH
68551: LD_VAR 0 2
68555: ARRAY
68556: PUSH
68557: LD_VAR 0 3
68561: ARRAY
68562: PUSH
68563: LD_INT 3
68565: ARRAY
68566: PPUSH
68567: CALL_OW 284
68571: PUSH
68572: LD_INT 0
68574: EQUAL
68575: AND
68576: IFFALSE 68631
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68578: LD_ADDR_VAR 0 5
68582: PUSH
68583: LD_EXP 84
68587: PUSH
68588: LD_VAR 0 2
68592: ARRAY
68593: PPUSH
68594: LD_VAR 0 3
68598: PPUSH
68599: CALL_OW 3
68603: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68604: LD_ADDR_EXP 84
68608: PUSH
68609: LD_EXP 84
68613: PPUSH
68614: LD_VAR 0 2
68618: PPUSH
68619: LD_VAR 0 5
68623: PPUSH
68624: CALL_OW 1
68628: ST_TO_ADDR
// continue ;
68629: GO 68475
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68631: LD_VAR 0 6
68635: PPUSH
68636: LD_EXP 84
68640: PUSH
68641: LD_VAR 0 2
68645: ARRAY
68646: PUSH
68647: LD_VAR 0 3
68651: ARRAY
68652: PUSH
68653: LD_INT 2
68655: ARRAY
68656: PPUSH
68657: LD_EXP 84
68661: PUSH
68662: LD_VAR 0 2
68666: ARRAY
68667: PUSH
68668: LD_VAR 0 3
68672: ARRAY
68673: PUSH
68674: LD_INT 3
68676: ARRAY
68677: PPUSH
68678: LD_INT 30
68680: PPUSH
68681: CALL 19646 0 4
68685: PUSH
68686: LD_INT 4
68688: ARRAY
68689: PUSH
68690: LD_INT 0
68692: EQUAL
68693: IFFALSE 68719
// begin target := mc_crates [ i ] [ j ] ;
68695: LD_ADDR_VAR 0 7
68699: PUSH
68700: LD_EXP 84
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: PUSH
68711: LD_VAR 0 3
68715: ARRAY
68716: ST_TO_ADDR
// break ;
68717: GO 68721
// end ; end ;
68719: GO 68475
68721: POP
68722: POP
// if not target then
68723: LD_VAR 0 7
68727: NOT
68728: IFFALSE 68732
// continue ;
68730: GO 68282
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68732: LD_ADDR_VAR 0 8
68736: PUSH
68737: LD_EXP 87
68741: PUSH
68742: LD_VAR 0 2
68746: ARRAY
68747: PPUSH
68748: LD_INT 2
68750: PUSH
68751: LD_INT 3
68753: PUSH
68754: LD_INT 58
68756: PUSH
68757: EMPTY
68758: LIST
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 61
68766: PUSH
68767: EMPTY
68768: LIST
68769: PUSH
68770: LD_INT 33
68772: PUSH
68773: LD_INT 5
68775: PUSH
68776: EMPTY
68777: LIST
68778: LIST
68779: PUSH
68780: LD_INT 33
68782: PUSH
68783: LD_INT 3
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: LIST
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 2
68799: PUSH
68800: LD_INT 34
68802: PUSH
68803: LD_INT 32
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 34
68812: PUSH
68813: LD_INT 51
68815: PUSH
68816: EMPTY
68817: LIST
68818: LIST
68819: PUSH
68820: LD_INT 34
68822: PUSH
68823: LD_INT 12
68825: PUSH
68826: EMPTY
68827: LIST
68828: LIST
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PPUSH
68840: CALL_OW 72
68844: ST_TO_ADDR
// if not cargo then
68845: LD_VAR 0 8
68849: NOT
68850: IFFALSE 69556
// begin if mc_crates_collector [ i ] < 5 then
68852: LD_EXP 85
68856: PUSH
68857: LD_VAR 0 2
68861: ARRAY
68862: PUSH
68863: LD_INT 5
68865: LESS
68866: IFFALSE 69232
// begin if mc_ape [ i ] then
68868: LD_EXP 97
68872: PUSH
68873: LD_VAR 0 2
68877: ARRAY
68878: IFFALSE 68925
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68880: LD_ADDR_VAR 0 5
68884: PUSH
68885: LD_EXP 97
68889: PUSH
68890: LD_VAR 0 2
68894: ARRAY
68895: PPUSH
68896: LD_INT 25
68898: PUSH
68899: LD_INT 16
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 24
68908: PUSH
68909: LD_INT 750
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PPUSH
68920: CALL_OW 72
68924: ST_TO_ADDR
// if not tmp then
68925: LD_VAR 0 5
68929: NOT
68930: IFFALSE 68977
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68932: LD_ADDR_VAR 0 5
68936: PUSH
68937: LD_EXP 68
68941: PUSH
68942: LD_VAR 0 2
68946: ARRAY
68947: PPUSH
68948: LD_INT 25
68950: PUSH
68951: LD_INT 2
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: PUSH
68958: LD_INT 24
68960: PUSH
68961: LD_INT 750
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PPUSH
68972: CALL_OW 72
68976: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68977: LD_EXP 97
68981: PUSH
68982: LD_VAR 0 2
68986: ARRAY
68987: PUSH
68988: LD_EXP 68
68992: PUSH
68993: LD_VAR 0 2
68997: ARRAY
68998: PPUSH
68999: LD_INT 25
69001: PUSH
69002: LD_INT 2
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 24
69011: PUSH
69012: LD_INT 750
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PPUSH
69023: CALL_OW 72
69027: AND
69028: PUSH
69029: LD_VAR 0 5
69033: PUSH
69034: LD_INT 5
69036: LESS
69037: AND
69038: IFFALSE 69120
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69040: LD_ADDR_VAR 0 3
69044: PUSH
69045: LD_EXP 68
69049: PUSH
69050: LD_VAR 0 2
69054: ARRAY
69055: PPUSH
69056: LD_INT 25
69058: PUSH
69059: LD_INT 2
69061: PUSH
69062: EMPTY
69063: LIST
69064: LIST
69065: PUSH
69066: LD_INT 24
69068: PUSH
69069: LD_INT 750
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: EMPTY
69077: LIST
69078: LIST
69079: PPUSH
69080: CALL_OW 72
69084: PUSH
69085: FOR_IN
69086: IFFALSE 69118
// begin tmp := tmp union j ;
69088: LD_ADDR_VAR 0 5
69092: PUSH
69093: LD_VAR 0 5
69097: PUSH
69098: LD_VAR 0 3
69102: UNION
69103: ST_TO_ADDR
// if tmp >= 5 then
69104: LD_VAR 0 5
69108: PUSH
69109: LD_INT 5
69111: GREATEREQUAL
69112: IFFALSE 69116
// break ;
69114: GO 69118
// end ;
69116: GO 69085
69118: POP
69119: POP
// end ; if not tmp then
69120: LD_VAR 0 5
69124: NOT
69125: IFFALSE 69129
// continue ;
69127: GO 68282
// for j in tmp do
69129: LD_ADDR_VAR 0 3
69133: PUSH
69134: LD_VAR 0 5
69138: PUSH
69139: FOR_IN
69140: IFFALSE 69230
// if not GetTag ( j ) then
69142: LD_VAR 0 3
69146: PPUSH
69147: CALL_OW 110
69151: NOT
69152: IFFALSE 69228
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69154: LD_ADDR_EXP 85
69158: PUSH
69159: LD_EXP 85
69163: PPUSH
69164: LD_VAR 0 2
69168: PUSH
69169: LD_EXP 85
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: PUSH
69180: LD_INT 1
69182: PLUS
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PPUSH
69188: LD_VAR 0 3
69192: PPUSH
69193: CALL 18750 0 3
69197: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69198: LD_VAR 0 3
69202: PPUSH
69203: LD_INT 107
69205: PPUSH
69206: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69210: LD_EXP 85
69214: PUSH
69215: LD_VAR 0 2
69219: ARRAY
69220: PUSH
69221: LD_INT 5
69223: GREATEREQUAL
69224: IFFALSE 69228
// break ;
69226: GO 69230
// end ;
69228: GO 69139
69230: POP
69231: POP
// end ; if mc_crates_collector [ i ] and target then
69232: LD_EXP 85
69236: PUSH
69237: LD_VAR 0 2
69241: ARRAY
69242: PUSH
69243: LD_VAR 0 7
69247: AND
69248: IFFALSE 69554
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69250: LD_EXP 85
69254: PUSH
69255: LD_VAR 0 2
69259: ARRAY
69260: PUSH
69261: LD_VAR 0 7
69265: PUSH
69266: LD_INT 1
69268: ARRAY
69269: LESS
69270: IFFALSE 69290
// tmp := mc_crates_collector [ i ] else
69272: LD_ADDR_VAR 0 5
69276: PUSH
69277: LD_EXP 85
69281: PUSH
69282: LD_VAR 0 2
69286: ARRAY
69287: ST_TO_ADDR
69288: GO 69304
// tmp := target [ 1 ] ;
69290: LD_ADDR_VAR 0 5
69294: PUSH
69295: LD_VAR 0 7
69299: PUSH
69300: LD_INT 1
69302: ARRAY
69303: ST_TO_ADDR
// k := 0 ;
69304: LD_ADDR_VAR 0 4
69308: PUSH
69309: LD_INT 0
69311: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_EXP 85
69321: PUSH
69322: LD_VAR 0 2
69326: ARRAY
69327: PUSH
69328: FOR_IN
69329: IFFALSE 69552
// begin k := k + 1 ;
69331: LD_ADDR_VAR 0 4
69335: PUSH
69336: LD_VAR 0 4
69340: PUSH
69341: LD_INT 1
69343: PLUS
69344: ST_TO_ADDR
// if k > tmp then
69345: LD_VAR 0 4
69349: PUSH
69350: LD_VAR 0 5
69354: GREATER
69355: IFFALSE 69359
// break ;
69357: GO 69552
// if not GetClass ( j ) in [ 2 , 16 ] then
69359: LD_VAR 0 3
69363: PPUSH
69364: CALL_OW 257
69368: PUSH
69369: LD_INT 2
69371: PUSH
69372: LD_INT 16
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: IN
69379: NOT
69380: IFFALSE 69433
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69382: LD_ADDR_EXP 85
69386: PUSH
69387: LD_EXP 85
69391: PPUSH
69392: LD_VAR 0 2
69396: PPUSH
69397: LD_EXP 85
69401: PUSH
69402: LD_VAR 0 2
69406: ARRAY
69407: PUSH
69408: LD_VAR 0 3
69412: DIFF
69413: PPUSH
69414: CALL_OW 1
69418: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69419: LD_VAR 0 3
69423: PPUSH
69424: LD_INT 0
69426: PPUSH
69427: CALL_OW 109
// continue ;
69431: GO 69328
// end ; if IsInUnit ( j ) then
69433: LD_VAR 0 3
69437: PPUSH
69438: CALL_OW 310
69442: IFFALSE 69453
// ComExitBuilding ( j ) ;
69444: LD_VAR 0 3
69448: PPUSH
69449: CALL_OW 122
// wait ( 3 ) ;
69453: LD_INT 3
69455: PPUSH
69456: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69460: LD_VAR 0 3
69464: PPUSH
69465: CALL_OW 314
69469: PUSH
69470: LD_VAR 0 6
69474: PPUSH
69475: LD_VAR 0 7
69479: PUSH
69480: LD_INT 2
69482: ARRAY
69483: PPUSH
69484: LD_VAR 0 7
69488: PUSH
69489: LD_INT 3
69491: ARRAY
69492: PPUSH
69493: LD_INT 30
69495: PPUSH
69496: CALL 19646 0 4
69500: PUSH
69501: LD_INT 4
69503: ARRAY
69504: AND
69505: IFFALSE 69523
// ComStandNearbyBuilding ( j , depot ) else
69507: LD_VAR 0 3
69511: PPUSH
69512: LD_VAR 0 9
69516: PPUSH
69517: CALL 15175 0 2
69521: GO 69550
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69523: LD_VAR 0 3
69527: PPUSH
69528: LD_VAR 0 7
69532: PUSH
69533: LD_INT 2
69535: ARRAY
69536: PPUSH
69537: LD_VAR 0 7
69541: PUSH
69542: LD_INT 3
69544: ARRAY
69545: PPUSH
69546: CALL_OW 117
// end ;
69550: GO 69328
69552: POP
69553: POP
// end ; end else
69554: GO 70086
// begin for j in cargo do
69556: LD_ADDR_VAR 0 3
69560: PUSH
69561: LD_VAR 0 8
69565: PUSH
69566: FOR_IN
69567: IFFALSE 70084
// begin if GetTag ( j ) <> 0 then
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL_OW 110
69578: PUSH
69579: LD_INT 0
69581: NONEQUAL
69582: IFFALSE 69586
// continue ;
69584: GO 69566
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69586: LD_VAR 0 3
69590: PPUSH
69591: CALL_OW 256
69595: PUSH
69596: LD_INT 1000
69598: LESS
69599: PUSH
69600: LD_VAR 0 3
69604: PPUSH
69605: LD_EXP 92
69609: PUSH
69610: LD_VAR 0 2
69614: ARRAY
69615: PPUSH
69616: CALL_OW 308
69620: NOT
69621: AND
69622: IFFALSE 69644
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69624: LD_VAR 0 3
69628: PPUSH
69629: LD_EXP 92
69633: PUSH
69634: LD_VAR 0 2
69638: ARRAY
69639: PPUSH
69640: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69644: LD_VAR 0 3
69648: PPUSH
69649: CALL_OW 256
69653: PUSH
69654: LD_INT 1000
69656: LESS
69657: PUSH
69658: LD_VAR 0 3
69662: PPUSH
69663: LD_EXP 92
69667: PUSH
69668: LD_VAR 0 2
69672: ARRAY
69673: PPUSH
69674: CALL_OW 308
69678: AND
69679: IFFALSE 69683
// continue ;
69681: GO 69566
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69683: LD_VAR 0 3
69687: PPUSH
69688: CALL_OW 262
69692: PUSH
69693: LD_INT 2
69695: EQUAL
69696: PUSH
69697: LD_VAR 0 3
69701: PPUSH
69702: CALL_OW 261
69706: PUSH
69707: LD_INT 15
69709: LESS
69710: AND
69711: IFFALSE 69715
// continue ;
69713: GO 69566
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69715: LD_VAR 0 3
69719: PPUSH
69720: CALL_OW 262
69724: PUSH
69725: LD_INT 1
69727: EQUAL
69728: PUSH
69729: LD_VAR 0 3
69733: PPUSH
69734: CALL_OW 261
69738: PUSH
69739: LD_INT 10
69741: LESS
69742: AND
69743: IFFALSE 70023
// begin if not depot then
69745: LD_VAR 0 9
69749: NOT
69750: IFFALSE 69754
// continue ;
69752: GO 69566
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69754: LD_VAR 0 3
69758: PPUSH
69759: LD_VAR 0 9
69763: PPUSH
69764: LD_VAR 0 3
69768: PPUSH
69769: CALL_OW 74
69773: PPUSH
69774: CALL_OW 296
69778: PUSH
69779: LD_INT 6
69781: LESS
69782: IFFALSE 69798
// SetFuel ( j , 100 ) else
69784: LD_VAR 0 3
69788: PPUSH
69789: LD_INT 100
69791: PPUSH
69792: CALL_OW 240
69796: GO 70023
// if GetFuel ( j ) = 0 then
69798: LD_VAR 0 3
69802: PPUSH
69803: CALL_OW 261
69807: PUSH
69808: LD_INT 0
69810: EQUAL
69811: IFFALSE 70023
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69813: LD_ADDR_EXP 87
69817: PUSH
69818: LD_EXP 87
69822: PPUSH
69823: LD_VAR 0 2
69827: PPUSH
69828: LD_EXP 87
69832: PUSH
69833: LD_VAR 0 2
69837: ARRAY
69838: PUSH
69839: LD_VAR 0 3
69843: DIFF
69844: PPUSH
69845: CALL_OW 1
69849: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69850: LD_VAR 0 3
69854: PPUSH
69855: CALL_OW 263
69859: PUSH
69860: LD_INT 1
69862: EQUAL
69863: IFFALSE 69879
// ComExitVehicle ( IsInUnit ( j ) ) ;
69865: LD_VAR 0 3
69869: PPUSH
69870: CALL_OW 310
69874: PPUSH
69875: CALL_OW 121
// if GetControl ( j ) = control_remote then
69879: LD_VAR 0 3
69883: PPUSH
69884: CALL_OW 263
69888: PUSH
69889: LD_INT 2
69891: EQUAL
69892: IFFALSE 69903
// ComUnlink ( j ) ;
69894: LD_VAR 0 3
69898: PPUSH
69899: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69903: LD_ADDR_VAR 0 10
69907: PUSH
69908: LD_VAR 0 2
69912: PPUSH
69913: LD_INT 3
69915: PPUSH
69916: CALL 79662 0 2
69920: ST_TO_ADDR
// if fac then
69921: LD_VAR 0 10
69925: IFFALSE 70021
// begin for k in fac do
69927: LD_ADDR_VAR 0 4
69931: PUSH
69932: LD_VAR 0 10
69936: PUSH
69937: FOR_IN
69938: IFFALSE 70019
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69940: LD_ADDR_VAR 0 11
69944: PUSH
69945: LD_VAR 0 10
69949: PPUSH
69950: LD_VAR 0 3
69954: PPUSH
69955: CALL_OW 265
69959: PPUSH
69960: LD_VAR 0 3
69964: PPUSH
69965: CALL_OW 262
69969: PPUSH
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 263
69979: PPUSH
69980: LD_VAR 0 3
69984: PPUSH
69985: CALL_OW 264
69989: PPUSH
69990: CALL 16246 0 5
69994: ST_TO_ADDR
// if components then
69995: LD_VAR 0 11
69999: IFFALSE 70017
// begin MC_InsertProduceList ( i , components ) ;
70001: LD_VAR 0 2
70005: PPUSH
70006: LD_VAR 0 11
70010: PPUSH
70011: CALL 79207 0 2
// break ;
70015: GO 70019
// end ; end ;
70017: GO 69937
70019: POP
70020: POP
// end ; continue ;
70021: GO 69566
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70023: LD_VAR 0 3
70027: PPUSH
70028: LD_INT 1
70030: PPUSH
70031: CALL_OW 289
70035: PUSH
70036: LD_INT 100
70038: LESS
70039: PUSH
70040: LD_VAR 0 3
70044: PPUSH
70045: CALL_OW 314
70049: NOT
70050: AND
70051: IFFALSE 70080
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70053: LD_VAR 0 3
70057: PPUSH
70058: LD_VAR 0 7
70062: PUSH
70063: LD_INT 2
70065: ARRAY
70066: PPUSH
70067: LD_VAR 0 7
70071: PUSH
70072: LD_INT 3
70074: ARRAY
70075: PPUSH
70076: CALL_OW 117
// break ;
70080: GO 70084
// end ;
70082: GO 69566
70084: POP
70085: POP
// end ; end ;
70086: GO 68282
70088: POP
70089: POP
// end ;
70090: LD_VAR 0 1
70094: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70095: LD_INT 0
70097: PPUSH
70098: PPUSH
70099: PPUSH
70100: PPUSH
// if not mc_bases then
70101: LD_EXP 68
70105: NOT
70106: IFFALSE 70110
// exit ;
70108: GO 70271
// for i = 1 to mc_bases do
70110: LD_ADDR_VAR 0 2
70114: PUSH
70115: DOUBLE
70116: LD_INT 1
70118: DEC
70119: ST_TO_ADDR
70120: LD_EXP 68
70124: PUSH
70125: FOR_TO
70126: IFFALSE 70269
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70128: LD_ADDR_VAR 0 4
70132: PUSH
70133: LD_EXP 87
70137: PUSH
70138: LD_VAR 0 2
70142: ARRAY
70143: PUSH
70144: LD_EXP 90
70148: PUSH
70149: LD_VAR 0 2
70153: ARRAY
70154: UNION
70155: PPUSH
70156: LD_INT 33
70158: PUSH
70159: LD_INT 2
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PPUSH
70166: CALL_OW 72
70170: ST_TO_ADDR
// if tmp then
70171: LD_VAR 0 4
70175: IFFALSE 70267
// for j in tmp do
70177: LD_ADDR_VAR 0 3
70181: PUSH
70182: LD_VAR 0 4
70186: PUSH
70187: FOR_IN
70188: IFFALSE 70265
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70190: LD_VAR 0 3
70194: PPUSH
70195: CALL_OW 312
70199: NOT
70200: PUSH
70201: LD_VAR 0 3
70205: PPUSH
70206: CALL_OW 256
70210: PUSH
70211: LD_INT 250
70213: GREATEREQUAL
70214: AND
70215: IFFALSE 70228
// Connect ( j ) else
70217: LD_VAR 0 3
70221: PPUSH
70222: CALL 21721 0 1
70226: GO 70263
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70228: LD_VAR 0 3
70232: PPUSH
70233: CALL_OW 256
70237: PUSH
70238: LD_INT 250
70240: LESS
70241: PUSH
70242: LD_VAR 0 3
70246: PPUSH
70247: CALL_OW 312
70251: AND
70252: IFFALSE 70263
// ComUnlink ( j ) ;
70254: LD_VAR 0 3
70258: PPUSH
70259: CALL_OW 136
70263: GO 70187
70265: POP
70266: POP
// end ;
70267: GO 70125
70269: POP
70270: POP
// end ;
70271: LD_VAR 0 1
70275: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70276: LD_INT 0
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
// if not mc_bases then
70283: LD_EXP 68
70287: NOT
70288: IFFALSE 70292
// exit ;
70290: GO 70737
// for i = 1 to mc_bases do
70292: LD_ADDR_VAR 0 2
70296: PUSH
70297: DOUBLE
70298: LD_INT 1
70300: DEC
70301: ST_TO_ADDR
70302: LD_EXP 68
70306: PUSH
70307: FOR_TO
70308: IFFALSE 70735
// begin if not mc_produce [ i ] then
70310: LD_EXP 89
70314: PUSH
70315: LD_VAR 0 2
70319: ARRAY
70320: NOT
70321: IFFALSE 70325
// continue ;
70323: GO 70307
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70325: LD_ADDR_VAR 0 5
70329: PUSH
70330: LD_EXP 68
70334: PUSH
70335: LD_VAR 0 2
70339: ARRAY
70340: PPUSH
70341: LD_INT 30
70343: PUSH
70344: LD_INT 3
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PPUSH
70351: CALL_OW 72
70355: ST_TO_ADDR
// if not fac then
70356: LD_VAR 0 5
70360: NOT
70361: IFFALSE 70365
// continue ;
70363: GO 70307
// for j in fac do
70365: LD_ADDR_VAR 0 3
70369: PUSH
70370: LD_VAR 0 5
70374: PUSH
70375: FOR_IN
70376: IFFALSE 70731
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70378: LD_VAR 0 3
70382: PPUSH
70383: CALL_OW 461
70387: PUSH
70388: LD_INT 2
70390: NONEQUAL
70391: PUSH
70392: LD_VAR 0 3
70396: PPUSH
70397: LD_INT 15
70399: PPUSH
70400: CALL 21349 0 2
70404: PUSH
70405: LD_INT 4
70407: ARRAY
70408: OR
70409: IFFALSE 70413
// continue ;
70411: GO 70375
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70413: LD_VAR 0 3
70417: PPUSH
70418: LD_EXP 89
70422: PUSH
70423: LD_VAR 0 2
70427: ARRAY
70428: PUSH
70429: LD_INT 1
70431: ARRAY
70432: PUSH
70433: LD_INT 1
70435: ARRAY
70436: PPUSH
70437: LD_EXP 89
70441: PUSH
70442: LD_VAR 0 2
70446: ARRAY
70447: PUSH
70448: LD_INT 1
70450: ARRAY
70451: PUSH
70452: LD_INT 2
70454: ARRAY
70455: PPUSH
70456: LD_EXP 89
70460: PUSH
70461: LD_VAR 0 2
70465: ARRAY
70466: PUSH
70467: LD_INT 1
70469: ARRAY
70470: PUSH
70471: LD_INT 3
70473: ARRAY
70474: PPUSH
70475: LD_EXP 89
70479: PUSH
70480: LD_VAR 0 2
70484: ARRAY
70485: PUSH
70486: LD_INT 1
70488: ARRAY
70489: PUSH
70490: LD_INT 4
70492: ARRAY
70493: PPUSH
70494: CALL_OW 448
70498: PUSH
70499: LD_VAR 0 3
70503: PPUSH
70504: LD_EXP 89
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PUSH
70515: LD_INT 1
70517: ARRAY
70518: PUSH
70519: LD_INT 1
70521: ARRAY
70522: PUSH
70523: LD_EXP 89
70527: PUSH
70528: LD_VAR 0 2
70532: ARRAY
70533: PUSH
70534: LD_INT 1
70536: ARRAY
70537: PUSH
70538: LD_INT 2
70540: ARRAY
70541: PUSH
70542: LD_EXP 89
70546: PUSH
70547: LD_VAR 0 2
70551: ARRAY
70552: PUSH
70553: LD_INT 1
70555: ARRAY
70556: PUSH
70557: LD_INT 3
70559: ARRAY
70560: PUSH
70561: LD_EXP 89
70565: PUSH
70566: LD_VAR 0 2
70570: ARRAY
70571: PUSH
70572: LD_INT 1
70574: ARRAY
70575: PUSH
70576: LD_INT 4
70578: ARRAY
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: PPUSH
70586: CALL 25116 0 2
70590: AND
70591: IFFALSE 70729
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70593: LD_VAR 0 3
70597: PPUSH
70598: LD_EXP 89
70602: PUSH
70603: LD_VAR 0 2
70607: ARRAY
70608: PUSH
70609: LD_INT 1
70611: ARRAY
70612: PUSH
70613: LD_INT 1
70615: ARRAY
70616: PPUSH
70617: LD_EXP 89
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PUSH
70628: LD_INT 1
70630: ARRAY
70631: PUSH
70632: LD_INT 2
70634: ARRAY
70635: PPUSH
70636: LD_EXP 89
70640: PUSH
70641: LD_VAR 0 2
70645: ARRAY
70646: PUSH
70647: LD_INT 1
70649: ARRAY
70650: PUSH
70651: LD_INT 3
70653: ARRAY
70654: PPUSH
70655: LD_EXP 89
70659: PUSH
70660: LD_VAR 0 2
70664: ARRAY
70665: PUSH
70666: LD_INT 1
70668: ARRAY
70669: PUSH
70670: LD_INT 4
70672: ARRAY
70673: PPUSH
70674: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70678: LD_ADDR_VAR 0 4
70682: PUSH
70683: LD_EXP 89
70687: PUSH
70688: LD_VAR 0 2
70692: ARRAY
70693: PPUSH
70694: LD_INT 1
70696: PPUSH
70697: CALL_OW 3
70701: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70702: LD_ADDR_EXP 89
70706: PUSH
70707: LD_EXP 89
70711: PPUSH
70712: LD_VAR 0 2
70716: PPUSH
70717: LD_VAR 0 4
70721: PPUSH
70722: CALL_OW 1
70726: ST_TO_ADDR
// break ;
70727: GO 70731
// end ; end ;
70729: GO 70375
70731: POP
70732: POP
// end ;
70733: GO 70307
70735: POP
70736: POP
// end ;
70737: LD_VAR 0 1
70741: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70742: LD_INT 0
70744: PPUSH
70745: PPUSH
70746: PPUSH
// if not mc_bases then
70747: LD_EXP 68
70751: NOT
70752: IFFALSE 70756
// exit ;
70754: GO 70845
// for i = 1 to mc_bases do
70756: LD_ADDR_VAR 0 2
70760: PUSH
70761: DOUBLE
70762: LD_INT 1
70764: DEC
70765: ST_TO_ADDR
70766: LD_EXP 68
70770: PUSH
70771: FOR_TO
70772: IFFALSE 70843
// begin if mc_attack [ i ] then
70774: LD_EXP 88
70778: PUSH
70779: LD_VAR 0 2
70783: ARRAY
70784: IFFALSE 70841
// begin tmp := mc_attack [ i ] [ 1 ] ;
70786: LD_ADDR_VAR 0 3
70790: PUSH
70791: LD_EXP 88
70795: PUSH
70796: LD_VAR 0 2
70800: ARRAY
70801: PUSH
70802: LD_INT 1
70804: ARRAY
70805: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70806: LD_ADDR_EXP 88
70810: PUSH
70811: LD_EXP 88
70815: PPUSH
70816: LD_VAR 0 2
70820: PPUSH
70821: EMPTY
70822: PPUSH
70823: CALL_OW 1
70827: ST_TO_ADDR
// Attack ( tmp ) ;
70828: LD_VAR 0 3
70832: PPUSH
70833: CALL 105575 0 1
// exit ;
70837: POP
70838: POP
70839: GO 70845
// end ; end ;
70841: GO 70771
70843: POP
70844: POP
// end ;
70845: LD_VAR 0 1
70849: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70850: LD_INT 0
70852: PPUSH
70853: PPUSH
70854: PPUSH
70855: PPUSH
70856: PPUSH
70857: PPUSH
70858: PPUSH
// if not mc_bases then
70859: LD_EXP 68
70863: NOT
70864: IFFALSE 70868
// exit ;
70866: GO 71725
// for i = 1 to mc_bases do
70868: LD_ADDR_VAR 0 2
70872: PUSH
70873: DOUBLE
70874: LD_INT 1
70876: DEC
70877: ST_TO_ADDR
70878: LD_EXP 68
70882: PUSH
70883: FOR_TO
70884: IFFALSE 71723
// begin if not mc_bases [ i ] then
70886: LD_EXP 68
70890: PUSH
70891: LD_VAR 0 2
70895: ARRAY
70896: NOT
70897: IFFALSE 70901
// continue ;
70899: GO 70883
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70901: LD_ADDR_VAR 0 7
70905: PUSH
70906: LD_EXP 68
70910: PUSH
70911: LD_VAR 0 2
70915: ARRAY
70916: PUSH
70917: LD_INT 1
70919: ARRAY
70920: PPUSH
70921: CALL 15397 0 1
70925: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70926: LD_ADDR_EXP 91
70930: PUSH
70931: LD_EXP 91
70935: PPUSH
70936: LD_VAR 0 2
70940: PPUSH
70941: LD_EXP 68
70945: PUSH
70946: LD_VAR 0 2
70950: ARRAY
70951: PUSH
70952: LD_INT 1
70954: ARRAY
70955: PPUSH
70956: CALL_OW 255
70960: PPUSH
70961: LD_EXP 93
70965: PUSH
70966: LD_VAR 0 2
70970: ARRAY
70971: PPUSH
70972: CALL 15362 0 2
70976: PPUSH
70977: CALL_OW 1
70981: ST_TO_ADDR
// if not mc_scan [ i ] then
70982: LD_EXP 91
70986: PUSH
70987: LD_VAR 0 2
70991: ARRAY
70992: NOT
70993: IFFALSE 71171
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70995: LD_ADDR_EXP 111
70999: PUSH
71000: LD_EXP 111
71004: PPUSH
71005: LD_VAR 0 2
71009: PPUSH
71010: LD_INT 0
71012: PPUSH
71013: CALL_OW 1
71017: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71018: LD_ADDR_VAR 0 4
71022: PUSH
71023: LD_EXP 68
71027: PUSH
71028: LD_VAR 0 2
71032: ARRAY
71033: PPUSH
71034: LD_INT 2
71036: PUSH
71037: LD_INT 25
71039: PUSH
71040: LD_INT 5
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 25
71049: PUSH
71050: LD_INT 8
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 25
71059: PUSH
71060: LD_INT 9
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: PPUSH
71073: CALL_OW 72
71077: ST_TO_ADDR
// if not tmp then
71078: LD_VAR 0 4
71082: NOT
71083: IFFALSE 71087
// continue ;
71085: GO 70883
// for j in tmp do
71087: LD_ADDR_VAR 0 3
71091: PUSH
71092: LD_VAR 0 4
71096: PUSH
71097: FOR_IN
71098: IFFALSE 71169
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71100: LD_VAR 0 3
71104: PPUSH
71105: CALL_OW 310
71109: PPUSH
71110: CALL_OW 266
71114: PUSH
71115: LD_INT 5
71117: EQUAL
71118: PUSH
71119: LD_VAR 0 3
71123: PPUSH
71124: CALL_OW 257
71128: PUSH
71129: LD_INT 1
71131: EQUAL
71132: AND
71133: PUSH
71134: LD_VAR 0 3
71138: PPUSH
71139: CALL_OW 459
71143: NOT
71144: AND
71145: PUSH
71146: LD_VAR 0 7
71150: AND
71151: IFFALSE 71167
// ComChangeProfession ( j , class ) ;
71153: LD_VAR 0 3
71157: PPUSH
71158: LD_VAR 0 7
71162: PPUSH
71163: CALL_OW 123
71167: GO 71097
71169: POP
71170: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71171: LD_EXP 91
71175: PUSH
71176: LD_VAR 0 2
71180: ARRAY
71181: PUSH
71182: LD_EXP 111
71186: PUSH
71187: LD_VAR 0 2
71191: ARRAY
71192: NOT
71193: AND
71194: PUSH
71195: LD_EXP 90
71199: PUSH
71200: LD_VAR 0 2
71204: ARRAY
71205: NOT
71206: AND
71207: PUSH
71208: LD_EXP 68
71212: PUSH
71213: LD_VAR 0 2
71217: ARRAY
71218: PPUSH
71219: LD_INT 50
71221: PUSH
71222: EMPTY
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: LD_INT 30
71230: PUSH
71231: LD_INT 32
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: PUSH
71238: LD_INT 30
71240: PUSH
71241: LD_INT 33
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 30
71250: PUSH
71251: LD_INT 4
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: LD_INT 30
71260: PUSH
71261: LD_INT 5
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PPUSH
71279: CALL_OW 72
71283: PUSH
71284: LD_INT 4
71286: LESS
71287: PUSH
71288: LD_EXP 68
71292: PUSH
71293: LD_VAR 0 2
71297: ARRAY
71298: PPUSH
71299: LD_INT 3
71301: PUSH
71302: LD_INT 24
71304: PUSH
71305: LD_INT 1000
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: PUSH
71316: LD_INT 2
71318: PUSH
71319: LD_INT 30
71321: PUSH
71322: LD_INT 0
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 30
71331: PUSH
71332: LD_INT 1
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: LIST
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PPUSH
71348: CALL_OW 72
71352: OR
71353: AND
71354: IFFALSE 71605
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71356: LD_ADDR_EXP 111
71360: PUSH
71361: LD_EXP 111
71365: PPUSH
71366: LD_VAR 0 2
71370: PPUSH
71371: LD_INT 1
71373: PPUSH
71374: CALL_OW 1
71378: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71379: LD_ADDR_VAR 0 4
71383: PUSH
71384: LD_EXP 68
71388: PUSH
71389: LD_VAR 0 2
71393: ARRAY
71394: PPUSH
71395: LD_INT 2
71397: PUSH
71398: LD_INT 25
71400: PUSH
71401: LD_INT 1
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 25
71410: PUSH
71411: LD_INT 5
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: LD_INT 25
71420: PUSH
71421: LD_INT 8
71423: PUSH
71424: EMPTY
71425: LIST
71426: LIST
71427: PUSH
71428: LD_INT 25
71430: PUSH
71431: LD_INT 9
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: LIST
71444: PPUSH
71445: CALL_OW 72
71449: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71450: LD_ADDR_VAR 0 4
71454: PUSH
71455: LD_VAR 0 4
71459: PUSH
71460: LD_VAR 0 4
71464: PPUSH
71465: LD_INT 18
71467: PPUSH
71468: CALL 48586 0 2
71472: DIFF
71473: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71474: LD_VAR 0 4
71478: NOT
71479: PUSH
71480: LD_EXP 68
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: PPUSH
71491: LD_INT 2
71493: PUSH
71494: LD_INT 30
71496: PUSH
71497: LD_INT 4
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 30
71506: PUSH
71507: LD_INT 5
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: LIST
71518: PPUSH
71519: CALL_OW 72
71523: NOT
71524: AND
71525: IFFALSE 71587
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71527: LD_ADDR_VAR 0 4
71531: PUSH
71532: LD_EXP 68
71536: PUSH
71537: LD_VAR 0 2
71541: ARRAY
71542: PPUSH
71543: LD_INT 2
71545: PUSH
71546: LD_INT 25
71548: PUSH
71549: LD_INT 2
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 25
71558: PUSH
71559: LD_INT 3
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 25
71568: PUSH
71569: LD_INT 4
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: PPUSH
71582: CALL_OW 72
71586: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71587: LD_VAR 0 2
71591: PPUSH
71592: LD_VAR 0 4
71596: PPUSH
71597: CALL 110284 0 2
// exit ;
71601: POP
71602: POP
71603: GO 71725
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71605: LD_EXP 91
71609: PUSH
71610: LD_VAR 0 2
71614: ARRAY
71615: PUSH
71616: LD_EXP 111
71620: PUSH
71621: LD_VAR 0 2
71625: ARRAY
71626: NOT
71627: AND
71628: PUSH
71629: LD_EXP 90
71633: PUSH
71634: LD_VAR 0 2
71638: ARRAY
71639: AND
71640: IFFALSE 71721
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71642: LD_ADDR_EXP 111
71646: PUSH
71647: LD_EXP 111
71651: PPUSH
71652: LD_VAR 0 2
71656: PPUSH
71657: LD_INT 1
71659: PPUSH
71660: CALL_OW 1
71664: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71665: LD_ADDR_VAR 0 4
71669: PUSH
71670: LD_EXP 90
71674: PUSH
71675: LD_VAR 0 2
71679: ARRAY
71680: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71681: LD_ADDR_EXP 90
71685: PUSH
71686: LD_EXP 90
71690: PPUSH
71691: LD_VAR 0 2
71695: PPUSH
71696: EMPTY
71697: PPUSH
71698: CALL_OW 1
71702: ST_TO_ADDR
// Defend ( i , tmp ) ;
71703: LD_VAR 0 2
71707: PPUSH
71708: LD_VAR 0 4
71712: PPUSH
71713: CALL 110880 0 2
// exit ;
71717: POP
71718: POP
71719: GO 71725
// end ; end ;
71721: GO 70883
71723: POP
71724: POP
// end ;
71725: LD_VAR 0 1
71729: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71730: LD_INT 0
71732: PPUSH
71733: PPUSH
71734: PPUSH
71735: PPUSH
71736: PPUSH
71737: PPUSH
71738: PPUSH
71739: PPUSH
71740: PPUSH
71741: PPUSH
71742: PPUSH
// if not mc_bases then
71743: LD_EXP 68
71747: NOT
71748: IFFALSE 71752
// exit ;
71750: GO 72839
// for i = 1 to mc_bases do
71752: LD_ADDR_VAR 0 2
71756: PUSH
71757: DOUBLE
71758: LD_INT 1
71760: DEC
71761: ST_TO_ADDR
71762: LD_EXP 68
71766: PUSH
71767: FOR_TO
71768: IFFALSE 72837
// begin tmp := mc_lab [ i ] ;
71770: LD_ADDR_VAR 0 6
71774: PUSH
71775: LD_EXP 101
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: ST_TO_ADDR
// if not tmp then
71786: LD_VAR 0 6
71790: NOT
71791: IFFALSE 71795
// continue ;
71793: GO 71767
// idle_lab := 0 ;
71795: LD_ADDR_VAR 0 11
71799: PUSH
71800: LD_INT 0
71802: ST_TO_ADDR
// for j in tmp do
71803: LD_ADDR_VAR 0 3
71807: PUSH
71808: LD_VAR 0 6
71812: PUSH
71813: FOR_IN
71814: IFFALSE 72833
// begin researching := false ;
71816: LD_ADDR_VAR 0 10
71820: PUSH
71821: LD_INT 0
71823: ST_TO_ADDR
// side := GetSide ( j ) ;
71824: LD_ADDR_VAR 0 4
71828: PUSH
71829: LD_VAR 0 3
71833: PPUSH
71834: CALL_OW 255
71838: ST_TO_ADDR
// if not mc_tech [ side ] then
71839: LD_EXP 95
71843: PUSH
71844: LD_VAR 0 4
71848: ARRAY
71849: NOT
71850: IFFALSE 71854
// continue ;
71852: GO 71813
// if BuildingStatus ( j ) = bs_idle then
71854: LD_VAR 0 3
71858: PPUSH
71859: CALL_OW 461
71863: PUSH
71864: LD_INT 2
71866: EQUAL
71867: IFFALSE 72055
// begin if idle_lab and UnitsInside ( j ) < 6 then
71869: LD_VAR 0 11
71873: PUSH
71874: LD_VAR 0 3
71878: PPUSH
71879: CALL_OW 313
71883: PUSH
71884: LD_INT 6
71886: LESS
71887: AND
71888: IFFALSE 71959
// begin tmp2 := UnitsInside ( idle_lab ) ;
71890: LD_ADDR_VAR 0 9
71894: PUSH
71895: LD_VAR 0 11
71899: PPUSH
71900: CALL_OW 313
71904: ST_TO_ADDR
// if tmp2 then
71905: LD_VAR 0 9
71909: IFFALSE 71951
// for x in tmp2 do
71911: LD_ADDR_VAR 0 7
71915: PUSH
71916: LD_VAR 0 9
71920: PUSH
71921: FOR_IN
71922: IFFALSE 71949
// begin ComExitBuilding ( x ) ;
71924: LD_VAR 0 7
71928: PPUSH
71929: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71933: LD_VAR 0 7
71937: PPUSH
71938: LD_VAR 0 3
71942: PPUSH
71943: CALL_OW 180
// end ;
71947: GO 71921
71949: POP
71950: POP
// idle_lab := 0 ;
71951: LD_ADDR_VAR 0 11
71955: PUSH
71956: LD_INT 0
71958: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71959: LD_ADDR_VAR 0 5
71963: PUSH
71964: LD_EXP 95
71968: PUSH
71969: LD_VAR 0 4
71973: ARRAY
71974: PUSH
71975: FOR_IN
71976: IFFALSE 72036
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71978: LD_VAR 0 3
71982: PPUSH
71983: LD_VAR 0 5
71987: PPUSH
71988: CALL_OW 430
71992: PUSH
71993: LD_VAR 0 4
71997: PPUSH
71998: LD_VAR 0 5
72002: PPUSH
72003: CALL 14467 0 2
72007: AND
72008: IFFALSE 72034
// begin researching := true ;
72010: LD_ADDR_VAR 0 10
72014: PUSH
72015: LD_INT 1
72017: ST_TO_ADDR
// ComResearch ( j , t ) ;
72018: LD_VAR 0 3
72022: PPUSH
72023: LD_VAR 0 5
72027: PPUSH
72028: CALL_OW 124
// break ;
72032: GO 72036
// end ;
72034: GO 71975
72036: POP
72037: POP
// if not researching then
72038: LD_VAR 0 10
72042: NOT
72043: IFFALSE 72055
// idle_lab := j ;
72045: LD_ADDR_VAR 0 11
72049: PUSH
72050: LD_VAR 0 3
72054: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72055: LD_VAR 0 3
72059: PPUSH
72060: CALL_OW 461
72064: PUSH
72065: LD_INT 10
72067: EQUAL
72068: IFFALSE 72656
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72070: LD_EXP 97
72074: PUSH
72075: LD_VAR 0 2
72079: ARRAY
72080: NOT
72081: PUSH
72082: LD_EXP 98
72086: PUSH
72087: LD_VAR 0 2
72091: ARRAY
72092: NOT
72093: AND
72094: PUSH
72095: LD_EXP 95
72099: PUSH
72100: LD_VAR 0 4
72104: ARRAY
72105: PUSH
72106: LD_INT 1
72108: GREATER
72109: AND
72110: IFFALSE 72241
// begin ComCancel ( j ) ;
72112: LD_VAR 0 3
72116: PPUSH
72117: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72121: LD_ADDR_EXP 95
72125: PUSH
72126: LD_EXP 95
72130: PPUSH
72131: LD_VAR 0 4
72135: PPUSH
72136: LD_EXP 95
72140: PUSH
72141: LD_VAR 0 4
72145: ARRAY
72146: PPUSH
72147: LD_EXP 95
72151: PUSH
72152: LD_VAR 0 4
72156: ARRAY
72157: PUSH
72158: LD_INT 1
72160: MINUS
72161: PPUSH
72162: LD_EXP 95
72166: PUSH
72167: LD_VAR 0 4
72171: ARRAY
72172: PPUSH
72173: LD_INT 0
72175: PPUSH
72176: CALL 18168 0 4
72180: PPUSH
72181: CALL_OW 1
72185: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72186: LD_ADDR_EXP 95
72190: PUSH
72191: LD_EXP 95
72195: PPUSH
72196: LD_VAR 0 4
72200: PPUSH
72201: LD_EXP 95
72205: PUSH
72206: LD_VAR 0 4
72210: ARRAY
72211: PPUSH
72212: LD_EXP 95
72216: PUSH
72217: LD_VAR 0 4
72221: ARRAY
72222: PPUSH
72223: LD_INT 1
72225: PPUSH
72226: LD_INT 0
72228: PPUSH
72229: CALL 18168 0 4
72233: PPUSH
72234: CALL_OW 1
72238: ST_TO_ADDR
// continue ;
72239: GO 71813
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72241: LD_EXP 97
72245: PUSH
72246: LD_VAR 0 2
72250: ARRAY
72251: PUSH
72252: LD_EXP 98
72256: PUSH
72257: LD_VAR 0 2
72261: ARRAY
72262: NOT
72263: AND
72264: IFFALSE 72391
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72266: LD_ADDR_EXP 98
72270: PUSH
72271: LD_EXP 98
72275: PPUSH
72276: LD_VAR 0 2
72280: PUSH
72281: LD_EXP 98
72285: PUSH
72286: LD_VAR 0 2
72290: ARRAY
72291: PUSH
72292: LD_INT 1
72294: PLUS
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: PPUSH
72300: LD_EXP 97
72304: PUSH
72305: LD_VAR 0 2
72309: ARRAY
72310: PUSH
72311: LD_INT 1
72313: ARRAY
72314: PPUSH
72315: CALL 18750 0 3
72319: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72320: LD_EXP 97
72324: PUSH
72325: LD_VAR 0 2
72329: ARRAY
72330: PUSH
72331: LD_INT 1
72333: ARRAY
72334: PPUSH
72335: LD_INT 112
72337: PPUSH
72338: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72342: LD_ADDR_VAR 0 9
72346: PUSH
72347: LD_EXP 97
72351: PUSH
72352: LD_VAR 0 2
72356: ARRAY
72357: PPUSH
72358: LD_INT 1
72360: PPUSH
72361: CALL_OW 3
72365: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72366: LD_ADDR_EXP 97
72370: PUSH
72371: LD_EXP 97
72375: PPUSH
72376: LD_VAR 0 2
72380: PPUSH
72381: LD_VAR 0 9
72385: PPUSH
72386: CALL_OW 1
72390: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72391: LD_EXP 97
72395: PUSH
72396: LD_VAR 0 2
72400: ARRAY
72401: PUSH
72402: LD_EXP 98
72406: PUSH
72407: LD_VAR 0 2
72411: ARRAY
72412: AND
72413: PUSH
72414: LD_EXP 98
72418: PUSH
72419: LD_VAR 0 2
72423: ARRAY
72424: PUSH
72425: LD_INT 1
72427: ARRAY
72428: PPUSH
72429: CALL_OW 310
72433: NOT
72434: AND
72435: PUSH
72436: LD_VAR 0 3
72440: PPUSH
72441: CALL_OW 313
72445: PUSH
72446: LD_INT 6
72448: EQUAL
72449: AND
72450: IFFALSE 72506
// begin tmp2 := UnitsInside ( j ) ;
72452: LD_ADDR_VAR 0 9
72456: PUSH
72457: LD_VAR 0 3
72461: PPUSH
72462: CALL_OW 313
72466: ST_TO_ADDR
// if tmp2 = 6 then
72467: LD_VAR 0 9
72471: PUSH
72472: LD_INT 6
72474: EQUAL
72475: IFFALSE 72506
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72477: LD_VAR 0 9
72481: PUSH
72482: LD_INT 1
72484: ARRAY
72485: PPUSH
72486: LD_INT 112
72488: PPUSH
72489: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72493: LD_VAR 0 9
72497: PUSH
72498: LD_INT 1
72500: ARRAY
72501: PPUSH
72502: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72506: LD_EXP 98
72510: PUSH
72511: LD_VAR 0 2
72515: ARRAY
72516: PUSH
72517: LD_EXP 98
72521: PUSH
72522: LD_VAR 0 2
72526: ARRAY
72527: PUSH
72528: LD_INT 1
72530: ARRAY
72531: PPUSH
72532: CALL_OW 314
72536: NOT
72537: AND
72538: PUSH
72539: LD_EXP 98
72543: PUSH
72544: LD_VAR 0 2
72548: ARRAY
72549: PUSH
72550: LD_INT 1
72552: ARRAY
72553: PPUSH
72554: CALL_OW 310
72558: NOT
72559: AND
72560: IFFALSE 72586
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72562: LD_EXP 98
72566: PUSH
72567: LD_VAR 0 2
72571: ARRAY
72572: PUSH
72573: LD_INT 1
72575: ARRAY
72576: PPUSH
72577: LD_VAR 0 3
72581: PPUSH
72582: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72586: LD_EXP 98
72590: PUSH
72591: LD_VAR 0 2
72595: ARRAY
72596: PUSH
72597: LD_INT 1
72599: ARRAY
72600: PPUSH
72601: CALL_OW 310
72605: PUSH
72606: LD_EXP 98
72610: PUSH
72611: LD_VAR 0 2
72615: ARRAY
72616: PUSH
72617: LD_INT 1
72619: ARRAY
72620: PPUSH
72621: CALL_OW 310
72625: PPUSH
72626: CALL_OW 461
72630: PUSH
72631: LD_INT 3
72633: NONEQUAL
72634: AND
72635: IFFALSE 72656
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72637: LD_EXP 98
72641: PUSH
72642: LD_VAR 0 2
72646: ARRAY
72647: PUSH
72648: LD_INT 1
72650: ARRAY
72651: PPUSH
72652: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72656: LD_VAR 0 3
72660: PPUSH
72661: CALL_OW 461
72665: PUSH
72666: LD_INT 6
72668: EQUAL
72669: PUSH
72670: LD_VAR 0 6
72674: PUSH
72675: LD_INT 1
72677: GREATER
72678: AND
72679: IFFALSE 72831
// begin sci := [ ] ;
72681: LD_ADDR_VAR 0 8
72685: PUSH
72686: EMPTY
72687: ST_TO_ADDR
// for x in ( tmp diff j ) do
72688: LD_ADDR_VAR 0 7
72692: PUSH
72693: LD_VAR 0 6
72697: PUSH
72698: LD_VAR 0 3
72702: DIFF
72703: PUSH
72704: FOR_IN
72705: IFFALSE 72757
// begin if sci = 6 then
72707: LD_VAR 0 8
72711: PUSH
72712: LD_INT 6
72714: EQUAL
72715: IFFALSE 72719
// break ;
72717: GO 72757
// if BuildingStatus ( x ) = bs_idle then
72719: LD_VAR 0 7
72723: PPUSH
72724: CALL_OW 461
72728: PUSH
72729: LD_INT 2
72731: EQUAL
72732: IFFALSE 72755
// sci := sci ^ UnitsInside ( x ) ;
72734: LD_ADDR_VAR 0 8
72738: PUSH
72739: LD_VAR 0 8
72743: PUSH
72744: LD_VAR 0 7
72748: PPUSH
72749: CALL_OW 313
72753: ADD
72754: ST_TO_ADDR
// end ;
72755: GO 72704
72757: POP
72758: POP
// if not sci then
72759: LD_VAR 0 8
72763: NOT
72764: IFFALSE 72768
// continue ;
72766: GO 71813
// for x in sci do
72768: LD_ADDR_VAR 0 7
72772: PUSH
72773: LD_VAR 0 8
72777: PUSH
72778: FOR_IN
72779: IFFALSE 72829
// if IsInUnit ( x ) and not HasTask ( x ) then
72781: LD_VAR 0 7
72785: PPUSH
72786: CALL_OW 310
72790: PUSH
72791: LD_VAR 0 7
72795: PPUSH
72796: CALL_OW 314
72800: NOT
72801: AND
72802: IFFALSE 72827
// begin ComExitBuilding ( x ) ;
72804: LD_VAR 0 7
72808: PPUSH
72809: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72813: LD_VAR 0 7
72817: PPUSH
72818: LD_VAR 0 3
72822: PPUSH
72823: CALL_OW 180
// end ;
72827: GO 72778
72829: POP
72830: POP
// end ; end ;
72831: GO 71813
72833: POP
72834: POP
// end ;
72835: GO 71767
72837: POP
72838: POP
// end ;
72839: LD_VAR 0 1
72843: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72844: LD_INT 0
72846: PPUSH
72847: PPUSH
// if not mc_bases then
72848: LD_EXP 68
72852: NOT
72853: IFFALSE 72857
// exit ;
72855: GO 72938
// for i = 1 to mc_bases do
72857: LD_ADDR_VAR 0 2
72861: PUSH
72862: DOUBLE
72863: LD_INT 1
72865: DEC
72866: ST_TO_ADDR
72867: LD_EXP 68
72871: PUSH
72872: FOR_TO
72873: IFFALSE 72936
// if mc_mines [ i ] and mc_miners [ i ] then
72875: LD_EXP 81
72879: PUSH
72880: LD_VAR 0 2
72884: ARRAY
72885: PUSH
72886: LD_EXP 82
72890: PUSH
72891: LD_VAR 0 2
72895: ARRAY
72896: AND
72897: IFFALSE 72934
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72899: LD_EXP 82
72903: PUSH
72904: LD_VAR 0 2
72908: ARRAY
72909: PUSH
72910: LD_INT 1
72912: ARRAY
72913: PPUSH
72914: CALL_OW 255
72918: PPUSH
72919: LD_EXP 81
72923: PUSH
72924: LD_VAR 0 2
72928: ARRAY
72929: PPUSH
72930: CALL 15550 0 2
72934: GO 72872
72936: POP
72937: POP
// end ;
72938: LD_VAR 0 1
72942: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72943: LD_INT 0
72945: PPUSH
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
72950: PPUSH
72951: PPUSH
72952: PPUSH
// if not mc_bases or not mc_parking then
72953: LD_EXP 68
72957: NOT
72958: PUSH
72959: LD_EXP 92
72963: NOT
72964: OR
72965: IFFALSE 72969
// exit ;
72967: GO 73679
// for i = 1 to mc_bases do
72969: LD_ADDR_VAR 0 2
72973: PUSH
72974: DOUBLE
72975: LD_INT 1
72977: DEC
72978: ST_TO_ADDR
72979: LD_EXP 68
72983: PUSH
72984: FOR_TO
72985: IFFALSE 73677
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72987: LD_EXP 68
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: NOT
72998: PUSH
72999: LD_EXP 92
73003: PUSH
73004: LD_VAR 0 2
73008: ARRAY
73009: NOT
73010: OR
73011: IFFALSE 73015
// continue ;
73013: GO 72984
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73015: LD_ADDR_VAR 0 5
73019: PUSH
73020: LD_EXP 68
73024: PUSH
73025: LD_VAR 0 2
73029: ARRAY
73030: PUSH
73031: LD_INT 1
73033: ARRAY
73034: PPUSH
73035: CALL_OW 255
73039: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73040: LD_ADDR_VAR 0 6
73044: PUSH
73045: LD_EXP 68
73049: PUSH
73050: LD_VAR 0 2
73054: ARRAY
73055: PPUSH
73056: LD_INT 30
73058: PUSH
73059: LD_INT 3
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PPUSH
73066: CALL_OW 72
73070: ST_TO_ADDR
// if not fac then
73071: LD_VAR 0 6
73075: NOT
73076: IFFALSE 73127
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73078: LD_ADDR_VAR 0 6
73082: PUSH
73083: LD_EXP 68
73087: PUSH
73088: LD_VAR 0 2
73092: ARRAY
73093: PPUSH
73094: LD_INT 2
73096: PUSH
73097: LD_INT 30
73099: PUSH
73100: LD_INT 0
73102: PUSH
73103: EMPTY
73104: LIST
73105: LIST
73106: PUSH
73107: LD_INT 30
73109: PUSH
73110: LD_INT 1
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: LIST
73121: PPUSH
73122: CALL_OW 72
73126: ST_TO_ADDR
// if not fac then
73127: LD_VAR 0 6
73131: NOT
73132: IFFALSE 73136
// continue ;
73134: GO 72984
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73136: LD_ADDR_VAR 0 7
73140: PUSH
73141: LD_EXP 92
73145: PUSH
73146: LD_VAR 0 2
73150: ARRAY
73151: PPUSH
73152: LD_INT 22
73154: PUSH
73155: LD_VAR 0 5
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 21
73166: PUSH
73167: LD_INT 2
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 3
73176: PUSH
73177: LD_INT 24
73179: PUSH
73180: LD_INT 1000
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: LIST
73195: PPUSH
73196: CALL_OW 70
73200: ST_TO_ADDR
// for j in fac do
73201: LD_ADDR_VAR 0 3
73205: PUSH
73206: LD_VAR 0 6
73210: PUSH
73211: FOR_IN
73212: IFFALSE 73293
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73214: LD_ADDR_VAR 0 7
73218: PUSH
73219: LD_VAR 0 7
73223: PUSH
73224: LD_INT 22
73226: PUSH
73227: LD_VAR 0 5
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: PUSH
73236: LD_INT 91
73238: PUSH
73239: LD_VAR 0 3
73243: PUSH
73244: LD_INT 15
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 21
73254: PUSH
73255: LD_INT 2
73257: PUSH
73258: EMPTY
73259: LIST
73260: LIST
73261: PUSH
73262: LD_INT 3
73264: PUSH
73265: LD_INT 24
73267: PUSH
73268: LD_INT 1000
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: PPUSH
73285: CALL_OW 69
73289: UNION
73290: ST_TO_ADDR
73291: GO 73211
73293: POP
73294: POP
// if not vehs then
73295: LD_VAR 0 7
73299: NOT
73300: IFFALSE 73326
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73302: LD_ADDR_EXP 80
73306: PUSH
73307: LD_EXP 80
73311: PPUSH
73312: LD_VAR 0 2
73316: PPUSH
73317: EMPTY
73318: PPUSH
73319: CALL_OW 1
73323: ST_TO_ADDR
// continue ;
73324: GO 72984
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73326: LD_ADDR_VAR 0 8
73330: PUSH
73331: LD_EXP 68
73335: PUSH
73336: LD_VAR 0 2
73340: ARRAY
73341: PPUSH
73342: LD_INT 30
73344: PUSH
73345: LD_INT 3
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PPUSH
73352: CALL_OW 72
73356: ST_TO_ADDR
// if tmp then
73357: LD_VAR 0 8
73361: IFFALSE 73464
// begin for j in tmp do
73363: LD_ADDR_VAR 0 3
73367: PUSH
73368: LD_VAR 0 8
73372: PUSH
73373: FOR_IN
73374: IFFALSE 73462
// for k in UnitsInside ( j ) do
73376: LD_ADDR_VAR 0 4
73380: PUSH
73381: LD_VAR 0 3
73385: PPUSH
73386: CALL_OW 313
73390: PUSH
73391: FOR_IN
73392: IFFALSE 73458
// if k then
73394: LD_VAR 0 4
73398: IFFALSE 73456
// if not k in mc_repair_vehicle [ i ] then
73400: LD_VAR 0 4
73404: PUSH
73405: LD_EXP 80
73409: PUSH
73410: LD_VAR 0 2
73414: ARRAY
73415: IN
73416: NOT
73417: IFFALSE 73456
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73419: LD_ADDR_EXP 80
73423: PUSH
73424: LD_EXP 80
73428: PPUSH
73429: LD_VAR 0 2
73433: PPUSH
73434: LD_EXP 80
73438: PUSH
73439: LD_VAR 0 2
73443: ARRAY
73444: PUSH
73445: LD_VAR 0 4
73449: UNION
73450: PPUSH
73451: CALL_OW 1
73455: ST_TO_ADDR
73456: GO 73391
73458: POP
73459: POP
73460: GO 73373
73462: POP
73463: POP
// end ; if not mc_repair_vehicle [ i ] then
73464: LD_EXP 80
73468: PUSH
73469: LD_VAR 0 2
73473: ARRAY
73474: NOT
73475: IFFALSE 73479
// continue ;
73477: GO 72984
// for j in mc_repair_vehicle [ i ] do
73479: LD_ADDR_VAR 0 3
73483: PUSH
73484: LD_EXP 80
73488: PUSH
73489: LD_VAR 0 2
73493: ARRAY
73494: PUSH
73495: FOR_IN
73496: IFFALSE 73673
// begin if GetClass ( j ) <> 3 then
73498: LD_VAR 0 3
73502: PPUSH
73503: CALL_OW 257
73507: PUSH
73508: LD_INT 3
73510: NONEQUAL
73511: IFFALSE 73552
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73513: LD_ADDR_EXP 80
73517: PUSH
73518: LD_EXP 80
73522: PPUSH
73523: LD_VAR 0 2
73527: PPUSH
73528: LD_EXP 80
73532: PUSH
73533: LD_VAR 0 2
73537: ARRAY
73538: PUSH
73539: LD_VAR 0 3
73543: DIFF
73544: PPUSH
73545: CALL_OW 1
73549: ST_TO_ADDR
// continue ;
73550: GO 73495
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73552: LD_VAR 0 3
73556: PPUSH
73557: CALL_OW 311
73561: NOT
73562: PUSH
73563: LD_VAR 0 3
73567: PUSH
73568: LD_EXP 71
73572: PUSH
73573: LD_VAR 0 2
73577: ARRAY
73578: PUSH
73579: LD_INT 1
73581: ARRAY
73582: IN
73583: NOT
73584: AND
73585: PUSH
73586: LD_VAR 0 3
73590: PUSH
73591: LD_EXP 71
73595: PUSH
73596: LD_VAR 0 2
73600: ARRAY
73601: PUSH
73602: LD_INT 2
73604: ARRAY
73605: IN
73606: NOT
73607: AND
73608: IFFALSE 73671
// begin if IsInUnit ( j ) then
73610: LD_VAR 0 3
73614: PPUSH
73615: CALL_OW 310
73619: IFFALSE 73632
// ComExitBuilding ( j ) else
73621: LD_VAR 0 3
73625: PPUSH
73626: CALL_OW 122
73630: GO 73671
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73632: LD_VAR 0 3
73636: PPUSH
73637: LD_VAR 0 7
73641: PUSH
73642: LD_INT 1
73644: ARRAY
73645: PPUSH
73646: CALL 53079 0 2
73650: NOT
73651: IFFALSE 73671
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73653: LD_VAR 0 3
73657: PPUSH
73658: LD_VAR 0 7
73662: PUSH
73663: LD_INT 1
73665: ARRAY
73666: PPUSH
73667: CALL_OW 129
// end ; end ;
73671: GO 73495
73673: POP
73674: POP
// end ;
73675: GO 72984
73677: POP
73678: POP
// end ;
73679: LD_VAR 0 1
73683: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73684: LD_INT 0
73686: PPUSH
73687: PPUSH
73688: PPUSH
73689: PPUSH
73690: PPUSH
73691: PPUSH
73692: PPUSH
73693: PPUSH
73694: PPUSH
73695: PPUSH
73696: PPUSH
// if not mc_bases then
73697: LD_EXP 68
73701: NOT
73702: IFFALSE 73706
// exit ;
73704: GO 74508
// for i = 1 to mc_bases do
73706: LD_ADDR_VAR 0 2
73710: PUSH
73711: DOUBLE
73712: LD_INT 1
73714: DEC
73715: ST_TO_ADDR
73716: LD_EXP 68
73720: PUSH
73721: FOR_TO
73722: IFFALSE 74506
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73724: LD_EXP 96
73728: PUSH
73729: LD_VAR 0 2
73733: ARRAY
73734: NOT
73735: PUSH
73736: LD_EXP 71
73740: PUSH
73741: LD_VAR 0 2
73745: ARRAY
73746: PUSH
73747: LD_INT 1
73749: ARRAY
73750: OR
73751: PUSH
73752: LD_EXP 71
73756: PUSH
73757: LD_VAR 0 2
73761: ARRAY
73762: PUSH
73763: LD_INT 2
73765: ARRAY
73766: OR
73767: PUSH
73768: LD_EXP 94
73772: PUSH
73773: LD_VAR 0 2
73777: ARRAY
73778: PPUSH
73779: LD_INT 1
73781: PPUSH
73782: CALL_OW 325
73786: NOT
73787: OR
73788: PUSH
73789: LD_EXP 91
73793: PUSH
73794: LD_VAR 0 2
73798: ARRAY
73799: OR
73800: IFFALSE 73804
// continue ;
73802: GO 73721
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73804: LD_ADDR_VAR 0 8
73808: PUSH
73809: LD_EXP 68
73813: PUSH
73814: LD_VAR 0 2
73818: ARRAY
73819: PPUSH
73820: LD_INT 25
73822: PUSH
73823: LD_INT 4
73825: PUSH
73826: EMPTY
73827: LIST
73828: LIST
73829: PUSH
73830: LD_INT 50
73832: PUSH
73833: EMPTY
73834: LIST
73835: PUSH
73836: LD_INT 3
73838: PUSH
73839: LD_INT 60
73841: PUSH
73842: EMPTY
73843: LIST
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: LIST
73853: PPUSH
73854: CALL_OW 72
73858: PUSH
73859: LD_EXP 72
73863: PUSH
73864: LD_VAR 0 2
73868: ARRAY
73869: DIFF
73870: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73871: LD_ADDR_VAR 0 9
73875: PUSH
73876: LD_EXP 68
73880: PUSH
73881: LD_VAR 0 2
73885: ARRAY
73886: PPUSH
73887: LD_INT 2
73889: PUSH
73890: LD_INT 30
73892: PUSH
73893: LD_INT 0
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 30
73902: PUSH
73903: LD_INT 1
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: LIST
73914: PPUSH
73915: CALL_OW 72
73919: ST_TO_ADDR
// if not tmp or not dep then
73920: LD_VAR 0 8
73924: NOT
73925: PUSH
73926: LD_VAR 0 9
73930: NOT
73931: OR
73932: IFFALSE 73936
// continue ;
73934: GO 73721
// side := GetSide ( tmp [ 1 ] ) ;
73936: LD_ADDR_VAR 0 11
73940: PUSH
73941: LD_VAR 0 8
73945: PUSH
73946: LD_INT 1
73948: ARRAY
73949: PPUSH
73950: CALL_OW 255
73954: ST_TO_ADDR
// dep := dep [ 1 ] ;
73955: LD_ADDR_VAR 0 9
73959: PUSH
73960: LD_VAR 0 9
73964: PUSH
73965: LD_INT 1
73967: ARRAY
73968: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73969: LD_ADDR_VAR 0 7
73973: PUSH
73974: LD_EXP 96
73978: PUSH
73979: LD_VAR 0 2
73983: ARRAY
73984: PPUSH
73985: LD_INT 22
73987: PUSH
73988: LD_INT 0
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 25
73997: PUSH
73998: LD_INT 12
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: PPUSH
74009: CALL_OW 70
74013: PUSH
74014: LD_INT 22
74016: PUSH
74017: LD_INT 0
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 25
74026: PUSH
74027: LD_INT 12
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 91
74036: PUSH
74037: LD_VAR 0 9
74041: PUSH
74042: LD_INT 20
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: LIST
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: LIST
74054: PPUSH
74055: CALL_OW 69
74059: UNION
74060: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74061: LD_ADDR_VAR 0 10
74065: PUSH
74066: LD_EXP 96
74070: PUSH
74071: LD_VAR 0 2
74075: ARRAY
74076: PPUSH
74077: LD_INT 81
74079: PUSH
74080: LD_VAR 0 11
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PPUSH
74089: CALL_OW 70
74093: ST_TO_ADDR
// if not apes or danger_at_area then
74094: LD_VAR 0 7
74098: NOT
74099: PUSH
74100: LD_VAR 0 10
74104: OR
74105: IFFALSE 74155
// begin if mc_taming [ i ] then
74107: LD_EXP 99
74111: PUSH
74112: LD_VAR 0 2
74116: ARRAY
74117: IFFALSE 74153
// begin MC_Reset ( i , 121 ) ;
74119: LD_VAR 0 2
74123: PPUSH
74124: LD_INT 121
74126: PPUSH
74127: CALL 59141 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74131: LD_ADDR_EXP 99
74135: PUSH
74136: LD_EXP 99
74140: PPUSH
74141: LD_VAR 0 2
74145: PPUSH
74146: EMPTY
74147: PPUSH
74148: CALL_OW 1
74152: ST_TO_ADDR
// end ; continue ;
74153: GO 73721
// end ; for j in tmp do
74155: LD_ADDR_VAR 0 3
74159: PUSH
74160: LD_VAR 0 8
74164: PUSH
74165: FOR_IN
74166: IFFALSE 74502
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74168: LD_VAR 0 3
74172: PUSH
74173: LD_EXP 99
74177: PUSH
74178: LD_VAR 0 2
74182: ARRAY
74183: IN
74184: NOT
74185: PUSH
74186: LD_EXP 99
74190: PUSH
74191: LD_VAR 0 2
74195: ARRAY
74196: PUSH
74197: LD_INT 3
74199: LESS
74200: AND
74201: IFFALSE 74259
// begin SetTag ( j , 121 ) ;
74203: LD_VAR 0 3
74207: PPUSH
74208: LD_INT 121
74210: PPUSH
74211: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74215: LD_ADDR_EXP 99
74219: PUSH
74220: LD_EXP 99
74224: PPUSH
74225: LD_VAR 0 2
74229: PUSH
74230: LD_EXP 99
74234: PUSH
74235: LD_VAR 0 2
74239: ARRAY
74240: PUSH
74241: LD_INT 1
74243: PLUS
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PPUSH
74249: LD_VAR 0 3
74253: PPUSH
74254: CALL 18750 0 3
74258: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74259: LD_VAR 0 3
74263: PUSH
74264: LD_EXP 99
74268: PUSH
74269: LD_VAR 0 2
74273: ARRAY
74274: IN
74275: IFFALSE 74500
// begin if GetClass ( j ) <> 4 then
74277: LD_VAR 0 3
74281: PPUSH
74282: CALL_OW 257
74286: PUSH
74287: LD_INT 4
74289: NONEQUAL
74290: IFFALSE 74343
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74292: LD_ADDR_EXP 99
74296: PUSH
74297: LD_EXP 99
74301: PPUSH
74302: LD_VAR 0 2
74306: PPUSH
74307: LD_EXP 99
74311: PUSH
74312: LD_VAR 0 2
74316: ARRAY
74317: PUSH
74318: LD_VAR 0 3
74322: DIFF
74323: PPUSH
74324: CALL_OW 1
74328: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74329: LD_VAR 0 3
74333: PPUSH
74334: LD_INT 0
74336: PPUSH
74337: CALL_OW 109
// continue ;
74341: GO 74165
// end ; if IsInUnit ( j ) then
74343: LD_VAR 0 3
74347: PPUSH
74348: CALL_OW 310
74352: IFFALSE 74363
// ComExitBuilding ( j ) ;
74354: LD_VAR 0 3
74358: PPUSH
74359: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74363: LD_ADDR_VAR 0 6
74367: PUSH
74368: LD_VAR 0 7
74372: PPUSH
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 74
74382: ST_TO_ADDR
// if not ape then
74383: LD_VAR 0 6
74387: NOT
74388: IFFALSE 74392
// break ;
74390: GO 74502
// x := GetX ( ape ) ;
74392: LD_ADDR_VAR 0 4
74396: PUSH
74397: LD_VAR 0 6
74401: PPUSH
74402: CALL_OW 250
74406: ST_TO_ADDR
// y := GetY ( ape ) ;
74407: LD_ADDR_VAR 0 5
74411: PUSH
74412: LD_VAR 0 6
74416: PPUSH
74417: CALL_OW 251
74421: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74422: LD_VAR 0 4
74426: PPUSH
74427: LD_VAR 0 5
74431: PPUSH
74432: CALL_OW 488
74436: NOT
74437: PUSH
74438: LD_VAR 0 11
74442: PPUSH
74443: LD_VAR 0 4
74447: PPUSH
74448: LD_VAR 0 5
74452: PPUSH
74453: LD_INT 20
74455: PPUSH
74456: CALL 19646 0 4
74460: PUSH
74461: LD_INT 4
74463: ARRAY
74464: OR
74465: IFFALSE 74469
// break ;
74467: GO 74502
// if not HasTask ( j ) then
74469: LD_VAR 0 3
74473: PPUSH
74474: CALL_OW 314
74478: NOT
74479: IFFALSE 74500
// ComTameXY ( j , x , y ) ;
74481: LD_VAR 0 3
74485: PPUSH
74486: LD_VAR 0 4
74490: PPUSH
74491: LD_VAR 0 5
74495: PPUSH
74496: CALL_OW 131
// end ; end ;
74500: GO 74165
74502: POP
74503: POP
// end ;
74504: GO 73721
74506: POP
74507: POP
// end ;
74508: LD_VAR 0 1
74512: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74513: LD_INT 0
74515: PPUSH
74516: PPUSH
74517: PPUSH
74518: PPUSH
74519: PPUSH
74520: PPUSH
74521: PPUSH
74522: PPUSH
// if not mc_bases then
74523: LD_EXP 68
74527: NOT
74528: IFFALSE 74532
// exit ;
74530: GO 75158
// for i = 1 to mc_bases do
74532: LD_ADDR_VAR 0 2
74536: PUSH
74537: DOUBLE
74538: LD_INT 1
74540: DEC
74541: ST_TO_ADDR
74542: LD_EXP 68
74546: PUSH
74547: FOR_TO
74548: IFFALSE 75156
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74550: LD_EXP 97
74554: PUSH
74555: LD_VAR 0 2
74559: ARRAY
74560: NOT
74561: PUSH
74562: LD_EXP 97
74566: PUSH
74567: LD_VAR 0 2
74571: ARRAY
74572: PPUSH
74573: LD_INT 25
74575: PUSH
74576: LD_INT 12
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PPUSH
74583: CALL_OW 72
74587: NOT
74588: OR
74589: IFFALSE 74593
// continue ;
74591: GO 74547
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74593: LD_ADDR_VAR 0 5
74597: PUSH
74598: LD_EXP 97
74602: PUSH
74603: LD_VAR 0 2
74607: ARRAY
74608: PUSH
74609: LD_INT 1
74611: ARRAY
74612: PPUSH
74613: CALL_OW 255
74617: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74618: LD_VAR 0 5
74622: PPUSH
74623: LD_INT 2
74625: PPUSH
74626: CALL_OW 325
74630: IFFALSE 74883
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74632: LD_ADDR_VAR 0 4
74636: PUSH
74637: LD_EXP 97
74641: PUSH
74642: LD_VAR 0 2
74646: ARRAY
74647: PPUSH
74648: LD_INT 25
74650: PUSH
74651: LD_INT 16
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: PPUSH
74658: CALL_OW 72
74662: ST_TO_ADDR
// if tmp < 6 then
74663: LD_VAR 0 4
74667: PUSH
74668: LD_INT 6
74670: LESS
74671: IFFALSE 74883
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74673: LD_ADDR_VAR 0 6
74677: PUSH
74678: LD_EXP 68
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: PPUSH
74689: LD_INT 2
74691: PUSH
74692: LD_INT 30
74694: PUSH
74695: LD_INT 0
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 30
74704: PUSH
74705: LD_INT 1
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: LIST
74716: PPUSH
74717: CALL_OW 72
74721: ST_TO_ADDR
// if depot then
74722: LD_VAR 0 6
74726: IFFALSE 74883
// begin selected := 0 ;
74728: LD_ADDR_VAR 0 7
74732: PUSH
74733: LD_INT 0
74735: ST_TO_ADDR
// for j in depot do
74736: LD_ADDR_VAR 0 3
74740: PUSH
74741: LD_VAR 0 6
74745: PUSH
74746: FOR_IN
74747: IFFALSE 74778
// begin if UnitsInside ( j ) < 6 then
74749: LD_VAR 0 3
74753: PPUSH
74754: CALL_OW 313
74758: PUSH
74759: LD_INT 6
74761: LESS
74762: IFFALSE 74776
// begin selected := j ;
74764: LD_ADDR_VAR 0 7
74768: PUSH
74769: LD_VAR 0 3
74773: ST_TO_ADDR
// break ;
74774: GO 74778
// end ; end ;
74776: GO 74746
74778: POP
74779: POP
// if selected then
74780: LD_VAR 0 7
74784: IFFALSE 74883
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74786: LD_ADDR_VAR 0 3
74790: PUSH
74791: LD_EXP 97
74795: PUSH
74796: LD_VAR 0 2
74800: ARRAY
74801: PPUSH
74802: LD_INT 25
74804: PUSH
74805: LD_INT 12
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PPUSH
74812: CALL_OW 72
74816: PUSH
74817: FOR_IN
74818: IFFALSE 74881
// if not HasTask ( j ) then
74820: LD_VAR 0 3
74824: PPUSH
74825: CALL_OW 314
74829: NOT
74830: IFFALSE 74879
// begin if not IsInUnit ( j ) then
74832: LD_VAR 0 3
74836: PPUSH
74837: CALL_OW 310
74841: NOT
74842: IFFALSE 74858
// ComEnterUnit ( j , selected ) ;
74844: LD_VAR 0 3
74848: PPUSH
74849: LD_VAR 0 7
74853: PPUSH
74854: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74858: LD_VAR 0 3
74862: PPUSH
74863: LD_INT 16
74865: PPUSH
74866: CALL_OW 183
// AddComExitBuilding ( j ) ;
74870: LD_VAR 0 3
74874: PPUSH
74875: CALL_OW 182
// end ;
74879: GO 74817
74881: POP
74882: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74883: LD_VAR 0 5
74887: PPUSH
74888: LD_INT 11
74890: PPUSH
74891: CALL_OW 325
74895: IFFALSE 75154
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74897: LD_ADDR_VAR 0 4
74901: PUSH
74902: LD_EXP 97
74906: PUSH
74907: LD_VAR 0 2
74911: ARRAY
74912: PPUSH
74913: LD_INT 25
74915: PUSH
74916: LD_INT 16
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PPUSH
74923: CALL_OW 72
74927: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74928: LD_VAR 0 4
74932: PUSH
74933: LD_INT 6
74935: GREATEREQUAL
74936: PUSH
74937: LD_VAR 0 5
74941: PPUSH
74942: LD_INT 2
74944: PPUSH
74945: CALL_OW 325
74949: NOT
74950: OR
74951: IFFALSE 75154
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74953: LD_ADDR_VAR 0 8
74957: PUSH
74958: LD_EXP 68
74962: PUSH
74963: LD_VAR 0 2
74967: ARRAY
74968: PPUSH
74969: LD_INT 2
74971: PUSH
74972: LD_INT 30
74974: PUSH
74975: LD_INT 4
74977: PUSH
74978: EMPTY
74979: LIST
74980: LIST
74981: PUSH
74982: LD_INT 30
74984: PUSH
74985: LD_INT 5
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: LIST
74996: PPUSH
74997: CALL_OW 72
75001: ST_TO_ADDR
// if barracks then
75002: LD_VAR 0 8
75006: IFFALSE 75154
// begin selected := 0 ;
75008: LD_ADDR_VAR 0 7
75012: PUSH
75013: LD_INT 0
75015: ST_TO_ADDR
// for j in barracks do
75016: LD_ADDR_VAR 0 3
75020: PUSH
75021: LD_VAR 0 8
75025: PUSH
75026: FOR_IN
75027: IFFALSE 75058
// begin if UnitsInside ( j ) < 6 then
75029: LD_VAR 0 3
75033: PPUSH
75034: CALL_OW 313
75038: PUSH
75039: LD_INT 6
75041: LESS
75042: IFFALSE 75056
// begin selected := j ;
75044: LD_ADDR_VAR 0 7
75048: PUSH
75049: LD_VAR 0 3
75053: ST_TO_ADDR
// break ;
75054: GO 75058
// end ; end ;
75056: GO 75026
75058: POP
75059: POP
// if selected then
75060: LD_VAR 0 7
75064: IFFALSE 75154
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75066: LD_ADDR_VAR 0 3
75070: PUSH
75071: LD_EXP 97
75075: PUSH
75076: LD_VAR 0 2
75080: ARRAY
75081: PPUSH
75082: LD_INT 25
75084: PUSH
75085: LD_INT 12
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PPUSH
75092: CALL_OW 72
75096: PUSH
75097: FOR_IN
75098: IFFALSE 75152
// if not IsInUnit ( j ) and not HasTask ( j ) then
75100: LD_VAR 0 3
75104: PPUSH
75105: CALL_OW 310
75109: NOT
75110: PUSH
75111: LD_VAR 0 3
75115: PPUSH
75116: CALL_OW 314
75120: NOT
75121: AND
75122: IFFALSE 75150
// begin ComEnterUnit ( j , selected ) ;
75124: LD_VAR 0 3
75128: PPUSH
75129: LD_VAR 0 7
75133: PPUSH
75134: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75138: LD_VAR 0 3
75142: PPUSH
75143: LD_INT 15
75145: PPUSH
75146: CALL_OW 183
// end ;
75150: GO 75097
75152: POP
75153: POP
// end ; end ; end ; end ; end ;
75154: GO 74547
75156: POP
75157: POP
// end ;
75158: LD_VAR 0 1
75162: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75163: LD_INT 0
75165: PPUSH
75166: PPUSH
75167: PPUSH
75168: PPUSH
// if not mc_bases then
75169: LD_EXP 68
75173: NOT
75174: IFFALSE 75178
// exit ;
75176: GO 75356
// for i = 1 to mc_bases do
75178: LD_ADDR_VAR 0 2
75182: PUSH
75183: DOUBLE
75184: LD_INT 1
75186: DEC
75187: ST_TO_ADDR
75188: LD_EXP 68
75192: PUSH
75193: FOR_TO
75194: IFFALSE 75354
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75196: LD_ADDR_VAR 0 4
75200: PUSH
75201: LD_EXP 68
75205: PUSH
75206: LD_VAR 0 2
75210: ARRAY
75211: PPUSH
75212: LD_INT 25
75214: PUSH
75215: LD_INT 9
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PPUSH
75222: CALL_OW 72
75226: ST_TO_ADDR
// if not tmp then
75227: LD_VAR 0 4
75231: NOT
75232: IFFALSE 75236
// continue ;
75234: GO 75193
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75236: LD_EXP 94
75240: PUSH
75241: LD_VAR 0 2
75245: ARRAY
75246: PPUSH
75247: LD_INT 29
75249: PPUSH
75250: CALL_OW 325
75254: NOT
75255: PUSH
75256: LD_EXP 94
75260: PUSH
75261: LD_VAR 0 2
75265: ARRAY
75266: PPUSH
75267: LD_INT 28
75269: PPUSH
75270: CALL_OW 325
75274: NOT
75275: AND
75276: IFFALSE 75280
// continue ;
75278: GO 75193
// for j in tmp do
75280: LD_ADDR_VAR 0 3
75284: PUSH
75285: LD_VAR 0 4
75289: PUSH
75290: FOR_IN
75291: IFFALSE 75350
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75293: LD_VAR 0 3
75297: PUSH
75298: LD_EXP 71
75302: PUSH
75303: LD_VAR 0 2
75307: ARRAY
75308: PUSH
75309: LD_INT 1
75311: ARRAY
75312: IN
75313: NOT
75314: PUSH
75315: LD_VAR 0 3
75319: PUSH
75320: LD_EXP 71
75324: PUSH
75325: LD_VAR 0 2
75329: ARRAY
75330: PUSH
75331: LD_INT 2
75333: ARRAY
75334: IN
75335: NOT
75336: AND
75337: IFFALSE 75348
// ComSpaceTimeShoot ( j ) ;
75339: LD_VAR 0 3
75343: PPUSH
75344: CALL 14558 0 1
75348: GO 75290
75350: POP
75351: POP
// end ;
75352: GO 75193
75354: POP
75355: POP
// end ;
75356: LD_VAR 0 1
75360: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75361: LD_INT 0
75363: PPUSH
75364: PPUSH
75365: PPUSH
75366: PPUSH
75367: PPUSH
75368: PPUSH
75369: PPUSH
75370: PPUSH
75371: PPUSH
// if not mc_bases then
75372: LD_EXP 68
75376: NOT
75377: IFFALSE 75381
// exit ;
75379: GO 76003
// for i = 1 to mc_bases do
75381: LD_ADDR_VAR 0 2
75385: PUSH
75386: DOUBLE
75387: LD_INT 1
75389: DEC
75390: ST_TO_ADDR
75391: LD_EXP 68
75395: PUSH
75396: FOR_TO
75397: IFFALSE 76001
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75399: LD_EXP 103
75403: PUSH
75404: LD_VAR 0 2
75408: ARRAY
75409: NOT
75410: PUSH
75411: LD_INT 38
75413: PPUSH
75414: LD_EXP 94
75418: PUSH
75419: LD_VAR 0 2
75423: ARRAY
75424: PPUSH
75425: CALL_OW 321
75429: PUSH
75430: LD_INT 2
75432: NONEQUAL
75433: OR
75434: IFFALSE 75438
// continue ;
75436: GO 75396
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75438: LD_ADDR_VAR 0 8
75442: PUSH
75443: LD_EXP 68
75447: PUSH
75448: LD_VAR 0 2
75452: ARRAY
75453: PPUSH
75454: LD_INT 30
75456: PUSH
75457: LD_INT 34
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PPUSH
75464: CALL_OW 72
75468: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75469: LD_ADDR_VAR 0 9
75473: PUSH
75474: LD_EXP 68
75478: PUSH
75479: LD_VAR 0 2
75483: ARRAY
75484: PPUSH
75485: LD_INT 25
75487: PUSH
75488: LD_INT 4
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PPUSH
75495: CALL_OW 72
75499: PPUSH
75500: LD_INT 0
75502: PPUSH
75503: CALL 48586 0 2
75507: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75508: LD_VAR 0 9
75512: NOT
75513: PUSH
75514: LD_VAR 0 8
75518: NOT
75519: OR
75520: PUSH
75521: LD_EXP 68
75525: PUSH
75526: LD_VAR 0 2
75530: ARRAY
75531: PPUSH
75532: LD_INT 124
75534: PPUSH
75535: CALL 48586 0 2
75539: OR
75540: IFFALSE 75544
// continue ;
75542: GO 75396
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75544: LD_EXP 104
75548: PUSH
75549: LD_VAR 0 2
75553: ARRAY
75554: PUSH
75555: LD_EXP 103
75559: PUSH
75560: LD_VAR 0 2
75564: ARRAY
75565: LESS
75566: PUSH
75567: LD_EXP 104
75571: PUSH
75572: LD_VAR 0 2
75576: ARRAY
75577: PUSH
75578: LD_VAR 0 8
75582: LESS
75583: AND
75584: IFFALSE 75999
// begin tmp := sci [ 1 ] ;
75586: LD_ADDR_VAR 0 7
75590: PUSH
75591: LD_VAR 0 9
75595: PUSH
75596: LD_INT 1
75598: ARRAY
75599: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75600: LD_VAR 0 7
75604: PPUSH
75605: LD_INT 124
75607: PPUSH
75608: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75612: LD_ADDR_VAR 0 3
75616: PUSH
75617: DOUBLE
75618: LD_EXP 103
75622: PUSH
75623: LD_VAR 0 2
75627: ARRAY
75628: INC
75629: ST_TO_ADDR
75630: LD_EXP 103
75634: PUSH
75635: LD_VAR 0 2
75639: ARRAY
75640: PUSH
75641: FOR_DOWNTO
75642: IFFALSE 75985
// begin if IsInUnit ( tmp ) then
75644: LD_VAR 0 7
75648: PPUSH
75649: CALL_OW 310
75653: IFFALSE 75664
// ComExitBuilding ( tmp ) ;
75655: LD_VAR 0 7
75659: PPUSH
75660: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75664: LD_INT 35
75666: PPUSH
75667: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75671: LD_VAR 0 7
75675: PPUSH
75676: CALL_OW 310
75680: NOT
75681: PUSH
75682: LD_VAR 0 7
75686: PPUSH
75687: CALL_OW 314
75691: NOT
75692: AND
75693: IFFALSE 75664
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75695: LD_ADDR_VAR 0 6
75699: PUSH
75700: LD_VAR 0 7
75704: PPUSH
75705: CALL_OW 250
75709: PUSH
75710: LD_VAR 0 7
75714: PPUSH
75715: CALL_OW 251
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75724: LD_INT 35
75726: PPUSH
75727: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75731: LD_ADDR_VAR 0 4
75735: PUSH
75736: LD_EXP 103
75740: PUSH
75741: LD_VAR 0 2
75745: ARRAY
75746: PUSH
75747: LD_VAR 0 3
75751: ARRAY
75752: PUSH
75753: LD_INT 1
75755: ARRAY
75756: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75757: LD_ADDR_VAR 0 5
75761: PUSH
75762: LD_EXP 103
75766: PUSH
75767: LD_VAR 0 2
75771: ARRAY
75772: PUSH
75773: LD_VAR 0 3
75777: ARRAY
75778: PUSH
75779: LD_INT 2
75781: ARRAY
75782: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75783: LD_VAR 0 7
75787: PPUSH
75788: LD_INT 10
75790: PPUSH
75791: CALL 21349 0 2
75795: PUSH
75796: LD_INT 4
75798: ARRAY
75799: IFFALSE 75837
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75801: LD_VAR 0 7
75805: PPUSH
75806: LD_VAR 0 6
75810: PUSH
75811: LD_INT 1
75813: ARRAY
75814: PPUSH
75815: LD_VAR 0 6
75819: PUSH
75820: LD_INT 2
75822: ARRAY
75823: PPUSH
75824: CALL_OW 111
// wait ( 0 0$10 ) ;
75828: LD_INT 350
75830: PPUSH
75831: CALL_OW 67
// end else
75835: GO 75863
// begin ComMoveXY ( tmp , x , y ) ;
75837: LD_VAR 0 7
75841: PPUSH
75842: LD_VAR 0 4
75846: PPUSH
75847: LD_VAR 0 5
75851: PPUSH
75852: CALL_OW 111
// wait ( 0 0$3 ) ;
75856: LD_INT 105
75858: PPUSH
75859: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75863: LD_VAR 0 7
75867: PPUSH
75868: LD_VAR 0 4
75872: PPUSH
75873: LD_VAR 0 5
75877: PPUSH
75878: CALL_OW 307
75882: IFFALSE 75724
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75884: LD_VAR 0 7
75888: PPUSH
75889: LD_VAR 0 4
75893: PPUSH
75894: LD_VAR 0 5
75898: PPUSH
75899: LD_VAR 0 8
75903: PUSH
75904: LD_VAR 0 3
75908: ARRAY
75909: PPUSH
75910: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75914: LD_INT 35
75916: PPUSH
75917: CALL_OW 67
// until not HasTask ( tmp ) ;
75921: LD_VAR 0 7
75925: PPUSH
75926: CALL_OW 314
75930: NOT
75931: IFFALSE 75914
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75933: LD_ADDR_EXP 104
75937: PUSH
75938: LD_EXP 104
75942: PPUSH
75943: LD_VAR 0 2
75947: PUSH
75948: LD_EXP 104
75952: PUSH
75953: LD_VAR 0 2
75957: ARRAY
75958: PUSH
75959: LD_INT 1
75961: PLUS
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PPUSH
75967: LD_VAR 0 8
75971: PUSH
75972: LD_VAR 0 3
75976: ARRAY
75977: PPUSH
75978: CALL 18750 0 3
75982: ST_TO_ADDR
// end ;
75983: GO 75641
75985: POP
75986: POP
// MC_Reset ( i , 124 ) ;
75987: LD_VAR 0 2
75991: PPUSH
75992: LD_INT 124
75994: PPUSH
75995: CALL 59141 0 2
// end ; end ;
75999: GO 75396
76001: POP
76002: POP
// end ;
76003: LD_VAR 0 1
76007: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76008: LD_INT 0
76010: PPUSH
76011: PPUSH
76012: PPUSH
// if not mc_bases then
76013: LD_EXP 68
76017: NOT
76018: IFFALSE 76022
// exit ;
76020: GO 76628
// for i = 1 to mc_bases do
76022: LD_ADDR_VAR 0 2
76026: PUSH
76027: DOUBLE
76028: LD_INT 1
76030: DEC
76031: ST_TO_ADDR
76032: LD_EXP 68
76036: PUSH
76037: FOR_TO
76038: IFFALSE 76626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76040: LD_ADDR_VAR 0 3
76044: PUSH
76045: LD_EXP 68
76049: PUSH
76050: LD_VAR 0 2
76054: ARRAY
76055: PPUSH
76056: LD_INT 25
76058: PUSH
76059: LD_INT 4
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: PPUSH
76066: CALL_OW 72
76070: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76071: LD_VAR 0 3
76075: NOT
76076: PUSH
76077: LD_EXP 105
76081: PUSH
76082: LD_VAR 0 2
76086: ARRAY
76087: NOT
76088: OR
76089: PUSH
76090: LD_EXP 68
76094: PUSH
76095: LD_VAR 0 2
76099: ARRAY
76100: PPUSH
76101: LD_INT 2
76103: PUSH
76104: LD_INT 30
76106: PUSH
76107: LD_INT 0
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 30
76116: PUSH
76117: LD_INT 1
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: LIST
76128: PPUSH
76129: CALL_OW 72
76133: NOT
76134: OR
76135: IFFALSE 76185
// begin if mc_deposits_finder [ i ] then
76137: LD_EXP 106
76141: PUSH
76142: LD_VAR 0 2
76146: ARRAY
76147: IFFALSE 76183
// begin MC_Reset ( i , 125 ) ;
76149: LD_VAR 0 2
76153: PPUSH
76154: LD_INT 125
76156: PPUSH
76157: CALL 59141 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76161: LD_ADDR_EXP 106
76165: PUSH
76166: LD_EXP 106
76170: PPUSH
76171: LD_VAR 0 2
76175: PPUSH
76176: EMPTY
76177: PPUSH
76178: CALL_OW 1
76182: ST_TO_ADDR
// end ; continue ;
76183: GO 76037
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76185: LD_EXP 105
76189: PUSH
76190: LD_VAR 0 2
76194: ARRAY
76195: PUSH
76196: LD_INT 1
76198: ARRAY
76199: PUSH
76200: LD_INT 3
76202: ARRAY
76203: PUSH
76204: LD_INT 1
76206: EQUAL
76207: PUSH
76208: LD_INT 20
76210: PPUSH
76211: LD_EXP 94
76215: PUSH
76216: LD_VAR 0 2
76220: ARRAY
76221: PPUSH
76222: CALL_OW 321
76226: PUSH
76227: LD_INT 2
76229: NONEQUAL
76230: AND
76231: IFFALSE 76281
// begin if mc_deposits_finder [ i ] then
76233: LD_EXP 106
76237: PUSH
76238: LD_VAR 0 2
76242: ARRAY
76243: IFFALSE 76279
// begin MC_Reset ( i , 125 ) ;
76245: LD_VAR 0 2
76249: PPUSH
76250: LD_INT 125
76252: PPUSH
76253: CALL 59141 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76257: LD_ADDR_EXP 106
76261: PUSH
76262: LD_EXP 106
76266: PPUSH
76267: LD_VAR 0 2
76271: PPUSH
76272: EMPTY
76273: PPUSH
76274: CALL_OW 1
76278: ST_TO_ADDR
// end ; continue ;
76279: GO 76037
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76281: LD_EXP 105
76285: PUSH
76286: LD_VAR 0 2
76290: ARRAY
76291: PUSH
76292: LD_INT 1
76294: ARRAY
76295: PUSH
76296: LD_INT 1
76298: ARRAY
76299: PPUSH
76300: LD_EXP 105
76304: PUSH
76305: LD_VAR 0 2
76309: ARRAY
76310: PUSH
76311: LD_INT 1
76313: ARRAY
76314: PUSH
76315: LD_INT 2
76317: ARRAY
76318: PPUSH
76319: LD_EXP 94
76323: PUSH
76324: LD_VAR 0 2
76328: ARRAY
76329: PPUSH
76330: CALL_OW 440
76334: IFFALSE 76377
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76336: LD_ADDR_EXP 105
76340: PUSH
76341: LD_EXP 105
76345: PPUSH
76346: LD_VAR 0 2
76350: PPUSH
76351: LD_EXP 105
76355: PUSH
76356: LD_VAR 0 2
76360: ARRAY
76361: PPUSH
76362: LD_INT 1
76364: PPUSH
76365: CALL_OW 3
76369: PPUSH
76370: CALL_OW 1
76374: ST_TO_ADDR
76375: GO 76624
// begin if not mc_deposits_finder [ i ] then
76377: LD_EXP 106
76381: PUSH
76382: LD_VAR 0 2
76386: ARRAY
76387: NOT
76388: IFFALSE 76440
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76390: LD_ADDR_EXP 106
76394: PUSH
76395: LD_EXP 106
76399: PPUSH
76400: LD_VAR 0 2
76404: PPUSH
76405: LD_VAR 0 3
76409: PUSH
76410: LD_INT 1
76412: ARRAY
76413: PUSH
76414: EMPTY
76415: LIST
76416: PPUSH
76417: CALL_OW 1
76421: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76422: LD_VAR 0 3
76426: PUSH
76427: LD_INT 1
76429: ARRAY
76430: PPUSH
76431: LD_INT 125
76433: PPUSH
76434: CALL_OW 109
// end else
76438: GO 76624
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76440: LD_EXP 106
76444: PUSH
76445: LD_VAR 0 2
76449: ARRAY
76450: PUSH
76451: LD_INT 1
76453: ARRAY
76454: PPUSH
76455: CALL_OW 310
76459: IFFALSE 76482
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76461: LD_EXP 106
76465: PUSH
76466: LD_VAR 0 2
76470: ARRAY
76471: PUSH
76472: LD_INT 1
76474: ARRAY
76475: PPUSH
76476: CALL_OW 122
76480: GO 76624
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76482: LD_EXP 106
76486: PUSH
76487: LD_VAR 0 2
76491: ARRAY
76492: PUSH
76493: LD_INT 1
76495: ARRAY
76496: PPUSH
76497: CALL_OW 314
76501: NOT
76502: PUSH
76503: LD_EXP 106
76507: PUSH
76508: LD_VAR 0 2
76512: ARRAY
76513: PUSH
76514: LD_INT 1
76516: ARRAY
76517: PPUSH
76518: LD_EXP 105
76522: PUSH
76523: LD_VAR 0 2
76527: ARRAY
76528: PUSH
76529: LD_INT 1
76531: ARRAY
76532: PUSH
76533: LD_INT 1
76535: ARRAY
76536: PPUSH
76537: LD_EXP 105
76541: PUSH
76542: LD_VAR 0 2
76546: ARRAY
76547: PUSH
76548: LD_INT 1
76550: ARRAY
76551: PUSH
76552: LD_INT 2
76554: ARRAY
76555: PPUSH
76556: CALL_OW 297
76560: PUSH
76561: LD_INT 6
76563: GREATER
76564: AND
76565: IFFALSE 76624
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76567: LD_EXP 106
76571: PUSH
76572: LD_VAR 0 2
76576: ARRAY
76577: PUSH
76578: LD_INT 1
76580: ARRAY
76581: PPUSH
76582: LD_EXP 105
76586: PUSH
76587: LD_VAR 0 2
76591: ARRAY
76592: PUSH
76593: LD_INT 1
76595: ARRAY
76596: PUSH
76597: LD_INT 1
76599: ARRAY
76600: PPUSH
76601: LD_EXP 105
76605: PUSH
76606: LD_VAR 0 2
76610: ARRAY
76611: PUSH
76612: LD_INT 1
76614: ARRAY
76615: PUSH
76616: LD_INT 2
76618: ARRAY
76619: PPUSH
76620: CALL_OW 111
// end ; end ; end ;
76624: GO 76037
76626: POP
76627: POP
// end ;
76628: LD_VAR 0 1
76632: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76633: LD_INT 0
76635: PPUSH
76636: PPUSH
76637: PPUSH
76638: PPUSH
76639: PPUSH
76640: PPUSH
76641: PPUSH
76642: PPUSH
76643: PPUSH
76644: PPUSH
76645: PPUSH
// if not mc_bases then
76646: LD_EXP 68
76650: NOT
76651: IFFALSE 76655
// exit ;
76653: GO 77595
// for i = 1 to mc_bases do
76655: LD_ADDR_VAR 0 2
76659: PUSH
76660: DOUBLE
76661: LD_INT 1
76663: DEC
76664: ST_TO_ADDR
76665: LD_EXP 68
76669: PUSH
76670: FOR_TO
76671: IFFALSE 77593
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76673: LD_EXP 68
76677: PUSH
76678: LD_VAR 0 2
76682: ARRAY
76683: NOT
76684: PUSH
76685: LD_EXP 91
76689: PUSH
76690: LD_VAR 0 2
76694: ARRAY
76695: OR
76696: IFFALSE 76700
// continue ;
76698: GO 76670
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76700: LD_ADDR_VAR 0 7
76704: PUSH
76705: LD_EXP 68
76709: PUSH
76710: LD_VAR 0 2
76714: ARRAY
76715: PUSH
76716: LD_INT 1
76718: ARRAY
76719: PPUSH
76720: CALL_OW 248
76724: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76725: LD_VAR 0 7
76729: PUSH
76730: LD_INT 3
76732: EQUAL
76733: PUSH
76734: LD_EXP 87
76738: PUSH
76739: LD_VAR 0 2
76743: ARRAY
76744: PUSH
76745: LD_EXP 90
76749: PUSH
76750: LD_VAR 0 2
76754: ARRAY
76755: UNION
76756: PPUSH
76757: LD_INT 33
76759: PUSH
76760: LD_INT 2
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PPUSH
76767: CALL_OW 72
76771: NOT
76772: OR
76773: IFFALSE 76777
// continue ;
76775: GO 76670
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76777: LD_ADDR_VAR 0 9
76781: PUSH
76782: LD_EXP 68
76786: PUSH
76787: LD_VAR 0 2
76791: ARRAY
76792: PPUSH
76793: LD_INT 30
76795: PUSH
76796: LD_INT 36
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PPUSH
76803: CALL_OW 72
76807: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76808: LD_ADDR_VAR 0 10
76812: PUSH
76813: LD_EXP 87
76817: PUSH
76818: LD_VAR 0 2
76822: ARRAY
76823: PPUSH
76824: LD_INT 34
76826: PUSH
76827: LD_INT 31
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PPUSH
76834: CALL_OW 72
76838: ST_TO_ADDR
// if not cts and not mcts then
76839: LD_VAR 0 9
76843: NOT
76844: PUSH
76845: LD_VAR 0 10
76849: NOT
76850: AND
76851: IFFALSE 76855
// continue ;
76853: GO 76670
// x := cts ;
76855: LD_ADDR_VAR 0 11
76859: PUSH
76860: LD_VAR 0 9
76864: ST_TO_ADDR
// if not x then
76865: LD_VAR 0 11
76869: NOT
76870: IFFALSE 76882
// x := mcts ;
76872: LD_ADDR_VAR 0 11
76876: PUSH
76877: LD_VAR 0 10
76881: ST_TO_ADDR
// if not x then
76882: LD_VAR 0 11
76886: NOT
76887: IFFALSE 76891
// continue ;
76889: GO 76670
// if mc_remote_driver [ i ] then
76891: LD_EXP 108
76895: PUSH
76896: LD_VAR 0 2
76900: ARRAY
76901: IFFALSE 77288
// for j in mc_remote_driver [ i ] do
76903: LD_ADDR_VAR 0 3
76907: PUSH
76908: LD_EXP 108
76912: PUSH
76913: LD_VAR 0 2
76917: ARRAY
76918: PUSH
76919: FOR_IN
76920: IFFALSE 77286
// begin if GetClass ( j ) <> 3 then
76922: LD_VAR 0 3
76926: PPUSH
76927: CALL_OW 257
76931: PUSH
76932: LD_INT 3
76934: NONEQUAL
76935: IFFALSE 76988
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76937: LD_ADDR_EXP 108
76941: PUSH
76942: LD_EXP 108
76946: PPUSH
76947: LD_VAR 0 2
76951: PPUSH
76952: LD_EXP 108
76956: PUSH
76957: LD_VAR 0 2
76961: ARRAY
76962: PUSH
76963: LD_VAR 0 3
76967: DIFF
76968: PPUSH
76969: CALL_OW 1
76973: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76974: LD_VAR 0 3
76978: PPUSH
76979: LD_INT 0
76981: PPUSH
76982: CALL_OW 109
// continue ;
76986: GO 76919
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76988: LD_EXP 87
76992: PUSH
76993: LD_VAR 0 2
76997: ARRAY
76998: PPUSH
76999: LD_INT 34
77001: PUSH
77002: LD_INT 31
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 58
77011: PUSH
77012: EMPTY
77013: LIST
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PPUSH
77019: CALL_OW 72
77023: PUSH
77024: LD_VAR 0 3
77028: PPUSH
77029: CALL 48621 0 1
77033: NOT
77034: AND
77035: IFFALSE 77106
// begin if IsInUnit ( j ) then
77037: LD_VAR 0 3
77041: PPUSH
77042: CALL_OW 310
77046: IFFALSE 77057
// ComExitBuilding ( j ) ;
77048: LD_VAR 0 3
77052: PPUSH
77053: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77057: LD_VAR 0 3
77061: PPUSH
77062: LD_EXP 87
77066: PUSH
77067: LD_VAR 0 2
77071: ARRAY
77072: PPUSH
77073: LD_INT 34
77075: PUSH
77076: LD_INT 31
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 58
77085: PUSH
77086: EMPTY
77087: LIST
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PPUSH
77093: CALL_OW 72
77097: PUSH
77098: LD_INT 1
77100: ARRAY
77101: PPUSH
77102: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77106: LD_VAR 0 3
77110: PPUSH
77111: CALL_OW 310
77115: NOT
77116: PUSH
77117: LD_VAR 0 3
77121: PPUSH
77122: CALL_OW 310
77126: PPUSH
77127: CALL_OW 266
77131: PUSH
77132: LD_INT 36
77134: NONEQUAL
77135: PUSH
77136: LD_VAR 0 3
77140: PPUSH
77141: CALL 48621 0 1
77145: NOT
77146: AND
77147: OR
77148: IFFALSE 77284
// begin if IsInUnit ( j ) then
77150: LD_VAR 0 3
77154: PPUSH
77155: CALL_OW 310
77159: IFFALSE 77170
// ComExitBuilding ( j ) ;
77161: LD_VAR 0 3
77165: PPUSH
77166: CALL_OW 122
// ct := 0 ;
77170: LD_ADDR_VAR 0 8
77174: PUSH
77175: LD_INT 0
77177: ST_TO_ADDR
// for k in x do
77178: LD_ADDR_VAR 0 4
77182: PUSH
77183: LD_VAR 0 11
77187: PUSH
77188: FOR_IN
77189: IFFALSE 77262
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77191: LD_VAR 0 4
77195: PPUSH
77196: CALL_OW 264
77200: PUSH
77201: LD_INT 31
77203: EQUAL
77204: PUSH
77205: LD_VAR 0 4
77209: PPUSH
77210: CALL_OW 311
77214: NOT
77215: AND
77216: PUSH
77217: LD_VAR 0 4
77221: PPUSH
77222: CALL_OW 266
77226: PUSH
77227: LD_INT 36
77229: EQUAL
77230: PUSH
77231: LD_VAR 0 4
77235: PPUSH
77236: CALL_OW 313
77240: PUSH
77241: LD_INT 3
77243: LESS
77244: AND
77245: OR
77246: IFFALSE 77260
// begin ct := k ;
77248: LD_ADDR_VAR 0 8
77252: PUSH
77253: LD_VAR 0 4
77257: ST_TO_ADDR
// break ;
77258: GO 77262
// end ;
77260: GO 77188
77262: POP
77263: POP
// if ct then
77264: LD_VAR 0 8
77268: IFFALSE 77284
// ComEnterUnit ( j , ct ) ;
77270: LD_VAR 0 3
77274: PPUSH
77275: LD_VAR 0 8
77279: PPUSH
77280: CALL_OW 120
// end ; end ;
77284: GO 76919
77286: POP
77287: POP
// places := 0 ;
77288: LD_ADDR_VAR 0 5
77292: PUSH
77293: LD_INT 0
77295: ST_TO_ADDR
// for j = 1 to x do
77296: LD_ADDR_VAR 0 3
77300: PUSH
77301: DOUBLE
77302: LD_INT 1
77304: DEC
77305: ST_TO_ADDR
77306: LD_VAR 0 11
77310: PUSH
77311: FOR_TO
77312: IFFALSE 77388
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77314: LD_VAR 0 11
77318: PUSH
77319: LD_VAR 0 3
77323: ARRAY
77324: PPUSH
77325: CALL_OW 264
77329: PUSH
77330: LD_INT 31
77332: EQUAL
77333: IFFALSE 77351
// places := places + 1 else
77335: LD_ADDR_VAR 0 5
77339: PUSH
77340: LD_VAR 0 5
77344: PUSH
77345: LD_INT 1
77347: PLUS
77348: ST_TO_ADDR
77349: GO 77386
// if GetBType ( x [ j ] ) = b_control_tower then
77351: LD_VAR 0 11
77355: PUSH
77356: LD_VAR 0 3
77360: ARRAY
77361: PPUSH
77362: CALL_OW 266
77366: PUSH
77367: LD_INT 36
77369: EQUAL
77370: IFFALSE 77386
// places := places + 3 ;
77372: LD_ADDR_VAR 0 5
77376: PUSH
77377: LD_VAR 0 5
77381: PUSH
77382: LD_INT 3
77384: PLUS
77385: ST_TO_ADDR
77386: GO 77311
77388: POP
77389: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77390: LD_VAR 0 5
77394: PUSH
77395: LD_INT 0
77397: EQUAL
77398: PUSH
77399: LD_VAR 0 5
77403: PUSH
77404: LD_EXP 108
77408: PUSH
77409: LD_VAR 0 2
77413: ARRAY
77414: LESSEQUAL
77415: OR
77416: IFFALSE 77420
// continue ;
77418: GO 76670
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77420: LD_ADDR_VAR 0 6
77424: PUSH
77425: LD_EXP 68
77429: PUSH
77430: LD_VAR 0 2
77434: ARRAY
77435: PPUSH
77436: LD_INT 25
77438: PUSH
77439: LD_INT 3
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PPUSH
77446: CALL_OW 72
77450: PUSH
77451: LD_EXP 108
77455: PUSH
77456: LD_VAR 0 2
77460: ARRAY
77461: DIFF
77462: PPUSH
77463: LD_INT 3
77465: PPUSH
77466: CALL 49521 0 2
77470: ST_TO_ADDR
// for j in tmp do
77471: LD_ADDR_VAR 0 3
77475: PUSH
77476: LD_VAR 0 6
77480: PUSH
77481: FOR_IN
77482: IFFALSE 77517
// if GetTag ( j ) > 0 then
77484: LD_VAR 0 3
77488: PPUSH
77489: CALL_OW 110
77493: PUSH
77494: LD_INT 0
77496: GREATER
77497: IFFALSE 77515
// tmp := tmp diff j ;
77499: LD_ADDR_VAR 0 6
77503: PUSH
77504: LD_VAR 0 6
77508: PUSH
77509: LD_VAR 0 3
77513: DIFF
77514: ST_TO_ADDR
77515: GO 77481
77517: POP
77518: POP
// if not tmp then
77519: LD_VAR 0 6
77523: NOT
77524: IFFALSE 77528
// continue ;
77526: GO 76670
// if places then
77528: LD_VAR 0 5
77532: IFFALSE 77591
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77534: LD_ADDR_EXP 108
77538: PUSH
77539: LD_EXP 108
77543: PPUSH
77544: LD_VAR 0 2
77548: PPUSH
77549: LD_EXP 108
77553: PUSH
77554: LD_VAR 0 2
77558: ARRAY
77559: PUSH
77560: LD_VAR 0 6
77564: PUSH
77565: LD_INT 1
77567: ARRAY
77568: UNION
77569: PPUSH
77570: CALL_OW 1
77574: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77575: LD_VAR 0 6
77579: PUSH
77580: LD_INT 1
77582: ARRAY
77583: PPUSH
77584: LD_INT 126
77586: PPUSH
77587: CALL_OW 109
// end ; end ;
77591: GO 76670
77593: POP
77594: POP
// end ;
77595: LD_VAR 0 1
77599: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77600: LD_INT 0
77602: PPUSH
77603: PPUSH
77604: PPUSH
77605: PPUSH
77606: PPUSH
77607: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77608: LD_VAR 0 1
77612: NOT
77613: PUSH
77614: LD_VAR 0 2
77618: NOT
77619: OR
77620: PUSH
77621: LD_VAR 0 3
77625: NOT
77626: OR
77627: PUSH
77628: LD_VAR 0 4
77632: PUSH
77633: LD_INT 1
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: LD_INT 3
77641: PUSH
77642: LD_INT 4
77644: PUSH
77645: LD_INT 5
77647: PUSH
77648: LD_INT 8
77650: PUSH
77651: LD_INT 9
77653: PUSH
77654: LD_INT 15
77656: PUSH
77657: LD_INT 16
77659: PUSH
77660: EMPTY
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: IN
77671: NOT
77672: OR
77673: IFFALSE 77677
// exit ;
77675: GO 78577
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77677: LD_ADDR_VAR 0 2
77681: PUSH
77682: LD_VAR 0 2
77686: PPUSH
77687: LD_INT 21
77689: PUSH
77690: LD_INT 3
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 24
77699: PUSH
77700: LD_INT 250
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PPUSH
77711: CALL_OW 72
77715: ST_TO_ADDR
// case class of 1 , 15 :
77716: LD_VAR 0 4
77720: PUSH
77721: LD_INT 1
77723: DOUBLE
77724: EQUAL
77725: IFTRUE 77735
77727: LD_INT 15
77729: DOUBLE
77730: EQUAL
77731: IFTRUE 77735
77733: GO 77820
77735: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77736: LD_ADDR_VAR 0 8
77740: PUSH
77741: LD_VAR 0 2
77745: PPUSH
77746: LD_INT 2
77748: PUSH
77749: LD_INT 30
77751: PUSH
77752: LD_INT 32
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 30
77761: PUSH
77762: LD_INT 31
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: LIST
77773: PPUSH
77774: CALL_OW 72
77778: PUSH
77779: LD_VAR 0 2
77783: PPUSH
77784: LD_INT 2
77786: PUSH
77787: LD_INT 30
77789: PUSH
77790: LD_INT 4
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 30
77799: PUSH
77800: LD_INT 5
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: LIST
77811: PPUSH
77812: CALL_OW 72
77816: ADD
77817: ST_TO_ADDR
77818: GO 78066
77820: LD_INT 2
77822: DOUBLE
77823: EQUAL
77824: IFTRUE 77834
77826: LD_INT 16
77828: DOUBLE
77829: EQUAL
77830: IFTRUE 77834
77832: GO 77880
77834: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77835: LD_ADDR_VAR 0 8
77839: PUSH
77840: LD_VAR 0 2
77844: PPUSH
77845: LD_INT 2
77847: PUSH
77848: LD_INT 30
77850: PUSH
77851: LD_INT 0
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 30
77860: PUSH
77861: LD_INT 1
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: LIST
77872: PPUSH
77873: CALL_OW 72
77877: ST_TO_ADDR
77878: GO 78066
77880: LD_INT 3
77882: DOUBLE
77883: EQUAL
77884: IFTRUE 77888
77886: GO 77934
77888: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77889: LD_ADDR_VAR 0 8
77893: PUSH
77894: LD_VAR 0 2
77898: PPUSH
77899: LD_INT 2
77901: PUSH
77902: LD_INT 30
77904: PUSH
77905: LD_INT 2
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: LD_INT 30
77914: PUSH
77915: LD_INT 3
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: EMPTY
77923: LIST
77924: LIST
77925: LIST
77926: PPUSH
77927: CALL_OW 72
77931: ST_TO_ADDR
77932: GO 78066
77934: LD_INT 4
77936: DOUBLE
77937: EQUAL
77938: IFTRUE 77942
77940: GO 77999
77942: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77943: LD_ADDR_VAR 0 8
77947: PUSH
77948: LD_VAR 0 2
77952: PPUSH
77953: LD_INT 2
77955: PUSH
77956: LD_INT 30
77958: PUSH
77959: LD_INT 6
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 30
77968: PUSH
77969: LD_INT 7
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 30
77978: PUSH
77979: LD_INT 8
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: PPUSH
77992: CALL_OW 72
77996: ST_TO_ADDR
77997: GO 78066
77999: LD_INT 5
78001: DOUBLE
78002: EQUAL
78003: IFTRUE 78019
78005: LD_INT 8
78007: DOUBLE
78008: EQUAL
78009: IFTRUE 78019
78011: LD_INT 9
78013: DOUBLE
78014: EQUAL
78015: IFTRUE 78019
78017: GO 78065
78019: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78020: LD_ADDR_VAR 0 8
78024: PUSH
78025: LD_VAR 0 2
78029: PPUSH
78030: LD_INT 2
78032: PUSH
78033: LD_INT 30
78035: PUSH
78036: LD_INT 4
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: LD_INT 30
78045: PUSH
78046: LD_INT 5
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: LIST
78057: PPUSH
78058: CALL_OW 72
78062: ST_TO_ADDR
78063: GO 78066
78065: POP
// if not tmp then
78066: LD_VAR 0 8
78070: NOT
78071: IFFALSE 78075
// exit ;
78073: GO 78577
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78075: LD_VAR 0 4
78079: PUSH
78080: LD_INT 1
78082: PUSH
78083: LD_INT 15
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: IN
78090: PUSH
78091: LD_EXP 77
78095: PUSH
78096: LD_VAR 0 1
78100: ARRAY
78101: AND
78102: IFFALSE 78258
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78104: LD_ADDR_VAR 0 9
78108: PUSH
78109: LD_EXP 77
78113: PUSH
78114: LD_VAR 0 1
78118: ARRAY
78119: PUSH
78120: LD_INT 1
78122: ARRAY
78123: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78124: LD_VAR 0 9
78128: PUSH
78129: LD_EXP 78
78133: PUSH
78134: LD_VAR 0 1
78138: ARRAY
78139: IN
78140: NOT
78141: IFFALSE 78256
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78143: LD_ADDR_EXP 78
78147: PUSH
78148: LD_EXP 78
78152: PPUSH
78153: LD_VAR 0 1
78157: PUSH
78158: LD_EXP 78
78162: PUSH
78163: LD_VAR 0 1
78167: ARRAY
78168: PUSH
78169: LD_INT 1
78171: PLUS
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PPUSH
78177: LD_VAR 0 9
78181: PPUSH
78182: CALL 18750 0 3
78186: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78187: LD_ADDR_EXP 77
78191: PUSH
78192: LD_EXP 77
78196: PPUSH
78197: LD_VAR 0 1
78201: PPUSH
78202: LD_EXP 77
78206: PUSH
78207: LD_VAR 0 1
78211: ARRAY
78212: PUSH
78213: LD_VAR 0 9
78217: DIFF
78218: PPUSH
78219: CALL_OW 1
78223: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78224: LD_VAR 0 3
78228: PPUSH
78229: LD_EXP 78
78233: PUSH
78234: LD_VAR 0 1
78238: ARRAY
78239: PUSH
78240: LD_EXP 78
78244: PUSH
78245: LD_VAR 0 1
78249: ARRAY
78250: ARRAY
78251: PPUSH
78252: CALL_OW 120
// end ; exit ;
78256: GO 78577
// end ; if tmp > 1 then
78258: LD_VAR 0 8
78262: PUSH
78263: LD_INT 1
78265: GREATER
78266: IFFALSE 78370
// for i = 2 to tmp do
78268: LD_ADDR_VAR 0 6
78272: PUSH
78273: DOUBLE
78274: LD_INT 2
78276: DEC
78277: ST_TO_ADDR
78278: LD_VAR 0 8
78282: PUSH
78283: FOR_TO
78284: IFFALSE 78368
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78286: LD_VAR 0 8
78290: PUSH
78291: LD_VAR 0 6
78295: ARRAY
78296: PPUSH
78297: CALL_OW 461
78301: PUSH
78302: LD_INT 6
78304: EQUAL
78305: IFFALSE 78366
// begin x := tmp [ i ] ;
78307: LD_ADDR_VAR 0 9
78311: PUSH
78312: LD_VAR 0 8
78316: PUSH
78317: LD_VAR 0 6
78321: ARRAY
78322: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78323: LD_ADDR_VAR 0 8
78327: PUSH
78328: LD_VAR 0 8
78332: PPUSH
78333: LD_VAR 0 6
78337: PPUSH
78338: CALL_OW 3
78342: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78343: LD_ADDR_VAR 0 8
78347: PUSH
78348: LD_VAR 0 8
78352: PPUSH
78353: LD_INT 1
78355: PPUSH
78356: LD_VAR 0 9
78360: PPUSH
78361: CALL_OW 2
78365: ST_TO_ADDR
// end ;
78366: GO 78283
78368: POP
78369: POP
// for i in tmp do
78370: LD_ADDR_VAR 0 6
78374: PUSH
78375: LD_VAR 0 8
78379: PUSH
78380: FOR_IN
78381: IFFALSE 78450
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78383: LD_VAR 0 6
78387: PPUSH
78388: CALL_OW 313
78392: PUSH
78393: LD_INT 6
78395: LESS
78396: PUSH
78397: LD_VAR 0 6
78401: PPUSH
78402: CALL_OW 266
78406: PUSH
78407: LD_INT 31
78409: PUSH
78410: LD_INT 32
78412: PUSH
78413: EMPTY
78414: LIST
78415: LIST
78416: IN
78417: NOT
78418: AND
78419: PUSH
78420: LD_VAR 0 6
78424: PPUSH
78425: CALL_OW 313
78429: PUSH
78430: LD_INT 0
78432: EQUAL
78433: OR
78434: IFFALSE 78448
// begin j := i ;
78436: LD_ADDR_VAR 0 7
78440: PUSH
78441: LD_VAR 0 6
78445: ST_TO_ADDR
// break ;
78446: GO 78450
// end ; end ;
78448: GO 78380
78450: POP
78451: POP
// if j then
78452: LD_VAR 0 7
78456: IFFALSE 78474
// ComEnterUnit ( unit , j ) else
78458: LD_VAR 0 3
78462: PPUSH
78463: LD_VAR 0 7
78467: PPUSH
78468: CALL_OW 120
78472: GO 78577
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78474: LD_ADDR_VAR 0 10
78478: PUSH
78479: LD_VAR 0 2
78483: PPUSH
78484: LD_INT 2
78486: PUSH
78487: LD_INT 30
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 30
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: LIST
78511: PPUSH
78512: CALL_OW 72
78516: ST_TO_ADDR
// if depot then
78517: LD_VAR 0 10
78521: IFFALSE 78577
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78523: LD_ADDR_VAR 0 10
78527: PUSH
78528: LD_VAR 0 10
78532: PPUSH
78533: LD_VAR 0 3
78537: PPUSH
78538: CALL_OW 74
78542: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78543: LD_VAR 0 3
78547: PPUSH
78548: LD_VAR 0 10
78552: PPUSH
78553: CALL_OW 296
78557: PUSH
78558: LD_INT 10
78560: GREATER
78561: IFFALSE 78577
// ComStandNearbyBuilding ( unit , depot ) ;
78563: LD_VAR 0 3
78567: PPUSH
78568: LD_VAR 0 10
78572: PPUSH
78573: CALL 15175 0 2
// end ; end ; end ;
78577: LD_VAR 0 5
78581: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78582: LD_INT 0
78584: PPUSH
78585: PPUSH
78586: PPUSH
78587: PPUSH
// if not mc_bases then
78588: LD_EXP 68
78592: NOT
78593: IFFALSE 78597
// exit ;
78595: GO 78836
// for i = 1 to mc_bases do
78597: LD_ADDR_VAR 0 2
78601: PUSH
78602: DOUBLE
78603: LD_INT 1
78605: DEC
78606: ST_TO_ADDR
78607: LD_EXP 68
78611: PUSH
78612: FOR_TO
78613: IFFALSE 78834
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78615: LD_ADDR_VAR 0 4
78619: PUSH
78620: LD_EXP 68
78624: PUSH
78625: LD_VAR 0 2
78629: ARRAY
78630: PPUSH
78631: LD_INT 21
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PPUSH
78641: CALL_OW 72
78645: PUSH
78646: LD_EXP 97
78650: PUSH
78651: LD_VAR 0 2
78655: ARRAY
78656: UNION
78657: ST_TO_ADDR
// if not tmp then
78658: LD_VAR 0 4
78662: NOT
78663: IFFALSE 78667
// continue ;
78665: GO 78612
// for j in tmp do
78667: LD_ADDR_VAR 0 3
78671: PUSH
78672: LD_VAR 0 4
78676: PUSH
78677: FOR_IN
78678: IFFALSE 78830
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78680: LD_VAR 0 3
78684: PPUSH
78685: CALL_OW 110
78689: NOT
78690: PUSH
78691: LD_VAR 0 3
78695: PPUSH
78696: CALL_OW 314
78700: NOT
78701: AND
78702: PUSH
78703: LD_VAR 0 3
78707: PPUSH
78708: CALL_OW 311
78712: NOT
78713: AND
78714: PUSH
78715: LD_VAR 0 3
78719: PPUSH
78720: CALL_OW 310
78724: NOT
78725: AND
78726: PUSH
78727: LD_VAR 0 3
78731: PUSH
78732: LD_EXP 71
78736: PUSH
78737: LD_VAR 0 2
78741: ARRAY
78742: PUSH
78743: LD_INT 1
78745: ARRAY
78746: IN
78747: NOT
78748: AND
78749: PUSH
78750: LD_VAR 0 3
78754: PUSH
78755: LD_EXP 71
78759: PUSH
78760: LD_VAR 0 2
78764: ARRAY
78765: PUSH
78766: LD_INT 2
78768: ARRAY
78769: IN
78770: NOT
78771: AND
78772: PUSH
78773: LD_VAR 0 3
78777: PUSH
78778: LD_EXP 80
78782: PUSH
78783: LD_VAR 0 2
78787: ARRAY
78788: IN
78789: NOT
78790: AND
78791: IFFALSE 78828
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78793: LD_VAR 0 2
78797: PPUSH
78798: LD_EXP 68
78802: PUSH
78803: LD_VAR 0 2
78807: ARRAY
78808: PPUSH
78809: LD_VAR 0 3
78813: PPUSH
78814: LD_VAR 0 3
78818: PPUSH
78819: CALL_OW 257
78823: PPUSH
78824: CALL 77600 0 4
// end ;
78828: GO 78677
78830: POP
78831: POP
// end ;
78832: GO 78612
78834: POP
78835: POP
// end ;
78836: LD_VAR 0 1
78840: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78841: LD_INT 0
78843: PPUSH
78844: PPUSH
78845: PPUSH
78846: PPUSH
78847: PPUSH
78848: PPUSH
// if not mc_bases [ base ] then
78849: LD_EXP 68
78853: PUSH
78854: LD_VAR 0 1
78858: ARRAY
78859: NOT
78860: IFFALSE 78864
// exit ;
78862: GO 79046
// tmp := [ ] ;
78864: LD_ADDR_VAR 0 6
78868: PUSH
78869: EMPTY
78870: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78871: LD_ADDR_VAR 0 7
78875: PUSH
78876: LD_VAR 0 3
78880: PPUSH
78881: LD_INT 0
78883: PPUSH
78884: CALL_OW 517
78888: ST_TO_ADDR
// if not list then
78889: LD_VAR 0 7
78893: NOT
78894: IFFALSE 78898
// exit ;
78896: GO 79046
// for i = 1 to amount do
78898: LD_ADDR_VAR 0 5
78902: PUSH
78903: DOUBLE
78904: LD_INT 1
78906: DEC
78907: ST_TO_ADDR
78908: LD_VAR 0 2
78912: PUSH
78913: FOR_TO
78914: IFFALSE 78994
// begin x := rand ( 1 , list [ 1 ] ) ;
78916: LD_ADDR_VAR 0 8
78920: PUSH
78921: LD_INT 1
78923: PPUSH
78924: LD_VAR 0 7
78928: PUSH
78929: LD_INT 1
78931: ARRAY
78932: PPUSH
78933: CALL_OW 12
78937: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78938: LD_ADDR_VAR 0 6
78942: PUSH
78943: LD_VAR 0 6
78947: PPUSH
78948: LD_VAR 0 5
78952: PPUSH
78953: LD_VAR 0 7
78957: PUSH
78958: LD_INT 1
78960: ARRAY
78961: PUSH
78962: LD_VAR 0 8
78966: ARRAY
78967: PUSH
78968: LD_VAR 0 7
78972: PUSH
78973: LD_INT 2
78975: ARRAY
78976: PUSH
78977: LD_VAR 0 8
78981: ARRAY
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PPUSH
78987: CALL_OW 1
78991: ST_TO_ADDR
// end ;
78992: GO 78913
78994: POP
78995: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78996: LD_ADDR_EXP 81
79000: PUSH
79001: LD_EXP 81
79005: PPUSH
79006: LD_VAR 0 1
79010: PPUSH
79011: LD_VAR 0 6
79015: PPUSH
79016: CALL_OW 1
79020: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79021: LD_ADDR_EXP 83
79025: PUSH
79026: LD_EXP 83
79030: PPUSH
79031: LD_VAR 0 1
79035: PPUSH
79036: LD_VAR 0 3
79040: PPUSH
79041: CALL_OW 1
79045: ST_TO_ADDR
// end ;
79046: LD_VAR 0 4
79050: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79051: LD_INT 0
79053: PPUSH
// if not mc_bases [ base ] then
79054: LD_EXP 68
79058: PUSH
79059: LD_VAR 0 1
79063: ARRAY
79064: NOT
79065: IFFALSE 79069
// exit ;
79067: GO 79094
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79069: LD_ADDR_EXP 73
79073: PUSH
79074: LD_EXP 73
79078: PPUSH
79079: LD_VAR 0 1
79083: PPUSH
79084: LD_VAR 0 2
79088: PPUSH
79089: CALL_OW 1
79093: ST_TO_ADDR
// end ;
79094: LD_VAR 0 3
79098: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79099: LD_INT 0
79101: PPUSH
// if not mc_bases [ base ] then
79102: LD_EXP 68
79106: PUSH
79107: LD_VAR 0 1
79111: ARRAY
79112: NOT
79113: IFFALSE 79117
// exit ;
79115: GO 79154
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79117: LD_ADDR_EXP 73
79121: PUSH
79122: LD_EXP 73
79126: PPUSH
79127: LD_VAR 0 1
79131: PPUSH
79132: LD_EXP 73
79136: PUSH
79137: LD_VAR 0 1
79141: ARRAY
79142: PUSH
79143: LD_VAR 0 2
79147: UNION
79148: PPUSH
79149: CALL_OW 1
79153: ST_TO_ADDR
// end ;
79154: LD_VAR 0 3
79158: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79159: LD_INT 0
79161: PPUSH
// if not mc_bases [ base ] then
79162: LD_EXP 68
79166: PUSH
79167: LD_VAR 0 1
79171: ARRAY
79172: NOT
79173: IFFALSE 79177
// exit ;
79175: GO 79202
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79177: LD_ADDR_EXP 89
79181: PUSH
79182: LD_EXP 89
79186: PPUSH
79187: LD_VAR 0 1
79191: PPUSH
79192: LD_VAR 0 2
79196: PPUSH
79197: CALL_OW 1
79201: ST_TO_ADDR
// end ;
79202: LD_VAR 0 3
79206: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79207: LD_INT 0
79209: PPUSH
// if not mc_bases [ base ] then
79210: LD_EXP 68
79214: PUSH
79215: LD_VAR 0 1
79219: ARRAY
79220: NOT
79221: IFFALSE 79225
// exit ;
79223: GO 79262
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79225: LD_ADDR_EXP 89
79229: PUSH
79230: LD_EXP 89
79234: PPUSH
79235: LD_VAR 0 1
79239: PPUSH
79240: LD_EXP 89
79244: PUSH
79245: LD_VAR 0 1
79249: ARRAY
79250: PUSH
79251: LD_VAR 0 2
79255: ADD
79256: PPUSH
79257: CALL_OW 1
79261: ST_TO_ADDR
// end ;
79262: LD_VAR 0 3
79266: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79267: LD_INT 0
79269: PPUSH
// if not mc_bases [ base ] then
79270: LD_EXP 68
79274: PUSH
79275: LD_VAR 0 1
79279: ARRAY
79280: NOT
79281: IFFALSE 79285
// exit ;
79283: GO 79339
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79285: LD_ADDR_EXP 90
79289: PUSH
79290: LD_EXP 90
79294: PPUSH
79295: LD_VAR 0 1
79299: PPUSH
79300: LD_VAR 0 2
79304: PPUSH
79305: CALL_OW 1
79309: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79310: LD_ADDR_EXP 79
79314: PUSH
79315: LD_EXP 79
79319: PPUSH
79320: LD_VAR 0 1
79324: PPUSH
79325: LD_VAR 0 2
79329: PUSH
79330: LD_INT 0
79332: PLUS
79333: PPUSH
79334: CALL_OW 1
79338: ST_TO_ADDR
// end ;
79339: LD_VAR 0 3
79343: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79344: LD_INT 0
79346: PPUSH
// if not mc_bases [ base ] then
79347: LD_EXP 68
79351: PUSH
79352: LD_VAR 0 1
79356: ARRAY
79357: NOT
79358: IFFALSE 79362
// exit ;
79360: GO 79387
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79362: LD_ADDR_EXP 79
79366: PUSH
79367: LD_EXP 79
79371: PPUSH
79372: LD_VAR 0 1
79376: PPUSH
79377: LD_VAR 0 2
79381: PPUSH
79382: CALL_OW 1
79386: ST_TO_ADDR
// end ;
79387: LD_VAR 0 3
79391: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79392: LD_INT 0
79394: PPUSH
79395: PPUSH
79396: PPUSH
79397: PPUSH
// if not mc_bases [ base ] then
79398: LD_EXP 68
79402: PUSH
79403: LD_VAR 0 1
79407: ARRAY
79408: NOT
79409: IFFALSE 79413
// exit ;
79411: GO 79478
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79413: LD_ADDR_EXP 88
79417: PUSH
79418: LD_EXP 88
79422: PPUSH
79423: LD_VAR 0 1
79427: PUSH
79428: LD_EXP 88
79432: PUSH
79433: LD_VAR 0 1
79437: ARRAY
79438: PUSH
79439: LD_INT 1
79441: PLUS
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PPUSH
79447: LD_VAR 0 1
79451: PUSH
79452: LD_VAR 0 2
79456: PUSH
79457: LD_VAR 0 3
79461: PUSH
79462: LD_VAR 0 4
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: PPUSH
79473: CALL 18750 0 3
79477: ST_TO_ADDR
// end ;
79478: LD_VAR 0 5
79482: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79483: LD_INT 0
79485: PPUSH
// if not mc_bases [ base ] then
79486: LD_EXP 68
79490: PUSH
79491: LD_VAR 0 1
79495: ARRAY
79496: NOT
79497: IFFALSE 79501
// exit ;
79499: GO 79526
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79501: LD_ADDR_EXP 105
79505: PUSH
79506: LD_EXP 105
79510: PPUSH
79511: LD_VAR 0 1
79515: PPUSH
79516: LD_VAR 0 2
79520: PPUSH
79521: CALL_OW 1
79525: ST_TO_ADDR
// end ;
79526: LD_VAR 0 3
79530: RET
// export function MC_GetMinesField ( base ) ; begin
79531: LD_INT 0
79533: PPUSH
// result := mc_mines [ base ] ;
79534: LD_ADDR_VAR 0 2
79538: PUSH
79539: LD_EXP 81
79543: PUSH
79544: LD_VAR 0 1
79548: ARRAY
79549: ST_TO_ADDR
// end ;
79550: LD_VAR 0 2
79554: RET
// export function MC_GetProduceList ( base ) ; begin
79555: LD_INT 0
79557: PPUSH
// result := mc_produce [ base ] ;
79558: LD_ADDR_VAR 0 2
79562: PUSH
79563: LD_EXP 89
79567: PUSH
79568: LD_VAR 0 1
79572: ARRAY
79573: ST_TO_ADDR
// end ;
79574: LD_VAR 0 2
79578: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79579: LD_INT 0
79581: PPUSH
79582: PPUSH
// if not mc_bases then
79583: LD_EXP 68
79587: NOT
79588: IFFALSE 79592
// exit ;
79590: GO 79657
// if mc_bases [ base ] then
79592: LD_EXP 68
79596: PUSH
79597: LD_VAR 0 1
79601: ARRAY
79602: IFFALSE 79657
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79604: LD_ADDR_VAR 0 3
79608: PUSH
79609: LD_EXP 68
79613: PUSH
79614: LD_VAR 0 1
79618: ARRAY
79619: PPUSH
79620: LD_INT 30
79622: PUSH
79623: LD_VAR 0 2
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PPUSH
79632: CALL_OW 72
79636: ST_TO_ADDR
// if result then
79637: LD_VAR 0 3
79641: IFFALSE 79657
// result := result [ 1 ] ;
79643: LD_ADDR_VAR 0 3
79647: PUSH
79648: LD_VAR 0 3
79652: PUSH
79653: LD_INT 1
79655: ARRAY
79656: ST_TO_ADDR
// end ; end ;
79657: LD_VAR 0 3
79661: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79662: LD_INT 0
79664: PPUSH
79665: PPUSH
// if not mc_bases then
79666: LD_EXP 68
79670: NOT
79671: IFFALSE 79675
// exit ;
79673: GO 79720
// if mc_bases [ base ] then
79675: LD_EXP 68
79679: PUSH
79680: LD_VAR 0 1
79684: ARRAY
79685: IFFALSE 79720
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79687: LD_ADDR_VAR 0 3
79691: PUSH
79692: LD_EXP 68
79696: PUSH
79697: LD_VAR 0 1
79701: ARRAY
79702: PPUSH
79703: LD_INT 30
79705: PUSH
79706: LD_VAR 0 2
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PPUSH
79715: CALL_OW 72
79719: ST_TO_ADDR
// end ;
79720: LD_VAR 0 3
79724: RET
// export function MC_SetTame ( base , area ) ; begin
79725: LD_INT 0
79727: PPUSH
// if not mc_bases or not base then
79728: LD_EXP 68
79732: NOT
79733: PUSH
79734: LD_VAR 0 1
79738: NOT
79739: OR
79740: IFFALSE 79744
// exit ;
79742: GO 79769
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79744: LD_ADDR_EXP 96
79748: PUSH
79749: LD_EXP 96
79753: PPUSH
79754: LD_VAR 0 1
79758: PPUSH
79759: LD_VAR 0 2
79763: PPUSH
79764: CALL_OW 1
79768: ST_TO_ADDR
// end ;
79769: LD_VAR 0 3
79773: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79774: LD_INT 0
79776: PPUSH
79777: PPUSH
// if not mc_bases or not base then
79778: LD_EXP 68
79782: NOT
79783: PUSH
79784: LD_VAR 0 1
79788: NOT
79789: OR
79790: IFFALSE 79794
// exit ;
79792: GO 79896
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79794: LD_ADDR_VAR 0 4
79798: PUSH
79799: LD_EXP 68
79803: PUSH
79804: LD_VAR 0 1
79808: ARRAY
79809: PPUSH
79810: LD_INT 30
79812: PUSH
79813: LD_VAR 0 2
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PPUSH
79822: CALL_OW 72
79826: ST_TO_ADDR
// if not tmp then
79827: LD_VAR 0 4
79831: NOT
79832: IFFALSE 79836
// exit ;
79834: GO 79896
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79836: LD_ADDR_EXP 100
79840: PUSH
79841: LD_EXP 100
79845: PPUSH
79846: LD_VAR 0 1
79850: PPUSH
79851: LD_EXP 100
79855: PUSH
79856: LD_VAR 0 1
79860: ARRAY
79861: PPUSH
79862: LD_EXP 100
79866: PUSH
79867: LD_VAR 0 1
79871: ARRAY
79872: PUSH
79873: LD_INT 1
79875: PLUS
79876: PPUSH
79877: LD_VAR 0 4
79881: PUSH
79882: LD_INT 1
79884: ARRAY
79885: PPUSH
79886: CALL_OW 2
79890: PPUSH
79891: CALL_OW 1
79895: ST_TO_ADDR
// end ;
79896: LD_VAR 0 3
79900: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79901: LD_INT 0
79903: PPUSH
79904: PPUSH
// if not mc_bases or not base or not kinds then
79905: LD_EXP 68
79909: NOT
79910: PUSH
79911: LD_VAR 0 1
79915: NOT
79916: OR
79917: PUSH
79918: LD_VAR 0 2
79922: NOT
79923: OR
79924: IFFALSE 79928
// exit ;
79926: GO 79989
// for i in kinds do
79928: LD_ADDR_VAR 0 4
79932: PUSH
79933: LD_VAR 0 2
79937: PUSH
79938: FOR_IN
79939: IFFALSE 79987
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79941: LD_ADDR_EXP 102
79945: PUSH
79946: LD_EXP 102
79950: PPUSH
79951: LD_VAR 0 1
79955: PUSH
79956: LD_EXP 102
79960: PUSH
79961: LD_VAR 0 1
79965: ARRAY
79966: PUSH
79967: LD_INT 1
79969: PLUS
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PPUSH
79975: LD_VAR 0 4
79979: PPUSH
79980: CALL 18750 0 3
79984: ST_TO_ADDR
79985: GO 79938
79987: POP
79988: POP
// end ;
79989: LD_VAR 0 3
79993: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79994: LD_INT 0
79996: PPUSH
// if not mc_bases or not base or not areas then
79997: LD_EXP 68
80001: NOT
80002: PUSH
80003: LD_VAR 0 1
80007: NOT
80008: OR
80009: PUSH
80010: LD_VAR 0 2
80014: NOT
80015: OR
80016: IFFALSE 80020
// exit ;
80018: GO 80045
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80020: LD_ADDR_EXP 86
80024: PUSH
80025: LD_EXP 86
80029: PPUSH
80030: LD_VAR 0 1
80034: PPUSH
80035: LD_VAR 0 2
80039: PPUSH
80040: CALL_OW 1
80044: ST_TO_ADDR
// end ;
80045: LD_VAR 0 3
80049: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80050: LD_INT 0
80052: PPUSH
// if not mc_bases or not base or not teleports_exit then
80053: LD_EXP 68
80057: NOT
80058: PUSH
80059: LD_VAR 0 1
80063: NOT
80064: OR
80065: PUSH
80066: LD_VAR 0 2
80070: NOT
80071: OR
80072: IFFALSE 80076
// exit ;
80074: GO 80101
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80076: LD_ADDR_EXP 103
80080: PUSH
80081: LD_EXP 103
80085: PPUSH
80086: LD_VAR 0 1
80090: PPUSH
80091: LD_VAR 0 2
80095: PPUSH
80096: CALL_OW 1
80100: ST_TO_ADDR
// end ;
80101: LD_VAR 0 3
80105: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80106: LD_INT 0
80108: PPUSH
80109: PPUSH
80110: PPUSH
// if not mc_bases or not base or not ext_list then
80111: LD_EXP 68
80115: NOT
80116: PUSH
80117: LD_VAR 0 1
80121: NOT
80122: OR
80123: PUSH
80124: LD_VAR 0 5
80128: NOT
80129: OR
80130: IFFALSE 80134
// exit ;
80132: GO 80307
// tmp := GetFacExtXYD ( x , y , d ) ;
80134: LD_ADDR_VAR 0 8
80138: PUSH
80139: LD_VAR 0 2
80143: PPUSH
80144: LD_VAR 0 3
80148: PPUSH
80149: LD_VAR 0 4
80153: PPUSH
80154: CALL 48651 0 3
80158: ST_TO_ADDR
// if not tmp then
80159: LD_VAR 0 8
80163: NOT
80164: IFFALSE 80168
// exit ;
80166: GO 80307
// for i in tmp do
80168: LD_ADDR_VAR 0 7
80172: PUSH
80173: LD_VAR 0 8
80177: PUSH
80178: FOR_IN
80179: IFFALSE 80305
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80181: LD_ADDR_EXP 73
80185: PUSH
80186: LD_EXP 73
80190: PPUSH
80191: LD_VAR 0 1
80195: PPUSH
80196: LD_EXP 73
80200: PUSH
80201: LD_VAR 0 1
80205: ARRAY
80206: PPUSH
80207: LD_EXP 73
80211: PUSH
80212: LD_VAR 0 1
80216: ARRAY
80217: PUSH
80218: LD_INT 1
80220: PLUS
80221: PPUSH
80222: LD_VAR 0 5
80226: PUSH
80227: LD_INT 1
80229: ARRAY
80230: PUSH
80231: LD_VAR 0 7
80235: PUSH
80236: LD_INT 1
80238: ARRAY
80239: PUSH
80240: LD_VAR 0 7
80244: PUSH
80245: LD_INT 2
80247: ARRAY
80248: PUSH
80249: LD_VAR 0 7
80253: PUSH
80254: LD_INT 3
80256: ARRAY
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: PPUSH
80264: CALL_OW 2
80268: PPUSH
80269: CALL_OW 1
80273: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80274: LD_ADDR_VAR 0 5
80278: PUSH
80279: LD_VAR 0 5
80283: PPUSH
80284: LD_INT 1
80286: PPUSH
80287: CALL_OW 3
80291: ST_TO_ADDR
// if not ext_list then
80292: LD_VAR 0 5
80296: NOT
80297: IFFALSE 80303
// exit ;
80299: POP
80300: POP
80301: GO 80307
// end ;
80303: GO 80178
80305: POP
80306: POP
// end ;
80307: LD_VAR 0 6
80311: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80312: LD_INT 0
80314: PPUSH
// if not mc_bases or not base or not weapon_list then
80315: LD_EXP 68
80319: NOT
80320: PUSH
80321: LD_VAR 0 1
80325: NOT
80326: OR
80327: PUSH
80328: LD_VAR 0 2
80332: NOT
80333: OR
80334: IFFALSE 80338
// exit ;
80336: GO 80363
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80338: LD_ADDR_EXP 107
80342: PUSH
80343: LD_EXP 107
80347: PPUSH
80348: LD_VAR 0 1
80352: PPUSH
80353: LD_VAR 0 2
80357: PPUSH
80358: CALL_OW 1
80362: ST_TO_ADDR
// end ;
80363: LD_VAR 0 3
80367: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80368: LD_INT 0
80370: PPUSH
// if not mc_bases or not base or not tech_list then
80371: LD_EXP 68
80375: NOT
80376: PUSH
80377: LD_VAR 0 1
80381: NOT
80382: OR
80383: PUSH
80384: LD_VAR 0 2
80388: NOT
80389: OR
80390: IFFALSE 80394
// exit ;
80392: GO 80419
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80394: LD_ADDR_EXP 95
80398: PUSH
80399: LD_EXP 95
80403: PPUSH
80404: LD_VAR 0 1
80408: PPUSH
80409: LD_VAR 0 2
80413: PPUSH
80414: CALL_OW 1
80418: ST_TO_ADDR
// end ;
80419: LD_VAR 0 3
80423: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80424: LD_INT 0
80426: PPUSH
// if not mc_bases or not parking_area or not base then
80427: LD_EXP 68
80431: NOT
80432: PUSH
80433: LD_VAR 0 2
80437: NOT
80438: OR
80439: PUSH
80440: LD_VAR 0 1
80444: NOT
80445: OR
80446: IFFALSE 80450
// exit ;
80448: GO 80475
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80450: LD_ADDR_EXP 92
80454: PUSH
80455: LD_EXP 92
80459: PPUSH
80460: LD_VAR 0 1
80464: PPUSH
80465: LD_VAR 0 2
80469: PPUSH
80470: CALL_OW 1
80474: ST_TO_ADDR
// end ;
80475: LD_VAR 0 3
80479: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80480: LD_INT 0
80482: PPUSH
// if not mc_bases or not base or not scan_area then
80483: LD_EXP 68
80487: NOT
80488: PUSH
80489: LD_VAR 0 1
80493: NOT
80494: OR
80495: PUSH
80496: LD_VAR 0 2
80500: NOT
80501: OR
80502: IFFALSE 80506
// exit ;
80504: GO 80531
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80506: LD_ADDR_EXP 93
80510: PUSH
80511: LD_EXP 93
80515: PPUSH
80516: LD_VAR 0 1
80520: PPUSH
80521: LD_VAR 0 2
80525: PPUSH
80526: CALL_OW 1
80530: ST_TO_ADDR
// end ;
80531: LD_VAR 0 3
80535: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80536: LD_INT 0
80538: PPUSH
80539: PPUSH
// if not mc_bases or not base then
80540: LD_EXP 68
80544: NOT
80545: PUSH
80546: LD_VAR 0 1
80550: NOT
80551: OR
80552: IFFALSE 80556
// exit ;
80554: GO 80620
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80556: LD_ADDR_VAR 0 3
80560: PUSH
80561: LD_INT 1
80563: PUSH
80564: LD_INT 2
80566: PUSH
80567: LD_INT 3
80569: PUSH
80570: LD_INT 4
80572: PUSH
80573: LD_INT 11
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80583: LD_ADDR_EXP 95
80587: PUSH
80588: LD_EXP 95
80592: PPUSH
80593: LD_VAR 0 1
80597: PPUSH
80598: LD_EXP 95
80602: PUSH
80603: LD_VAR 0 1
80607: ARRAY
80608: PUSH
80609: LD_VAR 0 3
80613: DIFF
80614: PPUSH
80615: CALL_OW 1
80619: ST_TO_ADDR
// end ;
80620: LD_VAR 0 2
80624: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80625: LD_INT 0
80627: PPUSH
// result := mc_vehicles [ base ] ;
80628: LD_ADDR_VAR 0 3
80632: PUSH
80633: LD_EXP 87
80637: PUSH
80638: LD_VAR 0 1
80642: ARRAY
80643: ST_TO_ADDR
// if onlyCombat then
80644: LD_VAR 0 2
80648: IFFALSE 80826
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80650: LD_ADDR_VAR 0 3
80654: PUSH
80655: LD_VAR 0 3
80659: PUSH
80660: LD_VAR 0 3
80664: PPUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 34
80670: PUSH
80671: LD_INT 12
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 34
80680: PUSH
80681: LD_INT 51
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 34
80690: PUSH
80691: LD_EXP 49
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 34
80702: PUSH
80703: LD_INT 32
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 34
80712: PUSH
80713: LD_INT 13
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 34
80722: PUSH
80723: LD_INT 52
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 34
80732: PUSH
80733: LD_EXP 54
80737: PUSH
80738: EMPTY
80739: LIST
80740: LIST
80741: PUSH
80742: LD_INT 34
80744: PUSH
80745: LD_INT 14
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 34
80754: PUSH
80755: LD_INT 53
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 34
80764: PUSH
80765: LD_EXP 48
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 34
80776: PUSH
80777: LD_INT 31
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 34
80786: PUSH
80787: LD_INT 48
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 34
80796: PUSH
80797: LD_INT 8
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: PPUSH
80820: CALL_OW 72
80824: DIFF
80825: ST_TO_ADDR
// end ; end_of_file
80826: LD_VAR 0 3
80830: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80831: LD_INT 0
80833: PPUSH
80834: PPUSH
80835: PPUSH
// if not mc_bases or not skirmish then
80836: LD_EXP 68
80840: NOT
80841: PUSH
80842: LD_EXP 66
80846: NOT
80847: OR
80848: IFFALSE 80852
// exit ;
80850: GO 81017
// for i = 1 to mc_bases do
80852: LD_ADDR_VAR 0 4
80856: PUSH
80857: DOUBLE
80858: LD_INT 1
80860: DEC
80861: ST_TO_ADDR
80862: LD_EXP 68
80866: PUSH
80867: FOR_TO
80868: IFFALSE 81015
// begin if sci in mc_bases [ i ] then
80870: LD_VAR 0 2
80874: PUSH
80875: LD_EXP 68
80879: PUSH
80880: LD_VAR 0 4
80884: ARRAY
80885: IN
80886: IFFALSE 81013
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80888: LD_ADDR_EXP 97
80892: PUSH
80893: LD_EXP 97
80897: PPUSH
80898: LD_VAR 0 4
80902: PUSH
80903: LD_EXP 97
80907: PUSH
80908: LD_VAR 0 4
80912: ARRAY
80913: PUSH
80914: LD_INT 1
80916: PLUS
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PPUSH
80922: LD_VAR 0 1
80926: PPUSH
80927: CALL 18750 0 3
80931: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80932: LD_ADDR_VAR 0 5
80936: PUSH
80937: LD_EXP 68
80941: PUSH
80942: LD_VAR 0 4
80946: ARRAY
80947: PPUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 30
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 30
80963: PUSH
80964: LD_INT 1
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: LIST
80975: PPUSH
80976: CALL_OW 72
80980: PPUSH
80981: LD_VAR 0 1
80985: PPUSH
80986: CALL_OW 74
80990: ST_TO_ADDR
// if tmp then
80991: LD_VAR 0 5
80995: IFFALSE 81011
// ComStandNearbyBuilding ( ape , tmp ) ;
80997: LD_VAR 0 1
81001: PPUSH
81002: LD_VAR 0 5
81006: PPUSH
81007: CALL 15175 0 2
// break ;
81011: GO 81015
// end ; end ;
81013: GO 80867
81015: POP
81016: POP
// end ;
81017: LD_VAR 0 3
81021: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81022: LD_INT 0
81024: PPUSH
81025: PPUSH
81026: PPUSH
// if not mc_bases or not skirmish then
81027: LD_EXP 68
81031: NOT
81032: PUSH
81033: LD_EXP 66
81037: NOT
81038: OR
81039: IFFALSE 81043
// exit ;
81041: GO 81132
// for i = 1 to mc_bases do
81043: LD_ADDR_VAR 0 4
81047: PUSH
81048: DOUBLE
81049: LD_INT 1
81051: DEC
81052: ST_TO_ADDR
81053: LD_EXP 68
81057: PUSH
81058: FOR_TO
81059: IFFALSE 81130
// begin if building in mc_busy_turret_list [ i ] then
81061: LD_VAR 0 1
81065: PUSH
81066: LD_EXP 78
81070: PUSH
81071: LD_VAR 0 4
81075: ARRAY
81076: IN
81077: IFFALSE 81128
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81079: LD_ADDR_VAR 0 5
81083: PUSH
81084: LD_EXP 78
81088: PUSH
81089: LD_VAR 0 4
81093: ARRAY
81094: PUSH
81095: LD_VAR 0 1
81099: DIFF
81100: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81101: LD_ADDR_EXP 78
81105: PUSH
81106: LD_EXP 78
81110: PPUSH
81111: LD_VAR 0 4
81115: PPUSH
81116: LD_VAR 0 5
81120: PPUSH
81121: CALL_OW 1
81125: ST_TO_ADDR
// break ;
81126: GO 81130
// end ; end ;
81128: GO 81058
81130: POP
81131: POP
// end ;
81132: LD_VAR 0 3
81136: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81137: LD_INT 0
81139: PPUSH
81140: PPUSH
81141: PPUSH
// if not mc_bases or not skirmish then
81142: LD_EXP 68
81146: NOT
81147: PUSH
81148: LD_EXP 66
81152: NOT
81153: OR
81154: IFFALSE 81158
// exit ;
81156: GO 81357
// for i = 1 to mc_bases do
81158: LD_ADDR_VAR 0 5
81162: PUSH
81163: DOUBLE
81164: LD_INT 1
81166: DEC
81167: ST_TO_ADDR
81168: LD_EXP 68
81172: PUSH
81173: FOR_TO
81174: IFFALSE 81355
// if building in mc_bases [ i ] then
81176: LD_VAR 0 1
81180: PUSH
81181: LD_EXP 68
81185: PUSH
81186: LD_VAR 0 5
81190: ARRAY
81191: IN
81192: IFFALSE 81353
// begin tmp := mc_bases [ i ] diff building ;
81194: LD_ADDR_VAR 0 6
81198: PUSH
81199: LD_EXP 68
81203: PUSH
81204: LD_VAR 0 5
81208: ARRAY
81209: PUSH
81210: LD_VAR 0 1
81214: DIFF
81215: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81216: LD_ADDR_EXP 68
81220: PUSH
81221: LD_EXP 68
81225: PPUSH
81226: LD_VAR 0 5
81230: PPUSH
81231: LD_VAR 0 6
81235: PPUSH
81236: CALL_OW 1
81240: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81241: LD_VAR 0 1
81245: PUSH
81246: LD_EXP 76
81250: PUSH
81251: LD_VAR 0 5
81255: ARRAY
81256: IN
81257: IFFALSE 81296
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81259: LD_ADDR_EXP 76
81263: PUSH
81264: LD_EXP 76
81268: PPUSH
81269: LD_VAR 0 5
81273: PPUSH
81274: LD_EXP 76
81278: PUSH
81279: LD_VAR 0 5
81283: ARRAY
81284: PUSH
81285: LD_VAR 0 1
81289: DIFF
81290: PPUSH
81291: CALL_OW 1
81295: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81296: LD_VAR 0 1
81300: PUSH
81301: LD_EXP 77
81305: PUSH
81306: LD_VAR 0 5
81310: ARRAY
81311: IN
81312: IFFALSE 81351
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81314: LD_ADDR_EXP 77
81318: PUSH
81319: LD_EXP 77
81323: PPUSH
81324: LD_VAR 0 5
81328: PPUSH
81329: LD_EXP 77
81333: PUSH
81334: LD_VAR 0 5
81338: ARRAY
81339: PUSH
81340: LD_VAR 0 1
81344: DIFF
81345: PPUSH
81346: CALL_OW 1
81350: ST_TO_ADDR
// break ;
81351: GO 81355
// end ;
81353: GO 81173
81355: POP
81356: POP
// end ;
81357: LD_VAR 0 4
81361: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81362: LD_INT 0
81364: PPUSH
81365: PPUSH
81366: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81367: LD_EXP 68
81371: NOT
81372: PUSH
81373: LD_EXP 66
81377: NOT
81378: OR
81379: PUSH
81380: LD_VAR 0 3
81384: PUSH
81385: LD_EXP 94
81389: IN
81390: NOT
81391: OR
81392: IFFALSE 81396
// exit ;
81394: GO 81519
// for i = 1 to mc_vehicles do
81396: LD_ADDR_VAR 0 6
81400: PUSH
81401: DOUBLE
81402: LD_INT 1
81404: DEC
81405: ST_TO_ADDR
81406: LD_EXP 87
81410: PUSH
81411: FOR_TO
81412: IFFALSE 81517
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81414: LD_VAR 0 2
81418: PUSH
81419: LD_EXP 87
81423: PUSH
81424: LD_VAR 0 6
81428: ARRAY
81429: IN
81430: PUSH
81431: LD_VAR 0 1
81435: PUSH
81436: LD_EXP 87
81440: PUSH
81441: LD_VAR 0 6
81445: ARRAY
81446: IN
81447: OR
81448: IFFALSE 81515
// begin tmp := mc_vehicles [ i ] diff old ;
81450: LD_ADDR_VAR 0 7
81454: PUSH
81455: LD_EXP 87
81459: PUSH
81460: LD_VAR 0 6
81464: ARRAY
81465: PUSH
81466: LD_VAR 0 2
81470: DIFF
81471: ST_TO_ADDR
// tmp := tmp diff new ;
81472: LD_ADDR_VAR 0 7
81476: PUSH
81477: LD_VAR 0 7
81481: PUSH
81482: LD_VAR 0 1
81486: DIFF
81487: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81488: LD_ADDR_EXP 87
81492: PUSH
81493: LD_EXP 87
81497: PPUSH
81498: LD_VAR 0 6
81502: PPUSH
81503: LD_VAR 0 7
81507: PPUSH
81508: CALL_OW 1
81512: ST_TO_ADDR
// break ;
81513: GO 81517
// end ;
81515: GO 81411
81517: POP
81518: POP
// end ;
81519: LD_VAR 0 5
81523: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81524: LD_INT 0
81526: PPUSH
81527: PPUSH
81528: PPUSH
81529: PPUSH
// if not mc_bases or not skirmish then
81530: LD_EXP 68
81534: NOT
81535: PUSH
81536: LD_EXP 66
81540: NOT
81541: OR
81542: IFFALSE 81546
// exit ;
81544: GO 81938
// side := GetSide ( vehicle ) ;
81546: LD_ADDR_VAR 0 5
81550: PUSH
81551: LD_VAR 0 1
81555: PPUSH
81556: CALL_OW 255
81560: ST_TO_ADDR
// for i = 1 to mc_bases do
81561: LD_ADDR_VAR 0 4
81565: PUSH
81566: DOUBLE
81567: LD_INT 1
81569: DEC
81570: ST_TO_ADDR
81571: LD_EXP 68
81575: PUSH
81576: FOR_TO
81577: IFFALSE 81936
// begin if factory in mc_bases [ i ] then
81579: LD_VAR 0 2
81583: PUSH
81584: LD_EXP 68
81588: PUSH
81589: LD_VAR 0 4
81593: ARRAY
81594: IN
81595: IFFALSE 81934
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81597: LD_EXP 90
81601: PUSH
81602: LD_VAR 0 4
81606: ARRAY
81607: PUSH
81608: LD_EXP 79
81612: PUSH
81613: LD_VAR 0 4
81617: ARRAY
81618: LESS
81619: PUSH
81620: LD_VAR 0 1
81624: PPUSH
81625: CALL_OW 264
81629: PUSH
81630: LD_INT 31
81632: PUSH
81633: LD_INT 32
81635: PUSH
81636: LD_INT 51
81638: PUSH
81639: LD_EXP 49
81643: PUSH
81644: LD_INT 12
81646: PUSH
81647: LD_INT 30
81649: PUSH
81650: LD_EXP 48
81654: PUSH
81655: LD_INT 11
81657: PUSH
81658: LD_INT 53
81660: PUSH
81661: LD_INT 14
81663: PUSH
81664: LD_EXP 52
81668: PUSH
81669: LD_INT 29
81671: PUSH
81672: LD_EXP 50
81676: PUSH
81677: LD_INT 13
81679: PUSH
81680: LD_INT 52
81682: PUSH
81683: LD_EXP 54
81687: PUSH
81688: LD_INT 48
81690: PUSH
81691: LD_INT 8
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: IN
81714: NOT
81715: AND
81716: IFFALSE 81764
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81718: LD_ADDR_EXP 90
81722: PUSH
81723: LD_EXP 90
81727: PPUSH
81728: LD_VAR 0 4
81732: PUSH
81733: LD_EXP 90
81737: PUSH
81738: LD_VAR 0 4
81742: ARRAY
81743: PUSH
81744: LD_INT 1
81746: PLUS
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PPUSH
81752: LD_VAR 0 1
81756: PPUSH
81757: CALL 18750 0 3
81761: ST_TO_ADDR
81762: GO 81808
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81764: LD_ADDR_EXP 87
81768: PUSH
81769: LD_EXP 87
81773: PPUSH
81774: LD_VAR 0 4
81778: PUSH
81779: LD_EXP 87
81783: PUSH
81784: LD_VAR 0 4
81788: ARRAY
81789: PUSH
81790: LD_INT 1
81792: PLUS
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PPUSH
81798: LD_VAR 0 1
81802: PPUSH
81803: CALL 18750 0 3
81807: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81808: LD_VAR 0 1
81812: PPUSH
81813: CALL_OW 263
81817: PUSH
81818: LD_INT 2
81820: EQUAL
81821: IFFALSE 81850
// begin repeat wait ( 0 0$3 ) ;
81823: LD_INT 105
81825: PPUSH
81826: CALL_OW 67
// Connect ( vehicle ) ;
81830: LD_VAR 0 1
81834: PPUSH
81835: CALL 21721 0 1
// until IsControledBy ( vehicle ) ;
81839: LD_VAR 0 1
81843: PPUSH
81844: CALL_OW 312
81848: IFFALSE 81823
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81850: LD_VAR 0 1
81854: PPUSH
81855: LD_EXP 92
81859: PUSH
81860: LD_VAR 0 4
81864: ARRAY
81865: PPUSH
81866: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81870: LD_VAR 0 1
81874: PPUSH
81875: CALL_OW 263
81879: PUSH
81880: LD_INT 1
81882: NONEQUAL
81883: IFFALSE 81887
// break ;
81885: GO 81936
// repeat wait ( 0 0$1 ) ;
81887: LD_INT 35
81889: PPUSH
81890: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81894: LD_VAR 0 1
81898: PPUSH
81899: LD_EXP 92
81903: PUSH
81904: LD_VAR 0 4
81908: ARRAY
81909: PPUSH
81910: CALL_OW 308
81914: IFFALSE 81887
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81916: LD_VAR 0 1
81920: PPUSH
81921: CALL_OW 311
81925: PPUSH
81926: CALL_OW 121
// exit ;
81930: POP
81931: POP
81932: GO 81938
// end ; end ;
81934: GO 81576
81936: POP
81937: POP
// end ;
81938: LD_VAR 0 3
81942: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81943: LD_INT 0
81945: PPUSH
81946: PPUSH
81947: PPUSH
81948: PPUSH
// if not mc_bases or not skirmish then
81949: LD_EXP 68
81953: NOT
81954: PUSH
81955: LD_EXP 66
81959: NOT
81960: OR
81961: IFFALSE 81965
// exit ;
81963: GO 82318
// repeat wait ( 0 0$1 ) ;
81965: LD_INT 35
81967: PPUSH
81968: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81972: LD_VAR 0 2
81976: PPUSH
81977: LD_VAR 0 3
81981: PPUSH
81982: CALL_OW 284
81986: IFFALSE 81965
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81988: LD_VAR 0 2
81992: PPUSH
81993: LD_VAR 0 3
81997: PPUSH
81998: CALL_OW 283
82002: PUSH
82003: LD_INT 4
82005: EQUAL
82006: IFFALSE 82010
// exit ;
82008: GO 82318
// for i = 1 to mc_bases do
82010: LD_ADDR_VAR 0 7
82014: PUSH
82015: DOUBLE
82016: LD_INT 1
82018: DEC
82019: ST_TO_ADDR
82020: LD_EXP 68
82024: PUSH
82025: FOR_TO
82026: IFFALSE 82316
// begin if mc_crates_area [ i ] then
82028: LD_EXP 86
82032: PUSH
82033: LD_VAR 0 7
82037: ARRAY
82038: IFFALSE 82149
// for j in mc_crates_area [ i ] do
82040: LD_ADDR_VAR 0 8
82044: PUSH
82045: LD_EXP 86
82049: PUSH
82050: LD_VAR 0 7
82054: ARRAY
82055: PUSH
82056: FOR_IN
82057: IFFALSE 82147
// if InArea ( x , y , j ) then
82059: LD_VAR 0 2
82063: PPUSH
82064: LD_VAR 0 3
82068: PPUSH
82069: LD_VAR 0 8
82073: PPUSH
82074: CALL_OW 309
82078: IFFALSE 82145
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82080: LD_ADDR_EXP 84
82084: PUSH
82085: LD_EXP 84
82089: PPUSH
82090: LD_VAR 0 7
82094: PUSH
82095: LD_EXP 84
82099: PUSH
82100: LD_VAR 0 7
82104: ARRAY
82105: PUSH
82106: LD_INT 1
82108: PLUS
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PPUSH
82114: LD_VAR 0 4
82118: PUSH
82119: LD_VAR 0 2
82123: PUSH
82124: LD_VAR 0 3
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: LIST
82133: PPUSH
82134: CALL 18750 0 3
82138: ST_TO_ADDR
// exit ;
82139: POP
82140: POP
82141: POP
82142: POP
82143: GO 82318
// end ;
82145: GO 82056
82147: POP
82148: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82149: LD_ADDR_VAR 0 9
82153: PUSH
82154: LD_EXP 68
82158: PUSH
82159: LD_VAR 0 7
82163: ARRAY
82164: PPUSH
82165: LD_INT 2
82167: PUSH
82168: LD_INT 30
82170: PUSH
82171: LD_INT 0
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 30
82180: PUSH
82181: LD_INT 1
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: LIST
82192: PPUSH
82193: CALL_OW 72
82197: ST_TO_ADDR
// if not depot then
82198: LD_VAR 0 9
82202: NOT
82203: IFFALSE 82207
// continue ;
82205: GO 82025
// for j in depot do
82207: LD_ADDR_VAR 0 8
82211: PUSH
82212: LD_VAR 0 9
82216: PUSH
82217: FOR_IN
82218: IFFALSE 82312
// if GetDistUnitXY ( j , x , y ) < 30 then
82220: LD_VAR 0 8
82224: PPUSH
82225: LD_VAR 0 2
82229: PPUSH
82230: LD_VAR 0 3
82234: PPUSH
82235: CALL_OW 297
82239: PUSH
82240: LD_INT 30
82242: LESS
82243: IFFALSE 82310
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82245: LD_ADDR_EXP 84
82249: PUSH
82250: LD_EXP 84
82254: PPUSH
82255: LD_VAR 0 7
82259: PUSH
82260: LD_EXP 84
82264: PUSH
82265: LD_VAR 0 7
82269: ARRAY
82270: PUSH
82271: LD_INT 1
82273: PLUS
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PPUSH
82279: LD_VAR 0 4
82283: PUSH
82284: LD_VAR 0 2
82288: PUSH
82289: LD_VAR 0 3
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: LIST
82298: PPUSH
82299: CALL 18750 0 3
82303: ST_TO_ADDR
// exit ;
82304: POP
82305: POP
82306: POP
82307: POP
82308: GO 82318
// end ;
82310: GO 82217
82312: POP
82313: POP
// end ;
82314: GO 82025
82316: POP
82317: POP
// end ;
82318: LD_VAR 0 6
82322: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82323: LD_INT 0
82325: PPUSH
82326: PPUSH
82327: PPUSH
82328: PPUSH
// if not mc_bases or not skirmish then
82329: LD_EXP 68
82333: NOT
82334: PUSH
82335: LD_EXP 66
82339: NOT
82340: OR
82341: IFFALSE 82345
// exit ;
82343: GO 82622
// side := GetSide ( lab ) ;
82345: LD_ADDR_VAR 0 4
82349: PUSH
82350: LD_VAR 0 2
82354: PPUSH
82355: CALL_OW 255
82359: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82360: LD_VAR 0 4
82364: PUSH
82365: LD_EXP 94
82369: IN
82370: NOT
82371: PUSH
82372: LD_EXP 95
82376: NOT
82377: OR
82378: PUSH
82379: LD_EXP 68
82383: NOT
82384: OR
82385: IFFALSE 82389
// exit ;
82387: GO 82622
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82389: LD_ADDR_EXP 95
82393: PUSH
82394: LD_EXP 95
82398: PPUSH
82399: LD_VAR 0 4
82403: PPUSH
82404: LD_EXP 95
82408: PUSH
82409: LD_VAR 0 4
82413: ARRAY
82414: PUSH
82415: LD_VAR 0 1
82419: DIFF
82420: PPUSH
82421: CALL_OW 1
82425: ST_TO_ADDR
// for i = 1 to mc_bases do
82426: LD_ADDR_VAR 0 5
82430: PUSH
82431: DOUBLE
82432: LD_INT 1
82434: DEC
82435: ST_TO_ADDR
82436: LD_EXP 68
82440: PUSH
82441: FOR_TO
82442: IFFALSE 82620
// begin if lab in mc_bases [ i ] then
82444: LD_VAR 0 2
82448: PUSH
82449: LD_EXP 68
82453: PUSH
82454: LD_VAR 0 5
82458: ARRAY
82459: IN
82460: IFFALSE 82618
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82462: LD_VAR 0 1
82466: PUSH
82467: LD_INT 11
82469: PUSH
82470: LD_INT 4
82472: PUSH
82473: LD_INT 3
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: IN
82485: PUSH
82486: LD_EXP 98
82490: PUSH
82491: LD_VAR 0 5
82495: ARRAY
82496: AND
82497: IFFALSE 82618
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82499: LD_ADDR_VAR 0 6
82503: PUSH
82504: LD_EXP 98
82508: PUSH
82509: LD_VAR 0 5
82513: ARRAY
82514: PUSH
82515: LD_INT 1
82517: ARRAY
82518: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82519: LD_ADDR_EXP 98
82523: PUSH
82524: LD_EXP 98
82528: PPUSH
82529: LD_VAR 0 5
82533: PPUSH
82534: EMPTY
82535: PPUSH
82536: CALL_OW 1
82540: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82541: LD_VAR 0 6
82545: PPUSH
82546: LD_INT 0
82548: PPUSH
82549: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82553: LD_VAR 0 6
82557: PPUSH
82558: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82562: LD_ADDR_EXP 97
82566: PUSH
82567: LD_EXP 97
82571: PPUSH
82572: LD_VAR 0 5
82576: PPUSH
82577: LD_EXP 97
82581: PUSH
82582: LD_VAR 0 5
82586: ARRAY
82587: PPUSH
82588: LD_INT 1
82590: PPUSH
82591: LD_VAR 0 6
82595: PPUSH
82596: CALL_OW 2
82600: PPUSH
82601: CALL_OW 1
82605: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82606: LD_VAR 0 5
82610: PPUSH
82611: LD_INT 112
82613: PPUSH
82614: CALL 59141 0 2
// end ; end ; end ;
82618: GO 82441
82620: POP
82621: POP
// end ;
82622: LD_VAR 0 3
82626: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82627: LD_INT 0
82629: PPUSH
82630: PPUSH
82631: PPUSH
82632: PPUSH
82633: PPUSH
82634: PPUSH
82635: PPUSH
82636: PPUSH
// if not mc_bases or not skirmish then
82637: LD_EXP 68
82641: NOT
82642: PUSH
82643: LD_EXP 66
82647: NOT
82648: OR
82649: IFFALSE 82653
// exit ;
82651: GO 84024
// for i = 1 to mc_bases do
82653: LD_ADDR_VAR 0 3
82657: PUSH
82658: DOUBLE
82659: LD_INT 1
82661: DEC
82662: ST_TO_ADDR
82663: LD_EXP 68
82667: PUSH
82668: FOR_TO
82669: IFFALSE 84022
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82671: LD_VAR 0 1
82675: PUSH
82676: LD_EXP 68
82680: PUSH
82681: LD_VAR 0 3
82685: ARRAY
82686: IN
82687: PUSH
82688: LD_VAR 0 1
82692: PUSH
82693: LD_EXP 75
82697: PUSH
82698: LD_VAR 0 3
82702: ARRAY
82703: IN
82704: OR
82705: PUSH
82706: LD_VAR 0 1
82710: PUSH
82711: LD_EXP 90
82715: PUSH
82716: LD_VAR 0 3
82720: ARRAY
82721: IN
82722: OR
82723: PUSH
82724: LD_VAR 0 1
82728: PUSH
82729: LD_EXP 87
82733: PUSH
82734: LD_VAR 0 3
82738: ARRAY
82739: IN
82740: OR
82741: PUSH
82742: LD_VAR 0 1
82746: PUSH
82747: LD_EXP 97
82751: PUSH
82752: LD_VAR 0 3
82756: ARRAY
82757: IN
82758: OR
82759: PUSH
82760: LD_VAR 0 1
82764: PUSH
82765: LD_EXP 98
82769: PUSH
82770: LD_VAR 0 3
82774: ARRAY
82775: IN
82776: OR
82777: IFFALSE 84020
// begin if un in mc_ape [ i ] then
82779: LD_VAR 0 1
82783: PUSH
82784: LD_EXP 97
82788: PUSH
82789: LD_VAR 0 3
82793: ARRAY
82794: IN
82795: IFFALSE 82834
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82797: LD_ADDR_EXP 97
82801: PUSH
82802: LD_EXP 97
82806: PPUSH
82807: LD_VAR 0 3
82811: PPUSH
82812: LD_EXP 97
82816: PUSH
82817: LD_VAR 0 3
82821: ARRAY
82822: PUSH
82823: LD_VAR 0 1
82827: DIFF
82828: PPUSH
82829: CALL_OW 1
82833: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82834: LD_VAR 0 1
82838: PUSH
82839: LD_EXP 98
82843: PUSH
82844: LD_VAR 0 3
82848: ARRAY
82849: IN
82850: IFFALSE 82874
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82852: LD_ADDR_EXP 98
82856: PUSH
82857: LD_EXP 98
82861: PPUSH
82862: LD_VAR 0 3
82866: PPUSH
82867: EMPTY
82868: PPUSH
82869: CALL_OW 1
82873: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82874: LD_VAR 0 1
82878: PPUSH
82879: CALL_OW 247
82883: PUSH
82884: LD_INT 2
82886: EQUAL
82887: PUSH
82888: LD_VAR 0 1
82892: PPUSH
82893: CALL_OW 110
82897: PUSH
82898: LD_INT 20
82900: EQUAL
82901: PUSH
82902: LD_VAR 0 1
82906: PUSH
82907: LD_EXP 90
82911: PUSH
82912: LD_VAR 0 3
82916: ARRAY
82917: IN
82918: OR
82919: PUSH
82920: LD_VAR 0 1
82924: PPUSH
82925: CALL_OW 264
82929: PUSH
82930: LD_INT 12
82932: PUSH
82933: LD_INT 51
82935: PUSH
82936: LD_EXP 49
82940: PUSH
82941: LD_INT 32
82943: PUSH
82944: LD_INT 13
82946: PUSH
82947: LD_INT 52
82949: PUSH
82950: LD_INT 31
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: IN
82962: OR
82963: AND
82964: IFFALSE 83272
// begin if un in mc_defender [ i ] then
82966: LD_VAR 0 1
82970: PUSH
82971: LD_EXP 90
82975: PUSH
82976: LD_VAR 0 3
82980: ARRAY
82981: IN
82982: IFFALSE 83021
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82984: LD_ADDR_EXP 90
82988: PUSH
82989: LD_EXP 90
82993: PPUSH
82994: LD_VAR 0 3
82998: PPUSH
82999: LD_EXP 90
83003: PUSH
83004: LD_VAR 0 3
83008: ARRAY
83009: PUSH
83010: LD_VAR 0 1
83014: DIFF
83015: PPUSH
83016: CALL_OW 1
83020: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83021: LD_ADDR_VAR 0 8
83025: PUSH
83026: LD_VAR 0 3
83030: PPUSH
83031: LD_INT 3
83033: PPUSH
83034: CALL 79662 0 2
83038: ST_TO_ADDR
// if fac then
83039: LD_VAR 0 8
83043: IFFALSE 83272
// begin for j in fac do
83045: LD_ADDR_VAR 0 4
83049: PUSH
83050: LD_VAR 0 8
83054: PUSH
83055: FOR_IN
83056: IFFALSE 83270
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83058: LD_ADDR_VAR 0 9
83062: PUSH
83063: LD_VAR 0 8
83067: PPUSH
83068: LD_VAR 0 1
83072: PPUSH
83073: CALL_OW 265
83077: PPUSH
83078: LD_VAR 0 1
83082: PPUSH
83083: CALL_OW 262
83087: PPUSH
83088: LD_VAR 0 1
83092: PPUSH
83093: CALL_OW 263
83097: PPUSH
83098: LD_VAR 0 1
83102: PPUSH
83103: CALL_OW 264
83107: PPUSH
83108: CALL 16246 0 5
83112: ST_TO_ADDR
// if components then
83113: LD_VAR 0 9
83117: IFFALSE 83268
// begin if GetWeapon ( un ) = ar_control_tower then
83119: LD_VAR 0 1
83123: PPUSH
83124: CALL_OW 264
83128: PUSH
83129: LD_INT 31
83131: EQUAL
83132: IFFALSE 83249
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83134: LD_VAR 0 1
83138: PPUSH
83139: CALL_OW 311
83143: PPUSH
83144: LD_INT 0
83146: PPUSH
83147: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83151: LD_ADDR_EXP 108
83155: PUSH
83156: LD_EXP 108
83160: PPUSH
83161: LD_VAR 0 3
83165: PPUSH
83166: LD_EXP 108
83170: PUSH
83171: LD_VAR 0 3
83175: ARRAY
83176: PUSH
83177: LD_VAR 0 1
83181: PPUSH
83182: CALL_OW 311
83186: DIFF
83187: PPUSH
83188: CALL_OW 1
83192: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83193: LD_ADDR_VAR 0 7
83197: PUSH
83198: LD_EXP 89
83202: PUSH
83203: LD_VAR 0 3
83207: ARRAY
83208: PPUSH
83209: LD_INT 1
83211: PPUSH
83212: LD_VAR 0 9
83216: PPUSH
83217: CALL_OW 2
83221: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83222: LD_ADDR_EXP 89
83226: PUSH
83227: LD_EXP 89
83231: PPUSH
83232: LD_VAR 0 3
83236: PPUSH
83237: LD_VAR 0 7
83241: PPUSH
83242: CALL_OW 1
83246: ST_TO_ADDR
// end else
83247: GO 83266
// MC_InsertProduceList ( i , [ components ] ) ;
83249: LD_VAR 0 3
83253: PPUSH
83254: LD_VAR 0 9
83258: PUSH
83259: EMPTY
83260: LIST
83261: PPUSH
83262: CALL 79207 0 2
// break ;
83266: GO 83270
// end ; end ;
83268: GO 83055
83270: POP
83271: POP
// end ; end ; if GetType ( un ) = unit_building then
83272: LD_VAR 0 1
83276: PPUSH
83277: CALL_OW 247
83281: PUSH
83282: LD_INT 3
83284: EQUAL
83285: IFFALSE 83688
// begin btype := GetBType ( un ) ;
83287: LD_ADDR_VAR 0 5
83291: PUSH
83292: LD_VAR 0 1
83296: PPUSH
83297: CALL_OW 266
83301: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83302: LD_VAR 0 5
83306: PUSH
83307: LD_INT 29
83309: PUSH
83310: LD_INT 30
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: IN
83317: IFFALSE 83390
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83319: LD_VAR 0 1
83323: PPUSH
83324: CALL_OW 250
83328: PPUSH
83329: LD_VAR 0 1
83333: PPUSH
83334: CALL_OW 251
83338: PPUSH
83339: LD_VAR 0 1
83343: PPUSH
83344: CALL_OW 255
83348: PPUSH
83349: CALL_OW 440
83353: NOT
83354: IFFALSE 83390
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83356: LD_VAR 0 1
83360: PPUSH
83361: CALL_OW 250
83365: PPUSH
83366: LD_VAR 0 1
83370: PPUSH
83371: CALL_OW 251
83375: PPUSH
83376: LD_VAR 0 1
83380: PPUSH
83381: CALL_OW 255
83385: PPUSH
83386: CALL_OW 441
// end ; if btype = b_warehouse then
83390: LD_VAR 0 5
83394: PUSH
83395: LD_INT 1
83397: EQUAL
83398: IFFALSE 83416
// begin btype := b_depot ;
83400: LD_ADDR_VAR 0 5
83404: PUSH
83405: LD_INT 0
83407: ST_TO_ADDR
// pos := 1 ;
83408: LD_ADDR_VAR 0 6
83412: PUSH
83413: LD_INT 1
83415: ST_TO_ADDR
// end ; if btype = b_factory then
83416: LD_VAR 0 5
83420: PUSH
83421: LD_INT 3
83423: EQUAL
83424: IFFALSE 83442
// begin btype := b_workshop ;
83426: LD_ADDR_VAR 0 5
83430: PUSH
83431: LD_INT 2
83433: ST_TO_ADDR
// pos := 1 ;
83434: LD_ADDR_VAR 0 6
83438: PUSH
83439: LD_INT 1
83441: ST_TO_ADDR
// end ; if btype = b_barracks then
83442: LD_VAR 0 5
83446: PUSH
83447: LD_INT 5
83449: EQUAL
83450: IFFALSE 83460
// btype := b_armoury ;
83452: LD_ADDR_VAR 0 5
83456: PUSH
83457: LD_INT 4
83459: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83460: LD_VAR 0 5
83464: PUSH
83465: LD_INT 7
83467: PUSH
83468: LD_INT 8
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: IN
83475: IFFALSE 83485
// btype := b_lab ;
83477: LD_ADDR_VAR 0 5
83481: PUSH
83482: LD_INT 6
83484: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83485: LD_ADDR_EXP 73
83489: PUSH
83490: LD_EXP 73
83494: PPUSH
83495: LD_VAR 0 3
83499: PUSH
83500: LD_EXP 73
83504: PUSH
83505: LD_VAR 0 3
83509: ARRAY
83510: PUSH
83511: LD_INT 1
83513: PLUS
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PPUSH
83519: LD_VAR 0 5
83523: PUSH
83524: LD_VAR 0 1
83528: PPUSH
83529: CALL_OW 250
83533: PUSH
83534: LD_VAR 0 1
83538: PPUSH
83539: CALL_OW 251
83543: PUSH
83544: LD_VAR 0 1
83548: PPUSH
83549: CALL_OW 254
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: PPUSH
83560: CALL 18750 0 3
83564: ST_TO_ADDR
// if pos = 1 then
83565: LD_VAR 0 6
83569: PUSH
83570: LD_INT 1
83572: EQUAL
83573: IFFALSE 83688
// begin tmp := mc_build_list [ i ] ;
83575: LD_ADDR_VAR 0 7
83579: PUSH
83580: LD_EXP 73
83584: PUSH
83585: LD_VAR 0 3
83589: ARRAY
83590: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83591: LD_VAR 0 7
83595: PPUSH
83596: LD_INT 2
83598: PUSH
83599: LD_INT 30
83601: PUSH
83602: LD_INT 0
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 30
83611: PUSH
83612: LD_INT 1
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: EMPTY
83620: LIST
83621: LIST
83622: LIST
83623: PPUSH
83624: CALL_OW 72
83628: IFFALSE 83638
// pos := 2 ;
83630: LD_ADDR_VAR 0 6
83634: PUSH
83635: LD_INT 2
83637: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83638: LD_ADDR_VAR 0 7
83642: PUSH
83643: LD_VAR 0 7
83647: PPUSH
83648: LD_VAR 0 6
83652: PPUSH
83653: LD_VAR 0 7
83657: PPUSH
83658: CALL 19076 0 3
83662: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83663: LD_ADDR_EXP 73
83667: PUSH
83668: LD_EXP 73
83672: PPUSH
83673: LD_VAR 0 3
83677: PPUSH
83678: LD_VAR 0 7
83682: PPUSH
83683: CALL_OW 1
83687: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83688: LD_VAR 0 1
83692: PUSH
83693: LD_EXP 68
83697: PUSH
83698: LD_VAR 0 3
83702: ARRAY
83703: IN
83704: IFFALSE 83743
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83706: LD_ADDR_EXP 68
83710: PUSH
83711: LD_EXP 68
83715: PPUSH
83716: LD_VAR 0 3
83720: PPUSH
83721: LD_EXP 68
83725: PUSH
83726: LD_VAR 0 3
83730: ARRAY
83731: PUSH
83732: LD_VAR 0 1
83736: DIFF
83737: PPUSH
83738: CALL_OW 1
83742: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83743: LD_VAR 0 1
83747: PUSH
83748: LD_EXP 75
83752: PUSH
83753: LD_VAR 0 3
83757: ARRAY
83758: IN
83759: IFFALSE 83798
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83761: LD_ADDR_EXP 75
83765: PUSH
83766: LD_EXP 75
83770: PPUSH
83771: LD_VAR 0 3
83775: PPUSH
83776: LD_EXP 75
83780: PUSH
83781: LD_VAR 0 3
83785: ARRAY
83786: PUSH
83787: LD_VAR 0 1
83791: DIFF
83792: PPUSH
83793: CALL_OW 1
83797: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83798: LD_VAR 0 1
83802: PUSH
83803: LD_EXP 87
83807: PUSH
83808: LD_VAR 0 3
83812: ARRAY
83813: IN
83814: IFFALSE 83853
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83816: LD_ADDR_EXP 87
83820: PUSH
83821: LD_EXP 87
83825: PPUSH
83826: LD_VAR 0 3
83830: PPUSH
83831: LD_EXP 87
83835: PUSH
83836: LD_VAR 0 3
83840: ARRAY
83841: PUSH
83842: LD_VAR 0 1
83846: DIFF
83847: PPUSH
83848: CALL_OW 1
83852: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83853: LD_VAR 0 1
83857: PUSH
83858: LD_EXP 90
83862: PUSH
83863: LD_VAR 0 3
83867: ARRAY
83868: IN
83869: IFFALSE 83908
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83871: LD_ADDR_EXP 90
83875: PUSH
83876: LD_EXP 90
83880: PPUSH
83881: LD_VAR 0 3
83885: PPUSH
83886: LD_EXP 90
83890: PUSH
83891: LD_VAR 0 3
83895: ARRAY
83896: PUSH
83897: LD_VAR 0 1
83901: DIFF
83902: PPUSH
83903: CALL_OW 1
83907: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83908: LD_VAR 0 1
83912: PUSH
83913: LD_EXP 77
83917: PUSH
83918: LD_VAR 0 3
83922: ARRAY
83923: IN
83924: IFFALSE 83963
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83926: LD_ADDR_EXP 77
83930: PUSH
83931: LD_EXP 77
83935: PPUSH
83936: LD_VAR 0 3
83940: PPUSH
83941: LD_EXP 77
83945: PUSH
83946: LD_VAR 0 3
83950: ARRAY
83951: PUSH
83952: LD_VAR 0 1
83956: DIFF
83957: PPUSH
83958: CALL_OW 1
83962: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83963: LD_VAR 0 1
83967: PUSH
83968: LD_EXP 76
83972: PUSH
83973: LD_VAR 0 3
83977: ARRAY
83978: IN
83979: IFFALSE 84018
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83981: LD_ADDR_EXP 76
83985: PUSH
83986: LD_EXP 76
83990: PPUSH
83991: LD_VAR 0 3
83995: PPUSH
83996: LD_EXP 76
84000: PUSH
84001: LD_VAR 0 3
84005: ARRAY
84006: PUSH
84007: LD_VAR 0 1
84011: DIFF
84012: PPUSH
84013: CALL_OW 1
84017: ST_TO_ADDR
// end ; break ;
84018: GO 84022
// end ;
84020: GO 82668
84022: POP
84023: POP
// end ;
84024: LD_VAR 0 2
84028: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84029: LD_INT 0
84031: PPUSH
84032: PPUSH
84033: PPUSH
// if not mc_bases or not skirmish then
84034: LD_EXP 68
84038: NOT
84039: PUSH
84040: LD_EXP 66
84044: NOT
84045: OR
84046: IFFALSE 84050
// exit ;
84048: GO 84265
// for i = 1 to mc_bases do
84050: LD_ADDR_VAR 0 3
84054: PUSH
84055: DOUBLE
84056: LD_INT 1
84058: DEC
84059: ST_TO_ADDR
84060: LD_EXP 68
84064: PUSH
84065: FOR_TO
84066: IFFALSE 84263
// begin if building in mc_construct_list [ i ] then
84068: LD_VAR 0 1
84072: PUSH
84073: LD_EXP 75
84077: PUSH
84078: LD_VAR 0 3
84082: ARRAY
84083: IN
84084: IFFALSE 84261
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84086: LD_ADDR_EXP 75
84090: PUSH
84091: LD_EXP 75
84095: PPUSH
84096: LD_VAR 0 3
84100: PPUSH
84101: LD_EXP 75
84105: PUSH
84106: LD_VAR 0 3
84110: ARRAY
84111: PUSH
84112: LD_VAR 0 1
84116: DIFF
84117: PPUSH
84118: CALL_OW 1
84122: ST_TO_ADDR
// if building in mc_lab [ i ] then
84123: LD_VAR 0 1
84127: PUSH
84128: LD_EXP 101
84132: PUSH
84133: LD_VAR 0 3
84137: ARRAY
84138: IN
84139: IFFALSE 84194
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84141: LD_ADDR_EXP 102
84145: PUSH
84146: LD_EXP 102
84150: PPUSH
84151: LD_VAR 0 3
84155: PPUSH
84156: LD_EXP 102
84160: PUSH
84161: LD_VAR 0 3
84165: ARRAY
84166: PPUSH
84167: LD_INT 1
84169: PPUSH
84170: LD_EXP 102
84174: PUSH
84175: LD_VAR 0 3
84179: ARRAY
84180: PPUSH
84181: LD_INT 0
84183: PPUSH
84184: CALL 18168 0 4
84188: PPUSH
84189: CALL_OW 1
84193: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84194: LD_VAR 0 1
84198: PUSH
84199: LD_EXP 68
84203: PUSH
84204: LD_VAR 0 3
84208: ARRAY
84209: IN
84210: NOT
84211: IFFALSE 84257
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84213: LD_ADDR_EXP 68
84217: PUSH
84218: LD_EXP 68
84222: PPUSH
84223: LD_VAR 0 3
84227: PUSH
84228: LD_EXP 68
84232: PUSH
84233: LD_VAR 0 3
84237: ARRAY
84238: PUSH
84239: LD_INT 1
84241: PLUS
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PPUSH
84247: LD_VAR 0 1
84251: PPUSH
84252: CALL 18750 0 3
84256: ST_TO_ADDR
// exit ;
84257: POP
84258: POP
84259: GO 84265
// end ; end ;
84261: GO 84065
84263: POP
84264: POP
// end ;
84265: LD_VAR 0 2
84269: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84270: LD_INT 0
84272: PPUSH
84273: PPUSH
84274: PPUSH
84275: PPUSH
84276: PPUSH
84277: PPUSH
84278: PPUSH
// if not mc_bases or not skirmish then
84279: LD_EXP 68
84283: NOT
84284: PUSH
84285: LD_EXP 66
84289: NOT
84290: OR
84291: IFFALSE 84295
// exit ;
84293: GO 84956
// for i = 1 to mc_bases do
84295: LD_ADDR_VAR 0 3
84299: PUSH
84300: DOUBLE
84301: LD_INT 1
84303: DEC
84304: ST_TO_ADDR
84305: LD_EXP 68
84309: PUSH
84310: FOR_TO
84311: IFFALSE 84954
// begin if building in mc_construct_list [ i ] then
84313: LD_VAR 0 1
84317: PUSH
84318: LD_EXP 75
84322: PUSH
84323: LD_VAR 0 3
84327: ARRAY
84328: IN
84329: IFFALSE 84952
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84331: LD_ADDR_EXP 75
84335: PUSH
84336: LD_EXP 75
84340: PPUSH
84341: LD_VAR 0 3
84345: PPUSH
84346: LD_EXP 75
84350: PUSH
84351: LD_VAR 0 3
84355: ARRAY
84356: PUSH
84357: LD_VAR 0 1
84361: DIFF
84362: PPUSH
84363: CALL_OW 1
84367: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84368: LD_ADDR_EXP 68
84372: PUSH
84373: LD_EXP 68
84377: PPUSH
84378: LD_VAR 0 3
84382: PUSH
84383: LD_EXP 68
84387: PUSH
84388: LD_VAR 0 3
84392: ARRAY
84393: PUSH
84394: LD_INT 1
84396: PLUS
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PPUSH
84402: LD_VAR 0 1
84406: PPUSH
84407: CALL 18750 0 3
84411: ST_TO_ADDR
// btype := GetBType ( building ) ;
84412: LD_ADDR_VAR 0 5
84416: PUSH
84417: LD_VAR 0 1
84421: PPUSH
84422: CALL_OW 266
84426: ST_TO_ADDR
// side := GetSide ( building ) ;
84427: LD_ADDR_VAR 0 8
84431: PUSH
84432: LD_VAR 0 1
84436: PPUSH
84437: CALL_OW 255
84441: ST_TO_ADDR
// if btype = b_lab then
84442: LD_VAR 0 5
84446: PUSH
84447: LD_INT 6
84449: EQUAL
84450: IFFALSE 84500
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84452: LD_ADDR_EXP 101
84456: PUSH
84457: LD_EXP 101
84461: PPUSH
84462: LD_VAR 0 3
84466: PUSH
84467: LD_EXP 101
84471: PUSH
84472: LD_VAR 0 3
84476: ARRAY
84477: PUSH
84478: LD_INT 1
84480: PLUS
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PPUSH
84486: LD_VAR 0 1
84490: PPUSH
84491: CALL 18750 0 3
84495: ST_TO_ADDR
// exit ;
84496: POP
84497: POP
84498: GO 84956
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84500: LD_VAR 0 5
84504: PUSH
84505: LD_INT 0
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: LD_INT 4
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: LIST
84518: IN
84519: IFFALSE 84643
// begin if btype = b_armoury then
84521: LD_VAR 0 5
84525: PUSH
84526: LD_INT 4
84528: EQUAL
84529: IFFALSE 84539
// btype := b_barracks ;
84531: LD_ADDR_VAR 0 5
84535: PUSH
84536: LD_INT 5
84538: ST_TO_ADDR
// if btype = b_depot then
84539: LD_VAR 0 5
84543: PUSH
84544: LD_INT 0
84546: EQUAL
84547: IFFALSE 84557
// btype := b_warehouse ;
84549: LD_ADDR_VAR 0 5
84553: PUSH
84554: LD_INT 1
84556: ST_TO_ADDR
// if btype = b_workshop then
84557: LD_VAR 0 5
84561: PUSH
84562: LD_INT 2
84564: EQUAL
84565: IFFALSE 84575
// btype := b_factory ;
84567: LD_ADDR_VAR 0 5
84571: PUSH
84572: LD_INT 3
84574: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84575: LD_VAR 0 5
84579: PPUSH
84580: LD_VAR 0 8
84584: PPUSH
84585: CALL_OW 323
84589: PUSH
84590: LD_INT 1
84592: EQUAL
84593: IFFALSE 84639
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84595: LD_ADDR_EXP 100
84599: PUSH
84600: LD_EXP 100
84604: PPUSH
84605: LD_VAR 0 3
84609: PUSH
84610: LD_EXP 100
84614: PUSH
84615: LD_VAR 0 3
84619: ARRAY
84620: PUSH
84621: LD_INT 1
84623: PLUS
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PPUSH
84629: LD_VAR 0 1
84633: PPUSH
84634: CALL 18750 0 3
84638: ST_TO_ADDR
// exit ;
84639: POP
84640: POP
84641: GO 84956
// end ; if btype in [ b_bunker , b_turret ] then
84643: LD_VAR 0 5
84647: PUSH
84648: LD_INT 32
84650: PUSH
84651: LD_INT 33
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: IN
84658: IFFALSE 84948
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84660: LD_ADDR_EXP 76
84664: PUSH
84665: LD_EXP 76
84669: PPUSH
84670: LD_VAR 0 3
84674: PUSH
84675: LD_EXP 76
84679: PUSH
84680: LD_VAR 0 3
84684: ARRAY
84685: PUSH
84686: LD_INT 1
84688: PLUS
84689: PUSH
84690: EMPTY
84691: LIST
84692: LIST
84693: PPUSH
84694: LD_VAR 0 1
84698: PPUSH
84699: CALL 18750 0 3
84703: ST_TO_ADDR
// if btype = b_bunker then
84704: LD_VAR 0 5
84708: PUSH
84709: LD_INT 32
84711: EQUAL
84712: IFFALSE 84948
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84714: LD_ADDR_EXP 77
84718: PUSH
84719: LD_EXP 77
84723: PPUSH
84724: LD_VAR 0 3
84728: PUSH
84729: LD_EXP 77
84733: PUSH
84734: LD_VAR 0 3
84738: ARRAY
84739: PUSH
84740: LD_INT 1
84742: PLUS
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PPUSH
84748: LD_VAR 0 1
84752: PPUSH
84753: CALL 18750 0 3
84757: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84758: LD_ADDR_VAR 0 6
84762: PUSH
84763: LD_EXP 68
84767: PUSH
84768: LD_VAR 0 3
84772: ARRAY
84773: PPUSH
84774: LD_INT 25
84776: PUSH
84777: LD_INT 1
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 3
84786: PUSH
84787: LD_INT 54
84789: PUSH
84790: EMPTY
84791: LIST
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PPUSH
84801: CALL_OW 72
84805: ST_TO_ADDR
// if tmp then
84806: LD_VAR 0 6
84810: IFFALSE 84816
// exit ;
84812: POP
84813: POP
84814: GO 84956
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84816: LD_ADDR_VAR 0 6
84820: PUSH
84821: LD_EXP 68
84825: PUSH
84826: LD_VAR 0 3
84830: ARRAY
84831: PPUSH
84832: LD_INT 2
84834: PUSH
84835: LD_INT 30
84837: PUSH
84838: LD_INT 4
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 30
84847: PUSH
84848: LD_INT 5
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: LIST
84859: PPUSH
84860: CALL_OW 72
84864: ST_TO_ADDR
// if not tmp then
84865: LD_VAR 0 6
84869: NOT
84870: IFFALSE 84876
// exit ;
84872: POP
84873: POP
84874: GO 84956
// for j in tmp do
84876: LD_ADDR_VAR 0 4
84880: PUSH
84881: LD_VAR 0 6
84885: PUSH
84886: FOR_IN
84887: IFFALSE 84946
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84889: LD_ADDR_VAR 0 7
84893: PUSH
84894: LD_VAR 0 4
84898: PPUSH
84899: CALL_OW 313
84903: PPUSH
84904: LD_INT 25
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PPUSH
84914: CALL_OW 72
84918: ST_TO_ADDR
// if units then
84919: LD_VAR 0 7
84923: IFFALSE 84944
// begin ComExitBuilding ( units [ 1 ] ) ;
84925: LD_VAR 0 7
84929: PUSH
84930: LD_INT 1
84932: ARRAY
84933: PPUSH
84934: CALL_OW 122
// exit ;
84938: POP
84939: POP
84940: POP
84941: POP
84942: GO 84956
// end ; end ;
84944: GO 84886
84946: POP
84947: POP
// end ; end ; exit ;
84948: POP
84949: POP
84950: GO 84956
// end ; end ;
84952: GO 84310
84954: POP
84955: POP
// end ;
84956: LD_VAR 0 2
84960: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84961: LD_INT 0
84963: PPUSH
84964: PPUSH
84965: PPUSH
84966: PPUSH
84967: PPUSH
84968: PPUSH
84969: PPUSH
// if not mc_bases or not skirmish then
84970: LD_EXP 68
84974: NOT
84975: PUSH
84976: LD_EXP 66
84980: NOT
84981: OR
84982: IFFALSE 84986
// exit ;
84984: GO 85251
// btype := GetBType ( building ) ;
84986: LD_ADDR_VAR 0 6
84990: PUSH
84991: LD_VAR 0 1
84995: PPUSH
84996: CALL_OW 266
85000: ST_TO_ADDR
// x := GetX ( building ) ;
85001: LD_ADDR_VAR 0 7
85005: PUSH
85006: LD_VAR 0 1
85010: PPUSH
85011: CALL_OW 250
85015: ST_TO_ADDR
// y := GetY ( building ) ;
85016: LD_ADDR_VAR 0 8
85020: PUSH
85021: LD_VAR 0 1
85025: PPUSH
85026: CALL_OW 251
85030: ST_TO_ADDR
// d := GetDir ( building ) ;
85031: LD_ADDR_VAR 0 9
85035: PUSH
85036: LD_VAR 0 1
85040: PPUSH
85041: CALL_OW 254
85045: ST_TO_ADDR
// for i = 1 to mc_bases do
85046: LD_ADDR_VAR 0 4
85050: PUSH
85051: DOUBLE
85052: LD_INT 1
85054: DEC
85055: ST_TO_ADDR
85056: LD_EXP 68
85060: PUSH
85061: FOR_TO
85062: IFFALSE 85249
// begin if not mc_build_list [ i ] then
85064: LD_EXP 73
85068: PUSH
85069: LD_VAR 0 4
85073: ARRAY
85074: NOT
85075: IFFALSE 85079
// continue ;
85077: GO 85061
// for j := 1 to mc_build_list [ i ] do
85079: LD_ADDR_VAR 0 5
85083: PUSH
85084: DOUBLE
85085: LD_INT 1
85087: DEC
85088: ST_TO_ADDR
85089: LD_EXP 73
85093: PUSH
85094: LD_VAR 0 4
85098: ARRAY
85099: PUSH
85100: FOR_TO
85101: IFFALSE 85245
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85103: LD_VAR 0 6
85107: PUSH
85108: LD_VAR 0 7
85112: PUSH
85113: LD_VAR 0 8
85117: PUSH
85118: LD_VAR 0 9
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: PPUSH
85129: LD_EXP 73
85133: PUSH
85134: LD_VAR 0 4
85138: ARRAY
85139: PUSH
85140: LD_VAR 0 5
85144: ARRAY
85145: PPUSH
85146: CALL 24932 0 2
85150: IFFALSE 85243
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85152: LD_ADDR_EXP 73
85156: PUSH
85157: LD_EXP 73
85161: PPUSH
85162: LD_VAR 0 4
85166: PPUSH
85167: LD_EXP 73
85171: PUSH
85172: LD_VAR 0 4
85176: ARRAY
85177: PPUSH
85178: LD_VAR 0 5
85182: PPUSH
85183: CALL_OW 3
85187: PPUSH
85188: CALL_OW 1
85192: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85193: LD_ADDR_EXP 75
85197: PUSH
85198: LD_EXP 75
85202: PPUSH
85203: LD_VAR 0 4
85207: PUSH
85208: LD_EXP 75
85212: PUSH
85213: LD_VAR 0 4
85217: ARRAY
85218: PUSH
85219: LD_INT 1
85221: PLUS
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PPUSH
85227: LD_VAR 0 1
85231: PPUSH
85232: CALL 18750 0 3
85236: ST_TO_ADDR
// exit ;
85237: POP
85238: POP
85239: POP
85240: POP
85241: GO 85251
// end ;
85243: GO 85100
85245: POP
85246: POP
// end ;
85247: GO 85061
85249: POP
85250: POP
// end ;
85251: LD_VAR 0 3
85255: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85256: LD_INT 0
85258: PPUSH
85259: PPUSH
85260: PPUSH
// if not mc_bases or not skirmish then
85261: LD_EXP 68
85265: NOT
85266: PUSH
85267: LD_EXP 66
85271: NOT
85272: OR
85273: IFFALSE 85277
// exit ;
85275: GO 85467
// for i = 1 to mc_bases do
85277: LD_ADDR_VAR 0 4
85281: PUSH
85282: DOUBLE
85283: LD_INT 1
85285: DEC
85286: ST_TO_ADDR
85287: LD_EXP 68
85291: PUSH
85292: FOR_TO
85293: IFFALSE 85380
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85295: LD_VAR 0 1
85299: PUSH
85300: LD_EXP 76
85304: PUSH
85305: LD_VAR 0 4
85309: ARRAY
85310: IN
85311: PUSH
85312: LD_VAR 0 1
85316: PUSH
85317: LD_EXP 77
85321: PUSH
85322: LD_VAR 0 4
85326: ARRAY
85327: IN
85328: NOT
85329: AND
85330: IFFALSE 85378
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85332: LD_ADDR_EXP 77
85336: PUSH
85337: LD_EXP 77
85341: PPUSH
85342: LD_VAR 0 4
85346: PUSH
85347: LD_EXP 77
85351: PUSH
85352: LD_VAR 0 4
85356: ARRAY
85357: PUSH
85358: LD_INT 1
85360: PLUS
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PPUSH
85366: LD_VAR 0 1
85370: PPUSH
85371: CALL 18750 0 3
85375: ST_TO_ADDR
// break ;
85376: GO 85380
// end ; end ;
85378: GO 85292
85380: POP
85381: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85382: LD_VAR 0 1
85386: PPUSH
85387: CALL_OW 257
85391: PUSH
85392: LD_EXP 94
85396: IN
85397: PUSH
85398: LD_VAR 0 1
85402: PPUSH
85403: CALL_OW 266
85407: PUSH
85408: LD_INT 5
85410: EQUAL
85411: AND
85412: PUSH
85413: LD_VAR 0 2
85417: PPUSH
85418: CALL_OW 110
85422: PUSH
85423: LD_INT 18
85425: NONEQUAL
85426: AND
85427: IFFALSE 85467
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85429: LD_VAR 0 2
85433: PPUSH
85434: CALL_OW 257
85438: PUSH
85439: LD_INT 5
85441: PUSH
85442: LD_INT 8
85444: PUSH
85445: LD_INT 9
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: LIST
85452: IN
85453: IFFALSE 85467
// SetClass ( unit , 1 ) ;
85455: LD_VAR 0 2
85459: PPUSH
85460: LD_INT 1
85462: PPUSH
85463: CALL_OW 336
// end ;
85467: LD_VAR 0 3
85471: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85472: LD_INT 0
85474: PPUSH
85475: PPUSH
// if not mc_bases or not skirmish then
85476: LD_EXP 68
85480: NOT
85481: PUSH
85482: LD_EXP 66
85486: NOT
85487: OR
85488: IFFALSE 85492
// exit ;
85490: GO 85608
// if GetLives ( abandoned_vehicle ) > 250 then
85492: LD_VAR 0 2
85496: PPUSH
85497: CALL_OW 256
85501: PUSH
85502: LD_INT 250
85504: GREATER
85505: IFFALSE 85509
// exit ;
85507: GO 85608
// for i = 1 to mc_bases do
85509: LD_ADDR_VAR 0 6
85513: PUSH
85514: DOUBLE
85515: LD_INT 1
85517: DEC
85518: ST_TO_ADDR
85519: LD_EXP 68
85523: PUSH
85524: FOR_TO
85525: IFFALSE 85606
// begin if driver in mc_bases [ i ] then
85527: LD_VAR 0 1
85531: PUSH
85532: LD_EXP 68
85536: PUSH
85537: LD_VAR 0 6
85541: ARRAY
85542: IN
85543: IFFALSE 85604
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85545: LD_VAR 0 1
85549: PPUSH
85550: LD_EXP 68
85554: PUSH
85555: LD_VAR 0 6
85559: ARRAY
85560: PPUSH
85561: LD_INT 2
85563: PUSH
85564: LD_INT 30
85566: PUSH
85567: LD_INT 0
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 30
85576: PUSH
85577: LD_INT 1
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: LIST
85588: PPUSH
85589: CALL_OW 72
85593: PUSH
85594: LD_INT 1
85596: ARRAY
85597: PPUSH
85598: CALL 51889 0 2
// break ;
85602: GO 85606
// end ; end ;
85604: GO 85524
85606: POP
85607: POP
// end ; end_of_file end_of_file
85608: LD_VAR 0 5
85612: RET
// every 0 0$1 do
85613: GO 85615
85615: DISABLE
// begin enable ;
85616: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85617: LD_STRING updateTimer(
85619: PUSH
85620: LD_OWVAR 1
85624: STR
85625: PUSH
85626: LD_STRING );
85628: STR
85629: PPUSH
85630: CALL_OW 559
// end ;
85634: END
// export function SOS_MapStart ( ) ; begin
85635: LD_INT 0
85637: PPUSH
// if streamModeActive then
85638: LD_EXP 112
85642: IFFALSE 85651
// DefineStreamItems ( true ) ;
85644: LD_INT 1
85646: PPUSH
85647: CALL 87305 0 1
// UpdateFactoryWaypoints ( ) ;
85651: CALL 100166 0 0
// UpdateWarehouseGatheringPoints ( ) ;
85655: CALL 100423 0 0
// end ;
85659: LD_VAR 0 1
85663: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85664: LD_INT 0
85666: PPUSH
// if p2 = 100 then
85667: LD_VAR 0 2
85671: PUSH
85672: LD_INT 100
85674: EQUAL
85675: IFFALSE 86678
// begin if not StreamModeActive then
85677: LD_EXP 112
85681: NOT
85682: IFFALSE 85692
// StreamModeActive := true ;
85684: LD_ADDR_EXP 112
85688: PUSH
85689: LD_INT 1
85691: ST_TO_ADDR
// if p3 = 0 then
85692: LD_VAR 0 3
85696: PUSH
85697: LD_INT 0
85699: EQUAL
85700: IFFALSE 85706
// InitStreamMode ;
85702: CALL 86841 0 0
// if p3 = 1 then
85706: LD_VAR 0 3
85710: PUSH
85711: LD_INT 1
85713: EQUAL
85714: IFFALSE 85724
// sRocket := true ;
85716: LD_ADDR_EXP 117
85720: PUSH
85721: LD_INT 1
85723: ST_TO_ADDR
// if p3 = 2 then
85724: LD_VAR 0 3
85728: PUSH
85729: LD_INT 2
85731: EQUAL
85732: IFFALSE 85742
// sSpeed := true ;
85734: LD_ADDR_EXP 116
85738: PUSH
85739: LD_INT 1
85741: ST_TO_ADDR
// if p3 = 3 then
85742: LD_VAR 0 3
85746: PUSH
85747: LD_INT 3
85749: EQUAL
85750: IFFALSE 85760
// sEngine := true ;
85752: LD_ADDR_EXP 118
85756: PUSH
85757: LD_INT 1
85759: ST_TO_ADDR
// if p3 = 4 then
85760: LD_VAR 0 3
85764: PUSH
85765: LD_INT 4
85767: EQUAL
85768: IFFALSE 85778
// sSpec := true ;
85770: LD_ADDR_EXP 115
85774: PUSH
85775: LD_INT 1
85777: ST_TO_ADDR
// if p3 = 5 then
85778: LD_VAR 0 3
85782: PUSH
85783: LD_INT 5
85785: EQUAL
85786: IFFALSE 85796
// sLevel := true ;
85788: LD_ADDR_EXP 119
85792: PUSH
85793: LD_INT 1
85795: ST_TO_ADDR
// if p3 = 6 then
85796: LD_VAR 0 3
85800: PUSH
85801: LD_INT 6
85803: EQUAL
85804: IFFALSE 85814
// sArmoury := true ;
85806: LD_ADDR_EXP 120
85810: PUSH
85811: LD_INT 1
85813: ST_TO_ADDR
// if p3 = 7 then
85814: LD_VAR 0 3
85818: PUSH
85819: LD_INT 7
85821: EQUAL
85822: IFFALSE 85832
// sRadar := true ;
85824: LD_ADDR_EXP 121
85828: PUSH
85829: LD_INT 1
85831: ST_TO_ADDR
// if p3 = 8 then
85832: LD_VAR 0 3
85836: PUSH
85837: LD_INT 8
85839: EQUAL
85840: IFFALSE 85850
// sBunker := true ;
85842: LD_ADDR_EXP 122
85846: PUSH
85847: LD_INT 1
85849: ST_TO_ADDR
// if p3 = 9 then
85850: LD_VAR 0 3
85854: PUSH
85855: LD_INT 9
85857: EQUAL
85858: IFFALSE 85868
// sHack := true ;
85860: LD_ADDR_EXP 123
85864: PUSH
85865: LD_INT 1
85867: ST_TO_ADDR
// if p3 = 10 then
85868: LD_VAR 0 3
85872: PUSH
85873: LD_INT 10
85875: EQUAL
85876: IFFALSE 85886
// sFire := true ;
85878: LD_ADDR_EXP 124
85882: PUSH
85883: LD_INT 1
85885: ST_TO_ADDR
// if p3 = 11 then
85886: LD_VAR 0 3
85890: PUSH
85891: LD_INT 11
85893: EQUAL
85894: IFFALSE 85904
// sRefresh := true ;
85896: LD_ADDR_EXP 125
85900: PUSH
85901: LD_INT 1
85903: ST_TO_ADDR
// if p3 = 12 then
85904: LD_VAR 0 3
85908: PUSH
85909: LD_INT 12
85911: EQUAL
85912: IFFALSE 85922
// sExp := true ;
85914: LD_ADDR_EXP 126
85918: PUSH
85919: LD_INT 1
85921: ST_TO_ADDR
// if p3 = 13 then
85922: LD_VAR 0 3
85926: PUSH
85927: LD_INT 13
85929: EQUAL
85930: IFFALSE 85940
// sDepot := true ;
85932: LD_ADDR_EXP 127
85936: PUSH
85937: LD_INT 1
85939: ST_TO_ADDR
// if p3 = 14 then
85940: LD_VAR 0 3
85944: PUSH
85945: LD_INT 14
85947: EQUAL
85948: IFFALSE 85958
// sFlag := true ;
85950: LD_ADDR_EXP 128
85954: PUSH
85955: LD_INT 1
85957: ST_TO_ADDR
// if p3 = 15 then
85958: LD_VAR 0 3
85962: PUSH
85963: LD_INT 15
85965: EQUAL
85966: IFFALSE 85976
// sKamikadze := true ;
85968: LD_ADDR_EXP 136
85972: PUSH
85973: LD_INT 1
85975: ST_TO_ADDR
// if p3 = 16 then
85976: LD_VAR 0 3
85980: PUSH
85981: LD_INT 16
85983: EQUAL
85984: IFFALSE 85994
// sTroll := true ;
85986: LD_ADDR_EXP 137
85990: PUSH
85991: LD_INT 1
85993: ST_TO_ADDR
// if p3 = 17 then
85994: LD_VAR 0 3
85998: PUSH
85999: LD_INT 17
86001: EQUAL
86002: IFFALSE 86012
// sSlow := true ;
86004: LD_ADDR_EXP 138
86008: PUSH
86009: LD_INT 1
86011: ST_TO_ADDR
// if p3 = 18 then
86012: LD_VAR 0 3
86016: PUSH
86017: LD_INT 18
86019: EQUAL
86020: IFFALSE 86030
// sLack := true ;
86022: LD_ADDR_EXP 139
86026: PUSH
86027: LD_INT 1
86029: ST_TO_ADDR
// if p3 = 19 then
86030: LD_VAR 0 3
86034: PUSH
86035: LD_INT 19
86037: EQUAL
86038: IFFALSE 86048
// sTank := true ;
86040: LD_ADDR_EXP 141
86044: PUSH
86045: LD_INT 1
86047: ST_TO_ADDR
// if p3 = 20 then
86048: LD_VAR 0 3
86052: PUSH
86053: LD_INT 20
86055: EQUAL
86056: IFFALSE 86066
// sRemote := true ;
86058: LD_ADDR_EXP 142
86062: PUSH
86063: LD_INT 1
86065: ST_TO_ADDR
// if p3 = 21 then
86066: LD_VAR 0 3
86070: PUSH
86071: LD_INT 21
86073: EQUAL
86074: IFFALSE 86084
// sPowell := true ;
86076: LD_ADDR_EXP 143
86080: PUSH
86081: LD_INT 1
86083: ST_TO_ADDR
// if p3 = 22 then
86084: LD_VAR 0 3
86088: PUSH
86089: LD_INT 22
86091: EQUAL
86092: IFFALSE 86102
// sTeleport := true ;
86094: LD_ADDR_EXP 146
86098: PUSH
86099: LD_INT 1
86101: ST_TO_ADDR
// if p3 = 23 then
86102: LD_VAR 0 3
86106: PUSH
86107: LD_INT 23
86109: EQUAL
86110: IFFALSE 86120
// sOilTower := true ;
86112: LD_ADDR_EXP 148
86116: PUSH
86117: LD_INT 1
86119: ST_TO_ADDR
// if p3 = 24 then
86120: LD_VAR 0 3
86124: PUSH
86125: LD_INT 24
86127: EQUAL
86128: IFFALSE 86138
// sShovel := true ;
86130: LD_ADDR_EXP 149
86134: PUSH
86135: LD_INT 1
86137: ST_TO_ADDR
// if p3 = 25 then
86138: LD_VAR 0 3
86142: PUSH
86143: LD_INT 25
86145: EQUAL
86146: IFFALSE 86156
// sSheik := true ;
86148: LD_ADDR_EXP 150
86152: PUSH
86153: LD_INT 1
86155: ST_TO_ADDR
// if p3 = 26 then
86156: LD_VAR 0 3
86160: PUSH
86161: LD_INT 26
86163: EQUAL
86164: IFFALSE 86174
// sEarthquake := true ;
86166: LD_ADDR_EXP 152
86170: PUSH
86171: LD_INT 1
86173: ST_TO_ADDR
// if p3 = 27 then
86174: LD_VAR 0 3
86178: PUSH
86179: LD_INT 27
86181: EQUAL
86182: IFFALSE 86192
// sAI := true ;
86184: LD_ADDR_EXP 153
86188: PUSH
86189: LD_INT 1
86191: ST_TO_ADDR
// if p3 = 28 then
86192: LD_VAR 0 3
86196: PUSH
86197: LD_INT 28
86199: EQUAL
86200: IFFALSE 86210
// sCargo := true ;
86202: LD_ADDR_EXP 156
86206: PUSH
86207: LD_INT 1
86209: ST_TO_ADDR
// if p3 = 29 then
86210: LD_VAR 0 3
86214: PUSH
86215: LD_INT 29
86217: EQUAL
86218: IFFALSE 86228
// sDLaser := true ;
86220: LD_ADDR_EXP 157
86224: PUSH
86225: LD_INT 1
86227: ST_TO_ADDR
// if p3 = 30 then
86228: LD_VAR 0 3
86232: PUSH
86233: LD_INT 30
86235: EQUAL
86236: IFFALSE 86246
// sExchange := true ;
86238: LD_ADDR_EXP 158
86242: PUSH
86243: LD_INT 1
86245: ST_TO_ADDR
// if p3 = 31 then
86246: LD_VAR 0 3
86250: PUSH
86251: LD_INT 31
86253: EQUAL
86254: IFFALSE 86264
// sFac := true ;
86256: LD_ADDR_EXP 159
86260: PUSH
86261: LD_INT 1
86263: ST_TO_ADDR
// if p3 = 32 then
86264: LD_VAR 0 3
86268: PUSH
86269: LD_INT 32
86271: EQUAL
86272: IFFALSE 86282
// sPower := true ;
86274: LD_ADDR_EXP 160
86278: PUSH
86279: LD_INT 1
86281: ST_TO_ADDR
// if p3 = 33 then
86282: LD_VAR 0 3
86286: PUSH
86287: LD_INT 33
86289: EQUAL
86290: IFFALSE 86300
// sRandom := true ;
86292: LD_ADDR_EXP 161
86296: PUSH
86297: LD_INT 1
86299: ST_TO_ADDR
// if p3 = 34 then
86300: LD_VAR 0 3
86304: PUSH
86305: LD_INT 34
86307: EQUAL
86308: IFFALSE 86318
// sShield := true ;
86310: LD_ADDR_EXP 162
86314: PUSH
86315: LD_INT 1
86317: ST_TO_ADDR
// if p3 = 35 then
86318: LD_VAR 0 3
86322: PUSH
86323: LD_INT 35
86325: EQUAL
86326: IFFALSE 86336
// sTime := true ;
86328: LD_ADDR_EXP 163
86332: PUSH
86333: LD_INT 1
86335: ST_TO_ADDR
// if p3 = 36 then
86336: LD_VAR 0 3
86340: PUSH
86341: LD_INT 36
86343: EQUAL
86344: IFFALSE 86354
// sTools := true ;
86346: LD_ADDR_EXP 164
86350: PUSH
86351: LD_INT 1
86353: ST_TO_ADDR
// if p3 = 101 then
86354: LD_VAR 0 3
86358: PUSH
86359: LD_INT 101
86361: EQUAL
86362: IFFALSE 86372
// sSold := true ;
86364: LD_ADDR_EXP 129
86368: PUSH
86369: LD_INT 1
86371: ST_TO_ADDR
// if p3 = 102 then
86372: LD_VAR 0 3
86376: PUSH
86377: LD_INT 102
86379: EQUAL
86380: IFFALSE 86390
// sDiff := true ;
86382: LD_ADDR_EXP 130
86386: PUSH
86387: LD_INT 1
86389: ST_TO_ADDR
// if p3 = 103 then
86390: LD_VAR 0 3
86394: PUSH
86395: LD_INT 103
86397: EQUAL
86398: IFFALSE 86408
// sFog := true ;
86400: LD_ADDR_EXP 133
86404: PUSH
86405: LD_INT 1
86407: ST_TO_ADDR
// if p3 = 104 then
86408: LD_VAR 0 3
86412: PUSH
86413: LD_INT 104
86415: EQUAL
86416: IFFALSE 86426
// sReset := true ;
86418: LD_ADDR_EXP 134
86422: PUSH
86423: LD_INT 1
86425: ST_TO_ADDR
// if p3 = 105 then
86426: LD_VAR 0 3
86430: PUSH
86431: LD_INT 105
86433: EQUAL
86434: IFFALSE 86444
// sSun := true ;
86436: LD_ADDR_EXP 135
86440: PUSH
86441: LD_INT 1
86443: ST_TO_ADDR
// if p3 = 106 then
86444: LD_VAR 0 3
86448: PUSH
86449: LD_INT 106
86451: EQUAL
86452: IFFALSE 86462
// sTiger := true ;
86454: LD_ADDR_EXP 131
86458: PUSH
86459: LD_INT 1
86461: ST_TO_ADDR
// if p3 = 107 then
86462: LD_VAR 0 3
86466: PUSH
86467: LD_INT 107
86469: EQUAL
86470: IFFALSE 86480
// sBomb := true ;
86472: LD_ADDR_EXP 132
86476: PUSH
86477: LD_INT 1
86479: ST_TO_ADDR
// if p3 = 108 then
86480: LD_VAR 0 3
86484: PUSH
86485: LD_INT 108
86487: EQUAL
86488: IFFALSE 86498
// sWound := true ;
86490: LD_ADDR_EXP 140
86494: PUSH
86495: LD_INT 1
86497: ST_TO_ADDR
// if p3 = 109 then
86498: LD_VAR 0 3
86502: PUSH
86503: LD_INT 109
86505: EQUAL
86506: IFFALSE 86516
// sBetray := true ;
86508: LD_ADDR_EXP 144
86512: PUSH
86513: LD_INT 1
86515: ST_TO_ADDR
// if p3 = 110 then
86516: LD_VAR 0 3
86520: PUSH
86521: LD_INT 110
86523: EQUAL
86524: IFFALSE 86534
// sContamin := true ;
86526: LD_ADDR_EXP 145
86530: PUSH
86531: LD_INT 1
86533: ST_TO_ADDR
// if p3 = 111 then
86534: LD_VAR 0 3
86538: PUSH
86539: LD_INT 111
86541: EQUAL
86542: IFFALSE 86552
// sOil := true ;
86544: LD_ADDR_EXP 147
86548: PUSH
86549: LD_INT 1
86551: ST_TO_ADDR
// if p3 = 112 then
86552: LD_VAR 0 3
86556: PUSH
86557: LD_INT 112
86559: EQUAL
86560: IFFALSE 86570
// sStu := true ;
86562: LD_ADDR_EXP 151
86566: PUSH
86567: LD_INT 1
86569: ST_TO_ADDR
// if p3 = 113 then
86570: LD_VAR 0 3
86574: PUSH
86575: LD_INT 113
86577: EQUAL
86578: IFFALSE 86588
// sBazooka := true ;
86580: LD_ADDR_EXP 154
86584: PUSH
86585: LD_INT 1
86587: ST_TO_ADDR
// if p3 = 114 then
86588: LD_VAR 0 3
86592: PUSH
86593: LD_INT 114
86595: EQUAL
86596: IFFALSE 86606
// sMortar := true ;
86598: LD_ADDR_EXP 155
86602: PUSH
86603: LD_INT 1
86605: ST_TO_ADDR
// if p3 = 115 then
86606: LD_VAR 0 3
86610: PUSH
86611: LD_INT 115
86613: EQUAL
86614: IFFALSE 86624
// sRanger := true ;
86616: LD_ADDR_EXP 165
86620: PUSH
86621: LD_INT 1
86623: ST_TO_ADDR
// if p3 = 116 then
86624: LD_VAR 0 3
86628: PUSH
86629: LD_INT 116
86631: EQUAL
86632: IFFALSE 86642
// sComputer := true ;
86634: LD_ADDR_EXP 166
86638: PUSH
86639: LD_INT 1
86641: ST_TO_ADDR
// if p3 = 117 then
86642: LD_VAR 0 3
86646: PUSH
86647: LD_INT 117
86649: EQUAL
86650: IFFALSE 86660
// s30 := true ;
86652: LD_ADDR_EXP 167
86656: PUSH
86657: LD_INT 1
86659: ST_TO_ADDR
// if p3 = 118 then
86660: LD_VAR 0 3
86664: PUSH
86665: LD_INT 118
86667: EQUAL
86668: IFFALSE 86678
// s60 := true ;
86670: LD_ADDR_EXP 168
86674: PUSH
86675: LD_INT 1
86677: ST_TO_ADDR
// end ; if p2 = 101 then
86678: LD_VAR 0 2
86682: PUSH
86683: LD_INT 101
86685: EQUAL
86686: IFFALSE 86814
// begin case p3 of 1 :
86688: LD_VAR 0 3
86692: PUSH
86693: LD_INT 1
86695: DOUBLE
86696: EQUAL
86697: IFTRUE 86701
86699: GO 86708
86701: POP
// hHackUnlimitedResources ; 2 :
86702: CALL 98912 0 0
86706: GO 86814
86708: LD_INT 2
86710: DOUBLE
86711: EQUAL
86712: IFTRUE 86716
86714: GO 86723
86716: POP
// hHackSetLevel10 ; 3 :
86717: CALL 99045 0 0
86721: GO 86814
86723: LD_INT 3
86725: DOUBLE
86726: EQUAL
86727: IFTRUE 86731
86729: GO 86738
86731: POP
// hHackSetLevel10YourUnits ; 4 :
86732: CALL 99130 0 0
86736: GO 86814
86738: LD_INT 4
86740: DOUBLE
86741: EQUAL
86742: IFTRUE 86746
86744: GO 86753
86746: POP
// hHackInvincible ; 5 :
86747: CALL 99578 0 0
86751: GO 86814
86753: LD_INT 5
86755: DOUBLE
86756: EQUAL
86757: IFTRUE 86761
86759: GO 86768
86761: POP
// hHackInvisible ; 6 :
86762: CALL 99689 0 0
86766: GO 86814
86768: LD_INT 6
86770: DOUBLE
86771: EQUAL
86772: IFTRUE 86776
86774: GO 86783
86776: POP
// hHackChangeYourSide ; 7 :
86777: CALL 99746 0 0
86781: GO 86814
86783: LD_INT 7
86785: DOUBLE
86786: EQUAL
86787: IFTRUE 86791
86789: GO 86798
86791: POP
// hHackChangeUnitSide ; 8 :
86792: CALL 99788 0 0
86796: GO 86814
86798: LD_INT 8
86800: DOUBLE
86801: EQUAL
86802: IFTRUE 86806
86804: GO 86813
86806: POP
// hHackFog ; end ;
86807: CALL 99889 0 0
86811: GO 86814
86813: POP
// end ; end ;
86814: LD_VAR 0 7
86818: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
86819: GO 86821
86821: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86822: LD_STRING initStreamRollete();
86824: PPUSH
86825: CALL_OW 559
// InitStreamMode ;
86829: CALL 86841 0 0
// DefineStreamItems ( false ) ;
86833: LD_INT 0
86835: PPUSH
86836: CALL 87305 0 1
// end ;
86840: END
// function InitStreamMode ; begin
86841: LD_INT 0
86843: PPUSH
// streamModeActive := false ;
86844: LD_ADDR_EXP 112
86848: PUSH
86849: LD_INT 0
86851: ST_TO_ADDR
// normalCounter := 36 ;
86852: LD_ADDR_EXP 113
86856: PUSH
86857: LD_INT 36
86859: ST_TO_ADDR
// hardcoreCounter := 18 ;
86860: LD_ADDR_EXP 114
86864: PUSH
86865: LD_INT 18
86867: ST_TO_ADDR
// sRocket := false ;
86868: LD_ADDR_EXP 117
86872: PUSH
86873: LD_INT 0
86875: ST_TO_ADDR
// sSpeed := false ;
86876: LD_ADDR_EXP 116
86880: PUSH
86881: LD_INT 0
86883: ST_TO_ADDR
// sEngine := false ;
86884: LD_ADDR_EXP 118
86888: PUSH
86889: LD_INT 0
86891: ST_TO_ADDR
// sSpec := false ;
86892: LD_ADDR_EXP 115
86896: PUSH
86897: LD_INT 0
86899: ST_TO_ADDR
// sLevel := false ;
86900: LD_ADDR_EXP 119
86904: PUSH
86905: LD_INT 0
86907: ST_TO_ADDR
// sArmoury := false ;
86908: LD_ADDR_EXP 120
86912: PUSH
86913: LD_INT 0
86915: ST_TO_ADDR
// sRadar := false ;
86916: LD_ADDR_EXP 121
86920: PUSH
86921: LD_INT 0
86923: ST_TO_ADDR
// sBunker := false ;
86924: LD_ADDR_EXP 122
86928: PUSH
86929: LD_INT 0
86931: ST_TO_ADDR
// sHack := false ;
86932: LD_ADDR_EXP 123
86936: PUSH
86937: LD_INT 0
86939: ST_TO_ADDR
// sFire := false ;
86940: LD_ADDR_EXP 124
86944: PUSH
86945: LD_INT 0
86947: ST_TO_ADDR
// sRefresh := false ;
86948: LD_ADDR_EXP 125
86952: PUSH
86953: LD_INT 0
86955: ST_TO_ADDR
// sExp := false ;
86956: LD_ADDR_EXP 126
86960: PUSH
86961: LD_INT 0
86963: ST_TO_ADDR
// sDepot := false ;
86964: LD_ADDR_EXP 127
86968: PUSH
86969: LD_INT 0
86971: ST_TO_ADDR
// sFlag := false ;
86972: LD_ADDR_EXP 128
86976: PUSH
86977: LD_INT 0
86979: ST_TO_ADDR
// sKamikadze := false ;
86980: LD_ADDR_EXP 136
86984: PUSH
86985: LD_INT 0
86987: ST_TO_ADDR
// sTroll := false ;
86988: LD_ADDR_EXP 137
86992: PUSH
86993: LD_INT 0
86995: ST_TO_ADDR
// sSlow := false ;
86996: LD_ADDR_EXP 138
87000: PUSH
87001: LD_INT 0
87003: ST_TO_ADDR
// sLack := false ;
87004: LD_ADDR_EXP 139
87008: PUSH
87009: LD_INT 0
87011: ST_TO_ADDR
// sTank := false ;
87012: LD_ADDR_EXP 141
87016: PUSH
87017: LD_INT 0
87019: ST_TO_ADDR
// sRemote := false ;
87020: LD_ADDR_EXP 142
87024: PUSH
87025: LD_INT 0
87027: ST_TO_ADDR
// sPowell := false ;
87028: LD_ADDR_EXP 143
87032: PUSH
87033: LD_INT 0
87035: ST_TO_ADDR
// sTeleport := false ;
87036: LD_ADDR_EXP 146
87040: PUSH
87041: LD_INT 0
87043: ST_TO_ADDR
// sOilTower := false ;
87044: LD_ADDR_EXP 148
87048: PUSH
87049: LD_INT 0
87051: ST_TO_ADDR
// sShovel := false ;
87052: LD_ADDR_EXP 149
87056: PUSH
87057: LD_INT 0
87059: ST_TO_ADDR
// sSheik := false ;
87060: LD_ADDR_EXP 150
87064: PUSH
87065: LD_INT 0
87067: ST_TO_ADDR
// sEarthquake := false ;
87068: LD_ADDR_EXP 152
87072: PUSH
87073: LD_INT 0
87075: ST_TO_ADDR
// sAI := false ;
87076: LD_ADDR_EXP 153
87080: PUSH
87081: LD_INT 0
87083: ST_TO_ADDR
// sCargo := false ;
87084: LD_ADDR_EXP 156
87088: PUSH
87089: LD_INT 0
87091: ST_TO_ADDR
// sDLaser := false ;
87092: LD_ADDR_EXP 157
87096: PUSH
87097: LD_INT 0
87099: ST_TO_ADDR
// sExchange := false ;
87100: LD_ADDR_EXP 158
87104: PUSH
87105: LD_INT 0
87107: ST_TO_ADDR
// sFac := false ;
87108: LD_ADDR_EXP 159
87112: PUSH
87113: LD_INT 0
87115: ST_TO_ADDR
// sPower := false ;
87116: LD_ADDR_EXP 160
87120: PUSH
87121: LD_INT 0
87123: ST_TO_ADDR
// sRandom := false ;
87124: LD_ADDR_EXP 161
87128: PUSH
87129: LD_INT 0
87131: ST_TO_ADDR
// sShield := false ;
87132: LD_ADDR_EXP 162
87136: PUSH
87137: LD_INT 0
87139: ST_TO_ADDR
// sTime := false ;
87140: LD_ADDR_EXP 163
87144: PUSH
87145: LD_INT 0
87147: ST_TO_ADDR
// sTools := false ;
87148: LD_ADDR_EXP 164
87152: PUSH
87153: LD_INT 0
87155: ST_TO_ADDR
// sSold := false ;
87156: LD_ADDR_EXP 129
87160: PUSH
87161: LD_INT 0
87163: ST_TO_ADDR
// sDiff := false ;
87164: LD_ADDR_EXP 130
87168: PUSH
87169: LD_INT 0
87171: ST_TO_ADDR
// sFog := false ;
87172: LD_ADDR_EXP 133
87176: PUSH
87177: LD_INT 0
87179: ST_TO_ADDR
// sReset := false ;
87180: LD_ADDR_EXP 134
87184: PUSH
87185: LD_INT 0
87187: ST_TO_ADDR
// sSun := false ;
87188: LD_ADDR_EXP 135
87192: PUSH
87193: LD_INT 0
87195: ST_TO_ADDR
// sTiger := false ;
87196: LD_ADDR_EXP 131
87200: PUSH
87201: LD_INT 0
87203: ST_TO_ADDR
// sBomb := false ;
87204: LD_ADDR_EXP 132
87208: PUSH
87209: LD_INT 0
87211: ST_TO_ADDR
// sWound := false ;
87212: LD_ADDR_EXP 140
87216: PUSH
87217: LD_INT 0
87219: ST_TO_ADDR
// sBetray := false ;
87220: LD_ADDR_EXP 144
87224: PUSH
87225: LD_INT 0
87227: ST_TO_ADDR
// sContamin := false ;
87228: LD_ADDR_EXP 145
87232: PUSH
87233: LD_INT 0
87235: ST_TO_ADDR
// sOil := false ;
87236: LD_ADDR_EXP 147
87240: PUSH
87241: LD_INT 0
87243: ST_TO_ADDR
// sStu := false ;
87244: LD_ADDR_EXP 151
87248: PUSH
87249: LD_INT 0
87251: ST_TO_ADDR
// sBazooka := false ;
87252: LD_ADDR_EXP 154
87256: PUSH
87257: LD_INT 0
87259: ST_TO_ADDR
// sMortar := false ;
87260: LD_ADDR_EXP 155
87264: PUSH
87265: LD_INT 0
87267: ST_TO_ADDR
// sRanger := false ;
87268: LD_ADDR_EXP 165
87272: PUSH
87273: LD_INT 0
87275: ST_TO_ADDR
// sComputer := false ;
87276: LD_ADDR_EXP 166
87280: PUSH
87281: LD_INT 0
87283: ST_TO_ADDR
// s30 := false ;
87284: LD_ADDR_EXP 167
87288: PUSH
87289: LD_INT 0
87291: ST_TO_ADDR
// s60 := false ;
87292: LD_ADDR_EXP 168
87296: PUSH
87297: LD_INT 0
87299: ST_TO_ADDR
// end ;
87300: LD_VAR 0 1
87304: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87305: LD_INT 0
87307: PPUSH
87308: PPUSH
87309: PPUSH
87310: PPUSH
87311: PPUSH
87312: PPUSH
87313: PPUSH
// result := [ ] ;
87314: LD_ADDR_VAR 0 2
87318: PUSH
87319: EMPTY
87320: ST_TO_ADDR
// if campaign_id = 1 then
87321: LD_OWVAR 69
87325: PUSH
87326: LD_INT 1
87328: EQUAL
87329: IFFALSE 90495
// begin case mission_number of 1 :
87331: LD_OWVAR 70
87335: PUSH
87336: LD_INT 1
87338: DOUBLE
87339: EQUAL
87340: IFTRUE 87344
87342: GO 87420
87344: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87345: LD_ADDR_VAR 0 2
87349: PUSH
87350: LD_INT 2
87352: PUSH
87353: LD_INT 4
87355: PUSH
87356: LD_INT 11
87358: PUSH
87359: LD_INT 12
87361: PUSH
87362: LD_INT 15
87364: PUSH
87365: LD_INT 16
87367: PUSH
87368: LD_INT 22
87370: PUSH
87371: LD_INT 23
87373: PUSH
87374: LD_INT 26
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: PUSH
87388: LD_INT 101
87390: PUSH
87391: LD_INT 102
87393: PUSH
87394: LD_INT 106
87396: PUSH
87397: LD_INT 116
87399: PUSH
87400: LD_INT 117
87402: PUSH
87403: LD_INT 118
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: ST_TO_ADDR
87418: GO 90493
87420: LD_INT 2
87422: DOUBLE
87423: EQUAL
87424: IFTRUE 87428
87426: GO 87512
87428: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87429: LD_ADDR_VAR 0 2
87433: PUSH
87434: LD_INT 2
87436: PUSH
87437: LD_INT 4
87439: PUSH
87440: LD_INT 11
87442: PUSH
87443: LD_INT 12
87445: PUSH
87446: LD_INT 15
87448: PUSH
87449: LD_INT 16
87451: PUSH
87452: LD_INT 22
87454: PUSH
87455: LD_INT 23
87457: PUSH
87458: LD_INT 26
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: LIST
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 101
87474: PUSH
87475: LD_INT 102
87477: PUSH
87478: LD_INT 105
87480: PUSH
87481: LD_INT 106
87483: PUSH
87484: LD_INT 108
87486: PUSH
87487: LD_INT 116
87489: PUSH
87490: LD_INT 117
87492: PUSH
87493: LD_INT 118
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: ST_TO_ADDR
87510: GO 90493
87512: LD_INT 3
87514: DOUBLE
87515: EQUAL
87516: IFTRUE 87520
87518: GO 87608
87520: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87521: LD_ADDR_VAR 0 2
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: LD_INT 4
87531: PUSH
87532: LD_INT 5
87534: PUSH
87535: LD_INT 11
87537: PUSH
87538: LD_INT 12
87540: PUSH
87541: LD_INT 15
87543: PUSH
87544: LD_INT 16
87546: PUSH
87547: LD_INT 22
87549: PUSH
87550: LD_INT 26
87552: PUSH
87553: LD_INT 36
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 101
87570: PUSH
87571: LD_INT 102
87573: PUSH
87574: LD_INT 105
87576: PUSH
87577: LD_INT 106
87579: PUSH
87580: LD_INT 108
87582: PUSH
87583: LD_INT 116
87585: PUSH
87586: LD_INT 117
87588: PUSH
87589: LD_INT 118
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: ST_TO_ADDR
87606: GO 90493
87608: LD_INT 4
87610: DOUBLE
87611: EQUAL
87612: IFTRUE 87616
87614: GO 87712
87616: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87617: LD_ADDR_VAR 0 2
87621: PUSH
87622: LD_INT 2
87624: PUSH
87625: LD_INT 4
87627: PUSH
87628: LD_INT 5
87630: PUSH
87631: LD_INT 8
87633: PUSH
87634: LD_INT 11
87636: PUSH
87637: LD_INT 12
87639: PUSH
87640: LD_INT 15
87642: PUSH
87643: LD_INT 16
87645: PUSH
87646: LD_INT 22
87648: PUSH
87649: LD_INT 23
87651: PUSH
87652: LD_INT 26
87654: PUSH
87655: LD_INT 36
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 101
87674: PUSH
87675: LD_INT 102
87677: PUSH
87678: LD_INT 105
87680: PUSH
87681: LD_INT 106
87683: PUSH
87684: LD_INT 108
87686: PUSH
87687: LD_INT 116
87689: PUSH
87690: LD_INT 117
87692: PUSH
87693: LD_INT 118
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: ST_TO_ADDR
87710: GO 90493
87712: LD_INT 5
87714: DOUBLE
87715: EQUAL
87716: IFTRUE 87720
87718: GO 87832
87720: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87721: LD_ADDR_VAR 0 2
87725: PUSH
87726: LD_INT 2
87728: PUSH
87729: LD_INT 4
87731: PUSH
87732: LD_INT 5
87734: PUSH
87735: LD_INT 6
87737: PUSH
87738: LD_INT 8
87740: PUSH
87741: LD_INT 11
87743: PUSH
87744: LD_INT 12
87746: PUSH
87747: LD_INT 15
87749: PUSH
87750: LD_INT 16
87752: PUSH
87753: LD_INT 22
87755: PUSH
87756: LD_INT 23
87758: PUSH
87759: LD_INT 25
87761: PUSH
87762: LD_INT 26
87764: PUSH
87765: LD_INT 36
87767: PUSH
87768: EMPTY
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: PUSH
87784: LD_INT 101
87786: PUSH
87787: LD_INT 102
87789: PUSH
87790: LD_INT 105
87792: PUSH
87793: LD_INT 106
87795: PUSH
87796: LD_INT 108
87798: PUSH
87799: LD_INT 109
87801: PUSH
87802: LD_INT 112
87804: PUSH
87805: LD_INT 116
87807: PUSH
87808: LD_INT 117
87810: PUSH
87811: LD_INT 118
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: ST_TO_ADDR
87830: GO 90493
87832: LD_INT 6
87834: DOUBLE
87835: EQUAL
87836: IFTRUE 87840
87838: GO 87972
87840: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
87841: LD_ADDR_VAR 0 2
87845: PUSH
87846: LD_INT 2
87848: PUSH
87849: LD_INT 4
87851: PUSH
87852: LD_INT 5
87854: PUSH
87855: LD_INT 6
87857: PUSH
87858: LD_INT 8
87860: PUSH
87861: LD_INT 11
87863: PUSH
87864: LD_INT 12
87866: PUSH
87867: LD_INT 15
87869: PUSH
87870: LD_INT 16
87872: PUSH
87873: LD_INT 20
87875: PUSH
87876: LD_INT 21
87878: PUSH
87879: LD_INT 22
87881: PUSH
87882: LD_INT 23
87884: PUSH
87885: LD_INT 25
87887: PUSH
87888: LD_INT 26
87890: PUSH
87891: LD_INT 30
87893: PUSH
87894: LD_INT 31
87896: PUSH
87897: LD_INT 32
87899: PUSH
87900: LD_INT 36
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 101
87926: PUSH
87927: LD_INT 102
87929: PUSH
87930: LD_INT 105
87932: PUSH
87933: LD_INT 106
87935: PUSH
87936: LD_INT 108
87938: PUSH
87939: LD_INT 109
87941: PUSH
87942: LD_INT 112
87944: PUSH
87945: LD_INT 116
87947: PUSH
87948: LD_INT 117
87950: PUSH
87951: LD_INT 118
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: ST_TO_ADDR
87970: GO 90493
87972: LD_INT 7
87974: DOUBLE
87975: EQUAL
87976: IFTRUE 87980
87978: GO 88092
87980: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
87981: LD_ADDR_VAR 0 2
87985: PUSH
87986: LD_INT 2
87988: PUSH
87989: LD_INT 4
87991: PUSH
87992: LD_INT 5
87994: PUSH
87995: LD_INT 7
87997: PUSH
87998: LD_INT 11
88000: PUSH
88001: LD_INT 12
88003: PUSH
88004: LD_INT 15
88006: PUSH
88007: LD_INT 16
88009: PUSH
88010: LD_INT 20
88012: PUSH
88013: LD_INT 21
88015: PUSH
88016: LD_INT 22
88018: PUSH
88019: LD_INT 23
88021: PUSH
88022: LD_INT 25
88024: PUSH
88025: LD_INT 26
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 101
88046: PUSH
88047: LD_INT 102
88049: PUSH
88050: LD_INT 103
88052: PUSH
88053: LD_INT 105
88055: PUSH
88056: LD_INT 106
88058: PUSH
88059: LD_INT 108
88061: PUSH
88062: LD_INT 112
88064: PUSH
88065: LD_INT 116
88067: PUSH
88068: LD_INT 117
88070: PUSH
88071: LD_INT 118
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: ST_TO_ADDR
88090: GO 90493
88092: LD_INT 8
88094: DOUBLE
88095: EQUAL
88096: IFTRUE 88100
88098: GO 88240
88100: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88101: LD_ADDR_VAR 0 2
88105: PUSH
88106: LD_INT 2
88108: PUSH
88109: LD_INT 4
88111: PUSH
88112: LD_INT 5
88114: PUSH
88115: LD_INT 6
88117: PUSH
88118: LD_INT 7
88120: PUSH
88121: LD_INT 8
88123: PUSH
88124: LD_INT 11
88126: PUSH
88127: LD_INT 12
88129: PUSH
88130: LD_INT 15
88132: PUSH
88133: LD_INT 16
88135: PUSH
88136: LD_INT 20
88138: PUSH
88139: LD_INT 21
88141: PUSH
88142: LD_INT 22
88144: PUSH
88145: LD_INT 23
88147: PUSH
88148: LD_INT 25
88150: PUSH
88151: LD_INT 26
88153: PUSH
88154: LD_INT 30
88156: PUSH
88157: LD_INT 31
88159: PUSH
88160: LD_INT 32
88162: PUSH
88163: LD_INT 36
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 101
88190: PUSH
88191: LD_INT 102
88193: PUSH
88194: LD_INT 103
88196: PUSH
88197: LD_INT 105
88199: PUSH
88200: LD_INT 106
88202: PUSH
88203: LD_INT 108
88205: PUSH
88206: LD_INT 109
88208: PUSH
88209: LD_INT 112
88211: PUSH
88212: LD_INT 116
88214: PUSH
88215: LD_INT 117
88217: PUSH
88218: LD_INT 118
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: ST_TO_ADDR
88238: GO 90493
88240: LD_INT 9
88242: DOUBLE
88243: EQUAL
88244: IFTRUE 88248
88246: GO 88396
88248: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88249: LD_ADDR_VAR 0 2
88253: PUSH
88254: LD_INT 2
88256: PUSH
88257: LD_INT 4
88259: PUSH
88260: LD_INT 5
88262: PUSH
88263: LD_INT 6
88265: PUSH
88266: LD_INT 7
88268: PUSH
88269: LD_INT 8
88271: PUSH
88272: LD_INT 11
88274: PUSH
88275: LD_INT 12
88277: PUSH
88278: LD_INT 15
88280: PUSH
88281: LD_INT 16
88283: PUSH
88284: LD_INT 20
88286: PUSH
88287: LD_INT 21
88289: PUSH
88290: LD_INT 22
88292: PUSH
88293: LD_INT 23
88295: PUSH
88296: LD_INT 25
88298: PUSH
88299: LD_INT 26
88301: PUSH
88302: LD_INT 28
88304: PUSH
88305: LD_INT 30
88307: PUSH
88308: LD_INT 31
88310: PUSH
88311: LD_INT 32
88313: PUSH
88314: LD_INT 36
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 101
88342: PUSH
88343: LD_INT 102
88345: PUSH
88346: LD_INT 103
88348: PUSH
88349: LD_INT 105
88351: PUSH
88352: LD_INT 106
88354: PUSH
88355: LD_INT 108
88357: PUSH
88358: LD_INT 109
88360: PUSH
88361: LD_INT 112
88363: PUSH
88364: LD_INT 114
88366: PUSH
88367: LD_INT 116
88369: PUSH
88370: LD_INT 117
88372: PUSH
88373: LD_INT 118
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: ST_TO_ADDR
88394: GO 90493
88396: LD_INT 10
88398: DOUBLE
88399: EQUAL
88400: IFTRUE 88404
88402: GO 88600
88404: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88405: LD_ADDR_VAR 0 2
88409: PUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 4
88415: PUSH
88416: LD_INT 5
88418: PUSH
88419: LD_INT 6
88421: PUSH
88422: LD_INT 7
88424: PUSH
88425: LD_INT 8
88427: PUSH
88428: LD_INT 9
88430: PUSH
88431: LD_INT 10
88433: PUSH
88434: LD_INT 11
88436: PUSH
88437: LD_INT 12
88439: PUSH
88440: LD_INT 13
88442: PUSH
88443: LD_INT 14
88445: PUSH
88446: LD_INT 15
88448: PUSH
88449: LD_INT 16
88451: PUSH
88452: LD_INT 17
88454: PUSH
88455: LD_INT 18
88457: PUSH
88458: LD_INT 19
88460: PUSH
88461: LD_INT 20
88463: PUSH
88464: LD_INT 21
88466: PUSH
88467: LD_INT 22
88469: PUSH
88470: LD_INT 23
88472: PUSH
88473: LD_INT 24
88475: PUSH
88476: LD_INT 25
88478: PUSH
88479: LD_INT 26
88481: PUSH
88482: LD_INT 28
88484: PUSH
88485: LD_INT 30
88487: PUSH
88488: LD_INT 31
88490: PUSH
88491: LD_INT 32
88493: PUSH
88494: LD_INT 36
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 101
88530: PUSH
88531: LD_INT 102
88533: PUSH
88534: LD_INT 103
88536: PUSH
88537: LD_INT 104
88539: PUSH
88540: LD_INT 105
88542: PUSH
88543: LD_INT 106
88545: PUSH
88546: LD_INT 107
88548: PUSH
88549: LD_INT 108
88551: PUSH
88552: LD_INT 109
88554: PUSH
88555: LD_INT 110
88557: PUSH
88558: LD_INT 111
88560: PUSH
88561: LD_INT 112
88563: PUSH
88564: LD_INT 114
88566: PUSH
88567: LD_INT 116
88569: PUSH
88570: LD_INT 117
88572: PUSH
88573: LD_INT 118
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: ST_TO_ADDR
88598: GO 90493
88600: LD_INT 11
88602: DOUBLE
88603: EQUAL
88604: IFTRUE 88608
88606: GO 88812
88608: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88609: LD_ADDR_VAR 0 2
88613: PUSH
88614: LD_INT 2
88616: PUSH
88617: LD_INT 3
88619: PUSH
88620: LD_INT 4
88622: PUSH
88623: LD_INT 5
88625: PUSH
88626: LD_INT 6
88628: PUSH
88629: LD_INT 7
88631: PUSH
88632: LD_INT 8
88634: PUSH
88635: LD_INT 9
88637: PUSH
88638: LD_INT 10
88640: PUSH
88641: LD_INT 11
88643: PUSH
88644: LD_INT 12
88646: PUSH
88647: LD_INT 13
88649: PUSH
88650: LD_INT 14
88652: PUSH
88653: LD_INT 15
88655: PUSH
88656: LD_INT 16
88658: PUSH
88659: LD_INT 17
88661: PUSH
88662: LD_INT 18
88664: PUSH
88665: LD_INT 19
88667: PUSH
88668: LD_INT 20
88670: PUSH
88671: LD_INT 21
88673: PUSH
88674: LD_INT 22
88676: PUSH
88677: LD_INT 23
88679: PUSH
88680: LD_INT 24
88682: PUSH
88683: LD_INT 25
88685: PUSH
88686: LD_INT 26
88688: PUSH
88689: LD_INT 28
88691: PUSH
88692: LD_INT 30
88694: PUSH
88695: LD_INT 31
88697: PUSH
88698: LD_INT 32
88700: PUSH
88701: LD_INT 34
88703: PUSH
88704: LD_INT 36
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 101
88742: PUSH
88743: LD_INT 102
88745: PUSH
88746: LD_INT 103
88748: PUSH
88749: LD_INT 104
88751: PUSH
88752: LD_INT 105
88754: PUSH
88755: LD_INT 106
88757: PUSH
88758: LD_INT 107
88760: PUSH
88761: LD_INT 108
88763: PUSH
88764: LD_INT 109
88766: PUSH
88767: LD_INT 110
88769: PUSH
88770: LD_INT 111
88772: PUSH
88773: LD_INT 112
88775: PUSH
88776: LD_INT 114
88778: PUSH
88779: LD_INT 116
88781: PUSH
88782: LD_INT 117
88784: PUSH
88785: LD_INT 118
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: ST_TO_ADDR
88810: GO 90493
88812: LD_INT 12
88814: DOUBLE
88815: EQUAL
88816: IFTRUE 88820
88818: GO 89040
88820: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
88821: LD_ADDR_VAR 0 2
88825: PUSH
88826: LD_INT 1
88828: PUSH
88829: LD_INT 2
88831: PUSH
88832: LD_INT 3
88834: PUSH
88835: LD_INT 4
88837: PUSH
88838: LD_INT 5
88840: PUSH
88841: LD_INT 6
88843: PUSH
88844: LD_INT 7
88846: PUSH
88847: LD_INT 8
88849: PUSH
88850: LD_INT 9
88852: PUSH
88853: LD_INT 10
88855: PUSH
88856: LD_INT 11
88858: PUSH
88859: LD_INT 12
88861: PUSH
88862: LD_INT 13
88864: PUSH
88865: LD_INT 14
88867: PUSH
88868: LD_INT 15
88870: PUSH
88871: LD_INT 16
88873: PUSH
88874: LD_INT 17
88876: PUSH
88877: LD_INT 18
88879: PUSH
88880: LD_INT 19
88882: PUSH
88883: LD_INT 20
88885: PUSH
88886: LD_INT 21
88888: PUSH
88889: LD_INT 22
88891: PUSH
88892: LD_INT 23
88894: PUSH
88895: LD_INT 24
88897: PUSH
88898: LD_INT 25
88900: PUSH
88901: LD_INT 26
88903: PUSH
88904: LD_INT 27
88906: PUSH
88907: LD_INT 28
88909: PUSH
88910: LD_INT 30
88912: PUSH
88913: LD_INT 31
88915: PUSH
88916: LD_INT 32
88918: PUSH
88919: LD_INT 33
88921: PUSH
88922: LD_INT 34
88924: PUSH
88925: LD_INT 36
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 101
88966: PUSH
88967: LD_INT 102
88969: PUSH
88970: LD_INT 103
88972: PUSH
88973: LD_INT 104
88975: PUSH
88976: LD_INT 105
88978: PUSH
88979: LD_INT 106
88981: PUSH
88982: LD_INT 107
88984: PUSH
88985: LD_INT 108
88987: PUSH
88988: LD_INT 109
88990: PUSH
88991: LD_INT 110
88993: PUSH
88994: LD_INT 111
88996: PUSH
88997: LD_INT 112
88999: PUSH
89000: LD_INT 113
89002: PUSH
89003: LD_INT 114
89005: PUSH
89006: LD_INT 116
89008: PUSH
89009: LD_INT 117
89011: PUSH
89012: LD_INT 118
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: PUSH
89034: EMPTY
89035: LIST
89036: LIST
89037: ST_TO_ADDR
89038: GO 90493
89040: LD_INT 13
89042: DOUBLE
89043: EQUAL
89044: IFTRUE 89048
89046: GO 89256
89048: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89049: LD_ADDR_VAR 0 2
89053: PUSH
89054: LD_INT 1
89056: PUSH
89057: LD_INT 2
89059: PUSH
89060: LD_INT 3
89062: PUSH
89063: LD_INT 4
89065: PUSH
89066: LD_INT 5
89068: PUSH
89069: LD_INT 8
89071: PUSH
89072: LD_INT 9
89074: PUSH
89075: LD_INT 10
89077: PUSH
89078: LD_INT 11
89080: PUSH
89081: LD_INT 12
89083: PUSH
89084: LD_INT 14
89086: PUSH
89087: LD_INT 15
89089: PUSH
89090: LD_INT 16
89092: PUSH
89093: LD_INT 17
89095: PUSH
89096: LD_INT 18
89098: PUSH
89099: LD_INT 19
89101: PUSH
89102: LD_INT 20
89104: PUSH
89105: LD_INT 21
89107: PUSH
89108: LD_INT 22
89110: PUSH
89111: LD_INT 23
89113: PUSH
89114: LD_INT 24
89116: PUSH
89117: LD_INT 25
89119: PUSH
89120: LD_INT 26
89122: PUSH
89123: LD_INT 27
89125: PUSH
89126: LD_INT 28
89128: PUSH
89129: LD_INT 30
89131: PUSH
89132: LD_INT 31
89134: PUSH
89135: LD_INT 32
89137: PUSH
89138: LD_INT 33
89140: PUSH
89141: LD_INT 34
89143: PUSH
89144: LD_INT 36
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: PUSH
89180: LD_INT 101
89182: PUSH
89183: LD_INT 102
89185: PUSH
89186: LD_INT 103
89188: PUSH
89189: LD_INT 104
89191: PUSH
89192: LD_INT 105
89194: PUSH
89195: LD_INT 106
89197: PUSH
89198: LD_INT 107
89200: PUSH
89201: LD_INT 108
89203: PUSH
89204: LD_INT 109
89206: PUSH
89207: LD_INT 110
89209: PUSH
89210: LD_INT 111
89212: PUSH
89213: LD_INT 112
89215: PUSH
89216: LD_INT 113
89218: PUSH
89219: LD_INT 114
89221: PUSH
89222: LD_INT 116
89224: PUSH
89225: LD_INT 117
89227: PUSH
89228: LD_INT 118
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: ST_TO_ADDR
89254: GO 90493
89256: LD_INT 14
89258: DOUBLE
89259: EQUAL
89260: IFTRUE 89264
89262: GO 89488
89264: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89265: LD_ADDR_VAR 0 2
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: LD_INT 2
89275: PUSH
89276: LD_INT 3
89278: PUSH
89279: LD_INT 4
89281: PUSH
89282: LD_INT 5
89284: PUSH
89285: LD_INT 6
89287: PUSH
89288: LD_INT 7
89290: PUSH
89291: LD_INT 8
89293: PUSH
89294: LD_INT 9
89296: PUSH
89297: LD_INT 10
89299: PUSH
89300: LD_INT 11
89302: PUSH
89303: LD_INT 12
89305: PUSH
89306: LD_INT 13
89308: PUSH
89309: LD_INT 14
89311: PUSH
89312: LD_INT 15
89314: PUSH
89315: LD_INT 16
89317: PUSH
89318: LD_INT 17
89320: PUSH
89321: LD_INT 18
89323: PUSH
89324: LD_INT 19
89326: PUSH
89327: LD_INT 20
89329: PUSH
89330: LD_INT 21
89332: PUSH
89333: LD_INT 22
89335: PUSH
89336: LD_INT 23
89338: PUSH
89339: LD_INT 24
89341: PUSH
89342: LD_INT 25
89344: PUSH
89345: LD_INT 26
89347: PUSH
89348: LD_INT 27
89350: PUSH
89351: LD_INT 28
89353: PUSH
89354: LD_INT 29
89356: PUSH
89357: LD_INT 30
89359: PUSH
89360: LD_INT 31
89362: PUSH
89363: LD_INT 32
89365: PUSH
89366: LD_INT 33
89368: PUSH
89369: LD_INT 34
89371: PUSH
89372: LD_INT 36
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: PUSH
89412: LD_INT 101
89414: PUSH
89415: LD_INT 102
89417: PUSH
89418: LD_INT 103
89420: PUSH
89421: LD_INT 104
89423: PUSH
89424: LD_INT 105
89426: PUSH
89427: LD_INT 106
89429: PUSH
89430: LD_INT 107
89432: PUSH
89433: LD_INT 108
89435: PUSH
89436: LD_INT 109
89438: PUSH
89439: LD_INT 110
89441: PUSH
89442: LD_INT 111
89444: PUSH
89445: LD_INT 112
89447: PUSH
89448: LD_INT 113
89450: PUSH
89451: LD_INT 114
89453: PUSH
89454: LD_INT 116
89456: PUSH
89457: LD_INT 117
89459: PUSH
89460: LD_INT 118
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: ST_TO_ADDR
89486: GO 90493
89488: LD_INT 15
89490: DOUBLE
89491: EQUAL
89492: IFTRUE 89496
89494: GO 89720
89496: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89497: LD_ADDR_VAR 0 2
89501: PUSH
89502: LD_INT 1
89504: PUSH
89505: LD_INT 2
89507: PUSH
89508: LD_INT 3
89510: PUSH
89511: LD_INT 4
89513: PUSH
89514: LD_INT 5
89516: PUSH
89517: LD_INT 6
89519: PUSH
89520: LD_INT 7
89522: PUSH
89523: LD_INT 8
89525: PUSH
89526: LD_INT 9
89528: PUSH
89529: LD_INT 10
89531: PUSH
89532: LD_INT 11
89534: PUSH
89535: LD_INT 12
89537: PUSH
89538: LD_INT 13
89540: PUSH
89541: LD_INT 14
89543: PUSH
89544: LD_INT 15
89546: PUSH
89547: LD_INT 16
89549: PUSH
89550: LD_INT 17
89552: PUSH
89553: LD_INT 18
89555: PUSH
89556: LD_INT 19
89558: PUSH
89559: LD_INT 20
89561: PUSH
89562: LD_INT 21
89564: PUSH
89565: LD_INT 22
89567: PUSH
89568: LD_INT 23
89570: PUSH
89571: LD_INT 24
89573: PUSH
89574: LD_INT 25
89576: PUSH
89577: LD_INT 26
89579: PUSH
89580: LD_INT 27
89582: PUSH
89583: LD_INT 28
89585: PUSH
89586: LD_INT 29
89588: PUSH
89589: LD_INT 30
89591: PUSH
89592: LD_INT 31
89594: PUSH
89595: LD_INT 32
89597: PUSH
89598: LD_INT 33
89600: PUSH
89601: LD_INT 34
89603: PUSH
89604: LD_INT 36
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: PUSH
89644: LD_INT 101
89646: PUSH
89647: LD_INT 102
89649: PUSH
89650: LD_INT 103
89652: PUSH
89653: LD_INT 104
89655: PUSH
89656: LD_INT 105
89658: PUSH
89659: LD_INT 106
89661: PUSH
89662: LD_INT 107
89664: PUSH
89665: LD_INT 108
89667: PUSH
89668: LD_INT 109
89670: PUSH
89671: LD_INT 110
89673: PUSH
89674: LD_INT 111
89676: PUSH
89677: LD_INT 112
89679: PUSH
89680: LD_INT 113
89682: PUSH
89683: LD_INT 114
89685: PUSH
89686: LD_INT 116
89688: PUSH
89689: LD_INT 117
89691: PUSH
89692: LD_INT 118
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: ST_TO_ADDR
89718: GO 90493
89720: LD_INT 16
89722: DOUBLE
89723: EQUAL
89724: IFTRUE 89728
89726: GO 89864
89728: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89729: LD_ADDR_VAR 0 2
89733: PUSH
89734: LD_INT 2
89736: PUSH
89737: LD_INT 4
89739: PUSH
89740: LD_INT 5
89742: PUSH
89743: LD_INT 7
89745: PUSH
89746: LD_INT 11
89748: PUSH
89749: LD_INT 12
89751: PUSH
89752: LD_INT 15
89754: PUSH
89755: LD_INT 16
89757: PUSH
89758: LD_INT 20
89760: PUSH
89761: LD_INT 21
89763: PUSH
89764: LD_INT 22
89766: PUSH
89767: LD_INT 23
89769: PUSH
89770: LD_INT 25
89772: PUSH
89773: LD_INT 26
89775: PUSH
89776: LD_INT 30
89778: PUSH
89779: LD_INT 31
89781: PUSH
89782: LD_INT 32
89784: PUSH
89785: LD_INT 33
89787: PUSH
89788: LD_INT 34
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 101
89814: PUSH
89815: LD_INT 102
89817: PUSH
89818: LD_INT 103
89820: PUSH
89821: LD_INT 106
89823: PUSH
89824: LD_INT 108
89826: PUSH
89827: LD_INT 112
89829: PUSH
89830: LD_INT 113
89832: PUSH
89833: LD_INT 114
89835: PUSH
89836: LD_INT 116
89838: PUSH
89839: LD_INT 117
89841: PUSH
89842: LD_INT 118
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: ST_TO_ADDR
89862: GO 90493
89864: LD_INT 17
89866: DOUBLE
89867: EQUAL
89868: IFTRUE 89872
89870: GO 90096
89872: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
89873: LD_ADDR_VAR 0 2
89877: PUSH
89878: LD_INT 1
89880: PUSH
89881: LD_INT 2
89883: PUSH
89884: LD_INT 3
89886: PUSH
89887: LD_INT 4
89889: PUSH
89890: LD_INT 5
89892: PUSH
89893: LD_INT 6
89895: PUSH
89896: LD_INT 7
89898: PUSH
89899: LD_INT 8
89901: PUSH
89902: LD_INT 9
89904: PUSH
89905: LD_INT 10
89907: PUSH
89908: LD_INT 11
89910: PUSH
89911: LD_INT 12
89913: PUSH
89914: LD_INT 13
89916: PUSH
89917: LD_INT 14
89919: PUSH
89920: LD_INT 15
89922: PUSH
89923: LD_INT 16
89925: PUSH
89926: LD_INT 17
89928: PUSH
89929: LD_INT 18
89931: PUSH
89932: LD_INT 19
89934: PUSH
89935: LD_INT 20
89937: PUSH
89938: LD_INT 21
89940: PUSH
89941: LD_INT 22
89943: PUSH
89944: LD_INT 23
89946: PUSH
89947: LD_INT 24
89949: PUSH
89950: LD_INT 25
89952: PUSH
89953: LD_INT 26
89955: PUSH
89956: LD_INT 27
89958: PUSH
89959: LD_INT 28
89961: PUSH
89962: LD_INT 29
89964: PUSH
89965: LD_INT 30
89967: PUSH
89968: LD_INT 31
89970: PUSH
89971: LD_INT 32
89973: PUSH
89974: LD_INT 33
89976: PUSH
89977: LD_INT 34
89979: PUSH
89980: LD_INT 36
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: LIST
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 101
90022: PUSH
90023: LD_INT 102
90025: PUSH
90026: LD_INT 103
90028: PUSH
90029: LD_INT 104
90031: PUSH
90032: LD_INT 105
90034: PUSH
90035: LD_INT 106
90037: PUSH
90038: LD_INT 107
90040: PUSH
90041: LD_INT 108
90043: PUSH
90044: LD_INT 109
90046: PUSH
90047: LD_INT 110
90049: PUSH
90050: LD_INT 111
90052: PUSH
90053: LD_INT 112
90055: PUSH
90056: LD_INT 113
90058: PUSH
90059: LD_INT 114
90061: PUSH
90062: LD_INT 116
90064: PUSH
90065: LD_INT 117
90067: PUSH
90068: LD_INT 118
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: ST_TO_ADDR
90094: GO 90493
90096: LD_INT 18
90098: DOUBLE
90099: EQUAL
90100: IFTRUE 90104
90102: GO 90252
90104: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90105: LD_ADDR_VAR 0 2
90109: PUSH
90110: LD_INT 2
90112: PUSH
90113: LD_INT 4
90115: PUSH
90116: LD_INT 5
90118: PUSH
90119: LD_INT 7
90121: PUSH
90122: LD_INT 11
90124: PUSH
90125: LD_INT 12
90127: PUSH
90128: LD_INT 15
90130: PUSH
90131: LD_INT 16
90133: PUSH
90134: LD_INT 20
90136: PUSH
90137: LD_INT 21
90139: PUSH
90140: LD_INT 22
90142: PUSH
90143: LD_INT 23
90145: PUSH
90146: LD_INT 25
90148: PUSH
90149: LD_INT 26
90151: PUSH
90152: LD_INT 30
90154: PUSH
90155: LD_INT 31
90157: PUSH
90158: LD_INT 32
90160: PUSH
90161: LD_INT 33
90163: PUSH
90164: LD_INT 34
90166: PUSH
90167: LD_INT 35
90169: PUSH
90170: LD_INT 36
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 101
90198: PUSH
90199: LD_INT 102
90201: PUSH
90202: LD_INT 103
90204: PUSH
90205: LD_INT 106
90207: PUSH
90208: LD_INT 108
90210: PUSH
90211: LD_INT 112
90213: PUSH
90214: LD_INT 113
90216: PUSH
90217: LD_INT 114
90219: PUSH
90220: LD_INT 115
90222: PUSH
90223: LD_INT 116
90225: PUSH
90226: LD_INT 117
90228: PUSH
90229: LD_INT 118
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: ST_TO_ADDR
90250: GO 90493
90252: LD_INT 19
90254: DOUBLE
90255: EQUAL
90256: IFTRUE 90260
90258: GO 90492
90260: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90261: LD_ADDR_VAR 0 2
90265: PUSH
90266: LD_INT 1
90268: PUSH
90269: LD_INT 2
90271: PUSH
90272: LD_INT 3
90274: PUSH
90275: LD_INT 4
90277: PUSH
90278: LD_INT 5
90280: PUSH
90281: LD_INT 6
90283: PUSH
90284: LD_INT 7
90286: PUSH
90287: LD_INT 8
90289: PUSH
90290: LD_INT 9
90292: PUSH
90293: LD_INT 10
90295: PUSH
90296: LD_INT 11
90298: PUSH
90299: LD_INT 12
90301: PUSH
90302: LD_INT 13
90304: PUSH
90305: LD_INT 14
90307: PUSH
90308: LD_INT 15
90310: PUSH
90311: LD_INT 16
90313: PUSH
90314: LD_INT 17
90316: PUSH
90317: LD_INT 18
90319: PUSH
90320: LD_INT 19
90322: PUSH
90323: LD_INT 20
90325: PUSH
90326: LD_INT 21
90328: PUSH
90329: LD_INT 22
90331: PUSH
90332: LD_INT 23
90334: PUSH
90335: LD_INT 24
90337: PUSH
90338: LD_INT 25
90340: PUSH
90341: LD_INT 26
90343: PUSH
90344: LD_INT 27
90346: PUSH
90347: LD_INT 28
90349: PUSH
90350: LD_INT 29
90352: PUSH
90353: LD_INT 30
90355: PUSH
90356: LD_INT 31
90358: PUSH
90359: LD_INT 32
90361: PUSH
90362: LD_INT 33
90364: PUSH
90365: LD_INT 34
90367: PUSH
90368: LD_INT 35
90370: PUSH
90371: LD_INT 36
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 101
90414: PUSH
90415: LD_INT 102
90417: PUSH
90418: LD_INT 103
90420: PUSH
90421: LD_INT 104
90423: PUSH
90424: LD_INT 105
90426: PUSH
90427: LD_INT 106
90429: PUSH
90430: LD_INT 107
90432: PUSH
90433: LD_INT 108
90435: PUSH
90436: LD_INT 109
90438: PUSH
90439: LD_INT 110
90441: PUSH
90442: LD_INT 111
90444: PUSH
90445: LD_INT 112
90447: PUSH
90448: LD_INT 113
90450: PUSH
90451: LD_INT 114
90453: PUSH
90454: LD_INT 115
90456: PUSH
90457: LD_INT 116
90459: PUSH
90460: LD_INT 117
90462: PUSH
90463: LD_INT 118
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: ST_TO_ADDR
90490: GO 90493
90492: POP
// end else
90493: GO 90724
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90495: LD_ADDR_VAR 0 2
90499: PUSH
90500: LD_INT 1
90502: PUSH
90503: LD_INT 2
90505: PUSH
90506: LD_INT 3
90508: PUSH
90509: LD_INT 4
90511: PUSH
90512: LD_INT 5
90514: PUSH
90515: LD_INT 6
90517: PUSH
90518: LD_INT 7
90520: PUSH
90521: LD_INT 8
90523: PUSH
90524: LD_INT 9
90526: PUSH
90527: LD_INT 10
90529: PUSH
90530: LD_INT 11
90532: PUSH
90533: LD_INT 12
90535: PUSH
90536: LD_INT 13
90538: PUSH
90539: LD_INT 14
90541: PUSH
90542: LD_INT 15
90544: PUSH
90545: LD_INT 16
90547: PUSH
90548: LD_INT 17
90550: PUSH
90551: LD_INT 18
90553: PUSH
90554: LD_INT 19
90556: PUSH
90557: LD_INT 20
90559: PUSH
90560: LD_INT 21
90562: PUSH
90563: LD_INT 22
90565: PUSH
90566: LD_INT 23
90568: PUSH
90569: LD_INT 24
90571: PUSH
90572: LD_INT 25
90574: PUSH
90575: LD_INT 26
90577: PUSH
90578: LD_INT 27
90580: PUSH
90581: LD_INT 28
90583: PUSH
90584: LD_INT 29
90586: PUSH
90587: LD_INT 30
90589: PUSH
90590: LD_INT 31
90592: PUSH
90593: LD_INT 32
90595: PUSH
90596: LD_INT 33
90598: PUSH
90599: LD_INT 34
90601: PUSH
90602: LD_INT 35
90604: PUSH
90605: LD_INT 36
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 101
90648: PUSH
90649: LD_INT 102
90651: PUSH
90652: LD_INT 103
90654: PUSH
90655: LD_INT 104
90657: PUSH
90658: LD_INT 105
90660: PUSH
90661: LD_INT 106
90663: PUSH
90664: LD_INT 107
90666: PUSH
90667: LD_INT 108
90669: PUSH
90670: LD_INT 109
90672: PUSH
90673: LD_INT 110
90675: PUSH
90676: LD_INT 111
90678: PUSH
90679: LD_INT 112
90681: PUSH
90682: LD_INT 113
90684: PUSH
90685: LD_INT 114
90687: PUSH
90688: LD_INT 115
90690: PUSH
90691: LD_INT 116
90693: PUSH
90694: LD_INT 117
90696: PUSH
90697: LD_INT 118
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: ST_TO_ADDR
// if result then
90724: LD_VAR 0 2
90728: IFFALSE 91514
// begin normal :=  ;
90730: LD_ADDR_VAR 0 5
90734: PUSH
90735: LD_STRING 
90737: ST_TO_ADDR
// hardcore :=  ;
90738: LD_ADDR_VAR 0 6
90742: PUSH
90743: LD_STRING 
90745: ST_TO_ADDR
// active :=  ;
90746: LD_ADDR_VAR 0 7
90750: PUSH
90751: LD_STRING 
90753: ST_TO_ADDR
// for i = 1 to normalCounter do
90754: LD_ADDR_VAR 0 8
90758: PUSH
90759: DOUBLE
90760: LD_INT 1
90762: DEC
90763: ST_TO_ADDR
90764: LD_EXP 113
90768: PUSH
90769: FOR_TO
90770: IFFALSE 90871
// begin tmp := 0 ;
90772: LD_ADDR_VAR 0 3
90776: PUSH
90777: LD_STRING 0
90779: ST_TO_ADDR
// if result [ 1 ] then
90780: LD_VAR 0 2
90784: PUSH
90785: LD_INT 1
90787: ARRAY
90788: IFFALSE 90853
// if result [ 1 ] [ 1 ] = i then
90790: LD_VAR 0 2
90794: PUSH
90795: LD_INT 1
90797: ARRAY
90798: PUSH
90799: LD_INT 1
90801: ARRAY
90802: PUSH
90803: LD_VAR 0 8
90807: EQUAL
90808: IFFALSE 90853
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90810: LD_ADDR_VAR 0 2
90814: PUSH
90815: LD_VAR 0 2
90819: PPUSH
90820: LD_INT 1
90822: PPUSH
90823: LD_VAR 0 2
90827: PUSH
90828: LD_INT 1
90830: ARRAY
90831: PPUSH
90832: LD_INT 1
90834: PPUSH
90835: CALL_OW 3
90839: PPUSH
90840: CALL_OW 1
90844: ST_TO_ADDR
// tmp := 1 ;
90845: LD_ADDR_VAR 0 3
90849: PUSH
90850: LD_STRING 1
90852: ST_TO_ADDR
// end ; normal := normal & tmp ;
90853: LD_ADDR_VAR 0 5
90857: PUSH
90858: LD_VAR 0 5
90862: PUSH
90863: LD_VAR 0 3
90867: STR
90868: ST_TO_ADDR
// end ;
90869: GO 90769
90871: POP
90872: POP
// for i = 1 to hardcoreCounter do
90873: LD_ADDR_VAR 0 8
90877: PUSH
90878: DOUBLE
90879: LD_INT 1
90881: DEC
90882: ST_TO_ADDR
90883: LD_EXP 114
90887: PUSH
90888: FOR_TO
90889: IFFALSE 90994
// begin tmp := 0 ;
90891: LD_ADDR_VAR 0 3
90895: PUSH
90896: LD_STRING 0
90898: ST_TO_ADDR
// if result [ 2 ] then
90899: LD_VAR 0 2
90903: PUSH
90904: LD_INT 2
90906: ARRAY
90907: IFFALSE 90976
// if result [ 2 ] [ 1 ] = 100 + i then
90909: LD_VAR 0 2
90913: PUSH
90914: LD_INT 2
90916: ARRAY
90917: PUSH
90918: LD_INT 1
90920: ARRAY
90921: PUSH
90922: LD_INT 100
90924: PUSH
90925: LD_VAR 0 8
90929: PLUS
90930: EQUAL
90931: IFFALSE 90976
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90933: LD_ADDR_VAR 0 2
90937: PUSH
90938: LD_VAR 0 2
90942: PPUSH
90943: LD_INT 2
90945: PPUSH
90946: LD_VAR 0 2
90950: PUSH
90951: LD_INT 2
90953: ARRAY
90954: PPUSH
90955: LD_INT 1
90957: PPUSH
90958: CALL_OW 3
90962: PPUSH
90963: CALL_OW 1
90967: ST_TO_ADDR
// tmp := 1 ;
90968: LD_ADDR_VAR 0 3
90972: PUSH
90973: LD_STRING 1
90975: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90976: LD_ADDR_VAR 0 6
90980: PUSH
90981: LD_VAR 0 6
90985: PUSH
90986: LD_VAR 0 3
90990: STR
90991: ST_TO_ADDR
// end ;
90992: GO 90888
90994: POP
90995: POP
// if isGameLoad then
90996: LD_VAR 0 1
91000: IFFALSE 91475
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91002: LD_ADDR_VAR 0 4
91006: PUSH
91007: LD_EXP 117
91011: PUSH
91012: LD_EXP 116
91016: PUSH
91017: LD_EXP 118
91021: PUSH
91022: LD_EXP 115
91026: PUSH
91027: LD_EXP 119
91031: PUSH
91032: LD_EXP 120
91036: PUSH
91037: LD_EXP 121
91041: PUSH
91042: LD_EXP 122
91046: PUSH
91047: LD_EXP 123
91051: PUSH
91052: LD_EXP 124
91056: PUSH
91057: LD_EXP 125
91061: PUSH
91062: LD_EXP 126
91066: PUSH
91067: LD_EXP 127
91071: PUSH
91072: LD_EXP 128
91076: PUSH
91077: LD_EXP 136
91081: PUSH
91082: LD_EXP 137
91086: PUSH
91087: LD_EXP 138
91091: PUSH
91092: LD_EXP 139
91096: PUSH
91097: LD_EXP 141
91101: PUSH
91102: LD_EXP 142
91106: PUSH
91107: LD_EXP 143
91111: PUSH
91112: LD_EXP 146
91116: PUSH
91117: LD_EXP 148
91121: PUSH
91122: LD_EXP 149
91126: PUSH
91127: LD_EXP 150
91131: PUSH
91132: LD_EXP 152
91136: PUSH
91137: LD_EXP 153
91141: PUSH
91142: LD_EXP 156
91146: PUSH
91147: LD_EXP 157
91151: PUSH
91152: LD_EXP 158
91156: PUSH
91157: LD_EXP 159
91161: PUSH
91162: LD_EXP 160
91166: PUSH
91167: LD_EXP 161
91171: PUSH
91172: LD_EXP 162
91176: PUSH
91177: LD_EXP 163
91181: PUSH
91182: LD_EXP 164
91186: PUSH
91187: LD_EXP 129
91191: PUSH
91192: LD_EXP 130
91196: PUSH
91197: LD_EXP 133
91201: PUSH
91202: LD_EXP 134
91206: PUSH
91207: LD_EXP 135
91211: PUSH
91212: LD_EXP 131
91216: PUSH
91217: LD_EXP 132
91221: PUSH
91222: LD_EXP 140
91226: PUSH
91227: LD_EXP 144
91231: PUSH
91232: LD_EXP 145
91236: PUSH
91237: LD_EXP 147
91241: PUSH
91242: LD_EXP 151
91246: PUSH
91247: LD_EXP 154
91251: PUSH
91252: LD_EXP 155
91256: PUSH
91257: LD_EXP 165
91261: PUSH
91262: LD_EXP 166
91266: PUSH
91267: LD_EXP 167
91271: PUSH
91272: LD_EXP 168
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: ST_TO_ADDR
// tmp :=  ;
91333: LD_ADDR_VAR 0 3
91337: PUSH
91338: LD_STRING 
91340: ST_TO_ADDR
// for i = 1 to normalCounter do
91341: LD_ADDR_VAR 0 8
91345: PUSH
91346: DOUBLE
91347: LD_INT 1
91349: DEC
91350: ST_TO_ADDR
91351: LD_EXP 113
91355: PUSH
91356: FOR_TO
91357: IFFALSE 91393
// begin if flags [ i ] then
91359: LD_VAR 0 4
91363: PUSH
91364: LD_VAR 0 8
91368: ARRAY
91369: IFFALSE 91391
// tmp := tmp & i & ; ;
91371: LD_ADDR_VAR 0 3
91375: PUSH
91376: LD_VAR 0 3
91380: PUSH
91381: LD_VAR 0 8
91385: STR
91386: PUSH
91387: LD_STRING ;
91389: STR
91390: ST_TO_ADDR
// end ;
91391: GO 91356
91393: POP
91394: POP
// for i = 1 to hardcoreCounter do
91395: LD_ADDR_VAR 0 8
91399: PUSH
91400: DOUBLE
91401: LD_INT 1
91403: DEC
91404: ST_TO_ADDR
91405: LD_EXP 114
91409: PUSH
91410: FOR_TO
91411: IFFALSE 91457
// begin if flags [ normalCounter + i ] then
91413: LD_VAR 0 4
91417: PUSH
91418: LD_EXP 113
91422: PUSH
91423: LD_VAR 0 8
91427: PLUS
91428: ARRAY
91429: IFFALSE 91455
// tmp := tmp & ( 100 + i ) & ; ;
91431: LD_ADDR_VAR 0 3
91435: PUSH
91436: LD_VAR 0 3
91440: PUSH
91441: LD_INT 100
91443: PUSH
91444: LD_VAR 0 8
91448: PLUS
91449: STR
91450: PUSH
91451: LD_STRING ;
91453: STR
91454: ST_TO_ADDR
// end ;
91455: GO 91410
91457: POP
91458: POP
// if tmp then
91459: LD_VAR 0 3
91463: IFFALSE 91475
// active := tmp ;
91465: LD_ADDR_VAR 0 7
91469: PUSH
91470: LD_VAR 0 3
91474: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91475: LD_STRING getStreamItemsFromMission("
91477: PUSH
91478: LD_VAR 0 5
91482: STR
91483: PUSH
91484: LD_STRING ","
91486: STR
91487: PUSH
91488: LD_VAR 0 6
91492: STR
91493: PUSH
91494: LD_STRING ","
91496: STR
91497: PUSH
91498: LD_VAR 0 7
91502: STR
91503: PUSH
91504: LD_STRING ")
91506: STR
91507: PPUSH
91508: CALL_OW 559
// end else
91512: GO 91521
// ToLua ( getStreamItemsFromMission("","","") ) ;
91514: LD_STRING getStreamItemsFromMission("","","")
91516: PPUSH
91517: CALL_OW 559
// end ;
91521: LD_VAR 0 2
91525: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91526: LD_EXP 112
91530: PUSH
91531: LD_EXP 117
91535: AND
91536: IFFALSE 91660
91538: GO 91540
91540: DISABLE
91541: LD_INT 0
91543: PPUSH
91544: PPUSH
// begin enable ;
91545: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91546: LD_ADDR_VAR 0 2
91550: PUSH
91551: LD_INT 22
91553: PUSH
91554: LD_OWVAR 2
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PUSH
91563: LD_INT 2
91565: PUSH
91566: LD_INT 34
91568: PUSH
91569: LD_INT 7
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 34
91578: PUSH
91579: LD_INT 45
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 34
91588: PUSH
91589: LD_INT 28
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 34
91598: PUSH
91599: LD_INT 47
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PPUSH
91617: CALL_OW 69
91621: ST_TO_ADDR
// if not tmp then
91622: LD_VAR 0 2
91626: NOT
91627: IFFALSE 91631
// exit ;
91629: GO 91660
// for i in tmp do
91631: LD_ADDR_VAR 0 1
91635: PUSH
91636: LD_VAR 0 2
91640: PUSH
91641: FOR_IN
91642: IFFALSE 91658
// begin SetLives ( i , 0 ) ;
91644: LD_VAR 0 1
91648: PPUSH
91649: LD_INT 0
91651: PPUSH
91652: CALL_OW 234
// end ;
91656: GO 91641
91658: POP
91659: POP
// end ;
91660: PPOPN 2
91662: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91663: LD_EXP 112
91667: PUSH
91668: LD_EXP 118
91672: AND
91673: IFFALSE 91757
91675: GO 91677
91677: DISABLE
91678: LD_INT 0
91680: PPUSH
91681: PPUSH
// begin enable ;
91682: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91683: LD_ADDR_VAR 0 2
91687: PUSH
91688: LD_INT 22
91690: PUSH
91691: LD_OWVAR 2
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 32
91702: PUSH
91703: LD_INT 3
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PPUSH
91714: CALL_OW 69
91718: ST_TO_ADDR
// if not tmp then
91719: LD_VAR 0 2
91723: NOT
91724: IFFALSE 91728
// exit ;
91726: GO 91757
// for i in tmp do
91728: LD_ADDR_VAR 0 1
91732: PUSH
91733: LD_VAR 0 2
91737: PUSH
91738: FOR_IN
91739: IFFALSE 91755
// begin SetLives ( i , 0 ) ;
91741: LD_VAR 0 1
91745: PPUSH
91746: LD_INT 0
91748: PPUSH
91749: CALL_OW 234
// end ;
91753: GO 91738
91755: POP
91756: POP
// end ;
91757: PPOPN 2
91759: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91760: LD_EXP 112
91764: PUSH
91765: LD_EXP 115
91769: AND
91770: IFFALSE 91863
91772: GO 91774
91774: DISABLE
91775: LD_INT 0
91777: PPUSH
// begin enable ;
91778: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91779: LD_ADDR_VAR 0 1
91783: PUSH
91784: LD_INT 22
91786: PUSH
91787: LD_OWVAR 2
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 2
91798: PUSH
91799: LD_INT 25
91801: PUSH
91802: LD_INT 5
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 25
91811: PUSH
91812: LD_INT 9
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 25
91821: PUSH
91822: LD_INT 8
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PPUSH
91839: CALL_OW 69
91843: PUSH
91844: FOR_IN
91845: IFFALSE 91861
// begin SetClass ( i , 1 ) ;
91847: LD_VAR 0 1
91851: PPUSH
91852: LD_INT 1
91854: PPUSH
91855: CALL_OW 336
// end ;
91859: GO 91844
91861: POP
91862: POP
// end ;
91863: PPOPN 1
91865: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91866: LD_EXP 112
91870: PUSH
91871: LD_EXP 116
91875: AND
91876: PUSH
91877: LD_OWVAR 65
91881: PUSH
91882: LD_INT 7
91884: LESS
91885: AND
91886: IFFALSE 91900
91888: GO 91890
91890: DISABLE
// begin enable ;
91891: ENABLE
// game_speed := 7 ;
91892: LD_ADDR_OWVAR 65
91896: PUSH
91897: LD_INT 7
91899: ST_TO_ADDR
// end ;
91900: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91901: LD_EXP 112
91905: PUSH
91906: LD_EXP 119
91910: AND
91911: IFFALSE 92113
91913: GO 91915
91915: DISABLE
91916: LD_INT 0
91918: PPUSH
91919: PPUSH
91920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91921: LD_ADDR_VAR 0 3
91925: PUSH
91926: LD_INT 81
91928: PUSH
91929: LD_OWVAR 2
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 21
91940: PUSH
91941: LD_INT 1
91943: PUSH
91944: EMPTY
91945: LIST
91946: LIST
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PPUSH
91952: CALL_OW 69
91956: ST_TO_ADDR
// if not tmp then
91957: LD_VAR 0 3
91961: NOT
91962: IFFALSE 91966
// exit ;
91964: GO 92113
// if tmp > 5 then
91966: LD_VAR 0 3
91970: PUSH
91971: LD_INT 5
91973: GREATER
91974: IFFALSE 91986
// k := 5 else
91976: LD_ADDR_VAR 0 2
91980: PUSH
91981: LD_INT 5
91983: ST_TO_ADDR
91984: GO 91996
// k := tmp ;
91986: LD_ADDR_VAR 0 2
91990: PUSH
91991: LD_VAR 0 3
91995: ST_TO_ADDR
// for i := 1 to k do
91996: LD_ADDR_VAR 0 1
92000: PUSH
92001: DOUBLE
92002: LD_INT 1
92004: DEC
92005: ST_TO_ADDR
92006: LD_VAR 0 2
92010: PUSH
92011: FOR_TO
92012: IFFALSE 92111
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92014: LD_VAR 0 3
92018: PUSH
92019: LD_VAR 0 1
92023: ARRAY
92024: PPUSH
92025: LD_VAR 0 1
92029: PUSH
92030: LD_INT 4
92032: MOD
92033: PUSH
92034: LD_INT 1
92036: PLUS
92037: PPUSH
92038: CALL_OW 259
92042: PUSH
92043: LD_INT 10
92045: LESS
92046: IFFALSE 92109
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92048: LD_VAR 0 3
92052: PUSH
92053: LD_VAR 0 1
92057: ARRAY
92058: PPUSH
92059: LD_VAR 0 1
92063: PUSH
92064: LD_INT 4
92066: MOD
92067: PUSH
92068: LD_INT 1
92070: PLUS
92071: PPUSH
92072: LD_VAR 0 3
92076: PUSH
92077: LD_VAR 0 1
92081: ARRAY
92082: PPUSH
92083: LD_VAR 0 1
92087: PUSH
92088: LD_INT 4
92090: MOD
92091: PUSH
92092: LD_INT 1
92094: PLUS
92095: PPUSH
92096: CALL_OW 259
92100: PUSH
92101: LD_INT 1
92103: PLUS
92104: PPUSH
92105: CALL_OW 237
92109: GO 92011
92111: POP
92112: POP
// end ;
92113: PPOPN 3
92115: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92116: LD_EXP 112
92120: PUSH
92121: LD_EXP 120
92125: AND
92126: IFFALSE 92146
92128: GO 92130
92130: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92131: LD_INT 4
92133: PPUSH
92134: LD_OWVAR 2
92138: PPUSH
92139: LD_INT 0
92141: PPUSH
92142: CALL_OW 324
92146: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92147: LD_EXP 112
92151: PUSH
92152: LD_EXP 149
92156: AND
92157: IFFALSE 92177
92159: GO 92161
92161: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92162: LD_INT 19
92164: PPUSH
92165: LD_OWVAR 2
92169: PPUSH
92170: LD_INT 0
92172: PPUSH
92173: CALL_OW 324
92177: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92178: LD_EXP 112
92182: PUSH
92183: LD_EXP 121
92187: AND
92188: IFFALSE 92290
92190: GO 92192
92192: DISABLE
92193: LD_INT 0
92195: PPUSH
92196: PPUSH
// begin enable ;
92197: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92198: LD_ADDR_VAR 0 2
92202: PUSH
92203: LD_INT 22
92205: PUSH
92206: LD_OWVAR 2
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 2
92217: PUSH
92218: LD_INT 34
92220: PUSH
92221: LD_INT 11
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 34
92230: PUSH
92231: LD_INT 30
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: LIST
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PPUSH
92247: CALL_OW 69
92251: ST_TO_ADDR
// if not tmp then
92252: LD_VAR 0 2
92256: NOT
92257: IFFALSE 92261
// exit ;
92259: GO 92290
// for i in tmp do
92261: LD_ADDR_VAR 0 1
92265: PUSH
92266: LD_VAR 0 2
92270: PUSH
92271: FOR_IN
92272: IFFALSE 92288
// begin SetLives ( i , 0 ) ;
92274: LD_VAR 0 1
92278: PPUSH
92279: LD_INT 0
92281: PPUSH
92282: CALL_OW 234
// end ;
92286: GO 92271
92288: POP
92289: POP
// end ;
92290: PPOPN 2
92292: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92293: LD_EXP 112
92297: PUSH
92298: LD_EXP 122
92302: AND
92303: IFFALSE 92323
92305: GO 92307
92307: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92308: LD_INT 32
92310: PPUSH
92311: LD_OWVAR 2
92315: PPUSH
92316: LD_INT 0
92318: PPUSH
92319: CALL_OW 324
92323: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92324: LD_EXP 112
92328: PUSH
92329: LD_EXP 123
92333: AND
92334: IFFALSE 92515
92336: GO 92338
92338: DISABLE
92339: LD_INT 0
92341: PPUSH
92342: PPUSH
92343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92344: LD_ADDR_VAR 0 2
92348: PUSH
92349: LD_INT 22
92351: PUSH
92352: LD_OWVAR 2
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 33
92363: PUSH
92364: LD_INT 3
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PPUSH
92375: CALL_OW 69
92379: ST_TO_ADDR
// if not tmp then
92380: LD_VAR 0 2
92384: NOT
92385: IFFALSE 92389
// exit ;
92387: GO 92515
// side := 0 ;
92389: LD_ADDR_VAR 0 3
92393: PUSH
92394: LD_INT 0
92396: ST_TO_ADDR
// for i := 1 to 8 do
92397: LD_ADDR_VAR 0 1
92401: PUSH
92402: DOUBLE
92403: LD_INT 1
92405: DEC
92406: ST_TO_ADDR
92407: LD_INT 8
92409: PUSH
92410: FOR_TO
92411: IFFALSE 92459
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92413: LD_OWVAR 2
92417: PUSH
92418: LD_VAR 0 1
92422: NONEQUAL
92423: PUSH
92424: LD_OWVAR 2
92428: PPUSH
92429: LD_VAR 0 1
92433: PPUSH
92434: CALL_OW 81
92438: PUSH
92439: LD_INT 2
92441: EQUAL
92442: AND
92443: IFFALSE 92457
// begin side := i ;
92445: LD_ADDR_VAR 0 3
92449: PUSH
92450: LD_VAR 0 1
92454: ST_TO_ADDR
// break ;
92455: GO 92459
// end ;
92457: GO 92410
92459: POP
92460: POP
// if not side then
92461: LD_VAR 0 3
92465: NOT
92466: IFFALSE 92470
// exit ;
92468: GO 92515
// for i := 1 to tmp do
92470: LD_ADDR_VAR 0 1
92474: PUSH
92475: DOUBLE
92476: LD_INT 1
92478: DEC
92479: ST_TO_ADDR
92480: LD_VAR 0 2
92484: PUSH
92485: FOR_TO
92486: IFFALSE 92513
// if Prob ( 60 ) then
92488: LD_INT 60
92490: PPUSH
92491: CALL_OW 13
92495: IFFALSE 92511
// SetSide ( i , side ) ;
92497: LD_VAR 0 1
92501: PPUSH
92502: LD_VAR 0 3
92506: PPUSH
92507: CALL_OW 235
92511: GO 92485
92513: POP
92514: POP
// end ;
92515: PPOPN 3
92517: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92518: LD_EXP 112
92522: PUSH
92523: LD_EXP 125
92527: AND
92528: IFFALSE 92647
92530: GO 92532
92532: DISABLE
92533: LD_INT 0
92535: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92536: LD_ADDR_VAR 0 1
92540: PUSH
92541: LD_INT 22
92543: PUSH
92544: LD_OWVAR 2
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 21
92555: PUSH
92556: LD_INT 1
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 3
92565: PUSH
92566: LD_INT 23
92568: PUSH
92569: LD_INT 0
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: LIST
92584: PPUSH
92585: CALL_OW 69
92589: PUSH
92590: FOR_IN
92591: IFFALSE 92645
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92593: LD_VAR 0 1
92597: PPUSH
92598: CALL_OW 257
92602: PUSH
92603: LD_INT 1
92605: PUSH
92606: LD_INT 2
92608: PUSH
92609: LD_INT 3
92611: PUSH
92612: LD_INT 4
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: IN
92621: IFFALSE 92643
// SetClass ( un , rand ( 1 , 4 ) ) ;
92623: LD_VAR 0 1
92627: PPUSH
92628: LD_INT 1
92630: PPUSH
92631: LD_INT 4
92633: PPUSH
92634: CALL_OW 12
92638: PPUSH
92639: CALL_OW 336
92643: GO 92590
92645: POP
92646: POP
// end ;
92647: PPOPN 1
92649: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92650: LD_EXP 112
92654: PUSH
92655: LD_EXP 124
92659: AND
92660: IFFALSE 92739
92662: GO 92664
92664: DISABLE
92665: LD_INT 0
92667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92668: LD_ADDR_VAR 0 1
92672: PUSH
92673: LD_INT 22
92675: PUSH
92676: LD_OWVAR 2
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 21
92687: PUSH
92688: LD_INT 3
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PPUSH
92699: CALL_OW 69
92703: ST_TO_ADDR
// if not tmp then
92704: LD_VAR 0 1
92708: NOT
92709: IFFALSE 92713
// exit ;
92711: GO 92739
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92713: LD_VAR 0 1
92717: PUSH
92718: LD_INT 1
92720: PPUSH
92721: LD_VAR 0 1
92725: PPUSH
92726: CALL_OW 12
92730: ARRAY
92731: PPUSH
92732: LD_INT 100
92734: PPUSH
92735: CALL_OW 234
// end ;
92739: PPOPN 1
92741: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92742: LD_EXP 112
92746: PUSH
92747: LD_EXP 126
92751: AND
92752: IFFALSE 92850
92754: GO 92756
92756: DISABLE
92757: LD_INT 0
92759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92760: LD_ADDR_VAR 0 1
92764: PUSH
92765: LD_INT 22
92767: PUSH
92768: LD_OWVAR 2
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 21
92779: PUSH
92780: LD_INT 1
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PPUSH
92791: CALL_OW 69
92795: ST_TO_ADDR
// if not tmp then
92796: LD_VAR 0 1
92800: NOT
92801: IFFALSE 92805
// exit ;
92803: GO 92850
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92805: LD_VAR 0 1
92809: PUSH
92810: LD_INT 1
92812: PPUSH
92813: LD_VAR 0 1
92817: PPUSH
92818: CALL_OW 12
92822: ARRAY
92823: PPUSH
92824: LD_INT 1
92826: PPUSH
92827: LD_INT 4
92829: PPUSH
92830: CALL_OW 12
92834: PPUSH
92835: LD_INT 3000
92837: PPUSH
92838: LD_INT 9000
92840: PPUSH
92841: CALL_OW 12
92845: PPUSH
92846: CALL_OW 492
// end ;
92850: PPOPN 1
92852: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92853: LD_EXP 112
92857: PUSH
92858: LD_EXP 127
92862: AND
92863: IFFALSE 92883
92865: GO 92867
92867: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92868: LD_INT 1
92870: PPUSH
92871: LD_OWVAR 2
92875: PPUSH
92876: LD_INT 0
92878: PPUSH
92879: CALL_OW 324
92883: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92884: LD_EXP 112
92888: PUSH
92889: LD_EXP 128
92893: AND
92894: IFFALSE 92977
92896: GO 92898
92898: DISABLE
92899: LD_INT 0
92901: PPUSH
92902: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92903: LD_ADDR_VAR 0 2
92907: PUSH
92908: LD_INT 22
92910: PUSH
92911: LD_OWVAR 2
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 21
92922: PUSH
92923: LD_INT 3
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PPUSH
92934: CALL_OW 69
92938: ST_TO_ADDR
// if not tmp then
92939: LD_VAR 0 2
92943: NOT
92944: IFFALSE 92948
// exit ;
92946: GO 92977
// for i in tmp do
92948: LD_ADDR_VAR 0 1
92952: PUSH
92953: LD_VAR 0 2
92957: PUSH
92958: FOR_IN
92959: IFFALSE 92975
// SetBLevel ( i , 10 ) ;
92961: LD_VAR 0 1
92965: PPUSH
92966: LD_INT 10
92968: PPUSH
92969: CALL_OW 241
92973: GO 92958
92975: POP
92976: POP
// end ;
92977: PPOPN 2
92979: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
92980: LD_EXP 112
92984: PUSH
92985: LD_EXP 129
92989: AND
92990: IFFALSE 93101
92992: GO 92994
92994: DISABLE
92995: LD_INT 0
92997: PPUSH
92998: PPUSH
92999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93000: LD_ADDR_VAR 0 3
93004: PUSH
93005: LD_INT 22
93007: PUSH
93008: LD_OWVAR 2
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 25
93019: PUSH
93020: LD_INT 1
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PPUSH
93031: CALL_OW 69
93035: ST_TO_ADDR
// if not tmp then
93036: LD_VAR 0 3
93040: NOT
93041: IFFALSE 93045
// exit ;
93043: GO 93101
// un := tmp [ rand ( 1 , tmp ) ] ;
93045: LD_ADDR_VAR 0 2
93049: PUSH
93050: LD_VAR 0 3
93054: PUSH
93055: LD_INT 1
93057: PPUSH
93058: LD_VAR 0 3
93062: PPUSH
93063: CALL_OW 12
93067: ARRAY
93068: ST_TO_ADDR
// if Crawls ( un ) then
93069: LD_VAR 0 2
93073: PPUSH
93074: CALL_OW 318
93078: IFFALSE 93089
// ComWalk ( un ) ;
93080: LD_VAR 0 2
93084: PPUSH
93085: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93089: LD_VAR 0 2
93093: PPUSH
93094: LD_INT 5
93096: PPUSH
93097: CALL_OW 336
// end ;
93101: PPOPN 3
93103: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93104: LD_EXP 112
93108: PUSH
93109: LD_EXP 130
93113: AND
93114: PUSH
93115: LD_OWVAR 67
93119: PUSH
93120: LD_INT 4
93122: LESS
93123: AND
93124: IFFALSE 93143
93126: GO 93128
93128: DISABLE
// begin Difficulty := Difficulty + 1 ;
93129: LD_ADDR_OWVAR 67
93133: PUSH
93134: LD_OWVAR 67
93138: PUSH
93139: LD_INT 1
93141: PLUS
93142: ST_TO_ADDR
// end ;
93143: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93144: LD_EXP 112
93148: PUSH
93149: LD_EXP 131
93153: AND
93154: IFFALSE 93257
93156: GO 93158
93158: DISABLE
93159: LD_INT 0
93161: PPUSH
// begin for i := 1 to 5 do
93162: LD_ADDR_VAR 0 1
93166: PUSH
93167: DOUBLE
93168: LD_INT 1
93170: DEC
93171: ST_TO_ADDR
93172: LD_INT 5
93174: PUSH
93175: FOR_TO
93176: IFFALSE 93255
// begin uc_nation := nation_nature ;
93178: LD_ADDR_OWVAR 21
93182: PUSH
93183: LD_INT 0
93185: ST_TO_ADDR
// uc_side := 0 ;
93186: LD_ADDR_OWVAR 20
93190: PUSH
93191: LD_INT 0
93193: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93194: LD_ADDR_OWVAR 29
93198: PUSH
93199: LD_INT 12
93201: PUSH
93202: LD_INT 12
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: ST_TO_ADDR
// hc_agressivity := 20 ;
93209: LD_ADDR_OWVAR 35
93213: PUSH
93214: LD_INT 20
93216: ST_TO_ADDR
// hc_class := class_tiger ;
93217: LD_ADDR_OWVAR 28
93221: PUSH
93222: LD_INT 14
93224: ST_TO_ADDR
// hc_gallery :=  ;
93225: LD_ADDR_OWVAR 33
93229: PUSH
93230: LD_STRING 
93232: ST_TO_ADDR
// hc_name :=  ;
93233: LD_ADDR_OWVAR 26
93237: PUSH
93238: LD_STRING 
93240: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93241: CALL_OW 44
93245: PPUSH
93246: LD_INT 0
93248: PPUSH
93249: CALL_OW 51
// end ;
93253: GO 93175
93255: POP
93256: POP
// end ;
93257: PPOPN 1
93259: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93260: LD_EXP 112
93264: PUSH
93265: LD_EXP 132
93269: AND
93270: IFFALSE 93279
93272: GO 93274
93274: DISABLE
// StreamSibBomb ;
93275: CALL 93280 0 0
93279: END
// export function StreamSibBomb ; var i , x , y ; begin
93280: LD_INT 0
93282: PPUSH
93283: PPUSH
93284: PPUSH
93285: PPUSH
// result := false ;
93286: LD_ADDR_VAR 0 1
93290: PUSH
93291: LD_INT 0
93293: ST_TO_ADDR
// for i := 1 to 16 do
93294: LD_ADDR_VAR 0 2
93298: PUSH
93299: DOUBLE
93300: LD_INT 1
93302: DEC
93303: ST_TO_ADDR
93304: LD_INT 16
93306: PUSH
93307: FOR_TO
93308: IFFALSE 93507
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93310: LD_ADDR_VAR 0 3
93314: PUSH
93315: LD_INT 10
93317: PUSH
93318: LD_INT 20
93320: PUSH
93321: LD_INT 30
93323: PUSH
93324: LD_INT 40
93326: PUSH
93327: LD_INT 50
93329: PUSH
93330: LD_INT 60
93332: PUSH
93333: LD_INT 70
93335: PUSH
93336: LD_INT 80
93338: PUSH
93339: LD_INT 90
93341: PUSH
93342: LD_INT 100
93344: PUSH
93345: LD_INT 110
93347: PUSH
93348: LD_INT 120
93350: PUSH
93351: LD_INT 130
93353: PUSH
93354: LD_INT 140
93356: PUSH
93357: LD_INT 150
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: PUSH
93377: LD_INT 1
93379: PPUSH
93380: LD_INT 15
93382: PPUSH
93383: CALL_OW 12
93387: ARRAY
93388: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93389: LD_ADDR_VAR 0 4
93393: PUSH
93394: LD_INT 10
93396: PUSH
93397: LD_INT 20
93399: PUSH
93400: LD_INT 30
93402: PUSH
93403: LD_INT 40
93405: PUSH
93406: LD_INT 50
93408: PUSH
93409: LD_INT 60
93411: PUSH
93412: LD_INT 70
93414: PUSH
93415: LD_INT 80
93417: PUSH
93418: LD_INT 90
93420: PUSH
93421: LD_INT 100
93423: PUSH
93424: LD_INT 110
93426: PUSH
93427: LD_INT 120
93429: PUSH
93430: LD_INT 130
93432: PUSH
93433: LD_INT 140
93435: PUSH
93436: LD_INT 150
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 1
93458: PPUSH
93459: LD_INT 15
93461: PPUSH
93462: CALL_OW 12
93466: ARRAY
93467: ST_TO_ADDR
// if ValidHex ( x , y ) then
93468: LD_VAR 0 3
93472: PPUSH
93473: LD_VAR 0 4
93477: PPUSH
93478: CALL_OW 488
93482: IFFALSE 93505
// begin result := [ x , y ] ;
93484: LD_ADDR_VAR 0 1
93488: PUSH
93489: LD_VAR 0 3
93493: PUSH
93494: LD_VAR 0 4
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: ST_TO_ADDR
// break ;
93503: GO 93507
// end ; end ;
93505: GO 93307
93507: POP
93508: POP
// if result then
93509: LD_VAR 0 1
93513: IFFALSE 93573
// begin ToLua ( playSibBomb() ) ;
93515: LD_STRING playSibBomb()
93517: PPUSH
93518: CALL_OW 559
// wait ( 0 0$14 ) ;
93522: LD_INT 490
93524: PPUSH
93525: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93529: LD_VAR 0 1
93533: PUSH
93534: LD_INT 1
93536: ARRAY
93537: PPUSH
93538: LD_VAR 0 1
93542: PUSH
93543: LD_INT 2
93545: ARRAY
93546: PPUSH
93547: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93551: LD_VAR 0 1
93555: PUSH
93556: LD_INT 1
93558: ARRAY
93559: PPUSH
93560: LD_VAR 0 1
93564: PUSH
93565: LD_INT 2
93567: ARRAY
93568: PPUSH
93569: CALL_OW 429
// end ; end ;
93573: LD_VAR 0 1
93577: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93578: LD_EXP 112
93582: PUSH
93583: LD_EXP 134
93587: AND
93588: IFFALSE 93600
93590: GO 93592
93592: DISABLE
// YouLost (  ) ;
93593: LD_STRING 
93595: PPUSH
93596: CALL_OW 104
93600: END
// every 0 0$1 trigger StreamModeActive and sFog do
93601: LD_EXP 112
93605: PUSH
93606: LD_EXP 133
93610: AND
93611: IFFALSE 93625
93613: GO 93615
93615: DISABLE
// FogOff ( your_side ) ;
93616: LD_OWVAR 2
93620: PPUSH
93621: CALL_OW 344
93625: END
// every 0 0$1 trigger StreamModeActive and sSun do
93626: LD_EXP 112
93630: PUSH
93631: LD_EXP 135
93635: AND
93636: IFFALSE 93664
93638: GO 93640
93640: DISABLE
// begin solar_recharge_percent := 0 ;
93641: LD_ADDR_OWVAR 79
93645: PUSH
93646: LD_INT 0
93648: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93649: LD_INT 10500
93651: PPUSH
93652: CALL_OW 67
// solar_recharge_percent := 100 ;
93656: LD_ADDR_OWVAR 79
93660: PUSH
93661: LD_INT 100
93663: ST_TO_ADDR
// end ;
93664: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93665: LD_EXP 112
93669: PUSH
93670: LD_EXP 136
93674: AND
93675: IFFALSE 93914
93677: GO 93679
93679: DISABLE
93680: LD_INT 0
93682: PPUSH
93683: PPUSH
93684: PPUSH
// begin tmp := [ ] ;
93685: LD_ADDR_VAR 0 3
93689: PUSH
93690: EMPTY
93691: ST_TO_ADDR
// for i := 1 to 6 do
93692: LD_ADDR_VAR 0 1
93696: PUSH
93697: DOUBLE
93698: LD_INT 1
93700: DEC
93701: ST_TO_ADDR
93702: LD_INT 6
93704: PUSH
93705: FOR_TO
93706: IFFALSE 93811
// begin uc_nation := nation_nature ;
93708: LD_ADDR_OWVAR 21
93712: PUSH
93713: LD_INT 0
93715: ST_TO_ADDR
// uc_side := 0 ;
93716: LD_ADDR_OWVAR 20
93720: PUSH
93721: LD_INT 0
93723: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93724: LD_ADDR_OWVAR 29
93728: PUSH
93729: LD_INT 12
93731: PUSH
93732: LD_INT 12
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: ST_TO_ADDR
// hc_agressivity := 20 ;
93739: LD_ADDR_OWVAR 35
93743: PUSH
93744: LD_INT 20
93746: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93747: LD_ADDR_OWVAR 28
93751: PUSH
93752: LD_INT 17
93754: ST_TO_ADDR
// hc_gallery :=  ;
93755: LD_ADDR_OWVAR 33
93759: PUSH
93760: LD_STRING 
93762: ST_TO_ADDR
// hc_name :=  ;
93763: LD_ADDR_OWVAR 26
93767: PUSH
93768: LD_STRING 
93770: ST_TO_ADDR
// un := CreateHuman ;
93771: LD_ADDR_VAR 0 2
93775: PUSH
93776: CALL_OW 44
93780: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93781: LD_VAR 0 2
93785: PPUSH
93786: LD_INT 1
93788: PPUSH
93789: CALL_OW 51
// tmp := tmp ^ un ;
93793: LD_ADDR_VAR 0 3
93797: PUSH
93798: LD_VAR 0 3
93802: PUSH
93803: LD_VAR 0 2
93807: ADD
93808: ST_TO_ADDR
// end ;
93809: GO 93705
93811: POP
93812: POP
// repeat wait ( 0 0$1 ) ;
93813: LD_INT 35
93815: PPUSH
93816: CALL_OW 67
// for un in tmp do
93820: LD_ADDR_VAR 0 2
93824: PUSH
93825: LD_VAR 0 3
93829: PUSH
93830: FOR_IN
93831: IFFALSE 93905
// begin if IsDead ( un ) then
93833: LD_VAR 0 2
93837: PPUSH
93838: CALL_OW 301
93842: IFFALSE 93862
// begin tmp := tmp diff un ;
93844: LD_ADDR_VAR 0 3
93848: PUSH
93849: LD_VAR 0 3
93853: PUSH
93854: LD_VAR 0 2
93858: DIFF
93859: ST_TO_ADDR
// continue ;
93860: GO 93830
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93862: LD_VAR 0 2
93866: PPUSH
93867: LD_INT 3
93869: PUSH
93870: LD_INT 22
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PPUSH
93884: CALL_OW 69
93888: PPUSH
93889: LD_VAR 0 2
93893: PPUSH
93894: CALL_OW 74
93898: PPUSH
93899: CALL_OW 115
// end ;
93903: GO 93830
93905: POP
93906: POP
// until not tmp ;
93907: LD_VAR 0 3
93911: NOT
93912: IFFALSE 93813
// end ;
93914: PPOPN 3
93916: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93917: LD_EXP 112
93921: PUSH
93922: LD_EXP 137
93926: AND
93927: IFFALSE 93981
93929: GO 93931
93931: DISABLE
// begin ToLua ( displayTroll(); ) ;
93932: LD_STRING displayTroll();
93934: PPUSH
93935: CALL_OW 559
// wait ( 3 3$00 ) ;
93939: LD_INT 6300
93941: PPUSH
93942: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93946: LD_STRING hideTroll();
93948: PPUSH
93949: CALL_OW 559
// wait ( 1 1$00 ) ;
93953: LD_INT 2100
93955: PPUSH
93956: CALL_OW 67
// ToLua ( displayTroll(); ) ;
93960: LD_STRING displayTroll();
93962: PPUSH
93963: CALL_OW 559
// wait ( 1 1$00 ) ;
93967: LD_INT 2100
93969: PPUSH
93970: CALL_OW 67
// ToLua ( hideTroll(); ) ;
93974: LD_STRING hideTroll();
93976: PPUSH
93977: CALL_OW 559
// end ;
93981: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
93982: LD_EXP 112
93986: PUSH
93987: LD_EXP 138
93991: AND
93992: IFFALSE 94055
93994: GO 93996
93996: DISABLE
93997: LD_INT 0
93999: PPUSH
// begin p := 0 ;
94000: LD_ADDR_VAR 0 1
94004: PUSH
94005: LD_INT 0
94007: ST_TO_ADDR
// repeat game_speed := 1 ;
94008: LD_ADDR_OWVAR 65
94012: PUSH
94013: LD_INT 1
94015: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94016: LD_INT 35
94018: PPUSH
94019: CALL_OW 67
// p := p + 1 ;
94023: LD_ADDR_VAR 0 1
94027: PUSH
94028: LD_VAR 0 1
94032: PUSH
94033: LD_INT 1
94035: PLUS
94036: ST_TO_ADDR
// until p >= 60 ;
94037: LD_VAR 0 1
94041: PUSH
94042: LD_INT 60
94044: GREATEREQUAL
94045: IFFALSE 94008
// game_speed := 4 ;
94047: LD_ADDR_OWVAR 65
94051: PUSH
94052: LD_INT 4
94054: ST_TO_ADDR
// end ;
94055: PPOPN 1
94057: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94058: LD_EXP 112
94062: PUSH
94063: LD_EXP 139
94067: AND
94068: IFFALSE 94214
94070: GO 94072
94072: DISABLE
94073: LD_INT 0
94075: PPUSH
94076: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94077: LD_ADDR_VAR 0 1
94081: PUSH
94082: LD_INT 22
94084: PUSH
94085: LD_OWVAR 2
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: LD_INT 2
94096: PUSH
94097: LD_INT 30
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 30
94109: PUSH
94110: LD_INT 1
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: LIST
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PPUSH
94126: CALL_OW 69
94130: ST_TO_ADDR
// if not depot then
94131: LD_VAR 0 1
94135: NOT
94136: IFFALSE 94140
// exit ;
94138: GO 94214
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94140: LD_ADDR_VAR 0 2
94144: PUSH
94145: LD_VAR 0 1
94149: PUSH
94150: LD_INT 1
94152: PPUSH
94153: LD_VAR 0 1
94157: PPUSH
94158: CALL_OW 12
94162: ARRAY
94163: PPUSH
94164: CALL_OW 274
94168: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94169: LD_VAR 0 2
94173: PPUSH
94174: LD_INT 1
94176: PPUSH
94177: LD_INT 0
94179: PPUSH
94180: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94184: LD_VAR 0 2
94188: PPUSH
94189: LD_INT 2
94191: PPUSH
94192: LD_INT 0
94194: PPUSH
94195: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94199: LD_VAR 0 2
94203: PPUSH
94204: LD_INT 3
94206: PPUSH
94207: LD_INT 0
94209: PPUSH
94210: CALL_OW 277
// end ;
94214: PPOPN 2
94216: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94217: LD_EXP 112
94221: PUSH
94222: LD_EXP 140
94226: AND
94227: IFFALSE 94324
94229: GO 94231
94231: DISABLE
94232: LD_INT 0
94234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94235: LD_ADDR_VAR 0 1
94239: PUSH
94240: LD_INT 22
94242: PUSH
94243: LD_OWVAR 2
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 21
94254: PUSH
94255: LD_INT 1
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 3
94264: PUSH
94265: LD_INT 23
94267: PUSH
94268: LD_INT 0
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: LIST
94283: PPUSH
94284: CALL_OW 69
94288: ST_TO_ADDR
// if not tmp then
94289: LD_VAR 0 1
94293: NOT
94294: IFFALSE 94298
// exit ;
94296: GO 94324
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94298: LD_VAR 0 1
94302: PUSH
94303: LD_INT 1
94305: PPUSH
94306: LD_VAR 0 1
94310: PPUSH
94311: CALL_OW 12
94315: ARRAY
94316: PPUSH
94317: LD_INT 200
94319: PPUSH
94320: CALL_OW 234
// end ;
94324: PPOPN 1
94326: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94327: LD_EXP 112
94331: PUSH
94332: LD_EXP 141
94336: AND
94337: IFFALSE 94416
94339: GO 94341
94341: DISABLE
94342: LD_INT 0
94344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94345: LD_ADDR_VAR 0 1
94349: PUSH
94350: LD_INT 22
94352: PUSH
94353: LD_OWVAR 2
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 21
94364: PUSH
94365: LD_INT 2
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PPUSH
94376: CALL_OW 69
94380: ST_TO_ADDR
// if not tmp then
94381: LD_VAR 0 1
94385: NOT
94386: IFFALSE 94390
// exit ;
94388: GO 94416
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94390: LD_VAR 0 1
94394: PUSH
94395: LD_INT 1
94397: PPUSH
94398: LD_VAR 0 1
94402: PPUSH
94403: CALL_OW 12
94407: ARRAY
94408: PPUSH
94409: LD_INT 60
94411: PPUSH
94412: CALL_OW 234
// end ;
94416: PPOPN 1
94418: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94419: LD_EXP 112
94423: PUSH
94424: LD_EXP 142
94428: AND
94429: IFFALSE 94528
94431: GO 94433
94433: DISABLE
94434: LD_INT 0
94436: PPUSH
94437: PPUSH
// begin enable ;
94438: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94439: LD_ADDR_VAR 0 1
94443: PUSH
94444: LD_INT 22
94446: PUSH
94447: LD_OWVAR 2
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 61
94458: PUSH
94459: EMPTY
94460: LIST
94461: PUSH
94462: LD_INT 33
94464: PUSH
94465: LD_INT 2
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: LIST
94476: PPUSH
94477: CALL_OW 69
94481: ST_TO_ADDR
// if not tmp then
94482: LD_VAR 0 1
94486: NOT
94487: IFFALSE 94491
// exit ;
94489: GO 94528
// for i in tmp do
94491: LD_ADDR_VAR 0 2
94495: PUSH
94496: LD_VAR 0 1
94500: PUSH
94501: FOR_IN
94502: IFFALSE 94526
// if IsControledBy ( i ) then
94504: LD_VAR 0 2
94508: PPUSH
94509: CALL_OW 312
94513: IFFALSE 94524
// ComUnlink ( i ) ;
94515: LD_VAR 0 2
94519: PPUSH
94520: CALL_OW 136
94524: GO 94501
94526: POP
94527: POP
// end ;
94528: PPOPN 2
94530: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94531: LD_EXP 112
94535: PUSH
94536: LD_EXP 143
94540: AND
94541: IFFALSE 94681
94543: GO 94545
94545: DISABLE
94546: LD_INT 0
94548: PPUSH
94549: PPUSH
// begin ToLua ( displayPowell(); ) ;
94550: LD_STRING displayPowell();
94552: PPUSH
94553: CALL_OW 559
// uc_side := 0 ;
94557: LD_ADDR_OWVAR 20
94561: PUSH
94562: LD_INT 0
94564: ST_TO_ADDR
// uc_nation := 2 ;
94565: LD_ADDR_OWVAR 21
94569: PUSH
94570: LD_INT 2
94572: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94573: LD_ADDR_OWVAR 37
94577: PUSH
94578: LD_INT 14
94580: ST_TO_ADDR
// vc_engine := engine_siberite ;
94581: LD_ADDR_OWVAR 39
94585: PUSH
94586: LD_INT 3
94588: ST_TO_ADDR
// vc_control := control_apeman ;
94589: LD_ADDR_OWVAR 38
94593: PUSH
94594: LD_INT 5
94596: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94597: LD_ADDR_OWVAR 40
94601: PUSH
94602: LD_INT 29
94604: ST_TO_ADDR
// un := CreateVehicle ;
94605: LD_ADDR_VAR 0 2
94609: PUSH
94610: CALL_OW 45
94614: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94615: LD_VAR 0 2
94619: PPUSH
94620: LD_INT 1
94622: PPUSH
94623: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94627: LD_INT 35
94629: PPUSH
94630: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94634: LD_VAR 0 2
94638: PPUSH
94639: LD_INT 22
94641: PUSH
94642: LD_OWVAR 2
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PPUSH
94651: CALL_OW 69
94655: PPUSH
94656: LD_VAR 0 2
94660: PPUSH
94661: CALL_OW 74
94665: PPUSH
94666: CALL_OW 115
// until IsDead ( un ) ;
94670: LD_VAR 0 2
94674: PPUSH
94675: CALL_OW 301
94679: IFFALSE 94627
// end ;
94681: PPOPN 2
94683: END
// every 0 0$1 trigger StreamModeActive and sStu do
94684: LD_EXP 112
94688: PUSH
94689: LD_EXP 151
94693: AND
94694: IFFALSE 94710
94696: GO 94698
94698: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94699: LD_STRING displayStucuk();
94701: PPUSH
94702: CALL_OW 559
// ResetFog ;
94706: CALL_OW 335
// end ;
94710: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94711: LD_EXP 112
94715: PUSH
94716: LD_EXP 144
94720: AND
94721: IFFALSE 94862
94723: GO 94725
94725: DISABLE
94726: LD_INT 0
94728: PPUSH
94729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94730: LD_ADDR_VAR 0 2
94734: PUSH
94735: LD_INT 22
94737: PUSH
94738: LD_OWVAR 2
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: LD_INT 21
94749: PUSH
94750: LD_INT 1
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: EMPTY
94758: LIST
94759: LIST
94760: PPUSH
94761: CALL_OW 69
94765: ST_TO_ADDR
// if not tmp then
94766: LD_VAR 0 2
94770: NOT
94771: IFFALSE 94775
// exit ;
94773: GO 94862
// un := tmp [ rand ( 1 , tmp ) ] ;
94775: LD_ADDR_VAR 0 1
94779: PUSH
94780: LD_VAR 0 2
94784: PUSH
94785: LD_INT 1
94787: PPUSH
94788: LD_VAR 0 2
94792: PPUSH
94793: CALL_OW 12
94797: ARRAY
94798: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94799: LD_VAR 0 1
94803: PPUSH
94804: LD_INT 0
94806: PPUSH
94807: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94811: LD_VAR 0 1
94815: PPUSH
94816: LD_OWVAR 3
94820: PUSH
94821: LD_VAR 0 1
94825: DIFF
94826: PPUSH
94827: LD_VAR 0 1
94831: PPUSH
94832: CALL_OW 74
94836: PPUSH
94837: CALL_OW 115
// wait ( 0 0$20 ) ;
94841: LD_INT 700
94843: PPUSH
94844: CALL_OW 67
// SetSide ( un , your_side ) ;
94848: LD_VAR 0 1
94852: PPUSH
94853: LD_OWVAR 2
94857: PPUSH
94858: CALL_OW 235
// end ;
94862: PPOPN 2
94864: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94865: LD_EXP 112
94869: PUSH
94870: LD_EXP 145
94874: AND
94875: IFFALSE 94981
94877: GO 94879
94879: DISABLE
94880: LD_INT 0
94882: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94883: LD_ADDR_VAR 0 1
94887: PUSH
94888: LD_INT 22
94890: PUSH
94891: LD_OWVAR 2
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 2
94902: PUSH
94903: LD_INT 30
94905: PUSH
94906: LD_INT 0
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 30
94915: PUSH
94916: LD_INT 1
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: LIST
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: PPUSH
94932: CALL_OW 69
94936: ST_TO_ADDR
// if not depot then
94937: LD_VAR 0 1
94941: NOT
94942: IFFALSE 94946
// exit ;
94944: GO 94981
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
94946: LD_VAR 0 1
94950: PUSH
94951: LD_INT 1
94953: ARRAY
94954: PPUSH
94955: CALL_OW 250
94959: PPUSH
94960: LD_VAR 0 1
94964: PUSH
94965: LD_INT 1
94967: ARRAY
94968: PPUSH
94969: CALL_OW 251
94973: PPUSH
94974: LD_INT 70
94976: PPUSH
94977: CALL_OW 495
// end ;
94981: PPOPN 1
94983: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
94984: LD_EXP 112
94988: PUSH
94989: LD_EXP 146
94993: AND
94994: IFFALSE 95205
94996: GO 94998
94998: DISABLE
94999: LD_INT 0
95001: PPUSH
95002: PPUSH
95003: PPUSH
95004: PPUSH
95005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95006: LD_ADDR_VAR 0 5
95010: PUSH
95011: LD_INT 22
95013: PUSH
95014: LD_OWVAR 2
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 21
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PPUSH
95037: CALL_OW 69
95041: ST_TO_ADDR
// if not tmp then
95042: LD_VAR 0 5
95046: NOT
95047: IFFALSE 95051
// exit ;
95049: GO 95205
// for i in tmp do
95051: LD_ADDR_VAR 0 1
95055: PUSH
95056: LD_VAR 0 5
95060: PUSH
95061: FOR_IN
95062: IFFALSE 95203
// begin d := rand ( 0 , 5 ) ;
95064: LD_ADDR_VAR 0 4
95068: PUSH
95069: LD_INT 0
95071: PPUSH
95072: LD_INT 5
95074: PPUSH
95075: CALL_OW 12
95079: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95080: LD_ADDR_VAR 0 2
95084: PUSH
95085: LD_VAR 0 1
95089: PPUSH
95090: CALL_OW 250
95094: PPUSH
95095: LD_VAR 0 4
95099: PPUSH
95100: LD_INT 3
95102: PPUSH
95103: LD_INT 12
95105: PPUSH
95106: CALL_OW 12
95110: PPUSH
95111: CALL_OW 272
95115: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95116: LD_ADDR_VAR 0 3
95120: PUSH
95121: LD_VAR 0 1
95125: PPUSH
95126: CALL_OW 251
95130: PPUSH
95131: LD_VAR 0 4
95135: PPUSH
95136: LD_INT 3
95138: PPUSH
95139: LD_INT 12
95141: PPUSH
95142: CALL_OW 12
95146: PPUSH
95147: CALL_OW 273
95151: ST_TO_ADDR
// if ValidHex ( x , y ) then
95152: LD_VAR 0 2
95156: PPUSH
95157: LD_VAR 0 3
95161: PPUSH
95162: CALL_OW 488
95166: IFFALSE 95201
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95168: LD_VAR 0 1
95172: PPUSH
95173: LD_VAR 0 2
95177: PPUSH
95178: LD_VAR 0 3
95182: PPUSH
95183: LD_INT 3
95185: PPUSH
95186: LD_INT 6
95188: PPUSH
95189: CALL_OW 12
95193: PPUSH
95194: LD_INT 1
95196: PPUSH
95197: CALL_OW 483
// end ;
95201: GO 95061
95203: POP
95204: POP
// end ;
95205: PPOPN 5
95207: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95208: LD_EXP 112
95212: PUSH
95213: LD_EXP 147
95217: AND
95218: IFFALSE 95312
95220: GO 95222
95222: DISABLE
95223: LD_INT 0
95225: PPUSH
95226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95227: LD_ADDR_VAR 0 2
95231: PUSH
95232: LD_INT 22
95234: PUSH
95235: LD_OWVAR 2
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 32
95246: PUSH
95247: LD_INT 1
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: LD_INT 21
95256: PUSH
95257: LD_INT 2
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: LIST
95268: PPUSH
95269: CALL_OW 69
95273: ST_TO_ADDR
// if not tmp then
95274: LD_VAR 0 2
95278: NOT
95279: IFFALSE 95283
// exit ;
95281: GO 95312
// for i in tmp do
95283: LD_ADDR_VAR 0 1
95287: PUSH
95288: LD_VAR 0 2
95292: PUSH
95293: FOR_IN
95294: IFFALSE 95310
// SetFuel ( i , 0 ) ;
95296: LD_VAR 0 1
95300: PPUSH
95301: LD_INT 0
95303: PPUSH
95304: CALL_OW 240
95308: GO 95293
95310: POP
95311: POP
// end ;
95312: PPOPN 2
95314: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95315: LD_EXP 112
95319: PUSH
95320: LD_EXP 148
95324: AND
95325: IFFALSE 95391
95327: GO 95329
95329: DISABLE
95330: LD_INT 0
95332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95333: LD_ADDR_VAR 0 1
95337: PUSH
95338: LD_INT 22
95340: PUSH
95341: LD_OWVAR 2
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 30
95352: PUSH
95353: LD_INT 29
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: PPUSH
95364: CALL_OW 69
95368: ST_TO_ADDR
// if not tmp then
95369: LD_VAR 0 1
95373: NOT
95374: IFFALSE 95378
// exit ;
95376: GO 95391
// DestroyUnit ( tmp [ 1 ] ) ;
95378: LD_VAR 0 1
95382: PUSH
95383: LD_INT 1
95385: ARRAY
95386: PPUSH
95387: CALL_OW 65
// end ;
95391: PPOPN 1
95393: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95394: LD_EXP 112
95398: PUSH
95399: LD_EXP 150
95403: AND
95404: IFFALSE 95533
95406: GO 95408
95408: DISABLE
95409: LD_INT 0
95411: PPUSH
// begin uc_side := 0 ;
95412: LD_ADDR_OWVAR 20
95416: PUSH
95417: LD_INT 0
95419: ST_TO_ADDR
// uc_nation := nation_arabian ;
95420: LD_ADDR_OWVAR 21
95424: PUSH
95425: LD_INT 2
95427: ST_TO_ADDR
// hc_gallery :=  ;
95428: LD_ADDR_OWVAR 33
95432: PUSH
95433: LD_STRING 
95435: ST_TO_ADDR
// hc_name :=  ;
95436: LD_ADDR_OWVAR 26
95440: PUSH
95441: LD_STRING 
95443: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95444: LD_INT 1
95446: PPUSH
95447: LD_INT 11
95449: PPUSH
95450: LD_INT 10
95452: PPUSH
95453: CALL_OW 380
// un := CreateHuman ;
95457: LD_ADDR_VAR 0 1
95461: PUSH
95462: CALL_OW 44
95466: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95467: LD_VAR 0 1
95471: PPUSH
95472: LD_INT 1
95474: PPUSH
95475: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95479: LD_INT 35
95481: PPUSH
95482: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95486: LD_VAR 0 1
95490: PPUSH
95491: LD_INT 22
95493: PUSH
95494: LD_OWVAR 2
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PPUSH
95503: CALL_OW 69
95507: PPUSH
95508: LD_VAR 0 1
95512: PPUSH
95513: CALL_OW 74
95517: PPUSH
95518: CALL_OW 115
// until IsDead ( un ) ;
95522: LD_VAR 0 1
95526: PPUSH
95527: CALL_OW 301
95531: IFFALSE 95479
// end ;
95533: PPOPN 1
95535: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95536: LD_EXP 112
95540: PUSH
95541: LD_EXP 152
95545: AND
95546: IFFALSE 95558
95548: GO 95550
95550: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95551: LD_STRING earthquake(getX(game), 0, 32)
95553: PPUSH
95554: CALL_OW 559
95558: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95559: LD_EXP 112
95563: PUSH
95564: LD_EXP 153
95568: AND
95569: IFFALSE 95660
95571: GO 95573
95573: DISABLE
95574: LD_INT 0
95576: PPUSH
// begin enable ;
95577: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95578: LD_ADDR_VAR 0 1
95582: PUSH
95583: LD_INT 22
95585: PUSH
95586: LD_OWVAR 2
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 21
95597: PUSH
95598: LD_INT 2
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 33
95607: PUSH
95608: LD_INT 3
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: LIST
95619: PPUSH
95620: CALL_OW 69
95624: ST_TO_ADDR
// if not tmp then
95625: LD_VAR 0 1
95629: NOT
95630: IFFALSE 95634
// exit ;
95632: GO 95660
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95634: LD_VAR 0 1
95638: PUSH
95639: LD_INT 1
95641: PPUSH
95642: LD_VAR 0 1
95646: PPUSH
95647: CALL_OW 12
95651: ARRAY
95652: PPUSH
95653: LD_INT 1
95655: PPUSH
95656: CALL_OW 234
// end ;
95660: PPOPN 1
95662: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95663: LD_EXP 112
95667: PUSH
95668: LD_EXP 154
95672: AND
95673: IFFALSE 95814
95675: GO 95677
95677: DISABLE
95678: LD_INT 0
95680: PPUSH
95681: PPUSH
95682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95683: LD_ADDR_VAR 0 3
95687: PUSH
95688: LD_INT 22
95690: PUSH
95691: LD_OWVAR 2
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 25
95702: PUSH
95703: LD_INT 1
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PPUSH
95714: CALL_OW 69
95718: ST_TO_ADDR
// if not tmp then
95719: LD_VAR 0 3
95723: NOT
95724: IFFALSE 95728
// exit ;
95726: GO 95814
// un := tmp [ rand ( 1 , tmp ) ] ;
95728: LD_ADDR_VAR 0 2
95732: PUSH
95733: LD_VAR 0 3
95737: PUSH
95738: LD_INT 1
95740: PPUSH
95741: LD_VAR 0 3
95745: PPUSH
95746: CALL_OW 12
95750: ARRAY
95751: ST_TO_ADDR
// if Crawls ( un ) then
95752: LD_VAR 0 2
95756: PPUSH
95757: CALL_OW 318
95761: IFFALSE 95772
// ComWalk ( un ) ;
95763: LD_VAR 0 2
95767: PPUSH
95768: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95772: LD_VAR 0 2
95776: PPUSH
95777: LD_INT 9
95779: PPUSH
95780: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95784: LD_INT 28
95786: PPUSH
95787: LD_OWVAR 2
95791: PPUSH
95792: LD_INT 2
95794: PPUSH
95795: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95799: LD_INT 29
95801: PPUSH
95802: LD_OWVAR 2
95806: PPUSH
95807: LD_INT 2
95809: PPUSH
95810: CALL_OW 322
// end ;
95814: PPOPN 3
95816: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95817: LD_EXP 112
95821: PUSH
95822: LD_EXP 155
95826: AND
95827: IFFALSE 95938
95829: GO 95831
95831: DISABLE
95832: LD_INT 0
95834: PPUSH
95835: PPUSH
95836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95837: LD_ADDR_VAR 0 3
95841: PUSH
95842: LD_INT 22
95844: PUSH
95845: LD_OWVAR 2
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 25
95856: PUSH
95857: LD_INT 1
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: PPUSH
95868: CALL_OW 69
95872: ST_TO_ADDR
// if not tmp then
95873: LD_VAR 0 3
95877: NOT
95878: IFFALSE 95882
// exit ;
95880: GO 95938
// un := tmp [ rand ( 1 , tmp ) ] ;
95882: LD_ADDR_VAR 0 2
95886: PUSH
95887: LD_VAR 0 3
95891: PUSH
95892: LD_INT 1
95894: PPUSH
95895: LD_VAR 0 3
95899: PPUSH
95900: CALL_OW 12
95904: ARRAY
95905: ST_TO_ADDR
// if Crawls ( un ) then
95906: LD_VAR 0 2
95910: PPUSH
95911: CALL_OW 318
95915: IFFALSE 95926
// ComWalk ( un ) ;
95917: LD_VAR 0 2
95921: PPUSH
95922: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95926: LD_VAR 0 2
95930: PPUSH
95931: LD_INT 8
95933: PPUSH
95934: CALL_OW 336
// end ;
95938: PPOPN 3
95940: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
95941: LD_EXP 112
95945: PUSH
95946: LD_EXP 156
95950: AND
95951: IFFALSE 96095
95953: GO 95955
95955: DISABLE
95956: LD_INT 0
95958: PPUSH
95959: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
95960: LD_ADDR_VAR 0 2
95964: PUSH
95965: LD_INT 22
95967: PUSH
95968: LD_OWVAR 2
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PUSH
95977: LD_INT 21
95979: PUSH
95980: LD_INT 2
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 2
95989: PUSH
95990: LD_INT 34
95992: PUSH
95993: LD_INT 12
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 34
96002: PUSH
96003: LD_INT 51
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 34
96012: PUSH
96013: LD_INT 32
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: LIST
96030: PPUSH
96031: CALL_OW 69
96035: ST_TO_ADDR
// if not tmp then
96036: LD_VAR 0 2
96040: NOT
96041: IFFALSE 96045
// exit ;
96043: GO 96095
// for i in tmp do
96045: LD_ADDR_VAR 0 1
96049: PUSH
96050: LD_VAR 0 2
96054: PUSH
96055: FOR_IN
96056: IFFALSE 96093
// if GetCargo ( i , mat_artifact ) = 0 then
96058: LD_VAR 0 1
96062: PPUSH
96063: LD_INT 4
96065: PPUSH
96066: CALL_OW 289
96070: PUSH
96071: LD_INT 0
96073: EQUAL
96074: IFFALSE 96091
// SetCargo ( i , mat_siberit , 100 ) ;
96076: LD_VAR 0 1
96080: PPUSH
96081: LD_INT 3
96083: PPUSH
96084: LD_INT 100
96086: PPUSH
96087: CALL_OW 290
96091: GO 96055
96093: POP
96094: POP
// end ;
96095: PPOPN 2
96097: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96098: LD_EXP 112
96102: PUSH
96103: LD_EXP 157
96107: AND
96108: IFFALSE 96291
96110: GO 96112
96112: DISABLE
96113: LD_INT 0
96115: PPUSH
96116: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96117: LD_ADDR_VAR 0 2
96121: PUSH
96122: LD_INT 22
96124: PUSH
96125: LD_OWVAR 2
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PPUSH
96134: CALL_OW 69
96138: ST_TO_ADDR
// if not tmp then
96139: LD_VAR 0 2
96143: NOT
96144: IFFALSE 96148
// exit ;
96146: GO 96291
// for i := 1 to 2 do
96148: LD_ADDR_VAR 0 1
96152: PUSH
96153: DOUBLE
96154: LD_INT 1
96156: DEC
96157: ST_TO_ADDR
96158: LD_INT 2
96160: PUSH
96161: FOR_TO
96162: IFFALSE 96289
// begin uc_side := your_side ;
96164: LD_ADDR_OWVAR 20
96168: PUSH
96169: LD_OWVAR 2
96173: ST_TO_ADDR
// uc_nation := nation_american ;
96174: LD_ADDR_OWVAR 21
96178: PUSH
96179: LD_INT 1
96181: ST_TO_ADDR
// vc_chassis := us_morphling ;
96182: LD_ADDR_OWVAR 37
96186: PUSH
96187: LD_INT 5
96189: ST_TO_ADDR
// vc_engine := engine_siberite ;
96190: LD_ADDR_OWVAR 39
96194: PUSH
96195: LD_INT 3
96197: ST_TO_ADDR
// vc_control := control_computer ;
96198: LD_ADDR_OWVAR 38
96202: PUSH
96203: LD_INT 3
96205: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96206: LD_ADDR_OWVAR 40
96210: PUSH
96211: LD_INT 10
96213: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96214: LD_VAR 0 2
96218: PUSH
96219: LD_INT 1
96221: ARRAY
96222: PPUSH
96223: CALL_OW 310
96227: NOT
96228: IFFALSE 96275
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96230: CALL_OW 45
96234: PPUSH
96235: LD_VAR 0 2
96239: PUSH
96240: LD_INT 1
96242: ARRAY
96243: PPUSH
96244: CALL_OW 250
96248: PPUSH
96249: LD_VAR 0 2
96253: PUSH
96254: LD_INT 1
96256: ARRAY
96257: PPUSH
96258: CALL_OW 251
96262: PPUSH
96263: LD_INT 12
96265: PPUSH
96266: LD_INT 1
96268: PPUSH
96269: CALL_OW 50
96273: GO 96287
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96275: CALL_OW 45
96279: PPUSH
96280: LD_INT 1
96282: PPUSH
96283: CALL_OW 51
// end ;
96287: GO 96161
96289: POP
96290: POP
// end ;
96291: PPOPN 2
96293: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96294: LD_EXP 112
96298: PUSH
96299: LD_EXP 158
96303: AND
96304: IFFALSE 96526
96306: GO 96308
96308: DISABLE
96309: LD_INT 0
96311: PPUSH
96312: PPUSH
96313: PPUSH
96314: PPUSH
96315: PPUSH
96316: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96317: LD_ADDR_VAR 0 6
96321: PUSH
96322: LD_INT 22
96324: PUSH
96325: LD_OWVAR 2
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 21
96336: PUSH
96337: LD_INT 1
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: PUSH
96347: LD_INT 23
96349: PUSH
96350: LD_INT 0
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: LIST
96365: PPUSH
96366: CALL_OW 69
96370: ST_TO_ADDR
// if not tmp then
96371: LD_VAR 0 6
96375: NOT
96376: IFFALSE 96380
// exit ;
96378: GO 96526
// s1 := rand ( 1 , 4 ) ;
96380: LD_ADDR_VAR 0 2
96384: PUSH
96385: LD_INT 1
96387: PPUSH
96388: LD_INT 4
96390: PPUSH
96391: CALL_OW 12
96395: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96396: LD_ADDR_VAR 0 4
96400: PUSH
96401: LD_VAR 0 6
96405: PUSH
96406: LD_INT 1
96408: ARRAY
96409: PPUSH
96410: LD_VAR 0 2
96414: PPUSH
96415: CALL_OW 259
96419: ST_TO_ADDR
// if s1 = 1 then
96420: LD_VAR 0 2
96424: PUSH
96425: LD_INT 1
96427: EQUAL
96428: IFFALSE 96448
// s2 := rand ( 2 , 4 ) else
96430: LD_ADDR_VAR 0 3
96434: PUSH
96435: LD_INT 2
96437: PPUSH
96438: LD_INT 4
96440: PPUSH
96441: CALL_OW 12
96445: ST_TO_ADDR
96446: GO 96456
// s2 := 1 ;
96448: LD_ADDR_VAR 0 3
96452: PUSH
96453: LD_INT 1
96455: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96456: LD_ADDR_VAR 0 5
96460: PUSH
96461: LD_VAR 0 6
96465: PUSH
96466: LD_INT 1
96468: ARRAY
96469: PPUSH
96470: LD_VAR 0 3
96474: PPUSH
96475: CALL_OW 259
96479: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96480: LD_VAR 0 6
96484: PUSH
96485: LD_INT 1
96487: ARRAY
96488: PPUSH
96489: LD_VAR 0 2
96493: PPUSH
96494: LD_VAR 0 5
96498: PPUSH
96499: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96503: LD_VAR 0 6
96507: PUSH
96508: LD_INT 1
96510: ARRAY
96511: PPUSH
96512: LD_VAR 0 3
96516: PPUSH
96517: LD_VAR 0 4
96521: PPUSH
96522: CALL_OW 237
// end ;
96526: PPOPN 6
96528: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96529: LD_EXP 112
96533: PUSH
96534: LD_EXP 159
96538: AND
96539: IFFALSE 96618
96541: GO 96543
96543: DISABLE
96544: LD_INT 0
96546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96547: LD_ADDR_VAR 0 1
96551: PUSH
96552: LD_INT 22
96554: PUSH
96555: LD_OWVAR 2
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 30
96566: PUSH
96567: LD_INT 3
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PPUSH
96578: CALL_OW 69
96582: ST_TO_ADDR
// if not tmp then
96583: LD_VAR 0 1
96587: NOT
96588: IFFALSE 96592
// exit ;
96590: GO 96618
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96592: LD_VAR 0 1
96596: PUSH
96597: LD_INT 1
96599: PPUSH
96600: LD_VAR 0 1
96604: PPUSH
96605: CALL_OW 12
96609: ARRAY
96610: PPUSH
96611: LD_INT 1
96613: PPUSH
96614: CALL_OW 234
// end ;
96618: PPOPN 1
96620: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96621: LD_EXP 112
96625: PUSH
96626: LD_EXP 160
96630: AND
96631: IFFALSE 96743
96633: GO 96635
96635: DISABLE
96636: LD_INT 0
96638: PPUSH
96639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96640: LD_ADDR_VAR 0 2
96644: PUSH
96645: LD_INT 22
96647: PUSH
96648: LD_OWVAR 2
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PUSH
96657: LD_INT 2
96659: PUSH
96660: LD_INT 30
96662: PUSH
96663: LD_INT 27
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 30
96672: PUSH
96673: LD_INT 26
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 30
96682: PUSH
96683: LD_INT 28
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PPUSH
96700: CALL_OW 69
96704: ST_TO_ADDR
// if not tmp then
96705: LD_VAR 0 2
96709: NOT
96710: IFFALSE 96714
// exit ;
96712: GO 96743
// for i in tmp do
96714: LD_ADDR_VAR 0 1
96718: PUSH
96719: LD_VAR 0 2
96723: PUSH
96724: FOR_IN
96725: IFFALSE 96741
// SetLives ( i , 1 ) ;
96727: LD_VAR 0 1
96731: PPUSH
96732: LD_INT 1
96734: PPUSH
96735: CALL_OW 234
96739: GO 96724
96741: POP
96742: POP
// end ;
96743: PPOPN 2
96745: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96746: LD_EXP 112
96750: PUSH
96751: LD_EXP 161
96755: AND
96756: IFFALSE 97043
96758: GO 96760
96760: DISABLE
96761: LD_INT 0
96763: PPUSH
96764: PPUSH
96765: PPUSH
// begin i := rand ( 1 , 7 ) ;
96766: LD_ADDR_VAR 0 1
96770: PUSH
96771: LD_INT 1
96773: PPUSH
96774: LD_INT 7
96776: PPUSH
96777: CALL_OW 12
96781: ST_TO_ADDR
// case i of 1 :
96782: LD_VAR 0 1
96786: PUSH
96787: LD_INT 1
96789: DOUBLE
96790: EQUAL
96791: IFTRUE 96795
96793: GO 96805
96795: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96796: LD_STRING earthquake(getX(game), 0, 32)
96798: PPUSH
96799: CALL_OW 559
96803: GO 97043
96805: LD_INT 2
96807: DOUBLE
96808: EQUAL
96809: IFTRUE 96813
96811: GO 96827
96813: POP
// begin ToLua ( displayStucuk(); ) ;
96814: LD_STRING displayStucuk();
96816: PPUSH
96817: CALL_OW 559
// ResetFog ;
96821: CALL_OW 335
// end ; 3 :
96825: GO 97043
96827: LD_INT 3
96829: DOUBLE
96830: EQUAL
96831: IFTRUE 96835
96833: GO 96939
96835: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96836: LD_ADDR_VAR 0 2
96840: PUSH
96841: LD_INT 22
96843: PUSH
96844: LD_OWVAR 2
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: PUSH
96853: LD_INT 25
96855: PUSH
96856: LD_INT 1
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PPUSH
96867: CALL_OW 69
96871: ST_TO_ADDR
// if not tmp then
96872: LD_VAR 0 2
96876: NOT
96877: IFFALSE 96881
// exit ;
96879: GO 97043
// un := tmp [ rand ( 1 , tmp ) ] ;
96881: LD_ADDR_VAR 0 3
96885: PUSH
96886: LD_VAR 0 2
96890: PUSH
96891: LD_INT 1
96893: PPUSH
96894: LD_VAR 0 2
96898: PPUSH
96899: CALL_OW 12
96903: ARRAY
96904: ST_TO_ADDR
// if Crawls ( un ) then
96905: LD_VAR 0 3
96909: PPUSH
96910: CALL_OW 318
96914: IFFALSE 96925
// ComWalk ( un ) ;
96916: LD_VAR 0 3
96920: PPUSH
96921: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96925: LD_VAR 0 3
96929: PPUSH
96930: LD_INT 8
96932: PPUSH
96933: CALL_OW 336
// end ; 4 :
96937: GO 97043
96939: LD_INT 4
96941: DOUBLE
96942: EQUAL
96943: IFTRUE 96947
96945: GO 97021
96947: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96948: LD_ADDR_VAR 0 2
96952: PUSH
96953: LD_INT 22
96955: PUSH
96956: LD_OWVAR 2
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 30
96967: PUSH
96968: LD_INT 29
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PPUSH
96979: CALL_OW 69
96983: ST_TO_ADDR
// if not tmp then
96984: LD_VAR 0 2
96988: NOT
96989: IFFALSE 96993
// exit ;
96991: GO 97043
// CenterNowOnUnits ( tmp [ 1 ] ) ;
96993: LD_VAR 0 2
96997: PUSH
96998: LD_INT 1
97000: ARRAY
97001: PPUSH
97002: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97006: LD_VAR 0 2
97010: PUSH
97011: LD_INT 1
97013: ARRAY
97014: PPUSH
97015: CALL_OW 65
// end ; 5 .. 7 :
97019: GO 97043
97021: LD_INT 5
97023: DOUBLE
97024: GREATEREQUAL
97025: IFFALSE 97033
97027: LD_INT 7
97029: DOUBLE
97030: LESSEQUAL
97031: IFTRUE 97035
97033: GO 97042
97035: POP
// StreamSibBomb ; end ;
97036: CALL 93280 0 0
97040: GO 97043
97042: POP
// end ;
97043: PPOPN 3
97045: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97046: LD_EXP 112
97050: PUSH
97051: LD_EXP 162
97055: AND
97056: IFFALSE 97212
97058: GO 97060
97060: DISABLE
97061: LD_INT 0
97063: PPUSH
97064: PPUSH
97065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97066: LD_ADDR_VAR 0 2
97070: PUSH
97071: LD_INT 81
97073: PUSH
97074: LD_OWVAR 2
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 2
97085: PUSH
97086: LD_INT 21
97088: PUSH
97089: LD_INT 1
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 21
97098: PUSH
97099: LD_INT 2
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: EMPTY
97107: LIST
97108: LIST
97109: LIST
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PPUSH
97115: CALL_OW 69
97119: ST_TO_ADDR
// if not tmp then
97120: LD_VAR 0 2
97124: NOT
97125: IFFALSE 97129
// exit ;
97127: GO 97212
// p := 0 ;
97129: LD_ADDR_VAR 0 3
97133: PUSH
97134: LD_INT 0
97136: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97137: LD_INT 35
97139: PPUSH
97140: CALL_OW 67
// p := p + 1 ;
97144: LD_ADDR_VAR 0 3
97148: PUSH
97149: LD_VAR 0 3
97153: PUSH
97154: LD_INT 1
97156: PLUS
97157: ST_TO_ADDR
// for i in tmp do
97158: LD_ADDR_VAR 0 1
97162: PUSH
97163: LD_VAR 0 2
97167: PUSH
97168: FOR_IN
97169: IFFALSE 97200
// if GetLives ( i ) < 1000 then
97171: LD_VAR 0 1
97175: PPUSH
97176: CALL_OW 256
97180: PUSH
97181: LD_INT 1000
97183: LESS
97184: IFFALSE 97198
// SetLives ( i , 1000 ) ;
97186: LD_VAR 0 1
97190: PPUSH
97191: LD_INT 1000
97193: PPUSH
97194: CALL_OW 234
97198: GO 97168
97200: POP
97201: POP
// until p > 20 ;
97202: LD_VAR 0 3
97206: PUSH
97207: LD_INT 20
97209: GREATER
97210: IFFALSE 97137
// end ;
97212: PPOPN 3
97214: END
// every 0 0$1 trigger StreamModeActive and sTime do
97215: LD_EXP 112
97219: PUSH
97220: LD_EXP 163
97224: AND
97225: IFFALSE 97260
97227: GO 97229
97229: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97230: LD_INT 28
97232: PPUSH
97233: LD_OWVAR 2
97237: PPUSH
97238: LD_INT 2
97240: PPUSH
97241: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97245: LD_INT 30
97247: PPUSH
97248: LD_OWVAR 2
97252: PPUSH
97253: LD_INT 2
97255: PPUSH
97256: CALL_OW 322
// end ;
97260: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97261: LD_EXP 112
97265: PUSH
97266: LD_EXP 164
97270: AND
97271: IFFALSE 97392
97273: GO 97275
97275: DISABLE
97276: LD_INT 0
97278: PPUSH
97279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97280: LD_ADDR_VAR 0 2
97284: PUSH
97285: LD_INT 22
97287: PUSH
97288: LD_OWVAR 2
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 21
97299: PUSH
97300: LD_INT 1
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 3
97309: PUSH
97310: LD_INT 23
97312: PUSH
97313: LD_INT 0
97315: PUSH
97316: EMPTY
97317: LIST
97318: LIST
97319: PUSH
97320: EMPTY
97321: LIST
97322: LIST
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: LIST
97328: PPUSH
97329: CALL_OW 69
97333: ST_TO_ADDR
// if not tmp then
97334: LD_VAR 0 2
97338: NOT
97339: IFFALSE 97343
// exit ;
97341: GO 97392
// for i in tmp do
97343: LD_ADDR_VAR 0 1
97347: PUSH
97348: LD_VAR 0 2
97352: PUSH
97353: FOR_IN
97354: IFFALSE 97390
// begin if Crawls ( i ) then
97356: LD_VAR 0 1
97360: PPUSH
97361: CALL_OW 318
97365: IFFALSE 97376
// ComWalk ( i ) ;
97367: LD_VAR 0 1
97371: PPUSH
97372: CALL_OW 138
// SetClass ( i , 2 ) ;
97376: LD_VAR 0 1
97380: PPUSH
97381: LD_INT 2
97383: PPUSH
97384: CALL_OW 336
// end ;
97388: GO 97353
97390: POP
97391: POP
// end ;
97392: PPOPN 2
97394: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97395: LD_EXP 112
97399: PUSH
97400: LD_EXP 165
97404: AND
97405: IFFALSE 97693
97407: GO 97409
97409: DISABLE
97410: LD_INT 0
97412: PPUSH
97413: PPUSH
97414: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97415: LD_OWVAR 2
97419: PPUSH
97420: LD_INT 9
97422: PPUSH
97423: LD_INT 1
97425: PPUSH
97426: LD_INT 1
97428: PPUSH
97429: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97433: LD_INT 9
97435: PPUSH
97436: LD_OWVAR 2
97440: PPUSH
97441: CALL_OW 343
// uc_side := 9 ;
97445: LD_ADDR_OWVAR 20
97449: PUSH
97450: LD_INT 9
97452: ST_TO_ADDR
// uc_nation := 2 ;
97453: LD_ADDR_OWVAR 21
97457: PUSH
97458: LD_INT 2
97460: ST_TO_ADDR
// hc_name := Dark Warrior ;
97461: LD_ADDR_OWVAR 26
97465: PUSH
97466: LD_STRING Dark Warrior
97468: ST_TO_ADDR
// hc_gallery :=  ;
97469: LD_ADDR_OWVAR 33
97473: PUSH
97474: LD_STRING 
97476: ST_TO_ADDR
// hc_noskilllimit := true ;
97477: LD_ADDR_OWVAR 76
97481: PUSH
97482: LD_INT 1
97484: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97485: LD_ADDR_OWVAR 31
97489: PUSH
97490: LD_INT 30
97492: PUSH
97493: LD_INT 30
97495: PUSH
97496: LD_INT 30
97498: PUSH
97499: LD_INT 30
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: ST_TO_ADDR
// un := CreateHuman ;
97508: LD_ADDR_VAR 0 3
97512: PUSH
97513: CALL_OW 44
97517: ST_TO_ADDR
// hc_noskilllimit := false ;
97518: LD_ADDR_OWVAR 76
97522: PUSH
97523: LD_INT 0
97525: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97526: LD_VAR 0 3
97530: PPUSH
97531: LD_INT 1
97533: PPUSH
97534: CALL_OW 51
// ToLua ( playRanger() ) ;
97538: LD_STRING playRanger()
97540: PPUSH
97541: CALL_OW 559
// p := 0 ;
97545: LD_ADDR_VAR 0 2
97549: PUSH
97550: LD_INT 0
97552: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97553: LD_INT 35
97555: PPUSH
97556: CALL_OW 67
// p := p + 1 ;
97560: LD_ADDR_VAR 0 2
97564: PUSH
97565: LD_VAR 0 2
97569: PUSH
97570: LD_INT 1
97572: PLUS
97573: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97574: LD_VAR 0 3
97578: PPUSH
97579: CALL_OW 256
97583: PUSH
97584: LD_INT 1000
97586: LESS
97587: IFFALSE 97601
// SetLives ( un , 1000 ) ;
97589: LD_VAR 0 3
97593: PPUSH
97594: LD_INT 1000
97596: PPUSH
97597: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97601: LD_VAR 0 3
97605: PPUSH
97606: LD_INT 81
97608: PUSH
97609: LD_OWVAR 2
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: PUSH
97618: LD_INT 91
97620: PUSH
97621: LD_VAR 0 3
97625: PUSH
97626: LD_INT 30
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: LIST
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PPUSH
97638: CALL_OW 69
97642: PPUSH
97643: LD_VAR 0 3
97647: PPUSH
97648: CALL_OW 74
97652: PPUSH
97653: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
97657: LD_VAR 0 2
97661: PUSH
97662: LD_INT 80
97664: GREATER
97665: PUSH
97666: LD_VAR 0 3
97670: PPUSH
97671: CALL_OW 301
97675: OR
97676: IFFALSE 97553
// if un then
97678: LD_VAR 0 3
97682: IFFALSE 97693
// RemoveUnit ( un ) ;
97684: LD_VAR 0 3
97688: PPUSH
97689: CALL_OW 64
// end ;
97693: PPOPN 3
97695: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
97696: LD_EXP 166
97700: IFFALSE 97816
97702: GO 97704
97704: DISABLE
97705: LD_INT 0
97707: PPUSH
97708: PPUSH
97709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97710: LD_ADDR_VAR 0 2
97714: PUSH
97715: LD_INT 81
97717: PUSH
97718: LD_OWVAR 2
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: PUSH
97727: LD_INT 21
97729: PUSH
97730: LD_INT 1
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: PPUSH
97741: CALL_OW 69
97745: ST_TO_ADDR
// ToLua ( playComputer() ) ;
97746: LD_STRING playComputer()
97748: PPUSH
97749: CALL_OW 559
// if not tmp then
97753: LD_VAR 0 2
97757: NOT
97758: IFFALSE 97762
// exit ;
97760: GO 97816
// for i in tmp do
97762: LD_ADDR_VAR 0 1
97766: PUSH
97767: LD_VAR 0 2
97771: PUSH
97772: FOR_IN
97773: IFFALSE 97814
// for j := 1 to 4 do
97775: LD_ADDR_VAR 0 3
97779: PUSH
97780: DOUBLE
97781: LD_INT 1
97783: DEC
97784: ST_TO_ADDR
97785: LD_INT 4
97787: PUSH
97788: FOR_TO
97789: IFFALSE 97810
// SetSkill ( i , j , 10 ) ;
97791: LD_VAR 0 1
97795: PPUSH
97796: LD_VAR 0 3
97800: PPUSH
97801: LD_INT 10
97803: PPUSH
97804: CALL_OW 237
97808: GO 97788
97810: POP
97811: POP
97812: GO 97772
97814: POP
97815: POP
// end ;
97816: PPOPN 3
97818: END
// every 0 0$1 trigger s30 do var i , tmp ;
97819: LD_EXP 167
97823: IFFALSE 97892
97825: GO 97827
97827: DISABLE
97828: LD_INT 0
97830: PPUSH
97831: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97832: LD_ADDR_VAR 0 2
97836: PUSH
97837: LD_INT 22
97839: PUSH
97840: LD_OWVAR 2
97844: PUSH
97845: EMPTY
97846: LIST
97847: LIST
97848: PPUSH
97849: CALL_OW 69
97853: ST_TO_ADDR
// if not tmp then
97854: LD_VAR 0 2
97858: NOT
97859: IFFALSE 97863
// exit ;
97861: GO 97892
// for i in tmp do
97863: LD_ADDR_VAR 0 1
97867: PUSH
97868: LD_VAR 0 2
97872: PUSH
97873: FOR_IN
97874: IFFALSE 97890
// SetLives ( i , 300 ) ;
97876: LD_VAR 0 1
97880: PPUSH
97881: LD_INT 300
97883: PPUSH
97884: CALL_OW 234
97888: GO 97873
97890: POP
97891: POP
// end ;
97892: PPOPN 2
97894: END
// every 0 0$1 trigger s60 do var i , tmp ;
97895: LD_EXP 168
97899: IFFALSE 97968
97901: GO 97903
97903: DISABLE
97904: LD_INT 0
97906: PPUSH
97907: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97908: LD_ADDR_VAR 0 2
97912: PUSH
97913: LD_INT 22
97915: PUSH
97916: LD_OWVAR 2
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: PPUSH
97925: CALL_OW 69
97929: ST_TO_ADDR
// if not tmp then
97930: LD_VAR 0 2
97934: NOT
97935: IFFALSE 97939
// exit ;
97937: GO 97968
// for i in tmp do
97939: LD_ADDR_VAR 0 1
97943: PUSH
97944: LD_VAR 0 2
97948: PUSH
97949: FOR_IN
97950: IFFALSE 97966
// SetLives ( i , 600 ) ;
97952: LD_VAR 0 1
97956: PPUSH
97957: LD_INT 600
97959: PPUSH
97960: CALL_OW 234
97964: GO 97949
97966: POP
97967: POP
// end ;
97968: PPOPN 2
97970: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
97971: LD_INT 0
97973: PPUSH
// case cmd of 301 :
97974: LD_VAR 0 1
97978: PUSH
97979: LD_INT 301
97981: DOUBLE
97982: EQUAL
97983: IFTRUE 97987
97985: GO 98019
97987: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
97988: LD_VAR 0 6
97992: PPUSH
97993: LD_VAR 0 7
97997: PPUSH
97998: LD_VAR 0 8
98002: PPUSH
98003: LD_VAR 0 4
98007: PPUSH
98008: LD_VAR 0 5
98012: PPUSH
98013: CALL 99220 0 5
98017: GO 98140
98019: LD_INT 302
98021: DOUBLE
98022: EQUAL
98023: IFTRUE 98027
98025: GO 98064
98027: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98028: LD_VAR 0 6
98032: PPUSH
98033: LD_VAR 0 7
98037: PPUSH
98038: LD_VAR 0 8
98042: PPUSH
98043: LD_VAR 0 9
98047: PPUSH
98048: LD_VAR 0 4
98052: PPUSH
98053: LD_VAR 0 5
98057: PPUSH
98058: CALL 99311 0 6
98062: GO 98140
98064: LD_INT 303
98066: DOUBLE
98067: EQUAL
98068: IFTRUE 98072
98070: GO 98109
98072: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98073: LD_VAR 0 6
98077: PPUSH
98078: LD_VAR 0 7
98082: PPUSH
98083: LD_VAR 0 8
98087: PPUSH
98088: LD_VAR 0 9
98092: PPUSH
98093: LD_VAR 0 4
98097: PPUSH
98098: LD_VAR 0 5
98102: PPUSH
98103: CALL 98145 0 6
98107: GO 98140
98109: LD_INT 304
98111: DOUBLE
98112: EQUAL
98113: IFTRUE 98117
98115: GO 98139
98117: POP
// hHackTeleport ( unit , x , y ) ; end ;
98118: LD_VAR 0 2
98122: PPUSH
98123: LD_VAR 0 4
98127: PPUSH
98128: LD_VAR 0 5
98132: PPUSH
98133: CALL 99904 0 3
98137: GO 98140
98139: POP
// end ;
98140: LD_VAR 0 12
98144: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98145: LD_INT 0
98147: PPUSH
98148: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98149: LD_VAR 0 1
98153: PUSH
98154: LD_INT 1
98156: LESS
98157: PUSH
98158: LD_VAR 0 1
98162: PUSH
98163: LD_INT 3
98165: GREATER
98166: OR
98167: PUSH
98168: LD_VAR 0 5
98172: PPUSH
98173: LD_VAR 0 6
98177: PPUSH
98178: CALL_OW 428
98182: OR
98183: IFFALSE 98187
// exit ;
98185: GO 98907
// uc_side := your_side ;
98187: LD_ADDR_OWVAR 20
98191: PUSH
98192: LD_OWVAR 2
98196: ST_TO_ADDR
// uc_nation := nation ;
98197: LD_ADDR_OWVAR 21
98201: PUSH
98202: LD_VAR 0 1
98206: ST_TO_ADDR
// bc_level = 1 ;
98207: LD_ADDR_OWVAR 43
98211: PUSH
98212: LD_INT 1
98214: ST_TO_ADDR
// case btype of 1 :
98215: LD_VAR 0 2
98219: PUSH
98220: LD_INT 1
98222: DOUBLE
98223: EQUAL
98224: IFTRUE 98228
98226: GO 98239
98228: POP
// bc_type := b_depot ; 2 :
98229: LD_ADDR_OWVAR 42
98233: PUSH
98234: LD_INT 0
98236: ST_TO_ADDR
98237: GO 98851
98239: LD_INT 2
98241: DOUBLE
98242: EQUAL
98243: IFTRUE 98247
98245: GO 98258
98247: POP
// bc_type := b_warehouse ; 3 :
98248: LD_ADDR_OWVAR 42
98252: PUSH
98253: LD_INT 1
98255: ST_TO_ADDR
98256: GO 98851
98258: LD_INT 3
98260: DOUBLE
98261: EQUAL
98262: IFTRUE 98266
98264: GO 98277
98266: POP
// bc_type := b_lab ; 4 .. 9 :
98267: LD_ADDR_OWVAR 42
98271: PUSH
98272: LD_INT 6
98274: ST_TO_ADDR
98275: GO 98851
98277: LD_INT 4
98279: DOUBLE
98280: GREATEREQUAL
98281: IFFALSE 98289
98283: LD_INT 9
98285: DOUBLE
98286: LESSEQUAL
98287: IFTRUE 98291
98289: GO 98343
98291: POP
// begin bc_type := b_lab_half ;
98292: LD_ADDR_OWVAR 42
98296: PUSH
98297: LD_INT 7
98299: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98300: LD_ADDR_OWVAR 44
98304: PUSH
98305: LD_INT 10
98307: PUSH
98308: LD_INT 11
98310: PUSH
98311: LD_INT 12
98313: PUSH
98314: LD_INT 15
98316: PUSH
98317: LD_INT 14
98319: PUSH
98320: LD_INT 13
98322: PUSH
98323: EMPTY
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: PUSH
98331: LD_VAR 0 2
98335: PUSH
98336: LD_INT 3
98338: MINUS
98339: ARRAY
98340: ST_TO_ADDR
// end ; 10 .. 13 :
98341: GO 98851
98343: LD_INT 10
98345: DOUBLE
98346: GREATEREQUAL
98347: IFFALSE 98355
98349: LD_INT 13
98351: DOUBLE
98352: LESSEQUAL
98353: IFTRUE 98357
98355: GO 98434
98357: POP
// begin bc_type := b_lab_full ;
98358: LD_ADDR_OWVAR 42
98362: PUSH
98363: LD_INT 8
98365: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98366: LD_ADDR_OWVAR 44
98370: PUSH
98371: LD_INT 10
98373: PUSH
98374: LD_INT 12
98376: PUSH
98377: LD_INT 14
98379: PUSH
98380: LD_INT 13
98382: PUSH
98383: EMPTY
98384: LIST
98385: LIST
98386: LIST
98387: LIST
98388: PUSH
98389: LD_VAR 0 2
98393: PUSH
98394: LD_INT 9
98396: MINUS
98397: ARRAY
98398: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98399: LD_ADDR_OWVAR 45
98403: PUSH
98404: LD_INT 11
98406: PUSH
98407: LD_INT 15
98409: PUSH
98410: LD_INT 12
98412: PUSH
98413: LD_INT 15
98415: PUSH
98416: EMPTY
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: PUSH
98422: LD_VAR 0 2
98426: PUSH
98427: LD_INT 9
98429: MINUS
98430: ARRAY
98431: ST_TO_ADDR
// end ; 14 :
98432: GO 98851
98434: LD_INT 14
98436: DOUBLE
98437: EQUAL
98438: IFTRUE 98442
98440: GO 98453
98442: POP
// bc_type := b_workshop ; 15 :
98443: LD_ADDR_OWVAR 42
98447: PUSH
98448: LD_INT 2
98450: ST_TO_ADDR
98451: GO 98851
98453: LD_INT 15
98455: DOUBLE
98456: EQUAL
98457: IFTRUE 98461
98459: GO 98472
98461: POP
// bc_type := b_factory ; 16 :
98462: LD_ADDR_OWVAR 42
98466: PUSH
98467: LD_INT 3
98469: ST_TO_ADDR
98470: GO 98851
98472: LD_INT 16
98474: DOUBLE
98475: EQUAL
98476: IFTRUE 98480
98478: GO 98491
98480: POP
// bc_type := b_ext_gun ; 17 :
98481: LD_ADDR_OWVAR 42
98485: PUSH
98486: LD_INT 17
98488: ST_TO_ADDR
98489: GO 98851
98491: LD_INT 17
98493: DOUBLE
98494: EQUAL
98495: IFTRUE 98499
98497: GO 98527
98499: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98500: LD_ADDR_OWVAR 42
98504: PUSH
98505: LD_INT 19
98507: PUSH
98508: LD_INT 23
98510: PUSH
98511: LD_INT 19
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: LIST
98518: PUSH
98519: LD_VAR 0 1
98523: ARRAY
98524: ST_TO_ADDR
98525: GO 98851
98527: LD_INT 18
98529: DOUBLE
98530: EQUAL
98531: IFTRUE 98535
98533: GO 98546
98535: POP
// bc_type := b_ext_radar ; 19 :
98536: LD_ADDR_OWVAR 42
98540: PUSH
98541: LD_INT 20
98543: ST_TO_ADDR
98544: GO 98851
98546: LD_INT 19
98548: DOUBLE
98549: EQUAL
98550: IFTRUE 98554
98552: GO 98565
98554: POP
// bc_type := b_ext_radio ; 20 :
98555: LD_ADDR_OWVAR 42
98559: PUSH
98560: LD_INT 22
98562: ST_TO_ADDR
98563: GO 98851
98565: LD_INT 20
98567: DOUBLE
98568: EQUAL
98569: IFTRUE 98573
98571: GO 98584
98573: POP
// bc_type := b_ext_siberium ; 21 :
98574: LD_ADDR_OWVAR 42
98578: PUSH
98579: LD_INT 21
98581: ST_TO_ADDR
98582: GO 98851
98584: LD_INT 21
98586: DOUBLE
98587: EQUAL
98588: IFTRUE 98592
98590: GO 98603
98592: POP
// bc_type := b_ext_computer ; 22 :
98593: LD_ADDR_OWVAR 42
98597: PUSH
98598: LD_INT 24
98600: ST_TO_ADDR
98601: GO 98851
98603: LD_INT 22
98605: DOUBLE
98606: EQUAL
98607: IFTRUE 98611
98609: GO 98622
98611: POP
// bc_type := b_ext_track ; 23 :
98612: LD_ADDR_OWVAR 42
98616: PUSH
98617: LD_INT 16
98619: ST_TO_ADDR
98620: GO 98851
98622: LD_INT 23
98624: DOUBLE
98625: EQUAL
98626: IFTRUE 98630
98628: GO 98641
98630: POP
// bc_type := b_ext_laser ; 24 :
98631: LD_ADDR_OWVAR 42
98635: PUSH
98636: LD_INT 25
98638: ST_TO_ADDR
98639: GO 98851
98641: LD_INT 24
98643: DOUBLE
98644: EQUAL
98645: IFTRUE 98649
98647: GO 98660
98649: POP
// bc_type := b_control_tower ; 25 :
98650: LD_ADDR_OWVAR 42
98654: PUSH
98655: LD_INT 36
98657: ST_TO_ADDR
98658: GO 98851
98660: LD_INT 25
98662: DOUBLE
98663: EQUAL
98664: IFTRUE 98668
98666: GO 98679
98668: POP
// bc_type := b_breastwork ; 26 :
98669: LD_ADDR_OWVAR 42
98673: PUSH
98674: LD_INT 31
98676: ST_TO_ADDR
98677: GO 98851
98679: LD_INT 26
98681: DOUBLE
98682: EQUAL
98683: IFTRUE 98687
98685: GO 98698
98687: POP
// bc_type := b_bunker ; 27 :
98688: LD_ADDR_OWVAR 42
98692: PUSH
98693: LD_INT 32
98695: ST_TO_ADDR
98696: GO 98851
98698: LD_INT 27
98700: DOUBLE
98701: EQUAL
98702: IFTRUE 98706
98704: GO 98717
98706: POP
// bc_type := b_turret ; 28 :
98707: LD_ADDR_OWVAR 42
98711: PUSH
98712: LD_INT 33
98714: ST_TO_ADDR
98715: GO 98851
98717: LD_INT 28
98719: DOUBLE
98720: EQUAL
98721: IFTRUE 98725
98723: GO 98736
98725: POP
// bc_type := b_armoury ; 29 :
98726: LD_ADDR_OWVAR 42
98730: PUSH
98731: LD_INT 4
98733: ST_TO_ADDR
98734: GO 98851
98736: LD_INT 29
98738: DOUBLE
98739: EQUAL
98740: IFTRUE 98744
98742: GO 98755
98744: POP
// bc_type := b_barracks ; 30 :
98745: LD_ADDR_OWVAR 42
98749: PUSH
98750: LD_INT 5
98752: ST_TO_ADDR
98753: GO 98851
98755: LD_INT 30
98757: DOUBLE
98758: EQUAL
98759: IFTRUE 98763
98761: GO 98774
98763: POP
// bc_type := b_solar_power ; 31 :
98764: LD_ADDR_OWVAR 42
98768: PUSH
98769: LD_INT 27
98771: ST_TO_ADDR
98772: GO 98851
98774: LD_INT 31
98776: DOUBLE
98777: EQUAL
98778: IFTRUE 98782
98780: GO 98793
98782: POP
// bc_type := b_oil_power ; 32 :
98783: LD_ADDR_OWVAR 42
98787: PUSH
98788: LD_INT 26
98790: ST_TO_ADDR
98791: GO 98851
98793: LD_INT 32
98795: DOUBLE
98796: EQUAL
98797: IFTRUE 98801
98799: GO 98812
98801: POP
// bc_type := b_siberite_power ; 33 :
98802: LD_ADDR_OWVAR 42
98806: PUSH
98807: LD_INT 28
98809: ST_TO_ADDR
98810: GO 98851
98812: LD_INT 33
98814: DOUBLE
98815: EQUAL
98816: IFTRUE 98820
98818: GO 98831
98820: POP
// bc_type := b_oil_mine ; 34 :
98821: LD_ADDR_OWVAR 42
98825: PUSH
98826: LD_INT 29
98828: ST_TO_ADDR
98829: GO 98851
98831: LD_INT 34
98833: DOUBLE
98834: EQUAL
98835: IFTRUE 98839
98837: GO 98850
98839: POP
// bc_type := b_siberite_mine ; end ;
98840: LD_ADDR_OWVAR 42
98844: PUSH
98845: LD_INT 30
98847: ST_TO_ADDR
98848: GO 98851
98850: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
98851: LD_ADDR_VAR 0 8
98855: PUSH
98856: LD_VAR 0 5
98860: PPUSH
98861: LD_VAR 0 6
98865: PPUSH
98866: LD_VAR 0 3
98870: PPUSH
98871: CALL_OW 47
98875: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98876: LD_OWVAR 42
98880: PUSH
98881: LD_INT 32
98883: PUSH
98884: LD_INT 33
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: IN
98891: IFFALSE 98907
// PlaceWeaponTurret ( b , weapon ) ;
98893: LD_VAR 0 8
98897: PPUSH
98898: LD_VAR 0 4
98902: PPUSH
98903: CALL_OW 431
// end ;
98907: LD_VAR 0 7
98911: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98912: LD_INT 0
98914: PPUSH
98915: PPUSH
98916: PPUSH
98917: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98918: LD_ADDR_VAR 0 4
98922: PUSH
98923: LD_INT 22
98925: PUSH
98926: LD_OWVAR 2
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 2
98937: PUSH
98938: LD_INT 30
98940: PUSH
98941: LD_INT 0
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: PUSH
98948: LD_INT 30
98950: PUSH
98951: LD_INT 1
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: LIST
98962: PUSH
98963: EMPTY
98964: LIST
98965: LIST
98966: PPUSH
98967: CALL_OW 69
98971: ST_TO_ADDR
// if not tmp then
98972: LD_VAR 0 4
98976: NOT
98977: IFFALSE 98981
// exit ;
98979: GO 99040
// for i in tmp do
98981: LD_ADDR_VAR 0 2
98985: PUSH
98986: LD_VAR 0 4
98990: PUSH
98991: FOR_IN
98992: IFFALSE 99038
// for j = 1 to 3 do
98994: LD_ADDR_VAR 0 3
98998: PUSH
98999: DOUBLE
99000: LD_INT 1
99002: DEC
99003: ST_TO_ADDR
99004: LD_INT 3
99006: PUSH
99007: FOR_TO
99008: IFFALSE 99034
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99010: LD_VAR 0 2
99014: PPUSH
99015: CALL_OW 274
99019: PPUSH
99020: LD_VAR 0 3
99024: PPUSH
99025: LD_INT 99999
99027: PPUSH
99028: CALL_OW 277
99032: GO 99007
99034: POP
99035: POP
99036: GO 98991
99038: POP
99039: POP
// end ;
99040: LD_VAR 0 1
99044: RET
// export function hHackSetLevel10 ; var i , j ; begin
99045: LD_INT 0
99047: PPUSH
99048: PPUSH
99049: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99050: LD_ADDR_VAR 0 2
99054: PUSH
99055: LD_INT 21
99057: PUSH
99058: LD_INT 1
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: PPUSH
99065: CALL_OW 69
99069: PUSH
99070: FOR_IN
99071: IFFALSE 99123
// if IsSelected ( i ) then
99073: LD_VAR 0 2
99077: PPUSH
99078: CALL_OW 306
99082: IFFALSE 99121
// begin for j := 1 to 4 do
99084: LD_ADDR_VAR 0 3
99088: PUSH
99089: DOUBLE
99090: LD_INT 1
99092: DEC
99093: ST_TO_ADDR
99094: LD_INT 4
99096: PUSH
99097: FOR_TO
99098: IFFALSE 99119
// SetSkill ( i , j , 10 ) ;
99100: LD_VAR 0 2
99104: PPUSH
99105: LD_VAR 0 3
99109: PPUSH
99110: LD_INT 10
99112: PPUSH
99113: CALL_OW 237
99117: GO 99097
99119: POP
99120: POP
// end ;
99121: GO 99070
99123: POP
99124: POP
// end ;
99125: LD_VAR 0 1
99129: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
99134: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99135: LD_ADDR_VAR 0 2
99139: PUSH
99140: LD_INT 22
99142: PUSH
99143: LD_OWVAR 2
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: PUSH
99152: LD_INT 21
99154: PUSH
99155: LD_INT 1
99157: PUSH
99158: EMPTY
99159: LIST
99160: LIST
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: PPUSH
99166: CALL_OW 69
99170: PUSH
99171: FOR_IN
99172: IFFALSE 99213
// begin for j := 1 to 4 do
99174: LD_ADDR_VAR 0 3
99178: PUSH
99179: DOUBLE
99180: LD_INT 1
99182: DEC
99183: ST_TO_ADDR
99184: LD_INT 4
99186: PUSH
99187: FOR_TO
99188: IFFALSE 99209
// SetSkill ( i , j , 10 ) ;
99190: LD_VAR 0 2
99194: PPUSH
99195: LD_VAR 0 3
99199: PPUSH
99200: LD_INT 10
99202: PPUSH
99203: CALL_OW 237
99207: GO 99187
99209: POP
99210: POP
// end ;
99211: GO 99171
99213: POP
99214: POP
// end ;
99215: LD_VAR 0 1
99219: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99220: LD_INT 0
99222: PPUSH
// uc_side := your_side ;
99223: LD_ADDR_OWVAR 20
99227: PUSH
99228: LD_OWVAR 2
99232: ST_TO_ADDR
// uc_nation := nation ;
99233: LD_ADDR_OWVAR 21
99237: PUSH
99238: LD_VAR 0 1
99242: ST_TO_ADDR
// InitHc ;
99243: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99247: LD_INT 0
99249: PPUSH
99250: LD_VAR 0 2
99254: PPUSH
99255: LD_VAR 0 3
99259: PPUSH
99260: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99264: LD_VAR 0 4
99268: PPUSH
99269: LD_VAR 0 5
99273: PPUSH
99274: CALL_OW 428
99278: PUSH
99279: LD_INT 0
99281: EQUAL
99282: IFFALSE 99306
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99284: CALL_OW 44
99288: PPUSH
99289: LD_VAR 0 4
99293: PPUSH
99294: LD_VAR 0 5
99298: PPUSH
99299: LD_INT 1
99301: PPUSH
99302: CALL_OW 48
// end ;
99306: LD_VAR 0 6
99310: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99311: LD_INT 0
99313: PPUSH
99314: PPUSH
// uc_side := your_side ;
99315: LD_ADDR_OWVAR 20
99319: PUSH
99320: LD_OWVAR 2
99324: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99325: LD_VAR 0 1
99329: PUSH
99330: LD_INT 1
99332: PUSH
99333: LD_INT 2
99335: PUSH
99336: LD_INT 3
99338: PUSH
99339: LD_INT 4
99341: PUSH
99342: LD_INT 5
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: IN
99352: IFFALSE 99364
// uc_nation := nation_american else
99354: LD_ADDR_OWVAR 21
99358: PUSH
99359: LD_INT 1
99361: ST_TO_ADDR
99362: GO 99407
// if chassis in [ 11 , 12 , 13 , 14 ] then
99364: LD_VAR 0 1
99368: PUSH
99369: LD_INT 11
99371: PUSH
99372: LD_INT 12
99374: PUSH
99375: LD_INT 13
99377: PUSH
99378: LD_INT 14
99380: PUSH
99381: EMPTY
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: IN
99387: IFFALSE 99399
// uc_nation := nation_arabian else
99389: LD_ADDR_OWVAR 21
99393: PUSH
99394: LD_INT 2
99396: ST_TO_ADDR
99397: GO 99407
// uc_nation := nation_russian ;
99399: LD_ADDR_OWVAR 21
99403: PUSH
99404: LD_INT 3
99406: ST_TO_ADDR
// vc_chassis := chassis ;
99407: LD_ADDR_OWVAR 37
99411: PUSH
99412: LD_VAR 0 1
99416: ST_TO_ADDR
// vc_engine := engine ;
99417: LD_ADDR_OWVAR 39
99421: PUSH
99422: LD_VAR 0 2
99426: ST_TO_ADDR
// vc_control := control ;
99427: LD_ADDR_OWVAR 38
99431: PUSH
99432: LD_VAR 0 3
99436: ST_TO_ADDR
// vc_weapon := weapon ;
99437: LD_ADDR_OWVAR 40
99441: PUSH
99442: LD_VAR 0 4
99446: ST_TO_ADDR
// un := CreateVehicle ;
99447: LD_ADDR_VAR 0 8
99451: PUSH
99452: CALL_OW 45
99456: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99457: LD_VAR 0 8
99461: PPUSH
99462: LD_INT 0
99464: PPUSH
99465: LD_INT 5
99467: PPUSH
99468: CALL_OW 12
99472: PPUSH
99473: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99477: LD_VAR 0 8
99481: PPUSH
99482: LD_VAR 0 5
99486: PPUSH
99487: LD_VAR 0 6
99491: PPUSH
99492: LD_INT 1
99494: PPUSH
99495: CALL_OW 48
// end ;
99499: LD_VAR 0 7
99503: RET
// export hInvincible ; every 1 do
99504: GO 99506
99506: DISABLE
// hInvincible := [ ] ;
99507: LD_ADDR_EXP 169
99511: PUSH
99512: EMPTY
99513: ST_TO_ADDR
99514: END
// every 10 do var i ;
99515: GO 99517
99517: DISABLE
99518: LD_INT 0
99520: PPUSH
// begin enable ;
99521: ENABLE
// if not hInvincible then
99522: LD_EXP 169
99526: NOT
99527: IFFALSE 99531
// exit ;
99529: GO 99575
// for i in hInvincible do
99531: LD_ADDR_VAR 0 1
99535: PUSH
99536: LD_EXP 169
99540: PUSH
99541: FOR_IN
99542: IFFALSE 99573
// if GetLives ( i ) < 1000 then
99544: LD_VAR 0 1
99548: PPUSH
99549: CALL_OW 256
99553: PUSH
99554: LD_INT 1000
99556: LESS
99557: IFFALSE 99571
// SetLives ( i , 1000 ) ;
99559: LD_VAR 0 1
99563: PPUSH
99564: LD_INT 1000
99566: PPUSH
99567: CALL_OW 234
99571: GO 99541
99573: POP
99574: POP
// end ;
99575: PPOPN 1
99577: END
// export function hHackInvincible ; var i ; begin
99578: LD_INT 0
99580: PPUSH
99581: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99582: LD_ADDR_VAR 0 2
99586: PUSH
99587: LD_INT 2
99589: PUSH
99590: LD_INT 21
99592: PUSH
99593: LD_INT 1
99595: PUSH
99596: EMPTY
99597: LIST
99598: LIST
99599: PUSH
99600: LD_INT 21
99602: PUSH
99603: LD_INT 2
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: LIST
99614: PPUSH
99615: CALL_OW 69
99619: PUSH
99620: FOR_IN
99621: IFFALSE 99682
// if IsSelected ( i ) then
99623: LD_VAR 0 2
99627: PPUSH
99628: CALL_OW 306
99632: IFFALSE 99680
// begin if i in hInvincible then
99634: LD_VAR 0 2
99638: PUSH
99639: LD_EXP 169
99643: IN
99644: IFFALSE 99664
// hInvincible := hInvincible diff i else
99646: LD_ADDR_EXP 169
99650: PUSH
99651: LD_EXP 169
99655: PUSH
99656: LD_VAR 0 2
99660: DIFF
99661: ST_TO_ADDR
99662: GO 99680
// hInvincible := hInvincible union i ;
99664: LD_ADDR_EXP 169
99668: PUSH
99669: LD_EXP 169
99673: PUSH
99674: LD_VAR 0 2
99678: UNION
99679: ST_TO_ADDR
// end ;
99680: GO 99620
99682: POP
99683: POP
// end ;
99684: LD_VAR 0 1
99688: RET
// export function hHackInvisible ; var i , j ; begin
99689: LD_INT 0
99691: PPUSH
99692: PPUSH
99693: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99694: LD_ADDR_VAR 0 2
99698: PUSH
99699: LD_INT 21
99701: PUSH
99702: LD_INT 1
99704: PUSH
99705: EMPTY
99706: LIST
99707: LIST
99708: PPUSH
99709: CALL_OW 69
99713: PUSH
99714: FOR_IN
99715: IFFALSE 99739
// if IsSelected ( i ) then
99717: LD_VAR 0 2
99721: PPUSH
99722: CALL_OW 306
99726: IFFALSE 99737
// ComForceInvisible ( i ) ;
99728: LD_VAR 0 2
99732: PPUSH
99733: CALL_OW 496
99737: GO 99714
99739: POP
99740: POP
// end ;
99741: LD_VAR 0 1
99745: RET
// export function hHackChangeYourSide ; begin
99746: LD_INT 0
99748: PPUSH
// if your_side = 8 then
99749: LD_OWVAR 2
99753: PUSH
99754: LD_INT 8
99756: EQUAL
99757: IFFALSE 99769
// your_side := 0 else
99759: LD_ADDR_OWVAR 2
99763: PUSH
99764: LD_INT 0
99766: ST_TO_ADDR
99767: GO 99783
// your_side := your_side + 1 ;
99769: LD_ADDR_OWVAR 2
99773: PUSH
99774: LD_OWVAR 2
99778: PUSH
99779: LD_INT 1
99781: PLUS
99782: ST_TO_ADDR
// end ;
99783: LD_VAR 0 1
99787: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99788: LD_INT 0
99790: PPUSH
99791: PPUSH
99792: PPUSH
// for i in all_units do
99793: LD_ADDR_VAR 0 2
99797: PUSH
99798: LD_OWVAR 3
99802: PUSH
99803: FOR_IN
99804: IFFALSE 99882
// if IsSelected ( i ) then
99806: LD_VAR 0 2
99810: PPUSH
99811: CALL_OW 306
99815: IFFALSE 99880
// begin j := GetSide ( i ) ;
99817: LD_ADDR_VAR 0 3
99821: PUSH
99822: LD_VAR 0 2
99826: PPUSH
99827: CALL_OW 255
99831: ST_TO_ADDR
// if j = 8 then
99832: LD_VAR 0 3
99836: PUSH
99837: LD_INT 8
99839: EQUAL
99840: IFFALSE 99852
// j := 0 else
99842: LD_ADDR_VAR 0 3
99846: PUSH
99847: LD_INT 0
99849: ST_TO_ADDR
99850: GO 99866
// j := j + 1 ;
99852: LD_ADDR_VAR 0 3
99856: PUSH
99857: LD_VAR 0 3
99861: PUSH
99862: LD_INT 1
99864: PLUS
99865: ST_TO_ADDR
// SetSide ( i , j ) ;
99866: LD_VAR 0 2
99870: PPUSH
99871: LD_VAR 0 3
99875: PPUSH
99876: CALL_OW 235
// end ;
99880: GO 99803
99882: POP
99883: POP
// end ;
99884: LD_VAR 0 1
99888: RET
// export function hHackFog ; begin
99889: LD_INT 0
99891: PPUSH
// FogOff ( true ) ;
99892: LD_INT 1
99894: PPUSH
99895: CALL_OW 344
// end ;
99899: LD_VAR 0 1
99903: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99904: LD_INT 0
99906: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99907: LD_VAR 0 1
99911: PPUSH
99912: LD_VAR 0 2
99916: PPUSH
99917: LD_VAR 0 3
99921: PPUSH
99922: LD_INT 1
99924: PPUSH
99925: LD_INT 1
99927: PPUSH
99928: CALL_OW 483
// CenterOnXY ( x , y ) ;
99932: LD_VAR 0 2
99936: PPUSH
99937: LD_VAR 0 3
99941: PPUSH
99942: CALL_OW 84
// end ;
99946: LD_VAR 0 4
99950: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
99951: LD_INT 0
99953: PPUSH
99954: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
99955: LD_VAR 0 1
99959: NOT
99960: PUSH
99961: LD_VAR 0 2
99965: PPUSH
99966: LD_VAR 0 3
99970: PPUSH
99971: CALL_OW 488
99975: NOT
99976: OR
99977: PUSH
99978: LD_VAR 0 1
99982: PPUSH
99983: CALL_OW 266
99987: PUSH
99988: LD_INT 3
99990: NONEQUAL
99991: PUSH
99992: LD_VAR 0 1
99996: PPUSH
99997: CALL_OW 247
100001: PUSH
100002: LD_INT 1
100004: EQUAL
100005: NOT
100006: AND
100007: OR
100008: IFFALSE 100012
// exit ;
100010: GO 100161
// if GetType ( factory ) = unit_human then
100012: LD_VAR 0 1
100016: PPUSH
100017: CALL_OW 247
100021: PUSH
100022: LD_INT 1
100024: EQUAL
100025: IFFALSE 100042
// factory := IsInUnit ( factory ) ;
100027: LD_ADDR_VAR 0 1
100031: PUSH
100032: LD_VAR 0 1
100036: PPUSH
100037: CALL_OW 310
100041: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100042: LD_VAR 0 1
100046: PPUSH
100047: CALL_OW 266
100051: PUSH
100052: LD_INT 3
100054: NONEQUAL
100055: IFFALSE 100059
// exit ;
100057: GO 100161
// if HexInfo ( x , y ) = factory then
100059: LD_VAR 0 2
100063: PPUSH
100064: LD_VAR 0 3
100068: PPUSH
100069: CALL_OW 428
100073: PUSH
100074: LD_VAR 0 1
100078: EQUAL
100079: IFFALSE 100106
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100081: LD_ADDR_EXP 170
100085: PUSH
100086: LD_EXP 170
100090: PPUSH
100091: LD_VAR 0 1
100095: PPUSH
100096: LD_INT 0
100098: PPUSH
100099: CALL_OW 1
100103: ST_TO_ADDR
100104: GO 100157
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100106: LD_ADDR_EXP 170
100110: PUSH
100111: LD_EXP 170
100115: PPUSH
100116: LD_VAR 0 1
100120: PPUSH
100121: LD_VAR 0 1
100125: PPUSH
100126: CALL_OW 255
100130: PUSH
100131: LD_VAR 0 1
100135: PUSH
100136: LD_VAR 0 2
100140: PUSH
100141: LD_VAR 0 3
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: LIST
100150: LIST
100151: PPUSH
100152: CALL_OW 1
100156: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100157: CALL 100166 0 0
// end ;
100161: LD_VAR 0 4
100165: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
100166: LD_INT 0
100168: PPUSH
100169: PPUSH
100170: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100171: LD_STRING resetFactoryWaypoint();
100173: PPUSH
100174: CALL_OW 559
// if factoryWaypoints then
100178: LD_EXP 170
100182: IFFALSE 100308
// begin list := PrepareArray ( factoryWaypoints ) ;
100184: LD_ADDR_VAR 0 3
100188: PUSH
100189: LD_EXP 170
100193: PPUSH
100194: CALL 54776 0 1
100198: ST_TO_ADDR
// for i := 1 to list do
100199: LD_ADDR_VAR 0 2
100203: PUSH
100204: DOUBLE
100205: LD_INT 1
100207: DEC
100208: ST_TO_ADDR
100209: LD_VAR 0 3
100213: PUSH
100214: FOR_TO
100215: IFFALSE 100306
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100217: LD_STRING setFactoryWaypointXY(
100219: PUSH
100220: LD_VAR 0 3
100224: PUSH
100225: LD_VAR 0 2
100229: ARRAY
100230: PUSH
100231: LD_INT 1
100233: ARRAY
100234: STR
100235: PUSH
100236: LD_STRING ,
100238: STR
100239: PUSH
100240: LD_VAR 0 3
100244: PUSH
100245: LD_VAR 0 2
100249: ARRAY
100250: PUSH
100251: LD_INT 2
100253: ARRAY
100254: STR
100255: PUSH
100256: LD_STRING ,
100258: STR
100259: PUSH
100260: LD_VAR 0 3
100264: PUSH
100265: LD_VAR 0 2
100269: ARRAY
100270: PUSH
100271: LD_INT 3
100273: ARRAY
100274: STR
100275: PUSH
100276: LD_STRING ,
100278: STR
100279: PUSH
100280: LD_VAR 0 3
100284: PUSH
100285: LD_VAR 0 2
100289: ARRAY
100290: PUSH
100291: LD_INT 4
100293: ARRAY
100294: STR
100295: PUSH
100296: LD_STRING )
100298: STR
100299: PPUSH
100300: CALL_OW 559
100304: GO 100214
100306: POP
100307: POP
// end ; end ;
100308: LD_VAR 0 1
100312: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
100313: LD_INT 0
100315: PPUSH
// if HexInfo ( x , y ) = warehouse then
100316: LD_VAR 0 2
100320: PPUSH
100321: LD_VAR 0 3
100325: PPUSH
100326: CALL_OW 428
100330: PUSH
100331: LD_VAR 0 1
100335: EQUAL
100336: IFFALSE 100363
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
100338: LD_ADDR_EXP 171
100342: PUSH
100343: LD_EXP 171
100347: PPUSH
100348: LD_VAR 0 1
100352: PPUSH
100353: LD_INT 0
100355: PPUSH
100356: CALL_OW 1
100360: ST_TO_ADDR
100361: GO 100414
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
100363: LD_ADDR_EXP 171
100367: PUSH
100368: LD_EXP 171
100372: PPUSH
100373: LD_VAR 0 1
100377: PPUSH
100378: LD_VAR 0 1
100382: PPUSH
100383: CALL_OW 255
100387: PUSH
100388: LD_VAR 0 1
100392: PUSH
100393: LD_VAR 0 2
100397: PUSH
100398: LD_VAR 0 3
100402: PUSH
100403: EMPTY
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: PPUSH
100409: CALL_OW 1
100413: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
100414: CALL 100423 0 0
// end ;
100418: LD_VAR 0 4
100422: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
100423: LD_INT 0
100425: PPUSH
100426: PPUSH
100427: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
100428: LD_STRING resetWarehouseGatheringPoints();
100430: PPUSH
100431: CALL_OW 559
// if warehouseGatheringPoints then
100435: LD_EXP 171
100439: IFFALSE 100565
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
100441: LD_ADDR_VAR 0 3
100445: PUSH
100446: LD_EXP 171
100450: PPUSH
100451: CALL 54776 0 1
100455: ST_TO_ADDR
// for i := 1 to list do
100456: LD_ADDR_VAR 0 2
100460: PUSH
100461: DOUBLE
100462: LD_INT 1
100464: DEC
100465: ST_TO_ADDR
100466: LD_VAR 0 3
100470: PUSH
100471: FOR_TO
100472: IFFALSE 100563
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100474: LD_STRING setWarehouseGatheringPointXY(
100476: PUSH
100477: LD_VAR 0 3
100481: PUSH
100482: LD_VAR 0 2
100486: ARRAY
100487: PUSH
100488: LD_INT 1
100490: ARRAY
100491: STR
100492: PUSH
100493: LD_STRING ,
100495: STR
100496: PUSH
100497: LD_VAR 0 3
100501: PUSH
100502: LD_VAR 0 2
100506: ARRAY
100507: PUSH
100508: LD_INT 2
100510: ARRAY
100511: STR
100512: PUSH
100513: LD_STRING ,
100515: STR
100516: PUSH
100517: LD_VAR 0 3
100521: PUSH
100522: LD_VAR 0 2
100526: ARRAY
100527: PUSH
100528: LD_INT 3
100530: ARRAY
100531: STR
100532: PUSH
100533: LD_STRING ,
100535: STR
100536: PUSH
100537: LD_VAR 0 3
100541: PUSH
100542: LD_VAR 0 2
100546: ARRAY
100547: PUSH
100548: LD_INT 4
100550: ARRAY
100551: STR
100552: PUSH
100553: LD_STRING )
100555: STR
100556: PPUSH
100557: CALL_OW 559
100561: GO 100471
100563: POP
100564: POP
// end ; end ;
100565: LD_VAR 0 1
100569: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
100570: LD_EXP 171
100574: IFFALSE 101261
100576: GO 100578
100578: DISABLE
100579: LD_INT 0
100581: PPUSH
100582: PPUSH
100583: PPUSH
100584: PPUSH
100585: PPUSH
100586: PPUSH
100587: PPUSH
100588: PPUSH
100589: PPUSH
// begin enable ;
100590: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
100591: LD_ADDR_VAR 0 3
100595: PUSH
100596: LD_EXP 171
100600: PPUSH
100601: CALL 54776 0 1
100605: ST_TO_ADDR
// if not list then
100606: LD_VAR 0 3
100610: NOT
100611: IFFALSE 100615
// exit ;
100613: GO 101261
// for i := 1 to list do
100615: LD_ADDR_VAR 0 1
100619: PUSH
100620: DOUBLE
100621: LD_INT 1
100623: DEC
100624: ST_TO_ADDR
100625: LD_VAR 0 3
100629: PUSH
100630: FOR_TO
100631: IFFALSE 101259
// begin depot := list [ i ] [ 2 ] ;
100633: LD_ADDR_VAR 0 8
100637: PUSH
100638: LD_VAR 0 3
100642: PUSH
100643: LD_VAR 0 1
100647: ARRAY
100648: PUSH
100649: LD_INT 2
100651: ARRAY
100652: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
100653: LD_ADDR_VAR 0 5
100657: PUSH
100658: LD_VAR 0 3
100662: PUSH
100663: LD_VAR 0 1
100667: ARRAY
100668: PUSH
100669: LD_INT 1
100671: ARRAY
100672: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
100673: LD_VAR 0 8
100677: PPUSH
100678: CALL_OW 301
100682: PUSH
100683: LD_VAR 0 5
100687: PUSH
100688: LD_VAR 0 8
100692: PPUSH
100693: CALL_OW 255
100697: NONEQUAL
100698: OR
100699: IFFALSE 100728
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
100701: LD_ADDR_EXP 171
100705: PUSH
100706: LD_EXP 171
100710: PPUSH
100711: LD_VAR 0 8
100715: PPUSH
100716: LD_INT 0
100718: PPUSH
100719: CALL_OW 1
100723: ST_TO_ADDR
// exit ;
100724: POP
100725: POP
100726: GO 101261
// end ; x := list [ i ] [ 3 ] ;
100728: LD_ADDR_VAR 0 6
100732: PUSH
100733: LD_VAR 0 3
100737: PUSH
100738: LD_VAR 0 1
100742: ARRAY
100743: PUSH
100744: LD_INT 3
100746: ARRAY
100747: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
100748: LD_ADDR_VAR 0 7
100752: PUSH
100753: LD_VAR 0 3
100757: PUSH
100758: LD_VAR 0 1
100762: ARRAY
100763: PUSH
100764: LD_INT 4
100766: ARRAY
100767: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
100768: LD_ADDR_VAR 0 9
100772: PUSH
100773: LD_VAR 0 6
100777: PPUSH
100778: LD_VAR 0 7
100782: PPUSH
100783: LD_INT 16
100785: PPUSH
100786: CALL 53360 0 3
100790: ST_TO_ADDR
// if not cratesNearbyPoint then
100791: LD_VAR 0 9
100795: NOT
100796: IFFALSE 100802
// exit ;
100798: POP
100799: POP
100800: GO 101261
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
100802: LD_ADDR_VAR 0 4
100806: PUSH
100807: LD_INT 22
100809: PUSH
100810: LD_VAR 0 5
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 3
100821: PUSH
100822: LD_INT 60
100824: PUSH
100825: EMPTY
100826: LIST
100827: PUSH
100828: EMPTY
100829: LIST
100830: LIST
100831: PUSH
100832: LD_INT 91
100834: PUSH
100835: LD_VAR 0 8
100839: PUSH
100840: LD_INT 6
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: LIST
100847: PUSH
100848: LD_INT 2
100850: PUSH
100851: LD_INT 25
100853: PUSH
100854: LD_INT 2
100856: PUSH
100857: EMPTY
100858: LIST
100859: LIST
100860: PUSH
100861: LD_INT 25
100863: PUSH
100864: LD_INT 16
100866: PUSH
100867: EMPTY
100868: LIST
100869: LIST
100870: PUSH
100871: EMPTY
100872: LIST
100873: LIST
100874: LIST
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: PPUSH
100882: CALL_OW 69
100886: PUSH
100887: LD_VAR 0 8
100891: PPUSH
100892: CALL_OW 313
100896: PPUSH
100897: LD_INT 3
100899: PUSH
100900: LD_INT 60
100902: PUSH
100903: EMPTY
100904: LIST
100905: PUSH
100906: EMPTY
100907: LIST
100908: LIST
100909: PUSH
100910: LD_INT 2
100912: PUSH
100913: LD_INT 25
100915: PUSH
100916: LD_INT 2
100918: PUSH
100919: EMPTY
100920: LIST
100921: LIST
100922: PUSH
100923: LD_INT 25
100925: PUSH
100926: LD_INT 16
100928: PUSH
100929: EMPTY
100930: LIST
100931: LIST
100932: PUSH
100933: EMPTY
100934: LIST
100935: LIST
100936: LIST
100937: PUSH
100938: EMPTY
100939: LIST
100940: LIST
100941: PPUSH
100942: CALL_OW 72
100946: UNION
100947: ST_TO_ADDR
// if tmp then
100948: LD_VAR 0 4
100952: IFFALSE 101032
// begin tmp := ShrinkArray ( tmp , 3 ) ;
100954: LD_ADDR_VAR 0 4
100958: PUSH
100959: LD_VAR 0 4
100963: PPUSH
100964: LD_INT 3
100966: PPUSH
100967: CALL 51327 0 2
100971: ST_TO_ADDR
// for j in tmp do
100972: LD_ADDR_VAR 0 2
100976: PUSH
100977: LD_VAR 0 4
100981: PUSH
100982: FOR_IN
100983: IFFALSE 101026
// begin if IsInUnit ( j ) then
100985: LD_VAR 0 2
100989: PPUSH
100990: CALL_OW 310
100994: IFFALSE 101005
// ComExit ( j ) ;
100996: LD_VAR 0 2
101000: PPUSH
101001: CALL 51410 0 1
// AddComCollect ( j , x , y ) ;
101005: LD_VAR 0 2
101009: PPUSH
101010: LD_VAR 0 6
101014: PPUSH
101015: LD_VAR 0 7
101019: PPUSH
101020: CALL_OW 177
// end ;
101024: GO 100982
101026: POP
101027: POP
// exit ;
101028: POP
101029: POP
101030: GO 101261
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
101032: LD_ADDR_VAR 0 4
101036: PUSH
101037: LD_INT 22
101039: PUSH
101040: LD_VAR 0 5
101044: PUSH
101045: EMPTY
101046: LIST
101047: LIST
101048: PUSH
101049: LD_INT 91
101051: PUSH
101052: LD_VAR 0 8
101056: PUSH
101057: LD_INT 8
101059: PUSH
101060: EMPTY
101061: LIST
101062: LIST
101063: LIST
101064: PUSH
101065: LD_INT 2
101067: PUSH
101068: LD_INT 34
101070: PUSH
101071: LD_INT 12
101073: PUSH
101074: EMPTY
101075: LIST
101076: LIST
101077: PUSH
101078: LD_INT 34
101080: PUSH
101081: LD_INT 51
101083: PUSH
101084: EMPTY
101085: LIST
101086: LIST
101087: PUSH
101088: LD_INT 34
101090: PUSH
101091: LD_INT 32
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PUSH
101098: LD_INT 34
101100: PUSH
101101: LD_EXP 49
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: PUSH
101110: EMPTY
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: PUSH
101117: EMPTY
101118: LIST
101119: LIST
101120: LIST
101121: PPUSH
101122: CALL_OW 69
101126: ST_TO_ADDR
// if tmp then
101127: LD_VAR 0 4
101131: IFFALSE 101257
// begin for j in tmp do
101133: LD_ADDR_VAR 0 2
101137: PUSH
101138: LD_VAR 0 4
101142: PUSH
101143: FOR_IN
101144: IFFALSE 101255
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
101146: LD_VAR 0 2
101150: PPUSH
101151: CALL_OW 262
101155: PUSH
101156: LD_INT 3
101158: EQUAL
101159: PUSH
101160: LD_VAR 0 2
101164: PPUSH
101165: CALL_OW 261
101169: PUSH
101170: LD_INT 20
101172: GREATER
101173: OR
101174: PUSH
101175: LD_VAR 0 2
101179: PPUSH
101180: CALL_OW 314
101184: NOT
101185: AND
101186: PUSH
101187: LD_VAR 0 2
101191: PPUSH
101192: CALL_OW 263
101196: PUSH
101197: LD_INT 1
101199: NONEQUAL
101200: PUSH
101201: LD_VAR 0 2
101205: PPUSH
101206: CALL_OW 311
101210: OR
101211: AND
101212: IFFALSE 101253
// begin ComCollect ( j , x , y ) ;
101214: LD_VAR 0 2
101218: PPUSH
101219: LD_VAR 0 6
101223: PPUSH
101224: LD_VAR 0 7
101228: PPUSH
101229: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
101233: LD_VAR 0 2
101237: PPUSH
101238: LD_VAR 0 8
101242: PPUSH
101243: CALL_OW 172
// exit ;
101247: POP
101248: POP
101249: POP
101250: POP
101251: GO 101261
// end ;
101253: GO 101143
101255: POP
101256: POP
// end ; end ;
101257: GO 100630
101259: POP
101260: POP
// end ; end_of_file
101261: PPOPN 9
101263: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101264: LD_INT 0
101266: PPUSH
101267: PPUSH
101268: PPUSH
101269: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101270: LD_VAR 0 1
101274: PPUSH
101275: CALL_OW 264
101279: PUSH
101280: LD_EXP 52
101284: EQUAL
101285: IFFALSE 101357
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101287: LD_INT 68
101289: PPUSH
101290: LD_VAR 0 1
101294: PPUSH
101295: CALL_OW 255
101299: PPUSH
101300: CALL_OW 321
101304: PUSH
101305: LD_INT 2
101307: EQUAL
101308: IFFALSE 101320
// eff := 70 else
101310: LD_ADDR_VAR 0 4
101314: PUSH
101315: LD_INT 70
101317: ST_TO_ADDR
101318: GO 101328
// eff := 30 ;
101320: LD_ADDR_VAR 0 4
101324: PUSH
101325: LD_INT 30
101327: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101328: LD_VAR 0 1
101332: PPUSH
101333: CALL_OW 250
101337: PPUSH
101338: LD_VAR 0 1
101342: PPUSH
101343: CALL_OW 251
101347: PPUSH
101348: LD_VAR 0 4
101352: PPUSH
101353: CALL_OW 495
// end ; end ;
101357: LD_VAR 0 2
101361: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101362: LD_INT 0
101364: PPUSH
// end ;
101365: LD_VAR 0 4
101369: RET
// export function SOS_Command ( cmd ) ; begin
101370: LD_INT 0
101372: PPUSH
// end ;
101373: LD_VAR 0 2
101377: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101378: LD_INT 0
101380: PPUSH
// end ;
101381: LD_VAR 0 6
101385: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
101386: LD_INT 0
101388: PPUSH
101389: PPUSH
// if not vehicle or not factory then
101390: LD_VAR 0 1
101394: NOT
101395: PUSH
101396: LD_VAR 0 2
101400: NOT
101401: OR
101402: IFFALSE 101406
// exit ;
101404: GO 101637
// if factoryWaypoints >= factory then
101406: LD_EXP 170
101410: PUSH
101411: LD_VAR 0 2
101415: GREATEREQUAL
101416: IFFALSE 101637
// if factoryWaypoints [ factory ] then
101418: LD_EXP 170
101422: PUSH
101423: LD_VAR 0 2
101427: ARRAY
101428: IFFALSE 101637
// begin if GetControl ( vehicle ) = control_manual then
101430: LD_VAR 0 1
101434: PPUSH
101435: CALL_OW 263
101439: PUSH
101440: LD_INT 1
101442: EQUAL
101443: IFFALSE 101524
// begin driver := IsDrivenBy ( vehicle ) ;
101445: LD_ADDR_VAR 0 4
101449: PUSH
101450: LD_VAR 0 1
101454: PPUSH
101455: CALL_OW 311
101459: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101460: LD_VAR 0 4
101464: PPUSH
101465: LD_EXP 170
101469: PUSH
101470: LD_VAR 0 2
101474: ARRAY
101475: PUSH
101476: LD_INT 3
101478: ARRAY
101479: PPUSH
101480: LD_EXP 170
101484: PUSH
101485: LD_VAR 0 2
101489: ARRAY
101490: PUSH
101491: LD_INT 4
101493: ARRAY
101494: PPUSH
101495: CALL_OW 171
// AddComExitVehicle ( driver ) ;
101499: LD_VAR 0 4
101503: PPUSH
101504: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
101508: LD_VAR 0 4
101512: PPUSH
101513: LD_VAR 0 2
101517: PPUSH
101518: CALL_OW 180
// end else
101522: GO 101637
// if GetControl ( vehicle ) = control_remote then
101524: LD_VAR 0 1
101528: PPUSH
101529: CALL_OW 263
101533: PUSH
101534: LD_INT 2
101536: EQUAL
101537: IFFALSE 101598
// begin wait ( 0 0$2 ) ;
101539: LD_INT 70
101541: PPUSH
101542: CALL_OW 67
// if Connect ( vehicle ) then
101546: LD_VAR 0 1
101550: PPUSH
101551: CALL 21721 0 1
101555: IFFALSE 101596
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101557: LD_VAR 0 1
101561: PPUSH
101562: LD_EXP 170
101566: PUSH
101567: LD_VAR 0 2
101571: ARRAY
101572: PUSH
101573: LD_INT 3
101575: ARRAY
101576: PPUSH
101577: LD_EXP 170
101581: PUSH
101582: LD_VAR 0 2
101586: ARRAY
101587: PUSH
101588: LD_INT 4
101590: ARRAY
101591: PPUSH
101592: CALL_OW 171
// end else
101596: GO 101637
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101598: LD_VAR 0 1
101602: PPUSH
101603: LD_EXP 170
101607: PUSH
101608: LD_VAR 0 2
101612: ARRAY
101613: PUSH
101614: LD_INT 3
101616: ARRAY
101617: PPUSH
101618: LD_EXP 170
101622: PUSH
101623: LD_VAR 0 2
101627: ARRAY
101628: PUSH
101629: LD_INT 4
101631: ARRAY
101632: PPUSH
101633: CALL_OW 171
// end ; end ;
101637: LD_VAR 0 3
101641: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
101642: LD_INT 0
101644: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
101645: LD_VAR 0 1
101649: PUSH
101650: LD_INT 250
101652: EQUAL
101653: PUSH
101654: LD_VAR 0 2
101658: PPUSH
101659: CALL_OW 264
101663: PUSH
101664: LD_EXP 55
101668: EQUAL
101669: AND
101670: IFFALSE 101691
// MinerPlaceMine ( unit , x , y ) ;
101672: LD_VAR 0 2
101676: PPUSH
101677: LD_VAR 0 4
101681: PPUSH
101682: LD_VAR 0 5
101686: PPUSH
101687: CALL 104090 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
101691: LD_VAR 0 1
101695: PUSH
101696: LD_INT 251
101698: EQUAL
101699: PUSH
101700: LD_VAR 0 2
101704: PPUSH
101705: CALL_OW 264
101709: PUSH
101710: LD_EXP 55
101714: EQUAL
101715: AND
101716: IFFALSE 101737
// MinerDetonateMine ( unit , x , y ) ;
101718: LD_VAR 0 2
101722: PPUSH
101723: LD_VAR 0 4
101727: PPUSH
101728: LD_VAR 0 5
101732: PPUSH
101733: CALL 104367 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
101737: LD_VAR 0 1
101741: PUSH
101742: LD_INT 252
101744: EQUAL
101745: PUSH
101746: LD_VAR 0 2
101750: PPUSH
101751: CALL_OW 264
101755: PUSH
101756: LD_EXP 55
101760: EQUAL
101761: AND
101762: IFFALSE 101783
// MinerCreateMinefield ( unit , x , y ) ;
101764: LD_VAR 0 2
101768: PPUSH
101769: LD_VAR 0 4
101773: PPUSH
101774: LD_VAR 0 5
101778: PPUSH
101779: CALL 104784 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
101783: LD_VAR 0 1
101787: PUSH
101788: LD_INT 253
101790: EQUAL
101791: PUSH
101792: LD_VAR 0 2
101796: PPUSH
101797: CALL_OW 257
101801: PUSH
101802: LD_INT 5
101804: EQUAL
101805: AND
101806: IFFALSE 101827
// ComBinocular ( unit , x , y ) ;
101808: LD_VAR 0 2
101812: PPUSH
101813: LD_VAR 0 4
101817: PPUSH
101818: LD_VAR 0 5
101822: PPUSH
101823: CALL 105155 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
101827: LD_VAR 0 1
101831: PUSH
101832: LD_INT 254
101834: EQUAL
101835: PUSH
101836: LD_VAR 0 2
101840: PPUSH
101841: CALL_OW 264
101845: PUSH
101846: LD_EXP 50
101850: EQUAL
101851: AND
101852: PUSH
101853: LD_VAR 0 3
101857: PPUSH
101858: CALL_OW 263
101862: PUSH
101863: LD_INT 3
101865: EQUAL
101866: AND
101867: IFFALSE 101883
// HackDestroyVehicle ( unit , selectedUnit ) ;
101869: LD_VAR 0 2
101873: PPUSH
101874: LD_VAR 0 3
101878: PPUSH
101879: CALL 103450 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
101883: LD_VAR 0 1
101887: PUSH
101888: LD_INT 255
101890: EQUAL
101891: PUSH
101892: LD_VAR 0 2
101896: PPUSH
101897: CALL_OW 264
101901: PUSH
101902: LD_INT 14
101904: PUSH
101905: LD_INT 53
101907: PUSH
101908: EMPTY
101909: LIST
101910: LIST
101911: IN
101912: AND
101913: PUSH
101914: LD_VAR 0 4
101918: PPUSH
101919: LD_VAR 0 5
101923: PPUSH
101924: CALL_OW 488
101928: AND
101929: IFFALSE 101953
// CutTreeXYR ( unit , x , y , 12 ) ;
101931: LD_VAR 0 2
101935: PPUSH
101936: LD_VAR 0 4
101940: PPUSH
101941: LD_VAR 0 5
101945: PPUSH
101946: LD_INT 12
101948: PPUSH
101949: CALL 102016 0 4
// if cmd = 256 then
101953: LD_VAR 0 1
101957: PUSH
101958: LD_INT 256
101960: EQUAL
101961: IFFALSE 101982
// SetFactoryWaypoint ( unit , x , y ) ;
101963: LD_VAR 0 2
101967: PPUSH
101968: LD_VAR 0 4
101972: PPUSH
101973: LD_VAR 0 5
101977: PPUSH
101978: CALL 99951 0 3
// if cmd = 257 then
101982: LD_VAR 0 1
101986: PUSH
101987: LD_INT 257
101989: EQUAL
101990: IFFALSE 102011
// SetWarehouseGatheringPoint ( unit , x , y ) ;
101992: LD_VAR 0 2
101996: PPUSH
101997: LD_VAR 0 4
102001: PPUSH
102002: LD_VAR 0 5
102006: PPUSH
102007: CALL 100313 0 3
// end ;
102011: LD_VAR 0 6
102015: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102016: LD_INT 0
102018: PPUSH
102019: PPUSH
102020: PPUSH
102021: PPUSH
102022: PPUSH
102023: PPUSH
102024: PPUSH
102025: PPUSH
102026: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102027: LD_VAR 0 1
102031: NOT
102032: PUSH
102033: LD_VAR 0 2
102037: PPUSH
102038: LD_VAR 0 3
102042: PPUSH
102043: CALL_OW 488
102047: NOT
102048: OR
102049: PUSH
102050: LD_VAR 0 4
102054: NOT
102055: OR
102056: IFFALSE 102060
// exit ;
102058: GO 102400
// list := [ ] ;
102060: LD_ADDR_VAR 0 13
102064: PUSH
102065: EMPTY
102066: ST_TO_ADDR
// if x - r < 0 then
102067: LD_VAR 0 2
102071: PUSH
102072: LD_VAR 0 4
102076: MINUS
102077: PUSH
102078: LD_INT 0
102080: LESS
102081: IFFALSE 102093
// min_x := 0 else
102083: LD_ADDR_VAR 0 7
102087: PUSH
102088: LD_INT 0
102090: ST_TO_ADDR
102091: GO 102109
// min_x := x - r ;
102093: LD_ADDR_VAR 0 7
102097: PUSH
102098: LD_VAR 0 2
102102: PUSH
102103: LD_VAR 0 4
102107: MINUS
102108: ST_TO_ADDR
// if y - r < 0 then
102109: LD_VAR 0 3
102113: PUSH
102114: LD_VAR 0 4
102118: MINUS
102119: PUSH
102120: LD_INT 0
102122: LESS
102123: IFFALSE 102135
// min_y := 0 else
102125: LD_ADDR_VAR 0 8
102129: PUSH
102130: LD_INT 0
102132: ST_TO_ADDR
102133: GO 102151
// min_y := y - r ;
102135: LD_ADDR_VAR 0 8
102139: PUSH
102140: LD_VAR 0 3
102144: PUSH
102145: LD_VAR 0 4
102149: MINUS
102150: ST_TO_ADDR
// max_x := x + r ;
102151: LD_ADDR_VAR 0 9
102155: PUSH
102156: LD_VAR 0 2
102160: PUSH
102161: LD_VAR 0 4
102165: PLUS
102166: ST_TO_ADDR
// max_y := y + r ;
102167: LD_ADDR_VAR 0 10
102171: PUSH
102172: LD_VAR 0 3
102176: PUSH
102177: LD_VAR 0 4
102181: PLUS
102182: ST_TO_ADDR
// for _x = min_x to max_x do
102183: LD_ADDR_VAR 0 11
102187: PUSH
102188: DOUBLE
102189: LD_VAR 0 7
102193: DEC
102194: ST_TO_ADDR
102195: LD_VAR 0 9
102199: PUSH
102200: FOR_TO
102201: IFFALSE 102318
// for _y = min_y to max_y do
102203: LD_ADDR_VAR 0 12
102207: PUSH
102208: DOUBLE
102209: LD_VAR 0 8
102213: DEC
102214: ST_TO_ADDR
102215: LD_VAR 0 10
102219: PUSH
102220: FOR_TO
102221: IFFALSE 102314
// begin if not ValidHex ( _x , _y ) then
102223: LD_VAR 0 11
102227: PPUSH
102228: LD_VAR 0 12
102232: PPUSH
102233: CALL_OW 488
102237: NOT
102238: IFFALSE 102242
// continue ;
102240: GO 102220
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102242: LD_VAR 0 11
102246: PPUSH
102247: LD_VAR 0 12
102251: PPUSH
102252: CALL_OW 351
102256: PUSH
102257: LD_VAR 0 11
102261: PPUSH
102262: LD_VAR 0 12
102266: PPUSH
102267: CALL_OW 554
102271: AND
102272: IFFALSE 102312
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102274: LD_ADDR_VAR 0 13
102278: PUSH
102279: LD_VAR 0 13
102283: PPUSH
102284: LD_VAR 0 13
102288: PUSH
102289: LD_INT 1
102291: PLUS
102292: PPUSH
102293: LD_VAR 0 11
102297: PUSH
102298: LD_VAR 0 12
102302: PUSH
102303: EMPTY
102304: LIST
102305: LIST
102306: PPUSH
102307: CALL_OW 2
102311: ST_TO_ADDR
// end ;
102312: GO 102220
102314: POP
102315: POP
102316: GO 102200
102318: POP
102319: POP
// if not list then
102320: LD_VAR 0 13
102324: NOT
102325: IFFALSE 102329
// exit ;
102327: GO 102400
// for i in list do
102329: LD_ADDR_VAR 0 6
102333: PUSH
102334: LD_VAR 0 13
102338: PUSH
102339: FOR_IN
102340: IFFALSE 102398
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102342: LD_VAR 0 1
102346: PPUSH
102347: LD_STRING M
102349: PUSH
102350: LD_VAR 0 6
102354: PUSH
102355: LD_INT 1
102357: ARRAY
102358: PUSH
102359: LD_VAR 0 6
102363: PUSH
102364: LD_INT 2
102366: ARRAY
102367: PUSH
102368: LD_INT 0
102370: PUSH
102371: LD_INT 0
102373: PUSH
102374: LD_INT 0
102376: PUSH
102377: LD_INT 0
102379: PUSH
102380: EMPTY
102381: LIST
102382: LIST
102383: LIST
102384: LIST
102385: LIST
102386: LIST
102387: LIST
102388: PUSH
102389: EMPTY
102390: LIST
102391: PPUSH
102392: CALL_OW 447
102396: GO 102339
102398: POP
102399: POP
// end ;
102400: LD_VAR 0 5
102404: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102405: LD_EXP 173
102409: NOT
102410: IFFALSE 102460
102412: GO 102414
102414: DISABLE
// begin initHack := true ;
102415: LD_ADDR_EXP 173
102419: PUSH
102420: LD_INT 1
102422: ST_TO_ADDR
// hackTanks := [ ] ;
102423: LD_ADDR_EXP 174
102427: PUSH
102428: EMPTY
102429: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102430: LD_ADDR_EXP 175
102434: PUSH
102435: EMPTY
102436: ST_TO_ADDR
// hackLimit := 3 ;
102437: LD_ADDR_EXP 176
102441: PUSH
102442: LD_INT 3
102444: ST_TO_ADDR
// hackDist := 12 ;
102445: LD_ADDR_EXP 177
102449: PUSH
102450: LD_INT 12
102452: ST_TO_ADDR
// hackCounter := [ ] ;
102453: LD_ADDR_EXP 178
102457: PUSH
102458: EMPTY
102459: ST_TO_ADDR
// end ;
102460: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102461: LD_EXP 173
102465: PUSH
102466: LD_INT 34
102468: PUSH
102469: LD_EXP 50
102473: PUSH
102474: EMPTY
102475: LIST
102476: LIST
102477: PPUSH
102478: CALL_OW 69
102482: AND
102483: IFFALSE 102738
102485: GO 102487
102487: DISABLE
102488: LD_INT 0
102490: PPUSH
102491: PPUSH
// begin enable ;
102492: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102493: LD_ADDR_VAR 0 1
102497: PUSH
102498: LD_INT 34
102500: PUSH
102501: LD_EXP 50
102505: PUSH
102506: EMPTY
102507: LIST
102508: LIST
102509: PPUSH
102510: CALL_OW 69
102514: PUSH
102515: FOR_IN
102516: IFFALSE 102736
// begin if not i in hackTanks then
102518: LD_VAR 0 1
102522: PUSH
102523: LD_EXP 174
102527: IN
102528: NOT
102529: IFFALSE 102612
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102531: LD_ADDR_EXP 174
102535: PUSH
102536: LD_EXP 174
102540: PPUSH
102541: LD_EXP 174
102545: PUSH
102546: LD_INT 1
102548: PLUS
102549: PPUSH
102550: LD_VAR 0 1
102554: PPUSH
102555: CALL_OW 1
102559: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102560: LD_ADDR_EXP 175
102564: PUSH
102565: LD_EXP 175
102569: PPUSH
102570: LD_EXP 175
102574: PUSH
102575: LD_INT 1
102577: PLUS
102578: PPUSH
102579: EMPTY
102580: PPUSH
102581: CALL_OW 1
102585: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102586: LD_ADDR_EXP 178
102590: PUSH
102591: LD_EXP 178
102595: PPUSH
102596: LD_EXP 178
102600: PUSH
102601: LD_INT 1
102603: PLUS
102604: PPUSH
102605: EMPTY
102606: PPUSH
102607: CALL_OW 1
102611: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102612: LD_VAR 0 1
102616: PPUSH
102617: CALL_OW 302
102621: NOT
102622: IFFALSE 102635
// begin HackUnlinkAll ( i ) ;
102624: LD_VAR 0 1
102628: PPUSH
102629: CALL 102741 0 1
// continue ;
102633: GO 102515
// end ; HackCheckCapturedStatus ( i ) ;
102635: LD_VAR 0 1
102639: PPUSH
102640: CALL 103184 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
102644: LD_ADDR_VAR 0 2
102648: PUSH
102649: LD_INT 81
102651: PUSH
102652: LD_VAR 0 1
102656: PPUSH
102657: CALL_OW 255
102661: PUSH
102662: EMPTY
102663: LIST
102664: LIST
102665: PUSH
102666: LD_INT 33
102668: PUSH
102669: LD_INT 3
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: PUSH
102676: LD_INT 91
102678: PUSH
102679: LD_VAR 0 1
102683: PUSH
102684: LD_EXP 177
102688: PUSH
102689: EMPTY
102690: LIST
102691: LIST
102692: LIST
102693: PUSH
102694: LD_INT 50
102696: PUSH
102697: EMPTY
102698: LIST
102699: PUSH
102700: EMPTY
102701: LIST
102702: LIST
102703: LIST
102704: LIST
102705: PPUSH
102706: CALL_OW 69
102710: ST_TO_ADDR
// if not tmp then
102711: LD_VAR 0 2
102715: NOT
102716: IFFALSE 102720
// continue ;
102718: GO 102515
// HackLink ( i , tmp ) ;
102720: LD_VAR 0 1
102724: PPUSH
102725: LD_VAR 0 2
102729: PPUSH
102730: CALL 102877 0 2
// end ;
102734: GO 102515
102736: POP
102737: POP
// end ;
102738: PPOPN 2
102740: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
102741: LD_INT 0
102743: PPUSH
102744: PPUSH
102745: PPUSH
// if not hack in hackTanks then
102746: LD_VAR 0 1
102750: PUSH
102751: LD_EXP 174
102755: IN
102756: NOT
102757: IFFALSE 102761
// exit ;
102759: GO 102872
// index := GetElementIndex ( hackTanks , hack ) ;
102761: LD_ADDR_VAR 0 4
102765: PUSH
102766: LD_EXP 174
102770: PPUSH
102771: LD_VAR 0 1
102775: PPUSH
102776: CALL 18535 0 2
102780: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
102781: LD_EXP 175
102785: PUSH
102786: LD_VAR 0 4
102790: ARRAY
102791: IFFALSE 102872
// begin for i in hackTanksCaptured [ index ] do
102793: LD_ADDR_VAR 0 3
102797: PUSH
102798: LD_EXP 175
102802: PUSH
102803: LD_VAR 0 4
102807: ARRAY
102808: PUSH
102809: FOR_IN
102810: IFFALSE 102836
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
102812: LD_VAR 0 3
102816: PUSH
102817: LD_INT 1
102819: ARRAY
102820: PPUSH
102821: LD_VAR 0 3
102825: PUSH
102826: LD_INT 2
102828: ARRAY
102829: PPUSH
102830: CALL_OW 235
102834: GO 102809
102836: POP
102837: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
102838: LD_ADDR_EXP 175
102842: PUSH
102843: LD_EXP 175
102847: PPUSH
102848: LD_VAR 0 4
102852: PPUSH
102853: EMPTY
102854: PPUSH
102855: CALL_OW 1
102859: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
102860: LD_VAR 0 1
102864: PPUSH
102865: LD_INT 0
102867: PPUSH
102868: CALL_OW 505
// end ; end ;
102872: LD_VAR 0 2
102876: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
102877: LD_INT 0
102879: PPUSH
102880: PPUSH
102881: PPUSH
// if not hack in hackTanks or not vehicles then
102882: LD_VAR 0 1
102886: PUSH
102887: LD_EXP 174
102891: IN
102892: NOT
102893: PUSH
102894: LD_VAR 0 2
102898: NOT
102899: OR
102900: IFFALSE 102904
// exit ;
102902: GO 103179
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
102904: LD_ADDR_VAR 0 2
102908: PUSH
102909: LD_VAR 0 1
102913: PPUSH
102914: LD_VAR 0 2
102918: PPUSH
102919: LD_INT 1
102921: PPUSH
102922: LD_INT 1
102924: PPUSH
102925: CALL 19185 0 4
102929: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102930: LD_ADDR_VAR 0 5
102934: PUSH
102935: LD_EXP 174
102939: PPUSH
102940: LD_VAR 0 1
102944: PPUSH
102945: CALL 18535 0 2
102949: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102950: LD_EXP 175
102954: PUSH
102955: LD_VAR 0 5
102959: ARRAY
102960: PUSH
102961: LD_EXP 176
102965: LESS
102966: IFFALSE 103155
// begin for i := 1 to vehicles do
102968: LD_ADDR_VAR 0 4
102972: PUSH
102973: DOUBLE
102974: LD_INT 1
102976: DEC
102977: ST_TO_ADDR
102978: LD_VAR 0 2
102982: PUSH
102983: FOR_TO
102984: IFFALSE 103153
// begin if hackTanksCaptured [ index ] = hackLimit then
102986: LD_EXP 175
102990: PUSH
102991: LD_VAR 0 5
102995: ARRAY
102996: PUSH
102997: LD_EXP 176
103001: EQUAL
103002: IFFALSE 103006
// break ;
103004: GO 103153
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103006: LD_ADDR_EXP 178
103010: PUSH
103011: LD_EXP 178
103015: PPUSH
103016: LD_VAR 0 5
103020: PPUSH
103021: LD_EXP 178
103025: PUSH
103026: LD_VAR 0 5
103030: ARRAY
103031: PUSH
103032: LD_INT 1
103034: PLUS
103035: PPUSH
103036: CALL_OW 1
103040: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103041: LD_ADDR_EXP 175
103045: PUSH
103046: LD_EXP 175
103050: PPUSH
103051: LD_VAR 0 5
103055: PUSH
103056: LD_EXP 175
103060: PUSH
103061: LD_VAR 0 5
103065: ARRAY
103066: PUSH
103067: LD_INT 1
103069: PLUS
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: PPUSH
103075: LD_VAR 0 2
103079: PUSH
103080: LD_VAR 0 4
103084: ARRAY
103085: PUSH
103086: LD_VAR 0 2
103090: PUSH
103091: LD_VAR 0 4
103095: ARRAY
103096: PPUSH
103097: CALL_OW 255
103101: PUSH
103102: EMPTY
103103: LIST
103104: LIST
103105: PPUSH
103106: CALL 18750 0 3
103110: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103111: LD_VAR 0 2
103115: PUSH
103116: LD_VAR 0 4
103120: ARRAY
103121: PPUSH
103122: LD_VAR 0 1
103126: PPUSH
103127: CALL_OW 255
103131: PPUSH
103132: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103136: LD_VAR 0 2
103140: PUSH
103141: LD_VAR 0 4
103145: ARRAY
103146: PPUSH
103147: CALL_OW 141
// end ;
103151: GO 102983
103153: POP
103154: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103155: LD_VAR 0 1
103159: PPUSH
103160: LD_EXP 175
103164: PUSH
103165: LD_VAR 0 5
103169: ARRAY
103170: PUSH
103171: LD_INT 0
103173: PLUS
103174: PPUSH
103175: CALL_OW 505
// end ;
103179: LD_VAR 0 3
103183: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103184: LD_INT 0
103186: PPUSH
103187: PPUSH
103188: PPUSH
103189: PPUSH
// if not hack in hackTanks then
103190: LD_VAR 0 1
103194: PUSH
103195: LD_EXP 174
103199: IN
103200: NOT
103201: IFFALSE 103205
// exit ;
103203: GO 103445
// index := GetElementIndex ( hackTanks , hack ) ;
103205: LD_ADDR_VAR 0 4
103209: PUSH
103210: LD_EXP 174
103214: PPUSH
103215: LD_VAR 0 1
103219: PPUSH
103220: CALL 18535 0 2
103224: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103225: LD_ADDR_VAR 0 3
103229: PUSH
103230: DOUBLE
103231: LD_EXP 175
103235: PUSH
103236: LD_VAR 0 4
103240: ARRAY
103241: INC
103242: ST_TO_ADDR
103243: LD_INT 1
103245: PUSH
103246: FOR_DOWNTO
103247: IFFALSE 103419
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103249: LD_ADDR_VAR 0 5
103253: PUSH
103254: LD_EXP 175
103258: PUSH
103259: LD_VAR 0 4
103263: ARRAY
103264: PUSH
103265: LD_VAR 0 3
103269: ARRAY
103270: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103271: LD_VAR 0 5
103275: PUSH
103276: LD_INT 1
103278: ARRAY
103279: PPUSH
103280: CALL_OW 302
103284: NOT
103285: PUSH
103286: LD_VAR 0 5
103290: PUSH
103291: LD_INT 1
103293: ARRAY
103294: PPUSH
103295: CALL_OW 255
103299: PUSH
103300: LD_VAR 0 1
103304: PPUSH
103305: CALL_OW 255
103309: NONEQUAL
103310: OR
103311: IFFALSE 103417
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103313: LD_VAR 0 5
103317: PUSH
103318: LD_INT 1
103320: ARRAY
103321: PPUSH
103322: CALL_OW 305
103326: PUSH
103327: LD_VAR 0 5
103331: PUSH
103332: LD_INT 1
103334: ARRAY
103335: PPUSH
103336: CALL_OW 255
103340: PUSH
103341: LD_VAR 0 1
103345: PPUSH
103346: CALL_OW 255
103350: EQUAL
103351: AND
103352: IFFALSE 103376
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103354: LD_VAR 0 5
103358: PUSH
103359: LD_INT 1
103361: ARRAY
103362: PPUSH
103363: LD_VAR 0 5
103367: PUSH
103368: LD_INT 2
103370: ARRAY
103371: PPUSH
103372: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103376: LD_ADDR_EXP 175
103380: PUSH
103381: LD_EXP 175
103385: PPUSH
103386: LD_VAR 0 4
103390: PPUSH
103391: LD_EXP 175
103395: PUSH
103396: LD_VAR 0 4
103400: ARRAY
103401: PPUSH
103402: LD_VAR 0 3
103406: PPUSH
103407: CALL_OW 3
103411: PPUSH
103412: CALL_OW 1
103416: ST_TO_ADDR
// end ; end ;
103417: GO 103246
103419: POP
103420: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103421: LD_VAR 0 1
103425: PPUSH
103426: LD_EXP 175
103430: PUSH
103431: LD_VAR 0 4
103435: ARRAY
103436: PUSH
103437: LD_INT 0
103439: PLUS
103440: PPUSH
103441: CALL_OW 505
// end ;
103445: LD_VAR 0 2
103449: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103450: LD_INT 0
103452: PPUSH
103453: PPUSH
103454: PPUSH
103455: PPUSH
// if not hack in hackTanks then
103456: LD_VAR 0 1
103460: PUSH
103461: LD_EXP 174
103465: IN
103466: NOT
103467: IFFALSE 103471
// exit ;
103469: GO 103556
// index := GetElementIndex ( hackTanks , hack ) ;
103471: LD_ADDR_VAR 0 5
103475: PUSH
103476: LD_EXP 174
103480: PPUSH
103481: LD_VAR 0 1
103485: PPUSH
103486: CALL 18535 0 2
103490: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103491: LD_ADDR_VAR 0 4
103495: PUSH
103496: DOUBLE
103497: LD_INT 1
103499: DEC
103500: ST_TO_ADDR
103501: LD_EXP 175
103505: PUSH
103506: LD_VAR 0 5
103510: ARRAY
103511: PUSH
103512: FOR_TO
103513: IFFALSE 103554
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103515: LD_EXP 175
103519: PUSH
103520: LD_VAR 0 5
103524: ARRAY
103525: PUSH
103526: LD_VAR 0 4
103530: ARRAY
103531: PUSH
103532: LD_INT 1
103534: ARRAY
103535: PUSH
103536: LD_VAR 0 2
103540: EQUAL
103541: IFFALSE 103552
// KillUnit ( vehicle ) ;
103543: LD_VAR 0 2
103547: PPUSH
103548: CALL_OW 66
103552: GO 103512
103554: POP
103555: POP
// end ;
103556: LD_VAR 0 3
103560: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103561: LD_EXP 179
103565: NOT
103566: IFFALSE 103601
103568: GO 103570
103570: DISABLE
// begin initMiner := true ;
103571: LD_ADDR_EXP 179
103575: PUSH
103576: LD_INT 1
103578: ST_TO_ADDR
// minersList := [ ] ;
103579: LD_ADDR_EXP 180
103583: PUSH
103584: EMPTY
103585: ST_TO_ADDR
// minerMinesList := [ ] ;
103586: LD_ADDR_EXP 181
103590: PUSH
103591: EMPTY
103592: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103593: LD_ADDR_EXP 182
103597: PUSH
103598: LD_INT 5
103600: ST_TO_ADDR
// end ;
103601: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103602: LD_EXP 179
103606: PUSH
103607: LD_INT 34
103609: PUSH
103610: LD_EXP 55
103614: PUSH
103615: EMPTY
103616: LIST
103617: LIST
103618: PPUSH
103619: CALL_OW 69
103623: AND
103624: IFFALSE 104087
103626: GO 103628
103628: DISABLE
103629: LD_INT 0
103631: PPUSH
103632: PPUSH
103633: PPUSH
103634: PPUSH
// begin enable ;
103635: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
103636: LD_ADDR_VAR 0 1
103640: PUSH
103641: LD_INT 34
103643: PUSH
103644: LD_EXP 55
103648: PUSH
103649: EMPTY
103650: LIST
103651: LIST
103652: PPUSH
103653: CALL_OW 69
103657: PUSH
103658: FOR_IN
103659: IFFALSE 103731
// begin if not i in minersList then
103661: LD_VAR 0 1
103665: PUSH
103666: LD_EXP 180
103670: IN
103671: NOT
103672: IFFALSE 103729
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
103674: LD_ADDR_EXP 180
103678: PUSH
103679: LD_EXP 180
103683: PPUSH
103684: LD_EXP 180
103688: PUSH
103689: LD_INT 1
103691: PLUS
103692: PPUSH
103693: LD_VAR 0 1
103697: PPUSH
103698: CALL_OW 1
103702: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
103703: LD_ADDR_EXP 181
103707: PUSH
103708: LD_EXP 181
103712: PPUSH
103713: LD_EXP 181
103717: PUSH
103718: LD_INT 1
103720: PLUS
103721: PPUSH
103722: EMPTY
103723: PPUSH
103724: CALL_OW 1
103728: ST_TO_ADDR
// end end ;
103729: GO 103658
103731: POP
103732: POP
// for i := minerMinesList downto 1 do
103733: LD_ADDR_VAR 0 1
103737: PUSH
103738: DOUBLE
103739: LD_EXP 181
103743: INC
103744: ST_TO_ADDR
103745: LD_INT 1
103747: PUSH
103748: FOR_DOWNTO
103749: IFFALSE 104085
// begin if IsLive ( minersList [ i ] ) then
103751: LD_EXP 180
103755: PUSH
103756: LD_VAR 0 1
103760: ARRAY
103761: PPUSH
103762: CALL_OW 300
103766: IFFALSE 103794
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
103768: LD_EXP 180
103772: PUSH
103773: LD_VAR 0 1
103777: ARRAY
103778: PPUSH
103779: LD_EXP 181
103783: PUSH
103784: LD_VAR 0 1
103788: ARRAY
103789: PPUSH
103790: CALL_OW 505
// if not minerMinesList [ i ] then
103794: LD_EXP 181
103798: PUSH
103799: LD_VAR 0 1
103803: ARRAY
103804: NOT
103805: IFFALSE 103809
// continue ;
103807: GO 103748
// for j := minerMinesList [ i ] downto 1 do
103809: LD_ADDR_VAR 0 2
103813: PUSH
103814: DOUBLE
103815: LD_EXP 181
103819: PUSH
103820: LD_VAR 0 1
103824: ARRAY
103825: INC
103826: ST_TO_ADDR
103827: LD_INT 1
103829: PUSH
103830: FOR_DOWNTO
103831: IFFALSE 104081
// begin side := GetSide ( minersList [ i ] ) ;
103833: LD_ADDR_VAR 0 3
103837: PUSH
103838: LD_EXP 180
103842: PUSH
103843: LD_VAR 0 1
103847: ARRAY
103848: PPUSH
103849: CALL_OW 255
103853: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
103854: LD_ADDR_VAR 0 4
103858: PUSH
103859: LD_EXP 181
103863: PUSH
103864: LD_VAR 0 1
103868: ARRAY
103869: PUSH
103870: LD_VAR 0 2
103874: ARRAY
103875: PUSH
103876: LD_INT 1
103878: ARRAY
103879: PPUSH
103880: LD_EXP 181
103884: PUSH
103885: LD_VAR 0 1
103889: ARRAY
103890: PUSH
103891: LD_VAR 0 2
103895: ARRAY
103896: PUSH
103897: LD_INT 2
103899: ARRAY
103900: PPUSH
103901: CALL_OW 428
103905: ST_TO_ADDR
// if not tmp then
103906: LD_VAR 0 4
103910: NOT
103911: IFFALSE 103915
// continue ;
103913: GO 103830
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103915: LD_VAR 0 4
103919: PUSH
103920: LD_INT 81
103922: PUSH
103923: LD_VAR 0 3
103927: PUSH
103928: EMPTY
103929: LIST
103930: LIST
103931: PPUSH
103932: CALL_OW 69
103936: IN
103937: PUSH
103938: LD_EXP 181
103942: PUSH
103943: LD_VAR 0 1
103947: ARRAY
103948: PUSH
103949: LD_VAR 0 2
103953: ARRAY
103954: PUSH
103955: LD_INT 1
103957: ARRAY
103958: PPUSH
103959: LD_EXP 181
103963: PUSH
103964: LD_VAR 0 1
103968: ARRAY
103969: PUSH
103970: LD_VAR 0 2
103974: ARRAY
103975: PUSH
103976: LD_INT 2
103978: ARRAY
103979: PPUSH
103980: CALL_OW 458
103984: AND
103985: IFFALSE 104079
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103987: LD_EXP 181
103991: PUSH
103992: LD_VAR 0 1
103996: ARRAY
103997: PUSH
103998: LD_VAR 0 2
104002: ARRAY
104003: PUSH
104004: LD_INT 1
104006: ARRAY
104007: PPUSH
104008: LD_EXP 181
104012: PUSH
104013: LD_VAR 0 1
104017: ARRAY
104018: PUSH
104019: LD_VAR 0 2
104023: ARRAY
104024: PUSH
104025: LD_INT 2
104027: ARRAY
104028: PPUSH
104029: LD_VAR 0 3
104033: PPUSH
104034: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104038: LD_ADDR_EXP 181
104042: PUSH
104043: LD_EXP 181
104047: PPUSH
104048: LD_VAR 0 1
104052: PPUSH
104053: LD_EXP 181
104057: PUSH
104058: LD_VAR 0 1
104062: ARRAY
104063: PPUSH
104064: LD_VAR 0 2
104068: PPUSH
104069: CALL_OW 3
104073: PPUSH
104074: CALL_OW 1
104078: ST_TO_ADDR
// end ; end ;
104079: GO 103830
104081: POP
104082: POP
// end ;
104083: GO 103748
104085: POP
104086: POP
// end ;
104087: PPOPN 4
104089: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104090: LD_INT 0
104092: PPUSH
104093: PPUSH
// result := false ;
104094: LD_ADDR_VAR 0 4
104098: PUSH
104099: LD_INT 0
104101: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104102: LD_VAR 0 1
104106: PPUSH
104107: CALL_OW 264
104111: PUSH
104112: LD_EXP 55
104116: EQUAL
104117: NOT
104118: IFFALSE 104122
// exit ;
104120: GO 104362
// index := GetElementIndex ( minersList , unit ) ;
104122: LD_ADDR_VAR 0 5
104126: PUSH
104127: LD_EXP 180
104131: PPUSH
104132: LD_VAR 0 1
104136: PPUSH
104137: CALL 18535 0 2
104141: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104142: LD_EXP 181
104146: PUSH
104147: LD_VAR 0 5
104151: ARRAY
104152: PUSH
104153: LD_EXP 182
104157: GREATEREQUAL
104158: IFFALSE 104162
// exit ;
104160: GO 104362
// ComMoveXY ( unit , x , y ) ;
104162: LD_VAR 0 1
104166: PPUSH
104167: LD_VAR 0 2
104171: PPUSH
104172: LD_VAR 0 3
104176: PPUSH
104177: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104181: LD_INT 35
104183: PPUSH
104184: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104188: LD_VAR 0 1
104192: PPUSH
104193: LD_VAR 0 2
104197: PPUSH
104198: LD_VAR 0 3
104202: PPUSH
104203: CALL 49821 0 3
104207: NOT
104208: PUSH
104209: LD_VAR 0 1
104213: PPUSH
104214: CALL_OW 314
104218: AND
104219: IFFALSE 104223
// exit ;
104221: GO 104362
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104223: LD_VAR 0 2
104227: PPUSH
104228: LD_VAR 0 3
104232: PPUSH
104233: CALL_OW 428
104237: PUSH
104238: LD_VAR 0 1
104242: EQUAL
104243: PUSH
104244: LD_VAR 0 1
104248: PPUSH
104249: CALL_OW 314
104253: NOT
104254: AND
104255: IFFALSE 104181
// PlaySoundXY ( x , y , PlantMine ) ;
104257: LD_VAR 0 2
104261: PPUSH
104262: LD_VAR 0 3
104266: PPUSH
104267: LD_STRING PlantMine
104269: PPUSH
104270: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104274: LD_VAR 0 2
104278: PPUSH
104279: LD_VAR 0 3
104283: PPUSH
104284: LD_VAR 0 1
104288: PPUSH
104289: CALL_OW 255
104293: PPUSH
104294: LD_INT 0
104296: PPUSH
104297: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104301: LD_ADDR_EXP 181
104305: PUSH
104306: LD_EXP 181
104310: PPUSH
104311: LD_VAR 0 5
104315: PUSH
104316: LD_EXP 181
104320: PUSH
104321: LD_VAR 0 5
104325: ARRAY
104326: PUSH
104327: LD_INT 1
104329: PLUS
104330: PUSH
104331: EMPTY
104332: LIST
104333: LIST
104334: PPUSH
104335: LD_VAR 0 2
104339: PUSH
104340: LD_VAR 0 3
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PPUSH
104349: CALL 18750 0 3
104353: ST_TO_ADDR
// result := true ;
104354: LD_ADDR_VAR 0 4
104358: PUSH
104359: LD_INT 1
104361: ST_TO_ADDR
// end ;
104362: LD_VAR 0 4
104366: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104367: LD_INT 0
104369: PPUSH
104370: PPUSH
104371: PPUSH
// if not unit in minersList then
104372: LD_VAR 0 1
104376: PUSH
104377: LD_EXP 180
104381: IN
104382: NOT
104383: IFFALSE 104387
// exit ;
104385: GO 104779
// index := GetElementIndex ( minersList , unit ) ;
104387: LD_ADDR_VAR 0 6
104391: PUSH
104392: LD_EXP 180
104396: PPUSH
104397: LD_VAR 0 1
104401: PPUSH
104402: CALL 18535 0 2
104406: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104407: LD_ADDR_VAR 0 5
104411: PUSH
104412: DOUBLE
104413: LD_EXP 181
104417: PUSH
104418: LD_VAR 0 6
104422: ARRAY
104423: INC
104424: ST_TO_ADDR
104425: LD_INT 1
104427: PUSH
104428: FOR_DOWNTO
104429: IFFALSE 104590
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104431: LD_EXP 181
104435: PUSH
104436: LD_VAR 0 6
104440: ARRAY
104441: PUSH
104442: LD_VAR 0 5
104446: ARRAY
104447: PUSH
104448: LD_INT 1
104450: ARRAY
104451: PUSH
104452: LD_VAR 0 2
104456: EQUAL
104457: PUSH
104458: LD_EXP 181
104462: PUSH
104463: LD_VAR 0 6
104467: ARRAY
104468: PUSH
104469: LD_VAR 0 5
104473: ARRAY
104474: PUSH
104475: LD_INT 2
104477: ARRAY
104478: PUSH
104479: LD_VAR 0 3
104483: EQUAL
104484: AND
104485: IFFALSE 104588
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104487: LD_EXP 181
104491: PUSH
104492: LD_VAR 0 6
104496: ARRAY
104497: PUSH
104498: LD_VAR 0 5
104502: ARRAY
104503: PUSH
104504: LD_INT 1
104506: ARRAY
104507: PPUSH
104508: LD_EXP 181
104512: PUSH
104513: LD_VAR 0 6
104517: ARRAY
104518: PUSH
104519: LD_VAR 0 5
104523: ARRAY
104524: PUSH
104525: LD_INT 2
104527: ARRAY
104528: PPUSH
104529: LD_VAR 0 1
104533: PPUSH
104534: CALL_OW 255
104538: PPUSH
104539: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104543: LD_ADDR_EXP 181
104547: PUSH
104548: LD_EXP 181
104552: PPUSH
104553: LD_VAR 0 6
104557: PPUSH
104558: LD_EXP 181
104562: PUSH
104563: LD_VAR 0 6
104567: ARRAY
104568: PPUSH
104569: LD_VAR 0 5
104573: PPUSH
104574: CALL_OW 3
104578: PPUSH
104579: CALL_OW 1
104583: ST_TO_ADDR
// exit ;
104584: POP
104585: POP
104586: GO 104779
// end ; end ;
104588: GO 104428
104590: POP
104591: POP
// for i := minerMinesList [ index ] downto 1 do
104592: LD_ADDR_VAR 0 5
104596: PUSH
104597: DOUBLE
104598: LD_EXP 181
104602: PUSH
104603: LD_VAR 0 6
104607: ARRAY
104608: INC
104609: ST_TO_ADDR
104610: LD_INT 1
104612: PUSH
104613: FOR_DOWNTO
104614: IFFALSE 104777
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104616: LD_EXP 181
104620: PUSH
104621: LD_VAR 0 6
104625: ARRAY
104626: PUSH
104627: LD_VAR 0 5
104631: ARRAY
104632: PUSH
104633: LD_INT 1
104635: ARRAY
104636: PPUSH
104637: LD_EXP 181
104641: PUSH
104642: LD_VAR 0 6
104646: ARRAY
104647: PUSH
104648: LD_VAR 0 5
104652: ARRAY
104653: PUSH
104654: LD_INT 2
104656: ARRAY
104657: PPUSH
104658: LD_VAR 0 2
104662: PPUSH
104663: LD_VAR 0 3
104667: PPUSH
104668: CALL_OW 298
104672: PUSH
104673: LD_INT 6
104675: LESS
104676: IFFALSE 104775
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104678: LD_EXP 181
104682: PUSH
104683: LD_VAR 0 6
104687: ARRAY
104688: PUSH
104689: LD_VAR 0 5
104693: ARRAY
104694: PUSH
104695: LD_INT 1
104697: ARRAY
104698: PPUSH
104699: LD_EXP 181
104703: PUSH
104704: LD_VAR 0 6
104708: ARRAY
104709: PUSH
104710: LD_VAR 0 5
104714: ARRAY
104715: PUSH
104716: LD_INT 2
104718: ARRAY
104719: PPUSH
104720: LD_VAR 0 1
104724: PPUSH
104725: CALL_OW 255
104729: PPUSH
104730: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104734: LD_ADDR_EXP 181
104738: PUSH
104739: LD_EXP 181
104743: PPUSH
104744: LD_VAR 0 6
104748: PPUSH
104749: LD_EXP 181
104753: PUSH
104754: LD_VAR 0 6
104758: ARRAY
104759: PPUSH
104760: LD_VAR 0 5
104764: PPUSH
104765: CALL_OW 3
104769: PPUSH
104770: CALL_OW 1
104774: ST_TO_ADDR
// end ; end ;
104775: GO 104613
104777: POP
104778: POP
// end ;
104779: LD_VAR 0 4
104783: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
104784: LD_INT 0
104786: PPUSH
104787: PPUSH
104788: PPUSH
104789: PPUSH
104790: PPUSH
104791: PPUSH
104792: PPUSH
104793: PPUSH
104794: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
104795: LD_VAR 0 1
104799: PPUSH
104800: CALL_OW 264
104804: PUSH
104805: LD_EXP 55
104809: EQUAL
104810: NOT
104811: PUSH
104812: LD_VAR 0 1
104816: PUSH
104817: LD_EXP 180
104821: IN
104822: NOT
104823: OR
104824: IFFALSE 104828
// exit ;
104826: GO 105150
// index := GetElementIndex ( minersList , unit ) ;
104828: LD_ADDR_VAR 0 6
104832: PUSH
104833: LD_EXP 180
104837: PPUSH
104838: LD_VAR 0 1
104842: PPUSH
104843: CALL 18535 0 2
104847: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
104848: LD_ADDR_VAR 0 8
104852: PUSH
104853: LD_EXP 182
104857: PUSH
104858: LD_EXP 181
104862: PUSH
104863: LD_VAR 0 6
104867: ARRAY
104868: MINUS
104869: ST_TO_ADDR
// if not minesFreeAmount then
104870: LD_VAR 0 8
104874: NOT
104875: IFFALSE 104879
// exit ;
104877: GO 105150
// tmp := [ ] ;
104879: LD_ADDR_VAR 0 7
104883: PUSH
104884: EMPTY
104885: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
104886: LD_ADDR_VAR 0 5
104890: PUSH
104891: DOUBLE
104892: LD_INT 1
104894: DEC
104895: ST_TO_ADDR
104896: LD_VAR 0 8
104900: PUSH
104901: FOR_TO
104902: IFFALSE 105097
// begin _d := rand ( 0 , 5 ) ;
104904: LD_ADDR_VAR 0 11
104908: PUSH
104909: LD_INT 0
104911: PPUSH
104912: LD_INT 5
104914: PPUSH
104915: CALL_OW 12
104919: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104920: LD_ADDR_VAR 0 12
104924: PUSH
104925: LD_INT 2
104927: PPUSH
104928: LD_INT 6
104930: PPUSH
104931: CALL_OW 12
104935: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104936: LD_ADDR_VAR 0 9
104940: PUSH
104941: LD_VAR 0 2
104945: PPUSH
104946: LD_VAR 0 11
104950: PPUSH
104951: LD_VAR 0 12
104955: PPUSH
104956: CALL_OW 272
104960: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104961: LD_ADDR_VAR 0 10
104965: PUSH
104966: LD_VAR 0 3
104970: PPUSH
104971: LD_VAR 0 11
104975: PPUSH
104976: LD_VAR 0 12
104980: PPUSH
104981: CALL_OW 273
104985: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104986: LD_VAR 0 9
104990: PPUSH
104991: LD_VAR 0 10
104995: PPUSH
104996: CALL_OW 488
105000: PUSH
105001: LD_VAR 0 9
105005: PUSH
105006: LD_VAR 0 10
105010: PUSH
105011: EMPTY
105012: LIST
105013: LIST
105014: PUSH
105015: LD_VAR 0 7
105019: IN
105020: NOT
105021: AND
105022: PUSH
105023: LD_VAR 0 9
105027: PPUSH
105028: LD_VAR 0 10
105032: PPUSH
105033: CALL_OW 458
105037: NOT
105038: AND
105039: IFFALSE 105081
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105041: LD_ADDR_VAR 0 7
105045: PUSH
105046: LD_VAR 0 7
105050: PPUSH
105051: LD_VAR 0 7
105055: PUSH
105056: LD_INT 1
105058: PLUS
105059: PPUSH
105060: LD_VAR 0 9
105064: PUSH
105065: LD_VAR 0 10
105069: PUSH
105070: EMPTY
105071: LIST
105072: LIST
105073: PPUSH
105074: CALL_OW 1
105078: ST_TO_ADDR
105079: GO 105095
// i := i - 1 ;
105081: LD_ADDR_VAR 0 5
105085: PUSH
105086: LD_VAR 0 5
105090: PUSH
105091: LD_INT 1
105093: MINUS
105094: ST_TO_ADDR
// end ;
105095: GO 104901
105097: POP
105098: POP
// for i in tmp do
105099: LD_ADDR_VAR 0 5
105103: PUSH
105104: LD_VAR 0 7
105108: PUSH
105109: FOR_IN
105110: IFFALSE 105148
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105112: LD_VAR 0 1
105116: PPUSH
105117: LD_VAR 0 5
105121: PUSH
105122: LD_INT 1
105124: ARRAY
105125: PPUSH
105126: LD_VAR 0 5
105130: PUSH
105131: LD_INT 2
105133: ARRAY
105134: PPUSH
105135: CALL 104090 0 3
105139: NOT
105140: IFFALSE 105146
// exit ;
105142: POP
105143: POP
105144: GO 105150
105146: GO 105109
105148: POP
105149: POP
// end ;
105150: LD_VAR 0 4
105154: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105155: LD_INT 0
105157: PPUSH
105158: PPUSH
105159: PPUSH
105160: PPUSH
105161: PPUSH
105162: PPUSH
105163: PPUSH
// if not GetClass ( unit ) = class_sniper then
105164: LD_VAR 0 1
105168: PPUSH
105169: CALL_OW 257
105173: PUSH
105174: LD_INT 5
105176: EQUAL
105177: NOT
105178: IFFALSE 105182
// exit ;
105180: GO 105570
// dist := 8 ;
105182: LD_ADDR_VAR 0 5
105186: PUSH
105187: LD_INT 8
105189: ST_TO_ADDR
// viewRange := 12 ;
105190: LD_ADDR_VAR 0 7
105194: PUSH
105195: LD_INT 12
105197: ST_TO_ADDR
// side := GetSide ( unit ) ;
105198: LD_ADDR_VAR 0 6
105202: PUSH
105203: LD_VAR 0 1
105207: PPUSH
105208: CALL_OW 255
105212: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105213: LD_INT 61
105215: PPUSH
105216: LD_VAR 0 6
105220: PPUSH
105221: CALL_OW 321
105225: PUSH
105226: LD_INT 2
105228: EQUAL
105229: IFFALSE 105239
// viewRange := 16 ;
105231: LD_ADDR_VAR 0 7
105235: PUSH
105236: LD_INT 16
105238: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105239: LD_VAR 0 1
105243: PPUSH
105244: LD_VAR 0 2
105248: PPUSH
105249: LD_VAR 0 3
105253: PPUSH
105254: CALL_OW 297
105258: PUSH
105259: LD_VAR 0 5
105263: GREATER
105264: IFFALSE 105343
// begin ComMoveXY ( unit , x , y ) ;
105266: LD_VAR 0 1
105270: PPUSH
105271: LD_VAR 0 2
105275: PPUSH
105276: LD_VAR 0 3
105280: PPUSH
105281: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105285: LD_INT 35
105287: PPUSH
105288: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105292: LD_VAR 0 1
105296: PPUSH
105297: LD_VAR 0 2
105301: PPUSH
105302: LD_VAR 0 3
105306: PPUSH
105307: CALL 49821 0 3
105311: NOT
105312: IFFALSE 105316
// exit ;
105314: GO 105570
// until GetDistUnitXY ( unit , x , y ) < dist ;
105316: LD_VAR 0 1
105320: PPUSH
105321: LD_VAR 0 2
105325: PPUSH
105326: LD_VAR 0 3
105330: PPUSH
105331: CALL_OW 297
105335: PUSH
105336: LD_VAR 0 5
105340: LESS
105341: IFFALSE 105285
// end ; ComTurnXY ( unit , x , y ) ;
105343: LD_VAR 0 1
105347: PPUSH
105348: LD_VAR 0 2
105352: PPUSH
105353: LD_VAR 0 3
105357: PPUSH
105358: CALL_OW 118
// wait ( 5 ) ;
105362: LD_INT 5
105364: PPUSH
105365: CALL_OW 67
// _d := GetDir ( unit ) ;
105369: LD_ADDR_VAR 0 10
105373: PUSH
105374: LD_VAR 0 1
105378: PPUSH
105379: CALL_OW 254
105383: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105384: LD_ADDR_VAR 0 8
105388: PUSH
105389: LD_VAR 0 1
105393: PPUSH
105394: CALL_OW 250
105398: PPUSH
105399: LD_VAR 0 10
105403: PPUSH
105404: LD_VAR 0 5
105408: PPUSH
105409: CALL_OW 272
105413: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105414: LD_ADDR_VAR 0 9
105418: PUSH
105419: LD_VAR 0 1
105423: PPUSH
105424: CALL_OW 251
105428: PPUSH
105429: LD_VAR 0 10
105433: PPUSH
105434: LD_VAR 0 5
105438: PPUSH
105439: CALL_OW 273
105443: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105444: LD_VAR 0 8
105448: PPUSH
105449: LD_VAR 0 9
105453: PPUSH
105454: CALL_OW 488
105458: NOT
105459: IFFALSE 105463
// exit ;
105461: GO 105570
// ComAnimCustom ( unit , 1 ) ;
105463: LD_VAR 0 1
105467: PPUSH
105468: LD_INT 1
105470: PPUSH
105471: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105475: LD_VAR 0 8
105479: PPUSH
105480: LD_VAR 0 9
105484: PPUSH
105485: LD_VAR 0 6
105489: PPUSH
105490: LD_VAR 0 7
105494: PPUSH
105495: CALL_OW 330
// repeat wait ( 1 ) ;
105499: LD_INT 1
105501: PPUSH
105502: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105506: LD_VAR 0 1
105510: PPUSH
105511: CALL_OW 316
105515: PUSH
105516: LD_VAR 0 1
105520: PPUSH
105521: CALL_OW 314
105525: OR
105526: PUSH
105527: LD_VAR 0 1
105531: PPUSH
105532: CALL_OW 302
105536: NOT
105537: OR
105538: PUSH
105539: LD_VAR 0 1
105543: PPUSH
105544: CALL_OW 301
105548: OR
105549: IFFALSE 105499
// RemoveSeeing ( _x , _y , side ) ;
105551: LD_VAR 0 8
105555: PPUSH
105556: LD_VAR 0 9
105560: PPUSH
105561: LD_VAR 0 6
105565: PPUSH
105566: CALL_OW 331
// end ; end_of_file
105570: LD_VAR 0 4
105574: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105575: LD_INT 0
105577: PPUSH
105578: PPUSH
105579: PPUSH
105580: PPUSH
105581: PPUSH
105582: PPUSH
105583: PPUSH
105584: PPUSH
105585: PPUSH
105586: PPUSH
105587: PPUSH
105588: PPUSH
105589: PPUSH
105590: PPUSH
105591: PPUSH
105592: PPUSH
105593: PPUSH
105594: PPUSH
105595: PPUSH
105596: PPUSH
105597: PPUSH
105598: PPUSH
105599: PPUSH
105600: PPUSH
105601: PPUSH
105602: PPUSH
105603: PPUSH
105604: PPUSH
105605: PPUSH
105606: PPUSH
105607: PPUSH
105608: PPUSH
105609: PPUSH
105610: PPUSH
// if not list then
105611: LD_VAR 0 1
105615: NOT
105616: IFFALSE 105620
// exit ;
105618: GO 110279
// base := list [ 1 ] ;
105620: LD_ADDR_VAR 0 3
105624: PUSH
105625: LD_VAR 0 1
105629: PUSH
105630: LD_INT 1
105632: ARRAY
105633: ST_TO_ADDR
// group := list [ 2 ] ;
105634: LD_ADDR_VAR 0 4
105638: PUSH
105639: LD_VAR 0 1
105643: PUSH
105644: LD_INT 2
105646: ARRAY
105647: ST_TO_ADDR
// path := list [ 3 ] ;
105648: LD_ADDR_VAR 0 5
105652: PUSH
105653: LD_VAR 0 1
105657: PUSH
105658: LD_INT 3
105660: ARRAY
105661: ST_TO_ADDR
// flags := list [ 4 ] ;
105662: LD_ADDR_VAR 0 6
105666: PUSH
105667: LD_VAR 0 1
105671: PUSH
105672: LD_INT 4
105674: ARRAY
105675: ST_TO_ADDR
// mined := [ ] ;
105676: LD_ADDR_VAR 0 27
105680: PUSH
105681: EMPTY
105682: ST_TO_ADDR
// bombed := [ ] ;
105683: LD_ADDR_VAR 0 28
105687: PUSH
105688: EMPTY
105689: ST_TO_ADDR
// healers := [ ] ;
105690: LD_ADDR_VAR 0 31
105694: PUSH
105695: EMPTY
105696: ST_TO_ADDR
// to_heal := [ ] ;
105697: LD_ADDR_VAR 0 30
105701: PUSH
105702: EMPTY
105703: ST_TO_ADDR
// repairs := [ ] ;
105704: LD_ADDR_VAR 0 33
105708: PUSH
105709: EMPTY
105710: ST_TO_ADDR
// to_repair := [ ] ;
105711: LD_ADDR_VAR 0 32
105715: PUSH
105716: EMPTY
105717: ST_TO_ADDR
// if not group or not path then
105718: LD_VAR 0 4
105722: NOT
105723: PUSH
105724: LD_VAR 0 5
105728: NOT
105729: OR
105730: IFFALSE 105734
// exit ;
105732: GO 110279
// side := GetSide ( group [ 1 ] ) ;
105734: LD_ADDR_VAR 0 35
105738: PUSH
105739: LD_VAR 0 4
105743: PUSH
105744: LD_INT 1
105746: ARRAY
105747: PPUSH
105748: CALL_OW 255
105752: ST_TO_ADDR
// if flags then
105753: LD_VAR 0 6
105757: IFFALSE 105901
// begin f_ignore_area := flags [ 1 ] ;
105759: LD_ADDR_VAR 0 17
105763: PUSH
105764: LD_VAR 0 6
105768: PUSH
105769: LD_INT 1
105771: ARRAY
105772: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
105773: LD_ADDR_VAR 0 18
105777: PUSH
105778: LD_VAR 0 6
105782: PUSH
105783: LD_INT 2
105785: ARRAY
105786: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
105787: LD_ADDR_VAR 0 19
105791: PUSH
105792: LD_VAR 0 6
105796: PUSH
105797: LD_INT 3
105799: ARRAY
105800: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
105801: LD_ADDR_VAR 0 20
105805: PUSH
105806: LD_VAR 0 6
105810: PUSH
105811: LD_INT 4
105813: ARRAY
105814: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
105815: LD_ADDR_VAR 0 21
105819: PUSH
105820: LD_VAR 0 6
105824: PUSH
105825: LD_INT 5
105827: ARRAY
105828: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
105829: LD_ADDR_VAR 0 22
105833: PUSH
105834: LD_VAR 0 6
105838: PUSH
105839: LD_INT 6
105841: ARRAY
105842: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
105843: LD_ADDR_VAR 0 23
105847: PUSH
105848: LD_VAR 0 6
105852: PUSH
105853: LD_INT 7
105855: ARRAY
105856: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
105857: LD_ADDR_VAR 0 24
105861: PUSH
105862: LD_VAR 0 6
105866: PUSH
105867: LD_INT 8
105869: ARRAY
105870: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
105871: LD_ADDR_VAR 0 25
105875: PUSH
105876: LD_VAR 0 6
105880: PUSH
105881: LD_INT 9
105883: ARRAY
105884: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
105885: LD_ADDR_VAR 0 26
105889: PUSH
105890: LD_VAR 0 6
105894: PUSH
105895: LD_INT 10
105897: ARRAY
105898: ST_TO_ADDR
// end else
105899: GO 105981
// begin f_ignore_area := false ;
105901: LD_ADDR_VAR 0 17
105905: PUSH
105906: LD_INT 0
105908: ST_TO_ADDR
// f_capture := false ;
105909: LD_ADDR_VAR 0 18
105913: PUSH
105914: LD_INT 0
105916: ST_TO_ADDR
// f_ignore_civ := false ;
105917: LD_ADDR_VAR 0 19
105921: PUSH
105922: LD_INT 0
105924: ST_TO_ADDR
// f_murder := false ;
105925: LD_ADDR_VAR 0 20
105929: PUSH
105930: LD_INT 0
105932: ST_TO_ADDR
// f_mines := false ;
105933: LD_ADDR_VAR 0 21
105937: PUSH
105938: LD_INT 0
105940: ST_TO_ADDR
// f_repair := false ;
105941: LD_ADDR_VAR 0 22
105945: PUSH
105946: LD_INT 0
105948: ST_TO_ADDR
// f_heal := false ;
105949: LD_ADDR_VAR 0 23
105953: PUSH
105954: LD_INT 0
105956: ST_TO_ADDR
// f_spacetime := false ;
105957: LD_ADDR_VAR 0 24
105961: PUSH
105962: LD_INT 0
105964: ST_TO_ADDR
// f_attack_depot := false ;
105965: LD_ADDR_VAR 0 25
105969: PUSH
105970: LD_INT 0
105972: ST_TO_ADDR
// f_crawl := false ;
105973: LD_ADDR_VAR 0 26
105977: PUSH
105978: LD_INT 0
105980: ST_TO_ADDR
// end ; if f_heal then
105981: LD_VAR 0 23
105985: IFFALSE 106012
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105987: LD_ADDR_VAR 0 31
105991: PUSH
105992: LD_VAR 0 4
105996: PPUSH
105997: LD_INT 25
105999: PUSH
106000: LD_INT 4
106002: PUSH
106003: EMPTY
106004: LIST
106005: LIST
106006: PPUSH
106007: CALL_OW 72
106011: ST_TO_ADDR
// if f_repair then
106012: LD_VAR 0 22
106016: IFFALSE 106043
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106018: LD_ADDR_VAR 0 33
106022: PUSH
106023: LD_VAR 0 4
106027: PPUSH
106028: LD_INT 25
106030: PUSH
106031: LD_INT 3
106033: PUSH
106034: EMPTY
106035: LIST
106036: LIST
106037: PPUSH
106038: CALL_OW 72
106042: ST_TO_ADDR
// units_path := [ ] ;
106043: LD_ADDR_VAR 0 16
106047: PUSH
106048: EMPTY
106049: ST_TO_ADDR
// for i = 1 to group do
106050: LD_ADDR_VAR 0 7
106054: PUSH
106055: DOUBLE
106056: LD_INT 1
106058: DEC
106059: ST_TO_ADDR
106060: LD_VAR 0 4
106064: PUSH
106065: FOR_TO
106066: IFFALSE 106095
// units_path := Replace ( units_path , i , path ) ;
106068: LD_ADDR_VAR 0 16
106072: PUSH
106073: LD_VAR 0 16
106077: PPUSH
106078: LD_VAR 0 7
106082: PPUSH
106083: LD_VAR 0 5
106087: PPUSH
106088: CALL_OW 1
106092: ST_TO_ADDR
106093: GO 106065
106095: POP
106096: POP
// repeat for i = group downto 1 do
106097: LD_ADDR_VAR 0 7
106101: PUSH
106102: DOUBLE
106103: LD_VAR 0 4
106107: INC
106108: ST_TO_ADDR
106109: LD_INT 1
106111: PUSH
106112: FOR_DOWNTO
106113: IFFALSE 110235
// begin wait ( 5 ) ;
106115: LD_INT 5
106117: PPUSH
106118: CALL_OW 67
// tmp := [ ] ;
106122: LD_ADDR_VAR 0 14
106126: PUSH
106127: EMPTY
106128: ST_TO_ADDR
// attacking := false ;
106129: LD_ADDR_VAR 0 29
106133: PUSH
106134: LD_INT 0
106136: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106137: LD_VAR 0 4
106141: PUSH
106142: LD_VAR 0 7
106146: ARRAY
106147: PPUSH
106148: CALL_OW 301
106152: PUSH
106153: LD_VAR 0 4
106157: PUSH
106158: LD_VAR 0 7
106162: ARRAY
106163: NOT
106164: OR
106165: IFFALSE 106274
// begin if GetType ( group [ i ] ) = unit_human then
106167: LD_VAR 0 4
106171: PUSH
106172: LD_VAR 0 7
106176: ARRAY
106177: PPUSH
106178: CALL_OW 247
106182: PUSH
106183: LD_INT 1
106185: EQUAL
106186: IFFALSE 106232
// begin to_heal := to_heal diff group [ i ] ;
106188: LD_ADDR_VAR 0 30
106192: PUSH
106193: LD_VAR 0 30
106197: PUSH
106198: LD_VAR 0 4
106202: PUSH
106203: LD_VAR 0 7
106207: ARRAY
106208: DIFF
106209: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106210: LD_ADDR_VAR 0 31
106214: PUSH
106215: LD_VAR 0 31
106219: PUSH
106220: LD_VAR 0 4
106224: PUSH
106225: LD_VAR 0 7
106229: ARRAY
106230: DIFF
106231: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106232: LD_ADDR_VAR 0 4
106236: PUSH
106237: LD_VAR 0 4
106241: PPUSH
106242: LD_VAR 0 7
106246: PPUSH
106247: CALL_OW 3
106251: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106252: LD_ADDR_VAR 0 16
106256: PUSH
106257: LD_VAR 0 16
106261: PPUSH
106262: LD_VAR 0 7
106266: PPUSH
106267: CALL_OW 3
106271: ST_TO_ADDR
// continue ;
106272: GO 106112
// end ; if f_repair then
106274: LD_VAR 0 22
106278: IFFALSE 106767
// begin if GetType ( group [ i ] ) = unit_vehicle then
106280: LD_VAR 0 4
106284: PUSH
106285: LD_VAR 0 7
106289: ARRAY
106290: PPUSH
106291: CALL_OW 247
106295: PUSH
106296: LD_INT 2
106298: EQUAL
106299: IFFALSE 106489
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106301: LD_VAR 0 4
106305: PUSH
106306: LD_VAR 0 7
106310: ARRAY
106311: PPUSH
106312: CALL_OW 256
106316: PUSH
106317: LD_INT 700
106319: LESS
106320: PUSH
106321: LD_VAR 0 4
106325: PUSH
106326: LD_VAR 0 7
106330: ARRAY
106331: PUSH
106332: LD_VAR 0 32
106336: IN
106337: NOT
106338: AND
106339: IFFALSE 106363
// to_repair := to_repair union group [ i ] ;
106341: LD_ADDR_VAR 0 32
106345: PUSH
106346: LD_VAR 0 32
106350: PUSH
106351: LD_VAR 0 4
106355: PUSH
106356: LD_VAR 0 7
106360: ARRAY
106361: UNION
106362: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106363: LD_VAR 0 4
106367: PUSH
106368: LD_VAR 0 7
106372: ARRAY
106373: PPUSH
106374: CALL_OW 256
106378: PUSH
106379: LD_INT 1000
106381: EQUAL
106382: PUSH
106383: LD_VAR 0 4
106387: PUSH
106388: LD_VAR 0 7
106392: ARRAY
106393: PUSH
106394: LD_VAR 0 32
106398: IN
106399: AND
106400: IFFALSE 106424
// to_repair := to_repair diff group [ i ] ;
106402: LD_ADDR_VAR 0 32
106406: PUSH
106407: LD_VAR 0 32
106411: PUSH
106412: LD_VAR 0 4
106416: PUSH
106417: LD_VAR 0 7
106421: ARRAY
106422: DIFF
106423: ST_TO_ADDR
// if group [ i ] in to_repair then
106424: LD_VAR 0 4
106428: PUSH
106429: LD_VAR 0 7
106433: ARRAY
106434: PUSH
106435: LD_VAR 0 32
106439: IN
106440: IFFALSE 106487
// begin if not IsInArea ( group [ i ] , f_repair ) then
106442: LD_VAR 0 4
106446: PUSH
106447: LD_VAR 0 7
106451: ARRAY
106452: PPUSH
106453: LD_VAR 0 22
106457: PPUSH
106458: CALL_OW 308
106462: NOT
106463: IFFALSE 106485
// ComMoveToArea ( group [ i ] , f_repair ) ;
106465: LD_VAR 0 4
106469: PUSH
106470: LD_VAR 0 7
106474: ARRAY
106475: PPUSH
106476: LD_VAR 0 22
106480: PPUSH
106481: CALL_OW 113
// continue ;
106485: GO 106112
// end ; end else
106487: GO 106767
// if group [ i ] in repairs then
106489: LD_VAR 0 4
106493: PUSH
106494: LD_VAR 0 7
106498: ARRAY
106499: PUSH
106500: LD_VAR 0 33
106504: IN
106505: IFFALSE 106767
// begin if IsInUnit ( group [ i ] ) then
106507: LD_VAR 0 4
106511: PUSH
106512: LD_VAR 0 7
106516: ARRAY
106517: PPUSH
106518: CALL_OW 310
106522: IFFALSE 106590
// begin z := IsInUnit ( group [ i ] ) ;
106524: LD_ADDR_VAR 0 13
106528: PUSH
106529: LD_VAR 0 4
106533: PUSH
106534: LD_VAR 0 7
106538: ARRAY
106539: PPUSH
106540: CALL_OW 310
106544: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106545: LD_VAR 0 13
106549: PUSH
106550: LD_VAR 0 32
106554: IN
106555: PUSH
106556: LD_VAR 0 13
106560: PPUSH
106561: LD_VAR 0 22
106565: PPUSH
106566: CALL_OW 308
106570: AND
106571: IFFALSE 106588
// ComExitVehicle ( group [ i ] ) ;
106573: LD_VAR 0 4
106577: PUSH
106578: LD_VAR 0 7
106582: ARRAY
106583: PPUSH
106584: CALL_OW 121
// end else
106588: GO 106767
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106590: LD_ADDR_VAR 0 13
106594: PUSH
106595: LD_VAR 0 4
106599: PPUSH
106600: LD_INT 95
106602: PUSH
106603: LD_VAR 0 22
106607: PUSH
106608: EMPTY
106609: LIST
106610: LIST
106611: PUSH
106612: LD_INT 58
106614: PUSH
106615: EMPTY
106616: LIST
106617: PUSH
106618: EMPTY
106619: LIST
106620: LIST
106621: PPUSH
106622: CALL_OW 72
106626: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
106627: LD_VAR 0 4
106631: PUSH
106632: LD_VAR 0 7
106636: ARRAY
106637: PPUSH
106638: CALL_OW 314
106642: NOT
106643: IFFALSE 106765
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
106645: LD_ADDR_VAR 0 10
106649: PUSH
106650: LD_VAR 0 13
106654: PPUSH
106655: LD_VAR 0 4
106659: PUSH
106660: LD_VAR 0 7
106664: ARRAY
106665: PPUSH
106666: CALL_OW 74
106670: ST_TO_ADDR
// if not x then
106671: LD_VAR 0 10
106675: NOT
106676: IFFALSE 106680
// continue ;
106678: GO 106112
// if GetLives ( x ) < 1000 then
106680: LD_VAR 0 10
106684: PPUSH
106685: CALL_OW 256
106689: PUSH
106690: LD_INT 1000
106692: LESS
106693: IFFALSE 106717
// ComRepairVehicle ( group [ i ] , x ) else
106695: LD_VAR 0 4
106699: PUSH
106700: LD_VAR 0 7
106704: ARRAY
106705: PPUSH
106706: LD_VAR 0 10
106710: PPUSH
106711: CALL_OW 129
106715: GO 106765
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
106717: LD_VAR 0 23
106721: PUSH
106722: LD_VAR 0 4
106726: PUSH
106727: LD_VAR 0 7
106731: ARRAY
106732: PPUSH
106733: CALL_OW 256
106737: PUSH
106738: LD_INT 1000
106740: LESS
106741: AND
106742: NOT
106743: IFFALSE 106765
// ComEnterUnit ( group [ i ] , x ) ;
106745: LD_VAR 0 4
106749: PUSH
106750: LD_VAR 0 7
106754: ARRAY
106755: PPUSH
106756: LD_VAR 0 10
106760: PPUSH
106761: CALL_OW 120
// end ; continue ;
106765: GO 106112
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
106767: LD_VAR 0 23
106771: PUSH
106772: LD_VAR 0 4
106776: PUSH
106777: LD_VAR 0 7
106781: ARRAY
106782: PPUSH
106783: CALL_OW 247
106787: PUSH
106788: LD_INT 1
106790: EQUAL
106791: AND
106792: IFFALSE 107270
// begin if group [ i ] in healers then
106794: LD_VAR 0 4
106798: PUSH
106799: LD_VAR 0 7
106803: ARRAY
106804: PUSH
106805: LD_VAR 0 31
106809: IN
106810: IFFALSE 107083
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
106812: LD_VAR 0 4
106816: PUSH
106817: LD_VAR 0 7
106821: ARRAY
106822: PPUSH
106823: LD_VAR 0 23
106827: PPUSH
106828: CALL_OW 308
106832: NOT
106833: PUSH
106834: LD_VAR 0 4
106838: PUSH
106839: LD_VAR 0 7
106843: ARRAY
106844: PPUSH
106845: CALL_OW 314
106849: NOT
106850: AND
106851: IFFALSE 106875
// ComMoveToArea ( group [ i ] , f_heal ) else
106853: LD_VAR 0 4
106857: PUSH
106858: LD_VAR 0 7
106862: ARRAY
106863: PPUSH
106864: LD_VAR 0 23
106868: PPUSH
106869: CALL_OW 113
106873: GO 107081
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
106875: LD_VAR 0 4
106879: PUSH
106880: LD_VAR 0 7
106884: ARRAY
106885: PPUSH
106886: CALL 48397 0 1
106890: PPUSH
106891: CALL_OW 256
106895: PUSH
106896: LD_INT 1000
106898: EQUAL
106899: IFFALSE 106918
// ComStop ( group [ i ] ) else
106901: LD_VAR 0 4
106905: PUSH
106906: LD_VAR 0 7
106910: ARRAY
106911: PPUSH
106912: CALL_OW 141
106916: GO 107081
// if not HasTask ( group [ i ] ) and to_heal then
106918: LD_VAR 0 4
106922: PUSH
106923: LD_VAR 0 7
106927: ARRAY
106928: PPUSH
106929: CALL_OW 314
106933: NOT
106934: PUSH
106935: LD_VAR 0 30
106939: AND
106940: IFFALSE 107081
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106942: LD_ADDR_VAR 0 13
106946: PUSH
106947: LD_VAR 0 30
106951: PPUSH
106952: LD_INT 3
106954: PUSH
106955: LD_INT 54
106957: PUSH
106958: EMPTY
106959: LIST
106960: PUSH
106961: EMPTY
106962: LIST
106963: LIST
106964: PPUSH
106965: CALL_OW 72
106969: PPUSH
106970: LD_VAR 0 4
106974: PUSH
106975: LD_VAR 0 7
106979: ARRAY
106980: PPUSH
106981: CALL_OW 74
106985: ST_TO_ADDR
// if z then
106986: LD_VAR 0 13
106990: IFFALSE 107081
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106992: LD_INT 91
106994: PUSH
106995: LD_VAR 0 13
106999: PUSH
107000: LD_INT 10
107002: PUSH
107003: EMPTY
107004: LIST
107005: LIST
107006: LIST
107007: PUSH
107008: LD_INT 81
107010: PUSH
107011: LD_VAR 0 13
107015: PPUSH
107016: CALL_OW 255
107020: PUSH
107021: EMPTY
107022: LIST
107023: LIST
107024: PUSH
107025: EMPTY
107026: LIST
107027: LIST
107028: PPUSH
107029: CALL_OW 69
107033: PUSH
107034: LD_INT 0
107036: EQUAL
107037: IFFALSE 107061
// ComHeal ( group [ i ] , z ) else
107039: LD_VAR 0 4
107043: PUSH
107044: LD_VAR 0 7
107048: ARRAY
107049: PPUSH
107050: LD_VAR 0 13
107054: PPUSH
107055: CALL_OW 128
107059: GO 107081
// ComMoveToArea ( group [ i ] , f_heal ) ;
107061: LD_VAR 0 4
107065: PUSH
107066: LD_VAR 0 7
107070: ARRAY
107071: PPUSH
107072: LD_VAR 0 23
107076: PPUSH
107077: CALL_OW 113
// end ; continue ;
107081: GO 106112
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107083: LD_VAR 0 4
107087: PUSH
107088: LD_VAR 0 7
107092: ARRAY
107093: PPUSH
107094: CALL_OW 256
107098: PUSH
107099: LD_INT 700
107101: LESS
107102: PUSH
107103: LD_VAR 0 4
107107: PUSH
107108: LD_VAR 0 7
107112: ARRAY
107113: PUSH
107114: LD_VAR 0 30
107118: IN
107119: NOT
107120: AND
107121: IFFALSE 107145
// to_heal := to_heal union group [ i ] ;
107123: LD_ADDR_VAR 0 30
107127: PUSH
107128: LD_VAR 0 30
107132: PUSH
107133: LD_VAR 0 4
107137: PUSH
107138: LD_VAR 0 7
107142: ARRAY
107143: UNION
107144: ST_TO_ADDR
// if group [ i ] in to_heal then
107145: LD_VAR 0 4
107149: PUSH
107150: LD_VAR 0 7
107154: ARRAY
107155: PUSH
107156: LD_VAR 0 30
107160: IN
107161: IFFALSE 107270
// begin if GetLives ( group [ i ] ) = 1000 then
107163: LD_VAR 0 4
107167: PUSH
107168: LD_VAR 0 7
107172: ARRAY
107173: PPUSH
107174: CALL_OW 256
107178: PUSH
107179: LD_INT 1000
107181: EQUAL
107182: IFFALSE 107208
// to_heal := to_heal diff group [ i ] else
107184: LD_ADDR_VAR 0 30
107188: PUSH
107189: LD_VAR 0 30
107193: PUSH
107194: LD_VAR 0 4
107198: PUSH
107199: LD_VAR 0 7
107203: ARRAY
107204: DIFF
107205: ST_TO_ADDR
107206: GO 107270
// begin if not IsInArea ( group [ i ] , to_heal ) then
107208: LD_VAR 0 4
107212: PUSH
107213: LD_VAR 0 7
107217: ARRAY
107218: PPUSH
107219: LD_VAR 0 30
107223: PPUSH
107224: CALL_OW 308
107228: NOT
107229: IFFALSE 107253
// ComMoveToArea ( group [ i ] , f_heal ) else
107231: LD_VAR 0 4
107235: PUSH
107236: LD_VAR 0 7
107240: ARRAY
107241: PPUSH
107242: LD_VAR 0 23
107246: PPUSH
107247: CALL_OW 113
107251: GO 107268
// ComHold ( group [ i ] ) ;
107253: LD_VAR 0 4
107257: PUSH
107258: LD_VAR 0 7
107262: ARRAY
107263: PPUSH
107264: CALL_OW 140
// continue ;
107268: GO 106112
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107270: LD_VAR 0 4
107274: PUSH
107275: LD_VAR 0 7
107279: ARRAY
107280: PPUSH
107281: LD_INT 10
107283: PPUSH
107284: CALL 46250 0 2
107288: NOT
107289: PUSH
107290: LD_VAR 0 16
107294: PUSH
107295: LD_VAR 0 7
107299: ARRAY
107300: PUSH
107301: EMPTY
107302: EQUAL
107303: NOT
107304: AND
107305: IFFALSE 107571
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107307: LD_VAR 0 4
107311: PUSH
107312: LD_VAR 0 7
107316: ARRAY
107317: PPUSH
107318: CALL_OW 262
107322: PUSH
107323: LD_INT 1
107325: PUSH
107326: LD_INT 2
107328: PUSH
107329: EMPTY
107330: LIST
107331: LIST
107332: IN
107333: IFFALSE 107374
// if GetFuel ( group [ i ] ) < 10 then
107335: LD_VAR 0 4
107339: PUSH
107340: LD_VAR 0 7
107344: ARRAY
107345: PPUSH
107346: CALL_OW 261
107350: PUSH
107351: LD_INT 10
107353: LESS
107354: IFFALSE 107374
// SetFuel ( group [ i ] , 12 ) ;
107356: LD_VAR 0 4
107360: PUSH
107361: LD_VAR 0 7
107365: ARRAY
107366: PPUSH
107367: LD_INT 12
107369: PPUSH
107370: CALL_OW 240
// if units_path [ i ] then
107374: LD_VAR 0 16
107378: PUSH
107379: LD_VAR 0 7
107383: ARRAY
107384: IFFALSE 107569
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107386: LD_VAR 0 4
107390: PUSH
107391: LD_VAR 0 7
107395: ARRAY
107396: PPUSH
107397: LD_VAR 0 16
107401: PUSH
107402: LD_VAR 0 7
107406: ARRAY
107407: PUSH
107408: LD_INT 1
107410: ARRAY
107411: PUSH
107412: LD_INT 1
107414: ARRAY
107415: PPUSH
107416: LD_VAR 0 16
107420: PUSH
107421: LD_VAR 0 7
107425: ARRAY
107426: PUSH
107427: LD_INT 1
107429: ARRAY
107430: PUSH
107431: LD_INT 2
107433: ARRAY
107434: PPUSH
107435: CALL_OW 297
107439: PUSH
107440: LD_INT 6
107442: GREATER
107443: IFFALSE 107518
// begin if not HasTask ( group [ i ] ) then
107445: LD_VAR 0 4
107449: PUSH
107450: LD_VAR 0 7
107454: ARRAY
107455: PPUSH
107456: CALL_OW 314
107460: NOT
107461: IFFALSE 107516
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107463: LD_VAR 0 4
107467: PUSH
107468: LD_VAR 0 7
107472: ARRAY
107473: PPUSH
107474: LD_VAR 0 16
107478: PUSH
107479: LD_VAR 0 7
107483: ARRAY
107484: PUSH
107485: LD_INT 1
107487: ARRAY
107488: PUSH
107489: LD_INT 1
107491: ARRAY
107492: PPUSH
107493: LD_VAR 0 16
107497: PUSH
107498: LD_VAR 0 7
107502: ARRAY
107503: PUSH
107504: LD_INT 1
107506: ARRAY
107507: PUSH
107508: LD_INT 2
107510: ARRAY
107511: PPUSH
107512: CALL_OW 114
// end else
107516: GO 107569
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107518: LD_ADDR_VAR 0 15
107522: PUSH
107523: LD_VAR 0 16
107527: PUSH
107528: LD_VAR 0 7
107532: ARRAY
107533: PPUSH
107534: LD_INT 1
107536: PPUSH
107537: CALL_OW 3
107541: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107542: LD_ADDR_VAR 0 16
107546: PUSH
107547: LD_VAR 0 16
107551: PPUSH
107552: LD_VAR 0 7
107556: PPUSH
107557: LD_VAR 0 15
107561: PPUSH
107562: CALL_OW 1
107566: ST_TO_ADDR
// continue ;
107567: GO 106112
// end ; end ; end else
107569: GO 110233
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107571: LD_ADDR_VAR 0 14
107575: PUSH
107576: LD_INT 81
107578: PUSH
107579: LD_VAR 0 4
107583: PUSH
107584: LD_VAR 0 7
107588: ARRAY
107589: PPUSH
107590: CALL_OW 255
107594: PUSH
107595: EMPTY
107596: LIST
107597: LIST
107598: PPUSH
107599: CALL_OW 69
107603: ST_TO_ADDR
// if not tmp then
107604: LD_VAR 0 14
107608: NOT
107609: IFFALSE 107613
// continue ;
107611: GO 106112
// if f_ignore_area then
107613: LD_VAR 0 17
107617: IFFALSE 107705
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107619: LD_ADDR_VAR 0 15
107623: PUSH
107624: LD_VAR 0 14
107628: PPUSH
107629: LD_INT 3
107631: PUSH
107632: LD_INT 92
107634: PUSH
107635: LD_VAR 0 17
107639: PUSH
107640: LD_INT 1
107642: ARRAY
107643: PUSH
107644: LD_VAR 0 17
107648: PUSH
107649: LD_INT 2
107651: ARRAY
107652: PUSH
107653: LD_VAR 0 17
107657: PUSH
107658: LD_INT 3
107660: ARRAY
107661: PUSH
107662: EMPTY
107663: LIST
107664: LIST
107665: LIST
107666: LIST
107667: PUSH
107668: EMPTY
107669: LIST
107670: LIST
107671: PPUSH
107672: CALL_OW 72
107676: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107677: LD_VAR 0 14
107681: PUSH
107682: LD_VAR 0 15
107686: DIFF
107687: IFFALSE 107705
// tmp := tmp diff tmp2 ;
107689: LD_ADDR_VAR 0 14
107693: PUSH
107694: LD_VAR 0 14
107698: PUSH
107699: LD_VAR 0 15
107703: DIFF
107704: ST_TO_ADDR
// end ; if not f_murder then
107705: LD_VAR 0 20
107709: NOT
107710: IFFALSE 107768
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
107712: LD_ADDR_VAR 0 15
107716: PUSH
107717: LD_VAR 0 14
107721: PPUSH
107722: LD_INT 3
107724: PUSH
107725: LD_INT 50
107727: PUSH
107728: EMPTY
107729: LIST
107730: PUSH
107731: EMPTY
107732: LIST
107733: LIST
107734: PPUSH
107735: CALL_OW 72
107739: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
107740: LD_VAR 0 14
107744: PUSH
107745: LD_VAR 0 15
107749: DIFF
107750: IFFALSE 107768
// tmp := tmp diff tmp2 ;
107752: LD_ADDR_VAR 0 14
107756: PUSH
107757: LD_VAR 0 14
107761: PUSH
107762: LD_VAR 0 15
107766: DIFF
107767: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
107768: LD_ADDR_VAR 0 14
107772: PUSH
107773: LD_VAR 0 4
107777: PUSH
107778: LD_VAR 0 7
107782: ARRAY
107783: PPUSH
107784: LD_VAR 0 14
107788: PPUSH
107789: LD_INT 1
107791: PPUSH
107792: LD_INT 1
107794: PPUSH
107795: CALL 19185 0 4
107799: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
107800: LD_VAR 0 4
107804: PUSH
107805: LD_VAR 0 7
107809: ARRAY
107810: PPUSH
107811: CALL_OW 257
107815: PUSH
107816: LD_INT 1
107818: EQUAL
107819: IFFALSE 108267
// begin if WantPlant ( group [ i ] ) then
107821: LD_VAR 0 4
107825: PUSH
107826: LD_VAR 0 7
107830: ARRAY
107831: PPUSH
107832: CALL 18686 0 1
107836: IFFALSE 107840
// continue ;
107838: GO 106112
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
107840: LD_VAR 0 18
107844: PUSH
107845: LD_VAR 0 4
107849: PUSH
107850: LD_VAR 0 7
107854: ARRAY
107855: PPUSH
107856: CALL_OW 310
107860: NOT
107861: AND
107862: PUSH
107863: LD_VAR 0 14
107867: PUSH
107868: LD_INT 1
107870: ARRAY
107871: PUSH
107872: LD_VAR 0 14
107876: PPUSH
107877: LD_INT 21
107879: PUSH
107880: LD_INT 2
107882: PUSH
107883: EMPTY
107884: LIST
107885: LIST
107886: PUSH
107887: LD_INT 58
107889: PUSH
107890: EMPTY
107891: LIST
107892: PUSH
107893: EMPTY
107894: LIST
107895: LIST
107896: PPUSH
107897: CALL_OW 72
107901: IN
107902: AND
107903: IFFALSE 107939
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
107905: LD_VAR 0 4
107909: PUSH
107910: LD_VAR 0 7
107914: ARRAY
107915: PPUSH
107916: LD_VAR 0 14
107920: PUSH
107921: LD_INT 1
107923: ARRAY
107924: PPUSH
107925: CALL_OW 120
// attacking := true ;
107929: LD_ADDR_VAR 0 29
107933: PUSH
107934: LD_INT 1
107936: ST_TO_ADDR
// continue ;
107937: GO 106112
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107939: LD_VAR 0 26
107943: PUSH
107944: LD_VAR 0 4
107948: PUSH
107949: LD_VAR 0 7
107953: ARRAY
107954: PPUSH
107955: CALL_OW 257
107959: PUSH
107960: LD_INT 1
107962: EQUAL
107963: AND
107964: PUSH
107965: LD_VAR 0 4
107969: PUSH
107970: LD_VAR 0 7
107974: ARRAY
107975: PPUSH
107976: CALL_OW 256
107980: PUSH
107981: LD_INT 800
107983: LESS
107984: AND
107985: PUSH
107986: LD_VAR 0 4
107990: PUSH
107991: LD_VAR 0 7
107995: ARRAY
107996: PPUSH
107997: CALL_OW 318
108001: NOT
108002: AND
108003: IFFALSE 108020
// ComCrawl ( group [ i ] ) ;
108005: LD_VAR 0 4
108009: PUSH
108010: LD_VAR 0 7
108014: ARRAY
108015: PPUSH
108016: CALL_OW 137
// if f_mines then
108020: LD_VAR 0 21
108024: IFFALSE 108267
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108026: LD_VAR 0 14
108030: PUSH
108031: LD_INT 1
108033: ARRAY
108034: PPUSH
108035: CALL_OW 247
108039: PUSH
108040: LD_INT 3
108042: EQUAL
108043: PUSH
108044: LD_VAR 0 14
108048: PUSH
108049: LD_INT 1
108051: ARRAY
108052: PUSH
108053: LD_VAR 0 27
108057: IN
108058: NOT
108059: AND
108060: IFFALSE 108267
// begin x := GetX ( tmp [ 1 ] ) ;
108062: LD_ADDR_VAR 0 10
108066: PUSH
108067: LD_VAR 0 14
108071: PUSH
108072: LD_INT 1
108074: ARRAY
108075: PPUSH
108076: CALL_OW 250
108080: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108081: LD_ADDR_VAR 0 11
108085: PUSH
108086: LD_VAR 0 14
108090: PUSH
108091: LD_INT 1
108093: ARRAY
108094: PPUSH
108095: CALL_OW 251
108099: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108100: LD_ADDR_VAR 0 12
108104: PUSH
108105: LD_VAR 0 4
108109: PUSH
108110: LD_VAR 0 7
108114: ARRAY
108115: PPUSH
108116: CALL 46335 0 1
108120: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108121: LD_VAR 0 4
108125: PUSH
108126: LD_VAR 0 7
108130: ARRAY
108131: PPUSH
108132: LD_VAR 0 10
108136: PPUSH
108137: LD_VAR 0 11
108141: PPUSH
108142: LD_VAR 0 14
108146: PUSH
108147: LD_INT 1
108149: ARRAY
108150: PPUSH
108151: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108155: LD_VAR 0 4
108159: PUSH
108160: LD_VAR 0 7
108164: ARRAY
108165: PPUSH
108166: LD_VAR 0 10
108170: PPUSH
108171: LD_VAR 0 12
108175: PPUSH
108176: LD_INT 7
108178: PPUSH
108179: CALL_OW 272
108183: PPUSH
108184: LD_VAR 0 11
108188: PPUSH
108189: LD_VAR 0 12
108193: PPUSH
108194: LD_INT 7
108196: PPUSH
108197: CALL_OW 273
108201: PPUSH
108202: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108206: LD_VAR 0 4
108210: PUSH
108211: LD_VAR 0 7
108215: ARRAY
108216: PPUSH
108217: LD_INT 71
108219: PPUSH
108220: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108224: LD_ADDR_VAR 0 27
108228: PUSH
108229: LD_VAR 0 27
108233: PPUSH
108234: LD_VAR 0 27
108238: PUSH
108239: LD_INT 1
108241: PLUS
108242: PPUSH
108243: LD_VAR 0 14
108247: PUSH
108248: LD_INT 1
108250: ARRAY
108251: PPUSH
108252: CALL_OW 1
108256: ST_TO_ADDR
// attacking := true ;
108257: LD_ADDR_VAR 0 29
108261: PUSH
108262: LD_INT 1
108264: ST_TO_ADDR
// continue ;
108265: GO 106112
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108267: LD_VAR 0 4
108271: PUSH
108272: LD_VAR 0 7
108276: ARRAY
108277: PPUSH
108278: CALL_OW 257
108282: PUSH
108283: LD_INT 17
108285: EQUAL
108286: PUSH
108287: LD_VAR 0 4
108291: PUSH
108292: LD_VAR 0 7
108296: ARRAY
108297: PPUSH
108298: CALL_OW 110
108302: PUSH
108303: LD_INT 71
108305: EQUAL
108306: NOT
108307: AND
108308: IFFALSE 108454
// begin attacking := false ;
108310: LD_ADDR_VAR 0 29
108314: PUSH
108315: LD_INT 0
108317: ST_TO_ADDR
// k := 5 ;
108318: LD_ADDR_VAR 0 9
108322: PUSH
108323: LD_INT 5
108325: ST_TO_ADDR
// if tmp < k then
108326: LD_VAR 0 14
108330: PUSH
108331: LD_VAR 0 9
108335: LESS
108336: IFFALSE 108348
// k := tmp ;
108338: LD_ADDR_VAR 0 9
108342: PUSH
108343: LD_VAR 0 14
108347: ST_TO_ADDR
// for j = 1 to k do
108348: LD_ADDR_VAR 0 8
108352: PUSH
108353: DOUBLE
108354: LD_INT 1
108356: DEC
108357: ST_TO_ADDR
108358: LD_VAR 0 9
108362: PUSH
108363: FOR_TO
108364: IFFALSE 108452
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108366: LD_VAR 0 14
108370: PUSH
108371: LD_VAR 0 8
108375: ARRAY
108376: PUSH
108377: LD_VAR 0 14
108381: PPUSH
108382: LD_INT 58
108384: PUSH
108385: EMPTY
108386: LIST
108387: PPUSH
108388: CALL_OW 72
108392: IN
108393: NOT
108394: IFFALSE 108450
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108396: LD_VAR 0 4
108400: PUSH
108401: LD_VAR 0 7
108405: ARRAY
108406: PPUSH
108407: LD_VAR 0 14
108411: PUSH
108412: LD_VAR 0 8
108416: ARRAY
108417: PPUSH
108418: CALL_OW 115
// attacking := true ;
108422: LD_ADDR_VAR 0 29
108426: PUSH
108427: LD_INT 1
108429: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108430: LD_VAR 0 4
108434: PUSH
108435: LD_VAR 0 7
108439: ARRAY
108440: PPUSH
108441: LD_INT 71
108443: PPUSH
108444: CALL_OW 109
// continue ;
108448: GO 108363
// end ; end ;
108450: GO 108363
108452: POP
108453: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108454: LD_VAR 0 4
108458: PUSH
108459: LD_VAR 0 7
108463: ARRAY
108464: PPUSH
108465: CALL_OW 257
108469: PUSH
108470: LD_INT 8
108472: EQUAL
108473: PUSH
108474: LD_VAR 0 4
108478: PUSH
108479: LD_VAR 0 7
108483: ARRAY
108484: PPUSH
108485: CALL_OW 264
108489: PUSH
108490: LD_INT 28
108492: PUSH
108493: LD_INT 45
108495: PUSH
108496: LD_INT 7
108498: PUSH
108499: LD_INT 47
108501: PUSH
108502: EMPTY
108503: LIST
108504: LIST
108505: LIST
108506: LIST
108507: IN
108508: OR
108509: IFFALSE 108765
// begin attacking := false ;
108511: LD_ADDR_VAR 0 29
108515: PUSH
108516: LD_INT 0
108518: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108519: LD_VAR 0 14
108523: PUSH
108524: LD_INT 1
108526: ARRAY
108527: PPUSH
108528: CALL_OW 266
108532: PUSH
108533: LD_INT 32
108535: PUSH
108536: LD_INT 31
108538: PUSH
108539: LD_INT 33
108541: PUSH
108542: LD_INT 4
108544: PUSH
108545: LD_INT 5
108547: PUSH
108548: EMPTY
108549: LIST
108550: LIST
108551: LIST
108552: LIST
108553: LIST
108554: IN
108555: IFFALSE 108741
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108557: LD_ADDR_VAR 0 9
108561: PUSH
108562: LD_VAR 0 14
108566: PUSH
108567: LD_INT 1
108569: ARRAY
108570: PPUSH
108571: CALL_OW 266
108575: PPUSH
108576: LD_VAR 0 14
108580: PUSH
108581: LD_INT 1
108583: ARRAY
108584: PPUSH
108585: CALL_OW 250
108589: PPUSH
108590: LD_VAR 0 14
108594: PUSH
108595: LD_INT 1
108597: ARRAY
108598: PPUSH
108599: CALL_OW 251
108603: PPUSH
108604: LD_VAR 0 14
108608: PUSH
108609: LD_INT 1
108611: ARRAY
108612: PPUSH
108613: CALL_OW 254
108617: PPUSH
108618: LD_VAR 0 14
108622: PUSH
108623: LD_INT 1
108625: ARRAY
108626: PPUSH
108627: CALL_OW 248
108631: PPUSH
108632: LD_INT 0
108634: PPUSH
108635: CALL 27705 0 6
108639: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
108640: LD_ADDR_VAR 0 8
108644: PUSH
108645: LD_VAR 0 4
108649: PUSH
108650: LD_VAR 0 7
108654: ARRAY
108655: PPUSH
108656: LD_VAR 0 9
108660: PPUSH
108661: CALL 46375 0 2
108665: ST_TO_ADDR
// if j then
108666: LD_VAR 0 8
108670: IFFALSE 108739
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
108672: LD_VAR 0 8
108676: PUSH
108677: LD_INT 1
108679: ARRAY
108680: PPUSH
108681: LD_VAR 0 8
108685: PUSH
108686: LD_INT 2
108688: ARRAY
108689: PPUSH
108690: CALL_OW 488
108694: IFFALSE 108739
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
108696: LD_VAR 0 4
108700: PUSH
108701: LD_VAR 0 7
108705: ARRAY
108706: PPUSH
108707: LD_VAR 0 8
108711: PUSH
108712: LD_INT 1
108714: ARRAY
108715: PPUSH
108716: LD_VAR 0 8
108720: PUSH
108721: LD_INT 2
108723: ARRAY
108724: PPUSH
108725: CALL_OW 116
// attacking := true ;
108729: LD_ADDR_VAR 0 29
108733: PUSH
108734: LD_INT 1
108736: ST_TO_ADDR
// continue ;
108737: GO 106112
// end ; end else
108739: GO 108765
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108741: LD_VAR 0 4
108745: PUSH
108746: LD_VAR 0 7
108750: ARRAY
108751: PPUSH
108752: LD_VAR 0 14
108756: PUSH
108757: LD_INT 1
108759: ARRAY
108760: PPUSH
108761: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
108765: LD_VAR 0 4
108769: PUSH
108770: LD_VAR 0 7
108774: ARRAY
108775: PPUSH
108776: CALL_OW 265
108780: PUSH
108781: LD_INT 11
108783: EQUAL
108784: IFFALSE 109062
// begin k := 10 ;
108786: LD_ADDR_VAR 0 9
108790: PUSH
108791: LD_INT 10
108793: ST_TO_ADDR
// x := 0 ;
108794: LD_ADDR_VAR 0 10
108798: PUSH
108799: LD_INT 0
108801: ST_TO_ADDR
// if tmp < k then
108802: LD_VAR 0 14
108806: PUSH
108807: LD_VAR 0 9
108811: LESS
108812: IFFALSE 108824
// k := tmp ;
108814: LD_ADDR_VAR 0 9
108818: PUSH
108819: LD_VAR 0 14
108823: ST_TO_ADDR
// for j = k downto 1 do
108824: LD_ADDR_VAR 0 8
108828: PUSH
108829: DOUBLE
108830: LD_VAR 0 9
108834: INC
108835: ST_TO_ADDR
108836: LD_INT 1
108838: PUSH
108839: FOR_DOWNTO
108840: IFFALSE 108915
// begin if GetType ( tmp [ j ] ) = unit_human then
108842: LD_VAR 0 14
108846: PUSH
108847: LD_VAR 0 8
108851: ARRAY
108852: PPUSH
108853: CALL_OW 247
108857: PUSH
108858: LD_INT 1
108860: EQUAL
108861: IFFALSE 108913
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
108863: LD_VAR 0 4
108867: PUSH
108868: LD_VAR 0 7
108872: ARRAY
108873: PPUSH
108874: LD_VAR 0 14
108878: PUSH
108879: LD_VAR 0 8
108883: ARRAY
108884: PPUSH
108885: CALL 46646 0 2
// x := tmp [ j ] ;
108889: LD_ADDR_VAR 0 10
108893: PUSH
108894: LD_VAR 0 14
108898: PUSH
108899: LD_VAR 0 8
108903: ARRAY
108904: ST_TO_ADDR
// attacking := true ;
108905: LD_ADDR_VAR 0 29
108909: PUSH
108910: LD_INT 1
108912: ST_TO_ADDR
// end ; end ;
108913: GO 108839
108915: POP
108916: POP
// if not x then
108917: LD_VAR 0 10
108921: NOT
108922: IFFALSE 109062
// begin attacking := true ;
108924: LD_ADDR_VAR 0 29
108928: PUSH
108929: LD_INT 1
108931: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108932: LD_VAR 0 4
108936: PUSH
108937: LD_VAR 0 7
108941: ARRAY
108942: PPUSH
108943: CALL_OW 250
108947: PPUSH
108948: LD_VAR 0 4
108952: PUSH
108953: LD_VAR 0 7
108957: ARRAY
108958: PPUSH
108959: CALL_OW 251
108963: PPUSH
108964: CALL_OW 546
108968: PUSH
108969: LD_INT 2
108971: ARRAY
108972: PUSH
108973: LD_VAR 0 14
108977: PUSH
108978: LD_INT 1
108980: ARRAY
108981: PPUSH
108982: CALL_OW 250
108986: PPUSH
108987: LD_VAR 0 14
108991: PUSH
108992: LD_INT 1
108994: ARRAY
108995: PPUSH
108996: CALL_OW 251
109000: PPUSH
109001: CALL_OW 546
109005: PUSH
109006: LD_INT 2
109008: ARRAY
109009: EQUAL
109010: IFFALSE 109038
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109012: LD_VAR 0 4
109016: PUSH
109017: LD_VAR 0 7
109021: ARRAY
109022: PPUSH
109023: LD_VAR 0 14
109027: PUSH
109028: LD_INT 1
109030: ARRAY
109031: PPUSH
109032: CALL 46646 0 2
109036: GO 109062
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109038: LD_VAR 0 4
109042: PUSH
109043: LD_VAR 0 7
109047: ARRAY
109048: PPUSH
109049: LD_VAR 0 14
109053: PUSH
109054: LD_INT 1
109056: ARRAY
109057: PPUSH
109058: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109062: LD_VAR 0 4
109066: PUSH
109067: LD_VAR 0 7
109071: ARRAY
109072: PPUSH
109073: CALL_OW 264
109077: PUSH
109078: LD_INT 29
109080: EQUAL
109081: IFFALSE 109447
// begin if WantsToAttack ( group [ i ] ) in bombed then
109083: LD_VAR 0 4
109087: PUSH
109088: LD_VAR 0 7
109092: ARRAY
109093: PPUSH
109094: CALL_OW 319
109098: PUSH
109099: LD_VAR 0 28
109103: IN
109104: IFFALSE 109108
// continue ;
109106: GO 106112
// k := 8 ;
109108: LD_ADDR_VAR 0 9
109112: PUSH
109113: LD_INT 8
109115: ST_TO_ADDR
// x := 0 ;
109116: LD_ADDR_VAR 0 10
109120: PUSH
109121: LD_INT 0
109123: ST_TO_ADDR
// if tmp < k then
109124: LD_VAR 0 14
109128: PUSH
109129: LD_VAR 0 9
109133: LESS
109134: IFFALSE 109146
// k := tmp ;
109136: LD_ADDR_VAR 0 9
109140: PUSH
109141: LD_VAR 0 14
109145: ST_TO_ADDR
// for j = 1 to k do
109146: LD_ADDR_VAR 0 8
109150: PUSH
109151: DOUBLE
109152: LD_INT 1
109154: DEC
109155: ST_TO_ADDR
109156: LD_VAR 0 9
109160: PUSH
109161: FOR_TO
109162: IFFALSE 109294
// begin if GetType ( tmp [ j ] ) = unit_building then
109164: LD_VAR 0 14
109168: PUSH
109169: LD_VAR 0 8
109173: ARRAY
109174: PPUSH
109175: CALL_OW 247
109179: PUSH
109180: LD_INT 3
109182: EQUAL
109183: IFFALSE 109292
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109185: LD_VAR 0 14
109189: PUSH
109190: LD_VAR 0 8
109194: ARRAY
109195: PUSH
109196: LD_VAR 0 28
109200: IN
109201: NOT
109202: PUSH
109203: LD_VAR 0 14
109207: PUSH
109208: LD_VAR 0 8
109212: ARRAY
109213: PPUSH
109214: CALL_OW 313
109218: AND
109219: IFFALSE 109292
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109221: LD_VAR 0 4
109225: PUSH
109226: LD_VAR 0 7
109230: ARRAY
109231: PPUSH
109232: LD_VAR 0 14
109236: PUSH
109237: LD_VAR 0 8
109241: ARRAY
109242: PPUSH
109243: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109247: LD_ADDR_VAR 0 28
109251: PUSH
109252: LD_VAR 0 28
109256: PPUSH
109257: LD_VAR 0 28
109261: PUSH
109262: LD_INT 1
109264: PLUS
109265: PPUSH
109266: LD_VAR 0 14
109270: PUSH
109271: LD_VAR 0 8
109275: ARRAY
109276: PPUSH
109277: CALL_OW 1
109281: ST_TO_ADDR
// attacking := true ;
109282: LD_ADDR_VAR 0 29
109286: PUSH
109287: LD_INT 1
109289: ST_TO_ADDR
// break ;
109290: GO 109294
// end ; end ;
109292: GO 109161
109294: POP
109295: POP
// if not attacking and f_attack_depot then
109296: LD_VAR 0 29
109300: NOT
109301: PUSH
109302: LD_VAR 0 25
109306: AND
109307: IFFALSE 109402
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109309: LD_ADDR_VAR 0 13
109313: PUSH
109314: LD_VAR 0 14
109318: PPUSH
109319: LD_INT 2
109321: PUSH
109322: LD_INT 30
109324: PUSH
109325: LD_INT 0
109327: PUSH
109328: EMPTY
109329: LIST
109330: LIST
109331: PUSH
109332: LD_INT 30
109334: PUSH
109335: LD_INT 1
109337: PUSH
109338: EMPTY
109339: LIST
109340: LIST
109341: PUSH
109342: EMPTY
109343: LIST
109344: LIST
109345: LIST
109346: PPUSH
109347: CALL_OW 72
109351: ST_TO_ADDR
// if z then
109352: LD_VAR 0 13
109356: IFFALSE 109402
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109358: LD_VAR 0 4
109362: PUSH
109363: LD_VAR 0 7
109367: ARRAY
109368: PPUSH
109369: LD_VAR 0 13
109373: PPUSH
109374: LD_VAR 0 4
109378: PUSH
109379: LD_VAR 0 7
109383: ARRAY
109384: PPUSH
109385: CALL_OW 74
109389: PPUSH
109390: CALL_OW 115
// attacking := true ;
109394: LD_ADDR_VAR 0 29
109398: PUSH
109399: LD_INT 1
109401: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109402: LD_VAR 0 4
109406: PUSH
109407: LD_VAR 0 7
109411: ARRAY
109412: PPUSH
109413: CALL_OW 256
109417: PUSH
109418: LD_INT 500
109420: LESS
109421: IFFALSE 109447
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109423: LD_VAR 0 4
109427: PUSH
109428: LD_VAR 0 7
109432: ARRAY
109433: PPUSH
109434: LD_VAR 0 14
109438: PUSH
109439: LD_INT 1
109441: ARRAY
109442: PPUSH
109443: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109447: LD_VAR 0 4
109451: PUSH
109452: LD_VAR 0 7
109456: ARRAY
109457: PPUSH
109458: CALL_OW 264
109462: PUSH
109463: LD_INT 49
109465: EQUAL
109466: IFFALSE 109587
// begin if not HasTask ( group [ i ] ) then
109468: LD_VAR 0 4
109472: PUSH
109473: LD_VAR 0 7
109477: ARRAY
109478: PPUSH
109479: CALL_OW 314
109483: NOT
109484: IFFALSE 109587
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109486: LD_ADDR_VAR 0 9
109490: PUSH
109491: LD_INT 81
109493: PUSH
109494: LD_VAR 0 4
109498: PUSH
109499: LD_VAR 0 7
109503: ARRAY
109504: PPUSH
109505: CALL_OW 255
109509: PUSH
109510: EMPTY
109511: LIST
109512: LIST
109513: PPUSH
109514: CALL_OW 69
109518: PPUSH
109519: LD_VAR 0 4
109523: PUSH
109524: LD_VAR 0 7
109528: ARRAY
109529: PPUSH
109530: CALL_OW 74
109534: ST_TO_ADDR
// if k then
109535: LD_VAR 0 9
109539: IFFALSE 109587
// if GetDistUnits ( group [ i ] , k ) > 10 then
109541: LD_VAR 0 4
109545: PUSH
109546: LD_VAR 0 7
109550: ARRAY
109551: PPUSH
109552: LD_VAR 0 9
109556: PPUSH
109557: CALL_OW 296
109561: PUSH
109562: LD_INT 10
109564: GREATER
109565: IFFALSE 109587
// ComMoveUnit ( group [ i ] , k ) ;
109567: LD_VAR 0 4
109571: PUSH
109572: LD_VAR 0 7
109576: ARRAY
109577: PPUSH
109578: LD_VAR 0 9
109582: PPUSH
109583: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109587: LD_VAR 0 4
109591: PUSH
109592: LD_VAR 0 7
109596: ARRAY
109597: PPUSH
109598: CALL_OW 256
109602: PUSH
109603: LD_INT 250
109605: LESS
109606: PUSH
109607: LD_VAR 0 4
109611: PUSH
109612: LD_VAR 0 7
109616: ARRAY
109617: PUSH
109618: LD_INT 21
109620: PUSH
109621: LD_INT 2
109623: PUSH
109624: EMPTY
109625: LIST
109626: LIST
109627: PUSH
109628: LD_INT 23
109630: PUSH
109631: LD_INT 2
109633: PUSH
109634: EMPTY
109635: LIST
109636: LIST
109637: PUSH
109638: EMPTY
109639: LIST
109640: LIST
109641: PPUSH
109642: CALL_OW 69
109646: IN
109647: AND
109648: IFFALSE 109773
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
109650: LD_ADDR_VAR 0 9
109654: PUSH
109655: LD_OWVAR 3
109659: PUSH
109660: LD_VAR 0 4
109664: PUSH
109665: LD_VAR 0 7
109669: ARRAY
109670: DIFF
109671: PPUSH
109672: LD_VAR 0 4
109676: PUSH
109677: LD_VAR 0 7
109681: ARRAY
109682: PPUSH
109683: CALL_OW 74
109687: ST_TO_ADDR
// if not k then
109688: LD_VAR 0 9
109692: NOT
109693: IFFALSE 109697
// continue ;
109695: GO 106112
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
109697: LD_VAR 0 9
109701: PUSH
109702: LD_INT 81
109704: PUSH
109705: LD_VAR 0 4
109709: PUSH
109710: LD_VAR 0 7
109714: ARRAY
109715: PPUSH
109716: CALL_OW 255
109720: PUSH
109721: EMPTY
109722: LIST
109723: LIST
109724: PPUSH
109725: CALL_OW 69
109729: IN
109730: PUSH
109731: LD_VAR 0 9
109735: PPUSH
109736: LD_VAR 0 4
109740: PUSH
109741: LD_VAR 0 7
109745: ARRAY
109746: PPUSH
109747: CALL_OW 296
109751: PUSH
109752: LD_INT 5
109754: LESS
109755: AND
109756: IFFALSE 109773
// ComAutodestruct ( group [ i ] ) ;
109758: LD_VAR 0 4
109762: PUSH
109763: LD_VAR 0 7
109767: ARRAY
109768: PPUSH
109769: CALL 46544 0 1
// end ; if f_attack_depot then
109773: LD_VAR 0 25
109777: IFFALSE 109889
// begin k := 6 ;
109779: LD_ADDR_VAR 0 9
109783: PUSH
109784: LD_INT 6
109786: ST_TO_ADDR
// if tmp < k then
109787: LD_VAR 0 14
109791: PUSH
109792: LD_VAR 0 9
109796: LESS
109797: IFFALSE 109809
// k := tmp ;
109799: LD_ADDR_VAR 0 9
109803: PUSH
109804: LD_VAR 0 14
109808: ST_TO_ADDR
// for j = 1 to k do
109809: LD_ADDR_VAR 0 8
109813: PUSH
109814: DOUBLE
109815: LD_INT 1
109817: DEC
109818: ST_TO_ADDR
109819: LD_VAR 0 9
109823: PUSH
109824: FOR_TO
109825: IFFALSE 109887
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
109827: LD_VAR 0 8
109831: PPUSH
109832: CALL_OW 266
109836: PUSH
109837: LD_INT 0
109839: PUSH
109840: LD_INT 1
109842: PUSH
109843: EMPTY
109844: LIST
109845: LIST
109846: IN
109847: IFFALSE 109885
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109849: LD_VAR 0 4
109853: PUSH
109854: LD_VAR 0 7
109858: ARRAY
109859: PPUSH
109860: LD_VAR 0 14
109864: PUSH
109865: LD_VAR 0 8
109869: ARRAY
109870: PPUSH
109871: CALL_OW 115
// attacking := true ;
109875: LD_ADDR_VAR 0 29
109879: PUSH
109880: LD_INT 1
109882: ST_TO_ADDR
// break ;
109883: GO 109887
// end ;
109885: GO 109824
109887: POP
109888: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
109889: LD_VAR 0 4
109893: PUSH
109894: LD_VAR 0 7
109898: ARRAY
109899: PPUSH
109900: CALL_OW 302
109904: PUSH
109905: LD_VAR 0 29
109909: NOT
109910: AND
109911: IFFALSE 110233
// begin if GetTag ( group [ i ] ) = 71 then
109913: LD_VAR 0 4
109917: PUSH
109918: LD_VAR 0 7
109922: ARRAY
109923: PPUSH
109924: CALL_OW 110
109928: PUSH
109929: LD_INT 71
109931: EQUAL
109932: IFFALSE 109973
// begin if HasTask ( group [ i ] ) then
109934: LD_VAR 0 4
109938: PUSH
109939: LD_VAR 0 7
109943: ARRAY
109944: PPUSH
109945: CALL_OW 314
109949: IFFALSE 109955
// continue else
109951: GO 106112
109953: GO 109973
// SetTag ( group [ i ] , 0 ) ;
109955: LD_VAR 0 4
109959: PUSH
109960: LD_VAR 0 7
109964: ARRAY
109965: PPUSH
109966: LD_INT 0
109968: PPUSH
109969: CALL_OW 109
// end ; k := 8 ;
109973: LD_ADDR_VAR 0 9
109977: PUSH
109978: LD_INT 8
109980: ST_TO_ADDR
// x := 0 ;
109981: LD_ADDR_VAR 0 10
109985: PUSH
109986: LD_INT 0
109988: ST_TO_ADDR
// if tmp < k then
109989: LD_VAR 0 14
109993: PUSH
109994: LD_VAR 0 9
109998: LESS
109999: IFFALSE 110011
// k := tmp ;
110001: LD_ADDR_VAR 0 9
110005: PUSH
110006: LD_VAR 0 14
110010: ST_TO_ADDR
// for j = 1 to k do
110011: LD_ADDR_VAR 0 8
110015: PUSH
110016: DOUBLE
110017: LD_INT 1
110019: DEC
110020: ST_TO_ADDR
110021: LD_VAR 0 9
110025: PUSH
110026: FOR_TO
110027: IFFALSE 110125
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110029: LD_VAR 0 14
110033: PUSH
110034: LD_VAR 0 8
110038: ARRAY
110039: PPUSH
110040: CALL_OW 247
110044: PUSH
110045: LD_INT 1
110047: EQUAL
110048: PUSH
110049: LD_VAR 0 14
110053: PUSH
110054: LD_VAR 0 8
110058: ARRAY
110059: PPUSH
110060: CALL_OW 256
110064: PUSH
110065: LD_INT 250
110067: LESS
110068: PUSH
110069: LD_VAR 0 20
110073: AND
110074: PUSH
110075: LD_VAR 0 20
110079: NOT
110080: PUSH
110081: LD_VAR 0 14
110085: PUSH
110086: LD_VAR 0 8
110090: ARRAY
110091: PPUSH
110092: CALL_OW 256
110096: PUSH
110097: LD_INT 250
110099: GREATEREQUAL
110100: AND
110101: OR
110102: AND
110103: IFFALSE 110123
// begin x := tmp [ j ] ;
110105: LD_ADDR_VAR 0 10
110109: PUSH
110110: LD_VAR 0 14
110114: PUSH
110115: LD_VAR 0 8
110119: ARRAY
110120: ST_TO_ADDR
// break ;
110121: GO 110125
// end ;
110123: GO 110026
110125: POP
110126: POP
// if x then
110127: LD_VAR 0 10
110131: IFFALSE 110155
// ComAttackUnit ( group [ i ] , x ) else
110133: LD_VAR 0 4
110137: PUSH
110138: LD_VAR 0 7
110142: ARRAY
110143: PPUSH
110144: LD_VAR 0 10
110148: PPUSH
110149: CALL_OW 115
110153: GO 110179
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110155: LD_VAR 0 4
110159: PUSH
110160: LD_VAR 0 7
110164: ARRAY
110165: PPUSH
110166: LD_VAR 0 14
110170: PUSH
110171: LD_INT 1
110173: ARRAY
110174: PPUSH
110175: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110179: LD_VAR 0 4
110183: PUSH
110184: LD_VAR 0 7
110188: ARRAY
110189: PPUSH
110190: CALL_OW 314
110194: NOT
110195: IFFALSE 110233
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110197: LD_VAR 0 4
110201: PUSH
110202: LD_VAR 0 7
110206: ARRAY
110207: PPUSH
110208: LD_VAR 0 14
110212: PPUSH
110213: LD_VAR 0 4
110217: PUSH
110218: LD_VAR 0 7
110222: ARRAY
110223: PPUSH
110224: CALL_OW 74
110228: PPUSH
110229: CALL_OW 115
// end ; end ; end ;
110233: GO 106112
110235: POP
110236: POP
// wait ( 0 0$2 ) ;
110237: LD_INT 70
110239: PPUSH
110240: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110244: LD_VAR 0 4
110248: NOT
110249: PUSH
110250: LD_VAR 0 4
110254: PUSH
110255: EMPTY
110256: EQUAL
110257: OR
110258: PUSH
110259: LD_INT 81
110261: PUSH
110262: LD_VAR 0 35
110266: PUSH
110267: EMPTY
110268: LIST
110269: LIST
110270: PPUSH
110271: CALL_OW 69
110275: NOT
110276: OR
110277: IFFALSE 106097
// end ;
110279: LD_VAR 0 2
110283: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
110284: LD_INT 0
110286: PPUSH
110287: PPUSH
110288: PPUSH
110289: PPUSH
110290: PPUSH
110291: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110292: LD_VAR 0 1
110296: NOT
110297: PUSH
110298: LD_EXP 68
110302: PUSH
110303: LD_VAR 0 1
110307: ARRAY
110308: NOT
110309: OR
110310: PUSH
110311: LD_VAR 0 2
110315: NOT
110316: OR
110317: IFFALSE 110321
// exit ;
110319: GO 110875
// side := mc_sides [ base ] ;
110321: LD_ADDR_VAR 0 6
110325: PUSH
110326: LD_EXP 94
110330: PUSH
110331: LD_VAR 0 1
110335: ARRAY
110336: ST_TO_ADDR
// if not side then
110337: LD_VAR 0 6
110341: NOT
110342: IFFALSE 110346
// exit ;
110344: GO 110875
// for i in solds do
110346: LD_ADDR_VAR 0 7
110350: PUSH
110351: LD_VAR 0 2
110355: PUSH
110356: FOR_IN
110357: IFFALSE 110418
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110359: LD_VAR 0 7
110363: PPUSH
110364: CALL_OW 310
110368: PPUSH
110369: CALL_OW 266
110373: PUSH
110374: LD_INT 32
110376: PUSH
110377: LD_INT 31
110379: PUSH
110380: EMPTY
110381: LIST
110382: LIST
110383: IN
110384: IFFALSE 110404
// solds := solds diff i else
110386: LD_ADDR_VAR 0 2
110390: PUSH
110391: LD_VAR 0 2
110395: PUSH
110396: LD_VAR 0 7
110400: DIFF
110401: ST_TO_ADDR
110402: GO 110416
// SetTag ( i , 18 ) ;
110404: LD_VAR 0 7
110408: PPUSH
110409: LD_INT 18
110411: PPUSH
110412: CALL_OW 109
110416: GO 110356
110418: POP
110419: POP
// if not solds then
110420: LD_VAR 0 2
110424: NOT
110425: IFFALSE 110429
// exit ;
110427: GO 110875
// repeat wait ( 0 0$2 ) ;
110429: LD_INT 70
110431: PPUSH
110432: CALL_OW 67
// enemy := mc_scan [ base ] ;
110436: LD_ADDR_VAR 0 4
110440: PUSH
110441: LD_EXP 91
110445: PUSH
110446: LD_VAR 0 1
110450: ARRAY
110451: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110452: LD_EXP 68
110456: PUSH
110457: LD_VAR 0 1
110461: ARRAY
110462: NOT
110463: PUSH
110464: LD_EXP 68
110468: PUSH
110469: LD_VAR 0 1
110473: ARRAY
110474: PUSH
110475: EMPTY
110476: EQUAL
110477: OR
110478: IFFALSE 110515
// begin for i in solds do
110480: LD_ADDR_VAR 0 7
110484: PUSH
110485: LD_VAR 0 2
110489: PUSH
110490: FOR_IN
110491: IFFALSE 110504
// ComStop ( i ) ;
110493: LD_VAR 0 7
110497: PPUSH
110498: CALL_OW 141
110502: GO 110490
110504: POP
110505: POP
// solds := [ ] ;
110506: LD_ADDR_VAR 0 2
110510: PUSH
110511: EMPTY
110512: ST_TO_ADDR
// exit ;
110513: GO 110875
// end ; for i in solds do
110515: LD_ADDR_VAR 0 7
110519: PUSH
110520: LD_VAR 0 2
110524: PUSH
110525: FOR_IN
110526: IFFALSE 110847
// begin if IsInUnit ( i ) then
110528: LD_VAR 0 7
110532: PPUSH
110533: CALL_OW 310
110537: IFFALSE 110548
// ComExitBuilding ( i ) ;
110539: LD_VAR 0 7
110543: PPUSH
110544: CALL_OW 122
// if GetLives ( i ) > 500 then
110548: LD_VAR 0 7
110552: PPUSH
110553: CALL_OW 256
110557: PUSH
110558: LD_INT 500
110560: GREATER
110561: IFFALSE 110614
// begin e := NearestUnitToUnit ( enemy , i ) ;
110563: LD_ADDR_VAR 0 5
110567: PUSH
110568: LD_VAR 0 4
110572: PPUSH
110573: LD_VAR 0 7
110577: PPUSH
110578: CALL_OW 74
110582: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
110583: LD_VAR 0 7
110587: PPUSH
110588: LD_VAR 0 5
110592: PPUSH
110593: CALL_OW 250
110597: PPUSH
110598: LD_VAR 0 5
110602: PPUSH
110603: CALL_OW 251
110607: PPUSH
110608: CALL_OW 114
// end else
110612: GO 110845
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110614: LD_VAR 0 7
110618: PPUSH
110619: LD_EXP 68
110623: PUSH
110624: LD_VAR 0 1
110628: ARRAY
110629: PPUSH
110630: LD_INT 2
110632: PUSH
110633: LD_INT 30
110635: PUSH
110636: LD_INT 0
110638: PUSH
110639: EMPTY
110640: LIST
110641: LIST
110642: PUSH
110643: LD_INT 30
110645: PUSH
110646: LD_INT 1
110648: PUSH
110649: EMPTY
110650: LIST
110651: LIST
110652: PUSH
110653: LD_INT 30
110655: PUSH
110656: LD_INT 6
110658: PUSH
110659: EMPTY
110660: LIST
110661: LIST
110662: PUSH
110663: EMPTY
110664: LIST
110665: LIST
110666: LIST
110667: LIST
110668: PPUSH
110669: CALL_OW 72
110673: PPUSH
110674: LD_VAR 0 7
110678: PPUSH
110679: CALL_OW 74
110683: PPUSH
110684: CALL_OW 296
110688: PUSH
110689: LD_INT 10
110691: GREATER
110692: IFFALSE 110845
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
110694: LD_ADDR_VAR 0 8
110698: PUSH
110699: LD_EXP 68
110703: PUSH
110704: LD_VAR 0 1
110708: ARRAY
110709: PPUSH
110710: LD_INT 2
110712: PUSH
110713: LD_INT 30
110715: PUSH
110716: LD_INT 0
110718: PUSH
110719: EMPTY
110720: LIST
110721: LIST
110722: PUSH
110723: LD_INT 30
110725: PUSH
110726: LD_INT 1
110728: PUSH
110729: EMPTY
110730: LIST
110731: LIST
110732: PUSH
110733: LD_INT 30
110735: PUSH
110736: LD_INT 6
110738: PUSH
110739: EMPTY
110740: LIST
110741: LIST
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: PPUSH
110749: CALL_OW 72
110753: PPUSH
110754: LD_VAR 0 7
110758: PPUSH
110759: CALL_OW 74
110763: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
110764: LD_VAR 0 7
110768: PPUSH
110769: LD_VAR 0 8
110773: PPUSH
110774: CALL_OW 250
110778: PPUSH
110779: LD_INT 3
110781: PPUSH
110782: LD_INT 5
110784: PPUSH
110785: CALL_OW 272
110789: PPUSH
110790: LD_VAR 0 8
110794: PPUSH
110795: CALL_OW 251
110799: PPUSH
110800: LD_INT 3
110802: PPUSH
110803: LD_INT 5
110805: PPUSH
110806: CALL_OW 273
110810: PPUSH
110811: CALL_OW 111
// SetTag ( i , 0 ) ;
110815: LD_VAR 0 7
110819: PPUSH
110820: LD_INT 0
110822: PPUSH
110823: CALL_OW 109
// solds := solds diff i ;
110827: LD_ADDR_VAR 0 2
110831: PUSH
110832: LD_VAR 0 2
110836: PUSH
110837: LD_VAR 0 7
110841: DIFF
110842: ST_TO_ADDR
// continue ;
110843: GO 110525
// end ; end ;
110845: GO 110525
110847: POP
110848: POP
// until not solds or not enemy ;
110849: LD_VAR 0 2
110853: NOT
110854: PUSH
110855: LD_VAR 0 4
110859: NOT
110860: OR
110861: IFFALSE 110429
// MC_Reset ( base , 18 ) ;
110863: LD_VAR 0 1
110867: PPUSH
110868: LD_INT 18
110870: PPUSH
110871: CALL 59141 0 2
// end ;
110875: LD_VAR 0 3
110879: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
110880: LD_INT 0
110882: PPUSH
110883: PPUSH
110884: PPUSH
110885: PPUSH
110886: PPUSH
110887: PPUSH
110888: PPUSH
110889: PPUSH
110890: PPUSH
110891: PPUSH
110892: PPUSH
110893: PPUSH
110894: PPUSH
110895: PPUSH
110896: PPUSH
110897: PPUSH
110898: PPUSH
110899: PPUSH
110900: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
110901: LD_ADDR_VAR 0 12
110905: PUSH
110906: LD_EXP 68
110910: PUSH
110911: LD_VAR 0 1
110915: ARRAY
110916: PPUSH
110917: LD_INT 25
110919: PUSH
110920: LD_INT 3
110922: PUSH
110923: EMPTY
110924: LIST
110925: LIST
110926: PPUSH
110927: CALL_OW 72
110931: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110932: LD_EXP 108
110936: PUSH
110937: LD_VAR 0 1
110941: ARRAY
110942: IFFALSE 110966
// mechs := mechs diff mc_remote_driver [ base ] ;
110944: LD_ADDR_VAR 0 12
110948: PUSH
110949: LD_VAR 0 12
110953: PUSH
110954: LD_EXP 108
110958: PUSH
110959: LD_VAR 0 1
110963: ARRAY
110964: DIFF
110965: ST_TO_ADDR
// for i in mechs do
110966: LD_ADDR_VAR 0 4
110970: PUSH
110971: LD_VAR 0 12
110975: PUSH
110976: FOR_IN
110977: IFFALSE 111012
// if GetTag ( i ) > 0 then
110979: LD_VAR 0 4
110983: PPUSH
110984: CALL_OW 110
110988: PUSH
110989: LD_INT 0
110991: GREATER
110992: IFFALSE 111010
// mechs := mechs diff i ;
110994: LD_ADDR_VAR 0 12
110998: PUSH
110999: LD_VAR 0 12
111003: PUSH
111004: LD_VAR 0 4
111008: DIFF
111009: ST_TO_ADDR
111010: GO 110976
111012: POP
111013: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111014: LD_ADDR_VAR 0 8
111018: PUSH
111019: LD_EXP 68
111023: PUSH
111024: LD_VAR 0 1
111028: ARRAY
111029: PPUSH
111030: LD_INT 2
111032: PUSH
111033: LD_INT 25
111035: PUSH
111036: LD_INT 1
111038: PUSH
111039: EMPTY
111040: LIST
111041: LIST
111042: PUSH
111043: LD_INT 25
111045: PUSH
111046: LD_INT 5
111048: PUSH
111049: EMPTY
111050: LIST
111051: LIST
111052: PUSH
111053: LD_INT 25
111055: PUSH
111056: LD_INT 8
111058: PUSH
111059: EMPTY
111060: LIST
111061: LIST
111062: PUSH
111063: LD_INT 25
111065: PUSH
111066: LD_INT 9
111068: PUSH
111069: EMPTY
111070: LIST
111071: LIST
111072: PUSH
111073: EMPTY
111074: LIST
111075: LIST
111076: LIST
111077: LIST
111078: LIST
111079: PPUSH
111080: CALL_OW 72
111084: ST_TO_ADDR
// if not defenders and not solds then
111085: LD_VAR 0 2
111089: NOT
111090: PUSH
111091: LD_VAR 0 8
111095: NOT
111096: AND
111097: IFFALSE 111101
// exit ;
111099: GO 112871
// depot_under_attack := false ;
111101: LD_ADDR_VAR 0 16
111105: PUSH
111106: LD_INT 0
111108: ST_TO_ADDR
// sold_defenders := [ ] ;
111109: LD_ADDR_VAR 0 17
111113: PUSH
111114: EMPTY
111115: ST_TO_ADDR
// if mechs then
111116: LD_VAR 0 12
111120: IFFALSE 111273
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111122: LD_ADDR_VAR 0 4
111126: PUSH
111127: LD_VAR 0 2
111131: PPUSH
111132: LD_INT 21
111134: PUSH
111135: LD_INT 2
111137: PUSH
111138: EMPTY
111139: LIST
111140: LIST
111141: PPUSH
111142: CALL_OW 72
111146: PUSH
111147: FOR_IN
111148: IFFALSE 111271
// begin if GetTag ( i ) <> 20 then
111150: LD_VAR 0 4
111154: PPUSH
111155: CALL_OW 110
111159: PUSH
111160: LD_INT 20
111162: NONEQUAL
111163: IFFALSE 111177
// SetTag ( i , 20 ) ;
111165: LD_VAR 0 4
111169: PPUSH
111170: LD_INT 20
111172: PPUSH
111173: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111177: LD_VAR 0 4
111181: PPUSH
111182: CALL_OW 263
111186: PUSH
111187: LD_INT 1
111189: EQUAL
111190: PUSH
111191: LD_VAR 0 4
111195: PPUSH
111196: CALL_OW 311
111200: NOT
111201: AND
111202: IFFALSE 111269
// begin un := mechs [ 1 ] ;
111204: LD_ADDR_VAR 0 10
111208: PUSH
111209: LD_VAR 0 12
111213: PUSH
111214: LD_INT 1
111216: ARRAY
111217: ST_TO_ADDR
// ComExit ( un ) ;
111218: LD_VAR 0 10
111222: PPUSH
111223: CALL 51410 0 1
// AddComEnterUnit ( un , i ) ;
111227: LD_VAR 0 10
111231: PPUSH
111232: LD_VAR 0 4
111236: PPUSH
111237: CALL_OW 180
// SetTag ( un , 19 ) ;
111241: LD_VAR 0 10
111245: PPUSH
111246: LD_INT 19
111248: PPUSH
111249: CALL_OW 109
// mechs := mechs diff un ;
111253: LD_ADDR_VAR 0 12
111257: PUSH
111258: LD_VAR 0 12
111262: PUSH
111263: LD_VAR 0 10
111267: DIFF
111268: ST_TO_ADDR
// end ; end ;
111269: GO 111147
111271: POP
111272: POP
// if solds then
111273: LD_VAR 0 8
111277: IFFALSE 111336
// for i in solds do
111279: LD_ADDR_VAR 0 4
111283: PUSH
111284: LD_VAR 0 8
111288: PUSH
111289: FOR_IN
111290: IFFALSE 111334
// if not GetTag ( i ) then
111292: LD_VAR 0 4
111296: PPUSH
111297: CALL_OW 110
111301: NOT
111302: IFFALSE 111332
// begin defenders := defenders union i ;
111304: LD_ADDR_VAR 0 2
111308: PUSH
111309: LD_VAR 0 2
111313: PUSH
111314: LD_VAR 0 4
111318: UNION
111319: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111320: LD_VAR 0 4
111324: PPUSH
111325: LD_INT 18
111327: PPUSH
111328: CALL_OW 109
// end ;
111332: GO 111289
111334: POP
111335: POP
// repeat wait ( 0 0$2 ) ;
111336: LD_INT 70
111338: PPUSH
111339: CALL_OW 67
// enemy := mc_scan [ base ] ;
111343: LD_ADDR_VAR 0 21
111347: PUSH
111348: LD_EXP 91
111352: PUSH
111353: LD_VAR 0 1
111357: ARRAY
111358: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111359: LD_EXP 68
111363: PUSH
111364: LD_VAR 0 1
111368: ARRAY
111369: NOT
111370: PUSH
111371: LD_EXP 68
111375: PUSH
111376: LD_VAR 0 1
111380: ARRAY
111381: PUSH
111382: EMPTY
111383: EQUAL
111384: OR
111385: IFFALSE 111422
// begin for i in defenders do
111387: LD_ADDR_VAR 0 4
111391: PUSH
111392: LD_VAR 0 2
111396: PUSH
111397: FOR_IN
111398: IFFALSE 111411
// ComStop ( i ) ;
111400: LD_VAR 0 4
111404: PPUSH
111405: CALL_OW 141
111409: GO 111397
111411: POP
111412: POP
// defenders := [ ] ;
111413: LD_ADDR_VAR 0 2
111417: PUSH
111418: EMPTY
111419: ST_TO_ADDR
// exit ;
111420: GO 112871
// end ; for i in defenders do
111422: LD_ADDR_VAR 0 4
111426: PUSH
111427: LD_VAR 0 2
111431: PUSH
111432: FOR_IN
111433: IFFALSE 112331
// begin e := NearestUnitToUnit ( enemy , i ) ;
111435: LD_ADDR_VAR 0 13
111439: PUSH
111440: LD_VAR 0 21
111444: PPUSH
111445: LD_VAR 0 4
111449: PPUSH
111450: CALL_OW 74
111454: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111455: LD_ADDR_VAR 0 7
111459: PUSH
111460: LD_EXP 68
111464: PUSH
111465: LD_VAR 0 1
111469: ARRAY
111470: PPUSH
111471: LD_INT 2
111473: PUSH
111474: LD_INT 30
111476: PUSH
111477: LD_INT 0
111479: PUSH
111480: EMPTY
111481: LIST
111482: LIST
111483: PUSH
111484: LD_INT 30
111486: PUSH
111487: LD_INT 1
111489: PUSH
111490: EMPTY
111491: LIST
111492: LIST
111493: PUSH
111494: EMPTY
111495: LIST
111496: LIST
111497: LIST
111498: PPUSH
111499: CALL_OW 72
111503: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111504: LD_ADDR_VAR 0 16
111508: PUSH
111509: LD_VAR 0 7
111513: NOT
111514: PUSH
111515: LD_VAR 0 7
111519: PPUSH
111520: LD_INT 3
111522: PUSH
111523: LD_INT 24
111525: PUSH
111526: LD_INT 600
111528: PUSH
111529: EMPTY
111530: LIST
111531: LIST
111532: PUSH
111533: EMPTY
111534: LIST
111535: LIST
111536: PPUSH
111537: CALL_OW 72
111541: OR
111542: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111543: LD_VAR 0 4
111547: PPUSH
111548: CALL_OW 247
111552: PUSH
111553: LD_INT 2
111555: DOUBLE
111556: EQUAL
111557: IFTRUE 111561
111559: GO 111957
111561: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111562: LD_VAR 0 4
111566: PPUSH
111567: CALL_OW 256
111571: PUSH
111572: LD_INT 1000
111574: EQUAL
111575: PUSH
111576: LD_VAR 0 4
111580: PPUSH
111581: LD_VAR 0 13
111585: PPUSH
111586: CALL_OW 296
111590: PUSH
111591: LD_INT 40
111593: LESS
111594: PUSH
111595: LD_VAR 0 13
111599: PPUSH
111600: LD_EXP 93
111604: PUSH
111605: LD_VAR 0 1
111609: ARRAY
111610: PPUSH
111611: CALL_OW 308
111615: OR
111616: AND
111617: IFFALSE 111739
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111619: LD_VAR 0 4
111623: PPUSH
111624: CALL_OW 262
111628: PUSH
111629: LD_INT 1
111631: EQUAL
111632: PUSH
111633: LD_VAR 0 4
111637: PPUSH
111638: CALL_OW 261
111642: PUSH
111643: LD_INT 30
111645: LESS
111646: AND
111647: PUSH
111648: LD_VAR 0 7
111652: AND
111653: IFFALSE 111723
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
111655: LD_VAR 0 4
111659: PPUSH
111660: LD_VAR 0 7
111664: PPUSH
111665: LD_VAR 0 4
111669: PPUSH
111670: CALL_OW 74
111674: PPUSH
111675: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
111679: LD_VAR 0 4
111683: PPUSH
111684: LD_VAR 0 7
111688: PPUSH
111689: LD_VAR 0 4
111693: PPUSH
111694: CALL_OW 74
111698: PPUSH
111699: CALL_OW 296
111703: PUSH
111704: LD_INT 6
111706: LESS
111707: IFFALSE 111721
// SetFuel ( i , 100 ) ;
111709: LD_VAR 0 4
111713: PPUSH
111714: LD_INT 100
111716: PPUSH
111717: CALL_OW 240
// end else
111721: GO 111737
// ComAttackUnit ( i , e ) ;
111723: LD_VAR 0 4
111727: PPUSH
111728: LD_VAR 0 13
111732: PPUSH
111733: CALL_OW 115
// end else
111737: GO 111840
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
111739: LD_VAR 0 13
111743: PPUSH
111744: LD_EXP 93
111748: PUSH
111749: LD_VAR 0 1
111753: ARRAY
111754: PPUSH
111755: CALL_OW 308
111759: NOT
111760: PUSH
111761: LD_VAR 0 4
111765: PPUSH
111766: LD_VAR 0 13
111770: PPUSH
111771: CALL_OW 296
111775: PUSH
111776: LD_INT 40
111778: GREATEREQUAL
111779: AND
111780: PUSH
111781: LD_VAR 0 4
111785: PPUSH
111786: CALL_OW 256
111790: PUSH
111791: LD_INT 650
111793: LESSEQUAL
111794: OR
111795: PUSH
111796: LD_VAR 0 4
111800: PPUSH
111801: LD_EXP 92
111805: PUSH
111806: LD_VAR 0 1
111810: ARRAY
111811: PPUSH
111812: CALL_OW 308
111816: NOT
111817: AND
111818: IFFALSE 111840
// ComMoveToArea ( i , mc_parking [ base ] ) ;
111820: LD_VAR 0 4
111824: PPUSH
111825: LD_EXP 92
111829: PUSH
111830: LD_VAR 0 1
111834: ARRAY
111835: PPUSH
111836: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
111840: LD_VAR 0 4
111844: PPUSH
111845: CALL_OW 256
111849: PUSH
111850: LD_INT 1000
111852: LESS
111853: PUSH
111854: LD_VAR 0 4
111858: PPUSH
111859: CALL_OW 263
111863: PUSH
111864: LD_INT 1
111866: EQUAL
111867: AND
111868: PUSH
111869: LD_VAR 0 4
111873: PPUSH
111874: CALL_OW 311
111878: AND
111879: PUSH
111880: LD_VAR 0 4
111884: PPUSH
111885: LD_EXP 92
111889: PUSH
111890: LD_VAR 0 1
111894: ARRAY
111895: PPUSH
111896: CALL_OW 308
111900: AND
111901: IFFALSE 111955
// begin mech := IsDrivenBy ( i ) ;
111903: LD_ADDR_VAR 0 9
111907: PUSH
111908: LD_VAR 0 4
111912: PPUSH
111913: CALL_OW 311
111917: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111918: LD_VAR 0 9
111922: PPUSH
111923: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111927: LD_VAR 0 9
111931: PPUSH
111932: LD_VAR 0 4
111936: PPUSH
111937: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111941: LD_VAR 0 9
111945: PPUSH
111946: LD_VAR 0 4
111950: PPUSH
111951: CALL_OW 180
// end ; end ; unit_human :
111955: GO 112302
111957: LD_INT 1
111959: DOUBLE
111960: EQUAL
111961: IFTRUE 111965
111963: GO 112301
111965: POP
// begin b := IsInUnit ( i ) ;
111966: LD_ADDR_VAR 0 18
111970: PUSH
111971: LD_VAR 0 4
111975: PPUSH
111976: CALL_OW 310
111980: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111981: LD_ADDR_VAR 0 19
111985: PUSH
111986: LD_VAR 0 18
111990: NOT
111991: PUSH
111992: LD_VAR 0 18
111996: PPUSH
111997: CALL_OW 266
112001: PUSH
112002: LD_INT 32
112004: PUSH
112005: LD_INT 31
112007: PUSH
112008: EMPTY
112009: LIST
112010: LIST
112011: IN
112012: OR
112013: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
112014: LD_VAR 0 18
112018: PPUSH
112019: CALL_OW 266
112023: PUSH
112024: LD_INT 5
112026: EQUAL
112027: PUSH
112028: LD_VAR 0 4
112032: PPUSH
112033: CALL_OW 257
112037: PUSH
112038: LD_INT 1
112040: PUSH
112041: LD_INT 2
112043: PUSH
112044: LD_INT 3
112046: PUSH
112047: LD_INT 4
112049: PUSH
112050: EMPTY
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: IN
112056: AND
112057: IFFALSE 112094
// begin class := AllowSpecClass ( i ) ;
112059: LD_ADDR_VAR 0 20
112063: PUSH
112064: LD_VAR 0 4
112068: PPUSH
112069: CALL 15397 0 1
112073: ST_TO_ADDR
// if class then
112074: LD_VAR 0 20
112078: IFFALSE 112094
// ComChangeProfession ( i , class ) ;
112080: LD_VAR 0 4
112084: PPUSH
112085: LD_VAR 0 20
112089: PPUSH
112090: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112094: LD_VAR 0 16
112098: PUSH
112099: LD_VAR 0 2
112103: PPUSH
112104: LD_INT 21
112106: PUSH
112107: LD_INT 2
112109: PUSH
112110: EMPTY
112111: LIST
112112: LIST
112113: PPUSH
112114: CALL_OW 72
112118: PUSH
112119: LD_INT 1
112121: LESSEQUAL
112122: OR
112123: PUSH
112124: LD_VAR 0 19
112128: AND
112129: PUSH
112130: LD_VAR 0 4
112134: PUSH
112135: LD_VAR 0 17
112139: IN
112140: NOT
112141: AND
112142: IFFALSE 112235
// begin if b then
112144: LD_VAR 0 18
112148: IFFALSE 112197
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112150: LD_VAR 0 18
112154: PPUSH
112155: LD_VAR 0 21
112159: PPUSH
112160: LD_VAR 0 18
112164: PPUSH
112165: CALL_OW 74
112169: PPUSH
112170: CALL_OW 296
112174: PUSH
112175: LD_INT 10
112177: LESS
112178: PUSH
112179: LD_VAR 0 18
112183: PPUSH
112184: CALL_OW 461
112188: PUSH
112189: LD_INT 7
112191: NONEQUAL
112192: AND
112193: IFFALSE 112197
// continue ;
112195: GO 111432
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112197: LD_ADDR_VAR 0 17
112201: PUSH
112202: LD_VAR 0 17
112206: PPUSH
112207: LD_VAR 0 17
112211: PUSH
112212: LD_INT 1
112214: PLUS
112215: PPUSH
112216: LD_VAR 0 4
112220: PPUSH
112221: CALL_OW 1
112225: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112226: LD_VAR 0 4
112230: PPUSH
112231: CALL_OW 122
// end ; if sold_defenders then
112235: LD_VAR 0 17
112239: IFFALSE 112299
// if i in sold_defenders then
112241: LD_VAR 0 4
112245: PUSH
112246: LD_VAR 0 17
112250: IN
112251: IFFALSE 112299
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112253: LD_VAR 0 4
112257: PPUSH
112258: CALL_OW 314
112262: NOT
112263: PUSH
112264: LD_VAR 0 4
112268: PPUSH
112269: LD_VAR 0 13
112273: PPUSH
112274: CALL_OW 296
112278: PUSH
112279: LD_INT 30
112281: LESS
112282: AND
112283: IFFALSE 112299
// ComAttackUnit ( i , e ) ;
112285: LD_VAR 0 4
112289: PPUSH
112290: LD_VAR 0 13
112294: PPUSH
112295: CALL_OW 115
// end ; end ; end ;
112299: GO 112302
112301: POP
// if IsDead ( i ) then
112302: LD_VAR 0 4
112306: PPUSH
112307: CALL_OW 301
112311: IFFALSE 112329
// defenders := defenders diff i ;
112313: LD_ADDR_VAR 0 2
112317: PUSH
112318: LD_VAR 0 2
112322: PUSH
112323: LD_VAR 0 4
112327: DIFF
112328: ST_TO_ADDR
// end ;
112329: GO 111432
112331: POP
112332: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112333: LD_VAR 0 21
112337: NOT
112338: PUSH
112339: LD_VAR 0 2
112343: NOT
112344: OR
112345: PUSH
112346: LD_EXP 68
112350: PUSH
112351: LD_VAR 0 1
112355: ARRAY
112356: NOT
112357: OR
112358: IFFALSE 111336
// MC_Reset ( base , 18 ) ;
112360: LD_VAR 0 1
112364: PPUSH
112365: LD_INT 18
112367: PPUSH
112368: CALL 59141 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112372: LD_ADDR_VAR 0 2
112376: PUSH
112377: LD_VAR 0 2
112381: PUSH
112382: LD_VAR 0 2
112386: PPUSH
112387: LD_INT 2
112389: PUSH
112390: LD_INT 25
112392: PUSH
112393: LD_INT 1
112395: PUSH
112396: EMPTY
112397: LIST
112398: LIST
112399: PUSH
112400: LD_INT 25
112402: PUSH
112403: LD_INT 5
112405: PUSH
112406: EMPTY
112407: LIST
112408: LIST
112409: PUSH
112410: LD_INT 25
112412: PUSH
112413: LD_INT 8
112415: PUSH
112416: EMPTY
112417: LIST
112418: LIST
112419: PUSH
112420: LD_INT 25
112422: PUSH
112423: LD_INT 9
112425: PUSH
112426: EMPTY
112427: LIST
112428: LIST
112429: PUSH
112430: EMPTY
112431: LIST
112432: LIST
112433: LIST
112434: LIST
112435: LIST
112436: PPUSH
112437: CALL_OW 72
112441: DIFF
112442: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112443: LD_VAR 0 21
112447: NOT
112448: PUSH
112449: LD_VAR 0 2
112453: PPUSH
112454: LD_INT 21
112456: PUSH
112457: LD_INT 2
112459: PUSH
112460: EMPTY
112461: LIST
112462: LIST
112463: PPUSH
112464: CALL_OW 72
112468: AND
112469: IFFALSE 112807
// begin tmp := FilterByTag ( defenders , 19 ) ;
112471: LD_ADDR_VAR 0 11
112475: PUSH
112476: LD_VAR 0 2
112480: PPUSH
112481: LD_INT 19
112483: PPUSH
112484: CALL 48586 0 2
112488: ST_TO_ADDR
// if tmp then
112489: LD_VAR 0 11
112493: IFFALSE 112563
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112495: LD_ADDR_VAR 0 11
112499: PUSH
112500: LD_VAR 0 11
112504: PPUSH
112505: LD_INT 25
112507: PUSH
112508: LD_INT 3
112510: PUSH
112511: EMPTY
112512: LIST
112513: LIST
112514: PPUSH
112515: CALL_OW 72
112519: ST_TO_ADDR
// if tmp then
112520: LD_VAR 0 11
112524: IFFALSE 112563
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112526: LD_ADDR_EXP 80
112530: PUSH
112531: LD_EXP 80
112535: PPUSH
112536: LD_VAR 0 1
112540: PPUSH
112541: LD_EXP 80
112545: PUSH
112546: LD_VAR 0 1
112550: ARRAY
112551: PUSH
112552: LD_VAR 0 11
112556: UNION
112557: PPUSH
112558: CALL_OW 1
112562: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112563: LD_VAR 0 1
112567: PPUSH
112568: LD_INT 19
112570: PPUSH
112571: CALL 59141 0 2
// repeat wait ( 0 0$1 ) ;
112575: LD_INT 35
112577: PPUSH
112578: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112582: LD_EXP 68
112586: PUSH
112587: LD_VAR 0 1
112591: ARRAY
112592: NOT
112593: PUSH
112594: LD_EXP 68
112598: PUSH
112599: LD_VAR 0 1
112603: ARRAY
112604: PUSH
112605: EMPTY
112606: EQUAL
112607: OR
112608: IFFALSE 112645
// begin for i in defenders do
112610: LD_ADDR_VAR 0 4
112614: PUSH
112615: LD_VAR 0 2
112619: PUSH
112620: FOR_IN
112621: IFFALSE 112634
// ComStop ( i ) ;
112623: LD_VAR 0 4
112627: PPUSH
112628: CALL_OW 141
112632: GO 112620
112634: POP
112635: POP
// defenders := [ ] ;
112636: LD_ADDR_VAR 0 2
112640: PUSH
112641: EMPTY
112642: ST_TO_ADDR
// exit ;
112643: GO 112871
// end ; for i in defenders do
112645: LD_ADDR_VAR 0 4
112649: PUSH
112650: LD_VAR 0 2
112654: PUSH
112655: FOR_IN
112656: IFFALSE 112745
// begin if not IsInArea ( i , mc_parking [ base ] ) then
112658: LD_VAR 0 4
112662: PPUSH
112663: LD_EXP 92
112667: PUSH
112668: LD_VAR 0 1
112672: ARRAY
112673: PPUSH
112674: CALL_OW 308
112678: NOT
112679: IFFALSE 112703
// ComMoveToArea ( i , mc_parking [ base ] ) else
112681: LD_VAR 0 4
112685: PPUSH
112686: LD_EXP 92
112690: PUSH
112691: LD_VAR 0 1
112695: ARRAY
112696: PPUSH
112697: CALL_OW 113
112701: GO 112743
// if GetControl ( i ) = control_manual then
112703: LD_VAR 0 4
112707: PPUSH
112708: CALL_OW 263
112712: PUSH
112713: LD_INT 1
112715: EQUAL
112716: IFFALSE 112743
// if IsDrivenBy ( i ) then
112718: LD_VAR 0 4
112722: PPUSH
112723: CALL_OW 311
112727: IFFALSE 112743
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
112729: LD_VAR 0 4
112733: PPUSH
112734: CALL_OW 311
112738: PPUSH
112739: CALL_OW 121
// end ;
112743: GO 112655
112745: POP
112746: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
112747: LD_VAR 0 2
112751: PPUSH
112752: LD_INT 95
112754: PUSH
112755: LD_EXP 92
112759: PUSH
112760: LD_VAR 0 1
112764: ARRAY
112765: PUSH
112766: EMPTY
112767: LIST
112768: LIST
112769: PPUSH
112770: CALL_OW 72
112774: PUSH
112775: LD_VAR 0 2
112779: EQUAL
112780: PUSH
112781: LD_EXP 91
112785: PUSH
112786: LD_VAR 0 1
112790: ARRAY
112791: OR
112792: PUSH
112793: LD_EXP 68
112797: PUSH
112798: LD_VAR 0 1
112802: ARRAY
112803: NOT
112804: OR
112805: IFFALSE 112575
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
112807: LD_ADDR_EXP 90
112811: PUSH
112812: LD_EXP 90
112816: PPUSH
112817: LD_VAR 0 1
112821: PPUSH
112822: LD_VAR 0 2
112826: PPUSH
112827: LD_INT 21
112829: PUSH
112830: LD_INT 2
112832: PUSH
112833: EMPTY
112834: LIST
112835: LIST
112836: PPUSH
112837: CALL_OW 72
112841: PPUSH
112842: CALL_OW 1
112846: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
112847: LD_VAR 0 1
112851: PPUSH
112852: LD_INT 19
112854: PPUSH
112855: CALL 59141 0 2
// MC_Reset ( base , 20 ) ;
112859: LD_VAR 0 1
112863: PPUSH
112864: LD_INT 20
112866: PPUSH
112867: CALL 59141 0 2
// end ; end_of_file
112871: LD_VAR 0 3
112875: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
112876: LD_VAR 0 1
112880: PUSH
112881: LD_INT 200
112883: DOUBLE
112884: GREATEREQUAL
112885: IFFALSE 112893
112887: LD_INT 299
112889: DOUBLE
112890: LESSEQUAL
112891: IFTRUE 112895
112893: GO 112927
112895: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
112896: LD_VAR 0 1
112900: PPUSH
112901: LD_VAR 0 2
112905: PPUSH
112906: LD_VAR 0 3
112910: PPUSH
112911: LD_VAR 0 4
112915: PPUSH
112916: LD_VAR 0 5
112920: PPUSH
112921: CALL 101642 0 5
112925: GO 113004
112927: LD_INT 300
112929: DOUBLE
112930: GREATEREQUAL
112931: IFFALSE 112939
112933: LD_INT 399
112935: DOUBLE
112936: LESSEQUAL
112937: IFTRUE 112941
112939: GO 113003
112941: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112942: LD_VAR 0 1
112946: PPUSH
112947: LD_VAR 0 2
112951: PPUSH
112952: LD_VAR 0 3
112956: PPUSH
112957: LD_VAR 0 4
112961: PPUSH
112962: LD_VAR 0 5
112966: PPUSH
112967: LD_VAR 0 6
112971: PPUSH
112972: LD_VAR 0 7
112976: PPUSH
112977: LD_VAR 0 8
112981: PPUSH
112982: LD_VAR 0 9
112986: PPUSH
112987: LD_VAR 0 10
112991: PPUSH
112992: LD_VAR 0 11
112996: PPUSH
112997: CALL 97971 0 11
113001: GO 113004
113003: POP
// end ;
113004: PPOPN 11
113006: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
113007: LD_VAR 0 1
113011: PPUSH
113012: LD_VAR 0 2
113016: PPUSH
113017: LD_VAR 0 3
113021: PPUSH
113022: LD_VAR 0 4
113026: PPUSH
113027: LD_VAR 0 5
113031: PPUSH
113032: CALL 101378 0 5
// end ; end_of_file
113036: PPOPN 5
113038: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113039: LD_VAR 0 1
113043: PPUSH
113044: LD_VAR 0 2
113048: PPUSH
113049: LD_VAR 0 3
113053: PPUSH
113054: LD_VAR 0 4
113058: PPUSH
113059: LD_VAR 0 5
113063: PPUSH
113064: LD_VAR 0 6
113068: PPUSH
113069: CALL 85664 0 6
// end ;
113073: PPOPN 6
113075: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
113076: LD_INT 0
113078: PPUSH
// begin if not units then
113079: LD_VAR 0 1
113083: NOT
113084: IFFALSE 113088
// exit ;
113086: GO 113088
// end ;
113088: PPOPN 7
113090: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
113091: CALL 85635 0 0
// end ;
113095: PPOPN 1
113097: END
