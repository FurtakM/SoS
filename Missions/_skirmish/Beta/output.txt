// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5444 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2607 0 0
// PrepareBeta ;
 105: CALL 2996 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12724 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4719 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 50
 744: PUSH
 745: LD_EXP 50
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 50
 777: PUSH
 778: LD_EXP 50
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 57334 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1237
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3578 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4303 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4190 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12581 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12581 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 1 1$20 ) ;
1043: LD_INT 2800
1045: PPUSH
1046: CALL_OW 67
// ComMoveXY ( Bulldozers , 64 , 114 ) ;
1050: LD_EXP 18
1054: PPUSH
1055: LD_INT 64
1057: PPUSH
1058: LD_INT 114
1060: PPUSH
1061: CALL_OW 111
// wait ( 0 0$10 ) ;
1065: LD_INT 350
1067: PPUSH
1068: CALL_OW 67
// for i := 1 to 2 do
1072: LD_ADDR_VAR 0 1
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: FOR_TO
1086: IFFALSE 1105
// RemoveUnit ( Bulldozers [ i ] ) ;
1088: LD_EXP 18
1092: PUSH
1093: LD_VAR 0 1
1097: ARRAY
1098: PPUSH
1099: CALL_OW 64
1103: GO 1085
1105: POP
1106: POP
// RemoveEnvironmentArea ( BulldozerArea ) ;
1107: LD_INT 9
1109: PPUSH
1110: CALL_OW 355
// RemoveEnvironmentArea ( BulldozerArea2 ) ;
1114: LD_INT 11
1116: PPUSH
1117: CALL_OW 355
// SayEffect ( DRuSol-A1 ) ;
1121: LD_STRING DRuSol-A1
1123: PPUSH
1124: CALL_OW 96
// AssaultStarted := true ;
1128: LD_ADDR_EXP 8
1132: PUSH
1133: LD_INT 1
1135: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1136: LD_INT 70
1138: PPUSH
1139: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1143: LD_EXP 13
1147: PPUSH
1148: LD_STRING DDeath-Yas-1
1150: PPUSH
1151: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1155: LD_EXP 15
1159: PPUSH
1160: LD_STRING DDeath-Gay-2
1162: PPUSH
1163: CALL_OW 88
// wait ( 0 0$2 ) ;
1167: LD_INT 70
1169: PPUSH
1170: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1174: LD_EXP 14
1178: PPUSH
1179: LD_STRING DDeath-Pop-1
1181: PPUSH
1182: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1186: LD_EXP 15
1190: PPUSH
1191: LD_STRING DDeath-Gay-1
1193: PPUSH
1194: CALL_OW 88
// wait ( 0 0$5 ) ;
1198: LD_INT 175
1200: PPUSH
1201: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1205: LD_EXP 16
1209: PPUSH
1210: LD_STRING DDeath-Vse-1
1212: PPUSH
1213: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1217: LD_EXP 14
1221: PPUSH
1222: LD_STRING DDeath-Pop-2
1224: PPUSH
1225: CALL_OW 88
// southAreaBlocker = false ;
1229: LD_ADDR_EXP 2
1233: PUSH
1234: LD_INT 0
1236: ST_TO_ADDR
// end ;
1237: PPOPN 2
1239: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1240: LD_EXP 8
1244: IFFALSE 1835
1246: GO 1248
1248: DISABLE
1249: LD_INT 0
1251: PPUSH
1252: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1253: LD_INT 6
1255: PPUSH
1256: LD_INT 1
1258: PPUSH
1259: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1263: LD_INT 6
1265: PPUSH
1266: LD_INT 3
1268: PPUSH
1269: CALL_OW 470
// repeat for i in RuArmada do
1273: LD_ADDR_VAR 0 1
1277: PUSH
1278: LD_EXP 17
1282: PUSH
1283: FOR_IN
1284: IFFALSE 1487
// begin if GetDistUnitXY ( i , 87 , 77 ) < 10 and not GetTag ( i ) then
1286: LD_VAR 0 1
1290: PPUSH
1291: LD_INT 87
1293: PPUSH
1294: LD_INT 77
1296: PPUSH
1297: CALL_OW 297
1301: PUSH
1302: LD_INT 10
1304: LESS
1305: PUSH
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 110
1315: NOT
1316: AND
1317: IFFALSE 1331
// SetTag ( i , 1 ) ;
1319: LD_VAR 0 1
1323: PPUSH
1324: LD_INT 1
1326: PPUSH
1327: CALL_OW 109
// if GetDistUnitXY ( i , 62 , 48 ) < 10 and GetTag ( i ) < 2 then
1331: LD_VAR 0 1
1335: PPUSH
1336: LD_INT 62
1338: PPUSH
1339: LD_INT 48
1341: PPUSH
1342: CALL_OW 297
1346: PUSH
1347: LD_INT 10
1349: LESS
1350: PUSH
1351: LD_VAR 0 1
1355: PPUSH
1356: CALL_OW 110
1360: PUSH
1361: LD_INT 2
1363: LESS
1364: AND
1365: IFFALSE 1379
// SetTag ( i , 2 ) ;
1367: LD_VAR 0 1
1371: PPUSH
1372: LD_INT 2
1374: PPUSH
1375: CALL_OW 109
// if not GetTag ( i ) then
1379: LD_VAR 0 1
1383: PPUSH
1384: CALL_OW 110
1388: NOT
1389: IFFALSE 1406
// ComAgressiveMove ( i , 87 , 77 ) ;
1391: LD_VAR 0 1
1395: PPUSH
1396: LD_INT 87
1398: PPUSH
1399: LD_INT 77
1401: PPUSH
1402: CALL_OW 114
// if GetTag ( i ) = 1 then
1406: LD_VAR 0 1
1410: PPUSH
1411: CALL_OW 110
1415: PUSH
1416: LD_INT 1
1418: EQUAL
1419: IFFALSE 1436
// ComAgressiveMove ( i , 62 , 48 ) ;
1421: LD_VAR 0 1
1425: PPUSH
1426: LD_INT 62
1428: PPUSH
1429: LD_INT 48
1431: PPUSH
1432: CALL_OW 114
// if GetTag ( i ) = 2 then
1436: LD_VAR 0 1
1440: PPUSH
1441: CALL_OW 110
1445: PUSH
1446: LD_INT 2
1448: EQUAL
1449: IFFALSE 1485
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1451: LD_VAR 0 1
1455: PPUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 1
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PPUSH
1466: CALL_OW 69
1470: PPUSH
1471: LD_VAR 0 1
1475: PPUSH
1476: CALL_OW 74
1480: PPUSH
1481: CALL_OW 115
// end ;
1485: GO 1283
1487: POP
1488: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1489: LD_INT 35
1491: PPUSH
1492: CALL_OW 67
1496: LD_INT 1
1498: PUSH
1499: LD_INT 22
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: PUSH
1509: LD_INT 21
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PPUSH
1524: CALL_OW 69
1528: PUSH
1529: LD_INT 10
1531: LESS
1532: PUSH
1533: LD_EXP 13
1537: PPUSH
1538: CALL_OW 301
1542: AND
1543: PUSH
1544: LD_EXP 14
1548: PPUSH
1549: CALL_OW 301
1553: AND
1554: PUSH
1555: LD_EXP 15
1559: PPUSH
1560: CALL_OW 301
1564: AND
1565: PUSH
1566: LD_EXP 16
1570: PPUSH
1571: CALL_OW 301
1575: AND
1576: IFFALSE 1273
// AssaultStarted := false ;
1578: LD_ADDR_EXP 8
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1586: LD_INT 22
1588: PUSH
1589: LD_INT 6
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PPUSH
1596: CALL_OW 69
1600: PPUSH
1601: LD_INT 5
1603: PPUSH
1604: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1608: LD_ADDR_EXP 5
1612: PUSH
1613: LD_INT 1
1615: PUSH
1616: LD_INT 22
1618: PUSH
1619: LD_INT 6
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: PUSH
1626: LD_INT 26
1628: PUSH
1629: LD_INT 1
1631: PUSH
1632: EMPTY
1633: LIST
1634: LIST
1635: PUSH
1636: LD_INT 21
1638: PUSH
1639: LD_INT 1
1641: PUSH
1642: EMPTY
1643: LIST
1644: LIST
1645: PUSH
1646: LD_INT 24
1648: PUSH
1649: LD_INT 500
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: PPUSH
1663: CALL_OW 69
1667: ST_TO_ADDR
// if RuSpeaker then
1668: LD_EXP 5
1672: IFFALSE 1690
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1674: LD_EXP 5
1678: PUSH
1679: LD_INT 1
1681: ARRAY
1682: PPUSH
1683: LD_STRING DRuSol-A2
1685: PPUSH
1686: CALL_OW 88
// wait ( 0 0$30 ) ;
1690: LD_INT 1050
1692: PPUSH
1693: CALL_OW 67
// DialogueOn ;
1697: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1701: LD_EXP 9
1705: PPUSH
1706: LD_STRING DBrighton-B1
1708: PPUSH
1709: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1713: LD_EXP 10
1717: PPUSH
1718: LD_STRING DPalmer-B1
1720: PPUSH
1721: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1725: LD_EXP 9
1729: PPUSH
1730: LD_STRING DBrighton-B2
1732: PPUSH
1733: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1737: LD_EXP 19
1741: PPUSH
1742: LD_STRING DBurlak-B1
1744: PPUSH
1745: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1749: LD_EXP 9
1753: PPUSH
1754: LD_STRING DBrighton-B3
1756: PPUSH
1757: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1761: LD_EXP 10
1765: PPUSH
1766: LD_STRING DPalmer-B2
1768: PPUSH
1769: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1773: LD_EXP 9
1777: PPUSH
1778: LD_STRING DBrighton-B4
1780: PPUSH
1781: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1785: LD_EXP 9
1789: PPUSH
1790: LD_STRING DBrighton-B5
1792: PPUSH
1793: CALL_OW 88
// DialogueOff ;
1797: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1801: LD_STRING C2
1803: PPUSH
1804: CALL_OW 337
// FirstAssaultRepelled := true ;
1808: LD_ADDR_EXP 4
1812: PUSH
1813: LD_INT 1
1815: ST_TO_ADDR
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1816: LD_INT 22
1818: PUSH
1819: LD_INT 6
1821: PUSH
1822: EMPTY
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 69
1830: PPUSH
1831: CALL_OW 181
// end ;
1835: PPOPN 2
1837: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1838: LD_EXP 4
1842: IFFALSE 2007
1844: GO 1846
1846: DISABLE
1847: LD_INT 0
1849: PPUSH
1850: PPUSH
// begin enable ;
1851: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 22
1857: PUSH
1858: LD_INT 6
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: PUSH
1865: EMPTY
1866: LIST
1867: PPUSH
1868: CALL_OW 70
1872: PUSH
1873: LD_INT 0
1875: EQUAL
1876: IFFALSE 1880
// exit ;
1878: GO 2007
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1880: LD_ADDR_VAR 0 1
1884: PUSH
1885: LD_INT 5
1887: PPUSH
1888: LD_INT 22
1890: PUSH
1891: LD_INT 6
1893: PUSH
1894: EMPTY
1895: LIST
1896: LIST
1897: PUSH
1898: EMPTY
1899: LIST
1900: PPUSH
1901: CALL_OW 70
1905: PUSH
1906: FOR_IN
1907: IFFALSE 2005
// begin SetSide ( unit , 3 ) ;
1909: LD_VAR 0 1
1913: PPUSH
1914: LD_INT 3
1916: PPUSH
1917: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1921: LD_VAR 0 1
1925: PPUSH
1926: CALL_OW 247
1930: PUSH
1931: LD_INT 2
1933: EQUAL
1934: IFFALSE 1970
// for insideUnit in UnitsInside ( unit ) do
1936: LD_ADDR_VAR 0 2
1940: PUSH
1941: LD_VAR 0 1
1945: PPUSH
1946: CALL_OW 313
1950: PUSH
1951: FOR_IN
1952: IFFALSE 1968
// SetSide ( insideUnit , 3 ) ;
1954: LD_VAR 0 2
1958: PPUSH
1959: LD_INT 3
1961: PPUSH
1962: CALL_OW 235
1966: GO 1951
1968: POP
1969: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
1970: LD_ADDR_EXP 50
1974: PUSH
1975: LD_EXP 50
1979: PPUSH
1980: LD_INT 1
1982: PPUSH
1983: LD_INT 22
1985: PUSH
1986: LD_INT 3
1988: PUSH
1989: EMPTY
1990: LIST
1991: LIST
1992: PPUSH
1993: CALL_OW 69
1997: PPUSH
1998: CALL_OW 1
2002: ST_TO_ADDR
// end ;
2003: GO 1906
2005: POP
2006: POP
// end ;
2007: PPOPN 2
2009: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2010: LD_EXP 4
2014: PUSH
2015: LD_EXP 41
2019: PUSH
2020: LD_INT 0
2022: GREATER
2023: AND
2024: IFFALSE 2044
2026: GO 2028
2028: DISABLE
// begin enable ;
2029: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2030: LD_ADDR_EXP 41
2034: PUSH
2035: LD_EXP 41
2039: PUSH
2040: LD_INT 35
2042: MINUS
2043: ST_TO_ADDR
// end ;
2044: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2045: LD_EXP 41
2049: PUSH
2050: LD_INT 0
2052: EQUAL
2053: IFFALSE 2159
2055: GO 2057
2057: DISABLE
// begin JMMReinforcement ;
2058: CALL 5047 0 0
// DialogueOn ;
2062: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2066: LD_EXP 37
2070: PPUSH
2071: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2075: LD_EXP 37
2079: PPUSH
2080: LD_STRING DJMM-F1
2082: PPUSH
2083: CALL_OW 88
// if RussiansDefeated then
2087: LD_EXP 44
2091: IFFALSE 2117
// begin AddMedal ( Russians , 1 ) ;
2093: LD_STRING Russians
2095: PPUSH
2096: LD_INT 1
2098: PPUSH
2099: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2103: LD_EXP 9
2107: PPUSH
2108: LD_STRING DBrighton-F1a
2110: PPUSH
2111: CALL_OW 88
// end else
2115: GO 2147
// begin AddMedal ( Russians , - 1 ) ;
2117: LD_STRING Russians
2119: PPUSH
2120: LD_INT 1
2122: NEG
2123: PPUSH
2124: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2128: LD_EXP 9
2132: PPUSH
2133: LD_STRING DBrighton-F1
2135: PPUSH
2136: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2140: LD_STRING C3
2142: PPUSH
2143: CALL_OW 337
// end ; DialogueOff ;
2147: CALL_OW 7
// JMM_Arrived := true ;
2151: LD_ADDR_EXP 6
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// end ;
2159: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2160: LD_EXP 6
2164: PUSH
2165: LD_INT 1
2167: PPUSH
2168: LD_EXP 19
2172: PPUSH
2173: CALL_OW 292
2177: AND
2178: IFFALSE 2207
2180: GO 2182
2182: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2183: LD_EXP 19
2187: PPUSH
2188: LD_STRING DBurlak
2190: PPUSH
2191: CALL_OW 88
// Say ( JMM , DJMM ) ;
2195: LD_EXP 37
2199: PPUSH
2200: LD_STRING DJMM
2202: PPUSH
2203: CALL_OW 88
// end ;
2207: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2208: LD_INT 1
2210: PUSH
2211: LD_INT 22
2213: PUSH
2214: LD_INT 1
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 2
2223: PUSH
2224: LD_INT 34
2226: PUSH
2227: LD_INT 9
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: PUSH
2234: LD_INT 35
2236: PUSH
2237: LD_INT 9
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: PUSH
2259: LD_INT 1
2261: GREATER
2262: IFFALSE 2275
2264: GO 2266
2266: DISABLE
// LaserBuilt := true ;
2267: LD_ADDR_EXP 7
2271: PUSH
2272: LD_INT 1
2274: ST_TO_ADDR
2275: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2276: LD_EXP 8
2280: PUSH
2281: LD_INT 6
2283: PPUSH
2284: LD_INT 1
2286: PUSH
2287: LD_INT 22
2289: PUSH
2290: LD_INT 1
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: PUSH
2297: LD_INT 35
2299: PUSH
2300: LD_INT 9
2302: PUSH
2303: EMPTY
2304: LIST
2305: LIST
2306: PUSH
2307: EMPTY
2308: LIST
2309: LIST
2310: PUSH
2311: EMPTY
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PPUSH
2320: LD_EXP 16
2324: PPUSH
2325: CALL_OW 310
2329: PPUSH
2330: CALL_OW 74
2334: PPUSH
2335: CALL_OW 292
2339: AND
2340: IFFALSE 2369
2342: GO 2344
2344: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2345: LD_EXP 16
2349: PPUSH
2350: LD_STRING DDeath-Vse-2
2352: PPUSH
2353: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2357: LD_EXP 13
2361: PPUSH
2362: LD_STRING DDeath-Yas-2
2364: PPUSH
2365: CALL_OW 88
// end ;
2369: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2370: LD_EXP 1
2374: PUSH
2375: LD_INT 12
2377: PPUSH
2378: LD_INT 1
2380: PPUSH
2381: CALL_OW 287
2385: PUSH
2386: LD_INT 20
2388: LESS
2389: AND
2390: IFFALSE 2432
2392: GO 2394
2394: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2395: LD_INT 1750
2397: PPUSH
2398: LD_INT 4900
2400: PPUSH
2401: CALL_OW 12
2405: PPUSH
2406: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2410: LD_INT 2
2412: PPUSH
2413: LD_INT 5
2415: PPUSH
2416: CALL_OW 12
2420: PPUSH
2421: LD_INT 12
2423: PPUSH
2424: LD_INT 1
2426: PPUSH
2427: CALL_OW 55
// enable ;
2431: ENABLE
// end ;
2432: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2433: LD_INT 17
2435: PPUSH
2436: LD_INT 81
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: EMPTY
2443: LIST
2444: LIST
2445: PPUSH
2446: CALL_OW 70
2450: IFFALSE 2576
2452: GO 2454
2454: DISABLE
2455: LD_INT 0
2457: PPUSH
2458: PPUSH
2459: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2460: LD_ADDR_VAR 0 1
2464: PUSH
2465: LD_INT 17
2467: PPUSH
2468: LD_INT 81
2470: PUSH
2471: LD_INT 1
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 70
2482: PUSH
2483: LD_INT 1
2485: ARRAY
2486: ST_TO_ADDR
// x := GetX ( un ) ;
2487: LD_ADDR_VAR 0 2
2491: PUSH
2492: LD_VAR 0 1
2496: PPUSH
2497: CALL_OW 250
2501: ST_TO_ADDR
// y := GetY ( un ) ;
2502: LD_ADDR_VAR 0 3
2506: PUSH
2507: LD_VAR 0 1
2511: PPUSH
2512: CALL_OW 251
2516: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2517: LD_VAR 0 2
2521: PPUSH
2522: LD_VAR 0 3
2526: PPUSH
2527: LD_INT 1
2529: PPUSH
2530: LD_INT 12
2532: NEG
2533: PPUSH
2534: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2538: LD_VAR 0 1
2542: PPUSH
2543: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2547: LD_EXP 9
2551: PPUSH
2552: LD_STRING DBrighton-E1
2554: PPUSH
2555: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2559: LD_VAR 0 2
2563: PPUSH
2564: LD_VAR 0 3
2568: PPUSH
2569: LD_INT 1
2571: PPUSH
2572: CALL_OW 331
// end ;
2576: PPOPN 3
2578: END
// every 0 0$1 trigger MissionStart do
2579: LD_EXP 1
2583: IFFALSE 2606
2585: GO 2587
2587: DISABLE
// begin enable ;
2588: ENABLE
// display_Strings := [ #tick , tick ] ;
2589: LD_ADDR_OWVAR 47
2593: PUSH
2594: LD_STRING #tick
2596: PUSH
2597: LD_OWVAR 1
2601: PUSH
2602: EMPTY
2603: LIST
2604: LIST
2605: ST_TO_ADDR
// end ; end_of_file
2606: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2607: LD_INT 0
2609: PPUSH
// uc_side := 1 ;
2610: LD_ADDR_OWVAR 20
2614: PUSH
2615: LD_INT 1
2617: ST_TO_ADDR
// hc_class = class_soldier ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 1
2625: ST_TO_ADDR
// uc_nation := nation_american ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_sex = sex_male ;
2634: LD_ADDR_OWVAR 27
2638: PUSH
2639: LD_INT 1
2641: ST_TO_ADDR
// hc_importance = 110 ;
2642: LD_ADDR_OWVAR 32
2646: PUSH
2647: LD_INT 110
2649: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2650: LD_ADDR_OWVAR 30
2654: PUSH
2655: LD_INT 5
2657: PUSH
2658: LD_INT 4
2660: PUSH
2661: LD_INT 5
2663: PUSH
2664: LD_INT 3
2666: PUSH
2667: EMPTY
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2673: LD_ADDR_OWVAR 31
2677: PUSH
2678: LD_INT 9
2680: PUSH
2681: LD_INT 6
2683: PUSH
2684: LD_INT 7
2686: PUSH
2687: LD_INT 6
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: LIST
2695: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2696: LD_ADDR_OWVAR 29
2700: PUSH
2701: LD_INT 12
2703: PUSH
2704: LD_INT 10
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2711: LD_ADDR_OWVAR 26
2715: PUSH
2716: LD_STRING Gerard Brighton
2718: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2719: LD_ADDR_OWVAR 33
2723: PUSH
2724: LD_STRING Beta_Skirmish
2726: ST_TO_ADDR
// hc_face_number := 1 ;
2727: LD_ADDR_OWVAR 34
2731: PUSH
2732: LD_INT 1
2734: ST_TO_ADDR
// Brighton := CreateHuman ;
2735: LD_ADDR_EXP 9
2739: PUSH
2740: CALL_OW 44
2744: ST_TO_ADDR
// uc_nation := nation_american ;
2745: LD_ADDR_OWVAR 21
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// hc_importance = 80 ;
2753: LD_ADDR_OWVAR 32
2757: PUSH
2758: LD_INT 80
2760: ST_TO_ADDR
// hc_sex = sex_male ;
2761: LD_ADDR_OWVAR 27
2765: PUSH
2766: LD_INT 1
2768: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2769: LD_ADDR_OWVAR 30
2773: PUSH
2774: LD_INT 5
2776: PUSH
2777: LD_INT 5
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2792: LD_ADDR_OWVAR 31
2796: PUSH
2797: LD_INT 7
2799: PUSH
2800: LD_INT 6
2802: PUSH
2803: LD_INT 5
2805: PUSH
2806: LD_INT 3
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2815: LD_ADDR_OWVAR 29
2819: PUSH
2820: LD_INT 10
2822: PUSH
2823: LD_INT 10
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: ST_TO_ADDR
// hc_name := Brian Palmer ;
2830: LD_ADDR_OWVAR 26
2834: PUSH
2835: LD_STRING Brian Palmer
2837: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2838: LD_ADDR_OWVAR 33
2842: PUSH
2843: LD_STRING Beta_Skirmish
2845: ST_TO_ADDR
// hc_face_number := 3 ;
2846: LD_ADDR_OWVAR 34
2850: PUSH
2851: LD_INT 3
2853: ST_TO_ADDR
// Palmer := CreateHuman ;
2854: LD_ADDR_EXP 10
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// hc_class = class_scientistic ;
2864: LD_ADDR_OWVAR 28
2868: PUSH
2869: LD_INT 4
2871: ST_TO_ADDR
// uc_nation := nation_american ;
2872: LD_ADDR_OWVAR 21
2876: PUSH
2877: LD_INT 1
2879: ST_TO_ADDR
// hc_importance = 70 ;
2880: LD_ADDR_OWVAR 32
2884: PUSH
2885: LD_INT 70
2887: ST_TO_ADDR
// hc_sex = sex_female ;
2888: LD_ADDR_OWVAR 27
2892: PUSH
2893: LD_INT 2
2895: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2896: LD_ADDR_OWVAR 30
2900: PUSH
2901: LD_INT 3
2903: PUSH
2904: LD_INT 2
2906: PUSH
2907: LD_INT 4
2909: PUSH
2910: LD_INT 6
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2919: LD_ADDR_OWVAR 31
2923: PUSH
2924: LD_INT 4
2926: PUSH
2927: LD_INT 2
2929: PUSH
2930: LD_INT 5
2932: PUSH
2933: LD_INT 8
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2942: LD_ADDR_OWVAR 29
2946: PUSH
2947: LD_INT 10
2949: PUSH
2950: LD_INT 10
2952: PUSH
2953: EMPTY
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// hc_name := Megan Armitage ;
2957: LD_ADDR_OWVAR 26
2961: PUSH
2962: LD_STRING Megan Armitage
2964: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2965: LD_ADDR_OWVAR 33
2969: PUSH
2970: LD_STRING Beta_Skirmish
2972: ST_TO_ADDR
// hc_face_number := 4 ;
2973: LD_ADDR_OWVAR 34
2977: PUSH
2978: LD_INT 4
2980: ST_TO_ADDR
// Megan := CreateHuman ;
2981: LD_ADDR_EXP 11
2985: PUSH
2986: CALL_OW 44
2990: ST_TO_ADDR
// end ;
2991: LD_VAR 0 1
2995: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
2996: LD_INT 0
2998: PPUSH
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
// uc_side := 1 ;
3003: LD_ADDR_OWVAR 20
3007: PUSH
3008: LD_INT 1
3010: ST_TO_ADDR
// uc_nation := nation_american ;
3011: LD_ADDR_OWVAR 21
3015: PUSH
3016: LD_INT 1
3018: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3019: LD_ADDR_VAR 0 2
3023: PUSH
3024: LD_INT 22
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 30
3036: PUSH
3037: LD_INT 32
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PPUSH
3048: CALL_OW 69
3052: PUSH
3053: FOR_IN
3054: IFFALSE 3109
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3056: LD_VAR 0 2
3060: PPUSH
3061: LD_INT 3
3063: PUSH
3064: LD_INT 3
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 5
3072: PUSH
3073: LD_INT 11
3075: PUSH
3076: LD_INT 3
3078: PUSH
3079: LD_INT 4
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 1
3093: PPUSH
3094: LD_INT 7
3096: PPUSH
3097: CALL_OW 12
3101: ARRAY
3102: PPUSH
3103: CALL_OW 431
3107: GO 3053
3109: POP
3110: POP
// hc_name :=  ;
3111: LD_ADDR_OWVAR 26
3115: PUSH
3116: LD_STRING 
3118: ST_TO_ADDR
// hc_gallery :=  ;
3119: LD_ADDR_OWVAR 33
3123: PUSH
3124: LD_STRING 
3126: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3127: LD_ADDR_VAR 0 2
3131: PUSH
3132: DOUBLE
3133: LD_INT 1
3135: DEC
3136: ST_TO_ADDR
3137: LD_INT 6
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 5
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: LIST
3150: PUSH
3151: LD_OWVAR 67
3155: ARRAY
3156: PUSH
3157: FOR_TO
3158: IFFALSE 3216
// begin PrepareSoldier ( 1 , game_skill ) ;
3160: LD_INT 1
3162: PPUSH
3163: LD_EXP 39
3167: PPUSH
3168: CALL_OW 381
// un := CreateHuman ;
3172: LD_ADDR_VAR 0 4
3176: PUSH
3177: CALL_OW 44
3181: ST_TO_ADDR
// filter := filter ^ un ;
3182: LD_ADDR_VAR 0 3
3186: PUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_VAR 0 4
3196: ADD
3197: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3198: LD_ADDR_VAR 0 5
3202: PUSH
3203: LD_VAR 0 5
3207: PUSH
3208: LD_VAR 0 4
3212: ADD
3213: ST_TO_ADDR
// end ;
3214: GO 3157
3216: POP
3217: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: DOUBLE
3224: LD_INT 1
3226: DEC
3227: ST_TO_ADDR
3228: LD_INT 3
3230: PUSH
3231: LD_INT 2
3233: PUSH
3234: LD_INT 2
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PUSH
3242: LD_OWVAR 67
3246: ARRAY
3247: PUSH
3248: FOR_TO
3249: IFFALSE 3303
// begin PrepareEngineer ( 0 , game_skill ) ;
3251: LD_INT 0
3253: PPUSH
3254: LD_EXP 39
3258: PPUSH
3259: CALL_OW 382
// un := CreateHuman ;
3263: LD_ADDR_VAR 0 4
3267: PUSH
3268: CALL_OW 44
3272: ST_TO_ADDR
// filter := filter ^ un ;
3273: LD_ADDR_VAR 0 3
3277: PUSH
3278: LD_VAR 0 3
3282: PUSH
3283: LD_VAR 0 4
3287: ADD
3288: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3289: LD_VAR 0 4
3293: PPUSH
3294: LD_INT 3
3296: PPUSH
3297: CALL_OW 52
// end ;
3301: GO 3248
3303: POP
3304: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3305: LD_ADDR_VAR 0 2
3309: PUSH
3310: DOUBLE
3311: LD_INT 1
3313: DEC
3314: ST_TO_ADDR
3315: LD_INT 4
3317: PUSH
3318: LD_INT 3
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_OWVAR 67
3333: ARRAY
3334: PUSH
3335: FOR_TO
3336: IFFALSE 3390
// begin PrepareMechanic ( 0 , game_skill ) ;
3338: LD_INT 0
3340: PPUSH
3341: LD_EXP 39
3345: PPUSH
3346: CALL_OW 383
// un := CreateHuman ;
3350: LD_ADDR_VAR 0 4
3354: PUSH
3355: CALL_OW 44
3359: ST_TO_ADDR
// filter := filter ^ un ;
3360: LD_ADDR_VAR 0 3
3364: PUSH
3365: LD_VAR 0 3
3369: PUSH
3370: LD_VAR 0 4
3374: ADD
3375: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3376: LD_VAR 0 4
3380: PPUSH
3381: LD_INT 8
3383: PPUSH
3384: CALL_OW 52
// end ;
3388: GO 3335
3390: POP
3391: POP
// for i = 1 to 2 do
3392: LD_ADDR_VAR 0 2
3396: PUSH
3397: DOUBLE
3398: LD_INT 1
3400: DEC
3401: ST_TO_ADDR
3402: LD_INT 2
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareScientist ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 384
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 14
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to soldiers do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_VAR 0 5
3476: PUSH
3477: FOR_TO
3478: IFFALSE 3503
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3480: LD_VAR 0 5
3484: PUSH
3485: LD_VAR 0 2
3489: ARRAY
3490: PPUSH
3491: LD_INT 1
3493: PPUSH
3494: LD_INT 0
3496: PPUSH
3497: CALL_OW 49
3501: GO 3477
3503: POP
3504: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3505: LD_EXP 9
3509: PPUSH
3510: LD_INT 51
3512: PPUSH
3513: LD_INT 43
3515: PPUSH
3516: LD_INT 0
3518: PPUSH
3519: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3523: LD_EXP 10
3527: PPUSH
3528: LD_INT 55
3530: PPUSH
3531: LD_INT 58
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3541: LD_EXP 11
3545: PPUSH
3546: LD_INT 39
3548: PPUSH
3549: LD_INT 36
3551: PPUSH
3552: LD_INT 0
3554: PPUSH
3555: CALL_OW 48
// BetaSquad := filter diff 0 ;
3559: LD_ADDR_EXP 12
3563: PUSH
3564: LD_VAR 0 3
3568: PUSH
3569: LD_INT 0
3571: DIFF
3572: ST_TO_ADDR
// end ;
3573: LD_VAR 0 1
3577: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3578: LD_INT 0
3580: PPUSH
3581: PPUSH
3582: PPUSH
3583: PPUSH
3584: PPUSH
3585: PPUSH
// uc_side := 6 ;
3586: LD_ADDR_OWVAR 20
3590: PUSH
3591: LD_INT 6
3593: ST_TO_ADDR
// uc_nation := nation_russian ;
3594: LD_ADDR_OWVAR 21
3598: PUSH
3599: LD_INT 3
3601: ST_TO_ADDR
// soldiers := [ ] ;
3602: LD_ADDR_VAR 0 4
3606: PUSH
3607: EMPTY
3608: ST_TO_ADDR
// vehs := [ ] ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: EMPTY
3615: ST_TO_ADDR
// RUArmada := [ ] ;
3616: LD_ADDR_EXP 17
3620: PUSH
3621: EMPTY
3622: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3623: LD_ADDR_EXP 13
3627: PUSH
3628: LD_STRING Yashin
3630: PPUSH
3631: CALL_OW 25
3635: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3636: LD_ADDR_EXP 14
3640: PUSH
3641: LD_STRING Popov
3643: PPUSH
3644: CALL_OW 25
3648: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3649: LD_ADDR_EXP 15
3653: PUSH
3654: LD_STRING Gaydar
3656: PPUSH
3657: CALL_OW 25
3661: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3662: LD_ADDR_EXP 16
3666: PUSH
3667: LD_STRING Vsevolod
3669: PPUSH
3670: CALL_OW 25
3674: ST_TO_ADDR
// for i = 1 to 16 do
3675: LD_ADDR_VAR 0 2
3679: PUSH
3680: DOUBLE
3681: LD_INT 1
3683: DEC
3684: ST_TO_ADDR
3685: LD_INT 16
3687: PUSH
3688: FOR_TO
3689: IFFALSE 3731
// begin PrepareSoldier ( 0 , game_eskill ) ;
3691: LD_INT 0
3693: PPUSH
3694: LD_EXP 40
3698: PPUSH
3699: CALL_OW 381
// un := CreateHuman ;
3703: LD_ADDR_VAR 0 5
3707: PUSH
3708: CALL_OW 44
3712: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 4
3722: PUSH
3723: LD_VAR 0 5
3727: ADD
3728: ST_TO_ADDR
// end ;
3729: GO 3688
3731: POP
3732: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: LD_EXP 13
3742: PUSH
3743: LD_EXP 14
3747: ADD
3748: PUSH
3749: LD_EXP 15
3753: ADD
3754: PUSH
3755: LD_EXP 16
3759: ADD
3760: PUSH
3761: LD_VAR 0 4
3765: ADD
3766: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3767: LD_INT 24
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 46
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 18451 0 5
// for i = 1 to 8 do
3786: LD_ADDR_VAR 0 2
3790: PUSH
3791: DOUBLE
3792: LD_INT 1
3794: DEC
3795: ST_TO_ADDR
3796: LD_INT 8
3798: PUSH
3799: FOR_TO
3800: IFFALSE 3883
// begin vehicle := CreateVehicle ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: CALL_OW 45
3811: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3812: LD_VAR 0 4
3816: PUSH
3817: LD_INT 1
3819: ARRAY
3820: PPUSH
3821: LD_VAR 0 3
3825: PPUSH
3826: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3830: LD_ADDR_VAR 0 4
3834: PUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_VAR 0 4
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: DIFF
3849: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3850: LD_VAR 0 3
3854: PPUSH
3855: LD_INT 5
3857: PPUSH
3858: LD_INT 0
3860: PPUSH
3861: CALL_OW 49
// vehs := vehs ^ vehicle ;
3865: LD_ADDR_VAR 0 6
3869: PUSH
3870: LD_VAR 0 6
3874: PUSH
3875: LD_VAR 0 3
3879: ADD
3880: ST_TO_ADDR
// end ;
3881: GO 3799
3883: POP
3884: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3885: LD_INT 24
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: LD_INT 43
3896: PPUSH
3897: LD_INT 100
3899: PPUSH
3900: CALL 18451 0 5
// for i = 1 to 8 do
3904: LD_ADDR_VAR 0 2
3908: PUSH
3909: DOUBLE
3910: LD_INT 1
3912: DEC
3913: ST_TO_ADDR
3914: LD_INT 8
3916: PUSH
3917: FOR_TO
3918: IFFALSE 4001
// begin vehicle := CreateVehicle ;
3920: LD_ADDR_VAR 0 3
3924: PUSH
3925: CALL_OW 45
3929: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3930: LD_VAR 0 4
3934: PUSH
3935: LD_INT 1
3937: ARRAY
3938: PPUSH
3939: LD_VAR 0 3
3943: PPUSH
3944: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3948: LD_ADDR_VAR 0 4
3952: PUSH
3953: LD_VAR 0 4
3957: PUSH
3958: LD_VAR 0 4
3962: PUSH
3963: LD_INT 1
3965: ARRAY
3966: DIFF
3967: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3968: LD_VAR 0 3
3972: PPUSH
3973: LD_INT 5
3975: PPUSH
3976: LD_INT 0
3978: PPUSH
3979: CALL_OW 49
// vehs := vehs ^ vehicle ;
3983: LD_ADDR_VAR 0 6
3987: PUSH
3988: LD_VAR 0 6
3992: PUSH
3993: LD_VAR 0 3
3997: ADD
3998: ST_TO_ADDR
// end ;
3999: GO 3917
4001: POP
4002: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4003: LD_INT 22
4005: PPUSH
4006: LD_INT 3
4008: PPUSH
4009: LD_INT 1
4011: PPUSH
4012: LD_INT 44
4014: PPUSH
4015: LD_INT 100
4017: PPUSH
4018: CALL 18451 0 5
// for i = 1 to 4 do
4022: LD_ADDR_VAR 0 2
4026: PUSH
4027: DOUBLE
4028: LD_INT 1
4030: DEC
4031: ST_TO_ADDR
4032: LD_INT 4
4034: PUSH
4035: FOR_TO
4036: IFFALSE 4119
// begin vehicle := CreateVehicle ;
4038: LD_ADDR_VAR 0 3
4042: PUSH
4043: CALL_OW 45
4047: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4048: LD_VAR 0 4
4052: PUSH
4053: LD_INT 1
4055: ARRAY
4056: PPUSH
4057: LD_VAR 0 3
4061: PPUSH
4062: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4066: LD_ADDR_VAR 0 4
4070: PUSH
4071: LD_VAR 0 4
4075: PUSH
4076: LD_VAR 0 4
4080: PUSH
4081: LD_INT 1
4083: ARRAY
4084: DIFF
4085: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 5
4093: PPUSH
4094: LD_INT 0
4096: PPUSH
4097: CALL_OW 49
// vehs := vehs ^ vehicle ;
4101: LD_ADDR_VAR 0 6
4105: PUSH
4106: LD_VAR 0 6
4110: PUSH
4111: LD_VAR 0 3
4115: ADD
4116: ST_TO_ADDR
// end ;
4117: GO 4035
4119: POP
4120: POP
// RUArmada := vehs ;
4121: LD_ADDR_EXP 17
4125: PUSH
4126: LD_VAR 0 6
4130: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4131: LD_EXP 13
4135: PPUSH
4136: CALL_OW 310
4140: PUSH
4141: LD_EXP 14
4145: PPUSH
4146: CALL_OW 310
4150: PUSH
4151: LD_EXP 15
4155: PPUSH
4156: CALL_OW 310
4160: PUSH
4161: LD_EXP 16
4165: PPUSH
4166: CALL_OW 310
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: LIST
4176: PPUSH
4177: LD_INT 6
4179: NEG
4180: PPUSH
4181: CALL_OW 242
// end ;
4185: LD_VAR 0 1
4189: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4190: LD_INT 0
4192: PPUSH
4193: PPUSH
4194: PPUSH
// uc_side := 6 ;
4195: LD_ADDR_OWVAR 20
4199: PUSH
4200: LD_INT 6
4202: ST_TO_ADDR
// uc_nation := nation_russian ;
4203: LD_ADDR_OWVAR 21
4207: PUSH
4208: LD_INT 3
4210: ST_TO_ADDR
// Bulldozers := [ ] ;
4211: LD_ADDR_EXP 18
4215: PUSH
4216: EMPTY
4217: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4218: LD_INT 24
4220: PPUSH
4221: LD_INT 3
4223: PPUSH
4224: LD_INT 3
4226: PPUSH
4227: LD_INT 53
4229: PPUSH
4230: LD_INT 100
4232: PPUSH
4233: CALL 18451 0 5
// for i = 1 to 2 do
4237: LD_ADDR_VAR 0 2
4241: PUSH
4242: DOUBLE
4243: LD_INT 1
4245: DEC
4246: ST_TO_ADDR
4247: LD_INT 2
4249: PUSH
4250: FOR_TO
4251: IFFALSE 4296
// begin vehicle := CreateVehicle ;
4253: LD_ADDR_VAR 0 3
4257: PUSH
4258: CALL_OW 45
4262: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4263: LD_VAR 0 3
4267: PPUSH
4268: LD_INT 5
4270: PPUSH
4271: LD_INT 0
4273: PPUSH
4274: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4278: LD_ADDR_EXP 18
4282: PUSH
4283: LD_EXP 18
4287: PUSH
4288: LD_VAR 0 3
4292: ADD
4293: ST_TO_ADDR
// end ;
4294: GO 4250
4296: POP
4297: POP
// end ;
4298: LD_VAR 0 1
4302: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4303: LD_INT 0
4305: PPUSH
4306: PPUSH
4307: PPUSH
4308: PPUSH
// uc_side := 3 ;
4309: LD_ADDR_OWVAR 20
4313: PUSH
4314: LD_INT 3
4316: ST_TO_ADDR
// uc_nation := nation_russian ;
4317: LD_ADDR_OWVAR 21
4321: PUSH
4322: LD_INT 3
4324: ST_TO_ADDR
// hc_name :=  ;
4325: LD_ADDR_OWVAR 26
4329: PUSH
4330: LD_STRING 
4332: ST_TO_ADDR
// hc_gallery :=  ;
4333: LD_ADDR_OWVAR 33
4337: PUSH
4338: LD_STRING 
4340: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4341: LD_ADDR_EXP 19
4345: PUSH
4346: LD_STRING Burlak
4348: PPUSH
4349: CALL_OW 25
4353: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4354: LD_ADDR_EXP 20
4358: PUSH
4359: LD_STRING Gleb
4361: PPUSH
4362: CALL_OW 25
4366: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4367: LD_ADDR_EXP 21
4371: PUSH
4372: LD_STRING Furmanov
4374: PPUSH
4375: CALL_OW 25
4379: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4380: LD_ADDR_EXP 22
4384: PUSH
4385: LD_STRING Titov
4387: PPUSH
4388: CALL_OW 25
4392: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4393: LD_ADDR_EXP 23
4397: PUSH
4398: LD_STRING Scholtze
4400: PPUSH
4401: CALL_OW 25
4405: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4406: LD_ADDR_EXP 24
4410: PUSH
4411: LD_STRING Dolgov
4413: PPUSH
4414: CALL_OW 25
4418: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4419: LD_ADDR_EXP 25
4423: PUSH
4424: LD_STRING Kapitsova
4426: PPUSH
4427: CALL_OW 25
4431: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4432: LD_ADDR_EXP 26
4436: PUSH
4437: LD_STRING Karamazov
4439: PPUSH
4440: CALL_OW 25
4444: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4445: LD_ADDR_EXP 27
4449: PUSH
4450: LD_STRING Kirlenkova
4452: PPUSH
4453: CALL_OW 25
4457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4458: LD_ADDR_EXP 28
4462: PUSH
4463: LD_STRING Kovalyuk
4465: PPUSH
4466: CALL_OW 25
4470: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4471: LD_ADDR_EXP 29
4475: PUSH
4476: LD_STRING Kozlov
4478: PPUSH
4479: CALL_OW 25
4483: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4484: LD_ADDR_EXP 30
4488: PUSH
4489: LD_STRING Kuzmov
4491: PPUSH
4492: CALL_OW 25
4496: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4497: LD_ADDR_EXP 31
4501: PUSH
4502: LD_STRING Lipshchin
4504: PPUSH
4505: CALL_OW 25
4509: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4510: LD_ADDR_EXP 32
4514: PUSH
4515: LD_STRING Oblukov
4517: PPUSH
4518: CALL_OW 25
4522: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4523: LD_ADDR_EXP 33
4527: PUSH
4528: LD_STRING Xavier2
4530: PPUSH
4531: CALL_OW 25
4535: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4536: LD_ADDR_EXP 34
4540: PUSH
4541: LD_STRING Gnyevko
4543: PPUSH
4544: CALL_OW 25
4548: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4549: LD_ADDR_EXP 35
4553: PUSH
4554: LD_STRING Belkov
4556: PPUSH
4557: CALL_OW 25
4561: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4562: LD_ADDR_VAR 0 3
4566: PUSH
4567: LD_EXP 19
4571: PUSH
4572: LD_EXP 20
4576: PUSH
4577: LD_EXP 21
4581: PUSH
4582: LD_EXP 22
4586: PUSH
4587: LD_EXP 23
4591: PUSH
4592: LD_EXP 24
4596: PUSH
4597: LD_EXP 25
4601: PUSH
4602: LD_EXP 26
4606: PUSH
4607: LD_EXP 27
4611: PUSH
4612: LD_EXP 28
4616: PUSH
4617: LD_EXP 29
4621: PUSH
4622: LD_EXP 30
4626: PUSH
4627: LD_EXP 31
4631: PUSH
4632: LD_EXP 32
4636: PUSH
4637: LD_EXP 33
4641: PUSH
4642: LD_EXP 34
4646: PUSH
4647: LD_EXP 35
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ST_TO_ADDR
// for i = 1 to filter do
4671: LD_ADDR_VAR 0 2
4675: PUSH
4676: DOUBLE
4677: LD_INT 1
4679: DEC
4680: ST_TO_ADDR
4681: LD_VAR 0 3
4685: PUSH
4686: FOR_TO
4687: IFFALSE 4712
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4689: LD_VAR 0 3
4693: PUSH
4694: LD_VAR 0 2
4698: ARRAY
4699: PPUSH
4700: LD_INT 6
4702: PPUSH
4703: LD_INT 0
4705: PPUSH
4706: CALL_OW 49
4710: GO 4686
4712: POP
4713: POP
// end ;
4714: LD_VAR 0 1
4718: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4719: LD_INT 0
4721: PPUSH
4722: PPUSH
4723: PPUSH
4724: PPUSH
// uc_side := 3 ;
4725: LD_ADDR_OWVAR 20
4729: PUSH
4730: LD_INT 3
4732: ST_TO_ADDR
// uc_nation := nation_russian ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 3
4740: ST_TO_ADDR
// hc_name :=  ;
4741: LD_ADDR_OWVAR 26
4745: PUSH
4746: LD_STRING 
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// for i = 1 to 8 do
4757: LD_ADDR_VAR 0 2
4761: PUSH
4762: DOUBLE
4763: LD_INT 1
4765: DEC
4766: ST_TO_ADDR
4767: LD_INT 8
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4813
// begin PrepareSoldier ( 0 , game_eskill ) ;
4773: LD_INT 0
4775: PPUSH
4776: LD_EXP 40
4780: PPUSH
4781: CALL_OW 381
// un := CreateHuman ;
4785: LD_ADDR_VAR 0 4
4789: PUSH
4790: CALL_OW 44
4794: ST_TO_ADDR
// filter := filter ^ un ;
4795: LD_ADDR_VAR 0 3
4799: PUSH
4800: LD_VAR 0 3
4804: PUSH
4805: LD_VAR 0 4
4809: ADD
4810: ST_TO_ADDR
// end ;
4811: GO 4770
4813: POP
4814: POP
// for i = 1 to 4 do
4815: LD_ADDR_VAR 0 2
4819: PUSH
4820: DOUBLE
4821: LD_INT 1
4823: DEC
4824: ST_TO_ADDR
4825: LD_INT 4
4827: PUSH
4828: FOR_TO
4829: IFFALSE 4871
// begin PrepareEngineer ( 0 , game_eskill ) ;
4831: LD_INT 0
4833: PPUSH
4834: LD_EXP 40
4838: PPUSH
4839: CALL_OW 382
// un := CreateHuman ;
4843: LD_ADDR_VAR 0 4
4847: PUSH
4848: CALL_OW 44
4852: ST_TO_ADDR
// filter := filter ^ un ;
4853: LD_ADDR_VAR 0 3
4857: PUSH
4858: LD_VAR 0 3
4862: PUSH
4863: LD_VAR 0 4
4867: ADD
4868: ST_TO_ADDR
// end ;
4869: GO 4828
4871: POP
4872: POP
// for i = 1 to 6 do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 6
4885: PUSH
4886: FOR_TO
4887: IFFALSE 4929
// begin PrepareMechanic ( 0 , game_eskill ) ;
4889: LD_INT 0
4891: PPUSH
4892: LD_EXP 40
4896: PPUSH
4897: CALL_OW 383
// un := CreateHuman ;
4901: LD_ADDR_VAR 0 4
4905: PUSH
4906: CALL_OW 44
4910: ST_TO_ADDR
// filter := filter ^ un ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_VAR 0 3
4920: PUSH
4921: LD_VAR 0 4
4925: ADD
4926: ST_TO_ADDR
// end ;
4927: GO 4886
4929: POP
4930: POP
// for i = 1 to 4 do
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: DOUBLE
4937: LD_INT 1
4939: DEC
4940: ST_TO_ADDR
4941: LD_INT 4
4943: PUSH
4944: FOR_TO
4945: IFFALSE 4987
// begin PrepareScientist ( 0 , game_eskill ) ;
4947: LD_INT 0
4949: PPUSH
4950: LD_EXP 40
4954: PPUSH
4955: CALL_OW 384
// un := CreateHuman ;
4959: LD_ADDR_VAR 0 4
4963: PUSH
4964: CALL_OW 44
4968: ST_TO_ADDR
// filter := filter ^ un ;
4969: LD_ADDR_VAR 0 3
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: LD_VAR 0 4
4983: ADD
4984: ST_TO_ADDR
// end ;
4985: GO 4944
4987: POP
4988: POP
// for i = 1 to filter do
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: DOUBLE
4995: LD_INT 1
4997: DEC
4998: ST_TO_ADDR
4999: LD_VAR 0 3
5003: PUSH
5004: FOR_TO
5005: IFFALSE 5030
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5007: LD_VAR 0 3
5011: PUSH
5012: LD_VAR 0 2
5016: ARRAY
5017: PPUSH
5018: LD_INT 6
5020: PPUSH
5021: LD_INT 0
5023: PPUSH
5024: CALL_OW 49
5028: GO 5004
5030: POP
5031: POP
// RU_SecondPersonnel := filter ;
5032: LD_ADDR_EXP 36
5036: PUSH
5037: LD_VAR 0 3
5041: ST_TO_ADDR
// end ;
5042: LD_VAR 0 1
5046: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5047: LD_INT 0
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
5055: PPUSH
// uc_side := 1 ;
5056: LD_ADDR_OWVAR 20
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// uc_nation := nation_american ;
5064: LD_ADDR_OWVAR 21
5068: PUSH
5069: LD_INT 1
5071: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5072: LD_ADDR_EXP 37
5076: PUSH
5077: LD_STRING JMM
5079: PPUSH
5080: CALL_OW 25
5084: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5085: LD_EXP 37
5089: PPUSH
5090: LD_INT 1
5092: PPUSH
5093: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5097: LD_EXP 37
5101: PPUSH
5102: LD_INT 7
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 49
// mechs := [ ] ;
5112: LD_ADDR_VAR 0 7
5116: PUSH
5117: EMPTY
5118: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5119: LD_ADDR_VAR 0 2
5123: PUSH
5124: DOUBLE
5125: LD_INT 1
5127: DEC
5128: ST_TO_ADDR
5129: LD_INT 4
5131: PUSH
5132: LD_INT 3
5134: PUSH
5135: LD_INT 3
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_OWVAR 67
5147: ARRAY
5148: PUSH
5149: FOR_TO
5150: IFFALSE 5211
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_EXP 39
5159: PUSH
5160: LD_INT 1
5162: PLUS
5163: PPUSH
5164: CALL_OW 381
// un := CreateHuman ;
5168: LD_ADDR_VAR 0 4
5172: PUSH
5173: CALL_OW 44
5177: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5178: LD_ADDR_VAR 0 3
5182: PUSH
5183: LD_VAR 0 3
5187: PUSH
5188: LD_VAR 0 4
5192: ADD
5193: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5194: LD_VAR 0 4
5198: PPUSH
5199: LD_INT 7
5201: PPUSH
5202: LD_INT 0
5204: PPUSH
5205: CALL_OW 49
// end ;
5209: GO 5149
5211: POP
5212: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5213: LD_ADDR_VAR 0 2
5217: PUSH
5218: DOUBLE
5219: LD_INT 1
5221: DEC
5222: ST_TO_ADDR
5223: LD_INT 7
5225: PUSH
5226: LD_INT 6
5228: PUSH
5229: LD_INT 4
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: LIST
5236: PUSH
5237: LD_OWVAR 67
5241: ARRAY
5242: PUSH
5243: FOR_TO
5244: IFFALSE 5290
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5246: LD_INT 0
5248: PPUSH
5249: LD_EXP 39
5253: PUSH
5254: LD_INT 1
5256: PLUS
5257: PPUSH
5258: CALL_OW 383
// un := CreateHuman ;
5262: LD_ADDR_VAR 0 4
5266: PUSH
5267: CALL_OW 44
5271: ST_TO_ADDR
// mechs := mechs ^ un ;
5272: LD_ADDR_VAR 0 7
5276: PUSH
5277: LD_VAR 0 7
5281: PUSH
5282: LD_VAR 0 4
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5243
5290: POP
5291: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: LD_INT 1
5300: PPUSH
5301: LD_INT 5
5303: PPUSH
5304: LD_INT 100
5306: PPUSH
5307: CALL 18451 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5311: LD_ADDR_VAR 0 2
5315: PUSH
5316: DOUBLE
5317: LD_INT 1
5319: DEC
5320: ST_TO_ADDR
5321: LD_INT 7
5323: PUSH
5324: LD_INT 6
5326: PUSH
5327: LD_INT 4
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: PUSH
5335: LD_OWVAR 67
5339: ARRAY
5340: PUSH
5341: FOR_TO
5342: IFFALSE 5437
// begin vehicle := CreateVehicle ;
5344: LD_ADDR_VAR 0 6
5348: PUSH
5349: CALL_OW 45
5353: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5354: LD_VAR 0 7
5358: PUSH
5359: LD_INT 1
5361: ARRAY
5362: PPUSH
5363: LD_VAR 0 6
5367: PPUSH
5368: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5372: LD_ADDR_VAR 0 7
5376: PUSH
5377: LD_VAR 0 7
5381: PUSH
5382: LD_VAR 0 7
5386: PUSH
5387: LD_INT 1
5389: ARRAY
5390: DIFF
5391: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5392: LD_VAR 0 6
5396: PPUSH
5397: LD_INT 1
5399: PPUSH
5400: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5404: LD_VAR 0 6
5408: PPUSH
5409: LD_INT 7
5411: PPUSH
5412: LD_INT 0
5414: PPUSH
5415: CALL_OW 49
// vehs := vehs ^ vehicle ;
5419: LD_ADDR_VAR 0 5
5423: PUSH
5424: LD_VAR 0 5
5428: PUSH
5429: LD_VAR 0 6
5433: ADD
5434: ST_TO_ADDR
// end ;
5435: GO 5341
5437: POP
5438: POP
// end ; end_of_file
5439: LD_VAR 0 1
5443: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5444: LD_INT 0
5446: PPUSH
5447: PPUSH
5448: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5449: LD_ADDR_OWVAR 67
5453: PUSH
5454: LD_INT 0
5456: PPUSH
5457: CALL_OW 426
5461: ST_TO_ADDR
// game_diff := Difficulty ;
5462: LD_ADDR_EXP 38
5466: PUSH
5467: LD_OWVAR 67
5471: ST_TO_ADDR
// game_skill := [ 7 , 6 , 5 ] [ game_diff ] ;
5472: LD_ADDR_EXP 39
5476: PUSH
5477: LD_INT 7
5479: PUSH
5480: LD_INT 6
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: LD_EXP 38
5495: ARRAY
5496: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5497: LD_ADDR_EXP 40
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: LD_INT 7
5507: PUSH
5508: LD_INT 8
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: LIST
5515: PUSH
5516: LD_EXP 38
5520: ARRAY
5521: ST_TO_ADDR
// ruArrival := [ 3 3$00 , 2 2$00 , 1 1$00 ] [ game_diff ] ;
5522: LD_ADDR_EXP 42
5526: PUSH
5527: LD_INT 6300
5529: PUSH
5530: LD_INT 4200
5532: PUSH
5533: LD_INT 2100
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: LIST
5540: PUSH
5541: LD_EXP 38
5545: ARRAY
5546: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5547: LD_ADDR_EXP 41
5551: PUSH
5552: LD_INT 73500
5554: PUSH
5555: LD_INT 94500
5557: PUSH
5558: LD_INT 115500
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PUSH
5566: LD_EXP 38
5570: ARRAY
5571: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_INT 51
5579: PUSH
5580: EMPTY
5581: LIST
5582: PUSH
5583: LD_INT 51
5585: PUSH
5586: LD_INT 57
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 51
5595: PUSH
5596: LD_INT 52
5598: PUSH
5599: LD_INT 57
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5612: LD_ADDR_EXP 43
5616: PUSH
5617: LD_INT 300
5619: PUSH
5620: LD_INT 350
5622: PUSH
5623: EMPTY
5624: LIST
5625: LIST
5626: PUSH
5627: LD_INT 230
5629: PUSH
5630: LD_INT 200
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PUSH
5637: LD_INT 150
5639: PUSH
5640: LD_INT 100
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_EXP 38
5656: ARRAY
5657: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5658: LD_ADDR_VAR 0 2
5662: PUSH
5663: DOUBLE
5664: LD_INT 1
5666: DEC
5667: ST_TO_ADDR
5668: LD_VAR 0 3
5672: PUSH
5673: LD_EXP 38
5677: ARRAY
5678: PUSH
5679: FOR_TO
5680: IFFALSE 5738
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5682: LD_VAR 0 3
5686: PUSH
5687: LD_EXP 38
5691: ARRAY
5692: PUSH
5693: LD_VAR 0 2
5697: ARRAY
5698: PPUSH
5699: LD_INT 3
5701: PPUSH
5702: LD_INT 2
5704: PPUSH
5705: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5709: LD_VAR 0 3
5713: PUSH
5714: LD_EXP 38
5718: ARRAY
5719: PUSH
5720: LD_VAR 0 2
5724: ARRAY
5725: PPUSH
5726: LD_INT 6
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 322
// end ;
5736: GO 5679
5738: POP
5739: POP
// end ; end_of_file
5740: LD_VAR 0 1
5744: RET
// export function CustomEvent ( event ) ; begin
5745: LD_INT 0
5747: PPUSH
// end ;
5748: LD_VAR 0 2
5752: RET
// export function CustomInitMacro ( ) ; begin
5753: LD_INT 0
5755: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5756: LD_INT 1
5758: PPUSH
5759: LD_INT 3
5761: PPUSH
5762: CALL 80709 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 4
5771: PPUSH
5772: CALL 80653 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5776: LD_INT 1
5778: PPUSH
5779: LD_INT 136
5781: PUSH
5782: LD_INT 130
5784: PUSH
5785: LD_INT 0
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 145
5795: PUSH
5796: LD_INT 123
5798: PUSH
5799: LD_INT 0
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: CALL 79712 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5815: LD_INT 1
5817: PPUSH
5818: LD_INT 43
5820: PUSH
5821: LD_INT 46
5823: PUSH
5824: LD_INT 45
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: PPUSH
5832: CALL 80541 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 3
5841: PPUSH
5842: CALL 80223 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: CALL 79954 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5856: LD_INT 1
5858: PPUSH
5859: LD_INT 8
5861: PPUSH
5862: CALL 79573 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5866: LD_INT 1
5868: PPUSH
5869: LD_INT 22
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 3
5877: PUSH
5878: LD_INT 43
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 22
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 44
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 22
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: LD_INT 45
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 24
5925: PUSH
5926: LD_INT 1
5928: PUSH
5929: LD_INT 3
5931: PUSH
5932: LD_INT 43
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 24
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 3
5949: PUSH
5950: LD_INT 43
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 24
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 46
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: PUSH
5977: LD_INT 22
5979: PUSH
5980: LD_INT 1
5982: PUSH
5983: LD_INT 3
5985: PUSH
5986: LD_INT 43
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: LD_INT 3
6003: PUSH
6004: LD_INT 44
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PPUSH
6023: CALL 79388 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6027: LD_INT 1
6029: PPUSH
6030: LD_INT 0
6032: PUSH
6033: LD_INT 127
6035: PUSH
6036: LD_INT 125
6038: PUSH
6039: LD_INT 5
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 6
6050: PUSH
6051: LD_INT 124
6053: PUSH
6054: LD_INT 132
6056: PUSH
6057: LD_INT 0
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 29
6068: PUSH
6069: LD_INT 136
6071: PUSH
6072: LD_INT 130
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 4
6086: PUSH
6087: LD_INT 118
6089: PUSH
6090: LD_INT 114
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 29
6104: PUSH
6105: LD_INT 145
6107: PUSH
6108: LD_INT 123
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 26
6122: PUSH
6123: LD_INT 150
6125: PUSH
6126: LD_INT 135
6128: PUSH
6129: LD_INT 1
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 26
6140: PUSH
6141: LD_INT 140
6143: PUSH
6144: LD_INT 134
6146: PUSH
6147: LD_INT 2
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_INT 26
6158: PUSH
6159: LD_INT 137
6161: PUSH
6162: LD_INT 121
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 2
6176: PUSH
6177: LD_INT 155
6179: PUSH
6180: LD_INT 130
6182: PUSH
6183: LD_INT 0
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 32
6194: PUSH
6195: LD_INT 155
6197: PUSH
6198: LD_INT 130
6200: PUSH
6201: LD_INT 0
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: LD_INT 130
6215: PUSH
6216: LD_INT 114
6218: PUSH
6219: LD_INT 3
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: PUSH
6228: LD_INT 32
6230: PUSH
6231: LD_INT 142
6233: PUSH
6234: LD_INT 115
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 32
6248: PUSH
6249: LD_INT 153
6251: PUSH
6252: LD_INT 120
6254: PUSH
6255: LD_INT 3
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: LIST
6262: LIST
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: LIST
6278: PPUSH
6279: CALL 79280 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6283: LD_INT 1
6285: PPUSH
6286: LD_INT 10
6288: PUSH
6289: LD_INT 12
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: PPUSH
6296: CALL 80130 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6300: LD_INT 1
6302: PPUSH
6303: LD_INT 155
6305: PPUSH
6306: LD_INT 130
6308: PPUSH
6309: LD_INT 0
6311: PPUSH
6312: LD_INT 24
6314: PUSH
6315: LD_INT 16
6317: PUSH
6318: LD_INT 17
6320: PUSH
6321: LD_INT 18
6323: PUSH
6324: LD_INT 21
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL 80335 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6338: LD_INT 2
6340: PPUSH
6341: LD_INT 3
6343: PPUSH
6344: CALL 80709 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6348: LD_INT 2
6350: PPUSH
6351: LD_INT 4
6353: PPUSH
6354: CALL 80653 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 84
6363: PUSH
6364: LD_INT 125
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: PUSH
6375: EMPTY
6376: LIST
6377: PPUSH
6378: CALL 79712 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6382: LD_INT 2
6384: PPUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 46
6390: PUSH
6391: LD_INT 45
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: LIST
6398: PPUSH
6399: CALL 80541 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6403: LD_INT 2
6405: PPUSH
6406: LD_INT 3
6408: PPUSH
6409: CALL 80223 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6413: LD_INT 2
6415: PPUSH
6416: LD_INT 3
6418: PPUSH
6419: CALL 79954 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6423: LD_INT 2
6425: PPUSH
6426: LD_INT 8
6428: PPUSH
6429: CALL 79573 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6433: LD_INT 2
6435: PPUSH
6436: LD_INT 22
6438: PUSH
6439: LD_INT 3
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: LD_INT 43
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 22
6456: PUSH
6457: LD_INT 3
6459: PUSH
6460: LD_INT 3
6462: PUSH
6463: LD_INT 44
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 22
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 3
6480: PUSH
6481: LD_INT 45
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 24
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 43
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 24
6510: PUSH
6511: LD_INT 3
6513: PUSH
6514: LD_INT 3
6516: PUSH
6517: LD_INT 43
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 24
6528: PUSH
6529: LD_INT 3
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: LD_INT 46
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 22
6546: PUSH
6547: LD_INT 3
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 43
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 22
6564: PUSH
6565: LD_INT 3
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 44
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: PPUSH
6590: CALL 79388 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6594: LD_INT 2
6596: PPUSH
6597: LD_INT 0
6599: PUSH
6600: LD_INT 96
6602: PUSH
6603: LD_INT 125
6605: PUSH
6606: LD_INT 0
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 6
6617: PUSH
6618: LD_INT 74
6620: PUSH
6621: LD_INT 122
6623: PUSH
6624: LD_INT 1
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 30
6635: PUSH
6636: LD_INT 84
6638: PUSH
6639: LD_INT 125
6641: PUSH
6642: LD_INT 1
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: PUSH
6651: LD_INT 28
6653: PUSH
6654: LD_INT 86
6656: PUSH
6657: LD_INT 128
6659: PUSH
6660: LD_INT 1
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_INT 28
6671: PUSH
6672: LD_INT 85
6674: PUSH
6675: LD_INT 130
6677: PUSH
6678: LD_INT 2
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: PUSH
6687: LD_INT 28
6689: PUSH
6690: LD_INT 88
6692: PUSH
6693: LD_INT 132
6695: PUSH
6696: LD_INT 5
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: LIST
6703: LIST
6704: PUSH
6705: LD_INT 2
6707: PUSH
6708: LD_INT 106
6710: PUSH
6711: LD_INT 130
6713: PUSH
6714: LD_INT 0
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 4
6725: PUSH
6726: LD_INT 99
6728: PUSH
6729: LD_INT 114
6731: PUSH
6732: LD_INT 3
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: PUSH
6741: LD_INT 32
6743: PUSH
6744: LD_INT 72
6746: PUSH
6747: LD_INT 112
6749: PUSH
6750: LD_INT 2
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 32
6761: PUSH
6762: LD_INT 78
6764: PUSH
6765: LD_INT 110
6767: PUSH
6768: LD_INT 3
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: PUSH
6777: LD_INT 32
6779: PUSH
6780: LD_INT 84
6782: PUSH
6783: LD_INT 110
6785: PUSH
6786: LD_INT 2
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 32
6797: PUSH
6798: LD_INT 105
6800: PUSH
6801: LD_INT 117
6803: PUSH
6804: LD_INT 3
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: PPUSH
6827: CALL 79280 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6831: LD_INT 2
6833: PPUSH
6834: LD_INT 14
6836: PUSH
6837: LD_INT 11
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: PPUSH
6844: CALL 80130 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6848: LD_INT 2
6850: PPUSH
6851: LD_INT 106
6853: PPUSH
6854: LD_INT 130
6856: PPUSH
6857: LD_INT 0
6859: PPUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 16
6865: PUSH
6866: LD_INT 17
6868: PUSH
6869: LD_INT 18
6871: PUSH
6872: LD_INT 21
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: LIST
6879: LIST
6880: LIST
6881: PPUSH
6882: CALL 80335 0 5
// end ;
6886: LD_VAR 0 1
6890: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6891: LD_INT 22
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 30
6903: PUSH
6904: LD_INT 3
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: IFFALSE 8062
6921: GO 6923
6923: DISABLE
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
6932: LD_INT 6300
6934: PUSH
6935: LD_INT 4200
6937: PUSH
6938: LD_INT 2100
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_OWVAR 67
6950: ARRAY
6951: PPUSH
6952: CALL_OW 67
// base := 2 ;
6956: LD_ADDR_VAR 0 2
6960: PUSH
6961: LD_INT 2
6963: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
6964: LD_INT 22
6966: PUSH
6967: LD_INT 3
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: PUSH
6974: LD_INT 30
6976: PUSH
6977: LD_INT 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PPUSH
6988: CALL_OW 69
6992: NOT
6993: IFFALSE 6997
// continue ;
6995: GO 6932
// case Rand ( 1 , 3 ) of 1 :
6997: LD_INT 1
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 12
7007: PUSH
7008: LD_INT 1
7010: DOUBLE
7011: EQUAL
7012: IFTRUE 7016
7014: GO 7192
7016: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7017: LD_ADDR_VAR 0 3
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 3
7027: PUSH
7028: LD_INT 3
7030: PUSH
7031: LD_INT 43
7033: PUSH
7034: EMPTY
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: PUSH
7040: LD_INT 24
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 3
7048: PUSH
7049: LD_INT 46
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: LIST
7056: LIST
7057: PUSH
7058: LD_INT 24
7060: PUSH
7061: LD_INT 3
7063: PUSH
7064: LD_INT 3
7066: PUSH
7067: LD_INT 43
7069: PUSH
7070: EMPTY
7071: LIST
7072: LIST
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 24
7078: PUSH
7079: LD_INT 3
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: LD_INT 46
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_INT 22
7096: PUSH
7097: LD_INT 3
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 45
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 3
7117: PUSH
7118: LD_INT 3
7120: PUSH
7121: LD_INT 43
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: LIST
7128: LIST
7129: PUSH
7130: LD_INT 24
7132: PUSH
7133: LD_INT 3
7135: PUSH
7136: LD_INT 3
7138: PUSH
7139: LD_INT 46
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_INT 22
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 3
7156: PUSH
7157: LD_INT 45
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: LIST
7164: LIST
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: LIST
7173: LIST
7174: LIST
7175: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_VAR 0 3
7185: PPUSH
7186: CALL 79436 0 2
// end ; 2 :
7190: GO 7523
7192: LD_INT 2
7194: DOUBLE
7195: EQUAL
7196: IFTRUE 7200
7198: GO 7338
7200: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7201: LD_ADDR_VAR 0 3
7205: PUSH
7206: LD_INT 24
7208: PUSH
7209: LD_INT 3
7211: PUSH
7212: LD_INT 3
7214: PUSH
7215: LD_INT 43
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: LIST
7223: PUSH
7224: LD_INT 24
7226: PUSH
7227: LD_INT 3
7229: PUSH
7230: LD_INT 3
7232: PUSH
7233: LD_INT 46
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: PUSH
7242: LD_INT 24
7244: PUSH
7245: LD_INT 3
7247: PUSH
7248: LD_INT 3
7250: PUSH
7251: LD_INT 43
7253: PUSH
7254: EMPTY
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: PUSH
7260: LD_INT 24
7262: PUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 3
7268: PUSH
7269: LD_INT 46
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: PUSH
7278: LD_INT 22
7280: PUSH
7281: LD_INT 3
7283: PUSH
7284: LD_INT 3
7286: PUSH
7287: LD_INT 45
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 22
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 3
7304: PUSH
7305: LD_INT 45
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: LIST
7318: LIST
7319: LIST
7320: LIST
7321: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: LD_VAR 0 3
7331: PPUSH
7332: CALL 79436 0 2
// end ; 3 :
7336: GO 7523
7338: LD_INT 3
7340: DOUBLE
7341: EQUAL
7342: IFTRUE 7346
7344: GO 7522
7346: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7347: LD_ADDR_VAR 0 3
7351: PUSH
7352: LD_INT 22
7354: PUSH
7355: LD_INT 3
7357: PUSH
7358: LD_INT 3
7360: PUSH
7361: LD_INT 43
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 24
7372: PUSH
7373: LD_INT 3
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 46
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 22
7390: PUSH
7391: LD_INT 3
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 43
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 24
7408: PUSH
7409: LD_INT 3
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 46
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_INT 3
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: LD_INT 22
7444: PUSH
7445: LD_INT 3
7447: PUSH
7448: LD_INT 3
7450: PUSH
7451: LD_INT 43
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: LIST
7458: LIST
7459: PUSH
7460: LD_INT 24
7462: PUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 3
7468: PUSH
7469: LD_INT 46
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: PUSH
7478: LD_INT 22
7480: PUSH
7481: LD_INT 3
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 45
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: LIST
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: LIST
7503: LIST
7504: LIST
7505: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7506: LD_VAR 0 2
7510: PPUSH
7511: LD_VAR 0 3
7515: PPUSH
7516: CALL 79436 0 2
// end ; end ;
7520: GO 7523
7522: POP
// repeat wait ( 0 0$1 ) ;
7523: LD_INT 35
7525: PPUSH
7526: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7530: LD_VAR 0 2
7534: PPUSH
7535: CALL 79784 0 1
7539: PUSH
7540: LD_INT 0
7542: EQUAL
7543: IFFALSE 7523
// wait ( 0 0$30 ) ;
7545: LD_INT 1050
7547: PPUSH
7548: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7552: LD_ADDR_VAR 0 5
7556: PUSH
7557: LD_INT 86
7559: PUSH
7560: LD_INT 77
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 63
7569: PUSH
7570: LD_INT 38
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7581: LD_ADDR_VAR 0 4
7585: PUSH
7586: LD_INT 0
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: LD_INT 0
7594: PUSH
7595: LD_INT 1
7597: PUSH
7598: LD_INT 0
7600: PUSH
7601: LD_INT 0
7603: PUSH
7604: LD_INT 0
7606: PUSH
7607: LD_INT 0
7609: PUSH
7610: LD_INT 1
7612: PUSH
7613: LD_INT 0
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: LIST
7626: LIST
7627: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7628: LD_ADDR_VAR 0 6
7632: PUSH
7633: LD_EXP 69
7637: PUSH
7638: LD_VAR 0 2
7642: ARRAY
7643: PUSH
7644: LD_EXP 72
7648: PUSH
7649: LD_VAR 0 2
7653: ARRAY
7654: DIFF
7655: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7656: LD_ADDR_EXP 69
7660: PUSH
7661: LD_EXP 69
7665: PPUSH
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_EXP 69
7675: PUSH
7676: LD_VAR 0 2
7680: ARRAY
7681: PUSH
7682: LD_VAR 0 6
7686: DIFF
7687: PPUSH
7688: CALL_OW 1
7692: ST_TO_ADDR
// if not attackers then
7693: LD_VAR 0 6
7697: NOT
7698: IFFALSE 7702
// continue ;
7700: GO 6932
// repeat wait ( 0 0$1 ) ;
7702: LD_INT 35
7704: PPUSH
7705: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7709: LD_VAR 0 6
7713: PPUSH
7714: LD_INT 60
7716: PUSH
7717: EMPTY
7718: LIST
7719: PPUSH
7720: CALL_OW 72
7724: NOT
7725: IFFALSE 7702
// repeat wait ( 0 0$1 ) ;
7727: LD_INT 35
7729: PPUSH
7730: CALL_OW 67
// for i in attackers do
7734: LD_ADDR_VAR 0 1
7738: PUSH
7739: LD_VAR 0 6
7743: PUSH
7744: FOR_IN
7745: IFFALSE 8029
// begin if IsDead ( i ) then
7747: LD_VAR 0 1
7751: PPUSH
7752: CALL_OW 301
7756: IFFALSE 7774
// attackers := attackers diff i ;
7758: LD_ADDR_VAR 0 6
7762: PUSH
7763: LD_VAR 0 6
7767: PUSH
7768: LD_VAR 0 1
7772: DIFF
7773: ST_TO_ADDR
// if not HasTask ( i ) then
7774: LD_VAR 0 1
7778: PPUSH
7779: CALL_OW 314
7783: NOT
7784: IFFALSE 8027
// begin if not GetTag ( i ) then
7786: LD_VAR 0 1
7790: PPUSH
7791: CALL_OW 110
7795: NOT
7796: IFFALSE 7888
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7798: LD_VAR 0 1
7802: PPUSH
7803: LD_VAR 0 5
7807: PUSH
7808: LD_INT 1
7810: ARRAY
7811: PUSH
7812: LD_INT 1
7814: ARRAY
7815: PPUSH
7816: LD_VAR 0 5
7820: PUSH
7821: LD_INT 1
7823: ARRAY
7824: PUSH
7825: LD_INT 2
7827: ARRAY
7828: PPUSH
7829: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7833: LD_VAR 0 1
7837: PPUSH
7838: LD_VAR 0 5
7842: PUSH
7843: LD_INT 1
7845: ARRAY
7846: PUSH
7847: LD_INT 1
7849: ARRAY
7850: PPUSH
7851: LD_VAR 0 5
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_INT 2
7862: ARRAY
7863: PPUSH
7864: CALL_OW 297
7868: PUSH
7869: LD_INT 8
7871: LESS
7872: IFFALSE 7886
// SetTag ( i , 1 ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_INT 1
7881: PPUSH
7882: CALL_OW 109
// end else
7886: GO 8027
// if GetTag ( i ) = 1 then
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 110
7897: PUSH
7898: LD_INT 1
7900: EQUAL
7901: IFFALSE 7993
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 2
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 2
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
7938: LD_VAR 0 1
7942: PPUSH
7943: LD_VAR 0 5
7947: PUSH
7948: LD_INT 2
7950: ARRAY
7951: PUSH
7952: LD_INT 1
7954: ARRAY
7955: PPUSH
7956: LD_VAR 0 5
7960: PUSH
7961: LD_INT 2
7963: ARRAY
7964: PUSH
7965: LD_INT 2
7967: ARRAY
7968: PPUSH
7969: CALL_OW 297
7973: PUSH
7974: LD_INT 8
7976: LESS
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// end else
7991: GO 8027
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 81
8000: PUSH
8001: LD_INT 3
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PPUSH
8008: CALL_OW 69
8012: PPUSH
8013: LD_VAR 0 1
8017: PPUSH
8018: CALL_OW 74
8022: PPUSH
8023: CALL_OW 115
// end ; end ;
8027: GO 7744
8029: POP
8030: POP
// until not attackers ;
8031: LD_VAR 0 6
8035: NOT
8036: IFFALSE 7727
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8038: LD_EXP 50
8042: PUSH
8043: LD_VAR 0 2
8047: ARRAY
8048: PPUSH
8049: LD_INT 50
8051: PUSH
8052: EMPTY
8053: LIST
8054: PPUSH
8055: CALL_OW 72
8059: NOT
8060: IFFALSE 6932
// end ;
8062: PPOPN 6
8064: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8065: LD_INT 22
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: LD_INT 30
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PPUSH
8089: CALL_OW 69
8093: IFFALSE 9277
8095: GO 8097
8097: DISABLE
8098: LD_INT 0
8100: PPUSH
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8106: LD_INT 6300
8108: PUSH
8109: LD_INT 4200
8111: PUSH
8112: LD_INT 2100
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PPUSH
8126: CALL_OW 67
// base := 1 ;
8130: LD_ADDR_VAR 0 2
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8138: LD_INT 22
8140: PUSH
8141: LD_INT 3
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 30
8150: PUSH
8151: LD_INT 3
8153: PUSH
8154: EMPTY
8155: LIST
8156: LIST
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PPUSH
8162: CALL_OW 69
8166: NOT
8167: IFFALSE 8171
// continue ;
8169: GO 8106
// case Rand ( 1 , 3 ) of 1 :
8171: LD_INT 1
8173: PPUSH
8174: LD_INT 3
8176: PPUSH
8177: CALL_OW 12
8181: PUSH
8182: LD_INT 1
8184: DOUBLE
8185: EQUAL
8186: IFTRUE 8190
8188: GO 8366
8190: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8191: LD_ADDR_VAR 0 3
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 1
8201: PUSH
8202: LD_INT 3
8204: PUSH
8205: LD_INT 43
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 24
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 3
8222: PUSH
8223: LD_INT 46
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: LIST
8230: LIST
8231: PUSH
8232: LD_INT 24
8234: PUSH
8235: LD_INT 1
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: LD_INT 43
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: PUSH
8250: LD_INT 24
8252: PUSH
8253: LD_INT 1
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: LD_INT 46
8261: PUSH
8262: EMPTY
8263: LIST
8264: LIST
8265: LIST
8266: LIST
8267: PUSH
8268: LD_INT 22
8270: PUSH
8271: LD_INT 1
8273: PUSH
8274: LD_INT 3
8276: PUSH
8277: LD_INT 45
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: LIST
8284: LIST
8285: PUSH
8286: LD_INT 22
8288: PUSH
8289: LD_INT 1
8291: PUSH
8292: LD_INT 3
8294: PUSH
8295: LD_INT 43
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: LIST
8302: LIST
8303: PUSH
8304: LD_INT 24
8306: PUSH
8307: LD_INT 1
8309: PUSH
8310: LD_INT 3
8312: PUSH
8313: LD_INT 46
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_INT 22
8324: PUSH
8325: LD_INT 1
8327: PUSH
8328: LD_INT 3
8330: PUSH
8331: LD_INT 45
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: LIST
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: LIST
8349: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_VAR 0 3
8359: PPUSH
8360: CALL 79436 0 2
// end ; 2 :
8364: GO 8735
8366: LD_INT 2
8368: DOUBLE
8369: EQUAL
8370: IFTRUE 8374
8372: GO 8550
8374: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8375: LD_ADDR_VAR 0 3
8379: PUSH
8380: LD_INT 24
8382: PUSH
8383: LD_INT 1
8385: PUSH
8386: LD_INT 3
8388: PUSH
8389: LD_INT 43
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 24
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: LD_INT 3
8406: PUSH
8407: LD_INT 46
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 24
8418: PUSH
8419: LD_INT 1
8421: PUSH
8422: LD_INT 3
8424: PUSH
8425: LD_INT 43
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 24
8436: PUSH
8437: LD_INT 1
8439: PUSH
8440: LD_INT 3
8442: PUSH
8443: LD_INT 46
8445: PUSH
8446: EMPTY
8447: LIST
8448: LIST
8449: LIST
8450: LIST
8451: PUSH
8452: LD_INT 22
8454: PUSH
8455: LD_INT 1
8457: PUSH
8458: LD_INT 3
8460: PUSH
8461: LD_INT 45
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_INT 1
8475: PUSH
8476: LD_INT 3
8478: PUSH
8479: LD_INT 45
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 22
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 3
8496: PUSH
8497: LD_INT 45
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 3
8514: PUSH
8515: LD_INT 45
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL 79436 0 2
// end ; 3 :
8548: GO 8735
8550: LD_INT 3
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8734
8558: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: LD_INT 22
8566: PUSH
8567: LD_INT 1
8569: PUSH
8570: LD_INT 3
8572: PUSH
8573: LD_INT 43
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 24
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: LD_INT 3
8590: PUSH
8591: LD_INT 46
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 22
8602: PUSH
8603: LD_INT 1
8605: PUSH
8606: LD_INT 3
8608: PUSH
8609: LD_INT 43
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_INT 24
8620: PUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: LD_INT 46
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: PUSH
8636: LD_INT 22
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: LD_INT 45
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: PUSH
8654: LD_INT 22
8656: PUSH
8657: LD_INT 1
8659: PUSH
8660: LD_INT 3
8662: PUSH
8663: LD_INT 43
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: LIST
8670: LIST
8671: PUSH
8672: LD_INT 24
8674: PUSH
8675: LD_INT 1
8677: PUSH
8678: LD_INT 3
8680: PUSH
8681: LD_INT 46
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 22
8692: PUSH
8693: LD_INT 1
8695: PUSH
8696: LD_INT 3
8698: PUSH
8699: LD_INT 45
8701: PUSH
8702: EMPTY
8703: LIST
8704: LIST
8705: LIST
8706: LIST
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: LIST
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: LIST
8717: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8718: LD_VAR 0 2
8722: PPUSH
8723: LD_VAR 0 3
8727: PPUSH
8728: CALL 79436 0 2
// end ; end ;
8732: GO 8735
8734: POP
// repeat wait ( 0 0$1 ) ;
8735: LD_INT 35
8737: PPUSH
8738: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8742: LD_VAR 0 2
8746: PPUSH
8747: LD_INT 1
8749: PPUSH
8750: CALL 80854 0 2
8754: PUSH
8755: LD_INT 8
8757: GREATEREQUAL
8758: IFFALSE 8735
// wait ( 0 0$30 ) ;
8760: LD_INT 1050
8762: PPUSH
8763: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8767: LD_ADDR_VAR 0 5
8771: PUSH
8772: LD_INT 144
8774: PUSH
8775: LD_INT 65
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 63
8784: PUSH
8785: LD_INT 38
8787: PUSH
8788: EMPTY
8789: LIST
8790: LIST
8791: PUSH
8792: EMPTY
8793: LIST
8794: LIST
8795: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8796: LD_ADDR_VAR 0 4
8800: PUSH
8801: LD_INT 0
8803: PUSH
8804: LD_INT 0
8806: PUSH
8807: LD_INT 0
8809: PUSH
8810: LD_INT 1
8812: PUSH
8813: LD_INT 0
8815: PUSH
8816: LD_INT 0
8818: PUSH
8819: LD_INT 0
8821: PUSH
8822: LD_INT 0
8824: PUSH
8825: LD_INT 1
8827: PUSH
8828: LD_INT 0
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: LIST
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: LIST
8842: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8843: LD_ADDR_VAR 0 6
8847: PUSH
8848: LD_EXP 69
8852: PUSH
8853: LD_VAR 0 2
8857: ARRAY
8858: PUSH
8859: LD_EXP 72
8863: PUSH
8864: LD_VAR 0 2
8868: ARRAY
8869: DIFF
8870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8871: LD_ADDR_EXP 69
8875: PUSH
8876: LD_EXP 69
8880: PPUSH
8881: LD_VAR 0 2
8885: PPUSH
8886: LD_EXP 69
8890: PUSH
8891: LD_VAR 0 2
8895: ARRAY
8896: PUSH
8897: LD_VAR 0 6
8901: DIFF
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// if not attackers then
8908: LD_VAR 0 6
8912: NOT
8913: IFFALSE 8917
// continue ;
8915: GO 8106
// repeat wait ( 0 0$1 ) ;
8917: LD_INT 35
8919: PPUSH
8920: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8924: LD_VAR 0 6
8928: PPUSH
8929: LD_INT 60
8931: PUSH
8932: EMPTY
8933: LIST
8934: PPUSH
8935: CALL_OW 72
8939: NOT
8940: IFFALSE 8917
// repeat wait ( 0 0$1 ) ;
8942: LD_INT 35
8944: PPUSH
8945: CALL_OW 67
// for i in attackers do
8949: LD_ADDR_VAR 0 1
8953: PUSH
8954: LD_VAR 0 6
8958: PUSH
8959: FOR_IN
8960: IFFALSE 9244
// begin if IsDead ( i ) then
8962: LD_VAR 0 1
8966: PPUSH
8967: CALL_OW 301
8971: IFFALSE 8989
// attackers := attackers diff i ;
8973: LD_ADDR_VAR 0 6
8977: PUSH
8978: LD_VAR 0 6
8982: PUSH
8983: LD_VAR 0 1
8987: DIFF
8988: ST_TO_ADDR
// if not HasTask ( i ) then
8989: LD_VAR 0 1
8993: PPUSH
8994: CALL_OW 314
8998: NOT
8999: IFFALSE 9242
// begin if not GetTag ( i ) then
9001: LD_VAR 0 1
9005: PPUSH
9006: CALL_OW 110
9010: NOT
9011: IFFALSE 9103
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9013: LD_VAR 0 1
9017: PPUSH
9018: LD_VAR 0 5
9022: PUSH
9023: LD_INT 1
9025: ARRAY
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_VAR 0 5
9035: PUSH
9036: LD_INT 1
9038: ARRAY
9039: PUSH
9040: LD_INT 2
9042: ARRAY
9043: PPUSH
9044: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9048: LD_VAR 0 1
9052: PPUSH
9053: LD_VAR 0 5
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PUSH
9062: LD_INT 1
9064: ARRAY
9065: PPUSH
9066: LD_VAR 0 5
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PUSH
9075: LD_INT 2
9077: ARRAY
9078: PPUSH
9079: CALL_OW 297
9083: PUSH
9084: LD_INT 8
9086: LESS
9087: IFFALSE 9101
// SetTag ( i , 1 ) ;
9089: LD_VAR 0 1
9093: PPUSH
9094: LD_INT 1
9096: PPUSH
9097: CALL_OW 109
// end else
9101: GO 9242
// if GetTag ( i ) = 1 then
9103: LD_VAR 0 1
9107: PPUSH
9108: CALL_OW 110
9112: PUSH
9113: LD_INT 1
9115: EQUAL
9116: IFFALSE 9208
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 2
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 2
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9153: LD_VAR 0 1
9157: PPUSH
9158: LD_VAR 0 5
9162: PUSH
9163: LD_INT 2
9165: ARRAY
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 5
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PUSH
9180: LD_INT 2
9182: ARRAY
9183: PPUSH
9184: CALL_OW 297
9188: PUSH
9189: LD_INT 8
9191: LESS
9192: IFFALSE 9206
// SetTag ( i , 2 ) ;
9194: LD_VAR 0 1
9198: PPUSH
9199: LD_INT 2
9201: PPUSH
9202: CALL_OW 109
// end else
9206: GO 9242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9208: LD_VAR 0 1
9212: PPUSH
9213: LD_INT 81
9215: PUSH
9216: LD_INT 3
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PPUSH
9223: CALL_OW 69
9227: PPUSH
9228: LD_VAR 0 1
9232: PPUSH
9233: CALL_OW 74
9237: PPUSH
9238: CALL_OW 115
// end ; end ;
9242: GO 8959
9244: POP
9245: POP
// until not attackers ;
9246: LD_VAR 0 6
9250: NOT
9251: IFFALSE 8942
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9253: LD_EXP 50
9257: PUSH
9258: LD_VAR 0 2
9262: ARRAY
9263: PPUSH
9264: LD_INT 50
9266: PUSH
9267: EMPTY
9268: LIST
9269: PPUSH
9270: CALL_OW 72
9274: NOT
9275: IFFALSE 8106
// end ;
9277: PPOPN 6
9279: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9280: LD_EXP 4
9284: PUSH
9285: LD_INT 22
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 21
9297: PUSH
9298: LD_INT 1
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PUSH
9314: LD_INT 0
9316: EQUAL
9317: AND
9318: IFFALSE 9331
9320: GO 9322
9322: DISABLE
// RussiansDefeated := true ;
9323: LD_ADDR_EXP 44
9327: PUSH
9328: LD_INT 1
9330: ST_TO_ADDR
9331: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9332: LD_EXP 4
9336: PUSH
9337: LD_EXP 6
9341: NOT
9342: AND
9343: IFFALSE 10767
9345: GO 9347
9347: DISABLE
9348: LD_INT 0
9350: PPUSH
9351: PPUSH
9352: PPUSH
9353: PPUSH
9354: PPUSH
9355: PPUSH
9356: PPUSH
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
9361: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9362: LD_INT 8400
9364: PPUSH
9365: LD_INT 9450
9367: PPUSH
9368: CALL_OW 12
9372: PUSH
9373: LD_INT 9450
9375: PPUSH
9376: LD_INT 7350
9378: PPUSH
9379: CALL_OW 12
9383: PUSH
9384: LD_INT 6300
9386: PPUSH
9387: LD_INT 4200
9389: PPUSH
9390: CALL_OW 12
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: LIST
9399: PUSH
9400: LD_OWVAR 67
9404: ARRAY
9405: PPUSH
9406: CALL_OW 67
// filter := [ ] ;
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: EMPTY
9416: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: LD_INT 2
9424: PPUSH
9425: LD_INT 3
9427: PPUSH
9428: CALL_OW 12
9432: PUSH
9433: LD_INT 3
9435: PPUSH
9436: LD_INT 4
9438: PPUSH
9439: CALL_OW 12
9443: PUSH
9444: LD_INT 3
9446: PPUSH
9447: LD_INT 5
9449: PPUSH
9450: CALL_OW 12
9454: PUSH
9455: EMPTY
9456: LIST
9457: LIST
9458: LIST
9459: PUSH
9460: LD_OWVAR 67
9464: ARRAY
9465: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 1
9473: PUSH
9474: LD_INT 1
9476: PPUSH
9477: LD_INT 2
9479: PPUSH
9480: CALL_OW 12
9484: PUSH
9485: LD_INT 2
9487: PPUSH
9488: LD_INT 3
9490: PPUSH
9491: CALL_OW 12
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: LIST
9500: PUSH
9501: LD_OWVAR 67
9505: ARRAY
9506: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9507: LD_ADDR_VAR 0 6
9511: PUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 3
9517: PPUSH
9518: CALL_OW 12
9522: PUSH
9523: LD_INT 2
9525: PPUSH
9526: LD_INT 4
9528: PPUSH
9529: CALL_OW 12
9533: PUSH
9534: LD_INT 3
9536: PPUSH
9537: LD_INT 5
9539: PPUSH
9540: CALL_OW 12
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: LIST
9549: PUSH
9550: LD_OWVAR 67
9554: ARRAY
9555: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9556: LD_ADDR_VAR 0 8
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 2
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: LD_OWVAR 67
9579: ARRAY
9580: ST_TO_ADDR
// uc_side := 3 ;
9581: LD_ADDR_OWVAR 20
9585: PUSH
9586: LD_INT 3
9588: ST_TO_ADDR
// uc_nation := nation_russian ;
9589: LD_ADDR_OWVAR 21
9593: PUSH
9594: LD_INT 3
9596: ST_TO_ADDR
// for i = 1 to soldiers do
9597: LD_ADDR_VAR 0 1
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_VAR 0 4
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9655
// begin PrepareSoldier ( 0 , game_eskill ) ;
9615: LD_INT 0
9617: PPUSH
9618: LD_EXP 40
9622: PPUSH
9623: CALL_OW 381
// un := CreateHuman ;
9627: LD_ADDR_VAR 0 2
9631: PUSH
9632: CALL_OW 44
9636: ST_TO_ADDR
// filter := filter ^ un ;
9637: LD_ADDR_VAR 0 3
9641: PUSH
9642: LD_VAR 0 3
9646: PUSH
9647: LD_VAR 0 2
9651: ADD
9652: ST_TO_ADDR
// end ;
9653: GO 9612
9655: POP
9656: POP
// for i = 1 to bazookas do
9657: LD_ADDR_VAR 0 1
9661: PUSH
9662: DOUBLE
9663: LD_INT 1
9665: DEC
9666: ST_TO_ADDR
9667: LD_VAR 0 5
9671: PUSH
9672: FOR_TO
9673: IFFALSE 9723
// begin PrepareSoldier ( 0 , game_eskill ) ;
9675: LD_INT 0
9677: PPUSH
9678: LD_EXP 40
9682: PPUSH
9683: CALL_OW 381
// hc_class := class_bazooker ;
9687: LD_ADDR_OWVAR 28
9691: PUSH
9692: LD_INT 9
9694: ST_TO_ADDR
// un := CreateHuman ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: CALL_OW 44
9704: ST_TO_ADDR
// filter := filter ^ un ;
9705: LD_ADDR_VAR 0 3
9709: PUSH
9710: LD_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: ADD
9720: ST_TO_ADDR
// end ;
9721: GO 9672
9723: POP
9724: POP
// for i = 1 to medics do
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: DOUBLE
9731: LD_INT 1
9733: DEC
9734: ST_TO_ADDR
9735: LD_VAR 0 8
9739: PUSH
9740: FOR_TO
9741: IFFALSE 9783
// begin PrepareScientist ( 0 , game_eskill ) ;
9743: LD_INT 0
9745: PPUSH
9746: LD_EXP 40
9750: PPUSH
9751: CALL_OW 384
// un := CreateHuman ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: CALL_OW 44
9764: ST_TO_ADDR
// filter := filter ^ un ;
9765: LD_ADDR_VAR 0 3
9769: PUSH
9770: LD_VAR 0 3
9774: PUSH
9775: LD_VAR 0 2
9779: ADD
9780: ST_TO_ADDR
// end ;
9781: GO 9740
9783: POP
9784: POP
// for i = 1 to vehs do
9785: LD_ADDR_VAR 0 1
9789: PUSH
9790: DOUBLE
9791: LD_INT 1
9793: DEC
9794: ST_TO_ADDR
9795: LD_VAR 0 6
9799: PUSH
9800: FOR_TO
9801: IFFALSE 9993
// begin case Rand ( 1 , 5 ) of 1 :
9803: LD_INT 1
9805: PPUSH
9806: LD_INT 5
9808: PPUSH
9809: CALL_OW 12
9813: PUSH
9814: LD_INT 1
9816: DOUBLE
9817: EQUAL
9818: IFTRUE 9822
9820: GO 9844
9822: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9823: LD_INT 22
9825: PPUSH
9826: LD_INT 3
9828: PPUSH
9829: LD_INT 3
9831: PPUSH
9832: LD_INT 43
9834: PPUSH
9835: LD_INT 100
9837: PPUSH
9838: CALL 18451 0 5
9842: GO 9965
9844: LD_INT 2
9846: DOUBLE
9847: EQUAL
9848: IFTRUE 9852
9850: GO 9874
9852: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9853: LD_INT 22
9855: PPUSH
9856: LD_INT 3
9858: PPUSH
9859: LD_INT 3
9861: PPUSH
9862: LD_INT 44
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL 18451 0 5
9872: GO 9965
9874: LD_INT 3
9876: DOUBLE
9877: EQUAL
9878: IFTRUE 9882
9880: GO 9904
9882: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9883: LD_INT 22
9885: PPUSH
9886: LD_INT 3
9888: PPUSH
9889: LD_INT 3
9891: PPUSH
9892: LD_INT 45
9894: PPUSH
9895: LD_INT 100
9897: PPUSH
9898: CALL 18451 0 5
9902: GO 9965
9904: LD_INT 4
9906: DOUBLE
9907: EQUAL
9908: IFTRUE 9912
9910: GO 9934
9912: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9913: LD_INT 24
9915: PPUSH
9916: LD_INT 3
9918: PPUSH
9919: LD_INT 3
9921: PPUSH
9922: LD_INT 43
9924: PPUSH
9925: LD_INT 100
9927: PPUSH
9928: CALL 18451 0 5
9932: GO 9965
9934: LD_INT 5
9936: DOUBLE
9937: EQUAL
9938: IFTRUE 9942
9940: GO 9964
9942: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
9943: LD_INT 24
9945: PPUSH
9946: LD_INT 3
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 46
9954: PPUSH
9955: LD_INT 100
9957: PPUSH
9958: CALL 18451 0 5
9962: GO 9965
9964: POP
// vehicle := CreateVehicle ;
9965: LD_ADDR_VAR 0 7
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// filter := filter ^ vehicle ;
9975: LD_ADDR_VAR 0 3
9979: PUSH
9980: LD_VAR 0 3
9984: PUSH
9985: LD_VAR 0 7
9989: ADD
9990: ST_TO_ADDR
// end ;
9991: GO 9800
9993: POP
9994: POP
// for i = 1 to filter do
9995: LD_ADDR_VAR 0 1
9999: PUSH
10000: DOUBLE
10001: LD_INT 1
10003: DEC
10004: ST_TO_ADDR
10005: LD_VAR 0 3
10009: PUSH
10010: FOR_TO
10011: IFFALSE 10036
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10013: LD_VAR 0 3
10017: PUSH
10018: LD_VAR 0 1
10022: ARRAY
10023: PPUSH
10024: LD_INT 14
10026: PPUSH
10027: LD_INT 0
10029: PPUSH
10030: CALL_OW 49
10034: GO 10010
10036: POP
10037: POP
// case Rand ( 1 , 3 ) of 1 :
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 3
10043: PPUSH
10044: CALL_OW 12
10048: PUSH
10049: LD_INT 1
10051: DOUBLE
10052: EQUAL
10053: IFTRUE 10057
10055: GO 10111
10057: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10058: LD_ADDR_VAR 0 11
10062: PUSH
10063: LD_INT 165
10065: PUSH
10066: LD_INT 114
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: PUSH
10073: LD_INT 104
10075: PUSH
10076: LD_INT 108
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PUSH
10083: LD_INT 86
10085: PUSH
10086: LD_INT 77
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PUSH
10093: LD_INT 63
10095: PUSH
10096: LD_INT 38
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: EMPTY
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: ST_TO_ADDR
10109: GO 10236
10111: LD_INT 2
10113: DOUBLE
10114: EQUAL
10115: IFTRUE 10119
10117: GO 10173
10119: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10120: LD_ADDR_VAR 0 11
10124: PUSH
10125: LD_INT 165
10127: PUSH
10128: LD_INT 114
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 146
10137: PUSH
10138: LD_INT 71
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: LD_INT 112
10147: PUSH
10148: LD_INT 41
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: PUSH
10155: LD_INT 63
10157: PUSH
10158: LD_INT 38
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: LIST
10169: LIST
10170: ST_TO_ADDR
10171: GO 10236
10173: LD_INT 3
10175: DOUBLE
10176: EQUAL
10177: IFTRUE 10181
10179: GO 10235
10181: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10182: LD_ADDR_VAR 0 11
10186: PUSH
10187: LD_INT 165
10189: PUSH
10190: LD_INT 114
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 63
10199: PUSH
10200: LD_INT 99
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 55
10209: PUSH
10210: LD_INT 77
10212: PUSH
10213: EMPTY
10214: LIST
10215: LIST
10216: PUSH
10217: LD_INT 63
10219: PUSH
10220: LD_INT 38
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: LIST
10231: LIST
10232: ST_TO_ADDR
10233: GO 10236
10235: POP
// attackers := filter ;
10236: LD_ADDR_VAR 0 10
10240: PUSH
10241: LD_VAR 0 3
10245: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// for i in attackers do
10253: LD_ADDR_VAR 0 1
10257: PUSH
10258: LD_VAR 0 10
10262: PUSH
10263: FOR_IN
10264: IFFALSE 10758
// begin if IsDead ( i ) then
10266: LD_VAR 0 1
10270: PPUSH
10271: CALL_OW 301
10275: IFFALSE 10293
// attackers := attackers diff i ;
10277: LD_ADDR_VAR 0 10
10281: PUSH
10282: LD_VAR 0 10
10286: PUSH
10287: LD_VAR 0 1
10291: DIFF
10292: ST_TO_ADDR
// if not HasTask ( i ) then
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 314
10302: NOT
10303: IFFALSE 10756
// begin if not GetTag ( i ) then
10305: LD_VAR 0 1
10309: PPUSH
10310: CALL_OW 110
10314: NOT
10315: IFFALSE 10407
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10317: LD_VAR 0 1
10321: PPUSH
10322: LD_VAR 0 11
10326: PUSH
10327: LD_INT 1
10329: ARRAY
10330: PUSH
10331: LD_INT 1
10333: ARRAY
10334: PPUSH
10335: LD_VAR 0 11
10339: PUSH
10340: LD_INT 1
10342: ARRAY
10343: PUSH
10344: LD_INT 2
10346: ARRAY
10347: PPUSH
10348: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 11
10361: PUSH
10362: LD_INT 1
10364: ARRAY
10365: PUSH
10366: LD_INT 1
10368: ARRAY
10369: PPUSH
10370: LD_VAR 0 11
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PUSH
10379: LD_INT 2
10381: ARRAY
10382: PPUSH
10383: CALL_OW 297
10387: PUSH
10388: LD_INT 8
10390: LESS
10391: IFFALSE 10405
// SetTag ( i , 1 ) ;
10393: LD_VAR 0 1
10397: PPUSH
10398: LD_INT 1
10400: PPUSH
10401: CALL_OW 109
// end else
10405: GO 10756
// if GetTag ( i ) = 1 then
10407: LD_VAR 0 1
10411: PPUSH
10412: CALL_OW 110
10416: PUSH
10417: LD_INT 1
10419: EQUAL
10420: IFFALSE 10512
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 2
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 2
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10457: LD_VAR 0 1
10461: PPUSH
10462: LD_VAR 0 11
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PUSH
10471: LD_INT 1
10473: ARRAY
10474: PPUSH
10475: LD_VAR 0 11
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PUSH
10484: LD_INT 2
10486: ARRAY
10487: PPUSH
10488: CALL_OW 297
10492: PUSH
10493: LD_INT 8
10495: LESS
10496: IFFALSE 10510
// SetTag ( i , 2 ) ;
10498: LD_VAR 0 1
10502: PPUSH
10503: LD_INT 2
10505: PPUSH
10506: CALL_OW 109
// end else
10510: GO 10756
// if GetTag ( i ) = 2 then
10512: LD_VAR 0 1
10516: PPUSH
10517: CALL_OW 110
10521: PUSH
10522: LD_INT 2
10524: EQUAL
10525: IFFALSE 10617
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 3
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 3
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10562: LD_VAR 0 1
10566: PPUSH
10567: LD_VAR 0 11
10571: PUSH
10572: LD_INT 3
10574: ARRAY
10575: PUSH
10576: LD_INT 1
10578: ARRAY
10579: PPUSH
10580: LD_VAR 0 11
10584: PUSH
10585: LD_INT 3
10587: ARRAY
10588: PUSH
10589: LD_INT 2
10591: ARRAY
10592: PPUSH
10593: CALL_OW 297
10597: PUSH
10598: LD_INT 8
10600: LESS
10601: IFFALSE 10615
// SetTag ( i , 3 ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: LD_INT 3
10610: PPUSH
10611: CALL_OW 109
// end else
10615: GO 10756
// if GetTag ( i ) = 3 then
10617: LD_VAR 0 1
10621: PPUSH
10622: CALL_OW 110
10626: PUSH
10627: LD_INT 3
10629: EQUAL
10630: IFFALSE 10722
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 4
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 4
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10667: LD_VAR 0 1
10671: PPUSH
10672: LD_VAR 0 11
10676: PUSH
10677: LD_INT 4
10679: ARRAY
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PPUSH
10685: LD_VAR 0 11
10689: PUSH
10690: LD_INT 4
10692: ARRAY
10693: PUSH
10694: LD_INT 2
10696: ARRAY
10697: PPUSH
10698: CALL_OW 297
10702: PUSH
10703: LD_INT 8
10705: LESS
10706: IFFALSE 10720
// SetTag ( i , 4 ) ;
10708: LD_VAR 0 1
10712: PPUSH
10713: LD_INT 4
10715: PPUSH
10716: CALL_OW 109
// end else
10720: GO 10756
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_INT 81
10729: PUSH
10730: LD_INT 3
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PPUSH
10737: CALL_OW 69
10741: PPUSH
10742: LD_VAR 0 1
10746: PPUSH
10747: CALL_OW 74
10751: PPUSH
10752: CALL_OW 115
// end ; end ;
10756: GO 10263
10758: POP
10759: POP
// until not attackers ;
10760: LD_VAR 0 10
10764: NOT
10765: IFFALSE 10246
// end ;
10767: PPOPN 12
10769: END
// every 0 0$1 do var i , tmp ;
10770: GO 10772
10772: DISABLE
10773: LD_INT 0
10775: PPUSH
10776: PPUSH
// begin enable ;
10777: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10778: LD_ADDR_VAR 0 2
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: LD_INT 22
10788: PUSH
10789: LD_INT 1
10791: PUSH
10792: EMPTY
10793: LIST
10794: LIST
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 32
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: ST_TO_ADDR
// if tmp then
10819: LD_VAR 0 2
10823: IFFALSE 10869
// for i in tmp do
10825: LD_ADDR_VAR 0 1
10829: PUSH
10830: LD_VAR 0 2
10834: PUSH
10835: FOR_IN
10836: IFFALSE 10867
// if GetFuel ( i ) < 3 then
10838: LD_VAR 0 1
10842: PPUSH
10843: CALL_OW 261
10847: PUSH
10848: LD_INT 3
10850: LESS
10851: IFFALSE 10865
// SetFuel ( i , 3 ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_INT 3
10860: PPUSH
10861: CALL_OW 240
10865: GO 10835
10867: POP
10868: POP
// end ;
10869: PPOPN 2
10871: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10872: LD_INT 3
10874: PPUSH
10875: LD_INT 22
10877: PUSH
10878: LD_INT 1
10880: PUSH
10881: EMPTY
10882: LIST
10883: LIST
10884: PPUSH
10885: CALL_OW 70
10889: PUSH
10890: LD_EXP 41
10894: NOT
10895: AND
10896: PUSH
10897: LD_INT 10
10899: PPUSH
10900: LD_INT 22
10902: PUSH
10903: LD_INT 1
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PPUSH
10910: CALL_OW 70
10914: PUSH
10915: LD_EXP 4
10919: NOT
10920: AND
10921: OR
10922: IFFALSE 10931
10924: GO 10926
10926: DISABLE
// Antirush ;
10927: CALL 10932 0 0
10931: END
// export function Antirush ; var i , veh , tmp , num ; begin
10932: LD_INT 0
10934: PPUSH
10935: PPUSH
10936: PPUSH
10937: PPUSH
10938: PPUSH
// tmp := [ ] ;
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: EMPTY
10945: ST_TO_ADDR
// if not FirstAssaultRepelled then
10946: LD_EXP 4
10950: NOT
10951: IFFALSE 10963
// num := 12 else
10953: LD_ADDR_VAR 0 5
10957: PUSH
10958: LD_INT 12
10960: ST_TO_ADDR
10961: GO 10971
// num := 10 ;
10963: LD_ADDR_VAR 0 5
10967: PUSH
10968: LD_INT 10
10970: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
10971: LD_ADDR_VAR 0 5
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: LD_INT 4
10983: PUSH
10984: LD_INT 2
10986: PUSH
10987: LD_INT 0
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PUSH
10995: LD_OWVAR 67
10999: ARRAY
11000: MINUS
11001: ST_TO_ADDR
// for i := 1 to num do
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: DOUBLE
11008: LD_INT 1
11010: DEC
11011: ST_TO_ADDR
11012: LD_VAR 0 5
11016: PUSH
11017: FOR_TO
11018: IFFALSE 11157
// begin uc_side := 3 ;
11020: LD_ADDR_OWVAR 20
11024: PUSH
11025: LD_INT 3
11027: ST_TO_ADDR
// uc_nation := 3 ;
11028: LD_ADDR_OWVAR 21
11032: PUSH
11033: LD_INT 3
11035: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11036: LD_INT 23
11038: PPUSH
11039: LD_INT 3
11041: PPUSH
11042: LD_INT 3
11044: PPUSH
11045: LD_INT 46
11047: PUSH
11048: LD_INT 43
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: PUSH
11055: LD_INT 1
11057: PPUSH
11058: LD_INT 2
11060: PPUSH
11061: CALL_OW 12
11065: ARRAY
11066: PPUSH
11067: LD_INT 100
11069: PPUSH
11070: CALL 18451 0 5
// veh := CreateVehicle ;
11074: LD_ADDR_VAR 0 3
11078: PUSH
11079: CALL_OW 45
11083: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11084: LD_VAR 0 3
11088: PPUSH
11089: LD_INT 5
11091: PPUSH
11092: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11096: LD_VAR 0 3
11100: PPUSH
11101: LD_INT 199
11103: PPUSH
11104: LD_INT 135
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: LD_INT 0
11112: PPUSH
11113: CALL_OW 50
// tmp := tmp ^ veh ;
11117: LD_ADDR_VAR 0 4
11121: PUSH
11122: LD_VAR 0 4
11126: PUSH
11127: LD_VAR 0 3
11131: ADD
11132: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11133: LD_VAR 0 3
11137: PPUSH
11138: LD_INT 173
11140: PPUSH
11141: LD_INT 118
11143: PPUSH
11144: CALL_OW 111
// wait ( 0 0$2 ) ;
11148: LD_INT 70
11150: PPUSH
11151: CALL_OW 67
// end ;
11155: GO 11017
11157: POP
11158: POP
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// for i in tmp do
11166: LD_ADDR_VAR 0 2
11170: PUSH
11171: LD_VAR 0 4
11175: PUSH
11176: FOR_IN
11177: IFFALSE 11244
// if IsDead ( i ) then
11179: LD_VAR 0 2
11183: PPUSH
11184: CALL_OW 301
11188: IFFALSE 11208
// tmp := tmp diff i else
11190: LD_ADDR_VAR 0 4
11194: PUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_VAR 0 2
11204: DIFF
11205: ST_TO_ADDR
11206: GO 11242
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 22
11215: PUSH
11216: LD_INT 1
11218: PUSH
11219: EMPTY
11220: LIST
11221: LIST
11222: PPUSH
11223: CALL_OW 69
11227: PPUSH
11228: LD_VAR 0 2
11232: PPUSH
11233: CALL_OW 74
11237: PPUSH
11238: CALL_OW 115
11242: GO 11176
11244: POP
11245: POP
// until not tmp ;
11246: LD_VAR 0 4
11250: NOT
11251: IFFALSE 11159
// end ; end_of_file
11253: LD_VAR 0 1
11257: RET
// export Losses ; on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11258: LD_VAR 0 1
11262: PPUSH
11263: CALL 101664 0 1
// if un = Brighton then
11267: LD_VAR 0 1
11271: PUSH
11272: LD_EXP 9
11276: EQUAL
11277: IFFALSE 11293
// begin wait ( 0 0$1 ) ;
11279: LD_INT 35
11281: PPUSH
11282: CALL_OW 67
// YouLost ( Brighton ) ;
11286: LD_STRING Brighton
11288: PPUSH
11289: CALL_OW 104
// end ; if un = JMM then
11293: LD_VAR 0 1
11297: PUSH
11298: LD_EXP 37
11302: EQUAL
11303: IFFALSE 11319
// begin wait ( 0 0$1 ) ;
11305: LD_INT 35
11307: PPUSH
11308: CALL_OW 67
// YouLost ( JMM ) ;
11312: LD_STRING JMM
11314: PPUSH
11315: CALL_OW 104
// end ; if un = Megan then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_EXP 11
11328: EQUAL
11329: IFFALSE 11343
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11331: LD_EXP 9
11335: PPUSH
11336: LD_STRING DBrighton-MeganDeath
11338: PPUSH
11339: CALL_OW 88
// end ; if un = Palmer then
11343: LD_VAR 0 1
11347: PUSH
11348: LD_EXP 10
11352: EQUAL
11353: IFFALSE 11367
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11355: LD_EXP 9
11359: PPUSH
11360: LD_STRING DBrighton-PalmerDeath
11362: PPUSH
11363: CALL_OW 88
// end ; if un = Burlak then
11367: LD_VAR 0 1
11371: PUSH
11372: LD_EXP 19
11376: EQUAL
11377: IFFALSE 11409
// begin if JMM_Arrived then
11379: LD_EXP 6
11383: IFFALSE 11397
// Say ( JMM , DJMM-BurlakDead ) ;
11385: LD_EXP 37
11389: PPUSH
11390: LD_STRING DJMM-BurlakDead
11392: PPUSH
11393: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11397: LD_EXP 10
11401: PPUSH
11402: LD_STRING DSol-BurlakDead
11404: PPUSH
11405: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11409: LD_VAR 0 1
11413: PUSH
11414: LD_INT 1
11416: EQUAL
11417: PUSH
11418: LD_VAR 0 1
11422: PUSH
11423: LD_INT 3
11425: EQUAL
11426: OR
11427: IFFALSE 11443
// begin wait ( 0 0$1 ) ;
11429: LD_INT 35
11431: PPUSH
11432: CALL_OW 67
// YouLost ( Depot ) ;
11436: LD_STRING Depot
11438: PPUSH
11439: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL_OW 255
11452: PUSH
11453: LD_INT 1
11455: EQUAL
11456: PUSH
11457: LD_VAR 0 1
11461: PPUSH
11462: CALL_OW 247
11466: PUSH
11467: LD_INT 1
11469: EQUAL
11470: AND
11471: IFFALSE 11487
// Losses := Losses + 1 ;
11473: LD_ADDR_EXP 45
11477: PUSH
11478: LD_EXP 45
11482: PUSH
11483: LD_INT 1
11485: PLUS
11486: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11487: LD_VAR 0 1
11491: PPUSH
11492: CALL 82878 0 1
// end ;
11496: PPOPN 1
11498: END
// on UnitGoesToRed ( un ) do begin if GetType ( un ) = unit_vehicle and un in RUArmada then
11499: LD_VAR 0 1
11503: PPUSH
11504: CALL_OW 247
11508: PUSH
11509: LD_INT 2
11511: EQUAL
11512: PUSH
11513: LD_VAR 0 1
11517: PUSH
11518: LD_EXP 17
11522: IN
11523: AND
11524: IFFALSE 11538
// SetLives ( un , 0 ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: LD_INT 0
11533: PPUSH
11534: CALL_OW 234
// if un = Yashin then
11538: LD_VAR 0 1
11542: PUSH
11543: LD_EXP 13
11547: EQUAL
11548: IFFALSE 11562
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11550: LD_EXP 13
11554: PPUSH
11555: LD_STRING DDeath-Yas-3
11557: PPUSH
11558: CALL_OW 91
// if un = Popov then
11562: LD_VAR 0 1
11566: PUSH
11567: LD_EXP 14
11571: EQUAL
11572: IFFALSE 11586
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11574: LD_EXP 14
11578: PPUSH
11579: LD_STRING DDeath-Pop-3
11581: PPUSH
11582: CALL_OW 91
// if un = Gaydar then
11586: LD_VAR 0 1
11590: PUSH
11591: LD_EXP 15
11595: EQUAL
11596: IFFALSE 11610
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11598: LD_EXP 15
11602: PPUSH
11603: LD_STRING DDeath-Gay-3
11605: PPUSH
11606: CALL_OW 91
// if un = Sevi then
11610: LD_VAR 0 1
11614: PUSH
11615: LD_EXP 16
11619: EQUAL
11620: IFFALSE 11634
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11622: LD_EXP 16
11626: PPUSH
11627: LD_STRING DDeath-Vse-3
11629: PPUSH
11630: CALL_OW 91
// end ;
11634: PPOPN 1
11636: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11637: LD_VAR 0 1
11641: PUSH
11642: LD_INT 10
11644: EQUAL
11645: IFFALSE 11683
// begin Say ( Brighton , DBrighton-C1 ) ;
11647: LD_EXP 9
11651: PPUSH
11652: LD_STRING DBrighton-C1
11654: PPUSH
11655: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11659: LD_EXP 11
11663: PPUSH
11664: LD_STRING DMegan-C1
11666: PPUSH
11667: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11671: LD_EXP 9
11675: PPUSH
11676: LD_STRING DBrighton-C2
11678: PPUSH
11679: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_VAR 0 2
11692: PPUSH
11693: CALL 82574 0 2
// end ;
11697: PPOPN 2
11699: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11700: LD_VAR 0 1
11704: PPUSH
11705: LD_VAR 0 2
11709: PPUSH
11710: CALL 85210 0 2
// end ;
11714: PPOPN 2
11716: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11717: LD_VAR 0 1
11721: PPUSH
11722: CALL 84278 0 1
// end ;
11726: PPOPN 1
11728: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11729: LD_VAR 0 1
11733: PPUSH
11734: CALL_OW 266
11738: PUSH
11739: LD_INT 0
11741: EQUAL
11742: PUSH
11743: LD_VAR 0 1
11747: PPUSH
11748: CALL_OW 255
11752: PUSH
11753: LD_INT 3
11755: EQUAL
11756: AND
11757: IFFALSE 11819
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11759: LD_VAR 0 1
11763: PPUSH
11764: CALL_OW 274
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 10000
11774: PPUSH
11775: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11779: LD_VAR 0 1
11783: PPUSH
11784: CALL_OW 274
11788: PPUSH
11789: LD_INT 2
11791: PPUSH
11792: LD_INT 250
11794: PPUSH
11795: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11799: LD_VAR 0 1
11803: PPUSH
11804: CALL_OW 274
11808: PPUSH
11809: LD_INT 3
11811: PPUSH
11812: LD_INT 100
11814: PPUSH
11815: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11819: LD_VAR 0 1
11823: PPUSH
11824: CALL 84519 0 1
// end ;
11828: PPOPN 1
11830: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11831: LD_VAR 0 1
11835: PPUSH
11836: LD_VAR 0 2
11840: PPUSH
11841: LD_VAR 0 3
11845: PPUSH
11846: LD_VAR 0 4
11850: PPUSH
11851: LD_VAR 0 5
11855: PPUSH
11856: CALL 82194 0 5
// end ;
11860: PPOPN 5
11862: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11863: LD_VAR 0 1
11867: PPUSH
11868: LD_VAR 0 2
11872: PPUSH
11873: CALL 81747 0 2
// end ;
11877: PPOPN 2
11879: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11880: LD_VAR 0 1
11884: PPUSH
11885: LD_VAR 0 2
11889: PPUSH
11890: LD_VAR 0 3
11894: PPUSH
11895: LD_VAR 0 4
11899: PPUSH
11900: CALL 81585 0 4
// end ;
11904: PPOPN 4
11906: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11907: LD_VAR 0 1
11911: PPUSH
11912: LD_VAR 0 2
11916: PPUSH
11917: LD_VAR 0 3
11921: PPUSH
11922: CALL 81360 0 3
// end ;
11926: PPOPN 3
11928: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: CALL 81245 0 2
// end ;
11943: PPOPN 2
11945: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_VAR 0 2
11955: PPUSH
11956: CALL 85505 0 2
// end ;
11960: PPOPN 2
11962: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11963: LD_VAR 0 1
11967: PPUSH
11968: CALL_OW 255
11972: PUSH
11973: LD_INT 6
11975: EQUAL
11976: IFFALSE 12106
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
11978: LD_VAR 0 1
11982: PUSH
11983: LD_EXP 13
11987: PUSH
11988: LD_EXP 16
11992: PUSH
11993: LD_EXP 15
11997: PUSH
11998: LD_EXP 14
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: IN
12009: IFFALSE 12013
// exit ;
12011: GO 12130
// if AssaultStarted then
12013: LD_EXP 8
12017: IFFALSE 12091
// case Rand ( 1 , 4 ) of 1 .. 3 :
12019: LD_INT 1
12021: PPUSH
12022: LD_INT 4
12024: PPUSH
12025: CALL_OW 12
12029: PUSH
12030: LD_INT 1
12032: DOUBLE
12033: GREATEREQUAL
12034: IFFALSE 12042
12036: LD_INT 3
12038: DOUBLE
12039: LESSEQUAL
12040: IFTRUE 12044
12042: GO 12062
12044: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12045: LD_VAR 0 1
12049: PPUSH
12050: LD_INT 67
12052: PPUSH
12053: LD_INT 37
12055: PPUSH
12056: CALL_OW 114
12060: GO 12089
12062: LD_INT 4
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12088
12070: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12071: LD_VAR 0 1
12075: PPUSH
12076: LD_INT 120
12078: PPUSH
12079: LD_INT 131
12081: PPUSH
12082: CALL_OW 111
12086: GO 12089
12088: POP
12089: GO 12106
// ComMoveXY ( driver , 120 , 131 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 120
12098: PPUSH
12099: LD_INT 131
12101: PPUSH
12102: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12106: LD_VAR 0 1
12110: PPUSH
12111: LD_VAR 0 2
12115: PPUSH
12116: LD_VAR 0 3
12120: PPUSH
12121: LD_VAR 0 4
12125: PPUSH
12126: CALL 85721 0 4
// end ;
12130: PPOPN 4
12132: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12133: LD_VAR 0 1
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 81054 0 2
// end ;
12147: PPOPN 2
12149: END
// on Command ( cmd ) do var i ;
12150: LD_INT 0
12152: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12153: LD_VAR 0 1
12157: PUSH
12158: LD_INT 77
12160: EQUAL
12161: PUSH
12162: LD_EXP 2
12166: AND
12167: IFFALSE 12243
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12169: LD_ADDR_VAR 0 2
12173: PUSH
12174: LD_INT 22
12176: PUSH
12177: LD_INT 1
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: PUSH
12184: LD_INT 2
12186: PUSH
12187: LD_INT 21
12189: PUSH
12190: LD_INT 1
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 21
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PPUSH
12216: CALL_OW 69
12220: PUSH
12221: FOR_IN
12222: IFFALSE 12241
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12224: LD_VAR 0 2
12228: PPUSH
12229: LD_INT 20
12231: PPUSH
12232: LD_INT 19
12234: PPUSH
12235: CALL 51596 0 3
12239: GO 12221
12241: POP
12242: POP
// end ; SOS_Command ( cmd ) ;
12243: LD_VAR 0 1
12247: PPUSH
12248: CALL 101768 0 1
// end ;
12252: PPOPN 2
12254: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12255: LD_EXP 2
12259: PUSH
12260: LD_INT 16
12262: PPUSH
12263: LD_INT 22
12265: PUSH
12266: LD_INT 1
12268: PUSH
12269: EMPTY
12270: LIST
12271: LIST
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 21
12278: PUSH
12279: LD_INT 1
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 21
12288: PUSH
12289: LD_INT 2
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PPUSH
12305: CALL_OW 70
12309: AND
12310: IFFALSE 12396
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin enable ;
12318: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12319: LD_ADDR_VAR 0 1
12323: PUSH
12324: LD_INT 16
12326: PPUSH
12327: LD_INT 22
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 2
12339: PUSH
12340: LD_INT 21
12342: PUSH
12343: LD_INT 1
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 2
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: PPUSH
12369: CALL_OW 70
12373: PUSH
12374: FOR_IN
12375: IFFALSE 12394
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12377: LD_VAR 0 1
12381: PPUSH
12382: LD_INT 18
12384: PPUSH
12385: LD_INT 19
12387: PPUSH
12388: CALL 51596 0 3
12392: GO 12374
12394: POP
12395: POP
// end ; end_of_file
12396: PPOPN 1
12398: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12399: LD_EXP 6
12403: PUSH
12404: LD_EXP 44
12408: AND
12409: IFFALSE 12580
12411: GO 12413
12413: DISABLE
// begin wait ( 0 0$2 ) ;
12414: LD_INT 70
12416: PPUSH
12417: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12421: LD_EXP 9
12425: PPUSH
12426: LD_STRING DBrighton-G1
12428: PPUSH
12429: CALL_OW 88
// if Losses < 1 then
12433: LD_EXP 45
12437: PUSH
12438: LD_INT 1
12440: LESS
12441: IFFALSE 12455
// AddMedal ( Losses , 1 ) else
12443: LD_STRING Losses
12445: PPUSH
12446: LD_INT 1
12448: PPUSH
12449: CALL_OW 101
12453: GO 12488
// if Losses < 5 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 5
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 2 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 2
12470: PPUSH
12471: CALL_OW 101
12475: GO 12488
// AddMedal ( Losses , - 1 ) ;
12477: LD_STRING Losses
12479: PPUSH
12480: LD_INT 1
12482: NEG
12483: PPUSH
12484: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12488: LD_EXP 7
12492: PUSH
12493: LD_INT 10
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 321
12503: PUSH
12504: LD_INT 2
12506: EQUAL
12507: AND
12508: IFFALSE 12522
// AddMedal ( Laser , 1 ) else
12510: LD_STRING Laser
12512: PPUSH
12513: LD_INT 1
12515: PPUSH
12516: CALL_OW 101
12520: GO 12569
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12522: LD_EXP 7
12526: NOT
12527: PUSH
12528: LD_INT 10
12530: PPUSH
12531: LD_INT 1
12533: PPUSH
12534: CALL_OW 321
12538: PUSH
12539: LD_INT 2
12541: EQUAL
12542: AND
12543: IFFALSE 12558
// AddMedal ( Laser , - 1 ) else
12545: LD_STRING Laser
12547: PPUSH
12548: LD_INT 1
12550: NEG
12551: PPUSH
12552: CALL_OW 101
12556: GO 12569
// AddMedal ( Laser , - 2 ) ;
12558: LD_STRING Laser
12560: PPUSH
12561: LD_INT 2
12563: NEG
12564: PPUSH
12565: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12569: LD_STRING BaseMain
12571: PPUSH
12572: CALL_OW 102
// YouWin ;
12576: CALL_OW 103
// end ; end_of_file
12580: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12581: LD_INT 0
12583: PPUSH
12584: PPUSH
// area = ListEnvironmentArea ( area ) ;
12585: LD_ADDR_VAR 0 2
12589: PUSH
12590: LD_VAR 0 2
12594: PPUSH
12595: CALL_OW 353
12599: ST_TO_ADDR
// if bulldozer > 0 then
12600: LD_VAR 0 1
12604: PUSH
12605: LD_INT 0
12607: GREATER
12608: IFFALSE 12719
// for i = area downto 1 do
12610: LD_ADDR_VAR 0 4
12614: PUSH
12615: DOUBLE
12616: LD_VAR 0 2
12620: INC
12621: ST_TO_ADDR
12622: LD_INT 1
12624: PUSH
12625: FOR_DOWNTO
12626: IFFALSE 12717
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 4
12637: ARRAY
12638: PUSH
12639: LD_INT 1
12641: ARRAY
12642: PPUSH
12643: LD_VAR 0 2
12647: PUSH
12648: LD_VAR 0 4
12652: ARRAY
12653: PUSH
12654: LD_INT 2
12656: ARRAY
12657: PPUSH
12658: CALL_OW 351
12662: IFFALSE 12715
// if not HasTask ( bulldozer ) then
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 314
12673: NOT
12674: IFFALSE 12715
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PUSH
12686: LD_VAR 0 4
12690: ARRAY
12691: PUSH
12692: LD_INT 1
12694: ARRAY
12695: PPUSH
12696: LD_VAR 0 2
12700: PUSH
12701: LD_VAR 0 4
12705: ARRAY
12706: PUSH
12707: LD_INT 2
12709: ARRAY
12710: PPUSH
12711: CALL_OW 171
12715: GO 12625
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12724: LD_INT 0
12726: PPUSH
12727: PPUSH
12728: PPUSH
12729: PPUSH
12730: PPUSH
12731: PPUSH
12732: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12733: LD_ADDR_VAR 0 8
12737: PUSH
12738: LD_VAR 0 1
12742: PPUSH
12743: LD_INT 22
12745: PUSH
12746: LD_INT 1
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: LD_INT 21
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 25
12765: PUSH
12766: LD_INT 1
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: LIST
12777: PPUSH
12778: CALL_OW 72
12782: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12783: LD_ADDR_VAR 0 9
12787: PUSH
12788: LD_VAR 0 1
12792: PPUSH
12793: LD_INT 22
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 21
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: LD_INT 3
12815: PUSH
12816: LD_INT 25
12818: PUSH
12819: LD_INT 1
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: LIST
12834: PPUSH
12835: CALL_OW 72
12839: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12840: LD_ADDR_EXP 47
12844: PUSH
12845: LD_VAR 0 8
12849: PPUSH
12850: LD_VAR 0 9
12854: PPUSH
12855: CALL 13248 0 2
12859: ST_TO_ADDR
// offset = 0 ;
12860: LD_ADDR_VAR 0 7
12864: PUSH
12865: LD_INT 0
12867: ST_TO_ADDR
// for i := 1 to sold_team do
12868: LD_ADDR_VAR 0 4
12872: PUSH
12873: DOUBLE
12874: LD_INT 1
12876: DEC
12877: ST_TO_ADDR
12878: LD_VAR 0 8
12882: PUSH
12883: FOR_TO
12884: IFFALSE 13015
// begin if IsInUnit ( sold_team [ i ] ) then
12886: LD_VAR 0 8
12890: PUSH
12891: LD_VAR 0 4
12895: ARRAY
12896: PPUSH
12897: CALL_OW 310
12901: IFFALSE 12918
// ComExitBuilding ( sold_team [ i ] ) ;
12903: LD_VAR 0 8
12907: PUSH
12908: LD_VAR 0 4
12912: ARRAY
12913: PPUSH
12914: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12918: LD_VAR 0 8
12922: PUSH
12923: LD_VAR 0 4
12927: ARRAY
12928: PPUSH
12929: LD_EXP 47
12933: PUSH
12934: LD_INT 1
12936: ARRAY
12937: PUSH
12938: LD_VAR 0 4
12942: PUSH
12943: LD_VAR 0 7
12947: PLUS
12948: ARRAY
12949: PPUSH
12950: LD_EXP 47
12954: PUSH
12955: LD_INT 1
12957: ARRAY
12958: PUSH
12959: LD_VAR 0 4
12963: PUSH
12964: LD_INT 1
12966: PLUS
12967: PUSH
12968: LD_VAR 0 7
12972: PLUS
12973: ARRAY
12974: PPUSH
12975: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
12979: LD_VAR 0 8
12983: PUSH
12984: LD_VAR 0 4
12988: ARRAY
12989: PPUSH
12990: LD_EXP 9
12994: PPUSH
12995: CALL_OW 179
// offset = offset + 1 ;
12999: LD_ADDR_VAR 0 7
13003: PUSH
13004: LD_VAR 0 7
13008: PUSH
13009: LD_INT 1
13011: PLUS
13012: ST_TO_ADDR
// end ;
13013: GO 12883
13015: POP
13016: POP
// offset = 0 ;
13017: LD_ADDR_VAR 0 7
13021: PUSH
13022: LD_INT 0
13024: ST_TO_ADDR
// tmp = 1 ;
13025: LD_ADDR_VAR 0 6
13029: PUSH
13030: LD_INT 1
13032: ST_TO_ADDR
// for i := 2 to rows do
13033: LD_ADDR_VAR 0 4
13037: PUSH
13038: DOUBLE
13039: LD_INT 2
13041: DEC
13042: ST_TO_ADDR
13043: LD_EXP 47
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13241
// begin for x := 1 to sold_team do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13229
// begin if IsInUnit ( civil_team [ tmp ] ) then
13069: LD_VAR 0 9
13073: PUSH
13074: LD_VAR 0 6
13078: ARRAY
13079: PPUSH
13080: CALL_OW 310
13084: IFFALSE 13101
// ComExitBuilding ( civil_team [ tmp ] ) ;
13086: LD_VAR 0 9
13090: PUSH
13091: LD_VAR 0 6
13095: ARRAY
13096: PPUSH
13097: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13101: LD_VAR 0 9
13105: PUSH
13106: LD_VAR 0 6
13110: ARRAY
13111: PPUSH
13112: LD_EXP 47
13116: PUSH
13117: LD_VAR 0 4
13121: ARRAY
13122: PUSH
13123: LD_VAR 0 5
13127: PUSH
13128: LD_VAR 0 7
13132: PLUS
13133: ARRAY
13134: PPUSH
13135: LD_EXP 47
13139: PUSH
13140: LD_VAR 0 4
13144: ARRAY
13145: PUSH
13146: LD_VAR 0 5
13150: PUSH
13151: LD_INT 1
13153: PLUS
13154: PUSH
13155: LD_VAR 0 7
13159: PLUS
13160: ARRAY
13161: PPUSH
13162: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13166: LD_VAR 0 9
13170: PUSH
13171: LD_VAR 0 6
13175: ARRAY
13176: PPUSH
13177: LD_EXP 9
13181: PPUSH
13182: CALL_OW 179
// offset = offset + 1 ;
13186: LD_ADDR_VAR 0 7
13190: PUSH
13191: LD_VAR 0 7
13195: PUSH
13196: LD_INT 1
13198: PLUS
13199: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13200: LD_VAR 0 6
13204: PUSH
13205: LD_VAR 0 9
13209: EQUAL
13210: NOT
13211: IFFALSE 13227
// tmp = tmp + 1 ;
13213: LD_ADDR_VAR 0 6
13217: PUSH
13218: LD_VAR 0 6
13222: PUSH
13223: LD_INT 1
13225: PLUS
13226: ST_TO_ADDR
// end ;
13227: GO 13066
13229: POP
13230: POP
// offset = 0 ;
13231: LD_ADDR_VAR 0 7
13235: PUSH
13236: LD_INT 0
13238: ST_TO_ADDR
// end ;
13239: GO 13048
13241: POP
13242: POP
// end ;
13243: LD_VAR 0 3
13247: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
13253: PPUSH
13254: PPUSH
13255: PPUSH
13256: PPUSH
13257: PPUSH
13258: PPUSH
13259: PPUSH
// start_pos = [ 65 , 34 ] ;
13260: LD_ADDR_VAR 0 6
13264: PUSH
13265: LD_INT 65
13267: PUSH
13268: LD_INT 34
13270: PUSH
13271: EMPTY
13272: LIST
13273: LIST
13274: ST_TO_ADDR
// row_size = 0 ;
13275: LD_ADDR_VAR 0 7
13279: PUSH
13280: LD_INT 0
13282: ST_TO_ADDR
// result_rows = [ ] ;
13283: LD_ADDR_VAR 0 9
13287: PUSH
13288: EMPTY
13289: ST_TO_ADDR
// new_row = [ ] ;
13290: LD_ADDR_VAR 0 8
13294: PUSH
13295: EMPTY
13296: ST_TO_ADDR
// for i := 1 to sold_team do
13297: LD_ADDR_VAR 0 4
13301: PUSH
13302: DOUBLE
13303: LD_INT 1
13305: DEC
13306: ST_TO_ADDR
13307: LD_VAR 0 1
13311: PUSH
13312: FOR_TO
13313: IFFALSE 13367
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_VAR 0 8
13324: PUSH
13325: LD_VAR 0 6
13329: PUSH
13330: LD_INT 1
13332: ARRAY
13333: ADD
13334: PUSH
13335: LD_VAR 0 6
13339: PUSH
13340: LD_INT 2
13342: ARRAY
13343: PUSH
13344: LD_VAR 0 4
13348: PLUS
13349: ADD
13350: ST_TO_ADDR
// row_size = row_size + 1 ;
13351: LD_ADDR_VAR 0 7
13355: PUSH
13356: LD_VAR 0 7
13360: PUSH
13361: LD_INT 1
13363: PLUS
13364: ST_TO_ADDR
// end ;
13365: GO 13312
13367: POP
13368: POP
// result_rows = result_rows ^ [ new_row ] ;
13369: LD_ADDR_VAR 0 9
13373: PUSH
13374: LD_VAR 0 9
13378: PUSH
13379: LD_VAR 0 8
13383: PUSH
13384: EMPTY
13385: LIST
13386: ADD
13387: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13388: LD_ADDR_VAR 0 10
13392: PUSH
13393: LD_VAR 0 2
13397: PUSH
13398: LD_VAR 0 1
13402: DIV
13403: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13404: LD_VAR 0 10
13408: PUSH
13409: LD_VAR 0 1
13413: MOD
13414: PUSH
13415: LD_INT 0
13417: GREATER
13418: IFFALSE 13434
// civil_rows = civil_rows + 1 ;
13420: LD_ADDR_VAR 0 10
13424: PUSH
13425: LD_VAR 0 10
13429: PUSH
13430: LD_INT 1
13432: PLUS
13433: ST_TO_ADDR
// offsetX = 2 ;
13434: LD_ADDR_VAR 0 11
13438: PUSH
13439: LD_INT 2
13441: ST_TO_ADDR
// offsetY = 1 ;
13442: LD_ADDR_VAR 0 12
13446: PUSH
13447: LD_INT 1
13449: ST_TO_ADDR
// for i := 1 to civil_rows do
13450: LD_ADDR_VAR 0 4
13454: PUSH
13455: DOUBLE
13456: LD_INT 1
13458: DEC
13459: ST_TO_ADDR
13460: LD_VAR 0 10
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13594
// begin new_row = [ ] ;
13468: LD_ADDR_VAR 0 8
13472: PUSH
13473: EMPTY
13474: ST_TO_ADDR
// for x := 1 to row_size do
13475: LD_ADDR_VAR 0 5
13479: PUSH
13480: DOUBLE
13481: LD_INT 1
13483: DEC
13484: ST_TO_ADDR
13485: LD_VAR 0 7
13489: PUSH
13490: FOR_TO
13491: IFFALSE 13543
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13493: LD_ADDR_VAR 0 8
13497: PUSH
13498: LD_VAR 0 8
13502: PUSH
13503: LD_VAR 0 6
13507: PUSH
13508: LD_INT 1
13510: ARRAY
13511: PUSH
13512: LD_VAR 0 11
13516: PLUS
13517: ADD
13518: PUSH
13519: LD_VAR 0 6
13523: PUSH
13524: LD_INT 2
13526: ARRAY
13527: PUSH
13528: LD_VAR 0 12
13532: PLUS
13533: PUSH
13534: LD_VAR 0 5
13538: PLUS
13539: ADD
13540: ST_TO_ADDR
// end ;
13541: GO 13490
13543: POP
13544: POP
// result_rows = result_rows ^ [ new_row ] ;
13545: LD_ADDR_VAR 0 9
13549: PUSH
13550: LD_VAR 0 9
13554: PUSH
13555: LD_VAR 0 8
13559: PUSH
13560: EMPTY
13561: LIST
13562: ADD
13563: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13564: LD_ADDR_VAR 0 11
13568: PUSH
13569: LD_VAR 0 11
13573: PUSH
13574: LD_INT 2
13576: PLUS
13577: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13578: LD_ADDR_VAR 0 12
13582: PUSH
13583: LD_VAR 0 12
13587: PUSH
13588: LD_INT 1
13590: PLUS
13591: ST_TO_ADDR
// end ;
13592: GO 13465
13594: POP
13595: POP
// result = result_rows ;
13596: LD_ADDR_VAR 0 3
13600: PUSH
13601: LD_VAR 0 9
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 3
13610: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
// if exist_mode then
13615: LD_VAR 0 2
13619: IFFALSE 13644
// unit := CreateCharacter ( prefix & ident ) else
13621: LD_ADDR_VAR 0 5
13625: PUSH
13626: LD_VAR 0 3
13630: PUSH
13631: LD_VAR 0 1
13635: STR
13636: PPUSH
13637: CALL_OW 34
13641: ST_TO_ADDR
13642: GO 13659
// unit := NewCharacter ( ident ) ;
13644: LD_ADDR_VAR 0 5
13648: PUSH
13649: LD_VAR 0 1
13653: PPUSH
13654: CALL_OW 25
13658: ST_TO_ADDR
// result := unit ;
13659: LD_ADDR_VAR 0 4
13663: PUSH
13664: LD_VAR 0 5
13668: ST_TO_ADDR
// end ;
13669: LD_VAR 0 4
13673: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13674: LD_INT 0
13676: PPUSH
13677: PPUSH
// if not side or not nation then
13678: LD_VAR 0 1
13682: NOT
13683: PUSH
13684: LD_VAR 0 2
13688: NOT
13689: OR
13690: IFFALSE 13694
// exit ;
13692: GO 14462
// case nation of nation_american :
13694: LD_VAR 0 2
13698: PUSH
13699: LD_INT 1
13701: DOUBLE
13702: EQUAL
13703: IFTRUE 13707
13705: GO 13921
13707: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13708: LD_ADDR_VAR 0 4
13712: PUSH
13713: LD_INT 35
13715: PUSH
13716: LD_INT 45
13718: PUSH
13719: LD_INT 46
13721: PUSH
13722: LD_INT 47
13724: PUSH
13725: LD_INT 82
13727: PUSH
13728: LD_INT 83
13730: PUSH
13731: LD_INT 84
13733: PUSH
13734: LD_INT 85
13736: PUSH
13737: LD_INT 86
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: LD_INT 2
13745: PUSH
13746: LD_INT 6
13748: PUSH
13749: LD_INT 15
13751: PUSH
13752: LD_INT 16
13754: PUSH
13755: LD_INT 7
13757: PUSH
13758: LD_INT 12
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 10
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: LD_INT 20
13772: PUSH
13773: LD_INT 21
13775: PUSH
13776: LD_INT 22
13778: PUSH
13779: LD_INT 25
13781: PUSH
13782: LD_INT 32
13784: PUSH
13785: LD_INT 27
13787: PUSH
13788: LD_INT 36
13790: PUSH
13791: LD_INT 69
13793: PUSH
13794: LD_INT 39
13796: PUSH
13797: LD_INT 34
13799: PUSH
13800: LD_INT 40
13802: PUSH
13803: LD_INT 48
13805: PUSH
13806: LD_INT 49
13808: PUSH
13809: LD_INT 50
13811: PUSH
13812: LD_INT 51
13814: PUSH
13815: LD_INT 52
13817: PUSH
13818: LD_INT 53
13820: PUSH
13821: LD_INT 54
13823: PUSH
13824: LD_INT 55
13826: PUSH
13827: LD_INT 56
13829: PUSH
13830: LD_INT 57
13832: PUSH
13833: LD_INT 58
13835: PUSH
13836: LD_INT 59
13838: PUSH
13839: LD_INT 60
13841: PUSH
13842: LD_INT 61
13844: PUSH
13845: LD_INT 62
13847: PUSH
13848: LD_INT 80
13850: PUSH
13851: LD_INT 82
13853: PUSH
13854: LD_INT 83
13856: PUSH
13857: LD_INT 84
13859: PUSH
13860: LD_INT 85
13862: PUSH
13863: LD_INT 86
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: ST_TO_ADDR
13919: GO 14386
13921: LD_INT 2
13923: DOUBLE
13924: EQUAL
13925: IFTRUE 13929
13927: GO 14155
13929: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_INT 35
13937: PUSH
13938: LD_INT 45
13940: PUSH
13941: LD_INT 46
13943: PUSH
13944: LD_INT 47
13946: PUSH
13947: LD_INT 82
13949: PUSH
13950: LD_INT 83
13952: PUSH
13953: LD_INT 84
13955: PUSH
13956: LD_INT 85
13958: PUSH
13959: LD_INT 87
13961: PUSH
13962: LD_INT 70
13964: PUSH
13965: LD_INT 1
13967: PUSH
13968: LD_INT 11
13970: PUSH
13971: LD_INT 3
13973: PUSH
13974: LD_INT 4
13976: PUSH
13977: LD_INT 5
13979: PUSH
13980: LD_INT 6
13982: PUSH
13983: LD_INT 15
13985: PUSH
13986: LD_INT 18
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: LD_INT 17
13994: PUSH
13995: LD_INT 8
13997: PUSH
13998: LD_INT 20
14000: PUSH
14001: LD_INT 21
14003: PUSH
14004: LD_INT 22
14006: PUSH
14007: LD_INT 72
14009: PUSH
14010: LD_INT 26
14012: PUSH
14013: LD_INT 69
14015: PUSH
14016: LD_INT 39
14018: PUSH
14019: LD_INT 40
14021: PUSH
14022: LD_INT 41
14024: PUSH
14025: LD_INT 42
14027: PUSH
14028: LD_INT 43
14030: PUSH
14031: LD_INT 48
14033: PUSH
14034: LD_INT 49
14036: PUSH
14037: LD_INT 50
14039: PUSH
14040: LD_INT 51
14042: PUSH
14043: LD_INT 52
14045: PUSH
14046: LD_INT 53
14048: PUSH
14049: LD_INT 54
14051: PUSH
14052: LD_INT 55
14054: PUSH
14055: LD_INT 56
14057: PUSH
14058: LD_INT 60
14060: PUSH
14061: LD_INT 61
14063: PUSH
14064: LD_INT 62
14066: PUSH
14067: LD_INT 66
14069: PUSH
14070: LD_INT 67
14072: PUSH
14073: LD_INT 68
14075: PUSH
14076: LD_INT 81
14078: PUSH
14079: LD_INT 82
14081: PUSH
14082: LD_INT 83
14084: PUSH
14085: LD_INT 84
14087: PUSH
14088: LD_INT 85
14090: PUSH
14091: LD_INT 87
14093: PUSH
14094: LD_INT 88
14096: PUSH
14097: EMPTY
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14386
14155: LD_INT 3
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14385
14163: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14164: LD_ADDR_VAR 0 4
14168: PUSH
14169: LD_INT 46
14171: PUSH
14172: LD_INT 47
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: LD_INT 82
14183: PUSH
14184: LD_INT 83
14186: PUSH
14187: LD_INT 84
14189: PUSH
14190: LD_INT 85
14192: PUSH
14193: LD_INT 86
14195: PUSH
14196: LD_INT 11
14198: PUSH
14199: LD_INT 9
14201: PUSH
14202: LD_INT 20
14204: PUSH
14205: LD_INT 19
14207: PUSH
14208: LD_INT 21
14210: PUSH
14211: LD_INT 24
14213: PUSH
14214: LD_INT 22
14216: PUSH
14217: LD_INT 25
14219: PUSH
14220: LD_INT 28
14222: PUSH
14223: LD_INT 29
14225: PUSH
14226: LD_INT 30
14228: PUSH
14229: LD_INT 31
14231: PUSH
14232: LD_INT 37
14234: PUSH
14235: LD_INT 38
14237: PUSH
14238: LD_INT 32
14240: PUSH
14241: LD_INT 27
14243: PUSH
14244: LD_INT 33
14246: PUSH
14247: LD_INT 69
14249: PUSH
14250: LD_INT 39
14252: PUSH
14253: LD_INT 34
14255: PUSH
14256: LD_INT 40
14258: PUSH
14259: LD_INT 71
14261: PUSH
14262: LD_INT 23
14264: PUSH
14265: LD_INT 44
14267: PUSH
14268: LD_INT 48
14270: PUSH
14271: LD_INT 49
14273: PUSH
14274: LD_INT 50
14276: PUSH
14277: LD_INT 51
14279: PUSH
14280: LD_INT 52
14282: PUSH
14283: LD_INT 53
14285: PUSH
14286: LD_INT 54
14288: PUSH
14289: LD_INT 55
14291: PUSH
14292: LD_INT 56
14294: PUSH
14295: LD_INT 57
14297: PUSH
14298: LD_INT 58
14300: PUSH
14301: LD_INT 59
14303: PUSH
14304: LD_INT 63
14306: PUSH
14307: LD_INT 64
14309: PUSH
14310: LD_INT 65
14312: PUSH
14313: LD_INT 82
14315: PUSH
14316: LD_INT 83
14318: PUSH
14319: LD_INT 84
14321: PUSH
14322: LD_INT 85
14324: PUSH
14325: LD_INT 86
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: ST_TO_ADDR
14383: GO 14386
14385: POP
// if state > - 1 and state < 3 then
14386: LD_VAR 0 3
14390: PUSH
14391: LD_INT 1
14393: NEG
14394: GREATER
14395: PUSH
14396: LD_VAR 0 3
14400: PUSH
14401: LD_INT 3
14403: LESS
14404: AND
14405: IFFALSE 14462
// for i in result do
14407: LD_ADDR_VAR 0 5
14411: PUSH
14412: LD_VAR 0 4
14416: PUSH
14417: FOR_IN
14418: IFFALSE 14460
// if GetTech ( i , side ) <> state then
14420: LD_VAR 0 5
14424: PPUSH
14425: LD_VAR 0 1
14429: PPUSH
14430: CALL_OW 321
14434: PUSH
14435: LD_VAR 0 3
14439: NONEQUAL
14440: IFFALSE 14458
// result := result diff i ;
14442: LD_ADDR_VAR 0 4
14446: PUSH
14447: LD_VAR 0 4
14451: PUSH
14452: LD_VAR 0 5
14456: DIFF
14457: ST_TO_ADDR
14458: GO 14417
14460: POP
14461: POP
// end ;
14462: LD_VAR 0 4
14466: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14467: LD_INT 0
14469: PPUSH
14470: PPUSH
14471: PPUSH
// result := true ;
14472: LD_ADDR_VAR 0 3
14476: PUSH
14477: LD_INT 1
14479: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: LD_VAR 0 2
14489: PPUSH
14490: CALL_OW 480
14494: ST_TO_ADDR
// if not tmp then
14495: LD_VAR 0 5
14499: NOT
14500: IFFALSE 14504
// exit ;
14502: GO 14553
// for i in tmp do
14504: LD_ADDR_VAR 0 4
14508: PUSH
14509: LD_VAR 0 5
14513: PUSH
14514: FOR_IN
14515: IFFALSE 14551
// if GetTech ( i , side ) <> state_researched then
14517: LD_VAR 0 4
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 321
14531: PUSH
14532: LD_INT 2
14534: NONEQUAL
14535: IFFALSE 14549
// begin result := false ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 0
14544: ST_TO_ADDR
// exit ;
14545: POP
14546: POP
14547: GO 14553
// end ;
14549: GO 14514
14551: POP
14552: POP
// end ;
14553: LD_VAR 0 3
14557: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14558: LD_INT 0
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
14572: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14573: LD_VAR 0 1
14577: NOT
14578: PUSH
14579: LD_VAR 0 1
14583: PPUSH
14584: CALL_OW 257
14588: PUSH
14589: LD_INT 9
14591: NONEQUAL
14592: OR
14593: IFFALSE 14597
// exit ;
14595: GO 15170
// side := GetSide ( unit ) ;
14597: LD_ADDR_VAR 0 9
14601: PUSH
14602: LD_VAR 0 1
14606: PPUSH
14607: CALL_OW 255
14611: ST_TO_ADDR
// tech_space := tech_spacanom ;
14612: LD_ADDR_VAR 0 12
14616: PUSH
14617: LD_INT 29
14619: ST_TO_ADDR
// tech_time := tech_taurad ;
14620: LD_ADDR_VAR 0 13
14624: PUSH
14625: LD_INT 28
14627: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14628: LD_ADDR_VAR 0 11
14632: PUSH
14633: LD_VAR 0 1
14637: PPUSH
14638: CALL_OW 310
14642: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14643: LD_VAR 0 11
14647: PPUSH
14648: CALL_OW 247
14652: PUSH
14653: LD_INT 2
14655: EQUAL
14656: IFFALSE 14660
// exit ;
14658: GO 15170
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14660: LD_ADDR_VAR 0 8
14664: PUSH
14665: LD_INT 81
14667: PUSH
14668: LD_VAR 0 9
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 21
14682: PUSH
14683: LD_INT 3
14685: PUSH
14686: EMPTY
14687: LIST
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PPUSH
14698: CALL_OW 69
14702: ST_TO_ADDR
// if not tmp then
14703: LD_VAR 0 8
14707: NOT
14708: IFFALSE 14712
// exit ;
14710: GO 15170
// if in_unit then
14712: LD_VAR 0 11
14716: IFFALSE 14740
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14718: LD_ADDR_VAR 0 10
14722: PUSH
14723: LD_VAR 0 8
14727: PPUSH
14728: LD_VAR 0 11
14732: PPUSH
14733: CALL_OW 74
14737: ST_TO_ADDR
14738: GO 14760
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14740: LD_ADDR_VAR 0 10
14744: PUSH
14745: LD_VAR 0 8
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: ST_TO_ADDR
// if not enemy then
14760: LD_VAR 0 10
14764: NOT
14765: IFFALSE 14769
// exit ;
14767: GO 15170
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14769: LD_VAR 0 11
14773: PUSH
14774: LD_VAR 0 11
14778: PPUSH
14779: LD_VAR 0 10
14783: PPUSH
14784: CALL_OW 296
14788: PUSH
14789: LD_INT 13
14791: GREATER
14792: AND
14793: PUSH
14794: LD_VAR 0 1
14798: PPUSH
14799: LD_VAR 0 10
14803: PPUSH
14804: CALL_OW 296
14808: PUSH
14809: LD_INT 12
14811: GREATER
14812: OR
14813: IFFALSE 14817
// exit ;
14815: GO 15170
// missile := [ 1 ] ;
14817: LD_ADDR_VAR 0 14
14821: PUSH
14822: LD_INT 1
14824: PUSH
14825: EMPTY
14826: LIST
14827: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14828: LD_VAR 0 9
14832: PPUSH
14833: LD_VAR 0 12
14837: PPUSH
14838: CALL_OW 325
14842: IFFALSE 14871
// missile := Replace ( missile , missile + 1 , 2 ) ;
14844: LD_ADDR_VAR 0 14
14848: PUSH
14849: LD_VAR 0 14
14853: PPUSH
14854: LD_VAR 0 14
14858: PUSH
14859: LD_INT 1
14861: PLUS
14862: PPUSH
14863: LD_INT 2
14865: PPUSH
14866: CALL_OW 1
14870: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14871: LD_VAR 0 9
14875: PPUSH
14876: LD_VAR 0 13
14880: PPUSH
14881: CALL_OW 325
14885: PUSH
14886: LD_VAR 0 10
14890: PPUSH
14891: CALL_OW 255
14895: PPUSH
14896: LD_VAR 0 13
14900: PPUSH
14901: CALL_OW 325
14905: NOT
14906: AND
14907: IFFALSE 14936
// missile := Replace ( missile , missile + 1 , 3 ) ;
14909: LD_ADDR_VAR 0 14
14913: PUSH
14914: LD_VAR 0 14
14918: PPUSH
14919: LD_VAR 0 14
14923: PUSH
14924: LD_INT 1
14926: PLUS
14927: PPUSH
14928: LD_INT 3
14930: PPUSH
14931: CALL_OW 1
14935: ST_TO_ADDR
// if missile < 2 then
14936: LD_VAR 0 14
14940: PUSH
14941: LD_INT 2
14943: LESS
14944: IFFALSE 14948
// exit ;
14946: GO 15170
// x := GetX ( enemy ) ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 250
14962: ST_TO_ADDR
// y := GetY ( enemy ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 10
14972: PPUSH
14973: CALL_OW 251
14977: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 4
14987: PUSH
14988: LD_INT 1
14990: NEG
14991: PPUSH
14992: LD_INT 1
14994: PPUSH
14995: CALL_OW 12
14999: PLUS
15000: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15001: LD_ADDR_VAR 0 7
15005: PUSH
15006: LD_VAR 0 5
15010: PUSH
15011: LD_INT 1
15013: NEG
15014: PPUSH
15015: LD_INT 1
15017: PPUSH
15018: CALL_OW 12
15022: PLUS
15023: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15024: LD_VAR 0 6
15028: PPUSH
15029: LD_VAR 0 7
15033: PPUSH
15034: CALL_OW 488
15038: NOT
15039: IFFALSE 15061
// begin _x := x ;
15041: LD_ADDR_VAR 0 6
15045: PUSH
15046: LD_VAR 0 4
15050: ST_TO_ADDR
// _y := y ;
15051: LD_ADDR_VAR 0 7
15055: PUSH
15056: LD_VAR 0 5
15060: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 1
15068: PPUSH
15069: LD_VAR 0 14
15073: PPUSH
15074: CALL_OW 12
15078: ST_TO_ADDR
// case i of 1 :
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: DOUBLE
15087: EQUAL
15088: IFTRUE 15092
15090: GO 15109
15092: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15093: LD_VAR 0 1
15097: PPUSH
15098: LD_VAR 0 10
15102: PPUSH
15103: CALL_OW 115
15107: GO 15170
15109: LD_INT 2
15111: DOUBLE
15112: EQUAL
15113: IFTRUE 15117
15115: GO 15139
15117: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15118: LD_VAR 0 1
15122: PPUSH
15123: LD_VAR 0 6
15127: PPUSH
15128: LD_VAR 0 7
15132: PPUSH
15133: CALL_OW 153
15137: GO 15170
15139: LD_INT 3
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15169
15147: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 6
15157: PPUSH
15158: LD_VAR 0 7
15162: PPUSH
15163: CALL_OW 154
15167: GO 15170
15169: POP
// end ;
15170: LD_VAR 0 2
15174: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15175: LD_INT 0
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
15182: PPUSH
// if not unit or not building then
15183: LD_VAR 0 1
15187: NOT
15188: PUSH
15189: LD_VAR 0 2
15193: NOT
15194: OR
15195: IFFALSE 15199
// exit ;
15197: GO 15357
// x := GetX ( building ) ;
15199: LD_ADDR_VAR 0 5
15203: PUSH
15204: LD_VAR 0 2
15208: PPUSH
15209: CALL_OW 250
15213: ST_TO_ADDR
// y := GetY ( building ) ;
15214: LD_ADDR_VAR 0 6
15218: PUSH
15219: LD_VAR 0 2
15223: PPUSH
15224: CALL_OW 251
15228: ST_TO_ADDR
// for i = 0 to 5 do
15229: LD_ADDR_VAR 0 4
15233: PUSH
15234: DOUBLE
15235: LD_INT 0
15237: DEC
15238: ST_TO_ADDR
15239: LD_INT 5
15241: PUSH
15242: FOR_TO
15243: IFFALSE 15355
// begin _x := ShiftX ( x , i , 3 ) ;
15245: LD_ADDR_VAR 0 7
15249: PUSH
15250: LD_VAR 0 5
15254: PPUSH
15255: LD_VAR 0 4
15259: PPUSH
15260: LD_INT 3
15262: PPUSH
15263: CALL_OW 272
15267: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15268: LD_ADDR_VAR 0 8
15272: PUSH
15273: LD_VAR 0 6
15277: PPUSH
15278: LD_VAR 0 4
15282: PPUSH
15283: LD_INT 3
15285: PPUSH
15286: CALL_OW 273
15290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15291: LD_VAR 0 7
15295: PPUSH
15296: LD_VAR 0 8
15300: PPUSH
15301: CALL_OW 488
15305: NOT
15306: IFFALSE 15310
// continue ;
15308: GO 15242
// if HexInfo ( _x , _y ) = 0 then
15310: LD_VAR 0 7
15314: PPUSH
15315: LD_VAR 0 8
15319: PPUSH
15320: CALL_OW 428
15324: PUSH
15325: LD_INT 0
15327: EQUAL
15328: IFFALSE 15353
// begin ComMoveXY ( unit , _x , _y ) ;
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_VAR 0 7
15339: PPUSH
15340: LD_VAR 0 8
15344: PPUSH
15345: CALL_OW 111
// exit ;
15349: POP
15350: POP
15351: GO 15357
// end ; end ;
15353: GO 15242
15355: POP
15356: POP
// end ;
15357: LD_VAR 0 3
15361: RET
// export function ScanBase ( side , base_area ) ; begin
15362: LD_INT 0
15364: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15365: LD_ADDR_VAR 0 3
15369: PUSH
15370: LD_VAR 0 2
15374: PPUSH
15375: LD_INT 81
15377: PUSH
15378: LD_VAR 0 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PPUSH
15387: CALL_OW 70
15391: ST_TO_ADDR
// end ;
15392: LD_VAR 0 3
15396: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15397: LD_INT 0
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// result := false ;
15403: LD_ADDR_VAR 0 2
15407: PUSH
15408: LD_INT 0
15410: ST_TO_ADDR
// side := GetSide ( unit ) ;
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_VAR 0 1
15420: PPUSH
15421: CALL_OW 255
15425: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15426: LD_ADDR_VAR 0 4
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 248
15440: ST_TO_ADDR
// case nat of 1 :
15441: LD_VAR 0 4
15445: PUSH
15446: LD_INT 1
15448: DOUBLE
15449: EQUAL
15450: IFTRUE 15454
15452: GO 15465
15454: POP
// tech := tech_lassight ; 2 :
15455: LD_ADDR_VAR 0 5
15459: PUSH
15460: LD_INT 12
15462: ST_TO_ADDR
15463: GO 15504
15465: LD_INT 2
15467: DOUBLE
15468: EQUAL
15469: IFTRUE 15473
15471: GO 15484
15473: POP
// tech := tech_mortar ; 3 :
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_INT 41
15481: ST_TO_ADDR
15482: GO 15504
15484: LD_INT 3
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15503
15492: POP
// tech := tech_bazooka ; end ;
15493: LD_ADDR_VAR 0 5
15497: PUSH
15498: LD_INT 44
15500: ST_TO_ADDR
15501: GO 15504
15503: POP
// if Researched ( side , tech ) then
15504: LD_VAR 0 3
15508: PPUSH
15509: LD_VAR 0 5
15513: PPUSH
15514: CALL_OW 325
15518: IFFALSE 15545
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15520: LD_ADDR_VAR 0 2
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 8
15530: PUSH
15531: LD_INT 9
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: LIST
15538: PUSH
15539: LD_VAR 0 4
15543: ARRAY
15544: ST_TO_ADDR
// end ;
15545: LD_VAR 0 2
15549: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15550: LD_INT 0
15552: PPUSH
15553: PPUSH
15554: PPUSH
// if not mines then
15555: LD_VAR 0 2
15559: NOT
15560: IFFALSE 15564
// exit ;
15562: GO 15708
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15564: LD_ADDR_VAR 0 5
15568: PUSH
15569: LD_INT 81
15571: PUSH
15572: LD_VAR 0 1
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 3
15583: PUSH
15584: LD_INT 21
15586: PUSH
15587: LD_INT 3
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PPUSH
15602: CALL_OW 69
15606: ST_TO_ADDR
// for i in mines do
15607: LD_ADDR_VAR 0 4
15611: PUSH
15612: LD_VAR 0 2
15616: PUSH
15617: FOR_IN
15618: IFFALSE 15706
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15620: LD_VAR 0 4
15624: PUSH
15625: LD_INT 1
15627: ARRAY
15628: PPUSH
15629: LD_VAR 0 4
15633: PUSH
15634: LD_INT 2
15636: ARRAY
15637: PPUSH
15638: CALL_OW 458
15642: NOT
15643: IFFALSE 15647
// continue ;
15645: GO 15617
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 1
15654: ARRAY
15655: PPUSH
15656: LD_VAR 0 4
15660: PUSH
15661: LD_INT 2
15663: ARRAY
15664: PPUSH
15665: CALL_OW 428
15669: PUSH
15670: LD_VAR 0 5
15674: IN
15675: IFFALSE 15704
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15677: LD_VAR 0 4
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PPUSH
15686: LD_VAR 0 4
15690: PUSH
15691: LD_INT 2
15693: ARRAY
15694: PPUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 456
// end ;
15704: GO 15617
15706: POP
15707: POP
// end ;
15708: LD_VAR 0 3
15712: RET
// export function Count ( array ) ; begin
15713: LD_INT 0
15715: PPUSH
// result := array + 0 ;
15716: LD_ADDR_VAR 0 2
15720: PUSH
15721: LD_VAR 0 1
15725: PUSH
15726: LD_INT 0
15728: PLUS
15729: ST_TO_ADDR
// end ;
15730: LD_VAR 0 2
15734: RET
// export function IsEmpty ( building ) ; begin
15735: LD_INT 0
15737: PPUSH
// if not building then
15738: LD_VAR 0 1
15742: NOT
15743: IFFALSE 15747
// exit ;
15745: GO 15790
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15747: LD_ADDR_VAR 0 2
15751: PUSH
15752: LD_VAR 0 1
15756: PUSH
15757: LD_INT 22
15759: PUSH
15760: LD_VAR 0 1
15764: PPUSH
15765: CALL_OW 255
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 58
15776: PUSH
15777: EMPTY
15778: LIST
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 69
15788: IN
15789: ST_TO_ADDR
// end ;
15790: LD_VAR 0 2
15794: RET
// export function IsNotFull ( building ) ; var places ; begin
15795: LD_INT 0
15797: PPUSH
15798: PPUSH
// if not building then
15799: LD_VAR 0 1
15803: NOT
15804: IFFALSE 15808
// exit ;
15806: GO 15836
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
15808: LD_ADDR_VAR 0 2
15812: PUSH
15813: LD_VAR 0 1
15817: PPUSH
15818: LD_INT 3
15820: PUSH
15821: LD_INT 62
15823: PUSH
15824: EMPTY
15825: LIST
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: PPUSH
15831: CALL_OW 72
15835: ST_TO_ADDR
// end ;
15836: LD_VAR 0 2
15840: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15841: LD_INT 0
15843: PPUSH
15844: PPUSH
15845: PPUSH
15846: PPUSH
// tmp := [ ] ;
15847: LD_ADDR_VAR 0 3
15851: PUSH
15852: EMPTY
15853: ST_TO_ADDR
// list := [ ] ;
15854: LD_ADDR_VAR 0 5
15858: PUSH
15859: EMPTY
15860: ST_TO_ADDR
// for i = 16 to 25 do
15861: LD_ADDR_VAR 0 4
15865: PUSH
15866: DOUBLE
15867: LD_INT 16
15869: DEC
15870: ST_TO_ADDR
15871: LD_INT 25
15873: PUSH
15874: FOR_TO
15875: IFFALSE 15948
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15877: LD_ADDR_VAR 0 3
15881: PUSH
15882: LD_VAR 0 3
15886: PUSH
15887: LD_INT 22
15889: PUSH
15890: LD_VAR 0 1
15894: PPUSH
15895: CALL_OW 255
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PUSH
15904: LD_INT 91
15906: PUSH
15907: LD_VAR 0 1
15911: PUSH
15912: LD_INT 6
15914: PUSH
15915: EMPTY
15916: LIST
15917: LIST
15918: LIST
15919: PUSH
15920: LD_INT 30
15922: PUSH
15923: LD_VAR 0 4
15927: PUSH
15928: EMPTY
15929: LIST
15930: LIST
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: LIST
15936: PUSH
15937: EMPTY
15938: LIST
15939: PPUSH
15940: CALL_OW 69
15944: ADD
15945: ST_TO_ADDR
15946: GO 15874
15948: POP
15949: POP
// for i = 1 to tmp do
15950: LD_ADDR_VAR 0 4
15954: PUSH
15955: DOUBLE
15956: LD_INT 1
15958: DEC
15959: ST_TO_ADDR
15960: LD_VAR 0 3
15964: PUSH
15965: FOR_TO
15966: IFFALSE 16054
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
15968: LD_ADDR_VAR 0 5
15972: PUSH
15973: LD_VAR 0 5
15977: PUSH
15978: LD_VAR 0 3
15982: PUSH
15983: LD_VAR 0 4
15987: ARRAY
15988: PPUSH
15989: CALL_OW 266
15993: PUSH
15994: LD_VAR 0 3
15998: PUSH
15999: LD_VAR 0 4
16003: ARRAY
16004: PPUSH
16005: CALL_OW 250
16009: PUSH
16010: LD_VAR 0 3
16014: PUSH
16015: LD_VAR 0 4
16019: ARRAY
16020: PPUSH
16021: CALL_OW 251
16025: PUSH
16026: LD_VAR 0 3
16030: PUSH
16031: LD_VAR 0 4
16035: ARRAY
16036: PPUSH
16037: CALL_OW 254
16041: PUSH
16042: EMPTY
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: ADD
16051: ST_TO_ADDR
16052: GO 15965
16054: POP
16055: POP
// result := list ;
16056: LD_ADDR_VAR 0 2
16060: PUSH
16061: LD_VAR 0 5
16065: ST_TO_ADDR
// end ;
16066: LD_VAR 0 2
16070: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16071: LD_INT 0
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// if not factory then
16080: LD_VAR 0 1
16084: NOT
16085: IFFALSE 16089
// exit ;
16087: GO 16682
// if control = control_apeman then
16089: LD_VAR 0 4
16093: PUSH
16094: LD_INT 5
16096: EQUAL
16097: IFFALSE 16206
// begin tmp := UnitsInside ( factory ) ;
16099: LD_ADDR_VAR 0 8
16103: PUSH
16104: LD_VAR 0 1
16108: PPUSH
16109: CALL_OW 313
16113: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16114: LD_VAR 0 8
16118: PPUSH
16119: LD_INT 25
16121: PUSH
16122: LD_INT 12
16124: PUSH
16125: EMPTY
16126: LIST
16127: LIST
16128: PPUSH
16129: CALL_OW 72
16133: NOT
16134: IFFALSE 16144
// control := control_manual ;
16136: LD_ADDR_VAR 0 4
16140: PUSH
16141: LD_INT 1
16143: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16144: LD_ADDR_VAR 0 8
16148: PUSH
16149: LD_VAR 0 1
16153: PPUSH
16154: CALL 15841 0 1
16158: ST_TO_ADDR
// if tmp then
16159: LD_VAR 0 8
16163: IFFALSE 16206
// begin for i in tmp do
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_VAR 0 8
16174: PUSH
16175: FOR_IN
16176: IFFALSE 16204
// if i [ 1 ] = b_ext_radio then
16178: LD_VAR 0 7
16182: PUSH
16183: LD_INT 1
16185: ARRAY
16186: PUSH
16187: LD_INT 22
16189: EQUAL
16190: IFFALSE 16202
// begin control := control_remote ;
16192: LD_ADDR_VAR 0 4
16196: PUSH
16197: LD_INT 2
16199: ST_TO_ADDR
// break ;
16200: GO 16204
// end ;
16202: GO 16175
16204: POP
16205: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 2
16215: PPUSH
16216: LD_VAR 0 3
16220: PPUSH
16221: LD_VAR 0 4
16225: PPUSH
16226: LD_VAR 0 5
16230: PPUSH
16231: CALL_OW 448
16235: IFFALSE 16270
// begin result := [ chassis , engine , control , weapon ] ;
16237: LD_ADDR_VAR 0 6
16241: PUSH
16242: LD_VAR 0 2
16246: PUSH
16247: LD_VAR 0 3
16251: PUSH
16252: LD_VAR 0 4
16256: PUSH
16257: LD_VAR 0 5
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: LIST
16266: LIST
16267: ST_TO_ADDR
// exit ;
16268: GO 16682
// end ; _chassis := AvailableChassisList ( factory ) ;
16270: LD_ADDR_VAR 0 9
16274: PUSH
16275: LD_VAR 0 1
16279: PPUSH
16280: CALL_OW 475
16284: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16285: LD_ADDR_VAR 0 11
16289: PUSH
16290: LD_VAR 0 1
16294: PPUSH
16295: CALL_OW 476
16299: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16300: LD_ADDR_VAR 0 12
16304: PUSH
16305: LD_VAR 0 1
16309: PPUSH
16310: CALL_OW 477
16314: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16315: LD_ADDR_VAR 0 10
16319: PUSH
16320: LD_VAR 0 1
16324: PPUSH
16325: CALL_OW 478
16329: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16330: LD_VAR 0 9
16334: NOT
16335: PUSH
16336: LD_VAR 0 11
16340: NOT
16341: OR
16342: PUSH
16343: LD_VAR 0 12
16347: NOT
16348: OR
16349: PUSH
16350: LD_VAR 0 10
16354: NOT
16355: OR
16356: IFFALSE 16391
// begin result := [ chassis , engine , control , weapon ] ;
16358: LD_ADDR_VAR 0 6
16362: PUSH
16363: LD_VAR 0 2
16367: PUSH
16368: LD_VAR 0 3
16372: PUSH
16373: LD_VAR 0 4
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: LIST
16387: LIST
16388: ST_TO_ADDR
// exit ;
16389: GO 16682
// end ; if not chassis in _chassis then
16391: LD_VAR 0 2
16395: PUSH
16396: LD_VAR 0 9
16400: IN
16401: NOT
16402: IFFALSE 16428
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16404: LD_ADDR_VAR 0 2
16408: PUSH
16409: LD_VAR 0 9
16413: PUSH
16414: LD_INT 1
16416: PPUSH
16417: LD_VAR 0 9
16421: PPUSH
16422: CALL_OW 12
16426: ARRAY
16427: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16428: LD_VAR 0 2
16432: PPUSH
16433: LD_VAR 0 3
16437: PPUSH
16438: CALL 16687 0 2
16442: NOT
16443: IFFALSE 16502
// repeat engine := _engine [ 1 ] ;
16445: LD_ADDR_VAR 0 3
16449: PUSH
16450: LD_VAR 0 11
16454: PUSH
16455: LD_INT 1
16457: ARRAY
16458: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16459: LD_ADDR_VAR 0 11
16463: PUSH
16464: LD_VAR 0 11
16468: PPUSH
16469: LD_INT 1
16471: PPUSH
16472: CALL_OW 3
16476: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16477: LD_VAR 0 2
16481: PPUSH
16482: LD_VAR 0 3
16486: PPUSH
16487: CALL 16687 0 2
16491: PUSH
16492: LD_VAR 0 11
16496: PUSH
16497: EMPTY
16498: EQUAL
16499: OR
16500: IFFALSE 16445
// if not control in _control then
16502: LD_VAR 0 4
16506: PUSH
16507: LD_VAR 0 12
16511: IN
16512: NOT
16513: IFFALSE 16539
// control := _control [ rand ( 1 , _control ) ] ;
16515: LD_ADDR_VAR 0 4
16519: PUSH
16520: LD_VAR 0 12
16524: PUSH
16525: LD_INT 1
16527: PPUSH
16528: LD_VAR 0 12
16532: PPUSH
16533: CALL_OW 12
16537: ARRAY
16538: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16539: LD_VAR 0 2
16543: PPUSH
16544: LD_VAR 0 5
16548: PPUSH
16549: CALL 16907 0 2
16553: NOT
16554: IFFALSE 16613
// repeat weapon := _weapon [ 1 ] ;
16556: LD_ADDR_VAR 0 5
16560: PUSH
16561: LD_VAR 0 10
16565: PUSH
16566: LD_INT 1
16568: ARRAY
16569: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16570: LD_ADDR_VAR 0 10
16574: PUSH
16575: LD_VAR 0 10
16579: PPUSH
16580: LD_INT 1
16582: PPUSH
16583: CALL_OW 3
16587: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16588: LD_VAR 0 2
16592: PPUSH
16593: LD_VAR 0 5
16597: PPUSH
16598: CALL 16907 0 2
16602: PUSH
16603: LD_VAR 0 10
16607: PUSH
16608: EMPTY
16609: EQUAL
16610: OR
16611: IFFALSE 16556
// result := [ ] ;
16613: LD_ADDR_VAR 0 6
16617: PUSH
16618: EMPTY
16619: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16620: LD_VAR 0 1
16624: PPUSH
16625: LD_VAR 0 2
16629: PPUSH
16630: LD_VAR 0 3
16634: PPUSH
16635: LD_VAR 0 4
16639: PPUSH
16640: LD_VAR 0 5
16644: PPUSH
16645: CALL_OW 448
16649: IFFALSE 16682
// result := [ chassis , engine , control , weapon ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 2
16660: PUSH
16661: LD_VAR 0 3
16665: PUSH
16666: LD_VAR 0 4
16670: PUSH
16671: LD_VAR 0 5
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: LIST
16680: LIST
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 6
16686: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16687: LD_INT 0
16689: PPUSH
// if not chassis or not engine then
16690: LD_VAR 0 1
16694: NOT
16695: PUSH
16696: LD_VAR 0 2
16700: NOT
16701: OR
16702: IFFALSE 16706
// exit ;
16704: GO 16902
// case engine of engine_solar :
16706: LD_VAR 0 2
16710: PUSH
16711: LD_INT 2
16713: DOUBLE
16714: EQUAL
16715: IFTRUE 16719
16717: GO 16757
16719: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16720: LD_ADDR_VAR 0 3
16724: PUSH
16725: LD_INT 11
16727: PUSH
16728: LD_INT 12
16730: PUSH
16731: LD_INT 13
16733: PUSH
16734: LD_INT 14
16736: PUSH
16737: LD_INT 1
16739: PUSH
16740: LD_INT 2
16742: PUSH
16743: LD_INT 3
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: LIST
16750: LIST
16751: LIST
16752: LIST
16753: LIST
16754: ST_TO_ADDR
16755: GO 16886
16757: LD_INT 1
16759: DOUBLE
16760: EQUAL
16761: IFTRUE 16765
16763: GO 16827
16765: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16766: LD_ADDR_VAR 0 3
16770: PUSH
16771: LD_INT 11
16773: PUSH
16774: LD_INT 12
16776: PUSH
16777: LD_INT 13
16779: PUSH
16780: LD_INT 14
16782: PUSH
16783: LD_INT 1
16785: PUSH
16786: LD_INT 2
16788: PUSH
16789: LD_INT 3
16791: PUSH
16792: LD_INT 4
16794: PUSH
16795: LD_INT 5
16797: PUSH
16798: LD_INT 21
16800: PUSH
16801: LD_INT 23
16803: PUSH
16804: LD_INT 22
16806: PUSH
16807: LD_INT 24
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: LIST
16814: LIST
16815: LIST
16816: LIST
16817: LIST
16818: LIST
16819: LIST
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: ST_TO_ADDR
16825: GO 16886
16827: LD_INT 3
16829: DOUBLE
16830: EQUAL
16831: IFTRUE 16835
16833: GO 16885
16835: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16836: LD_ADDR_VAR 0 3
16840: PUSH
16841: LD_INT 13
16843: PUSH
16844: LD_INT 14
16846: PUSH
16847: LD_INT 2
16849: PUSH
16850: LD_INT 3
16852: PUSH
16853: LD_INT 4
16855: PUSH
16856: LD_INT 5
16858: PUSH
16859: LD_INT 21
16861: PUSH
16862: LD_INT 22
16864: PUSH
16865: LD_INT 23
16867: PUSH
16868: LD_INT 24
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: LIST
16878: LIST
16879: LIST
16880: LIST
16881: LIST
16882: ST_TO_ADDR
16883: GO 16886
16885: POP
// result := ( chassis in result ) ;
16886: LD_ADDR_VAR 0 3
16890: PUSH
16891: LD_VAR 0 1
16895: PUSH
16896: LD_VAR 0 3
16900: IN
16901: ST_TO_ADDR
// end ;
16902: LD_VAR 0 3
16906: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16907: LD_INT 0
16909: PPUSH
// if not chassis or not weapon then
16910: LD_VAR 0 1
16914: NOT
16915: PUSH
16916: LD_VAR 0 2
16920: NOT
16921: OR
16922: IFFALSE 16926
// exit ;
16924: GO 17986
// case weapon of us_machine_gun :
16926: LD_VAR 0 2
16930: PUSH
16931: LD_INT 2
16933: DOUBLE
16934: EQUAL
16935: IFTRUE 16939
16937: GO 16969
16939: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16940: LD_ADDR_VAR 0 3
16944: PUSH
16945: LD_INT 1
16947: PUSH
16948: LD_INT 2
16950: PUSH
16951: LD_INT 3
16953: PUSH
16954: LD_INT 4
16956: PUSH
16957: LD_INT 5
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
16967: GO 17970
16969: LD_INT 3
16971: DOUBLE
16972: EQUAL
16973: IFTRUE 16977
16975: GO 17007
16977: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
16978: LD_ADDR_VAR 0 3
16982: PUSH
16983: LD_INT 1
16985: PUSH
16986: LD_INT 2
16988: PUSH
16989: LD_INT 3
16991: PUSH
16992: LD_INT 4
16994: PUSH
16995: LD_INT 5
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: ST_TO_ADDR
17005: GO 17970
17007: LD_INT 11
17009: DOUBLE
17010: EQUAL
17011: IFTRUE 17015
17013: GO 17045
17015: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17016: LD_ADDR_VAR 0 3
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: LD_INT 2
17026: PUSH
17027: LD_INT 3
17029: PUSH
17030: LD_INT 4
17032: PUSH
17033: LD_INT 5
17035: PUSH
17036: EMPTY
17037: LIST
17038: LIST
17039: LIST
17040: LIST
17041: LIST
17042: ST_TO_ADDR
17043: GO 17970
17045: LD_INT 4
17047: DOUBLE
17048: EQUAL
17049: IFTRUE 17053
17051: GO 17079
17053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17054: LD_ADDR_VAR 0 3
17058: PUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 3
17064: PUSH
17065: LD_INT 4
17067: PUSH
17068: LD_INT 5
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: LIST
17076: ST_TO_ADDR
17077: GO 17970
17079: LD_INT 5
17081: DOUBLE
17082: EQUAL
17083: IFTRUE 17087
17085: GO 17113
17087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17088: LD_ADDR_VAR 0 3
17092: PUSH
17093: LD_INT 2
17095: PUSH
17096: LD_INT 3
17098: PUSH
17099: LD_INT 4
17101: PUSH
17102: LD_INT 5
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: LIST
17109: LIST
17110: ST_TO_ADDR
17111: GO 17970
17113: LD_INT 9
17115: DOUBLE
17116: EQUAL
17117: IFTRUE 17121
17119: GO 17147
17121: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17122: LD_ADDR_VAR 0 3
17126: PUSH
17127: LD_INT 2
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: LD_INT 4
17135: PUSH
17136: LD_INT 5
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: LIST
17143: LIST
17144: ST_TO_ADDR
17145: GO 17970
17147: LD_INT 7
17149: DOUBLE
17150: EQUAL
17151: IFTRUE 17155
17153: GO 17181
17155: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17156: LD_ADDR_VAR 0 3
17160: PUSH
17161: LD_INT 2
17163: PUSH
17164: LD_INT 3
17166: PUSH
17167: LD_INT 4
17169: PUSH
17170: LD_INT 5
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: ST_TO_ADDR
17179: GO 17970
17181: LD_INT 12
17183: DOUBLE
17184: EQUAL
17185: IFTRUE 17189
17187: GO 17215
17189: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17190: LD_ADDR_VAR 0 3
17194: PUSH
17195: LD_INT 2
17197: PUSH
17198: LD_INT 3
17200: PUSH
17201: LD_INT 4
17203: PUSH
17204: LD_INT 5
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: LIST
17211: LIST
17212: ST_TO_ADDR
17213: GO 17970
17215: LD_INT 13
17217: DOUBLE
17218: EQUAL
17219: IFTRUE 17223
17221: GO 17249
17223: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17224: LD_ADDR_VAR 0 3
17228: PUSH
17229: LD_INT 2
17231: PUSH
17232: LD_INT 3
17234: PUSH
17235: LD_INT 4
17237: PUSH
17238: LD_INT 5
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: LIST
17245: LIST
17246: ST_TO_ADDR
17247: GO 17970
17249: LD_INT 14
17251: DOUBLE
17252: EQUAL
17253: IFTRUE 17257
17255: GO 17275
17257: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17258: LD_ADDR_VAR 0 3
17262: PUSH
17263: LD_INT 4
17265: PUSH
17266: LD_INT 5
17268: PUSH
17269: EMPTY
17270: LIST
17271: LIST
17272: ST_TO_ADDR
17273: GO 17970
17275: LD_INT 6
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17301
17283: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17284: LD_ADDR_VAR 0 3
17288: PUSH
17289: LD_INT 4
17291: PUSH
17292: LD_INT 5
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: ST_TO_ADDR
17299: GO 17970
17301: LD_INT 10
17303: DOUBLE
17304: EQUAL
17305: IFTRUE 17309
17307: GO 17327
17309: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17310: LD_ADDR_VAR 0 3
17314: PUSH
17315: LD_INT 4
17317: PUSH
17318: LD_INT 5
17320: PUSH
17321: EMPTY
17322: LIST
17323: LIST
17324: ST_TO_ADDR
17325: GO 17970
17327: LD_INT 22
17329: DOUBLE
17330: EQUAL
17331: IFTRUE 17335
17333: GO 17361
17335: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17336: LD_ADDR_VAR 0 3
17340: PUSH
17341: LD_INT 11
17343: PUSH
17344: LD_INT 12
17346: PUSH
17347: LD_INT 13
17349: PUSH
17350: LD_INT 14
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: LIST
17357: LIST
17358: ST_TO_ADDR
17359: GO 17970
17361: LD_INT 23
17363: DOUBLE
17364: EQUAL
17365: IFTRUE 17369
17367: GO 17395
17369: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17370: LD_ADDR_VAR 0 3
17374: PUSH
17375: LD_INT 11
17377: PUSH
17378: LD_INT 12
17380: PUSH
17381: LD_INT 13
17383: PUSH
17384: LD_INT 14
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: ST_TO_ADDR
17393: GO 17970
17395: LD_INT 24
17397: DOUBLE
17398: EQUAL
17399: IFTRUE 17403
17401: GO 17429
17403: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17404: LD_ADDR_VAR 0 3
17408: PUSH
17409: LD_INT 11
17411: PUSH
17412: LD_INT 12
17414: PUSH
17415: LD_INT 13
17417: PUSH
17418: LD_INT 14
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: LIST
17426: ST_TO_ADDR
17427: GO 17970
17429: LD_INT 30
17431: DOUBLE
17432: EQUAL
17433: IFTRUE 17437
17435: GO 17463
17437: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17438: LD_ADDR_VAR 0 3
17442: PUSH
17443: LD_INT 11
17445: PUSH
17446: LD_INT 12
17448: PUSH
17449: LD_INT 13
17451: PUSH
17452: LD_INT 14
17454: PUSH
17455: EMPTY
17456: LIST
17457: LIST
17458: LIST
17459: LIST
17460: ST_TO_ADDR
17461: GO 17970
17463: LD_INT 25
17465: DOUBLE
17466: EQUAL
17467: IFTRUE 17471
17469: GO 17489
17471: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17472: LD_ADDR_VAR 0 3
17476: PUSH
17477: LD_INT 13
17479: PUSH
17480: LD_INT 14
17482: PUSH
17483: EMPTY
17484: LIST
17485: LIST
17486: ST_TO_ADDR
17487: GO 17970
17489: LD_INT 27
17491: DOUBLE
17492: EQUAL
17493: IFTRUE 17497
17495: GO 17515
17497: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
17498: LD_ADDR_VAR 0 3
17502: PUSH
17503: LD_INT 13
17505: PUSH
17506: LD_INT 14
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: ST_TO_ADDR
17513: GO 17970
17515: LD_INT 92
17517: DOUBLE
17518: EQUAL
17519: IFTRUE 17523
17521: GO 17549
17523: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17524: LD_ADDR_VAR 0 3
17528: PUSH
17529: LD_INT 11
17531: PUSH
17532: LD_INT 12
17534: PUSH
17535: LD_INT 13
17537: PUSH
17538: LD_INT 14
17540: PUSH
17541: EMPTY
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: ST_TO_ADDR
17547: GO 17970
17549: LD_INT 28
17551: DOUBLE
17552: EQUAL
17553: IFTRUE 17557
17555: GO 17575
17557: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17558: LD_ADDR_VAR 0 3
17562: PUSH
17563: LD_INT 13
17565: PUSH
17566: LD_INT 14
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: ST_TO_ADDR
17573: GO 17970
17575: LD_INT 29
17577: DOUBLE
17578: EQUAL
17579: IFTRUE 17583
17581: GO 17601
17583: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17584: LD_ADDR_VAR 0 3
17588: PUSH
17589: LD_INT 13
17591: PUSH
17592: LD_INT 14
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: ST_TO_ADDR
17599: GO 17970
17601: LD_INT 31
17603: DOUBLE
17604: EQUAL
17605: IFTRUE 17609
17607: GO 17627
17609: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 13
17617: PUSH
17618: LD_INT 14
17620: PUSH
17621: EMPTY
17622: LIST
17623: LIST
17624: ST_TO_ADDR
17625: GO 17970
17627: LD_INT 26
17629: DOUBLE
17630: EQUAL
17631: IFTRUE 17635
17633: GO 17653
17635: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 13
17643: PUSH
17644: LD_INT 14
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: ST_TO_ADDR
17651: GO 17970
17653: LD_INT 42
17655: DOUBLE
17656: EQUAL
17657: IFTRUE 17661
17659: GO 17687
17661: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17662: LD_ADDR_VAR 0 3
17666: PUSH
17667: LD_INT 21
17669: PUSH
17670: LD_INT 22
17672: PUSH
17673: LD_INT 23
17675: PUSH
17676: LD_INT 24
17678: PUSH
17679: EMPTY
17680: LIST
17681: LIST
17682: LIST
17683: LIST
17684: ST_TO_ADDR
17685: GO 17970
17687: LD_INT 43
17689: DOUBLE
17690: EQUAL
17691: IFTRUE 17695
17693: GO 17721
17695: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17696: LD_ADDR_VAR 0 3
17700: PUSH
17701: LD_INT 21
17703: PUSH
17704: LD_INT 22
17706: PUSH
17707: LD_INT 23
17709: PUSH
17710: LD_INT 24
17712: PUSH
17713: EMPTY
17714: LIST
17715: LIST
17716: LIST
17717: LIST
17718: ST_TO_ADDR
17719: GO 17970
17721: LD_INT 44
17723: DOUBLE
17724: EQUAL
17725: IFTRUE 17729
17727: GO 17755
17729: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17730: LD_ADDR_VAR 0 3
17734: PUSH
17735: LD_INT 21
17737: PUSH
17738: LD_INT 22
17740: PUSH
17741: LD_INT 23
17743: PUSH
17744: LD_INT 24
17746: PUSH
17747: EMPTY
17748: LIST
17749: LIST
17750: LIST
17751: LIST
17752: ST_TO_ADDR
17753: GO 17970
17755: LD_INT 45
17757: DOUBLE
17758: EQUAL
17759: IFTRUE 17763
17761: GO 17789
17763: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17764: LD_ADDR_VAR 0 3
17768: PUSH
17769: LD_INT 21
17771: PUSH
17772: LD_INT 22
17774: PUSH
17775: LD_INT 23
17777: PUSH
17778: LD_INT 24
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: ST_TO_ADDR
17787: GO 17970
17789: LD_INT 49
17791: DOUBLE
17792: EQUAL
17793: IFTRUE 17797
17795: GO 17823
17797: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17798: LD_ADDR_VAR 0 3
17802: PUSH
17803: LD_INT 21
17805: PUSH
17806: LD_INT 22
17808: PUSH
17809: LD_INT 23
17811: PUSH
17812: LD_INT 24
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: ST_TO_ADDR
17821: GO 17970
17823: LD_INT 51
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17857
17831: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17832: LD_ADDR_VAR 0 3
17836: PUSH
17837: LD_INT 21
17839: PUSH
17840: LD_INT 22
17842: PUSH
17843: LD_INT 23
17845: PUSH
17846: LD_INT 24
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: ST_TO_ADDR
17855: GO 17970
17857: LD_INT 52
17859: DOUBLE
17860: EQUAL
17861: IFTRUE 17865
17863: GO 17891
17865: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17866: LD_ADDR_VAR 0 3
17870: PUSH
17871: LD_INT 21
17873: PUSH
17874: LD_INT 22
17876: PUSH
17877: LD_INT 23
17879: PUSH
17880: LD_INT 24
17882: PUSH
17883: EMPTY
17884: LIST
17885: LIST
17886: LIST
17887: LIST
17888: ST_TO_ADDR
17889: GO 17970
17891: LD_INT 53
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17917
17899: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17900: LD_ADDR_VAR 0 3
17904: PUSH
17905: LD_INT 23
17907: PUSH
17908: LD_INT 24
17910: PUSH
17911: EMPTY
17912: LIST
17913: LIST
17914: ST_TO_ADDR
17915: GO 17970
17917: LD_INT 46
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17943
17925: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17926: LD_ADDR_VAR 0 3
17930: PUSH
17931: LD_INT 23
17933: PUSH
17934: LD_INT 24
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: ST_TO_ADDR
17941: GO 17970
17943: LD_INT 47
17945: DOUBLE
17946: EQUAL
17947: IFTRUE 17951
17949: GO 17969
17951: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17952: LD_ADDR_VAR 0 3
17956: PUSH
17957: LD_INT 23
17959: PUSH
17960: LD_INT 24
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: ST_TO_ADDR
17967: GO 17970
17969: POP
// result := ( chassis in result ) ;
17970: LD_ADDR_VAR 0 3
17974: PUSH
17975: LD_VAR 0 1
17979: PUSH
17980: LD_VAR 0 3
17984: IN
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 3
17990: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
17995: PPUSH
17996: PPUSH
17997: PPUSH
17998: PPUSH
17999: PPUSH
// result := array ;
18000: LD_ADDR_VAR 0 5
18004: PUSH
18005: LD_VAR 0 1
18009: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18010: LD_VAR 0 1
18014: NOT
18015: PUSH
18016: LD_VAR 0 2
18020: NOT
18021: OR
18022: PUSH
18023: LD_VAR 0 3
18027: NOT
18028: OR
18029: PUSH
18030: LD_VAR 0 2
18034: PUSH
18035: LD_VAR 0 1
18039: GREATER
18040: OR
18041: PUSH
18042: LD_VAR 0 3
18046: PUSH
18047: LD_VAR 0 1
18051: GREATER
18052: OR
18053: IFFALSE 18057
// exit ;
18055: GO 18353
// if direction then
18057: LD_VAR 0 4
18061: IFFALSE 18125
// begin d := 1 ;
18063: LD_ADDR_VAR 0 9
18067: PUSH
18068: LD_INT 1
18070: ST_TO_ADDR
// if i_from > i_to then
18071: LD_VAR 0 2
18075: PUSH
18076: LD_VAR 0 3
18080: GREATER
18081: IFFALSE 18107
// length := ( array - i_from ) + i_to else
18083: LD_ADDR_VAR 0 11
18087: PUSH
18088: LD_VAR 0 1
18092: PUSH
18093: LD_VAR 0 2
18097: MINUS
18098: PUSH
18099: LD_VAR 0 3
18103: PLUS
18104: ST_TO_ADDR
18105: GO 18123
// length := i_to - i_from ;
18107: LD_ADDR_VAR 0 11
18111: PUSH
18112: LD_VAR 0 3
18116: PUSH
18117: LD_VAR 0 2
18121: MINUS
18122: ST_TO_ADDR
// end else
18123: GO 18186
// begin d := - 1 ;
18125: LD_ADDR_VAR 0 9
18129: PUSH
18130: LD_INT 1
18132: NEG
18133: ST_TO_ADDR
// if i_from > i_to then
18134: LD_VAR 0 2
18138: PUSH
18139: LD_VAR 0 3
18143: GREATER
18144: IFFALSE 18164
// length := i_from - i_to else
18146: LD_ADDR_VAR 0 11
18150: PUSH
18151: LD_VAR 0 2
18155: PUSH
18156: LD_VAR 0 3
18160: MINUS
18161: ST_TO_ADDR
18162: GO 18186
// length := ( array - i_to ) + i_from ;
18164: LD_ADDR_VAR 0 11
18168: PUSH
18169: LD_VAR 0 1
18173: PUSH
18174: LD_VAR 0 3
18178: MINUS
18179: PUSH
18180: LD_VAR 0 2
18184: PLUS
18185: ST_TO_ADDR
// end ; if not length then
18186: LD_VAR 0 11
18190: NOT
18191: IFFALSE 18195
// exit ;
18193: GO 18353
// tmp := array ;
18195: LD_ADDR_VAR 0 10
18199: PUSH
18200: LD_VAR 0 1
18204: ST_TO_ADDR
// for i = 1 to length do
18205: LD_ADDR_VAR 0 6
18209: PUSH
18210: DOUBLE
18211: LD_INT 1
18213: DEC
18214: ST_TO_ADDR
18215: LD_VAR 0 11
18219: PUSH
18220: FOR_TO
18221: IFFALSE 18341
// begin for j = 1 to array do
18223: LD_ADDR_VAR 0 7
18227: PUSH
18228: DOUBLE
18229: LD_INT 1
18231: DEC
18232: ST_TO_ADDR
18233: LD_VAR 0 1
18237: PUSH
18238: FOR_TO
18239: IFFALSE 18327
// begin k := j + d ;
18241: LD_ADDR_VAR 0 8
18245: PUSH
18246: LD_VAR 0 7
18250: PUSH
18251: LD_VAR 0 9
18255: PLUS
18256: ST_TO_ADDR
// if k > array then
18257: LD_VAR 0 8
18261: PUSH
18262: LD_VAR 0 1
18266: GREATER
18267: IFFALSE 18277
// k := 1 ;
18269: LD_ADDR_VAR 0 8
18273: PUSH
18274: LD_INT 1
18276: ST_TO_ADDR
// if not k then
18277: LD_VAR 0 8
18281: NOT
18282: IFFALSE 18294
// k := array ;
18284: LD_ADDR_VAR 0 8
18288: PUSH
18289: LD_VAR 0 1
18293: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18294: LD_ADDR_VAR 0 10
18298: PUSH
18299: LD_VAR 0 10
18303: PPUSH
18304: LD_VAR 0 8
18308: PPUSH
18309: LD_VAR 0 1
18313: PUSH
18314: LD_VAR 0 7
18318: ARRAY
18319: PPUSH
18320: CALL_OW 1
18324: ST_TO_ADDR
// end ;
18325: GO 18238
18327: POP
18328: POP
// array := tmp ;
18329: LD_ADDR_VAR 0 1
18333: PUSH
18334: LD_VAR 0 10
18338: ST_TO_ADDR
// end ;
18339: GO 18220
18341: POP
18342: POP
// result := array ;
18343: LD_ADDR_VAR 0 5
18347: PUSH
18348: LD_VAR 0 1
18352: ST_TO_ADDR
// end ;
18353: LD_VAR 0 5
18357: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18358: LD_INT 0
18360: PPUSH
18361: PPUSH
// result := 0 ;
18362: LD_ADDR_VAR 0 3
18366: PUSH
18367: LD_INT 0
18369: ST_TO_ADDR
// if not array or not value in array then
18370: LD_VAR 0 1
18374: NOT
18375: PUSH
18376: LD_VAR 0 2
18380: PUSH
18381: LD_VAR 0 1
18385: IN
18386: NOT
18387: OR
18388: IFFALSE 18392
// exit ;
18390: GO 18446
// for i = 1 to array do
18392: LD_ADDR_VAR 0 4
18396: PUSH
18397: DOUBLE
18398: LD_INT 1
18400: DEC
18401: ST_TO_ADDR
18402: LD_VAR 0 1
18406: PUSH
18407: FOR_TO
18408: IFFALSE 18444
// if value = array [ i ] then
18410: LD_VAR 0 2
18414: PUSH
18415: LD_VAR 0 1
18419: PUSH
18420: LD_VAR 0 4
18424: ARRAY
18425: EQUAL
18426: IFFALSE 18442
// begin result := i ;
18428: LD_ADDR_VAR 0 3
18432: PUSH
18433: LD_VAR 0 4
18437: ST_TO_ADDR
// exit ;
18438: POP
18439: POP
18440: GO 18446
// end ;
18442: GO 18407
18444: POP
18445: POP
// end ;
18446: LD_VAR 0 3
18450: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18451: LD_INT 0
18453: PPUSH
// vc_chassis := chassis ;
18454: LD_ADDR_OWVAR 37
18458: PUSH
18459: LD_VAR 0 1
18463: ST_TO_ADDR
// vc_engine := engine ;
18464: LD_ADDR_OWVAR 39
18468: PUSH
18469: LD_VAR 0 2
18473: ST_TO_ADDR
// vc_control := control ;
18474: LD_ADDR_OWVAR 38
18478: PUSH
18479: LD_VAR 0 3
18483: ST_TO_ADDR
// vc_weapon := weapon ;
18484: LD_ADDR_OWVAR 40
18488: PUSH
18489: LD_VAR 0 4
18493: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18494: LD_ADDR_OWVAR 41
18498: PUSH
18499: LD_VAR 0 5
18503: ST_TO_ADDR
// end ;
18504: LD_VAR 0 6
18508: RET
// export function WantPlant ( unit ) ; var task ; begin
18509: LD_INT 0
18511: PPUSH
18512: PPUSH
// result := false ;
18513: LD_ADDR_VAR 0 2
18517: PUSH
18518: LD_INT 0
18520: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18521: LD_ADDR_VAR 0 3
18525: PUSH
18526: LD_VAR 0 1
18530: PPUSH
18531: CALL_OW 437
18535: ST_TO_ADDR
// if task then
18536: LD_VAR 0 3
18540: IFFALSE 18568
// if task [ 1 ] [ 1 ] = p then
18542: LD_VAR 0 3
18546: PUSH
18547: LD_INT 1
18549: ARRAY
18550: PUSH
18551: LD_INT 1
18553: ARRAY
18554: PUSH
18555: LD_STRING p
18557: EQUAL
18558: IFFALSE 18568
// result := true ;
18560: LD_ADDR_VAR 0 2
18564: PUSH
18565: LD_INT 1
18567: ST_TO_ADDR
// end ;
18568: LD_VAR 0 2
18572: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18573: LD_INT 0
18575: PPUSH
18576: PPUSH
18577: PPUSH
18578: PPUSH
// if pos < 1 then
18579: LD_VAR 0 2
18583: PUSH
18584: LD_INT 1
18586: LESS
18587: IFFALSE 18591
// exit ;
18589: GO 18894
// if pos = 1 then
18591: LD_VAR 0 2
18595: PUSH
18596: LD_INT 1
18598: EQUAL
18599: IFFALSE 18632
// result := Replace ( arr , pos [ 1 ] , value ) else
18601: LD_ADDR_VAR 0 4
18605: PUSH
18606: LD_VAR 0 1
18610: PPUSH
18611: LD_VAR 0 2
18615: PUSH
18616: LD_INT 1
18618: ARRAY
18619: PPUSH
18620: LD_VAR 0 3
18624: PPUSH
18625: CALL_OW 1
18629: ST_TO_ADDR
18630: GO 18894
// begin tmp := arr ;
18632: LD_ADDR_VAR 0 6
18636: PUSH
18637: LD_VAR 0 1
18641: ST_TO_ADDR
// s_arr := [ tmp ] ;
18642: LD_ADDR_VAR 0 7
18646: PUSH
18647: LD_VAR 0 6
18651: PUSH
18652: EMPTY
18653: LIST
18654: ST_TO_ADDR
// for i = 1 to pos - 1 do
18655: LD_ADDR_VAR 0 5
18659: PUSH
18660: DOUBLE
18661: LD_INT 1
18663: DEC
18664: ST_TO_ADDR
18665: LD_VAR 0 2
18669: PUSH
18670: LD_INT 1
18672: MINUS
18673: PUSH
18674: FOR_TO
18675: IFFALSE 18720
// begin tmp := tmp [ pos [ i ] ] ;
18677: LD_ADDR_VAR 0 6
18681: PUSH
18682: LD_VAR 0 6
18686: PUSH
18687: LD_VAR 0 2
18691: PUSH
18692: LD_VAR 0 5
18696: ARRAY
18697: ARRAY
18698: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18699: LD_ADDR_VAR 0 7
18703: PUSH
18704: LD_VAR 0 7
18708: PUSH
18709: LD_VAR 0 6
18713: PUSH
18714: EMPTY
18715: LIST
18716: ADD
18717: ST_TO_ADDR
// end ;
18718: GO 18674
18720: POP
18721: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18722: LD_ADDR_VAR 0 6
18726: PUSH
18727: LD_VAR 0 6
18731: PPUSH
18732: LD_VAR 0 2
18736: PUSH
18737: LD_VAR 0 2
18741: ARRAY
18742: PPUSH
18743: LD_VAR 0 3
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18753: LD_ADDR_VAR 0 7
18757: PUSH
18758: LD_VAR 0 7
18762: PPUSH
18763: LD_VAR 0 7
18767: PPUSH
18768: LD_VAR 0 6
18772: PPUSH
18773: CALL_OW 1
18777: ST_TO_ADDR
// for i = s_arr downto 2 do
18778: LD_ADDR_VAR 0 5
18782: PUSH
18783: DOUBLE
18784: LD_VAR 0 7
18788: INC
18789: ST_TO_ADDR
18790: LD_INT 2
18792: PUSH
18793: FOR_DOWNTO
18794: IFFALSE 18878
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18796: LD_ADDR_VAR 0 6
18800: PUSH
18801: LD_VAR 0 7
18805: PUSH
18806: LD_VAR 0 5
18810: PUSH
18811: LD_INT 1
18813: MINUS
18814: ARRAY
18815: PPUSH
18816: LD_VAR 0 2
18820: PUSH
18821: LD_VAR 0 5
18825: PUSH
18826: LD_INT 1
18828: MINUS
18829: ARRAY
18830: PPUSH
18831: LD_VAR 0 7
18835: PUSH
18836: LD_VAR 0 5
18840: ARRAY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18847: LD_ADDR_VAR 0 7
18851: PUSH
18852: LD_VAR 0 7
18856: PPUSH
18857: LD_VAR 0 5
18861: PUSH
18862: LD_INT 1
18864: MINUS
18865: PPUSH
18866: LD_VAR 0 6
18870: PPUSH
18871: CALL_OW 1
18875: ST_TO_ADDR
// end ;
18876: GO 18793
18878: POP
18879: POP
// result := s_arr [ 1 ] ;
18880: LD_ADDR_VAR 0 4
18884: PUSH
18885: LD_VAR 0 7
18889: PUSH
18890: LD_INT 1
18892: ARRAY
18893: ST_TO_ADDR
// end ; end ;
18894: LD_VAR 0 4
18898: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18899: LD_INT 0
18901: PPUSH
18902: PPUSH
// if not list then
18903: LD_VAR 0 1
18907: NOT
18908: IFFALSE 18912
// exit ;
18910: GO 19003
// i := list [ pos1 ] ;
18912: LD_ADDR_VAR 0 5
18916: PUSH
18917: LD_VAR 0 1
18921: PUSH
18922: LD_VAR 0 2
18926: ARRAY
18927: ST_TO_ADDR
// if not i then
18928: LD_VAR 0 5
18932: NOT
18933: IFFALSE 18937
// exit ;
18935: GO 19003
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18937: LD_ADDR_VAR 0 1
18941: PUSH
18942: LD_VAR 0 1
18946: PPUSH
18947: LD_VAR 0 2
18951: PPUSH
18952: LD_VAR 0 1
18956: PUSH
18957: LD_VAR 0 3
18961: ARRAY
18962: PPUSH
18963: CALL_OW 1
18967: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18968: LD_ADDR_VAR 0 1
18972: PUSH
18973: LD_VAR 0 1
18977: PPUSH
18978: LD_VAR 0 3
18982: PPUSH
18983: LD_VAR 0 5
18987: PPUSH
18988: CALL_OW 1
18992: ST_TO_ADDR
// result := list ;
18993: LD_ADDR_VAR 0 4
18997: PUSH
18998: LD_VAR 0 1
19002: ST_TO_ADDR
// end ;
19003: LD_VAR 0 4
19007: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19008: LD_INT 0
19010: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19011: LD_ADDR_VAR 0 5
19015: PUSH
19016: LD_VAR 0 1
19020: PPUSH
19021: CALL_OW 250
19025: PPUSH
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 251
19035: PPUSH
19036: LD_VAR 0 2
19040: PPUSH
19041: LD_VAR 0 3
19045: PPUSH
19046: LD_VAR 0 4
19050: PPUSH
19051: CALL 19061 0 5
19055: ST_TO_ADDR
// end ;
19056: LD_VAR 0 5
19060: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19061: LD_INT 0
19063: PPUSH
19064: PPUSH
19065: PPUSH
19066: PPUSH
// if not list then
19067: LD_VAR 0 3
19071: NOT
19072: IFFALSE 19076
// exit ;
19074: GO 19464
// result := [ ] ;
19076: LD_ADDR_VAR 0 6
19080: PUSH
19081: EMPTY
19082: ST_TO_ADDR
// for i in list do
19083: LD_ADDR_VAR 0 7
19087: PUSH
19088: LD_VAR 0 3
19092: PUSH
19093: FOR_IN
19094: IFFALSE 19296
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19096: LD_ADDR_VAR 0 9
19100: PUSH
19101: LD_VAR 0 7
19105: PPUSH
19106: LD_VAR 0 1
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 297
19120: ST_TO_ADDR
// if not result then
19121: LD_VAR 0 6
19125: NOT
19126: IFFALSE 19152
// result := [ [ i , tmp ] ] else
19128: LD_ADDR_VAR 0 6
19132: PUSH
19133: LD_VAR 0 7
19137: PUSH
19138: LD_VAR 0 9
19142: PUSH
19143: EMPTY
19144: LIST
19145: LIST
19146: PUSH
19147: EMPTY
19148: LIST
19149: ST_TO_ADDR
19150: GO 19294
// begin if result [ result ] [ 2 ] < tmp then
19152: LD_VAR 0 6
19156: PUSH
19157: LD_VAR 0 6
19161: ARRAY
19162: PUSH
19163: LD_INT 2
19165: ARRAY
19166: PUSH
19167: LD_VAR 0 9
19171: LESS
19172: IFFALSE 19214
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19174: LD_ADDR_VAR 0 6
19178: PUSH
19179: LD_VAR 0 6
19183: PPUSH
19184: LD_VAR 0 6
19188: PUSH
19189: LD_INT 1
19191: PLUS
19192: PPUSH
19193: LD_VAR 0 7
19197: PUSH
19198: LD_VAR 0 9
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PPUSH
19207: CALL_OW 2
19211: ST_TO_ADDR
19212: GO 19294
// for j = 1 to result do
19214: LD_ADDR_VAR 0 8
19218: PUSH
19219: DOUBLE
19220: LD_INT 1
19222: DEC
19223: ST_TO_ADDR
19224: LD_VAR 0 6
19228: PUSH
19229: FOR_TO
19230: IFFALSE 19292
// begin if tmp < result [ j ] [ 2 ] then
19232: LD_VAR 0 9
19236: PUSH
19237: LD_VAR 0 6
19241: PUSH
19242: LD_VAR 0 8
19246: ARRAY
19247: PUSH
19248: LD_INT 2
19250: ARRAY
19251: LESS
19252: IFFALSE 19290
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19254: LD_ADDR_VAR 0 6
19258: PUSH
19259: LD_VAR 0 6
19263: PPUSH
19264: LD_VAR 0 8
19268: PPUSH
19269: LD_VAR 0 7
19273: PUSH
19274: LD_VAR 0 9
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: PPUSH
19283: CALL_OW 2
19287: ST_TO_ADDR
// break ;
19288: GO 19292
// end ; end ;
19290: GO 19229
19292: POP
19293: POP
// end ; end ;
19294: GO 19093
19296: POP
19297: POP
// if result and not asc then
19298: LD_VAR 0 6
19302: PUSH
19303: LD_VAR 0 4
19307: NOT
19308: AND
19309: IFFALSE 19384
// begin tmp := result ;
19311: LD_ADDR_VAR 0 9
19315: PUSH
19316: LD_VAR 0 6
19320: ST_TO_ADDR
// for i = tmp downto 1 do
19321: LD_ADDR_VAR 0 7
19325: PUSH
19326: DOUBLE
19327: LD_VAR 0 9
19331: INC
19332: ST_TO_ADDR
19333: LD_INT 1
19335: PUSH
19336: FOR_DOWNTO
19337: IFFALSE 19382
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19339: LD_ADDR_VAR 0 6
19343: PUSH
19344: LD_VAR 0 6
19348: PPUSH
19349: LD_VAR 0 9
19353: PUSH
19354: LD_VAR 0 7
19358: MINUS
19359: PUSH
19360: LD_INT 1
19362: PLUS
19363: PPUSH
19364: LD_VAR 0 9
19368: PUSH
19369: LD_VAR 0 7
19373: ARRAY
19374: PPUSH
19375: CALL_OW 1
19379: ST_TO_ADDR
19380: GO 19336
19382: POP
19383: POP
// end ; tmp := [ ] ;
19384: LD_ADDR_VAR 0 9
19388: PUSH
19389: EMPTY
19390: ST_TO_ADDR
// if mode then
19391: LD_VAR 0 5
19395: IFFALSE 19464
// begin for i = 1 to result do
19397: LD_ADDR_VAR 0 7
19401: PUSH
19402: DOUBLE
19403: LD_INT 1
19405: DEC
19406: ST_TO_ADDR
19407: LD_VAR 0 6
19411: PUSH
19412: FOR_TO
19413: IFFALSE 19452
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19415: LD_ADDR_VAR 0 9
19419: PUSH
19420: LD_VAR 0 9
19424: PPUSH
19425: LD_VAR 0 7
19429: PPUSH
19430: LD_VAR 0 6
19434: PUSH
19435: LD_VAR 0 7
19439: ARRAY
19440: PUSH
19441: LD_INT 1
19443: ARRAY
19444: PPUSH
19445: CALL_OW 1
19449: ST_TO_ADDR
19450: GO 19412
19452: POP
19453: POP
// result := tmp ;
19454: LD_ADDR_VAR 0 6
19458: PUSH
19459: LD_VAR 0 9
19463: ST_TO_ADDR
// end ; end ;
19464: LD_VAR 0 6
19468: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19469: LD_INT 0
19471: PPUSH
19472: PPUSH
19473: PPUSH
19474: PPUSH
19475: PPUSH
19476: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19477: LD_ADDR_VAR 0 5
19481: PUSH
19482: LD_INT 0
19484: PUSH
19485: LD_INT 0
19487: PUSH
19488: LD_INT 0
19490: PUSH
19491: EMPTY
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: LIST
19498: ST_TO_ADDR
// if not x or not y then
19499: LD_VAR 0 2
19503: NOT
19504: PUSH
19505: LD_VAR 0 3
19509: NOT
19510: OR
19511: IFFALSE 19515
// exit ;
19513: GO 21165
// if not range then
19515: LD_VAR 0 4
19519: NOT
19520: IFFALSE 19530
// range := 10 ;
19522: LD_ADDR_VAR 0 4
19526: PUSH
19527: LD_INT 10
19529: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19530: LD_ADDR_VAR 0 8
19534: PUSH
19535: LD_INT 81
19537: PUSH
19538: LD_VAR 0 1
19542: PUSH
19543: EMPTY
19544: LIST
19545: LIST
19546: PUSH
19547: LD_INT 92
19549: PUSH
19550: LD_VAR 0 2
19554: PUSH
19555: LD_VAR 0 3
19559: PUSH
19560: LD_VAR 0 4
19564: PUSH
19565: EMPTY
19566: LIST
19567: LIST
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 3
19573: PUSH
19574: LD_INT 21
19576: PUSH
19577: LD_INT 3
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: PPUSH
19593: CALL_OW 69
19597: ST_TO_ADDR
// if not tmp then
19598: LD_VAR 0 8
19602: NOT
19603: IFFALSE 19607
// exit ;
19605: GO 21165
// for i in tmp do
19607: LD_ADDR_VAR 0 6
19611: PUSH
19612: LD_VAR 0 8
19616: PUSH
19617: FOR_IN
19618: IFFALSE 21140
// begin points := [ 0 , 0 , 0 ] ;
19620: LD_ADDR_VAR 0 9
19624: PUSH
19625: LD_INT 0
19627: PUSH
19628: LD_INT 0
19630: PUSH
19631: LD_INT 0
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: LIST
19638: ST_TO_ADDR
// bpoints := 1 ;
19639: LD_ADDR_VAR 0 10
19643: PUSH
19644: LD_INT 1
19646: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19647: LD_VAR 0 6
19651: PPUSH
19652: CALL_OW 247
19656: PUSH
19657: LD_INT 1
19659: DOUBLE
19660: EQUAL
19661: IFTRUE 19665
19663: GO 20243
19665: POP
// begin if GetClass ( i ) = 1 then
19666: LD_VAR 0 6
19670: PPUSH
19671: CALL_OW 257
19675: PUSH
19676: LD_INT 1
19678: EQUAL
19679: IFFALSE 19700
// points := [ 10 , 5 , 3 ] ;
19681: LD_ADDR_VAR 0 9
19685: PUSH
19686: LD_INT 10
19688: PUSH
19689: LD_INT 5
19691: PUSH
19692: LD_INT 3
19694: PUSH
19695: EMPTY
19696: LIST
19697: LIST
19698: LIST
19699: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19700: LD_VAR 0 6
19704: PPUSH
19705: CALL_OW 257
19709: PUSH
19710: LD_INT 2
19712: PUSH
19713: LD_INT 3
19715: PUSH
19716: LD_INT 4
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: IN
19724: IFFALSE 19745
// points := [ 3 , 2 , 1 ] ;
19726: LD_ADDR_VAR 0 9
19730: PUSH
19731: LD_INT 3
19733: PUSH
19734: LD_INT 2
19736: PUSH
19737: LD_INT 1
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19745: LD_VAR 0 6
19749: PPUSH
19750: CALL_OW 257
19754: PUSH
19755: LD_INT 5
19757: EQUAL
19758: IFFALSE 19779
// points := [ 130 , 5 , 2 ] ;
19760: LD_ADDR_VAR 0 9
19764: PUSH
19765: LD_INT 130
19767: PUSH
19768: LD_INT 5
19770: PUSH
19771: LD_INT 2
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19779: LD_VAR 0 6
19783: PPUSH
19784: CALL_OW 257
19788: PUSH
19789: LD_INT 8
19791: EQUAL
19792: IFFALSE 19813
// points := [ 35 , 35 , 30 ] ;
19794: LD_ADDR_VAR 0 9
19798: PUSH
19799: LD_INT 35
19801: PUSH
19802: LD_INT 35
19804: PUSH
19805: LD_INT 30
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: LIST
19812: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19813: LD_VAR 0 6
19817: PPUSH
19818: CALL_OW 257
19822: PUSH
19823: LD_INT 9
19825: EQUAL
19826: IFFALSE 19847
// points := [ 20 , 55 , 40 ] ;
19828: LD_ADDR_VAR 0 9
19832: PUSH
19833: LD_INT 20
19835: PUSH
19836: LD_INT 55
19838: PUSH
19839: LD_INT 40
19841: PUSH
19842: EMPTY
19843: LIST
19844: LIST
19845: LIST
19846: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19847: LD_VAR 0 6
19851: PPUSH
19852: CALL_OW 257
19856: PUSH
19857: LD_INT 12
19859: PUSH
19860: LD_INT 16
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: IN
19867: IFFALSE 19888
// points := [ 5 , 3 , 2 ] ;
19869: LD_ADDR_VAR 0 9
19873: PUSH
19874: LD_INT 5
19876: PUSH
19877: LD_INT 3
19879: PUSH
19880: LD_INT 2
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: LIST
19887: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19888: LD_VAR 0 6
19892: PPUSH
19893: CALL_OW 257
19897: PUSH
19898: LD_INT 17
19900: EQUAL
19901: IFFALSE 19922
// points := [ 100 , 50 , 75 ] ;
19903: LD_ADDR_VAR 0 9
19907: PUSH
19908: LD_INT 100
19910: PUSH
19911: LD_INT 50
19913: PUSH
19914: LD_INT 75
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: LIST
19921: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19922: LD_VAR 0 6
19926: PPUSH
19927: CALL_OW 257
19931: PUSH
19932: LD_INT 15
19934: EQUAL
19935: IFFALSE 19956
// points := [ 10 , 5 , 3 ] ;
19937: LD_ADDR_VAR 0 9
19941: PUSH
19942: LD_INT 10
19944: PUSH
19945: LD_INT 5
19947: PUSH
19948: LD_INT 3
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19956: LD_VAR 0 6
19960: PPUSH
19961: CALL_OW 257
19965: PUSH
19966: LD_INT 14
19968: EQUAL
19969: IFFALSE 19990
// points := [ 10 , 0 , 0 ] ;
19971: LD_ADDR_VAR 0 9
19975: PUSH
19976: LD_INT 10
19978: PUSH
19979: LD_INT 0
19981: PUSH
19982: LD_INT 0
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19990: LD_VAR 0 6
19994: PPUSH
19995: CALL_OW 257
19999: PUSH
20000: LD_INT 11
20002: EQUAL
20003: IFFALSE 20024
// points := [ 30 , 10 , 5 ] ;
20005: LD_ADDR_VAR 0 9
20009: PUSH
20010: LD_INT 30
20012: PUSH
20013: LD_INT 10
20015: PUSH
20016: LD_INT 5
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20024: LD_VAR 0 1
20028: PPUSH
20029: LD_INT 5
20031: PPUSH
20032: CALL_OW 321
20036: PUSH
20037: LD_INT 2
20039: EQUAL
20040: IFFALSE 20057
// bpoints := bpoints * 1.8 ;
20042: LD_ADDR_VAR 0 10
20046: PUSH
20047: LD_VAR 0 10
20051: PUSH
20052: LD_REAL  1.80000000000000E+0000
20055: MUL
20056: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20057: LD_VAR 0 6
20061: PPUSH
20062: CALL_OW 257
20066: PUSH
20067: LD_INT 1
20069: PUSH
20070: LD_INT 2
20072: PUSH
20073: LD_INT 3
20075: PUSH
20076: LD_INT 4
20078: PUSH
20079: EMPTY
20080: LIST
20081: LIST
20082: LIST
20083: LIST
20084: IN
20085: PUSH
20086: LD_VAR 0 1
20090: PPUSH
20091: LD_INT 51
20093: PPUSH
20094: CALL_OW 321
20098: PUSH
20099: LD_INT 2
20101: EQUAL
20102: AND
20103: IFFALSE 20120
// bpoints := bpoints * 1.2 ;
20105: LD_ADDR_VAR 0 10
20109: PUSH
20110: LD_VAR 0 10
20114: PUSH
20115: LD_REAL  1.20000000000000E+0000
20118: MUL
20119: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20120: LD_VAR 0 6
20124: PPUSH
20125: CALL_OW 257
20129: PUSH
20130: LD_INT 5
20132: PUSH
20133: LD_INT 7
20135: PUSH
20136: LD_INT 9
20138: PUSH
20139: EMPTY
20140: LIST
20141: LIST
20142: LIST
20143: IN
20144: PUSH
20145: LD_VAR 0 1
20149: PPUSH
20150: LD_INT 52
20152: PPUSH
20153: CALL_OW 321
20157: PUSH
20158: LD_INT 2
20160: EQUAL
20161: AND
20162: IFFALSE 20179
// bpoints := bpoints * 1.5 ;
20164: LD_ADDR_VAR 0 10
20168: PUSH
20169: LD_VAR 0 10
20173: PUSH
20174: LD_REAL  1.50000000000000E+0000
20177: MUL
20178: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20179: LD_VAR 0 1
20183: PPUSH
20184: LD_INT 66
20186: PPUSH
20187: CALL_OW 321
20191: PUSH
20192: LD_INT 2
20194: EQUAL
20195: IFFALSE 20212
// bpoints := bpoints * 1.1 ;
20197: LD_ADDR_VAR 0 10
20201: PUSH
20202: LD_VAR 0 10
20206: PUSH
20207: LD_REAL  1.10000000000000E+0000
20210: MUL
20211: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20212: LD_ADDR_VAR 0 10
20216: PUSH
20217: LD_VAR 0 10
20221: PUSH
20222: LD_VAR 0 6
20226: PPUSH
20227: LD_INT 1
20229: PPUSH
20230: CALL_OW 259
20234: PUSH
20235: LD_REAL  1.15000000000000E+0000
20238: MUL
20239: MUL
20240: ST_TO_ADDR
// end ; unit_vehicle :
20241: GO 21069
20243: LD_INT 2
20245: DOUBLE
20246: EQUAL
20247: IFTRUE 20251
20249: GO 21057
20251: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20252: LD_VAR 0 6
20256: PPUSH
20257: CALL_OW 264
20261: PUSH
20262: LD_INT 2
20264: PUSH
20265: LD_INT 42
20267: PUSH
20268: LD_INT 24
20270: PUSH
20271: EMPTY
20272: LIST
20273: LIST
20274: LIST
20275: IN
20276: IFFALSE 20297
// points := [ 25 , 5 , 3 ] ;
20278: LD_ADDR_VAR 0 9
20282: PUSH
20283: LD_INT 25
20285: PUSH
20286: LD_INT 5
20288: PUSH
20289: LD_INT 3
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: LIST
20296: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20297: LD_VAR 0 6
20301: PPUSH
20302: CALL_OW 264
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 43
20312: PUSH
20313: LD_INT 25
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: LIST
20320: IN
20321: IFFALSE 20342
// points := [ 40 , 15 , 5 ] ;
20323: LD_ADDR_VAR 0 9
20327: PUSH
20328: LD_INT 40
20330: PUSH
20331: LD_INT 15
20333: PUSH
20334: LD_INT 5
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20342: LD_VAR 0 6
20346: PPUSH
20347: CALL_OW 264
20351: PUSH
20352: LD_INT 3
20354: PUSH
20355: LD_INT 23
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: IN
20362: IFFALSE 20383
// points := [ 7 , 25 , 8 ] ;
20364: LD_ADDR_VAR 0 9
20368: PUSH
20369: LD_INT 7
20371: PUSH
20372: LD_INT 25
20374: PUSH
20375: LD_INT 8
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: LIST
20382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20383: LD_VAR 0 6
20387: PPUSH
20388: CALL_OW 264
20392: PUSH
20393: LD_INT 5
20395: PUSH
20396: LD_INT 27
20398: PUSH
20399: LD_INT 44
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: LIST
20406: IN
20407: IFFALSE 20428
// points := [ 14 , 50 , 16 ] ;
20409: LD_ADDR_VAR 0 9
20413: PUSH
20414: LD_INT 14
20416: PUSH
20417: LD_INT 50
20419: PUSH
20420: LD_INT 16
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: LIST
20427: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20428: LD_VAR 0 6
20432: PPUSH
20433: CALL_OW 264
20437: PUSH
20438: LD_INT 6
20440: PUSH
20441: LD_INT 46
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: IN
20448: IFFALSE 20469
// points := [ 32 , 120 , 70 ] ;
20450: LD_ADDR_VAR 0 9
20454: PUSH
20455: LD_INT 32
20457: PUSH
20458: LD_INT 120
20460: PUSH
20461: LD_INT 70
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
20469: LD_VAR 0 6
20473: PPUSH
20474: CALL_OW 264
20478: PUSH
20479: LD_INT 7
20481: PUSH
20482: LD_INT 28
20484: PUSH
20485: LD_INT 45
20487: PUSH
20488: LD_INT 92
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: LIST
20496: IN
20497: IFFALSE 20518
// points := [ 35 , 20 , 45 ] ;
20499: LD_ADDR_VAR 0 9
20503: PUSH
20504: LD_INT 35
20506: PUSH
20507: LD_INT 20
20509: PUSH
20510: LD_INT 45
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: LIST
20517: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20518: LD_VAR 0 6
20522: PPUSH
20523: CALL_OW 264
20527: PUSH
20528: LD_INT 47
20530: PUSH
20531: EMPTY
20532: LIST
20533: IN
20534: IFFALSE 20555
// points := [ 67 , 45 , 75 ] ;
20536: LD_ADDR_VAR 0 9
20540: PUSH
20541: LD_INT 67
20543: PUSH
20544: LD_INT 45
20546: PUSH
20547: LD_INT 75
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: LIST
20554: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20555: LD_VAR 0 6
20559: PPUSH
20560: CALL_OW 264
20564: PUSH
20565: LD_INT 26
20567: PUSH
20568: EMPTY
20569: LIST
20570: IN
20571: IFFALSE 20592
// points := [ 120 , 30 , 80 ] ;
20573: LD_ADDR_VAR 0 9
20577: PUSH
20578: LD_INT 120
20580: PUSH
20581: LD_INT 30
20583: PUSH
20584: LD_INT 80
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: LIST
20591: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20592: LD_VAR 0 6
20596: PPUSH
20597: CALL_OW 264
20601: PUSH
20602: LD_INT 22
20604: PUSH
20605: EMPTY
20606: LIST
20607: IN
20608: IFFALSE 20629
// points := [ 40 , 1 , 1 ] ;
20610: LD_ADDR_VAR 0 9
20614: PUSH
20615: LD_INT 40
20617: PUSH
20618: LD_INT 1
20620: PUSH
20621: LD_INT 1
20623: PUSH
20624: EMPTY
20625: LIST
20626: LIST
20627: LIST
20628: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20629: LD_VAR 0 6
20633: PPUSH
20634: CALL_OW 264
20638: PUSH
20639: LD_INT 29
20641: PUSH
20642: EMPTY
20643: LIST
20644: IN
20645: IFFALSE 20666
// points := [ 70 , 200 , 400 ] ;
20647: LD_ADDR_VAR 0 9
20651: PUSH
20652: LD_INT 70
20654: PUSH
20655: LD_INT 200
20657: PUSH
20658: LD_INT 400
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: LIST
20665: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20666: LD_VAR 0 6
20670: PPUSH
20671: CALL_OW 264
20675: PUSH
20676: LD_INT 14
20678: PUSH
20679: LD_INT 53
20681: PUSH
20682: EMPTY
20683: LIST
20684: LIST
20685: IN
20686: IFFALSE 20707
// points := [ 40 , 10 , 20 ] ;
20688: LD_ADDR_VAR 0 9
20692: PUSH
20693: LD_INT 40
20695: PUSH
20696: LD_INT 10
20698: PUSH
20699: LD_INT 20
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: LIST
20706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20707: LD_VAR 0 6
20711: PPUSH
20712: CALL_OW 264
20716: PUSH
20717: LD_INT 9
20719: PUSH
20720: EMPTY
20721: LIST
20722: IN
20723: IFFALSE 20744
// points := [ 5 , 70 , 20 ] ;
20725: LD_ADDR_VAR 0 9
20729: PUSH
20730: LD_INT 5
20732: PUSH
20733: LD_INT 70
20735: PUSH
20736: LD_INT 20
20738: PUSH
20739: EMPTY
20740: LIST
20741: LIST
20742: LIST
20743: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20744: LD_VAR 0 6
20748: PPUSH
20749: CALL_OW 264
20753: PUSH
20754: LD_INT 10
20756: PUSH
20757: EMPTY
20758: LIST
20759: IN
20760: IFFALSE 20781
// points := [ 35 , 110 , 70 ] ;
20762: LD_ADDR_VAR 0 9
20766: PUSH
20767: LD_INT 35
20769: PUSH
20770: LD_INT 110
20772: PUSH
20773: LD_INT 70
20775: PUSH
20776: EMPTY
20777: LIST
20778: LIST
20779: LIST
20780: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20781: LD_VAR 0 6
20785: PPUSH
20786: CALL_OW 265
20790: PUSH
20791: LD_INT 25
20793: EQUAL
20794: IFFALSE 20815
// points := [ 80 , 65 , 100 ] ;
20796: LD_ADDR_VAR 0 9
20800: PUSH
20801: LD_INT 80
20803: PUSH
20804: LD_INT 65
20806: PUSH
20807: LD_INT 100
20809: PUSH
20810: EMPTY
20811: LIST
20812: LIST
20813: LIST
20814: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20815: LD_VAR 0 6
20819: PPUSH
20820: CALL_OW 263
20824: PUSH
20825: LD_INT 1
20827: EQUAL
20828: IFFALSE 20863
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20830: LD_ADDR_VAR 0 10
20834: PUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_VAR 0 6
20844: PPUSH
20845: CALL_OW 311
20849: PPUSH
20850: LD_INT 3
20852: PPUSH
20853: CALL_OW 259
20857: PUSH
20858: LD_INT 4
20860: MUL
20861: MUL
20862: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20863: LD_VAR 0 6
20867: PPUSH
20868: CALL_OW 263
20872: PUSH
20873: LD_INT 2
20875: EQUAL
20876: IFFALSE 20927
// begin j := IsControledBy ( i ) ;
20878: LD_ADDR_VAR 0 7
20882: PUSH
20883: LD_VAR 0 6
20887: PPUSH
20888: CALL_OW 312
20892: ST_TO_ADDR
// if j then
20893: LD_VAR 0 7
20897: IFFALSE 20927
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20899: LD_ADDR_VAR 0 10
20903: PUSH
20904: LD_VAR 0 10
20908: PUSH
20909: LD_VAR 0 7
20913: PPUSH
20914: LD_INT 3
20916: PPUSH
20917: CALL_OW 259
20921: PUSH
20922: LD_INT 3
20924: MUL
20925: MUL
20926: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20927: LD_VAR 0 6
20931: PPUSH
20932: CALL_OW 264
20936: PUSH
20937: LD_INT 5
20939: PUSH
20940: LD_INT 6
20942: PUSH
20943: LD_INT 46
20945: PUSH
20946: LD_INT 44
20948: PUSH
20949: LD_INT 47
20951: PUSH
20952: LD_INT 45
20954: PUSH
20955: LD_INT 28
20957: PUSH
20958: LD_INT 7
20960: PUSH
20961: LD_INT 27
20963: PUSH
20964: LD_INT 29
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: LIST
20971: LIST
20972: LIST
20973: LIST
20974: LIST
20975: LIST
20976: LIST
20977: LIST
20978: IN
20979: PUSH
20980: LD_VAR 0 1
20984: PPUSH
20985: LD_INT 52
20987: PPUSH
20988: CALL_OW 321
20992: PUSH
20993: LD_INT 2
20995: EQUAL
20996: AND
20997: IFFALSE 21014
// bpoints := bpoints * 1.2 ;
20999: LD_ADDR_VAR 0 10
21003: PUSH
21004: LD_VAR 0 10
21008: PUSH
21009: LD_REAL  1.20000000000000E+0000
21012: MUL
21013: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21014: LD_VAR 0 6
21018: PPUSH
21019: CALL_OW 264
21023: PUSH
21024: LD_INT 6
21026: PUSH
21027: LD_INT 46
21029: PUSH
21030: LD_INT 47
21032: PUSH
21033: EMPTY
21034: LIST
21035: LIST
21036: LIST
21037: IN
21038: IFFALSE 21055
// bpoints := bpoints * 1.2 ;
21040: LD_ADDR_VAR 0 10
21044: PUSH
21045: LD_VAR 0 10
21049: PUSH
21050: LD_REAL  1.20000000000000E+0000
21053: MUL
21054: ST_TO_ADDR
// end ; unit_building :
21055: GO 21069
21057: LD_INT 3
21059: DOUBLE
21060: EQUAL
21061: IFTRUE 21065
21063: GO 21068
21065: POP
// ; end ;
21066: GO 21069
21068: POP
// for j = 1 to 3 do
21069: LD_ADDR_VAR 0 7
21073: PUSH
21074: DOUBLE
21075: LD_INT 1
21077: DEC
21078: ST_TO_ADDR
21079: LD_INT 3
21081: PUSH
21082: FOR_TO
21083: IFFALSE 21136
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21085: LD_ADDR_VAR 0 5
21089: PUSH
21090: LD_VAR 0 5
21094: PPUSH
21095: LD_VAR 0 7
21099: PPUSH
21100: LD_VAR 0 5
21104: PUSH
21105: LD_VAR 0 7
21109: ARRAY
21110: PUSH
21111: LD_VAR 0 9
21115: PUSH
21116: LD_VAR 0 7
21120: ARRAY
21121: PUSH
21122: LD_VAR 0 10
21126: MUL
21127: PLUS
21128: PPUSH
21129: CALL_OW 1
21133: ST_TO_ADDR
21134: GO 21082
21136: POP
21137: POP
// end ;
21138: GO 19617
21140: POP
21141: POP
// result := Replace ( result , 4 , tmp ) ;
21142: LD_ADDR_VAR 0 5
21146: PUSH
21147: LD_VAR 0 5
21151: PPUSH
21152: LD_INT 4
21154: PPUSH
21155: LD_VAR 0 8
21159: PPUSH
21160: CALL_OW 1
21164: ST_TO_ADDR
// end ;
21165: LD_VAR 0 5
21169: RET
// export function DangerAtRange ( unit , range ) ; begin
21170: LD_INT 0
21172: PPUSH
// if not unit then
21173: LD_VAR 0 1
21177: NOT
21178: IFFALSE 21182
// exit ;
21180: GO 21227
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21182: LD_ADDR_VAR 0 3
21186: PUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: CALL_OW 255
21196: PPUSH
21197: LD_VAR 0 1
21201: PPUSH
21202: CALL_OW 250
21206: PPUSH
21207: LD_VAR 0 1
21211: PPUSH
21212: CALL_OW 251
21216: PPUSH
21217: LD_VAR 0 2
21221: PPUSH
21222: CALL 19469 0 4
21226: ST_TO_ADDR
// end ;
21227: LD_VAR 0 3
21231: RET
// export function DangerInArea ( side , area ) ; begin
21232: LD_INT 0
21234: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21235: LD_ADDR_VAR 0 3
21239: PUSH
21240: LD_VAR 0 2
21244: PPUSH
21245: LD_INT 81
21247: PUSH
21248: LD_VAR 0 1
21252: PUSH
21253: EMPTY
21254: LIST
21255: LIST
21256: PPUSH
21257: CALL_OW 70
21261: ST_TO_ADDR
// end ;
21262: LD_VAR 0 3
21266: RET
// export function IsExtension ( b ) ; begin
21267: LD_INT 0
21269: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21270: LD_ADDR_VAR 0 2
21274: PUSH
21275: LD_VAR 0 1
21279: PUSH
21280: LD_INT 23
21282: PUSH
21283: LD_INT 20
21285: PUSH
21286: LD_INT 22
21288: PUSH
21289: LD_INT 17
21291: PUSH
21292: LD_INT 24
21294: PUSH
21295: LD_INT 21
21297: PUSH
21298: LD_INT 19
21300: PUSH
21301: LD_INT 16
21303: PUSH
21304: LD_INT 25
21306: PUSH
21307: LD_INT 18
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: LIST
21316: LIST
21317: LIST
21318: LIST
21319: LIST
21320: LIST
21321: IN
21322: ST_TO_ADDR
// end ;
21323: LD_VAR 0 2
21327: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
21328: LD_INT 0
21330: PPUSH
21331: PPUSH
21332: PPUSH
// result := [ ] ;
21333: LD_ADDR_VAR 0 4
21337: PUSH
21338: EMPTY
21339: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21340: LD_ADDR_VAR 0 5
21344: PUSH
21345: LD_VAR 0 2
21349: PPUSH
21350: LD_INT 21
21352: PUSH
21353: LD_INT 3
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PPUSH
21360: CALL_OW 70
21364: ST_TO_ADDR
// if not tmp then
21365: LD_VAR 0 5
21369: NOT
21370: IFFALSE 21374
// exit ;
21372: GO 21438
// if checkLink then
21374: LD_VAR 0 3
21378: IFFALSE 21428
// begin for i in tmp do
21380: LD_ADDR_VAR 0 6
21384: PUSH
21385: LD_VAR 0 5
21389: PUSH
21390: FOR_IN
21391: IFFALSE 21426
// if GetBase ( i ) <> base then
21393: LD_VAR 0 6
21397: PPUSH
21398: CALL_OW 274
21402: PUSH
21403: LD_VAR 0 1
21407: NONEQUAL
21408: IFFALSE 21424
// ComLinkToBase ( base , i ) ;
21410: LD_VAR 0 1
21414: PPUSH
21415: LD_VAR 0 6
21419: PPUSH
21420: CALL_OW 169
21424: GO 21390
21426: POP
21427: POP
// end ; result := tmp ;
21428: LD_ADDR_VAR 0 4
21432: PUSH
21433: LD_VAR 0 5
21437: ST_TO_ADDR
// end ;
21438: LD_VAR 0 4
21442: RET
// export function ComComplete ( units , b ) ; var i ; begin
21443: LD_INT 0
21445: PPUSH
21446: PPUSH
// if not units then
21447: LD_VAR 0 1
21451: NOT
21452: IFFALSE 21456
// exit ;
21454: GO 21546
// for i in units do
21456: LD_ADDR_VAR 0 4
21460: PUSH
21461: LD_VAR 0 1
21465: PUSH
21466: FOR_IN
21467: IFFALSE 21544
// if BuildingStatus ( b ) = bs_build then
21469: LD_VAR 0 2
21473: PPUSH
21474: CALL_OW 461
21478: PUSH
21479: LD_INT 1
21481: EQUAL
21482: IFFALSE 21542
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21484: LD_VAR 0 4
21488: PPUSH
21489: LD_STRING h
21491: PUSH
21492: LD_VAR 0 2
21496: PPUSH
21497: CALL_OW 250
21501: PUSH
21502: LD_VAR 0 2
21506: PPUSH
21507: CALL_OW 251
21511: PUSH
21512: LD_VAR 0 2
21516: PUSH
21517: LD_INT 0
21519: PUSH
21520: LD_INT 0
21522: PUSH
21523: LD_INT 0
21525: PUSH
21526: EMPTY
21527: LIST
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: LIST
21533: LIST
21534: PUSH
21535: EMPTY
21536: LIST
21537: PPUSH
21538: CALL_OW 446
21542: GO 21466
21544: POP
21545: POP
// end ;
21546: LD_VAR 0 3
21550: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21551: LD_INT 0
21553: PPUSH
21554: PPUSH
21555: PPUSH
21556: PPUSH
21557: PPUSH
21558: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
21559: LD_VAR 0 1
21563: NOT
21564: PUSH
21565: LD_VAR 0 1
21569: PPUSH
21570: CALL_OW 263
21574: PUSH
21575: LD_INT 2
21577: NONEQUAL
21578: OR
21579: IFFALSE 21583
// exit ;
21581: GO 21899
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21583: LD_ADDR_VAR 0 6
21587: PUSH
21588: LD_INT 22
21590: PUSH
21591: LD_VAR 0 1
21595: PPUSH
21596: CALL_OW 255
21600: PUSH
21601: EMPTY
21602: LIST
21603: LIST
21604: PUSH
21605: LD_INT 2
21607: PUSH
21608: LD_INT 30
21610: PUSH
21611: LD_INT 36
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: PUSH
21618: LD_INT 34
21620: PUSH
21621: LD_INT 31
21623: PUSH
21624: EMPTY
21625: LIST
21626: LIST
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: LIST
21632: PUSH
21633: EMPTY
21634: LIST
21635: LIST
21636: PPUSH
21637: CALL_OW 69
21641: ST_TO_ADDR
// if not tmp then
21642: LD_VAR 0 6
21646: NOT
21647: IFFALSE 21651
// exit ;
21649: GO 21899
// result := [ ] ;
21651: LD_ADDR_VAR 0 2
21655: PUSH
21656: EMPTY
21657: ST_TO_ADDR
// for i in tmp do
21658: LD_ADDR_VAR 0 3
21662: PUSH
21663: LD_VAR 0 6
21667: PUSH
21668: FOR_IN
21669: IFFALSE 21740
// begin t := UnitsInside ( i ) ;
21671: LD_ADDR_VAR 0 4
21675: PUSH
21676: LD_VAR 0 3
21680: PPUSH
21681: CALL_OW 313
21685: ST_TO_ADDR
// if t then
21686: LD_VAR 0 4
21690: IFFALSE 21738
// for j in t do
21692: LD_ADDR_VAR 0 7
21696: PUSH
21697: LD_VAR 0 4
21701: PUSH
21702: FOR_IN
21703: IFFALSE 21736
// result := Replace ( result , result + 1 , j ) ;
21705: LD_ADDR_VAR 0 2
21709: PUSH
21710: LD_VAR 0 2
21714: PPUSH
21715: LD_VAR 0 2
21719: PUSH
21720: LD_INT 1
21722: PLUS
21723: PPUSH
21724: LD_VAR 0 7
21728: PPUSH
21729: CALL_OW 1
21733: ST_TO_ADDR
21734: GO 21702
21736: POP
21737: POP
// end ;
21738: GO 21668
21740: POP
21741: POP
// if not result then
21742: LD_VAR 0 2
21746: NOT
21747: IFFALSE 21751
// exit ;
21749: GO 21899
// mech := result [ 1 ] ;
21751: LD_ADDR_VAR 0 5
21755: PUSH
21756: LD_VAR 0 2
21760: PUSH
21761: LD_INT 1
21763: ARRAY
21764: ST_TO_ADDR
// if result > 1 then
21765: LD_VAR 0 2
21769: PUSH
21770: LD_INT 1
21772: GREATER
21773: IFFALSE 21885
// begin for i = 2 to result do
21775: LD_ADDR_VAR 0 3
21779: PUSH
21780: DOUBLE
21781: LD_INT 2
21783: DEC
21784: ST_TO_ADDR
21785: LD_VAR 0 2
21789: PUSH
21790: FOR_TO
21791: IFFALSE 21883
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21793: LD_ADDR_VAR 0 4
21797: PUSH
21798: LD_VAR 0 2
21802: PUSH
21803: LD_VAR 0 3
21807: ARRAY
21808: PPUSH
21809: LD_INT 3
21811: PPUSH
21812: CALL_OW 259
21816: PUSH
21817: LD_VAR 0 2
21821: PUSH
21822: LD_VAR 0 3
21826: ARRAY
21827: PPUSH
21828: CALL_OW 432
21832: MINUS
21833: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21834: LD_VAR 0 4
21838: PUSH
21839: LD_VAR 0 5
21843: PPUSH
21844: LD_INT 3
21846: PPUSH
21847: CALL_OW 259
21851: PUSH
21852: LD_VAR 0 5
21856: PPUSH
21857: CALL_OW 432
21861: MINUS
21862: GREATEREQUAL
21863: IFFALSE 21881
// mech := result [ i ] ;
21865: LD_ADDR_VAR 0 5
21869: PUSH
21870: LD_VAR 0 2
21874: PUSH
21875: LD_VAR 0 3
21879: ARRAY
21880: ST_TO_ADDR
// end ;
21881: GO 21790
21883: POP
21884: POP
// end ; ComLinkTo ( vehicle , mech ) ;
21885: LD_VAR 0 1
21889: PPUSH
21890: LD_VAR 0 5
21894: PPUSH
21895: CALL_OW 135
// end ;
21899: LD_VAR 0 2
21903: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21904: LD_INT 0
21906: PPUSH
21907: PPUSH
21908: PPUSH
21909: PPUSH
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
// result := [ ] ;
21919: LD_ADDR_VAR 0 7
21923: PUSH
21924: EMPTY
21925: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21926: LD_VAR 0 1
21930: PPUSH
21931: CALL_OW 266
21935: PUSH
21936: LD_INT 0
21938: PUSH
21939: LD_INT 1
21941: PUSH
21942: EMPTY
21943: LIST
21944: LIST
21945: IN
21946: NOT
21947: IFFALSE 21951
// exit ;
21949: GO 23585
// if name then
21951: LD_VAR 0 3
21955: IFFALSE 21971
// SetBName ( base_dep , name ) ;
21957: LD_VAR 0 1
21961: PPUSH
21962: LD_VAR 0 3
21966: PPUSH
21967: CALL_OW 500
// base := GetBase ( base_dep ) ;
21971: LD_ADDR_VAR 0 15
21975: PUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: CALL_OW 274
21985: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21986: LD_ADDR_VAR 0 16
21990: PUSH
21991: LD_VAR 0 1
21995: PPUSH
21996: CALL_OW 255
22000: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22001: LD_ADDR_VAR 0 17
22005: PUSH
22006: LD_VAR 0 1
22010: PPUSH
22011: CALL_OW 248
22015: ST_TO_ADDR
// if sources then
22016: LD_VAR 0 5
22020: IFFALSE 22067
// for i = 1 to 3 do
22022: LD_ADDR_VAR 0 8
22026: PUSH
22027: DOUBLE
22028: LD_INT 1
22030: DEC
22031: ST_TO_ADDR
22032: LD_INT 3
22034: PUSH
22035: FOR_TO
22036: IFFALSE 22065
// AddResourceType ( base , i , sources [ i ] ) ;
22038: LD_VAR 0 15
22042: PPUSH
22043: LD_VAR 0 8
22047: PPUSH
22048: LD_VAR 0 5
22052: PUSH
22053: LD_VAR 0 8
22057: ARRAY
22058: PPUSH
22059: CALL_OW 276
22063: GO 22035
22065: POP
22066: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22067: LD_ADDR_VAR 0 18
22071: PUSH
22072: LD_VAR 0 15
22076: PPUSH
22077: LD_VAR 0 2
22081: PPUSH
22082: LD_INT 1
22084: PPUSH
22085: CALL 21328 0 3
22089: ST_TO_ADDR
// InitHc ;
22090: CALL_OW 19
// InitUc ;
22094: CALL_OW 18
// uc_side := side ;
22098: LD_ADDR_OWVAR 20
22102: PUSH
22103: LD_VAR 0 16
22107: ST_TO_ADDR
// uc_nation := nation ;
22108: LD_ADDR_OWVAR 21
22112: PUSH
22113: LD_VAR 0 17
22117: ST_TO_ADDR
// if buildings then
22118: LD_VAR 0 18
22122: IFFALSE 23444
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22124: LD_ADDR_VAR 0 19
22128: PUSH
22129: LD_VAR 0 18
22133: PPUSH
22134: LD_INT 2
22136: PUSH
22137: LD_INT 30
22139: PUSH
22140: LD_INT 29
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: PUSH
22147: LD_INT 30
22149: PUSH
22150: LD_INT 30
22152: PUSH
22153: EMPTY
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: LIST
22160: LIST
22161: PPUSH
22162: CALL_OW 72
22166: ST_TO_ADDR
// if tmp then
22167: LD_VAR 0 19
22171: IFFALSE 22219
// for i in tmp do
22173: LD_ADDR_VAR 0 8
22177: PUSH
22178: LD_VAR 0 19
22182: PUSH
22183: FOR_IN
22184: IFFALSE 22217
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22186: LD_VAR 0 8
22190: PPUSH
22191: CALL_OW 250
22195: PPUSH
22196: LD_VAR 0 8
22200: PPUSH
22201: CALL_OW 251
22205: PPUSH
22206: LD_VAR 0 16
22210: PPUSH
22211: CALL_OW 441
22215: GO 22183
22217: POP
22218: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22219: LD_VAR 0 18
22223: PPUSH
22224: LD_INT 2
22226: PUSH
22227: LD_INT 30
22229: PUSH
22230: LD_INT 32
22232: PUSH
22233: EMPTY
22234: LIST
22235: LIST
22236: PUSH
22237: LD_INT 30
22239: PUSH
22240: LD_INT 33
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: LIST
22251: PPUSH
22252: CALL_OW 72
22256: IFFALSE 22344
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22258: LD_ADDR_VAR 0 8
22262: PUSH
22263: LD_VAR 0 18
22267: PPUSH
22268: LD_INT 2
22270: PUSH
22271: LD_INT 30
22273: PUSH
22274: LD_INT 32
22276: PUSH
22277: EMPTY
22278: LIST
22279: LIST
22280: PUSH
22281: LD_INT 30
22283: PUSH
22284: LD_INT 33
22286: PUSH
22287: EMPTY
22288: LIST
22289: LIST
22290: PUSH
22291: EMPTY
22292: LIST
22293: LIST
22294: LIST
22295: PPUSH
22296: CALL_OW 72
22300: PUSH
22301: FOR_IN
22302: IFFALSE 22342
// begin if not GetBWeapon ( i ) then
22304: LD_VAR 0 8
22308: PPUSH
22309: CALL_OW 269
22313: NOT
22314: IFFALSE 22340
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22316: LD_VAR 0 8
22320: PPUSH
22321: LD_VAR 0 8
22325: PPUSH
22326: LD_VAR 0 2
22330: PPUSH
22331: CALL 23590 0 2
22335: PPUSH
22336: CALL_OW 431
// end ;
22340: GO 22301
22342: POP
22343: POP
// end ; for i = 1 to personel do
22344: LD_ADDR_VAR 0 8
22348: PUSH
22349: DOUBLE
22350: LD_INT 1
22352: DEC
22353: ST_TO_ADDR
22354: LD_VAR 0 6
22358: PUSH
22359: FOR_TO
22360: IFFALSE 23424
// begin if i > 4 then
22362: LD_VAR 0 8
22366: PUSH
22367: LD_INT 4
22369: GREATER
22370: IFFALSE 22374
// break ;
22372: GO 23424
// case i of 1 :
22374: LD_VAR 0 8
22378: PUSH
22379: LD_INT 1
22381: DOUBLE
22382: EQUAL
22383: IFTRUE 22387
22385: GO 22467
22387: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22388: LD_ADDR_VAR 0 12
22392: PUSH
22393: LD_VAR 0 18
22397: PPUSH
22398: LD_INT 22
22400: PUSH
22401: LD_VAR 0 16
22405: PUSH
22406: EMPTY
22407: LIST
22408: LIST
22409: PUSH
22410: LD_INT 58
22412: PUSH
22413: EMPTY
22414: LIST
22415: PUSH
22416: LD_INT 2
22418: PUSH
22419: LD_INT 30
22421: PUSH
22422: LD_INT 32
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: LD_INT 30
22431: PUSH
22432: LD_INT 4
22434: PUSH
22435: EMPTY
22436: LIST
22437: LIST
22438: PUSH
22439: LD_INT 30
22441: PUSH
22442: LD_INT 5
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: PUSH
22455: EMPTY
22456: LIST
22457: LIST
22458: LIST
22459: PPUSH
22460: CALL_OW 72
22464: ST_TO_ADDR
22465: GO 22689
22467: LD_INT 2
22469: DOUBLE
22470: EQUAL
22471: IFTRUE 22475
22473: GO 22537
22475: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22476: LD_ADDR_VAR 0 12
22480: PUSH
22481: LD_VAR 0 18
22485: PPUSH
22486: LD_INT 22
22488: PUSH
22489: LD_VAR 0 16
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: PUSH
22498: LD_INT 2
22500: PUSH
22501: LD_INT 30
22503: PUSH
22504: LD_INT 0
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: PUSH
22511: LD_INT 30
22513: PUSH
22514: LD_INT 1
22516: PUSH
22517: EMPTY
22518: LIST
22519: LIST
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: LIST
22525: PUSH
22526: EMPTY
22527: LIST
22528: LIST
22529: PPUSH
22530: CALL_OW 72
22534: ST_TO_ADDR
22535: GO 22689
22537: LD_INT 3
22539: DOUBLE
22540: EQUAL
22541: IFTRUE 22545
22543: GO 22607
22545: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22546: LD_ADDR_VAR 0 12
22550: PUSH
22551: LD_VAR 0 18
22555: PPUSH
22556: LD_INT 22
22558: PUSH
22559: LD_VAR 0 16
22563: PUSH
22564: EMPTY
22565: LIST
22566: LIST
22567: PUSH
22568: LD_INT 2
22570: PUSH
22571: LD_INT 30
22573: PUSH
22574: LD_INT 2
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PUSH
22581: LD_INT 30
22583: PUSH
22584: LD_INT 3
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: LIST
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: PPUSH
22600: CALL_OW 72
22604: ST_TO_ADDR
22605: GO 22689
22607: LD_INT 4
22609: DOUBLE
22610: EQUAL
22611: IFTRUE 22615
22613: GO 22688
22615: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22616: LD_ADDR_VAR 0 12
22620: PUSH
22621: LD_VAR 0 18
22625: PPUSH
22626: LD_INT 22
22628: PUSH
22629: LD_VAR 0 16
22633: PUSH
22634: EMPTY
22635: LIST
22636: LIST
22637: PUSH
22638: LD_INT 2
22640: PUSH
22641: LD_INT 30
22643: PUSH
22644: LD_INT 6
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: LD_INT 30
22653: PUSH
22654: LD_INT 7
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: PUSH
22661: LD_INT 30
22663: PUSH
22664: LD_INT 8
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: PUSH
22677: EMPTY
22678: LIST
22679: LIST
22680: PPUSH
22681: CALL_OW 72
22685: ST_TO_ADDR
22686: GO 22689
22688: POP
// if i = 1 then
22689: LD_VAR 0 8
22693: PUSH
22694: LD_INT 1
22696: EQUAL
22697: IFFALSE 22808
// begin tmp := [ ] ;
22699: LD_ADDR_VAR 0 19
22703: PUSH
22704: EMPTY
22705: ST_TO_ADDR
// for j in f do
22706: LD_ADDR_VAR 0 9
22710: PUSH
22711: LD_VAR 0 12
22715: PUSH
22716: FOR_IN
22717: IFFALSE 22790
// if GetBType ( j ) = b_bunker then
22719: LD_VAR 0 9
22723: PPUSH
22724: CALL_OW 266
22728: PUSH
22729: LD_INT 32
22731: EQUAL
22732: IFFALSE 22759
// tmp := Insert ( tmp , 1 , j ) else
22734: LD_ADDR_VAR 0 19
22738: PUSH
22739: LD_VAR 0 19
22743: PPUSH
22744: LD_INT 1
22746: PPUSH
22747: LD_VAR 0 9
22751: PPUSH
22752: CALL_OW 2
22756: ST_TO_ADDR
22757: GO 22788
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22759: LD_ADDR_VAR 0 19
22763: PUSH
22764: LD_VAR 0 19
22768: PPUSH
22769: LD_VAR 0 19
22773: PUSH
22774: LD_INT 1
22776: PLUS
22777: PPUSH
22778: LD_VAR 0 9
22782: PPUSH
22783: CALL_OW 2
22787: ST_TO_ADDR
22788: GO 22716
22790: POP
22791: POP
// if tmp then
22792: LD_VAR 0 19
22796: IFFALSE 22808
// f := tmp ;
22798: LD_ADDR_VAR 0 12
22802: PUSH
22803: LD_VAR 0 19
22807: ST_TO_ADDR
// end ; x := personel [ i ] ;
22808: LD_ADDR_VAR 0 13
22812: PUSH
22813: LD_VAR 0 6
22817: PUSH
22818: LD_VAR 0 8
22822: ARRAY
22823: ST_TO_ADDR
// if x = - 1 then
22824: LD_VAR 0 13
22828: PUSH
22829: LD_INT 1
22831: NEG
22832: EQUAL
22833: IFFALSE 23042
// begin for j in f do
22835: LD_ADDR_VAR 0 9
22839: PUSH
22840: LD_VAR 0 12
22844: PUSH
22845: FOR_IN
22846: IFFALSE 23038
// repeat InitHc ;
22848: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22852: LD_VAR 0 9
22856: PPUSH
22857: CALL_OW 266
22861: PUSH
22862: LD_INT 5
22864: EQUAL
22865: IFFALSE 22935
// begin if UnitsInside ( j ) < 3 then
22867: LD_VAR 0 9
22871: PPUSH
22872: CALL_OW 313
22876: PUSH
22877: LD_INT 3
22879: LESS
22880: IFFALSE 22916
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22882: LD_INT 0
22884: PPUSH
22885: LD_INT 5
22887: PUSH
22888: LD_INT 8
22890: PUSH
22891: LD_INT 9
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: LIST
22898: PUSH
22899: LD_VAR 0 17
22903: ARRAY
22904: PPUSH
22905: LD_VAR 0 4
22909: PPUSH
22910: CALL_OW 380
22914: GO 22933
// PrepareHuman ( false , i , skill ) ;
22916: LD_INT 0
22918: PPUSH
22919: LD_VAR 0 8
22923: PPUSH
22924: LD_VAR 0 4
22928: PPUSH
22929: CALL_OW 380
// end else
22933: GO 22952
// PrepareHuman ( false , i , skill ) ;
22935: LD_INT 0
22937: PPUSH
22938: LD_VAR 0 8
22942: PPUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: CALL_OW 380
// un := CreateHuman ;
22952: LD_ADDR_VAR 0 14
22956: PUSH
22957: CALL_OW 44
22961: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22962: LD_ADDR_VAR 0 7
22966: PUSH
22967: LD_VAR 0 7
22971: PPUSH
22972: LD_INT 1
22974: PPUSH
22975: LD_VAR 0 14
22979: PPUSH
22980: CALL_OW 2
22984: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22985: LD_VAR 0 14
22989: PPUSH
22990: LD_VAR 0 9
22994: PPUSH
22995: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22999: LD_VAR 0 9
23003: PPUSH
23004: CALL_OW 313
23008: PUSH
23009: LD_INT 6
23011: EQUAL
23012: PUSH
23013: LD_VAR 0 9
23017: PPUSH
23018: CALL_OW 266
23022: PUSH
23023: LD_INT 32
23025: PUSH
23026: LD_INT 31
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: IN
23033: OR
23034: IFFALSE 22848
23036: GO 22845
23038: POP
23039: POP
// end else
23040: GO 23422
// for j = 1 to x do
23042: LD_ADDR_VAR 0 9
23046: PUSH
23047: DOUBLE
23048: LD_INT 1
23050: DEC
23051: ST_TO_ADDR
23052: LD_VAR 0 13
23056: PUSH
23057: FOR_TO
23058: IFFALSE 23420
// begin InitHc ;
23060: CALL_OW 19
// if not f then
23064: LD_VAR 0 12
23068: NOT
23069: IFFALSE 23158
// begin PrepareHuman ( false , i , skill ) ;
23071: LD_INT 0
23073: PPUSH
23074: LD_VAR 0 8
23078: PPUSH
23079: LD_VAR 0 4
23083: PPUSH
23084: CALL_OW 380
// un := CreateHuman ;
23088: LD_ADDR_VAR 0 14
23092: PUSH
23093: CALL_OW 44
23097: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23098: LD_ADDR_VAR 0 7
23102: PUSH
23103: LD_VAR 0 7
23107: PPUSH
23108: LD_INT 1
23110: PPUSH
23111: LD_VAR 0 14
23115: PPUSH
23116: CALL_OW 2
23120: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23121: LD_VAR 0 14
23125: PPUSH
23126: LD_VAR 0 1
23130: PPUSH
23131: CALL_OW 250
23135: PPUSH
23136: LD_VAR 0 1
23140: PPUSH
23141: CALL_OW 251
23145: PPUSH
23146: LD_INT 10
23148: PPUSH
23149: LD_INT 0
23151: PPUSH
23152: CALL_OW 50
// continue ;
23156: GO 23057
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23158: LD_VAR 0 12
23162: PUSH
23163: LD_INT 1
23165: ARRAY
23166: PPUSH
23167: CALL_OW 313
23171: PUSH
23172: LD_VAR 0 12
23176: PUSH
23177: LD_INT 1
23179: ARRAY
23180: PPUSH
23181: CALL_OW 266
23185: PUSH
23186: LD_INT 32
23188: PUSH
23189: LD_INT 31
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: IN
23196: AND
23197: PUSH
23198: LD_VAR 0 12
23202: PUSH
23203: LD_INT 1
23205: ARRAY
23206: PPUSH
23207: CALL_OW 313
23211: PUSH
23212: LD_INT 6
23214: EQUAL
23215: OR
23216: IFFALSE 23236
// f := Delete ( f , 1 ) ;
23218: LD_ADDR_VAR 0 12
23222: PUSH
23223: LD_VAR 0 12
23227: PPUSH
23228: LD_INT 1
23230: PPUSH
23231: CALL_OW 3
23235: ST_TO_ADDR
// if not f then
23236: LD_VAR 0 12
23240: NOT
23241: IFFALSE 23259
// begin x := x + 2 ;
23243: LD_ADDR_VAR 0 13
23247: PUSH
23248: LD_VAR 0 13
23252: PUSH
23253: LD_INT 2
23255: PLUS
23256: ST_TO_ADDR
// continue ;
23257: GO 23057
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23259: LD_VAR 0 12
23263: PUSH
23264: LD_INT 1
23266: ARRAY
23267: PPUSH
23268: CALL_OW 266
23272: PUSH
23273: LD_INT 5
23275: EQUAL
23276: IFFALSE 23350
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23278: LD_VAR 0 12
23282: PUSH
23283: LD_INT 1
23285: ARRAY
23286: PPUSH
23287: CALL_OW 313
23291: PUSH
23292: LD_INT 3
23294: LESS
23295: IFFALSE 23331
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23297: LD_INT 0
23299: PPUSH
23300: LD_INT 5
23302: PUSH
23303: LD_INT 8
23305: PUSH
23306: LD_INT 9
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: LIST
23313: PUSH
23314: LD_VAR 0 17
23318: ARRAY
23319: PPUSH
23320: LD_VAR 0 4
23324: PPUSH
23325: CALL_OW 380
23329: GO 23348
// PrepareHuman ( false , i , skill ) ;
23331: LD_INT 0
23333: PPUSH
23334: LD_VAR 0 8
23338: PPUSH
23339: LD_VAR 0 4
23343: PPUSH
23344: CALL_OW 380
// end else
23348: GO 23367
// PrepareHuman ( false , i , skill ) ;
23350: LD_INT 0
23352: PPUSH
23353: LD_VAR 0 8
23357: PPUSH
23358: LD_VAR 0 4
23362: PPUSH
23363: CALL_OW 380
// un := CreateHuman ;
23367: LD_ADDR_VAR 0 14
23371: PUSH
23372: CALL_OW 44
23376: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23377: LD_ADDR_VAR 0 7
23381: PUSH
23382: LD_VAR 0 7
23386: PPUSH
23387: LD_INT 1
23389: PPUSH
23390: LD_VAR 0 14
23394: PPUSH
23395: CALL_OW 2
23399: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23400: LD_VAR 0 14
23404: PPUSH
23405: LD_VAR 0 12
23409: PUSH
23410: LD_INT 1
23412: ARRAY
23413: PPUSH
23414: CALL_OW 52
// end ;
23418: GO 23057
23420: POP
23421: POP
// end ;
23422: GO 22359
23424: POP
23425: POP
// result := result ^ buildings ;
23426: LD_ADDR_VAR 0 7
23430: PUSH
23431: LD_VAR 0 7
23435: PUSH
23436: LD_VAR 0 18
23440: ADD
23441: ST_TO_ADDR
// end else
23442: GO 23585
// begin for i = 1 to personel do
23444: LD_ADDR_VAR 0 8
23448: PUSH
23449: DOUBLE
23450: LD_INT 1
23452: DEC
23453: ST_TO_ADDR
23454: LD_VAR 0 6
23458: PUSH
23459: FOR_TO
23460: IFFALSE 23583
// begin if i > 4 then
23462: LD_VAR 0 8
23466: PUSH
23467: LD_INT 4
23469: GREATER
23470: IFFALSE 23474
// break ;
23472: GO 23583
// x := personel [ i ] ;
23474: LD_ADDR_VAR 0 13
23478: PUSH
23479: LD_VAR 0 6
23483: PUSH
23484: LD_VAR 0 8
23488: ARRAY
23489: ST_TO_ADDR
// if x = - 1 then
23490: LD_VAR 0 13
23494: PUSH
23495: LD_INT 1
23497: NEG
23498: EQUAL
23499: IFFALSE 23503
// continue ;
23501: GO 23459
// PrepareHuman ( false , i , skill ) ;
23503: LD_INT 0
23505: PPUSH
23506: LD_VAR 0 8
23510: PPUSH
23511: LD_VAR 0 4
23515: PPUSH
23516: CALL_OW 380
// un := CreateHuman ;
23520: LD_ADDR_VAR 0 14
23524: PUSH
23525: CALL_OW 44
23529: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23530: LD_VAR 0 14
23534: PPUSH
23535: LD_VAR 0 1
23539: PPUSH
23540: CALL_OW 250
23544: PPUSH
23545: LD_VAR 0 1
23549: PPUSH
23550: CALL_OW 251
23554: PPUSH
23555: LD_INT 10
23557: PPUSH
23558: LD_INT 0
23560: PPUSH
23561: CALL_OW 50
// result := result ^ un ;
23565: LD_ADDR_VAR 0 7
23569: PUSH
23570: LD_VAR 0 7
23574: PUSH
23575: LD_VAR 0 14
23579: ADD
23580: ST_TO_ADDR
// end ;
23581: GO 23459
23583: POP
23584: POP
// end ; end ;
23585: LD_VAR 0 7
23589: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23590: LD_INT 0
23592: PPUSH
23593: PPUSH
23594: PPUSH
23595: PPUSH
23596: PPUSH
23597: PPUSH
23598: PPUSH
23599: PPUSH
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
23606: PPUSH
23607: PPUSH
// result := false ;
23608: LD_ADDR_VAR 0 3
23612: PUSH
23613: LD_INT 0
23615: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23616: LD_VAR 0 1
23620: NOT
23621: PUSH
23622: LD_VAR 0 1
23626: PPUSH
23627: CALL_OW 266
23631: PUSH
23632: LD_INT 32
23634: PUSH
23635: LD_INT 33
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: IN
23642: NOT
23643: OR
23644: IFFALSE 23648
// exit ;
23646: GO 24757
// nat := GetNation ( tower ) ;
23648: LD_ADDR_VAR 0 12
23652: PUSH
23653: LD_VAR 0 1
23657: PPUSH
23658: CALL_OW 248
23662: ST_TO_ADDR
// side := GetSide ( tower ) ;
23663: LD_ADDR_VAR 0 16
23667: PUSH
23668: LD_VAR 0 1
23672: PPUSH
23673: CALL_OW 255
23677: ST_TO_ADDR
// x := GetX ( tower ) ;
23678: LD_ADDR_VAR 0 10
23682: PUSH
23683: LD_VAR 0 1
23687: PPUSH
23688: CALL_OW 250
23692: ST_TO_ADDR
// y := GetY ( tower ) ;
23693: LD_ADDR_VAR 0 11
23697: PUSH
23698: LD_VAR 0 1
23702: PPUSH
23703: CALL_OW 251
23707: ST_TO_ADDR
// if not x or not y then
23708: LD_VAR 0 10
23712: NOT
23713: PUSH
23714: LD_VAR 0 11
23718: NOT
23719: OR
23720: IFFALSE 23724
// exit ;
23722: GO 24757
// weapon := 0 ;
23724: LD_ADDR_VAR 0 18
23728: PUSH
23729: LD_INT 0
23731: ST_TO_ADDR
// fac_list := [ ] ;
23732: LD_ADDR_VAR 0 17
23736: PUSH
23737: EMPTY
23738: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
23739: LD_ADDR_VAR 0 6
23743: PUSH
23744: LD_VAR 0 1
23748: PPUSH
23749: CALL_OW 274
23753: PPUSH
23754: LD_VAR 0 2
23758: PPUSH
23759: LD_INT 0
23761: PPUSH
23762: CALL 21328 0 3
23766: PPUSH
23767: LD_INT 30
23769: PUSH
23770: LD_INT 3
23772: PUSH
23773: EMPTY
23774: LIST
23775: LIST
23776: PPUSH
23777: CALL_OW 72
23781: ST_TO_ADDR
// if not factories then
23782: LD_VAR 0 6
23786: NOT
23787: IFFALSE 23791
// exit ;
23789: GO 24757
// for i in factories do
23791: LD_ADDR_VAR 0 8
23795: PUSH
23796: LD_VAR 0 6
23800: PUSH
23801: FOR_IN
23802: IFFALSE 23827
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23804: LD_ADDR_VAR 0 17
23808: PUSH
23809: LD_VAR 0 17
23813: PUSH
23814: LD_VAR 0 8
23818: PPUSH
23819: CALL_OW 478
23823: UNION
23824: ST_TO_ADDR
23825: GO 23801
23827: POP
23828: POP
// if not fac_list then
23829: LD_VAR 0 17
23833: NOT
23834: IFFALSE 23838
// exit ;
23836: GO 24757
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23838: LD_ADDR_VAR 0 5
23842: PUSH
23843: LD_INT 4
23845: PUSH
23846: LD_INT 5
23848: PUSH
23849: LD_INT 9
23851: PUSH
23852: LD_INT 10
23854: PUSH
23855: LD_INT 6
23857: PUSH
23858: LD_INT 7
23860: PUSH
23861: LD_INT 11
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: PUSH
23873: LD_INT 27
23875: PUSH
23876: LD_INT 28
23878: PUSH
23879: LD_INT 26
23881: PUSH
23882: LD_INT 30
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: LIST
23889: LIST
23890: PUSH
23891: LD_INT 43
23893: PUSH
23894: LD_INT 44
23896: PUSH
23897: LD_INT 46
23899: PUSH
23900: LD_INT 45
23902: PUSH
23903: LD_INT 47
23905: PUSH
23906: LD_INT 49
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PUSH
23922: LD_VAR 0 12
23926: ARRAY
23927: ST_TO_ADDR
// list := list isect fac_list ;
23928: LD_ADDR_VAR 0 5
23932: PUSH
23933: LD_VAR 0 5
23937: PUSH
23938: LD_VAR 0 17
23942: ISECT
23943: ST_TO_ADDR
// if not list then
23944: LD_VAR 0 5
23948: NOT
23949: IFFALSE 23953
// exit ;
23951: GO 24757
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23953: LD_VAR 0 12
23957: PUSH
23958: LD_INT 3
23960: EQUAL
23961: PUSH
23962: LD_INT 49
23964: PUSH
23965: LD_VAR 0 5
23969: IN
23970: AND
23971: PUSH
23972: LD_INT 31
23974: PPUSH
23975: LD_VAR 0 16
23979: PPUSH
23980: CALL_OW 321
23984: PUSH
23985: LD_INT 2
23987: EQUAL
23988: AND
23989: IFFALSE 24049
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23991: LD_INT 22
23993: PUSH
23994: LD_VAR 0 16
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: LD_INT 35
24005: PUSH
24006: LD_INT 49
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: PUSH
24013: LD_INT 91
24015: PUSH
24016: LD_VAR 0 1
24020: PUSH
24021: LD_INT 10
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: LIST
24033: PPUSH
24034: CALL_OW 69
24038: NOT
24039: IFFALSE 24049
// weapon := ru_time_lapser ;
24041: LD_ADDR_VAR 0 18
24045: PUSH
24046: LD_INT 49
24048: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24049: LD_VAR 0 12
24053: PUSH
24054: LD_INT 1
24056: PUSH
24057: LD_INT 2
24059: PUSH
24060: EMPTY
24061: LIST
24062: LIST
24063: IN
24064: PUSH
24065: LD_INT 11
24067: PUSH
24068: LD_VAR 0 5
24072: IN
24073: PUSH
24074: LD_INT 30
24076: PUSH
24077: LD_VAR 0 5
24081: IN
24082: OR
24083: AND
24084: PUSH
24085: LD_INT 6
24087: PPUSH
24088: LD_VAR 0 16
24092: PPUSH
24093: CALL_OW 321
24097: PUSH
24098: LD_INT 2
24100: EQUAL
24101: AND
24102: IFFALSE 24267
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24104: LD_INT 22
24106: PUSH
24107: LD_VAR 0 16
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: PUSH
24116: LD_INT 2
24118: PUSH
24119: LD_INT 35
24121: PUSH
24122: LD_INT 11
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: PUSH
24129: LD_INT 35
24131: PUSH
24132: LD_INT 30
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: LIST
24143: PUSH
24144: LD_INT 91
24146: PUSH
24147: LD_VAR 0 1
24151: PUSH
24152: LD_INT 18
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: LIST
24164: PPUSH
24165: CALL_OW 69
24169: NOT
24170: PUSH
24171: LD_INT 22
24173: PUSH
24174: LD_VAR 0 16
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: LD_INT 2
24185: PUSH
24186: LD_INT 30
24188: PUSH
24189: LD_INT 32
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: PUSH
24196: LD_INT 30
24198: PUSH
24199: LD_INT 33
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: LIST
24210: PUSH
24211: LD_INT 91
24213: PUSH
24214: LD_VAR 0 1
24218: PUSH
24219: LD_INT 12
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: LIST
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: PUSH
24232: EMPTY
24233: LIST
24234: PPUSH
24235: CALL_OW 69
24239: PUSH
24240: LD_INT 2
24242: GREATER
24243: AND
24244: IFFALSE 24267
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24246: LD_ADDR_VAR 0 18
24250: PUSH
24251: LD_INT 11
24253: PUSH
24254: LD_INT 30
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_VAR 0 12
24265: ARRAY
24266: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24267: LD_VAR 0 18
24271: NOT
24272: PUSH
24273: LD_INT 40
24275: PPUSH
24276: LD_VAR 0 16
24280: PPUSH
24281: CALL_OW 321
24285: PUSH
24286: LD_INT 2
24288: EQUAL
24289: AND
24290: PUSH
24291: LD_INT 7
24293: PUSH
24294: LD_VAR 0 5
24298: IN
24299: PUSH
24300: LD_INT 28
24302: PUSH
24303: LD_VAR 0 5
24307: IN
24308: OR
24309: PUSH
24310: LD_INT 45
24312: PUSH
24313: LD_VAR 0 5
24317: IN
24318: OR
24319: AND
24320: IFFALSE 24574
// begin hex := GetHexInfo ( x , y ) ;
24322: LD_ADDR_VAR 0 4
24326: PUSH
24327: LD_VAR 0 10
24331: PPUSH
24332: LD_VAR 0 11
24336: PPUSH
24337: CALL_OW 546
24341: ST_TO_ADDR
// if hex [ 1 ] then
24342: LD_VAR 0 4
24346: PUSH
24347: LD_INT 1
24349: ARRAY
24350: IFFALSE 24354
// exit ;
24352: GO 24757
// height := hex [ 2 ] ;
24354: LD_ADDR_VAR 0 15
24358: PUSH
24359: LD_VAR 0 4
24363: PUSH
24364: LD_INT 2
24366: ARRAY
24367: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24368: LD_ADDR_VAR 0 14
24372: PUSH
24373: LD_INT 0
24375: PUSH
24376: LD_INT 2
24378: PUSH
24379: LD_INT 3
24381: PUSH
24382: LD_INT 5
24384: PUSH
24385: EMPTY
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: ST_TO_ADDR
// for i in tmp do
24391: LD_ADDR_VAR 0 8
24395: PUSH
24396: LD_VAR 0 14
24400: PUSH
24401: FOR_IN
24402: IFFALSE 24572
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24404: LD_ADDR_VAR 0 9
24408: PUSH
24409: LD_VAR 0 10
24413: PPUSH
24414: LD_VAR 0 8
24418: PPUSH
24419: LD_INT 5
24421: PPUSH
24422: CALL_OW 272
24426: PUSH
24427: LD_VAR 0 11
24431: PPUSH
24432: LD_VAR 0 8
24436: PPUSH
24437: LD_INT 5
24439: PPUSH
24440: CALL_OW 273
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24449: LD_VAR 0 9
24453: PUSH
24454: LD_INT 1
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 9
24462: PUSH
24463: LD_INT 2
24465: ARRAY
24466: PPUSH
24467: CALL_OW 488
24471: IFFALSE 24570
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24473: LD_ADDR_VAR 0 4
24477: PUSH
24478: LD_VAR 0 9
24482: PUSH
24483: LD_INT 1
24485: ARRAY
24486: PPUSH
24487: LD_VAR 0 9
24491: PUSH
24492: LD_INT 2
24494: ARRAY
24495: PPUSH
24496: CALL_OW 546
24500: ST_TO_ADDR
// if hex [ 1 ] then
24501: LD_VAR 0 4
24505: PUSH
24506: LD_INT 1
24508: ARRAY
24509: IFFALSE 24513
// continue ;
24511: GO 24401
// h := hex [ 2 ] ;
24513: LD_ADDR_VAR 0 13
24517: PUSH
24518: LD_VAR 0 4
24522: PUSH
24523: LD_INT 2
24525: ARRAY
24526: ST_TO_ADDR
// if h + 7 < height then
24527: LD_VAR 0 13
24531: PUSH
24532: LD_INT 7
24534: PLUS
24535: PUSH
24536: LD_VAR 0 15
24540: LESS
24541: IFFALSE 24570
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24543: LD_ADDR_VAR 0 18
24547: PUSH
24548: LD_INT 7
24550: PUSH
24551: LD_INT 28
24553: PUSH
24554: LD_INT 45
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: LIST
24561: PUSH
24562: LD_VAR 0 12
24566: ARRAY
24567: ST_TO_ADDR
// break ;
24568: GO 24572
// end ; end ; end ;
24570: GO 24401
24572: POP
24573: POP
// end ; if not weapon then
24574: LD_VAR 0 18
24578: NOT
24579: IFFALSE 24639
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24581: LD_ADDR_VAR 0 5
24585: PUSH
24586: LD_VAR 0 5
24590: PUSH
24591: LD_INT 11
24593: PUSH
24594: LD_INT 30
24596: PUSH
24597: LD_INT 49
24599: PUSH
24600: EMPTY
24601: LIST
24602: LIST
24603: LIST
24604: DIFF
24605: ST_TO_ADDR
// if not list then
24606: LD_VAR 0 5
24610: NOT
24611: IFFALSE 24615
// exit ;
24613: GO 24757
// weapon := list [ rand ( 1 , list ) ] ;
24615: LD_ADDR_VAR 0 18
24619: PUSH
24620: LD_VAR 0 5
24624: PUSH
24625: LD_INT 1
24627: PPUSH
24628: LD_VAR 0 5
24632: PPUSH
24633: CALL_OW 12
24637: ARRAY
24638: ST_TO_ADDR
// end ; if weapon then
24639: LD_VAR 0 18
24643: IFFALSE 24757
// begin tmp := CostOfWeapon ( weapon ) ;
24645: LD_ADDR_VAR 0 14
24649: PUSH
24650: LD_VAR 0 18
24654: PPUSH
24655: CALL_OW 451
24659: ST_TO_ADDR
// j := GetBase ( tower ) ;
24660: LD_ADDR_VAR 0 9
24664: PUSH
24665: LD_VAR 0 1
24669: PPUSH
24670: CALL_OW 274
24674: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24675: LD_VAR 0 9
24679: PPUSH
24680: LD_INT 1
24682: PPUSH
24683: CALL_OW 275
24687: PUSH
24688: LD_VAR 0 14
24692: PUSH
24693: LD_INT 1
24695: ARRAY
24696: GREATEREQUAL
24697: PUSH
24698: LD_VAR 0 9
24702: PPUSH
24703: LD_INT 2
24705: PPUSH
24706: CALL_OW 275
24710: PUSH
24711: LD_VAR 0 14
24715: PUSH
24716: LD_INT 2
24718: ARRAY
24719: GREATEREQUAL
24720: AND
24721: PUSH
24722: LD_VAR 0 9
24726: PPUSH
24727: LD_INT 3
24729: PPUSH
24730: CALL_OW 275
24734: PUSH
24735: LD_VAR 0 14
24739: PUSH
24740: LD_INT 3
24742: ARRAY
24743: GREATEREQUAL
24744: AND
24745: IFFALSE 24757
// result := weapon ;
24747: LD_ADDR_VAR 0 3
24751: PUSH
24752: LD_VAR 0 18
24756: ST_TO_ADDR
// end ; end ;
24757: LD_VAR 0 3
24761: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24762: LD_INT 0
24764: PPUSH
24765: PPUSH
// result := true ;
24766: LD_ADDR_VAR 0 3
24770: PUSH
24771: LD_INT 1
24773: ST_TO_ADDR
// if array1 = array2 then
24774: LD_VAR 0 1
24778: PUSH
24779: LD_VAR 0 2
24783: EQUAL
24784: IFFALSE 24844
// begin for i = 1 to array1 do
24786: LD_ADDR_VAR 0 4
24790: PUSH
24791: DOUBLE
24792: LD_INT 1
24794: DEC
24795: ST_TO_ADDR
24796: LD_VAR 0 1
24800: PUSH
24801: FOR_TO
24802: IFFALSE 24840
// if array1 [ i ] <> array2 [ i ] then
24804: LD_VAR 0 1
24808: PUSH
24809: LD_VAR 0 4
24813: ARRAY
24814: PUSH
24815: LD_VAR 0 2
24819: PUSH
24820: LD_VAR 0 4
24824: ARRAY
24825: NONEQUAL
24826: IFFALSE 24838
// begin result := false ;
24828: LD_ADDR_VAR 0 3
24832: PUSH
24833: LD_INT 0
24835: ST_TO_ADDR
// break ;
24836: GO 24840
// end ;
24838: GO 24801
24840: POP
24841: POP
// end else
24842: GO 24852
// result := false ;
24844: LD_ADDR_VAR 0 3
24848: PUSH
24849: LD_INT 0
24851: ST_TO_ADDR
// end ;
24852: LD_VAR 0 3
24856: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
24857: LD_INT 0
24859: PPUSH
24860: PPUSH
// if not array1 or not array2 then
24861: LD_VAR 0 1
24865: NOT
24866: PUSH
24867: LD_VAR 0 2
24871: NOT
24872: OR
24873: IFFALSE 24877
// exit ;
24875: GO 24941
// result := true ;
24877: LD_ADDR_VAR 0 3
24881: PUSH
24882: LD_INT 1
24884: ST_TO_ADDR
// for i = 1 to array1 do
24885: LD_ADDR_VAR 0 4
24889: PUSH
24890: DOUBLE
24891: LD_INT 1
24893: DEC
24894: ST_TO_ADDR
24895: LD_VAR 0 1
24899: PUSH
24900: FOR_TO
24901: IFFALSE 24939
// if array1 [ i ] <> array2 [ i ] then
24903: LD_VAR 0 1
24907: PUSH
24908: LD_VAR 0 4
24912: ARRAY
24913: PUSH
24914: LD_VAR 0 2
24918: PUSH
24919: LD_VAR 0 4
24923: ARRAY
24924: NONEQUAL
24925: IFFALSE 24937
// begin result := false ;
24927: LD_ADDR_VAR 0 3
24931: PUSH
24932: LD_INT 0
24934: ST_TO_ADDR
// break ;
24935: GO 24939
// end ;
24937: GO 24900
24939: POP
24940: POP
// end ;
24941: LD_VAR 0 3
24945: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24946: LD_INT 0
24948: PPUSH
24949: PPUSH
24950: PPUSH
// pom := GetBase ( fac ) ;
24951: LD_ADDR_VAR 0 5
24955: PUSH
24956: LD_VAR 0 1
24960: PPUSH
24961: CALL_OW 274
24965: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24966: LD_ADDR_VAR 0 4
24970: PUSH
24971: LD_VAR 0 2
24975: PUSH
24976: LD_INT 1
24978: ARRAY
24979: PPUSH
24980: LD_VAR 0 2
24984: PUSH
24985: LD_INT 2
24987: ARRAY
24988: PPUSH
24989: LD_VAR 0 2
24993: PUSH
24994: LD_INT 3
24996: ARRAY
24997: PPUSH
24998: LD_VAR 0 2
25002: PUSH
25003: LD_INT 4
25005: ARRAY
25006: PPUSH
25007: CALL_OW 449
25011: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25012: LD_ADDR_VAR 0 3
25016: PUSH
25017: LD_VAR 0 5
25021: PPUSH
25022: LD_INT 1
25024: PPUSH
25025: CALL_OW 275
25029: PUSH
25030: LD_VAR 0 4
25034: PUSH
25035: LD_INT 1
25037: ARRAY
25038: GREATEREQUAL
25039: PUSH
25040: LD_VAR 0 5
25044: PPUSH
25045: LD_INT 2
25047: PPUSH
25048: CALL_OW 275
25052: PUSH
25053: LD_VAR 0 4
25057: PUSH
25058: LD_INT 2
25060: ARRAY
25061: GREATEREQUAL
25062: AND
25063: PUSH
25064: LD_VAR 0 5
25068: PPUSH
25069: LD_INT 3
25071: PPUSH
25072: CALL_OW 275
25076: PUSH
25077: LD_VAR 0 4
25081: PUSH
25082: LD_INT 3
25084: ARRAY
25085: GREATEREQUAL
25086: AND
25087: ST_TO_ADDR
// end ;
25088: LD_VAR 0 3
25092: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25093: LD_INT 0
25095: PPUSH
25096: PPUSH
25097: PPUSH
25098: PPUSH
// pom := GetBase ( building ) ;
25099: LD_ADDR_VAR 0 3
25103: PUSH
25104: LD_VAR 0 1
25108: PPUSH
25109: CALL_OW 274
25113: ST_TO_ADDR
// if not pom then
25114: LD_VAR 0 3
25118: NOT
25119: IFFALSE 25123
// exit ;
25121: GO 25293
// btype := GetBType ( building ) ;
25123: LD_ADDR_VAR 0 5
25127: PUSH
25128: LD_VAR 0 1
25132: PPUSH
25133: CALL_OW 266
25137: ST_TO_ADDR
// if btype = b_armoury then
25138: LD_VAR 0 5
25142: PUSH
25143: LD_INT 4
25145: EQUAL
25146: IFFALSE 25156
// btype := b_barracks ;
25148: LD_ADDR_VAR 0 5
25152: PUSH
25153: LD_INT 5
25155: ST_TO_ADDR
// if btype = b_depot then
25156: LD_VAR 0 5
25160: PUSH
25161: LD_INT 0
25163: EQUAL
25164: IFFALSE 25174
// btype := b_warehouse ;
25166: LD_ADDR_VAR 0 5
25170: PUSH
25171: LD_INT 1
25173: ST_TO_ADDR
// if btype = b_workshop then
25174: LD_VAR 0 5
25178: PUSH
25179: LD_INT 2
25181: EQUAL
25182: IFFALSE 25192
// btype := b_factory ;
25184: LD_ADDR_VAR 0 5
25188: PUSH
25189: LD_INT 3
25191: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25192: LD_ADDR_VAR 0 4
25196: PUSH
25197: LD_VAR 0 5
25201: PPUSH
25202: LD_VAR 0 1
25206: PPUSH
25207: CALL_OW 248
25211: PPUSH
25212: CALL_OW 450
25216: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25217: LD_ADDR_VAR 0 2
25221: PUSH
25222: LD_VAR 0 3
25226: PPUSH
25227: LD_INT 1
25229: PPUSH
25230: CALL_OW 275
25234: PUSH
25235: LD_VAR 0 4
25239: PUSH
25240: LD_INT 1
25242: ARRAY
25243: GREATEREQUAL
25244: PUSH
25245: LD_VAR 0 3
25249: PPUSH
25250: LD_INT 2
25252: PPUSH
25253: CALL_OW 275
25257: PUSH
25258: LD_VAR 0 4
25262: PUSH
25263: LD_INT 2
25265: ARRAY
25266: GREATEREQUAL
25267: AND
25268: PUSH
25269: LD_VAR 0 3
25273: PPUSH
25274: LD_INT 3
25276: PPUSH
25277: CALL_OW 275
25281: PUSH
25282: LD_VAR 0 4
25286: PUSH
25287: LD_INT 3
25289: ARRAY
25290: GREATEREQUAL
25291: AND
25292: ST_TO_ADDR
// end ;
25293: LD_VAR 0 2
25297: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25298: LD_INT 0
25300: PPUSH
25301: PPUSH
25302: PPUSH
// pom := GetBase ( building ) ;
25303: LD_ADDR_VAR 0 4
25307: PUSH
25308: LD_VAR 0 1
25312: PPUSH
25313: CALL_OW 274
25317: ST_TO_ADDR
// if not pom then
25318: LD_VAR 0 4
25322: NOT
25323: IFFALSE 25327
// exit ;
25325: GO 25428
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25327: LD_ADDR_VAR 0 5
25331: PUSH
25332: LD_VAR 0 2
25336: PPUSH
25337: LD_VAR 0 1
25341: PPUSH
25342: CALL_OW 248
25346: PPUSH
25347: CALL_OW 450
25351: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25352: LD_ADDR_VAR 0 3
25356: PUSH
25357: LD_VAR 0 4
25361: PPUSH
25362: LD_INT 1
25364: PPUSH
25365: CALL_OW 275
25369: PUSH
25370: LD_VAR 0 5
25374: PUSH
25375: LD_INT 1
25377: ARRAY
25378: GREATEREQUAL
25379: PUSH
25380: LD_VAR 0 4
25384: PPUSH
25385: LD_INT 2
25387: PPUSH
25388: CALL_OW 275
25392: PUSH
25393: LD_VAR 0 5
25397: PUSH
25398: LD_INT 2
25400: ARRAY
25401: GREATEREQUAL
25402: AND
25403: PUSH
25404: LD_VAR 0 4
25408: PPUSH
25409: LD_INT 3
25411: PPUSH
25412: CALL_OW 275
25416: PUSH
25417: LD_VAR 0 5
25421: PUSH
25422: LD_INT 3
25424: ARRAY
25425: GREATEREQUAL
25426: AND
25427: ST_TO_ADDR
// end ;
25428: LD_VAR 0 3
25432: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
25433: LD_INT 0
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
// result := false ;
25446: LD_ADDR_VAR 0 8
25450: PUSH
25451: LD_INT 0
25453: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
25454: LD_VAR 0 5
25458: NOT
25459: PUSH
25460: LD_VAR 0 1
25464: NOT
25465: OR
25466: PUSH
25467: LD_VAR 0 2
25471: NOT
25472: OR
25473: PUSH
25474: LD_VAR 0 3
25478: NOT
25479: OR
25480: IFFALSE 25484
// exit ;
25482: GO 26298
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
25484: LD_ADDR_VAR 0 14
25488: PUSH
25489: LD_VAR 0 1
25493: PPUSH
25494: LD_VAR 0 2
25498: PPUSH
25499: LD_VAR 0 3
25503: PPUSH
25504: LD_VAR 0 4
25508: PPUSH
25509: LD_VAR 0 5
25513: PUSH
25514: LD_INT 1
25516: ARRAY
25517: PPUSH
25518: CALL_OW 248
25522: PPUSH
25523: LD_INT 0
25525: PPUSH
25526: CALL 27551 0 6
25530: ST_TO_ADDR
// if not hexes then
25531: LD_VAR 0 14
25535: NOT
25536: IFFALSE 25540
// exit ;
25538: GO 26298
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25540: LD_ADDR_VAR 0 17
25544: PUSH
25545: LD_VAR 0 5
25549: PPUSH
25550: LD_INT 22
25552: PUSH
25553: LD_VAR 0 13
25557: PPUSH
25558: CALL_OW 255
25562: PUSH
25563: EMPTY
25564: LIST
25565: LIST
25566: PUSH
25567: LD_INT 2
25569: PUSH
25570: LD_INT 30
25572: PUSH
25573: LD_INT 0
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 30
25582: PUSH
25583: LD_INT 1
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: LIST
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: PPUSH
25599: CALL_OW 72
25603: ST_TO_ADDR
// for i = 1 to hexes do
25604: LD_ADDR_VAR 0 9
25608: PUSH
25609: DOUBLE
25610: LD_INT 1
25612: DEC
25613: ST_TO_ADDR
25614: LD_VAR 0 14
25618: PUSH
25619: FOR_TO
25620: IFFALSE 26296
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25622: LD_ADDR_VAR 0 13
25626: PUSH
25627: LD_VAR 0 14
25631: PUSH
25632: LD_VAR 0 9
25636: ARRAY
25637: PUSH
25638: LD_INT 1
25640: ARRAY
25641: PPUSH
25642: LD_VAR 0 14
25646: PUSH
25647: LD_VAR 0 9
25651: ARRAY
25652: PUSH
25653: LD_INT 2
25655: ARRAY
25656: PPUSH
25657: CALL_OW 428
25661: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25662: LD_VAR 0 14
25666: PUSH
25667: LD_VAR 0 9
25671: ARRAY
25672: PUSH
25673: LD_INT 1
25675: ARRAY
25676: PPUSH
25677: LD_VAR 0 14
25681: PUSH
25682: LD_VAR 0 9
25686: ARRAY
25687: PUSH
25688: LD_INT 2
25690: ARRAY
25691: PPUSH
25692: CALL_OW 351
25696: PUSH
25697: LD_VAR 0 14
25701: PUSH
25702: LD_VAR 0 9
25706: ARRAY
25707: PUSH
25708: LD_INT 1
25710: ARRAY
25711: PPUSH
25712: LD_VAR 0 14
25716: PUSH
25717: LD_VAR 0 9
25721: ARRAY
25722: PUSH
25723: LD_INT 2
25725: ARRAY
25726: PPUSH
25727: CALL_OW 488
25731: NOT
25732: OR
25733: PUSH
25734: LD_VAR 0 13
25738: PPUSH
25739: CALL_OW 247
25743: PUSH
25744: LD_INT 3
25746: EQUAL
25747: OR
25748: IFFALSE 25754
// exit ;
25750: POP
25751: POP
25752: GO 26298
// if not tmp then
25754: LD_VAR 0 13
25758: NOT
25759: IFFALSE 25763
// continue ;
25761: GO 25619
// result := true ;
25763: LD_ADDR_VAR 0 8
25767: PUSH
25768: LD_INT 1
25770: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
25771: LD_VAR 0 6
25775: PUSH
25776: LD_VAR 0 13
25780: PPUSH
25781: CALL_OW 247
25785: PUSH
25786: LD_INT 2
25788: EQUAL
25789: AND
25790: PUSH
25791: LD_VAR 0 13
25795: PPUSH
25796: CALL_OW 263
25800: PUSH
25801: LD_INT 1
25803: EQUAL
25804: AND
25805: IFFALSE 25969
// begin if IsDrivenBy ( tmp ) then
25807: LD_VAR 0 13
25811: PPUSH
25812: CALL_OW 311
25816: IFFALSE 25820
// continue ;
25818: GO 25619
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
25820: LD_VAR 0 6
25824: PPUSH
25825: LD_INT 3
25827: PUSH
25828: LD_INT 60
25830: PUSH
25831: EMPTY
25832: LIST
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 3
25840: PUSH
25841: LD_INT 55
25843: PUSH
25844: EMPTY
25845: LIST
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PPUSH
25855: CALL_OW 72
25859: IFFALSE 25967
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
25861: LD_ADDR_VAR 0 18
25865: PUSH
25866: LD_VAR 0 6
25870: PPUSH
25871: LD_INT 3
25873: PUSH
25874: LD_INT 60
25876: PUSH
25877: EMPTY
25878: LIST
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 3
25886: PUSH
25887: LD_INT 55
25889: PUSH
25890: EMPTY
25891: LIST
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PPUSH
25901: CALL_OW 72
25905: PUSH
25906: LD_INT 1
25908: ARRAY
25909: ST_TO_ADDR
// if IsInUnit ( driver ) then
25910: LD_VAR 0 18
25914: PPUSH
25915: CALL_OW 310
25919: IFFALSE 25930
// ComExit ( driver ) ;
25921: LD_VAR 0 18
25925: PPUSH
25926: CALL 51330 0 1
// AddComEnterUnit ( driver , tmp ) ;
25930: LD_VAR 0 18
25934: PPUSH
25935: LD_VAR 0 13
25939: PPUSH
25940: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
25944: LD_VAR 0 18
25948: PPUSH
25949: LD_VAR 0 7
25953: PPUSH
25954: CALL_OW 173
// AddComExitVehicle ( driver ) ;
25958: LD_VAR 0 18
25962: PPUSH
25963: CALL_OW 181
// end ; continue ;
25967: GO 25619
// end ; if not cleaners or not tmp in cleaners then
25969: LD_VAR 0 6
25973: NOT
25974: PUSH
25975: LD_VAR 0 13
25979: PUSH
25980: LD_VAR 0 6
25984: IN
25985: NOT
25986: OR
25987: IFFALSE 26294
// begin if dep then
25989: LD_VAR 0 17
25993: IFFALSE 26129
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25995: LD_ADDR_VAR 0 16
25999: PUSH
26000: LD_VAR 0 17
26004: PUSH
26005: LD_INT 1
26007: ARRAY
26008: PPUSH
26009: CALL_OW 250
26013: PPUSH
26014: LD_VAR 0 17
26018: PUSH
26019: LD_INT 1
26021: ARRAY
26022: PPUSH
26023: CALL_OW 254
26027: PPUSH
26028: LD_INT 5
26030: PPUSH
26031: CALL_OW 272
26035: PUSH
26036: LD_VAR 0 17
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PPUSH
26045: CALL_OW 251
26049: PPUSH
26050: LD_VAR 0 17
26054: PUSH
26055: LD_INT 1
26057: ARRAY
26058: PPUSH
26059: CALL_OW 254
26063: PPUSH
26064: LD_INT 5
26066: PPUSH
26067: CALL_OW 273
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26076: LD_VAR 0 16
26080: PUSH
26081: LD_INT 1
26083: ARRAY
26084: PPUSH
26085: LD_VAR 0 16
26089: PUSH
26090: LD_INT 2
26092: ARRAY
26093: PPUSH
26094: CALL_OW 488
26098: IFFALSE 26129
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26100: LD_VAR 0 13
26104: PPUSH
26105: LD_VAR 0 16
26109: PUSH
26110: LD_INT 1
26112: ARRAY
26113: PPUSH
26114: LD_VAR 0 16
26118: PUSH
26119: LD_INT 2
26121: ARRAY
26122: PPUSH
26123: CALL_OW 111
// continue ;
26127: GO 25619
// end ; end ; r := GetDir ( tmp ) ;
26129: LD_ADDR_VAR 0 15
26133: PUSH
26134: LD_VAR 0 13
26138: PPUSH
26139: CALL_OW 254
26143: ST_TO_ADDR
// if r = 5 then
26144: LD_VAR 0 15
26148: PUSH
26149: LD_INT 5
26151: EQUAL
26152: IFFALSE 26162
// r := 0 ;
26154: LD_ADDR_VAR 0 15
26158: PUSH
26159: LD_INT 0
26161: ST_TO_ADDR
// for j = r to 5 do
26162: LD_ADDR_VAR 0 10
26166: PUSH
26167: DOUBLE
26168: LD_VAR 0 15
26172: DEC
26173: ST_TO_ADDR
26174: LD_INT 5
26176: PUSH
26177: FOR_TO
26178: IFFALSE 26292
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26180: LD_ADDR_VAR 0 11
26184: PUSH
26185: LD_VAR 0 13
26189: PPUSH
26190: CALL_OW 250
26194: PPUSH
26195: LD_VAR 0 10
26199: PPUSH
26200: LD_INT 2
26202: PPUSH
26203: CALL_OW 272
26207: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26208: LD_ADDR_VAR 0 12
26212: PUSH
26213: LD_VAR 0 13
26217: PPUSH
26218: CALL_OW 251
26222: PPUSH
26223: LD_VAR 0 10
26227: PPUSH
26228: LD_INT 2
26230: PPUSH
26231: CALL_OW 273
26235: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26236: LD_VAR 0 11
26240: PPUSH
26241: LD_VAR 0 12
26245: PPUSH
26246: CALL_OW 488
26250: PUSH
26251: LD_VAR 0 11
26255: PPUSH
26256: LD_VAR 0 12
26260: PPUSH
26261: CALL_OW 428
26265: NOT
26266: AND
26267: IFFALSE 26290
// begin ComMoveXY ( tmp , _x , _y ) ;
26269: LD_VAR 0 13
26273: PPUSH
26274: LD_VAR 0 11
26278: PPUSH
26279: LD_VAR 0 12
26283: PPUSH
26284: CALL_OW 111
// break ;
26288: GO 26292
// end ; end ;
26290: GO 26177
26292: POP
26293: POP
// end ; end ;
26294: GO 25619
26296: POP
26297: POP
// end ;
26298: LD_VAR 0 8
26302: RET
// export function BuildingTechInvented ( side , btype ) ; begin
26303: LD_INT 0
26305: PPUSH
// result := true ;
26306: LD_ADDR_VAR 0 3
26310: PUSH
26311: LD_INT 1
26313: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
26314: LD_VAR 0 2
26318: PUSH
26319: LD_INT 24
26321: DOUBLE
26322: EQUAL
26323: IFTRUE 26333
26325: LD_INT 33
26327: DOUBLE
26328: EQUAL
26329: IFTRUE 26333
26331: GO 26358
26333: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
26334: LD_ADDR_VAR 0 3
26338: PUSH
26339: LD_INT 32
26341: PPUSH
26342: LD_VAR 0 1
26346: PPUSH
26347: CALL_OW 321
26351: PUSH
26352: LD_INT 2
26354: EQUAL
26355: ST_TO_ADDR
26356: GO 26674
26358: LD_INT 20
26360: DOUBLE
26361: EQUAL
26362: IFTRUE 26366
26364: GO 26391
26366: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
26367: LD_ADDR_VAR 0 3
26371: PUSH
26372: LD_INT 6
26374: PPUSH
26375: LD_VAR 0 1
26379: PPUSH
26380: CALL_OW 321
26384: PUSH
26385: LD_INT 2
26387: EQUAL
26388: ST_TO_ADDR
26389: GO 26674
26391: LD_INT 22
26393: DOUBLE
26394: EQUAL
26395: IFTRUE 26405
26397: LD_INT 36
26399: DOUBLE
26400: EQUAL
26401: IFTRUE 26405
26403: GO 26430
26405: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
26406: LD_ADDR_VAR 0 3
26410: PUSH
26411: LD_INT 15
26413: PPUSH
26414: LD_VAR 0 1
26418: PPUSH
26419: CALL_OW 321
26423: PUSH
26424: LD_INT 2
26426: EQUAL
26427: ST_TO_ADDR
26428: GO 26674
26430: LD_INT 30
26432: DOUBLE
26433: EQUAL
26434: IFTRUE 26438
26436: GO 26463
26438: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
26439: LD_ADDR_VAR 0 3
26443: PUSH
26444: LD_INT 20
26446: PPUSH
26447: LD_VAR 0 1
26451: PPUSH
26452: CALL_OW 321
26456: PUSH
26457: LD_INT 2
26459: EQUAL
26460: ST_TO_ADDR
26461: GO 26674
26463: LD_INT 28
26465: DOUBLE
26466: EQUAL
26467: IFTRUE 26477
26469: LD_INT 21
26471: DOUBLE
26472: EQUAL
26473: IFTRUE 26477
26475: GO 26502
26477: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
26478: LD_ADDR_VAR 0 3
26482: PUSH
26483: LD_INT 21
26485: PPUSH
26486: LD_VAR 0 1
26490: PPUSH
26491: CALL_OW 321
26495: PUSH
26496: LD_INT 2
26498: EQUAL
26499: ST_TO_ADDR
26500: GO 26674
26502: LD_INT 16
26504: DOUBLE
26505: EQUAL
26506: IFTRUE 26510
26508: GO 26535
26510: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
26511: LD_ADDR_VAR 0 3
26515: PUSH
26516: LD_INT 84
26518: PPUSH
26519: LD_VAR 0 1
26523: PPUSH
26524: CALL_OW 321
26528: PUSH
26529: LD_INT 2
26531: EQUAL
26532: ST_TO_ADDR
26533: GO 26674
26535: LD_INT 19
26537: DOUBLE
26538: EQUAL
26539: IFTRUE 26549
26541: LD_INT 23
26543: DOUBLE
26544: EQUAL
26545: IFTRUE 26549
26547: GO 26574
26549: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
26550: LD_ADDR_VAR 0 3
26554: PUSH
26555: LD_INT 83
26557: PPUSH
26558: LD_VAR 0 1
26562: PPUSH
26563: CALL_OW 321
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: ST_TO_ADDR
26572: GO 26674
26574: LD_INT 17
26576: DOUBLE
26577: EQUAL
26578: IFTRUE 26582
26580: GO 26607
26582: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
26583: LD_ADDR_VAR 0 3
26587: PUSH
26588: LD_INT 39
26590: PPUSH
26591: LD_VAR 0 1
26595: PPUSH
26596: CALL_OW 321
26600: PUSH
26601: LD_INT 2
26603: EQUAL
26604: ST_TO_ADDR
26605: GO 26674
26607: LD_INT 18
26609: DOUBLE
26610: EQUAL
26611: IFTRUE 26615
26613: GO 26640
26615: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
26616: LD_ADDR_VAR 0 3
26620: PUSH
26621: LD_INT 40
26623: PPUSH
26624: LD_VAR 0 1
26628: PPUSH
26629: CALL_OW 321
26633: PUSH
26634: LD_INT 2
26636: EQUAL
26637: ST_TO_ADDR
26638: GO 26674
26640: LD_INT 27
26642: DOUBLE
26643: EQUAL
26644: IFTRUE 26648
26646: GO 26673
26648: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
26649: LD_ADDR_VAR 0 3
26653: PUSH
26654: LD_INT 35
26656: PPUSH
26657: LD_VAR 0 1
26661: PPUSH
26662: CALL_OW 321
26666: PUSH
26667: LD_INT 2
26669: EQUAL
26670: ST_TO_ADDR
26671: GO 26674
26673: POP
// end ;
26674: LD_VAR 0 3
26678: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
26679: LD_INT 0
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
26687: PPUSH
26688: PPUSH
26689: PPUSH
26690: PPUSH
26691: PPUSH
// result := false ;
26692: LD_ADDR_VAR 0 6
26696: PUSH
26697: LD_INT 0
26699: ST_TO_ADDR
// if btype = b_depot then
26700: LD_VAR 0 2
26704: PUSH
26705: LD_INT 0
26707: EQUAL
26708: IFFALSE 26720
// begin result := true ;
26710: LD_ADDR_VAR 0 6
26714: PUSH
26715: LD_INT 1
26717: ST_TO_ADDR
// exit ;
26718: GO 27546
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26720: LD_VAR 0 1
26724: NOT
26725: PUSH
26726: LD_VAR 0 1
26730: PPUSH
26731: CALL_OW 266
26735: PUSH
26736: LD_INT 0
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: IN
26746: NOT
26747: OR
26748: PUSH
26749: LD_VAR 0 2
26753: NOT
26754: OR
26755: PUSH
26756: LD_VAR 0 5
26760: PUSH
26761: LD_INT 0
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: LD_INT 2
26769: PUSH
26770: LD_INT 3
26772: PUSH
26773: LD_INT 4
26775: PUSH
26776: LD_INT 5
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: IN
26787: NOT
26788: OR
26789: PUSH
26790: LD_VAR 0 3
26794: PPUSH
26795: LD_VAR 0 4
26799: PPUSH
26800: CALL_OW 488
26804: NOT
26805: OR
26806: IFFALSE 26810
// exit ;
26808: GO 27546
// side := GetSide ( depot ) ;
26810: LD_ADDR_VAR 0 9
26814: PUSH
26815: LD_VAR 0 1
26819: PPUSH
26820: CALL_OW 255
26824: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
26825: LD_VAR 0 9
26829: PPUSH
26830: LD_VAR 0 2
26834: PPUSH
26835: CALL 26303 0 2
26839: NOT
26840: IFFALSE 26844
// exit ;
26842: GO 27546
// pom := GetBase ( depot ) ;
26844: LD_ADDR_VAR 0 10
26848: PUSH
26849: LD_VAR 0 1
26853: PPUSH
26854: CALL_OW 274
26858: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26859: LD_ADDR_VAR 0 11
26863: PUSH
26864: LD_VAR 0 2
26868: PPUSH
26869: LD_VAR 0 1
26873: PPUSH
26874: CALL_OW 248
26878: PPUSH
26879: CALL_OW 450
26883: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26884: LD_VAR 0 10
26888: PPUSH
26889: LD_INT 1
26891: PPUSH
26892: CALL_OW 275
26896: PUSH
26897: LD_VAR 0 11
26901: PUSH
26902: LD_INT 1
26904: ARRAY
26905: GREATEREQUAL
26906: PUSH
26907: LD_VAR 0 10
26911: PPUSH
26912: LD_INT 2
26914: PPUSH
26915: CALL_OW 275
26919: PUSH
26920: LD_VAR 0 11
26924: PUSH
26925: LD_INT 2
26927: ARRAY
26928: GREATEREQUAL
26929: AND
26930: PUSH
26931: LD_VAR 0 10
26935: PPUSH
26936: LD_INT 3
26938: PPUSH
26939: CALL_OW 275
26943: PUSH
26944: LD_VAR 0 11
26948: PUSH
26949: LD_INT 3
26951: ARRAY
26952: GREATEREQUAL
26953: AND
26954: NOT
26955: IFFALSE 26959
// exit ;
26957: GO 27546
// if GetBType ( depot ) = b_depot then
26959: LD_VAR 0 1
26963: PPUSH
26964: CALL_OW 266
26968: PUSH
26969: LD_INT 0
26971: EQUAL
26972: IFFALSE 26984
// dist := 28 else
26974: LD_ADDR_VAR 0 14
26978: PUSH
26979: LD_INT 28
26981: ST_TO_ADDR
26982: GO 26992
// dist := 36 ;
26984: LD_ADDR_VAR 0 14
26988: PUSH
26989: LD_INT 36
26991: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26992: LD_VAR 0 1
26996: PPUSH
26997: LD_VAR 0 3
27001: PPUSH
27002: LD_VAR 0 4
27006: PPUSH
27007: CALL_OW 297
27011: PUSH
27012: LD_VAR 0 14
27016: GREATER
27017: IFFALSE 27021
// exit ;
27019: GO 27546
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27021: LD_ADDR_VAR 0 12
27025: PUSH
27026: LD_VAR 0 2
27030: PPUSH
27031: LD_VAR 0 3
27035: PPUSH
27036: LD_VAR 0 4
27040: PPUSH
27041: LD_VAR 0 5
27045: PPUSH
27046: LD_VAR 0 1
27050: PPUSH
27051: CALL_OW 248
27055: PPUSH
27056: LD_INT 0
27058: PPUSH
27059: CALL 27551 0 6
27063: ST_TO_ADDR
// if not hexes then
27064: LD_VAR 0 12
27068: NOT
27069: IFFALSE 27073
// exit ;
27071: GO 27546
// hex := GetHexInfo ( x , y ) ;
27073: LD_ADDR_VAR 0 15
27077: PUSH
27078: LD_VAR 0 3
27082: PPUSH
27083: LD_VAR 0 4
27087: PPUSH
27088: CALL_OW 546
27092: ST_TO_ADDR
// if hex [ 1 ] then
27093: LD_VAR 0 15
27097: PUSH
27098: LD_INT 1
27100: ARRAY
27101: IFFALSE 27105
// exit ;
27103: GO 27546
// height := hex [ 2 ] ;
27105: LD_ADDR_VAR 0 13
27109: PUSH
27110: LD_VAR 0 15
27114: PUSH
27115: LD_INT 2
27117: ARRAY
27118: ST_TO_ADDR
// for i = 1 to hexes do
27119: LD_ADDR_VAR 0 7
27123: PUSH
27124: DOUBLE
27125: LD_INT 1
27127: DEC
27128: ST_TO_ADDR
27129: LD_VAR 0 12
27133: PUSH
27134: FOR_TO
27135: IFFALSE 27465
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27137: LD_VAR 0 12
27141: PUSH
27142: LD_VAR 0 7
27146: ARRAY
27147: PUSH
27148: LD_INT 1
27150: ARRAY
27151: PPUSH
27152: LD_VAR 0 12
27156: PUSH
27157: LD_VAR 0 7
27161: ARRAY
27162: PUSH
27163: LD_INT 2
27165: ARRAY
27166: PPUSH
27167: CALL_OW 488
27171: NOT
27172: PUSH
27173: LD_VAR 0 12
27177: PUSH
27178: LD_VAR 0 7
27182: ARRAY
27183: PUSH
27184: LD_INT 1
27186: ARRAY
27187: PPUSH
27188: LD_VAR 0 12
27192: PUSH
27193: LD_VAR 0 7
27197: ARRAY
27198: PUSH
27199: LD_INT 2
27201: ARRAY
27202: PPUSH
27203: CALL_OW 428
27207: PUSH
27208: LD_INT 0
27210: GREATER
27211: OR
27212: PUSH
27213: LD_VAR 0 12
27217: PUSH
27218: LD_VAR 0 7
27222: ARRAY
27223: PUSH
27224: LD_INT 1
27226: ARRAY
27227: PPUSH
27228: LD_VAR 0 12
27232: PUSH
27233: LD_VAR 0 7
27237: ARRAY
27238: PUSH
27239: LD_INT 2
27241: ARRAY
27242: PPUSH
27243: CALL_OW 351
27247: OR
27248: IFFALSE 27254
// exit ;
27250: POP
27251: POP
27252: GO 27546
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27254: LD_ADDR_VAR 0 8
27258: PUSH
27259: LD_VAR 0 12
27263: PUSH
27264: LD_VAR 0 7
27268: ARRAY
27269: PUSH
27270: LD_INT 1
27272: ARRAY
27273: PPUSH
27274: LD_VAR 0 12
27278: PUSH
27279: LD_VAR 0 7
27283: ARRAY
27284: PUSH
27285: LD_INT 2
27287: ARRAY
27288: PPUSH
27289: CALL_OW 546
27293: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27294: LD_VAR 0 8
27298: PUSH
27299: LD_INT 1
27301: ARRAY
27302: PUSH
27303: LD_VAR 0 8
27307: PUSH
27308: LD_INT 2
27310: ARRAY
27311: PUSH
27312: LD_VAR 0 13
27316: PUSH
27317: LD_INT 2
27319: PLUS
27320: GREATER
27321: OR
27322: PUSH
27323: LD_VAR 0 8
27327: PUSH
27328: LD_INT 2
27330: ARRAY
27331: PUSH
27332: LD_VAR 0 13
27336: PUSH
27337: LD_INT 2
27339: MINUS
27340: LESS
27341: OR
27342: PUSH
27343: LD_VAR 0 8
27347: PUSH
27348: LD_INT 3
27350: ARRAY
27351: PUSH
27352: LD_INT 0
27354: PUSH
27355: LD_INT 8
27357: PUSH
27358: LD_INT 9
27360: PUSH
27361: LD_INT 10
27363: PUSH
27364: LD_INT 11
27366: PUSH
27367: LD_INT 12
27369: PUSH
27370: LD_INT 13
27372: PUSH
27373: LD_INT 16
27375: PUSH
27376: LD_INT 17
27378: PUSH
27379: LD_INT 18
27381: PUSH
27382: LD_INT 19
27384: PUSH
27385: LD_INT 20
27387: PUSH
27388: LD_INT 21
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: IN
27406: NOT
27407: OR
27408: PUSH
27409: LD_VAR 0 8
27413: PUSH
27414: LD_INT 5
27416: ARRAY
27417: NOT
27418: OR
27419: PUSH
27420: LD_VAR 0 8
27424: PUSH
27425: LD_INT 6
27427: ARRAY
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 7
27437: PUSH
27438: LD_INT 9
27440: PUSH
27441: LD_INT 10
27443: PUSH
27444: LD_INT 11
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: IN
27455: NOT
27456: OR
27457: IFFALSE 27463
// exit ;
27459: POP
27460: POP
27461: GO 27546
// end ;
27463: GO 27134
27465: POP
27466: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27467: LD_VAR 0 9
27471: PPUSH
27472: LD_VAR 0 3
27476: PPUSH
27477: LD_VAR 0 4
27481: PPUSH
27482: LD_INT 20
27484: PPUSH
27485: CALL 19469 0 4
27489: PUSH
27490: LD_INT 4
27492: ARRAY
27493: IFFALSE 27497
// exit ;
27495: GO 27546
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27497: LD_VAR 0 2
27501: PUSH
27502: LD_INT 29
27504: PUSH
27505: LD_INT 30
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: IN
27512: PUSH
27513: LD_VAR 0 3
27517: PPUSH
27518: LD_VAR 0 4
27522: PPUSH
27523: LD_VAR 0 9
27527: PPUSH
27528: CALL_OW 440
27532: NOT
27533: AND
27534: IFFALSE 27538
// exit ;
27536: GO 27546
// result := true ;
27538: LD_ADDR_VAR 0 6
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// end ;
27546: LD_VAR 0 6
27550: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27551: LD_INT 0
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
27570: PPUSH
27571: PPUSH
27572: PPUSH
27573: PPUSH
27574: PPUSH
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
27583: PPUSH
27584: PPUSH
27585: PPUSH
27586: PPUSH
27587: PPUSH
27588: PPUSH
27589: PPUSH
27590: PPUSH
27591: PPUSH
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
27602: PPUSH
27603: PPUSH
27604: PPUSH
27605: PPUSH
27606: PPUSH
27607: PPUSH
27608: PPUSH
27609: PPUSH
27610: PPUSH
// result = [ ] ;
27611: LD_ADDR_VAR 0 7
27615: PUSH
27616: EMPTY
27617: ST_TO_ADDR
// temp_list = [ ] ;
27618: LD_ADDR_VAR 0 9
27622: PUSH
27623: EMPTY
27624: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27625: LD_VAR 0 4
27629: PUSH
27630: LD_INT 0
27632: PUSH
27633: LD_INT 1
27635: PUSH
27636: LD_INT 2
27638: PUSH
27639: LD_INT 3
27641: PUSH
27642: LD_INT 4
27644: PUSH
27645: LD_INT 5
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: IN
27656: NOT
27657: PUSH
27658: LD_VAR 0 1
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 1
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: IN
27673: PUSH
27674: LD_VAR 0 5
27678: PUSH
27679: LD_INT 1
27681: PUSH
27682: LD_INT 2
27684: PUSH
27685: LD_INT 3
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: LIST
27692: IN
27693: NOT
27694: AND
27695: OR
27696: IFFALSE 27700
// exit ;
27698: GO 46091
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 6
27707: PUSH
27708: LD_INT 7
27710: PUSH
27711: LD_INT 8
27713: PUSH
27714: LD_INT 13
27716: PUSH
27717: LD_INT 12
27719: PUSH
27720: LD_INT 15
27722: PUSH
27723: LD_INT 11
27725: PUSH
27726: LD_INT 14
27728: PUSH
27729: LD_INT 10
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: LIST
27736: LIST
27737: LIST
27738: LIST
27739: LIST
27740: LIST
27741: LIST
27742: IN
27743: IFFALSE 27753
// btype = b_lab ;
27745: LD_ADDR_VAR 0 1
27749: PUSH
27750: LD_INT 6
27752: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27753: LD_VAR 0 6
27757: PUSH
27758: LD_INT 0
27760: PUSH
27761: LD_INT 1
27763: PUSH
27764: LD_INT 2
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: LIST
27771: IN
27772: NOT
27773: PUSH
27774: LD_VAR 0 1
27778: PUSH
27779: LD_INT 0
27781: PUSH
27782: LD_INT 1
27784: PUSH
27785: LD_INT 2
27787: PUSH
27788: LD_INT 3
27790: PUSH
27791: LD_INT 6
27793: PUSH
27794: LD_INT 36
27796: PUSH
27797: LD_INT 4
27799: PUSH
27800: LD_INT 5
27802: PUSH
27803: LD_INT 31
27805: PUSH
27806: LD_INT 32
27808: PUSH
27809: LD_INT 33
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: IN
27825: NOT
27826: PUSH
27827: LD_VAR 0 6
27831: PUSH
27832: LD_INT 1
27834: EQUAL
27835: AND
27836: OR
27837: PUSH
27838: LD_VAR 0 1
27842: PUSH
27843: LD_INT 2
27845: PUSH
27846: LD_INT 3
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: IN
27853: NOT
27854: PUSH
27855: LD_VAR 0 6
27859: PUSH
27860: LD_INT 2
27862: EQUAL
27863: AND
27864: OR
27865: IFFALSE 27875
// mode = 0 ;
27867: LD_ADDR_VAR 0 6
27871: PUSH
27872: LD_INT 0
27874: ST_TO_ADDR
// case mode of 0 :
27875: LD_VAR 0 6
27879: PUSH
27880: LD_INT 0
27882: DOUBLE
27883: EQUAL
27884: IFTRUE 27888
27886: GO 39341
27888: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27889: LD_ADDR_VAR 0 11
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: LD_INT 0
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: LD_INT 0
27906: PUSH
27907: LD_INT 1
27909: NEG
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 1
27917: PUSH
27918: LD_INT 0
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: LD_INT 1
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 0
27937: PUSH
27938: LD_INT 1
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: PUSH
27945: LD_INT 1
27947: NEG
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: LD_INT 1
27962: NEG
27963: PUSH
27964: EMPTY
27965: LIST
27966: LIST
27967: PUSH
27968: LD_INT 1
27970: NEG
27971: PUSH
27972: LD_INT 2
27974: NEG
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: PUSH
27980: LD_INT 0
27982: PUSH
27983: LD_INT 2
27985: NEG
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 1
27993: PUSH
27994: LD_INT 1
27996: NEG
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 1
28004: PUSH
28005: LD_INT 2
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 0
28014: PUSH
28015: LD_INT 2
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: LD_INT 1
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 1
28035: PUSH
28036: LD_INT 3
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: PUSH
28043: LD_INT 0
28045: PUSH
28046: LD_INT 3
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: PUSH
28053: LD_INT 1
28055: NEG
28056: PUSH
28057: LD_INT 2
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: LIST
28081: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28082: LD_ADDR_VAR 0 12
28086: PUSH
28087: LD_INT 0
28089: PUSH
28090: LD_INT 0
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 0
28099: PUSH
28100: LD_INT 1
28102: NEG
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: LD_INT 1
28110: PUSH
28111: LD_INT 0
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 1
28120: PUSH
28121: LD_INT 1
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 1
28133: PUSH
28134: EMPTY
28135: LIST
28136: LIST
28137: PUSH
28138: LD_INT 1
28140: NEG
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 1
28151: NEG
28152: PUSH
28153: LD_INT 1
28155: NEG
28156: PUSH
28157: EMPTY
28158: LIST
28159: LIST
28160: PUSH
28161: LD_INT 1
28163: PUSH
28164: LD_INT 1
28166: NEG
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 2
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 2
28184: PUSH
28185: LD_INT 1
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 1
28198: PUSH
28199: EMPTY
28200: LIST
28201: LIST
28202: PUSH
28203: LD_INT 2
28205: NEG
28206: PUSH
28207: LD_INT 0
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: PUSH
28214: LD_INT 2
28216: NEG
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: NEG
28229: PUSH
28230: LD_INT 1
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 3
28239: NEG
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 3
28250: NEG
28251: PUSH
28252: LD_INT 1
28254: NEG
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: LIST
28272: LIST
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28278: LD_ADDR_VAR 0 13
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: LD_INT 0
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PUSH
28293: LD_INT 0
28295: PUSH
28296: LD_INT 1
28298: NEG
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 1
28306: PUSH
28307: LD_INT 0
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 1
28316: PUSH
28317: LD_INT 1
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PUSH
28324: LD_INT 0
28326: PUSH
28327: LD_INT 1
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 1
28336: NEG
28337: PUSH
28338: LD_INT 0
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 1
28347: NEG
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 1
28359: NEG
28360: PUSH
28361: LD_INT 2
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 2
28371: PUSH
28372: LD_INT 1
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PUSH
28379: LD_INT 2
28381: PUSH
28382: LD_INT 2
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: PUSH
28389: LD_INT 1
28391: PUSH
28392: LD_INT 2
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 2
28401: NEG
28402: PUSH
28403: LD_INT 1
28405: NEG
28406: PUSH
28407: EMPTY
28408: LIST
28409: LIST
28410: PUSH
28411: LD_INT 2
28413: NEG
28414: PUSH
28415: LD_INT 2
28417: NEG
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: PUSH
28423: LD_INT 2
28425: NEG
28426: PUSH
28427: LD_INT 3
28429: NEG
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 3
28437: NEG
28438: PUSH
28439: LD_INT 2
28441: NEG
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 3
28449: NEG
28450: PUSH
28451: LD_INT 3
28453: NEG
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28477: LD_ADDR_VAR 0 14
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: LD_INT 0
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PUSH
28492: LD_INT 0
28494: PUSH
28495: LD_INT 1
28497: NEG
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 1
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: LD_INT 1
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 0
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 1
28535: NEG
28536: PUSH
28537: LD_INT 0
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: NEG
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: LD_INT 1
28558: NEG
28559: PUSH
28560: LD_INT 2
28562: NEG
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 0
28570: PUSH
28571: LD_INT 2
28573: NEG
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 1
28581: PUSH
28582: LD_INT 1
28584: NEG
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 1
28592: PUSH
28593: LD_INT 2
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 0
28602: PUSH
28603: LD_INT 2
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 1
28612: NEG
28613: PUSH
28614: LD_INT 1
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PUSH
28621: LD_INT 1
28623: NEG
28624: PUSH
28625: LD_INT 3
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 0
28635: PUSH
28636: LD_INT 3
28638: NEG
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 1
28646: PUSH
28647: LD_INT 2
28649: NEG
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: LIST
28672: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28673: LD_ADDR_VAR 0 15
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 0
28690: PUSH
28691: LD_INT 1
28693: NEG
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: LD_INT 0
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 0
28721: PUSH
28722: LD_INT 1
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: LD_INT 1
28731: NEG
28732: PUSH
28733: LD_INT 0
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: LD_INT 1
28746: NEG
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: LD_INT 1
28754: PUSH
28755: LD_INT 1
28757: NEG
28758: PUSH
28759: EMPTY
28760: LIST
28761: LIST
28762: PUSH
28763: LD_INT 2
28765: PUSH
28766: LD_INT 0
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: LD_INT 2
28775: PUSH
28776: LD_INT 1
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 1
28785: NEG
28786: PUSH
28787: LD_INT 1
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: LD_INT 2
28796: NEG
28797: PUSH
28798: LD_INT 0
28800: PUSH
28801: EMPTY
28802: LIST
28803: LIST
28804: PUSH
28805: LD_INT 2
28807: NEG
28808: PUSH
28809: LD_INT 1
28811: NEG
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: LD_INT 1
28822: NEG
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 3
28830: PUSH
28831: LD_INT 0
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: LD_INT 3
28840: PUSH
28841: LD_INT 1
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28866: LD_ADDR_VAR 0 16
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 0
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: PUSH
28895: LD_INT 0
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: LD_INT 1
28904: PUSH
28905: LD_INT 1
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: PUSH
28912: LD_INT 0
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: PUSH
28922: LD_INT 1
28924: NEG
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 1
28947: NEG
28948: PUSH
28949: LD_INT 2
28951: NEG
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: LD_INT 2
28959: PUSH
28960: LD_INT 1
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 2
28969: PUSH
28970: LD_INT 2
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 1
28979: PUSH
28980: LD_INT 2
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 2
28989: NEG
28990: PUSH
28991: LD_INT 1
28993: NEG
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: PUSH
28999: LD_INT 2
29001: NEG
29002: PUSH
29003: LD_INT 2
29005: NEG
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PUSH
29011: LD_INT 3
29013: PUSH
29014: LD_INT 2
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 3
29023: PUSH
29024: LD_INT 3
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: LD_INT 2
29033: PUSH
29034: LD_INT 3
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: LIST
29058: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29059: LD_ADDR_VAR 0 17
29063: PUSH
29064: LD_INT 0
29066: PUSH
29067: LD_INT 0
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 0
29076: PUSH
29077: LD_INT 1
29079: NEG
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: LD_INT 0
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 0
29107: PUSH
29108: LD_INT 1
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 1
29117: NEG
29118: PUSH
29119: LD_INT 0
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 1
29128: NEG
29129: PUSH
29130: LD_INT 1
29132: NEG
29133: PUSH
29134: EMPTY
29135: LIST
29136: LIST
29137: PUSH
29138: LD_INT 1
29140: NEG
29141: PUSH
29142: LD_INT 2
29144: NEG
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 0
29152: PUSH
29153: LD_INT 2
29155: NEG
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: LD_INT 1
29166: NEG
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 2
29174: PUSH
29175: LD_INT 0
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 2
29184: PUSH
29185: LD_INT 1
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 2
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 1
29204: PUSH
29205: LD_INT 2
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: LD_INT 2
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: NEG
29225: PUSH
29226: LD_INT 1
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 2
29235: NEG
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: LD_INT 2
29246: NEG
29247: PUSH
29248: LD_INT 1
29250: NEG
29251: PUSH
29252: EMPTY
29253: LIST
29254: LIST
29255: PUSH
29256: LD_INT 2
29258: NEG
29259: PUSH
29260: LD_INT 2
29262: NEG
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29289: LD_ADDR_VAR 0 18
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 0
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: LD_INT 1
29309: NEG
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: LD_INT 1
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: NEG
29348: PUSH
29349: LD_INT 0
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: NEG
29359: PUSH
29360: LD_INT 1
29362: NEG
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: LD_INT 2
29374: NEG
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: LD_INT 2
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 1
29396: NEG
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 2
29404: PUSH
29405: LD_INT 0
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 2
29414: PUSH
29415: LD_INT 1
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 2
29424: PUSH
29425: LD_INT 2
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 1
29434: PUSH
29435: LD_INT 2
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 0
29444: PUSH
29445: LD_INT 2
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 1
29454: NEG
29455: PUSH
29456: LD_INT 1
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 2
29465: NEG
29466: PUSH
29467: LD_INT 0
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 2
29476: NEG
29477: PUSH
29478: LD_INT 1
29480: NEG
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 2
29488: NEG
29489: PUSH
29490: LD_INT 2
29492: NEG
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: LIST
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: LIST
29516: LIST
29517: LIST
29518: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29519: LD_ADDR_VAR 0 19
29523: PUSH
29524: LD_INT 0
29526: PUSH
29527: LD_INT 0
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 0
29536: PUSH
29537: LD_INT 1
29539: NEG
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 0
29567: PUSH
29568: LD_INT 1
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 1
29577: NEG
29578: PUSH
29579: LD_INT 0
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: NEG
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: LD_INT 2
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: LD_INT 2
29615: NEG
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: LD_INT 1
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 2
29634: PUSH
29635: LD_INT 0
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 2
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 2
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 1
29664: PUSH
29665: LD_INT 2
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: LD_INT 2
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 2
29695: NEG
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 2
29718: NEG
29719: PUSH
29720: LD_INT 2
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29749: LD_ADDR_VAR 0 20
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 0
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 1
29769: NEG
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: PUSH
29778: LD_INT 0
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: LD_INT 1
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 1
29807: NEG
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: NEG
29819: PUSH
29820: LD_INT 1
29822: NEG
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: LD_INT 1
29830: NEG
29831: PUSH
29832: LD_INT 2
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: LD_INT 2
29845: NEG
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: LD_INT 1
29856: NEG
29857: PUSH
29858: EMPTY
29859: LIST
29860: LIST
29861: PUSH
29862: LD_INT 2
29864: PUSH
29865: LD_INT 0
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 2
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 2
29884: PUSH
29885: LD_INT 2
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: PUSH
29895: LD_INT 2
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 2
29925: NEG
29926: PUSH
29927: LD_INT 0
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 2
29936: NEG
29937: PUSH
29938: LD_INT 1
29940: NEG
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 2
29948: NEG
29949: PUSH
29950: LD_INT 2
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29979: LD_ADDR_VAR 0 21
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 1
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 0
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: NEG
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: NEG
30061: PUSH
30062: LD_INT 2
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 2
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 1
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 2
30114: PUSH
30115: LD_INT 2
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 1
30124: PUSH
30125: LD_INT 2
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 0
30134: PUSH
30135: LD_INT 2
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: LD_INT 1
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: LD_INT 2
30155: NEG
30156: PUSH
30157: LD_INT 0
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 2
30166: NEG
30167: PUSH
30168: LD_INT 1
30170: NEG
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 2
30178: NEG
30179: PUSH
30180: LD_INT 2
30182: NEG
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30209: LD_ADDR_VAR 0 22
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 0
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: NEG
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 0
30302: PUSH
30303: LD_INT 2
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 2
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 2
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: PUSH
30345: LD_INT 2
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: LD_INT 2
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 0
30364: PUSH
30365: LD_INT 2
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: NEG
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 2
30385: NEG
30386: PUSH
30387: LD_INT 0
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 2
30396: NEG
30397: PUSH
30398: LD_INT 1
30400: NEG
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 2
30408: NEG
30409: PUSH
30410: LD_INT 2
30412: NEG
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30439: LD_ADDR_VAR 0 23
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: LD_INT 0
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 0
30456: PUSH
30457: LD_INT 1
30459: NEG
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: PUSH
30468: LD_INT 0
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: LD_INT 1
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: PUSH
30485: LD_INT 0
30487: PUSH
30488: LD_INT 1
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: PUSH
30495: LD_INT 1
30497: NEG
30498: PUSH
30499: LD_INT 0
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 1
30520: NEG
30521: PUSH
30522: LD_INT 2
30524: NEG
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 0
30532: PUSH
30533: LD_INT 2
30535: NEG
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: LD_INT 1
30546: NEG
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 2
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: LD_INT 1
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 2
30574: PUSH
30575: LD_INT 2
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 1
30584: PUSH
30585: LD_INT 2
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 0
30594: PUSH
30595: LD_INT 2
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: LD_INT 2
30615: NEG
30616: PUSH
30617: LD_INT 0
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 2
30626: NEG
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 2
30638: NEG
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: NEG
30651: PUSH
30652: LD_INT 3
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 1
30662: NEG
30663: PUSH
30664: LD_INT 3
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: PUSH
30675: LD_INT 2
30677: NEG
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 2
30685: PUSH
30686: LD_INT 1
30688: NEG
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30719: LD_ADDR_VAR 0 24
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 0
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 0
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: LD_INT 1
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: NEG
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 1
30788: NEG
30789: PUSH
30790: LD_INT 1
30792: NEG
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: NEG
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: LD_INT 2
30815: NEG
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 1
30823: PUSH
30824: LD_INT 1
30826: NEG
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: LD_INT 2
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 2
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 2
30854: PUSH
30855: LD_INT 2
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 2
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 0
30874: PUSH
30875: LD_INT 2
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 1
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 2
30895: NEG
30896: PUSH
30897: LD_INT 0
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 2
30906: NEG
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 2
30918: NEG
30919: PUSH
30920: LD_INT 2
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: LD_INT 2
30933: NEG
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: LD_INT 1
30944: NEG
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 3
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 3
30962: PUSH
30963: LD_INT 2
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30995: LD_ADDR_VAR 0 25
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 0
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 0
31043: PUSH
31044: LD_INT 1
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: LD_INT 0
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: LD_INT 2
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: LD_INT 2
31091: NEG
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 1
31102: NEG
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: LD_INT 0
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 2
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: PUSH
31131: LD_INT 2
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: LD_INT 2
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 0
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: LD_INT 1
31164: PUSH
31165: EMPTY
31166: LIST
31167: LIST
31168: PUSH
31169: LD_INT 2
31171: NEG
31172: PUSH
31173: LD_INT 0
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: NEG
31183: PUSH
31184: LD_INT 1
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: NEG
31195: PUSH
31196: LD_INT 2
31198: NEG
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 3
31206: PUSH
31207: LD_INT 1
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 3
31216: PUSH
31217: LD_INT 2
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 2
31226: PUSH
31227: LD_INT 3
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 1
31236: PUSH
31237: LD_INT 3
31239: PUSH
31240: EMPTY
31241: LIST
31242: LIST
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31269: LD_ADDR_VAR 0 26
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 0
31286: PUSH
31287: LD_INT 1
31289: NEG
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 1
31297: PUSH
31298: LD_INT 0
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: LD_INT 0
31317: PUSH
31318: LD_INT 1
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 1
31327: NEG
31328: PUSH
31329: LD_INT 0
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 2
31354: NEG
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 2
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 2
31394: PUSH
31395: LD_INT 1
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: LD_INT 2
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 2
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: LD_INT 2
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 2
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 2
31480: PUSH
31481: LD_INT 3
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: PUSH
31491: LD_INT 3
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: LD_INT 1
31500: NEG
31501: PUSH
31502: LD_INT 2
31504: PUSH
31505: EMPTY
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 2
31511: NEG
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31545: LD_ADDR_VAR 0 27
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 0
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 1
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 2
31630: NEG
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 2
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 1
31652: NEG
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: LD_INT 2
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 2
31680: PUSH
31681: LD_INT 2
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: PUSH
31691: LD_INT 2
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 0
31700: PUSH
31701: LD_INT 2
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: LD_INT 1
31710: NEG
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: PUSH
31719: LD_INT 2
31721: NEG
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 2
31732: NEG
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 2
31744: NEG
31745: PUSH
31746: LD_INT 2
31748: NEG
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 1
31756: NEG
31757: PUSH
31758: LD_INT 2
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: LD_INT 2
31767: NEG
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 3
31778: NEG
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 3
31790: NEG
31791: PUSH
31792: LD_INT 2
31794: NEG
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31825: LD_ADDR_VAR 0 28
31829: PUSH
31830: LD_INT 0
31832: PUSH
31833: LD_INT 0
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 0
31842: PUSH
31843: LD_INT 1
31845: NEG
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 1
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 0
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: NEG
31884: PUSH
31885: LD_INT 0
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 1
31894: NEG
31895: PUSH
31896: LD_INT 1
31898: NEG
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 1
31906: NEG
31907: PUSH
31908: LD_INT 2
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 0
31918: PUSH
31919: LD_INT 2
31921: NEG
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 1
31929: PUSH
31930: LD_INT 1
31932: NEG
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: LD_INT 2
31940: PUSH
31941: LD_INT 0
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 2
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: PUSH
31961: LD_INT 2
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: LD_INT 2
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 0
31980: PUSH
31981: LD_INT 2
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: NEG
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 2
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 2
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 2
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 2
32036: NEG
32037: PUSH
32038: LD_INT 3
32040: NEG
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 1
32048: NEG
32049: PUSH
32050: LD_INT 3
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 3
32060: NEG
32061: PUSH
32062: LD_INT 1
32064: NEG
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 3
32072: NEG
32073: PUSH
32074: LD_INT 2
32076: NEG
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32107: LD_ADDR_VAR 0 29
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: LD_INT 0
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 0
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 0
32155: PUSH
32156: LD_INT 1
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 1
32165: NEG
32166: PUSH
32167: LD_INT 0
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 1
32176: NEG
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: EMPTY
32183: LIST
32184: LIST
32185: PUSH
32186: LD_INT 1
32188: NEG
32189: PUSH
32190: LD_INT 2
32192: NEG
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 0
32200: PUSH
32201: LD_INT 2
32203: NEG
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 1
32211: PUSH
32212: LD_INT 1
32214: NEG
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 2
32222: PUSH
32223: LD_INT 0
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: PUSH
32233: LD_INT 1
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: LD_INT 2
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 2
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: LD_INT 1
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 2
32273: NEG
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 2
32297: NEG
32298: PUSH
32299: LD_INT 3
32301: NEG
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PUSH
32307: LD_INT 2
32309: PUSH
32310: LD_INT 1
32312: NEG
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 3
32320: PUSH
32321: LD_INT 1
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 3
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: LD_INT 2
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 3
32351: NEG
32352: PUSH
32353: LD_INT 2
32355: NEG
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32386: LD_ADDR_VAR 0 30
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 0
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 0
32403: PUSH
32404: LD_INT 1
32406: NEG
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 0
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 1
32444: NEG
32445: PUSH
32446: LD_INT 0
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 1
32455: NEG
32456: PUSH
32457: LD_INT 1
32459: NEG
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 0
32479: PUSH
32480: LD_INT 2
32482: NEG
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 2
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 2
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 2
32521: PUSH
32522: LD_INT 2
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: LD_INT 2
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 1
32541: NEG
32542: PUSH
32543: LD_INT 1
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 2
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: NEG
32576: PUSH
32577: LD_INT 3
32579: NEG
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 1
32587: PUSH
32588: LD_INT 2
32590: NEG
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 3
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 3
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: NEG
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 3
32629: NEG
32630: PUSH
32631: LD_INT 1
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32664: LD_ADDR_VAR 0 31
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 1
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 1
32722: NEG
32723: PUSH
32724: LD_INT 0
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 1
32733: NEG
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 2
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 1
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 2
32768: PUSH
32769: LD_INT 0
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 2
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 1
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 0
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 1
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 2
32829: NEG
32830: PUSH
32831: LD_INT 1
32833: NEG
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 2
32841: NEG
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 2
32853: NEG
32854: PUSH
32855: LD_INT 3
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 2
32865: PUSH
32866: LD_INT 1
32868: NEG
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 3
32876: PUSH
32877: LD_INT 1
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 1
32886: PUSH
32887: LD_INT 3
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: LD_INT 2
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 3
32907: NEG
32908: PUSH
32909: LD_INT 2
32911: NEG
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32942: LD_ADDR_VAR 0 32
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: LD_INT 0
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 1
32970: PUSH
32971: LD_INT 0
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 0
32990: PUSH
32991: LD_INT 1
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 1
33000: NEG
33001: PUSH
33002: LD_INT 0
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: NEG
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 1
33023: NEG
33024: PUSH
33025: LD_INT 2
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: LD_INT 2
33038: NEG
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 1
33046: PUSH
33047: LD_INT 1
33049: NEG
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 2
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: LD_INT 2
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 2
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 0
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: NEG
33098: PUSH
33099: LD_INT 1
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 2
33119: NEG
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 1
33131: NEG
33132: PUSH
33133: LD_INT 3
33135: NEG
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 1
33143: PUSH
33144: LD_INT 2
33146: NEG
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 3
33154: PUSH
33155: LD_INT 2
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 2
33164: PUSH
33165: LD_INT 3
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 2
33174: NEG
33175: PUSH
33176: LD_INT 1
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 3
33185: NEG
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: LIST
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33220: LD_ADDR_VAR 0 33
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: PUSH
33249: LD_INT 0
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 1
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: NEG
33279: PUSH
33280: LD_INT 0
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 2
33305: NEG
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: LD_INT 0
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 0
33354: PUSH
33355: LD_INT 2
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 1
33364: NEG
33365: PUSH
33366: LD_INT 1
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 2
33375: NEG
33376: PUSH
33377: LD_INT 0
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 2
33386: NEG
33387: PUSH
33388: LD_INT 1
33390: NEG
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 2
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 2
33410: NEG
33411: PUSH
33412: LD_INT 3
33414: NEG
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 2
33422: PUSH
33423: LD_INT 1
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 3
33433: PUSH
33434: LD_INT 1
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: LD_INT 2
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 3
33464: NEG
33465: PUSH
33466: LD_INT 2
33468: NEG
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33499: LD_ADDR_VAR 0 34
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 0
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 0
33547: PUSH
33548: LD_INT 1
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: NEG
33581: PUSH
33582: LD_INT 2
33584: NEG
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: LD_INT 2
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 1
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: PUSH
33615: LD_INT 1
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: LD_INT 2
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: LD_INT 2
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: LD_INT 1
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 2
33655: NEG
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 2
33666: NEG
33667: PUSH
33668: LD_INT 1
33670: NEG
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: LD_INT 2
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 3
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 1
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 3
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 2
33723: PUSH
33724: LD_INT 3
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 2
33733: NEG
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 3
33744: NEG
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: LIST
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33779: LD_ADDR_VAR 0 35
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 0
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 0
33796: PUSH
33797: LD_INT 1
33799: NEG
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: LD_INT 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: LD_INT 1
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: LD_INT 0
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 1
33848: NEG
33849: PUSH
33850: LD_INT 1
33852: NEG
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 2
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 2
33870: NEG
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33891: LD_ADDR_VAR 0 36
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 0
33908: PUSH
33909: LD_INT 1
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: PUSH
33920: LD_INT 0
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 1
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 0
33939: PUSH
33940: LD_INT 1
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: NEG
33950: PUSH
33951: LD_INT 0
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 1
33972: NEG
33973: PUSH
33974: LD_INT 2
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: LD_INT 2
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34003: LD_ADDR_VAR 0 37
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 0
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 1
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: EMPTY
34036: LIST
34037: LIST
34038: PUSH
34039: LD_INT 1
34041: PUSH
34042: LD_INT 1
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 0
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 1
34061: NEG
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: NEG
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34115: LD_ADDR_VAR 0 38
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 0
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 0
34132: PUSH
34133: LD_INT 1
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: PUSH
34154: LD_INT 1
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: LD_INT 1
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 1
34184: NEG
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: NEG
34207: PUSH
34208: LD_INT 1
34210: NEG
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34227: LD_ADDR_VAR 0 39
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: LD_INT 1
34247: NEG
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: PUSH
34266: LD_INT 1
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: LD_INT 1
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 1
34285: NEG
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 1
34296: NEG
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 2
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 2
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34339: LD_ADDR_VAR 0 40
34343: PUSH
34344: LD_INT 0
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 0
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 1
34408: NEG
34409: PUSH
34410: LD_INT 1
34412: NEG
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34451: LD_ADDR_VAR 0 41
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 0
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 1
34471: NEG
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 0
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: LD_INT 2
34536: NEG
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: LD_INT 1
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 2
34617: NEG
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 2
34629: NEG
34630: PUSH
34631: LD_INT 2
34633: NEG
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 2
34641: NEG
34642: PUSH
34643: LD_INT 3
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: LD_INT 1
34656: NEG
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 3
34664: PUSH
34665: LD_INT 0
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 3
34674: PUSH
34675: LD_INT 1
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 3
34684: PUSH
34685: LD_INT 2
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 3
34694: PUSH
34695: LD_INT 3
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 2
34704: PUSH
34705: LD_INT 3
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 2
34714: NEG
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 3
34725: NEG
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 3
34736: NEG
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 3
34748: NEG
34749: PUSH
34750: LD_INT 2
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 3
34760: NEG
34761: PUSH
34762: LD_INT 3
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34801: LD_ADDR_VAR 0 42
34805: PUSH
34806: LD_INT 0
34808: PUSH
34809: LD_INT 0
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 0
34818: PUSH
34819: LD_INT 1
34821: NEG
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 1
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 1
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: LD_INT 0
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: NEG
34871: PUSH
34872: LD_INT 1
34874: NEG
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: NEG
34883: PUSH
34884: LD_INT 2
34886: NEG
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 0
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 1
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 2
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 2
34926: PUSH
34927: LD_INT 2
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 1
34936: PUSH
34937: LD_INT 2
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 0
34946: PUSH
34947: LD_INT 2
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: NEG
34968: PUSH
34969: LD_INT 1
34971: NEG
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 2
34979: NEG
34980: PUSH
34981: LD_INT 2
34983: NEG
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: NEG
34992: PUSH
34993: LD_INT 3
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: LD_INT 3
35007: NEG
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 3
35018: NEG
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: LD_INT 2
35029: NEG
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 3
35037: PUSH
35038: LD_INT 2
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 3
35047: PUSH
35048: LD_INT 3
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 2
35057: PUSH
35058: LD_INT 3
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: LD_INT 1
35067: PUSH
35068: LD_INT 3
35070: PUSH
35071: EMPTY
35072: LIST
35073: LIST
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: LD_INT 3
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 1
35087: NEG
35088: PUSH
35089: LD_INT 2
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 3
35098: NEG
35099: PUSH
35100: LD_INT 2
35102: NEG
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 3
35110: NEG
35111: PUSH
35112: LD_INT 3
35114: NEG
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35151: LD_ADDR_VAR 0 43
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 0
35168: PUSH
35169: LD_INT 1
35171: NEG
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 1
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 0
35199: PUSH
35200: LD_INT 1
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: LD_INT 0
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 1
35232: NEG
35233: PUSH
35234: LD_INT 2
35236: NEG
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: LD_INT 2
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: PUSH
35256: LD_INT 1
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 2
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 2
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: PUSH
35287: LD_INT 2
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: LD_INT 2
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 1
35306: NEG
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 2
35317: NEG
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 2
35328: NEG
35329: PUSH
35330: LD_INT 1
35332: NEG
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: LD_INT 3
35344: NEG
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 0
35352: PUSH
35353: LD_INT 3
35355: NEG
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: PUSH
35364: LD_INT 2
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: LD_INT 1
35377: NEG
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 3
35385: PUSH
35386: LD_INT 0
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 3
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 1
35405: PUSH
35406: LD_INT 3
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: LD_INT 3
35418: PUSH
35419: EMPTY
35420: LIST
35421: LIST
35422: PUSH
35423: LD_INT 1
35425: NEG
35426: PUSH
35427: LD_INT 2
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 2
35436: NEG
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 3
35447: NEG
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 3
35458: NEG
35459: PUSH
35460: LD_INT 1
35462: NEG
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35499: LD_ADDR_VAR 0 44
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 0
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: LD_INT 0
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 1
35537: PUSH
35538: LD_INT 1
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 0
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 1
35568: NEG
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 2
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 1
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: PUSH
35624: LD_INT 2
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 1
35633: PUSH
35634: LD_INT 2
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: NEG
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 2
35677: NEG
35678: PUSH
35679: LD_INT 2
35681: NEG
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: LD_INT 3
35693: NEG
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 2
35701: PUSH
35702: LD_INT 1
35704: NEG
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 3
35712: PUSH
35713: LD_INT 0
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 3
35722: PUSH
35723: LD_INT 1
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 3
35732: PUSH
35733: LD_INT 2
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: PUSH
35743: LD_INT 3
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 2
35752: PUSH
35753: LD_INT 3
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 2
35762: NEG
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 3
35773: NEG
35774: PUSH
35775: LD_INT 0
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 3
35784: NEG
35785: PUSH
35786: LD_INT 1
35788: NEG
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 3
35796: NEG
35797: PUSH
35798: LD_INT 2
35800: NEG
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 3
35808: NEG
35809: PUSH
35810: LD_INT 3
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35849: LD_ADDR_VAR 0 45
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 0
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 1
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: EMPTY
35892: LIST
35893: LIST
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: LD_INT 1
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 1
35907: NEG
35908: PUSH
35909: LD_INT 0
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: NEG
35919: PUSH
35920: LD_INT 1
35922: NEG
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 1
35930: NEG
35931: PUSH
35932: LD_INT 2
35934: NEG
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 0
35942: PUSH
35943: LD_INT 2
35945: NEG
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 1
35953: PUSH
35954: LD_INT 1
35956: NEG
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: LD_INT 1
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: LD_INT 2
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 1
35984: PUSH
35985: LD_INT 2
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: LD_INT 2
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: NEG
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 2
36015: NEG
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 2
36039: NEG
36040: PUSH
36041: LD_INT 3
36043: NEG
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 1
36051: NEG
36052: PUSH
36053: LD_INT 3
36055: NEG
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: LD_INT 3
36066: NEG
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: PUSH
36075: LD_INT 2
36077: NEG
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 3
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: PUSH
36093: LD_INT 3
36095: PUSH
36096: LD_INT 3
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 2
36105: PUSH
36106: LD_INT 3
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: LD_INT 1
36115: PUSH
36116: LD_INT 3
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: LD_INT 3
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 1
36135: NEG
36136: PUSH
36137: LD_INT 2
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 3
36146: NEG
36147: PUSH
36148: LD_INT 2
36150: NEG
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 3
36158: NEG
36159: PUSH
36160: LD_INT 3
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36199: LD_ADDR_VAR 0 46
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 1
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 0
36247: PUSH
36248: LD_INT 1
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 1
36257: NEG
36258: PUSH
36259: LD_INT 0
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: LD_INT 1
36272: NEG
36273: PUSH
36274: EMPTY
36275: LIST
36276: LIST
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: LD_INT 2
36284: NEG
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 2
36295: NEG
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 2
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: LD_INT 2
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 2
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 1
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: LD_INT 0
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 2
36376: NEG
36377: PUSH
36378: LD_INT 1
36380: NEG
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 3
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 0
36400: PUSH
36401: LD_INT 3
36403: NEG
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 1
36411: PUSH
36412: LD_INT 2
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 2
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 3
36433: PUSH
36434: LD_INT 0
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 3
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 1
36453: PUSH
36454: LD_INT 3
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: LD_INT 3
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: LD_INT 2
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 2
36484: NEG
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 3
36495: NEG
36496: PUSH
36497: LD_INT 0
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: LD_INT 3
36506: NEG
36507: PUSH
36508: LD_INT 1
36510: NEG
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36547: LD_ADDR_VAR 0 47
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 1
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 0
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: NEG
36606: PUSH
36607: LD_INT 0
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: NEG
36617: PUSH
36618: LD_INT 1
36620: NEG
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 1
36628: NEG
36629: PUSH
36630: LD_INT 2
36632: NEG
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: LD_INT 2
36643: NEG
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: LD_INT 1
36654: NEG
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 2
36662: NEG
36663: PUSH
36664: LD_INT 1
36666: NEG
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 2
36674: NEG
36675: PUSH
36676: LD_INT 2
36678: NEG
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36698: LD_ADDR_VAR 0 48
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 0
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 0
36746: PUSH
36747: LD_INT 1
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: LD_INT 0
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 1
36767: NEG
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: LD_INT 2
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 0
36791: PUSH
36792: LD_INT 2
36794: NEG
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: EMPTY
36828: LIST
36829: LIST
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36845: LD_ADDR_VAR 0 49
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: LD_INT 0
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 0
36862: PUSH
36863: LD_INT 1
36865: NEG
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: PUSH
36874: LD_INT 0
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 1
36883: PUSH
36884: LD_INT 1
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 1
36914: NEG
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: PUSH
36927: LD_INT 1
36929: NEG
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 2
36937: PUSH
36938: LD_INT 0
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 2
36957: PUSH
36958: LD_INT 2
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 1
36967: PUSH
36968: LD_INT 2
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36989: LD_ADDR_VAR 0 50
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 0
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 0
37006: PUSH
37007: LD_INT 1
37009: NEG
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: PUSH
37018: LD_INT 0
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 1
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 0
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 1
37058: NEG
37059: PUSH
37060: LD_INT 1
37062: NEG
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 2
37080: PUSH
37081: LD_INT 2
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 1
37090: PUSH
37091: LD_INT 2
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 2
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 1
37110: NEG
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37133: LD_ADDR_VAR 0 51
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: LD_INT 0
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 0
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: LD_INT 0
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: LD_INT 1
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 0
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 1
37191: NEG
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: LD_INT 1
37202: NEG
37203: PUSH
37204: LD_INT 1
37206: NEG
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 1
37214: PUSH
37215: LD_INT 2
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: LD_INT 2
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: LD_INT 1
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 2
37245: NEG
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 2
37256: NEG
37257: PUSH
37258: LD_INT 1
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: LIST
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37280: LD_ADDR_VAR 0 52
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: LD_INT 0
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 0
37297: PUSH
37298: LD_INT 1
37300: NEG
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 1
37318: PUSH
37319: LD_INT 1
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 0
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 1
37338: NEG
37339: PUSH
37340: LD_INT 0
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 1
37349: NEG
37350: PUSH
37351: LD_INT 1
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: NEG
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: LD_INT 1
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 2
37384: NEG
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: PUSH
37393: LD_INT 2
37395: NEG
37396: PUSH
37397: LD_INT 1
37399: NEG
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 2
37407: NEG
37408: PUSH
37409: LD_INT 2
37411: NEG
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: LIST
37430: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37431: LD_ADDR_VAR 0 53
37435: PUSH
37436: LD_INT 0
37438: PUSH
37439: LD_INT 0
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 0
37448: PUSH
37449: LD_INT 1
37451: NEG
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 1
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 0
37479: PUSH
37480: LD_INT 1
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 1
37489: NEG
37490: PUSH
37491: LD_INT 0
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: LD_INT 2
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 0
37524: PUSH
37525: LD_INT 2
37527: NEG
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: LD_INT 1
37538: NEG
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 2
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: EMPTY
37551: LIST
37552: LIST
37553: PUSH
37554: LD_INT 2
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 2
37566: PUSH
37567: LD_INT 2
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: LD_INT 2
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 0
37586: PUSH
37587: LD_INT 2
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 1
37596: NEG
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 2
37607: NEG
37608: PUSH
37609: LD_INT 0
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: LD_INT 1
37622: NEG
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 2
37630: NEG
37631: PUSH
37632: LD_INT 2
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37661: LD_ADDR_VAR 0 54
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 0
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: LD_INT 1
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: PUSH
37690: LD_INT 0
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 1
37719: NEG
37720: PUSH
37721: LD_INT 0
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 1
37730: NEG
37731: PUSH
37732: LD_INT 1
37734: NEG
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: LD_INT 1
37742: NEG
37743: PUSH
37744: LD_INT 2
37746: NEG
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 0
37754: PUSH
37755: LD_INT 2
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 2
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 2
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 2
37796: PUSH
37797: LD_INT 2
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 1
37806: PUSH
37807: LD_INT 2
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 0
37816: PUSH
37817: LD_INT 2
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 1
37826: NEG
37827: PUSH
37828: LD_INT 1
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: NEG
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 2
37848: NEG
37849: PUSH
37850: LD_INT 1
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 2
37860: NEG
37861: PUSH
37862: LD_INT 2
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37891: LD_ADDR_VAR 0 55
37895: PUSH
37896: LD_INT 0
37898: PUSH
37899: LD_INT 0
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 0
37908: PUSH
37909: LD_INT 1
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: LD_INT 0
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 0
37939: PUSH
37940: LD_INT 1
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 1
37949: NEG
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: NEG
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: LD_INT 2
37976: NEG
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: LD_INT 2
37987: NEG
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 2
38006: PUSH
38007: LD_INT 0
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: PUSH
38014: LD_INT 2
38016: PUSH
38017: LD_INT 1
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 2
38026: PUSH
38027: LD_INT 2
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 1
38036: PUSH
38037: LD_INT 2
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: LD_INT 2
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: LD_INT 1
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 2
38067: NEG
38068: PUSH
38069: LD_INT 0
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 2
38078: NEG
38079: PUSH
38080: LD_INT 1
38082: NEG
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 2
38090: NEG
38091: PUSH
38092: LD_INT 2
38094: NEG
38095: PUSH
38096: EMPTY
38097: LIST
38098: LIST
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: LIST
38104: LIST
38105: LIST
38106: LIST
38107: LIST
38108: LIST
38109: LIST
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: LIST
38120: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38121: LD_ADDR_VAR 0 56
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: PUSH
38150: LD_INT 0
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 0
38169: PUSH
38170: LD_INT 1
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: NEG
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 1
38190: NEG
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: NEG
38203: PUSH
38204: LD_INT 2
38206: NEG
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: LD_INT 2
38217: NEG
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: LD_INT 1
38228: NEG
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 2
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 2
38246: PUSH
38247: LD_INT 1
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: PUSH
38257: LD_INT 2
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: LD_INT 2
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: LD_INT 2
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: LD_INT 0
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 2
38308: NEG
38309: PUSH
38310: LD_INT 1
38312: NEG
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 2
38320: NEG
38321: PUSH
38322: LD_INT 2
38324: NEG
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38351: LD_ADDR_VAR 0 57
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 0
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 1
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 0
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 1
38424: NEG
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: NEG
38433: PUSH
38434: LD_INT 2
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 1
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 2
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 2
38486: PUSH
38487: LD_INT 2
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 1
38496: PUSH
38497: LD_INT 2
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 0
38506: PUSH
38507: LD_INT 2
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: NEG
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 2
38538: NEG
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 2
38550: NEG
38551: PUSH
38552: LD_INT 2
38554: NEG
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: LIST
38570: LIST
38571: LIST
38572: LIST
38573: LIST
38574: LIST
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38581: LD_ADDR_VAR 0 58
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 0
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 0
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 1
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 0
38629: PUSH
38630: LD_INT 1
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: NEG
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: LD_INT 1
38654: NEG
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 1
38662: NEG
38663: PUSH
38664: LD_INT 2
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 0
38674: PUSH
38675: LD_INT 2
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 2
38696: PUSH
38697: LD_INT 0
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 2
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: PUSH
38717: LD_INT 2
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 1
38726: PUSH
38727: LD_INT 2
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 0
38736: PUSH
38737: LD_INT 2
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 1
38746: NEG
38747: PUSH
38748: LD_INT 1
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 2
38757: NEG
38758: PUSH
38759: LD_INT 0
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 2
38768: NEG
38769: PUSH
38770: LD_INT 1
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 2
38780: NEG
38781: PUSH
38782: LD_INT 2
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: LIST
38795: LIST
38796: LIST
38797: LIST
38798: LIST
38799: LIST
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38811: LD_ADDR_VAR 0 59
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: LD_INT 0
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 0
38828: PUSH
38829: LD_INT 1
38831: NEG
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: PUSH
38840: LD_INT 0
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 1
38849: PUSH
38850: LD_INT 1
38852: PUSH
38853: EMPTY
38854: LIST
38855: LIST
38856: PUSH
38857: LD_INT 0
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: PUSH
38867: LD_INT 1
38869: NEG
38870: PUSH
38871: LD_INT 0
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: PUSH
38878: LD_INT 1
38880: NEG
38881: PUSH
38882: LD_INT 1
38884: NEG
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38899: LD_ADDR_VAR 0 60
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 0
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 1
38968: NEG
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38987: LD_ADDR_VAR 0 61
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 0
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 1
39025: PUSH
39026: LD_INT 1
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: EMPTY
39040: LIST
39041: LIST
39042: PUSH
39043: LD_INT 1
39045: NEG
39046: PUSH
39047: LD_INT 0
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: NEG
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39075: LD_ADDR_VAR 0 62
39079: PUSH
39080: LD_INT 0
39082: PUSH
39083: LD_INT 0
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 0
39092: PUSH
39093: LD_INT 1
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: LD_INT 0
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 1
39113: PUSH
39114: LD_INT 1
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: LD_INT 1
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PUSH
39131: LD_INT 1
39133: NEG
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 1
39144: NEG
39145: PUSH
39146: LD_INT 1
39148: NEG
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39163: LD_ADDR_VAR 0 63
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 0
39180: PUSH
39181: LD_INT 1
39183: NEG
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 1
39201: PUSH
39202: LD_INT 1
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 0
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 1
39221: NEG
39222: PUSH
39223: LD_INT 0
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 1
39232: NEG
39233: PUSH
39234: LD_INT 1
39236: NEG
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39251: LD_ADDR_VAR 0 64
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 0
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: LD_INT 1
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 1
39289: PUSH
39290: LD_INT 1
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 0
39299: PUSH
39300: LD_INT 1
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 1
39309: NEG
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: ST_TO_ADDR
// end ; 1 :
39339: GO 45236
39341: LD_INT 1
39343: DOUBLE
39344: EQUAL
39345: IFTRUE 39349
39347: GO 41972
39349: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39350: LD_ADDR_VAR 0 11
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 3
39361: NEG
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 3
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 2
39383: NEG
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: LIST
39393: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39394: LD_ADDR_VAR 0 12
39398: PUSH
39399: LD_INT 2
39401: PUSH
39402: LD_INT 1
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 3
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 3
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: LIST
39434: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39435: LD_ADDR_VAR 0 13
39439: PUSH
39440: LD_INT 3
39442: PUSH
39443: LD_INT 2
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 3
39452: PUSH
39453: LD_INT 3
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 2
39462: PUSH
39463: LD_INT 3
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: LIST
39474: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39475: LD_ADDR_VAR 0 14
39479: PUSH
39480: LD_INT 1
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 0
39492: PUSH
39493: LD_INT 3
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: NEG
39503: PUSH
39504: LD_INT 2
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: LIST
39515: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39516: LD_ADDR_VAR 0 15
39520: PUSH
39521: LD_INT 2
39523: NEG
39524: PUSH
39525: LD_INT 1
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 3
39534: NEG
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: NEG
39546: PUSH
39547: LD_INT 1
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: LIST
39559: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39560: LD_ADDR_VAR 0 16
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 3
39579: NEG
39580: PUSH
39581: LD_INT 2
39583: NEG
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 3
39591: NEG
39592: PUSH
39593: LD_INT 3
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: LIST
39605: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39606: LD_ADDR_VAR 0 17
39610: PUSH
39611: LD_INT 1
39613: NEG
39614: PUSH
39615: LD_INT 3
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 0
39625: PUSH
39626: LD_INT 3
39628: NEG
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 1
39636: PUSH
39637: LD_INT 2
39639: NEG
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: LIST
39649: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39650: LD_ADDR_VAR 0 18
39654: PUSH
39655: LD_INT 2
39657: PUSH
39658: LD_INT 1
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 3
39668: PUSH
39669: LD_INT 0
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 3
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: LIST
39690: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39691: LD_ADDR_VAR 0 19
39695: PUSH
39696: LD_INT 3
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 3
39708: PUSH
39709: LD_INT 3
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 2
39718: PUSH
39719: LD_INT 3
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: LIST
39730: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39731: LD_ADDR_VAR 0 20
39735: PUSH
39736: LD_INT 1
39738: PUSH
39739: LD_INT 3
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: LD_INT 3
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: LD_INT 2
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: LIST
39771: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39772: LD_ADDR_VAR 0 21
39776: PUSH
39777: LD_INT 2
39779: NEG
39780: PUSH
39781: LD_INT 1
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 3
39790: NEG
39791: PUSH
39792: LD_INT 0
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 3
39801: NEG
39802: PUSH
39803: LD_INT 1
39805: NEG
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: LIST
39815: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39816: LD_ADDR_VAR 0 22
39820: PUSH
39821: LD_INT 2
39823: NEG
39824: PUSH
39825: LD_INT 3
39827: NEG
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 3
39835: NEG
39836: PUSH
39837: LD_INT 2
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 3
39847: NEG
39848: PUSH
39849: LD_INT 3
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: LIST
39861: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39862: LD_ADDR_VAR 0 23
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: LD_INT 3
39872: NEG
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 1
39880: NEG
39881: PUSH
39882: LD_INT 4
39884: NEG
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: LD_INT 3
39895: NEG
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: LIST
39905: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39906: LD_ADDR_VAR 0 24
39910: PUSH
39911: LD_INT 3
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 3
39923: PUSH
39924: LD_INT 1
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 4
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39947: LD_ADDR_VAR 0 25
39951: PUSH
39952: LD_INT 3
39954: PUSH
39955: LD_INT 3
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 4
39964: PUSH
39965: LD_INT 3
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 3
39974: PUSH
39975: LD_INT 4
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: LIST
39986: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39987: LD_ADDR_VAR 0 26
39991: PUSH
39992: LD_INT 0
39994: PUSH
39995: LD_INT 3
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: LD_INT 4
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 1
40014: NEG
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: LIST
40027: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40028: LD_ADDR_VAR 0 27
40032: PUSH
40033: LD_INT 3
40035: NEG
40036: PUSH
40037: LD_INT 0
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 3
40046: NEG
40047: PUSH
40048: LD_INT 1
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 4
40057: NEG
40058: PUSH
40059: LD_INT 1
40061: NEG
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: LIST
40071: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40072: LD_ADDR_VAR 0 28
40076: PUSH
40077: LD_INT 3
40079: NEG
40080: PUSH
40081: LD_INT 3
40083: NEG
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 3
40091: NEG
40092: PUSH
40093: LD_INT 4
40095: NEG
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 4
40103: NEG
40104: PUSH
40105: LD_INT 3
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: LIST
40117: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40118: LD_ADDR_VAR 0 29
40122: PUSH
40123: LD_INT 1
40125: NEG
40126: PUSH
40127: LD_INT 3
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: LD_INT 3
40140: NEG
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 1
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 4
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: LD_INT 4
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: LD_INT 3
40185: NEG
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 1
40193: NEG
40194: PUSH
40195: LD_INT 5
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 5
40208: NEG
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: PUSH
40217: LD_INT 4
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: LD_INT 6
40231: NEG
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 0
40239: PUSH
40240: LD_INT 6
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: LD_INT 5
40253: NEG
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40273: LD_ADDR_VAR 0 30
40277: PUSH
40278: LD_INT 2
40280: PUSH
40281: LD_INT 1
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 3
40291: PUSH
40292: LD_INT 0
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 3
40301: PUSH
40302: LD_INT 1
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 3
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 4
40322: PUSH
40323: LD_INT 0
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 4
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 4
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 5
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 5
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 5
40373: PUSH
40374: LD_INT 1
40376: NEG
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 6
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 6
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: LIST
40406: LIST
40407: LIST
40408: LIST
40409: LIST
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40416: LD_ADDR_VAR 0 31
40420: PUSH
40421: LD_INT 3
40423: PUSH
40424: LD_INT 2
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: LD_INT 3
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 2
40443: PUSH
40444: LD_INT 3
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 4
40453: PUSH
40454: LD_INT 3
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 4
40463: PUSH
40464: LD_INT 4
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 3
40473: PUSH
40474: LD_INT 4
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 5
40483: PUSH
40484: LD_INT 4
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 5
40493: PUSH
40494: LD_INT 5
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 4
40503: PUSH
40504: LD_INT 5
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 6
40513: PUSH
40514: LD_INT 5
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 6
40523: PUSH
40524: LD_INT 6
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 5
40533: PUSH
40534: LD_INT 6
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40555: LD_ADDR_VAR 0 32
40559: PUSH
40560: LD_INT 1
40562: PUSH
40563: LD_INT 3
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 0
40572: PUSH
40573: LD_INT 3
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: NEG
40583: PUSH
40584: LD_INT 2
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 1
40593: PUSH
40594: LD_INT 4
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 0
40603: PUSH
40604: LD_INT 4
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 1
40613: NEG
40614: PUSH
40615: LD_INT 3
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 1
40624: PUSH
40625: LD_INT 5
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 0
40634: PUSH
40635: LD_INT 5
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: LD_INT 1
40644: NEG
40645: PUSH
40646: LD_INT 4
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: PUSH
40653: LD_INT 1
40655: PUSH
40656: LD_INT 6
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 6
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 1
40675: NEG
40676: PUSH
40677: LD_INT 5
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40698: LD_ADDR_VAR 0 33
40702: PUSH
40703: LD_INT 2
40705: NEG
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 3
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 3
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 3
40739: NEG
40740: PUSH
40741: LD_INT 1
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 4
40750: NEG
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 4
40761: NEG
40762: PUSH
40763: LD_INT 1
40765: NEG
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 4
40773: NEG
40774: PUSH
40775: LD_INT 1
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 5
40784: NEG
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 5
40795: NEG
40796: PUSH
40797: LD_INT 1
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 5
40807: NEG
40808: PUSH
40809: LD_INT 1
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 6
40818: NEG
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 6
40829: NEG
40830: PUSH
40831: LD_INT 1
40833: NEG
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: LIST
40843: LIST
40844: LIST
40845: LIST
40846: LIST
40847: LIST
40848: LIST
40849: LIST
40850: LIST
40851: LIST
40852: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40853: LD_ADDR_VAR 0 34
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: LD_INT 3
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: LD_INT 2
40876: NEG
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 3
40884: NEG
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 3
40896: NEG
40897: PUSH
40898: LD_INT 4
40900: NEG
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 4
40908: NEG
40909: PUSH
40910: LD_INT 3
40912: NEG
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 4
40920: NEG
40921: PUSH
40922: LD_INT 4
40924: NEG
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: LD_INT 4
40932: NEG
40933: PUSH
40934: LD_INT 5
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 5
40944: NEG
40945: PUSH
40946: LD_INT 4
40948: NEG
40949: PUSH
40950: EMPTY
40951: LIST
40952: LIST
40953: PUSH
40954: LD_INT 5
40956: NEG
40957: PUSH
40958: LD_INT 5
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 5
40968: NEG
40969: PUSH
40970: LD_INT 6
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 6
40980: NEG
40981: PUSH
40982: LD_INT 5
40984: NEG
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 6
40992: NEG
40993: PUSH
40994: LD_INT 6
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41016: LD_ADDR_VAR 0 41
41020: PUSH
41021: LD_INT 0
41023: PUSH
41024: LD_INT 2
41026: NEG
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: LD_INT 1
41034: NEG
41035: PUSH
41036: LD_INT 3
41038: NEG
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: LD_INT 2
41049: NEG
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: LIST
41059: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41060: LD_ADDR_VAR 0 42
41064: PUSH
41065: LD_INT 2
41067: PUSH
41068: LD_INT 0
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 2
41077: PUSH
41078: LD_INT 1
41080: NEG
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: LD_INT 3
41088: PUSH
41089: LD_INT 1
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: LIST
41100: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41101: LD_ADDR_VAR 0 43
41105: PUSH
41106: LD_INT 2
41108: PUSH
41109: LD_INT 2
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 2
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 2
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41141: LD_ADDR_VAR 0 44
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: LD_INT 2
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 1
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 1
41168: NEG
41169: PUSH
41170: LD_INT 2
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: EMPTY
41178: LIST
41179: LIST
41180: LIST
41181: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41182: LD_ADDR_VAR 0 45
41186: PUSH
41187: LD_INT 2
41189: NEG
41190: PUSH
41191: LD_INT 0
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 2
41200: NEG
41201: PUSH
41202: LD_INT 1
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: LD_INT 3
41211: NEG
41212: PUSH
41213: LD_INT 1
41215: NEG
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: LIST
41225: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41226: LD_ADDR_VAR 0 46
41230: PUSH
41231: LD_INT 2
41233: NEG
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 2
41245: NEG
41246: PUSH
41247: LD_INT 3
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 3
41257: NEG
41258: PUSH
41259: LD_INT 2
41261: NEG
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: LIST
41271: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41272: LD_ADDR_VAR 0 47
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: LD_INT 3
41283: NEG
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 1
41291: NEG
41292: PUSH
41293: LD_INT 3
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41305: LD_ADDR_VAR 0 48
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: LD_INT 2
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 2
41323: PUSH
41324: LD_INT 1
41326: NEG
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41336: LD_ADDR_VAR 0 49
41340: PUSH
41341: LD_INT 3
41343: PUSH
41344: LD_INT 1
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 3
41353: PUSH
41354: LD_INT 2
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41365: LD_ADDR_VAR 0 50
41369: PUSH
41370: LD_INT 2
41372: PUSH
41373: LD_INT 3
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: PUSH
41383: LD_INT 3
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41394: LD_ADDR_VAR 0 51
41398: PUSH
41399: LD_INT 1
41401: NEG
41402: PUSH
41403: LD_INT 2
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 2
41412: NEG
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41425: LD_ADDR_VAR 0 52
41429: PUSH
41430: LD_INT 3
41432: NEG
41433: PUSH
41434: LD_INT 1
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 3
41444: NEG
41445: PUSH
41446: LD_INT 2
41448: NEG
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41458: LD_ADDR_VAR 0 53
41462: PUSH
41463: LD_INT 1
41465: NEG
41466: PUSH
41467: LD_INT 3
41469: NEG
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 0
41477: PUSH
41478: LD_INT 3
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 1
41488: PUSH
41489: LD_INT 2
41491: NEG
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41502: LD_ADDR_VAR 0 54
41506: PUSH
41507: LD_INT 2
41509: PUSH
41510: LD_INT 1
41512: NEG
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 3
41520: PUSH
41521: LD_INT 0
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 3
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: LIST
41542: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41543: LD_ADDR_VAR 0 55
41547: PUSH
41548: LD_INT 3
41550: PUSH
41551: LD_INT 2
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 3
41560: PUSH
41561: LD_INT 3
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 2
41570: PUSH
41571: LD_INT 3
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: LIST
41582: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41583: LD_ADDR_VAR 0 56
41587: PUSH
41588: LD_INT 1
41590: PUSH
41591: LD_INT 3
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 0
41600: PUSH
41601: LD_INT 3
41603: PUSH
41604: EMPTY
41605: LIST
41606: LIST
41607: PUSH
41608: LD_INT 1
41610: NEG
41611: PUSH
41612: LD_INT 2
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: LIST
41623: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41624: LD_ADDR_VAR 0 57
41628: PUSH
41629: LD_INT 2
41631: NEG
41632: PUSH
41633: LD_INT 1
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 3
41642: NEG
41643: PUSH
41644: LD_INT 0
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 3
41653: NEG
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: LIST
41667: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41668: LD_ADDR_VAR 0 58
41672: PUSH
41673: LD_INT 2
41675: NEG
41676: PUSH
41677: LD_INT 3
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 3
41687: NEG
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: LD_INT 3
41699: NEG
41700: PUSH
41701: LD_INT 3
41703: NEG
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: LIST
41713: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41714: LD_ADDR_VAR 0 59
41718: PUSH
41719: LD_INT 1
41721: NEG
41722: PUSH
41723: LD_INT 2
41725: NEG
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 0
41733: PUSH
41734: LD_INT 2
41736: NEG
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: LD_INT 1
41747: NEG
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: LIST
41757: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41758: LD_ADDR_VAR 0 60
41762: PUSH
41763: LD_INT 1
41765: PUSH
41766: LD_INT 1
41768: NEG
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 2
41776: PUSH
41777: LD_INT 0
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: LIST
41798: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41799: LD_ADDR_VAR 0 61
41803: PUSH
41804: LD_INT 2
41806: PUSH
41807: LD_INT 1
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 2
41816: PUSH
41817: LD_INT 2
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 1
41826: PUSH
41827: LD_INT 2
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: LIST
41838: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41839: LD_ADDR_VAR 0 62
41843: PUSH
41844: LD_INT 1
41846: PUSH
41847: LD_INT 2
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 0
41856: PUSH
41857: LD_INT 2
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 1
41866: NEG
41867: PUSH
41868: LD_INT 1
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: LIST
41879: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41880: LD_ADDR_VAR 0 63
41884: PUSH
41885: LD_INT 1
41887: NEG
41888: PUSH
41889: LD_INT 1
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 2
41898: NEG
41899: PUSH
41900: LD_INT 0
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 2
41909: NEG
41910: PUSH
41911: LD_INT 1
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: LIST
41923: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41924: LD_ADDR_VAR 0 64
41928: PUSH
41929: LD_INT 1
41931: NEG
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 2
41943: NEG
41944: PUSH
41945: LD_INT 1
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 2
41955: NEG
41956: PUSH
41957: LD_INT 2
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: LIST
41969: ST_TO_ADDR
// end ; 2 :
41970: GO 45236
41972: LD_INT 2
41974: DOUBLE
41975: EQUAL
41976: IFTRUE 41980
41978: GO 45235
41980: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41981: LD_ADDR_VAR 0 29
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: LD_INT 0
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 4
41998: PUSH
41999: LD_INT 1
42001: NEG
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: LD_INT 5
42009: PUSH
42010: LD_INT 0
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 5
42019: PUSH
42020: LD_INT 1
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 4
42029: PUSH
42030: LD_INT 1
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 3
42039: PUSH
42040: LD_INT 0
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 3
42049: PUSH
42050: LD_INT 1
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 3
42060: PUSH
42061: LD_INT 2
42063: NEG
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 5
42071: PUSH
42072: LD_INT 2
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 3
42081: PUSH
42082: LD_INT 3
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 3
42091: PUSH
42092: LD_INT 2
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 4
42101: PUSH
42102: LD_INT 3
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 4
42111: PUSH
42112: LD_INT 4
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 3
42121: PUSH
42122: LD_INT 4
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 2
42131: PUSH
42132: LD_INT 3
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 2
42141: PUSH
42142: LD_INT 2
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: PUSH
42152: LD_INT 2
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 2
42161: PUSH
42162: LD_INT 4
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: LD_INT 4
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 0
42181: PUSH
42182: LD_INT 3
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 1
42191: PUSH
42192: LD_INT 4
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: LD_INT 1
42201: PUSH
42202: LD_INT 5
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PUSH
42209: LD_INT 0
42211: PUSH
42212: LD_INT 5
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: NEG
42222: PUSH
42223: LD_INT 4
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 1
42232: NEG
42233: PUSH
42234: LD_INT 3
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 2
42243: PUSH
42244: LD_INT 5
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 2
42253: NEG
42254: PUSH
42255: LD_INT 3
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 3
42264: NEG
42265: PUSH
42266: LD_INT 0
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 3
42275: NEG
42276: PUSH
42277: LD_INT 1
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 2
42287: NEG
42288: PUSH
42289: LD_INT 0
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: PUSH
42296: LD_INT 2
42298: NEG
42299: PUSH
42300: LD_INT 1
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: LD_INT 3
42309: NEG
42310: PUSH
42311: LD_INT 1
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PUSH
42318: LD_INT 4
42320: NEG
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: LD_INT 1
42335: NEG
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 4
42343: NEG
42344: PUSH
42345: LD_INT 2
42347: NEG
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 2
42355: NEG
42356: PUSH
42357: LD_INT 2
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: LD_INT 4
42366: NEG
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 4
42378: NEG
42379: PUSH
42380: LD_INT 5
42382: NEG
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 3
42390: NEG
42391: PUSH
42392: LD_INT 4
42394: NEG
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 3
42402: NEG
42403: PUSH
42404: LD_INT 3
42406: NEG
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 4
42414: NEG
42415: PUSH
42416: LD_INT 3
42418: NEG
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 5
42426: NEG
42427: PUSH
42428: LD_INT 4
42430: NEG
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 5
42438: NEG
42439: PUSH
42440: LD_INT 5
42442: NEG
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 3
42450: NEG
42451: PUSH
42452: LD_INT 5
42454: NEG
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 5
42462: NEG
42463: PUSH
42464: LD_INT 3
42466: NEG
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: LIST
42492: LIST
42493: LIST
42494: LIST
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: LIST
42500: LIST
42501: LIST
42502: LIST
42503: LIST
42504: LIST
42505: LIST
42506: LIST
42507: LIST
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: LIST
42513: LIST
42514: LIST
42515: LIST
42516: LIST
42517: LIST
42518: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42519: LD_ADDR_VAR 0 30
42523: PUSH
42524: LD_INT 4
42526: PUSH
42527: LD_INT 4
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 4
42536: PUSH
42537: LD_INT 3
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: PUSH
42544: LD_INT 5
42546: PUSH
42547: LD_INT 4
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 5
42556: PUSH
42557: LD_INT 5
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 4
42566: PUSH
42567: LD_INT 5
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 3
42576: PUSH
42577: LD_INT 4
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: PUSH
42587: LD_INT 3
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 5
42596: PUSH
42597: LD_INT 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 3
42606: PUSH
42607: LD_INT 5
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: LD_INT 3
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 0
42626: PUSH
42627: LD_INT 2
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 1
42636: PUSH
42637: LD_INT 3
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 1
42646: PUSH
42647: LD_INT 4
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 0
42656: PUSH
42657: LD_INT 4
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 1
42666: NEG
42667: PUSH
42668: LD_INT 3
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 1
42677: NEG
42678: PUSH
42679: LD_INT 2
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 2
42688: PUSH
42689: LD_INT 4
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 2
42698: NEG
42699: PUSH
42700: LD_INT 2
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 4
42709: NEG
42710: PUSH
42711: LD_INT 0
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 4
42720: NEG
42721: PUSH
42722: LD_INT 1
42724: NEG
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 3
42732: NEG
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 3
42743: NEG
42744: PUSH
42745: LD_INT 1
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 4
42754: NEG
42755: PUSH
42756: LD_INT 1
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 5
42765: NEG
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: LD_INT 5
42776: NEG
42777: PUSH
42778: LD_INT 1
42780: NEG
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: PUSH
42786: LD_INT 5
42788: NEG
42789: PUSH
42790: LD_INT 2
42792: NEG
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: LD_INT 3
42800: NEG
42801: PUSH
42802: LD_INT 2
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: LD_INT 3
42811: NEG
42812: PUSH
42813: LD_INT 3
42815: NEG
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 3
42823: NEG
42824: PUSH
42825: LD_INT 4
42827: NEG
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: PUSH
42833: LD_INT 2
42835: NEG
42836: PUSH
42837: LD_INT 3
42839: NEG
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 2
42847: NEG
42848: PUSH
42849: LD_INT 2
42851: NEG
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 3
42859: NEG
42860: PUSH
42861: LD_INT 2
42863: NEG
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PUSH
42869: LD_INT 4
42871: NEG
42872: PUSH
42873: LD_INT 3
42875: NEG
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PUSH
42881: LD_INT 4
42883: NEG
42884: PUSH
42885: LD_INT 4
42887: NEG
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 2
42895: NEG
42896: PUSH
42897: LD_INT 4
42899: NEG
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: LD_INT 4
42907: NEG
42908: PUSH
42909: LD_INT 2
42911: NEG
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 0
42919: PUSH
42920: LD_INT 4
42922: NEG
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: LD_INT 5
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 1
42941: PUSH
42942: LD_INT 4
42944: NEG
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 1
42952: PUSH
42953: LD_INT 3
42955: NEG
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 0
42963: PUSH
42964: LD_INT 3
42966: NEG
42967: PUSH
42968: EMPTY
42969: LIST
42970: LIST
42971: PUSH
42972: LD_INT 1
42974: NEG
42975: PUSH
42976: LD_INT 4
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: LD_INT 5
42990: NEG
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: PUSH
42999: LD_INT 3
43001: NEG
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 5
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: LIST
43027: LIST
43028: LIST
43029: LIST
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: LIST
43052: LIST
43053: LIST
43054: LIST
43055: LIST
43056: LIST
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43066: LD_ADDR_VAR 0 31
43070: PUSH
43071: LD_INT 0
43073: PUSH
43074: LD_INT 4
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 0
43083: PUSH
43084: LD_INT 3
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 1
43093: PUSH
43094: LD_INT 4
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 1
43103: PUSH
43104: LD_INT 5
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: LD_INT 0
43113: PUSH
43114: LD_INT 5
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 1
43123: NEG
43124: PUSH
43125: LD_INT 4
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 1
43134: NEG
43135: PUSH
43136: LD_INT 3
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 2
43145: PUSH
43146: LD_INT 5
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 2
43155: NEG
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 3
43166: NEG
43167: PUSH
43168: LD_INT 0
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 3
43177: NEG
43178: PUSH
43179: LD_INT 1
43181: NEG
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 2
43189: NEG
43190: PUSH
43191: LD_INT 0
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 2
43200: NEG
43201: PUSH
43202: LD_INT 1
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PUSH
43209: LD_INT 3
43211: NEG
43212: PUSH
43213: LD_INT 1
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: LD_INT 4
43222: NEG
43223: PUSH
43224: LD_INT 0
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 4
43233: NEG
43234: PUSH
43235: LD_INT 1
43237: NEG
43238: PUSH
43239: EMPTY
43240: LIST
43241: LIST
43242: PUSH
43243: LD_INT 4
43245: NEG
43246: PUSH
43247: LD_INT 2
43249: NEG
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 2
43257: NEG
43258: PUSH
43259: LD_INT 2
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 4
43268: NEG
43269: PUSH
43270: LD_INT 4
43272: NEG
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: PUSH
43278: LD_INT 4
43280: NEG
43281: PUSH
43282: LD_INT 5
43284: NEG
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 3
43292: NEG
43293: PUSH
43294: LD_INT 4
43296: NEG
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: LD_INT 3
43304: NEG
43305: PUSH
43306: LD_INT 3
43308: NEG
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 4
43316: NEG
43317: PUSH
43318: LD_INT 3
43320: NEG
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: LD_INT 5
43328: NEG
43329: PUSH
43330: LD_INT 4
43332: NEG
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PUSH
43338: LD_INT 5
43340: NEG
43341: PUSH
43342: LD_INT 5
43344: NEG
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 3
43352: NEG
43353: PUSH
43354: LD_INT 5
43356: NEG
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: LD_INT 5
43364: NEG
43365: PUSH
43366: LD_INT 3
43368: NEG
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 0
43376: PUSH
43377: LD_INT 3
43379: NEG
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: LD_INT 4
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 1
43398: PUSH
43399: LD_INT 3
43401: NEG
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 1
43409: PUSH
43410: LD_INT 2
43412: NEG
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 0
43420: PUSH
43421: LD_INT 2
43423: NEG
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 1
43431: NEG
43432: PUSH
43433: LD_INT 3
43435: NEG
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 1
43443: NEG
43444: PUSH
43445: LD_INT 4
43447: NEG
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: LD_INT 2
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 2
43466: NEG
43467: PUSH
43468: LD_INT 4
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 4
43478: PUSH
43479: LD_INT 0
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 4
43488: PUSH
43489: LD_INT 1
43491: NEG
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PUSH
43497: LD_INT 5
43499: PUSH
43500: LD_INT 0
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 5
43509: PUSH
43510: LD_INT 1
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 4
43519: PUSH
43520: LD_INT 1
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 3
43529: PUSH
43530: LD_INT 0
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 3
43539: PUSH
43540: LD_INT 1
43542: NEG
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: LD_INT 3
43550: PUSH
43551: LD_INT 2
43553: NEG
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 5
43561: PUSH
43562: LD_INT 2
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: LIST
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: LIST
43586: LIST
43587: LIST
43588: LIST
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: LIST
43594: LIST
43595: LIST
43596: LIST
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43616: LD_ADDR_VAR 0 32
43620: PUSH
43621: LD_INT 4
43623: NEG
43624: PUSH
43625: LD_INT 0
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 4
43634: NEG
43635: PUSH
43636: LD_INT 1
43638: NEG
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 3
43646: NEG
43647: PUSH
43648: LD_INT 0
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 3
43657: NEG
43658: PUSH
43659: LD_INT 1
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: LD_INT 1
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: LD_INT 5
43679: NEG
43680: PUSH
43681: LD_INT 0
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: PUSH
43688: LD_INT 5
43690: NEG
43691: PUSH
43692: LD_INT 1
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 5
43702: NEG
43703: PUSH
43704: LD_INT 2
43706: NEG
43707: PUSH
43708: EMPTY
43709: LIST
43710: LIST
43711: PUSH
43712: LD_INT 3
43714: NEG
43715: PUSH
43716: LD_INT 2
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 3
43725: NEG
43726: PUSH
43727: LD_INT 3
43729: NEG
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 3
43737: NEG
43738: PUSH
43739: LD_INT 4
43741: NEG
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 2
43749: NEG
43750: PUSH
43751: LD_INT 3
43753: NEG
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 2
43761: NEG
43762: PUSH
43763: LD_INT 2
43765: NEG
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 3
43773: NEG
43774: PUSH
43775: LD_INT 2
43777: NEG
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 4
43785: NEG
43786: PUSH
43787: LD_INT 3
43789: NEG
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 4
43797: NEG
43798: PUSH
43799: LD_INT 4
43801: NEG
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: LD_INT 2
43809: NEG
43810: PUSH
43811: LD_INT 4
43813: NEG
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 4
43821: NEG
43822: PUSH
43823: LD_INT 2
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 0
43833: PUSH
43834: LD_INT 4
43836: NEG
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 0
43844: PUSH
43845: LD_INT 5
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 1
43855: PUSH
43856: LD_INT 4
43858: NEG
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 1
43866: PUSH
43867: LD_INT 3
43869: NEG
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 0
43877: PUSH
43878: LD_INT 3
43880: NEG
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: NEG
43889: PUSH
43890: LD_INT 4
43892: NEG
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: NEG
43901: PUSH
43902: LD_INT 5
43904: NEG
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 2
43912: PUSH
43913: LD_INT 3
43915: NEG
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 2
43923: NEG
43924: PUSH
43925: LD_INT 5
43927: NEG
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 3
43935: PUSH
43936: LD_INT 0
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 3
43945: PUSH
43946: LD_INT 1
43948: NEG
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 4
43956: PUSH
43957: LD_INT 0
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 4
43966: PUSH
43967: LD_INT 1
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 3
43976: PUSH
43977: LD_INT 1
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 2
43986: PUSH
43987: LD_INT 0
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 2
43996: PUSH
43997: LD_INT 1
43999: NEG
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 2
44007: PUSH
44008: LD_INT 2
44010: NEG
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 4
44018: PUSH
44019: LD_INT 2
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 4
44028: PUSH
44029: LD_INT 4
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 4
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 5
44048: PUSH
44049: LD_INT 4
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 5
44058: PUSH
44059: LD_INT 5
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 4
44068: PUSH
44069: LD_INT 5
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 3
44078: PUSH
44079: LD_INT 4
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 3
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 5
44098: PUSH
44099: LD_INT 3
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 3
44108: PUSH
44109: LD_INT 5
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: LIST
44122: LIST
44123: LIST
44124: LIST
44125: LIST
44126: LIST
44127: LIST
44128: LIST
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: LIST
44135: LIST
44136: LIST
44137: LIST
44138: LIST
44139: LIST
44140: LIST
44141: LIST
44142: LIST
44143: LIST
44144: LIST
44145: LIST
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44163: LD_ADDR_VAR 0 33
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: LD_INT 4
44174: NEG
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 4
44182: NEG
44183: PUSH
44184: LD_INT 5
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 3
44194: NEG
44195: PUSH
44196: LD_INT 4
44198: NEG
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_INT 3
44206: NEG
44207: PUSH
44208: LD_INT 3
44210: NEG
44211: PUSH
44212: EMPTY
44213: LIST
44214: LIST
44215: PUSH
44216: LD_INT 4
44218: NEG
44219: PUSH
44220: LD_INT 3
44222: NEG
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 5
44230: NEG
44231: PUSH
44232: LD_INT 4
44234: NEG
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 5
44242: NEG
44243: PUSH
44244: LD_INT 5
44246: NEG
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 3
44254: NEG
44255: PUSH
44256: LD_INT 5
44258: NEG
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 5
44266: NEG
44267: PUSH
44268: LD_INT 3
44270: NEG
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: LD_INT 3
44281: NEG
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 0
44289: PUSH
44290: LD_INT 4
44292: NEG
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 1
44300: PUSH
44301: LD_INT 3
44303: NEG
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 1
44311: PUSH
44312: LD_INT 2
44314: NEG
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: LD_INT 2
44325: NEG
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PUSH
44331: LD_INT 1
44333: NEG
44334: PUSH
44335: LD_INT 3
44337: NEG
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 1
44345: NEG
44346: PUSH
44347: LD_INT 4
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 2
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 2
44368: NEG
44369: PUSH
44370: LD_INT 4
44372: NEG
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 4
44380: PUSH
44381: LD_INT 0
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: LD_INT 4
44390: PUSH
44391: LD_INT 1
44393: NEG
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: LD_INT 5
44401: PUSH
44402: LD_INT 0
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 5
44411: PUSH
44412: LD_INT 1
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PUSH
44419: LD_INT 4
44421: PUSH
44422: LD_INT 1
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 3
44431: PUSH
44432: LD_INT 0
44434: PUSH
44435: EMPTY
44436: LIST
44437: LIST
44438: PUSH
44439: LD_INT 3
44441: PUSH
44442: LD_INT 1
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 3
44452: PUSH
44453: LD_INT 2
44455: NEG
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 5
44463: PUSH
44464: LD_INT 2
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 3
44473: PUSH
44474: LD_INT 3
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 3
44483: PUSH
44484: LD_INT 2
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 4
44493: PUSH
44494: LD_INT 3
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 4
44503: PUSH
44504: LD_INT 4
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: PUSH
44511: LD_INT 3
44513: PUSH
44514: LD_INT 4
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 2
44523: PUSH
44524: LD_INT 3
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 2
44533: PUSH
44534: LD_INT 2
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 4
44543: PUSH
44544: LD_INT 2
44546: PUSH
44547: EMPTY
44548: LIST
44549: LIST
44550: PUSH
44551: LD_INT 2
44553: PUSH
44554: LD_INT 4
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: PUSH
44561: LD_INT 0
44563: PUSH
44564: LD_INT 4
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 0
44573: PUSH
44574: LD_INT 3
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 1
44583: PUSH
44584: LD_INT 4
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 1
44593: PUSH
44594: LD_INT 5
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 0
44603: PUSH
44604: LD_INT 5
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 1
44613: NEG
44614: PUSH
44615: LD_INT 4
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: LD_INT 1
44624: NEG
44625: PUSH
44626: LD_INT 3
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 2
44635: PUSH
44636: LD_INT 5
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 2
44645: NEG
44646: PUSH
44647: LD_INT 3
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: LIST
44675: LIST
44676: LIST
44677: LIST
44678: LIST
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: LIST
44696: LIST
44697: LIST
44698: LIST
44699: LIST
44700: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44701: LD_ADDR_VAR 0 34
44705: PUSH
44706: LD_INT 0
44708: PUSH
44709: LD_INT 4
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 5
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 1
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: LD_INT 3
44744: NEG
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 0
44752: PUSH
44753: LD_INT 3
44755: NEG
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 1
44763: NEG
44764: PUSH
44765: LD_INT 4
44767: NEG
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 1
44775: NEG
44776: PUSH
44777: LD_INT 5
44779: NEG
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: PUSH
44785: LD_INT 2
44787: PUSH
44788: LD_INT 3
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 2
44798: NEG
44799: PUSH
44800: LD_INT 5
44802: NEG
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 3
44810: PUSH
44811: LD_INT 0
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 3
44820: PUSH
44821: LD_INT 1
44823: NEG
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 4
44831: PUSH
44832: LD_INT 0
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 4
44841: PUSH
44842: LD_INT 1
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 3
44851: PUSH
44852: LD_INT 1
44854: PUSH
44855: EMPTY
44856: LIST
44857: LIST
44858: PUSH
44859: LD_INT 2
44861: PUSH
44862: LD_INT 0
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 2
44871: PUSH
44872: LD_INT 1
44874: NEG
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 2
44882: PUSH
44883: LD_INT 2
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 4
44893: PUSH
44894: LD_INT 2
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 4
44903: PUSH
44904: LD_INT 4
44906: PUSH
44907: EMPTY
44908: LIST
44909: LIST
44910: PUSH
44911: LD_INT 4
44913: PUSH
44914: LD_INT 3
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 5
44923: PUSH
44924: LD_INT 4
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 5
44933: PUSH
44934: LD_INT 5
44936: PUSH
44937: EMPTY
44938: LIST
44939: LIST
44940: PUSH
44941: LD_INT 4
44943: PUSH
44944: LD_INT 5
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 3
44953: PUSH
44954: LD_INT 4
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 3
44963: PUSH
44964: LD_INT 3
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 5
44973: PUSH
44974: LD_INT 3
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 3
44983: PUSH
44984: LD_INT 5
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: LD_INT 3
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: LD_INT 0
45003: PUSH
45004: LD_INT 2
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 1
45013: PUSH
45014: LD_INT 3
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: LD_INT 1
45023: PUSH
45024: LD_INT 4
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 0
45033: PUSH
45034: LD_INT 4
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 1
45043: NEG
45044: PUSH
45045: LD_INT 3
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 1
45054: NEG
45055: PUSH
45056: LD_INT 2
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 2
45065: PUSH
45066: LD_INT 4
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 2
45075: NEG
45076: PUSH
45077: LD_INT 2
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 4
45086: NEG
45087: PUSH
45088: LD_INT 0
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 4
45097: NEG
45098: PUSH
45099: LD_INT 1
45101: NEG
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 3
45109: NEG
45110: PUSH
45111: LD_INT 0
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 3
45120: NEG
45121: PUSH
45122: LD_INT 1
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 4
45131: NEG
45132: PUSH
45133: LD_INT 1
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 5
45142: NEG
45143: PUSH
45144: LD_INT 0
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: PUSH
45151: LD_INT 5
45153: NEG
45154: PUSH
45155: LD_INT 1
45157: NEG
45158: PUSH
45159: EMPTY
45160: LIST
45161: LIST
45162: PUSH
45163: LD_INT 5
45165: NEG
45166: PUSH
45167: LD_INT 2
45169: NEG
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 3
45177: NEG
45178: PUSH
45179: LD_INT 2
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: LIST
45219: LIST
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: ST_TO_ADDR
// end ; end ;
45233: GO 45236
45235: POP
// case btype of b_depot , b_warehouse :
45236: LD_VAR 0 1
45240: PUSH
45241: LD_INT 0
45243: DOUBLE
45244: EQUAL
45245: IFTRUE 45255
45247: LD_INT 1
45249: DOUBLE
45250: EQUAL
45251: IFTRUE 45255
45253: GO 45456
45255: POP
// case nation of nation_american :
45256: LD_VAR 0 5
45260: PUSH
45261: LD_INT 1
45263: DOUBLE
45264: EQUAL
45265: IFTRUE 45269
45267: GO 45325
45269: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45270: LD_ADDR_VAR 0 9
45274: PUSH
45275: LD_VAR 0 11
45279: PUSH
45280: LD_VAR 0 12
45284: PUSH
45285: LD_VAR 0 13
45289: PUSH
45290: LD_VAR 0 14
45294: PUSH
45295: LD_VAR 0 15
45299: PUSH
45300: LD_VAR 0 16
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: PUSH
45313: LD_VAR 0 4
45317: PUSH
45318: LD_INT 1
45320: PLUS
45321: ARRAY
45322: ST_TO_ADDR
45323: GO 45454
45325: LD_INT 2
45327: DOUBLE
45328: EQUAL
45329: IFTRUE 45333
45331: GO 45389
45333: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45334: LD_ADDR_VAR 0 9
45338: PUSH
45339: LD_VAR 0 17
45343: PUSH
45344: LD_VAR 0 18
45348: PUSH
45349: LD_VAR 0 19
45353: PUSH
45354: LD_VAR 0 20
45358: PUSH
45359: LD_VAR 0 21
45363: PUSH
45364: LD_VAR 0 22
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: PUSH
45377: LD_VAR 0 4
45381: PUSH
45382: LD_INT 1
45384: PLUS
45385: ARRAY
45386: ST_TO_ADDR
45387: GO 45454
45389: LD_INT 3
45391: DOUBLE
45392: EQUAL
45393: IFTRUE 45397
45395: GO 45453
45397: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45398: LD_ADDR_VAR 0 9
45402: PUSH
45403: LD_VAR 0 23
45407: PUSH
45408: LD_VAR 0 24
45412: PUSH
45413: LD_VAR 0 25
45417: PUSH
45418: LD_VAR 0 26
45422: PUSH
45423: LD_VAR 0 27
45427: PUSH
45428: LD_VAR 0 28
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: PUSH
45441: LD_VAR 0 4
45445: PUSH
45446: LD_INT 1
45448: PLUS
45449: ARRAY
45450: ST_TO_ADDR
45451: GO 45454
45453: POP
45454: GO 46009
45456: LD_INT 2
45458: DOUBLE
45459: EQUAL
45460: IFTRUE 45470
45462: LD_INT 3
45464: DOUBLE
45465: EQUAL
45466: IFTRUE 45470
45468: GO 45526
45470: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45471: LD_ADDR_VAR 0 9
45475: PUSH
45476: LD_VAR 0 29
45480: PUSH
45481: LD_VAR 0 30
45485: PUSH
45486: LD_VAR 0 31
45490: PUSH
45491: LD_VAR 0 32
45495: PUSH
45496: LD_VAR 0 33
45500: PUSH
45501: LD_VAR 0 34
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: PUSH
45514: LD_VAR 0 4
45518: PUSH
45519: LD_INT 1
45521: PLUS
45522: ARRAY
45523: ST_TO_ADDR
45524: GO 46009
45526: LD_INT 16
45528: DOUBLE
45529: EQUAL
45530: IFTRUE 45588
45532: LD_INT 17
45534: DOUBLE
45535: EQUAL
45536: IFTRUE 45588
45538: LD_INT 18
45540: DOUBLE
45541: EQUAL
45542: IFTRUE 45588
45544: LD_INT 19
45546: DOUBLE
45547: EQUAL
45548: IFTRUE 45588
45550: LD_INT 22
45552: DOUBLE
45553: EQUAL
45554: IFTRUE 45588
45556: LD_INT 20
45558: DOUBLE
45559: EQUAL
45560: IFTRUE 45588
45562: LD_INT 21
45564: DOUBLE
45565: EQUAL
45566: IFTRUE 45588
45568: LD_INT 23
45570: DOUBLE
45571: EQUAL
45572: IFTRUE 45588
45574: LD_INT 24
45576: DOUBLE
45577: EQUAL
45578: IFTRUE 45588
45580: LD_INT 25
45582: DOUBLE
45583: EQUAL
45584: IFTRUE 45588
45586: GO 45644
45588: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45589: LD_ADDR_VAR 0 9
45593: PUSH
45594: LD_VAR 0 35
45598: PUSH
45599: LD_VAR 0 36
45603: PUSH
45604: LD_VAR 0 37
45608: PUSH
45609: LD_VAR 0 38
45613: PUSH
45614: LD_VAR 0 39
45618: PUSH
45619: LD_VAR 0 40
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: PUSH
45632: LD_VAR 0 4
45636: PUSH
45637: LD_INT 1
45639: PLUS
45640: ARRAY
45641: ST_TO_ADDR
45642: GO 46009
45644: LD_INT 6
45646: DOUBLE
45647: EQUAL
45648: IFTRUE 45700
45650: LD_INT 7
45652: DOUBLE
45653: EQUAL
45654: IFTRUE 45700
45656: LD_INT 8
45658: DOUBLE
45659: EQUAL
45660: IFTRUE 45700
45662: LD_INT 13
45664: DOUBLE
45665: EQUAL
45666: IFTRUE 45700
45668: LD_INT 12
45670: DOUBLE
45671: EQUAL
45672: IFTRUE 45700
45674: LD_INT 15
45676: DOUBLE
45677: EQUAL
45678: IFTRUE 45700
45680: LD_INT 11
45682: DOUBLE
45683: EQUAL
45684: IFTRUE 45700
45686: LD_INT 14
45688: DOUBLE
45689: EQUAL
45690: IFTRUE 45700
45692: LD_INT 10
45694: DOUBLE
45695: EQUAL
45696: IFTRUE 45700
45698: GO 45756
45700: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45701: LD_ADDR_VAR 0 9
45705: PUSH
45706: LD_VAR 0 41
45710: PUSH
45711: LD_VAR 0 42
45715: PUSH
45716: LD_VAR 0 43
45720: PUSH
45721: LD_VAR 0 44
45725: PUSH
45726: LD_VAR 0 45
45730: PUSH
45731: LD_VAR 0 46
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: PUSH
45744: LD_VAR 0 4
45748: PUSH
45749: LD_INT 1
45751: PLUS
45752: ARRAY
45753: ST_TO_ADDR
45754: GO 46009
45756: LD_INT 36
45758: DOUBLE
45759: EQUAL
45760: IFTRUE 45764
45762: GO 45820
45764: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45765: LD_ADDR_VAR 0 9
45769: PUSH
45770: LD_VAR 0 47
45774: PUSH
45775: LD_VAR 0 48
45779: PUSH
45780: LD_VAR 0 49
45784: PUSH
45785: LD_VAR 0 50
45789: PUSH
45790: LD_VAR 0 51
45794: PUSH
45795: LD_VAR 0 52
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: PUSH
45808: LD_VAR 0 4
45812: PUSH
45813: LD_INT 1
45815: PLUS
45816: ARRAY
45817: ST_TO_ADDR
45818: GO 46009
45820: LD_INT 4
45822: DOUBLE
45823: EQUAL
45824: IFTRUE 45846
45826: LD_INT 5
45828: DOUBLE
45829: EQUAL
45830: IFTRUE 45846
45832: LD_INT 34
45834: DOUBLE
45835: EQUAL
45836: IFTRUE 45846
45838: LD_INT 37
45840: DOUBLE
45841: EQUAL
45842: IFTRUE 45846
45844: GO 45902
45846: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45847: LD_ADDR_VAR 0 9
45851: PUSH
45852: LD_VAR 0 53
45856: PUSH
45857: LD_VAR 0 54
45861: PUSH
45862: LD_VAR 0 55
45866: PUSH
45867: LD_VAR 0 56
45871: PUSH
45872: LD_VAR 0 57
45876: PUSH
45877: LD_VAR 0 58
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: PUSH
45890: LD_VAR 0 4
45894: PUSH
45895: LD_INT 1
45897: PLUS
45898: ARRAY
45899: ST_TO_ADDR
45900: GO 46009
45902: LD_INT 31
45904: DOUBLE
45905: EQUAL
45906: IFTRUE 45952
45908: LD_INT 32
45910: DOUBLE
45911: EQUAL
45912: IFTRUE 45952
45914: LD_INT 33
45916: DOUBLE
45917: EQUAL
45918: IFTRUE 45952
45920: LD_INT 27
45922: DOUBLE
45923: EQUAL
45924: IFTRUE 45952
45926: LD_INT 26
45928: DOUBLE
45929: EQUAL
45930: IFTRUE 45952
45932: LD_INT 28
45934: DOUBLE
45935: EQUAL
45936: IFTRUE 45952
45938: LD_INT 29
45940: DOUBLE
45941: EQUAL
45942: IFTRUE 45952
45944: LD_INT 30
45946: DOUBLE
45947: EQUAL
45948: IFTRUE 45952
45950: GO 46008
45952: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45953: LD_ADDR_VAR 0 9
45957: PUSH
45958: LD_VAR 0 59
45962: PUSH
45963: LD_VAR 0 60
45967: PUSH
45968: LD_VAR 0 61
45972: PUSH
45973: LD_VAR 0 62
45977: PUSH
45978: LD_VAR 0 63
45982: PUSH
45983: LD_VAR 0 64
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: PUSH
45996: LD_VAR 0 4
46000: PUSH
46001: LD_INT 1
46003: PLUS
46004: ARRAY
46005: ST_TO_ADDR
46006: GO 46009
46008: POP
// temp_list2 = [ ] ;
46009: LD_ADDR_VAR 0 10
46013: PUSH
46014: EMPTY
46015: ST_TO_ADDR
// for i in temp_list do
46016: LD_ADDR_VAR 0 8
46020: PUSH
46021: LD_VAR 0 9
46025: PUSH
46026: FOR_IN
46027: IFFALSE 46079
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46029: LD_ADDR_VAR 0 10
46033: PUSH
46034: LD_VAR 0 10
46038: PUSH
46039: LD_VAR 0 8
46043: PUSH
46044: LD_INT 1
46046: ARRAY
46047: PUSH
46048: LD_VAR 0 2
46052: PLUS
46053: PUSH
46054: LD_VAR 0 8
46058: PUSH
46059: LD_INT 2
46061: ARRAY
46062: PUSH
46063: LD_VAR 0 3
46067: PLUS
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: EMPTY
46074: LIST
46075: ADD
46076: ST_TO_ADDR
46077: GO 46026
46079: POP
46080: POP
// result = temp_list2 ;
46081: LD_ADDR_VAR 0 7
46085: PUSH
46086: LD_VAR 0 10
46090: ST_TO_ADDR
// end ;
46091: LD_VAR 0 7
46095: RET
// export function EnemyInRange ( unit , dist ) ; begin
46096: LD_INT 0
46098: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46099: LD_ADDR_VAR 0 3
46103: PUSH
46104: LD_VAR 0 1
46108: PPUSH
46109: CALL_OW 255
46113: PPUSH
46114: LD_VAR 0 1
46118: PPUSH
46119: CALL_OW 250
46123: PPUSH
46124: LD_VAR 0 1
46128: PPUSH
46129: CALL_OW 251
46133: PPUSH
46134: LD_VAR 0 2
46138: PPUSH
46139: CALL 19469 0 4
46143: PUSH
46144: LD_INT 4
46146: ARRAY
46147: ST_TO_ADDR
// end ;
46148: LD_VAR 0 3
46152: RET
// export function PlayerSeeMe ( unit ) ; begin
46153: LD_INT 0
46155: PPUSH
// result := See ( your_side , unit ) ;
46156: LD_ADDR_VAR 0 2
46160: PUSH
46161: LD_OWVAR 2
46165: PPUSH
46166: LD_VAR 0 1
46170: PPUSH
46171: CALL_OW 292
46175: ST_TO_ADDR
// end ;
46176: LD_VAR 0 2
46180: RET
// export function ReverseDir ( unit ) ; begin
46181: LD_INT 0
46183: PPUSH
// if not unit then
46184: LD_VAR 0 1
46188: NOT
46189: IFFALSE 46193
// exit ;
46191: GO 46216
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46193: LD_ADDR_VAR 0 2
46197: PUSH
46198: LD_VAR 0 1
46202: PPUSH
46203: CALL_OW 254
46207: PUSH
46208: LD_INT 3
46210: PLUS
46211: PUSH
46212: LD_INT 6
46214: MOD
46215: ST_TO_ADDR
// end ;
46216: LD_VAR 0 2
46220: RET
// export function ReverseArray ( array ) ; var i ; begin
46221: LD_INT 0
46223: PPUSH
46224: PPUSH
// if not array then
46225: LD_VAR 0 1
46229: NOT
46230: IFFALSE 46234
// exit ;
46232: GO 46289
// result := [ ] ;
46234: LD_ADDR_VAR 0 2
46238: PUSH
46239: EMPTY
46240: ST_TO_ADDR
// for i := array downto 1 do
46241: LD_ADDR_VAR 0 3
46245: PUSH
46246: DOUBLE
46247: LD_VAR 0 1
46251: INC
46252: ST_TO_ADDR
46253: LD_INT 1
46255: PUSH
46256: FOR_DOWNTO
46257: IFFALSE 46287
// result := Join ( result , array [ i ] ) ;
46259: LD_ADDR_VAR 0 2
46263: PUSH
46264: LD_VAR 0 2
46268: PPUSH
46269: LD_VAR 0 1
46273: PUSH
46274: LD_VAR 0 3
46278: ARRAY
46279: PPUSH
46280: CALL 50932 0 2
46284: ST_TO_ADDR
46285: GO 46256
46287: POP
46288: POP
// end ;
46289: LD_VAR 0 2
46293: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
46294: LD_INT 0
46296: PPUSH
46297: PPUSH
46298: PPUSH
46299: PPUSH
46300: PPUSH
46301: PPUSH
// if not unit or not hexes then
46302: LD_VAR 0 1
46306: NOT
46307: PUSH
46308: LD_VAR 0 2
46312: NOT
46313: OR
46314: IFFALSE 46318
// exit ;
46316: GO 46441
// dist := 9999 ;
46318: LD_ADDR_VAR 0 5
46322: PUSH
46323: LD_INT 9999
46325: ST_TO_ADDR
// for i = 1 to hexes do
46326: LD_ADDR_VAR 0 4
46330: PUSH
46331: DOUBLE
46332: LD_INT 1
46334: DEC
46335: ST_TO_ADDR
46336: LD_VAR 0 2
46340: PUSH
46341: FOR_TO
46342: IFFALSE 46429
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46344: LD_ADDR_VAR 0 6
46348: PUSH
46349: LD_VAR 0 1
46353: PPUSH
46354: LD_VAR 0 2
46358: PUSH
46359: LD_VAR 0 4
46363: ARRAY
46364: PUSH
46365: LD_INT 1
46367: ARRAY
46368: PPUSH
46369: LD_VAR 0 2
46373: PUSH
46374: LD_VAR 0 4
46378: ARRAY
46379: PUSH
46380: LD_INT 2
46382: ARRAY
46383: PPUSH
46384: CALL_OW 297
46388: ST_TO_ADDR
// if tdist < dist then
46389: LD_VAR 0 6
46393: PUSH
46394: LD_VAR 0 5
46398: LESS
46399: IFFALSE 46427
// begin hex := hexes [ i ] ;
46401: LD_ADDR_VAR 0 8
46405: PUSH
46406: LD_VAR 0 2
46410: PUSH
46411: LD_VAR 0 4
46415: ARRAY
46416: ST_TO_ADDR
// dist := tdist ;
46417: LD_ADDR_VAR 0 5
46421: PUSH
46422: LD_VAR 0 6
46426: ST_TO_ADDR
// end ; end ;
46427: GO 46341
46429: POP
46430: POP
// result := hex ;
46431: LD_ADDR_VAR 0 3
46435: PUSH
46436: LD_VAR 0 8
46440: ST_TO_ADDR
// end ;
46441: LD_VAR 0 3
46445: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46446: LD_INT 0
46448: PPUSH
46449: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46450: LD_VAR 0 1
46454: NOT
46455: PUSH
46456: LD_VAR 0 1
46460: PUSH
46461: LD_INT 21
46463: PUSH
46464: LD_INT 2
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 23
46473: PUSH
46474: LD_INT 2
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: EMPTY
46482: LIST
46483: LIST
46484: PPUSH
46485: CALL_OW 69
46489: IN
46490: NOT
46491: OR
46492: IFFALSE 46496
// exit ;
46494: GO 46543
// for i = 1 to 3 do
46496: LD_ADDR_VAR 0 3
46500: PUSH
46501: DOUBLE
46502: LD_INT 1
46504: DEC
46505: ST_TO_ADDR
46506: LD_INT 3
46508: PUSH
46509: FOR_TO
46510: IFFALSE 46541
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46512: LD_VAR 0 1
46516: PPUSH
46517: CALL_OW 250
46521: PPUSH
46522: LD_VAR 0 1
46526: PPUSH
46527: CALL_OW 251
46531: PPUSH
46532: LD_INT 1
46534: PPUSH
46535: CALL_OW 453
46539: GO 46509
46541: POP
46542: POP
// end ;
46543: LD_VAR 0 2
46547: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46548: LD_INT 0
46550: PPUSH
46551: PPUSH
46552: PPUSH
46553: PPUSH
46554: PPUSH
46555: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46556: LD_VAR 0 1
46560: NOT
46561: PUSH
46562: LD_VAR 0 2
46566: NOT
46567: OR
46568: PUSH
46569: LD_VAR 0 1
46573: PPUSH
46574: CALL_OW 314
46578: OR
46579: IFFALSE 46583
// exit ;
46581: GO 47050
// if GetLives ( i ) < 250 then
46583: LD_VAR 0 4
46587: PPUSH
46588: CALL_OW 256
46592: PUSH
46593: LD_INT 250
46595: LESS
46596: IFFALSE 46609
// begin ComAutodestruct ( i ) ;
46598: LD_VAR 0 4
46602: PPUSH
46603: CALL 46446 0 1
// exit ;
46607: GO 47050
// end ; x := GetX ( enemy_unit ) ;
46609: LD_ADDR_VAR 0 7
46613: PUSH
46614: LD_VAR 0 2
46618: PPUSH
46619: CALL_OW 250
46623: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46624: LD_ADDR_VAR 0 8
46628: PUSH
46629: LD_VAR 0 2
46633: PPUSH
46634: CALL_OW 251
46638: ST_TO_ADDR
// if not x or not y then
46639: LD_VAR 0 7
46643: NOT
46644: PUSH
46645: LD_VAR 0 8
46649: NOT
46650: OR
46651: IFFALSE 46655
// exit ;
46653: GO 47050
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46655: LD_ADDR_VAR 0 6
46659: PUSH
46660: LD_VAR 0 7
46664: PPUSH
46665: LD_INT 0
46667: PPUSH
46668: LD_INT 4
46670: PPUSH
46671: CALL_OW 272
46675: PUSH
46676: LD_VAR 0 8
46680: PPUSH
46681: LD_INT 0
46683: PPUSH
46684: LD_INT 4
46686: PPUSH
46687: CALL_OW 273
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_VAR 0 7
46700: PPUSH
46701: LD_INT 1
46703: PPUSH
46704: LD_INT 4
46706: PPUSH
46707: CALL_OW 272
46711: PUSH
46712: LD_VAR 0 8
46716: PPUSH
46717: LD_INT 1
46719: PPUSH
46720: LD_INT 4
46722: PPUSH
46723: CALL_OW 273
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_VAR 0 7
46736: PPUSH
46737: LD_INT 2
46739: PPUSH
46740: LD_INT 4
46742: PPUSH
46743: CALL_OW 272
46747: PUSH
46748: LD_VAR 0 8
46752: PPUSH
46753: LD_INT 2
46755: PPUSH
46756: LD_INT 4
46758: PPUSH
46759: CALL_OW 273
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: PUSH
46768: LD_VAR 0 7
46772: PPUSH
46773: LD_INT 3
46775: PPUSH
46776: LD_INT 4
46778: PPUSH
46779: CALL_OW 272
46783: PUSH
46784: LD_VAR 0 8
46788: PPUSH
46789: LD_INT 3
46791: PPUSH
46792: LD_INT 4
46794: PPUSH
46795: CALL_OW 273
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: PUSH
46804: LD_VAR 0 7
46808: PPUSH
46809: LD_INT 4
46811: PPUSH
46812: LD_INT 4
46814: PPUSH
46815: CALL_OW 272
46819: PUSH
46820: LD_VAR 0 8
46824: PPUSH
46825: LD_INT 4
46827: PPUSH
46828: LD_INT 4
46830: PPUSH
46831: CALL_OW 273
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: PUSH
46840: LD_VAR 0 7
46844: PPUSH
46845: LD_INT 5
46847: PPUSH
46848: LD_INT 4
46850: PPUSH
46851: CALL_OW 272
46855: PUSH
46856: LD_VAR 0 8
46860: PPUSH
46861: LD_INT 5
46863: PPUSH
46864: LD_INT 4
46866: PPUSH
46867: CALL_OW 273
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: ST_TO_ADDR
// for i = tmp downto 1 do
46884: LD_ADDR_VAR 0 4
46888: PUSH
46889: DOUBLE
46890: LD_VAR 0 6
46894: INC
46895: ST_TO_ADDR
46896: LD_INT 1
46898: PUSH
46899: FOR_DOWNTO
46900: IFFALSE 47001
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46902: LD_VAR 0 6
46906: PUSH
46907: LD_VAR 0 4
46911: ARRAY
46912: PUSH
46913: LD_INT 1
46915: ARRAY
46916: PPUSH
46917: LD_VAR 0 6
46921: PUSH
46922: LD_VAR 0 4
46926: ARRAY
46927: PUSH
46928: LD_INT 2
46930: ARRAY
46931: PPUSH
46932: CALL_OW 488
46936: NOT
46937: PUSH
46938: LD_VAR 0 6
46942: PUSH
46943: LD_VAR 0 4
46947: ARRAY
46948: PUSH
46949: LD_INT 1
46951: ARRAY
46952: PPUSH
46953: LD_VAR 0 6
46957: PUSH
46958: LD_VAR 0 4
46962: ARRAY
46963: PUSH
46964: LD_INT 2
46966: ARRAY
46967: PPUSH
46968: CALL_OW 428
46972: PUSH
46973: LD_INT 0
46975: NONEQUAL
46976: OR
46977: IFFALSE 46999
// tmp := Delete ( tmp , i ) ;
46979: LD_ADDR_VAR 0 6
46983: PUSH
46984: LD_VAR 0 6
46988: PPUSH
46989: LD_VAR 0 4
46993: PPUSH
46994: CALL_OW 3
46998: ST_TO_ADDR
46999: GO 46899
47001: POP
47002: POP
// j := GetClosestHex ( unit , tmp ) ;
47003: LD_ADDR_VAR 0 5
47007: PUSH
47008: LD_VAR 0 1
47012: PPUSH
47013: LD_VAR 0 6
47017: PPUSH
47018: CALL 46294 0 2
47022: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47023: LD_VAR 0 1
47027: PPUSH
47028: LD_VAR 0 5
47032: PUSH
47033: LD_INT 1
47035: ARRAY
47036: PPUSH
47037: LD_VAR 0 5
47041: PUSH
47042: LD_INT 2
47044: ARRAY
47045: PPUSH
47046: CALL_OW 111
// end ;
47050: LD_VAR 0 3
47054: RET
// export function PrepareApemanSoldier ( ) ; begin
47055: LD_INT 0
47057: PPUSH
// uc_nation := 0 ;
47058: LD_ADDR_OWVAR 21
47062: PUSH
47063: LD_INT 0
47065: ST_TO_ADDR
// hc_sex := sex_male ;
47066: LD_ADDR_OWVAR 27
47070: PUSH
47071: LD_INT 1
47073: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
47074: LD_ADDR_OWVAR 28
47078: PUSH
47079: LD_INT 15
47081: ST_TO_ADDR
// hc_gallery :=  ;
47082: LD_ADDR_OWVAR 33
47086: PUSH
47087: LD_STRING 
47089: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47090: LD_ADDR_OWVAR 31
47094: PUSH
47095: LD_INT 0
47097: PPUSH
47098: LD_INT 3
47100: PPUSH
47101: CALL_OW 12
47105: PUSH
47106: LD_INT 0
47108: PPUSH
47109: LD_INT 3
47111: PPUSH
47112: CALL_OW 12
47116: PUSH
47117: LD_INT 0
47119: PUSH
47120: LD_INT 0
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: LIST
47127: LIST
47128: ST_TO_ADDR
// end ;
47129: LD_VAR 0 1
47133: RET
// export function PrepareApemanEngineer ( ) ; begin
47134: LD_INT 0
47136: PPUSH
// uc_nation := 0 ;
47137: LD_ADDR_OWVAR 21
47141: PUSH
47142: LD_INT 0
47144: ST_TO_ADDR
// hc_sex := sex_male ;
47145: LD_ADDR_OWVAR 27
47149: PUSH
47150: LD_INT 1
47152: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
47153: LD_ADDR_OWVAR 28
47157: PUSH
47158: LD_INT 16
47160: ST_TO_ADDR
// hc_gallery :=  ;
47161: LD_ADDR_OWVAR 33
47165: PUSH
47166: LD_STRING 
47168: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47169: LD_ADDR_OWVAR 31
47173: PUSH
47174: LD_INT 0
47176: PPUSH
47177: LD_INT 3
47179: PPUSH
47180: CALL_OW 12
47184: PUSH
47185: LD_INT 0
47187: PPUSH
47188: LD_INT 3
47190: PPUSH
47191: CALL_OW 12
47195: PUSH
47196: LD_INT 0
47198: PUSH
47199: LD_INT 0
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: ST_TO_ADDR
// end ;
47208: LD_VAR 0 1
47212: RET
// export function PrepareApeman ( agressivity ) ; begin
47213: LD_INT 0
47215: PPUSH
// uc_side := 0 ;
47216: LD_ADDR_OWVAR 20
47220: PUSH
47221: LD_INT 0
47223: ST_TO_ADDR
// uc_nation := 0 ;
47224: LD_ADDR_OWVAR 21
47228: PUSH
47229: LD_INT 0
47231: ST_TO_ADDR
// hc_sex := sex_male ;
47232: LD_ADDR_OWVAR 27
47236: PUSH
47237: LD_INT 1
47239: ST_TO_ADDR
// hc_class := class_apeman ;
47240: LD_ADDR_OWVAR 28
47244: PUSH
47245: LD_INT 12
47247: ST_TO_ADDR
// hc_gallery :=  ;
47248: LD_ADDR_OWVAR 33
47252: PUSH
47253: LD_STRING 
47255: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47256: LD_ADDR_OWVAR 35
47260: PUSH
47261: LD_VAR 0 1
47265: NEG
47266: PPUSH
47267: LD_VAR 0 1
47271: PPUSH
47272: CALL_OW 12
47276: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
47277: LD_ADDR_OWVAR 31
47281: PUSH
47282: LD_INT 0
47284: PPUSH
47285: LD_INT 3
47287: PPUSH
47288: CALL_OW 12
47292: PUSH
47293: LD_INT 0
47295: PPUSH
47296: LD_INT 3
47298: PPUSH
47299: CALL_OW 12
47303: PUSH
47304: LD_INT 0
47306: PUSH
47307: LD_INT 0
47309: PUSH
47310: EMPTY
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: ST_TO_ADDR
// end ;
47316: LD_VAR 0 2
47320: RET
// export function PrepareTiger ( agressivity ) ; begin
47321: LD_INT 0
47323: PPUSH
// uc_side := 0 ;
47324: LD_ADDR_OWVAR 20
47328: PUSH
47329: LD_INT 0
47331: ST_TO_ADDR
// uc_nation := 0 ;
47332: LD_ADDR_OWVAR 21
47336: PUSH
47337: LD_INT 0
47339: ST_TO_ADDR
// hc_class := class_tiger ;
47340: LD_ADDR_OWVAR 28
47344: PUSH
47345: LD_INT 14
47347: ST_TO_ADDR
// hc_gallery :=  ;
47348: LD_ADDR_OWVAR 33
47352: PUSH
47353: LD_STRING 
47355: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
47356: LD_ADDR_OWVAR 35
47360: PUSH
47361: LD_VAR 0 1
47365: NEG
47366: PPUSH
47367: LD_VAR 0 1
47371: PPUSH
47372: CALL_OW 12
47376: ST_TO_ADDR
// end ;
47377: LD_VAR 0 2
47381: RET
// export function PrepareEnchidna ( ) ; begin
47382: LD_INT 0
47384: PPUSH
// uc_side := 0 ;
47385: LD_ADDR_OWVAR 20
47389: PUSH
47390: LD_INT 0
47392: ST_TO_ADDR
// uc_nation := 0 ;
47393: LD_ADDR_OWVAR 21
47397: PUSH
47398: LD_INT 0
47400: ST_TO_ADDR
// hc_class := class_baggie ;
47401: LD_ADDR_OWVAR 28
47405: PUSH
47406: LD_INT 13
47408: ST_TO_ADDR
// hc_gallery :=  ;
47409: LD_ADDR_OWVAR 33
47413: PUSH
47414: LD_STRING 
47416: ST_TO_ADDR
// end ;
47417: LD_VAR 0 1
47421: RET
// export function PrepareFrog ( ) ; begin
47422: LD_INT 0
47424: PPUSH
// uc_side := 0 ;
47425: LD_ADDR_OWVAR 20
47429: PUSH
47430: LD_INT 0
47432: ST_TO_ADDR
// uc_nation := 0 ;
47433: LD_ADDR_OWVAR 21
47437: PUSH
47438: LD_INT 0
47440: ST_TO_ADDR
// hc_class := class_frog ;
47441: LD_ADDR_OWVAR 28
47445: PUSH
47446: LD_INT 19
47448: ST_TO_ADDR
// hc_gallery :=  ;
47449: LD_ADDR_OWVAR 33
47453: PUSH
47454: LD_STRING 
47456: ST_TO_ADDR
// end ;
47457: LD_VAR 0 1
47461: RET
// export function PrepareFish ( ) ; begin
47462: LD_INT 0
47464: PPUSH
// uc_side := 0 ;
47465: LD_ADDR_OWVAR 20
47469: PUSH
47470: LD_INT 0
47472: ST_TO_ADDR
// uc_nation := 0 ;
47473: LD_ADDR_OWVAR 21
47477: PUSH
47478: LD_INT 0
47480: ST_TO_ADDR
// hc_class := class_fish ;
47481: LD_ADDR_OWVAR 28
47485: PUSH
47486: LD_INT 20
47488: ST_TO_ADDR
// hc_gallery :=  ;
47489: LD_ADDR_OWVAR 33
47493: PUSH
47494: LD_STRING 
47496: ST_TO_ADDR
// end ;
47497: LD_VAR 0 1
47501: RET
// export function PrepareBird ( ) ; begin
47502: LD_INT 0
47504: PPUSH
// uc_side := 0 ;
47505: LD_ADDR_OWVAR 20
47509: PUSH
47510: LD_INT 0
47512: ST_TO_ADDR
// uc_nation := 0 ;
47513: LD_ADDR_OWVAR 21
47517: PUSH
47518: LD_INT 0
47520: ST_TO_ADDR
// hc_class := class_phororhacos ;
47521: LD_ADDR_OWVAR 28
47525: PUSH
47526: LD_INT 18
47528: ST_TO_ADDR
// hc_gallery :=  ;
47529: LD_ADDR_OWVAR 33
47533: PUSH
47534: LD_STRING 
47536: ST_TO_ADDR
// end ;
47537: LD_VAR 0 1
47541: RET
// export function PrepareHorse ( ) ; begin
47542: LD_INT 0
47544: PPUSH
// uc_side := 0 ;
47545: LD_ADDR_OWVAR 20
47549: PUSH
47550: LD_INT 0
47552: ST_TO_ADDR
// uc_nation := 0 ;
47553: LD_ADDR_OWVAR 21
47557: PUSH
47558: LD_INT 0
47560: ST_TO_ADDR
// hc_class := class_horse ;
47561: LD_ADDR_OWVAR 28
47565: PUSH
47566: LD_INT 21
47568: ST_TO_ADDR
// hc_gallery :=  ;
47569: LD_ADDR_OWVAR 33
47573: PUSH
47574: LD_STRING 
47576: ST_TO_ADDR
// end ;
47577: LD_VAR 0 1
47581: RET
// export function PrepareMastodont ( ) ; begin
47582: LD_INT 0
47584: PPUSH
// uc_side := 0 ;
47585: LD_ADDR_OWVAR 20
47589: PUSH
47590: LD_INT 0
47592: ST_TO_ADDR
// uc_nation := 0 ;
47593: LD_ADDR_OWVAR 21
47597: PUSH
47598: LD_INT 0
47600: ST_TO_ADDR
// vc_chassis := class_mastodont ;
47601: LD_ADDR_OWVAR 37
47605: PUSH
47606: LD_INT 31
47608: ST_TO_ADDR
// vc_control := control_rider ;
47609: LD_ADDR_OWVAR 38
47613: PUSH
47614: LD_INT 4
47616: ST_TO_ADDR
// end ;
47617: LD_VAR 0 1
47621: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47622: LD_INT 0
47624: PPUSH
47625: PPUSH
47626: PPUSH
// uc_side = 0 ;
47627: LD_ADDR_OWVAR 20
47631: PUSH
47632: LD_INT 0
47634: ST_TO_ADDR
// uc_nation = 0 ;
47635: LD_ADDR_OWVAR 21
47639: PUSH
47640: LD_INT 0
47642: ST_TO_ADDR
// InitHc_All ( ) ;
47643: CALL_OW 584
// InitVc ;
47647: CALL_OW 20
// if mastodonts then
47651: LD_VAR 0 6
47655: IFFALSE 47722
// for i = 1 to mastodonts do
47657: LD_ADDR_VAR 0 11
47661: PUSH
47662: DOUBLE
47663: LD_INT 1
47665: DEC
47666: ST_TO_ADDR
47667: LD_VAR 0 6
47671: PUSH
47672: FOR_TO
47673: IFFALSE 47720
// begin vc_chassis := 31 ;
47675: LD_ADDR_OWVAR 37
47679: PUSH
47680: LD_INT 31
47682: ST_TO_ADDR
// vc_control := control_rider ;
47683: LD_ADDR_OWVAR 38
47687: PUSH
47688: LD_INT 4
47690: ST_TO_ADDR
// animal := CreateVehicle ;
47691: LD_ADDR_VAR 0 12
47695: PUSH
47696: CALL_OW 45
47700: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47701: LD_VAR 0 12
47705: PPUSH
47706: LD_VAR 0 8
47710: PPUSH
47711: LD_INT 0
47713: PPUSH
47714: CALL 49850 0 3
// end ;
47718: GO 47672
47720: POP
47721: POP
// if horses then
47722: LD_VAR 0 5
47726: IFFALSE 47793
// for i = 1 to horses do
47728: LD_ADDR_VAR 0 11
47732: PUSH
47733: DOUBLE
47734: LD_INT 1
47736: DEC
47737: ST_TO_ADDR
47738: LD_VAR 0 5
47742: PUSH
47743: FOR_TO
47744: IFFALSE 47791
// begin hc_class := 21 ;
47746: LD_ADDR_OWVAR 28
47750: PUSH
47751: LD_INT 21
47753: ST_TO_ADDR
// hc_gallery :=  ;
47754: LD_ADDR_OWVAR 33
47758: PUSH
47759: LD_STRING 
47761: ST_TO_ADDR
// animal := CreateHuman ;
47762: LD_ADDR_VAR 0 12
47766: PUSH
47767: CALL_OW 44
47771: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47772: LD_VAR 0 12
47776: PPUSH
47777: LD_VAR 0 8
47781: PPUSH
47782: LD_INT 0
47784: PPUSH
47785: CALL 49850 0 3
// end ;
47789: GO 47743
47791: POP
47792: POP
// if birds then
47793: LD_VAR 0 1
47797: IFFALSE 47864
// for i = 1 to birds do
47799: LD_ADDR_VAR 0 11
47803: PUSH
47804: DOUBLE
47805: LD_INT 1
47807: DEC
47808: ST_TO_ADDR
47809: LD_VAR 0 1
47813: PUSH
47814: FOR_TO
47815: IFFALSE 47862
// begin hc_class := 18 ;
47817: LD_ADDR_OWVAR 28
47821: PUSH
47822: LD_INT 18
47824: ST_TO_ADDR
// hc_gallery =  ;
47825: LD_ADDR_OWVAR 33
47829: PUSH
47830: LD_STRING 
47832: ST_TO_ADDR
// animal := CreateHuman ;
47833: LD_ADDR_VAR 0 12
47837: PUSH
47838: CALL_OW 44
47842: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47843: LD_VAR 0 12
47847: PPUSH
47848: LD_VAR 0 8
47852: PPUSH
47853: LD_INT 0
47855: PPUSH
47856: CALL 49850 0 3
// end ;
47860: GO 47814
47862: POP
47863: POP
// if tigers then
47864: LD_VAR 0 2
47868: IFFALSE 47952
// for i = 1 to tigers do
47870: LD_ADDR_VAR 0 11
47874: PUSH
47875: DOUBLE
47876: LD_INT 1
47878: DEC
47879: ST_TO_ADDR
47880: LD_VAR 0 2
47884: PUSH
47885: FOR_TO
47886: IFFALSE 47950
// begin hc_class = class_tiger ;
47888: LD_ADDR_OWVAR 28
47892: PUSH
47893: LD_INT 14
47895: ST_TO_ADDR
// hc_gallery =  ;
47896: LD_ADDR_OWVAR 33
47900: PUSH
47901: LD_STRING 
47903: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47904: LD_ADDR_OWVAR 35
47908: PUSH
47909: LD_INT 7
47911: NEG
47912: PPUSH
47913: LD_INT 7
47915: PPUSH
47916: CALL_OW 12
47920: ST_TO_ADDR
// animal := CreateHuman ;
47921: LD_ADDR_VAR 0 12
47925: PUSH
47926: CALL_OW 44
47930: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47931: LD_VAR 0 12
47935: PPUSH
47936: LD_VAR 0 8
47940: PPUSH
47941: LD_INT 0
47943: PPUSH
47944: CALL 49850 0 3
// end ;
47948: GO 47885
47950: POP
47951: POP
// if apemans then
47952: LD_VAR 0 3
47956: IFFALSE 48079
// for i = 1 to apemans do
47958: LD_ADDR_VAR 0 11
47962: PUSH
47963: DOUBLE
47964: LD_INT 1
47966: DEC
47967: ST_TO_ADDR
47968: LD_VAR 0 3
47972: PUSH
47973: FOR_TO
47974: IFFALSE 48077
// begin hc_class = class_apeman ;
47976: LD_ADDR_OWVAR 28
47980: PUSH
47981: LD_INT 12
47983: ST_TO_ADDR
// hc_gallery =  ;
47984: LD_ADDR_OWVAR 33
47988: PUSH
47989: LD_STRING 
47991: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
47992: LD_ADDR_OWVAR 35
47996: PUSH
47997: LD_INT 2
47999: NEG
48000: PPUSH
48001: LD_INT 2
48003: PPUSH
48004: CALL_OW 12
48008: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48009: LD_ADDR_OWVAR 31
48013: PUSH
48014: LD_INT 1
48016: PPUSH
48017: LD_INT 3
48019: PPUSH
48020: CALL_OW 12
48024: PUSH
48025: LD_INT 1
48027: PPUSH
48028: LD_INT 3
48030: PPUSH
48031: CALL_OW 12
48035: PUSH
48036: LD_INT 0
48038: PUSH
48039: LD_INT 0
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: ST_TO_ADDR
// animal := CreateHuman ;
48048: LD_ADDR_VAR 0 12
48052: PUSH
48053: CALL_OW 44
48057: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48058: LD_VAR 0 12
48062: PPUSH
48063: LD_VAR 0 8
48067: PPUSH
48068: LD_INT 0
48070: PPUSH
48071: CALL 49850 0 3
// end ;
48075: GO 47973
48077: POP
48078: POP
// if enchidnas then
48079: LD_VAR 0 4
48083: IFFALSE 48150
// for i = 1 to enchidnas do
48085: LD_ADDR_VAR 0 11
48089: PUSH
48090: DOUBLE
48091: LD_INT 1
48093: DEC
48094: ST_TO_ADDR
48095: LD_VAR 0 4
48099: PUSH
48100: FOR_TO
48101: IFFALSE 48148
// begin hc_class = 13 ;
48103: LD_ADDR_OWVAR 28
48107: PUSH
48108: LD_INT 13
48110: ST_TO_ADDR
// hc_gallery =  ;
48111: LD_ADDR_OWVAR 33
48115: PUSH
48116: LD_STRING 
48118: ST_TO_ADDR
// animal := CreateHuman ;
48119: LD_ADDR_VAR 0 12
48123: PUSH
48124: CALL_OW 44
48128: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48129: LD_VAR 0 12
48133: PPUSH
48134: LD_VAR 0 8
48138: PPUSH
48139: LD_INT 0
48141: PPUSH
48142: CALL 49850 0 3
// end ;
48146: GO 48100
48148: POP
48149: POP
// if fishes then
48150: LD_VAR 0 7
48154: IFFALSE 48221
// for i = 1 to fishes do
48156: LD_ADDR_VAR 0 11
48160: PUSH
48161: DOUBLE
48162: LD_INT 1
48164: DEC
48165: ST_TO_ADDR
48166: LD_VAR 0 7
48170: PUSH
48171: FOR_TO
48172: IFFALSE 48219
// begin hc_class = 20 ;
48174: LD_ADDR_OWVAR 28
48178: PUSH
48179: LD_INT 20
48181: ST_TO_ADDR
// hc_gallery =  ;
48182: LD_ADDR_OWVAR 33
48186: PUSH
48187: LD_STRING 
48189: ST_TO_ADDR
// animal := CreateHuman ;
48190: LD_ADDR_VAR 0 12
48194: PUSH
48195: CALL_OW 44
48199: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48200: LD_VAR 0 12
48204: PPUSH
48205: LD_VAR 0 9
48209: PPUSH
48210: LD_INT 0
48212: PPUSH
48213: CALL 49850 0 3
// end ;
48217: GO 48171
48219: POP
48220: POP
// end ;
48221: LD_VAR 0 10
48225: RET
// export function WantHeal ( sci , unit ) ; begin
48226: LD_INT 0
48228: PPUSH
// if GetTaskList ( sci ) > 0 then
48229: LD_VAR 0 1
48233: PPUSH
48234: CALL_OW 437
48238: PUSH
48239: LD_INT 0
48241: GREATER
48242: IFFALSE 48312
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48244: LD_VAR 0 1
48248: PPUSH
48249: CALL_OW 437
48253: PUSH
48254: LD_INT 1
48256: ARRAY
48257: PUSH
48258: LD_INT 1
48260: ARRAY
48261: PUSH
48262: LD_STRING l
48264: EQUAL
48265: PUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL_OW 437
48275: PUSH
48276: LD_INT 1
48278: ARRAY
48279: PUSH
48280: LD_INT 4
48282: ARRAY
48283: PUSH
48284: LD_VAR 0 2
48288: EQUAL
48289: AND
48290: IFFALSE 48302
// result := true else
48292: LD_ADDR_VAR 0 3
48296: PUSH
48297: LD_INT 1
48299: ST_TO_ADDR
48300: GO 48310
// result := false ;
48302: LD_ADDR_VAR 0 3
48306: PUSH
48307: LD_INT 0
48309: ST_TO_ADDR
// end else
48310: GO 48320
// result := false ;
48312: LD_ADDR_VAR 0 3
48316: PUSH
48317: LD_INT 0
48319: ST_TO_ADDR
// end ;
48320: LD_VAR 0 3
48324: RET
// export function HealTarget ( sci ) ; begin
48325: LD_INT 0
48327: PPUSH
// if not sci then
48328: LD_VAR 0 1
48332: NOT
48333: IFFALSE 48337
// exit ;
48335: GO 48402
// result := 0 ;
48337: LD_ADDR_VAR 0 2
48341: PUSH
48342: LD_INT 0
48344: ST_TO_ADDR
// if GetTaskList ( sci ) then
48345: LD_VAR 0 1
48349: PPUSH
48350: CALL_OW 437
48354: IFFALSE 48402
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48356: LD_VAR 0 1
48360: PPUSH
48361: CALL_OW 437
48365: PUSH
48366: LD_INT 1
48368: ARRAY
48369: PUSH
48370: LD_INT 1
48372: ARRAY
48373: PUSH
48374: LD_STRING l
48376: EQUAL
48377: IFFALSE 48402
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48379: LD_ADDR_VAR 0 2
48383: PUSH
48384: LD_VAR 0 1
48388: PPUSH
48389: CALL_OW 437
48393: PUSH
48394: LD_INT 1
48396: ARRAY
48397: PUSH
48398: LD_INT 4
48400: ARRAY
48401: ST_TO_ADDR
// end ;
48402: LD_VAR 0 2
48406: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48407: LD_INT 0
48409: PPUSH
48410: PPUSH
48411: PPUSH
48412: PPUSH
// if not base_units then
48413: LD_VAR 0 1
48417: NOT
48418: IFFALSE 48422
// exit ;
48420: GO 48509
// result := false ;
48422: LD_ADDR_VAR 0 2
48426: PUSH
48427: LD_INT 0
48429: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48430: LD_ADDR_VAR 0 5
48434: PUSH
48435: LD_VAR 0 1
48439: PPUSH
48440: LD_INT 21
48442: PUSH
48443: LD_INT 3
48445: PUSH
48446: EMPTY
48447: LIST
48448: LIST
48449: PPUSH
48450: CALL_OW 72
48454: ST_TO_ADDR
// if not tmp then
48455: LD_VAR 0 5
48459: NOT
48460: IFFALSE 48464
// exit ;
48462: GO 48509
// for i in tmp do
48464: LD_ADDR_VAR 0 3
48468: PUSH
48469: LD_VAR 0 5
48473: PUSH
48474: FOR_IN
48475: IFFALSE 48507
// begin result := EnemyInRange ( i , 22 ) ;
48477: LD_ADDR_VAR 0 2
48481: PUSH
48482: LD_VAR 0 3
48486: PPUSH
48487: LD_INT 22
48489: PPUSH
48490: CALL 46096 0 2
48494: ST_TO_ADDR
// if result then
48495: LD_VAR 0 2
48499: IFFALSE 48505
// exit ;
48501: POP
48502: POP
48503: GO 48509
// end ;
48505: GO 48474
48507: POP
48508: POP
// end ;
48509: LD_VAR 0 2
48513: RET
// export function FilterByTag ( units , tag ) ; begin
48514: LD_INT 0
48516: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
48517: LD_ADDR_VAR 0 3
48521: PUSH
48522: LD_VAR 0 1
48526: PPUSH
48527: LD_INT 120
48529: PUSH
48530: LD_VAR 0 2
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PPUSH
48539: CALL_OW 72
48543: ST_TO_ADDR
// end ;
48544: LD_VAR 0 3
48548: RET
// export function IsDriver ( un ) ; begin
48549: LD_INT 0
48551: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48552: LD_ADDR_VAR 0 2
48556: PUSH
48557: LD_VAR 0 1
48561: PUSH
48562: LD_INT 55
48564: PUSH
48565: EMPTY
48566: LIST
48567: PPUSH
48568: CALL_OW 69
48572: IN
48573: ST_TO_ADDR
// end ;
48574: LD_VAR 0 2
48578: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48579: LD_INT 0
48581: PPUSH
48582: PPUSH
// list := [ ] ;
48583: LD_ADDR_VAR 0 5
48587: PUSH
48588: EMPTY
48589: ST_TO_ADDR
// case d of 0 :
48590: LD_VAR 0 3
48594: PUSH
48595: LD_INT 0
48597: DOUBLE
48598: EQUAL
48599: IFTRUE 48603
48601: GO 48736
48603: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48604: LD_ADDR_VAR 0 5
48608: PUSH
48609: LD_VAR 0 1
48613: PUSH
48614: LD_INT 4
48616: MINUS
48617: PUSH
48618: LD_VAR 0 2
48622: PUSH
48623: LD_INT 4
48625: MINUS
48626: PUSH
48627: LD_INT 2
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: LIST
48634: PUSH
48635: LD_VAR 0 1
48639: PUSH
48640: LD_INT 3
48642: MINUS
48643: PUSH
48644: LD_VAR 0 2
48648: PUSH
48649: LD_INT 1
48651: PUSH
48652: EMPTY
48653: LIST
48654: LIST
48655: LIST
48656: PUSH
48657: LD_VAR 0 1
48661: PUSH
48662: LD_INT 4
48664: PLUS
48665: PUSH
48666: LD_VAR 0 2
48670: PUSH
48671: LD_INT 4
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: LIST
48678: PUSH
48679: LD_VAR 0 1
48683: PUSH
48684: LD_INT 3
48686: PLUS
48687: PUSH
48688: LD_VAR 0 2
48692: PUSH
48693: LD_INT 3
48695: PLUS
48696: PUSH
48697: LD_INT 5
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: LIST
48704: PUSH
48705: LD_VAR 0 1
48709: PUSH
48710: LD_VAR 0 2
48714: PUSH
48715: LD_INT 4
48717: PLUS
48718: PUSH
48719: LD_INT 0
48721: PUSH
48722: EMPTY
48723: LIST
48724: LIST
48725: LIST
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: LIST
48731: LIST
48732: LIST
48733: ST_TO_ADDR
// end ; 1 :
48734: GO 49434
48736: LD_INT 1
48738: DOUBLE
48739: EQUAL
48740: IFTRUE 48744
48742: GO 48877
48744: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48745: LD_ADDR_VAR 0 5
48749: PUSH
48750: LD_VAR 0 1
48754: PUSH
48755: LD_VAR 0 2
48759: PUSH
48760: LD_INT 4
48762: MINUS
48763: PUSH
48764: LD_INT 3
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: LIST
48771: PUSH
48772: LD_VAR 0 1
48776: PUSH
48777: LD_INT 3
48779: MINUS
48780: PUSH
48781: LD_VAR 0 2
48785: PUSH
48786: LD_INT 3
48788: MINUS
48789: PUSH
48790: LD_INT 2
48792: PUSH
48793: EMPTY
48794: LIST
48795: LIST
48796: LIST
48797: PUSH
48798: LD_VAR 0 1
48802: PUSH
48803: LD_INT 4
48805: MINUS
48806: PUSH
48807: LD_VAR 0 2
48811: PUSH
48812: LD_INT 1
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: PUSH
48820: LD_VAR 0 1
48824: PUSH
48825: LD_VAR 0 2
48829: PUSH
48830: LD_INT 3
48832: PLUS
48833: PUSH
48834: LD_INT 0
48836: PUSH
48837: EMPTY
48838: LIST
48839: LIST
48840: LIST
48841: PUSH
48842: LD_VAR 0 1
48846: PUSH
48847: LD_INT 4
48849: PLUS
48850: PUSH
48851: LD_VAR 0 2
48855: PUSH
48856: LD_INT 4
48858: PLUS
48859: PUSH
48860: LD_INT 5
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: LIST
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: LIST
48872: LIST
48873: LIST
48874: ST_TO_ADDR
// end ; 2 :
48875: GO 49434
48877: LD_INT 2
48879: DOUBLE
48880: EQUAL
48881: IFTRUE 48885
48883: GO 49014
48885: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48886: LD_ADDR_VAR 0 5
48890: PUSH
48891: LD_VAR 0 1
48895: PUSH
48896: LD_VAR 0 2
48900: PUSH
48901: LD_INT 3
48903: MINUS
48904: PUSH
48905: LD_INT 3
48907: PUSH
48908: EMPTY
48909: LIST
48910: LIST
48911: LIST
48912: PUSH
48913: LD_VAR 0 1
48917: PUSH
48918: LD_INT 4
48920: PLUS
48921: PUSH
48922: LD_VAR 0 2
48926: PUSH
48927: LD_INT 4
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: LIST
48934: PUSH
48935: LD_VAR 0 1
48939: PUSH
48940: LD_VAR 0 2
48944: PUSH
48945: LD_INT 4
48947: PLUS
48948: PUSH
48949: LD_INT 0
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: LIST
48956: PUSH
48957: LD_VAR 0 1
48961: PUSH
48962: LD_INT 3
48964: MINUS
48965: PUSH
48966: LD_VAR 0 2
48970: PUSH
48971: LD_INT 1
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: LIST
48978: PUSH
48979: LD_VAR 0 1
48983: PUSH
48984: LD_INT 4
48986: MINUS
48987: PUSH
48988: LD_VAR 0 2
48992: PUSH
48993: LD_INT 4
48995: MINUS
48996: PUSH
48997: LD_INT 2
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: LIST
49004: PUSH
49005: EMPTY
49006: LIST
49007: LIST
49008: LIST
49009: LIST
49010: LIST
49011: ST_TO_ADDR
// end ; 3 :
49012: GO 49434
49014: LD_INT 3
49016: DOUBLE
49017: EQUAL
49018: IFTRUE 49022
49020: GO 49155
49022: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49023: LD_ADDR_VAR 0 5
49027: PUSH
49028: LD_VAR 0 1
49032: PUSH
49033: LD_INT 3
49035: PLUS
49036: PUSH
49037: LD_VAR 0 2
49041: PUSH
49042: LD_INT 4
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: LIST
49049: PUSH
49050: LD_VAR 0 1
49054: PUSH
49055: LD_INT 4
49057: PLUS
49058: PUSH
49059: LD_VAR 0 2
49063: PUSH
49064: LD_INT 4
49066: PLUS
49067: PUSH
49068: LD_INT 5
49070: PUSH
49071: EMPTY
49072: LIST
49073: LIST
49074: LIST
49075: PUSH
49076: LD_VAR 0 1
49080: PUSH
49081: LD_INT 4
49083: MINUS
49084: PUSH
49085: LD_VAR 0 2
49089: PUSH
49090: LD_INT 1
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: LIST
49097: PUSH
49098: LD_VAR 0 1
49102: PUSH
49103: LD_VAR 0 2
49107: PUSH
49108: LD_INT 4
49110: MINUS
49111: PUSH
49112: LD_INT 3
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: LIST
49119: PUSH
49120: LD_VAR 0 1
49124: PUSH
49125: LD_INT 3
49127: MINUS
49128: PUSH
49129: LD_VAR 0 2
49133: PUSH
49134: LD_INT 3
49136: MINUS
49137: PUSH
49138: LD_INT 2
49140: PUSH
49141: EMPTY
49142: LIST
49143: LIST
49144: LIST
49145: PUSH
49146: EMPTY
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: ST_TO_ADDR
// end ; 4 :
49153: GO 49434
49155: LD_INT 4
49157: DOUBLE
49158: EQUAL
49159: IFTRUE 49163
49161: GO 49296
49163: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49164: LD_ADDR_VAR 0 5
49168: PUSH
49169: LD_VAR 0 1
49173: PUSH
49174: LD_VAR 0 2
49178: PUSH
49179: LD_INT 4
49181: PLUS
49182: PUSH
49183: LD_INT 0
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: LIST
49190: PUSH
49191: LD_VAR 0 1
49195: PUSH
49196: LD_INT 3
49198: PLUS
49199: PUSH
49200: LD_VAR 0 2
49204: PUSH
49205: LD_INT 3
49207: PLUS
49208: PUSH
49209: LD_INT 5
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: LIST
49216: PUSH
49217: LD_VAR 0 1
49221: PUSH
49222: LD_INT 4
49224: PLUS
49225: PUSH
49226: LD_VAR 0 2
49230: PUSH
49231: LD_INT 4
49233: PUSH
49234: EMPTY
49235: LIST
49236: LIST
49237: LIST
49238: PUSH
49239: LD_VAR 0 1
49243: PUSH
49244: LD_VAR 0 2
49248: PUSH
49249: LD_INT 3
49251: MINUS
49252: PUSH
49253: LD_INT 3
49255: PUSH
49256: EMPTY
49257: LIST
49258: LIST
49259: LIST
49260: PUSH
49261: LD_VAR 0 1
49265: PUSH
49266: LD_INT 4
49268: MINUS
49269: PUSH
49270: LD_VAR 0 2
49274: PUSH
49275: LD_INT 4
49277: MINUS
49278: PUSH
49279: LD_INT 2
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: LIST
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: LIST
49291: LIST
49292: LIST
49293: ST_TO_ADDR
// end ; 5 :
49294: GO 49434
49296: LD_INT 5
49298: DOUBLE
49299: EQUAL
49300: IFTRUE 49304
49302: GO 49433
49304: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49305: LD_ADDR_VAR 0 5
49309: PUSH
49310: LD_VAR 0 1
49314: PUSH
49315: LD_INT 4
49317: MINUS
49318: PUSH
49319: LD_VAR 0 2
49323: PUSH
49324: LD_INT 1
49326: PUSH
49327: EMPTY
49328: LIST
49329: LIST
49330: LIST
49331: PUSH
49332: LD_VAR 0 1
49336: PUSH
49337: LD_VAR 0 2
49341: PUSH
49342: LD_INT 4
49344: MINUS
49345: PUSH
49346: LD_INT 3
49348: PUSH
49349: EMPTY
49350: LIST
49351: LIST
49352: LIST
49353: PUSH
49354: LD_VAR 0 1
49358: PUSH
49359: LD_INT 4
49361: PLUS
49362: PUSH
49363: LD_VAR 0 2
49367: PUSH
49368: LD_INT 4
49370: PLUS
49371: PUSH
49372: LD_INT 5
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: LIST
49379: PUSH
49380: LD_VAR 0 1
49384: PUSH
49385: LD_INT 3
49387: PLUS
49388: PUSH
49389: LD_VAR 0 2
49393: PUSH
49394: LD_INT 4
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: LIST
49401: PUSH
49402: LD_VAR 0 1
49406: PUSH
49407: LD_VAR 0 2
49411: PUSH
49412: LD_INT 3
49414: PLUS
49415: PUSH
49416: LD_INT 0
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: LIST
49423: PUSH
49424: EMPTY
49425: LIST
49426: LIST
49427: LIST
49428: LIST
49429: LIST
49430: ST_TO_ADDR
// end ; end ;
49431: GO 49434
49433: POP
// result := list ;
49434: LD_ADDR_VAR 0 4
49438: PUSH
49439: LD_VAR 0 5
49443: ST_TO_ADDR
// end ;
49444: LD_VAR 0 4
49448: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49449: LD_INT 0
49451: PPUSH
49452: PPUSH
49453: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49454: LD_VAR 0 1
49458: NOT
49459: PUSH
49460: LD_VAR 0 2
49464: PUSH
49465: LD_INT 1
49467: PUSH
49468: LD_INT 2
49470: PUSH
49471: LD_INT 3
49473: PUSH
49474: LD_INT 4
49476: PUSH
49477: EMPTY
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: IN
49483: NOT
49484: OR
49485: IFFALSE 49489
// exit ;
49487: GO 49572
// tmp := [ ] ;
49489: LD_ADDR_VAR 0 5
49493: PUSH
49494: EMPTY
49495: ST_TO_ADDR
// for i in units do
49496: LD_ADDR_VAR 0 4
49500: PUSH
49501: LD_VAR 0 1
49505: PUSH
49506: FOR_IN
49507: IFFALSE 49541
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
49509: LD_ADDR_VAR 0 5
49513: PUSH
49514: LD_VAR 0 5
49518: PPUSH
49519: LD_VAR 0 4
49523: PPUSH
49524: LD_VAR 0 2
49528: PPUSH
49529: CALL_OW 259
49533: PPUSH
49534: CALL 50932 0 2
49538: ST_TO_ADDR
49539: GO 49506
49541: POP
49542: POP
// if not tmp then
49543: LD_VAR 0 5
49547: NOT
49548: IFFALSE 49552
// exit ;
49550: GO 49572
// result := SortListByListDesc ( units , tmp ) ;
49552: LD_ADDR_VAR 0 3
49556: PUSH
49557: LD_VAR 0 1
49561: PPUSH
49562: LD_VAR 0 5
49566: PPUSH
49567: CALL_OW 77
49571: ST_TO_ADDR
// end ;
49572: LD_VAR 0 3
49576: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49577: LD_INT 0
49579: PPUSH
49580: PPUSH
49581: PPUSH
// result := false ;
49582: LD_ADDR_VAR 0 3
49586: PUSH
49587: LD_INT 0
49589: ST_TO_ADDR
// if not building then
49590: LD_VAR 0 2
49594: NOT
49595: IFFALSE 49599
// exit ;
49597: GO 49737
// x := GetX ( building ) ;
49599: LD_ADDR_VAR 0 4
49603: PUSH
49604: LD_VAR 0 2
49608: PPUSH
49609: CALL_OW 250
49613: ST_TO_ADDR
// y := GetY ( building ) ;
49614: LD_ADDR_VAR 0 5
49618: PUSH
49619: LD_VAR 0 2
49623: PPUSH
49624: CALL_OW 251
49628: ST_TO_ADDR
// if not x or not y then
49629: LD_VAR 0 4
49633: NOT
49634: PUSH
49635: LD_VAR 0 5
49639: NOT
49640: OR
49641: IFFALSE 49645
// exit ;
49643: GO 49737
// if GetTaskList ( unit ) then
49645: LD_VAR 0 1
49649: PPUSH
49650: CALL_OW 437
49654: IFFALSE 49737
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49656: LD_STRING e
49658: PUSH
49659: LD_VAR 0 1
49663: PPUSH
49664: CALL_OW 437
49668: PUSH
49669: LD_INT 1
49671: ARRAY
49672: PUSH
49673: LD_INT 1
49675: ARRAY
49676: EQUAL
49677: PUSH
49678: LD_VAR 0 4
49682: PUSH
49683: LD_VAR 0 1
49687: PPUSH
49688: CALL_OW 437
49692: PUSH
49693: LD_INT 1
49695: ARRAY
49696: PUSH
49697: LD_INT 2
49699: ARRAY
49700: EQUAL
49701: AND
49702: PUSH
49703: LD_VAR 0 5
49707: PUSH
49708: LD_VAR 0 1
49712: PPUSH
49713: CALL_OW 437
49717: PUSH
49718: LD_INT 1
49720: ARRAY
49721: PUSH
49722: LD_INT 3
49724: ARRAY
49725: EQUAL
49726: AND
49727: IFFALSE 49737
// result := true end ;
49729: LD_ADDR_VAR 0 3
49733: PUSH
49734: LD_INT 1
49736: ST_TO_ADDR
// end ;
49737: LD_VAR 0 3
49741: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49742: LD_INT 0
49744: PPUSH
// result := false ;
49745: LD_ADDR_VAR 0 4
49749: PUSH
49750: LD_INT 0
49752: ST_TO_ADDR
// if GetTaskList ( unit ) then
49753: LD_VAR 0 1
49757: PPUSH
49758: CALL_OW 437
49762: IFFALSE 49845
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49764: LD_STRING M
49766: PUSH
49767: LD_VAR 0 1
49771: PPUSH
49772: CALL_OW 437
49776: PUSH
49777: LD_INT 1
49779: ARRAY
49780: PUSH
49781: LD_INT 1
49783: ARRAY
49784: EQUAL
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: LD_VAR 0 1
49795: PPUSH
49796: CALL_OW 437
49800: PUSH
49801: LD_INT 1
49803: ARRAY
49804: PUSH
49805: LD_INT 2
49807: ARRAY
49808: EQUAL
49809: AND
49810: PUSH
49811: LD_VAR 0 3
49815: PUSH
49816: LD_VAR 0 1
49820: PPUSH
49821: CALL_OW 437
49825: PUSH
49826: LD_INT 1
49828: ARRAY
49829: PUSH
49830: LD_INT 3
49832: ARRAY
49833: EQUAL
49834: AND
49835: IFFALSE 49845
// result := true ;
49837: LD_ADDR_VAR 0 4
49841: PUSH
49842: LD_INT 1
49844: ST_TO_ADDR
// end ; end ;
49845: LD_VAR 0 4
49849: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49850: LD_INT 0
49852: PPUSH
49853: PPUSH
49854: PPUSH
49855: PPUSH
// if not unit or not area then
49856: LD_VAR 0 1
49860: NOT
49861: PUSH
49862: LD_VAR 0 2
49866: NOT
49867: OR
49868: IFFALSE 49872
// exit ;
49870: GO 50035
// tmp := AreaToList ( area , i ) ;
49872: LD_ADDR_VAR 0 6
49876: PUSH
49877: LD_VAR 0 2
49881: PPUSH
49882: LD_VAR 0 5
49886: PPUSH
49887: CALL_OW 517
49891: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49892: LD_ADDR_VAR 0 5
49896: PUSH
49897: DOUBLE
49898: LD_INT 1
49900: DEC
49901: ST_TO_ADDR
49902: LD_VAR 0 6
49906: PUSH
49907: LD_INT 1
49909: ARRAY
49910: PUSH
49911: FOR_TO
49912: IFFALSE 50033
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49914: LD_ADDR_VAR 0 7
49918: PUSH
49919: LD_VAR 0 6
49923: PUSH
49924: LD_INT 1
49926: ARRAY
49927: PUSH
49928: LD_VAR 0 5
49932: ARRAY
49933: PUSH
49934: LD_VAR 0 6
49938: PUSH
49939: LD_INT 2
49941: ARRAY
49942: PUSH
49943: LD_VAR 0 5
49947: ARRAY
49948: PUSH
49949: EMPTY
49950: LIST
49951: LIST
49952: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
49953: LD_INT 92
49955: PUSH
49956: LD_VAR 0 7
49960: PUSH
49961: LD_INT 1
49963: ARRAY
49964: PUSH
49965: LD_VAR 0 7
49969: PUSH
49970: LD_INT 2
49972: ARRAY
49973: PUSH
49974: LD_INT 3
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: LIST
49981: LIST
49982: PPUSH
49983: CALL_OW 69
49987: PUSH
49988: LD_INT 0
49990: EQUAL
49991: IFFALSE 50031
// begin PlaceUnitArea ( unit , area , mode ) ;
49993: LD_VAR 0 1
49997: PPUSH
49998: LD_VAR 0 2
50002: PPUSH
50003: LD_VAR 0 3
50007: PPUSH
50008: CALL_OW 49
// result := IsPlaced ( unit ) ;
50012: LD_ADDR_VAR 0 4
50016: PUSH
50017: LD_VAR 0 1
50021: PPUSH
50022: CALL_OW 305
50026: ST_TO_ADDR
// exit ;
50027: POP
50028: POP
50029: GO 50035
// end ; end ;
50031: GO 49911
50033: POP
50034: POP
// end ;
50035: LD_VAR 0 4
50039: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50040: LD_INT 0
50042: PPUSH
50043: PPUSH
50044: PPUSH
// if not side or side > 8 then
50045: LD_VAR 0 1
50049: NOT
50050: PUSH
50051: LD_VAR 0 1
50055: PUSH
50056: LD_INT 8
50058: GREATER
50059: OR
50060: IFFALSE 50064
// exit ;
50062: GO 50251
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50064: LD_ADDR_VAR 0 4
50068: PUSH
50069: LD_INT 22
50071: PUSH
50072: LD_VAR 0 1
50076: PUSH
50077: EMPTY
50078: LIST
50079: LIST
50080: PUSH
50081: LD_INT 21
50083: PUSH
50084: LD_INT 3
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PPUSH
50095: CALL_OW 69
50099: ST_TO_ADDR
// if not tmp then
50100: LD_VAR 0 4
50104: NOT
50105: IFFALSE 50109
// exit ;
50107: GO 50251
// enable_addtolog := true ;
50109: LD_ADDR_OWVAR 81
50113: PUSH
50114: LD_INT 1
50116: ST_TO_ADDR
// AddToLog ( [ ) ;
50117: LD_STRING [
50119: PPUSH
50120: CALL_OW 561
// for i in tmp do
50124: LD_ADDR_VAR 0 3
50128: PUSH
50129: LD_VAR 0 4
50133: PUSH
50134: FOR_IN
50135: IFFALSE 50242
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50137: LD_STRING [
50139: PUSH
50140: LD_VAR 0 3
50144: PPUSH
50145: CALL_OW 266
50149: STR
50150: PUSH
50151: LD_STRING , 
50153: STR
50154: PUSH
50155: LD_VAR 0 3
50159: PPUSH
50160: CALL_OW 250
50164: STR
50165: PUSH
50166: LD_STRING , 
50168: STR
50169: PUSH
50170: LD_VAR 0 3
50174: PPUSH
50175: CALL_OW 251
50179: STR
50180: PUSH
50181: LD_STRING , 
50183: STR
50184: PUSH
50185: LD_VAR 0 3
50189: PPUSH
50190: CALL_OW 254
50194: STR
50195: PUSH
50196: LD_STRING , 
50198: STR
50199: PUSH
50200: LD_VAR 0 3
50204: PPUSH
50205: LD_INT 1
50207: PPUSH
50208: CALL_OW 268
50212: STR
50213: PUSH
50214: LD_STRING , 
50216: STR
50217: PUSH
50218: LD_VAR 0 3
50222: PPUSH
50223: LD_INT 2
50225: PPUSH
50226: CALL_OW 268
50230: STR
50231: PUSH
50232: LD_STRING ],
50234: STR
50235: PPUSH
50236: CALL_OW 561
// end ;
50240: GO 50134
50242: POP
50243: POP
// AddToLog ( ]; ) ;
50244: LD_STRING ];
50246: PPUSH
50247: CALL_OW 561
// end ;
50251: LD_VAR 0 2
50255: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50256: LD_INT 0
50258: PPUSH
50259: PPUSH
50260: PPUSH
50261: PPUSH
50262: PPUSH
// if not area or not rate or not max then
50263: LD_VAR 0 1
50267: NOT
50268: PUSH
50269: LD_VAR 0 2
50273: NOT
50274: OR
50275: PUSH
50276: LD_VAR 0 4
50280: NOT
50281: OR
50282: IFFALSE 50286
// exit ;
50284: GO 50475
// while 1 do
50286: LD_INT 1
50288: IFFALSE 50475
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50290: LD_ADDR_VAR 0 9
50294: PUSH
50295: LD_VAR 0 1
50299: PPUSH
50300: LD_INT 1
50302: PPUSH
50303: CALL_OW 287
50307: PUSH
50308: LD_INT 10
50310: MUL
50311: ST_TO_ADDR
// r := rate / 10 ;
50312: LD_ADDR_VAR 0 7
50316: PUSH
50317: LD_VAR 0 2
50321: PUSH
50322: LD_INT 10
50324: DIVREAL
50325: ST_TO_ADDR
// time := 1 1$00 ;
50326: LD_ADDR_VAR 0 8
50330: PUSH
50331: LD_INT 2100
50333: ST_TO_ADDR
// if amount < min then
50334: LD_VAR 0 9
50338: PUSH
50339: LD_VAR 0 3
50343: LESS
50344: IFFALSE 50362
// r := r * 2 else
50346: LD_ADDR_VAR 0 7
50350: PUSH
50351: LD_VAR 0 7
50355: PUSH
50356: LD_INT 2
50358: MUL
50359: ST_TO_ADDR
50360: GO 50388
// if amount > max then
50362: LD_VAR 0 9
50366: PUSH
50367: LD_VAR 0 4
50371: GREATER
50372: IFFALSE 50388
// r := r / 2 ;
50374: LD_ADDR_VAR 0 7
50378: PUSH
50379: LD_VAR 0 7
50383: PUSH
50384: LD_INT 2
50386: DIVREAL
50387: ST_TO_ADDR
// time := time / r ;
50388: LD_ADDR_VAR 0 8
50392: PUSH
50393: LD_VAR 0 8
50397: PUSH
50398: LD_VAR 0 7
50402: DIVREAL
50403: ST_TO_ADDR
// if time < 0 then
50404: LD_VAR 0 8
50408: PUSH
50409: LD_INT 0
50411: LESS
50412: IFFALSE 50429
// time := time * - 1 ;
50414: LD_ADDR_VAR 0 8
50418: PUSH
50419: LD_VAR 0 8
50423: PUSH
50424: LD_INT 1
50426: NEG
50427: MUL
50428: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
50429: LD_VAR 0 8
50433: PUSH
50434: LD_INT 35
50436: PPUSH
50437: LD_INT 875
50439: PPUSH
50440: CALL_OW 12
50444: PLUS
50445: PPUSH
50446: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50450: LD_INT 1
50452: PPUSH
50453: LD_INT 5
50455: PPUSH
50456: CALL_OW 12
50460: PPUSH
50461: LD_VAR 0 1
50465: PPUSH
50466: LD_INT 1
50468: PPUSH
50469: CALL_OW 55
// end ;
50473: GO 50286
// end ;
50475: LD_VAR 0 5
50479: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50480: LD_INT 0
50482: PPUSH
50483: PPUSH
50484: PPUSH
50485: PPUSH
50486: PPUSH
50487: PPUSH
50488: PPUSH
50489: PPUSH
// if not turrets or not factories then
50490: LD_VAR 0 1
50494: NOT
50495: PUSH
50496: LD_VAR 0 2
50500: NOT
50501: OR
50502: IFFALSE 50506
// exit ;
50504: GO 50813
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50506: LD_ADDR_VAR 0 10
50510: PUSH
50511: LD_INT 5
50513: PUSH
50514: LD_INT 6
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: PUSH
50521: LD_INT 2
50523: PUSH
50524: LD_INT 4
50526: PUSH
50527: EMPTY
50528: LIST
50529: LIST
50530: PUSH
50531: LD_INT 3
50533: PUSH
50534: LD_INT 5
50536: PUSH
50537: EMPTY
50538: LIST
50539: LIST
50540: PUSH
50541: EMPTY
50542: LIST
50543: LIST
50544: LIST
50545: PUSH
50546: LD_INT 24
50548: PUSH
50549: LD_INT 25
50551: PUSH
50552: EMPTY
50553: LIST
50554: LIST
50555: PUSH
50556: LD_INT 23
50558: PUSH
50559: LD_INT 27
50561: PUSH
50562: EMPTY
50563: LIST
50564: LIST
50565: PUSH
50566: EMPTY
50567: LIST
50568: LIST
50569: PUSH
50570: LD_INT 42
50572: PUSH
50573: LD_INT 43
50575: PUSH
50576: EMPTY
50577: LIST
50578: LIST
50579: PUSH
50580: LD_INT 44
50582: PUSH
50583: LD_INT 46
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: PUSH
50590: LD_INT 45
50592: PUSH
50593: LD_INT 47
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: LIST
50604: PUSH
50605: EMPTY
50606: LIST
50607: LIST
50608: LIST
50609: ST_TO_ADDR
// result := [ ] ;
50610: LD_ADDR_VAR 0 3
50614: PUSH
50615: EMPTY
50616: ST_TO_ADDR
// for i in turrets do
50617: LD_ADDR_VAR 0 4
50621: PUSH
50622: LD_VAR 0 1
50626: PUSH
50627: FOR_IN
50628: IFFALSE 50811
// begin nat := GetNation ( i ) ;
50630: LD_ADDR_VAR 0 7
50634: PUSH
50635: LD_VAR 0 4
50639: PPUSH
50640: CALL_OW 248
50644: ST_TO_ADDR
// weapon := 0 ;
50645: LD_ADDR_VAR 0 8
50649: PUSH
50650: LD_INT 0
50652: ST_TO_ADDR
// if not nat then
50653: LD_VAR 0 7
50657: NOT
50658: IFFALSE 50662
// continue ;
50660: GO 50627
// for j in list [ nat ] do
50662: LD_ADDR_VAR 0 5
50666: PUSH
50667: LD_VAR 0 10
50671: PUSH
50672: LD_VAR 0 7
50676: ARRAY
50677: PUSH
50678: FOR_IN
50679: IFFALSE 50720
// if GetBWeapon ( i ) = j [ 1 ] then
50681: LD_VAR 0 4
50685: PPUSH
50686: CALL_OW 269
50690: PUSH
50691: LD_VAR 0 5
50695: PUSH
50696: LD_INT 1
50698: ARRAY
50699: EQUAL
50700: IFFALSE 50718
// begin weapon := j [ 2 ] ;
50702: LD_ADDR_VAR 0 8
50706: PUSH
50707: LD_VAR 0 5
50711: PUSH
50712: LD_INT 2
50714: ARRAY
50715: ST_TO_ADDR
// break ;
50716: GO 50720
// end ;
50718: GO 50678
50720: POP
50721: POP
// if not weapon then
50722: LD_VAR 0 8
50726: NOT
50727: IFFALSE 50731
// continue ;
50729: GO 50627
// for k in factories do
50731: LD_ADDR_VAR 0 6
50735: PUSH
50736: LD_VAR 0 2
50740: PUSH
50741: FOR_IN
50742: IFFALSE 50807
// begin weapons := AvailableWeaponList ( k ) ;
50744: LD_ADDR_VAR 0 9
50748: PUSH
50749: LD_VAR 0 6
50753: PPUSH
50754: CALL_OW 478
50758: ST_TO_ADDR
// if not weapons then
50759: LD_VAR 0 9
50763: NOT
50764: IFFALSE 50768
// continue ;
50766: GO 50741
// if weapon in weapons then
50768: LD_VAR 0 8
50772: PUSH
50773: LD_VAR 0 9
50777: IN
50778: IFFALSE 50805
// begin result := [ i , weapon ] ;
50780: LD_ADDR_VAR 0 3
50784: PUSH
50785: LD_VAR 0 4
50789: PUSH
50790: LD_VAR 0 8
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: ST_TO_ADDR
// exit ;
50799: POP
50800: POP
50801: POP
50802: POP
50803: GO 50813
// end ; end ;
50805: GO 50741
50807: POP
50808: POP
// end ;
50809: GO 50627
50811: POP
50812: POP
// end ;
50813: LD_VAR 0 3
50817: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50818: LD_INT 0
50820: PPUSH
// if not side or side > 8 then
50821: LD_VAR 0 3
50825: NOT
50826: PUSH
50827: LD_VAR 0 3
50831: PUSH
50832: LD_INT 8
50834: GREATER
50835: OR
50836: IFFALSE 50840
// exit ;
50838: GO 50899
// if not range then
50840: LD_VAR 0 4
50844: NOT
50845: IFFALSE 50856
// range := - 12 ;
50847: LD_ADDR_VAR 0 4
50851: PUSH
50852: LD_INT 12
50854: NEG
50855: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50856: LD_VAR 0 1
50860: PPUSH
50861: LD_VAR 0 2
50865: PPUSH
50866: LD_VAR 0 3
50870: PPUSH
50871: LD_VAR 0 4
50875: PPUSH
50876: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50880: LD_VAR 0 1
50884: PPUSH
50885: LD_VAR 0 2
50889: PPUSH
50890: LD_VAR 0 3
50894: PPUSH
50895: CALL_OW 331
// end ;
50899: LD_VAR 0 5
50903: RET
// export function Video ( mode ) ; begin
50904: LD_INT 0
50906: PPUSH
// ingame_video = mode ;
50907: LD_ADDR_OWVAR 52
50911: PUSH
50912: LD_VAR 0 1
50916: ST_TO_ADDR
// interface_hidden = mode ;
50917: LD_ADDR_OWVAR 54
50921: PUSH
50922: LD_VAR 0 1
50926: ST_TO_ADDR
// end ;
50927: LD_VAR 0 2
50931: RET
// export function Join ( array , element ) ; begin
50932: LD_INT 0
50934: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50935: LD_ADDR_VAR 0 3
50939: PUSH
50940: LD_VAR 0 1
50944: PPUSH
50945: LD_VAR 0 1
50949: PUSH
50950: LD_INT 1
50952: PLUS
50953: PPUSH
50954: LD_VAR 0 2
50958: PPUSH
50959: CALL_OW 1
50963: ST_TO_ADDR
// end ;
50964: LD_VAR 0 3
50968: RET
// export function JoinUnion ( array , element ) ; begin
50969: LD_INT 0
50971: PPUSH
// result := array union element ;
50972: LD_ADDR_VAR 0 3
50976: PUSH
50977: LD_VAR 0 1
50981: PUSH
50982: LD_VAR 0 2
50986: UNION
50987: ST_TO_ADDR
// end ;
50988: LD_VAR 0 3
50992: RET
// export function GetBehemoths ( side ) ; begin
50993: LD_INT 0
50995: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
50996: LD_ADDR_VAR 0 2
51000: PUSH
51001: LD_INT 22
51003: PUSH
51004: LD_VAR 0 1
51008: PUSH
51009: EMPTY
51010: LIST
51011: LIST
51012: PUSH
51013: LD_INT 31
51015: PUSH
51016: LD_INT 25
51018: PUSH
51019: EMPTY
51020: LIST
51021: LIST
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: PPUSH
51027: CALL_OW 69
51031: ST_TO_ADDR
// end ;
51032: LD_VAR 0 2
51036: RET
// export function Shuffle ( array ) ; var i , index ; begin
51037: LD_INT 0
51039: PPUSH
51040: PPUSH
51041: PPUSH
// result := [ ] ;
51042: LD_ADDR_VAR 0 2
51046: PUSH
51047: EMPTY
51048: ST_TO_ADDR
// if not array then
51049: LD_VAR 0 1
51053: NOT
51054: IFFALSE 51058
// exit ;
51056: GO 51157
// Randomize ;
51058: CALL_OW 10
// for i = array downto 1 do
51062: LD_ADDR_VAR 0 3
51066: PUSH
51067: DOUBLE
51068: LD_VAR 0 1
51072: INC
51073: ST_TO_ADDR
51074: LD_INT 1
51076: PUSH
51077: FOR_DOWNTO
51078: IFFALSE 51155
// begin index := rand ( 1 , array ) ;
51080: LD_ADDR_VAR 0 4
51084: PUSH
51085: LD_INT 1
51087: PPUSH
51088: LD_VAR 0 1
51092: PPUSH
51093: CALL_OW 12
51097: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51098: LD_ADDR_VAR 0 2
51102: PUSH
51103: LD_VAR 0 2
51107: PPUSH
51108: LD_VAR 0 2
51112: PUSH
51113: LD_INT 1
51115: PLUS
51116: PPUSH
51117: LD_VAR 0 1
51121: PUSH
51122: LD_VAR 0 4
51126: ARRAY
51127: PPUSH
51128: CALL_OW 2
51132: ST_TO_ADDR
// array := Delete ( array , index ) ;
51133: LD_ADDR_VAR 0 1
51137: PUSH
51138: LD_VAR 0 1
51142: PPUSH
51143: LD_VAR 0 4
51147: PPUSH
51148: CALL_OW 3
51152: ST_TO_ADDR
// end ;
51153: GO 51077
51155: POP
51156: POP
// end ;
51157: LD_VAR 0 2
51161: RET
// export function GetBaseMaterials ( base ) ; begin
51162: LD_INT 0
51164: PPUSH
// result := [ 0 , 0 , 0 ] ;
51165: LD_ADDR_VAR 0 2
51169: PUSH
51170: LD_INT 0
51172: PUSH
51173: LD_INT 0
51175: PUSH
51176: LD_INT 0
51178: PUSH
51179: EMPTY
51180: LIST
51181: LIST
51182: LIST
51183: ST_TO_ADDR
// if not base then
51184: LD_VAR 0 1
51188: NOT
51189: IFFALSE 51193
// exit ;
51191: GO 51242
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51193: LD_ADDR_VAR 0 2
51197: PUSH
51198: LD_VAR 0 1
51202: PPUSH
51203: LD_INT 1
51205: PPUSH
51206: CALL_OW 275
51210: PUSH
51211: LD_VAR 0 1
51215: PPUSH
51216: LD_INT 2
51218: PPUSH
51219: CALL_OW 275
51223: PUSH
51224: LD_VAR 0 1
51228: PPUSH
51229: LD_INT 3
51231: PPUSH
51232: CALL_OW 275
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: LIST
51241: ST_TO_ADDR
// end ;
51242: LD_VAR 0 2
51246: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51247: LD_INT 0
51249: PPUSH
51250: PPUSH
// result := array ;
51251: LD_ADDR_VAR 0 3
51255: PUSH
51256: LD_VAR 0 1
51260: ST_TO_ADDR
// if size >= result then
51261: LD_VAR 0 2
51265: PUSH
51266: LD_VAR 0 3
51270: GREATEREQUAL
51271: IFFALSE 51275
// exit ;
51273: GO 51325
// if size then
51275: LD_VAR 0 2
51279: IFFALSE 51325
// for i := array downto size do
51281: LD_ADDR_VAR 0 4
51285: PUSH
51286: DOUBLE
51287: LD_VAR 0 1
51291: INC
51292: ST_TO_ADDR
51293: LD_VAR 0 2
51297: PUSH
51298: FOR_DOWNTO
51299: IFFALSE 51323
// result := Delete ( result , result ) ;
51301: LD_ADDR_VAR 0 3
51305: PUSH
51306: LD_VAR 0 3
51310: PPUSH
51311: LD_VAR 0 3
51315: PPUSH
51316: CALL_OW 3
51320: ST_TO_ADDR
51321: GO 51298
51323: POP
51324: POP
// end ;
51325: LD_VAR 0 3
51329: RET
// export function ComExit ( unit ) ; var tmp ; begin
51330: LD_INT 0
51332: PPUSH
51333: PPUSH
// if not IsInUnit ( unit ) then
51334: LD_VAR 0 1
51338: PPUSH
51339: CALL_OW 310
51343: NOT
51344: IFFALSE 51348
// exit ;
51346: GO 51408
// tmp := IsInUnit ( unit ) ;
51348: LD_ADDR_VAR 0 3
51352: PUSH
51353: LD_VAR 0 1
51357: PPUSH
51358: CALL_OW 310
51362: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51363: LD_VAR 0 3
51367: PPUSH
51368: CALL_OW 247
51372: PUSH
51373: LD_INT 2
51375: EQUAL
51376: IFFALSE 51389
// ComExitVehicle ( unit ) else
51378: LD_VAR 0 1
51382: PPUSH
51383: CALL_OW 121
51387: GO 51398
// ComExitBuilding ( unit ) ;
51389: LD_VAR 0 1
51393: PPUSH
51394: CALL_OW 122
// result := tmp ;
51398: LD_ADDR_VAR 0 2
51402: PUSH
51403: LD_VAR 0 3
51407: ST_TO_ADDR
// end ;
51408: LD_VAR 0 2
51412: RET
// export function ComExitAll ( units ) ; var i ; begin
51413: LD_INT 0
51415: PPUSH
51416: PPUSH
// if not units then
51417: LD_VAR 0 1
51421: NOT
51422: IFFALSE 51426
// exit ;
51424: GO 51452
// for i in units do
51426: LD_ADDR_VAR 0 3
51430: PUSH
51431: LD_VAR 0 1
51435: PUSH
51436: FOR_IN
51437: IFFALSE 51450
// ComExit ( i ) ;
51439: LD_VAR 0 3
51443: PPUSH
51444: CALL 51330 0 1
51448: GO 51436
51450: POP
51451: POP
// end ;
51452: LD_VAR 0 2
51456: RET
// export function ResetHc ; begin
51457: LD_INT 0
51459: PPUSH
// InitHc ;
51460: CALL_OW 19
// hc_importance := 0 ;
51464: LD_ADDR_OWVAR 32
51468: PUSH
51469: LD_INT 0
51471: ST_TO_ADDR
// end ;
51472: LD_VAR 0 1
51476: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51477: LD_INT 0
51479: PPUSH
51480: PPUSH
51481: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51482: LD_ADDR_VAR 0 6
51486: PUSH
51487: LD_VAR 0 1
51491: PUSH
51492: LD_VAR 0 3
51496: PLUS
51497: PUSH
51498: LD_INT 2
51500: DIV
51501: ST_TO_ADDR
// if _x < 0 then
51502: LD_VAR 0 6
51506: PUSH
51507: LD_INT 0
51509: LESS
51510: IFFALSE 51527
// _x := _x * - 1 ;
51512: LD_ADDR_VAR 0 6
51516: PUSH
51517: LD_VAR 0 6
51521: PUSH
51522: LD_INT 1
51524: NEG
51525: MUL
51526: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51527: LD_ADDR_VAR 0 7
51531: PUSH
51532: LD_VAR 0 2
51536: PUSH
51537: LD_VAR 0 4
51541: PLUS
51542: PUSH
51543: LD_INT 2
51545: DIV
51546: ST_TO_ADDR
// if _y < 0 then
51547: LD_VAR 0 7
51551: PUSH
51552: LD_INT 0
51554: LESS
51555: IFFALSE 51572
// _y := _y * - 1 ;
51557: LD_ADDR_VAR 0 7
51561: PUSH
51562: LD_VAR 0 7
51566: PUSH
51567: LD_INT 1
51569: NEG
51570: MUL
51571: ST_TO_ADDR
// result := [ _x , _y ] ;
51572: LD_ADDR_VAR 0 5
51576: PUSH
51577: LD_VAR 0 6
51581: PUSH
51582: LD_VAR 0 7
51586: PUSH
51587: EMPTY
51588: LIST
51589: LIST
51590: ST_TO_ADDR
// end ;
51591: LD_VAR 0 5
51595: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51596: LD_INT 0
51598: PPUSH
51599: PPUSH
51600: PPUSH
51601: PPUSH
// task := GetTaskList ( unit ) ;
51602: LD_ADDR_VAR 0 7
51606: PUSH
51607: LD_VAR 0 1
51611: PPUSH
51612: CALL_OW 437
51616: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51617: LD_VAR 0 7
51621: NOT
51622: PUSH
51623: LD_VAR 0 1
51627: PPUSH
51628: LD_VAR 0 2
51632: PPUSH
51633: CALL_OW 308
51637: NOT
51638: AND
51639: IFFALSE 51643
// exit ;
51641: GO 51761
// if IsInArea ( unit , area ) then
51643: LD_VAR 0 1
51647: PPUSH
51648: LD_VAR 0 2
51652: PPUSH
51653: CALL_OW 308
51657: IFFALSE 51675
// begin ComMoveToArea ( unit , goAway ) ;
51659: LD_VAR 0 1
51663: PPUSH
51664: LD_VAR 0 3
51668: PPUSH
51669: CALL_OW 113
// exit ;
51673: GO 51761
// end ; if task [ 1 ] [ 1 ] <> M then
51675: LD_VAR 0 7
51679: PUSH
51680: LD_INT 1
51682: ARRAY
51683: PUSH
51684: LD_INT 1
51686: ARRAY
51687: PUSH
51688: LD_STRING M
51690: NONEQUAL
51691: IFFALSE 51695
// exit ;
51693: GO 51761
// x := task [ 1 ] [ 2 ] ;
51695: LD_ADDR_VAR 0 5
51699: PUSH
51700: LD_VAR 0 7
51704: PUSH
51705: LD_INT 1
51707: ARRAY
51708: PUSH
51709: LD_INT 2
51711: ARRAY
51712: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51713: LD_ADDR_VAR 0 6
51717: PUSH
51718: LD_VAR 0 7
51722: PUSH
51723: LD_INT 1
51725: ARRAY
51726: PUSH
51727: LD_INT 3
51729: ARRAY
51730: ST_TO_ADDR
// if InArea ( x , y , area ) then
51731: LD_VAR 0 5
51735: PPUSH
51736: LD_VAR 0 6
51740: PPUSH
51741: LD_VAR 0 2
51745: PPUSH
51746: CALL_OW 309
51750: IFFALSE 51761
// ComStop ( unit ) ;
51752: LD_VAR 0 1
51756: PPUSH
51757: CALL_OW 141
// end ;
51761: LD_VAR 0 4
51765: RET
// export function Abs ( value ) ; begin
51766: LD_INT 0
51768: PPUSH
// result := value ;
51769: LD_ADDR_VAR 0 2
51773: PUSH
51774: LD_VAR 0 1
51778: ST_TO_ADDR
// if value < 0 then
51779: LD_VAR 0 1
51783: PUSH
51784: LD_INT 0
51786: LESS
51787: IFFALSE 51804
// result := value * - 1 ;
51789: LD_ADDR_VAR 0 2
51793: PUSH
51794: LD_VAR 0 1
51798: PUSH
51799: LD_INT 1
51801: NEG
51802: MUL
51803: ST_TO_ADDR
// end ;
51804: LD_VAR 0 2
51808: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51809: LD_INT 0
51811: PPUSH
51812: PPUSH
51813: PPUSH
51814: PPUSH
51815: PPUSH
51816: PPUSH
51817: PPUSH
51818: PPUSH
// if not unit or not building then
51819: LD_VAR 0 1
51823: NOT
51824: PUSH
51825: LD_VAR 0 2
51829: NOT
51830: OR
51831: IFFALSE 51835
// exit ;
51833: GO 52061
// x := GetX ( building ) ;
51835: LD_ADDR_VAR 0 4
51839: PUSH
51840: LD_VAR 0 2
51844: PPUSH
51845: CALL_OW 250
51849: ST_TO_ADDR
// y := GetY ( building ) ;
51850: LD_ADDR_VAR 0 6
51854: PUSH
51855: LD_VAR 0 2
51859: PPUSH
51860: CALL_OW 251
51864: ST_TO_ADDR
// d := GetDir ( building ) ;
51865: LD_ADDR_VAR 0 8
51869: PUSH
51870: LD_VAR 0 2
51874: PPUSH
51875: CALL_OW 254
51879: ST_TO_ADDR
// r := 4 ;
51880: LD_ADDR_VAR 0 9
51884: PUSH
51885: LD_INT 4
51887: ST_TO_ADDR
// for i := 1 to 5 do
51888: LD_ADDR_VAR 0 10
51892: PUSH
51893: DOUBLE
51894: LD_INT 1
51896: DEC
51897: ST_TO_ADDR
51898: LD_INT 5
51900: PUSH
51901: FOR_TO
51902: IFFALSE 52059
// begin _x := ShiftX ( x , d , r + i ) ;
51904: LD_ADDR_VAR 0 5
51908: PUSH
51909: LD_VAR 0 4
51913: PPUSH
51914: LD_VAR 0 8
51918: PPUSH
51919: LD_VAR 0 9
51923: PUSH
51924: LD_VAR 0 10
51928: PLUS
51929: PPUSH
51930: CALL_OW 272
51934: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51935: LD_ADDR_VAR 0 7
51939: PUSH
51940: LD_VAR 0 6
51944: PPUSH
51945: LD_VAR 0 8
51949: PPUSH
51950: LD_VAR 0 9
51954: PUSH
51955: LD_VAR 0 10
51959: PLUS
51960: PPUSH
51961: CALL_OW 273
51965: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51966: LD_VAR 0 5
51970: PPUSH
51971: LD_VAR 0 7
51975: PPUSH
51976: CALL_OW 488
51980: PUSH
51981: LD_VAR 0 5
51985: PPUSH
51986: LD_VAR 0 7
51990: PPUSH
51991: CALL_OW 428
51995: PPUSH
51996: CALL_OW 247
52000: PUSH
52001: LD_INT 3
52003: PUSH
52004: LD_INT 2
52006: PUSH
52007: EMPTY
52008: LIST
52009: LIST
52010: IN
52011: NOT
52012: AND
52013: IFFALSE 52057
// begin ComMoveXY ( unit , _x , _y ) ;
52015: LD_VAR 0 1
52019: PPUSH
52020: LD_VAR 0 5
52024: PPUSH
52025: LD_VAR 0 7
52029: PPUSH
52030: CALL_OW 111
// result := [ _x , _y ] ;
52034: LD_ADDR_VAR 0 3
52038: PUSH
52039: LD_VAR 0 5
52043: PUSH
52044: LD_VAR 0 7
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: ST_TO_ADDR
// exit ;
52053: POP
52054: POP
52055: GO 52061
// end ; end ;
52057: GO 51901
52059: POP
52060: POP
// end ;
52061: LD_VAR 0 3
52065: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52066: LD_INT 0
52068: PPUSH
52069: PPUSH
52070: PPUSH
// result := 0 ;
52071: LD_ADDR_VAR 0 3
52075: PUSH
52076: LD_INT 0
52078: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52079: LD_VAR 0 1
52083: PUSH
52084: LD_INT 0
52086: LESS
52087: PUSH
52088: LD_VAR 0 1
52092: PUSH
52093: LD_INT 8
52095: GREATER
52096: OR
52097: PUSH
52098: LD_VAR 0 2
52102: PUSH
52103: LD_INT 0
52105: LESS
52106: OR
52107: PUSH
52108: LD_VAR 0 2
52112: PUSH
52113: LD_INT 8
52115: GREATER
52116: OR
52117: IFFALSE 52121
// exit ;
52119: GO 52196
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52121: LD_ADDR_VAR 0 4
52125: PUSH
52126: LD_INT 22
52128: PUSH
52129: LD_VAR 0 2
52133: PUSH
52134: EMPTY
52135: LIST
52136: LIST
52137: PPUSH
52138: CALL_OW 69
52142: PUSH
52143: FOR_IN
52144: IFFALSE 52194
// begin un := UnitShoot ( i ) ;
52146: LD_ADDR_VAR 0 5
52150: PUSH
52151: LD_VAR 0 4
52155: PPUSH
52156: CALL_OW 504
52160: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52161: LD_VAR 0 5
52165: PPUSH
52166: CALL_OW 255
52170: PUSH
52171: LD_VAR 0 1
52175: EQUAL
52176: IFFALSE 52192
// begin result := un ;
52178: LD_ADDR_VAR 0 3
52182: PUSH
52183: LD_VAR 0 5
52187: ST_TO_ADDR
// exit ;
52188: POP
52189: POP
52190: GO 52196
// end ; end ;
52192: GO 52143
52194: POP
52195: POP
// end ;
52196: LD_VAR 0 3
52200: RET
// export function GetCargoBay ( units ) ; begin
52201: LD_INT 0
52203: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52204: LD_ADDR_VAR 0 2
52208: PUSH
52209: LD_VAR 0 1
52213: PPUSH
52214: LD_INT 2
52216: PUSH
52217: LD_INT 34
52219: PUSH
52220: LD_INT 12
52222: PUSH
52223: EMPTY
52224: LIST
52225: LIST
52226: PUSH
52227: LD_INT 34
52229: PUSH
52230: LD_INT 51
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: PUSH
52237: LD_INT 34
52239: PUSH
52240: LD_INT 32
52242: PUSH
52243: EMPTY
52244: LIST
52245: LIST
52246: PUSH
52247: LD_INT 34
52249: PUSH
52250: LD_INT 89
52252: PUSH
52253: EMPTY
52254: LIST
52255: LIST
52256: PUSH
52257: EMPTY
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: LIST
52263: PPUSH
52264: CALL_OW 72
52268: ST_TO_ADDR
// end ;
52269: LD_VAR 0 2
52273: RET
// export function Negate ( value ) ; begin
52274: LD_INT 0
52276: PPUSH
// result := not value ;
52277: LD_ADDR_VAR 0 2
52281: PUSH
52282: LD_VAR 0 1
52286: NOT
52287: ST_TO_ADDR
// end ;
52288: LD_VAR 0 2
52292: RET
// export function Inc ( value ) ; begin
52293: LD_INT 0
52295: PPUSH
// result := value + 1 ;
52296: LD_ADDR_VAR 0 2
52300: PUSH
52301: LD_VAR 0 1
52305: PUSH
52306: LD_INT 1
52308: PLUS
52309: ST_TO_ADDR
// end ;
52310: LD_VAR 0 2
52314: RET
// export function Dec ( value ) ; begin
52315: LD_INT 0
52317: PPUSH
// result := value - 1 ;
52318: LD_ADDR_VAR 0 2
52322: PUSH
52323: LD_VAR 0 1
52327: PUSH
52328: LD_INT 1
52330: MINUS
52331: ST_TO_ADDR
// end ;
52332: LD_VAR 0 2
52336: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52337: LD_INT 0
52339: PPUSH
52340: PPUSH
52341: PPUSH
52342: PPUSH
52343: PPUSH
52344: PPUSH
52345: PPUSH
52346: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52347: LD_VAR 0 1
52351: PPUSH
52352: LD_VAR 0 2
52356: PPUSH
52357: CALL_OW 488
52361: NOT
52362: PUSH
52363: LD_VAR 0 3
52367: PPUSH
52368: LD_VAR 0 4
52372: PPUSH
52373: CALL_OW 488
52377: NOT
52378: OR
52379: IFFALSE 52392
// begin result := - 1 ;
52381: LD_ADDR_VAR 0 5
52385: PUSH
52386: LD_INT 1
52388: NEG
52389: ST_TO_ADDR
// exit ;
52390: GO 52627
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
52392: LD_ADDR_VAR 0 12
52396: PUSH
52397: LD_VAR 0 1
52401: PPUSH
52402: LD_VAR 0 2
52406: PPUSH
52407: LD_VAR 0 3
52411: PPUSH
52412: LD_VAR 0 4
52416: PPUSH
52417: CALL 51477 0 4
52421: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
52422: LD_ADDR_VAR 0 11
52426: PUSH
52427: LD_VAR 0 1
52431: PPUSH
52432: LD_VAR 0 2
52436: PPUSH
52437: LD_VAR 0 12
52441: PUSH
52442: LD_INT 1
52444: ARRAY
52445: PPUSH
52446: LD_VAR 0 12
52450: PUSH
52451: LD_INT 2
52453: ARRAY
52454: PPUSH
52455: CALL_OW 298
52459: ST_TO_ADDR
// distance := 9999 ;
52460: LD_ADDR_VAR 0 10
52464: PUSH
52465: LD_INT 9999
52467: ST_TO_ADDR
// for i := 0 to 5 do
52468: LD_ADDR_VAR 0 6
52472: PUSH
52473: DOUBLE
52474: LD_INT 0
52476: DEC
52477: ST_TO_ADDR
52478: LD_INT 5
52480: PUSH
52481: FOR_TO
52482: IFFALSE 52625
// begin _x := ShiftX ( x1 , i , centerDist ) ;
52484: LD_ADDR_VAR 0 7
52488: PUSH
52489: LD_VAR 0 1
52493: PPUSH
52494: LD_VAR 0 6
52498: PPUSH
52499: LD_VAR 0 11
52503: PPUSH
52504: CALL_OW 272
52508: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
52509: LD_ADDR_VAR 0 8
52513: PUSH
52514: LD_VAR 0 2
52518: PPUSH
52519: LD_VAR 0 6
52523: PPUSH
52524: LD_VAR 0 11
52528: PPUSH
52529: CALL_OW 273
52533: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52534: LD_VAR 0 7
52538: PPUSH
52539: LD_VAR 0 8
52543: PPUSH
52544: CALL_OW 488
52548: NOT
52549: IFFALSE 52553
// continue ;
52551: GO 52481
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
52553: LD_ADDR_VAR 0 9
52557: PUSH
52558: LD_VAR 0 12
52562: PUSH
52563: LD_INT 1
52565: ARRAY
52566: PPUSH
52567: LD_VAR 0 12
52571: PUSH
52572: LD_INT 2
52574: ARRAY
52575: PPUSH
52576: LD_VAR 0 7
52580: PPUSH
52581: LD_VAR 0 8
52585: PPUSH
52586: CALL_OW 298
52590: ST_TO_ADDR
// if tmp < distance then
52591: LD_VAR 0 9
52595: PUSH
52596: LD_VAR 0 10
52600: LESS
52601: IFFALSE 52623
// begin result := i ;
52603: LD_ADDR_VAR 0 5
52607: PUSH
52608: LD_VAR 0 6
52612: ST_TO_ADDR
// distance := tmp ;
52613: LD_ADDR_VAR 0 10
52617: PUSH
52618: LD_VAR 0 9
52622: ST_TO_ADDR
// end ; end ;
52623: GO 52481
52625: POP
52626: POP
// end ;
52627: LD_VAR 0 5
52631: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52632: LD_INT 0
52634: PPUSH
52635: PPUSH
// if not driver or not IsInUnit ( driver ) then
52636: LD_VAR 0 1
52640: NOT
52641: PUSH
52642: LD_VAR 0 1
52646: PPUSH
52647: CALL_OW 310
52651: NOT
52652: OR
52653: IFFALSE 52657
// exit ;
52655: GO 52747
// vehicle := IsInUnit ( driver ) ;
52657: LD_ADDR_VAR 0 3
52661: PUSH
52662: LD_VAR 0 1
52666: PPUSH
52667: CALL_OW 310
52671: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52672: LD_VAR 0 1
52676: PPUSH
52677: LD_STRING \
52679: PUSH
52680: LD_INT 0
52682: PUSH
52683: LD_INT 0
52685: PUSH
52686: LD_INT 0
52688: PUSH
52689: LD_INT 0
52691: PUSH
52692: LD_INT 0
52694: PUSH
52695: LD_INT 0
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: LIST
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: PUSH
52707: LD_STRING E
52709: PUSH
52710: LD_INT 0
52712: PUSH
52713: LD_INT 0
52715: PUSH
52716: LD_VAR 0 3
52720: PUSH
52721: LD_INT 0
52723: PUSH
52724: LD_INT 0
52726: PUSH
52727: LD_INT 0
52729: PUSH
52730: EMPTY
52731: LIST
52732: LIST
52733: LIST
52734: LIST
52735: LIST
52736: LIST
52737: LIST
52738: PUSH
52739: EMPTY
52740: LIST
52741: LIST
52742: PPUSH
52743: CALL_OW 446
// end ;
52747: LD_VAR 0 2
52751: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
52752: LD_INT 0
52754: PPUSH
52755: PPUSH
// if not driver or not IsInUnit ( driver ) then
52756: LD_VAR 0 1
52760: NOT
52761: PUSH
52762: LD_VAR 0 1
52766: PPUSH
52767: CALL_OW 310
52771: NOT
52772: OR
52773: IFFALSE 52777
// exit ;
52775: GO 52867
// vehicle := IsInUnit ( driver ) ;
52777: LD_ADDR_VAR 0 3
52781: PUSH
52782: LD_VAR 0 1
52786: PPUSH
52787: CALL_OW 310
52791: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
52792: LD_VAR 0 1
52796: PPUSH
52797: LD_STRING \
52799: PUSH
52800: LD_INT 0
52802: PUSH
52803: LD_INT 0
52805: PUSH
52806: LD_INT 0
52808: PUSH
52809: LD_INT 0
52811: PUSH
52812: LD_INT 0
52814: PUSH
52815: LD_INT 0
52817: PUSH
52818: EMPTY
52819: LIST
52820: LIST
52821: LIST
52822: LIST
52823: LIST
52824: LIST
52825: LIST
52826: PUSH
52827: LD_STRING E
52829: PUSH
52830: LD_INT 0
52832: PUSH
52833: LD_INT 0
52835: PUSH
52836: LD_VAR 0 3
52840: PUSH
52841: LD_INT 0
52843: PUSH
52844: LD_INT 0
52846: PUSH
52847: LD_INT 0
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: LIST
52854: LIST
52855: LIST
52856: LIST
52857: LIST
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: PPUSH
52863: CALL_OW 447
// end ;
52867: LD_VAR 0 2
52871: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
52872: LD_INT 0
52874: PPUSH
52875: PPUSH
52876: PPUSH
// tmp := [ ] ;
52877: LD_ADDR_VAR 0 5
52881: PUSH
52882: EMPTY
52883: ST_TO_ADDR
// for i in units do
52884: LD_ADDR_VAR 0 4
52888: PUSH
52889: LD_VAR 0 1
52893: PUSH
52894: FOR_IN
52895: IFFALSE 52933
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
52897: LD_ADDR_VAR 0 5
52901: PUSH
52902: LD_VAR 0 5
52906: PPUSH
52907: LD_VAR 0 5
52911: PUSH
52912: LD_INT 1
52914: PLUS
52915: PPUSH
52916: LD_VAR 0 4
52920: PPUSH
52921: CALL_OW 256
52925: PPUSH
52926: CALL_OW 2
52930: ST_TO_ADDR
52931: GO 52894
52933: POP
52934: POP
// if not tmp then
52935: LD_VAR 0 5
52939: NOT
52940: IFFALSE 52944
// exit ;
52942: GO 52992
// if asc then
52944: LD_VAR 0 2
52948: IFFALSE 52972
// result := SortListByListAsc ( units , tmp ) else
52950: LD_ADDR_VAR 0 3
52954: PUSH
52955: LD_VAR 0 1
52959: PPUSH
52960: LD_VAR 0 5
52964: PPUSH
52965: CALL_OW 76
52969: ST_TO_ADDR
52970: GO 52992
// result := SortListByListDesc ( units , tmp ) ;
52972: LD_ADDR_VAR 0 3
52976: PUSH
52977: LD_VAR 0 1
52981: PPUSH
52982: LD_VAR 0 5
52986: PPUSH
52987: CALL_OW 77
52991: ST_TO_ADDR
// end ;
52992: LD_VAR 0 3
52996: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
52997: LD_INT 0
52999: PPUSH
53000: PPUSH
// task := GetTaskList ( mech ) ;
53001: LD_ADDR_VAR 0 4
53005: PUSH
53006: LD_VAR 0 1
53010: PPUSH
53011: CALL_OW 437
53015: ST_TO_ADDR
// if not task then
53016: LD_VAR 0 4
53020: NOT
53021: IFFALSE 53025
// exit ;
53023: GO 53067
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53025: LD_ADDR_VAR 0 3
53029: PUSH
53030: LD_VAR 0 4
53034: PUSH
53035: LD_INT 1
53037: ARRAY
53038: PUSH
53039: LD_INT 1
53041: ARRAY
53042: PUSH
53043: LD_STRING r
53045: EQUAL
53046: PUSH
53047: LD_VAR 0 4
53051: PUSH
53052: LD_INT 1
53054: ARRAY
53055: PUSH
53056: LD_INT 4
53058: ARRAY
53059: PUSH
53060: LD_VAR 0 2
53064: EQUAL
53065: AND
53066: ST_TO_ADDR
// end ;
53067: LD_VAR 0 3
53071: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53072: LD_INT 0
53074: PPUSH
// SetDir ( unit , d ) ;
53075: LD_VAR 0 1
53079: PPUSH
53080: LD_VAR 0 4
53084: PPUSH
53085: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53089: LD_VAR 0 1
53093: PPUSH
53094: LD_VAR 0 2
53098: PPUSH
53099: LD_VAR 0 3
53103: PPUSH
53104: LD_VAR 0 5
53108: PPUSH
53109: CALL_OW 48
// end ;
53113: LD_VAR 0 6
53117: RET
// export function ToNaturalNumber ( number ) ; begin
53118: LD_INT 0
53120: PPUSH
// result := number div 1 ;
53121: LD_ADDR_VAR 0 2
53125: PUSH
53126: LD_VAR 0 1
53130: PUSH
53131: LD_INT 1
53133: DIV
53134: ST_TO_ADDR
// if number < 0 then
53135: LD_VAR 0 1
53139: PUSH
53140: LD_INT 0
53142: LESS
53143: IFFALSE 53153
// result := 0 ;
53145: LD_ADDR_VAR 0 2
53149: PUSH
53150: LD_INT 0
53152: ST_TO_ADDR
// end ;
53153: LD_VAR 0 2
53157: RET
// export function SortByClass ( units , class ) ; var un ; begin
53158: LD_INT 0
53160: PPUSH
53161: PPUSH
// if not units or not class then
53162: LD_VAR 0 1
53166: NOT
53167: PUSH
53168: LD_VAR 0 2
53172: NOT
53173: OR
53174: IFFALSE 53178
// exit ;
53176: GO 53273
// result := [ ] ;
53178: LD_ADDR_VAR 0 3
53182: PUSH
53183: EMPTY
53184: ST_TO_ADDR
// for un in units do
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 1
53194: PUSH
53195: FOR_IN
53196: IFFALSE 53271
// if GetClass ( un ) = class then
53198: LD_VAR 0 4
53202: PPUSH
53203: CALL_OW 257
53207: PUSH
53208: LD_VAR 0 2
53212: EQUAL
53213: IFFALSE 53240
// result := Insert ( result , 1 , un ) else
53215: LD_ADDR_VAR 0 3
53219: PUSH
53220: LD_VAR 0 3
53224: PPUSH
53225: LD_INT 1
53227: PPUSH
53228: LD_VAR 0 4
53232: PPUSH
53233: CALL_OW 2
53237: ST_TO_ADDR
53238: GO 53269
// result := Replace ( result , result + 1 , un ) ;
53240: LD_ADDR_VAR 0 3
53244: PUSH
53245: LD_VAR 0 3
53249: PPUSH
53250: LD_VAR 0 3
53254: PUSH
53255: LD_INT 1
53257: PLUS
53258: PPUSH
53259: LD_VAR 0 4
53263: PPUSH
53264: CALL_OW 1
53268: ST_TO_ADDR
53269: GO 53195
53271: POP
53272: POP
// end ;
53273: LD_VAR 0 3
53277: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53278: LD_INT 0
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
// result := [ ] ;
53287: LD_ADDR_VAR 0 4
53291: PUSH
53292: EMPTY
53293: ST_TO_ADDR
// if x - r < 0 then
53294: LD_VAR 0 1
53298: PUSH
53299: LD_VAR 0 3
53303: MINUS
53304: PUSH
53305: LD_INT 0
53307: LESS
53308: IFFALSE 53320
// min_x := 0 else
53310: LD_ADDR_VAR 0 8
53314: PUSH
53315: LD_INT 0
53317: ST_TO_ADDR
53318: GO 53336
// min_x := x - r ;
53320: LD_ADDR_VAR 0 8
53324: PUSH
53325: LD_VAR 0 1
53329: PUSH
53330: LD_VAR 0 3
53334: MINUS
53335: ST_TO_ADDR
// if y - r < 0 then
53336: LD_VAR 0 2
53340: PUSH
53341: LD_VAR 0 3
53345: MINUS
53346: PUSH
53347: LD_INT 0
53349: LESS
53350: IFFALSE 53362
// min_y := 0 else
53352: LD_ADDR_VAR 0 7
53356: PUSH
53357: LD_INT 0
53359: ST_TO_ADDR
53360: GO 53378
// min_y := y - r ;
53362: LD_ADDR_VAR 0 7
53366: PUSH
53367: LD_VAR 0 2
53371: PUSH
53372: LD_VAR 0 3
53376: MINUS
53377: ST_TO_ADDR
// max_x := x + r ;
53378: LD_ADDR_VAR 0 9
53382: PUSH
53383: LD_VAR 0 1
53387: PUSH
53388: LD_VAR 0 3
53392: PLUS
53393: ST_TO_ADDR
// max_y := y + r ;
53394: LD_ADDR_VAR 0 10
53398: PUSH
53399: LD_VAR 0 2
53403: PUSH
53404: LD_VAR 0 3
53408: PLUS
53409: ST_TO_ADDR
// for _x = min_x to max_x do
53410: LD_ADDR_VAR 0 5
53414: PUSH
53415: DOUBLE
53416: LD_VAR 0 8
53420: DEC
53421: ST_TO_ADDR
53422: LD_VAR 0 9
53426: PUSH
53427: FOR_TO
53428: IFFALSE 53529
// for _y = min_y to max_y do
53430: LD_ADDR_VAR 0 6
53434: PUSH
53435: DOUBLE
53436: LD_VAR 0 7
53440: DEC
53441: ST_TO_ADDR
53442: LD_VAR 0 10
53446: PUSH
53447: FOR_TO
53448: IFFALSE 53525
// begin if not ValidHex ( _x , _y ) then
53450: LD_VAR 0 5
53454: PPUSH
53455: LD_VAR 0 6
53459: PPUSH
53460: CALL_OW 488
53464: NOT
53465: IFFALSE 53469
// continue ;
53467: GO 53447
// if GetResourceTypeXY ( _x , _y ) then
53469: LD_VAR 0 5
53473: PPUSH
53474: LD_VAR 0 6
53478: PPUSH
53479: CALL_OW 283
53483: IFFALSE 53523
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53485: LD_ADDR_VAR 0 4
53489: PUSH
53490: LD_VAR 0 4
53494: PPUSH
53495: LD_VAR 0 4
53499: PUSH
53500: LD_INT 1
53502: PLUS
53503: PPUSH
53504: LD_VAR 0 5
53508: PUSH
53509: LD_VAR 0 6
53513: PUSH
53514: EMPTY
53515: LIST
53516: LIST
53517: PPUSH
53518: CALL_OW 1
53522: ST_TO_ADDR
// end ;
53523: GO 53447
53525: POP
53526: POP
53527: GO 53427
53529: POP
53530: POP
// end ;
53531: LD_VAR 0 4
53535: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
53536: LD_INT 0
53538: PPUSH
53539: PPUSH
53540: PPUSH
53541: PPUSH
53542: PPUSH
53543: PPUSH
53544: PPUSH
53545: PPUSH
// if not units then
53546: LD_VAR 0 1
53550: NOT
53551: IFFALSE 53555
// exit ;
53553: GO 54079
// result := UnitFilter ( units , [ f_ok ] ) ;
53555: LD_ADDR_VAR 0 3
53559: PUSH
53560: LD_VAR 0 1
53564: PPUSH
53565: LD_INT 50
53567: PUSH
53568: EMPTY
53569: LIST
53570: PPUSH
53571: CALL_OW 72
53575: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53576: LD_ADDR_VAR 0 8
53580: PUSH
53581: LD_VAR 0 1
53585: PUSH
53586: LD_INT 1
53588: ARRAY
53589: PPUSH
53590: CALL_OW 255
53594: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
53595: LD_ADDR_VAR 0 10
53599: PUSH
53600: LD_INT 29
53602: PUSH
53603: LD_INT 91
53605: PUSH
53606: LD_INT 49
53608: PUSH
53609: EMPTY
53610: LIST
53611: LIST
53612: LIST
53613: ST_TO_ADDR
// if not result then
53614: LD_VAR 0 3
53618: NOT
53619: IFFALSE 53623
// exit ;
53621: GO 54079
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
53623: LD_ADDR_VAR 0 5
53627: PUSH
53628: LD_INT 81
53630: PUSH
53631: LD_VAR 0 8
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: PPUSH
53640: CALL_OW 69
53644: ST_TO_ADDR
// for i in result do
53645: LD_ADDR_VAR 0 4
53649: PUSH
53650: LD_VAR 0 3
53654: PUSH
53655: FOR_IN
53656: IFFALSE 54077
// begin tag := GetTag ( i ) + 1 ;
53658: LD_ADDR_VAR 0 9
53662: PUSH
53663: LD_VAR 0 4
53667: PPUSH
53668: CALL_OW 110
53672: PUSH
53673: LD_INT 1
53675: PLUS
53676: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
53677: LD_ADDR_VAR 0 7
53681: PUSH
53682: LD_VAR 0 4
53686: PPUSH
53687: CALL_OW 250
53691: PPUSH
53692: LD_VAR 0 4
53696: PPUSH
53697: CALL_OW 251
53701: PPUSH
53702: LD_INT 6
53704: PPUSH
53705: CALL 53278 0 3
53709: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
53710: LD_VAR 0 4
53714: PPUSH
53715: CALL_OW 247
53719: PUSH
53720: LD_INT 2
53722: EQUAL
53723: PUSH
53724: LD_VAR 0 7
53728: AND
53729: PUSH
53730: LD_VAR 0 4
53734: PPUSH
53735: CALL_OW 264
53739: PUSH
53740: LD_VAR 0 10
53744: IN
53745: NOT
53746: AND
53747: IFFALSE 53786
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
53749: LD_VAR 0 4
53753: PPUSH
53754: LD_VAR 0 7
53758: PUSH
53759: LD_INT 1
53761: ARRAY
53762: PUSH
53763: LD_INT 1
53765: ARRAY
53766: PPUSH
53767: LD_VAR 0 7
53771: PUSH
53772: LD_INT 1
53774: ARRAY
53775: PUSH
53776: LD_INT 2
53778: ARRAY
53779: PPUSH
53780: CALL_OW 116
53784: GO 54075
// if path > tag then
53786: LD_VAR 0 2
53790: PUSH
53791: LD_VAR 0 9
53795: GREATER
53796: IFFALSE 54004
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
53798: LD_ADDR_VAR 0 6
53802: PUSH
53803: LD_VAR 0 5
53807: PPUSH
53808: LD_INT 91
53810: PUSH
53811: LD_VAR 0 4
53815: PUSH
53816: LD_INT 8
53818: PUSH
53819: EMPTY
53820: LIST
53821: LIST
53822: LIST
53823: PPUSH
53824: CALL_OW 72
53828: ST_TO_ADDR
// if nearEnemy then
53829: LD_VAR 0 6
53833: IFFALSE 53902
// begin if GetWeapon ( i ) = ru_time_lapser then
53835: LD_VAR 0 4
53839: PPUSH
53840: CALL_OW 264
53844: PUSH
53845: LD_INT 49
53847: EQUAL
53848: IFFALSE 53876
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
53850: LD_VAR 0 4
53854: PPUSH
53855: LD_VAR 0 6
53859: PPUSH
53860: LD_VAR 0 4
53864: PPUSH
53865: CALL_OW 74
53869: PPUSH
53870: CALL_OW 112
53874: GO 53900
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
53876: LD_VAR 0 4
53880: PPUSH
53881: LD_VAR 0 6
53885: PPUSH
53886: LD_VAR 0 4
53890: PPUSH
53891: CALL_OW 74
53895: PPUSH
53896: CALL 55004 0 2
// end else
53900: GO 54002
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
53902: LD_VAR 0 4
53906: PPUSH
53907: LD_VAR 0 2
53911: PUSH
53912: LD_VAR 0 9
53916: ARRAY
53917: PUSH
53918: LD_INT 1
53920: ARRAY
53921: PPUSH
53922: LD_VAR 0 2
53926: PUSH
53927: LD_VAR 0 9
53931: ARRAY
53932: PUSH
53933: LD_INT 2
53935: ARRAY
53936: PPUSH
53937: CALL_OW 297
53941: PUSH
53942: LD_INT 6
53944: GREATER
53945: IFFALSE 53988
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
53947: LD_VAR 0 4
53951: PPUSH
53952: LD_VAR 0 2
53956: PUSH
53957: LD_VAR 0 9
53961: ARRAY
53962: PUSH
53963: LD_INT 1
53965: ARRAY
53966: PPUSH
53967: LD_VAR 0 2
53971: PUSH
53972: LD_VAR 0 9
53976: ARRAY
53977: PUSH
53978: LD_INT 2
53980: ARRAY
53981: PPUSH
53982: CALL_OW 114
53986: GO 54002
// SetTag ( i , tag ) ;
53988: LD_VAR 0 4
53992: PPUSH
53993: LD_VAR 0 9
53997: PPUSH
53998: CALL_OW 109
// end else
54002: GO 54075
// if enemy then
54004: LD_VAR 0 5
54008: IFFALSE 54075
// begin if GetWeapon ( i ) = ru_time_lapser then
54010: LD_VAR 0 4
54014: PPUSH
54015: CALL_OW 264
54019: PUSH
54020: LD_INT 49
54022: EQUAL
54023: IFFALSE 54051
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54025: LD_VAR 0 4
54029: PPUSH
54030: LD_VAR 0 5
54034: PPUSH
54035: LD_VAR 0 4
54039: PPUSH
54040: CALL_OW 74
54044: PPUSH
54045: CALL_OW 112
54049: GO 54075
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54051: LD_VAR 0 4
54055: PPUSH
54056: LD_VAR 0 5
54060: PPUSH
54061: LD_VAR 0 4
54065: PPUSH
54066: CALL_OW 74
54070: PPUSH
54071: CALL 55004 0 2
// end ; end ;
54075: GO 53655
54077: POP
54078: POP
// end ;
54079: LD_VAR 0 3
54083: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54084: LD_INT 0
54086: PPUSH
54087: PPUSH
54088: PPUSH
// if not unit or IsInUnit ( unit ) then
54089: LD_VAR 0 1
54093: NOT
54094: PUSH
54095: LD_VAR 0 1
54099: PPUSH
54100: CALL_OW 310
54104: OR
54105: IFFALSE 54109
// exit ;
54107: GO 54200
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54109: LD_ADDR_VAR 0 4
54113: PUSH
54114: LD_VAR 0 1
54118: PPUSH
54119: CALL_OW 250
54123: PPUSH
54124: LD_VAR 0 2
54128: PPUSH
54129: LD_INT 1
54131: PPUSH
54132: CALL_OW 272
54136: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54137: LD_ADDR_VAR 0 5
54141: PUSH
54142: LD_VAR 0 1
54146: PPUSH
54147: CALL_OW 251
54151: PPUSH
54152: LD_VAR 0 2
54156: PPUSH
54157: LD_INT 1
54159: PPUSH
54160: CALL_OW 273
54164: ST_TO_ADDR
// if ValidHex ( x , y ) then
54165: LD_VAR 0 4
54169: PPUSH
54170: LD_VAR 0 5
54174: PPUSH
54175: CALL_OW 488
54179: IFFALSE 54200
// ComTurnXY ( unit , x , y ) ;
54181: LD_VAR 0 1
54185: PPUSH
54186: LD_VAR 0 4
54190: PPUSH
54191: LD_VAR 0 5
54195: PPUSH
54196: CALL_OW 118
// end ;
54200: LD_VAR 0 3
54204: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54205: LD_INT 0
54207: PPUSH
54208: PPUSH
// result := false ;
54209: LD_ADDR_VAR 0 3
54213: PUSH
54214: LD_INT 0
54216: ST_TO_ADDR
// if not units then
54217: LD_VAR 0 2
54221: NOT
54222: IFFALSE 54226
// exit ;
54224: GO 54271
// for i in units do
54226: LD_ADDR_VAR 0 4
54230: PUSH
54231: LD_VAR 0 2
54235: PUSH
54236: FOR_IN
54237: IFFALSE 54269
// if See ( side , i ) then
54239: LD_VAR 0 1
54243: PPUSH
54244: LD_VAR 0 4
54248: PPUSH
54249: CALL_OW 292
54253: IFFALSE 54267
// begin result := true ;
54255: LD_ADDR_VAR 0 3
54259: PUSH
54260: LD_INT 1
54262: ST_TO_ADDR
// exit ;
54263: POP
54264: POP
54265: GO 54271
// end ;
54267: GO 54236
54269: POP
54270: POP
// end ;
54271: LD_VAR 0 3
54275: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54276: LD_INT 0
54278: PPUSH
54279: PPUSH
54280: PPUSH
54281: PPUSH
// if not unit or not points then
54282: LD_VAR 0 1
54286: NOT
54287: PUSH
54288: LD_VAR 0 2
54292: NOT
54293: OR
54294: IFFALSE 54298
// exit ;
54296: GO 54388
// dist := 99999 ;
54298: LD_ADDR_VAR 0 5
54302: PUSH
54303: LD_INT 99999
54305: ST_TO_ADDR
// for i in points do
54306: LD_ADDR_VAR 0 4
54310: PUSH
54311: LD_VAR 0 2
54315: PUSH
54316: FOR_IN
54317: IFFALSE 54386
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54319: LD_ADDR_VAR 0 6
54323: PUSH
54324: LD_VAR 0 1
54328: PPUSH
54329: LD_VAR 0 4
54333: PUSH
54334: LD_INT 1
54336: ARRAY
54337: PPUSH
54338: LD_VAR 0 4
54342: PUSH
54343: LD_INT 2
54345: ARRAY
54346: PPUSH
54347: CALL_OW 297
54351: ST_TO_ADDR
// if tmpDist < dist then
54352: LD_VAR 0 6
54356: PUSH
54357: LD_VAR 0 5
54361: LESS
54362: IFFALSE 54384
// begin result := i ;
54364: LD_ADDR_VAR 0 3
54368: PUSH
54369: LD_VAR 0 4
54373: ST_TO_ADDR
// dist := tmpDist ;
54374: LD_ADDR_VAR 0 5
54378: PUSH
54379: LD_VAR 0 6
54383: ST_TO_ADDR
// end ; end ;
54384: GO 54316
54386: POP
54387: POP
// end ;
54388: LD_VAR 0 3
54392: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
54393: LD_INT 0
54395: PPUSH
// uc_side := side ;
54396: LD_ADDR_OWVAR 20
54400: PUSH
54401: LD_VAR 0 1
54405: ST_TO_ADDR
// uc_nation := 3 ;
54406: LD_ADDR_OWVAR 21
54410: PUSH
54411: LD_INT 3
54413: ST_TO_ADDR
// vc_chassis := 25 ;
54414: LD_ADDR_OWVAR 37
54418: PUSH
54419: LD_INT 25
54421: ST_TO_ADDR
// vc_engine := engine_siberite ;
54422: LD_ADDR_OWVAR 39
54426: PUSH
54427: LD_INT 3
54429: ST_TO_ADDR
// vc_control := control_computer ;
54430: LD_ADDR_OWVAR 38
54434: PUSH
54435: LD_INT 3
54437: ST_TO_ADDR
// vc_weapon := 59 ;
54438: LD_ADDR_OWVAR 40
54442: PUSH
54443: LD_INT 59
54445: ST_TO_ADDR
// result := CreateVehicle ;
54446: LD_ADDR_VAR 0 5
54450: PUSH
54451: CALL_OW 45
54455: ST_TO_ADDR
// SetDir ( result , d ) ;
54456: LD_VAR 0 5
54460: PPUSH
54461: LD_VAR 0 4
54465: PPUSH
54466: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
54470: LD_VAR 0 5
54474: PPUSH
54475: LD_VAR 0 2
54479: PPUSH
54480: LD_VAR 0 3
54484: PPUSH
54485: LD_INT 0
54487: PPUSH
54488: CALL_OW 48
// end ;
54492: LD_VAR 0 5
54496: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
54497: LD_INT 0
54499: PPUSH
54500: PPUSH
54501: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
54502: LD_ADDR_VAR 0 2
54506: PUSH
54507: LD_INT 0
54509: PUSH
54510: LD_INT 0
54512: PUSH
54513: LD_INT 0
54515: PUSH
54516: LD_INT 0
54518: PUSH
54519: EMPTY
54520: LIST
54521: LIST
54522: LIST
54523: LIST
54524: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
54525: LD_VAR 0 1
54529: NOT
54530: PUSH
54531: LD_VAR 0 1
54535: PPUSH
54536: CALL_OW 264
54540: PUSH
54541: LD_INT 12
54543: PUSH
54544: LD_INT 51
54546: PUSH
54547: LD_INT 32
54549: PUSH
54550: LD_INT 89
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: LIST
54557: LIST
54558: IN
54559: NOT
54560: OR
54561: IFFALSE 54565
// exit ;
54563: GO 54663
// for i := 1 to 3 do
54565: LD_ADDR_VAR 0 3
54569: PUSH
54570: DOUBLE
54571: LD_INT 1
54573: DEC
54574: ST_TO_ADDR
54575: LD_INT 3
54577: PUSH
54578: FOR_TO
54579: IFFALSE 54661
// begin tmp := GetCargo ( cargo , i ) ;
54581: LD_ADDR_VAR 0 4
54585: PUSH
54586: LD_VAR 0 1
54590: PPUSH
54591: LD_VAR 0 3
54595: PPUSH
54596: CALL_OW 289
54600: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
54601: LD_ADDR_VAR 0 2
54605: PUSH
54606: LD_VAR 0 2
54610: PPUSH
54611: LD_VAR 0 3
54615: PPUSH
54616: LD_VAR 0 4
54620: PPUSH
54621: CALL_OW 1
54625: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
54626: LD_ADDR_VAR 0 2
54630: PUSH
54631: LD_VAR 0 2
54635: PPUSH
54636: LD_INT 4
54638: PPUSH
54639: LD_VAR 0 2
54643: PUSH
54644: LD_INT 4
54646: ARRAY
54647: PUSH
54648: LD_VAR 0 4
54652: PLUS
54653: PPUSH
54654: CALL_OW 1
54658: ST_TO_ADDR
// end ;
54659: GO 54578
54661: POP
54662: POP
// end ;
54663: LD_VAR 0 2
54667: RET
// export function Length ( array ) ; begin
54668: LD_INT 0
54670: PPUSH
// result := array + 0 ;
54671: LD_ADDR_VAR 0 2
54675: PUSH
54676: LD_VAR 0 1
54680: PUSH
54681: LD_INT 0
54683: PLUS
54684: ST_TO_ADDR
// end ;
54685: LD_VAR 0 2
54689: RET
// export function PrepareArray ( array ) ; begin
54690: LD_INT 0
54692: PPUSH
// result := array diff 0 ;
54693: LD_ADDR_VAR 0 2
54697: PUSH
54698: LD_VAR 0 1
54702: PUSH
54703: LD_INT 0
54705: DIFF
54706: ST_TO_ADDR
// if not result [ 1 ] then
54707: LD_VAR 0 2
54711: PUSH
54712: LD_INT 1
54714: ARRAY
54715: NOT
54716: IFFALSE 54736
// result := Delete ( result , 1 ) ;
54718: LD_ADDR_VAR 0 2
54722: PUSH
54723: LD_VAR 0 2
54727: PPUSH
54728: LD_INT 1
54730: PPUSH
54731: CALL_OW 3
54735: ST_TO_ADDR
// end ;
54736: LD_VAR 0 2
54740: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
54741: LD_INT 0
54743: PPUSH
54744: PPUSH
54745: PPUSH
54746: PPUSH
// sibRocketRange := 25 ;
54747: LD_ADDR_VAR 0 6
54751: PUSH
54752: LD_INT 25
54754: ST_TO_ADDR
// result := false ;
54755: LD_ADDR_VAR 0 4
54759: PUSH
54760: LD_INT 0
54762: ST_TO_ADDR
// for i := 0 to 5 do
54763: LD_ADDR_VAR 0 5
54767: PUSH
54768: DOUBLE
54769: LD_INT 0
54771: DEC
54772: ST_TO_ADDR
54773: LD_INT 5
54775: PUSH
54776: FOR_TO
54777: IFFALSE 54844
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
54779: LD_VAR 0 1
54783: PPUSH
54784: LD_VAR 0 5
54788: PPUSH
54789: LD_VAR 0 6
54793: PPUSH
54794: CALL_OW 272
54798: PPUSH
54799: LD_VAR 0 2
54803: PPUSH
54804: LD_VAR 0 5
54808: PPUSH
54809: LD_VAR 0 6
54813: PPUSH
54814: CALL_OW 273
54818: PPUSH
54819: LD_VAR 0 3
54823: PPUSH
54824: CALL_OW 309
54828: IFFALSE 54842
// begin result := true ;
54830: LD_ADDR_VAR 0 4
54834: PUSH
54835: LD_INT 1
54837: ST_TO_ADDR
// exit ;
54838: POP
54839: POP
54840: GO 54846
// end ;
54842: GO 54776
54844: POP
54845: POP
// end ;
54846: LD_VAR 0 4
54850: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
54851: LD_INT 0
54853: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
54854: LD_VAR 0 1
54858: PPUSH
54859: LD_VAR 0 2
54863: PPUSH
54864: LD_INT 0
54866: PPUSH
54867: LD_INT 0
54869: PPUSH
54870: LD_INT 1
54872: PPUSH
54873: LD_INT 0
54875: PPUSH
54876: CALL_OW 587
// end ;
54880: LD_VAR 0 3
54884: RET
// export function CenterOnNow ( unit ) ; begin
54885: LD_INT 0
54887: PPUSH
// result := IsInUnit ( unit ) ;
54888: LD_ADDR_VAR 0 2
54892: PUSH
54893: LD_VAR 0 1
54897: PPUSH
54898: CALL_OW 310
54902: ST_TO_ADDR
// if not result then
54903: LD_VAR 0 2
54907: NOT
54908: IFFALSE 54920
// result := unit ;
54910: LD_ADDR_VAR 0 2
54914: PUSH
54915: LD_VAR 0 1
54919: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
54920: LD_VAR 0 1
54924: PPUSH
54925: CALL_OW 87
// end ;
54929: LD_VAR 0 2
54933: RET
// export function ComMoveHex ( unit , hex ) ; begin
54934: LD_INT 0
54936: PPUSH
// if not hex then
54937: LD_VAR 0 2
54941: NOT
54942: IFFALSE 54946
// exit ;
54944: GO 54999
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
54946: LD_VAR 0 2
54950: PUSH
54951: LD_INT 1
54953: ARRAY
54954: PPUSH
54955: LD_VAR 0 2
54959: PUSH
54960: LD_INT 2
54962: ARRAY
54963: PPUSH
54964: CALL_OW 428
54968: IFFALSE 54972
// exit ;
54970: GO 54999
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
54972: LD_VAR 0 1
54976: PPUSH
54977: LD_VAR 0 2
54981: PUSH
54982: LD_INT 1
54984: ARRAY
54985: PPUSH
54986: LD_VAR 0 2
54990: PUSH
54991: LD_INT 2
54993: ARRAY
54994: PPUSH
54995: CALL_OW 111
// end ;
54999: LD_VAR 0 3
55003: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
55004: LD_INT 0
55006: PPUSH
55007: PPUSH
55008: PPUSH
// if not unit or not enemy then
55009: LD_VAR 0 1
55013: NOT
55014: PUSH
55015: LD_VAR 0 2
55019: NOT
55020: OR
55021: IFFALSE 55025
// exit ;
55023: GO 55149
// x := GetX ( enemy ) ;
55025: LD_ADDR_VAR 0 4
55029: PUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: CALL_OW 250
55039: ST_TO_ADDR
// y := GetY ( enemy ) ;
55040: LD_ADDR_VAR 0 5
55044: PUSH
55045: LD_VAR 0 2
55049: PPUSH
55050: CALL_OW 251
55054: ST_TO_ADDR
// if ValidHex ( x , y ) then
55055: LD_VAR 0 4
55059: PPUSH
55060: LD_VAR 0 5
55064: PPUSH
55065: CALL_OW 488
55069: IFFALSE 55149
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
55071: LD_VAR 0 2
55075: PPUSH
55076: CALL_OW 247
55080: PUSH
55081: LD_INT 3
55083: PUSH
55084: LD_INT 2
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: IN
55091: PUSH
55092: LD_VAR 0 1
55096: PPUSH
55097: CALL_OW 255
55101: PPUSH
55102: LD_VAR 0 2
55106: PPUSH
55107: CALL_OW 292
55111: AND
55112: IFFALSE 55130
// ComAttackUnit ( unit , enemy ) else
55114: LD_VAR 0 1
55118: PPUSH
55119: LD_VAR 0 2
55123: PPUSH
55124: CALL_OW 115
55128: GO 55149
// ComAgressiveMove ( unit , x , y ) ;
55130: LD_VAR 0 1
55134: PPUSH
55135: LD_VAR 0 4
55139: PPUSH
55140: LD_VAR 0 5
55144: PPUSH
55145: CALL_OW 114
// end ; end_of_file
55149: LD_VAR 0 3
55153: RET
// export ru_radar export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
55154: LD_INT 0
55156: PPUSH
55157: PPUSH
// skirmish := false ;
55158: LD_ADDR_EXP 48
55162: PUSH
55163: LD_INT 0
55165: ST_TO_ADDR
// debug_mc := false ;
55166: LD_ADDR_EXP 49
55170: PUSH
55171: LD_INT 0
55173: ST_TO_ADDR
// mc_bases := [ ] ;
55174: LD_ADDR_EXP 50
55178: PUSH
55179: EMPTY
55180: ST_TO_ADDR
// mc_sides := [ ] ;
55181: LD_ADDR_EXP 76
55185: PUSH
55186: EMPTY
55187: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55188: LD_ADDR_EXP 51
55192: PUSH
55193: EMPTY
55194: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55195: LD_ADDR_EXP 52
55199: PUSH
55200: EMPTY
55201: ST_TO_ADDR
// mc_need_heal := [ ] ;
55202: LD_ADDR_EXP 53
55206: PUSH
55207: EMPTY
55208: ST_TO_ADDR
// mc_healers := [ ] ;
55209: LD_ADDR_EXP 54
55213: PUSH
55214: EMPTY
55215: ST_TO_ADDR
// mc_build_list := [ ] ;
55216: LD_ADDR_EXP 55
55220: PUSH
55221: EMPTY
55222: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55223: LD_ADDR_EXP 82
55227: PUSH
55228: EMPTY
55229: ST_TO_ADDR
// mc_builders := [ ] ;
55230: LD_ADDR_EXP 56
55234: PUSH
55235: EMPTY
55236: ST_TO_ADDR
// mc_construct_list := [ ] ;
55237: LD_ADDR_EXP 57
55241: PUSH
55242: EMPTY
55243: ST_TO_ADDR
// mc_turret_list := [ ] ;
55244: LD_ADDR_EXP 58
55248: PUSH
55249: EMPTY
55250: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55251: LD_ADDR_EXP 59
55255: PUSH
55256: EMPTY
55257: ST_TO_ADDR
// mc_miners := [ ] ;
55258: LD_ADDR_EXP 64
55262: PUSH
55263: EMPTY
55264: ST_TO_ADDR
// mc_mines := [ ] ;
55265: LD_ADDR_EXP 63
55269: PUSH
55270: EMPTY
55271: ST_TO_ADDR
// mc_minefields := [ ] ;
55272: LD_ADDR_EXP 65
55276: PUSH
55277: EMPTY
55278: ST_TO_ADDR
// mc_crates := [ ] ;
55279: LD_ADDR_EXP 66
55283: PUSH
55284: EMPTY
55285: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55286: LD_ADDR_EXP 67
55290: PUSH
55291: EMPTY
55292: ST_TO_ADDR
// mc_crates_area := [ ] ;
55293: LD_ADDR_EXP 68
55297: PUSH
55298: EMPTY
55299: ST_TO_ADDR
// mc_vehicles := [ ] ;
55300: LD_ADDR_EXP 69
55304: PUSH
55305: EMPTY
55306: ST_TO_ADDR
// mc_attack := [ ] ;
55307: LD_ADDR_EXP 70
55311: PUSH
55312: EMPTY
55313: ST_TO_ADDR
// mc_produce := [ ] ;
55314: LD_ADDR_EXP 71
55318: PUSH
55319: EMPTY
55320: ST_TO_ADDR
// mc_defender := [ ] ;
55321: LD_ADDR_EXP 72
55325: PUSH
55326: EMPTY
55327: ST_TO_ADDR
// mc_parking := [ ] ;
55328: LD_ADDR_EXP 74
55332: PUSH
55333: EMPTY
55334: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55335: LD_ADDR_EXP 60
55339: PUSH
55340: EMPTY
55341: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55342: LD_ADDR_EXP 62
55346: PUSH
55347: EMPTY
55348: ST_TO_ADDR
// mc_scan := [ ] ;
55349: LD_ADDR_EXP 73
55353: PUSH
55354: EMPTY
55355: ST_TO_ADDR
// mc_scan_area := [ ] ;
55356: LD_ADDR_EXP 75
55360: PUSH
55361: EMPTY
55362: ST_TO_ADDR
// mc_tech := [ ] ;
55363: LD_ADDR_EXP 77
55367: PUSH
55368: EMPTY
55369: ST_TO_ADDR
// mc_class := [ ] ;
55370: LD_ADDR_EXP 91
55374: PUSH
55375: EMPTY
55376: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55377: LD_ADDR_EXP 92
55381: PUSH
55382: EMPTY
55383: ST_TO_ADDR
// mc_is_defending := [ ] ;
55384: LD_ADDR_EXP 93
55388: PUSH
55389: EMPTY
55390: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
55391: LD_ADDR_EXP 84
55395: PUSH
55396: EMPTY
55397: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
55398: LD_ADDR_EXP 94
55402: PUSH
55403: LD_INT 0
55405: ST_TO_ADDR
// end ;
55406: LD_VAR 0 1
55410: RET
// export function MC_Kill ( base ) ; begin
55411: LD_INT 0
55413: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55414: LD_ADDR_EXP 50
55418: PUSH
55419: LD_EXP 50
55423: PPUSH
55424: LD_VAR 0 1
55428: PPUSH
55429: EMPTY
55430: PPUSH
55431: CALL_OW 1
55435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55436: LD_ADDR_EXP 51
55440: PUSH
55441: LD_EXP 51
55445: PPUSH
55446: LD_VAR 0 1
55450: PPUSH
55451: EMPTY
55452: PPUSH
55453: CALL_OW 1
55457: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55458: LD_ADDR_EXP 52
55462: PUSH
55463: LD_EXP 52
55467: PPUSH
55468: LD_VAR 0 1
55472: PPUSH
55473: EMPTY
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55480: LD_ADDR_EXP 53
55484: PUSH
55485: LD_EXP 53
55489: PPUSH
55490: LD_VAR 0 1
55494: PPUSH
55495: EMPTY
55496: PPUSH
55497: CALL_OW 1
55501: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55502: LD_ADDR_EXP 54
55506: PUSH
55507: LD_EXP 54
55511: PPUSH
55512: LD_VAR 0 1
55516: PPUSH
55517: EMPTY
55518: PPUSH
55519: CALL_OW 1
55523: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55524: LD_ADDR_EXP 55
55528: PUSH
55529: LD_EXP 55
55533: PPUSH
55534: LD_VAR 0 1
55538: PPUSH
55539: EMPTY
55540: PPUSH
55541: CALL_OW 1
55545: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55546: LD_ADDR_EXP 56
55550: PUSH
55551: LD_EXP 56
55555: PPUSH
55556: LD_VAR 0 1
55560: PPUSH
55561: EMPTY
55562: PPUSH
55563: CALL_OW 1
55567: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55568: LD_ADDR_EXP 57
55572: PUSH
55573: LD_EXP 57
55577: PPUSH
55578: LD_VAR 0 1
55582: PPUSH
55583: EMPTY
55584: PPUSH
55585: CALL_OW 1
55589: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55590: LD_ADDR_EXP 58
55594: PUSH
55595: LD_EXP 58
55599: PPUSH
55600: LD_VAR 0 1
55604: PPUSH
55605: EMPTY
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55612: LD_ADDR_EXP 59
55616: PUSH
55617: LD_EXP 59
55621: PPUSH
55622: LD_VAR 0 1
55626: PPUSH
55627: EMPTY
55628: PPUSH
55629: CALL_OW 1
55633: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55634: LD_ADDR_EXP 60
55638: PUSH
55639: LD_EXP 60
55643: PPUSH
55644: LD_VAR 0 1
55648: PPUSH
55649: EMPTY
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55656: LD_ADDR_EXP 61
55660: PUSH
55661: LD_EXP 61
55665: PPUSH
55666: LD_VAR 0 1
55670: PPUSH
55671: LD_INT 0
55673: PPUSH
55674: CALL_OW 1
55678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55679: LD_ADDR_EXP 62
55683: PUSH
55684: LD_EXP 62
55688: PPUSH
55689: LD_VAR 0 1
55693: PPUSH
55694: EMPTY
55695: PPUSH
55696: CALL_OW 1
55700: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55701: LD_ADDR_EXP 63
55705: PUSH
55706: LD_EXP 63
55710: PPUSH
55711: LD_VAR 0 1
55715: PPUSH
55716: EMPTY
55717: PPUSH
55718: CALL_OW 1
55722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55723: LD_ADDR_EXP 64
55727: PUSH
55728: LD_EXP 64
55732: PPUSH
55733: LD_VAR 0 1
55737: PPUSH
55738: EMPTY
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55745: LD_ADDR_EXP 65
55749: PUSH
55750: LD_EXP 65
55754: PPUSH
55755: LD_VAR 0 1
55759: PPUSH
55760: EMPTY
55761: PPUSH
55762: CALL_OW 1
55766: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55767: LD_ADDR_EXP 66
55771: PUSH
55772: LD_EXP 66
55776: PPUSH
55777: LD_VAR 0 1
55781: PPUSH
55782: EMPTY
55783: PPUSH
55784: CALL_OW 1
55788: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55789: LD_ADDR_EXP 67
55793: PUSH
55794: LD_EXP 67
55798: PPUSH
55799: LD_VAR 0 1
55803: PPUSH
55804: EMPTY
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55811: LD_ADDR_EXP 68
55815: PUSH
55816: LD_EXP 68
55820: PPUSH
55821: LD_VAR 0 1
55825: PPUSH
55826: EMPTY
55827: PPUSH
55828: CALL_OW 1
55832: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55833: LD_ADDR_EXP 69
55837: PUSH
55838: LD_EXP 69
55842: PPUSH
55843: LD_VAR 0 1
55847: PPUSH
55848: EMPTY
55849: PPUSH
55850: CALL_OW 1
55854: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55855: LD_ADDR_EXP 70
55859: PUSH
55860: LD_EXP 70
55864: PPUSH
55865: LD_VAR 0 1
55869: PPUSH
55870: EMPTY
55871: PPUSH
55872: CALL_OW 1
55876: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55877: LD_ADDR_EXP 71
55881: PUSH
55882: LD_EXP 71
55886: PPUSH
55887: LD_VAR 0 1
55891: PPUSH
55892: EMPTY
55893: PPUSH
55894: CALL_OW 1
55898: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55899: LD_ADDR_EXP 72
55903: PUSH
55904: LD_EXP 72
55908: PPUSH
55909: LD_VAR 0 1
55913: PPUSH
55914: EMPTY
55915: PPUSH
55916: CALL_OW 1
55920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55921: LD_ADDR_EXP 73
55925: PUSH
55926: LD_EXP 73
55930: PPUSH
55931: LD_VAR 0 1
55935: PPUSH
55936: EMPTY
55937: PPUSH
55938: CALL_OW 1
55942: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55943: LD_ADDR_EXP 74
55947: PUSH
55948: LD_EXP 74
55952: PPUSH
55953: LD_VAR 0 1
55957: PPUSH
55958: EMPTY
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55965: LD_ADDR_EXP 75
55969: PUSH
55970: LD_EXP 75
55974: PPUSH
55975: LD_VAR 0 1
55979: PPUSH
55980: EMPTY
55981: PPUSH
55982: CALL_OW 1
55986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55987: LD_ADDR_EXP 77
55991: PUSH
55992: LD_EXP 77
55996: PPUSH
55997: LD_VAR 0 1
56001: PPUSH
56002: EMPTY
56003: PPUSH
56004: CALL_OW 1
56008: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56009: LD_ADDR_EXP 79
56013: PUSH
56014: LD_EXP 79
56018: PPUSH
56019: LD_VAR 0 1
56023: PPUSH
56024: EMPTY
56025: PPUSH
56026: CALL_OW 1
56030: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56031: LD_ADDR_EXP 80
56035: PUSH
56036: LD_EXP 80
56040: PPUSH
56041: LD_VAR 0 1
56045: PPUSH
56046: EMPTY
56047: PPUSH
56048: CALL_OW 1
56052: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56053: LD_ADDR_EXP 81
56057: PUSH
56058: LD_EXP 81
56062: PPUSH
56063: LD_VAR 0 1
56067: PPUSH
56068: EMPTY
56069: PPUSH
56070: CALL_OW 1
56074: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56075: LD_ADDR_EXP 82
56079: PUSH
56080: LD_EXP 82
56084: PPUSH
56085: LD_VAR 0 1
56089: PPUSH
56090: EMPTY
56091: PPUSH
56092: CALL_OW 1
56096: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56097: LD_ADDR_EXP 83
56101: PUSH
56102: LD_EXP 83
56106: PPUSH
56107: LD_VAR 0 1
56111: PPUSH
56112: EMPTY
56113: PPUSH
56114: CALL_OW 1
56118: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56119: LD_ADDR_EXP 84
56123: PUSH
56124: LD_EXP 84
56128: PPUSH
56129: LD_VAR 0 1
56133: PPUSH
56134: EMPTY
56135: PPUSH
56136: CALL_OW 1
56140: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56141: LD_ADDR_EXP 85
56145: PUSH
56146: LD_EXP 85
56150: PPUSH
56151: LD_VAR 0 1
56155: PPUSH
56156: EMPTY
56157: PPUSH
56158: CALL_OW 1
56162: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56163: LD_ADDR_EXP 86
56167: PUSH
56168: LD_EXP 86
56172: PPUSH
56173: LD_VAR 0 1
56177: PPUSH
56178: EMPTY
56179: PPUSH
56180: CALL_OW 1
56184: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56185: LD_ADDR_EXP 87
56189: PUSH
56190: LD_EXP 87
56194: PPUSH
56195: LD_VAR 0 1
56199: PPUSH
56200: EMPTY
56201: PPUSH
56202: CALL_OW 1
56206: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56207: LD_ADDR_EXP 88
56211: PUSH
56212: LD_EXP 88
56216: PPUSH
56217: LD_VAR 0 1
56221: PPUSH
56222: EMPTY
56223: PPUSH
56224: CALL_OW 1
56228: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56229: LD_ADDR_EXP 89
56233: PUSH
56234: LD_EXP 89
56238: PPUSH
56239: LD_VAR 0 1
56243: PPUSH
56244: EMPTY
56245: PPUSH
56246: CALL_OW 1
56250: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56251: LD_ADDR_EXP 90
56255: PUSH
56256: LD_EXP 90
56260: PPUSH
56261: LD_VAR 0 1
56265: PPUSH
56266: EMPTY
56267: PPUSH
56268: CALL_OW 1
56272: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56273: LD_ADDR_EXP 91
56277: PUSH
56278: LD_EXP 91
56282: PPUSH
56283: LD_VAR 0 1
56287: PPUSH
56288: EMPTY
56289: PPUSH
56290: CALL_OW 1
56294: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56295: LD_ADDR_EXP 92
56299: PUSH
56300: LD_EXP 92
56304: PPUSH
56305: LD_VAR 0 1
56309: PPUSH
56310: LD_INT 0
56312: PPUSH
56313: CALL_OW 1
56317: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56318: LD_ADDR_EXP 93
56322: PUSH
56323: LD_EXP 93
56327: PPUSH
56328: LD_VAR 0 1
56332: PPUSH
56333: LD_INT 0
56335: PPUSH
56336: CALL_OW 1
56340: ST_TO_ADDR
// end ;
56341: LD_VAR 0 2
56345: RET
// export function MC_Add ( side , units ) ; var base ; begin
56346: LD_INT 0
56348: PPUSH
56349: PPUSH
// base := mc_bases + 1 ;
56350: LD_ADDR_VAR 0 4
56354: PUSH
56355: LD_EXP 50
56359: PUSH
56360: LD_INT 1
56362: PLUS
56363: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56364: LD_ADDR_EXP 76
56368: PUSH
56369: LD_EXP 76
56373: PPUSH
56374: LD_VAR 0 4
56378: PPUSH
56379: LD_VAR 0 1
56383: PPUSH
56384: CALL_OW 1
56388: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56389: LD_ADDR_EXP 50
56393: PUSH
56394: LD_EXP 50
56398: PPUSH
56399: LD_VAR 0 4
56403: PPUSH
56404: LD_VAR 0 2
56408: PPUSH
56409: CALL_OW 1
56413: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56414: LD_ADDR_EXP 51
56418: PUSH
56419: LD_EXP 51
56423: PPUSH
56424: LD_VAR 0 4
56428: PPUSH
56429: EMPTY
56430: PPUSH
56431: CALL_OW 1
56435: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56436: LD_ADDR_EXP 52
56440: PUSH
56441: LD_EXP 52
56445: PPUSH
56446: LD_VAR 0 4
56450: PPUSH
56451: EMPTY
56452: PPUSH
56453: CALL_OW 1
56457: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56458: LD_ADDR_EXP 53
56462: PUSH
56463: LD_EXP 53
56467: PPUSH
56468: LD_VAR 0 4
56472: PPUSH
56473: EMPTY
56474: PPUSH
56475: CALL_OW 1
56479: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56480: LD_ADDR_EXP 54
56484: PUSH
56485: LD_EXP 54
56489: PPUSH
56490: LD_VAR 0 4
56494: PPUSH
56495: EMPTY
56496: PPUSH
56497: CALL_OW 1
56501: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56502: LD_ADDR_EXP 55
56506: PUSH
56507: LD_EXP 55
56511: PPUSH
56512: LD_VAR 0 4
56516: PPUSH
56517: EMPTY
56518: PPUSH
56519: CALL_OW 1
56523: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56524: LD_ADDR_EXP 56
56528: PUSH
56529: LD_EXP 56
56533: PPUSH
56534: LD_VAR 0 4
56538: PPUSH
56539: EMPTY
56540: PPUSH
56541: CALL_OW 1
56545: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56546: LD_ADDR_EXP 57
56550: PUSH
56551: LD_EXP 57
56555: PPUSH
56556: LD_VAR 0 4
56560: PPUSH
56561: EMPTY
56562: PPUSH
56563: CALL_OW 1
56567: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56568: LD_ADDR_EXP 58
56572: PUSH
56573: LD_EXP 58
56577: PPUSH
56578: LD_VAR 0 4
56582: PPUSH
56583: EMPTY
56584: PPUSH
56585: CALL_OW 1
56589: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56590: LD_ADDR_EXP 59
56594: PUSH
56595: LD_EXP 59
56599: PPUSH
56600: LD_VAR 0 4
56604: PPUSH
56605: EMPTY
56606: PPUSH
56607: CALL_OW 1
56611: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56612: LD_ADDR_EXP 60
56616: PUSH
56617: LD_EXP 60
56621: PPUSH
56622: LD_VAR 0 4
56626: PPUSH
56627: EMPTY
56628: PPUSH
56629: CALL_OW 1
56633: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56634: LD_ADDR_EXP 61
56638: PUSH
56639: LD_EXP 61
56643: PPUSH
56644: LD_VAR 0 4
56648: PPUSH
56649: LD_INT 0
56651: PPUSH
56652: CALL_OW 1
56656: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56657: LD_ADDR_EXP 62
56661: PUSH
56662: LD_EXP 62
56666: PPUSH
56667: LD_VAR 0 4
56671: PPUSH
56672: EMPTY
56673: PPUSH
56674: CALL_OW 1
56678: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56679: LD_ADDR_EXP 63
56683: PUSH
56684: LD_EXP 63
56688: PPUSH
56689: LD_VAR 0 4
56693: PPUSH
56694: EMPTY
56695: PPUSH
56696: CALL_OW 1
56700: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56701: LD_ADDR_EXP 64
56705: PUSH
56706: LD_EXP 64
56710: PPUSH
56711: LD_VAR 0 4
56715: PPUSH
56716: EMPTY
56717: PPUSH
56718: CALL_OW 1
56722: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56723: LD_ADDR_EXP 65
56727: PUSH
56728: LD_EXP 65
56732: PPUSH
56733: LD_VAR 0 4
56737: PPUSH
56738: EMPTY
56739: PPUSH
56740: CALL_OW 1
56744: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56745: LD_ADDR_EXP 66
56749: PUSH
56750: LD_EXP 66
56754: PPUSH
56755: LD_VAR 0 4
56759: PPUSH
56760: EMPTY
56761: PPUSH
56762: CALL_OW 1
56766: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56767: LD_ADDR_EXP 67
56771: PUSH
56772: LD_EXP 67
56776: PPUSH
56777: LD_VAR 0 4
56781: PPUSH
56782: EMPTY
56783: PPUSH
56784: CALL_OW 1
56788: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56789: LD_ADDR_EXP 68
56793: PUSH
56794: LD_EXP 68
56798: PPUSH
56799: LD_VAR 0 4
56803: PPUSH
56804: EMPTY
56805: PPUSH
56806: CALL_OW 1
56810: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56811: LD_ADDR_EXP 69
56815: PUSH
56816: LD_EXP 69
56820: PPUSH
56821: LD_VAR 0 4
56825: PPUSH
56826: EMPTY
56827: PPUSH
56828: CALL_OW 1
56832: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56833: LD_ADDR_EXP 70
56837: PUSH
56838: LD_EXP 70
56842: PPUSH
56843: LD_VAR 0 4
56847: PPUSH
56848: EMPTY
56849: PPUSH
56850: CALL_OW 1
56854: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56855: LD_ADDR_EXP 71
56859: PUSH
56860: LD_EXP 71
56864: PPUSH
56865: LD_VAR 0 4
56869: PPUSH
56870: EMPTY
56871: PPUSH
56872: CALL_OW 1
56876: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56877: LD_ADDR_EXP 72
56881: PUSH
56882: LD_EXP 72
56886: PPUSH
56887: LD_VAR 0 4
56891: PPUSH
56892: EMPTY
56893: PPUSH
56894: CALL_OW 1
56898: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56899: LD_ADDR_EXP 73
56903: PUSH
56904: LD_EXP 73
56908: PPUSH
56909: LD_VAR 0 4
56913: PPUSH
56914: EMPTY
56915: PPUSH
56916: CALL_OW 1
56920: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56921: LD_ADDR_EXP 74
56925: PUSH
56926: LD_EXP 74
56930: PPUSH
56931: LD_VAR 0 4
56935: PPUSH
56936: EMPTY
56937: PPUSH
56938: CALL_OW 1
56942: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56943: LD_ADDR_EXP 75
56947: PUSH
56948: LD_EXP 75
56952: PPUSH
56953: LD_VAR 0 4
56957: PPUSH
56958: EMPTY
56959: PPUSH
56960: CALL_OW 1
56964: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56965: LD_ADDR_EXP 77
56969: PUSH
56970: LD_EXP 77
56974: PPUSH
56975: LD_VAR 0 4
56979: PPUSH
56980: EMPTY
56981: PPUSH
56982: CALL_OW 1
56986: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56987: LD_ADDR_EXP 79
56991: PUSH
56992: LD_EXP 79
56996: PPUSH
56997: LD_VAR 0 4
57001: PPUSH
57002: EMPTY
57003: PPUSH
57004: CALL_OW 1
57008: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57009: LD_ADDR_EXP 80
57013: PUSH
57014: LD_EXP 80
57018: PPUSH
57019: LD_VAR 0 4
57023: PPUSH
57024: EMPTY
57025: PPUSH
57026: CALL_OW 1
57030: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57031: LD_ADDR_EXP 81
57035: PUSH
57036: LD_EXP 81
57040: PPUSH
57041: LD_VAR 0 4
57045: PPUSH
57046: EMPTY
57047: PPUSH
57048: CALL_OW 1
57052: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57053: LD_ADDR_EXP 82
57057: PUSH
57058: LD_EXP 82
57062: PPUSH
57063: LD_VAR 0 4
57067: PPUSH
57068: EMPTY
57069: PPUSH
57070: CALL_OW 1
57074: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57075: LD_ADDR_EXP 83
57079: PUSH
57080: LD_EXP 83
57084: PPUSH
57085: LD_VAR 0 4
57089: PPUSH
57090: EMPTY
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57097: LD_ADDR_EXP 84
57101: PUSH
57102: LD_EXP 84
57106: PPUSH
57107: LD_VAR 0 4
57111: PPUSH
57112: EMPTY
57113: PPUSH
57114: CALL_OW 1
57118: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57119: LD_ADDR_EXP 85
57123: PUSH
57124: LD_EXP 85
57128: PPUSH
57129: LD_VAR 0 4
57133: PPUSH
57134: EMPTY
57135: PPUSH
57136: CALL_OW 1
57140: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57141: LD_ADDR_EXP 86
57145: PUSH
57146: LD_EXP 86
57150: PPUSH
57151: LD_VAR 0 4
57155: PPUSH
57156: EMPTY
57157: PPUSH
57158: CALL_OW 1
57162: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57163: LD_ADDR_EXP 87
57167: PUSH
57168: LD_EXP 87
57172: PPUSH
57173: LD_VAR 0 4
57177: PPUSH
57178: EMPTY
57179: PPUSH
57180: CALL_OW 1
57184: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57185: LD_ADDR_EXP 88
57189: PUSH
57190: LD_EXP 88
57194: PPUSH
57195: LD_VAR 0 4
57199: PPUSH
57200: EMPTY
57201: PPUSH
57202: CALL_OW 1
57206: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57207: LD_ADDR_EXP 89
57211: PUSH
57212: LD_EXP 89
57216: PPUSH
57217: LD_VAR 0 4
57221: PPUSH
57222: EMPTY
57223: PPUSH
57224: CALL_OW 1
57228: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57229: LD_ADDR_EXP 90
57233: PUSH
57234: LD_EXP 90
57238: PPUSH
57239: LD_VAR 0 4
57243: PPUSH
57244: EMPTY
57245: PPUSH
57246: CALL_OW 1
57250: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57251: LD_ADDR_EXP 91
57255: PUSH
57256: LD_EXP 91
57260: PPUSH
57261: LD_VAR 0 4
57265: PPUSH
57266: EMPTY
57267: PPUSH
57268: CALL_OW 1
57272: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57273: LD_ADDR_EXP 92
57277: PUSH
57278: LD_EXP 92
57282: PPUSH
57283: LD_VAR 0 4
57287: PPUSH
57288: LD_INT 0
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57296: LD_ADDR_EXP 93
57300: PUSH
57301: LD_EXP 93
57305: PPUSH
57306: LD_VAR 0 4
57310: PPUSH
57311: LD_INT 0
57313: PPUSH
57314: CALL_OW 1
57318: ST_TO_ADDR
// result := base ;
57319: LD_ADDR_VAR 0 3
57323: PUSH
57324: LD_VAR 0 4
57328: ST_TO_ADDR
// end ;
57329: LD_VAR 0 3
57333: RET
// export function MC_Start ( ) ; var i ; begin
57334: LD_INT 0
57336: PPUSH
57337: PPUSH
// for i = 1 to mc_bases do
57338: LD_ADDR_VAR 0 2
57342: PUSH
57343: DOUBLE
57344: LD_INT 1
57346: DEC
57347: ST_TO_ADDR
57348: LD_EXP 50
57352: PUSH
57353: FOR_TO
57354: IFFALSE 58454
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57356: LD_ADDR_EXP 50
57360: PUSH
57361: LD_EXP 50
57365: PPUSH
57366: LD_VAR 0 2
57370: PPUSH
57371: LD_EXP 50
57375: PUSH
57376: LD_VAR 0 2
57380: ARRAY
57381: PUSH
57382: LD_INT 0
57384: DIFF
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57391: LD_ADDR_EXP 51
57395: PUSH
57396: LD_EXP 51
57400: PPUSH
57401: LD_VAR 0 2
57405: PPUSH
57406: EMPTY
57407: PPUSH
57408: CALL_OW 1
57412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57413: LD_ADDR_EXP 52
57417: PUSH
57418: LD_EXP 52
57422: PPUSH
57423: LD_VAR 0 2
57427: PPUSH
57428: EMPTY
57429: PPUSH
57430: CALL_OW 1
57434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57435: LD_ADDR_EXP 53
57439: PUSH
57440: LD_EXP 53
57444: PPUSH
57445: LD_VAR 0 2
57449: PPUSH
57450: EMPTY
57451: PPUSH
57452: CALL_OW 1
57456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57457: LD_ADDR_EXP 54
57461: PUSH
57462: LD_EXP 54
57466: PPUSH
57467: LD_VAR 0 2
57471: PPUSH
57472: EMPTY
57473: PUSH
57474: EMPTY
57475: PUSH
57476: EMPTY
57477: LIST
57478: LIST
57479: PPUSH
57480: CALL_OW 1
57484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57485: LD_ADDR_EXP 55
57489: PUSH
57490: LD_EXP 55
57494: PPUSH
57495: LD_VAR 0 2
57499: PPUSH
57500: EMPTY
57501: PPUSH
57502: CALL_OW 1
57506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57507: LD_ADDR_EXP 82
57511: PUSH
57512: LD_EXP 82
57516: PPUSH
57517: LD_VAR 0 2
57521: PPUSH
57522: EMPTY
57523: PPUSH
57524: CALL_OW 1
57528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57529: LD_ADDR_EXP 56
57533: PUSH
57534: LD_EXP 56
57538: PPUSH
57539: LD_VAR 0 2
57543: PPUSH
57544: EMPTY
57545: PPUSH
57546: CALL_OW 1
57550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57551: LD_ADDR_EXP 57
57555: PUSH
57556: LD_EXP 57
57560: PPUSH
57561: LD_VAR 0 2
57565: PPUSH
57566: EMPTY
57567: PPUSH
57568: CALL_OW 1
57572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57573: LD_ADDR_EXP 58
57577: PUSH
57578: LD_EXP 58
57582: PPUSH
57583: LD_VAR 0 2
57587: PPUSH
57588: LD_EXP 50
57592: PUSH
57593: LD_VAR 0 2
57597: ARRAY
57598: PPUSH
57599: LD_INT 2
57601: PUSH
57602: LD_INT 30
57604: PUSH
57605: LD_INT 32
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: PUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 33
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: LIST
57626: PPUSH
57627: CALL_OW 72
57631: PPUSH
57632: CALL_OW 1
57636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57637: LD_ADDR_EXP 59
57641: PUSH
57642: LD_EXP 59
57646: PPUSH
57647: LD_VAR 0 2
57651: PPUSH
57652: LD_EXP 50
57656: PUSH
57657: LD_VAR 0 2
57661: ARRAY
57662: PPUSH
57663: LD_INT 2
57665: PUSH
57666: LD_INT 30
57668: PUSH
57669: LD_INT 32
57671: PUSH
57672: EMPTY
57673: LIST
57674: LIST
57675: PUSH
57676: LD_INT 30
57678: PUSH
57679: LD_INT 31
57681: PUSH
57682: EMPTY
57683: LIST
57684: LIST
57685: PUSH
57686: EMPTY
57687: LIST
57688: LIST
57689: LIST
57690: PUSH
57691: LD_INT 58
57693: PUSH
57694: EMPTY
57695: LIST
57696: PUSH
57697: EMPTY
57698: LIST
57699: LIST
57700: PPUSH
57701: CALL_OW 72
57705: PPUSH
57706: CALL_OW 1
57710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57711: LD_ADDR_EXP 60
57715: PUSH
57716: LD_EXP 60
57720: PPUSH
57721: LD_VAR 0 2
57725: PPUSH
57726: EMPTY
57727: PPUSH
57728: CALL_OW 1
57732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57733: LD_ADDR_EXP 64
57737: PUSH
57738: LD_EXP 64
57742: PPUSH
57743: LD_VAR 0 2
57747: PPUSH
57748: EMPTY
57749: PPUSH
57750: CALL_OW 1
57754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57755: LD_ADDR_EXP 63
57759: PUSH
57760: LD_EXP 63
57764: PPUSH
57765: LD_VAR 0 2
57769: PPUSH
57770: EMPTY
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57777: LD_ADDR_EXP 65
57781: PUSH
57782: LD_EXP 65
57786: PPUSH
57787: LD_VAR 0 2
57791: PPUSH
57792: EMPTY
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57799: LD_ADDR_EXP 66
57803: PUSH
57804: LD_EXP 66
57808: PPUSH
57809: LD_VAR 0 2
57813: PPUSH
57814: EMPTY
57815: PPUSH
57816: CALL_OW 1
57820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57821: LD_ADDR_EXP 67
57825: PUSH
57826: LD_EXP 67
57830: PPUSH
57831: LD_VAR 0 2
57835: PPUSH
57836: EMPTY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57843: LD_ADDR_EXP 68
57847: PUSH
57848: LD_EXP 68
57852: PPUSH
57853: LD_VAR 0 2
57857: PPUSH
57858: EMPTY
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57865: LD_ADDR_EXP 69
57869: PUSH
57870: LD_EXP 69
57874: PPUSH
57875: LD_VAR 0 2
57879: PPUSH
57880: EMPTY
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57887: LD_ADDR_EXP 70
57891: PUSH
57892: LD_EXP 70
57896: PPUSH
57897: LD_VAR 0 2
57901: PPUSH
57902: EMPTY
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57909: LD_ADDR_EXP 71
57913: PUSH
57914: LD_EXP 71
57918: PPUSH
57919: LD_VAR 0 2
57923: PPUSH
57924: EMPTY
57925: PPUSH
57926: CALL_OW 1
57930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57931: LD_ADDR_EXP 72
57935: PUSH
57936: LD_EXP 72
57940: PPUSH
57941: LD_VAR 0 2
57945: PPUSH
57946: EMPTY
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57953: LD_ADDR_EXP 61
57957: PUSH
57958: LD_EXP 61
57962: PPUSH
57963: LD_VAR 0 2
57967: PPUSH
57968: LD_INT 0
57970: PPUSH
57971: CALL_OW 1
57975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57976: LD_ADDR_EXP 74
57980: PUSH
57981: LD_EXP 74
57985: PPUSH
57986: LD_VAR 0 2
57990: PPUSH
57991: LD_INT 0
57993: PPUSH
57994: CALL_OW 1
57998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57999: LD_ADDR_EXP 62
58003: PUSH
58004: LD_EXP 62
58008: PPUSH
58009: LD_VAR 0 2
58013: PPUSH
58014: EMPTY
58015: PPUSH
58016: CALL_OW 1
58020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58021: LD_ADDR_EXP 73
58025: PUSH
58026: LD_EXP 73
58030: PPUSH
58031: LD_VAR 0 2
58035: PPUSH
58036: LD_INT 0
58038: PPUSH
58039: CALL_OW 1
58043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58044: LD_ADDR_EXP 75
58048: PUSH
58049: LD_EXP 75
58053: PPUSH
58054: LD_VAR 0 2
58058: PPUSH
58059: EMPTY
58060: PPUSH
58061: CALL_OW 1
58065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58066: LD_ADDR_EXP 78
58070: PUSH
58071: LD_EXP 78
58075: PPUSH
58076: LD_VAR 0 2
58080: PPUSH
58081: LD_INT 0
58083: PPUSH
58084: CALL_OW 1
58088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58089: LD_ADDR_EXP 79
58093: PUSH
58094: LD_EXP 79
58098: PPUSH
58099: LD_VAR 0 2
58103: PPUSH
58104: EMPTY
58105: PPUSH
58106: CALL_OW 1
58110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58111: LD_ADDR_EXP 80
58115: PUSH
58116: LD_EXP 80
58120: PPUSH
58121: LD_VAR 0 2
58125: PPUSH
58126: EMPTY
58127: PPUSH
58128: CALL_OW 1
58132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58133: LD_ADDR_EXP 81
58137: PUSH
58138: LD_EXP 81
58142: PPUSH
58143: LD_VAR 0 2
58147: PPUSH
58148: EMPTY
58149: PPUSH
58150: CALL_OW 1
58154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58155: LD_ADDR_EXP 83
58159: PUSH
58160: LD_EXP 83
58164: PPUSH
58165: LD_VAR 0 2
58169: PPUSH
58170: LD_EXP 50
58174: PUSH
58175: LD_VAR 0 2
58179: ARRAY
58180: PPUSH
58181: LD_INT 2
58183: PUSH
58184: LD_INT 30
58186: PUSH
58187: LD_INT 6
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: PUSH
58194: LD_INT 30
58196: PUSH
58197: LD_INT 7
58199: PUSH
58200: EMPTY
58201: LIST
58202: LIST
58203: PUSH
58204: LD_INT 30
58206: PUSH
58207: LD_INT 8
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: LIST
58218: LIST
58219: PPUSH
58220: CALL_OW 72
58224: PPUSH
58225: CALL_OW 1
58229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58230: LD_ADDR_EXP 84
58234: PUSH
58235: LD_EXP 84
58239: PPUSH
58240: LD_VAR 0 2
58244: PPUSH
58245: EMPTY
58246: PPUSH
58247: CALL_OW 1
58251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58252: LD_ADDR_EXP 85
58256: PUSH
58257: LD_EXP 85
58261: PPUSH
58262: LD_VAR 0 2
58266: PPUSH
58267: EMPTY
58268: PPUSH
58269: CALL_OW 1
58273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58274: LD_ADDR_EXP 86
58278: PUSH
58279: LD_EXP 86
58283: PPUSH
58284: LD_VAR 0 2
58288: PPUSH
58289: EMPTY
58290: PPUSH
58291: CALL_OW 1
58295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58296: LD_ADDR_EXP 87
58300: PUSH
58301: LD_EXP 87
58305: PPUSH
58306: LD_VAR 0 2
58310: PPUSH
58311: EMPTY
58312: PPUSH
58313: CALL_OW 1
58317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58318: LD_ADDR_EXP 88
58322: PUSH
58323: LD_EXP 88
58327: PPUSH
58328: LD_VAR 0 2
58332: PPUSH
58333: EMPTY
58334: PPUSH
58335: CALL_OW 1
58339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58340: LD_ADDR_EXP 89
58344: PUSH
58345: LD_EXP 89
58349: PPUSH
58350: LD_VAR 0 2
58354: PPUSH
58355: EMPTY
58356: PPUSH
58357: CALL_OW 1
58361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58362: LD_ADDR_EXP 90
58366: PUSH
58367: LD_EXP 90
58371: PPUSH
58372: LD_VAR 0 2
58376: PPUSH
58377: EMPTY
58378: PPUSH
58379: CALL_OW 1
58383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58384: LD_ADDR_EXP 91
58388: PUSH
58389: LD_EXP 91
58393: PPUSH
58394: LD_VAR 0 2
58398: PPUSH
58399: EMPTY
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58406: LD_ADDR_EXP 92
58410: PUSH
58411: LD_EXP 92
58415: PPUSH
58416: LD_VAR 0 2
58420: PPUSH
58421: LD_INT 0
58423: PPUSH
58424: CALL_OW 1
58428: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58429: LD_ADDR_EXP 93
58433: PUSH
58434: LD_EXP 93
58438: PPUSH
58439: LD_VAR 0 2
58443: PPUSH
58444: LD_INT 0
58446: PPUSH
58447: CALL_OW 1
58451: ST_TO_ADDR
// end ;
58452: GO 57353
58454: POP
58455: POP
// MC_InitSides ( ) ;
58456: CALL 58742 0 0
// MC_InitResearch ( ) ;
58460: CALL 58481 0 0
// CustomInitMacro ( ) ;
58464: CALL 5753 0 0
// skirmish := true ;
58468: LD_ADDR_EXP 48
58472: PUSH
58473: LD_INT 1
58475: ST_TO_ADDR
// end ;
58476: LD_VAR 0 1
58480: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58481: LD_INT 0
58483: PPUSH
58484: PPUSH
58485: PPUSH
58486: PPUSH
58487: PPUSH
58488: PPUSH
// if not mc_bases then
58489: LD_EXP 50
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58737
// for i = 1 to 8 do
58498: LD_ADDR_VAR 0 2
58502: PUSH
58503: DOUBLE
58504: LD_INT 1
58506: DEC
58507: ST_TO_ADDR
58508: LD_INT 8
58510: PUSH
58511: FOR_TO
58512: IFFALSE 58538
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58514: LD_ADDR_EXP 77
58518: PUSH
58519: LD_EXP 77
58523: PPUSH
58524: LD_VAR 0 2
58528: PPUSH
58529: EMPTY
58530: PPUSH
58531: CALL_OW 1
58535: ST_TO_ADDR
58536: GO 58511
58538: POP
58539: POP
// tmp := [ ] ;
58540: LD_ADDR_VAR 0 5
58544: PUSH
58545: EMPTY
58546: ST_TO_ADDR
// for i = 1 to mc_sides do
58547: LD_ADDR_VAR 0 2
58551: PUSH
58552: DOUBLE
58553: LD_INT 1
58555: DEC
58556: ST_TO_ADDR
58557: LD_EXP 76
58561: PUSH
58562: FOR_TO
58563: IFFALSE 58621
// if not mc_sides [ i ] in tmp then
58565: LD_EXP 76
58569: PUSH
58570: LD_VAR 0 2
58574: ARRAY
58575: PUSH
58576: LD_VAR 0 5
58580: IN
58581: NOT
58582: IFFALSE 58619
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58584: LD_ADDR_VAR 0 5
58588: PUSH
58589: LD_VAR 0 5
58593: PPUSH
58594: LD_VAR 0 5
58598: PUSH
58599: LD_INT 1
58601: PLUS
58602: PPUSH
58603: LD_EXP 76
58607: PUSH
58608: LD_VAR 0 2
58612: ARRAY
58613: PPUSH
58614: CALL_OW 2
58618: ST_TO_ADDR
58619: GO 58562
58621: POP
58622: POP
// if not tmp then
58623: LD_VAR 0 5
58627: NOT
58628: IFFALSE 58632
// exit ;
58630: GO 58737
// for j in tmp do
58632: LD_ADDR_VAR 0 3
58636: PUSH
58637: LD_VAR 0 5
58641: PUSH
58642: FOR_IN
58643: IFFALSE 58735
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58645: LD_ADDR_VAR 0 6
58649: PUSH
58650: LD_INT 22
58652: PUSH
58653: LD_VAR 0 3
58657: PUSH
58658: EMPTY
58659: LIST
58660: LIST
58661: PPUSH
58662: CALL_OW 69
58666: ST_TO_ADDR
// if not un then
58667: LD_VAR 0 6
58671: NOT
58672: IFFALSE 58676
// continue ;
58674: GO 58642
// nation := GetNation ( un [ 1 ] ) ;
58676: LD_ADDR_VAR 0 4
58680: PUSH
58681: LD_VAR 0 6
58685: PUSH
58686: LD_INT 1
58688: ARRAY
58689: PPUSH
58690: CALL_OW 248
58694: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58695: LD_ADDR_EXP 77
58699: PUSH
58700: LD_EXP 77
58704: PPUSH
58705: LD_VAR 0 3
58709: PPUSH
58710: LD_VAR 0 3
58714: PPUSH
58715: LD_VAR 0 4
58719: PPUSH
58720: LD_INT 1
58722: PPUSH
58723: CALL 13674 0 3
58727: PPUSH
58728: CALL_OW 1
58732: ST_TO_ADDR
// end ;
58733: GO 58642
58735: POP
58736: POP
// end ;
58737: LD_VAR 0 1
58741: RET
// export function MC_InitSides ( ) ; var i ; begin
58742: LD_INT 0
58744: PPUSH
58745: PPUSH
// if not mc_bases then
58746: LD_EXP 50
58750: NOT
58751: IFFALSE 58755
// exit ;
58753: GO 58829
// for i = 1 to mc_bases do
58755: LD_ADDR_VAR 0 2
58759: PUSH
58760: DOUBLE
58761: LD_INT 1
58763: DEC
58764: ST_TO_ADDR
58765: LD_EXP 50
58769: PUSH
58770: FOR_TO
58771: IFFALSE 58827
// if mc_bases [ i ] then
58773: LD_EXP 50
58777: PUSH
58778: LD_VAR 0 2
58782: ARRAY
58783: IFFALSE 58825
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58785: LD_ADDR_EXP 76
58789: PUSH
58790: LD_EXP 76
58794: PPUSH
58795: LD_VAR 0 2
58799: PPUSH
58800: LD_EXP 50
58804: PUSH
58805: LD_VAR 0 2
58809: ARRAY
58810: PUSH
58811: LD_INT 1
58813: ARRAY
58814: PPUSH
58815: CALL_OW 255
58819: PPUSH
58820: CALL_OW 1
58824: ST_TO_ADDR
58825: GO 58770
58827: POP
58828: POP
// end ;
58829: LD_VAR 0 1
58833: RET
// every 0 0$03 trigger skirmish do
58834: LD_EXP 48
58838: IFFALSE 58992
58840: GO 58842
58842: DISABLE
// begin enable ;
58843: ENABLE
// MC_CheckBuildings ( ) ;
58844: CALL 63504 0 0
// MC_CheckPeopleLife ( ) ;
58848: CALL 63665 0 0
// RaiseSailEvent ( 100 ) ;
58852: LD_INT 100
58854: PPUSH
58855: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58859: LD_INT 103
58861: PPUSH
58862: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58866: LD_INT 104
58868: PPUSH
58869: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58873: LD_INT 105
58875: PPUSH
58876: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58880: LD_INT 106
58882: PPUSH
58883: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58887: LD_INT 107
58889: PPUSH
58890: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58894: LD_INT 108
58896: PPUSH
58897: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58901: LD_INT 109
58903: PPUSH
58904: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58908: LD_INT 110
58910: PPUSH
58911: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58915: LD_INT 111
58917: PPUSH
58918: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58922: LD_INT 112
58924: PPUSH
58925: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58929: LD_INT 113
58931: PPUSH
58932: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58936: LD_INT 120
58938: PPUSH
58939: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58943: LD_INT 121
58945: PPUSH
58946: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58950: LD_INT 122
58952: PPUSH
58953: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58957: LD_INT 123
58959: PPUSH
58960: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58964: LD_INT 124
58966: PPUSH
58967: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58971: LD_INT 125
58973: PPUSH
58974: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58978: LD_INT 126
58980: PPUSH
58981: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58985: LD_INT 200
58987: PPUSH
58988: CALL_OW 427
// end ;
58992: END
// on SailEvent ( event ) do begin if event < 100 then
58993: LD_VAR 0 1
58997: PUSH
58998: LD_INT 100
59000: LESS
59001: IFFALSE 59012
// CustomEvent ( event ) ;
59003: LD_VAR 0 1
59007: PPUSH
59008: CALL 5745 0 1
// if event = 100 then
59012: LD_VAR 0 1
59016: PUSH
59017: LD_INT 100
59019: EQUAL
59020: IFFALSE 59026
// MC_ClassManager ( ) ;
59022: CALL 59418 0 0
// if event = 101 then
59026: LD_VAR 0 1
59030: PUSH
59031: LD_INT 101
59033: EQUAL
59034: IFFALSE 59040
// MC_RepairBuildings ( ) ;
59036: CALL 64250 0 0
// if event = 102 then
59040: LD_VAR 0 1
59044: PUSH
59045: LD_INT 102
59047: EQUAL
59048: IFFALSE 59054
// MC_Heal ( ) ;
59050: CALL 65185 0 0
// if event = 103 then
59054: LD_VAR 0 1
59058: PUSH
59059: LD_INT 103
59061: EQUAL
59062: IFFALSE 59068
// MC_Build ( ) ;
59064: CALL 65607 0 0
// if event = 104 then
59068: LD_VAR 0 1
59072: PUSH
59073: LD_INT 104
59075: EQUAL
59076: IFFALSE 59082
// MC_TurretWeapon ( ) ;
59078: CALL 67241 0 0
// if event = 105 then
59082: LD_VAR 0 1
59086: PUSH
59087: LD_INT 105
59089: EQUAL
59090: IFFALSE 59096
// MC_BuildUpgrade ( ) ;
59092: CALL 66792 0 0
// if event = 106 then
59096: LD_VAR 0 1
59100: PUSH
59101: LD_INT 106
59103: EQUAL
59104: IFFALSE 59110
// MC_PlantMines ( ) ;
59106: CALL 67671 0 0
// if event = 107 then
59110: LD_VAR 0 1
59114: PUSH
59115: LD_INT 107
59117: EQUAL
59118: IFFALSE 59124
// MC_CollectCrates ( ) ;
59120: CALL 68469 0 0
// if event = 108 then
59124: LD_VAR 0 1
59128: PUSH
59129: LD_INT 108
59131: EQUAL
59132: IFFALSE 59138
// MC_LinkRemoteControl ( ) ;
59134: CALL 70319 0 0
// if event = 109 then
59138: LD_VAR 0 1
59142: PUSH
59143: LD_INT 109
59145: EQUAL
59146: IFFALSE 59152
// MC_ProduceVehicle ( ) ;
59148: CALL 70500 0 0
// if event = 110 then
59152: LD_VAR 0 1
59156: PUSH
59157: LD_INT 110
59159: EQUAL
59160: IFFALSE 59166
// MC_SendAttack ( ) ;
59162: CALL 70966 0 0
// if event = 111 then
59166: LD_VAR 0 1
59170: PUSH
59171: LD_INT 111
59173: EQUAL
59174: IFFALSE 59180
// MC_Defend ( ) ;
59176: CALL 71074 0 0
// if event = 112 then
59180: LD_VAR 0 1
59184: PUSH
59185: LD_INT 112
59187: EQUAL
59188: IFFALSE 59194
// MC_Research ( ) ;
59190: CALL 71954 0 0
// if event = 113 then
59194: LD_VAR 0 1
59198: PUSH
59199: LD_INT 113
59201: EQUAL
59202: IFFALSE 59208
// MC_MinesTrigger ( ) ;
59204: CALL 73068 0 0
// if event = 120 then
59208: LD_VAR 0 1
59212: PUSH
59213: LD_INT 120
59215: EQUAL
59216: IFFALSE 59222
// MC_RepairVehicle ( ) ;
59218: CALL 73167 0 0
// if event = 121 then
59222: LD_VAR 0 1
59226: PUSH
59227: LD_INT 121
59229: EQUAL
59230: IFFALSE 59236
// MC_TameApe ( ) ;
59232: CALL 73936 0 0
// if event = 122 then
59236: LD_VAR 0 1
59240: PUSH
59241: LD_INT 122
59243: EQUAL
59244: IFFALSE 59250
// MC_ChangeApeClass ( ) ;
59246: CALL 74765 0 0
// if event = 123 then
59250: LD_VAR 0 1
59254: PUSH
59255: LD_INT 123
59257: EQUAL
59258: IFFALSE 59264
// MC_Bazooka ( ) ;
59260: CALL 75415 0 0
// if event = 124 then
59264: LD_VAR 0 1
59268: PUSH
59269: LD_INT 124
59271: EQUAL
59272: IFFALSE 59278
// MC_TeleportExit ( ) ;
59274: CALL 75613 0 0
// if event = 125 then
59278: LD_VAR 0 1
59282: PUSH
59283: LD_INT 125
59285: EQUAL
59286: IFFALSE 59292
// MC_Deposits ( ) ;
59288: CALL 76260 0 0
// if event = 126 then
59292: LD_VAR 0 1
59296: PUSH
59297: LD_INT 126
59299: EQUAL
59300: IFFALSE 59306
// MC_RemoteDriver ( ) ;
59302: CALL 76885 0 0
// if event = 200 then
59306: LD_VAR 0 1
59310: PUSH
59311: LD_INT 200
59313: EQUAL
59314: IFFALSE 59320
// MC_Idle ( ) ;
59316: CALL 78792 0 0
// end ;
59320: PPOPN 1
59322: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59323: LD_INT 0
59325: PPUSH
59326: PPUSH
// if not mc_bases [ base ] or not tag then
59327: LD_EXP 50
59331: PUSH
59332: LD_VAR 0 1
59336: ARRAY
59337: NOT
59338: PUSH
59339: LD_VAR 0 2
59343: NOT
59344: OR
59345: IFFALSE 59349
// exit ;
59347: GO 59413
// for i in mc_bases [ base ] union mc_ape [ base ] do
59349: LD_ADDR_VAR 0 4
59353: PUSH
59354: LD_EXP 50
59358: PUSH
59359: LD_VAR 0 1
59363: ARRAY
59364: PUSH
59365: LD_EXP 79
59369: PUSH
59370: LD_VAR 0 1
59374: ARRAY
59375: UNION
59376: PUSH
59377: FOR_IN
59378: IFFALSE 59411
// if GetTag ( i ) = tag then
59380: LD_VAR 0 4
59384: PPUSH
59385: CALL_OW 110
59389: PUSH
59390: LD_VAR 0 2
59394: EQUAL
59395: IFFALSE 59409
// SetTag ( i , 0 ) ;
59397: LD_VAR 0 4
59401: PPUSH
59402: LD_INT 0
59404: PPUSH
59405: CALL_OW 109
59409: GO 59377
59411: POP
59412: POP
// end ;
59413: LD_VAR 0 3
59417: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59418: LD_INT 0
59420: PPUSH
59421: PPUSH
59422: PPUSH
59423: PPUSH
59424: PPUSH
59425: PPUSH
59426: PPUSH
59427: PPUSH
// if not mc_bases then
59428: LD_EXP 50
59432: NOT
59433: IFFALSE 59437
// exit ;
59435: GO 59886
// for i = 1 to mc_bases do
59437: LD_ADDR_VAR 0 2
59441: PUSH
59442: DOUBLE
59443: LD_INT 1
59445: DEC
59446: ST_TO_ADDR
59447: LD_EXP 50
59451: PUSH
59452: FOR_TO
59453: IFFALSE 59884
// begin tmp := MC_ClassCheckReq ( i ) ;
59455: LD_ADDR_VAR 0 4
59459: PUSH
59460: LD_VAR 0 2
59464: PPUSH
59465: CALL 59891 0 1
59469: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59470: LD_ADDR_EXP 91
59474: PUSH
59475: LD_EXP 91
59479: PPUSH
59480: LD_VAR 0 2
59484: PPUSH
59485: LD_VAR 0 4
59489: PPUSH
59490: CALL_OW 1
59494: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59495: LD_ADDR_VAR 0 6
59499: PUSH
59500: LD_EXP 50
59504: PUSH
59505: LD_VAR 0 2
59509: ARRAY
59510: PPUSH
59511: LD_INT 2
59513: PUSH
59514: LD_INT 30
59516: PUSH
59517: LD_INT 4
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 30
59526: PUSH
59527: LD_INT 5
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PUSH
59534: EMPTY
59535: LIST
59536: LIST
59537: LIST
59538: PPUSH
59539: CALL_OW 72
59543: PUSH
59544: LD_EXP 50
59548: PUSH
59549: LD_VAR 0 2
59553: ARRAY
59554: PPUSH
59555: LD_INT 2
59557: PUSH
59558: LD_INT 30
59560: PUSH
59561: LD_INT 0
59563: PUSH
59564: EMPTY
59565: LIST
59566: LIST
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_INT 1
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: PUSH
59578: EMPTY
59579: LIST
59580: LIST
59581: LIST
59582: PPUSH
59583: CALL_OW 72
59587: PUSH
59588: LD_EXP 50
59592: PUSH
59593: LD_VAR 0 2
59597: ARRAY
59598: PPUSH
59599: LD_INT 30
59601: PUSH
59602: LD_INT 3
59604: PUSH
59605: EMPTY
59606: LIST
59607: LIST
59608: PPUSH
59609: CALL_OW 72
59613: PUSH
59614: LD_EXP 50
59618: PUSH
59619: LD_VAR 0 2
59623: ARRAY
59624: PPUSH
59625: LD_INT 2
59627: PUSH
59628: LD_INT 30
59630: PUSH
59631: LD_INT 6
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: PUSH
59638: LD_INT 30
59640: PUSH
59641: LD_INT 7
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PUSH
59648: LD_INT 30
59650: PUSH
59651: LD_INT 8
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: LIST
59662: LIST
59663: PPUSH
59664: CALL_OW 72
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: LIST
59673: LIST
59674: ST_TO_ADDR
// for j := 1 to 4 do
59675: LD_ADDR_VAR 0 3
59679: PUSH
59680: DOUBLE
59681: LD_INT 1
59683: DEC
59684: ST_TO_ADDR
59685: LD_INT 4
59687: PUSH
59688: FOR_TO
59689: IFFALSE 59880
// begin if not tmp [ j ] then
59691: LD_VAR 0 4
59695: PUSH
59696: LD_VAR 0 3
59700: ARRAY
59701: NOT
59702: IFFALSE 59706
// continue ;
59704: GO 59688
// for p in tmp [ j ] do
59706: LD_ADDR_VAR 0 5
59710: PUSH
59711: LD_VAR 0 4
59715: PUSH
59716: LD_VAR 0 3
59720: ARRAY
59721: PUSH
59722: FOR_IN
59723: IFFALSE 59876
// begin if not b [ j ] then
59725: LD_VAR 0 6
59729: PUSH
59730: LD_VAR 0 3
59734: ARRAY
59735: NOT
59736: IFFALSE 59740
// break ;
59738: GO 59876
// e := 0 ;
59740: LD_ADDR_VAR 0 7
59744: PUSH
59745: LD_INT 0
59747: ST_TO_ADDR
// for k in b [ j ] do
59748: LD_ADDR_VAR 0 8
59752: PUSH
59753: LD_VAR 0 6
59757: PUSH
59758: LD_VAR 0 3
59762: ARRAY
59763: PUSH
59764: FOR_IN
59765: IFFALSE 59792
// if IsNotFull ( k ) then
59767: LD_VAR 0 8
59771: PPUSH
59772: CALL 15795 0 1
59776: IFFALSE 59790
// begin e := k ;
59778: LD_ADDR_VAR 0 7
59782: PUSH
59783: LD_VAR 0 8
59787: ST_TO_ADDR
// break ;
59788: GO 59792
// end ;
59790: GO 59764
59792: POP
59793: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59794: LD_VAR 0 7
59798: PUSH
59799: LD_VAR 0 5
59803: PPUSH
59804: LD_VAR 0 7
59808: PPUSH
59809: CALL 49577 0 2
59813: NOT
59814: AND
59815: IFFALSE 59874
// begin if IsInUnit ( p ) then
59817: LD_VAR 0 5
59821: PPUSH
59822: CALL_OW 310
59826: IFFALSE 59837
// ComExitBuilding ( p ) ;
59828: LD_VAR 0 5
59832: PPUSH
59833: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59837: LD_VAR 0 5
59841: PPUSH
59842: LD_VAR 0 7
59846: PPUSH
59847: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59851: LD_VAR 0 5
59855: PPUSH
59856: LD_VAR 0 3
59860: PPUSH
59861: CALL_OW 183
// AddComExitBuilding ( p ) ;
59865: LD_VAR 0 5
59869: PPUSH
59870: CALL_OW 182
// end ; end ;
59874: GO 59722
59876: POP
59877: POP
// end ;
59878: GO 59688
59880: POP
59881: POP
// end ;
59882: GO 59452
59884: POP
59885: POP
// end ;
59886: LD_VAR 0 1
59890: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59891: LD_INT 0
59893: PPUSH
59894: PPUSH
59895: PPUSH
59896: PPUSH
59897: PPUSH
59898: PPUSH
59899: PPUSH
59900: PPUSH
59901: PPUSH
59902: PPUSH
59903: PPUSH
59904: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59905: LD_ADDR_VAR 0 2
59909: PUSH
59910: LD_INT 0
59912: PUSH
59913: LD_INT 0
59915: PUSH
59916: LD_INT 0
59918: PUSH
59919: LD_INT 0
59921: PUSH
59922: EMPTY
59923: LIST
59924: LIST
59925: LIST
59926: LIST
59927: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59928: LD_VAR 0 1
59932: NOT
59933: PUSH
59934: LD_EXP 50
59938: PUSH
59939: LD_VAR 0 1
59943: ARRAY
59944: NOT
59945: OR
59946: PUSH
59947: LD_EXP 50
59951: PUSH
59952: LD_VAR 0 1
59956: ARRAY
59957: PPUSH
59958: LD_INT 2
59960: PUSH
59961: LD_INT 30
59963: PUSH
59964: LD_INT 0
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: PUSH
59971: LD_INT 30
59973: PUSH
59974: LD_INT 1
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PUSH
59981: EMPTY
59982: LIST
59983: LIST
59984: LIST
59985: PPUSH
59986: CALL_OW 72
59990: NOT
59991: OR
59992: IFFALSE 59996
// exit ;
59994: GO 63499
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59996: LD_ADDR_VAR 0 4
60000: PUSH
60001: LD_EXP 50
60005: PUSH
60006: LD_VAR 0 1
60010: ARRAY
60011: PPUSH
60012: LD_INT 2
60014: PUSH
60015: LD_INT 25
60017: PUSH
60018: LD_INT 1
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PUSH
60025: LD_INT 25
60027: PUSH
60028: LD_INT 2
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: PUSH
60035: LD_INT 25
60037: PUSH
60038: LD_INT 3
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: PUSH
60045: LD_INT 25
60047: PUSH
60048: LD_INT 4
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PUSH
60055: LD_INT 25
60057: PUSH
60058: LD_INT 5
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: PUSH
60065: LD_INT 25
60067: PUSH
60068: LD_INT 8
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PUSH
60075: LD_INT 25
60077: PUSH
60078: LD_INT 9
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: PUSH
60085: EMPTY
60086: LIST
60087: LIST
60088: LIST
60089: LIST
60090: LIST
60091: LIST
60092: LIST
60093: LIST
60094: PPUSH
60095: CALL_OW 72
60099: ST_TO_ADDR
// if not tmp then
60100: LD_VAR 0 4
60104: NOT
60105: IFFALSE 60109
// exit ;
60107: GO 63499
// for i in tmp do
60109: LD_ADDR_VAR 0 3
60113: PUSH
60114: LD_VAR 0 4
60118: PUSH
60119: FOR_IN
60120: IFFALSE 60151
// if GetTag ( i ) then
60122: LD_VAR 0 3
60126: PPUSH
60127: CALL_OW 110
60131: IFFALSE 60149
// tmp := tmp diff i ;
60133: LD_ADDR_VAR 0 4
60137: PUSH
60138: LD_VAR 0 4
60142: PUSH
60143: LD_VAR 0 3
60147: DIFF
60148: ST_TO_ADDR
60149: GO 60119
60151: POP
60152: POP
// if not tmp then
60153: LD_VAR 0 4
60157: NOT
60158: IFFALSE 60162
// exit ;
60160: GO 63499
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60162: LD_ADDR_VAR 0 5
60166: PUSH
60167: LD_EXP 50
60171: PUSH
60172: LD_VAR 0 1
60176: ARRAY
60177: PPUSH
60178: LD_INT 2
60180: PUSH
60181: LD_INT 25
60183: PUSH
60184: LD_INT 1
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 25
60193: PUSH
60194: LD_INT 5
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: LD_INT 25
60203: PUSH
60204: LD_INT 8
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PUSH
60211: LD_INT 25
60213: PUSH
60214: LD_INT 9
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: PPUSH
60228: CALL_OW 72
60232: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60233: LD_ADDR_VAR 0 6
60237: PUSH
60238: LD_EXP 50
60242: PUSH
60243: LD_VAR 0 1
60247: ARRAY
60248: PPUSH
60249: LD_INT 25
60251: PUSH
60252: LD_INT 2
60254: PUSH
60255: EMPTY
60256: LIST
60257: LIST
60258: PPUSH
60259: CALL_OW 72
60263: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60264: LD_ADDR_VAR 0 7
60268: PUSH
60269: LD_EXP 50
60273: PUSH
60274: LD_VAR 0 1
60278: ARRAY
60279: PPUSH
60280: LD_INT 25
60282: PUSH
60283: LD_INT 3
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PPUSH
60290: CALL_OW 72
60294: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60295: LD_ADDR_VAR 0 8
60299: PUSH
60300: LD_EXP 50
60304: PUSH
60305: LD_VAR 0 1
60309: ARRAY
60310: PPUSH
60311: LD_INT 25
60313: PUSH
60314: LD_INT 4
60316: PUSH
60317: EMPTY
60318: LIST
60319: LIST
60320: PUSH
60321: LD_INT 24
60323: PUSH
60324: LD_INT 251
60326: PUSH
60327: EMPTY
60328: LIST
60329: LIST
60330: PUSH
60331: EMPTY
60332: LIST
60333: LIST
60334: PPUSH
60335: CALL_OW 72
60339: ST_TO_ADDR
// if mc_is_defending [ base ] then
60340: LD_EXP 93
60344: PUSH
60345: LD_VAR 0 1
60349: ARRAY
60350: IFFALSE 60811
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60352: LD_ADDR_EXP 92
60356: PUSH
60357: LD_EXP 92
60361: PPUSH
60362: LD_VAR 0 1
60366: PPUSH
60367: LD_INT 4
60369: PPUSH
60370: CALL_OW 1
60374: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60375: LD_ADDR_VAR 0 12
60379: PUSH
60380: LD_EXP 50
60384: PUSH
60385: LD_VAR 0 1
60389: ARRAY
60390: PPUSH
60391: LD_INT 2
60393: PUSH
60394: LD_INT 30
60396: PUSH
60397: LD_INT 4
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: LD_INT 30
60406: PUSH
60407: LD_INT 5
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: LIST
60418: PPUSH
60419: CALL_OW 72
60423: ST_TO_ADDR
// if not b then
60424: LD_VAR 0 12
60428: NOT
60429: IFFALSE 60433
// exit ;
60431: GO 63499
// p := [ ] ;
60433: LD_ADDR_VAR 0 11
60437: PUSH
60438: EMPTY
60439: ST_TO_ADDR
// if sci >= 2 then
60440: LD_VAR 0 8
60444: PUSH
60445: LD_INT 2
60447: GREATEREQUAL
60448: IFFALSE 60479
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60450: LD_ADDR_VAR 0 8
60454: PUSH
60455: LD_VAR 0 8
60459: PUSH
60460: LD_INT 1
60462: ARRAY
60463: PUSH
60464: LD_VAR 0 8
60468: PUSH
60469: LD_INT 2
60471: ARRAY
60472: PUSH
60473: EMPTY
60474: LIST
60475: LIST
60476: ST_TO_ADDR
60477: GO 60540
// if sci = 1 then
60479: LD_VAR 0 8
60483: PUSH
60484: LD_INT 1
60486: EQUAL
60487: IFFALSE 60508
// sci := [ sci [ 1 ] ] else
60489: LD_ADDR_VAR 0 8
60493: PUSH
60494: LD_VAR 0 8
60498: PUSH
60499: LD_INT 1
60501: ARRAY
60502: PUSH
60503: EMPTY
60504: LIST
60505: ST_TO_ADDR
60506: GO 60540
// if sci = 0 then
60508: LD_VAR 0 8
60512: PUSH
60513: LD_INT 0
60515: EQUAL
60516: IFFALSE 60540
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60518: LD_ADDR_VAR 0 11
60522: PUSH
60523: LD_VAR 0 4
60527: PPUSH
60528: LD_INT 4
60530: PPUSH
60531: CALL 49449 0 2
60535: PUSH
60536: LD_INT 1
60538: ARRAY
60539: ST_TO_ADDR
// if eng > 4 then
60540: LD_VAR 0 6
60544: PUSH
60545: LD_INT 4
60547: GREATER
60548: IFFALSE 60594
// for i = eng downto 4 do
60550: LD_ADDR_VAR 0 3
60554: PUSH
60555: DOUBLE
60556: LD_VAR 0 6
60560: INC
60561: ST_TO_ADDR
60562: LD_INT 4
60564: PUSH
60565: FOR_DOWNTO
60566: IFFALSE 60592
// eng := eng diff eng [ i ] ;
60568: LD_ADDR_VAR 0 6
60572: PUSH
60573: LD_VAR 0 6
60577: PUSH
60578: LD_VAR 0 6
60582: PUSH
60583: LD_VAR 0 3
60587: ARRAY
60588: DIFF
60589: ST_TO_ADDR
60590: GO 60565
60592: POP
60593: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60594: LD_ADDR_VAR 0 4
60598: PUSH
60599: LD_VAR 0 4
60603: PUSH
60604: LD_VAR 0 5
60608: PUSH
60609: LD_VAR 0 6
60613: UNION
60614: PUSH
60615: LD_VAR 0 7
60619: UNION
60620: PUSH
60621: LD_VAR 0 8
60625: UNION
60626: DIFF
60627: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60628: LD_ADDR_VAR 0 13
60632: PUSH
60633: LD_EXP 50
60637: PUSH
60638: LD_VAR 0 1
60642: ARRAY
60643: PPUSH
60644: LD_INT 2
60646: PUSH
60647: LD_INT 30
60649: PUSH
60650: LD_INT 32
60652: PUSH
60653: EMPTY
60654: LIST
60655: LIST
60656: PUSH
60657: LD_INT 30
60659: PUSH
60660: LD_INT 31
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: EMPTY
60668: LIST
60669: LIST
60670: LIST
60671: PPUSH
60672: CALL_OW 72
60676: PUSH
60677: LD_EXP 50
60681: PUSH
60682: LD_VAR 0 1
60686: ARRAY
60687: PPUSH
60688: LD_INT 2
60690: PUSH
60691: LD_INT 30
60693: PUSH
60694: LD_INT 4
60696: PUSH
60697: EMPTY
60698: LIST
60699: LIST
60700: PUSH
60701: LD_INT 30
60703: PUSH
60704: LD_INT 5
60706: PUSH
60707: EMPTY
60708: LIST
60709: LIST
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: LIST
60715: PPUSH
60716: CALL_OW 72
60720: PUSH
60721: LD_INT 6
60723: MUL
60724: PLUS
60725: ST_TO_ADDR
// if bcount < tmp then
60726: LD_VAR 0 13
60730: PUSH
60731: LD_VAR 0 4
60735: LESS
60736: IFFALSE 60782
// for i = tmp downto bcount do
60738: LD_ADDR_VAR 0 3
60742: PUSH
60743: DOUBLE
60744: LD_VAR 0 4
60748: INC
60749: ST_TO_ADDR
60750: LD_VAR 0 13
60754: PUSH
60755: FOR_DOWNTO
60756: IFFALSE 60780
// tmp := Delete ( tmp , tmp ) ;
60758: LD_ADDR_VAR 0 4
60762: PUSH
60763: LD_VAR 0 4
60767: PPUSH
60768: LD_VAR 0 4
60772: PPUSH
60773: CALL_OW 3
60777: ST_TO_ADDR
60778: GO 60755
60780: POP
60781: POP
// result := [ tmp , 0 , 0 , p ] ;
60782: LD_ADDR_VAR 0 2
60786: PUSH
60787: LD_VAR 0 4
60791: PUSH
60792: LD_INT 0
60794: PUSH
60795: LD_INT 0
60797: PUSH
60798: LD_VAR 0 11
60802: PUSH
60803: EMPTY
60804: LIST
60805: LIST
60806: LIST
60807: LIST
60808: ST_TO_ADDR
// exit ;
60809: GO 63499
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60811: LD_EXP 50
60815: PUSH
60816: LD_VAR 0 1
60820: ARRAY
60821: PPUSH
60822: LD_INT 2
60824: PUSH
60825: LD_INT 30
60827: PUSH
60828: LD_INT 6
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PUSH
60835: LD_INT 30
60837: PUSH
60838: LD_INT 7
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: PUSH
60845: LD_INT 30
60847: PUSH
60848: LD_INT 8
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PUSH
60855: EMPTY
60856: LIST
60857: LIST
60858: LIST
60859: LIST
60860: PPUSH
60861: CALL_OW 72
60865: NOT
60866: PUSH
60867: LD_EXP 50
60871: PUSH
60872: LD_VAR 0 1
60876: ARRAY
60877: PPUSH
60878: LD_INT 30
60880: PUSH
60881: LD_INT 3
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: PPUSH
60888: CALL_OW 72
60892: NOT
60893: AND
60894: IFFALSE 60966
// begin if eng = tmp then
60896: LD_VAR 0 6
60900: PUSH
60901: LD_VAR 0 4
60905: EQUAL
60906: IFFALSE 60910
// exit ;
60908: GO 63499
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60910: LD_ADDR_EXP 92
60914: PUSH
60915: LD_EXP 92
60919: PPUSH
60920: LD_VAR 0 1
60924: PPUSH
60925: LD_INT 1
60927: PPUSH
60928: CALL_OW 1
60932: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60933: LD_ADDR_VAR 0 2
60937: PUSH
60938: LD_INT 0
60940: PUSH
60941: LD_VAR 0 4
60945: PUSH
60946: LD_VAR 0 6
60950: DIFF
60951: PUSH
60952: LD_INT 0
60954: PUSH
60955: LD_INT 0
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: LIST
60962: LIST
60963: ST_TO_ADDR
// exit ;
60964: GO 63499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60966: LD_EXP 77
60970: PUSH
60971: LD_EXP 76
60975: PUSH
60976: LD_VAR 0 1
60980: ARRAY
60981: ARRAY
60982: PUSH
60983: LD_EXP 50
60987: PUSH
60988: LD_VAR 0 1
60992: ARRAY
60993: PPUSH
60994: LD_INT 2
60996: PUSH
60997: LD_INT 30
60999: PUSH
61000: LD_INT 6
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 30
61009: PUSH
61010: LD_INT 7
61012: PUSH
61013: EMPTY
61014: LIST
61015: LIST
61016: PUSH
61017: LD_INT 30
61019: PUSH
61020: LD_INT 8
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: PPUSH
61033: CALL_OW 72
61037: AND
61038: PUSH
61039: LD_EXP 50
61043: PUSH
61044: LD_VAR 0 1
61048: ARRAY
61049: PPUSH
61050: LD_INT 30
61052: PUSH
61053: LD_INT 3
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: PPUSH
61060: CALL_OW 72
61064: NOT
61065: AND
61066: IFFALSE 61280
// begin if sci >= 6 then
61068: LD_VAR 0 8
61072: PUSH
61073: LD_INT 6
61075: GREATEREQUAL
61076: IFFALSE 61080
// exit ;
61078: GO 63499
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61080: LD_ADDR_EXP 92
61084: PUSH
61085: LD_EXP 92
61089: PPUSH
61090: LD_VAR 0 1
61094: PPUSH
61095: LD_INT 2
61097: PPUSH
61098: CALL_OW 1
61102: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61103: LD_ADDR_VAR 0 9
61107: PUSH
61108: LD_VAR 0 4
61112: PUSH
61113: LD_VAR 0 8
61117: DIFF
61118: PPUSH
61119: LD_INT 4
61121: PPUSH
61122: CALL 49449 0 2
61126: ST_TO_ADDR
// p := [ ] ;
61127: LD_ADDR_VAR 0 11
61131: PUSH
61132: EMPTY
61133: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61134: LD_VAR 0 8
61138: PUSH
61139: LD_INT 6
61141: LESS
61142: PUSH
61143: LD_VAR 0 9
61147: PUSH
61148: LD_INT 6
61150: GREATER
61151: AND
61152: IFFALSE 61233
// begin for i = 1 to 6 - sci do
61154: LD_ADDR_VAR 0 3
61158: PUSH
61159: DOUBLE
61160: LD_INT 1
61162: DEC
61163: ST_TO_ADDR
61164: LD_INT 6
61166: PUSH
61167: LD_VAR 0 8
61171: MINUS
61172: PUSH
61173: FOR_TO
61174: IFFALSE 61229
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61176: LD_ADDR_VAR 0 11
61180: PUSH
61181: LD_VAR 0 11
61185: PPUSH
61186: LD_VAR 0 11
61190: PUSH
61191: LD_INT 1
61193: PLUS
61194: PPUSH
61195: LD_VAR 0 9
61199: PUSH
61200: LD_INT 1
61202: ARRAY
61203: PPUSH
61204: CALL_OW 2
61208: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61209: LD_ADDR_VAR 0 9
61213: PUSH
61214: LD_VAR 0 9
61218: PPUSH
61219: LD_INT 1
61221: PPUSH
61222: CALL_OW 3
61226: ST_TO_ADDR
// end ;
61227: GO 61173
61229: POP
61230: POP
// end else
61231: GO 61253
// if sort then
61233: LD_VAR 0 9
61237: IFFALSE 61253
// p := sort [ 1 ] ;
61239: LD_ADDR_VAR 0 11
61243: PUSH
61244: LD_VAR 0 9
61248: PUSH
61249: LD_INT 1
61251: ARRAY
61252: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61253: LD_ADDR_VAR 0 2
61257: PUSH
61258: LD_INT 0
61260: PUSH
61261: LD_INT 0
61263: PUSH
61264: LD_INT 0
61266: PUSH
61267: LD_VAR 0 11
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: LIST
61276: LIST
61277: ST_TO_ADDR
// exit ;
61278: GO 63499
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61280: LD_EXP 77
61284: PUSH
61285: LD_EXP 76
61289: PUSH
61290: LD_VAR 0 1
61294: ARRAY
61295: ARRAY
61296: PUSH
61297: LD_EXP 50
61301: PUSH
61302: LD_VAR 0 1
61306: ARRAY
61307: PPUSH
61308: LD_INT 2
61310: PUSH
61311: LD_INT 30
61313: PUSH
61314: LD_INT 6
61316: PUSH
61317: EMPTY
61318: LIST
61319: LIST
61320: PUSH
61321: LD_INT 30
61323: PUSH
61324: LD_INT 7
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: LD_INT 30
61333: PUSH
61334: LD_INT 8
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: LIST
61345: LIST
61346: PPUSH
61347: CALL_OW 72
61351: AND
61352: PUSH
61353: LD_EXP 50
61357: PUSH
61358: LD_VAR 0 1
61362: ARRAY
61363: PPUSH
61364: LD_INT 30
61366: PUSH
61367: LD_INT 3
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: PPUSH
61374: CALL_OW 72
61378: AND
61379: IFFALSE 62113
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61381: LD_ADDR_EXP 92
61385: PUSH
61386: LD_EXP 92
61390: PPUSH
61391: LD_VAR 0 1
61395: PPUSH
61396: LD_INT 3
61398: PPUSH
61399: CALL_OW 1
61403: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61404: LD_ADDR_VAR 0 2
61408: PUSH
61409: LD_INT 0
61411: PUSH
61412: LD_INT 0
61414: PUSH
61415: LD_INT 0
61417: PUSH
61418: LD_INT 0
61420: PUSH
61421: EMPTY
61422: LIST
61423: LIST
61424: LIST
61425: LIST
61426: ST_TO_ADDR
// if not eng then
61427: LD_VAR 0 6
61431: NOT
61432: IFFALSE 61495
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61434: LD_ADDR_VAR 0 11
61438: PUSH
61439: LD_VAR 0 4
61443: PPUSH
61444: LD_INT 2
61446: PPUSH
61447: CALL 49449 0 2
61451: PUSH
61452: LD_INT 1
61454: ARRAY
61455: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61456: LD_ADDR_VAR 0 2
61460: PUSH
61461: LD_VAR 0 2
61465: PPUSH
61466: LD_INT 2
61468: PPUSH
61469: LD_VAR 0 11
61473: PPUSH
61474: CALL_OW 1
61478: ST_TO_ADDR
// tmp := tmp diff p ;
61479: LD_ADDR_VAR 0 4
61483: PUSH
61484: LD_VAR 0 4
61488: PUSH
61489: LD_VAR 0 11
61493: DIFF
61494: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61495: LD_VAR 0 4
61499: PUSH
61500: LD_VAR 0 8
61504: PUSH
61505: LD_INT 6
61507: LESS
61508: AND
61509: IFFALSE 61697
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61511: LD_ADDR_VAR 0 9
61515: PUSH
61516: LD_VAR 0 4
61520: PUSH
61521: LD_VAR 0 8
61525: PUSH
61526: LD_VAR 0 7
61530: UNION
61531: DIFF
61532: PPUSH
61533: LD_INT 4
61535: PPUSH
61536: CALL 49449 0 2
61540: ST_TO_ADDR
// p := [ ] ;
61541: LD_ADDR_VAR 0 11
61545: PUSH
61546: EMPTY
61547: ST_TO_ADDR
// if sort then
61548: LD_VAR 0 9
61552: IFFALSE 61668
// for i = 1 to 6 - sci do
61554: LD_ADDR_VAR 0 3
61558: PUSH
61559: DOUBLE
61560: LD_INT 1
61562: DEC
61563: ST_TO_ADDR
61564: LD_INT 6
61566: PUSH
61567: LD_VAR 0 8
61571: MINUS
61572: PUSH
61573: FOR_TO
61574: IFFALSE 61666
// begin if i = sort then
61576: LD_VAR 0 3
61580: PUSH
61581: LD_VAR 0 9
61585: EQUAL
61586: IFFALSE 61590
// break ;
61588: GO 61666
// if GetClass ( i ) = 4 then
61590: LD_VAR 0 3
61594: PPUSH
61595: CALL_OW 257
61599: PUSH
61600: LD_INT 4
61602: EQUAL
61603: IFFALSE 61607
// continue ;
61605: GO 61573
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61607: LD_ADDR_VAR 0 11
61611: PUSH
61612: LD_VAR 0 11
61616: PPUSH
61617: LD_VAR 0 11
61621: PUSH
61622: LD_INT 1
61624: PLUS
61625: PPUSH
61626: LD_VAR 0 9
61630: PUSH
61631: LD_VAR 0 3
61635: ARRAY
61636: PPUSH
61637: CALL_OW 2
61641: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61642: LD_ADDR_VAR 0 4
61646: PUSH
61647: LD_VAR 0 4
61651: PUSH
61652: LD_VAR 0 9
61656: PUSH
61657: LD_VAR 0 3
61661: ARRAY
61662: DIFF
61663: ST_TO_ADDR
// end ;
61664: GO 61573
61666: POP
61667: POP
// if p then
61668: LD_VAR 0 11
61672: IFFALSE 61697
// result := Replace ( result , 4 , p ) ;
61674: LD_ADDR_VAR 0 2
61678: PUSH
61679: LD_VAR 0 2
61683: PPUSH
61684: LD_INT 4
61686: PPUSH
61687: LD_VAR 0 11
61691: PPUSH
61692: CALL_OW 1
61696: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61697: LD_VAR 0 4
61701: PUSH
61702: LD_VAR 0 7
61706: PUSH
61707: LD_INT 6
61709: LESS
61710: AND
61711: IFFALSE 61899
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61713: LD_ADDR_VAR 0 9
61717: PUSH
61718: LD_VAR 0 4
61722: PUSH
61723: LD_VAR 0 8
61727: PUSH
61728: LD_VAR 0 7
61732: UNION
61733: DIFF
61734: PPUSH
61735: LD_INT 3
61737: PPUSH
61738: CALL 49449 0 2
61742: ST_TO_ADDR
// p := [ ] ;
61743: LD_ADDR_VAR 0 11
61747: PUSH
61748: EMPTY
61749: ST_TO_ADDR
// if sort then
61750: LD_VAR 0 9
61754: IFFALSE 61870
// for i = 1 to 6 - mech do
61756: LD_ADDR_VAR 0 3
61760: PUSH
61761: DOUBLE
61762: LD_INT 1
61764: DEC
61765: ST_TO_ADDR
61766: LD_INT 6
61768: PUSH
61769: LD_VAR 0 7
61773: MINUS
61774: PUSH
61775: FOR_TO
61776: IFFALSE 61868
// begin if i = sort then
61778: LD_VAR 0 3
61782: PUSH
61783: LD_VAR 0 9
61787: EQUAL
61788: IFFALSE 61792
// break ;
61790: GO 61868
// if GetClass ( i ) = 3 then
61792: LD_VAR 0 3
61796: PPUSH
61797: CALL_OW 257
61801: PUSH
61802: LD_INT 3
61804: EQUAL
61805: IFFALSE 61809
// continue ;
61807: GO 61775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61809: LD_ADDR_VAR 0 11
61813: PUSH
61814: LD_VAR 0 11
61818: PPUSH
61819: LD_VAR 0 11
61823: PUSH
61824: LD_INT 1
61826: PLUS
61827: PPUSH
61828: LD_VAR 0 9
61832: PUSH
61833: LD_VAR 0 3
61837: ARRAY
61838: PPUSH
61839: CALL_OW 2
61843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61844: LD_ADDR_VAR 0 4
61848: PUSH
61849: LD_VAR 0 4
61853: PUSH
61854: LD_VAR 0 9
61858: PUSH
61859: LD_VAR 0 3
61863: ARRAY
61864: DIFF
61865: ST_TO_ADDR
// end ;
61866: GO 61775
61868: POP
61869: POP
// if p then
61870: LD_VAR 0 11
61874: IFFALSE 61899
// result := Replace ( result , 3 , p ) ;
61876: LD_ADDR_VAR 0 2
61880: PUSH
61881: LD_VAR 0 2
61885: PPUSH
61886: LD_INT 3
61888: PPUSH
61889: LD_VAR 0 11
61893: PPUSH
61894: CALL_OW 1
61898: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61899: LD_VAR 0 4
61903: PUSH
61904: LD_INT 6
61906: GREATER
61907: PUSH
61908: LD_VAR 0 6
61912: PUSH
61913: LD_INT 6
61915: LESS
61916: AND
61917: IFFALSE 62111
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61919: LD_ADDR_VAR 0 9
61923: PUSH
61924: LD_VAR 0 4
61928: PUSH
61929: LD_VAR 0 8
61933: PUSH
61934: LD_VAR 0 7
61938: UNION
61939: PUSH
61940: LD_VAR 0 6
61944: UNION
61945: DIFF
61946: PPUSH
61947: LD_INT 2
61949: PPUSH
61950: CALL 49449 0 2
61954: ST_TO_ADDR
// p := [ ] ;
61955: LD_ADDR_VAR 0 11
61959: PUSH
61960: EMPTY
61961: ST_TO_ADDR
// if sort then
61962: LD_VAR 0 9
61966: IFFALSE 62082
// for i = 1 to 6 - eng do
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: DOUBLE
61974: LD_INT 1
61976: DEC
61977: ST_TO_ADDR
61978: LD_INT 6
61980: PUSH
61981: LD_VAR 0 6
61985: MINUS
61986: PUSH
61987: FOR_TO
61988: IFFALSE 62080
// begin if i = sort then
61990: LD_VAR 0 3
61994: PUSH
61995: LD_VAR 0 9
61999: EQUAL
62000: IFFALSE 62004
// break ;
62002: GO 62080
// if GetClass ( i ) = 2 then
62004: LD_VAR 0 3
62008: PPUSH
62009: CALL_OW 257
62013: PUSH
62014: LD_INT 2
62016: EQUAL
62017: IFFALSE 62021
// continue ;
62019: GO 61987
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62021: LD_ADDR_VAR 0 11
62025: PUSH
62026: LD_VAR 0 11
62030: PPUSH
62031: LD_VAR 0 11
62035: PUSH
62036: LD_INT 1
62038: PLUS
62039: PPUSH
62040: LD_VAR 0 9
62044: PUSH
62045: LD_VAR 0 3
62049: ARRAY
62050: PPUSH
62051: CALL_OW 2
62055: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62056: LD_ADDR_VAR 0 4
62060: PUSH
62061: LD_VAR 0 4
62065: PUSH
62066: LD_VAR 0 9
62070: PUSH
62071: LD_VAR 0 3
62075: ARRAY
62076: DIFF
62077: ST_TO_ADDR
// end ;
62078: GO 61987
62080: POP
62081: POP
// if p then
62082: LD_VAR 0 11
62086: IFFALSE 62111
// result := Replace ( result , 2 , p ) ;
62088: LD_ADDR_VAR 0 2
62092: PUSH
62093: LD_VAR 0 2
62097: PPUSH
62098: LD_INT 2
62100: PPUSH
62101: LD_VAR 0 11
62105: PPUSH
62106: CALL_OW 1
62110: ST_TO_ADDR
// end ; exit ;
62111: GO 63499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62113: LD_EXP 77
62117: PUSH
62118: LD_EXP 76
62122: PUSH
62123: LD_VAR 0 1
62127: ARRAY
62128: ARRAY
62129: NOT
62130: PUSH
62131: LD_EXP 50
62135: PUSH
62136: LD_VAR 0 1
62140: ARRAY
62141: PPUSH
62142: LD_INT 30
62144: PUSH
62145: LD_INT 3
62147: PUSH
62148: EMPTY
62149: LIST
62150: LIST
62151: PPUSH
62152: CALL_OW 72
62156: AND
62157: PUSH
62158: LD_EXP 55
62162: PUSH
62163: LD_VAR 0 1
62167: ARRAY
62168: AND
62169: IFFALSE 62777
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62171: LD_ADDR_EXP 92
62175: PUSH
62176: LD_EXP 92
62180: PPUSH
62181: LD_VAR 0 1
62185: PPUSH
62186: LD_INT 5
62188: PPUSH
62189: CALL_OW 1
62193: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62194: LD_ADDR_VAR 0 2
62198: PUSH
62199: LD_INT 0
62201: PUSH
62202: LD_INT 0
62204: PUSH
62205: LD_INT 0
62207: PUSH
62208: LD_INT 0
62210: PUSH
62211: EMPTY
62212: LIST
62213: LIST
62214: LIST
62215: LIST
62216: ST_TO_ADDR
// if sci > 1 then
62217: LD_VAR 0 8
62221: PUSH
62222: LD_INT 1
62224: GREATER
62225: IFFALSE 62253
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62227: LD_ADDR_VAR 0 4
62231: PUSH
62232: LD_VAR 0 4
62236: PUSH
62237: LD_VAR 0 8
62241: PUSH
62242: LD_VAR 0 8
62246: PUSH
62247: LD_INT 1
62249: ARRAY
62250: DIFF
62251: DIFF
62252: ST_TO_ADDR
// if tmp and not sci then
62253: LD_VAR 0 4
62257: PUSH
62258: LD_VAR 0 8
62262: NOT
62263: AND
62264: IFFALSE 62333
// begin sort := SortBySkill ( tmp , 4 ) ;
62266: LD_ADDR_VAR 0 9
62270: PUSH
62271: LD_VAR 0 4
62275: PPUSH
62276: LD_INT 4
62278: PPUSH
62279: CALL 49449 0 2
62283: ST_TO_ADDR
// if sort then
62284: LD_VAR 0 9
62288: IFFALSE 62304
// p := sort [ 1 ] ;
62290: LD_ADDR_VAR 0 11
62294: PUSH
62295: LD_VAR 0 9
62299: PUSH
62300: LD_INT 1
62302: ARRAY
62303: ST_TO_ADDR
// if p then
62304: LD_VAR 0 11
62308: IFFALSE 62333
// result := Replace ( result , 4 , p ) ;
62310: LD_ADDR_VAR 0 2
62314: PUSH
62315: LD_VAR 0 2
62319: PPUSH
62320: LD_INT 4
62322: PPUSH
62323: LD_VAR 0 11
62327: PPUSH
62328: CALL_OW 1
62332: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62333: LD_ADDR_VAR 0 4
62337: PUSH
62338: LD_VAR 0 4
62342: PUSH
62343: LD_VAR 0 7
62347: DIFF
62348: ST_TO_ADDR
// if tmp and mech < 6 then
62349: LD_VAR 0 4
62353: PUSH
62354: LD_VAR 0 7
62358: PUSH
62359: LD_INT 6
62361: LESS
62362: AND
62363: IFFALSE 62551
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62365: LD_ADDR_VAR 0 9
62369: PUSH
62370: LD_VAR 0 4
62374: PUSH
62375: LD_VAR 0 8
62379: PUSH
62380: LD_VAR 0 7
62384: UNION
62385: DIFF
62386: PPUSH
62387: LD_INT 3
62389: PPUSH
62390: CALL 49449 0 2
62394: ST_TO_ADDR
// p := [ ] ;
62395: LD_ADDR_VAR 0 11
62399: PUSH
62400: EMPTY
62401: ST_TO_ADDR
// if sort then
62402: LD_VAR 0 9
62406: IFFALSE 62522
// for i = 1 to 6 - mech do
62408: LD_ADDR_VAR 0 3
62412: PUSH
62413: DOUBLE
62414: LD_INT 1
62416: DEC
62417: ST_TO_ADDR
62418: LD_INT 6
62420: PUSH
62421: LD_VAR 0 7
62425: MINUS
62426: PUSH
62427: FOR_TO
62428: IFFALSE 62520
// begin if i = sort then
62430: LD_VAR 0 3
62434: PUSH
62435: LD_VAR 0 9
62439: EQUAL
62440: IFFALSE 62444
// break ;
62442: GO 62520
// if GetClass ( i ) = 3 then
62444: LD_VAR 0 3
62448: PPUSH
62449: CALL_OW 257
62453: PUSH
62454: LD_INT 3
62456: EQUAL
62457: IFFALSE 62461
// continue ;
62459: GO 62427
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62461: LD_ADDR_VAR 0 11
62465: PUSH
62466: LD_VAR 0 11
62470: PPUSH
62471: LD_VAR 0 11
62475: PUSH
62476: LD_INT 1
62478: PLUS
62479: PPUSH
62480: LD_VAR 0 9
62484: PUSH
62485: LD_VAR 0 3
62489: ARRAY
62490: PPUSH
62491: CALL_OW 2
62495: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62496: LD_ADDR_VAR 0 4
62500: PUSH
62501: LD_VAR 0 4
62505: PUSH
62506: LD_VAR 0 9
62510: PUSH
62511: LD_VAR 0 3
62515: ARRAY
62516: DIFF
62517: ST_TO_ADDR
// end ;
62518: GO 62427
62520: POP
62521: POP
// if p then
62522: LD_VAR 0 11
62526: IFFALSE 62551
// result := Replace ( result , 3 , p ) ;
62528: LD_ADDR_VAR 0 2
62532: PUSH
62533: LD_VAR 0 2
62537: PPUSH
62538: LD_INT 3
62540: PPUSH
62541: LD_VAR 0 11
62545: PPUSH
62546: CALL_OW 1
62550: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62551: LD_ADDR_VAR 0 4
62555: PUSH
62556: LD_VAR 0 4
62560: PUSH
62561: LD_VAR 0 6
62565: DIFF
62566: ST_TO_ADDR
// if tmp and eng < 6 then
62567: LD_VAR 0 4
62571: PUSH
62572: LD_VAR 0 6
62576: PUSH
62577: LD_INT 6
62579: LESS
62580: AND
62581: IFFALSE 62775
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62583: LD_ADDR_VAR 0 9
62587: PUSH
62588: LD_VAR 0 4
62592: PUSH
62593: LD_VAR 0 8
62597: PUSH
62598: LD_VAR 0 7
62602: UNION
62603: PUSH
62604: LD_VAR 0 6
62608: UNION
62609: DIFF
62610: PPUSH
62611: LD_INT 2
62613: PPUSH
62614: CALL 49449 0 2
62618: ST_TO_ADDR
// p := [ ] ;
62619: LD_ADDR_VAR 0 11
62623: PUSH
62624: EMPTY
62625: ST_TO_ADDR
// if sort then
62626: LD_VAR 0 9
62630: IFFALSE 62746
// for i = 1 to 6 - eng do
62632: LD_ADDR_VAR 0 3
62636: PUSH
62637: DOUBLE
62638: LD_INT 1
62640: DEC
62641: ST_TO_ADDR
62642: LD_INT 6
62644: PUSH
62645: LD_VAR 0 6
62649: MINUS
62650: PUSH
62651: FOR_TO
62652: IFFALSE 62744
// begin if i = sort then
62654: LD_VAR 0 3
62658: PUSH
62659: LD_VAR 0 9
62663: EQUAL
62664: IFFALSE 62668
// break ;
62666: GO 62744
// if GetClass ( i ) = 2 then
62668: LD_VAR 0 3
62672: PPUSH
62673: CALL_OW 257
62677: PUSH
62678: LD_INT 2
62680: EQUAL
62681: IFFALSE 62685
// continue ;
62683: GO 62651
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62685: LD_ADDR_VAR 0 11
62689: PUSH
62690: LD_VAR 0 11
62694: PPUSH
62695: LD_VAR 0 11
62699: PUSH
62700: LD_INT 1
62702: PLUS
62703: PPUSH
62704: LD_VAR 0 9
62708: PUSH
62709: LD_VAR 0 3
62713: ARRAY
62714: PPUSH
62715: CALL_OW 2
62719: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62720: LD_ADDR_VAR 0 4
62724: PUSH
62725: LD_VAR 0 4
62729: PUSH
62730: LD_VAR 0 9
62734: PUSH
62735: LD_VAR 0 3
62739: ARRAY
62740: DIFF
62741: ST_TO_ADDR
// end ;
62742: GO 62651
62744: POP
62745: POP
// if p then
62746: LD_VAR 0 11
62750: IFFALSE 62775
// result := Replace ( result , 2 , p ) ;
62752: LD_ADDR_VAR 0 2
62756: PUSH
62757: LD_VAR 0 2
62761: PPUSH
62762: LD_INT 2
62764: PPUSH
62765: LD_VAR 0 11
62769: PPUSH
62770: CALL_OW 1
62774: ST_TO_ADDR
// end ; exit ;
62775: GO 63499
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62777: LD_EXP 77
62781: PUSH
62782: LD_EXP 76
62786: PUSH
62787: LD_VAR 0 1
62791: ARRAY
62792: ARRAY
62793: NOT
62794: PUSH
62795: LD_EXP 50
62799: PUSH
62800: LD_VAR 0 1
62804: ARRAY
62805: PPUSH
62806: LD_INT 30
62808: PUSH
62809: LD_INT 3
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PPUSH
62816: CALL_OW 72
62820: AND
62821: PUSH
62822: LD_EXP 55
62826: PUSH
62827: LD_VAR 0 1
62831: ARRAY
62832: NOT
62833: AND
62834: IFFALSE 63499
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62836: LD_ADDR_EXP 92
62840: PUSH
62841: LD_EXP 92
62845: PPUSH
62846: LD_VAR 0 1
62850: PPUSH
62851: LD_INT 6
62853: PPUSH
62854: CALL_OW 1
62858: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62859: LD_ADDR_VAR 0 2
62863: PUSH
62864: LD_INT 0
62866: PUSH
62867: LD_INT 0
62869: PUSH
62870: LD_INT 0
62872: PUSH
62873: LD_INT 0
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: LIST
62880: LIST
62881: ST_TO_ADDR
// if sci >= 1 then
62882: LD_VAR 0 8
62886: PUSH
62887: LD_INT 1
62889: GREATEREQUAL
62890: IFFALSE 62912
// tmp := tmp diff sci [ 1 ] ;
62892: LD_ADDR_VAR 0 4
62896: PUSH
62897: LD_VAR 0 4
62901: PUSH
62902: LD_VAR 0 8
62906: PUSH
62907: LD_INT 1
62909: ARRAY
62910: DIFF
62911: ST_TO_ADDR
// if tmp and not sci then
62912: LD_VAR 0 4
62916: PUSH
62917: LD_VAR 0 8
62921: NOT
62922: AND
62923: IFFALSE 62992
// begin sort := SortBySkill ( tmp , 4 ) ;
62925: LD_ADDR_VAR 0 9
62929: PUSH
62930: LD_VAR 0 4
62934: PPUSH
62935: LD_INT 4
62937: PPUSH
62938: CALL 49449 0 2
62942: ST_TO_ADDR
// if sort then
62943: LD_VAR 0 9
62947: IFFALSE 62963
// p := sort [ 1 ] ;
62949: LD_ADDR_VAR 0 11
62953: PUSH
62954: LD_VAR 0 9
62958: PUSH
62959: LD_INT 1
62961: ARRAY
62962: ST_TO_ADDR
// if p then
62963: LD_VAR 0 11
62967: IFFALSE 62992
// result := Replace ( result , 4 , p ) ;
62969: LD_ADDR_VAR 0 2
62973: PUSH
62974: LD_VAR 0 2
62978: PPUSH
62979: LD_INT 4
62981: PPUSH
62982: LD_VAR 0 11
62986: PPUSH
62987: CALL_OW 1
62991: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62992: LD_ADDR_VAR 0 4
62996: PUSH
62997: LD_VAR 0 4
63001: PUSH
63002: LD_VAR 0 7
63006: DIFF
63007: ST_TO_ADDR
// if tmp and mech < 6 then
63008: LD_VAR 0 4
63012: PUSH
63013: LD_VAR 0 7
63017: PUSH
63018: LD_INT 6
63020: LESS
63021: AND
63022: IFFALSE 63204
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63024: LD_ADDR_VAR 0 9
63028: PUSH
63029: LD_VAR 0 4
63033: PUSH
63034: LD_VAR 0 7
63038: DIFF
63039: PPUSH
63040: LD_INT 3
63042: PPUSH
63043: CALL 49449 0 2
63047: ST_TO_ADDR
// p := [ ] ;
63048: LD_ADDR_VAR 0 11
63052: PUSH
63053: EMPTY
63054: ST_TO_ADDR
// if sort then
63055: LD_VAR 0 9
63059: IFFALSE 63175
// for i = 1 to 6 - mech do
63061: LD_ADDR_VAR 0 3
63065: PUSH
63066: DOUBLE
63067: LD_INT 1
63069: DEC
63070: ST_TO_ADDR
63071: LD_INT 6
63073: PUSH
63074: LD_VAR 0 7
63078: MINUS
63079: PUSH
63080: FOR_TO
63081: IFFALSE 63173
// begin if i = sort then
63083: LD_VAR 0 3
63087: PUSH
63088: LD_VAR 0 9
63092: EQUAL
63093: IFFALSE 63097
// break ;
63095: GO 63173
// if GetClass ( i ) = 3 then
63097: LD_VAR 0 3
63101: PPUSH
63102: CALL_OW 257
63106: PUSH
63107: LD_INT 3
63109: EQUAL
63110: IFFALSE 63114
// continue ;
63112: GO 63080
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63114: LD_ADDR_VAR 0 11
63118: PUSH
63119: LD_VAR 0 11
63123: PPUSH
63124: LD_VAR 0 11
63128: PUSH
63129: LD_INT 1
63131: PLUS
63132: PPUSH
63133: LD_VAR 0 9
63137: PUSH
63138: LD_VAR 0 3
63142: ARRAY
63143: PPUSH
63144: CALL_OW 2
63148: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63149: LD_ADDR_VAR 0 4
63153: PUSH
63154: LD_VAR 0 4
63158: PUSH
63159: LD_VAR 0 9
63163: PUSH
63164: LD_VAR 0 3
63168: ARRAY
63169: DIFF
63170: ST_TO_ADDR
// end ;
63171: GO 63080
63173: POP
63174: POP
// if p then
63175: LD_VAR 0 11
63179: IFFALSE 63204
// result := Replace ( result , 3 , p ) ;
63181: LD_ADDR_VAR 0 2
63185: PUSH
63186: LD_VAR 0 2
63190: PPUSH
63191: LD_INT 3
63193: PPUSH
63194: LD_VAR 0 11
63198: PPUSH
63199: CALL_OW 1
63203: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63204: LD_ADDR_VAR 0 4
63208: PUSH
63209: LD_VAR 0 4
63213: PUSH
63214: LD_VAR 0 6
63218: DIFF
63219: ST_TO_ADDR
// if tmp and eng < 4 then
63220: LD_VAR 0 4
63224: PUSH
63225: LD_VAR 0 6
63229: PUSH
63230: LD_INT 4
63232: LESS
63233: AND
63234: IFFALSE 63424
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63236: LD_ADDR_VAR 0 9
63240: PUSH
63241: LD_VAR 0 4
63245: PUSH
63246: LD_VAR 0 7
63250: PUSH
63251: LD_VAR 0 6
63255: UNION
63256: DIFF
63257: PPUSH
63258: LD_INT 2
63260: PPUSH
63261: CALL 49449 0 2
63265: ST_TO_ADDR
// p := [ ] ;
63266: LD_ADDR_VAR 0 11
63270: PUSH
63271: EMPTY
63272: ST_TO_ADDR
// if sort then
63273: LD_VAR 0 9
63277: IFFALSE 63393
// for i = 1 to 4 - eng do
63279: LD_ADDR_VAR 0 3
63283: PUSH
63284: DOUBLE
63285: LD_INT 1
63287: DEC
63288: ST_TO_ADDR
63289: LD_INT 4
63291: PUSH
63292: LD_VAR 0 6
63296: MINUS
63297: PUSH
63298: FOR_TO
63299: IFFALSE 63391
// begin if i = sort then
63301: LD_VAR 0 3
63305: PUSH
63306: LD_VAR 0 9
63310: EQUAL
63311: IFFALSE 63315
// break ;
63313: GO 63391
// if GetClass ( i ) = 2 then
63315: LD_VAR 0 3
63319: PPUSH
63320: CALL_OW 257
63324: PUSH
63325: LD_INT 2
63327: EQUAL
63328: IFFALSE 63332
// continue ;
63330: GO 63298
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63332: LD_ADDR_VAR 0 11
63336: PUSH
63337: LD_VAR 0 11
63341: PPUSH
63342: LD_VAR 0 11
63346: PUSH
63347: LD_INT 1
63349: PLUS
63350: PPUSH
63351: LD_VAR 0 9
63355: PUSH
63356: LD_VAR 0 3
63360: ARRAY
63361: PPUSH
63362: CALL_OW 2
63366: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63367: LD_ADDR_VAR 0 4
63371: PUSH
63372: LD_VAR 0 4
63376: PUSH
63377: LD_VAR 0 9
63381: PUSH
63382: LD_VAR 0 3
63386: ARRAY
63387: DIFF
63388: ST_TO_ADDR
// end ;
63389: GO 63298
63391: POP
63392: POP
// if p then
63393: LD_VAR 0 11
63397: IFFALSE 63422
// result := Replace ( result , 2 , p ) ;
63399: LD_ADDR_VAR 0 2
63403: PUSH
63404: LD_VAR 0 2
63408: PPUSH
63409: LD_INT 2
63411: PPUSH
63412: LD_VAR 0 11
63416: PPUSH
63417: CALL_OW 1
63421: ST_TO_ADDR
// end else
63422: GO 63468
// for i = eng downto 5 do
63424: LD_ADDR_VAR 0 3
63428: PUSH
63429: DOUBLE
63430: LD_VAR 0 6
63434: INC
63435: ST_TO_ADDR
63436: LD_INT 5
63438: PUSH
63439: FOR_DOWNTO
63440: IFFALSE 63466
// tmp := tmp union eng [ i ] ;
63442: LD_ADDR_VAR 0 4
63446: PUSH
63447: LD_VAR 0 4
63451: PUSH
63452: LD_VAR 0 6
63456: PUSH
63457: LD_VAR 0 3
63461: ARRAY
63462: UNION
63463: ST_TO_ADDR
63464: GO 63439
63466: POP
63467: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63468: LD_ADDR_VAR 0 2
63472: PUSH
63473: LD_VAR 0 2
63477: PPUSH
63478: LD_INT 1
63480: PPUSH
63481: LD_VAR 0 4
63485: PUSH
63486: LD_VAR 0 5
63490: DIFF
63491: PPUSH
63492: CALL_OW 1
63496: ST_TO_ADDR
// exit ;
63497: GO 63499
// end ; end ;
63499: LD_VAR 0 2
63503: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63504: LD_INT 0
63506: PPUSH
63507: PPUSH
63508: PPUSH
// if not mc_bases then
63509: LD_EXP 50
63513: NOT
63514: IFFALSE 63518
// exit ;
63516: GO 63660
// for i = 1 to mc_bases do
63518: LD_ADDR_VAR 0 2
63522: PUSH
63523: DOUBLE
63524: LD_INT 1
63526: DEC
63527: ST_TO_ADDR
63528: LD_EXP 50
63532: PUSH
63533: FOR_TO
63534: IFFALSE 63651
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63536: LD_ADDR_VAR 0 3
63540: PUSH
63541: LD_EXP 50
63545: PUSH
63546: LD_VAR 0 2
63550: ARRAY
63551: PPUSH
63552: LD_INT 21
63554: PUSH
63555: LD_INT 3
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PUSH
63562: LD_INT 3
63564: PUSH
63565: LD_INT 2
63567: PUSH
63568: LD_INT 30
63570: PUSH
63571: LD_INT 29
63573: PUSH
63574: EMPTY
63575: LIST
63576: LIST
63577: PUSH
63578: LD_INT 30
63580: PUSH
63581: LD_INT 30
63583: PUSH
63584: EMPTY
63585: LIST
63586: LIST
63587: PUSH
63588: EMPTY
63589: LIST
63590: LIST
63591: LIST
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: LD_INT 3
63599: PUSH
63600: LD_INT 24
63602: PUSH
63603: LD_INT 1000
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: LIST
63618: PPUSH
63619: CALL_OW 72
63623: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63624: LD_ADDR_EXP 51
63628: PUSH
63629: LD_EXP 51
63633: PPUSH
63634: LD_VAR 0 2
63638: PPUSH
63639: LD_VAR 0 3
63643: PPUSH
63644: CALL_OW 1
63648: ST_TO_ADDR
// end ;
63649: GO 63533
63651: POP
63652: POP
// RaiseSailEvent ( 101 ) ;
63653: LD_INT 101
63655: PPUSH
63656: CALL_OW 427
// end ;
63660: LD_VAR 0 1
63664: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63665: LD_INT 0
63667: PPUSH
63668: PPUSH
63669: PPUSH
63670: PPUSH
63671: PPUSH
63672: PPUSH
63673: PPUSH
// if not mc_bases then
63674: LD_EXP 50
63678: NOT
63679: IFFALSE 63683
// exit ;
63681: GO 64245
// for i = 1 to mc_bases do
63683: LD_ADDR_VAR 0 2
63687: PUSH
63688: DOUBLE
63689: LD_INT 1
63691: DEC
63692: ST_TO_ADDR
63693: LD_EXP 50
63697: PUSH
63698: FOR_TO
63699: IFFALSE 64236
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63701: LD_ADDR_VAR 0 5
63705: PUSH
63706: LD_EXP 50
63710: PUSH
63711: LD_VAR 0 2
63715: ARRAY
63716: PUSH
63717: LD_EXP 79
63721: PUSH
63722: LD_VAR 0 2
63726: ARRAY
63727: UNION
63728: PPUSH
63729: LD_INT 21
63731: PUSH
63732: LD_INT 1
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 1
63741: PUSH
63742: LD_INT 3
63744: PUSH
63745: LD_INT 54
63747: PUSH
63748: EMPTY
63749: LIST
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 3
63757: PUSH
63758: LD_INT 24
63760: PUSH
63761: LD_INT 1000
63763: PUSH
63764: EMPTY
63765: LIST
63766: LIST
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: LIST
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: PPUSH
63781: CALL_OW 72
63785: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63786: LD_ADDR_VAR 0 6
63790: PUSH
63791: LD_EXP 50
63795: PUSH
63796: LD_VAR 0 2
63800: ARRAY
63801: PPUSH
63802: LD_INT 21
63804: PUSH
63805: LD_INT 1
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: PUSH
63812: LD_INT 1
63814: PUSH
63815: LD_INT 3
63817: PUSH
63818: LD_INT 54
63820: PUSH
63821: EMPTY
63822: LIST
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 3
63830: PUSH
63831: LD_INT 24
63833: PUSH
63834: LD_INT 250
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: LIST
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: PPUSH
63854: CALL_OW 72
63858: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63859: LD_ADDR_VAR 0 7
63863: PUSH
63864: LD_VAR 0 5
63868: PUSH
63869: LD_VAR 0 6
63873: DIFF
63874: ST_TO_ADDR
// if not need_heal_1 then
63875: LD_VAR 0 6
63879: NOT
63880: IFFALSE 63913
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63882: LD_ADDR_EXP 53
63886: PUSH
63887: LD_EXP 53
63891: PPUSH
63892: LD_VAR 0 2
63896: PUSH
63897: LD_INT 1
63899: PUSH
63900: EMPTY
63901: LIST
63902: LIST
63903: PPUSH
63904: EMPTY
63905: PPUSH
63906: CALL 18573 0 3
63910: ST_TO_ADDR
63911: GO 63983
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63913: LD_ADDR_EXP 53
63917: PUSH
63918: LD_EXP 53
63922: PPUSH
63923: LD_VAR 0 2
63927: PUSH
63928: LD_INT 1
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PPUSH
63935: LD_EXP 53
63939: PUSH
63940: LD_VAR 0 2
63944: ARRAY
63945: PUSH
63946: LD_INT 1
63948: ARRAY
63949: PPUSH
63950: LD_INT 3
63952: PUSH
63953: LD_INT 24
63955: PUSH
63956: LD_INT 1000
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PPUSH
63967: CALL_OW 72
63971: PUSH
63972: LD_VAR 0 6
63976: UNION
63977: PPUSH
63978: CALL 18573 0 3
63982: ST_TO_ADDR
// if not need_heal_2 then
63983: LD_VAR 0 7
63987: NOT
63988: IFFALSE 64021
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63990: LD_ADDR_EXP 53
63994: PUSH
63995: LD_EXP 53
63999: PPUSH
64000: LD_VAR 0 2
64004: PUSH
64005: LD_INT 2
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PPUSH
64012: EMPTY
64013: PPUSH
64014: CALL 18573 0 3
64018: ST_TO_ADDR
64019: GO 64053
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64021: LD_ADDR_EXP 53
64025: PUSH
64026: LD_EXP 53
64030: PPUSH
64031: LD_VAR 0 2
64035: PUSH
64036: LD_INT 2
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PPUSH
64043: LD_VAR 0 7
64047: PPUSH
64048: CALL 18573 0 3
64052: ST_TO_ADDR
// if need_heal_2 then
64053: LD_VAR 0 7
64057: IFFALSE 64218
// for j in need_heal_2 do
64059: LD_ADDR_VAR 0 3
64063: PUSH
64064: LD_VAR 0 7
64068: PUSH
64069: FOR_IN
64070: IFFALSE 64216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64072: LD_ADDR_VAR 0 5
64076: PUSH
64077: LD_EXP 50
64081: PUSH
64082: LD_VAR 0 2
64086: ARRAY
64087: PPUSH
64088: LD_INT 2
64090: PUSH
64091: LD_INT 30
64093: PUSH
64094: LD_INT 6
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 30
64103: PUSH
64104: LD_INT 7
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PUSH
64111: LD_INT 30
64113: PUSH
64114: LD_INT 8
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 30
64123: PUSH
64124: LD_INT 0
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: PUSH
64131: LD_INT 30
64133: PUSH
64134: LD_INT 1
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: PPUSH
64149: CALL_OW 72
64153: ST_TO_ADDR
// if tmp then
64154: LD_VAR 0 5
64158: IFFALSE 64214
// begin k := NearestUnitToUnit ( tmp , j ) ;
64160: LD_ADDR_VAR 0 4
64164: PUSH
64165: LD_VAR 0 5
64169: PPUSH
64170: LD_VAR 0 3
64174: PPUSH
64175: CALL_OW 74
64179: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
64180: LD_VAR 0 3
64184: PPUSH
64185: LD_VAR 0 4
64189: PPUSH
64190: CALL_OW 296
64194: PUSH
64195: LD_INT 5
64197: GREATER
64198: IFFALSE 64214
// ComMoveToNearbyEntrance ( j , k ) ;
64200: LD_VAR 0 3
64204: PPUSH
64205: LD_VAR 0 4
64209: PPUSH
64210: CALL 51809 0 2
// end ; end ;
64214: GO 64069
64216: POP
64217: POP
// if not need_heal_1 and not need_heal_2 then
64218: LD_VAR 0 6
64222: NOT
64223: PUSH
64224: LD_VAR 0 7
64228: NOT
64229: AND
64230: IFFALSE 64234
// continue ;
64232: GO 63698
// end ;
64234: GO 63698
64236: POP
64237: POP
// RaiseSailEvent ( 102 ) ;
64238: LD_INT 102
64240: PPUSH
64241: CALL_OW 427
// end ;
64245: LD_VAR 0 1
64249: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
64250: LD_INT 0
64252: PPUSH
64253: PPUSH
64254: PPUSH
64255: PPUSH
64256: PPUSH
64257: PPUSH
64258: PPUSH
64259: PPUSH
// if not mc_bases then
64260: LD_EXP 50
64264: NOT
64265: IFFALSE 64269
// exit ;
64267: GO 65180
// for i = 1 to mc_bases do
64269: LD_ADDR_VAR 0 2
64273: PUSH
64274: DOUBLE
64275: LD_INT 1
64277: DEC
64278: ST_TO_ADDR
64279: LD_EXP 50
64283: PUSH
64284: FOR_TO
64285: IFFALSE 65178
// begin if not mc_building_need_repair [ i ] then
64287: LD_EXP 51
64291: PUSH
64292: LD_VAR 0 2
64296: ARRAY
64297: NOT
64298: IFFALSE 64483
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64300: LD_ADDR_VAR 0 6
64304: PUSH
64305: LD_EXP 69
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: PPUSH
64316: LD_INT 3
64318: PUSH
64319: LD_INT 24
64321: PUSH
64322: LD_INT 1000
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PUSH
64333: LD_INT 2
64335: PUSH
64336: LD_INT 34
64338: PUSH
64339: LD_INT 13
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: PUSH
64346: LD_INT 34
64348: PUSH
64349: LD_INT 52
64351: PUSH
64352: EMPTY
64353: LIST
64354: LIST
64355: PUSH
64356: LD_INT 34
64358: PUSH
64359: LD_INT 88
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: LIST
64370: LIST
64371: PUSH
64372: EMPTY
64373: LIST
64374: LIST
64375: PPUSH
64376: CALL_OW 72
64380: ST_TO_ADDR
// if cranes then
64381: LD_VAR 0 6
64385: IFFALSE 64447
// for j in cranes do
64387: LD_ADDR_VAR 0 3
64391: PUSH
64392: LD_VAR 0 6
64396: PUSH
64397: FOR_IN
64398: IFFALSE 64445
// if not IsInArea ( j , mc_parking [ i ] ) then
64400: LD_VAR 0 3
64404: PPUSH
64405: LD_EXP 74
64409: PUSH
64410: LD_VAR 0 2
64414: ARRAY
64415: PPUSH
64416: CALL_OW 308
64420: NOT
64421: IFFALSE 64443
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64423: LD_VAR 0 3
64427: PPUSH
64428: LD_EXP 74
64432: PUSH
64433: LD_VAR 0 2
64437: ARRAY
64438: PPUSH
64439: CALL_OW 113
64443: GO 64397
64445: POP
64446: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64447: LD_ADDR_EXP 52
64451: PUSH
64452: LD_EXP 52
64456: PPUSH
64457: LD_VAR 0 2
64461: PPUSH
64462: EMPTY
64463: PPUSH
64464: CALL_OW 1
64468: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64469: LD_VAR 0 2
64473: PPUSH
64474: LD_INT 101
64476: PPUSH
64477: CALL 59323 0 2
// continue ;
64481: GO 64284
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64483: LD_ADDR_EXP 56
64487: PUSH
64488: LD_EXP 56
64492: PPUSH
64493: LD_VAR 0 2
64497: PPUSH
64498: EMPTY
64499: PPUSH
64500: CALL_OW 1
64504: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64505: LD_VAR 0 2
64509: PPUSH
64510: LD_INT 103
64512: PPUSH
64513: CALL 59323 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64517: LD_ADDR_VAR 0 5
64521: PUSH
64522: LD_EXP 50
64526: PUSH
64527: LD_VAR 0 2
64531: ARRAY
64532: PUSH
64533: LD_EXP 79
64537: PUSH
64538: LD_VAR 0 2
64542: ARRAY
64543: UNION
64544: PPUSH
64545: LD_INT 2
64547: PUSH
64548: LD_INT 25
64550: PUSH
64551: LD_INT 2
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 25
64560: PUSH
64561: LD_INT 16
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: EMPTY
64569: LIST
64570: LIST
64571: LIST
64572: PUSH
64573: EMPTY
64574: LIST
64575: PPUSH
64576: CALL_OW 72
64580: ST_TO_ADDR
// if mc_need_heal [ i ] then
64581: LD_EXP 53
64585: PUSH
64586: LD_VAR 0 2
64590: ARRAY
64591: IFFALSE 64635
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64593: LD_ADDR_VAR 0 5
64597: PUSH
64598: LD_VAR 0 5
64602: PUSH
64603: LD_EXP 53
64607: PUSH
64608: LD_VAR 0 2
64612: ARRAY
64613: PUSH
64614: LD_INT 1
64616: ARRAY
64617: PUSH
64618: LD_EXP 53
64622: PUSH
64623: LD_VAR 0 2
64627: ARRAY
64628: PUSH
64629: LD_INT 2
64631: ARRAY
64632: UNION
64633: DIFF
64634: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64635: LD_ADDR_VAR 0 6
64639: PUSH
64640: LD_EXP 69
64644: PUSH
64645: LD_VAR 0 2
64649: ARRAY
64650: PPUSH
64651: LD_INT 2
64653: PUSH
64654: LD_INT 34
64656: PUSH
64657: LD_INT 13
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PUSH
64664: LD_INT 34
64666: PUSH
64667: LD_INT 52
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PUSH
64674: LD_INT 34
64676: PUSH
64677: LD_INT 88
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: PPUSH
64690: CALL_OW 72
64694: ST_TO_ADDR
// if cranes then
64695: LD_VAR 0 6
64699: IFFALSE 64867
// begin for j in cranes do
64701: LD_ADDR_VAR 0 3
64705: PUSH
64706: LD_VAR 0 6
64710: PUSH
64711: FOR_IN
64712: IFFALSE 64865
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64714: LD_VAR 0 3
64718: PPUSH
64719: CALL_OW 256
64723: PUSH
64724: LD_INT 1000
64726: EQUAL
64727: PUSH
64728: LD_VAR 0 3
64732: PPUSH
64733: CALL_OW 314
64737: NOT
64738: AND
64739: IFFALSE 64805
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
64741: LD_ADDR_VAR 0 8
64745: PUSH
64746: LD_EXP 51
64750: PUSH
64751: LD_VAR 0 2
64755: ARRAY
64756: PPUSH
64757: LD_VAR 0 3
64761: PPUSH
64762: CALL_OW 74
64766: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64767: LD_VAR 0 8
64771: PPUSH
64772: LD_INT 16
64774: PPUSH
64775: CALL 21170 0 2
64779: PUSH
64780: LD_INT 4
64782: ARRAY
64783: PUSH
64784: LD_INT 10
64786: LESS
64787: IFFALSE 64803
// ComRepairBuilding ( j , to_repair ) ;
64789: LD_VAR 0 3
64793: PPUSH
64794: LD_VAR 0 8
64798: PPUSH
64799: CALL_OW 130
// end else
64803: GO 64863
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64805: LD_VAR 0 3
64809: PPUSH
64810: CALL_OW 256
64814: PUSH
64815: LD_INT 500
64817: LESS
64818: PUSH
64819: LD_VAR 0 3
64823: PPUSH
64824: LD_EXP 74
64828: PUSH
64829: LD_VAR 0 2
64833: ARRAY
64834: PPUSH
64835: CALL_OW 308
64839: NOT
64840: AND
64841: IFFALSE 64863
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64843: LD_VAR 0 3
64847: PPUSH
64848: LD_EXP 74
64852: PUSH
64853: LD_VAR 0 2
64857: ARRAY
64858: PPUSH
64859: CALL_OW 113
// end ;
64863: GO 64711
64865: POP
64866: POP
// end ; if tmp > 3 then
64867: LD_VAR 0 5
64871: PUSH
64872: LD_INT 3
64874: GREATER
64875: IFFALSE 64895
// tmp := ShrinkArray ( tmp , 4 ) ;
64877: LD_ADDR_VAR 0 5
64881: PUSH
64882: LD_VAR 0 5
64886: PPUSH
64887: LD_INT 4
64889: PPUSH
64890: CALL 51247 0 2
64894: ST_TO_ADDR
// if not tmp then
64895: LD_VAR 0 5
64899: NOT
64900: IFFALSE 64904
// continue ;
64902: GO 64284
// for j in tmp do
64904: LD_ADDR_VAR 0 3
64908: PUSH
64909: LD_VAR 0 5
64913: PUSH
64914: FOR_IN
64915: IFFALSE 65174
// begin if IsInUnit ( j ) then
64917: LD_VAR 0 3
64921: PPUSH
64922: CALL_OW 310
64926: IFFALSE 64937
// ComExitBuilding ( j ) ;
64928: LD_VAR 0 3
64932: PPUSH
64933: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64937: LD_VAR 0 3
64941: PUSH
64942: LD_EXP 52
64946: PUSH
64947: LD_VAR 0 2
64951: ARRAY
64952: IN
64953: NOT
64954: IFFALSE 65012
// begin SetTag ( j , 101 ) ;
64956: LD_VAR 0 3
64960: PPUSH
64961: LD_INT 101
64963: PPUSH
64964: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64968: LD_ADDR_EXP 52
64972: PUSH
64973: LD_EXP 52
64977: PPUSH
64978: LD_VAR 0 2
64982: PUSH
64983: LD_EXP 52
64987: PUSH
64988: LD_VAR 0 2
64992: ARRAY
64993: PUSH
64994: LD_INT 1
64996: PLUS
64997: PUSH
64998: EMPTY
64999: LIST
65000: LIST
65001: PPUSH
65002: LD_VAR 0 3
65006: PPUSH
65007: CALL 18573 0 3
65011: ST_TO_ADDR
// end ; wait ( 1 ) ;
65012: LD_INT 1
65014: PPUSH
65015: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
65019: LD_ADDR_VAR 0 7
65023: PUSH
65024: LD_EXP 51
65028: PUSH
65029: LD_VAR 0 2
65033: ARRAY
65034: ST_TO_ADDR
// if mc_scan [ i ] then
65035: LD_EXP 73
65039: PUSH
65040: LD_VAR 0 2
65044: ARRAY
65045: IFFALSE 65107
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
65047: LD_ADDR_VAR 0 7
65051: PUSH
65052: LD_EXP 51
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: PPUSH
65063: LD_INT 3
65065: PUSH
65066: LD_INT 30
65068: PUSH
65069: LD_INT 32
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PUSH
65076: LD_INT 30
65078: PUSH
65079: LD_INT 33
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 30
65088: PUSH
65089: LD_INT 31
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: LIST
65100: LIST
65101: PPUSH
65102: CALL_OW 72
65106: ST_TO_ADDR
// if not to_repair_tmp then
65107: LD_VAR 0 7
65111: NOT
65112: IFFALSE 65116
// continue ;
65114: GO 64914
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
65116: LD_ADDR_VAR 0 8
65120: PUSH
65121: LD_VAR 0 7
65125: PPUSH
65126: LD_VAR 0 3
65130: PPUSH
65131: CALL_OW 74
65135: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
65136: LD_VAR 0 8
65140: PPUSH
65141: LD_INT 16
65143: PPUSH
65144: CALL 21170 0 2
65148: PUSH
65149: LD_INT 4
65151: ARRAY
65152: PUSH
65153: LD_INT 14
65155: LESS
65156: IFFALSE 65172
// ComRepairBuilding ( j , to_repair ) ;
65158: LD_VAR 0 3
65162: PPUSH
65163: LD_VAR 0 8
65167: PPUSH
65168: CALL_OW 130
// end ;
65172: GO 64914
65174: POP
65175: POP
// end ;
65176: GO 64284
65178: POP
65179: POP
// end ;
65180: LD_VAR 0 1
65184: RET
// export function MC_Heal ; var i , j , tmp ; begin
65185: LD_INT 0
65187: PPUSH
65188: PPUSH
65189: PPUSH
65190: PPUSH
// if not mc_bases then
65191: LD_EXP 50
65195: NOT
65196: IFFALSE 65200
// exit ;
65198: GO 65602
// for i = 1 to mc_bases do
65200: LD_ADDR_VAR 0 2
65204: PUSH
65205: DOUBLE
65206: LD_INT 1
65208: DEC
65209: ST_TO_ADDR
65210: LD_EXP 50
65214: PUSH
65215: FOR_TO
65216: IFFALSE 65600
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65218: LD_EXP 53
65222: PUSH
65223: LD_VAR 0 2
65227: ARRAY
65228: PUSH
65229: LD_INT 1
65231: ARRAY
65232: NOT
65233: PUSH
65234: LD_EXP 53
65238: PUSH
65239: LD_VAR 0 2
65243: ARRAY
65244: PUSH
65245: LD_INT 2
65247: ARRAY
65248: NOT
65249: AND
65250: IFFALSE 65288
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65252: LD_ADDR_EXP 54
65256: PUSH
65257: LD_EXP 54
65261: PPUSH
65262: LD_VAR 0 2
65266: PPUSH
65267: EMPTY
65268: PPUSH
65269: CALL_OW 1
65273: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65274: LD_VAR 0 2
65278: PPUSH
65279: LD_INT 102
65281: PPUSH
65282: CALL 59323 0 2
// continue ;
65286: GO 65215
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65288: LD_ADDR_VAR 0 4
65292: PUSH
65293: LD_EXP 50
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: PPUSH
65304: LD_INT 25
65306: PUSH
65307: LD_INT 4
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PPUSH
65314: CALL_OW 72
65318: ST_TO_ADDR
// if not tmp then
65319: LD_VAR 0 4
65323: NOT
65324: IFFALSE 65328
// continue ;
65326: GO 65215
// if mc_taming [ i ] then
65328: LD_EXP 81
65332: PUSH
65333: LD_VAR 0 2
65337: ARRAY
65338: IFFALSE 65362
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65340: LD_ADDR_EXP 81
65344: PUSH
65345: LD_EXP 81
65349: PPUSH
65350: LD_VAR 0 2
65354: PPUSH
65355: EMPTY
65356: PPUSH
65357: CALL_OW 1
65361: ST_TO_ADDR
// for j in tmp do
65362: LD_ADDR_VAR 0 3
65366: PUSH
65367: LD_VAR 0 4
65371: PUSH
65372: FOR_IN
65373: IFFALSE 65596
// begin if IsInUnit ( j ) then
65375: LD_VAR 0 3
65379: PPUSH
65380: CALL_OW 310
65384: IFFALSE 65395
// ComExitBuilding ( j ) ;
65386: LD_VAR 0 3
65390: PPUSH
65391: CALL_OW 122
// if not j in mc_healers [ i ] then
65395: LD_VAR 0 3
65399: PUSH
65400: LD_EXP 54
65404: PUSH
65405: LD_VAR 0 2
65409: ARRAY
65410: IN
65411: NOT
65412: IFFALSE 65458
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65414: LD_ADDR_EXP 54
65418: PUSH
65419: LD_EXP 54
65423: PPUSH
65424: LD_VAR 0 2
65428: PUSH
65429: LD_EXP 54
65433: PUSH
65434: LD_VAR 0 2
65438: ARRAY
65439: PUSH
65440: LD_INT 1
65442: PLUS
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PPUSH
65448: LD_VAR 0 3
65452: PPUSH
65453: CALL 18573 0 3
65457: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65458: LD_VAR 0 3
65462: PPUSH
65463: CALL_OW 110
65467: PUSH
65468: LD_INT 102
65470: NONEQUAL
65471: IFFALSE 65485
// SetTag ( j , 102 ) ;
65473: LD_VAR 0 3
65477: PPUSH
65478: LD_INT 102
65480: PPUSH
65481: CALL_OW 109
// Wait ( 3 ) ;
65485: LD_INT 3
65487: PPUSH
65488: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65492: LD_EXP 53
65496: PUSH
65497: LD_VAR 0 2
65501: ARRAY
65502: PUSH
65503: LD_INT 1
65505: ARRAY
65506: IFFALSE 65538
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65508: LD_VAR 0 3
65512: PPUSH
65513: LD_EXP 53
65517: PUSH
65518: LD_VAR 0 2
65522: ARRAY
65523: PUSH
65524: LD_INT 1
65526: ARRAY
65527: PUSH
65528: LD_INT 1
65530: ARRAY
65531: PPUSH
65532: CALL_OW 128
65536: GO 65594
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65538: LD_VAR 0 3
65542: PPUSH
65543: CALL_OW 314
65547: NOT
65548: PUSH
65549: LD_EXP 53
65553: PUSH
65554: LD_VAR 0 2
65558: ARRAY
65559: PUSH
65560: LD_INT 2
65562: ARRAY
65563: AND
65564: IFFALSE 65594
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65566: LD_VAR 0 3
65570: PPUSH
65571: LD_EXP 53
65575: PUSH
65576: LD_VAR 0 2
65580: ARRAY
65581: PUSH
65582: LD_INT 2
65584: ARRAY
65585: PUSH
65586: LD_INT 1
65588: ARRAY
65589: PPUSH
65590: CALL_OW 128
// end ;
65594: GO 65372
65596: POP
65597: POP
// end ;
65598: GO 65215
65600: POP
65601: POP
// end ;
65602: LD_VAR 0 1
65606: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
65607: LD_INT 0
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
65614: PPUSH
// if not mc_bases then
65615: LD_EXP 50
65619: NOT
65620: IFFALSE 65624
// exit ;
65622: GO 66787
// for i = 1 to mc_bases do
65624: LD_ADDR_VAR 0 2
65628: PUSH
65629: DOUBLE
65630: LD_INT 1
65632: DEC
65633: ST_TO_ADDR
65634: LD_EXP 50
65638: PUSH
65639: FOR_TO
65640: IFFALSE 66785
// begin if mc_scan [ i ] then
65642: LD_EXP 73
65646: PUSH
65647: LD_VAR 0 2
65651: ARRAY
65652: IFFALSE 65656
// continue ;
65654: GO 65639
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65656: LD_EXP 55
65660: PUSH
65661: LD_VAR 0 2
65665: ARRAY
65666: NOT
65667: PUSH
65668: LD_EXP 57
65672: PUSH
65673: LD_VAR 0 2
65677: ARRAY
65678: NOT
65679: AND
65680: PUSH
65681: LD_EXP 56
65685: PUSH
65686: LD_VAR 0 2
65690: ARRAY
65691: AND
65692: IFFALSE 65730
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65694: LD_ADDR_EXP 56
65698: PUSH
65699: LD_EXP 56
65703: PPUSH
65704: LD_VAR 0 2
65708: PPUSH
65709: EMPTY
65710: PPUSH
65711: CALL_OW 1
65715: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65716: LD_VAR 0 2
65720: PPUSH
65721: LD_INT 103
65723: PPUSH
65724: CALL 59323 0 2
// continue ;
65728: GO 65639
// end ; if mc_construct_list [ i ] then
65730: LD_EXP 57
65734: PUSH
65735: LD_VAR 0 2
65739: ARRAY
65740: IFFALSE 65960
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65742: LD_ADDR_VAR 0 5
65746: PUSH
65747: LD_EXP 50
65751: PUSH
65752: LD_VAR 0 2
65756: ARRAY
65757: PPUSH
65758: LD_INT 25
65760: PUSH
65761: LD_INT 2
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PPUSH
65768: CALL_OW 72
65772: PUSH
65773: LD_EXP 52
65777: PUSH
65778: LD_VAR 0 2
65782: ARRAY
65783: DIFF
65784: ST_TO_ADDR
// if not tmp then
65785: LD_VAR 0 5
65789: NOT
65790: IFFALSE 65794
// continue ;
65792: GO 65639
// for j in tmp do
65794: LD_ADDR_VAR 0 3
65798: PUSH
65799: LD_VAR 0 5
65803: PUSH
65804: FOR_IN
65805: IFFALSE 65956
// begin if not mc_builders [ i ] then
65807: LD_EXP 56
65811: PUSH
65812: LD_VAR 0 2
65816: ARRAY
65817: NOT
65818: IFFALSE 65876
// begin SetTag ( j , 103 ) ;
65820: LD_VAR 0 3
65824: PPUSH
65825: LD_INT 103
65827: PPUSH
65828: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65832: LD_ADDR_EXP 56
65836: PUSH
65837: LD_EXP 56
65841: PPUSH
65842: LD_VAR 0 2
65846: PUSH
65847: LD_EXP 56
65851: PUSH
65852: LD_VAR 0 2
65856: ARRAY
65857: PUSH
65858: LD_INT 1
65860: PLUS
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PPUSH
65866: LD_VAR 0 3
65870: PPUSH
65871: CALL 18573 0 3
65875: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65876: LD_VAR 0 3
65880: PPUSH
65881: CALL_OW 310
65885: IFFALSE 65896
// ComExitBuilding ( j ) ;
65887: LD_VAR 0 3
65891: PPUSH
65892: CALL_OW 122
// wait ( 3 ) ;
65896: LD_INT 3
65898: PPUSH
65899: CALL_OW 67
// if not mc_construct_list [ i ] then
65903: LD_EXP 57
65907: PUSH
65908: LD_VAR 0 2
65912: ARRAY
65913: NOT
65914: IFFALSE 65918
// break ;
65916: GO 65956
// if not HasTask ( j ) then
65918: LD_VAR 0 3
65922: PPUSH
65923: CALL_OW 314
65927: NOT
65928: IFFALSE 65954
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65930: LD_VAR 0 3
65934: PPUSH
65935: LD_EXP 57
65939: PUSH
65940: LD_VAR 0 2
65944: ARRAY
65945: PUSH
65946: LD_INT 1
65948: ARRAY
65949: PPUSH
65950: CALL 21443 0 2
// end ;
65954: GO 65804
65956: POP
65957: POP
// end else
65958: GO 66783
// if mc_build_list [ i ] then
65960: LD_EXP 55
65964: PUSH
65965: LD_VAR 0 2
65969: ARRAY
65970: IFFALSE 66783
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65972: LD_EXP 55
65976: PUSH
65977: LD_VAR 0 2
65981: ARRAY
65982: PUSH
65983: LD_INT 1
65985: ARRAY
65986: PUSH
65987: LD_INT 1
65989: ARRAY
65990: PPUSH
65991: CALL 21267 0 1
65995: PUSH
65996: LD_EXP 50
66000: PUSH
66001: LD_VAR 0 2
66005: ARRAY
66006: PPUSH
66007: LD_INT 2
66009: PUSH
66010: LD_INT 30
66012: PUSH
66013: LD_INT 2
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 30
66022: PUSH
66023: LD_INT 3
66025: PUSH
66026: EMPTY
66027: LIST
66028: LIST
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: LIST
66034: PPUSH
66035: CALL_OW 72
66039: NOT
66040: AND
66041: IFFALSE 66146
// begin for j = 1 to mc_build_list [ i ] do
66043: LD_ADDR_VAR 0 3
66047: PUSH
66048: DOUBLE
66049: LD_INT 1
66051: DEC
66052: ST_TO_ADDR
66053: LD_EXP 55
66057: PUSH
66058: LD_VAR 0 2
66062: ARRAY
66063: PUSH
66064: FOR_TO
66065: IFFALSE 66144
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66067: LD_EXP 55
66071: PUSH
66072: LD_VAR 0 2
66076: ARRAY
66077: PUSH
66078: LD_VAR 0 3
66082: ARRAY
66083: PUSH
66084: LD_INT 1
66086: ARRAY
66087: PUSH
66088: LD_INT 2
66090: EQUAL
66091: IFFALSE 66142
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66093: LD_ADDR_EXP 55
66097: PUSH
66098: LD_EXP 55
66102: PPUSH
66103: LD_VAR 0 2
66107: PPUSH
66108: LD_EXP 55
66112: PUSH
66113: LD_VAR 0 2
66117: ARRAY
66118: PPUSH
66119: LD_VAR 0 3
66123: PPUSH
66124: LD_INT 1
66126: PPUSH
66127: LD_INT 0
66129: PPUSH
66130: CALL 17991 0 4
66134: PPUSH
66135: CALL_OW 1
66139: ST_TO_ADDR
// break ;
66140: GO 66144
// end ;
66142: GO 66064
66144: POP
66145: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66146: LD_ADDR_VAR 0 6
66150: PUSH
66151: LD_EXP 50
66155: PUSH
66156: LD_VAR 0 2
66160: ARRAY
66161: PPUSH
66162: LD_INT 2
66164: PUSH
66165: LD_INT 30
66167: PUSH
66168: LD_INT 0
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: PUSH
66175: LD_INT 30
66177: PUSH
66178: LD_INT 1
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: LIST
66189: PPUSH
66190: CALL_OW 72
66194: ST_TO_ADDR
// for k := 1 to depot do
66195: LD_ADDR_VAR 0 4
66199: PUSH
66200: DOUBLE
66201: LD_INT 1
66203: DEC
66204: ST_TO_ADDR
66205: LD_VAR 0 6
66209: PUSH
66210: FOR_TO
66211: IFFALSE 66781
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66213: LD_EXP 55
66217: PUSH
66218: LD_VAR 0 2
66222: ARRAY
66223: PUSH
66224: LD_INT 1
66226: ARRAY
66227: PUSH
66228: LD_INT 1
66230: ARRAY
66231: PUSH
66232: LD_INT 0
66234: EQUAL
66235: PUSH
66236: LD_VAR 0 6
66240: PUSH
66241: LD_VAR 0 4
66245: ARRAY
66246: PPUSH
66247: LD_EXP 55
66251: PUSH
66252: LD_VAR 0 2
66256: ARRAY
66257: PUSH
66258: LD_INT 1
66260: ARRAY
66261: PUSH
66262: LD_INT 1
66264: ARRAY
66265: PPUSH
66266: LD_EXP 55
66270: PUSH
66271: LD_VAR 0 2
66275: ARRAY
66276: PUSH
66277: LD_INT 1
66279: ARRAY
66280: PUSH
66281: LD_INT 2
66283: ARRAY
66284: PPUSH
66285: LD_EXP 55
66289: PUSH
66290: LD_VAR 0 2
66294: ARRAY
66295: PUSH
66296: LD_INT 1
66298: ARRAY
66299: PUSH
66300: LD_INT 3
66302: ARRAY
66303: PPUSH
66304: LD_EXP 55
66308: PUSH
66309: LD_VAR 0 2
66313: ARRAY
66314: PUSH
66315: LD_INT 1
66317: ARRAY
66318: PUSH
66319: LD_INT 4
66321: ARRAY
66322: PPUSH
66323: CALL 26679 0 5
66327: OR
66328: IFFALSE 66609
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66330: LD_ADDR_VAR 0 5
66334: PUSH
66335: LD_EXP 50
66339: PUSH
66340: LD_VAR 0 2
66344: ARRAY
66345: PPUSH
66346: LD_INT 25
66348: PUSH
66349: LD_INT 2
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PPUSH
66356: CALL_OW 72
66360: PUSH
66361: LD_EXP 52
66365: PUSH
66366: LD_VAR 0 2
66370: ARRAY
66371: DIFF
66372: ST_TO_ADDR
// if not tmp then
66373: LD_VAR 0 5
66377: NOT
66378: IFFALSE 66382
// continue ;
66380: GO 66210
// for j in tmp do
66382: LD_ADDR_VAR 0 3
66386: PUSH
66387: LD_VAR 0 5
66391: PUSH
66392: FOR_IN
66393: IFFALSE 66605
// begin if not mc_builders [ i ] then
66395: LD_EXP 56
66399: PUSH
66400: LD_VAR 0 2
66404: ARRAY
66405: NOT
66406: IFFALSE 66464
// begin SetTag ( j , 103 ) ;
66408: LD_VAR 0 3
66412: PPUSH
66413: LD_INT 103
66415: PPUSH
66416: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66420: LD_ADDR_EXP 56
66424: PUSH
66425: LD_EXP 56
66429: PPUSH
66430: LD_VAR 0 2
66434: PUSH
66435: LD_EXP 56
66439: PUSH
66440: LD_VAR 0 2
66444: ARRAY
66445: PUSH
66446: LD_INT 1
66448: PLUS
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PPUSH
66454: LD_VAR 0 3
66458: PPUSH
66459: CALL 18573 0 3
66463: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66464: LD_VAR 0 3
66468: PPUSH
66469: CALL_OW 310
66473: IFFALSE 66484
// ComExitBuilding ( j ) ;
66475: LD_VAR 0 3
66479: PPUSH
66480: CALL_OW 122
// wait ( 3 ) ;
66484: LD_INT 3
66486: PPUSH
66487: CALL_OW 67
// if not mc_build_list [ i ] then
66491: LD_EXP 55
66495: PUSH
66496: LD_VAR 0 2
66500: ARRAY
66501: NOT
66502: IFFALSE 66506
// break ;
66504: GO 66605
// if not HasTask ( j ) then
66506: LD_VAR 0 3
66510: PPUSH
66511: CALL_OW 314
66515: NOT
66516: IFFALSE 66603
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66518: LD_VAR 0 3
66522: PPUSH
66523: LD_EXP 55
66527: PUSH
66528: LD_VAR 0 2
66532: ARRAY
66533: PUSH
66534: LD_INT 1
66536: ARRAY
66537: PUSH
66538: LD_INT 1
66540: ARRAY
66541: PPUSH
66542: LD_EXP 55
66546: PUSH
66547: LD_VAR 0 2
66551: ARRAY
66552: PUSH
66553: LD_INT 1
66555: ARRAY
66556: PUSH
66557: LD_INT 2
66559: ARRAY
66560: PPUSH
66561: LD_EXP 55
66565: PUSH
66566: LD_VAR 0 2
66570: ARRAY
66571: PUSH
66572: LD_INT 1
66574: ARRAY
66575: PUSH
66576: LD_INT 3
66578: ARRAY
66579: PPUSH
66580: LD_EXP 55
66584: PUSH
66585: LD_VAR 0 2
66589: ARRAY
66590: PUSH
66591: LD_INT 1
66593: ARRAY
66594: PUSH
66595: LD_INT 4
66597: ARRAY
66598: PPUSH
66599: CALL_OW 145
// end ;
66603: GO 66392
66605: POP
66606: POP
// end else
66607: GO 66779
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66609: LD_EXP 50
66613: PUSH
66614: LD_VAR 0 2
66618: ARRAY
66619: PPUSH
66620: LD_EXP 55
66624: PUSH
66625: LD_VAR 0 2
66629: ARRAY
66630: PUSH
66631: LD_INT 1
66633: ARRAY
66634: PUSH
66635: LD_INT 1
66637: ARRAY
66638: PPUSH
66639: LD_EXP 55
66643: PUSH
66644: LD_VAR 0 2
66648: ARRAY
66649: PUSH
66650: LD_INT 1
66652: ARRAY
66653: PUSH
66654: LD_INT 2
66656: ARRAY
66657: PPUSH
66658: LD_EXP 55
66662: PUSH
66663: LD_VAR 0 2
66667: ARRAY
66668: PUSH
66669: LD_INT 1
66671: ARRAY
66672: PUSH
66673: LD_INT 3
66675: ARRAY
66676: PPUSH
66677: LD_EXP 55
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: PUSH
66688: LD_INT 1
66690: ARRAY
66691: PUSH
66692: LD_INT 4
66694: ARRAY
66695: PPUSH
66696: LD_EXP 50
66700: PUSH
66701: LD_VAR 0 2
66705: ARRAY
66706: PPUSH
66707: LD_INT 21
66709: PUSH
66710: LD_INT 3
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PPUSH
66717: CALL_OW 72
66721: PPUSH
66722: EMPTY
66723: PPUSH
66724: CALL 25433 0 7
66728: NOT
66729: IFFALSE 66779
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66731: LD_ADDR_EXP 55
66735: PUSH
66736: LD_EXP 55
66740: PPUSH
66741: LD_VAR 0 2
66745: PPUSH
66746: LD_EXP 55
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: PPUSH
66757: LD_INT 1
66759: PPUSH
66760: LD_INT 1
66762: NEG
66763: PPUSH
66764: LD_INT 0
66766: PPUSH
66767: CALL 17991 0 4
66771: PPUSH
66772: CALL_OW 1
66776: ST_TO_ADDR
// continue ;
66777: GO 66210
// end ; end ;
66779: GO 66210
66781: POP
66782: POP
// end ; end ;
66783: GO 65639
66785: POP
66786: POP
// end ;
66787: LD_VAR 0 1
66791: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66792: LD_INT 0
66794: PPUSH
66795: PPUSH
66796: PPUSH
66797: PPUSH
66798: PPUSH
66799: PPUSH
// if not mc_bases then
66800: LD_EXP 50
66804: NOT
66805: IFFALSE 66809
// exit ;
66807: GO 67236
// for i = 1 to mc_bases do
66809: LD_ADDR_VAR 0 2
66813: PUSH
66814: DOUBLE
66815: LD_INT 1
66817: DEC
66818: ST_TO_ADDR
66819: LD_EXP 50
66823: PUSH
66824: FOR_TO
66825: IFFALSE 67234
// begin tmp := mc_build_upgrade [ i ] ;
66827: LD_ADDR_VAR 0 4
66831: PUSH
66832: LD_EXP 82
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66843: LD_ADDR_VAR 0 6
66847: PUSH
66848: LD_EXP 83
66852: PUSH
66853: LD_VAR 0 2
66857: ARRAY
66858: PPUSH
66859: LD_INT 2
66861: PUSH
66862: LD_INT 30
66864: PUSH
66865: LD_INT 6
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 30
66874: PUSH
66875: LD_INT 7
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: LIST
66886: PPUSH
66887: CALL_OW 72
66891: ST_TO_ADDR
// if not tmp and not lab then
66892: LD_VAR 0 4
66896: NOT
66897: PUSH
66898: LD_VAR 0 6
66902: NOT
66903: AND
66904: IFFALSE 66908
// continue ;
66906: GO 66824
// if tmp then
66908: LD_VAR 0 4
66912: IFFALSE 67032
// for j in tmp do
66914: LD_ADDR_VAR 0 3
66918: PUSH
66919: LD_VAR 0 4
66923: PUSH
66924: FOR_IN
66925: IFFALSE 67030
// begin if UpgradeCost ( j ) then
66927: LD_VAR 0 3
66931: PPUSH
66932: CALL 25093 0 1
66936: IFFALSE 67028
// begin ComUpgrade ( j ) ;
66938: LD_VAR 0 3
66942: PPUSH
66943: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66947: LD_ADDR_EXP 82
66951: PUSH
66952: LD_EXP 82
66956: PPUSH
66957: LD_VAR 0 2
66961: PPUSH
66962: LD_EXP 82
66966: PUSH
66967: LD_VAR 0 2
66971: ARRAY
66972: PUSH
66973: LD_VAR 0 3
66977: DIFF
66978: PPUSH
66979: CALL_OW 1
66983: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66984: LD_ADDR_EXP 57
66988: PUSH
66989: LD_EXP 57
66993: PPUSH
66994: LD_VAR 0 2
66998: PUSH
66999: LD_EXP 57
67003: PUSH
67004: LD_VAR 0 2
67008: ARRAY
67009: PUSH
67010: LD_INT 1
67012: PLUS
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PPUSH
67018: LD_VAR 0 3
67022: PPUSH
67023: CALL 18573 0 3
67027: ST_TO_ADDR
// end ; end ;
67028: GO 66924
67030: POP
67031: POP
// if not lab or not mc_lab_upgrade [ i ] then
67032: LD_VAR 0 6
67036: NOT
67037: PUSH
67038: LD_EXP 84
67042: PUSH
67043: LD_VAR 0 2
67047: ARRAY
67048: NOT
67049: OR
67050: IFFALSE 67054
// continue ;
67052: GO 66824
// for j in lab do
67054: LD_ADDR_VAR 0 3
67058: PUSH
67059: LD_VAR 0 6
67063: PUSH
67064: FOR_IN
67065: IFFALSE 67230
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67067: LD_VAR 0 3
67071: PPUSH
67072: CALL_OW 266
67076: PUSH
67077: LD_INT 6
67079: PUSH
67080: LD_INT 7
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: IN
67087: PUSH
67088: LD_VAR 0 3
67092: PPUSH
67093: CALL_OW 461
67097: PUSH
67098: LD_INT 1
67100: NONEQUAL
67101: AND
67102: IFFALSE 67228
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67104: LD_VAR 0 3
67108: PPUSH
67109: LD_EXP 84
67113: PUSH
67114: LD_VAR 0 2
67118: ARRAY
67119: PUSH
67120: LD_INT 1
67122: ARRAY
67123: PPUSH
67124: CALL 25298 0 2
67128: IFFALSE 67228
// begin ComCancel ( j ) ;
67130: LD_VAR 0 3
67134: PPUSH
67135: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67139: LD_VAR 0 3
67143: PPUSH
67144: LD_EXP 84
67148: PUSH
67149: LD_VAR 0 2
67153: ARRAY
67154: PUSH
67155: LD_INT 1
67157: ARRAY
67158: PPUSH
67159: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67163: LD_VAR 0 3
67167: PUSH
67168: LD_EXP 57
67172: PUSH
67173: LD_VAR 0 2
67177: ARRAY
67178: IN
67179: NOT
67180: IFFALSE 67226
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67182: LD_ADDR_EXP 57
67186: PUSH
67187: LD_EXP 57
67191: PPUSH
67192: LD_VAR 0 2
67196: PUSH
67197: LD_EXP 57
67201: PUSH
67202: LD_VAR 0 2
67206: ARRAY
67207: PUSH
67208: LD_INT 1
67210: PLUS
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PPUSH
67216: LD_VAR 0 3
67220: PPUSH
67221: CALL 18573 0 3
67225: ST_TO_ADDR
// break ;
67226: GO 67230
// end ; end ; end ;
67228: GO 67064
67230: POP
67231: POP
// end ;
67232: GO 66824
67234: POP
67235: POP
// end ;
67236: LD_VAR 0 1
67240: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67241: LD_INT 0
67243: PPUSH
67244: PPUSH
67245: PPUSH
67246: PPUSH
67247: PPUSH
67248: PPUSH
67249: PPUSH
67250: PPUSH
67251: PPUSH
// if not mc_bases then
67252: LD_EXP 50
67256: NOT
67257: IFFALSE 67261
// exit ;
67259: GO 67666
// for i = 1 to mc_bases do
67261: LD_ADDR_VAR 0 2
67265: PUSH
67266: DOUBLE
67267: LD_INT 1
67269: DEC
67270: ST_TO_ADDR
67271: LD_EXP 50
67275: PUSH
67276: FOR_TO
67277: IFFALSE 67664
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67279: LD_EXP 58
67283: PUSH
67284: LD_VAR 0 2
67288: ARRAY
67289: NOT
67290: PUSH
67291: LD_EXP 50
67295: PUSH
67296: LD_VAR 0 2
67300: ARRAY
67301: PPUSH
67302: LD_INT 30
67304: PUSH
67305: LD_INT 3
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: PPUSH
67312: CALL_OW 72
67316: NOT
67317: OR
67318: IFFALSE 67322
// continue ;
67320: GO 67276
// busy := false ;
67322: LD_ADDR_VAR 0 8
67326: PUSH
67327: LD_INT 0
67329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67330: LD_ADDR_VAR 0 4
67334: PUSH
67335: LD_EXP 50
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PPUSH
67346: LD_INT 30
67348: PUSH
67349: LD_INT 3
67351: PUSH
67352: EMPTY
67353: LIST
67354: LIST
67355: PPUSH
67356: CALL_OW 72
67360: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67361: LD_ADDR_VAR 0 6
67365: PUSH
67366: LD_EXP 58
67370: PUSH
67371: LD_VAR 0 2
67375: ARRAY
67376: PPUSH
67377: LD_INT 2
67379: PUSH
67380: LD_INT 30
67382: PUSH
67383: LD_INT 32
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 30
67392: PUSH
67393: LD_INT 33
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: LIST
67404: PPUSH
67405: CALL_OW 72
67409: ST_TO_ADDR
// if not t then
67410: LD_VAR 0 6
67414: NOT
67415: IFFALSE 67419
// continue ;
67417: GO 67276
// for j in tmp do
67419: LD_ADDR_VAR 0 3
67423: PUSH
67424: LD_VAR 0 4
67428: PUSH
67429: FOR_IN
67430: IFFALSE 67460
// if not BuildingStatus ( j ) = bs_idle then
67432: LD_VAR 0 3
67436: PPUSH
67437: CALL_OW 461
67441: PUSH
67442: LD_INT 2
67444: EQUAL
67445: NOT
67446: IFFALSE 67458
// begin busy := true ;
67448: LD_ADDR_VAR 0 8
67452: PUSH
67453: LD_INT 1
67455: ST_TO_ADDR
// break ;
67456: GO 67460
// end ;
67458: GO 67429
67460: POP
67461: POP
// if busy then
67462: LD_VAR 0 8
67466: IFFALSE 67470
// continue ;
67468: GO 67276
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67470: LD_ADDR_VAR 0 7
67474: PUSH
67475: LD_VAR 0 6
67479: PPUSH
67480: LD_INT 35
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PPUSH
67490: CALL_OW 72
67494: ST_TO_ADDR
// if tw then
67495: LD_VAR 0 7
67499: IFFALSE 67576
// begin tw := tw [ 1 ] ;
67501: LD_ADDR_VAR 0 7
67505: PUSH
67506: LD_VAR 0 7
67510: PUSH
67511: LD_INT 1
67513: ARRAY
67514: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67515: LD_ADDR_VAR 0 9
67519: PUSH
67520: LD_VAR 0 7
67524: PPUSH
67525: LD_EXP 75
67529: PUSH
67530: LD_VAR 0 2
67534: ARRAY
67535: PPUSH
67536: CALL 23590 0 2
67540: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67541: LD_EXP 89
67545: PUSH
67546: LD_VAR 0 2
67550: ARRAY
67551: IFFALSE 67574
// if not weapon in mc_allowed_tower_weapons [ i ] then
67553: LD_VAR 0 9
67557: PUSH
67558: LD_EXP 89
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: IN
67569: NOT
67570: IFFALSE 67574
// continue ;
67572: GO 67276
// end else
67574: GO 67639
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67576: LD_ADDR_VAR 0 5
67580: PUSH
67581: LD_EXP 58
67585: PUSH
67586: LD_VAR 0 2
67590: ARRAY
67591: PPUSH
67592: LD_VAR 0 4
67596: PPUSH
67597: CALL 50480 0 2
67601: ST_TO_ADDR
// if not tmp2 then
67602: LD_VAR 0 5
67606: NOT
67607: IFFALSE 67611
// continue ;
67609: GO 67276
// tw := tmp2 [ 1 ] ;
67611: LD_ADDR_VAR 0 7
67615: PUSH
67616: LD_VAR 0 5
67620: PUSH
67621: LD_INT 1
67623: ARRAY
67624: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67625: LD_ADDR_VAR 0 9
67629: PUSH
67630: LD_VAR 0 5
67634: PUSH
67635: LD_INT 2
67637: ARRAY
67638: ST_TO_ADDR
// end ; if not weapon then
67639: LD_VAR 0 9
67643: NOT
67644: IFFALSE 67648
// continue ;
67646: GO 67276
// ComPlaceWeapon ( tw , weapon ) ;
67648: LD_VAR 0 7
67652: PPUSH
67653: LD_VAR 0 9
67657: PPUSH
67658: CALL_OW 148
// end ;
67662: GO 67276
67664: POP
67665: POP
// end ;
67666: LD_VAR 0 1
67670: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67671: LD_INT 0
67673: PPUSH
67674: PPUSH
67675: PPUSH
67676: PPUSH
67677: PPUSH
67678: PPUSH
67679: PPUSH
// if not mc_bases then
67680: LD_EXP 50
67684: NOT
67685: IFFALSE 67689
// exit ;
67687: GO 68464
// for i = 1 to mc_bases do
67689: LD_ADDR_VAR 0 2
67693: PUSH
67694: DOUBLE
67695: LD_INT 1
67697: DEC
67698: ST_TO_ADDR
67699: LD_EXP 50
67703: PUSH
67704: FOR_TO
67705: IFFALSE 68462
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67707: LD_EXP 63
67711: PUSH
67712: LD_VAR 0 2
67716: ARRAY
67717: NOT
67718: PUSH
67719: LD_EXP 63
67723: PUSH
67724: LD_VAR 0 2
67728: ARRAY
67729: PUSH
67730: LD_EXP 64
67734: PUSH
67735: LD_VAR 0 2
67739: ARRAY
67740: EQUAL
67741: OR
67742: PUSH
67743: LD_EXP 73
67747: PUSH
67748: LD_VAR 0 2
67752: ARRAY
67753: OR
67754: IFFALSE 67758
// continue ;
67756: GO 67704
// if mc_miners [ i ] then
67758: LD_EXP 64
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: IFFALSE 68149
// begin for j = mc_miners [ i ] downto 1 do
67770: LD_ADDR_VAR 0 3
67774: PUSH
67775: DOUBLE
67776: LD_EXP 64
67780: PUSH
67781: LD_VAR 0 2
67785: ARRAY
67786: INC
67787: ST_TO_ADDR
67788: LD_INT 1
67790: PUSH
67791: FOR_DOWNTO
67792: IFFALSE 68147
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67794: LD_EXP 64
67798: PUSH
67799: LD_VAR 0 2
67803: ARRAY
67804: PUSH
67805: LD_VAR 0 3
67809: ARRAY
67810: PPUSH
67811: CALL_OW 301
67815: PUSH
67816: LD_EXP 64
67820: PUSH
67821: LD_VAR 0 2
67825: ARRAY
67826: PUSH
67827: LD_VAR 0 3
67831: ARRAY
67832: PPUSH
67833: CALL_OW 257
67837: PUSH
67838: LD_INT 1
67840: NONEQUAL
67841: OR
67842: IFFALSE 67905
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67844: LD_ADDR_VAR 0 5
67848: PUSH
67849: LD_EXP 64
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PUSH
67860: LD_EXP 64
67864: PUSH
67865: LD_VAR 0 2
67869: ARRAY
67870: PUSH
67871: LD_VAR 0 3
67875: ARRAY
67876: DIFF
67877: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67878: LD_ADDR_EXP 64
67882: PUSH
67883: LD_EXP 64
67887: PPUSH
67888: LD_VAR 0 2
67892: PPUSH
67893: LD_VAR 0 5
67897: PPUSH
67898: CALL_OW 1
67902: ST_TO_ADDR
// continue ;
67903: GO 67791
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67905: LD_EXP 64
67909: PUSH
67910: LD_VAR 0 2
67914: ARRAY
67915: PUSH
67916: LD_VAR 0 3
67920: ARRAY
67921: PPUSH
67922: CALL_OW 257
67926: PUSH
67927: LD_INT 1
67929: EQUAL
67930: PUSH
67931: LD_EXP 64
67935: PUSH
67936: LD_VAR 0 2
67940: ARRAY
67941: PUSH
67942: LD_VAR 0 3
67946: ARRAY
67947: PPUSH
67948: CALL_OW 459
67952: NOT
67953: AND
67954: PUSH
67955: LD_EXP 64
67959: PUSH
67960: LD_VAR 0 2
67964: ARRAY
67965: PUSH
67966: LD_VAR 0 3
67970: ARRAY
67971: PPUSH
67972: CALL_OW 314
67976: NOT
67977: AND
67978: IFFALSE 68145
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67980: LD_EXP 64
67984: PUSH
67985: LD_VAR 0 2
67989: ARRAY
67990: PUSH
67991: LD_VAR 0 3
67995: ARRAY
67996: PPUSH
67997: CALL_OW 310
68001: IFFALSE 68024
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68003: LD_EXP 64
68007: PUSH
68008: LD_VAR 0 2
68012: ARRAY
68013: PUSH
68014: LD_VAR 0 3
68018: ARRAY
68019: PPUSH
68020: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68024: LD_EXP 64
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: PUSH
68035: LD_VAR 0 3
68039: ARRAY
68040: PPUSH
68041: CALL_OW 314
68045: NOT
68046: IFFALSE 68145
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
68048: LD_ADDR_VAR 0 7
68052: PUSH
68053: LD_VAR 0 3
68057: PUSH
68058: LD_EXP 63
68062: PUSH
68063: LD_VAR 0 2
68067: ARRAY
68068: PPUSH
68069: CALL 15713 0 1
68073: MOD
68074: PUSH
68075: LD_INT 1
68077: PLUS
68078: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
68079: LD_EXP 64
68083: PUSH
68084: LD_VAR 0 2
68088: ARRAY
68089: PUSH
68090: LD_VAR 0 3
68094: ARRAY
68095: PPUSH
68096: LD_EXP 63
68100: PUSH
68101: LD_VAR 0 2
68105: ARRAY
68106: PUSH
68107: LD_VAR 0 7
68111: ARRAY
68112: PUSH
68113: LD_INT 1
68115: ARRAY
68116: PPUSH
68117: LD_EXP 63
68121: PUSH
68122: LD_VAR 0 2
68126: ARRAY
68127: PUSH
68128: LD_VAR 0 7
68132: ARRAY
68133: PUSH
68134: LD_INT 2
68136: ARRAY
68137: PPUSH
68138: LD_INT 0
68140: PPUSH
68141: CALL_OW 193
// end ; end ; end ;
68145: GO 67791
68147: POP
68148: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
68149: LD_ADDR_VAR 0 5
68153: PUSH
68154: LD_EXP 50
68158: PUSH
68159: LD_VAR 0 2
68163: ARRAY
68164: PPUSH
68165: LD_INT 2
68167: PUSH
68168: LD_INT 30
68170: PUSH
68171: LD_INT 4
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 30
68180: PUSH
68181: LD_INT 5
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 30
68190: PUSH
68191: LD_INT 32
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: PPUSH
68204: CALL_OW 72
68208: ST_TO_ADDR
// if not tmp then
68209: LD_VAR 0 5
68213: NOT
68214: IFFALSE 68218
// continue ;
68216: GO 67704
// list := [ ] ;
68218: LD_ADDR_VAR 0 6
68222: PUSH
68223: EMPTY
68224: ST_TO_ADDR
// for j in tmp do
68225: LD_ADDR_VAR 0 3
68229: PUSH
68230: LD_VAR 0 5
68234: PUSH
68235: FOR_IN
68236: IFFALSE 68305
// begin for k in UnitsInside ( j ) do
68238: LD_ADDR_VAR 0 4
68242: PUSH
68243: LD_VAR 0 3
68247: PPUSH
68248: CALL_OW 313
68252: PUSH
68253: FOR_IN
68254: IFFALSE 68301
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68256: LD_VAR 0 4
68260: PPUSH
68261: CALL_OW 257
68265: PUSH
68266: LD_INT 1
68268: EQUAL
68269: PUSH
68270: LD_VAR 0 4
68274: PPUSH
68275: CALL_OW 459
68279: NOT
68280: AND
68281: IFFALSE 68299
// list := list ^ k ;
68283: LD_ADDR_VAR 0 6
68287: PUSH
68288: LD_VAR 0 6
68292: PUSH
68293: LD_VAR 0 4
68297: ADD
68298: ST_TO_ADDR
68299: GO 68253
68301: POP
68302: POP
// end ;
68303: GO 68235
68305: POP
68306: POP
// list := list diff mc_miners [ i ] ;
68307: LD_ADDR_VAR 0 6
68311: PUSH
68312: LD_VAR 0 6
68316: PUSH
68317: LD_EXP 64
68321: PUSH
68322: LD_VAR 0 2
68326: ARRAY
68327: DIFF
68328: ST_TO_ADDR
// if not list then
68329: LD_VAR 0 6
68333: NOT
68334: IFFALSE 68338
// continue ;
68336: GO 67704
// k := mc_mines [ i ] - mc_miners [ i ] ;
68338: LD_ADDR_VAR 0 4
68342: PUSH
68343: LD_EXP 63
68347: PUSH
68348: LD_VAR 0 2
68352: ARRAY
68353: PUSH
68354: LD_EXP 64
68358: PUSH
68359: LD_VAR 0 2
68363: ARRAY
68364: MINUS
68365: ST_TO_ADDR
// if k > list then
68366: LD_VAR 0 4
68370: PUSH
68371: LD_VAR 0 6
68375: GREATER
68376: IFFALSE 68388
// k := list ;
68378: LD_ADDR_VAR 0 4
68382: PUSH
68383: LD_VAR 0 6
68387: ST_TO_ADDR
// for j = 1 to k do
68388: LD_ADDR_VAR 0 3
68392: PUSH
68393: DOUBLE
68394: LD_INT 1
68396: DEC
68397: ST_TO_ADDR
68398: LD_VAR 0 4
68402: PUSH
68403: FOR_TO
68404: IFFALSE 68458
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68406: LD_ADDR_EXP 64
68410: PUSH
68411: LD_EXP 64
68415: PPUSH
68416: LD_VAR 0 2
68420: PUSH
68421: LD_EXP 64
68425: PUSH
68426: LD_VAR 0 2
68430: ARRAY
68431: PUSH
68432: LD_INT 1
68434: PLUS
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: PPUSH
68440: LD_VAR 0 6
68444: PUSH
68445: LD_VAR 0 3
68449: ARRAY
68450: PPUSH
68451: CALL 18573 0 3
68455: ST_TO_ADDR
68456: GO 68403
68458: POP
68459: POP
// end ;
68460: GO 67704
68462: POP
68463: POP
// end ;
68464: LD_VAR 0 1
68468: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68469: LD_INT 0
68471: PPUSH
68472: PPUSH
68473: PPUSH
68474: PPUSH
68475: PPUSH
68476: PPUSH
68477: PPUSH
68478: PPUSH
68479: PPUSH
68480: PPUSH
68481: PPUSH
// if not mc_bases then
68482: LD_EXP 50
68486: NOT
68487: IFFALSE 68491
// exit ;
68489: GO 70314
// for i = 1 to mc_bases do
68491: LD_ADDR_VAR 0 2
68495: PUSH
68496: DOUBLE
68497: LD_INT 1
68499: DEC
68500: ST_TO_ADDR
68501: LD_EXP 50
68505: PUSH
68506: FOR_TO
68507: IFFALSE 70312
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68509: LD_EXP 50
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: NOT
68520: PUSH
68521: LD_EXP 57
68525: PUSH
68526: LD_VAR 0 2
68530: ARRAY
68531: OR
68532: IFFALSE 68536
// continue ;
68534: GO 68506
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68536: LD_EXP 66
68540: PUSH
68541: LD_VAR 0 2
68545: ARRAY
68546: NOT
68547: PUSH
68548: LD_EXP 67
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: AND
68559: IFFALSE 68597
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68561: LD_ADDR_EXP 67
68565: PUSH
68566: LD_EXP 67
68570: PPUSH
68571: LD_VAR 0 2
68575: PPUSH
68576: EMPTY
68577: PPUSH
68578: CALL_OW 1
68582: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68583: LD_VAR 0 2
68587: PPUSH
68588: LD_INT 107
68590: PPUSH
68591: CALL 59323 0 2
// continue ;
68595: GO 68506
// end ; target := [ ] ;
68597: LD_ADDR_VAR 0 7
68601: PUSH
68602: EMPTY
68603: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68604: LD_ADDR_VAR 0 6
68608: PUSH
68609: LD_EXP 50
68613: PUSH
68614: LD_VAR 0 2
68618: ARRAY
68619: PUSH
68620: LD_INT 1
68622: ARRAY
68623: PPUSH
68624: CALL_OW 255
68628: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68629: LD_ADDR_VAR 0 9
68633: PUSH
68634: LD_EXP 50
68638: PUSH
68639: LD_VAR 0 2
68643: ARRAY
68644: PPUSH
68645: LD_INT 2
68647: PUSH
68648: LD_INT 30
68650: PUSH
68651: LD_INT 0
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 30
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: LIST
68672: PPUSH
68673: CALL_OW 72
68677: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68678: LD_ADDR_VAR 0 3
68682: PUSH
68683: DOUBLE
68684: LD_EXP 66
68688: PUSH
68689: LD_VAR 0 2
68693: ARRAY
68694: INC
68695: ST_TO_ADDR
68696: LD_INT 1
68698: PUSH
68699: FOR_DOWNTO
68700: IFFALSE 68945
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68702: LD_EXP 66
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PUSH
68713: LD_VAR 0 3
68717: ARRAY
68718: PUSH
68719: LD_INT 2
68721: ARRAY
68722: PPUSH
68723: LD_EXP 66
68727: PUSH
68728: LD_VAR 0 2
68732: ARRAY
68733: PUSH
68734: LD_VAR 0 3
68738: ARRAY
68739: PUSH
68740: LD_INT 3
68742: ARRAY
68743: PPUSH
68744: CALL_OW 488
68748: PUSH
68749: LD_EXP 66
68753: PUSH
68754: LD_VAR 0 2
68758: ARRAY
68759: PUSH
68760: LD_VAR 0 3
68764: ARRAY
68765: PUSH
68766: LD_INT 2
68768: ARRAY
68769: PPUSH
68770: LD_EXP 66
68774: PUSH
68775: LD_VAR 0 2
68779: ARRAY
68780: PUSH
68781: LD_VAR 0 3
68785: ARRAY
68786: PUSH
68787: LD_INT 3
68789: ARRAY
68790: PPUSH
68791: CALL_OW 284
68795: PUSH
68796: LD_INT 0
68798: EQUAL
68799: AND
68800: IFFALSE 68855
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68802: LD_ADDR_VAR 0 5
68806: PUSH
68807: LD_EXP 66
68811: PUSH
68812: LD_VAR 0 2
68816: ARRAY
68817: PPUSH
68818: LD_VAR 0 3
68822: PPUSH
68823: CALL_OW 3
68827: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68828: LD_ADDR_EXP 66
68832: PUSH
68833: LD_EXP 66
68837: PPUSH
68838: LD_VAR 0 2
68842: PPUSH
68843: LD_VAR 0 5
68847: PPUSH
68848: CALL_OW 1
68852: ST_TO_ADDR
// continue ;
68853: GO 68699
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68855: LD_VAR 0 6
68859: PPUSH
68860: LD_EXP 66
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PUSH
68871: LD_VAR 0 3
68875: ARRAY
68876: PUSH
68877: LD_INT 2
68879: ARRAY
68880: PPUSH
68881: LD_EXP 66
68885: PUSH
68886: LD_VAR 0 2
68890: ARRAY
68891: PUSH
68892: LD_VAR 0 3
68896: ARRAY
68897: PUSH
68898: LD_INT 3
68900: ARRAY
68901: PPUSH
68902: LD_INT 30
68904: PPUSH
68905: CALL 19469 0 4
68909: PUSH
68910: LD_INT 4
68912: ARRAY
68913: PUSH
68914: LD_INT 0
68916: EQUAL
68917: IFFALSE 68943
// begin target := mc_crates [ i ] [ j ] ;
68919: LD_ADDR_VAR 0 7
68923: PUSH
68924: LD_EXP 66
68928: PUSH
68929: LD_VAR 0 2
68933: ARRAY
68934: PUSH
68935: LD_VAR 0 3
68939: ARRAY
68940: ST_TO_ADDR
// break ;
68941: GO 68945
// end ; end ;
68943: GO 68699
68945: POP
68946: POP
// if not target then
68947: LD_VAR 0 7
68951: NOT
68952: IFFALSE 68956
// continue ;
68954: GO 68506
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68956: LD_ADDR_VAR 0 8
68960: PUSH
68961: LD_EXP 69
68965: PUSH
68966: LD_VAR 0 2
68970: ARRAY
68971: PPUSH
68972: LD_INT 2
68974: PUSH
68975: LD_INT 3
68977: PUSH
68978: LD_INT 58
68980: PUSH
68981: EMPTY
68982: LIST
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 61
68990: PUSH
68991: EMPTY
68992: LIST
68993: PUSH
68994: LD_INT 33
68996: PUSH
68997: LD_INT 5
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 33
69006: PUSH
69007: LD_INT 3
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: PUSH
69021: LD_INT 2
69023: PUSH
69024: LD_INT 34
69026: PUSH
69027: LD_INT 32
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 34
69036: PUSH
69037: LD_INT 51
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 34
69046: PUSH
69047: LD_INT 12
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PPUSH
69064: CALL_OW 72
69068: ST_TO_ADDR
// if not cargo then
69069: LD_VAR 0 8
69073: NOT
69074: IFFALSE 69780
// begin if mc_crates_collector [ i ] < 5 then
69076: LD_EXP 67
69080: PUSH
69081: LD_VAR 0 2
69085: ARRAY
69086: PUSH
69087: LD_INT 5
69089: LESS
69090: IFFALSE 69456
// begin if mc_ape [ i ] then
69092: LD_EXP 79
69096: PUSH
69097: LD_VAR 0 2
69101: ARRAY
69102: IFFALSE 69149
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69104: LD_ADDR_VAR 0 5
69108: PUSH
69109: LD_EXP 79
69113: PUSH
69114: LD_VAR 0 2
69118: ARRAY
69119: PPUSH
69120: LD_INT 25
69122: PUSH
69123: LD_INT 16
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 24
69132: PUSH
69133: LD_INT 750
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: EMPTY
69141: LIST
69142: LIST
69143: PPUSH
69144: CALL_OW 72
69148: ST_TO_ADDR
// if not tmp then
69149: LD_VAR 0 5
69153: NOT
69154: IFFALSE 69201
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69156: LD_ADDR_VAR 0 5
69160: PUSH
69161: LD_EXP 50
69165: PUSH
69166: LD_VAR 0 2
69170: ARRAY
69171: PPUSH
69172: LD_INT 25
69174: PUSH
69175: LD_INT 2
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 24
69184: PUSH
69185: LD_INT 750
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PPUSH
69196: CALL_OW 72
69200: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
69201: LD_EXP 79
69205: PUSH
69206: LD_VAR 0 2
69210: ARRAY
69211: PUSH
69212: LD_EXP 50
69216: PUSH
69217: LD_VAR 0 2
69221: ARRAY
69222: PPUSH
69223: LD_INT 25
69225: PUSH
69226: LD_INT 2
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 24
69235: PUSH
69236: LD_INT 750
69238: PUSH
69239: EMPTY
69240: LIST
69241: LIST
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PPUSH
69247: CALL_OW 72
69251: AND
69252: PUSH
69253: LD_VAR 0 5
69257: PUSH
69258: LD_INT 5
69260: LESS
69261: AND
69262: IFFALSE 69344
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69264: LD_ADDR_VAR 0 3
69268: PUSH
69269: LD_EXP 50
69273: PUSH
69274: LD_VAR 0 2
69278: ARRAY
69279: PPUSH
69280: LD_INT 25
69282: PUSH
69283: LD_INT 2
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 24
69292: PUSH
69293: LD_INT 750
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PPUSH
69304: CALL_OW 72
69308: PUSH
69309: FOR_IN
69310: IFFALSE 69342
// begin tmp := tmp union j ;
69312: LD_ADDR_VAR 0 5
69316: PUSH
69317: LD_VAR 0 5
69321: PUSH
69322: LD_VAR 0 3
69326: UNION
69327: ST_TO_ADDR
// if tmp >= 5 then
69328: LD_VAR 0 5
69332: PUSH
69333: LD_INT 5
69335: GREATEREQUAL
69336: IFFALSE 69340
// break ;
69338: GO 69342
// end ;
69340: GO 69309
69342: POP
69343: POP
// end ; if not tmp then
69344: LD_VAR 0 5
69348: NOT
69349: IFFALSE 69353
// continue ;
69351: GO 68506
// for j in tmp do
69353: LD_ADDR_VAR 0 3
69357: PUSH
69358: LD_VAR 0 5
69362: PUSH
69363: FOR_IN
69364: IFFALSE 69454
// if not GetTag ( j ) then
69366: LD_VAR 0 3
69370: PPUSH
69371: CALL_OW 110
69375: NOT
69376: IFFALSE 69452
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69378: LD_ADDR_EXP 67
69382: PUSH
69383: LD_EXP 67
69387: PPUSH
69388: LD_VAR 0 2
69392: PUSH
69393: LD_EXP 67
69397: PUSH
69398: LD_VAR 0 2
69402: ARRAY
69403: PUSH
69404: LD_INT 1
69406: PLUS
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PPUSH
69412: LD_VAR 0 3
69416: PPUSH
69417: CALL 18573 0 3
69421: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69422: LD_VAR 0 3
69426: PPUSH
69427: LD_INT 107
69429: PPUSH
69430: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69434: LD_EXP 67
69438: PUSH
69439: LD_VAR 0 2
69443: ARRAY
69444: PUSH
69445: LD_INT 5
69447: GREATEREQUAL
69448: IFFALSE 69452
// break ;
69450: GO 69454
// end ;
69452: GO 69363
69454: POP
69455: POP
// end ; if mc_crates_collector [ i ] and target then
69456: LD_EXP 67
69460: PUSH
69461: LD_VAR 0 2
69465: ARRAY
69466: PUSH
69467: LD_VAR 0 7
69471: AND
69472: IFFALSE 69778
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69474: LD_EXP 67
69478: PUSH
69479: LD_VAR 0 2
69483: ARRAY
69484: PUSH
69485: LD_VAR 0 7
69489: PUSH
69490: LD_INT 1
69492: ARRAY
69493: LESS
69494: IFFALSE 69514
// tmp := mc_crates_collector [ i ] else
69496: LD_ADDR_VAR 0 5
69500: PUSH
69501: LD_EXP 67
69505: PUSH
69506: LD_VAR 0 2
69510: ARRAY
69511: ST_TO_ADDR
69512: GO 69528
// tmp := target [ 1 ] ;
69514: LD_ADDR_VAR 0 5
69518: PUSH
69519: LD_VAR 0 7
69523: PUSH
69524: LD_INT 1
69526: ARRAY
69527: ST_TO_ADDR
// k := 0 ;
69528: LD_ADDR_VAR 0 4
69532: PUSH
69533: LD_INT 0
69535: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69536: LD_ADDR_VAR 0 3
69540: PUSH
69541: LD_EXP 67
69545: PUSH
69546: LD_VAR 0 2
69550: ARRAY
69551: PUSH
69552: FOR_IN
69553: IFFALSE 69776
// begin k := k + 1 ;
69555: LD_ADDR_VAR 0 4
69559: PUSH
69560: LD_VAR 0 4
69564: PUSH
69565: LD_INT 1
69567: PLUS
69568: ST_TO_ADDR
// if k > tmp then
69569: LD_VAR 0 4
69573: PUSH
69574: LD_VAR 0 5
69578: GREATER
69579: IFFALSE 69583
// break ;
69581: GO 69776
// if not GetClass ( j ) in [ 2 , 16 ] then
69583: LD_VAR 0 3
69587: PPUSH
69588: CALL_OW 257
69592: PUSH
69593: LD_INT 2
69595: PUSH
69596: LD_INT 16
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: IN
69603: NOT
69604: IFFALSE 69657
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69606: LD_ADDR_EXP 67
69610: PUSH
69611: LD_EXP 67
69615: PPUSH
69616: LD_VAR 0 2
69620: PPUSH
69621: LD_EXP 67
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: PUSH
69632: LD_VAR 0 3
69636: DIFF
69637: PPUSH
69638: CALL_OW 1
69642: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69643: LD_VAR 0 3
69647: PPUSH
69648: LD_INT 0
69650: PPUSH
69651: CALL_OW 109
// continue ;
69655: GO 69552
// end ; if IsInUnit ( j ) then
69657: LD_VAR 0 3
69661: PPUSH
69662: CALL_OW 310
69666: IFFALSE 69677
// ComExitBuilding ( j ) ;
69668: LD_VAR 0 3
69672: PPUSH
69673: CALL_OW 122
// wait ( 3 ) ;
69677: LD_INT 3
69679: PPUSH
69680: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69684: LD_VAR 0 3
69688: PPUSH
69689: CALL_OW 314
69693: PUSH
69694: LD_VAR 0 6
69698: PPUSH
69699: LD_VAR 0 7
69703: PUSH
69704: LD_INT 2
69706: ARRAY
69707: PPUSH
69708: LD_VAR 0 7
69712: PUSH
69713: LD_INT 3
69715: ARRAY
69716: PPUSH
69717: LD_INT 30
69719: PPUSH
69720: CALL 19469 0 4
69724: PUSH
69725: LD_INT 4
69727: ARRAY
69728: AND
69729: IFFALSE 69747
// ComStandNearbyBuilding ( j , depot ) else
69731: LD_VAR 0 3
69735: PPUSH
69736: LD_VAR 0 9
69740: PPUSH
69741: CALL 15175 0 2
69745: GO 69774
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69747: LD_VAR 0 3
69751: PPUSH
69752: LD_VAR 0 7
69756: PUSH
69757: LD_INT 2
69759: ARRAY
69760: PPUSH
69761: LD_VAR 0 7
69765: PUSH
69766: LD_INT 3
69768: ARRAY
69769: PPUSH
69770: CALL_OW 117
// end ;
69774: GO 69552
69776: POP
69777: POP
// end ; end else
69778: GO 70310
// begin for j in cargo do
69780: LD_ADDR_VAR 0 3
69784: PUSH
69785: LD_VAR 0 8
69789: PUSH
69790: FOR_IN
69791: IFFALSE 70308
// begin if GetTag ( j ) <> 0 then
69793: LD_VAR 0 3
69797: PPUSH
69798: CALL_OW 110
69802: PUSH
69803: LD_INT 0
69805: NONEQUAL
69806: IFFALSE 69810
// continue ;
69808: GO 69790
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69810: LD_VAR 0 3
69814: PPUSH
69815: CALL_OW 256
69819: PUSH
69820: LD_INT 1000
69822: LESS
69823: PUSH
69824: LD_VAR 0 3
69828: PPUSH
69829: LD_EXP 74
69833: PUSH
69834: LD_VAR 0 2
69838: ARRAY
69839: PPUSH
69840: CALL_OW 308
69844: NOT
69845: AND
69846: IFFALSE 69868
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69848: LD_VAR 0 3
69852: PPUSH
69853: LD_EXP 74
69857: PUSH
69858: LD_VAR 0 2
69862: ARRAY
69863: PPUSH
69864: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69868: LD_VAR 0 3
69872: PPUSH
69873: CALL_OW 256
69877: PUSH
69878: LD_INT 1000
69880: LESS
69881: PUSH
69882: LD_VAR 0 3
69886: PPUSH
69887: LD_EXP 74
69891: PUSH
69892: LD_VAR 0 2
69896: ARRAY
69897: PPUSH
69898: CALL_OW 308
69902: AND
69903: IFFALSE 69907
// continue ;
69905: GO 69790
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69907: LD_VAR 0 3
69911: PPUSH
69912: CALL_OW 262
69916: PUSH
69917: LD_INT 2
69919: EQUAL
69920: PUSH
69921: LD_VAR 0 3
69925: PPUSH
69926: CALL_OW 261
69930: PUSH
69931: LD_INT 15
69933: LESS
69934: AND
69935: IFFALSE 69939
// continue ;
69937: GO 69790
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69939: LD_VAR 0 3
69943: PPUSH
69944: CALL_OW 262
69948: PUSH
69949: LD_INT 1
69951: EQUAL
69952: PUSH
69953: LD_VAR 0 3
69957: PPUSH
69958: CALL_OW 261
69962: PUSH
69963: LD_INT 10
69965: LESS
69966: AND
69967: IFFALSE 70247
// begin if not depot then
69969: LD_VAR 0 9
69973: NOT
69974: IFFALSE 69978
// continue ;
69976: GO 69790
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69978: LD_VAR 0 3
69982: PPUSH
69983: LD_VAR 0 9
69987: PPUSH
69988: LD_VAR 0 3
69992: PPUSH
69993: CALL_OW 74
69997: PPUSH
69998: CALL_OW 296
70002: PUSH
70003: LD_INT 6
70005: LESS
70006: IFFALSE 70022
// SetFuel ( j , 100 ) else
70008: LD_VAR 0 3
70012: PPUSH
70013: LD_INT 100
70015: PPUSH
70016: CALL_OW 240
70020: GO 70247
// if GetFuel ( j ) = 0 then
70022: LD_VAR 0 3
70026: PPUSH
70027: CALL_OW 261
70031: PUSH
70032: LD_INT 0
70034: EQUAL
70035: IFFALSE 70247
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70037: LD_ADDR_EXP 69
70041: PUSH
70042: LD_EXP 69
70046: PPUSH
70047: LD_VAR 0 2
70051: PPUSH
70052: LD_EXP 69
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: PUSH
70063: LD_VAR 0 3
70067: DIFF
70068: PPUSH
70069: CALL_OW 1
70073: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70074: LD_VAR 0 3
70078: PPUSH
70079: CALL_OW 263
70083: PUSH
70084: LD_INT 1
70086: EQUAL
70087: IFFALSE 70103
// ComExitVehicle ( IsInUnit ( j ) ) ;
70089: LD_VAR 0 3
70093: PPUSH
70094: CALL_OW 310
70098: PPUSH
70099: CALL_OW 121
// if GetControl ( j ) = control_remote then
70103: LD_VAR 0 3
70107: PPUSH
70108: CALL_OW 263
70112: PUSH
70113: LD_INT 2
70115: EQUAL
70116: IFFALSE 70127
// ComUnlink ( j ) ;
70118: LD_VAR 0 3
70122: PPUSH
70123: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
70127: LD_ADDR_VAR 0 10
70131: PUSH
70132: LD_VAR 0 2
70136: PPUSH
70137: LD_INT 3
70139: PPUSH
70140: CALL 79891 0 2
70144: ST_TO_ADDR
// if fac then
70145: LD_VAR 0 10
70149: IFFALSE 70245
// begin for k in fac do
70151: LD_ADDR_VAR 0 4
70155: PUSH
70156: LD_VAR 0 10
70160: PUSH
70161: FOR_IN
70162: IFFALSE 70243
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70164: LD_ADDR_VAR 0 11
70168: PUSH
70169: LD_VAR 0 10
70173: PPUSH
70174: LD_VAR 0 3
70178: PPUSH
70179: CALL_OW 265
70183: PPUSH
70184: LD_VAR 0 3
70188: PPUSH
70189: CALL_OW 262
70193: PPUSH
70194: LD_VAR 0 3
70198: PPUSH
70199: CALL_OW 263
70203: PPUSH
70204: LD_VAR 0 3
70208: PPUSH
70209: CALL_OW 264
70213: PPUSH
70214: CALL 16071 0 5
70218: ST_TO_ADDR
// if components then
70219: LD_VAR 0 11
70223: IFFALSE 70241
// begin MC_InsertProduceList ( i , components ) ;
70225: LD_VAR 0 2
70229: PPUSH
70230: LD_VAR 0 11
70234: PPUSH
70235: CALL 79436 0 2
// break ;
70239: GO 70243
// end ; end ;
70241: GO 70161
70243: POP
70244: POP
// end ; continue ;
70245: GO 69790
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70247: LD_VAR 0 3
70251: PPUSH
70252: LD_INT 1
70254: PPUSH
70255: CALL_OW 289
70259: PUSH
70260: LD_INT 100
70262: LESS
70263: PUSH
70264: LD_VAR 0 3
70268: PPUSH
70269: CALL_OW 314
70273: NOT
70274: AND
70275: IFFALSE 70304
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70277: LD_VAR 0 3
70281: PPUSH
70282: LD_VAR 0 7
70286: PUSH
70287: LD_INT 2
70289: ARRAY
70290: PPUSH
70291: LD_VAR 0 7
70295: PUSH
70296: LD_INT 3
70298: ARRAY
70299: PPUSH
70300: CALL_OW 117
// break ;
70304: GO 70308
// end ;
70306: GO 69790
70308: POP
70309: POP
// end ; end ;
70310: GO 68506
70312: POP
70313: POP
// end ;
70314: LD_VAR 0 1
70318: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70319: LD_INT 0
70321: PPUSH
70322: PPUSH
70323: PPUSH
70324: PPUSH
// if not mc_bases then
70325: LD_EXP 50
70329: NOT
70330: IFFALSE 70334
// exit ;
70332: GO 70495
// for i = 1 to mc_bases do
70334: LD_ADDR_VAR 0 2
70338: PUSH
70339: DOUBLE
70340: LD_INT 1
70342: DEC
70343: ST_TO_ADDR
70344: LD_EXP 50
70348: PUSH
70349: FOR_TO
70350: IFFALSE 70493
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70352: LD_ADDR_VAR 0 4
70356: PUSH
70357: LD_EXP 69
70361: PUSH
70362: LD_VAR 0 2
70366: ARRAY
70367: PUSH
70368: LD_EXP 72
70372: PUSH
70373: LD_VAR 0 2
70377: ARRAY
70378: UNION
70379: PPUSH
70380: LD_INT 33
70382: PUSH
70383: LD_INT 2
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PPUSH
70390: CALL_OW 72
70394: ST_TO_ADDR
// if tmp then
70395: LD_VAR 0 4
70399: IFFALSE 70491
// for j in tmp do
70401: LD_ADDR_VAR 0 3
70405: PUSH
70406: LD_VAR 0 4
70410: PUSH
70411: FOR_IN
70412: IFFALSE 70489
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70414: LD_VAR 0 3
70418: PPUSH
70419: CALL_OW 312
70423: NOT
70424: PUSH
70425: LD_VAR 0 3
70429: PPUSH
70430: CALL_OW 256
70434: PUSH
70435: LD_INT 250
70437: GREATEREQUAL
70438: AND
70439: IFFALSE 70452
// Connect ( j ) else
70441: LD_VAR 0 3
70445: PPUSH
70446: CALL 21551 0 1
70450: GO 70487
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70452: LD_VAR 0 3
70456: PPUSH
70457: CALL_OW 256
70461: PUSH
70462: LD_INT 250
70464: LESS
70465: PUSH
70466: LD_VAR 0 3
70470: PPUSH
70471: CALL_OW 312
70475: AND
70476: IFFALSE 70487
// ComUnlink ( j ) ;
70478: LD_VAR 0 3
70482: PPUSH
70483: CALL_OW 136
70487: GO 70411
70489: POP
70490: POP
// end ;
70491: GO 70349
70493: POP
70494: POP
// end ;
70495: LD_VAR 0 1
70499: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70500: LD_INT 0
70502: PPUSH
70503: PPUSH
70504: PPUSH
70505: PPUSH
70506: PPUSH
// if not mc_bases then
70507: LD_EXP 50
70511: NOT
70512: IFFALSE 70516
// exit ;
70514: GO 70961
// for i = 1 to mc_bases do
70516: LD_ADDR_VAR 0 2
70520: PUSH
70521: DOUBLE
70522: LD_INT 1
70524: DEC
70525: ST_TO_ADDR
70526: LD_EXP 50
70530: PUSH
70531: FOR_TO
70532: IFFALSE 70959
// begin if not mc_produce [ i ] then
70534: LD_EXP 71
70538: PUSH
70539: LD_VAR 0 2
70543: ARRAY
70544: NOT
70545: IFFALSE 70549
// continue ;
70547: GO 70531
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70549: LD_ADDR_VAR 0 5
70553: PUSH
70554: LD_EXP 50
70558: PUSH
70559: LD_VAR 0 2
70563: ARRAY
70564: PPUSH
70565: LD_INT 30
70567: PUSH
70568: LD_INT 3
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PPUSH
70575: CALL_OW 72
70579: ST_TO_ADDR
// if not fac then
70580: LD_VAR 0 5
70584: NOT
70585: IFFALSE 70589
// continue ;
70587: GO 70531
// for j in fac do
70589: LD_ADDR_VAR 0 3
70593: PUSH
70594: LD_VAR 0 5
70598: PUSH
70599: FOR_IN
70600: IFFALSE 70955
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70602: LD_VAR 0 3
70606: PPUSH
70607: CALL_OW 461
70611: PUSH
70612: LD_INT 2
70614: NONEQUAL
70615: PUSH
70616: LD_VAR 0 3
70620: PPUSH
70621: LD_INT 15
70623: PPUSH
70624: CALL 21170 0 2
70628: PUSH
70629: LD_INT 4
70631: ARRAY
70632: OR
70633: IFFALSE 70637
// continue ;
70635: GO 70599
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70637: LD_VAR 0 3
70641: PPUSH
70642: LD_EXP 71
70646: PUSH
70647: LD_VAR 0 2
70651: ARRAY
70652: PUSH
70653: LD_INT 1
70655: ARRAY
70656: PUSH
70657: LD_INT 1
70659: ARRAY
70660: PPUSH
70661: LD_EXP 71
70665: PUSH
70666: LD_VAR 0 2
70670: ARRAY
70671: PUSH
70672: LD_INT 1
70674: ARRAY
70675: PUSH
70676: LD_INT 2
70678: ARRAY
70679: PPUSH
70680: LD_EXP 71
70684: PUSH
70685: LD_VAR 0 2
70689: ARRAY
70690: PUSH
70691: LD_INT 1
70693: ARRAY
70694: PUSH
70695: LD_INT 3
70697: ARRAY
70698: PPUSH
70699: LD_EXP 71
70703: PUSH
70704: LD_VAR 0 2
70708: ARRAY
70709: PUSH
70710: LD_INT 1
70712: ARRAY
70713: PUSH
70714: LD_INT 4
70716: ARRAY
70717: PPUSH
70718: CALL_OW 448
70722: PUSH
70723: LD_VAR 0 3
70727: PPUSH
70728: LD_EXP 71
70732: PUSH
70733: LD_VAR 0 2
70737: ARRAY
70738: PUSH
70739: LD_INT 1
70741: ARRAY
70742: PUSH
70743: LD_INT 1
70745: ARRAY
70746: PUSH
70747: LD_EXP 71
70751: PUSH
70752: LD_VAR 0 2
70756: ARRAY
70757: PUSH
70758: LD_INT 1
70760: ARRAY
70761: PUSH
70762: LD_INT 2
70764: ARRAY
70765: PUSH
70766: LD_EXP 71
70770: PUSH
70771: LD_VAR 0 2
70775: ARRAY
70776: PUSH
70777: LD_INT 1
70779: ARRAY
70780: PUSH
70781: LD_INT 3
70783: ARRAY
70784: PUSH
70785: LD_EXP 71
70789: PUSH
70790: LD_VAR 0 2
70794: ARRAY
70795: PUSH
70796: LD_INT 1
70798: ARRAY
70799: PUSH
70800: LD_INT 4
70802: ARRAY
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: PPUSH
70810: CALL 24946 0 2
70814: AND
70815: IFFALSE 70953
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70817: LD_VAR 0 3
70821: PPUSH
70822: LD_EXP 71
70826: PUSH
70827: LD_VAR 0 2
70831: ARRAY
70832: PUSH
70833: LD_INT 1
70835: ARRAY
70836: PUSH
70837: LD_INT 1
70839: ARRAY
70840: PPUSH
70841: LD_EXP 71
70845: PUSH
70846: LD_VAR 0 2
70850: ARRAY
70851: PUSH
70852: LD_INT 1
70854: ARRAY
70855: PUSH
70856: LD_INT 2
70858: ARRAY
70859: PPUSH
70860: LD_EXP 71
70864: PUSH
70865: LD_VAR 0 2
70869: ARRAY
70870: PUSH
70871: LD_INT 1
70873: ARRAY
70874: PUSH
70875: LD_INT 3
70877: ARRAY
70878: PPUSH
70879: LD_EXP 71
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: PUSH
70890: LD_INT 1
70892: ARRAY
70893: PUSH
70894: LD_INT 4
70896: ARRAY
70897: PPUSH
70898: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70902: LD_ADDR_VAR 0 4
70906: PUSH
70907: LD_EXP 71
70911: PUSH
70912: LD_VAR 0 2
70916: ARRAY
70917: PPUSH
70918: LD_INT 1
70920: PPUSH
70921: CALL_OW 3
70925: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70926: LD_ADDR_EXP 71
70930: PUSH
70931: LD_EXP 71
70935: PPUSH
70936: LD_VAR 0 2
70940: PPUSH
70941: LD_VAR 0 4
70945: PPUSH
70946: CALL_OW 1
70950: ST_TO_ADDR
// break ;
70951: GO 70955
// end ; end ;
70953: GO 70599
70955: POP
70956: POP
// end ;
70957: GO 70531
70959: POP
70960: POP
// end ;
70961: LD_VAR 0 1
70965: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70966: LD_INT 0
70968: PPUSH
70969: PPUSH
70970: PPUSH
// if not mc_bases then
70971: LD_EXP 50
70975: NOT
70976: IFFALSE 70980
// exit ;
70978: GO 71069
// for i = 1 to mc_bases do
70980: LD_ADDR_VAR 0 2
70984: PUSH
70985: DOUBLE
70986: LD_INT 1
70988: DEC
70989: ST_TO_ADDR
70990: LD_EXP 50
70994: PUSH
70995: FOR_TO
70996: IFFALSE 71067
// begin if mc_attack [ i ] then
70998: LD_EXP 70
71002: PUSH
71003: LD_VAR 0 2
71007: ARRAY
71008: IFFALSE 71065
// begin tmp := mc_attack [ i ] [ 1 ] ;
71010: LD_ADDR_VAR 0 3
71014: PUSH
71015: LD_EXP 70
71019: PUSH
71020: LD_VAR 0 2
71024: ARRAY
71025: PUSH
71026: LD_INT 1
71028: ARRAY
71029: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71030: LD_ADDR_EXP 70
71034: PUSH
71035: LD_EXP 70
71039: PPUSH
71040: LD_VAR 0 2
71044: PPUSH
71045: EMPTY
71046: PPUSH
71047: CALL_OW 1
71051: ST_TO_ADDR
// Attack ( tmp ) ;
71052: LD_VAR 0 3
71056: PPUSH
71057: CALL 105953 0 1
// exit ;
71061: POP
71062: POP
71063: GO 71069
// end ; end ;
71065: GO 70995
71067: POP
71068: POP
// end ;
71069: LD_VAR 0 1
71073: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71074: LD_INT 0
71076: PPUSH
71077: PPUSH
71078: PPUSH
71079: PPUSH
71080: PPUSH
71081: PPUSH
71082: PPUSH
// if not mc_bases then
71083: LD_EXP 50
71087: NOT
71088: IFFALSE 71092
// exit ;
71090: GO 71949
// for i = 1 to mc_bases do
71092: LD_ADDR_VAR 0 2
71096: PUSH
71097: DOUBLE
71098: LD_INT 1
71100: DEC
71101: ST_TO_ADDR
71102: LD_EXP 50
71106: PUSH
71107: FOR_TO
71108: IFFALSE 71947
// begin if not mc_bases [ i ] then
71110: LD_EXP 50
71114: PUSH
71115: LD_VAR 0 2
71119: ARRAY
71120: NOT
71121: IFFALSE 71125
// continue ;
71123: GO 71107
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71125: LD_ADDR_VAR 0 7
71129: PUSH
71130: LD_EXP 50
71134: PUSH
71135: LD_VAR 0 2
71139: ARRAY
71140: PUSH
71141: LD_INT 1
71143: ARRAY
71144: PPUSH
71145: CALL 15397 0 1
71149: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71150: LD_ADDR_EXP 73
71154: PUSH
71155: LD_EXP 73
71159: PPUSH
71160: LD_VAR 0 2
71164: PPUSH
71165: LD_EXP 50
71169: PUSH
71170: LD_VAR 0 2
71174: ARRAY
71175: PUSH
71176: LD_INT 1
71178: ARRAY
71179: PPUSH
71180: CALL_OW 255
71184: PPUSH
71185: LD_EXP 75
71189: PUSH
71190: LD_VAR 0 2
71194: ARRAY
71195: PPUSH
71196: CALL 15362 0 2
71200: PPUSH
71201: CALL_OW 1
71205: ST_TO_ADDR
// if not mc_scan [ i ] then
71206: LD_EXP 73
71210: PUSH
71211: LD_VAR 0 2
71215: ARRAY
71216: NOT
71217: IFFALSE 71395
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
71219: LD_ADDR_EXP 93
71223: PUSH
71224: LD_EXP 93
71228: PPUSH
71229: LD_VAR 0 2
71233: PPUSH
71234: LD_INT 0
71236: PPUSH
71237: CALL_OW 1
71241: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71242: LD_ADDR_VAR 0 4
71246: PUSH
71247: LD_EXP 50
71251: PUSH
71252: LD_VAR 0 2
71256: ARRAY
71257: PPUSH
71258: LD_INT 2
71260: PUSH
71261: LD_INT 25
71263: PUSH
71264: LD_INT 5
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 25
71273: PUSH
71274: LD_INT 8
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 25
71283: PUSH
71284: LD_INT 9
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: PPUSH
71297: CALL_OW 72
71301: ST_TO_ADDR
// if not tmp then
71302: LD_VAR 0 4
71306: NOT
71307: IFFALSE 71311
// continue ;
71309: GO 71107
// for j in tmp do
71311: LD_ADDR_VAR 0 3
71315: PUSH
71316: LD_VAR 0 4
71320: PUSH
71321: FOR_IN
71322: IFFALSE 71393
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71324: LD_VAR 0 3
71328: PPUSH
71329: CALL_OW 310
71333: PPUSH
71334: CALL_OW 266
71338: PUSH
71339: LD_INT 5
71341: EQUAL
71342: PUSH
71343: LD_VAR 0 3
71347: PPUSH
71348: CALL_OW 257
71352: PUSH
71353: LD_INT 1
71355: EQUAL
71356: AND
71357: PUSH
71358: LD_VAR 0 3
71362: PPUSH
71363: CALL_OW 459
71367: NOT
71368: AND
71369: PUSH
71370: LD_VAR 0 7
71374: AND
71375: IFFALSE 71391
// ComChangeProfession ( j , class ) ;
71377: LD_VAR 0 3
71381: PPUSH
71382: LD_VAR 0 7
71386: PPUSH
71387: CALL_OW 123
71391: GO 71321
71393: POP
71394: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71395: LD_EXP 73
71399: PUSH
71400: LD_VAR 0 2
71404: ARRAY
71405: PUSH
71406: LD_EXP 93
71410: PUSH
71411: LD_VAR 0 2
71415: ARRAY
71416: NOT
71417: AND
71418: PUSH
71419: LD_EXP 72
71423: PUSH
71424: LD_VAR 0 2
71428: ARRAY
71429: NOT
71430: AND
71431: PUSH
71432: LD_EXP 50
71436: PUSH
71437: LD_VAR 0 2
71441: ARRAY
71442: PPUSH
71443: LD_INT 50
71445: PUSH
71446: EMPTY
71447: LIST
71448: PUSH
71449: LD_INT 2
71451: PUSH
71452: LD_INT 30
71454: PUSH
71455: LD_INT 32
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 30
71464: PUSH
71465: LD_INT 33
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 30
71474: PUSH
71475: LD_INT 4
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 30
71484: PUSH
71485: LD_INT 5
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PPUSH
71503: CALL_OW 72
71507: PUSH
71508: LD_INT 4
71510: LESS
71511: PUSH
71512: LD_EXP 50
71516: PUSH
71517: LD_VAR 0 2
71521: ARRAY
71522: PPUSH
71523: LD_INT 3
71525: PUSH
71526: LD_INT 24
71528: PUSH
71529: LD_INT 1000
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 2
71542: PUSH
71543: LD_INT 30
71545: PUSH
71546: LD_INT 0
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 30
71555: PUSH
71556: LD_INT 1
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: EMPTY
71564: LIST
71565: LIST
71566: LIST
71567: PUSH
71568: EMPTY
71569: LIST
71570: LIST
71571: PPUSH
71572: CALL_OW 72
71576: OR
71577: AND
71578: IFFALSE 71829
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71580: LD_ADDR_EXP 93
71584: PUSH
71585: LD_EXP 93
71589: PPUSH
71590: LD_VAR 0 2
71594: PPUSH
71595: LD_INT 1
71597: PPUSH
71598: CALL_OW 1
71602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71603: LD_ADDR_VAR 0 4
71607: PUSH
71608: LD_EXP 50
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: PPUSH
71619: LD_INT 2
71621: PUSH
71622: LD_INT 25
71624: PUSH
71625: LD_INT 1
71627: PUSH
71628: EMPTY
71629: LIST
71630: LIST
71631: PUSH
71632: LD_INT 25
71634: PUSH
71635: LD_INT 5
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PUSH
71642: LD_INT 25
71644: PUSH
71645: LD_INT 8
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 25
71654: PUSH
71655: LD_INT 9
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: PPUSH
71669: CALL_OW 72
71673: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71674: LD_ADDR_VAR 0 4
71678: PUSH
71679: LD_VAR 0 4
71683: PUSH
71684: LD_VAR 0 4
71688: PPUSH
71689: LD_INT 18
71691: PPUSH
71692: CALL 48514 0 2
71696: DIFF
71697: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71698: LD_VAR 0 4
71702: NOT
71703: PUSH
71704: LD_EXP 50
71708: PUSH
71709: LD_VAR 0 2
71713: ARRAY
71714: PPUSH
71715: LD_INT 2
71717: PUSH
71718: LD_INT 30
71720: PUSH
71721: LD_INT 4
71723: PUSH
71724: EMPTY
71725: LIST
71726: LIST
71727: PUSH
71728: LD_INT 30
71730: PUSH
71731: LD_INT 5
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: LIST
71742: PPUSH
71743: CALL_OW 72
71747: NOT
71748: AND
71749: IFFALSE 71811
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71751: LD_ADDR_VAR 0 4
71755: PUSH
71756: LD_EXP 50
71760: PUSH
71761: LD_VAR 0 2
71765: ARRAY
71766: PPUSH
71767: LD_INT 2
71769: PUSH
71770: LD_INT 25
71772: PUSH
71773: LD_INT 2
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 25
71782: PUSH
71783: LD_INT 3
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 25
71792: PUSH
71793: LD_INT 4
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: PPUSH
71806: CALL_OW 72
71810: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71811: LD_VAR 0 2
71815: PPUSH
71816: LD_VAR 0 4
71820: PPUSH
71821: CALL 110662 0 2
// exit ;
71825: POP
71826: POP
71827: GO 71949
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71829: LD_EXP 73
71833: PUSH
71834: LD_VAR 0 2
71838: ARRAY
71839: PUSH
71840: LD_EXP 93
71844: PUSH
71845: LD_VAR 0 2
71849: ARRAY
71850: NOT
71851: AND
71852: PUSH
71853: LD_EXP 72
71857: PUSH
71858: LD_VAR 0 2
71862: ARRAY
71863: AND
71864: IFFALSE 71945
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71866: LD_ADDR_EXP 93
71870: PUSH
71871: LD_EXP 93
71875: PPUSH
71876: LD_VAR 0 2
71880: PPUSH
71881: LD_INT 1
71883: PPUSH
71884: CALL_OW 1
71888: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71889: LD_ADDR_VAR 0 4
71893: PUSH
71894: LD_EXP 72
71898: PUSH
71899: LD_VAR 0 2
71903: ARRAY
71904: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71905: LD_ADDR_EXP 72
71909: PUSH
71910: LD_EXP 72
71914: PPUSH
71915: LD_VAR 0 2
71919: PPUSH
71920: EMPTY
71921: PPUSH
71922: CALL_OW 1
71926: ST_TO_ADDR
// Defend ( i , tmp ) ;
71927: LD_VAR 0 2
71931: PPUSH
71932: LD_VAR 0 4
71936: PPUSH
71937: CALL 111258 0 2
// exit ;
71941: POP
71942: POP
71943: GO 71949
// end ; end ;
71945: GO 71107
71947: POP
71948: POP
// end ;
71949: LD_VAR 0 1
71953: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71954: LD_INT 0
71956: PPUSH
71957: PPUSH
71958: PPUSH
71959: PPUSH
71960: PPUSH
71961: PPUSH
71962: PPUSH
71963: PPUSH
71964: PPUSH
71965: PPUSH
71966: PPUSH
// if not mc_bases then
71967: LD_EXP 50
71971: NOT
71972: IFFALSE 71976
// exit ;
71974: GO 73063
// for i = 1 to mc_bases do
71976: LD_ADDR_VAR 0 2
71980: PUSH
71981: DOUBLE
71982: LD_INT 1
71984: DEC
71985: ST_TO_ADDR
71986: LD_EXP 50
71990: PUSH
71991: FOR_TO
71992: IFFALSE 73061
// begin tmp := mc_lab [ i ] ;
71994: LD_ADDR_VAR 0 6
71998: PUSH
71999: LD_EXP 83
72003: PUSH
72004: LD_VAR 0 2
72008: ARRAY
72009: ST_TO_ADDR
// if not tmp then
72010: LD_VAR 0 6
72014: NOT
72015: IFFALSE 72019
// continue ;
72017: GO 71991
// idle_lab := 0 ;
72019: LD_ADDR_VAR 0 11
72023: PUSH
72024: LD_INT 0
72026: ST_TO_ADDR
// for j in tmp do
72027: LD_ADDR_VAR 0 3
72031: PUSH
72032: LD_VAR 0 6
72036: PUSH
72037: FOR_IN
72038: IFFALSE 73057
// begin researching := false ;
72040: LD_ADDR_VAR 0 10
72044: PUSH
72045: LD_INT 0
72047: ST_TO_ADDR
// side := GetSide ( j ) ;
72048: LD_ADDR_VAR 0 4
72052: PUSH
72053: LD_VAR 0 3
72057: PPUSH
72058: CALL_OW 255
72062: ST_TO_ADDR
// if not mc_tech [ side ] then
72063: LD_EXP 77
72067: PUSH
72068: LD_VAR 0 4
72072: ARRAY
72073: NOT
72074: IFFALSE 72078
// continue ;
72076: GO 72037
// if BuildingStatus ( j ) = bs_idle then
72078: LD_VAR 0 3
72082: PPUSH
72083: CALL_OW 461
72087: PUSH
72088: LD_INT 2
72090: EQUAL
72091: IFFALSE 72279
// begin if idle_lab and UnitsInside ( j ) < 6 then
72093: LD_VAR 0 11
72097: PUSH
72098: LD_VAR 0 3
72102: PPUSH
72103: CALL_OW 313
72107: PUSH
72108: LD_INT 6
72110: LESS
72111: AND
72112: IFFALSE 72183
// begin tmp2 := UnitsInside ( idle_lab ) ;
72114: LD_ADDR_VAR 0 9
72118: PUSH
72119: LD_VAR 0 11
72123: PPUSH
72124: CALL_OW 313
72128: ST_TO_ADDR
// if tmp2 then
72129: LD_VAR 0 9
72133: IFFALSE 72175
// for x in tmp2 do
72135: LD_ADDR_VAR 0 7
72139: PUSH
72140: LD_VAR 0 9
72144: PUSH
72145: FOR_IN
72146: IFFALSE 72173
// begin ComExitBuilding ( x ) ;
72148: LD_VAR 0 7
72152: PPUSH
72153: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72157: LD_VAR 0 7
72161: PPUSH
72162: LD_VAR 0 3
72166: PPUSH
72167: CALL_OW 180
// end ;
72171: GO 72145
72173: POP
72174: POP
// idle_lab := 0 ;
72175: LD_ADDR_VAR 0 11
72179: PUSH
72180: LD_INT 0
72182: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72183: LD_ADDR_VAR 0 5
72187: PUSH
72188: LD_EXP 77
72192: PUSH
72193: LD_VAR 0 4
72197: ARRAY
72198: PUSH
72199: FOR_IN
72200: IFFALSE 72260
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72202: LD_VAR 0 3
72206: PPUSH
72207: LD_VAR 0 5
72211: PPUSH
72212: CALL_OW 430
72216: PUSH
72217: LD_VAR 0 4
72221: PPUSH
72222: LD_VAR 0 5
72226: PPUSH
72227: CALL 14467 0 2
72231: AND
72232: IFFALSE 72258
// begin researching := true ;
72234: LD_ADDR_VAR 0 10
72238: PUSH
72239: LD_INT 1
72241: ST_TO_ADDR
// ComResearch ( j , t ) ;
72242: LD_VAR 0 3
72246: PPUSH
72247: LD_VAR 0 5
72251: PPUSH
72252: CALL_OW 124
// break ;
72256: GO 72260
// end ;
72258: GO 72199
72260: POP
72261: POP
// if not researching then
72262: LD_VAR 0 10
72266: NOT
72267: IFFALSE 72279
// idle_lab := j ;
72269: LD_ADDR_VAR 0 11
72273: PUSH
72274: LD_VAR 0 3
72278: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72279: LD_VAR 0 3
72283: PPUSH
72284: CALL_OW 461
72288: PUSH
72289: LD_INT 10
72291: EQUAL
72292: IFFALSE 72880
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72294: LD_EXP 79
72298: PUSH
72299: LD_VAR 0 2
72303: ARRAY
72304: NOT
72305: PUSH
72306: LD_EXP 80
72310: PUSH
72311: LD_VAR 0 2
72315: ARRAY
72316: NOT
72317: AND
72318: PUSH
72319: LD_EXP 77
72323: PUSH
72324: LD_VAR 0 4
72328: ARRAY
72329: PUSH
72330: LD_INT 1
72332: GREATER
72333: AND
72334: IFFALSE 72465
// begin ComCancel ( j ) ;
72336: LD_VAR 0 3
72340: PPUSH
72341: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72345: LD_ADDR_EXP 77
72349: PUSH
72350: LD_EXP 77
72354: PPUSH
72355: LD_VAR 0 4
72359: PPUSH
72360: LD_EXP 77
72364: PUSH
72365: LD_VAR 0 4
72369: ARRAY
72370: PPUSH
72371: LD_EXP 77
72375: PUSH
72376: LD_VAR 0 4
72380: ARRAY
72381: PUSH
72382: LD_INT 1
72384: MINUS
72385: PPUSH
72386: LD_EXP 77
72390: PUSH
72391: LD_VAR 0 4
72395: ARRAY
72396: PPUSH
72397: LD_INT 0
72399: PPUSH
72400: CALL 17991 0 4
72404: PPUSH
72405: CALL_OW 1
72409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72410: LD_ADDR_EXP 77
72414: PUSH
72415: LD_EXP 77
72419: PPUSH
72420: LD_VAR 0 4
72424: PPUSH
72425: LD_EXP 77
72429: PUSH
72430: LD_VAR 0 4
72434: ARRAY
72435: PPUSH
72436: LD_EXP 77
72440: PUSH
72441: LD_VAR 0 4
72445: ARRAY
72446: PPUSH
72447: LD_INT 1
72449: PPUSH
72450: LD_INT 0
72452: PPUSH
72453: CALL 17991 0 4
72457: PPUSH
72458: CALL_OW 1
72462: ST_TO_ADDR
// continue ;
72463: GO 72037
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72465: LD_EXP 79
72469: PUSH
72470: LD_VAR 0 2
72474: ARRAY
72475: PUSH
72476: LD_EXP 80
72480: PUSH
72481: LD_VAR 0 2
72485: ARRAY
72486: NOT
72487: AND
72488: IFFALSE 72615
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72490: LD_ADDR_EXP 80
72494: PUSH
72495: LD_EXP 80
72499: PPUSH
72500: LD_VAR 0 2
72504: PUSH
72505: LD_EXP 80
72509: PUSH
72510: LD_VAR 0 2
72514: ARRAY
72515: PUSH
72516: LD_INT 1
72518: PLUS
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PPUSH
72524: LD_EXP 79
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: CALL 18573 0 3
72543: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72544: LD_EXP 79
72548: PUSH
72549: LD_VAR 0 2
72553: ARRAY
72554: PUSH
72555: LD_INT 1
72557: ARRAY
72558: PPUSH
72559: LD_INT 112
72561: PPUSH
72562: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72566: LD_ADDR_VAR 0 9
72570: PUSH
72571: LD_EXP 79
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PPUSH
72582: LD_INT 1
72584: PPUSH
72585: CALL_OW 3
72589: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72590: LD_ADDR_EXP 79
72594: PUSH
72595: LD_EXP 79
72599: PPUSH
72600: LD_VAR 0 2
72604: PPUSH
72605: LD_VAR 0 9
72609: PPUSH
72610: CALL_OW 1
72614: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72615: LD_EXP 79
72619: PUSH
72620: LD_VAR 0 2
72624: ARRAY
72625: PUSH
72626: LD_EXP 80
72630: PUSH
72631: LD_VAR 0 2
72635: ARRAY
72636: AND
72637: PUSH
72638: LD_EXP 80
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: PUSH
72649: LD_INT 1
72651: ARRAY
72652: PPUSH
72653: CALL_OW 310
72657: NOT
72658: AND
72659: PUSH
72660: LD_VAR 0 3
72664: PPUSH
72665: CALL_OW 313
72669: PUSH
72670: LD_INT 6
72672: EQUAL
72673: AND
72674: IFFALSE 72730
// begin tmp2 := UnitsInside ( j ) ;
72676: LD_ADDR_VAR 0 9
72680: PUSH
72681: LD_VAR 0 3
72685: PPUSH
72686: CALL_OW 313
72690: ST_TO_ADDR
// if tmp2 = 6 then
72691: LD_VAR 0 9
72695: PUSH
72696: LD_INT 6
72698: EQUAL
72699: IFFALSE 72730
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72701: LD_VAR 0 9
72705: PUSH
72706: LD_INT 1
72708: ARRAY
72709: PPUSH
72710: LD_INT 112
72712: PPUSH
72713: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72717: LD_VAR 0 9
72721: PUSH
72722: LD_INT 1
72724: ARRAY
72725: PPUSH
72726: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72730: LD_EXP 80
72734: PUSH
72735: LD_VAR 0 2
72739: ARRAY
72740: PUSH
72741: LD_EXP 80
72745: PUSH
72746: LD_VAR 0 2
72750: ARRAY
72751: PUSH
72752: LD_INT 1
72754: ARRAY
72755: PPUSH
72756: CALL_OW 314
72760: NOT
72761: AND
72762: PUSH
72763: LD_EXP 80
72767: PUSH
72768: LD_VAR 0 2
72772: ARRAY
72773: PUSH
72774: LD_INT 1
72776: ARRAY
72777: PPUSH
72778: CALL_OW 310
72782: NOT
72783: AND
72784: IFFALSE 72810
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72786: LD_EXP 80
72790: PUSH
72791: LD_VAR 0 2
72795: ARRAY
72796: PUSH
72797: LD_INT 1
72799: ARRAY
72800: PPUSH
72801: LD_VAR 0 3
72805: PPUSH
72806: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72810: LD_EXP 80
72814: PUSH
72815: LD_VAR 0 2
72819: ARRAY
72820: PUSH
72821: LD_INT 1
72823: ARRAY
72824: PPUSH
72825: CALL_OW 310
72829: PUSH
72830: LD_EXP 80
72834: PUSH
72835: LD_VAR 0 2
72839: ARRAY
72840: PUSH
72841: LD_INT 1
72843: ARRAY
72844: PPUSH
72845: CALL_OW 310
72849: PPUSH
72850: CALL_OW 461
72854: PUSH
72855: LD_INT 3
72857: NONEQUAL
72858: AND
72859: IFFALSE 72880
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72861: LD_EXP 80
72865: PUSH
72866: LD_VAR 0 2
72870: ARRAY
72871: PUSH
72872: LD_INT 1
72874: ARRAY
72875: PPUSH
72876: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72880: LD_VAR 0 3
72884: PPUSH
72885: CALL_OW 461
72889: PUSH
72890: LD_INT 6
72892: EQUAL
72893: PUSH
72894: LD_VAR 0 6
72898: PUSH
72899: LD_INT 1
72901: GREATER
72902: AND
72903: IFFALSE 73055
// begin sci := [ ] ;
72905: LD_ADDR_VAR 0 8
72909: PUSH
72910: EMPTY
72911: ST_TO_ADDR
// for x in ( tmp diff j ) do
72912: LD_ADDR_VAR 0 7
72916: PUSH
72917: LD_VAR 0 6
72921: PUSH
72922: LD_VAR 0 3
72926: DIFF
72927: PUSH
72928: FOR_IN
72929: IFFALSE 72981
// begin if sci = 6 then
72931: LD_VAR 0 8
72935: PUSH
72936: LD_INT 6
72938: EQUAL
72939: IFFALSE 72943
// break ;
72941: GO 72981
// if BuildingStatus ( x ) = bs_idle then
72943: LD_VAR 0 7
72947: PPUSH
72948: CALL_OW 461
72952: PUSH
72953: LD_INT 2
72955: EQUAL
72956: IFFALSE 72979
// sci := sci ^ UnitsInside ( x ) ;
72958: LD_ADDR_VAR 0 8
72962: PUSH
72963: LD_VAR 0 8
72967: PUSH
72968: LD_VAR 0 7
72972: PPUSH
72973: CALL_OW 313
72977: ADD
72978: ST_TO_ADDR
// end ;
72979: GO 72928
72981: POP
72982: POP
// if not sci then
72983: LD_VAR 0 8
72987: NOT
72988: IFFALSE 72992
// continue ;
72990: GO 72037
// for x in sci do
72992: LD_ADDR_VAR 0 7
72996: PUSH
72997: LD_VAR 0 8
73001: PUSH
73002: FOR_IN
73003: IFFALSE 73053
// if IsInUnit ( x ) and not HasTask ( x ) then
73005: LD_VAR 0 7
73009: PPUSH
73010: CALL_OW 310
73014: PUSH
73015: LD_VAR 0 7
73019: PPUSH
73020: CALL_OW 314
73024: NOT
73025: AND
73026: IFFALSE 73051
// begin ComExitBuilding ( x ) ;
73028: LD_VAR 0 7
73032: PPUSH
73033: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73037: LD_VAR 0 7
73041: PPUSH
73042: LD_VAR 0 3
73046: PPUSH
73047: CALL_OW 180
// end ;
73051: GO 73002
73053: POP
73054: POP
// end ; end ;
73055: GO 72037
73057: POP
73058: POP
// end ;
73059: GO 71991
73061: POP
73062: POP
// end ;
73063: LD_VAR 0 1
73067: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73068: LD_INT 0
73070: PPUSH
73071: PPUSH
// if not mc_bases then
73072: LD_EXP 50
73076: NOT
73077: IFFALSE 73081
// exit ;
73079: GO 73162
// for i = 1 to mc_bases do
73081: LD_ADDR_VAR 0 2
73085: PUSH
73086: DOUBLE
73087: LD_INT 1
73089: DEC
73090: ST_TO_ADDR
73091: LD_EXP 50
73095: PUSH
73096: FOR_TO
73097: IFFALSE 73160
// if mc_mines [ i ] and mc_miners [ i ] then
73099: LD_EXP 63
73103: PUSH
73104: LD_VAR 0 2
73108: ARRAY
73109: PUSH
73110: LD_EXP 64
73114: PUSH
73115: LD_VAR 0 2
73119: ARRAY
73120: AND
73121: IFFALSE 73158
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73123: LD_EXP 64
73127: PUSH
73128: LD_VAR 0 2
73132: ARRAY
73133: PUSH
73134: LD_INT 1
73136: ARRAY
73137: PPUSH
73138: CALL_OW 255
73142: PPUSH
73143: LD_EXP 63
73147: PUSH
73148: LD_VAR 0 2
73152: ARRAY
73153: PPUSH
73154: CALL 15550 0 2
73158: GO 73096
73160: POP
73161: POP
// end ;
73162: LD_VAR 0 1
73166: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73167: LD_INT 0
73169: PPUSH
73170: PPUSH
73171: PPUSH
73172: PPUSH
73173: PPUSH
73174: PPUSH
73175: PPUSH
73176: PPUSH
// if not mc_bases or not mc_parking then
73177: LD_EXP 50
73181: NOT
73182: PUSH
73183: LD_EXP 74
73187: NOT
73188: OR
73189: IFFALSE 73193
// exit ;
73191: GO 73931
// for i = 1 to mc_bases do
73193: LD_ADDR_VAR 0 2
73197: PUSH
73198: DOUBLE
73199: LD_INT 1
73201: DEC
73202: ST_TO_ADDR
73203: LD_EXP 50
73207: PUSH
73208: FOR_TO
73209: IFFALSE 73929
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73211: LD_EXP 50
73215: PUSH
73216: LD_VAR 0 2
73220: ARRAY
73221: NOT
73222: PUSH
73223: LD_EXP 74
73227: PUSH
73228: LD_VAR 0 2
73232: ARRAY
73233: NOT
73234: OR
73235: IFFALSE 73239
// continue ;
73237: GO 73208
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73239: LD_ADDR_VAR 0 5
73243: PUSH
73244: LD_EXP 50
73248: PUSH
73249: LD_VAR 0 2
73253: ARRAY
73254: PUSH
73255: LD_INT 1
73257: ARRAY
73258: PPUSH
73259: CALL_OW 255
73263: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73264: LD_ADDR_VAR 0 6
73268: PUSH
73269: LD_EXP 50
73273: PUSH
73274: LD_VAR 0 2
73278: ARRAY
73279: PPUSH
73280: LD_INT 30
73282: PUSH
73283: LD_INT 3
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PPUSH
73290: CALL_OW 72
73294: ST_TO_ADDR
// if not fac then
73295: LD_VAR 0 6
73299: NOT
73300: IFFALSE 73351
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73302: LD_ADDR_VAR 0 6
73306: PUSH
73307: LD_EXP 50
73311: PUSH
73312: LD_VAR 0 2
73316: ARRAY
73317: PPUSH
73318: LD_INT 2
73320: PUSH
73321: LD_INT 30
73323: PUSH
73324: LD_INT 0
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 30
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: LIST
73345: PPUSH
73346: CALL_OW 72
73350: ST_TO_ADDR
// if not fac then
73351: LD_VAR 0 6
73355: NOT
73356: IFFALSE 73360
// continue ;
73358: GO 73208
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73360: LD_ADDR_VAR 0 7
73364: PUSH
73365: LD_EXP 74
73369: PUSH
73370: LD_VAR 0 2
73374: ARRAY
73375: PPUSH
73376: LD_INT 22
73378: PUSH
73379: LD_VAR 0 5
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 21
73390: PUSH
73391: LD_INT 2
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 3
73400: PUSH
73401: LD_INT 60
73403: PUSH
73404: EMPTY
73405: LIST
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 3
73413: PUSH
73414: LD_INT 24
73416: PUSH
73417: LD_INT 1000
73419: PUSH
73420: EMPTY
73421: LIST
73422: LIST
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: PPUSH
73434: CALL_OW 70
73438: ST_TO_ADDR
// for j in fac do
73439: LD_ADDR_VAR 0 3
73443: PUSH
73444: LD_VAR 0 6
73448: PUSH
73449: FOR_IN
73450: IFFALSE 73545
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73452: LD_ADDR_VAR 0 7
73456: PUSH
73457: LD_VAR 0 7
73461: PUSH
73462: LD_INT 22
73464: PUSH
73465: LD_VAR 0 5
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 91
73476: PUSH
73477: LD_VAR 0 3
73481: PUSH
73482: LD_INT 15
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: LIST
73489: PUSH
73490: LD_INT 21
73492: PUSH
73493: LD_INT 2
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 3
73502: PUSH
73503: LD_INT 60
73505: PUSH
73506: EMPTY
73507: LIST
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 3
73515: PUSH
73516: LD_INT 24
73518: PUSH
73519: LD_INT 1000
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: EMPTY
73527: LIST
73528: LIST
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: PPUSH
73537: CALL_OW 69
73541: UNION
73542: ST_TO_ADDR
73543: GO 73449
73545: POP
73546: POP
// if not vehs then
73547: LD_VAR 0 7
73551: NOT
73552: IFFALSE 73578
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73554: LD_ADDR_EXP 62
73558: PUSH
73559: LD_EXP 62
73563: PPUSH
73564: LD_VAR 0 2
73568: PPUSH
73569: EMPTY
73570: PPUSH
73571: CALL_OW 1
73575: ST_TO_ADDR
// continue ;
73576: GO 73208
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73578: LD_ADDR_VAR 0 8
73582: PUSH
73583: LD_EXP 50
73587: PUSH
73588: LD_VAR 0 2
73592: ARRAY
73593: PPUSH
73594: LD_INT 30
73596: PUSH
73597: LD_INT 3
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PPUSH
73604: CALL_OW 72
73608: ST_TO_ADDR
// if tmp then
73609: LD_VAR 0 8
73613: IFFALSE 73716
// begin for j in tmp do
73615: LD_ADDR_VAR 0 3
73619: PUSH
73620: LD_VAR 0 8
73624: PUSH
73625: FOR_IN
73626: IFFALSE 73714
// for k in UnitsInside ( j ) do
73628: LD_ADDR_VAR 0 4
73632: PUSH
73633: LD_VAR 0 3
73637: PPUSH
73638: CALL_OW 313
73642: PUSH
73643: FOR_IN
73644: IFFALSE 73710
// if k then
73646: LD_VAR 0 4
73650: IFFALSE 73708
// if not k in mc_repair_vehicle [ i ] then
73652: LD_VAR 0 4
73656: PUSH
73657: LD_EXP 62
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: IN
73668: NOT
73669: IFFALSE 73708
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73671: LD_ADDR_EXP 62
73675: PUSH
73676: LD_EXP 62
73680: PPUSH
73681: LD_VAR 0 2
73685: PPUSH
73686: LD_EXP 62
73690: PUSH
73691: LD_VAR 0 2
73695: ARRAY
73696: PUSH
73697: LD_VAR 0 4
73701: UNION
73702: PPUSH
73703: CALL_OW 1
73707: ST_TO_ADDR
73708: GO 73643
73710: POP
73711: POP
73712: GO 73625
73714: POP
73715: POP
// end ; if not mc_repair_vehicle [ i ] then
73716: LD_EXP 62
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: NOT
73727: IFFALSE 73731
// continue ;
73729: GO 73208
// for j in mc_repair_vehicle [ i ] do
73731: LD_ADDR_VAR 0 3
73735: PUSH
73736: LD_EXP 62
73740: PUSH
73741: LD_VAR 0 2
73745: ARRAY
73746: PUSH
73747: FOR_IN
73748: IFFALSE 73925
// begin if GetClass ( j ) <> 3 then
73750: LD_VAR 0 3
73754: PPUSH
73755: CALL_OW 257
73759: PUSH
73760: LD_INT 3
73762: NONEQUAL
73763: IFFALSE 73804
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73765: LD_ADDR_EXP 62
73769: PUSH
73770: LD_EXP 62
73774: PPUSH
73775: LD_VAR 0 2
73779: PPUSH
73780: LD_EXP 62
73784: PUSH
73785: LD_VAR 0 2
73789: ARRAY
73790: PUSH
73791: LD_VAR 0 3
73795: DIFF
73796: PPUSH
73797: CALL_OW 1
73801: ST_TO_ADDR
// continue ;
73802: GO 73747
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73804: LD_VAR 0 3
73808: PPUSH
73809: CALL_OW 311
73813: NOT
73814: PUSH
73815: LD_VAR 0 3
73819: PUSH
73820: LD_EXP 53
73824: PUSH
73825: LD_VAR 0 2
73829: ARRAY
73830: PUSH
73831: LD_INT 1
73833: ARRAY
73834: IN
73835: NOT
73836: AND
73837: PUSH
73838: LD_VAR 0 3
73842: PUSH
73843: LD_EXP 53
73847: PUSH
73848: LD_VAR 0 2
73852: ARRAY
73853: PUSH
73854: LD_INT 2
73856: ARRAY
73857: IN
73858: NOT
73859: AND
73860: IFFALSE 73923
// begin if IsInUnit ( j ) then
73862: LD_VAR 0 3
73866: PPUSH
73867: CALL_OW 310
73871: IFFALSE 73884
// ComExitBuilding ( j ) else
73873: LD_VAR 0 3
73877: PPUSH
73878: CALL_OW 122
73882: GO 73923
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73884: LD_VAR 0 3
73888: PPUSH
73889: LD_VAR 0 7
73893: PUSH
73894: LD_INT 1
73896: ARRAY
73897: PPUSH
73898: CALL 52997 0 2
73902: NOT
73903: IFFALSE 73923
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73905: LD_VAR 0 3
73909: PPUSH
73910: LD_VAR 0 7
73914: PUSH
73915: LD_INT 1
73917: ARRAY
73918: PPUSH
73919: CALL_OW 129
// end ; end ;
73923: GO 73747
73925: POP
73926: POP
// end ;
73927: GO 73208
73929: POP
73930: POP
// end ;
73931: LD_VAR 0 1
73935: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73936: LD_INT 0
73938: PPUSH
73939: PPUSH
73940: PPUSH
73941: PPUSH
73942: PPUSH
73943: PPUSH
73944: PPUSH
73945: PPUSH
73946: PPUSH
73947: PPUSH
73948: PPUSH
// if not mc_bases then
73949: LD_EXP 50
73953: NOT
73954: IFFALSE 73958
// exit ;
73956: GO 74760
// for i = 1 to mc_bases do
73958: LD_ADDR_VAR 0 2
73962: PUSH
73963: DOUBLE
73964: LD_INT 1
73966: DEC
73967: ST_TO_ADDR
73968: LD_EXP 50
73972: PUSH
73973: FOR_TO
73974: IFFALSE 74758
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73976: LD_EXP 78
73980: PUSH
73981: LD_VAR 0 2
73985: ARRAY
73986: NOT
73987: PUSH
73988: LD_EXP 53
73992: PUSH
73993: LD_VAR 0 2
73997: ARRAY
73998: PUSH
73999: LD_INT 1
74001: ARRAY
74002: OR
74003: PUSH
74004: LD_EXP 53
74008: PUSH
74009: LD_VAR 0 2
74013: ARRAY
74014: PUSH
74015: LD_INT 2
74017: ARRAY
74018: OR
74019: PUSH
74020: LD_EXP 76
74024: PUSH
74025: LD_VAR 0 2
74029: ARRAY
74030: PPUSH
74031: LD_INT 1
74033: PPUSH
74034: CALL_OW 325
74038: NOT
74039: OR
74040: PUSH
74041: LD_EXP 73
74045: PUSH
74046: LD_VAR 0 2
74050: ARRAY
74051: OR
74052: IFFALSE 74056
// continue ;
74054: GO 73973
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74056: LD_ADDR_VAR 0 8
74060: PUSH
74061: LD_EXP 50
74065: PUSH
74066: LD_VAR 0 2
74070: ARRAY
74071: PPUSH
74072: LD_INT 25
74074: PUSH
74075: LD_INT 4
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 50
74084: PUSH
74085: EMPTY
74086: LIST
74087: PUSH
74088: LD_INT 3
74090: PUSH
74091: LD_INT 60
74093: PUSH
74094: EMPTY
74095: LIST
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: LIST
74105: PPUSH
74106: CALL_OW 72
74110: PUSH
74111: LD_EXP 54
74115: PUSH
74116: LD_VAR 0 2
74120: ARRAY
74121: DIFF
74122: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74123: LD_ADDR_VAR 0 9
74127: PUSH
74128: LD_EXP 50
74132: PUSH
74133: LD_VAR 0 2
74137: ARRAY
74138: PPUSH
74139: LD_INT 2
74141: PUSH
74142: LD_INT 30
74144: PUSH
74145: LD_INT 0
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 30
74154: PUSH
74155: LD_INT 1
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: LIST
74166: PPUSH
74167: CALL_OW 72
74171: ST_TO_ADDR
// if not tmp or not dep then
74172: LD_VAR 0 8
74176: NOT
74177: PUSH
74178: LD_VAR 0 9
74182: NOT
74183: OR
74184: IFFALSE 74188
// continue ;
74186: GO 73973
// side := GetSide ( tmp [ 1 ] ) ;
74188: LD_ADDR_VAR 0 11
74192: PUSH
74193: LD_VAR 0 8
74197: PUSH
74198: LD_INT 1
74200: ARRAY
74201: PPUSH
74202: CALL_OW 255
74206: ST_TO_ADDR
// dep := dep [ 1 ] ;
74207: LD_ADDR_VAR 0 9
74211: PUSH
74212: LD_VAR 0 9
74216: PUSH
74217: LD_INT 1
74219: ARRAY
74220: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74221: LD_ADDR_VAR 0 7
74225: PUSH
74226: LD_EXP 78
74230: PUSH
74231: LD_VAR 0 2
74235: ARRAY
74236: PPUSH
74237: LD_INT 22
74239: PUSH
74240: LD_INT 0
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 25
74249: PUSH
74250: LD_INT 12
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PPUSH
74261: CALL_OW 70
74265: PUSH
74266: LD_INT 22
74268: PUSH
74269: LD_INT 0
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 25
74278: PUSH
74279: LD_INT 12
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 91
74288: PUSH
74289: LD_VAR 0 9
74293: PUSH
74294: LD_INT 20
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: LIST
74306: PPUSH
74307: CALL_OW 69
74311: UNION
74312: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74313: LD_ADDR_VAR 0 10
74317: PUSH
74318: LD_EXP 78
74322: PUSH
74323: LD_VAR 0 2
74327: ARRAY
74328: PPUSH
74329: LD_INT 81
74331: PUSH
74332: LD_VAR 0 11
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PPUSH
74341: CALL_OW 70
74345: ST_TO_ADDR
// if not apes or danger_at_area then
74346: LD_VAR 0 7
74350: NOT
74351: PUSH
74352: LD_VAR 0 10
74356: OR
74357: IFFALSE 74407
// begin if mc_taming [ i ] then
74359: LD_EXP 81
74363: PUSH
74364: LD_VAR 0 2
74368: ARRAY
74369: IFFALSE 74405
// begin MC_Reset ( i , 121 ) ;
74371: LD_VAR 0 2
74375: PPUSH
74376: LD_INT 121
74378: PPUSH
74379: CALL 59323 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74383: LD_ADDR_EXP 81
74387: PUSH
74388: LD_EXP 81
74392: PPUSH
74393: LD_VAR 0 2
74397: PPUSH
74398: EMPTY
74399: PPUSH
74400: CALL_OW 1
74404: ST_TO_ADDR
// end ; continue ;
74405: GO 73973
// end ; for j in tmp do
74407: LD_ADDR_VAR 0 3
74411: PUSH
74412: LD_VAR 0 8
74416: PUSH
74417: FOR_IN
74418: IFFALSE 74754
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74420: LD_VAR 0 3
74424: PUSH
74425: LD_EXP 81
74429: PUSH
74430: LD_VAR 0 2
74434: ARRAY
74435: IN
74436: NOT
74437: PUSH
74438: LD_EXP 81
74442: PUSH
74443: LD_VAR 0 2
74447: ARRAY
74448: PUSH
74449: LD_INT 3
74451: LESS
74452: AND
74453: IFFALSE 74511
// begin SetTag ( j , 121 ) ;
74455: LD_VAR 0 3
74459: PPUSH
74460: LD_INT 121
74462: PPUSH
74463: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74467: LD_ADDR_EXP 81
74471: PUSH
74472: LD_EXP 81
74476: PPUSH
74477: LD_VAR 0 2
74481: PUSH
74482: LD_EXP 81
74486: PUSH
74487: LD_VAR 0 2
74491: ARRAY
74492: PUSH
74493: LD_INT 1
74495: PLUS
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PPUSH
74501: LD_VAR 0 3
74505: PPUSH
74506: CALL 18573 0 3
74510: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74511: LD_VAR 0 3
74515: PUSH
74516: LD_EXP 81
74520: PUSH
74521: LD_VAR 0 2
74525: ARRAY
74526: IN
74527: IFFALSE 74752
// begin if GetClass ( j ) <> 4 then
74529: LD_VAR 0 3
74533: PPUSH
74534: CALL_OW 257
74538: PUSH
74539: LD_INT 4
74541: NONEQUAL
74542: IFFALSE 74595
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74544: LD_ADDR_EXP 81
74548: PUSH
74549: LD_EXP 81
74553: PPUSH
74554: LD_VAR 0 2
74558: PPUSH
74559: LD_EXP 81
74563: PUSH
74564: LD_VAR 0 2
74568: ARRAY
74569: PUSH
74570: LD_VAR 0 3
74574: DIFF
74575: PPUSH
74576: CALL_OW 1
74580: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74581: LD_VAR 0 3
74585: PPUSH
74586: LD_INT 0
74588: PPUSH
74589: CALL_OW 109
// continue ;
74593: GO 74417
// end ; if IsInUnit ( j ) then
74595: LD_VAR 0 3
74599: PPUSH
74600: CALL_OW 310
74604: IFFALSE 74615
// ComExitBuilding ( j ) ;
74606: LD_VAR 0 3
74610: PPUSH
74611: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74615: LD_ADDR_VAR 0 6
74619: PUSH
74620: LD_VAR 0 7
74624: PPUSH
74625: LD_VAR 0 3
74629: PPUSH
74630: CALL_OW 74
74634: ST_TO_ADDR
// if not ape then
74635: LD_VAR 0 6
74639: NOT
74640: IFFALSE 74644
// break ;
74642: GO 74754
// x := GetX ( ape ) ;
74644: LD_ADDR_VAR 0 4
74648: PUSH
74649: LD_VAR 0 6
74653: PPUSH
74654: CALL_OW 250
74658: ST_TO_ADDR
// y := GetY ( ape ) ;
74659: LD_ADDR_VAR 0 5
74663: PUSH
74664: LD_VAR 0 6
74668: PPUSH
74669: CALL_OW 251
74673: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74674: LD_VAR 0 4
74678: PPUSH
74679: LD_VAR 0 5
74683: PPUSH
74684: CALL_OW 488
74688: NOT
74689: PUSH
74690: LD_VAR 0 11
74694: PPUSH
74695: LD_VAR 0 4
74699: PPUSH
74700: LD_VAR 0 5
74704: PPUSH
74705: LD_INT 20
74707: PPUSH
74708: CALL 19469 0 4
74712: PUSH
74713: LD_INT 4
74715: ARRAY
74716: OR
74717: IFFALSE 74721
// break ;
74719: GO 74754
// if not HasTask ( j ) then
74721: LD_VAR 0 3
74725: PPUSH
74726: CALL_OW 314
74730: NOT
74731: IFFALSE 74752
// ComTameXY ( j , x , y ) ;
74733: LD_VAR 0 3
74737: PPUSH
74738: LD_VAR 0 4
74742: PPUSH
74743: LD_VAR 0 5
74747: PPUSH
74748: CALL_OW 131
// end ; end ;
74752: GO 74417
74754: POP
74755: POP
// end ;
74756: GO 73973
74758: POP
74759: POP
// end ;
74760: LD_VAR 0 1
74764: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74765: LD_INT 0
74767: PPUSH
74768: PPUSH
74769: PPUSH
74770: PPUSH
74771: PPUSH
74772: PPUSH
74773: PPUSH
74774: PPUSH
// if not mc_bases then
74775: LD_EXP 50
74779: NOT
74780: IFFALSE 74784
// exit ;
74782: GO 75410
// for i = 1 to mc_bases do
74784: LD_ADDR_VAR 0 2
74788: PUSH
74789: DOUBLE
74790: LD_INT 1
74792: DEC
74793: ST_TO_ADDR
74794: LD_EXP 50
74798: PUSH
74799: FOR_TO
74800: IFFALSE 75408
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74802: LD_EXP 79
74806: PUSH
74807: LD_VAR 0 2
74811: ARRAY
74812: NOT
74813: PUSH
74814: LD_EXP 79
74818: PUSH
74819: LD_VAR 0 2
74823: ARRAY
74824: PPUSH
74825: LD_INT 25
74827: PUSH
74828: LD_INT 12
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: PPUSH
74835: CALL_OW 72
74839: NOT
74840: OR
74841: IFFALSE 74845
// continue ;
74843: GO 74799
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74845: LD_ADDR_VAR 0 5
74849: PUSH
74850: LD_EXP 79
74854: PUSH
74855: LD_VAR 0 2
74859: ARRAY
74860: PUSH
74861: LD_INT 1
74863: ARRAY
74864: PPUSH
74865: CALL_OW 255
74869: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74870: LD_VAR 0 5
74874: PPUSH
74875: LD_INT 2
74877: PPUSH
74878: CALL_OW 325
74882: IFFALSE 75135
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74884: LD_ADDR_VAR 0 4
74888: PUSH
74889: LD_EXP 79
74893: PUSH
74894: LD_VAR 0 2
74898: ARRAY
74899: PPUSH
74900: LD_INT 25
74902: PUSH
74903: LD_INT 16
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PPUSH
74910: CALL_OW 72
74914: ST_TO_ADDR
// if tmp < 6 then
74915: LD_VAR 0 4
74919: PUSH
74920: LD_INT 6
74922: LESS
74923: IFFALSE 75135
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74925: LD_ADDR_VAR 0 6
74929: PUSH
74930: LD_EXP 50
74934: PUSH
74935: LD_VAR 0 2
74939: ARRAY
74940: PPUSH
74941: LD_INT 2
74943: PUSH
74944: LD_INT 30
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 30
74956: PUSH
74957: LD_INT 1
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: LIST
74968: PPUSH
74969: CALL_OW 72
74973: ST_TO_ADDR
// if depot then
74974: LD_VAR 0 6
74978: IFFALSE 75135
// begin selected := 0 ;
74980: LD_ADDR_VAR 0 7
74984: PUSH
74985: LD_INT 0
74987: ST_TO_ADDR
// for j in depot do
74988: LD_ADDR_VAR 0 3
74992: PUSH
74993: LD_VAR 0 6
74997: PUSH
74998: FOR_IN
74999: IFFALSE 75030
// begin if UnitsInside ( j ) < 6 then
75001: LD_VAR 0 3
75005: PPUSH
75006: CALL_OW 313
75010: PUSH
75011: LD_INT 6
75013: LESS
75014: IFFALSE 75028
// begin selected := j ;
75016: LD_ADDR_VAR 0 7
75020: PUSH
75021: LD_VAR 0 3
75025: ST_TO_ADDR
// break ;
75026: GO 75030
// end ; end ;
75028: GO 74998
75030: POP
75031: POP
// if selected then
75032: LD_VAR 0 7
75036: IFFALSE 75135
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75038: LD_ADDR_VAR 0 3
75042: PUSH
75043: LD_EXP 79
75047: PUSH
75048: LD_VAR 0 2
75052: ARRAY
75053: PPUSH
75054: LD_INT 25
75056: PUSH
75057: LD_INT 12
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PPUSH
75064: CALL_OW 72
75068: PUSH
75069: FOR_IN
75070: IFFALSE 75133
// if not HasTask ( j ) then
75072: LD_VAR 0 3
75076: PPUSH
75077: CALL_OW 314
75081: NOT
75082: IFFALSE 75131
// begin if not IsInUnit ( j ) then
75084: LD_VAR 0 3
75088: PPUSH
75089: CALL_OW 310
75093: NOT
75094: IFFALSE 75110
// ComEnterUnit ( j , selected ) ;
75096: LD_VAR 0 3
75100: PPUSH
75101: LD_VAR 0 7
75105: PPUSH
75106: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75110: LD_VAR 0 3
75114: PPUSH
75115: LD_INT 16
75117: PPUSH
75118: CALL_OW 183
// AddComExitBuilding ( j ) ;
75122: LD_VAR 0 3
75126: PPUSH
75127: CALL_OW 182
// end ;
75131: GO 75069
75133: POP
75134: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75135: LD_VAR 0 5
75139: PPUSH
75140: LD_INT 11
75142: PPUSH
75143: CALL_OW 325
75147: IFFALSE 75406
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75149: LD_ADDR_VAR 0 4
75153: PUSH
75154: LD_EXP 79
75158: PUSH
75159: LD_VAR 0 2
75163: ARRAY
75164: PPUSH
75165: LD_INT 25
75167: PUSH
75168: LD_INT 16
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PPUSH
75175: CALL_OW 72
75179: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75180: LD_VAR 0 4
75184: PUSH
75185: LD_INT 6
75187: GREATEREQUAL
75188: PUSH
75189: LD_VAR 0 5
75193: PPUSH
75194: LD_INT 2
75196: PPUSH
75197: CALL_OW 325
75201: NOT
75202: OR
75203: IFFALSE 75406
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75205: LD_ADDR_VAR 0 8
75209: PUSH
75210: LD_EXP 50
75214: PUSH
75215: LD_VAR 0 2
75219: ARRAY
75220: PPUSH
75221: LD_INT 2
75223: PUSH
75224: LD_INT 30
75226: PUSH
75227: LD_INT 4
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 30
75236: PUSH
75237: LD_INT 5
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: LIST
75248: PPUSH
75249: CALL_OW 72
75253: ST_TO_ADDR
// if barracks then
75254: LD_VAR 0 8
75258: IFFALSE 75406
// begin selected := 0 ;
75260: LD_ADDR_VAR 0 7
75264: PUSH
75265: LD_INT 0
75267: ST_TO_ADDR
// for j in barracks do
75268: LD_ADDR_VAR 0 3
75272: PUSH
75273: LD_VAR 0 8
75277: PUSH
75278: FOR_IN
75279: IFFALSE 75310
// begin if UnitsInside ( j ) < 6 then
75281: LD_VAR 0 3
75285: PPUSH
75286: CALL_OW 313
75290: PUSH
75291: LD_INT 6
75293: LESS
75294: IFFALSE 75308
// begin selected := j ;
75296: LD_ADDR_VAR 0 7
75300: PUSH
75301: LD_VAR 0 3
75305: ST_TO_ADDR
// break ;
75306: GO 75310
// end ; end ;
75308: GO 75278
75310: POP
75311: POP
// if selected then
75312: LD_VAR 0 7
75316: IFFALSE 75406
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75318: LD_ADDR_VAR 0 3
75322: PUSH
75323: LD_EXP 79
75327: PUSH
75328: LD_VAR 0 2
75332: ARRAY
75333: PPUSH
75334: LD_INT 25
75336: PUSH
75337: LD_INT 12
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PPUSH
75344: CALL_OW 72
75348: PUSH
75349: FOR_IN
75350: IFFALSE 75404
// if not IsInUnit ( j ) and not HasTask ( j ) then
75352: LD_VAR 0 3
75356: PPUSH
75357: CALL_OW 310
75361: NOT
75362: PUSH
75363: LD_VAR 0 3
75367: PPUSH
75368: CALL_OW 314
75372: NOT
75373: AND
75374: IFFALSE 75402
// begin ComEnterUnit ( j , selected ) ;
75376: LD_VAR 0 3
75380: PPUSH
75381: LD_VAR 0 7
75385: PPUSH
75386: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75390: LD_VAR 0 3
75394: PPUSH
75395: LD_INT 15
75397: PPUSH
75398: CALL_OW 183
// end ;
75402: GO 75349
75404: POP
75405: POP
// end ; end ; end ; end ; end ;
75406: GO 74799
75408: POP
75409: POP
// end ;
75410: LD_VAR 0 1
75414: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75415: LD_INT 0
75417: PPUSH
75418: PPUSH
75419: PPUSH
75420: PPUSH
// if not mc_bases then
75421: LD_EXP 50
75425: NOT
75426: IFFALSE 75430
// exit ;
75428: GO 75608
// for i = 1 to mc_bases do
75430: LD_ADDR_VAR 0 2
75434: PUSH
75435: DOUBLE
75436: LD_INT 1
75438: DEC
75439: ST_TO_ADDR
75440: LD_EXP 50
75444: PUSH
75445: FOR_TO
75446: IFFALSE 75606
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75448: LD_ADDR_VAR 0 4
75452: PUSH
75453: LD_EXP 50
75457: PUSH
75458: LD_VAR 0 2
75462: ARRAY
75463: PPUSH
75464: LD_INT 25
75466: PUSH
75467: LD_INT 9
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PPUSH
75474: CALL_OW 72
75478: ST_TO_ADDR
// if not tmp then
75479: LD_VAR 0 4
75483: NOT
75484: IFFALSE 75488
// continue ;
75486: GO 75445
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75488: LD_EXP 76
75492: PUSH
75493: LD_VAR 0 2
75497: ARRAY
75498: PPUSH
75499: LD_INT 29
75501: PPUSH
75502: CALL_OW 325
75506: NOT
75507: PUSH
75508: LD_EXP 76
75512: PUSH
75513: LD_VAR 0 2
75517: ARRAY
75518: PPUSH
75519: LD_INT 28
75521: PPUSH
75522: CALL_OW 325
75526: NOT
75527: AND
75528: IFFALSE 75532
// continue ;
75530: GO 75445
// for j in tmp do
75532: LD_ADDR_VAR 0 3
75536: PUSH
75537: LD_VAR 0 4
75541: PUSH
75542: FOR_IN
75543: IFFALSE 75602
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75545: LD_VAR 0 3
75549: PUSH
75550: LD_EXP 53
75554: PUSH
75555: LD_VAR 0 2
75559: ARRAY
75560: PUSH
75561: LD_INT 1
75563: ARRAY
75564: IN
75565: NOT
75566: PUSH
75567: LD_VAR 0 3
75571: PUSH
75572: LD_EXP 53
75576: PUSH
75577: LD_VAR 0 2
75581: ARRAY
75582: PUSH
75583: LD_INT 2
75585: ARRAY
75586: IN
75587: NOT
75588: AND
75589: IFFALSE 75600
// ComSpaceTimeShoot ( j ) ;
75591: LD_VAR 0 3
75595: PPUSH
75596: CALL 14558 0 1
75600: GO 75542
75602: POP
75603: POP
// end ;
75604: GO 75445
75606: POP
75607: POP
// end ;
75608: LD_VAR 0 1
75612: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75613: LD_INT 0
75615: PPUSH
75616: PPUSH
75617: PPUSH
75618: PPUSH
75619: PPUSH
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
// if not mc_bases then
75624: LD_EXP 50
75628: NOT
75629: IFFALSE 75633
// exit ;
75631: GO 76255
// for i = 1 to mc_bases do
75633: LD_ADDR_VAR 0 2
75637: PUSH
75638: DOUBLE
75639: LD_INT 1
75641: DEC
75642: ST_TO_ADDR
75643: LD_EXP 50
75647: PUSH
75648: FOR_TO
75649: IFFALSE 76253
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75651: LD_EXP 85
75655: PUSH
75656: LD_VAR 0 2
75660: ARRAY
75661: NOT
75662: PUSH
75663: LD_INT 38
75665: PPUSH
75666: LD_EXP 76
75670: PUSH
75671: LD_VAR 0 2
75675: ARRAY
75676: PPUSH
75677: CALL_OW 321
75681: PUSH
75682: LD_INT 2
75684: NONEQUAL
75685: OR
75686: IFFALSE 75690
// continue ;
75688: GO 75648
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75690: LD_ADDR_VAR 0 8
75694: PUSH
75695: LD_EXP 50
75699: PUSH
75700: LD_VAR 0 2
75704: ARRAY
75705: PPUSH
75706: LD_INT 30
75708: PUSH
75709: LD_INT 34
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PPUSH
75716: CALL_OW 72
75720: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75721: LD_ADDR_VAR 0 9
75725: PUSH
75726: LD_EXP 50
75730: PUSH
75731: LD_VAR 0 2
75735: ARRAY
75736: PPUSH
75737: LD_INT 25
75739: PUSH
75740: LD_INT 4
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PPUSH
75747: CALL_OW 72
75751: PPUSH
75752: LD_INT 0
75754: PPUSH
75755: CALL 48514 0 2
75759: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75760: LD_VAR 0 9
75764: NOT
75765: PUSH
75766: LD_VAR 0 8
75770: NOT
75771: OR
75772: PUSH
75773: LD_EXP 50
75777: PUSH
75778: LD_VAR 0 2
75782: ARRAY
75783: PPUSH
75784: LD_INT 124
75786: PPUSH
75787: CALL 48514 0 2
75791: OR
75792: IFFALSE 75796
// continue ;
75794: GO 75648
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75796: LD_EXP 86
75800: PUSH
75801: LD_VAR 0 2
75805: ARRAY
75806: PUSH
75807: LD_EXP 85
75811: PUSH
75812: LD_VAR 0 2
75816: ARRAY
75817: LESS
75818: PUSH
75819: LD_EXP 86
75823: PUSH
75824: LD_VAR 0 2
75828: ARRAY
75829: PUSH
75830: LD_VAR 0 8
75834: LESS
75835: AND
75836: IFFALSE 76251
// begin tmp := sci [ 1 ] ;
75838: LD_ADDR_VAR 0 7
75842: PUSH
75843: LD_VAR 0 9
75847: PUSH
75848: LD_INT 1
75850: ARRAY
75851: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75852: LD_VAR 0 7
75856: PPUSH
75857: LD_INT 124
75859: PPUSH
75860: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75864: LD_ADDR_VAR 0 3
75868: PUSH
75869: DOUBLE
75870: LD_EXP 85
75874: PUSH
75875: LD_VAR 0 2
75879: ARRAY
75880: INC
75881: ST_TO_ADDR
75882: LD_EXP 85
75886: PUSH
75887: LD_VAR 0 2
75891: ARRAY
75892: PUSH
75893: FOR_DOWNTO
75894: IFFALSE 76237
// begin if IsInUnit ( tmp ) then
75896: LD_VAR 0 7
75900: PPUSH
75901: CALL_OW 310
75905: IFFALSE 75916
// ComExitBuilding ( tmp ) ;
75907: LD_VAR 0 7
75911: PPUSH
75912: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75916: LD_INT 35
75918: PPUSH
75919: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75923: LD_VAR 0 7
75927: PPUSH
75928: CALL_OW 310
75932: NOT
75933: PUSH
75934: LD_VAR 0 7
75938: PPUSH
75939: CALL_OW 314
75943: NOT
75944: AND
75945: IFFALSE 75916
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75947: LD_ADDR_VAR 0 6
75951: PUSH
75952: LD_VAR 0 7
75956: PPUSH
75957: CALL_OW 250
75961: PUSH
75962: LD_VAR 0 7
75966: PPUSH
75967: CALL_OW 251
75971: PUSH
75972: EMPTY
75973: LIST
75974: LIST
75975: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75976: LD_INT 35
75978: PPUSH
75979: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75983: LD_ADDR_VAR 0 4
75987: PUSH
75988: LD_EXP 85
75992: PUSH
75993: LD_VAR 0 2
75997: ARRAY
75998: PUSH
75999: LD_VAR 0 3
76003: ARRAY
76004: PUSH
76005: LD_INT 1
76007: ARRAY
76008: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76009: LD_ADDR_VAR 0 5
76013: PUSH
76014: LD_EXP 85
76018: PUSH
76019: LD_VAR 0 2
76023: ARRAY
76024: PUSH
76025: LD_VAR 0 3
76029: ARRAY
76030: PUSH
76031: LD_INT 2
76033: ARRAY
76034: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76035: LD_VAR 0 7
76039: PPUSH
76040: LD_INT 10
76042: PPUSH
76043: CALL 21170 0 2
76047: PUSH
76048: LD_INT 4
76050: ARRAY
76051: IFFALSE 76089
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76053: LD_VAR 0 7
76057: PPUSH
76058: LD_VAR 0 6
76062: PUSH
76063: LD_INT 1
76065: ARRAY
76066: PPUSH
76067: LD_VAR 0 6
76071: PUSH
76072: LD_INT 2
76074: ARRAY
76075: PPUSH
76076: CALL_OW 111
// wait ( 0 0$10 ) ;
76080: LD_INT 350
76082: PPUSH
76083: CALL_OW 67
// end else
76087: GO 76115
// begin ComMoveXY ( tmp , x , y ) ;
76089: LD_VAR 0 7
76093: PPUSH
76094: LD_VAR 0 4
76098: PPUSH
76099: LD_VAR 0 5
76103: PPUSH
76104: CALL_OW 111
// wait ( 0 0$3 ) ;
76108: LD_INT 105
76110: PPUSH
76111: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76115: LD_VAR 0 7
76119: PPUSH
76120: LD_VAR 0 4
76124: PPUSH
76125: LD_VAR 0 5
76129: PPUSH
76130: CALL_OW 307
76134: IFFALSE 75976
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76136: LD_VAR 0 7
76140: PPUSH
76141: LD_VAR 0 4
76145: PPUSH
76146: LD_VAR 0 5
76150: PPUSH
76151: LD_VAR 0 8
76155: PUSH
76156: LD_VAR 0 3
76160: ARRAY
76161: PPUSH
76162: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76166: LD_INT 35
76168: PPUSH
76169: CALL_OW 67
// until not HasTask ( tmp ) ;
76173: LD_VAR 0 7
76177: PPUSH
76178: CALL_OW 314
76182: NOT
76183: IFFALSE 76166
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76185: LD_ADDR_EXP 86
76189: PUSH
76190: LD_EXP 86
76194: PPUSH
76195: LD_VAR 0 2
76199: PUSH
76200: LD_EXP 86
76204: PUSH
76205: LD_VAR 0 2
76209: ARRAY
76210: PUSH
76211: LD_INT 1
76213: PLUS
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PPUSH
76219: LD_VAR 0 8
76223: PUSH
76224: LD_VAR 0 3
76228: ARRAY
76229: PPUSH
76230: CALL 18573 0 3
76234: ST_TO_ADDR
// end ;
76235: GO 75893
76237: POP
76238: POP
// MC_Reset ( i , 124 ) ;
76239: LD_VAR 0 2
76243: PPUSH
76244: LD_INT 124
76246: PPUSH
76247: CALL 59323 0 2
// end ; end ;
76251: GO 75648
76253: POP
76254: POP
// end ;
76255: LD_VAR 0 1
76259: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76260: LD_INT 0
76262: PPUSH
76263: PPUSH
76264: PPUSH
// if not mc_bases then
76265: LD_EXP 50
76269: NOT
76270: IFFALSE 76274
// exit ;
76272: GO 76880
// for i = 1 to mc_bases do
76274: LD_ADDR_VAR 0 2
76278: PUSH
76279: DOUBLE
76280: LD_INT 1
76282: DEC
76283: ST_TO_ADDR
76284: LD_EXP 50
76288: PUSH
76289: FOR_TO
76290: IFFALSE 76878
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76292: LD_ADDR_VAR 0 3
76296: PUSH
76297: LD_EXP 50
76301: PUSH
76302: LD_VAR 0 2
76306: ARRAY
76307: PPUSH
76308: LD_INT 25
76310: PUSH
76311: LD_INT 4
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PPUSH
76318: CALL_OW 72
76322: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76323: LD_VAR 0 3
76327: NOT
76328: PUSH
76329: LD_EXP 87
76333: PUSH
76334: LD_VAR 0 2
76338: ARRAY
76339: NOT
76340: OR
76341: PUSH
76342: LD_EXP 50
76346: PUSH
76347: LD_VAR 0 2
76351: ARRAY
76352: PPUSH
76353: LD_INT 2
76355: PUSH
76356: LD_INT 30
76358: PUSH
76359: LD_INT 0
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 30
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: LIST
76380: PPUSH
76381: CALL_OW 72
76385: NOT
76386: OR
76387: IFFALSE 76437
// begin if mc_deposits_finder [ i ] then
76389: LD_EXP 88
76393: PUSH
76394: LD_VAR 0 2
76398: ARRAY
76399: IFFALSE 76435
// begin MC_Reset ( i , 125 ) ;
76401: LD_VAR 0 2
76405: PPUSH
76406: LD_INT 125
76408: PPUSH
76409: CALL 59323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76413: LD_ADDR_EXP 88
76417: PUSH
76418: LD_EXP 88
76422: PPUSH
76423: LD_VAR 0 2
76427: PPUSH
76428: EMPTY
76429: PPUSH
76430: CALL_OW 1
76434: ST_TO_ADDR
// end ; continue ;
76435: GO 76289
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76437: LD_EXP 87
76441: PUSH
76442: LD_VAR 0 2
76446: ARRAY
76447: PUSH
76448: LD_INT 1
76450: ARRAY
76451: PUSH
76452: LD_INT 3
76454: ARRAY
76455: PUSH
76456: LD_INT 1
76458: EQUAL
76459: PUSH
76460: LD_INT 20
76462: PPUSH
76463: LD_EXP 76
76467: PUSH
76468: LD_VAR 0 2
76472: ARRAY
76473: PPUSH
76474: CALL_OW 321
76478: PUSH
76479: LD_INT 2
76481: NONEQUAL
76482: AND
76483: IFFALSE 76533
// begin if mc_deposits_finder [ i ] then
76485: LD_EXP 88
76489: PUSH
76490: LD_VAR 0 2
76494: ARRAY
76495: IFFALSE 76531
// begin MC_Reset ( i , 125 ) ;
76497: LD_VAR 0 2
76501: PPUSH
76502: LD_INT 125
76504: PPUSH
76505: CALL 59323 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76509: LD_ADDR_EXP 88
76513: PUSH
76514: LD_EXP 88
76518: PPUSH
76519: LD_VAR 0 2
76523: PPUSH
76524: EMPTY
76525: PPUSH
76526: CALL_OW 1
76530: ST_TO_ADDR
// end ; continue ;
76531: GO 76289
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76533: LD_EXP 87
76537: PUSH
76538: LD_VAR 0 2
76542: ARRAY
76543: PUSH
76544: LD_INT 1
76546: ARRAY
76547: PUSH
76548: LD_INT 1
76550: ARRAY
76551: PPUSH
76552: LD_EXP 87
76556: PUSH
76557: LD_VAR 0 2
76561: ARRAY
76562: PUSH
76563: LD_INT 1
76565: ARRAY
76566: PUSH
76567: LD_INT 2
76569: ARRAY
76570: PPUSH
76571: LD_EXP 76
76575: PUSH
76576: LD_VAR 0 2
76580: ARRAY
76581: PPUSH
76582: CALL_OW 440
76586: IFFALSE 76629
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76588: LD_ADDR_EXP 87
76592: PUSH
76593: LD_EXP 87
76597: PPUSH
76598: LD_VAR 0 2
76602: PPUSH
76603: LD_EXP 87
76607: PUSH
76608: LD_VAR 0 2
76612: ARRAY
76613: PPUSH
76614: LD_INT 1
76616: PPUSH
76617: CALL_OW 3
76621: PPUSH
76622: CALL_OW 1
76626: ST_TO_ADDR
76627: GO 76876
// begin if not mc_deposits_finder [ i ] then
76629: LD_EXP 88
76633: PUSH
76634: LD_VAR 0 2
76638: ARRAY
76639: NOT
76640: IFFALSE 76692
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76642: LD_ADDR_EXP 88
76646: PUSH
76647: LD_EXP 88
76651: PPUSH
76652: LD_VAR 0 2
76656: PPUSH
76657: LD_VAR 0 3
76661: PUSH
76662: LD_INT 1
76664: ARRAY
76665: PUSH
76666: EMPTY
76667: LIST
76668: PPUSH
76669: CALL_OW 1
76673: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76674: LD_VAR 0 3
76678: PUSH
76679: LD_INT 1
76681: ARRAY
76682: PPUSH
76683: LD_INT 125
76685: PPUSH
76686: CALL_OW 109
// end else
76690: GO 76876
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76692: LD_EXP 88
76696: PUSH
76697: LD_VAR 0 2
76701: ARRAY
76702: PUSH
76703: LD_INT 1
76705: ARRAY
76706: PPUSH
76707: CALL_OW 310
76711: IFFALSE 76734
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76713: LD_EXP 88
76717: PUSH
76718: LD_VAR 0 2
76722: ARRAY
76723: PUSH
76724: LD_INT 1
76726: ARRAY
76727: PPUSH
76728: CALL_OW 122
76732: GO 76876
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76734: LD_EXP 88
76738: PUSH
76739: LD_VAR 0 2
76743: ARRAY
76744: PUSH
76745: LD_INT 1
76747: ARRAY
76748: PPUSH
76749: CALL_OW 314
76753: NOT
76754: PUSH
76755: LD_EXP 88
76759: PUSH
76760: LD_VAR 0 2
76764: ARRAY
76765: PUSH
76766: LD_INT 1
76768: ARRAY
76769: PPUSH
76770: LD_EXP 87
76774: PUSH
76775: LD_VAR 0 2
76779: ARRAY
76780: PUSH
76781: LD_INT 1
76783: ARRAY
76784: PUSH
76785: LD_INT 1
76787: ARRAY
76788: PPUSH
76789: LD_EXP 87
76793: PUSH
76794: LD_VAR 0 2
76798: ARRAY
76799: PUSH
76800: LD_INT 1
76802: ARRAY
76803: PUSH
76804: LD_INT 2
76806: ARRAY
76807: PPUSH
76808: CALL_OW 297
76812: PUSH
76813: LD_INT 6
76815: GREATER
76816: AND
76817: IFFALSE 76876
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76819: LD_EXP 88
76823: PUSH
76824: LD_VAR 0 2
76828: ARRAY
76829: PUSH
76830: LD_INT 1
76832: ARRAY
76833: PPUSH
76834: LD_EXP 87
76838: PUSH
76839: LD_VAR 0 2
76843: ARRAY
76844: PUSH
76845: LD_INT 1
76847: ARRAY
76848: PUSH
76849: LD_INT 1
76851: ARRAY
76852: PPUSH
76853: LD_EXP 87
76857: PUSH
76858: LD_VAR 0 2
76862: ARRAY
76863: PUSH
76864: LD_INT 1
76866: ARRAY
76867: PUSH
76868: LD_INT 2
76870: ARRAY
76871: PPUSH
76872: CALL_OW 111
// end ; end ; end ;
76876: GO 76289
76878: POP
76879: POP
// end ;
76880: LD_VAR 0 1
76884: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76885: LD_INT 0
76887: PPUSH
76888: PPUSH
76889: PPUSH
76890: PPUSH
76891: PPUSH
76892: PPUSH
76893: PPUSH
76894: PPUSH
76895: PPUSH
76896: PPUSH
76897: PPUSH
// if not mc_bases then
76898: LD_EXP 50
76902: NOT
76903: IFFALSE 76907
// exit ;
76905: GO 77847
// for i = 1 to mc_bases do
76907: LD_ADDR_VAR 0 2
76911: PUSH
76912: DOUBLE
76913: LD_INT 1
76915: DEC
76916: ST_TO_ADDR
76917: LD_EXP 50
76921: PUSH
76922: FOR_TO
76923: IFFALSE 77845
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76925: LD_EXP 50
76929: PUSH
76930: LD_VAR 0 2
76934: ARRAY
76935: NOT
76936: PUSH
76937: LD_EXP 73
76941: PUSH
76942: LD_VAR 0 2
76946: ARRAY
76947: OR
76948: IFFALSE 76952
// continue ;
76950: GO 76922
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76952: LD_ADDR_VAR 0 7
76956: PUSH
76957: LD_EXP 50
76961: PUSH
76962: LD_VAR 0 2
76966: ARRAY
76967: PUSH
76968: LD_INT 1
76970: ARRAY
76971: PPUSH
76972: CALL_OW 248
76976: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76977: LD_VAR 0 7
76981: PUSH
76982: LD_INT 3
76984: EQUAL
76985: PUSH
76986: LD_EXP 69
76990: PUSH
76991: LD_VAR 0 2
76995: ARRAY
76996: PUSH
76997: LD_EXP 72
77001: PUSH
77002: LD_VAR 0 2
77006: ARRAY
77007: UNION
77008: PPUSH
77009: LD_INT 33
77011: PUSH
77012: LD_INT 2
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PPUSH
77019: CALL_OW 72
77023: NOT
77024: OR
77025: IFFALSE 77029
// continue ;
77027: GO 76922
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77029: LD_ADDR_VAR 0 9
77033: PUSH
77034: LD_EXP 50
77038: PUSH
77039: LD_VAR 0 2
77043: ARRAY
77044: PPUSH
77045: LD_INT 30
77047: PUSH
77048: LD_INT 36
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: PPUSH
77055: CALL_OW 72
77059: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77060: LD_ADDR_VAR 0 10
77064: PUSH
77065: LD_EXP 69
77069: PUSH
77070: LD_VAR 0 2
77074: ARRAY
77075: PPUSH
77076: LD_INT 34
77078: PUSH
77079: LD_INT 31
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PPUSH
77086: CALL_OW 72
77090: ST_TO_ADDR
// if not cts and not mcts then
77091: LD_VAR 0 9
77095: NOT
77096: PUSH
77097: LD_VAR 0 10
77101: NOT
77102: AND
77103: IFFALSE 77107
// continue ;
77105: GO 76922
// x := cts ;
77107: LD_ADDR_VAR 0 11
77111: PUSH
77112: LD_VAR 0 9
77116: ST_TO_ADDR
// if not x then
77117: LD_VAR 0 11
77121: NOT
77122: IFFALSE 77134
// x := mcts ;
77124: LD_ADDR_VAR 0 11
77128: PUSH
77129: LD_VAR 0 10
77133: ST_TO_ADDR
// if not x then
77134: LD_VAR 0 11
77138: NOT
77139: IFFALSE 77143
// continue ;
77141: GO 76922
// if mc_remote_driver [ i ] then
77143: LD_EXP 90
77147: PUSH
77148: LD_VAR 0 2
77152: ARRAY
77153: IFFALSE 77540
// for j in mc_remote_driver [ i ] do
77155: LD_ADDR_VAR 0 3
77159: PUSH
77160: LD_EXP 90
77164: PUSH
77165: LD_VAR 0 2
77169: ARRAY
77170: PUSH
77171: FOR_IN
77172: IFFALSE 77538
// begin if GetClass ( j ) <> 3 then
77174: LD_VAR 0 3
77178: PPUSH
77179: CALL_OW 257
77183: PUSH
77184: LD_INT 3
77186: NONEQUAL
77187: IFFALSE 77240
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77189: LD_ADDR_EXP 90
77193: PUSH
77194: LD_EXP 90
77198: PPUSH
77199: LD_VAR 0 2
77203: PPUSH
77204: LD_EXP 90
77208: PUSH
77209: LD_VAR 0 2
77213: ARRAY
77214: PUSH
77215: LD_VAR 0 3
77219: DIFF
77220: PPUSH
77221: CALL_OW 1
77225: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77226: LD_VAR 0 3
77230: PPUSH
77231: LD_INT 0
77233: PPUSH
77234: CALL_OW 109
// continue ;
77238: GO 77171
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
77240: LD_EXP 69
77244: PUSH
77245: LD_VAR 0 2
77249: ARRAY
77250: PPUSH
77251: LD_INT 34
77253: PUSH
77254: LD_INT 31
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PUSH
77261: LD_INT 58
77263: PUSH
77264: EMPTY
77265: LIST
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PPUSH
77271: CALL_OW 72
77275: PUSH
77276: LD_VAR 0 3
77280: PPUSH
77281: CALL 48549 0 1
77285: NOT
77286: AND
77287: IFFALSE 77358
// begin if IsInUnit ( j ) then
77289: LD_VAR 0 3
77293: PPUSH
77294: CALL_OW 310
77298: IFFALSE 77309
// ComExitBuilding ( j ) ;
77300: LD_VAR 0 3
77304: PPUSH
77305: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77309: LD_VAR 0 3
77313: PPUSH
77314: LD_EXP 69
77318: PUSH
77319: LD_VAR 0 2
77323: ARRAY
77324: PPUSH
77325: LD_INT 34
77327: PUSH
77328: LD_INT 31
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 58
77337: PUSH
77338: EMPTY
77339: LIST
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PPUSH
77345: CALL_OW 72
77349: PUSH
77350: LD_INT 1
77352: ARRAY
77353: PPUSH
77354: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77358: LD_VAR 0 3
77362: PPUSH
77363: CALL_OW 310
77367: NOT
77368: PUSH
77369: LD_VAR 0 3
77373: PPUSH
77374: CALL_OW 310
77378: PPUSH
77379: CALL_OW 266
77383: PUSH
77384: LD_INT 36
77386: NONEQUAL
77387: PUSH
77388: LD_VAR 0 3
77392: PPUSH
77393: CALL 48549 0 1
77397: NOT
77398: AND
77399: OR
77400: IFFALSE 77536
// begin if IsInUnit ( j ) then
77402: LD_VAR 0 3
77406: PPUSH
77407: CALL_OW 310
77411: IFFALSE 77422
// ComExitBuilding ( j ) ;
77413: LD_VAR 0 3
77417: PPUSH
77418: CALL_OW 122
// ct := 0 ;
77422: LD_ADDR_VAR 0 8
77426: PUSH
77427: LD_INT 0
77429: ST_TO_ADDR
// for k in x do
77430: LD_ADDR_VAR 0 4
77434: PUSH
77435: LD_VAR 0 11
77439: PUSH
77440: FOR_IN
77441: IFFALSE 77514
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77443: LD_VAR 0 4
77447: PPUSH
77448: CALL_OW 264
77452: PUSH
77453: LD_INT 31
77455: EQUAL
77456: PUSH
77457: LD_VAR 0 4
77461: PPUSH
77462: CALL_OW 311
77466: NOT
77467: AND
77468: PUSH
77469: LD_VAR 0 4
77473: PPUSH
77474: CALL_OW 266
77478: PUSH
77479: LD_INT 36
77481: EQUAL
77482: PUSH
77483: LD_VAR 0 4
77487: PPUSH
77488: CALL_OW 313
77492: PUSH
77493: LD_INT 3
77495: LESS
77496: AND
77497: OR
77498: IFFALSE 77512
// begin ct := k ;
77500: LD_ADDR_VAR 0 8
77504: PUSH
77505: LD_VAR 0 4
77509: ST_TO_ADDR
// break ;
77510: GO 77514
// end ;
77512: GO 77440
77514: POP
77515: POP
// if ct then
77516: LD_VAR 0 8
77520: IFFALSE 77536
// ComEnterUnit ( j , ct ) ;
77522: LD_VAR 0 3
77526: PPUSH
77527: LD_VAR 0 8
77531: PPUSH
77532: CALL_OW 120
// end ; end ;
77536: GO 77171
77538: POP
77539: POP
// places := 0 ;
77540: LD_ADDR_VAR 0 5
77544: PUSH
77545: LD_INT 0
77547: ST_TO_ADDR
// for j = 1 to x do
77548: LD_ADDR_VAR 0 3
77552: PUSH
77553: DOUBLE
77554: LD_INT 1
77556: DEC
77557: ST_TO_ADDR
77558: LD_VAR 0 11
77562: PUSH
77563: FOR_TO
77564: IFFALSE 77640
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77566: LD_VAR 0 11
77570: PUSH
77571: LD_VAR 0 3
77575: ARRAY
77576: PPUSH
77577: CALL_OW 264
77581: PUSH
77582: LD_INT 31
77584: EQUAL
77585: IFFALSE 77603
// places := places + 1 else
77587: LD_ADDR_VAR 0 5
77591: PUSH
77592: LD_VAR 0 5
77596: PUSH
77597: LD_INT 1
77599: PLUS
77600: ST_TO_ADDR
77601: GO 77638
// if GetBType ( x [ j ] ) = b_control_tower then
77603: LD_VAR 0 11
77607: PUSH
77608: LD_VAR 0 3
77612: ARRAY
77613: PPUSH
77614: CALL_OW 266
77618: PUSH
77619: LD_INT 36
77621: EQUAL
77622: IFFALSE 77638
// places := places + 3 ;
77624: LD_ADDR_VAR 0 5
77628: PUSH
77629: LD_VAR 0 5
77633: PUSH
77634: LD_INT 3
77636: PLUS
77637: ST_TO_ADDR
77638: GO 77563
77640: POP
77641: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77642: LD_VAR 0 5
77646: PUSH
77647: LD_INT 0
77649: EQUAL
77650: PUSH
77651: LD_VAR 0 5
77655: PUSH
77656: LD_EXP 90
77660: PUSH
77661: LD_VAR 0 2
77665: ARRAY
77666: LESSEQUAL
77667: OR
77668: IFFALSE 77672
// continue ;
77670: GO 76922
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77672: LD_ADDR_VAR 0 6
77676: PUSH
77677: LD_EXP 50
77681: PUSH
77682: LD_VAR 0 2
77686: ARRAY
77687: PPUSH
77688: LD_INT 25
77690: PUSH
77691: LD_INT 3
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PPUSH
77698: CALL_OW 72
77702: PUSH
77703: LD_EXP 90
77707: PUSH
77708: LD_VAR 0 2
77712: ARRAY
77713: DIFF
77714: PPUSH
77715: LD_INT 3
77717: PPUSH
77718: CALL 49449 0 2
77722: ST_TO_ADDR
// for j in tmp do
77723: LD_ADDR_VAR 0 3
77727: PUSH
77728: LD_VAR 0 6
77732: PUSH
77733: FOR_IN
77734: IFFALSE 77769
// if GetTag ( j ) > 0 then
77736: LD_VAR 0 3
77740: PPUSH
77741: CALL_OW 110
77745: PUSH
77746: LD_INT 0
77748: GREATER
77749: IFFALSE 77767
// tmp := tmp diff j ;
77751: LD_ADDR_VAR 0 6
77755: PUSH
77756: LD_VAR 0 6
77760: PUSH
77761: LD_VAR 0 3
77765: DIFF
77766: ST_TO_ADDR
77767: GO 77733
77769: POP
77770: POP
// if not tmp then
77771: LD_VAR 0 6
77775: NOT
77776: IFFALSE 77780
// continue ;
77778: GO 76922
// if places then
77780: LD_VAR 0 5
77784: IFFALSE 77843
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77786: LD_ADDR_EXP 90
77790: PUSH
77791: LD_EXP 90
77795: PPUSH
77796: LD_VAR 0 2
77800: PPUSH
77801: LD_EXP 90
77805: PUSH
77806: LD_VAR 0 2
77810: ARRAY
77811: PUSH
77812: LD_VAR 0 6
77816: PUSH
77817: LD_INT 1
77819: ARRAY
77820: UNION
77821: PPUSH
77822: CALL_OW 1
77826: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77827: LD_VAR 0 6
77831: PUSH
77832: LD_INT 1
77834: ARRAY
77835: PPUSH
77836: LD_INT 126
77838: PPUSH
77839: CALL_OW 109
// end ; end ;
77843: GO 76922
77845: POP
77846: POP
// end ;
77847: LD_VAR 0 1
77851: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77852: LD_INT 0
77854: PPUSH
77855: PPUSH
77856: PPUSH
77857: PPUSH
77858: PPUSH
77859: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77860: LD_VAR 0 1
77864: NOT
77865: PUSH
77866: LD_VAR 0 2
77870: NOT
77871: OR
77872: PUSH
77873: LD_VAR 0 3
77877: NOT
77878: OR
77879: PUSH
77880: LD_VAR 0 4
77884: PUSH
77885: LD_INT 1
77887: PUSH
77888: LD_INT 2
77890: PUSH
77891: LD_INT 3
77893: PUSH
77894: LD_INT 4
77896: PUSH
77897: LD_INT 5
77899: PUSH
77900: LD_INT 8
77902: PUSH
77903: LD_INT 9
77905: PUSH
77906: LD_INT 15
77908: PUSH
77909: LD_INT 16
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: LIST
77922: IN
77923: NOT
77924: OR
77925: IFFALSE 77929
// exit ;
77927: GO 78787
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77929: LD_ADDR_VAR 0 2
77933: PUSH
77934: LD_VAR 0 2
77938: PPUSH
77939: LD_INT 21
77941: PUSH
77942: LD_INT 3
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 24
77951: PUSH
77952: LD_INT 250
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PPUSH
77963: CALL_OW 72
77967: ST_TO_ADDR
// case class of 1 , 15 :
77968: LD_VAR 0 4
77972: PUSH
77973: LD_INT 1
77975: DOUBLE
77976: EQUAL
77977: IFTRUE 77987
77979: LD_INT 15
77981: DOUBLE
77982: EQUAL
77983: IFTRUE 77987
77985: GO 78072
77987: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77988: LD_ADDR_VAR 0 8
77992: PUSH
77993: LD_VAR 0 2
77997: PPUSH
77998: LD_INT 2
78000: PUSH
78001: LD_INT 30
78003: PUSH
78004: LD_INT 32
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 30
78013: PUSH
78014: LD_INT 31
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: LIST
78025: PPUSH
78026: CALL_OW 72
78030: PUSH
78031: LD_VAR 0 2
78035: PPUSH
78036: LD_INT 2
78038: PUSH
78039: LD_INT 30
78041: PUSH
78042: LD_INT 4
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 30
78051: PUSH
78052: LD_INT 5
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: LIST
78063: PPUSH
78064: CALL_OW 72
78068: ADD
78069: ST_TO_ADDR
78070: GO 78318
78072: LD_INT 2
78074: DOUBLE
78075: EQUAL
78076: IFTRUE 78086
78078: LD_INT 16
78080: DOUBLE
78081: EQUAL
78082: IFTRUE 78086
78084: GO 78132
78086: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78087: LD_ADDR_VAR 0 8
78091: PUSH
78092: LD_VAR 0 2
78096: PPUSH
78097: LD_INT 2
78099: PUSH
78100: LD_INT 30
78102: PUSH
78103: LD_INT 0
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 30
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: LIST
78124: PPUSH
78125: CALL_OW 72
78129: ST_TO_ADDR
78130: GO 78318
78132: LD_INT 3
78134: DOUBLE
78135: EQUAL
78136: IFTRUE 78140
78138: GO 78186
78140: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78141: LD_ADDR_VAR 0 8
78145: PUSH
78146: LD_VAR 0 2
78150: PPUSH
78151: LD_INT 2
78153: PUSH
78154: LD_INT 30
78156: PUSH
78157: LD_INT 2
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 30
78166: PUSH
78167: LD_INT 3
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: LIST
78178: PPUSH
78179: CALL_OW 72
78183: ST_TO_ADDR
78184: GO 78318
78186: LD_INT 4
78188: DOUBLE
78189: EQUAL
78190: IFTRUE 78194
78192: GO 78251
78194: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78195: LD_ADDR_VAR 0 8
78199: PUSH
78200: LD_VAR 0 2
78204: PPUSH
78205: LD_INT 2
78207: PUSH
78208: LD_INT 30
78210: PUSH
78211: LD_INT 6
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 30
78220: PUSH
78221: LD_INT 7
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 30
78230: PUSH
78231: LD_INT 8
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: PPUSH
78244: CALL_OW 72
78248: ST_TO_ADDR
78249: GO 78318
78251: LD_INT 5
78253: DOUBLE
78254: EQUAL
78255: IFTRUE 78271
78257: LD_INT 8
78259: DOUBLE
78260: EQUAL
78261: IFTRUE 78271
78263: LD_INT 9
78265: DOUBLE
78266: EQUAL
78267: IFTRUE 78271
78269: GO 78317
78271: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78272: LD_ADDR_VAR 0 8
78276: PUSH
78277: LD_VAR 0 2
78281: PPUSH
78282: LD_INT 2
78284: PUSH
78285: LD_INT 30
78287: PUSH
78288: LD_INT 4
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 30
78297: PUSH
78298: LD_INT 5
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: LIST
78309: PPUSH
78310: CALL_OW 72
78314: ST_TO_ADDR
78315: GO 78318
78317: POP
// if not tmp then
78318: LD_VAR 0 8
78322: NOT
78323: IFFALSE 78327
// exit ;
78325: GO 78787
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78327: LD_VAR 0 4
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: LD_INT 15
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: IN
78342: PUSH
78343: LD_EXP 59
78347: PUSH
78348: LD_VAR 0 1
78352: ARRAY
78353: AND
78354: IFFALSE 78510
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78356: LD_ADDR_VAR 0 9
78360: PUSH
78361: LD_EXP 59
78365: PUSH
78366: LD_VAR 0 1
78370: ARRAY
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78376: LD_VAR 0 9
78380: PUSH
78381: LD_EXP 60
78385: PUSH
78386: LD_VAR 0 1
78390: ARRAY
78391: IN
78392: NOT
78393: IFFALSE 78508
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78395: LD_ADDR_EXP 60
78399: PUSH
78400: LD_EXP 60
78404: PPUSH
78405: LD_VAR 0 1
78409: PUSH
78410: LD_EXP 60
78414: PUSH
78415: LD_VAR 0 1
78419: ARRAY
78420: PUSH
78421: LD_INT 1
78423: PLUS
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PPUSH
78429: LD_VAR 0 9
78433: PPUSH
78434: CALL 18573 0 3
78438: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78439: LD_ADDR_EXP 59
78443: PUSH
78444: LD_EXP 59
78448: PPUSH
78449: LD_VAR 0 1
78453: PPUSH
78454: LD_EXP 59
78458: PUSH
78459: LD_VAR 0 1
78463: ARRAY
78464: PUSH
78465: LD_VAR 0 9
78469: DIFF
78470: PPUSH
78471: CALL_OW 1
78475: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78476: LD_VAR 0 3
78480: PPUSH
78481: LD_EXP 60
78485: PUSH
78486: LD_VAR 0 1
78490: ARRAY
78491: PUSH
78492: LD_EXP 60
78496: PUSH
78497: LD_VAR 0 1
78501: ARRAY
78502: ARRAY
78503: PPUSH
78504: CALL_OW 120
// end ; exit ;
78508: GO 78787
// end ; if tmp > 1 then
78510: LD_VAR 0 8
78514: PUSH
78515: LD_INT 1
78517: GREATER
78518: IFFALSE 78622
// for i = 2 to tmp do
78520: LD_ADDR_VAR 0 6
78524: PUSH
78525: DOUBLE
78526: LD_INT 2
78528: DEC
78529: ST_TO_ADDR
78530: LD_VAR 0 8
78534: PUSH
78535: FOR_TO
78536: IFFALSE 78620
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78538: LD_VAR 0 8
78542: PUSH
78543: LD_VAR 0 6
78547: ARRAY
78548: PPUSH
78549: CALL_OW 461
78553: PUSH
78554: LD_INT 6
78556: EQUAL
78557: IFFALSE 78618
// begin x := tmp [ i ] ;
78559: LD_ADDR_VAR 0 9
78563: PUSH
78564: LD_VAR 0 8
78568: PUSH
78569: LD_VAR 0 6
78573: ARRAY
78574: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78575: LD_ADDR_VAR 0 8
78579: PUSH
78580: LD_VAR 0 8
78584: PPUSH
78585: LD_VAR 0 6
78589: PPUSH
78590: CALL_OW 3
78594: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78595: LD_ADDR_VAR 0 8
78599: PUSH
78600: LD_VAR 0 8
78604: PPUSH
78605: LD_INT 1
78607: PPUSH
78608: LD_VAR 0 9
78612: PPUSH
78613: CALL_OW 2
78617: ST_TO_ADDR
// end ;
78618: GO 78535
78620: POP
78621: POP
// for i in tmp do
78622: LD_ADDR_VAR 0 6
78626: PUSH
78627: LD_VAR 0 8
78631: PUSH
78632: FOR_IN
78633: IFFALSE 78660
// begin if IsNotFull ( i ) then
78635: LD_VAR 0 6
78639: PPUSH
78640: CALL 15795 0 1
78644: IFFALSE 78658
// begin j := i ;
78646: LD_ADDR_VAR 0 7
78650: PUSH
78651: LD_VAR 0 6
78655: ST_TO_ADDR
// break ;
78656: GO 78660
// end ; end ;
78658: GO 78632
78660: POP
78661: POP
// if j then
78662: LD_VAR 0 7
78666: IFFALSE 78684
// ComEnterUnit ( unit , j ) else
78668: LD_VAR 0 3
78672: PPUSH
78673: LD_VAR 0 7
78677: PPUSH
78678: CALL_OW 120
78682: GO 78787
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78684: LD_ADDR_VAR 0 10
78688: PUSH
78689: LD_VAR 0 2
78693: PPUSH
78694: LD_INT 2
78696: PUSH
78697: LD_INT 30
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 30
78709: PUSH
78710: LD_INT 1
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: LIST
78721: PPUSH
78722: CALL_OW 72
78726: ST_TO_ADDR
// if depot then
78727: LD_VAR 0 10
78731: IFFALSE 78787
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78733: LD_ADDR_VAR 0 10
78737: PUSH
78738: LD_VAR 0 10
78742: PPUSH
78743: LD_VAR 0 3
78747: PPUSH
78748: CALL_OW 74
78752: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78753: LD_VAR 0 3
78757: PPUSH
78758: LD_VAR 0 10
78762: PPUSH
78763: CALL_OW 296
78767: PUSH
78768: LD_INT 10
78770: GREATER
78771: IFFALSE 78787
// ComStandNearbyBuilding ( unit , depot ) ;
78773: LD_VAR 0 3
78777: PPUSH
78778: LD_VAR 0 10
78782: PPUSH
78783: CALL 15175 0 2
// end ; end ; end ;
78787: LD_VAR 0 5
78791: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78792: LD_INT 0
78794: PPUSH
78795: PPUSH
78796: PPUSH
78797: PPUSH
// if not mc_bases then
78798: LD_EXP 50
78802: NOT
78803: IFFALSE 78807
// exit ;
78805: GO 79046
// for i = 1 to mc_bases do
78807: LD_ADDR_VAR 0 2
78811: PUSH
78812: DOUBLE
78813: LD_INT 1
78815: DEC
78816: ST_TO_ADDR
78817: LD_EXP 50
78821: PUSH
78822: FOR_TO
78823: IFFALSE 79044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78825: LD_ADDR_VAR 0 4
78829: PUSH
78830: LD_EXP 50
78834: PUSH
78835: LD_VAR 0 2
78839: ARRAY
78840: PPUSH
78841: LD_INT 21
78843: PUSH
78844: LD_INT 1
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PPUSH
78851: CALL_OW 72
78855: PUSH
78856: LD_EXP 79
78860: PUSH
78861: LD_VAR 0 2
78865: ARRAY
78866: UNION
78867: ST_TO_ADDR
// if not tmp then
78868: LD_VAR 0 4
78872: NOT
78873: IFFALSE 78877
// continue ;
78875: GO 78822
// for j in tmp do
78877: LD_ADDR_VAR 0 3
78881: PUSH
78882: LD_VAR 0 4
78886: PUSH
78887: FOR_IN
78888: IFFALSE 79040
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78890: LD_VAR 0 3
78894: PPUSH
78895: CALL_OW 110
78899: NOT
78900: PUSH
78901: LD_VAR 0 3
78905: PPUSH
78906: CALL_OW 314
78910: NOT
78911: AND
78912: PUSH
78913: LD_VAR 0 3
78917: PPUSH
78918: CALL_OW 311
78922: NOT
78923: AND
78924: PUSH
78925: LD_VAR 0 3
78929: PPUSH
78930: CALL_OW 310
78934: NOT
78935: AND
78936: PUSH
78937: LD_VAR 0 3
78941: PUSH
78942: LD_EXP 53
78946: PUSH
78947: LD_VAR 0 2
78951: ARRAY
78952: PUSH
78953: LD_INT 1
78955: ARRAY
78956: IN
78957: NOT
78958: AND
78959: PUSH
78960: LD_VAR 0 3
78964: PUSH
78965: LD_EXP 53
78969: PUSH
78970: LD_VAR 0 2
78974: ARRAY
78975: PUSH
78976: LD_INT 2
78978: ARRAY
78979: IN
78980: NOT
78981: AND
78982: PUSH
78983: LD_VAR 0 3
78987: PUSH
78988: LD_EXP 62
78992: PUSH
78993: LD_VAR 0 2
78997: ARRAY
78998: IN
78999: NOT
79000: AND
79001: IFFALSE 79038
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79003: LD_VAR 0 2
79007: PPUSH
79008: LD_EXP 50
79012: PUSH
79013: LD_VAR 0 2
79017: ARRAY
79018: PPUSH
79019: LD_VAR 0 3
79023: PPUSH
79024: LD_VAR 0 3
79028: PPUSH
79029: CALL_OW 257
79033: PPUSH
79034: CALL 77852 0 4
// end ;
79038: GO 78887
79040: POP
79041: POP
// end ;
79042: GO 78822
79044: POP
79045: POP
// end ;
79046: LD_VAR 0 1
79050: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
79051: LD_INT 0
79053: PPUSH
79054: PPUSH
79055: PPUSH
79056: PPUSH
79057: PPUSH
79058: PPUSH
// if not mc_bases [ base ] then
79059: LD_EXP 50
79063: PUSH
79064: LD_VAR 0 1
79068: ARRAY
79069: NOT
79070: IFFALSE 79074
// exit ;
79072: GO 79275
// tmp := [ ] ;
79074: LD_ADDR_VAR 0 6
79078: PUSH
79079: EMPTY
79080: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79081: LD_ADDR_VAR 0 7
79085: PUSH
79086: LD_VAR 0 3
79090: PPUSH
79091: LD_INT 0
79093: PPUSH
79094: CALL_OW 517
79098: ST_TO_ADDR
// if not list then
79099: LD_VAR 0 7
79103: NOT
79104: IFFALSE 79108
// exit ;
79106: GO 79275
// c := Count ( list [ 1 ] ) ;
79108: LD_ADDR_VAR 0 9
79112: PUSH
79113: LD_VAR 0 7
79117: PUSH
79118: LD_INT 1
79120: ARRAY
79121: PPUSH
79122: CALL 15713 0 1
79126: ST_TO_ADDR
// if amount > c then
79127: LD_VAR 0 2
79131: PUSH
79132: LD_VAR 0 9
79136: GREATER
79137: IFFALSE 79149
// amount := c ;
79139: LD_ADDR_VAR 0 2
79143: PUSH
79144: LD_VAR 0 9
79148: ST_TO_ADDR
// for i := 1 to amount do
79149: LD_ADDR_VAR 0 5
79153: PUSH
79154: DOUBLE
79155: LD_INT 1
79157: DEC
79158: ST_TO_ADDR
79159: LD_VAR 0 2
79163: PUSH
79164: FOR_TO
79165: IFFALSE 79223
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
79167: LD_ADDR_VAR 0 6
79171: PUSH
79172: LD_VAR 0 6
79176: PPUSH
79177: LD_VAR 0 5
79181: PPUSH
79182: LD_VAR 0 7
79186: PUSH
79187: LD_INT 1
79189: ARRAY
79190: PUSH
79191: LD_VAR 0 5
79195: ARRAY
79196: PUSH
79197: LD_VAR 0 7
79201: PUSH
79202: LD_INT 2
79204: ARRAY
79205: PUSH
79206: LD_VAR 0 5
79210: ARRAY
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PPUSH
79216: CALL_OW 1
79220: ST_TO_ADDR
79221: GO 79164
79223: POP
79224: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79225: LD_ADDR_EXP 63
79229: PUSH
79230: LD_EXP 63
79234: PPUSH
79235: LD_VAR 0 1
79239: PPUSH
79240: LD_VAR 0 6
79244: PPUSH
79245: CALL_OW 1
79249: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79250: LD_ADDR_EXP 65
79254: PUSH
79255: LD_EXP 65
79259: PPUSH
79260: LD_VAR 0 1
79264: PPUSH
79265: LD_VAR 0 3
79269: PPUSH
79270: CALL_OW 1
79274: ST_TO_ADDR
// end ;
79275: LD_VAR 0 4
79279: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79280: LD_INT 0
79282: PPUSH
// if not mc_bases [ base ] then
79283: LD_EXP 50
79287: PUSH
79288: LD_VAR 0 1
79292: ARRAY
79293: NOT
79294: IFFALSE 79298
// exit ;
79296: GO 79323
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79298: LD_ADDR_EXP 55
79302: PUSH
79303: LD_EXP 55
79307: PPUSH
79308: LD_VAR 0 1
79312: PPUSH
79313: LD_VAR 0 2
79317: PPUSH
79318: CALL_OW 1
79322: ST_TO_ADDR
// end ;
79323: LD_VAR 0 3
79327: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79328: LD_INT 0
79330: PPUSH
// if not mc_bases [ base ] then
79331: LD_EXP 50
79335: PUSH
79336: LD_VAR 0 1
79340: ARRAY
79341: NOT
79342: IFFALSE 79346
// exit ;
79344: GO 79383
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79346: LD_ADDR_EXP 55
79350: PUSH
79351: LD_EXP 55
79355: PPUSH
79356: LD_VAR 0 1
79360: PPUSH
79361: LD_EXP 55
79365: PUSH
79366: LD_VAR 0 1
79370: ARRAY
79371: PUSH
79372: LD_VAR 0 2
79376: UNION
79377: PPUSH
79378: CALL_OW 1
79382: ST_TO_ADDR
// end ;
79383: LD_VAR 0 3
79387: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79388: LD_INT 0
79390: PPUSH
// if not mc_bases [ base ] then
79391: LD_EXP 50
79395: PUSH
79396: LD_VAR 0 1
79400: ARRAY
79401: NOT
79402: IFFALSE 79406
// exit ;
79404: GO 79431
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79406: LD_ADDR_EXP 71
79410: PUSH
79411: LD_EXP 71
79415: PPUSH
79416: LD_VAR 0 1
79420: PPUSH
79421: LD_VAR 0 2
79425: PPUSH
79426: CALL_OW 1
79430: ST_TO_ADDR
// end ;
79431: LD_VAR 0 3
79435: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79436: LD_INT 0
79438: PPUSH
// if not mc_bases [ base ] then
79439: LD_EXP 50
79443: PUSH
79444: LD_VAR 0 1
79448: ARRAY
79449: NOT
79450: IFFALSE 79454
// exit ;
79452: GO 79491
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79454: LD_ADDR_EXP 71
79458: PUSH
79459: LD_EXP 71
79463: PPUSH
79464: LD_VAR 0 1
79468: PPUSH
79469: LD_EXP 71
79473: PUSH
79474: LD_VAR 0 1
79478: ARRAY
79479: PUSH
79480: LD_VAR 0 2
79484: ADD
79485: PPUSH
79486: CALL_OW 1
79490: ST_TO_ADDR
// end ;
79491: LD_VAR 0 3
79495: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79496: LD_INT 0
79498: PPUSH
// if not mc_bases [ base ] then
79499: LD_EXP 50
79503: PUSH
79504: LD_VAR 0 1
79508: ARRAY
79509: NOT
79510: IFFALSE 79514
// exit ;
79512: GO 79568
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79514: LD_ADDR_EXP 72
79518: PUSH
79519: LD_EXP 72
79523: PPUSH
79524: LD_VAR 0 1
79528: PPUSH
79529: LD_VAR 0 2
79533: PPUSH
79534: CALL_OW 1
79538: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79539: LD_ADDR_EXP 61
79543: PUSH
79544: LD_EXP 61
79548: PPUSH
79549: LD_VAR 0 1
79553: PPUSH
79554: LD_VAR 0 2
79558: PUSH
79559: LD_INT 0
79561: PLUS
79562: PPUSH
79563: CALL_OW 1
79567: ST_TO_ADDR
// end ;
79568: LD_VAR 0 3
79572: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79573: LD_INT 0
79575: PPUSH
// if not mc_bases [ base ] then
79576: LD_EXP 50
79580: PUSH
79581: LD_VAR 0 1
79585: ARRAY
79586: NOT
79587: IFFALSE 79591
// exit ;
79589: GO 79616
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79591: LD_ADDR_EXP 61
79595: PUSH
79596: LD_EXP 61
79600: PPUSH
79601: LD_VAR 0 1
79605: PPUSH
79606: LD_VAR 0 2
79610: PPUSH
79611: CALL_OW 1
79615: ST_TO_ADDR
// end ;
79616: LD_VAR 0 3
79620: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79621: LD_INT 0
79623: PPUSH
79624: PPUSH
79625: PPUSH
79626: PPUSH
// if not mc_bases [ base ] then
79627: LD_EXP 50
79631: PUSH
79632: LD_VAR 0 1
79636: ARRAY
79637: NOT
79638: IFFALSE 79642
// exit ;
79640: GO 79707
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79642: LD_ADDR_EXP 70
79646: PUSH
79647: LD_EXP 70
79651: PPUSH
79652: LD_VAR 0 1
79656: PUSH
79657: LD_EXP 70
79661: PUSH
79662: LD_VAR 0 1
79666: ARRAY
79667: PUSH
79668: LD_INT 1
79670: PLUS
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PPUSH
79676: LD_VAR 0 1
79680: PUSH
79681: LD_VAR 0 2
79685: PUSH
79686: LD_VAR 0 3
79690: PUSH
79691: LD_VAR 0 4
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: PPUSH
79702: CALL 18573 0 3
79706: ST_TO_ADDR
// end ;
79707: LD_VAR 0 5
79711: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79712: LD_INT 0
79714: PPUSH
// if not mc_bases [ base ] then
79715: LD_EXP 50
79719: PUSH
79720: LD_VAR 0 1
79724: ARRAY
79725: NOT
79726: IFFALSE 79730
// exit ;
79728: GO 79755
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79730: LD_ADDR_EXP 87
79734: PUSH
79735: LD_EXP 87
79739: PPUSH
79740: LD_VAR 0 1
79744: PPUSH
79745: LD_VAR 0 2
79749: PPUSH
79750: CALL_OW 1
79754: ST_TO_ADDR
// end ;
79755: LD_VAR 0 3
79759: RET
// export function MC_GetMinesField ( base ) ; begin
79760: LD_INT 0
79762: PPUSH
// result := mc_mines [ base ] ;
79763: LD_ADDR_VAR 0 2
79767: PUSH
79768: LD_EXP 63
79772: PUSH
79773: LD_VAR 0 1
79777: ARRAY
79778: ST_TO_ADDR
// end ;
79779: LD_VAR 0 2
79783: RET
// export function MC_GetProduceList ( base ) ; begin
79784: LD_INT 0
79786: PPUSH
// result := mc_produce [ base ] ;
79787: LD_ADDR_VAR 0 2
79791: PUSH
79792: LD_EXP 71
79796: PUSH
79797: LD_VAR 0 1
79801: ARRAY
79802: ST_TO_ADDR
// end ;
79803: LD_VAR 0 2
79807: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79808: LD_INT 0
79810: PPUSH
79811: PPUSH
// if not mc_bases then
79812: LD_EXP 50
79816: NOT
79817: IFFALSE 79821
// exit ;
79819: GO 79886
// if mc_bases [ base ] then
79821: LD_EXP 50
79825: PUSH
79826: LD_VAR 0 1
79830: ARRAY
79831: IFFALSE 79886
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79833: LD_ADDR_VAR 0 3
79837: PUSH
79838: LD_EXP 50
79842: PUSH
79843: LD_VAR 0 1
79847: ARRAY
79848: PPUSH
79849: LD_INT 30
79851: PUSH
79852: LD_VAR 0 2
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PPUSH
79861: CALL_OW 72
79865: ST_TO_ADDR
// if result then
79866: LD_VAR 0 3
79870: IFFALSE 79886
// result := result [ 1 ] ;
79872: LD_ADDR_VAR 0 3
79876: PUSH
79877: LD_VAR 0 3
79881: PUSH
79882: LD_INT 1
79884: ARRAY
79885: ST_TO_ADDR
// end ; end ;
79886: LD_VAR 0 3
79890: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79891: LD_INT 0
79893: PPUSH
79894: PPUSH
// if not mc_bases then
79895: LD_EXP 50
79899: NOT
79900: IFFALSE 79904
// exit ;
79902: GO 79949
// if mc_bases [ base ] then
79904: LD_EXP 50
79908: PUSH
79909: LD_VAR 0 1
79913: ARRAY
79914: IFFALSE 79949
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79916: LD_ADDR_VAR 0 3
79920: PUSH
79921: LD_EXP 50
79925: PUSH
79926: LD_VAR 0 1
79930: ARRAY
79931: PPUSH
79932: LD_INT 30
79934: PUSH
79935: LD_VAR 0 2
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PPUSH
79944: CALL_OW 72
79948: ST_TO_ADDR
// end ;
79949: LD_VAR 0 3
79953: RET
// export function MC_SetTame ( base , area ) ; begin
79954: LD_INT 0
79956: PPUSH
// if not mc_bases or not base then
79957: LD_EXP 50
79961: NOT
79962: PUSH
79963: LD_VAR 0 1
79967: NOT
79968: OR
79969: IFFALSE 79973
// exit ;
79971: GO 79998
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79973: LD_ADDR_EXP 78
79977: PUSH
79978: LD_EXP 78
79982: PPUSH
79983: LD_VAR 0 1
79987: PPUSH
79988: LD_VAR 0 2
79992: PPUSH
79993: CALL_OW 1
79997: ST_TO_ADDR
// end ;
79998: LD_VAR 0 3
80002: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80003: LD_INT 0
80005: PPUSH
80006: PPUSH
// if not mc_bases or not base then
80007: LD_EXP 50
80011: NOT
80012: PUSH
80013: LD_VAR 0 1
80017: NOT
80018: OR
80019: IFFALSE 80023
// exit ;
80021: GO 80125
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80023: LD_ADDR_VAR 0 4
80027: PUSH
80028: LD_EXP 50
80032: PUSH
80033: LD_VAR 0 1
80037: ARRAY
80038: PPUSH
80039: LD_INT 30
80041: PUSH
80042: LD_VAR 0 2
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PPUSH
80051: CALL_OW 72
80055: ST_TO_ADDR
// if not tmp then
80056: LD_VAR 0 4
80060: NOT
80061: IFFALSE 80065
// exit ;
80063: GO 80125
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80065: LD_ADDR_EXP 82
80069: PUSH
80070: LD_EXP 82
80074: PPUSH
80075: LD_VAR 0 1
80079: PPUSH
80080: LD_EXP 82
80084: PUSH
80085: LD_VAR 0 1
80089: ARRAY
80090: PPUSH
80091: LD_EXP 82
80095: PUSH
80096: LD_VAR 0 1
80100: ARRAY
80101: PUSH
80102: LD_INT 1
80104: PLUS
80105: PPUSH
80106: LD_VAR 0 4
80110: PUSH
80111: LD_INT 1
80113: ARRAY
80114: PPUSH
80115: CALL_OW 2
80119: PPUSH
80120: CALL_OW 1
80124: ST_TO_ADDR
// end ;
80125: LD_VAR 0 3
80129: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80130: LD_INT 0
80132: PPUSH
80133: PPUSH
// if not mc_bases or not base or not kinds then
80134: LD_EXP 50
80138: NOT
80139: PUSH
80140: LD_VAR 0 1
80144: NOT
80145: OR
80146: PUSH
80147: LD_VAR 0 2
80151: NOT
80152: OR
80153: IFFALSE 80157
// exit ;
80155: GO 80218
// for i in kinds do
80157: LD_ADDR_VAR 0 4
80161: PUSH
80162: LD_VAR 0 2
80166: PUSH
80167: FOR_IN
80168: IFFALSE 80216
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80170: LD_ADDR_EXP 84
80174: PUSH
80175: LD_EXP 84
80179: PPUSH
80180: LD_VAR 0 1
80184: PUSH
80185: LD_EXP 84
80189: PUSH
80190: LD_VAR 0 1
80194: ARRAY
80195: PUSH
80196: LD_INT 1
80198: PLUS
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PPUSH
80204: LD_VAR 0 4
80208: PPUSH
80209: CALL 18573 0 3
80213: ST_TO_ADDR
80214: GO 80167
80216: POP
80217: POP
// end ;
80218: LD_VAR 0 3
80222: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80223: LD_INT 0
80225: PPUSH
// if not mc_bases or not base or not areas then
80226: LD_EXP 50
80230: NOT
80231: PUSH
80232: LD_VAR 0 1
80236: NOT
80237: OR
80238: PUSH
80239: LD_VAR 0 2
80243: NOT
80244: OR
80245: IFFALSE 80249
// exit ;
80247: GO 80274
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80249: LD_ADDR_EXP 68
80253: PUSH
80254: LD_EXP 68
80258: PPUSH
80259: LD_VAR 0 1
80263: PPUSH
80264: LD_VAR 0 2
80268: PPUSH
80269: CALL_OW 1
80273: ST_TO_ADDR
// end ;
80274: LD_VAR 0 3
80278: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80279: LD_INT 0
80281: PPUSH
// if not mc_bases or not base or not teleports_exit then
80282: LD_EXP 50
80286: NOT
80287: PUSH
80288: LD_VAR 0 1
80292: NOT
80293: OR
80294: PUSH
80295: LD_VAR 0 2
80299: NOT
80300: OR
80301: IFFALSE 80305
// exit ;
80303: GO 80330
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80305: LD_ADDR_EXP 85
80309: PUSH
80310: LD_EXP 85
80314: PPUSH
80315: LD_VAR 0 1
80319: PPUSH
80320: LD_VAR 0 2
80324: PPUSH
80325: CALL_OW 1
80329: ST_TO_ADDR
// end ;
80330: LD_VAR 0 3
80334: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80335: LD_INT 0
80337: PPUSH
80338: PPUSH
80339: PPUSH
// if not mc_bases or not base or not ext_list then
80340: LD_EXP 50
80344: NOT
80345: PUSH
80346: LD_VAR 0 1
80350: NOT
80351: OR
80352: PUSH
80353: LD_VAR 0 5
80357: NOT
80358: OR
80359: IFFALSE 80363
// exit ;
80361: GO 80536
// tmp := GetFacExtXYD ( x , y , d ) ;
80363: LD_ADDR_VAR 0 8
80367: PUSH
80368: LD_VAR 0 2
80372: PPUSH
80373: LD_VAR 0 3
80377: PPUSH
80378: LD_VAR 0 4
80382: PPUSH
80383: CALL 48579 0 3
80387: ST_TO_ADDR
// if not tmp then
80388: LD_VAR 0 8
80392: NOT
80393: IFFALSE 80397
// exit ;
80395: GO 80536
// for i in tmp do
80397: LD_ADDR_VAR 0 7
80401: PUSH
80402: LD_VAR 0 8
80406: PUSH
80407: FOR_IN
80408: IFFALSE 80534
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80410: LD_ADDR_EXP 55
80414: PUSH
80415: LD_EXP 55
80419: PPUSH
80420: LD_VAR 0 1
80424: PPUSH
80425: LD_EXP 55
80429: PUSH
80430: LD_VAR 0 1
80434: ARRAY
80435: PPUSH
80436: LD_EXP 55
80440: PUSH
80441: LD_VAR 0 1
80445: ARRAY
80446: PUSH
80447: LD_INT 1
80449: PLUS
80450: PPUSH
80451: LD_VAR 0 5
80455: PUSH
80456: LD_INT 1
80458: ARRAY
80459: PUSH
80460: LD_VAR 0 7
80464: PUSH
80465: LD_INT 1
80467: ARRAY
80468: PUSH
80469: LD_VAR 0 7
80473: PUSH
80474: LD_INT 2
80476: ARRAY
80477: PUSH
80478: LD_VAR 0 7
80482: PUSH
80483: LD_INT 3
80485: ARRAY
80486: PUSH
80487: EMPTY
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: PPUSH
80493: CALL_OW 2
80497: PPUSH
80498: CALL_OW 1
80502: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80503: LD_ADDR_VAR 0 5
80507: PUSH
80508: LD_VAR 0 5
80512: PPUSH
80513: LD_INT 1
80515: PPUSH
80516: CALL_OW 3
80520: ST_TO_ADDR
// if not ext_list then
80521: LD_VAR 0 5
80525: NOT
80526: IFFALSE 80532
// exit ;
80528: POP
80529: POP
80530: GO 80536
// end ;
80532: GO 80407
80534: POP
80535: POP
// end ;
80536: LD_VAR 0 6
80540: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80541: LD_INT 0
80543: PPUSH
// if not mc_bases or not base or not weapon_list then
80544: LD_EXP 50
80548: NOT
80549: PUSH
80550: LD_VAR 0 1
80554: NOT
80555: OR
80556: PUSH
80557: LD_VAR 0 2
80561: NOT
80562: OR
80563: IFFALSE 80567
// exit ;
80565: GO 80592
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80567: LD_ADDR_EXP 89
80571: PUSH
80572: LD_EXP 89
80576: PPUSH
80577: LD_VAR 0 1
80581: PPUSH
80582: LD_VAR 0 2
80586: PPUSH
80587: CALL_OW 1
80591: ST_TO_ADDR
// end ;
80592: LD_VAR 0 3
80596: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80597: LD_INT 0
80599: PPUSH
// if not mc_bases or not base or not tech_list then
80600: LD_EXP 50
80604: NOT
80605: PUSH
80606: LD_VAR 0 1
80610: NOT
80611: OR
80612: PUSH
80613: LD_VAR 0 2
80617: NOT
80618: OR
80619: IFFALSE 80623
// exit ;
80621: GO 80648
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80623: LD_ADDR_EXP 77
80627: PUSH
80628: LD_EXP 77
80632: PPUSH
80633: LD_VAR 0 1
80637: PPUSH
80638: LD_VAR 0 2
80642: PPUSH
80643: CALL_OW 1
80647: ST_TO_ADDR
// end ;
80648: LD_VAR 0 3
80652: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80653: LD_INT 0
80655: PPUSH
// if not mc_bases or not parking_area or not base then
80656: LD_EXP 50
80660: NOT
80661: PUSH
80662: LD_VAR 0 2
80666: NOT
80667: OR
80668: PUSH
80669: LD_VAR 0 1
80673: NOT
80674: OR
80675: IFFALSE 80679
// exit ;
80677: GO 80704
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80679: LD_ADDR_EXP 74
80683: PUSH
80684: LD_EXP 74
80688: PPUSH
80689: LD_VAR 0 1
80693: PPUSH
80694: LD_VAR 0 2
80698: PPUSH
80699: CALL_OW 1
80703: ST_TO_ADDR
// end ;
80704: LD_VAR 0 3
80708: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80709: LD_INT 0
80711: PPUSH
// if not mc_bases or not base or not scan_area then
80712: LD_EXP 50
80716: NOT
80717: PUSH
80718: LD_VAR 0 1
80722: NOT
80723: OR
80724: PUSH
80725: LD_VAR 0 2
80729: NOT
80730: OR
80731: IFFALSE 80735
// exit ;
80733: GO 80760
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80735: LD_ADDR_EXP 75
80739: PUSH
80740: LD_EXP 75
80744: PPUSH
80745: LD_VAR 0 1
80749: PPUSH
80750: LD_VAR 0 2
80754: PPUSH
80755: CALL_OW 1
80759: ST_TO_ADDR
// end ;
80760: LD_VAR 0 3
80764: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80765: LD_INT 0
80767: PPUSH
80768: PPUSH
// if not mc_bases or not base then
80769: LD_EXP 50
80773: NOT
80774: PUSH
80775: LD_VAR 0 1
80779: NOT
80780: OR
80781: IFFALSE 80785
// exit ;
80783: GO 80849
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80785: LD_ADDR_VAR 0 3
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: LD_INT 2
80795: PUSH
80796: LD_INT 3
80798: PUSH
80799: LD_INT 4
80801: PUSH
80802: LD_INT 11
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: LIST
80809: LIST
80810: LIST
80811: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80812: LD_ADDR_EXP 77
80816: PUSH
80817: LD_EXP 77
80821: PPUSH
80822: LD_VAR 0 1
80826: PPUSH
80827: LD_EXP 77
80831: PUSH
80832: LD_VAR 0 1
80836: ARRAY
80837: PUSH
80838: LD_VAR 0 3
80842: DIFF
80843: PPUSH
80844: CALL_OW 1
80848: ST_TO_ADDR
// end ;
80849: LD_VAR 0 2
80853: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80854: LD_INT 0
80856: PPUSH
// result := mc_vehicles [ base ] ;
80857: LD_ADDR_VAR 0 3
80861: PUSH
80862: LD_EXP 69
80866: PUSH
80867: LD_VAR 0 1
80871: ARRAY
80872: ST_TO_ADDR
// if onlyCombat then
80873: LD_VAR 0 2
80877: IFFALSE 81049
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80879: LD_ADDR_VAR 0 3
80883: PUSH
80884: LD_VAR 0 3
80888: PUSH
80889: LD_VAR 0 3
80893: PPUSH
80894: LD_INT 2
80896: PUSH
80897: LD_INT 34
80899: PUSH
80900: LD_INT 12
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 34
80909: PUSH
80910: LD_INT 51
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 34
80919: PUSH
80920: LD_INT 89
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 34
80929: PUSH
80930: LD_INT 32
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 34
80939: PUSH
80940: LD_INT 13
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 34
80949: PUSH
80950: LD_INT 52
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 34
80959: PUSH
80960: LD_INT 88
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 34
80969: PUSH
80970: LD_INT 14
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 34
80979: PUSH
80980: LD_INT 53
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 34
80989: PUSH
80990: LD_INT 98
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 34
80999: PUSH
81000: LD_INT 31
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 34
81009: PUSH
81010: LD_INT 48
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 34
81019: PUSH
81020: LD_INT 8
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: LIST
81041: LIST
81042: PPUSH
81043: CALL_OW 72
81047: DIFF
81048: ST_TO_ADDR
// end ; end_of_file
81049: LD_VAR 0 3
81053: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81054: LD_INT 0
81056: PPUSH
81057: PPUSH
81058: PPUSH
// if not mc_bases or not skirmish then
81059: LD_EXP 50
81063: NOT
81064: PUSH
81065: LD_EXP 48
81069: NOT
81070: OR
81071: IFFALSE 81075
// exit ;
81073: GO 81240
// for i = 1 to mc_bases do
81075: LD_ADDR_VAR 0 4
81079: PUSH
81080: DOUBLE
81081: LD_INT 1
81083: DEC
81084: ST_TO_ADDR
81085: LD_EXP 50
81089: PUSH
81090: FOR_TO
81091: IFFALSE 81238
// begin if sci in mc_bases [ i ] then
81093: LD_VAR 0 2
81097: PUSH
81098: LD_EXP 50
81102: PUSH
81103: LD_VAR 0 4
81107: ARRAY
81108: IN
81109: IFFALSE 81236
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81111: LD_ADDR_EXP 79
81115: PUSH
81116: LD_EXP 79
81120: PPUSH
81121: LD_VAR 0 4
81125: PUSH
81126: LD_EXP 79
81130: PUSH
81131: LD_VAR 0 4
81135: ARRAY
81136: PUSH
81137: LD_INT 1
81139: PLUS
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PPUSH
81145: LD_VAR 0 1
81149: PPUSH
81150: CALL 18573 0 3
81154: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81155: LD_ADDR_VAR 0 5
81159: PUSH
81160: LD_EXP 50
81164: PUSH
81165: LD_VAR 0 4
81169: ARRAY
81170: PPUSH
81171: LD_INT 2
81173: PUSH
81174: LD_INT 30
81176: PUSH
81177: LD_INT 0
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 30
81186: PUSH
81187: LD_INT 1
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: LIST
81198: PPUSH
81199: CALL_OW 72
81203: PPUSH
81204: LD_VAR 0 1
81208: PPUSH
81209: CALL_OW 74
81213: ST_TO_ADDR
// if tmp then
81214: LD_VAR 0 5
81218: IFFALSE 81234
// ComStandNearbyBuilding ( ape , tmp ) ;
81220: LD_VAR 0 1
81224: PPUSH
81225: LD_VAR 0 5
81229: PPUSH
81230: CALL 15175 0 2
// break ;
81234: GO 81238
// end ; end ;
81236: GO 81090
81238: POP
81239: POP
// end ;
81240: LD_VAR 0 3
81244: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81245: LD_INT 0
81247: PPUSH
81248: PPUSH
81249: PPUSH
// if not mc_bases or not skirmish then
81250: LD_EXP 50
81254: NOT
81255: PUSH
81256: LD_EXP 48
81260: NOT
81261: OR
81262: IFFALSE 81266
// exit ;
81264: GO 81355
// for i = 1 to mc_bases do
81266: LD_ADDR_VAR 0 4
81270: PUSH
81271: DOUBLE
81272: LD_INT 1
81274: DEC
81275: ST_TO_ADDR
81276: LD_EXP 50
81280: PUSH
81281: FOR_TO
81282: IFFALSE 81353
// begin if building in mc_busy_turret_list [ i ] then
81284: LD_VAR 0 1
81288: PUSH
81289: LD_EXP 60
81293: PUSH
81294: LD_VAR 0 4
81298: ARRAY
81299: IN
81300: IFFALSE 81351
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81302: LD_ADDR_VAR 0 5
81306: PUSH
81307: LD_EXP 60
81311: PUSH
81312: LD_VAR 0 4
81316: ARRAY
81317: PUSH
81318: LD_VAR 0 1
81322: DIFF
81323: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81324: LD_ADDR_EXP 60
81328: PUSH
81329: LD_EXP 60
81333: PPUSH
81334: LD_VAR 0 4
81338: PPUSH
81339: LD_VAR 0 5
81343: PPUSH
81344: CALL_OW 1
81348: ST_TO_ADDR
// break ;
81349: GO 81353
// end ; end ;
81351: GO 81281
81353: POP
81354: POP
// end ;
81355: LD_VAR 0 3
81359: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81360: LD_INT 0
81362: PPUSH
81363: PPUSH
81364: PPUSH
// if not mc_bases or not skirmish then
81365: LD_EXP 50
81369: NOT
81370: PUSH
81371: LD_EXP 48
81375: NOT
81376: OR
81377: IFFALSE 81381
// exit ;
81379: GO 81580
// for i = 1 to mc_bases do
81381: LD_ADDR_VAR 0 5
81385: PUSH
81386: DOUBLE
81387: LD_INT 1
81389: DEC
81390: ST_TO_ADDR
81391: LD_EXP 50
81395: PUSH
81396: FOR_TO
81397: IFFALSE 81578
// if building in mc_bases [ i ] then
81399: LD_VAR 0 1
81403: PUSH
81404: LD_EXP 50
81408: PUSH
81409: LD_VAR 0 5
81413: ARRAY
81414: IN
81415: IFFALSE 81576
// begin tmp := mc_bases [ i ] diff building ;
81417: LD_ADDR_VAR 0 6
81421: PUSH
81422: LD_EXP 50
81426: PUSH
81427: LD_VAR 0 5
81431: ARRAY
81432: PUSH
81433: LD_VAR 0 1
81437: DIFF
81438: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81439: LD_ADDR_EXP 50
81443: PUSH
81444: LD_EXP 50
81448: PPUSH
81449: LD_VAR 0 5
81453: PPUSH
81454: LD_VAR 0 6
81458: PPUSH
81459: CALL_OW 1
81463: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81464: LD_VAR 0 1
81468: PUSH
81469: LD_EXP 58
81473: PUSH
81474: LD_VAR 0 5
81478: ARRAY
81479: IN
81480: IFFALSE 81519
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81482: LD_ADDR_EXP 58
81486: PUSH
81487: LD_EXP 58
81491: PPUSH
81492: LD_VAR 0 5
81496: PPUSH
81497: LD_EXP 58
81501: PUSH
81502: LD_VAR 0 5
81506: ARRAY
81507: PUSH
81508: LD_VAR 0 1
81512: DIFF
81513: PPUSH
81514: CALL_OW 1
81518: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81519: LD_VAR 0 1
81523: PUSH
81524: LD_EXP 59
81528: PUSH
81529: LD_VAR 0 5
81533: ARRAY
81534: IN
81535: IFFALSE 81574
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81537: LD_ADDR_EXP 59
81541: PUSH
81542: LD_EXP 59
81546: PPUSH
81547: LD_VAR 0 5
81551: PPUSH
81552: LD_EXP 59
81556: PUSH
81557: LD_VAR 0 5
81561: ARRAY
81562: PUSH
81563: LD_VAR 0 1
81567: DIFF
81568: PPUSH
81569: CALL_OW 1
81573: ST_TO_ADDR
// break ;
81574: GO 81578
// end ;
81576: GO 81396
81578: POP
81579: POP
// end ;
81580: LD_VAR 0 4
81584: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81585: LD_INT 0
81587: PPUSH
81588: PPUSH
81589: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81590: LD_EXP 50
81594: NOT
81595: PUSH
81596: LD_EXP 48
81600: NOT
81601: OR
81602: PUSH
81603: LD_VAR 0 3
81607: PUSH
81608: LD_EXP 76
81612: IN
81613: NOT
81614: OR
81615: IFFALSE 81619
// exit ;
81617: GO 81742
// for i = 1 to mc_vehicles do
81619: LD_ADDR_VAR 0 6
81623: PUSH
81624: DOUBLE
81625: LD_INT 1
81627: DEC
81628: ST_TO_ADDR
81629: LD_EXP 69
81633: PUSH
81634: FOR_TO
81635: IFFALSE 81740
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81637: LD_VAR 0 2
81641: PUSH
81642: LD_EXP 69
81646: PUSH
81647: LD_VAR 0 6
81651: ARRAY
81652: IN
81653: PUSH
81654: LD_VAR 0 1
81658: PUSH
81659: LD_EXP 69
81663: PUSH
81664: LD_VAR 0 6
81668: ARRAY
81669: IN
81670: OR
81671: IFFALSE 81738
// begin tmp := mc_vehicles [ i ] diff old ;
81673: LD_ADDR_VAR 0 7
81677: PUSH
81678: LD_EXP 69
81682: PUSH
81683: LD_VAR 0 6
81687: ARRAY
81688: PUSH
81689: LD_VAR 0 2
81693: DIFF
81694: ST_TO_ADDR
// tmp := tmp diff new ;
81695: LD_ADDR_VAR 0 7
81699: PUSH
81700: LD_VAR 0 7
81704: PUSH
81705: LD_VAR 0 1
81709: DIFF
81710: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81711: LD_ADDR_EXP 69
81715: PUSH
81716: LD_EXP 69
81720: PPUSH
81721: LD_VAR 0 6
81725: PPUSH
81726: LD_VAR 0 7
81730: PPUSH
81731: CALL_OW 1
81735: ST_TO_ADDR
// break ;
81736: GO 81740
// end ;
81738: GO 81634
81740: POP
81741: POP
// end ;
81742: LD_VAR 0 5
81746: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81747: LD_INT 0
81749: PPUSH
81750: PPUSH
81751: PPUSH
81752: PPUSH
// if not mc_bases or not skirmish then
81753: LD_EXP 50
81757: NOT
81758: PUSH
81759: LD_EXP 48
81763: NOT
81764: OR
81765: IFFALSE 81769
// exit ;
81767: GO 82189
// repeat wait ( 0 0$1 ) ;
81769: LD_INT 35
81771: PPUSH
81772: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
81776: LD_EXP 94
81780: NOT
81781: IFFALSE 81769
// mc_block_vehicle_constructed_thread := true ;
81783: LD_ADDR_EXP 94
81787: PUSH
81788: LD_INT 1
81790: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
81791: LD_ADDR_VAR 0 5
81795: PUSH
81796: LD_VAR 0 1
81800: PPUSH
81801: CALL_OW 255
81805: ST_TO_ADDR
// for i = 1 to mc_bases do
81806: LD_ADDR_VAR 0 4
81810: PUSH
81811: DOUBLE
81812: LD_INT 1
81814: DEC
81815: ST_TO_ADDR
81816: LD_EXP 50
81820: PUSH
81821: FOR_TO
81822: IFFALSE 82179
// begin if factory in mc_bases [ i ] then
81824: LD_VAR 0 2
81828: PUSH
81829: LD_EXP 50
81833: PUSH
81834: LD_VAR 0 4
81838: ARRAY
81839: IN
81840: IFFALSE 82177
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81842: LD_EXP 72
81846: PUSH
81847: LD_VAR 0 4
81851: ARRAY
81852: PUSH
81853: LD_EXP 61
81857: PUSH
81858: LD_VAR 0 4
81862: ARRAY
81863: LESS
81864: PUSH
81865: LD_VAR 0 1
81869: PPUSH
81870: CALL_OW 264
81874: PUSH
81875: LD_INT 31
81877: PUSH
81878: LD_INT 32
81880: PUSH
81881: LD_INT 51
81883: PUSH
81884: LD_INT 89
81886: PUSH
81887: LD_INT 12
81889: PUSH
81890: LD_INT 30
81892: PUSH
81893: LD_INT 98
81895: PUSH
81896: LD_INT 11
81898: PUSH
81899: LD_INT 53
81901: PUSH
81902: LD_INT 14
81904: PUSH
81905: LD_INT 91
81907: PUSH
81908: LD_INT 29
81910: PUSH
81911: LD_INT 99
81913: PUSH
81914: LD_INT 13
81916: PUSH
81917: LD_INT 52
81919: PUSH
81920: LD_INT 88
81922: PUSH
81923: LD_INT 48
81925: PUSH
81926: LD_INT 8
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: IN
81949: NOT
81950: AND
81951: IFFALSE 81999
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81953: LD_ADDR_EXP 72
81957: PUSH
81958: LD_EXP 72
81962: PPUSH
81963: LD_VAR 0 4
81967: PUSH
81968: LD_EXP 72
81972: PUSH
81973: LD_VAR 0 4
81977: ARRAY
81978: PUSH
81979: LD_INT 1
81981: PLUS
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PPUSH
81987: LD_VAR 0 1
81991: PPUSH
81992: CALL 18573 0 3
81996: ST_TO_ADDR
81997: GO 82043
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81999: LD_ADDR_EXP 69
82003: PUSH
82004: LD_EXP 69
82008: PPUSH
82009: LD_VAR 0 4
82013: PUSH
82014: LD_EXP 69
82018: PUSH
82019: LD_VAR 0 4
82023: ARRAY
82024: PUSH
82025: LD_INT 1
82027: PLUS
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PPUSH
82033: LD_VAR 0 1
82037: PPUSH
82038: CALL 18573 0 3
82042: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
82043: LD_ADDR_EXP 94
82047: PUSH
82048: LD_INT 0
82050: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82051: LD_VAR 0 1
82055: PPUSH
82056: CALL_OW 263
82060: PUSH
82061: LD_INT 2
82063: EQUAL
82064: IFFALSE 82093
// begin repeat wait ( 0 0$3 ) ;
82066: LD_INT 105
82068: PPUSH
82069: CALL_OW 67
// Connect ( vehicle ) ;
82073: LD_VAR 0 1
82077: PPUSH
82078: CALL 21551 0 1
// until IsControledBy ( vehicle ) ;
82082: LD_VAR 0 1
82086: PPUSH
82087: CALL_OW 312
82091: IFFALSE 82066
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82093: LD_VAR 0 1
82097: PPUSH
82098: LD_EXP 74
82102: PUSH
82103: LD_VAR 0 4
82107: ARRAY
82108: PPUSH
82109: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82113: LD_VAR 0 1
82117: PPUSH
82118: CALL_OW 263
82122: PUSH
82123: LD_INT 1
82125: NONEQUAL
82126: IFFALSE 82130
// break ;
82128: GO 82179
// repeat wait ( 0 0$1 ) ;
82130: LD_INT 35
82132: PPUSH
82133: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82137: LD_VAR 0 1
82141: PPUSH
82142: LD_EXP 74
82146: PUSH
82147: LD_VAR 0 4
82151: ARRAY
82152: PPUSH
82153: CALL_OW 308
82157: IFFALSE 82130
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82159: LD_VAR 0 1
82163: PPUSH
82164: CALL_OW 311
82168: PPUSH
82169: CALL_OW 121
// exit ;
82173: POP
82174: POP
82175: GO 82189
// end ; end ;
82177: GO 81821
82179: POP
82180: POP
// mc_block_vehicle_constructed_thread := false ;
82181: LD_ADDR_EXP 94
82185: PUSH
82186: LD_INT 0
82188: ST_TO_ADDR
// end ;
82189: LD_VAR 0 3
82193: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82194: LD_INT 0
82196: PPUSH
82197: PPUSH
82198: PPUSH
82199: PPUSH
// if not mc_bases or not skirmish then
82200: LD_EXP 50
82204: NOT
82205: PUSH
82206: LD_EXP 48
82210: NOT
82211: OR
82212: IFFALSE 82216
// exit ;
82214: GO 82569
// repeat wait ( 0 0$1 ) ;
82216: LD_INT 35
82218: PPUSH
82219: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82223: LD_VAR 0 2
82227: PPUSH
82228: LD_VAR 0 3
82232: PPUSH
82233: CALL_OW 284
82237: IFFALSE 82216
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82239: LD_VAR 0 2
82243: PPUSH
82244: LD_VAR 0 3
82248: PPUSH
82249: CALL_OW 283
82253: PUSH
82254: LD_INT 4
82256: EQUAL
82257: IFFALSE 82261
// exit ;
82259: GO 82569
// for i = 1 to mc_bases do
82261: LD_ADDR_VAR 0 7
82265: PUSH
82266: DOUBLE
82267: LD_INT 1
82269: DEC
82270: ST_TO_ADDR
82271: LD_EXP 50
82275: PUSH
82276: FOR_TO
82277: IFFALSE 82567
// begin if mc_crates_area [ i ] then
82279: LD_EXP 68
82283: PUSH
82284: LD_VAR 0 7
82288: ARRAY
82289: IFFALSE 82400
// for j in mc_crates_area [ i ] do
82291: LD_ADDR_VAR 0 8
82295: PUSH
82296: LD_EXP 68
82300: PUSH
82301: LD_VAR 0 7
82305: ARRAY
82306: PUSH
82307: FOR_IN
82308: IFFALSE 82398
// if InArea ( x , y , j ) then
82310: LD_VAR 0 2
82314: PPUSH
82315: LD_VAR 0 3
82319: PPUSH
82320: LD_VAR 0 8
82324: PPUSH
82325: CALL_OW 309
82329: IFFALSE 82396
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82331: LD_ADDR_EXP 66
82335: PUSH
82336: LD_EXP 66
82340: PPUSH
82341: LD_VAR 0 7
82345: PUSH
82346: LD_EXP 66
82350: PUSH
82351: LD_VAR 0 7
82355: ARRAY
82356: PUSH
82357: LD_INT 1
82359: PLUS
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PPUSH
82365: LD_VAR 0 4
82369: PUSH
82370: LD_VAR 0 2
82374: PUSH
82375: LD_VAR 0 3
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: LIST
82384: PPUSH
82385: CALL 18573 0 3
82389: ST_TO_ADDR
// exit ;
82390: POP
82391: POP
82392: POP
82393: POP
82394: GO 82569
// end ;
82396: GO 82307
82398: POP
82399: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82400: LD_ADDR_VAR 0 9
82404: PUSH
82405: LD_EXP 50
82409: PUSH
82410: LD_VAR 0 7
82414: ARRAY
82415: PPUSH
82416: LD_INT 2
82418: PUSH
82419: LD_INT 30
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 30
82431: PUSH
82432: LD_INT 1
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: LIST
82443: PPUSH
82444: CALL_OW 72
82448: ST_TO_ADDR
// if not depot then
82449: LD_VAR 0 9
82453: NOT
82454: IFFALSE 82458
// continue ;
82456: GO 82276
// for j in depot do
82458: LD_ADDR_VAR 0 8
82462: PUSH
82463: LD_VAR 0 9
82467: PUSH
82468: FOR_IN
82469: IFFALSE 82563
// if GetDistUnitXY ( j , x , y ) < 30 then
82471: LD_VAR 0 8
82475: PPUSH
82476: LD_VAR 0 2
82480: PPUSH
82481: LD_VAR 0 3
82485: PPUSH
82486: CALL_OW 297
82490: PUSH
82491: LD_INT 30
82493: LESS
82494: IFFALSE 82561
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82496: LD_ADDR_EXP 66
82500: PUSH
82501: LD_EXP 66
82505: PPUSH
82506: LD_VAR 0 7
82510: PUSH
82511: LD_EXP 66
82515: PUSH
82516: LD_VAR 0 7
82520: ARRAY
82521: PUSH
82522: LD_INT 1
82524: PLUS
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PPUSH
82530: LD_VAR 0 4
82534: PUSH
82535: LD_VAR 0 2
82539: PUSH
82540: LD_VAR 0 3
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: LIST
82549: PPUSH
82550: CALL 18573 0 3
82554: ST_TO_ADDR
// exit ;
82555: POP
82556: POP
82557: POP
82558: POP
82559: GO 82569
// end ;
82561: GO 82468
82563: POP
82564: POP
// end ;
82565: GO 82276
82567: POP
82568: POP
// end ;
82569: LD_VAR 0 6
82573: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82574: LD_INT 0
82576: PPUSH
82577: PPUSH
82578: PPUSH
82579: PPUSH
// if not mc_bases or not skirmish then
82580: LD_EXP 50
82584: NOT
82585: PUSH
82586: LD_EXP 48
82590: NOT
82591: OR
82592: IFFALSE 82596
// exit ;
82594: GO 82873
// side := GetSide ( lab ) ;
82596: LD_ADDR_VAR 0 4
82600: PUSH
82601: LD_VAR 0 2
82605: PPUSH
82606: CALL_OW 255
82610: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82611: LD_VAR 0 4
82615: PUSH
82616: LD_EXP 76
82620: IN
82621: NOT
82622: PUSH
82623: LD_EXP 77
82627: NOT
82628: OR
82629: PUSH
82630: LD_EXP 50
82634: NOT
82635: OR
82636: IFFALSE 82640
// exit ;
82638: GO 82873
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82640: LD_ADDR_EXP 77
82644: PUSH
82645: LD_EXP 77
82649: PPUSH
82650: LD_VAR 0 4
82654: PPUSH
82655: LD_EXP 77
82659: PUSH
82660: LD_VAR 0 4
82664: ARRAY
82665: PUSH
82666: LD_VAR 0 1
82670: DIFF
82671: PPUSH
82672: CALL_OW 1
82676: ST_TO_ADDR
// for i = 1 to mc_bases do
82677: LD_ADDR_VAR 0 5
82681: PUSH
82682: DOUBLE
82683: LD_INT 1
82685: DEC
82686: ST_TO_ADDR
82687: LD_EXP 50
82691: PUSH
82692: FOR_TO
82693: IFFALSE 82871
// begin if lab in mc_bases [ i ] then
82695: LD_VAR 0 2
82699: PUSH
82700: LD_EXP 50
82704: PUSH
82705: LD_VAR 0 5
82709: ARRAY
82710: IN
82711: IFFALSE 82869
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82713: LD_VAR 0 1
82717: PUSH
82718: LD_INT 11
82720: PUSH
82721: LD_INT 4
82723: PUSH
82724: LD_INT 3
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: IN
82736: PUSH
82737: LD_EXP 80
82741: PUSH
82742: LD_VAR 0 5
82746: ARRAY
82747: AND
82748: IFFALSE 82869
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82750: LD_ADDR_VAR 0 6
82754: PUSH
82755: LD_EXP 80
82759: PUSH
82760: LD_VAR 0 5
82764: ARRAY
82765: PUSH
82766: LD_INT 1
82768: ARRAY
82769: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82770: LD_ADDR_EXP 80
82774: PUSH
82775: LD_EXP 80
82779: PPUSH
82780: LD_VAR 0 5
82784: PPUSH
82785: EMPTY
82786: PPUSH
82787: CALL_OW 1
82791: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82792: LD_VAR 0 6
82796: PPUSH
82797: LD_INT 0
82799: PPUSH
82800: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82804: LD_VAR 0 6
82808: PPUSH
82809: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82813: LD_ADDR_EXP 79
82817: PUSH
82818: LD_EXP 79
82822: PPUSH
82823: LD_VAR 0 5
82827: PPUSH
82828: LD_EXP 79
82832: PUSH
82833: LD_VAR 0 5
82837: ARRAY
82838: PPUSH
82839: LD_INT 1
82841: PPUSH
82842: LD_VAR 0 6
82846: PPUSH
82847: CALL_OW 2
82851: PPUSH
82852: CALL_OW 1
82856: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82857: LD_VAR 0 5
82861: PPUSH
82862: LD_INT 112
82864: PPUSH
82865: CALL 59323 0 2
// end ; end ; end ;
82869: GO 82692
82871: POP
82872: POP
// end ;
82873: LD_VAR 0 3
82877: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82878: LD_INT 0
82880: PPUSH
82881: PPUSH
82882: PPUSH
82883: PPUSH
82884: PPUSH
82885: PPUSH
82886: PPUSH
82887: PPUSH
// if not mc_bases or not skirmish then
82888: LD_EXP 50
82892: NOT
82893: PUSH
82894: LD_EXP 48
82898: NOT
82899: OR
82900: IFFALSE 82904
// exit ;
82902: GO 84273
// for i = 1 to mc_bases do
82904: LD_ADDR_VAR 0 3
82908: PUSH
82909: DOUBLE
82910: LD_INT 1
82912: DEC
82913: ST_TO_ADDR
82914: LD_EXP 50
82918: PUSH
82919: FOR_TO
82920: IFFALSE 84271
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82922: LD_VAR 0 1
82926: PUSH
82927: LD_EXP 50
82931: PUSH
82932: LD_VAR 0 3
82936: ARRAY
82937: IN
82938: PUSH
82939: LD_VAR 0 1
82943: PUSH
82944: LD_EXP 57
82948: PUSH
82949: LD_VAR 0 3
82953: ARRAY
82954: IN
82955: OR
82956: PUSH
82957: LD_VAR 0 1
82961: PUSH
82962: LD_EXP 72
82966: PUSH
82967: LD_VAR 0 3
82971: ARRAY
82972: IN
82973: OR
82974: PUSH
82975: LD_VAR 0 1
82979: PUSH
82980: LD_EXP 69
82984: PUSH
82985: LD_VAR 0 3
82989: ARRAY
82990: IN
82991: OR
82992: PUSH
82993: LD_VAR 0 1
82997: PUSH
82998: LD_EXP 79
83002: PUSH
83003: LD_VAR 0 3
83007: ARRAY
83008: IN
83009: OR
83010: PUSH
83011: LD_VAR 0 1
83015: PUSH
83016: LD_EXP 80
83020: PUSH
83021: LD_VAR 0 3
83025: ARRAY
83026: IN
83027: OR
83028: IFFALSE 84269
// begin if un in mc_ape [ i ] then
83030: LD_VAR 0 1
83034: PUSH
83035: LD_EXP 79
83039: PUSH
83040: LD_VAR 0 3
83044: ARRAY
83045: IN
83046: IFFALSE 83085
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83048: LD_ADDR_EXP 79
83052: PUSH
83053: LD_EXP 79
83057: PPUSH
83058: LD_VAR 0 3
83062: PPUSH
83063: LD_EXP 79
83067: PUSH
83068: LD_VAR 0 3
83072: ARRAY
83073: PUSH
83074: LD_VAR 0 1
83078: DIFF
83079: PPUSH
83080: CALL_OW 1
83084: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83085: LD_VAR 0 1
83089: PUSH
83090: LD_EXP 80
83094: PUSH
83095: LD_VAR 0 3
83099: ARRAY
83100: IN
83101: IFFALSE 83125
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83103: LD_ADDR_EXP 80
83107: PUSH
83108: LD_EXP 80
83112: PPUSH
83113: LD_VAR 0 3
83117: PPUSH
83118: EMPTY
83119: PPUSH
83120: CALL_OW 1
83124: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
83125: LD_VAR 0 1
83129: PPUSH
83130: CALL_OW 247
83134: PUSH
83135: LD_INT 2
83137: EQUAL
83138: PUSH
83139: LD_VAR 0 1
83143: PPUSH
83144: CALL_OW 110
83148: PUSH
83149: LD_INT 20
83151: EQUAL
83152: PUSH
83153: LD_VAR 0 1
83157: PUSH
83158: LD_EXP 72
83162: PUSH
83163: LD_VAR 0 3
83167: ARRAY
83168: IN
83169: OR
83170: PUSH
83171: LD_VAR 0 1
83175: PPUSH
83176: CALL_OW 264
83180: PUSH
83181: LD_INT 12
83183: PUSH
83184: LD_INT 51
83186: PUSH
83187: LD_INT 89
83189: PUSH
83190: LD_INT 32
83192: PUSH
83193: LD_INT 13
83195: PUSH
83196: LD_INT 52
83198: PUSH
83199: LD_INT 31
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: LIST
83209: LIST
83210: IN
83211: OR
83212: AND
83213: IFFALSE 83521
// begin if un in mc_defender [ i ] then
83215: LD_VAR 0 1
83219: PUSH
83220: LD_EXP 72
83224: PUSH
83225: LD_VAR 0 3
83229: ARRAY
83230: IN
83231: IFFALSE 83270
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83233: LD_ADDR_EXP 72
83237: PUSH
83238: LD_EXP 72
83242: PPUSH
83243: LD_VAR 0 3
83247: PPUSH
83248: LD_EXP 72
83252: PUSH
83253: LD_VAR 0 3
83257: ARRAY
83258: PUSH
83259: LD_VAR 0 1
83263: DIFF
83264: PPUSH
83265: CALL_OW 1
83269: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83270: LD_ADDR_VAR 0 8
83274: PUSH
83275: LD_VAR 0 3
83279: PPUSH
83280: LD_INT 3
83282: PPUSH
83283: CALL 79891 0 2
83287: ST_TO_ADDR
// if fac then
83288: LD_VAR 0 8
83292: IFFALSE 83521
// begin for j in fac do
83294: LD_ADDR_VAR 0 4
83298: PUSH
83299: LD_VAR 0 8
83303: PUSH
83304: FOR_IN
83305: IFFALSE 83519
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83307: LD_ADDR_VAR 0 9
83311: PUSH
83312: LD_VAR 0 8
83316: PPUSH
83317: LD_VAR 0 1
83321: PPUSH
83322: CALL_OW 265
83326: PPUSH
83327: LD_VAR 0 1
83331: PPUSH
83332: CALL_OW 262
83336: PPUSH
83337: LD_VAR 0 1
83341: PPUSH
83342: CALL_OW 263
83346: PPUSH
83347: LD_VAR 0 1
83351: PPUSH
83352: CALL_OW 264
83356: PPUSH
83357: CALL 16071 0 5
83361: ST_TO_ADDR
// if components then
83362: LD_VAR 0 9
83366: IFFALSE 83517
// begin if GetWeapon ( un ) = ar_control_tower then
83368: LD_VAR 0 1
83372: PPUSH
83373: CALL_OW 264
83377: PUSH
83378: LD_INT 31
83380: EQUAL
83381: IFFALSE 83498
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83383: LD_VAR 0 1
83387: PPUSH
83388: CALL_OW 311
83392: PPUSH
83393: LD_INT 0
83395: PPUSH
83396: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83400: LD_ADDR_EXP 90
83404: PUSH
83405: LD_EXP 90
83409: PPUSH
83410: LD_VAR 0 3
83414: PPUSH
83415: LD_EXP 90
83419: PUSH
83420: LD_VAR 0 3
83424: ARRAY
83425: PUSH
83426: LD_VAR 0 1
83430: PPUSH
83431: CALL_OW 311
83435: DIFF
83436: PPUSH
83437: CALL_OW 1
83441: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83442: LD_ADDR_VAR 0 7
83446: PUSH
83447: LD_EXP 71
83451: PUSH
83452: LD_VAR 0 3
83456: ARRAY
83457: PPUSH
83458: LD_INT 1
83460: PPUSH
83461: LD_VAR 0 9
83465: PPUSH
83466: CALL_OW 2
83470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83471: LD_ADDR_EXP 71
83475: PUSH
83476: LD_EXP 71
83480: PPUSH
83481: LD_VAR 0 3
83485: PPUSH
83486: LD_VAR 0 7
83490: PPUSH
83491: CALL_OW 1
83495: ST_TO_ADDR
// end else
83496: GO 83515
// MC_InsertProduceList ( i , [ components ] ) ;
83498: LD_VAR 0 3
83502: PPUSH
83503: LD_VAR 0 9
83507: PUSH
83508: EMPTY
83509: LIST
83510: PPUSH
83511: CALL 79436 0 2
// break ;
83515: GO 83519
// end ; end ;
83517: GO 83304
83519: POP
83520: POP
// end ; end ; if GetType ( un ) = unit_building then
83521: LD_VAR 0 1
83525: PPUSH
83526: CALL_OW 247
83530: PUSH
83531: LD_INT 3
83533: EQUAL
83534: IFFALSE 83937
// begin btype := GetBType ( un ) ;
83536: LD_ADDR_VAR 0 5
83540: PUSH
83541: LD_VAR 0 1
83545: PPUSH
83546: CALL_OW 266
83550: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83551: LD_VAR 0 5
83555: PUSH
83556: LD_INT 29
83558: PUSH
83559: LD_INT 30
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: IN
83566: IFFALSE 83639
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83568: LD_VAR 0 1
83572: PPUSH
83573: CALL_OW 250
83577: PPUSH
83578: LD_VAR 0 1
83582: PPUSH
83583: CALL_OW 251
83587: PPUSH
83588: LD_VAR 0 1
83592: PPUSH
83593: CALL_OW 255
83597: PPUSH
83598: CALL_OW 440
83602: NOT
83603: IFFALSE 83639
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83605: LD_VAR 0 1
83609: PPUSH
83610: CALL_OW 250
83614: PPUSH
83615: LD_VAR 0 1
83619: PPUSH
83620: CALL_OW 251
83624: PPUSH
83625: LD_VAR 0 1
83629: PPUSH
83630: CALL_OW 255
83634: PPUSH
83635: CALL_OW 441
// end ; if btype = b_warehouse then
83639: LD_VAR 0 5
83643: PUSH
83644: LD_INT 1
83646: EQUAL
83647: IFFALSE 83665
// begin btype := b_depot ;
83649: LD_ADDR_VAR 0 5
83653: PUSH
83654: LD_INT 0
83656: ST_TO_ADDR
// pos := 1 ;
83657: LD_ADDR_VAR 0 6
83661: PUSH
83662: LD_INT 1
83664: ST_TO_ADDR
// end ; if btype = b_factory then
83665: LD_VAR 0 5
83669: PUSH
83670: LD_INT 3
83672: EQUAL
83673: IFFALSE 83691
// begin btype := b_workshop ;
83675: LD_ADDR_VAR 0 5
83679: PUSH
83680: LD_INT 2
83682: ST_TO_ADDR
// pos := 1 ;
83683: LD_ADDR_VAR 0 6
83687: PUSH
83688: LD_INT 1
83690: ST_TO_ADDR
// end ; if btype = b_barracks then
83691: LD_VAR 0 5
83695: PUSH
83696: LD_INT 5
83698: EQUAL
83699: IFFALSE 83709
// btype := b_armoury ;
83701: LD_ADDR_VAR 0 5
83705: PUSH
83706: LD_INT 4
83708: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83709: LD_VAR 0 5
83713: PUSH
83714: LD_INT 7
83716: PUSH
83717: LD_INT 8
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: IN
83724: IFFALSE 83734
// btype := b_lab ;
83726: LD_ADDR_VAR 0 5
83730: PUSH
83731: LD_INT 6
83733: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83734: LD_ADDR_EXP 55
83738: PUSH
83739: LD_EXP 55
83743: PPUSH
83744: LD_VAR 0 3
83748: PUSH
83749: LD_EXP 55
83753: PUSH
83754: LD_VAR 0 3
83758: ARRAY
83759: PUSH
83760: LD_INT 1
83762: PLUS
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PPUSH
83768: LD_VAR 0 5
83772: PUSH
83773: LD_VAR 0 1
83777: PPUSH
83778: CALL_OW 250
83782: PUSH
83783: LD_VAR 0 1
83787: PPUSH
83788: CALL_OW 251
83792: PUSH
83793: LD_VAR 0 1
83797: PPUSH
83798: CALL_OW 254
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: PPUSH
83809: CALL 18573 0 3
83813: ST_TO_ADDR
// if pos = 1 then
83814: LD_VAR 0 6
83818: PUSH
83819: LD_INT 1
83821: EQUAL
83822: IFFALSE 83937
// begin tmp := mc_build_list [ i ] ;
83824: LD_ADDR_VAR 0 7
83828: PUSH
83829: LD_EXP 55
83833: PUSH
83834: LD_VAR 0 3
83838: ARRAY
83839: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83840: LD_VAR 0 7
83844: PPUSH
83845: LD_INT 2
83847: PUSH
83848: LD_INT 30
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 30
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: LIST
83872: PPUSH
83873: CALL_OW 72
83877: IFFALSE 83887
// pos := 2 ;
83879: LD_ADDR_VAR 0 6
83883: PUSH
83884: LD_INT 2
83886: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83887: LD_ADDR_VAR 0 7
83891: PUSH
83892: LD_VAR 0 7
83896: PPUSH
83897: LD_VAR 0 6
83901: PPUSH
83902: LD_VAR 0 7
83906: PPUSH
83907: CALL 18899 0 3
83911: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83912: LD_ADDR_EXP 55
83916: PUSH
83917: LD_EXP 55
83921: PPUSH
83922: LD_VAR 0 3
83926: PPUSH
83927: LD_VAR 0 7
83931: PPUSH
83932: CALL_OW 1
83936: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83937: LD_VAR 0 1
83941: PUSH
83942: LD_EXP 50
83946: PUSH
83947: LD_VAR 0 3
83951: ARRAY
83952: IN
83953: IFFALSE 83992
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83955: LD_ADDR_EXP 50
83959: PUSH
83960: LD_EXP 50
83964: PPUSH
83965: LD_VAR 0 3
83969: PPUSH
83970: LD_EXP 50
83974: PUSH
83975: LD_VAR 0 3
83979: ARRAY
83980: PUSH
83981: LD_VAR 0 1
83985: DIFF
83986: PPUSH
83987: CALL_OW 1
83991: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83992: LD_VAR 0 1
83996: PUSH
83997: LD_EXP 57
84001: PUSH
84002: LD_VAR 0 3
84006: ARRAY
84007: IN
84008: IFFALSE 84047
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84010: LD_ADDR_EXP 57
84014: PUSH
84015: LD_EXP 57
84019: PPUSH
84020: LD_VAR 0 3
84024: PPUSH
84025: LD_EXP 57
84029: PUSH
84030: LD_VAR 0 3
84034: ARRAY
84035: PUSH
84036: LD_VAR 0 1
84040: DIFF
84041: PPUSH
84042: CALL_OW 1
84046: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84047: LD_VAR 0 1
84051: PUSH
84052: LD_EXP 69
84056: PUSH
84057: LD_VAR 0 3
84061: ARRAY
84062: IN
84063: IFFALSE 84102
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84065: LD_ADDR_EXP 69
84069: PUSH
84070: LD_EXP 69
84074: PPUSH
84075: LD_VAR 0 3
84079: PPUSH
84080: LD_EXP 69
84084: PUSH
84085: LD_VAR 0 3
84089: ARRAY
84090: PUSH
84091: LD_VAR 0 1
84095: DIFF
84096: PPUSH
84097: CALL_OW 1
84101: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84102: LD_VAR 0 1
84106: PUSH
84107: LD_EXP 72
84111: PUSH
84112: LD_VAR 0 3
84116: ARRAY
84117: IN
84118: IFFALSE 84157
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84120: LD_ADDR_EXP 72
84124: PUSH
84125: LD_EXP 72
84129: PPUSH
84130: LD_VAR 0 3
84134: PPUSH
84135: LD_EXP 72
84139: PUSH
84140: LD_VAR 0 3
84144: ARRAY
84145: PUSH
84146: LD_VAR 0 1
84150: DIFF
84151: PPUSH
84152: CALL_OW 1
84156: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84157: LD_VAR 0 1
84161: PUSH
84162: LD_EXP 59
84166: PUSH
84167: LD_VAR 0 3
84171: ARRAY
84172: IN
84173: IFFALSE 84212
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84175: LD_ADDR_EXP 59
84179: PUSH
84180: LD_EXP 59
84184: PPUSH
84185: LD_VAR 0 3
84189: PPUSH
84190: LD_EXP 59
84194: PUSH
84195: LD_VAR 0 3
84199: ARRAY
84200: PUSH
84201: LD_VAR 0 1
84205: DIFF
84206: PPUSH
84207: CALL_OW 1
84211: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84212: LD_VAR 0 1
84216: PUSH
84217: LD_EXP 58
84221: PUSH
84222: LD_VAR 0 3
84226: ARRAY
84227: IN
84228: IFFALSE 84267
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84230: LD_ADDR_EXP 58
84234: PUSH
84235: LD_EXP 58
84239: PPUSH
84240: LD_VAR 0 3
84244: PPUSH
84245: LD_EXP 58
84249: PUSH
84250: LD_VAR 0 3
84254: ARRAY
84255: PUSH
84256: LD_VAR 0 1
84260: DIFF
84261: PPUSH
84262: CALL_OW 1
84266: ST_TO_ADDR
// end ; break ;
84267: GO 84271
// end ;
84269: GO 82919
84271: POP
84272: POP
// end ;
84273: LD_VAR 0 2
84277: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84278: LD_INT 0
84280: PPUSH
84281: PPUSH
84282: PPUSH
// if not mc_bases or not skirmish then
84283: LD_EXP 50
84287: NOT
84288: PUSH
84289: LD_EXP 48
84293: NOT
84294: OR
84295: IFFALSE 84299
// exit ;
84297: GO 84514
// for i = 1 to mc_bases do
84299: LD_ADDR_VAR 0 3
84303: PUSH
84304: DOUBLE
84305: LD_INT 1
84307: DEC
84308: ST_TO_ADDR
84309: LD_EXP 50
84313: PUSH
84314: FOR_TO
84315: IFFALSE 84512
// begin if building in mc_construct_list [ i ] then
84317: LD_VAR 0 1
84321: PUSH
84322: LD_EXP 57
84326: PUSH
84327: LD_VAR 0 3
84331: ARRAY
84332: IN
84333: IFFALSE 84510
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84335: LD_ADDR_EXP 57
84339: PUSH
84340: LD_EXP 57
84344: PPUSH
84345: LD_VAR 0 3
84349: PPUSH
84350: LD_EXP 57
84354: PUSH
84355: LD_VAR 0 3
84359: ARRAY
84360: PUSH
84361: LD_VAR 0 1
84365: DIFF
84366: PPUSH
84367: CALL_OW 1
84371: ST_TO_ADDR
// if building in mc_lab [ i ] then
84372: LD_VAR 0 1
84376: PUSH
84377: LD_EXP 83
84381: PUSH
84382: LD_VAR 0 3
84386: ARRAY
84387: IN
84388: IFFALSE 84443
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84390: LD_ADDR_EXP 84
84394: PUSH
84395: LD_EXP 84
84399: PPUSH
84400: LD_VAR 0 3
84404: PPUSH
84405: LD_EXP 84
84409: PUSH
84410: LD_VAR 0 3
84414: ARRAY
84415: PPUSH
84416: LD_INT 1
84418: PPUSH
84419: LD_EXP 84
84423: PUSH
84424: LD_VAR 0 3
84428: ARRAY
84429: PPUSH
84430: LD_INT 0
84432: PPUSH
84433: CALL 17991 0 4
84437: PPUSH
84438: CALL_OW 1
84442: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84443: LD_VAR 0 1
84447: PUSH
84448: LD_EXP 50
84452: PUSH
84453: LD_VAR 0 3
84457: ARRAY
84458: IN
84459: NOT
84460: IFFALSE 84506
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84462: LD_ADDR_EXP 50
84466: PUSH
84467: LD_EXP 50
84471: PPUSH
84472: LD_VAR 0 3
84476: PUSH
84477: LD_EXP 50
84481: PUSH
84482: LD_VAR 0 3
84486: ARRAY
84487: PUSH
84488: LD_INT 1
84490: PLUS
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PPUSH
84496: LD_VAR 0 1
84500: PPUSH
84501: CALL 18573 0 3
84505: ST_TO_ADDR
// exit ;
84506: POP
84507: POP
84508: GO 84514
// end ; end ;
84510: GO 84314
84512: POP
84513: POP
// end ;
84514: LD_VAR 0 2
84518: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84519: LD_INT 0
84521: PPUSH
84522: PPUSH
84523: PPUSH
84524: PPUSH
84525: PPUSH
84526: PPUSH
84527: PPUSH
// if not mc_bases or not skirmish then
84528: LD_EXP 50
84532: NOT
84533: PUSH
84534: LD_EXP 48
84538: NOT
84539: OR
84540: IFFALSE 84544
// exit ;
84542: GO 85205
// for i = 1 to mc_bases do
84544: LD_ADDR_VAR 0 3
84548: PUSH
84549: DOUBLE
84550: LD_INT 1
84552: DEC
84553: ST_TO_ADDR
84554: LD_EXP 50
84558: PUSH
84559: FOR_TO
84560: IFFALSE 85203
// begin if building in mc_construct_list [ i ] then
84562: LD_VAR 0 1
84566: PUSH
84567: LD_EXP 57
84571: PUSH
84572: LD_VAR 0 3
84576: ARRAY
84577: IN
84578: IFFALSE 85201
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84580: LD_ADDR_EXP 57
84584: PUSH
84585: LD_EXP 57
84589: PPUSH
84590: LD_VAR 0 3
84594: PPUSH
84595: LD_EXP 57
84599: PUSH
84600: LD_VAR 0 3
84604: ARRAY
84605: PUSH
84606: LD_VAR 0 1
84610: DIFF
84611: PPUSH
84612: CALL_OW 1
84616: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84617: LD_ADDR_EXP 50
84621: PUSH
84622: LD_EXP 50
84626: PPUSH
84627: LD_VAR 0 3
84631: PUSH
84632: LD_EXP 50
84636: PUSH
84637: LD_VAR 0 3
84641: ARRAY
84642: PUSH
84643: LD_INT 1
84645: PLUS
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PPUSH
84651: LD_VAR 0 1
84655: PPUSH
84656: CALL 18573 0 3
84660: ST_TO_ADDR
// btype := GetBType ( building ) ;
84661: LD_ADDR_VAR 0 5
84665: PUSH
84666: LD_VAR 0 1
84670: PPUSH
84671: CALL_OW 266
84675: ST_TO_ADDR
// side := GetSide ( building ) ;
84676: LD_ADDR_VAR 0 8
84680: PUSH
84681: LD_VAR 0 1
84685: PPUSH
84686: CALL_OW 255
84690: ST_TO_ADDR
// if btype = b_lab then
84691: LD_VAR 0 5
84695: PUSH
84696: LD_INT 6
84698: EQUAL
84699: IFFALSE 84749
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84701: LD_ADDR_EXP 83
84705: PUSH
84706: LD_EXP 83
84710: PPUSH
84711: LD_VAR 0 3
84715: PUSH
84716: LD_EXP 83
84720: PUSH
84721: LD_VAR 0 3
84725: ARRAY
84726: PUSH
84727: LD_INT 1
84729: PLUS
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PPUSH
84735: LD_VAR 0 1
84739: PPUSH
84740: CALL 18573 0 3
84744: ST_TO_ADDR
// exit ;
84745: POP
84746: POP
84747: GO 85205
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84749: LD_VAR 0 5
84753: PUSH
84754: LD_INT 0
84756: PUSH
84757: LD_INT 2
84759: PUSH
84760: LD_INT 4
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: LIST
84767: IN
84768: IFFALSE 84892
// begin if btype = b_armoury then
84770: LD_VAR 0 5
84774: PUSH
84775: LD_INT 4
84777: EQUAL
84778: IFFALSE 84788
// btype := b_barracks ;
84780: LD_ADDR_VAR 0 5
84784: PUSH
84785: LD_INT 5
84787: ST_TO_ADDR
// if btype = b_depot then
84788: LD_VAR 0 5
84792: PUSH
84793: LD_INT 0
84795: EQUAL
84796: IFFALSE 84806
// btype := b_warehouse ;
84798: LD_ADDR_VAR 0 5
84802: PUSH
84803: LD_INT 1
84805: ST_TO_ADDR
// if btype = b_workshop then
84806: LD_VAR 0 5
84810: PUSH
84811: LD_INT 2
84813: EQUAL
84814: IFFALSE 84824
// btype := b_factory ;
84816: LD_ADDR_VAR 0 5
84820: PUSH
84821: LD_INT 3
84823: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84824: LD_VAR 0 5
84828: PPUSH
84829: LD_VAR 0 8
84833: PPUSH
84834: CALL_OW 323
84838: PUSH
84839: LD_INT 1
84841: EQUAL
84842: IFFALSE 84888
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84844: LD_ADDR_EXP 82
84848: PUSH
84849: LD_EXP 82
84853: PPUSH
84854: LD_VAR 0 3
84858: PUSH
84859: LD_EXP 82
84863: PUSH
84864: LD_VAR 0 3
84868: ARRAY
84869: PUSH
84870: LD_INT 1
84872: PLUS
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PPUSH
84878: LD_VAR 0 1
84882: PPUSH
84883: CALL 18573 0 3
84887: ST_TO_ADDR
// exit ;
84888: POP
84889: POP
84890: GO 85205
// end ; if btype in [ b_bunker , b_turret ] then
84892: LD_VAR 0 5
84896: PUSH
84897: LD_INT 32
84899: PUSH
84900: LD_INT 33
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: IN
84907: IFFALSE 85197
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84909: LD_ADDR_EXP 58
84913: PUSH
84914: LD_EXP 58
84918: PPUSH
84919: LD_VAR 0 3
84923: PUSH
84924: LD_EXP 58
84928: PUSH
84929: LD_VAR 0 3
84933: ARRAY
84934: PUSH
84935: LD_INT 1
84937: PLUS
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PPUSH
84943: LD_VAR 0 1
84947: PPUSH
84948: CALL 18573 0 3
84952: ST_TO_ADDR
// if btype = b_bunker then
84953: LD_VAR 0 5
84957: PUSH
84958: LD_INT 32
84960: EQUAL
84961: IFFALSE 85197
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84963: LD_ADDR_EXP 59
84967: PUSH
84968: LD_EXP 59
84972: PPUSH
84973: LD_VAR 0 3
84977: PUSH
84978: LD_EXP 59
84982: PUSH
84983: LD_VAR 0 3
84987: ARRAY
84988: PUSH
84989: LD_INT 1
84991: PLUS
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PPUSH
84997: LD_VAR 0 1
85001: PPUSH
85002: CALL 18573 0 3
85006: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85007: LD_ADDR_VAR 0 6
85011: PUSH
85012: LD_EXP 50
85016: PUSH
85017: LD_VAR 0 3
85021: ARRAY
85022: PPUSH
85023: LD_INT 25
85025: PUSH
85026: LD_INT 1
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 3
85035: PUSH
85036: LD_INT 54
85038: PUSH
85039: EMPTY
85040: LIST
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PPUSH
85050: CALL_OW 72
85054: ST_TO_ADDR
// if tmp then
85055: LD_VAR 0 6
85059: IFFALSE 85065
// exit ;
85061: POP
85062: POP
85063: GO 85205
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85065: LD_ADDR_VAR 0 6
85069: PUSH
85070: LD_EXP 50
85074: PUSH
85075: LD_VAR 0 3
85079: ARRAY
85080: PPUSH
85081: LD_INT 2
85083: PUSH
85084: LD_INT 30
85086: PUSH
85087: LD_INT 4
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 30
85096: PUSH
85097: LD_INT 5
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: LIST
85108: PPUSH
85109: CALL_OW 72
85113: ST_TO_ADDR
// if not tmp then
85114: LD_VAR 0 6
85118: NOT
85119: IFFALSE 85125
// exit ;
85121: POP
85122: POP
85123: GO 85205
// for j in tmp do
85125: LD_ADDR_VAR 0 4
85129: PUSH
85130: LD_VAR 0 6
85134: PUSH
85135: FOR_IN
85136: IFFALSE 85195
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85138: LD_ADDR_VAR 0 7
85142: PUSH
85143: LD_VAR 0 4
85147: PPUSH
85148: CALL_OW 313
85152: PPUSH
85153: LD_INT 25
85155: PUSH
85156: LD_INT 1
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PPUSH
85163: CALL_OW 72
85167: ST_TO_ADDR
// if units then
85168: LD_VAR 0 7
85172: IFFALSE 85193
// begin ComExitBuilding ( units [ 1 ] ) ;
85174: LD_VAR 0 7
85178: PUSH
85179: LD_INT 1
85181: ARRAY
85182: PPUSH
85183: CALL_OW 122
// exit ;
85187: POP
85188: POP
85189: POP
85190: POP
85191: GO 85205
// end ; end ;
85193: GO 85135
85195: POP
85196: POP
// end ; end ; exit ;
85197: POP
85198: POP
85199: GO 85205
// end ; end ;
85201: GO 84559
85203: POP
85204: POP
// end ;
85205: LD_VAR 0 2
85209: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85210: LD_INT 0
85212: PPUSH
85213: PPUSH
85214: PPUSH
85215: PPUSH
85216: PPUSH
85217: PPUSH
85218: PPUSH
// if not mc_bases or not skirmish then
85219: LD_EXP 50
85223: NOT
85224: PUSH
85225: LD_EXP 48
85229: NOT
85230: OR
85231: IFFALSE 85235
// exit ;
85233: GO 85500
// btype := GetBType ( building ) ;
85235: LD_ADDR_VAR 0 6
85239: PUSH
85240: LD_VAR 0 1
85244: PPUSH
85245: CALL_OW 266
85249: ST_TO_ADDR
// x := GetX ( building ) ;
85250: LD_ADDR_VAR 0 7
85254: PUSH
85255: LD_VAR 0 1
85259: PPUSH
85260: CALL_OW 250
85264: ST_TO_ADDR
// y := GetY ( building ) ;
85265: LD_ADDR_VAR 0 8
85269: PUSH
85270: LD_VAR 0 1
85274: PPUSH
85275: CALL_OW 251
85279: ST_TO_ADDR
// d := GetDir ( building ) ;
85280: LD_ADDR_VAR 0 9
85284: PUSH
85285: LD_VAR 0 1
85289: PPUSH
85290: CALL_OW 254
85294: ST_TO_ADDR
// for i = 1 to mc_bases do
85295: LD_ADDR_VAR 0 4
85299: PUSH
85300: DOUBLE
85301: LD_INT 1
85303: DEC
85304: ST_TO_ADDR
85305: LD_EXP 50
85309: PUSH
85310: FOR_TO
85311: IFFALSE 85498
// begin if not mc_build_list [ i ] then
85313: LD_EXP 55
85317: PUSH
85318: LD_VAR 0 4
85322: ARRAY
85323: NOT
85324: IFFALSE 85328
// continue ;
85326: GO 85310
// for j := 1 to mc_build_list [ i ] do
85328: LD_ADDR_VAR 0 5
85332: PUSH
85333: DOUBLE
85334: LD_INT 1
85336: DEC
85337: ST_TO_ADDR
85338: LD_EXP 55
85342: PUSH
85343: LD_VAR 0 4
85347: ARRAY
85348: PUSH
85349: FOR_TO
85350: IFFALSE 85494
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85352: LD_VAR 0 6
85356: PUSH
85357: LD_VAR 0 7
85361: PUSH
85362: LD_VAR 0 8
85366: PUSH
85367: LD_VAR 0 9
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: PPUSH
85378: LD_EXP 55
85382: PUSH
85383: LD_VAR 0 4
85387: ARRAY
85388: PUSH
85389: LD_VAR 0 5
85393: ARRAY
85394: PPUSH
85395: CALL 24762 0 2
85399: IFFALSE 85492
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85401: LD_ADDR_EXP 55
85405: PUSH
85406: LD_EXP 55
85410: PPUSH
85411: LD_VAR 0 4
85415: PPUSH
85416: LD_EXP 55
85420: PUSH
85421: LD_VAR 0 4
85425: ARRAY
85426: PPUSH
85427: LD_VAR 0 5
85431: PPUSH
85432: CALL_OW 3
85436: PPUSH
85437: CALL_OW 1
85441: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85442: LD_ADDR_EXP 57
85446: PUSH
85447: LD_EXP 57
85451: PPUSH
85452: LD_VAR 0 4
85456: PUSH
85457: LD_EXP 57
85461: PUSH
85462: LD_VAR 0 4
85466: ARRAY
85467: PUSH
85468: LD_INT 1
85470: PLUS
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PPUSH
85476: LD_VAR 0 1
85480: PPUSH
85481: CALL 18573 0 3
85485: ST_TO_ADDR
// exit ;
85486: POP
85487: POP
85488: POP
85489: POP
85490: GO 85500
// end ;
85492: GO 85349
85494: POP
85495: POP
// end ;
85496: GO 85310
85498: POP
85499: POP
// end ;
85500: LD_VAR 0 3
85504: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85505: LD_INT 0
85507: PPUSH
85508: PPUSH
85509: PPUSH
// if not mc_bases or not skirmish then
85510: LD_EXP 50
85514: NOT
85515: PUSH
85516: LD_EXP 48
85520: NOT
85521: OR
85522: IFFALSE 85526
// exit ;
85524: GO 85716
// for i = 1 to mc_bases do
85526: LD_ADDR_VAR 0 4
85530: PUSH
85531: DOUBLE
85532: LD_INT 1
85534: DEC
85535: ST_TO_ADDR
85536: LD_EXP 50
85540: PUSH
85541: FOR_TO
85542: IFFALSE 85629
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85544: LD_VAR 0 1
85548: PUSH
85549: LD_EXP 58
85553: PUSH
85554: LD_VAR 0 4
85558: ARRAY
85559: IN
85560: PUSH
85561: LD_VAR 0 1
85565: PUSH
85566: LD_EXP 59
85570: PUSH
85571: LD_VAR 0 4
85575: ARRAY
85576: IN
85577: NOT
85578: AND
85579: IFFALSE 85627
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85581: LD_ADDR_EXP 59
85585: PUSH
85586: LD_EXP 59
85590: PPUSH
85591: LD_VAR 0 4
85595: PUSH
85596: LD_EXP 59
85600: PUSH
85601: LD_VAR 0 4
85605: ARRAY
85606: PUSH
85607: LD_INT 1
85609: PLUS
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PPUSH
85615: LD_VAR 0 1
85619: PPUSH
85620: CALL 18573 0 3
85624: ST_TO_ADDR
// break ;
85625: GO 85629
// end ; end ;
85627: GO 85541
85629: POP
85630: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85631: LD_VAR 0 1
85635: PPUSH
85636: CALL_OW 257
85640: PUSH
85641: LD_EXP 76
85645: IN
85646: PUSH
85647: LD_VAR 0 1
85651: PPUSH
85652: CALL_OW 266
85656: PUSH
85657: LD_INT 5
85659: EQUAL
85660: AND
85661: PUSH
85662: LD_VAR 0 2
85666: PPUSH
85667: CALL_OW 110
85671: PUSH
85672: LD_INT 18
85674: NONEQUAL
85675: AND
85676: IFFALSE 85716
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85678: LD_VAR 0 2
85682: PPUSH
85683: CALL_OW 257
85687: PUSH
85688: LD_INT 5
85690: PUSH
85691: LD_INT 8
85693: PUSH
85694: LD_INT 9
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: LIST
85701: IN
85702: IFFALSE 85716
// SetClass ( unit , 1 ) ;
85704: LD_VAR 0 2
85708: PPUSH
85709: LD_INT 1
85711: PPUSH
85712: CALL_OW 336
// end ;
85716: LD_VAR 0 3
85720: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85721: LD_INT 0
85723: PPUSH
85724: PPUSH
// if not mc_bases or not skirmish then
85725: LD_EXP 50
85729: NOT
85730: PUSH
85731: LD_EXP 48
85735: NOT
85736: OR
85737: IFFALSE 85741
// exit ;
85739: GO 85857
// if GetLives ( abandoned_vehicle ) > 250 then
85741: LD_VAR 0 2
85745: PPUSH
85746: CALL_OW 256
85750: PUSH
85751: LD_INT 250
85753: GREATER
85754: IFFALSE 85758
// exit ;
85756: GO 85857
// for i = 1 to mc_bases do
85758: LD_ADDR_VAR 0 6
85762: PUSH
85763: DOUBLE
85764: LD_INT 1
85766: DEC
85767: ST_TO_ADDR
85768: LD_EXP 50
85772: PUSH
85773: FOR_TO
85774: IFFALSE 85855
// begin if driver in mc_bases [ i ] then
85776: LD_VAR 0 1
85780: PUSH
85781: LD_EXP 50
85785: PUSH
85786: LD_VAR 0 6
85790: ARRAY
85791: IN
85792: IFFALSE 85853
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85794: LD_VAR 0 1
85798: PPUSH
85799: LD_EXP 50
85803: PUSH
85804: LD_VAR 0 6
85808: ARRAY
85809: PPUSH
85810: LD_INT 2
85812: PUSH
85813: LD_INT 30
85815: PUSH
85816: LD_INT 0
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 30
85825: PUSH
85826: LD_INT 1
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: LIST
85837: PPUSH
85838: CALL_OW 72
85842: PUSH
85843: LD_INT 1
85845: ARRAY
85846: PPUSH
85847: CALL 51809 0 2
// break ;
85851: GO 85855
// end ; end ;
85853: GO 85773
85855: POP
85856: POP
// end ; end_of_file end_of_file
85857: LD_VAR 0 5
85861: RET
// export globalGameSaveCounter ; every 0 0$1 do
85862: GO 85864
85864: DISABLE
// begin enable ;
85865: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85866: LD_STRING updateTimer(
85868: PUSH
85869: LD_OWVAR 1
85873: STR
85874: PUSH
85875: LD_STRING );
85877: STR
85878: PPUSH
85879: CALL_OW 559
// end ;
85883: END
// every 0 0$1 do
85884: GO 85886
85886: DISABLE
// begin globalGameSaveCounter := 0 ;
85887: LD_ADDR_EXP 95
85891: PUSH
85892: LD_INT 0
85894: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
85895: LD_STRING setGameSaveCounter(0)
85897: PPUSH
85898: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
85902: LD_STRING initStreamRollete();
85904: PPUSH
85905: CALL_OW 559
// InitStreamMode ;
85909: CALL 87235 0 0
// DefineStreamItems ( false ) ;
85913: LD_INT 0
85915: PPUSH
85916: CALL 87699 0 1
// end ;
85920: END
// export function SOS_MapStart ( ) ; begin
85921: LD_INT 0
85923: PPUSH
// if streamModeActive then
85924: LD_EXP 96
85928: IFFALSE 85937
// DefineStreamItems ( true ) ;
85930: LD_INT 1
85932: PPUSH
85933: CALL 87699 0 1
// UpdateLuaVariables ( ) ;
85937: CALL 85954 0 0
// UpdateFactoryWaypoints ( ) ;
85941: CALL 100568 0 0
// UpdateWarehouseGatheringPoints ( ) ;
85945: CALL 100825 0 0
// end ;
85949: LD_VAR 0 1
85953: RET
// function UpdateLuaVariables ( ) ; begin
85954: LD_INT 0
85956: PPUSH
// if globalGameSaveCounter then
85957: LD_EXP 95
85961: IFFALSE 85995
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
85963: LD_ADDR_EXP 95
85967: PUSH
85968: LD_EXP 95
85972: PPUSH
85973: CALL 52293 0 1
85977: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
85978: LD_STRING setGameSaveCounter(
85980: PUSH
85981: LD_EXP 95
85985: STR
85986: PUSH
85987: LD_STRING )
85989: STR
85990: PPUSH
85991: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
85995: LD_STRING setGameDifficulty(
85997: PUSH
85998: LD_OWVAR 67
86002: STR
86003: PUSH
86004: LD_STRING )
86006: STR
86007: PPUSH
86008: CALL_OW 559
// end ;
86012: LD_VAR 0 1
86016: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
86017: LD_INT 0
86019: PPUSH
// if p2 = stream_mode then
86020: LD_VAR 0 2
86024: PUSH
86025: LD_INT 100
86027: EQUAL
86028: IFFALSE 87031
// begin if not StreamModeActive then
86030: LD_EXP 96
86034: NOT
86035: IFFALSE 86045
// StreamModeActive := true ;
86037: LD_ADDR_EXP 96
86041: PUSH
86042: LD_INT 1
86044: ST_TO_ADDR
// if p3 = 0 then
86045: LD_VAR 0 3
86049: PUSH
86050: LD_INT 0
86052: EQUAL
86053: IFFALSE 86059
// InitStreamMode ;
86055: CALL 87235 0 0
// if p3 = 1 then
86059: LD_VAR 0 3
86063: PUSH
86064: LD_INT 1
86066: EQUAL
86067: IFFALSE 86077
// sRocket := true ;
86069: LD_ADDR_EXP 101
86073: PUSH
86074: LD_INT 1
86076: ST_TO_ADDR
// if p3 = 2 then
86077: LD_VAR 0 3
86081: PUSH
86082: LD_INT 2
86084: EQUAL
86085: IFFALSE 86095
// sSpeed := true ;
86087: LD_ADDR_EXP 100
86091: PUSH
86092: LD_INT 1
86094: ST_TO_ADDR
// if p3 = 3 then
86095: LD_VAR 0 3
86099: PUSH
86100: LD_INT 3
86102: EQUAL
86103: IFFALSE 86113
// sEngine := true ;
86105: LD_ADDR_EXP 102
86109: PUSH
86110: LD_INT 1
86112: ST_TO_ADDR
// if p3 = 4 then
86113: LD_VAR 0 3
86117: PUSH
86118: LD_INT 4
86120: EQUAL
86121: IFFALSE 86131
// sSpec := true ;
86123: LD_ADDR_EXP 99
86127: PUSH
86128: LD_INT 1
86130: ST_TO_ADDR
// if p3 = 5 then
86131: LD_VAR 0 3
86135: PUSH
86136: LD_INT 5
86138: EQUAL
86139: IFFALSE 86149
// sLevel := true ;
86141: LD_ADDR_EXP 103
86145: PUSH
86146: LD_INT 1
86148: ST_TO_ADDR
// if p3 = 6 then
86149: LD_VAR 0 3
86153: PUSH
86154: LD_INT 6
86156: EQUAL
86157: IFFALSE 86167
// sArmoury := true ;
86159: LD_ADDR_EXP 104
86163: PUSH
86164: LD_INT 1
86166: ST_TO_ADDR
// if p3 = 7 then
86167: LD_VAR 0 3
86171: PUSH
86172: LD_INT 7
86174: EQUAL
86175: IFFALSE 86185
// sRadar := true ;
86177: LD_ADDR_EXP 105
86181: PUSH
86182: LD_INT 1
86184: ST_TO_ADDR
// if p3 = 8 then
86185: LD_VAR 0 3
86189: PUSH
86190: LD_INT 8
86192: EQUAL
86193: IFFALSE 86203
// sBunker := true ;
86195: LD_ADDR_EXP 106
86199: PUSH
86200: LD_INT 1
86202: ST_TO_ADDR
// if p3 = 9 then
86203: LD_VAR 0 3
86207: PUSH
86208: LD_INT 9
86210: EQUAL
86211: IFFALSE 86221
// sHack := true ;
86213: LD_ADDR_EXP 107
86217: PUSH
86218: LD_INT 1
86220: ST_TO_ADDR
// if p3 = 10 then
86221: LD_VAR 0 3
86225: PUSH
86226: LD_INT 10
86228: EQUAL
86229: IFFALSE 86239
// sFire := true ;
86231: LD_ADDR_EXP 108
86235: PUSH
86236: LD_INT 1
86238: ST_TO_ADDR
// if p3 = 11 then
86239: LD_VAR 0 3
86243: PUSH
86244: LD_INT 11
86246: EQUAL
86247: IFFALSE 86257
// sRefresh := true ;
86249: LD_ADDR_EXP 109
86253: PUSH
86254: LD_INT 1
86256: ST_TO_ADDR
// if p3 = 12 then
86257: LD_VAR 0 3
86261: PUSH
86262: LD_INT 12
86264: EQUAL
86265: IFFALSE 86275
// sExp := true ;
86267: LD_ADDR_EXP 110
86271: PUSH
86272: LD_INT 1
86274: ST_TO_ADDR
// if p3 = 13 then
86275: LD_VAR 0 3
86279: PUSH
86280: LD_INT 13
86282: EQUAL
86283: IFFALSE 86293
// sDepot := true ;
86285: LD_ADDR_EXP 111
86289: PUSH
86290: LD_INT 1
86292: ST_TO_ADDR
// if p3 = 14 then
86293: LD_VAR 0 3
86297: PUSH
86298: LD_INT 14
86300: EQUAL
86301: IFFALSE 86311
// sFlag := true ;
86303: LD_ADDR_EXP 112
86307: PUSH
86308: LD_INT 1
86310: ST_TO_ADDR
// if p3 = 15 then
86311: LD_VAR 0 3
86315: PUSH
86316: LD_INT 15
86318: EQUAL
86319: IFFALSE 86329
// sKamikadze := true ;
86321: LD_ADDR_EXP 120
86325: PUSH
86326: LD_INT 1
86328: ST_TO_ADDR
// if p3 = 16 then
86329: LD_VAR 0 3
86333: PUSH
86334: LD_INT 16
86336: EQUAL
86337: IFFALSE 86347
// sTroll := true ;
86339: LD_ADDR_EXP 121
86343: PUSH
86344: LD_INT 1
86346: ST_TO_ADDR
// if p3 = 17 then
86347: LD_VAR 0 3
86351: PUSH
86352: LD_INT 17
86354: EQUAL
86355: IFFALSE 86365
// sSlow := true ;
86357: LD_ADDR_EXP 122
86361: PUSH
86362: LD_INT 1
86364: ST_TO_ADDR
// if p3 = 18 then
86365: LD_VAR 0 3
86369: PUSH
86370: LD_INT 18
86372: EQUAL
86373: IFFALSE 86383
// sLack := true ;
86375: LD_ADDR_EXP 123
86379: PUSH
86380: LD_INT 1
86382: ST_TO_ADDR
// if p3 = 19 then
86383: LD_VAR 0 3
86387: PUSH
86388: LD_INT 19
86390: EQUAL
86391: IFFALSE 86401
// sTank := true ;
86393: LD_ADDR_EXP 125
86397: PUSH
86398: LD_INT 1
86400: ST_TO_ADDR
// if p3 = 20 then
86401: LD_VAR 0 3
86405: PUSH
86406: LD_INT 20
86408: EQUAL
86409: IFFALSE 86419
// sRemote := true ;
86411: LD_ADDR_EXP 126
86415: PUSH
86416: LD_INT 1
86418: ST_TO_ADDR
// if p3 = 21 then
86419: LD_VAR 0 3
86423: PUSH
86424: LD_INT 21
86426: EQUAL
86427: IFFALSE 86437
// sPowell := true ;
86429: LD_ADDR_EXP 127
86433: PUSH
86434: LD_INT 1
86436: ST_TO_ADDR
// if p3 = 22 then
86437: LD_VAR 0 3
86441: PUSH
86442: LD_INT 22
86444: EQUAL
86445: IFFALSE 86455
// sTeleport := true ;
86447: LD_ADDR_EXP 130
86451: PUSH
86452: LD_INT 1
86454: ST_TO_ADDR
// if p3 = 23 then
86455: LD_VAR 0 3
86459: PUSH
86460: LD_INT 23
86462: EQUAL
86463: IFFALSE 86473
// sOilTower := true ;
86465: LD_ADDR_EXP 132
86469: PUSH
86470: LD_INT 1
86472: ST_TO_ADDR
// if p3 = 24 then
86473: LD_VAR 0 3
86477: PUSH
86478: LD_INT 24
86480: EQUAL
86481: IFFALSE 86491
// sShovel := true ;
86483: LD_ADDR_EXP 133
86487: PUSH
86488: LD_INT 1
86490: ST_TO_ADDR
// if p3 = 25 then
86491: LD_VAR 0 3
86495: PUSH
86496: LD_INT 25
86498: EQUAL
86499: IFFALSE 86509
// sSheik := true ;
86501: LD_ADDR_EXP 134
86505: PUSH
86506: LD_INT 1
86508: ST_TO_ADDR
// if p3 = 26 then
86509: LD_VAR 0 3
86513: PUSH
86514: LD_INT 26
86516: EQUAL
86517: IFFALSE 86527
// sEarthquake := true ;
86519: LD_ADDR_EXP 136
86523: PUSH
86524: LD_INT 1
86526: ST_TO_ADDR
// if p3 = 27 then
86527: LD_VAR 0 3
86531: PUSH
86532: LD_INT 27
86534: EQUAL
86535: IFFALSE 86545
// sAI := true ;
86537: LD_ADDR_EXP 137
86541: PUSH
86542: LD_INT 1
86544: ST_TO_ADDR
// if p3 = 28 then
86545: LD_VAR 0 3
86549: PUSH
86550: LD_INT 28
86552: EQUAL
86553: IFFALSE 86563
// sCargo := true ;
86555: LD_ADDR_EXP 140
86559: PUSH
86560: LD_INT 1
86562: ST_TO_ADDR
// if p3 = 29 then
86563: LD_VAR 0 3
86567: PUSH
86568: LD_INT 29
86570: EQUAL
86571: IFFALSE 86581
// sDLaser := true ;
86573: LD_ADDR_EXP 141
86577: PUSH
86578: LD_INT 1
86580: ST_TO_ADDR
// if p3 = 30 then
86581: LD_VAR 0 3
86585: PUSH
86586: LD_INT 30
86588: EQUAL
86589: IFFALSE 86599
// sExchange := true ;
86591: LD_ADDR_EXP 142
86595: PUSH
86596: LD_INT 1
86598: ST_TO_ADDR
// if p3 = 31 then
86599: LD_VAR 0 3
86603: PUSH
86604: LD_INT 31
86606: EQUAL
86607: IFFALSE 86617
// sFac := true ;
86609: LD_ADDR_EXP 143
86613: PUSH
86614: LD_INT 1
86616: ST_TO_ADDR
// if p3 = 32 then
86617: LD_VAR 0 3
86621: PUSH
86622: LD_INT 32
86624: EQUAL
86625: IFFALSE 86635
// sPower := true ;
86627: LD_ADDR_EXP 144
86631: PUSH
86632: LD_INT 1
86634: ST_TO_ADDR
// if p3 = 33 then
86635: LD_VAR 0 3
86639: PUSH
86640: LD_INT 33
86642: EQUAL
86643: IFFALSE 86653
// sRandom := true ;
86645: LD_ADDR_EXP 145
86649: PUSH
86650: LD_INT 1
86652: ST_TO_ADDR
// if p3 = 34 then
86653: LD_VAR 0 3
86657: PUSH
86658: LD_INT 34
86660: EQUAL
86661: IFFALSE 86671
// sShield := true ;
86663: LD_ADDR_EXP 146
86667: PUSH
86668: LD_INT 1
86670: ST_TO_ADDR
// if p3 = 35 then
86671: LD_VAR 0 3
86675: PUSH
86676: LD_INT 35
86678: EQUAL
86679: IFFALSE 86689
// sTime := true ;
86681: LD_ADDR_EXP 147
86685: PUSH
86686: LD_INT 1
86688: ST_TO_ADDR
// if p3 = 36 then
86689: LD_VAR 0 3
86693: PUSH
86694: LD_INT 36
86696: EQUAL
86697: IFFALSE 86707
// sTools := true ;
86699: LD_ADDR_EXP 148
86703: PUSH
86704: LD_INT 1
86706: ST_TO_ADDR
// if p3 = 101 then
86707: LD_VAR 0 3
86711: PUSH
86712: LD_INT 101
86714: EQUAL
86715: IFFALSE 86725
// sSold := true ;
86717: LD_ADDR_EXP 113
86721: PUSH
86722: LD_INT 1
86724: ST_TO_ADDR
// if p3 = 102 then
86725: LD_VAR 0 3
86729: PUSH
86730: LD_INT 102
86732: EQUAL
86733: IFFALSE 86743
// sDiff := true ;
86735: LD_ADDR_EXP 114
86739: PUSH
86740: LD_INT 1
86742: ST_TO_ADDR
// if p3 = 103 then
86743: LD_VAR 0 3
86747: PUSH
86748: LD_INT 103
86750: EQUAL
86751: IFFALSE 86761
// sFog := true ;
86753: LD_ADDR_EXP 117
86757: PUSH
86758: LD_INT 1
86760: ST_TO_ADDR
// if p3 = 104 then
86761: LD_VAR 0 3
86765: PUSH
86766: LD_INT 104
86768: EQUAL
86769: IFFALSE 86779
// sReset := true ;
86771: LD_ADDR_EXP 118
86775: PUSH
86776: LD_INT 1
86778: ST_TO_ADDR
// if p3 = 105 then
86779: LD_VAR 0 3
86783: PUSH
86784: LD_INT 105
86786: EQUAL
86787: IFFALSE 86797
// sSun := true ;
86789: LD_ADDR_EXP 119
86793: PUSH
86794: LD_INT 1
86796: ST_TO_ADDR
// if p3 = 106 then
86797: LD_VAR 0 3
86801: PUSH
86802: LD_INT 106
86804: EQUAL
86805: IFFALSE 86815
// sTiger := true ;
86807: LD_ADDR_EXP 115
86811: PUSH
86812: LD_INT 1
86814: ST_TO_ADDR
// if p3 = 107 then
86815: LD_VAR 0 3
86819: PUSH
86820: LD_INT 107
86822: EQUAL
86823: IFFALSE 86833
// sBomb := true ;
86825: LD_ADDR_EXP 116
86829: PUSH
86830: LD_INT 1
86832: ST_TO_ADDR
// if p3 = 108 then
86833: LD_VAR 0 3
86837: PUSH
86838: LD_INT 108
86840: EQUAL
86841: IFFALSE 86851
// sWound := true ;
86843: LD_ADDR_EXP 124
86847: PUSH
86848: LD_INT 1
86850: ST_TO_ADDR
// if p3 = 109 then
86851: LD_VAR 0 3
86855: PUSH
86856: LD_INT 109
86858: EQUAL
86859: IFFALSE 86869
// sBetray := true ;
86861: LD_ADDR_EXP 128
86865: PUSH
86866: LD_INT 1
86868: ST_TO_ADDR
// if p3 = 110 then
86869: LD_VAR 0 3
86873: PUSH
86874: LD_INT 110
86876: EQUAL
86877: IFFALSE 86887
// sContamin := true ;
86879: LD_ADDR_EXP 129
86883: PUSH
86884: LD_INT 1
86886: ST_TO_ADDR
// if p3 = 111 then
86887: LD_VAR 0 3
86891: PUSH
86892: LD_INT 111
86894: EQUAL
86895: IFFALSE 86905
// sOil := true ;
86897: LD_ADDR_EXP 131
86901: PUSH
86902: LD_INT 1
86904: ST_TO_ADDR
// if p3 = 112 then
86905: LD_VAR 0 3
86909: PUSH
86910: LD_INT 112
86912: EQUAL
86913: IFFALSE 86923
// sStu := true ;
86915: LD_ADDR_EXP 135
86919: PUSH
86920: LD_INT 1
86922: ST_TO_ADDR
// if p3 = 113 then
86923: LD_VAR 0 3
86927: PUSH
86928: LD_INT 113
86930: EQUAL
86931: IFFALSE 86941
// sBazooka := true ;
86933: LD_ADDR_EXP 138
86937: PUSH
86938: LD_INT 1
86940: ST_TO_ADDR
// if p3 = 114 then
86941: LD_VAR 0 3
86945: PUSH
86946: LD_INT 114
86948: EQUAL
86949: IFFALSE 86959
// sMortar := true ;
86951: LD_ADDR_EXP 139
86955: PUSH
86956: LD_INT 1
86958: ST_TO_ADDR
// if p3 = 115 then
86959: LD_VAR 0 3
86963: PUSH
86964: LD_INT 115
86966: EQUAL
86967: IFFALSE 86977
// sRanger := true ;
86969: LD_ADDR_EXP 149
86973: PUSH
86974: LD_INT 1
86976: ST_TO_ADDR
// if p3 = 116 then
86977: LD_VAR 0 3
86981: PUSH
86982: LD_INT 116
86984: EQUAL
86985: IFFALSE 86995
// sComputer := true ;
86987: LD_ADDR_EXP 150
86991: PUSH
86992: LD_INT 1
86994: ST_TO_ADDR
// if p3 = 117 then
86995: LD_VAR 0 3
86999: PUSH
87000: LD_INT 117
87002: EQUAL
87003: IFFALSE 87013
// s30 := true ;
87005: LD_ADDR_EXP 151
87009: PUSH
87010: LD_INT 1
87012: ST_TO_ADDR
// if p3 = 118 then
87013: LD_VAR 0 3
87017: PUSH
87018: LD_INT 118
87020: EQUAL
87021: IFFALSE 87031
// s60 := true ;
87023: LD_ADDR_EXP 152
87027: PUSH
87028: LD_INT 1
87030: ST_TO_ADDR
// end ; if p2 = hack_mode then
87031: LD_VAR 0 2
87035: PUSH
87036: LD_INT 101
87038: EQUAL
87039: IFFALSE 87167
// begin case p3 of 1 :
87041: LD_VAR 0 3
87045: PUSH
87046: LD_INT 1
87048: DOUBLE
87049: EQUAL
87050: IFTRUE 87054
87052: GO 87061
87054: POP
// hHackUnlimitedResources ; 2 :
87055: CALL 99314 0 0
87059: GO 87167
87061: LD_INT 2
87063: DOUBLE
87064: EQUAL
87065: IFTRUE 87069
87067: GO 87076
87069: POP
// hHackSetLevel10 ; 3 :
87070: CALL 99447 0 0
87074: GO 87167
87076: LD_INT 3
87078: DOUBLE
87079: EQUAL
87080: IFTRUE 87084
87082: GO 87091
87084: POP
// hHackSetLevel10YourUnits ; 4 :
87085: CALL 99532 0 0
87089: GO 87167
87091: LD_INT 4
87093: DOUBLE
87094: EQUAL
87095: IFTRUE 87099
87097: GO 87106
87099: POP
// hHackInvincible ; 5 :
87100: CALL 99980 0 0
87104: GO 87167
87106: LD_INT 5
87108: DOUBLE
87109: EQUAL
87110: IFTRUE 87114
87112: GO 87121
87114: POP
// hHackInvisible ; 6 :
87115: CALL 100091 0 0
87119: GO 87167
87121: LD_INT 6
87123: DOUBLE
87124: EQUAL
87125: IFTRUE 87129
87127: GO 87136
87129: POP
// hHackChangeYourSide ; 7 :
87130: CALL 100148 0 0
87134: GO 87167
87136: LD_INT 7
87138: DOUBLE
87139: EQUAL
87140: IFTRUE 87144
87142: GO 87151
87144: POP
// hHackChangeUnitSide ; 8 :
87145: CALL 100190 0 0
87149: GO 87167
87151: LD_INT 8
87153: DOUBLE
87154: EQUAL
87155: IFTRUE 87159
87157: GO 87166
87159: POP
// hHackFog ; end ;
87160: CALL 100291 0 0
87164: GO 87167
87166: POP
// end ; if p2 = game_save_mode then
87167: LD_VAR 0 2
87171: PUSH
87172: LD_INT 102
87174: EQUAL
87175: IFFALSE 87230
// begin if p3 = 1 then
87177: LD_VAR 0 3
87181: PUSH
87182: LD_INT 1
87184: EQUAL
87185: IFFALSE 87197
// globalGameSaveCounter := p4 ;
87187: LD_ADDR_EXP 95
87191: PUSH
87192: LD_VAR 0 4
87196: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
87197: LD_VAR 0 3
87201: PUSH
87202: LD_INT 2
87204: EQUAL
87205: PUSH
87206: LD_EXP 95
87210: AND
87211: IFFALSE 87230
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87213: LD_STRING setGameSaveCounter(
87215: PUSH
87216: LD_EXP 95
87220: STR
87221: PUSH
87222: LD_STRING )
87224: STR
87225: PPUSH
87226: CALL_OW 559
// end ; end ;
87230: LD_VAR 0 7
87234: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
87235: LD_INT 0
87237: PPUSH
// streamModeActive := false ;
87238: LD_ADDR_EXP 96
87242: PUSH
87243: LD_INT 0
87245: ST_TO_ADDR
// normalCounter := 36 ;
87246: LD_ADDR_EXP 97
87250: PUSH
87251: LD_INT 36
87253: ST_TO_ADDR
// hardcoreCounter := 18 ;
87254: LD_ADDR_EXP 98
87258: PUSH
87259: LD_INT 18
87261: ST_TO_ADDR
// sRocket := false ;
87262: LD_ADDR_EXP 101
87266: PUSH
87267: LD_INT 0
87269: ST_TO_ADDR
// sSpeed := false ;
87270: LD_ADDR_EXP 100
87274: PUSH
87275: LD_INT 0
87277: ST_TO_ADDR
// sEngine := false ;
87278: LD_ADDR_EXP 102
87282: PUSH
87283: LD_INT 0
87285: ST_TO_ADDR
// sSpec := false ;
87286: LD_ADDR_EXP 99
87290: PUSH
87291: LD_INT 0
87293: ST_TO_ADDR
// sLevel := false ;
87294: LD_ADDR_EXP 103
87298: PUSH
87299: LD_INT 0
87301: ST_TO_ADDR
// sArmoury := false ;
87302: LD_ADDR_EXP 104
87306: PUSH
87307: LD_INT 0
87309: ST_TO_ADDR
// sRadar := false ;
87310: LD_ADDR_EXP 105
87314: PUSH
87315: LD_INT 0
87317: ST_TO_ADDR
// sBunker := false ;
87318: LD_ADDR_EXP 106
87322: PUSH
87323: LD_INT 0
87325: ST_TO_ADDR
// sHack := false ;
87326: LD_ADDR_EXP 107
87330: PUSH
87331: LD_INT 0
87333: ST_TO_ADDR
// sFire := false ;
87334: LD_ADDR_EXP 108
87338: PUSH
87339: LD_INT 0
87341: ST_TO_ADDR
// sRefresh := false ;
87342: LD_ADDR_EXP 109
87346: PUSH
87347: LD_INT 0
87349: ST_TO_ADDR
// sExp := false ;
87350: LD_ADDR_EXP 110
87354: PUSH
87355: LD_INT 0
87357: ST_TO_ADDR
// sDepot := false ;
87358: LD_ADDR_EXP 111
87362: PUSH
87363: LD_INT 0
87365: ST_TO_ADDR
// sFlag := false ;
87366: LD_ADDR_EXP 112
87370: PUSH
87371: LD_INT 0
87373: ST_TO_ADDR
// sKamikadze := false ;
87374: LD_ADDR_EXP 120
87378: PUSH
87379: LD_INT 0
87381: ST_TO_ADDR
// sTroll := false ;
87382: LD_ADDR_EXP 121
87386: PUSH
87387: LD_INT 0
87389: ST_TO_ADDR
// sSlow := false ;
87390: LD_ADDR_EXP 122
87394: PUSH
87395: LD_INT 0
87397: ST_TO_ADDR
// sLack := false ;
87398: LD_ADDR_EXP 123
87402: PUSH
87403: LD_INT 0
87405: ST_TO_ADDR
// sTank := false ;
87406: LD_ADDR_EXP 125
87410: PUSH
87411: LD_INT 0
87413: ST_TO_ADDR
// sRemote := false ;
87414: LD_ADDR_EXP 126
87418: PUSH
87419: LD_INT 0
87421: ST_TO_ADDR
// sPowell := false ;
87422: LD_ADDR_EXP 127
87426: PUSH
87427: LD_INT 0
87429: ST_TO_ADDR
// sTeleport := false ;
87430: LD_ADDR_EXP 130
87434: PUSH
87435: LD_INT 0
87437: ST_TO_ADDR
// sOilTower := false ;
87438: LD_ADDR_EXP 132
87442: PUSH
87443: LD_INT 0
87445: ST_TO_ADDR
// sShovel := false ;
87446: LD_ADDR_EXP 133
87450: PUSH
87451: LD_INT 0
87453: ST_TO_ADDR
// sSheik := false ;
87454: LD_ADDR_EXP 134
87458: PUSH
87459: LD_INT 0
87461: ST_TO_ADDR
// sEarthquake := false ;
87462: LD_ADDR_EXP 136
87466: PUSH
87467: LD_INT 0
87469: ST_TO_ADDR
// sAI := false ;
87470: LD_ADDR_EXP 137
87474: PUSH
87475: LD_INT 0
87477: ST_TO_ADDR
// sCargo := false ;
87478: LD_ADDR_EXP 140
87482: PUSH
87483: LD_INT 0
87485: ST_TO_ADDR
// sDLaser := false ;
87486: LD_ADDR_EXP 141
87490: PUSH
87491: LD_INT 0
87493: ST_TO_ADDR
// sExchange := false ;
87494: LD_ADDR_EXP 142
87498: PUSH
87499: LD_INT 0
87501: ST_TO_ADDR
// sFac := false ;
87502: LD_ADDR_EXP 143
87506: PUSH
87507: LD_INT 0
87509: ST_TO_ADDR
// sPower := false ;
87510: LD_ADDR_EXP 144
87514: PUSH
87515: LD_INT 0
87517: ST_TO_ADDR
// sRandom := false ;
87518: LD_ADDR_EXP 145
87522: PUSH
87523: LD_INT 0
87525: ST_TO_ADDR
// sShield := false ;
87526: LD_ADDR_EXP 146
87530: PUSH
87531: LD_INT 0
87533: ST_TO_ADDR
// sTime := false ;
87534: LD_ADDR_EXP 147
87538: PUSH
87539: LD_INT 0
87541: ST_TO_ADDR
// sTools := false ;
87542: LD_ADDR_EXP 148
87546: PUSH
87547: LD_INT 0
87549: ST_TO_ADDR
// sSold := false ;
87550: LD_ADDR_EXP 113
87554: PUSH
87555: LD_INT 0
87557: ST_TO_ADDR
// sDiff := false ;
87558: LD_ADDR_EXP 114
87562: PUSH
87563: LD_INT 0
87565: ST_TO_ADDR
// sFog := false ;
87566: LD_ADDR_EXP 117
87570: PUSH
87571: LD_INT 0
87573: ST_TO_ADDR
// sReset := false ;
87574: LD_ADDR_EXP 118
87578: PUSH
87579: LD_INT 0
87581: ST_TO_ADDR
// sSun := false ;
87582: LD_ADDR_EXP 119
87586: PUSH
87587: LD_INT 0
87589: ST_TO_ADDR
// sTiger := false ;
87590: LD_ADDR_EXP 115
87594: PUSH
87595: LD_INT 0
87597: ST_TO_ADDR
// sBomb := false ;
87598: LD_ADDR_EXP 116
87602: PUSH
87603: LD_INT 0
87605: ST_TO_ADDR
// sWound := false ;
87606: LD_ADDR_EXP 124
87610: PUSH
87611: LD_INT 0
87613: ST_TO_ADDR
// sBetray := false ;
87614: LD_ADDR_EXP 128
87618: PUSH
87619: LD_INT 0
87621: ST_TO_ADDR
// sContamin := false ;
87622: LD_ADDR_EXP 129
87626: PUSH
87627: LD_INT 0
87629: ST_TO_ADDR
// sOil := false ;
87630: LD_ADDR_EXP 131
87634: PUSH
87635: LD_INT 0
87637: ST_TO_ADDR
// sStu := false ;
87638: LD_ADDR_EXP 135
87642: PUSH
87643: LD_INT 0
87645: ST_TO_ADDR
// sBazooka := false ;
87646: LD_ADDR_EXP 138
87650: PUSH
87651: LD_INT 0
87653: ST_TO_ADDR
// sMortar := false ;
87654: LD_ADDR_EXP 139
87658: PUSH
87659: LD_INT 0
87661: ST_TO_ADDR
// sRanger := false ;
87662: LD_ADDR_EXP 149
87666: PUSH
87667: LD_INT 0
87669: ST_TO_ADDR
// sComputer := false ;
87670: LD_ADDR_EXP 150
87674: PUSH
87675: LD_INT 0
87677: ST_TO_ADDR
// s30 := false ;
87678: LD_ADDR_EXP 151
87682: PUSH
87683: LD_INT 0
87685: ST_TO_ADDR
// s60 := false ;
87686: LD_ADDR_EXP 152
87690: PUSH
87691: LD_INT 0
87693: ST_TO_ADDR
// end ;
87694: LD_VAR 0 1
87698: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87699: LD_INT 0
87701: PPUSH
87702: PPUSH
87703: PPUSH
87704: PPUSH
87705: PPUSH
87706: PPUSH
87707: PPUSH
// result := [ ] ;
87708: LD_ADDR_VAR 0 2
87712: PUSH
87713: EMPTY
87714: ST_TO_ADDR
// if campaign_id = 1 then
87715: LD_OWVAR 69
87719: PUSH
87720: LD_INT 1
87722: EQUAL
87723: IFFALSE 90889
// begin case mission_number of 1 :
87725: LD_OWVAR 70
87729: PUSH
87730: LD_INT 1
87732: DOUBLE
87733: EQUAL
87734: IFTRUE 87738
87736: GO 87814
87738: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87739: LD_ADDR_VAR 0 2
87743: PUSH
87744: LD_INT 2
87746: PUSH
87747: LD_INT 4
87749: PUSH
87750: LD_INT 11
87752: PUSH
87753: LD_INT 12
87755: PUSH
87756: LD_INT 15
87758: PUSH
87759: LD_INT 16
87761: PUSH
87762: LD_INT 22
87764: PUSH
87765: LD_INT 23
87767: PUSH
87768: LD_INT 26
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 101
87784: PUSH
87785: LD_INT 102
87787: PUSH
87788: LD_INT 106
87790: PUSH
87791: LD_INT 116
87793: PUSH
87794: LD_INT 117
87796: PUSH
87797: LD_INT 118
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: ST_TO_ADDR
87812: GO 90887
87814: LD_INT 2
87816: DOUBLE
87817: EQUAL
87818: IFTRUE 87822
87820: GO 87906
87822: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87823: LD_ADDR_VAR 0 2
87827: PUSH
87828: LD_INT 2
87830: PUSH
87831: LD_INT 4
87833: PUSH
87834: LD_INT 11
87836: PUSH
87837: LD_INT 12
87839: PUSH
87840: LD_INT 15
87842: PUSH
87843: LD_INT 16
87845: PUSH
87846: LD_INT 22
87848: PUSH
87849: LD_INT 23
87851: PUSH
87852: LD_INT 26
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 101
87868: PUSH
87869: LD_INT 102
87871: PUSH
87872: LD_INT 105
87874: PUSH
87875: LD_INT 106
87877: PUSH
87878: LD_INT 108
87880: PUSH
87881: LD_INT 116
87883: PUSH
87884: LD_INT 117
87886: PUSH
87887: LD_INT 118
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: ST_TO_ADDR
87904: GO 90887
87906: LD_INT 3
87908: DOUBLE
87909: EQUAL
87910: IFTRUE 87914
87912: GO 88002
87914: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87915: LD_ADDR_VAR 0 2
87919: PUSH
87920: LD_INT 2
87922: PUSH
87923: LD_INT 4
87925: PUSH
87926: LD_INT 5
87928: PUSH
87929: LD_INT 11
87931: PUSH
87932: LD_INT 12
87934: PUSH
87935: LD_INT 15
87937: PUSH
87938: LD_INT 16
87940: PUSH
87941: LD_INT 22
87943: PUSH
87944: LD_INT 26
87946: PUSH
87947: LD_INT 36
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 101
87964: PUSH
87965: LD_INT 102
87967: PUSH
87968: LD_INT 105
87970: PUSH
87971: LD_INT 106
87973: PUSH
87974: LD_INT 108
87976: PUSH
87977: LD_INT 116
87979: PUSH
87980: LD_INT 117
87982: PUSH
87983: LD_INT 118
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: ST_TO_ADDR
88000: GO 90887
88002: LD_INT 4
88004: DOUBLE
88005: EQUAL
88006: IFTRUE 88010
88008: GO 88106
88010: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
88011: LD_ADDR_VAR 0 2
88015: PUSH
88016: LD_INT 2
88018: PUSH
88019: LD_INT 4
88021: PUSH
88022: LD_INT 5
88024: PUSH
88025: LD_INT 8
88027: PUSH
88028: LD_INT 11
88030: PUSH
88031: LD_INT 12
88033: PUSH
88034: LD_INT 15
88036: PUSH
88037: LD_INT 16
88039: PUSH
88040: LD_INT 22
88042: PUSH
88043: LD_INT 23
88045: PUSH
88046: LD_INT 26
88048: PUSH
88049: LD_INT 36
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 101
88068: PUSH
88069: LD_INT 102
88071: PUSH
88072: LD_INT 105
88074: PUSH
88075: LD_INT 106
88077: PUSH
88078: LD_INT 108
88080: PUSH
88081: LD_INT 116
88083: PUSH
88084: LD_INT 117
88086: PUSH
88087: LD_INT 118
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: ST_TO_ADDR
88104: GO 90887
88106: LD_INT 5
88108: DOUBLE
88109: EQUAL
88110: IFTRUE 88114
88112: GO 88226
88114: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
88115: LD_ADDR_VAR 0 2
88119: PUSH
88120: LD_INT 2
88122: PUSH
88123: LD_INT 4
88125: PUSH
88126: LD_INT 5
88128: PUSH
88129: LD_INT 6
88131: PUSH
88132: LD_INT 8
88134: PUSH
88135: LD_INT 11
88137: PUSH
88138: LD_INT 12
88140: PUSH
88141: LD_INT 15
88143: PUSH
88144: LD_INT 16
88146: PUSH
88147: LD_INT 22
88149: PUSH
88150: LD_INT 23
88152: PUSH
88153: LD_INT 25
88155: PUSH
88156: LD_INT 26
88158: PUSH
88159: LD_INT 36
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 101
88180: PUSH
88181: LD_INT 102
88183: PUSH
88184: LD_INT 105
88186: PUSH
88187: LD_INT 106
88189: PUSH
88190: LD_INT 108
88192: PUSH
88193: LD_INT 109
88195: PUSH
88196: LD_INT 112
88198: PUSH
88199: LD_INT 116
88201: PUSH
88202: LD_INT 117
88204: PUSH
88205: LD_INT 118
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: ST_TO_ADDR
88224: GO 90887
88226: LD_INT 6
88228: DOUBLE
88229: EQUAL
88230: IFTRUE 88234
88232: GO 88366
88234: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
88235: LD_ADDR_VAR 0 2
88239: PUSH
88240: LD_INT 2
88242: PUSH
88243: LD_INT 4
88245: PUSH
88246: LD_INT 5
88248: PUSH
88249: LD_INT 6
88251: PUSH
88252: LD_INT 8
88254: PUSH
88255: LD_INT 11
88257: PUSH
88258: LD_INT 12
88260: PUSH
88261: LD_INT 15
88263: PUSH
88264: LD_INT 16
88266: PUSH
88267: LD_INT 20
88269: PUSH
88270: LD_INT 21
88272: PUSH
88273: LD_INT 22
88275: PUSH
88276: LD_INT 23
88278: PUSH
88279: LD_INT 25
88281: PUSH
88282: LD_INT 26
88284: PUSH
88285: LD_INT 30
88287: PUSH
88288: LD_INT 31
88290: PUSH
88291: LD_INT 32
88293: PUSH
88294: LD_INT 36
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 101
88320: PUSH
88321: LD_INT 102
88323: PUSH
88324: LD_INT 105
88326: PUSH
88327: LD_INT 106
88329: PUSH
88330: LD_INT 108
88332: PUSH
88333: LD_INT 109
88335: PUSH
88336: LD_INT 112
88338: PUSH
88339: LD_INT 116
88341: PUSH
88342: LD_INT 117
88344: PUSH
88345: LD_INT 118
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: ST_TO_ADDR
88364: GO 90887
88366: LD_INT 7
88368: DOUBLE
88369: EQUAL
88370: IFTRUE 88374
88372: GO 88486
88374: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
88375: LD_ADDR_VAR 0 2
88379: PUSH
88380: LD_INT 2
88382: PUSH
88383: LD_INT 4
88385: PUSH
88386: LD_INT 5
88388: PUSH
88389: LD_INT 7
88391: PUSH
88392: LD_INT 11
88394: PUSH
88395: LD_INT 12
88397: PUSH
88398: LD_INT 15
88400: PUSH
88401: LD_INT 16
88403: PUSH
88404: LD_INT 20
88406: PUSH
88407: LD_INT 21
88409: PUSH
88410: LD_INT 22
88412: PUSH
88413: LD_INT 23
88415: PUSH
88416: LD_INT 25
88418: PUSH
88419: LD_INT 26
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: PUSH
88438: LD_INT 101
88440: PUSH
88441: LD_INT 102
88443: PUSH
88444: LD_INT 103
88446: PUSH
88447: LD_INT 105
88449: PUSH
88450: LD_INT 106
88452: PUSH
88453: LD_INT 108
88455: PUSH
88456: LD_INT 112
88458: PUSH
88459: LD_INT 116
88461: PUSH
88462: LD_INT 117
88464: PUSH
88465: LD_INT 118
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: ST_TO_ADDR
88484: GO 90887
88486: LD_INT 8
88488: DOUBLE
88489: EQUAL
88490: IFTRUE 88494
88492: GO 88634
88494: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88495: LD_ADDR_VAR 0 2
88499: PUSH
88500: LD_INT 2
88502: PUSH
88503: LD_INT 4
88505: PUSH
88506: LD_INT 5
88508: PUSH
88509: LD_INT 6
88511: PUSH
88512: LD_INT 7
88514: PUSH
88515: LD_INT 8
88517: PUSH
88518: LD_INT 11
88520: PUSH
88521: LD_INT 12
88523: PUSH
88524: LD_INT 15
88526: PUSH
88527: LD_INT 16
88529: PUSH
88530: LD_INT 20
88532: PUSH
88533: LD_INT 21
88535: PUSH
88536: LD_INT 22
88538: PUSH
88539: LD_INT 23
88541: PUSH
88542: LD_INT 25
88544: PUSH
88545: LD_INT 26
88547: PUSH
88548: LD_INT 30
88550: PUSH
88551: LD_INT 31
88553: PUSH
88554: LD_INT 32
88556: PUSH
88557: LD_INT 36
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 101
88584: PUSH
88585: LD_INT 102
88587: PUSH
88588: LD_INT 103
88590: PUSH
88591: LD_INT 105
88593: PUSH
88594: LD_INT 106
88596: PUSH
88597: LD_INT 108
88599: PUSH
88600: LD_INT 109
88602: PUSH
88603: LD_INT 112
88605: PUSH
88606: LD_INT 116
88608: PUSH
88609: LD_INT 117
88611: PUSH
88612: LD_INT 118
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: PUSH
88628: EMPTY
88629: LIST
88630: LIST
88631: ST_TO_ADDR
88632: GO 90887
88634: LD_INT 9
88636: DOUBLE
88637: EQUAL
88638: IFTRUE 88642
88640: GO 88790
88642: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88643: LD_ADDR_VAR 0 2
88647: PUSH
88648: LD_INT 2
88650: PUSH
88651: LD_INT 4
88653: PUSH
88654: LD_INT 5
88656: PUSH
88657: LD_INT 6
88659: PUSH
88660: LD_INT 7
88662: PUSH
88663: LD_INT 8
88665: PUSH
88666: LD_INT 11
88668: PUSH
88669: LD_INT 12
88671: PUSH
88672: LD_INT 15
88674: PUSH
88675: LD_INT 16
88677: PUSH
88678: LD_INT 20
88680: PUSH
88681: LD_INT 21
88683: PUSH
88684: LD_INT 22
88686: PUSH
88687: LD_INT 23
88689: PUSH
88690: LD_INT 25
88692: PUSH
88693: LD_INT 26
88695: PUSH
88696: LD_INT 28
88698: PUSH
88699: LD_INT 30
88701: PUSH
88702: LD_INT 31
88704: PUSH
88705: LD_INT 32
88707: PUSH
88708: LD_INT 36
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 101
88736: PUSH
88737: LD_INT 102
88739: PUSH
88740: LD_INT 103
88742: PUSH
88743: LD_INT 105
88745: PUSH
88746: LD_INT 106
88748: PUSH
88749: LD_INT 108
88751: PUSH
88752: LD_INT 109
88754: PUSH
88755: LD_INT 112
88757: PUSH
88758: LD_INT 114
88760: PUSH
88761: LD_INT 116
88763: PUSH
88764: LD_INT 117
88766: PUSH
88767: LD_INT 118
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: ST_TO_ADDR
88788: GO 90887
88790: LD_INT 10
88792: DOUBLE
88793: EQUAL
88794: IFTRUE 88798
88796: GO 88994
88798: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88799: LD_ADDR_VAR 0 2
88803: PUSH
88804: LD_INT 2
88806: PUSH
88807: LD_INT 4
88809: PUSH
88810: LD_INT 5
88812: PUSH
88813: LD_INT 6
88815: PUSH
88816: LD_INT 7
88818: PUSH
88819: LD_INT 8
88821: PUSH
88822: LD_INT 9
88824: PUSH
88825: LD_INT 10
88827: PUSH
88828: LD_INT 11
88830: PUSH
88831: LD_INT 12
88833: PUSH
88834: LD_INT 13
88836: PUSH
88837: LD_INT 14
88839: PUSH
88840: LD_INT 15
88842: PUSH
88843: LD_INT 16
88845: PUSH
88846: LD_INT 17
88848: PUSH
88849: LD_INT 18
88851: PUSH
88852: LD_INT 19
88854: PUSH
88855: LD_INT 20
88857: PUSH
88858: LD_INT 21
88860: PUSH
88861: LD_INT 22
88863: PUSH
88864: LD_INT 23
88866: PUSH
88867: LD_INT 24
88869: PUSH
88870: LD_INT 25
88872: PUSH
88873: LD_INT 26
88875: PUSH
88876: LD_INT 28
88878: PUSH
88879: LD_INT 30
88881: PUSH
88882: LD_INT 31
88884: PUSH
88885: LD_INT 32
88887: PUSH
88888: LD_INT 36
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 101
88924: PUSH
88925: LD_INT 102
88927: PUSH
88928: LD_INT 103
88930: PUSH
88931: LD_INT 104
88933: PUSH
88934: LD_INT 105
88936: PUSH
88937: LD_INT 106
88939: PUSH
88940: LD_INT 107
88942: PUSH
88943: LD_INT 108
88945: PUSH
88946: LD_INT 109
88948: PUSH
88949: LD_INT 110
88951: PUSH
88952: LD_INT 111
88954: PUSH
88955: LD_INT 112
88957: PUSH
88958: LD_INT 114
88960: PUSH
88961: LD_INT 116
88963: PUSH
88964: LD_INT 117
88966: PUSH
88967: LD_INT 118
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: ST_TO_ADDR
88992: GO 90887
88994: LD_INT 11
88996: DOUBLE
88997: EQUAL
88998: IFTRUE 89002
89000: GO 89206
89002: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
89003: LD_ADDR_VAR 0 2
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: LD_INT 3
89013: PUSH
89014: LD_INT 4
89016: PUSH
89017: LD_INT 5
89019: PUSH
89020: LD_INT 6
89022: PUSH
89023: LD_INT 7
89025: PUSH
89026: LD_INT 8
89028: PUSH
89029: LD_INT 9
89031: PUSH
89032: LD_INT 10
89034: PUSH
89035: LD_INT 11
89037: PUSH
89038: LD_INT 12
89040: PUSH
89041: LD_INT 13
89043: PUSH
89044: LD_INT 14
89046: PUSH
89047: LD_INT 15
89049: PUSH
89050: LD_INT 16
89052: PUSH
89053: LD_INT 17
89055: PUSH
89056: LD_INT 18
89058: PUSH
89059: LD_INT 19
89061: PUSH
89062: LD_INT 20
89064: PUSH
89065: LD_INT 21
89067: PUSH
89068: LD_INT 22
89070: PUSH
89071: LD_INT 23
89073: PUSH
89074: LD_INT 24
89076: PUSH
89077: LD_INT 25
89079: PUSH
89080: LD_INT 26
89082: PUSH
89083: LD_INT 28
89085: PUSH
89086: LD_INT 30
89088: PUSH
89089: LD_INT 31
89091: PUSH
89092: LD_INT 32
89094: PUSH
89095: LD_INT 34
89097: PUSH
89098: LD_INT 36
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 101
89136: PUSH
89137: LD_INT 102
89139: PUSH
89140: LD_INT 103
89142: PUSH
89143: LD_INT 104
89145: PUSH
89146: LD_INT 105
89148: PUSH
89149: LD_INT 106
89151: PUSH
89152: LD_INT 107
89154: PUSH
89155: LD_INT 108
89157: PUSH
89158: LD_INT 109
89160: PUSH
89161: LD_INT 110
89163: PUSH
89164: LD_INT 111
89166: PUSH
89167: LD_INT 112
89169: PUSH
89170: LD_INT 114
89172: PUSH
89173: LD_INT 116
89175: PUSH
89176: LD_INT 117
89178: PUSH
89179: LD_INT 118
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: ST_TO_ADDR
89204: GO 90887
89206: LD_INT 12
89208: DOUBLE
89209: EQUAL
89210: IFTRUE 89214
89212: GO 89434
89214: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
89215: LD_ADDR_VAR 0 2
89219: PUSH
89220: LD_INT 1
89222: PUSH
89223: LD_INT 2
89225: PUSH
89226: LD_INT 3
89228: PUSH
89229: LD_INT 4
89231: PUSH
89232: LD_INT 5
89234: PUSH
89235: LD_INT 6
89237: PUSH
89238: LD_INT 7
89240: PUSH
89241: LD_INT 8
89243: PUSH
89244: LD_INT 9
89246: PUSH
89247: LD_INT 10
89249: PUSH
89250: LD_INT 11
89252: PUSH
89253: LD_INT 12
89255: PUSH
89256: LD_INT 13
89258: PUSH
89259: LD_INT 14
89261: PUSH
89262: LD_INT 15
89264: PUSH
89265: LD_INT 16
89267: PUSH
89268: LD_INT 17
89270: PUSH
89271: LD_INT 18
89273: PUSH
89274: LD_INT 19
89276: PUSH
89277: LD_INT 20
89279: PUSH
89280: LD_INT 21
89282: PUSH
89283: LD_INT 22
89285: PUSH
89286: LD_INT 23
89288: PUSH
89289: LD_INT 24
89291: PUSH
89292: LD_INT 25
89294: PUSH
89295: LD_INT 26
89297: PUSH
89298: LD_INT 27
89300: PUSH
89301: LD_INT 28
89303: PUSH
89304: LD_INT 30
89306: PUSH
89307: LD_INT 31
89309: PUSH
89310: LD_INT 32
89312: PUSH
89313: LD_INT 33
89315: PUSH
89316: LD_INT 34
89318: PUSH
89319: LD_INT 36
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 101
89360: PUSH
89361: LD_INT 102
89363: PUSH
89364: LD_INT 103
89366: PUSH
89367: LD_INT 104
89369: PUSH
89370: LD_INT 105
89372: PUSH
89373: LD_INT 106
89375: PUSH
89376: LD_INT 107
89378: PUSH
89379: LD_INT 108
89381: PUSH
89382: LD_INT 109
89384: PUSH
89385: LD_INT 110
89387: PUSH
89388: LD_INT 111
89390: PUSH
89391: LD_INT 112
89393: PUSH
89394: LD_INT 113
89396: PUSH
89397: LD_INT 114
89399: PUSH
89400: LD_INT 116
89402: PUSH
89403: LD_INT 117
89405: PUSH
89406: LD_INT 118
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: ST_TO_ADDR
89432: GO 90887
89434: LD_INT 13
89436: DOUBLE
89437: EQUAL
89438: IFTRUE 89442
89440: GO 89650
89442: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89443: LD_ADDR_VAR 0 2
89447: PUSH
89448: LD_INT 1
89450: PUSH
89451: LD_INT 2
89453: PUSH
89454: LD_INT 3
89456: PUSH
89457: LD_INT 4
89459: PUSH
89460: LD_INT 5
89462: PUSH
89463: LD_INT 8
89465: PUSH
89466: LD_INT 9
89468: PUSH
89469: LD_INT 10
89471: PUSH
89472: LD_INT 11
89474: PUSH
89475: LD_INT 12
89477: PUSH
89478: LD_INT 14
89480: PUSH
89481: LD_INT 15
89483: PUSH
89484: LD_INT 16
89486: PUSH
89487: LD_INT 17
89489: PUSH
89490: LD_INT 18
89492: PUSH
89493: LD_INT 19
89495: PUSH
89496: LD_INT 20
89498: PUSH
89499: LD_INT 21
89501: PUSH
89502: LD_INT 22
89504: PUSH
89505: LD_INT 23
89507: PUSH
89508: LD_INT 24
89510: PUSH
89511: LD_INT 25
89513: PUSH
89514: LD_INT 26
89516: PUSH
89517: LD_INT 27
89519: PUSH
89520: LD_INT 28
89522: PUSH
89523: LD_INT 30
89525: PUSH
89526: LD_INT 31
89528: PUSH
89529: LD_INT 32
89531: PUSH
89532: LD_INT 33
89534: PUSH
89535: LD_INT 34
89537: PUSH
89538: LD_INT 36
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 101
89576: PUSH
89577: LD_INT 102
89579: PUSH
89580: LD_INT 103
89582: PUSH
89583: LD_INT 104
89585: PUSH
89586: LD_INT 105
89588: PUSH
89589: LD_INT 106
89591: PUSH
89592: LD_INT 107
89594: PUSH
89595: LD_INT 108
89597: PUSH
89598: LD_INT 109
89600: PUSH
89601: LD_INT 110
89603: PUSH
89604: LD_INT 111
89606: PUSH
89607: LD_INT 112
89609: PUSH
89610: LD_INT 113
89612: PUSH
89613: LD_INT 114
89615: PUSH
89616: LD_INT 116
89618: PUSH
89619: LD_INT 117
89621: PUSH
89622: LD_INT 118
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: ST_TO_ADDR
89648: GO 90887
89650: LD_INT 14
89652: DOUBLE
89653: EQUAL
89654: IFTRUE 89658
89656: GO 89882
89658: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89659: LD_ADDR_VAR 0 2
89663: PUSH
89664: LD_INT 1
89666: PUSH
89667: LD_INT 2
89669: PUSH
89670: LD_INT 3
89672: PUSH
89673: LD_INT 4
89675: PUSH
89676: LD_INT 5
89678: PUSH
89679: LD_INT 6
89681: PUSH
89682: LD_INT 7
89684: PUSH
89685: LD_INT 8
89687: PUSH
89688: LD_INT 9
89690: PUSH
89691: LD_INT 10
89693: PUSH
89694: LD_INT 11
89696: PUSH
89697: LD_INT 12
89699: PUSH
89700: LD_INT 13
89702: PUSH
89703: LD_INT 14
89705: PUSH
89706: LD_INT 15
89708: PUSH
89709: LD_INT 16
89711: PUSH
89712: LD_INT 17
89714: PUSH
89715: LD_INT 18
89717: PUSH
89718: LD_INT 19
89720: PUSH
89721: LD_INT 20
89723: PUSH
89724: LD_INT 21
89726: PUSH
89727: LD_INT 22
89729: PUSH
89730: LD_INT 23
89732: PUSH
89733: LD_INT 24
89735: PUSH
89736: LD_INT 25
89738: PUSH
89739: LD_INT 26
89741: PUSH
89742: LD_INT 27
89744: PUSH
89745: LD_INT 28
89747: PUSH
89748: LD_INT 29
89750: PUSH
89751: LD_INT 30
89753: PUSH
89754: LD_INT 31
89756: PUSH
89757: LD_INT 32
89759: PUSH
89760: LD_INT 33
89762: PUSH
89763: LD_INT 34
89765: PUSH
89766: LD_INT 36
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: PUSH
89806: LD_INT 101
89808: PUSH
89809: LD_INT 102
89811: PUSH
89812: LD_INT 103
89814: PUSH
89815: LD_INT 104
89817: PUSH
89818: LD_INT 105
89820: PUSH
89821: LD_INT 106
89823: PUSH
89824: LD_INT 107
89826: PUSH
89827: LD_INT 108
89829: PUSH
89830: LD_INT 109
89832: PUSH
89833: LD_INT 110
89835: PUSH
89836: LD_INT 111
89838: PUSH
89839: LD_INT 112
89841: PUSH
89842: LD_INT 113
89844: PUSH
89845: LD_INT 114
89847: PUSH
89848: LD_INT 116
89850: PUSH
89851: LD_INT 117
89853: PUSH
89854: LD_INT 118
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: ST_TO_ADDR
89880: GO 90887
89882: LD_INT 15
89884: DOUBLE
89885: EQUAL
89886: IFTRUE 89890
89888: GO 90114
89890: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89891: LD_ADDR_VAR 0 2
89895: PUSH
89896: LD_INT 1
89898: PUSH
89899: LD_INT 2
89901: PUSH
89902: LD_INT 3
89904: PUSH
89905: LD_INT 4
89907: PUSH
89908: LD_INT 5
89910: PUSH
89911: LD_INT 6
89913: PUSH
89914: LD_INT 7
89916: PUSH
89917: LD_INT 8
89919: PUSH
89920: LD_INT 9
89922: PUSH
89923: LD_INT 10
89925: PUSH
89926: LD_INT 11
89928: PUSH
89929: LD_INT 12
89931: PUSH
89932: LD_INT 13
89934: PUSH
89935: LD_INT 14
89937: PUSH
89938: LD_INT 15
89940: PUSH
89941: LD_INT 16
89943: PUSH
89944: LD_INT 17
89946: PUSH
89947: LD_INT 18
89949: PUSH
89950: LD_INT 19
89952: PUSH
89953: LD_INT 20
89955: PUSH
89956: LD_INT 21
89958: PUSH
89959: LD_INT 22
89961: PUSH
89962: LD_INT 23
89964: PUSH
89965: LD_INT 24
89967: PUSH
89968: LD_INT 25
89970: PUSH
89971: LD_INT 26
89973: PUSH
89974: LD_INT 27
89976: PUSH
89977: LD_INT 28
89979: PUSH
89980: LD_INT 29
89982: PUSH
89983: LD_INT 30
89985: PUSH
89986: LD_INT 31
89988: PUSH
89989: LD_INT 32
89991: PUSH
89992: LD_INT 33
89994: PUSH
89995: LD_INT 34
89997: PUSH
89998: LD_INT 36
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 101
90040: PUSH
90041: LD_INT 102
90043: PUSH
90044: LD_INT 103
90046: PUSH
90047: LD_INT 104
90049: PUSH
90050: LD_INT 105
90052: PUSH
90053: LD_INT 106
90055: PUSH
90056: LD_INT 107
90058: PUSH
90059: LD_INT 108
90061: PUSH
90062: LD_INT 109
90064: PUSH
90065: LD_INT 110
90067: PUSH
90068: LD_INT 111
90070: PUSH
90071: LD_INT 112
90073: PUSH
90074: LD_INT 113
90076: PUSH
90077: LD_INT 114
90079: PUSH
90080: LD_INT 116
90082: PUSH
90083: LD_INT 117
90085: PUSH
90086: LD_INT 118
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: ST_TO_ADDR
90112: GO 90887
90114: LD_INT 16
90116: DOUBLE
90117: EQUAL
90118: IFTRUE 90122
90120: GO 90258
90122: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
90123: LD_ADDR_VAR 0 2
90127: PUSH
90128: LD_INT 2
90130: PUSH
90131: LD_INT 4
90133: PUSH
90134: LD_INT 5
90136: PUSH
90137: LD_INT 7
90139: PUSH
90140: LD_INT 11
90142: PUSH
90143: LD_INT 12
90145: PUSH
90146: LD_INT 15
90148: PUSH
90149: LD_INT 16
90151: PUSH
90152: LD_INT 20
90154: PUSH
90155: LD_INT 21
90157: PUSH
90158: LD_INT 22
90160: PUSH
90161: LD_INT 23
90163: PUSH
90164: LD_INT 25
90166: PUSH
90167: LD_INT 26
90169: PUSH
90170: LD_INT 30
90172: PUSH
90173: LD_INT 31
90175: PUSH
90176: LD_INT 32
90178: PUSH
90179: LD_INT 33
90181: PUSH
90182: LD_INT 34
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 101
90208: PUSH
90209: LD_INT 102
90211: PUSH
90212: LD_INT 103
90214: PUSH
90215: LD_INT 106
90217: PUSH
90218: LD_INT 108
90220: PUSH
90221: LD_INT 112
90223: PUSH
90224: LD_INT 113
90226: PUSH
90227: LD_INT 114
90229: PUSH
90230: LD_INT 116
90232: PUSH
90233: LD_INT 117
90235: PUSH
90236: LD_INT 118
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: ST_TO_ADDR
90256: GO 90887
90258: LD_INT 17
90260: DOUBLE
90261: EQUAL
90262: IFTRUE 90266
90264: GO 90490
90266: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
90267: LD_ADDR_VAR 0 2
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: LD_INT 2
90277: PUSH
90278: LD_INT 3
90280: PUSH
90281: LD_INT 4
90283: PUSH
90284: LD_INT 5
90286: PUSH
90287: LD_INT 6
90289: PUSH
90290: LD_INT 7
90292: PUSH
90293: LD_INT 8
90295: PUSH
90296: LD_INT 9
90298: PUSH
90299: LD_INT 10
90301: PUSH
90302: LD_INT 11
90304: PUSH
90305: LD_INT 12
90307: PUSH
90308: LD_INT 13
90310: PUSH
90311: LD_INT 14
90313: PUSH
90314: LD_INT 15
90316: PUSH
90317: LD_INT 16
90319: PUSH
90320: LD_INT 17
90322: PUSH
90323: LD_INT 18
90325: PUSH
90326: LD_INT 19
90328: PUSH
90329: LD_INT 20
90331: PUSH
90332: LD_INT 21
90334: PUSH
90335: LD_INT 22
90337: PUSH
90338: LD_INT 23
90340: PUSH
90341: LD_INT 24
90343: PUSH
90344: LD_INT 25
90346: PUSH
90347: LD_INT 26
90349: PUSH
90350: LD_INT 27
90352: PUSH
90353: LD_INT 28
90355: PUSH
90356: LD_INT 29
90358: PUSH
90359: LD_INT 30
90361: PUSH
90362: LD_INT 31
90364: PUSH
90365: LD_INT 32
90367: PUSH
90368: LD_INT 33
90370: PUSH
90371: LD_INT 34
90373: PUSH
90374: LD_INT 36
90376: PUSH
90377: EMPTY
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: PUSH
90414: LD_INT 101
90416: PUSH
90417: LD_INT 102
90419: PUSH
90420: LD_INT 103
90422: PUSH
90423: LD_INT 104
90425: PUSH
90426: LD_INT 105
90428: PUSH
90429: LD_INT 106
90431: PUSH
90432: LD_INT 107
90434: PUSH
90435: LD_INT 108
90437: PUSH
90438: LD_INT 109
90440: PUSH
90441: LD_INT 110
90443: PUSH
90444: LD_INT 111
90446: PUSH
90447: LD_INT 112
90449: PUSH
90450: LD_INT 113
90452: PUSH
90453: LD_INT 114
90455: PUSH
90456: LD_INT 116
90458: PUSH
90459: LD_INT 117
90461: PUSH
90462: LD_INT 118
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: ST_TO_ADDR
90488: GO 90887
90490: LD_INT 18
90492: DOUBLE
90493: EQUAL
90494: IFTRUE 90498
90496: GO 90646
90498: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90499: LD_ADDR_VAR 0 2
90503: PUSH
90504: LD_INT 2
90506: PUSH
90507: LD_INT 4
90509: PUSH
90510: LD_INT 5
90512: PUSH
90513: LD_INT 7
90515: PUSH
90516: LD_INT 11
90518: PUSH
90519: LD_INT 12
90521: PUSH
90522: LD_INT 15
90524: PUSH
90525: LD_INT 16
90527: PUSH
90528: LD_INT 20
90530: PUSH
90531: LD_INT 21
90533: PUSH
90534: LD_INT 22
90536: PUSH
90537: LD_INT 23
90539: PUSH
90540: LD_INT 25
90542: PUSH
90543: LD_INT 26
90545: PUSH
90546: LD_INT 30
90548: PUSH
90549: LD_INT 31
90551: PUSH
90552: LD_INT 32
90554: PUSH
90555: LD_INT 33
90557: PUSH
90558: LD_INT 34
90560: PUSH
90561: LD_INT 35
90563: PUSH
90564: LD_INT 36
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 101
90592: PUSH
90593: LD_INT 102
90595: PUSH
90596: LD_INT 103
90598: PUSH
90599: LD_INT 106
90601: PUSH
90602: LD_INT 108
90604: PUSH
90605: LD_INT 112
90607: PUSH
90608: LD_INT 113
90610: PUSH
90611: LD_INT 114
90613: PUSH
90614: LD_INT 115
90616: PUSH
90617: LD_INT 116
90619: PUSH
90620: LD_INT 117
90622: PUSH
90623: LD_INT 118
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: ST_TO_ADDR
90644: GO 90887
90646: LD_INT 19
90648: DOUBLE
90649: EQUAL
90650: IFTRUE 90654
90652: GO 90886
90654: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90655: LD_ADDR_VAR 0 2
90659: PUSH
90660: LD_INT 1
90662: PUSH
90663: LD_INT 2
90665: PUSH
90666: LD_INT 3
90668: PUSH
90669: LD_INT 4
90671: PUSH
90672: LD_INT 5
90674: PUSH
90675: LD_INT 6
90677: PUSH
90678: LD_INT 7
90680: PUSH
90681: LD_INT 8
90683: PUSH
90684: LD_INT 9
90686: PUSH
90687: LD_INT 10
90689: PUSH
90690: LD_INT 11
90692: PUSH
90693: LD_INT 12
90695: PUSH
90696: LD_INT 13
90698: PUSH
90699: LD_INT 14
90701: PUSH
90702: LD_INT 15
90704: PUSH
90705: LD_INT 16
90707: PUSH
90708: LD_INT 17
90710: PUSH
90711: LD_INT 18
90713: PUSH
90714: LD_INT 19
90716: PUSH
90717: LD_INT 20
90719: PUSH
90720: LD_INT 21
90722: PUSH
90723: LD_INT 22
90725: PUSH
90726: LD_INT 23
90728: PUSH
90729: LD_INT 24
90731: PUSH
90732: LD_INT 25
90734: PUSH
90735: LD_INT 26
90737: PUSH
90738: LD_INT 27
90740: PUSH
90741: LD_INT 28
90743: PUSH
90744: LD_INT 29
90746: PUSH
90747: LD_INT 30
90749: PUSH
90750: LD_INT 31
90752: PUSH
90753: LD_INT 32
90755: PUSH
90756: LD_INT 33
90758: PUSH
90759: LD_INT 34
90761: PUSH
90762: LD_INT 35
90764: PUSH
90765: LD_INT 36
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: PUSH
90806: LD_INT 101
90808: PUSH
90809: LD_INT 102
90811: PUSH
90812: LD_INT 103
90814: PUSH
90815: LD_INT 104
90817: PUSH
90818: LD_INT 105
90820: PUSH
90821: LD_INT 106
90823: PUSH
90824: LD_INT 107
90826: PUSH
90827: LD_INT 108
90829: PUSH
90830: LD_INT 109
90832: PUSH
90833: LD_INT 110
90835: PUSH
90836: LD_INT 111
90838: PUSH
90839: LD_INT 112
90841: PUSH
90842: LD_INT 113
90844: PUSH
90845: LD_INT 114
90847: PUSH
90848: LD_INT 115
90850: PUSH
90851: LD_INT 116
90853: PUSH
90854: LD_INT 117
90856: PUSH
90857: LD_INT 118
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: ST_TO_ADDR
90884: GO 90887
90886: POP
// end else
90887: GO 91118
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90889: LD_ADDR_VAR 0 2
90893: PUSH
90894: LD_INT 1
90896: PUSH
90897: LD_INT 2
90899: PUSH
90900: LD_INT 3
90902: PUSH
90903: LD_INT 4
90905: PUSH
90906: LD_INT 5
90908: PUSH
90909: LD_INT 6
90911: PUSH
90912: LD_INT 7
90914: PUSH
90915: LD_INT 8
90917: PUSH
90918: LD_INT 9
90920: PUSH
90921: LD_INT 10
90923: PUSH
90924: LD_INT 11
90926: PUSH
90927: LD_INT 12
90929: PUSH
90930: LD_INT 13
90932: PUSH
90933: LD_INT 14
90935: PUSH
90936: LD_INT 15
90938: PUSH
90939: LD_INT 16
90941: PUSH
90942: LD_INT 17
90944: PUSH
90945: LD_INT 18
90947: PUSH
90948: LD_INT 19
90950: PUSH
90951: LD_INT 20
90953: PUSH
90954: LD_INT 21
90956: PUSH
90957: LD_INT 22
90959: PUSH
90960: LD_INT 23
90962: PUSH
90963: LD_INT 24
90965: PUSH
90966: LD_INT 25
90968: PUSH
90969: LD_INT 26
90971: PUSH
90972: LD_INT 27
90974: PUSH
90975: LD_INT 28
90977: PUSH
90978: LD_INT 29
90980: PUSH
90981: LD_INT 30
90983: PUSH
90984: LD_INT 31
90986: PUSH
90987: LD_INT 32
90989: PUSH
90990: LD_INT 33
90992: PUSH
90993: LD_INT 34
90995: PUSH
90996: LD_INT 35
90998: PUSH
90999: LD_INT 36
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 101
91042: PUSH
91043: LD_INT 102
91045: PUSH
91046: LD_INT 103
91048: PUSH
91049: LD_INT 104
91051: PUSH
91052: LD_INT 105
91054: PUSH
91055: LD_INT 106
91057: PUSH
91058: LD_INT 107
91060: PUSH
91061: LD_INT 108
91063: PUSH
91064: LD_INT 109
91066: PUSH
91067: LD_INT 110
91069: PUSH
91070: LD_INT 111
91072: PUSH
91073: LD_INT 112
91075: PUSH
91076: LD_INT 113
91078: PUSH
91079: LD_INT 114
91081: PUSH
91082: LD_INT 115
91084: PUSH
91085: LD_INT 116
91087: PUSH
91088: LD_INT 117
91090: PUSH
91091: LD_INT 118
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: ST_TO_ADDR
// if result then
91118: LD_VAR 0 2
91122: IFFALSE 91908
// begin normal :=  ;
91124: LD_ADDR_VAR 0 5
91128: PUSH
91129: LD_STRING 
91131: ST_TO_ADDR
// hardcore :=  ;
91132: LD_ADDR_VAR 0 6
91136: PUSH
91137: LD_STRING 
91139: ST_TO_ADDR
// active :=  ;
91140: LD_ADDR_VAR 0 7
91144: PUSH
91145: LD_STRING 
91147: ST_TO_ADDR
// for i = 1 to normalCounter do
91148: LD_ADDR_VAR 0 8
91152: PUSH
91153: DOUBLE
91154: LD_INT 1
91156: DEC
91157: ST_TO_ADDR
91158: LD_EXP 97
91162: PUSH
91163: FOR_TO
91164: IFFALSE 91265
// begin tmp := 0 ;
91166: LD_ADDR_VAR 0 3
91170: PUSH
91171: LD_STRING 0
91173: ST_TO_ADDR
// if result [ 1 ] then
91174: LD_VAR 0 2
91178: PUSH
91179: LD_INT 1
91181: ARRAY
91182: IFFALSE 91247
// if result [ 1 ] [ 1 ] = i then
91184: LD_VAR 0 2
91188: PUSH
91189: LD_INT 1
91191: ARRAY
91192: PUSH
91193: LD_INT 1
91195: ARRAY
91196: PUSH
91197: LD_VAR 0 8
91201: EQUAL
91202: IFFALSE 91247
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91204: LD_ADDR_VAR 0 2
91208: PUSH
91209: LD_VAR 0 2
91213: PPUSH
91214: LD_INT 1
91216: PPUSH
91217: LD_VAR 0 2
91221: PUSH
91222: LD_INT 1
91224: ARRAY
91225: PPUSH
91226: LD_INT 1
91228: PPUSH
91229: CALL_OW 3
91233: PPUSH
91234: CALL_OW 1
91238: ST_TO_ADDR
// tmp := 1 ;
91239: LD_ADDR_VAR 0 3
91243: PUSH
91244: LD_STRING 1
91246: ST_TO_ADDR
// end ; normal := normal & tmp ;
91247: LD_ADDR_VAR 0 5
91251: PUSH
91252: LD_VAR 0 5
91256: PUSH
91257: LD_VAR 0 3
91261: STR
91262: ST_TO_ADDR
// end ;
91263: GO 91163
91265: POP
91266: POP
// for i = 1 to hardcoreCounter do
91267: LD_ADDR_VAR 0 8
91271: PUSH
91272: DOUBLE
91273: LD_INT 1
91275: DEC
91276: ST_TO_ADDR
91277: LD_EXP 98
91281: PUSH
91282: FOR_TO
91283: IFFALSE 91388
// begin tmp := 0 ;
91285: LD_ADDR_VAR 0 3
91289: PUSH
91290: LD_STRING 0
91292: ST_TO_ADDR
// if result [ 2 ] then
91293: LD_VAR 0 2
91297: PUSH
91298: LD_INT 2
91300: ARRAY
91301: IFFALSE 91370
// if result [ 2 ] [ 1 ] = 100 + i then
91303: LD_VAR 0 2
91307: PUSH
91308: LD_INT 2
91310: ARRAY
91311: PUSH
91312: LD_INT 1
91314: ARRAY
91315: PUSH
91316: LD_INT 100
91318: PUSH
91319: LD_VAR 0 8
91323: PLUS
91324: EQUAL
91325: IFFALSE 91370
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91327: LD_ADDR_VAR 0 2
91331: PUSH
91332: LD_VAR 0 2
91336: PPUSH
91337: LD_INT 2
91339: PPUSH
91340: LD_VAR 0 2
91344: PUSH
91345: LD_INT 2
91347: ARRAY
91348: PPUSH
91349: LD_INT 1
91351: PPUSH
91352: CALL_OW 3
91356: PPUSH
91357: CALL_OW 1
91361: ST_TO_ADDR
// tmp := 1 ;
91362: LD_ADDR_VAR 0 3
91366: PUSH
91367: LD_STRING 1
91369: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91370: LD_ADDR_VAR 0 6
91374: PUSH
91375: LD_VAR 0 6
91379: PUSH
91380: LD_VAR 0 3
91384: STR
91385: ST_TO_ADDR
// end ;
91386: GO 91282
91388: POP
91389: POP
// if isGameLoad then
91390: LD_VAR 0 1
91394: IFFALSE 91869
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91396: LD_ADDR_VAR 0 4
91400: PUSH
91401: LD_EXP 101
91405: PUSH
91406: LD_EXP 100
91410: PUSH
91411: LD_EXP 102
91415: PUSH
91416: LD_EXP 99
91420: PUSH
91421: LD_EXP 103
91425: PUSH
91426: LD_EXP 104
91430: PUSH
91431: LD_EXP 105
91435: PUSH
91436: LD_EXP 106
91440: PUSH
91441: LD_EXP 107
91445: PUSH
91446: LD_EXP 108
91450: PUSH
91451: LD_EXP 109
91455: PUSH
91456: LD_EXP 110
91460: PUSH
91461: LD_EXP 111
91465: PUSH
91466: LD_EXP 112
91470: PUSH
91471: LD_EXP 120
91475: PUSH
91476: LD_EXP 121
91480: PUSH
91481: LD_EXP 122
91485: PUSH
91486: LD_EXP 123
91490: PUSH
91491: LD_EXP 125
91495: PUSH
91496: LD_EXP 126
91500: PUSH
91501: LD_EXP 127
91505: PUSH
91506: LD_EXP 130
91510: PUSH
91511: LD_EXP 132
91515: PUSH
91516: LD_EXP 133
91520: PUSH
91521: LD_EXP 134
91525: PUSH
91526: LD_EXP 136
91530: PUSH
91531: LD_EXP 137
91535: PUSH
91536: LD_EXP 140
91540: PUSH
91541: LD_EXP 141
91545: PUSH
91546: LD_EXP 142
91550: PUSH
91551: LD_EXP 143
91555: PUSH
91556: LD_EXP 144
91560: PUSH
91561: LD_EXP 145
91565: PUSH
91566: LD_EXP 146
91570: PUSH
91571: LD_EXP 147
91575: PUSH
91576: LD_EXP 148
91580: PUSH
91581: LD_EXP 113
91585: PUSH
91586: LD_EXP 114
91590: PUSH
91591: LD_EXP 117
91595: PUSH
91596: LD_EXP 118
91600: PUSH
91601: LD_EXP 119
91605: PUSH
91606: LD_EXP 115
91610: PUSH
91611: LD_EXP 116
91615: PUSH
91616: LD_EXP 124
91620: PUSH
91621: LD_EXP 128
91625: PUSH
91626: LD_EXP 129
91630: PUSH
91631: LD_EXP 131
91635: PUSH
91636: LD_EXP 135
91640: PUSH
91641: LD_EXP 138
91645: PUSH
91646: LD_EXP 139
91650: PUSH
91651: LD_EXP 149
91655: PUSH
91656: LD_EXP 150
91660: PUSH
91661: LD_EXP 151
91665: PUSH
91666: LD_EXP 152
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: ST_TO_ADDR
// tmp :=  ;
91727: LD_ADDR_VAR 0 3
91731: PUSH
91732: LD_STRING 
91734: ST_TO_ADDR
// for i = 1 to normalCounter do
91735: LD_ADDR_VAR 0 8
91739: PUSH
91740: DOUBLE
91741: LD_INT 1
91743: DEC
91744: ST_TO_ADDR
91745: LD_EXP 97
91749: PUSH
91750: FOR_TO
91751: IFFALSE 91787
// begin if flags [ i ] then
91753: LD_VAR 0 4
91757: PUSH
91758: LD_VAR 0 8
91762: ARRAY
91763: IFFALSE 91785
// tmp := tmp & i & ; ;
91765: LD_ADDR_VAR 0 3
91769: PUSH
91770: LD_VAR 0 3
91774: PUSH
91775: LD_VAR 0 8
91779: STR
91780: PUSH
91781: LD_STRING ;
91783: STR
91784: ST_TO_ADDR
// end ;
91785: GO 91750
91787: POP
91788: POP
// for i = 1 to hardcoreCounter do
91789: LD_ADDR_VAR 0 8
91793: PUSH
91794: DOUBLE
91795: LD_INT 1
91797: DEC
91798: ST_TO_ADDR
91799: LD_EXP 98
91803: PUSH
91804: FOR_TO
91805: IFFALSE 91851
// begin if flags [ normalCounter + i ] then
91807: LD_VAR 0 4
91811: PUSH
91812: LD_EXP 97
91816: PUSH
91817: LD_VAR 0 8
91821: PLUS
91822: ARRAY
91823: IFFALSE 91849
// tmp := tmp & ( 100 + i ) & ; ;
91825: LD_ADDR_VAR 0 3
91829: PUSH
91830: LD_VAR 0 3
91834: PUSH
91835: LD_INT 100
91837: PUSH
91838: LD_VAR 0 8
91842: PLUS
91843: STR
91844: PUSH
91845: LD_STRING ;
91847: STR
91848: ST_TO_ADDR
// end ;
91849: GO 91804
91851: POP
91852: POP
// if tmp then
91853: LD_VAR 0 3
91857: IFFALSE 91869
// active := tmp ;
91859: LD_ADDR_VAR 0 7
91863: PUSH
91864: LD_VAR 0 3
91868: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91869: LD_STRING getStreamItemsFromMission("
91871: PUSH
91872: LD_VAR 0 5
91876: STR
91877: PUSH
91878: LD_STRING ","
91880: STR
91881: PUSH
91882: LD_VAR 0 6
91886: STR
91887: PUSH
91888: LD_STRING ","
91890: STR
91891: PUSH
91892: LD_VAR 0 7
91896: STR
91897: PUSH
91898: LD_STRING ")
91900: STR
91901: PPUSH
91902: CALL_OW 559
// end else
91906: GO 91915
// ToLua ( getStreamItemsFromMission("","","") ) ;
91908: LD_STRING getStreamItemsFromMission("","","")
91910: PPUSH
91911: CALL_OW 559
// end ;
91915: LD_VAR 0 2
91919: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91920: LD_EXP 96
91924: PUSH
91925: LD_EXP 101
91929: AND
91930: IFFALSE 92054
91932: GO 91934
91934: DISABLE
91935: LD_INT 0
91937: PPUSH
91938: PPUSH
// begin enable ;
91939: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91940: LD_ADDR_VAR 0 2
91944: PUSH
91945: LD_INT 22
91947: PUSH
91948: LD_OWVAR 2
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: PUSH
91957: LD_INT 2
91959: PUSH
91960: LD_INT 34
91962: PUSH
91963: LD_INT 7
91965: PUSH
91966: EMPTY
91967: LIST
91968: LIST
91969: PUSH
91970: LD_INT 34
91972: PUSH
91973: LD_INT 45
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 34
91982: PUSH
91983: LD_INT 28
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: PUSH
91990: LD_INT 34
91992: PUSH
91993: LD_INT 47
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PPUSH
92011: CALL_OW 69
92015: ST_TO_ADDR
// if not tmp then
92016: LD_VAR 0 2
92020: NOT
92021: IFFALSE 92025
// exit ;
92023: GO 92054
// for i in tmp do
92025: LD_ADDR_VAR 0 1
92029: PUSH
92030: LD_VAR 0 2
92034: PUSH
92035: FOR_IN
92036: IFFALSE 92052
// begin SetLives ( i , 0 ) ;
92038: LD_VAR 0 1
92042: PPUSH
92043: LD_INT 0
92045: PPUSH
92046: CALL_OW 234
// end ;
92050: GO 92035
92052: POP
92053: POP
// end ;
92054: PPOPN 2
92056: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92057: LD_EXP 96
92061: PUSH
92062: LD_EXP 102
92066: AND
92067: IFFALSE 92151
92069: GO 92071
92071: DISABLE
92072: LD_INT 0
92074: PPUSH
92075: PPUSH
// begin enable ;
92076: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92077: LD_ADDR_VAR 0 2
92081: PUSH
92082: LD_INT 22
92084: PUSH
92085: LD_OWVAR 2
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 32
92096: PUSH
92097: LD_INT 3
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PPUSH
92108: CALL_OW 69
92112: ST_TO_ADDR
// if not tmp then
92113: LD_VAR 0 2
92117: NOT
92118: IFFALSE 92122
// exit ;
92120: GO 92151
// for i in tmp do
92122: LD_ADDR_VAR 0 1
92126: PUSH
92127: LD_VAR 0 2
92131: PUSH
92132: FOR_IN
92133: IFFALSE 92149
// begin SetLives ( i , 0 ) ;
92135: LD_VAR 0 1
92139: PPUSH
92140: LD_INT 0
92142: PPUSH
92143: CALL_OW 234
// end ;
92147: GO 92132
92149: POP
92150: POP
// end ;
92151: PPOPN 2
92153: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92154: LD_EXP 96
92158: PUSH
92159: LD_EXP 99
92163: AND
92164: IFFALSE 92257
92166: GO 92168
92168: DISABLE
92169: LD_INT 0
92171: PPUSH
// begin enable ;
92172: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92173: LD_ADDR_VAR 0 1
92177: PUSH
92178: LD_INT 22
92180: PUSH
92181: LD_OWVAR 2
92185: PUSH
92186: EMPTY
92187: LIST
92188: LIST
92189: PUSH
92190: LD_INT 2
92192: PUSH
92193: LD_INT 25
92195: PUSH
92196: LD_INT 5
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 25
92205: PUSH
92206: LD_INT 9
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 25
92215: PUSH
92216: LD_INT 8
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PPUSH
92233: CALL_OW 69
92237: PUSH
92238: FOR_IN
92239: IFFALSE 92255
// begin SetClass ( i , 1 ) ;
92241: LD_VAR 0 1
92245: PPUSH
92246: LD_INT 1
92248: PPUSH
92249: CALL_OW 336
// end ;
92253: GO 92238
92255: POP
92256: POP
// end ;
92257: PPOPN 1
92259: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92260: LD_EXP 96
92264: PUSH
92265: LD_EXP 100
92269: AND
92270: PUSH
92271: LD_OWVAR 65
92275: PUSH
92276: LD_INT 7
92278: LESS
92279: AND
92280: IFFALSE 92294
92282: GO 92284
92284: DISABLE
// begin enable ;
92285: ENABLE
// game_speed := 7 ;
92286: LD_ADDR_OWVAR 65
92290: PUSH
92291: LD_INT 7
92293: ST_TO_ADDR
// end ;
92294: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92295: LD_EXP 96
92299: PUSH
92300: LD_EXP 103
92304: AND
92305: IFFALSE 92507
92307: GO 92309
92309: DISABLE
92310: LD_INT 0
92312: PPUSH
92313: PPUSH
92314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92315: LD_ADDR_VAR 0 3
92319: PUSH
92320: LD_INT 81
92322: PUSH
92323: LD_OWVAR 2
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 21
92334: PUSH
92335: LD_INT 1
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PPUSH
92346: CALL_OW 69
92350: ST_TO_ADDR
// if not tmp then
92351: LD_VAR 0 3
92355: NOT
92356: IFFALSE 92360
// exit ;
92358: GO 92507
// if tmp > 5 then
92360: LD_VAR 0 3
92364: PUSH
92365: LD_INT 5
92367: GREATER
92368: IFFALSE 92380
// k := 5 else
92370: LD_ADDR_VAR 0 2
92374: PUSH
92375: LD_INT 5
92377: ST_TO_ADDR
92378: GO 92390
// k := tmp ;
92380: LD_ADDR_VAR 0 2
92384: PUSH
92385: LD_VAR 0 3
92389: ST_TO_ADDR
// for i := 1 to k do
92390: LD_ADDR_VAR 0 1
92394: PUSH
92395: DOUBLE
92396: LD_INT 1
92398: DEC
92399: ST_TO_ADDR
92400: LD_VAR 0 2
92404: PUSH
92405: FOR_TO
92406: IFFALSE 92505
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92408: LD_VAR 0 3
92412: PUSH
92413: LD_VAR 0 1
92417: ARRAY
92418: PPUSH
92419: LD_VAR 0 1
92423: PUSH
92424: LD_INT 4
92426: MOD
92427: PUSH
92428: LD_INT 1
92430: PLUS
92431: PPUSH
92432: CALL_OW 259
92436: PUSH
92437: LD_INT 10
92439: LESS
92440: IFFALSE 92503
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92442: LD_VAR 0 3
92446: PUSH
92447: LD_VAR 0 1
92451: ARRAY
92452: PPUSH
92453: LD_VAR 0 1
92457: PUSH
92458: LD_INT 4
92460: MOD
92461: PUSH
92462: LD_INT 1
92464: PLUS
92465: PPUSH
92466: LD_VAR 0 3
92470: PUSH
92471: LD_VAR 0 1
92475: ARRAY
92476: PPUSH
92477: LD_VAR 0 1
92481: PUSH
92482: LD_INT 4
92484: MOD
92485: PUSH
92486: LD_INT 1
92488: PLUS
92489: PPUSH
92490: CALL_OW 259
92494: PUSH
92495: LD_INT 1
92497: PLUS
92498: PPUSH
92499: CALL_OW 237
92503: GO 92405
92505: POP
92506: POP
// end ;
92507: PPOPN 3
92509: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92510: LD_EXP 96
92514: PUSH
92515: LD_EXP 104
92519: AND
92520: IFFALSE 92540
92522: GO 92524
92524: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92525: LD_INT 4
92527: PPUSH
92528: LD_OWVAR 2
92532: PPUSH
92533: LD_INT 0
92535: PPUSH
92536: CALL_OW 324
92540: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92541: LD_EXP 96
92545: PUSH
92546: LD_EXP 133
92550: AND
92551: IFFALSE 92571
92553: GO 92555
92555: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92556: LD_INT 19
92558: PPUSH
92559: LD_OWVAR 2
92563: PPUSH
92564: LD_INT 0
92566: PPUSH
92567: CALL_OW 324
92571: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92572: LD_EXP 96
92576: PUSH
92577: LD_EXP 105
92581: AND
92582: IFFALSE 92684
92584: GO 92586
92586: DISABLE
92587: LD_INT 0
92589: PPUSH
92590: PPUSH
// begin enable ;
92591: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92592: LD_ADDR_VAR 0 2
92596: PUSH
92597: LD_INT 22
92599: PUSH
92600: LD_OWVAR 2
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 2
92611: PUSH
92612: LD_INT 34
92614: PUSH
92615: LD_INT 11
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 34
92624: PUSH
92625: LD_INT 30
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: LIST
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PPUSH
92641: CALL_OW 69
92645: ST_TO_ADDR
// if not tmp then
92646: LD_VAR 0 2
92650: NOT
92651: IFFALSE 92655
// exit ;
92653: GO 92684
// for i in tmp do
92655: LD_ADDR_VAR 0 1
92659: PUSH
92660: LD_VAR 0 2
92664: PUSH
92665: FOR_IN
92666: IFFALSE 92682
// begin SetLives ( i , 0 ) ;
92668: LD_VAR 0 1
92672: PPUSH
92673: LD_INT 0
92675: PPUSH
92676: CALL_OW 234
// end ;
92680: GO 92665
92682: POP
92683: POP
// end ;
92684: PPOPN 2
92686: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92687: LD_EXP 96
92691: PUSH
92692: LD_EXP 106
92696: AND
92697: IFFALSE 92717
92699: GO 92701
92701: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92702: LD_INT 32
92704: PPUSH
92705: LD_OWVAR 2
92709: PPUSH
92710: LD_INT 0
92712: PPUSH
92713: CALL_OW 324
92717: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92718: LD_EXP 96
92722: PUSH
92723: LD_EXP 107
92727: AND
92728: IFFALSE 92909
92730: GO 92732
92732: DISABLE
92733: LD_INT 0
92735: PPUSH
92736: PPUSH
92737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92738: LD_ADDR_VAR 0 2
92742: PUSH
92743: LD_INT 22
92745: PUSH
92746: LD_OWVAR 2
92750: PUSH
92751: EMPTY
92752: LIST
92753: LIST
92754: PUSH
92755: LD_INT 33
92757: PUSH
92758: LD_INT 3
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PPUSH
92769: CALL_OW 69
92773: ST_TO_ADDR
// if not tmp then
92774: LD_VAR 0 2
92778: NOT
92779: IFFALSE 92783
// exit ;
92781: GO 92909
// side := 0 ;
92783: LD_ADDR_VAR 0 3
92787: PUSH
92788: LD_INT 0
92790: ST_TO_ADDR
// for i := 1 to 8 do
92791: LD_ADDR_VAR 0 1
92795: PUSH
92796: DOUBLE
92797: LD_INT 1
92799: DEC
92800: ST_TO_ADDR
92801: LD_INT 8
92803: PUSH
92804: FOR_TO
92805: IFFALSE 92853
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92807: LD_OWVAR 2
92811: PUSH
92812: LD_VAR 0 1
92816: NONEQUAL
92817: PUSH
92818: LD_OWVAR 2
92822: PPUSH
92823: LD_VAR 0 1
92827: PPUSH
92828: CALL_OW 81
92832: PUSH
92833: LD_INT 2
92835: EQUAL
92836: AND
92837: IFFALSE 92851
// begin side := i ;
92839: LD_ADDR_VAR 0 3
92843: PUSH
92844: LD_VAR 0 1
92848: ST_TO_ADDR
// break ;
92849: GO 92853
// end ;
92851: GO 92804
92853: POP
92854: POP
// if not side then
92855: LD_VAR 0 3
92859: NOT
92860: IFFALSE 92864
// exit ;
92862: GO 92909
// for i := 1 to tmp do
92864: LD_ADDR_VAR 0 1
92868: PUSH
92869: DOUBLE
92870: LD_INT 1
92872: DEC
92873: ST_TO_ADDR
92874: LD_VAR 0 2
92878: PUSH
92879: FOR_TO
92880: IFFALSE 92907
// if Prob ( 60 ) then
92882: LD_INT 60
92884: PPUSH
92885: CALL_OW 13
92889: IFFALSE 92905
// SetSide ( i , side ) ;
92891: LD_VAR 0 1
92895: PPUSH
92896: LD_VAR 0 3
92900: PPUSH
92901: CALL_OW 235
92905: GO 92879
92907: POP
92908: POP
// end ;
92909: PPOPN 3
92911: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92912: LD_EXP 96
92916: PUSH
92917: LD_EXP 109
92921: AND
92922: IFFALSE 93041
92924: GO 92926
92926: DISABLE
92927: LD_INT 0
92929: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92930: LD_ADDR_VAR 0 1
92934: PUSH
92935: LD_INT 22
92937: PUSH
92938: LD_OWVAR 2
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PUSH
92947: LD_INT 21
92949: PUSH
92950: LD_INT 1
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 3
92959: PUSH
92960: LD_INT 23
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: EMPTY
92967: LIST
92968: LIST
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: LIST
92978: PPUSH
92979: CALL_OW 69
92983: PUSH
92984: FOR_IN
92985: IFFALSE 93039
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92987: LD_VAR 0 1
92991: PPUSH
92992: CALL_OW 257
92996: PUSH
92997: LD_INT 1
92999: PUSH
93000: LD_INT 2
93002: PUSH
93003: LD_INT 3
93005: PUSH
93006: LD_INT 4
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: IN
93015: IFFALSE 93037
// SetClass ( un , rand ( 1 , 4 ) ) ;
93017: LD_VAR 0 1
93021: PPUSH
93022: LD_INT 1
93024: PPUSH
93025: LD_INT 4
93027: PPUSH
93028: CALL_OW 12
93032: PPUSH
93033: CALL_OW 336
93037: GO 92984
93039: POP
93040: POP
// end ;
93041: PPOPN 1
93043: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93044: LD_EXP 96
93048: PUSH
93049: LD_EXP 108
93053: AND
93054: IFFALSE 93133
93056: GO 93058
93058: DISABLE
93059: LD_INT 0
93061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93062: LD_ADDR_VAR 0 1
93066: PUSH
93067: LD_INT 22
93069: PUSH
93070: LD_OWVAR 2
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 21
93081: PUSH
93082: LD_INT 3
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PPUSH
93093: CALL_OW 69
93097: ST_TO_ADDR
// if not tmp then
93098: LD_VAR 0 1
93102: NOT
93103: IFFALSE 93107
// exit ;
93105: GO 93133
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93107: LD_VAR 0 1
93111: PUSH
93112: LD_INT 1
93114: PPUSH
93115: LD_VAR 0 1
93119: PPUSH
93120: CALL_OW 12
93124: ARRAY
93125: PPUSH
93126: LD_INT 100
93128: PPUSH
93129: CALL_OW 234
// end ;
93133: PPOPN 1
93135: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93136: LD_EXP 96
93140: PUSH
93141: LD_EXP 110
93145: AND
93146: IFFALSE 93244
93148: GO 93150
93150: DISABLE
93151: LD_INT 0
93153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93154: LD_ADDR_VAR 0 1
93158: PUSH
93159: LD_INT 22
93161: PUSH
93162: LD_OWVAR 2
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 21
93173: PUSH
93174: LD_INT 1
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PPUSH
93185: CALL_OW 69
93189: ST_TO_ADDR
// if not tmp then
93190: LD_VAR 0 1
93194: NOT
93195: IFFALSE 93199
// exit ;
93197: GO 93244
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93199: LD_VAR 0 1
93203: PUSH
93204: LD_INT 1
93206: PPUSH
93207: LD_VAR 0 1
93211: PPUSH
93212: CALL_OW 12
93216: ARRAY
93217: PPUSH
93218: LD_INT 1
93220: PPUSH
93221: LD_INT 4
93223: PPUSH
93224: CALL_OW 12
93228: PPUSH
93229: LD_INT 3000
93231: PPUSH
93232: LD_INT 9000
93234: PPUSH
93235: CALL_OW 12
93239: PPUSH
93240: CALL_OW 492
// end ;
93244: PPOPN 1
93246: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93247: LD_EXP 96
93251: PUSH
93252: LD_EXP 111
93256: AND
93257: IFFALSE 93277
93259: GO 93261
93261: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93262: LD_INT 1
93264: PPUSH
93265: LD_OWVAR 2
93269: PPUSH
93270: LD_INT 0
93272: PPUSH
93273: CALL_OW 324
93277: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93278: LD_EXP 96
93282: PUSH
93283: LD_EXP 112
93287: AND
93288: IFFALSE 93371
93290: GO 93292
93292: DISABLE
93293: LD_INT 0
93295: PPUSH
93296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93297: LD_ADDR_VAR 0 2
93301: PUSH
93302: LD_INT 22
93304: PUSH
93305: LD_OWVAR 2
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 21
93316: PUSH
93317: LD_INT 3
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PPUSH
93328: CALL_OW 69
93332: ST_TO_ADDR
// if not tmp then
93333: LD_VAR 0 2
93337: NOT
93338: IFFALSE 93342
// exit ;
93340: GO 93371
// for i in tmp do
93342: LD_ADDR_VAR 0 1
93346: PUSH
93347: LD_VAR 0 2
93351: PUSH
93352: FOR_IN
93353: IFFALSE 93369
// SetBLevel ( i , 10 ) ;
93355: LD_VAR 0 1
93359: PPUSH
93360: LD_INT 10
93362: PPUSH
93363: CALL_OW 241
93367: GO 93352
93369: POP
93370: POP
// end ;
93371: PPOPN 2
93373: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93374: LD_EXP 96
93378: PUSH
93379: LD_EXP 113
93383: AND
93384: IFFALSE 93495
93386: GO 93388
93388: DISABLE
93389: LD_INT 0
93391: PPUSH
93392: PPUSH
93393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93394: LD_ADDR_VAR 0 3
93398: PUSH
93399: LD_INT 22
93401: PUSH
93402: LD_OWVAR 2
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 25
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PPUSH
93425: CALL_OW 69
93429: ST_TO_ADDR
// if not tmp then
93430: LD_VAR 0 3
93434: NOT
93435: IFFALSE 93439
// exit ;
93437: GO 93495
// un := tmp [ rand ( 1 , tmp ) ] ;
93439: LD_ADDR_VAR 0 2
93443: PUSH
93444: LD_VAR 0 3
93448: PUSH
93449: LD_INT 1
93451: PPUSH
93452: LD_VAR 0 3
93456: PPUSH
93457: CALL_OW 12
93461: ARRAY
93462: ST_TO_ADDR
// if Crawls ( un ) then
93463: LD_VAR 0 2
93467: PPUSH
93468: CALL_OW 318
93472: IFFALSE 93483
// ComWalk ( un ) ;
93474: LD_VAR 0 2
93478: PPUSH
93479: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93483: LD_VAR 0 2
93487: PPUSH
93488: LD_INT 5
93490: PPUSH
93491: CALL_OW 336
// end ;
93495: PPOPN 3
93497: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93498: LD_EXP 96
93502: PUSH
93503: LD_EXP 114
93507: AND
93508: PUSH
93509: LD_OWVAR 67
93513: PUSH
93514: LD_INT 4
93516: LESS
93517: AND
93518: IFFALSE 93537
93520: GO 93522
93522: DISABLE
// begin Difficulty := Difficulty + 1 ;
93523: LD_ADDR_OWVAR 67
93527: PUSH
93528: LD_OWVAR 67
93532: PUSH
93533: LD_INT 1
93535: PLUS
93536: ST_TO_ADDR
// end ;
93537: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93538: LD_EXP 96
93542: PUSH
93543: LD_EXP 115
93547: AND
93548: IFFALSE 93651
93550: GO 93552
93552: DISABLE
93553: LD_INT 0
93555: PPUSH
// begin for i := 1 to 5 do
93556: LD_ADDR_VAR 0 1
93560: PUSH
93561: DOUBLE
93562: LD_INT 1
93564: DEC
93565: ST_TO_ADDR
93566: LD_INT 5
93568: PUSH
93569: FOR_TO
93570: IFFALSE 93649
// begin uc_nation := nation_nature ;
93572: LD_ADDR_OWVAR 21
93576: PUSH
93577: LD_INT 0
93579: ST_TO_ADDR
// uc_side := 0 ;
93580: LD_ADDR_OWVAR 20
93584: PUSH
93585: LD_INT 0
93587: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93588: LD_ADDR_OWVAR 29
93592: PUSH
93593: LD_INT 12
93595: PUSH
93596: LD_INT 12
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: ST_TO_ADDR
// hc_agressivity := 20 ;
93603: LD_ADDR_OWVAR 35
93607: PUSH
93608: LD_INT 20
93610: ST_TO_ADDR
// hc_class := class_tiger ;
93611: LD_ADDR_OWVAR 28
93615: PUSH
93616: LD_INT 14
93618: ST_TO_ADDR
// hc_gallery :=  ;
93619: LD_ADDR_OWVAR 33
93623: PUSH
93624: LD_STRING 
93626: ST_TO_ADDR
// hc_name :=  ;
93627: LD_ADDR_OWVAR 26
93631: PUSH
93632: LD_STRING 
93634: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93635: CALL_OW 44
93639: PPUSH
93640: LD_INT 0
93642: PPUSH
93643: CALL_OW 51
// end ;
93647: GO 93569
93649: POP
93650: POP
// end ;
93651: PPOPN 1
93653: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93654: LD_EXP 96
93658: PUSH
93659: LD_EXP 116
93663: AND
93664: IFFALSE 93673
93666: GO 93668
93668: DISABLE
// StreamSibBomb ;
93669: CALL 93674 0 0
93673: END
// export function StreamSibBomb ; var i , x , y ; begin
93674: LD_INT 0
93676: PPUSH
93677: PPUSH
93678: PPUSH
93679: PPUSH
// result := false ;
93680: LD_ADDR_VAR 0 1
93684: PUSH
93685: LD_INT 0
93687: ST_TO_ADDR
// for i := 1 to 16 do
93688: LD_ADDR_VAR 0 2
93692: PUSH
93693: DOUBLE
93694: LD_INT 1
93696: DEC
93697: ST_TO_ADDR
93698: LD_INT 16
93700: PUSH
93701: FOR_TO
93702: IFFALSE 93901
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93704: LD_ADDR_VAR 0 3
93708: PUSH
93709: LD_INT 10
93711: PUSH
93712: LD_INT 20
93714: PUSH
93715: LD_INT 30
93717: PUSH
93718: LD_INT 40
93720: PUSH
93721: LD_INT 50
93723: PUSH
93724: LD_INT 60
93726: PUSH
93727: LD_INT 70
93729: PUSH
93730: LD_INT 80
93732: PUSH
93733: LD_INT 90
93735: PUSH
93736: LD_INT 100
93738: PUSH
93739: LD_INT 110
93741: PUSH
93742: LD_INT 120
93744: PUSH
93745: LD_INT 130
93747: PUSH
93748: LD_INT 140
93750: PUSH
93751: LD_INT 150
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: PUSH
93771: LD_INT 1
93773: PPUSH
93774: LD_INT 15
93776: PPUSH
93777: CALL_OW 12
93781: ARRAY
93782: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93783: LD_ADDR_VAR 0 4
93787: PUSH
93788: LD_INT 10
93790: PUSH
93791: LD_INT 20
93793: PUSH
93794: LD_INT 30
93796: PUSH
93797: LD_INT 40
93799: PUSH
93800: LD_INT 50
93802: PUSH
93803: LD_INT 60
93805: PUSH
93806: LD_INT 70
93808: PUSH
93809: LD_INT 80
93811: PUSH
93812: LD_INT 90
93814: PUSH
93815: LD_INT 100
93817: PUSH
93818: LD_INT 110
93820: PUSH
93821: LD_INT 120
93823: PUSH
93824: LD_INT 130
93826: PUSH
93827: LD_INT 140
93829: PUSH
93830: LD_INT 150
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 1
93852: PPUSH
93853: LD_INT 15
93855: PPUSH
93856: CALL_OW 12
93860: ARRAY
93861: ST_TO_ADDR
// if ValidHex ( x , y ) then
93862: LD_VAR 0 3
93866: PPUSH
93867: LD_VAR 0 4
93871: PPUSH
93872: CALL_OW 488
93876: IFFALSE 93899
// begin result := [ x , y ] ;
93878: LD_ADDR_VAR 0 1
93882: PUSH
93883: LD_VAR 0 3
93887: PUSH
93888: LD_VAR 0 4
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: ST_TO_ADDR
// break ;
93897: GO 93901
// end ; end ;
93899: GO 93701
93901: POP
93902: POP
// if result then
93903: LD_VAR 0 1
93907: IFFALSE 93967
// begin ToLua ( playSibBomb() ) ;
93909: LD_STRING playSibBomb()
93911: PPUSH
93912: CALL_OW 559
// wait ( 0 0$14 ) ;
93916: LD_INT 490
93918: PPUSH
93919: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93923: LD_VAR 0 1
93927: PUSH
93928: LD_INT 1
93930: ARRAY
93931: PPUSH
93932: LD_VAR 0 1
93936: PUSH
93937: LD_INT 2
93939: ARRAY
93940: PPUSH
93941: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93945: LD_VAR 0 1
93949: PUSH
93950: LD_INT 1
93952: ARRAY
93953: PPUSH
93954: LD_VAR 0 1
93958: PUSH
93959: LD_INT 2
93961: ARRAY
93962: PPUSH
93963: CALL_OW 429
// end ; end ;
93967: LD_VAR 0 1
93971: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93972: LD_EXP 96
93976: PUSH
93977: LD_EXP 118
93981: AND
93982: IFFALSE 93994
93984: GO 93986
93986: DISABLE
// YouLost (  ) ;
93987: LD_STRING 
93989: PPUSH
93990: CALL_OW 104
93994: END
// every 0 0$1 trigger StreamModeActive and sFog do
93995: LD_EXP 96
93999: PUSH
94000: LD_EXP 117
94004: AND
94005: IFFALSE 94019
94007: GO 94009
94009: DISABLE
// FogOff ( your_side ) ;
94010: LD_OWVAR 2
94014: PPUSH
94015: CALL_OW 344
94019: END
// every 0 0$1 trigger StreamModeActive and sSun do
94020: LD_EXP 96
94024: PUSH
94025: LD_EXP 119
94029: AND
94030: IFFALSE 94058
94032: GO 94034
94034: DISABLE
// begin solar_recharge_percent := 0 ;
94035: LD_ADDR_OWVAR 79
94039: PUSH
94040: LD_INT 0
94042: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94043: LD_INT 10500
94045: PPUSH
94046: CALL_OW 67
// solar_recharge_percent := 100 ;
94050: LD_ADDR_OWVAR 79
94054: PUSH
94055: LD_INT 100
94057: ST_TO_ADDR
// end ;
94058: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94059: LD_EXP 96
94063: PUSH
94064: LD_EXP 120
94068: AND
94069: IFFALSE 94308
94071: GO 94073
94073: DISABLE
94074: LD_INT 0
94076: PPUSH
94077: PPUSH
94078: PPUSH
// begin tmp := [ ] ;
94079: LD_ADDR_VAR 0 3
94083: PUSH
94084: EMPTY
94085: ST_TO_ADDR
// for i := 1 to 6 do
94086: LD_ADDR_VAR 0 1
94090: PUSH
94091: DOUBLE
94092: LD_INT 1
94094: DEC
94095: ST_TO_ADDR
94096: LD_INT 6
94098: PUSH
94099: FOR_TO
94100: IFFALSE 94205
// begin uc_nation := nation_nature ;
94102: LD_ADDR_OWVAR 21
94106: PUSH
94107: LD_INT 0
94109: ST_TO_ADDR
// uc_side := 0 ;
94110: LD_ADDR_OWVAR 20
94114: PUSH
94115: LD_INT 0
94117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94118: LD_ADDR_OWVAR 29
94122: PUSH
94123: LD_INT 12
94125: PUSH
94126: LD_INT 12
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: ST_TO_ADDR
// hc_agressivity := 20 ;
94133: LD_ADDR_OWVAR 35
94137: PUSH
94138: LD_INT 20
94140: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94141: LD_ADDR_OWVAR 28
94145: PUSH
94146: LD_INT 17
94148: ST_TO_ADDR
// hc_gallery :=  ;
94149: LD_ADDR_OWVAR 33
94153: PUSH
94154: LD_STRING 
94156: ST_TO_ADDR
// hc_name :=  ;
94157: LD_ADDR_OWVAR 26
94161: PUSH
94162: LD_STRING 
94164: ST_TO_ADDR
// un := CreateHuman ;
94165: LD_ADDR_VAR 0 2
94169: PUSH
94170: CALL_OW 44
94174: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94175: LD_VAR 0 2
94179: PPUSH
94180: LD_INT 1
94182: PPUSH
94183: CALL_OW 51
// tmp := tmp ^ un ;
94187: LD_ADDR_VAR 0 3
94191: PUSH
94192: LD_VAR 0 3
94196: PUSH
94197: LD_VAR 0 2
94201: ADD
94202: ST_TO_ADDR
// end ;
94203: GO 94099
94205: POP
94206: POP
// repeat wait ( 0 0$1 ) ;
94207: LD_INT 35
94209: PPUSH
94210: CALL_OW 67
// for un in tmp do
94214: LD_ADDR_VAR 0 2
94218: PUSH
94219: LD_VAR 0 3
94223: PUSH
94224: FOR_IN
94225: IFFALSE 94299
// begin if IsDead ( un ) then
94227: LD_VAR 0 2
94231: PPUSH
94232: CALL_OW 301
94236: IFFALSE 94256
// begin tmp := tmp diff un ;
94238: LD_ADDR_VAR 0 3
94242: PUSH
94243: LD_VAR 0 3
94247: PUSH
94248: LD_VAR 0 2
94252: DIFF
94253: ST_TO_ADDR
// continue ;
94254: GO 94224
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94256: LD_VAR 0 2
94260: PPUSH
94261: LD_INT 3
94263: PUSH
94264: LD_INT 22
94266: PUSH
94267: LD_INT 0
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: EMPTY
94275: LIST
94276: LIST
94277: PPUSH
94278: CALL_OW 69
94282: PPUSH
94283: LD_VAR 0 2
94287: PPUSH
94288: CALL_OW 74
94292: PPUSH
94293: CALL_OW 115
// end ;
94297: GO 94224
94299: POP
94300: POP
// until not tmp ;
94301: LD_VAR 0 3
94305: NOT
94306: IFFALSE 94207
// end ;
94308: PPOPN 3
94310: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94311: LD_EXP 96
94315: PUSH
94316: LD_EXP 121
94320: AND
94321: IFFALSE 94375
94323: GO 94325
94325: DISABLE
// begin ToLua ( displayTroll(); ) ;
94326: LD_STRING displayTroll();
94328: PPUSH
94329: CALL_OW 559
// wait ( 3 3$00 ) ;
94333: LD_INT 6300
94335: PPUSH
94336: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94340: LD_STRING hideTroll();
94342: PPUSH
94343: CALL_OW 559
// wait ( 1 1$00 ) ;
94347: LD_INT 2100
94349: PPUSH
94350: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94354: LD_STRING displayTroll();
94356: PPUSH
94357: CALL_OW 559
// wait ( 1 1$00 ) ;
94361: LD_INT 2100
94363: PPUSH
94364: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94368: LD_STRING hideTroll();
94370: PPUSH
94371: CALL_OW 559
// end ;
94375: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94376: LD_EXP 96
94380: PUSH
94381: LD_EXP 122
94385: AND
94386: IFFALSE 94449
94388: GO 94390
94390: DISABLE
94391: LD_INT 0
94393: PPUSH
// begin p := 0 ;
94394: LD_ADDR_VAR 0 1
94398: PUSH
94399: LD_INT 0
94401: ST_TO_ADDR
// repeat game_speed := 1 ;
94402: LD_ADDR_OWVAR 65
94406: PUSH
94407: LD_INT 1
94409: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94410: LD_INT 35
94412: PPUSH
94413: CALL_OW 67
// p := p + 1 ;
94417: LD_ADDR_VAR 0 1
94421: PUSH
94422: LD_VAR 0 1
94426: PUSH
94427: LD_INT 1
94429: PLUS
94430: ST_TO_ADDR
// until p >= 60 ;
94431: LD_VAR 0 1
94435: PUSH
94436: LD_INT 60
94438: GREATEREQUAL
94439: IFFALSE 94402
// game_speed := 4 ;
94441: LD_ADDR_OWVAR 65
94445: PUSH
94446: LD_INT 4
94448: ST_TO_ADDR
// end ;
94449: PPOPN 1
94451: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94452: LD_EXP 96
94456: PUSH
94457: LD_EXP 123
94461: AND
94462: IFFALSE 94608
94464: GO 94466
94466: DISABLE
94467: LD_INT 0
94469: PPUSH
94470: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94471: LD_ADDR_VAR 0 1
94475: PUSH
94476: LD_INT 22
94478: PUSH
94479: LD_OWVAR 2
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 2
94490: PUSH
94491: LD_INT 30
94493: PUSH
94494: LD_INT 0
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 30
94503: PUSH
94504: LD_INT 1
94506: PUSH
94507: EMPTY
94508: LIST
94509: LIST
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: LIST
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PPUSH
94520: CALL_OW 69
94524: ST_TO_ADDR
// if not depot then
94525: LD_VAR 0 1
94529: NOT
94530: IFFALSE 94534
// exit ;
94532: GO 94608
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94534: LD_ADDR_VAR 0 2
94538: PUSH
94539: LD_VAR 0 1
94543: PUSH
94544: LD_INT 1
94546: PPUSH
94547: LD_VAR 0 1
94551: PPUSH
94552: CALL_OW 12
94556: ARRAY
94557: PPUSH
94558: CALL_OW 274
94562: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94563: LD_VAR 0 2
94567: PPUSH
94568: LD_INT 1
94570: PPUSH
94571: LD_INT 0
94573: PPUSH
94574: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94578: LD_VAR 0 2
94582: PPUSH
94583: LD_INT 2
94585: PPUSH
94586: LD_INT 0
94588: PPUSH
94589: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94593: LD_VAR 0 2
94597: PPUSH
94598: LD_INT 3
94600: PPUSH
94601: LD_INT 0
94603: PPUSH
94604: CALL_OW 277
// end ;
94608: PPOPN 2
94610: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94611: LD_EXP 96
94615: PUSH
94616: LD_EXP 124
94620: AND
94621: IFFALSE 94718
94623: GO 94625
94625: DISABLE
94626: LD_INT 0
94628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94629: LD_ADDR_VAR 0 1
94633: PUSH
94634: LD_INT 22
94636: PUSH
94637: LD_OWVAR 2
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 21
94648: PUSH
94649: LD_INT 1
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 3
94658: PUSH
94659: LD_INT 23
94661: PUSH
94662: LD_INT 0
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: LIST
94677: PPUSH
94678: CALL_OW 69
94682: ST_TO_ADDR
// if not tmp then
94683: LD_VAR 0 1
94687: NOT
94688: IFFALSE 94692
// exit ;
94690: GO 94718
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94692: LD_VAR 0 1
94696: PUSH
94697: LD_INT 1
94699: PPUSH
94700: LD_VAR 0 1
94704: PPUSH
94705: CALL_OW 12
94709: ARRAY
94710: PPUSH
94711: LD_INT 200
94713: PPUSH
94714: CALL_OW 234
// end ;
94718: PPOPN 1
94720: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94721: LD_EXP 96
94725: PUSH
94726: LD_EXP 125
94730: AND
94731: IFFALSE 94810
94733: GO 94735
94735: DISABLE
94736: LD_INT 0
94738: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94739: LD_ADDR_VAR 0 1
94743: PUSH
94744: LD_INT 22
94746: PUSH
94747: LD_OWVAR 2
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 21
94758: PUSH
94759: LD_INT 2
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PPUSH
94770: CALL_OW 69
94774: ST_TO_ADDR
// if not tmp then
94775: LD_VAR 0 1
94779: NOT
94780: IFFALSE 94784
// exit ;
94782: GO 94810
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94784: LD_VAR 0 1
94788: PUSH
94789: LD_INT 1
94791: PPUSH
94792: LD_VAR 0 1
94796: PPUSH
94797: CALL_OW 12
94801: ARRAY
94802: PPUSH
94803: LD_INT 60
94805: PPUSH
94806: CALL_OW 234
// end ;
94810: PPOPN 1
94812: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94813: LD_EXP 96
94817: PUSH
94818: LD_EXP 126
94822: AND
94823: IFFALSE 94922
94825: GO 94827
94827: DISABLE
94828: LD_INT 0
94830: PPUSH
94831: PPUSH
// begin enable ;
94832: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94833: LD_ADDR_VAR 0 1
94837: PUSH
94838: LD_INT 22
94840: PUSH
94841: LD_OWVAR 2
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 61
94852: PUSH
94853: EMPTY
94854: LIST
94855: PUSH
94856: LD_INT 33
94858: PUSH
94859: LD_INT 2
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: LIST
94870: PPUSH
94871: CALL_OW 69
94875: ST_TO_ADDR
// if not tmp then
94876: LD_VAR 0 1
94880: NOT
94881: IFFALSE 94885
// exit ;
94883: GO 94922
// for i in tmp do
94885: LD_ADDR_VAR 0 2
94889: PUSH
94890: LD_VAR 0 1
94894: PUSH
94895: FOR_IN
94896: IFFALSE 94920
// if IsControledBy ( i ) then
94898: LD_VAR 0 2
94902: PPUSH
94903: CALL_OW 312
94907: IFFALSE 94918
// ComUnlink ( i ) ;
94909: LD_VAR 0 2
94913: PPUSH
94914: CALL_OW 136
94918: GO 94895
94920: POP
94921: POP
// end ;
94922: PPOPN 2
94924: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94925: LD_EXP 96
94929: PUSH
94930: LD_EXP 127
94934: AND
94935: IFFALSE 95075
94937: GO 94939
94939: DISABLE
94940: LD_INT 0
94942: PPUSH
94943: PPUSH
// begin ToLua ( displayPowell(); ) ;
94944: LD_STRING displayPowell();
94946: PPUSH
94947: CALL_OW 559
// uc_side := 0 ;
94951: LD_ADDR_OWVAR 20
94955: PUSH
94956: LD_INT 0
94958: ST_TO_ADDR
// uc_nation := 2 ;
94959: LD_ADDR_OWVAR 21
94963: PUSH
94964: LD_INT 2
94966: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94967: LD_ADDR_OWVAR 37
94971: PUSH
94972: LD_INT 14
94974: ST_TO_ADDR
// vc_engine := engine_siberite ;
94975: LD_ADDR_OWVAR 39
94979: PUSH
94980: LD_INT 3
94982: ST_TO_ADDR
// vc_control := control_apeman ;
94983: LD_ADDR_OWVAR 38
94987: PUSH
94988: LD_INT 5
94990: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94991: LD_ADDR_OWVAR 40
94995: PUSH
94996: LD_INT 29
94998: ST_TO_ADDR
// un := CreateVehicle ;
94999: LD_ADDR_VAR 0 2
95003: PUSH
95004: CALL_OW 45
95008: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95009: LD_VAR 0 2
95013: PPUSH
95014: LD_INT 1
95016: PPUSH
95017: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95021: LD_INT 35
95023: PPUSH
95024: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95028: LD_VAR 0 2
95032: PPUSH
95033: LD_INT 22
95035: PUSH
95036: LD_OWVAR 2
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PPUSH
95045: CALL_OW 69
95049: PPUSH
95050: LD_VAR 0 2
95054: PPUSH
95055: CALL_OW 74
95059: PPUSH
95060: CALL_OW 115
// until IsDead ( un ) ;
95064: LD_VAR 0 2
95068: PPUSH
95069: CALL_OW 301
95073: IFFALSE 95021
// end ;
95075: PPOPN 2
95077: END
// every 0 0$1 trigger StreamModeActive and sStu do
95078: LD_EXP 96
95082: PUSH
95083: LD_EXP 135
95087: AND
95088: IFFALSE 95104
95090: GO 95092
95092: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95093: LD_STRING displayStucuk();
95095: PPUSH
95096: CALL_OW 559
// ResetFog ;
95100: CALL_OW 335
// end ;
95104: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95105: LD_EXP 96
95109: PUSH
95110: LD_EXP 128
95114: AND
95115: IFFALSE 95256
95117: GO 95119
95119: DISABLE
95120: LD_INT 0
95122: PPUSH
95123: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95124: LD_ADDR_VAR 0 2
95128: PUSH
95129: LD_INT 22
95131: PUSH
95132: LD_OWVAR 2
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 21
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PPUSH
95155: CALL_OW 69
95159: ST_TO_ADDR
// if not tmp then
95160: LD_VAR 0 2
95164: NOT
95165: IFFALSE 95169
// exit ;
95167: GO 95256
// un := tmp [ rand ( 1 , tmp ) ] ;
95169: LD_ADDR_VAR 0 1
95173: PUSH
95174: LD_VAR 0 2
95178: PUSH
95179: LD_INT 1
95181: PPUSH
95182: LD_VAR 0 2
95186: PPUSH
95187: CALL_OW 12
95191: ARRAY
95192: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95193: LD_VAR 0 1
95197: PPUSH
95198: LD_INT 0
95200: PPUSH
95201: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95205: LD_VAR 0 1
95209: PPUSH
95210: LD_OWVAR 3
95214: PUSH
95215: LD_VAR 0 1
95219: DIFF
95220: PPUSH
95221: LD_VAR 0 1
95225: PPUSH
95226: CALL_OW 74
95230: PPUSH
95231: CALL_OW 115
// wait ( 0 0$20 ) ;
95235: LD_INT 700
95237: PPUSH
95238: CALL_OW 67
// SetSide ( un , your_side ) ;
95242: LD_VAR 0 1
95246: PPUSH
95247: LD_OWVAR 2
95251: PPUSH
95252: CALL_OW 235
// end ;
95256: PPOPN 2
95258: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95259: LD_EXP 96
95263: PUSH
95264: LD_EXP 129
95268: AND
95269: IFFALSE 95375
95271: GO 95273
95273: DISABLE
95274: LD_INT 0
95276: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95277: LD_ADDR_VAR 0 1
95281: PUSH
95282: LD_INT 22
95284: PUSH
95285: LD_OWVAR 2
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 2
95296: PUSH
95297: LD_INT 30
95299: PUSH
95300: LD_INT 0
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 30
95309: PUSH
95310: LD_INT 1
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: LIST
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PPUSH
95326: CALL_OW 69
95330: ST_TO_ADDR
// if not depot then
95331: LD_VAR 0 1
95335: NOT
95336: IFFALSE 95340
// exit ;
95338: GO 95375
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95340: LD_VAR 0 1
95344: PUSH
95345: LD_INT 1
95347: ARRAY
95348: PPUSH
95349: CALL_OW 250
95353: PPUSH
95354: LD_VAR 0 1
95358: PUSH
95359: LD_INT 1
95361: ARRAY
95362: PPUSH
95363: CALL_OW 251
95367: PPUSH
95368: LD_INT 70
95370: PPUSH
95371: CALL_OW 495
// end ;
95375: PPOPN 1
95377: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95378: LD_EXP 96
95382: PUSH
95383: LD_EXP 130
95387: AND
95388: IFFALSE 95599
95390: GO 95392
95392: DISABLE
95393: LD_INT 0
95395: PPUSH
95396: PPUSH
95397: PPUSH
95398: PPUSH
95399: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95400: LD_ADDR_VAR 0 5
95404: PUSH
95405: LD_INT 22
95407: PUSH
95408: LD_OWVAR 2
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 21
95419: PUSH
95420: LD_INT 1
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PPUSH
95431: CALL_OW 69
95435: ST_TO_ADDR
// if not tmp then
95436: LD_VAR 0 5
95440: NOT
95441: IFFALSE 95445
// exit ;
95443: GO 95599
// for i in tmp do
95445: LD_ADDR_VAR 0 1
95449: PUSH
95450: LD_VAR 0 5
95454: PUSH
95455: FOR_IN
95456: IFFALSE 95597
// begin d := rand ( 0 , 5 ) ;
95458: LD_ADDR_VAR 0 4
95462: PUSH
95463: LD_INT 0
95465: PPUSH
95466: LD_INT 5
95468: PPUSH
95469: CALL_OW 12
95473: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95474: LD_ADDR_VAR 0 2
95478: PUSH
95479: LD_VAR 0 1
95483: PPUSH
95484: CALL_OW 250
95488: PPUSH
95489: LD_VAR 0 4
95493: PPUSH
95494: LD_INT 3
95496: PPUSH
95497: LD_INT 12
95499: PPUSH
95500: CALL_OW 12
95504: PPUSH
95505: CALL_OW 272
95509: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95510: LD_ADDR_VAR 0 3
95514: PUSH
95515: LD_VAR 0 1
95519: PPUSH
95520: CALL_OW 251
95524: PPUSH
95525: LD_VAR 0 4
95529: PPUSH
95530: LD_INT 3
95532: PPUSH
95533: LD_INT 12
95535: PPUSH
95536: CALL_OW 12
95540: PPUSH
95541: CALL_OW 273
95545: ST_TO_ADDR
// if ValidHex ( x , y ) then
95546: LD_VAR 0 2
95550: PPUSH
95551: LD_VAR 0 3
95555: PPUSH
95556: CALL_OW 488
95560: IFFALSE 95595
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95562: LD_VAR 0 1
95566: PPUSH
95567: LD_VAR 0 2
95571: PPUSH
95572: LD_VAR 0 3
95576: PPUSH
95577: LD_INT 3
95579: PPUSH
95580: LD_INT 6
95582: PPUSH
95583: CALL_OW 12
95587: PPUSH
95588: LD_INT 1
95590: PPUSH
95591: CALL_OW 483
// end ;
95595: GO 95455
95597: POP
95598: POP
// end ;
95599: PPOPN 5
95601: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95602: LD_EXP 96
95606: PUSH
95607: LD_EXP 131
95611: AND
95612: IFFALSE 95706
95614: GO 95616
95616: DISABLE
95617: LD_INT 0
95619: PPUSH
95620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95621: LD_ADDR_VAR 0 2
95625: PUSH
95626: LD_INT 22
95628: PUSH
95629: LD_OWVAR 2
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 32
95640: PUSH
95641: LD_INT 1
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 21
95650: PUSH
95651: LD_INT 2
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: LIST
95662: PPUSH
95663: CALL_OW 69
95667: ST_TO_ADDR
// if not tmp then
95668: LD_VAR 0 2
95672: NOT
95673: IFFALSE 95677
// exit ;
95675: GO 95706
// for i in tmp do
95677: LD_ADDR_VAR 0 1
95681: PUSH
95682: LD_VAR 0 2
95686: PUSH
95687: FOR_IN
95688: IFFALSE 95704
// SetFuel ( i , 0 ) ;
95690: LD_VAR 0 1
95694: PPUSH
95695: LD_INT 0
95697: PPUSH
95698: CALL_OW 240
95702: GO 95687
95704: POP
95705: POP
// end ;
95706: PPOPN 2
95708: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95709: LD_EXP 96
95713: PUSH
95714: LD_EXP 132
95718: AND
95719: IFFALSE 95785
95721: GO 95723
95723: DISABLE
95724: LD_INT 0
95726: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95727: LD_ADDR_VAR 0 1
95731: PUSH
95732: LD_INT 22
95734: PUSH
95735: LD_OWVAR 2
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 30
95746: PUSH
95747: LD_INT 29
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PPUSH
95758: CALL_OW 69
95762: ST_TO_ADDR
// if not tmp then
95763: LD_VAR 0 1
95767: NOT
95768: IFFALSE 95772
// exit ;
95770: GO 95785
// DestroyUnit ( tmp [ 1 ] ) ;
95772: LD_VAR 0 1
95776: PUSH
95777: LD_INT 1
95779: ARRAY
95780: PPUSH
95781: CALL_OW 65
// end ;
95785: PPOPN 1
95787: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95788: LD_EXP 96
95792: PUSH
95793: LD_EXP 134
95797: AND
95798: IFFALSE 95927
95800: GO 95802
95802: DISABLE
95803: LD_INT 0
95805: PPUSH
// begin uc_side := 0 ;
95806: LD_ADDR_OWVAR 20
95810: PUSH
95811: LD_INT 0
95813: ST_TO_ADDR
// uc_nation := nation_arabian ;
95814: LD_ADDR_OWVAR 21
95818: PUSH
95819: LD_INT 2
95821: ST_TO_ADDR
// hc_gallery :=  ;
95822: LD_ADDR_OWVAR 33
95826: PUSH
95827: LD_STRING 
95829: ST_TO_ADDR
// hc_name :=  ;
95830: LD_ADDR_OWVAR 26
95834: PUSH
95835: LD_STRING 
95837: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95838: LD_INT 1
95840: PPUSH
95841: LD_INT 11
95843: PPUSH
95844: LD_INT 10
95846: PPUSH
95847: CALL_OW 380
// un := CreateHuman ;
95851: LD_ADDR_VAR 0 1
95855: PUSH
95856: CALL_OW 44
95860: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95861: LD_VAR 0 1
95865: PPUSH
95866: LD_INT 1
95868: PPUSH
95869: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95873: LD_INT 35
95875: PPUSH
95876: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95880: LD_VAR 0 1
95884: PPUSH
95885: LD_INT 22
95887: PUSH
95888: LD_OWVAR 2
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PPUSH
95897: CALL_OW 69
95901: PPUSH
95902: LD_VAR 0 1
95906: PPUSH
95907: CALL_OW 74
95911: PPUSH
95912: CALL_OW 115
// until IsDead ( un ) ;
95916: LD_VAR 0 1
95920: PPUSH
95921: CALL_OW 301
95925: IFFALSE 95873
// end ;
95927: PPOPN 1
95929: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95930: LD_EXP 96
95934: PUSH
95935: LD_EXP 136
95939: AND
95940: IFFALSE 95952
95942: GO 95944
95944: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95945: LD_STRING earthquake(getX(game), 0, 32)
95947: PPUSH
95948: CALL_OW 559
95952: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95953: LD_EXP 96
95957: PUSH
95958: LD_EXP 137
95962: AND
95963: IFFALSE 96054
95965: GO 95967
95967: DISABLE
95968: LD_INT 0
95970: PPUSH
// begin enable ;
95971: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95972: LD_ADDR_VAR 0 1
95976: PUSH
95977: LD_INT 22
95979: PUSH
95980: LD_OWVAR 2
95984: PUSH
95985: EMPTY
95986: LIST
95987: LIST
95988: PUSH
95989: LD_INT 21
95991: PUSH
95992: LD_INT 2
95994: PUSH
95995: EMPTY
95996: LIST
95997: LIST
95998: PUSH
95999: LD_INT 33
96001: PUSH
96002: LD_INT 3
96004: PUSH
96005: EMPTY
96006: LIST
96007: LIST
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: LIST
96013: PPUSH
96014: CALL_OW 69
96018: ST_TO_ADDR
// if not tmp then
96019: LD_VAR 0 1
96023: NOT
96024: IFFALSE 96028
// exit ;
96026: GO 96054
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96028: LD_VAR 0 1
96032: PUSH
96033: LD_INT 1
96035: PPUSH
96036: LD_VAR 0 1
96040: PPUSH
96041: CALL_OW 12
96045: ARRAY
96046: PPUSH
96047: LD_INT 1
96049: PPUSH
96050: CALL_OW 234
// end ;
96054: PPOPN 1
96056: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96057: LD_EXP 96
96061: PUSH
96062: LD_EXP 138
96066: AND
96067: IFFALSE 96208
96069: GO 96071
96071: DISABLE
96072: LD_INT 0
96074: PPUSH
96075: PPUSH
96076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96077: LD_ADDR_VAR 0 3
96081: PUSH
96082: LD_INT 22
96084: PUSH
96085: LD_OWVAR 2
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 25
96096: PUSH
96097: LD_INT 1
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: PPUSH
96108: CALL_OW 69
96112: ST_TO_ADDR
// if not tmp then
96113: LD_VAR 0 3
96117: NOT
96118: IFFALSE 96122
// exit ;
96120: GO 96208
// un := tmp [ rand ( 1 , tmp ) ] ;
96122: LD_ADDR_VAR 0 2
96126: PUSH
96127: LD_VAR 0 3
96131: PUSH
96132: LD_INT 1
96134: PPUSH
96135: LD_VAR 0 3
96139: PPUSH
96140: CALL_OW 12
96144: ARRAY
96145: ST_TO_ADDR
// if Crawls ( un ) then
96146: LD_VAR 0 2
96150: PPUSH
96151: CALL_OW 318
96155: IFFALSE 96166
// ComWalk ( un ) ;
96157: LD_VAR 0 2
96161: PPUSH
96162: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96166: LD_VAR 0 2
96170: PPUSH
96171: LD_INT 9
96173: PPUSH
96174: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96178: LD_INT 28
96180: PPUSH
96181: LD_OWVAR 2
96185: PPUSH
96186: LD_INT 2
96188: PPUSH
96189: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96193: LD_INT 29
96195: PPUSH
96196: LD_OWVAR 2
96200: PPUSH
96201: LD_INT 2
96203: PPUSH
96204: CALL_OW 322
// end ;
96208: PPOPN 3
96210: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96211: LD_EXP 96
96215: PUSH
96216: LD_EXP 139
96220: AND
96221: IFFALSE 96332
96223: GO 96225
96225: DISABLE
96226: LD_INT 0
96228: PPUSH
96229: PPUSH
96230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96231: LD_ADDR_VAR 0 3
96235: PUSH
96236: LD_INT 22
96238: PUSH
96239: LD_OWVAR 2
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 25
96250: PUSH
96251: LD_INT 1
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PPUSH
96262: CALL_OW 69
96266: ST_TO_ADDR
// if not tmp then
96267: LD_VAR 0 3
96271: NOT
96272: IFFALSE 96276
// exit ;
96274: GO 96332
// un := tmp [ rand ( 1 , tmp ) ] ;
96276: LD_ADDR_VAR 0 2
96280: PUSH
96281: LD_VAR 0 3
96285: PUSH
96286: LD_INT 1
96288: PPUSH
96289: LD_VAR 0 3
96293: PPUSH
96294: CALL_OW 12
96298: ARRAY
96299: ST_TO_ADDR
// if Crawls ( un ) then
96300: LD_VAR 0 2
96304: PPUSH
96305: CALL_OW 318
96309: IFFALSE 96320
// ComWalk ( un ) ;
96311: LD_VAR 0 2
96315: PPUSH
96316: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96320: LD_VAR 0 2
96324: PPUSH
96325: LD_INT 8
96327: PPUSH
96328: CALL_OW 336
// end ;
96332: PPOPN 3
96334: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96335: LD_EXP 96
96339: PUSH
96340: LD_EXP 140
96344: AND
96345: IFFALSE 96489
96347: GO 96349
96349: DISABLE
96350: LD_INT 0
96352: PPUSH
96353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96354: LD_ADDR_VAR 0 2
96358: PUSH
96359: LD_INT 22
96361: PUSH
96362: LD_OWVAR 2
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 21
96373: PUSH
96374: LD_INT 2
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 2
96383: PUSH
96384: LD_INT 34
96386: PUSH
96387: LD_INT 12
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 34
96396: PUSH
96397: LD_INT 51
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 34
96406: PUSH
96407: LD_INT 32
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: LIST
96424: PPUSH
96425: CALL_OW 69
96429: ST_TO_ADDR
// if not tmp then
96430: LD_VAR 0 2
96434: NOT
96435: IFFALSE 96439
// exit ;
96437: GO 96489
// for i in tmp do
96439: LD_ADDR_VAR 0 1
96443: PUSH
96444: LD_VAR 0 2
96448: PUSH
96449: FOR_IN
96450: IFFALSE 96487
// if GetCargo ( i , mat_artifact ) = 0 then
96452: LD_VAR 0 1
96456: PPUSH
96457: LD_INT 4
96459: PPUSH
96460: CALL_OW 289
96464: PUSH
96465: LD_INT 0
96467: EQUAL
96468: IFFALSE 96485
// SetCargo ( i , mat_siberit , 100 ) ;
96470: LD_VAR 0 1
96474: PPUSH
96475: LD_INT 3
96477: PPUSH
96478: LD_INT 100
96480: PPUSH
96481: CALL_OW 290
96485: GO 96449
96487: POP
96488: POP
// end ;
96489: PPOPN 2
96491: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96492: LD_EXP 96
96496: PUSH
96497: LD_EXP 141
96501: AND
96502: IFFALSE 96685
96504: GO 96506
96506: DISABLE
96507: LD_INT 0
96509: PPUSH
96510: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96511: LD_ADDR_VAR 0 2
96515: PUSH
96516: LD_INT 22
96518: PUSH
96519: LD_OWVAR 2
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PPUSH
96528: CALL_OW 69
96532: ST_TO_ADDR
// if not tmp then
96533: LD_VAR 0 2
96537: NOT
96538: IFFALSE 96542
// exit ;
96540: GO 96685
// for i := 1 to 2 do
96542: LD_ADDR_VAR 0 1
96546: PUSH
96547: DOUBLE
96548: LD_INT 1
96550: DEC
96551: ST_TO_ADDR
96552: LD_INT 2
96554: PUSH
96555: FOR_TO
96556: IFFALSE 96683
// begin uc_side := your_side ;
96558: LD_ADDR_OWVAR 20
96562: PUSH
96563: LD_OWVAR 2
96567: ST_TO_ADDR
// uc_nation := nation_american ;
96568: LD_ADDR_OWVAR 21
96572: PUSH
96573: LD_INT 1
96575: ST_TO_ADDR
// vc_chassis := us_morphling ;
96576: LD_ADDR_OWVAR 37
96580: PUSH
96581: LD_INT 5
96583: ST_TO_ADDR
// vc_engine := engine_siberite ;
96584: LD_ADDR_OWVAR 39
96588: PUSH
96589: LD_INT 3
96591: ST_TO_ADDR
// vc_control := control_computer ;
96592: LD_ADDR_OWVAR 38
96596: PUSH
96597: LD_INT 3
96599: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96600: LD_ADDR_OWVAR 40
96604: PUSH
96605: LD_INT 10
96607: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96608: LD_VAR 0 2
96612: PUSH
96613: LD_INT 1
96615: ARRAY
96616: PPUSH
96617: CALL_OW 310
96621: NOT
96622: IFFALSE 96669
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96624: CALL_OW 45
96628: PPUSH
96629: LD_VAR 0 2
96633: PUSH
96634: LD_INT 1
96636: ARRAY
96637: PPUSH
96638: CALL_OW 250
96642: PPUSH
96643: LD_VAR 0 2
96647: PUSH
96648: LD_INT 1
96650: ARRAY
96651: PPUSH
96652: CALL_OW 251
96656: PPUSH
96657: LD_INT 12
96659: PPUSH
96660: LD_INT 1
96662: PPUSH
96663: CALL_OW 50
96667: GO 96681
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96669: CALL_OW 45
96673: PPUSH
96674: LD_INT 1
96676: PPUSH
96677: CALL_OW 51
// end ;
96681: GO 96555
96683: POP
96684: POP
// end ;
96685: PPOPN 2
96687: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96688: LD_EXP 96
96692: PUSH
96693: LD_EXP 142
96697: AND
96698: IFFALSE 96920
96700: GO 96702
96702: DISABLE
96703: LD_INT 0
96705: PPUSH
96706: PPUSH
96707: PPUSH
96708: PPUSH
96709: PPUSH
96710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96711: LD_ADDR_VAR 0 6
96715: PUSH
96716: LD_INT 22
96718: PUSH
96719: LD_OWVAR 2
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: PUSH
96728: LD_INT 21
96730: PUSH
96731: LD_INT 1
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: PUSH
96738: LD_INT 3
96740: PUSH
96741: LD_INT 23
96743: PUSH
96744: LD_INT 0
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: LIST
96759: PPUSH
96760: CALL_OW 69
96764: ST_TO_ADDR
// if not tmp then
96765: LD_VAR 0 6
96769: NOT
96770: IFFALSE 96774
// exit ;
96772: GO 96920
// s1 := rand ( 1 , 4 ) ;
96774: LD_ADDR_VAR 0 2
96778: PUSH
96779: LD_INT 1
96781: PPUSH
96782: LD_INT 4
96784: PPUSH
96785: CALL_OW 12
96789: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96790: LD_ADDR_VAR 0 4
96794: PUSH
96795: LD_VAR 0 6
96799: PUSH
96800: LD_INT 1
96802: ARRAY
96803: PPUSH
96804: LD_VAR 0 2
96808: PPUSH
96809: CALL_OW 259
96813: ST_TO_ADDR
// if s1 = 1 then
96814: LD_VAR 0 2
96818: PUSH
96819: LD_INT 1
96821: EQUAL
96822: IFFALSE 96842
// s2 := rand ( 2 , 4 ) else
96824: LD_ADDR_VAR 0 3
96828: PUSH
96829: LD_INT 2
96831: PPUSH
96832: LD_INT 4
96834: PPUSH
96835: CALL_OW 12
96839: ST_TO_ADDR
96840: GO 96850
// s2 := 1 ;
96842: LD_ADDR_VAR 0 3
96846: PUSH
96847: LD_INT 1
96849: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96850: LD_ADDR_VAR 0 5
96854: PUSH
96855: LD_VAR 0 6
96859: PUSH
96860: LD_INT 1
96862: ARRAY
96863: PPUSH
96864: LD_VAR 0 3
96868: PPUSH
96869: CALL_OW 259
96873: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96874: LD_VAR 0 6
96878: PUSH
96879: LD_INT 1
96881: ARRAY
96882: PPUSH
96883: LD_VAR 0 2
96887: PPUSH
96888: LD_VAR 0 5
96892: PPUSH
96893: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96897: LD_VAR 0 6
96901: PUSH
96902: LD_INT 1
96904: ARRAY
96905: PPUSH
96906: LD_VAR 0 3
96910: PPUSH
96911: LD_VAR 0 4
96915: PPUSH
96916: CALL_OW 237
// end ;
96920: PPOPN 6
96922: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96923: LD_EXP 96
96927: PUSH
96928: LD_EXP 143
96932: AND
96933: IFFALSE 97012
96935: GO 96937
96937: DISABLE
96938: LD_INT 0
96940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96941: LD_ADDR_VAR 0 1
96945: PUSH
96946: LD_INT 22
96948: PUSH
96949: LD_OWVAR 2
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 30
96960: PUSH
96961: LD_INT 3
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: EMPTY
96969: LIST
96970: LIST
96971: PPUSH
96972: CALL_OW 69
96976: ST_TO_ADDR
// if not tmp then
96977: LD_VAR 0 1
96981: NOT
96982: IFFALSE 96986
// exit ;
96984: GO 97012
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96986: LD_VAR 0 1
96990: PUSH
96991: LD_INT 1
96993: PPUSH
96994: LD_VAR 0 1
96998: PPUSH
96999: CALL_OW 12
97003: ARRAY
97004: PPUSH
97005: LD_INT 1
97007: PPUSH
97008: CALL_OW 234
// end ;
97012: PPOPN 1
97014: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97015: LD_EXP 96
97019: PUSH
97020: LD_EXP 144
97024: AND
97025: IFFALSE 97137
97027: GO 97029
97029: DISABLE
97030: LD_INT 0
97032: PPUSH
97033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97034: LD_ADDR_VAR 0 2
97038: PUSH
97039: LD_INT 22
97041: PUSH
97042: LD_OWVAR 2
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 2
97053: PUSH
97054: LD_INT 30
97056: PUSH
97057: LD_INT 27
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: LD_INT 30
97066: PUSH
97067: LD_INT 26
97069: PUSH
97070: EMPTY
97071: LIST
97072: LIST
97073: PUSH
97074: LD_INT 30
97076: PUSH
97077: LD_INT 28
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PPUSH
97094: CALL_OW 69
97098: ST_TO_ADDR
// if not tmp then
97099: LD_VAR 0 2
97103: NOT
97104: IFFALSE 97108
// exit ;
97106: GO 97137
// for i in tmp do
97108: LD_ADDR_VAR 0 1
97112: PUSH
97113: LD_VAR 0 2
97117: PUSH
97118: FOR_IN
97119: IFFALSE 97135
// SetLives ( i , 1 ) ;
97121: LD_VAR 0 1
97125: PPUSH
97126: LD_INT 1
97128: PPUSH
97129: CALL_OW 234
97133: GO 97118
97135: POP
97136: POP
// end ;
97137: PPOPN 2
97139: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97140: LD_EXP 96
97144: PUSH
97145: LD_EXP 145
97149: AND
97150: IFFALSE 97437
97152: GO 97154
97154: DISABLE
97155: LD_INT 0
97157: PPUSH
97158: PPUSH
97159: PPUSH
// begin i := rand ( 1 , 7 ) ;
97160: LD_ADDR_VAR 0 1
97164: PUSH
97165: LD_INT 1
97167: PPUSH
97168: LD_INT 7
97170: PPUSH
97171: CALL_OW 12
97175: ST_TO_ADDR
// case i of 1 :
97176: LD_VAR 0 1
97180: PUSH
97181: LD_INT 1
97183: DOUBLE
97184: EQUAL
97185: IFTRUE 97189
97187: GO 97199
97189: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97190: LD_STRING earthquake(getX(game), 0, 32)
97192: PPUSH
97193: CALL_OW 559
97197: GO 97437
97199: LD_INT 2
97201: DOUBLE
97202: EQUAL
97203: IFTRUE 97207
97205: GO 97221
97207: POP
// begin ToLua ( displayStucuk(); ) ;
97208: LD_STRING displayStucuk();
97210: PPUSH
97211: CALL_OW 559
// ResetFog ;
97215: CALL_OW 335
// end ; 3 :
97219: GO 97437
97221: LD_INT 3
97223: DOUBLE
97224: EQUAL
97225: IFTRUE 97229
97227: GO 97333
97229: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97230: LD_ADDR_VAR 0 2
97234: PUSH
97235: LD_INT 22
97237: PUSH
97238: LD_OWVAR 2
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_INT 25
97249: PUSH
97250: LD_INT 1
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PPUSH
97261: CALL_OW 69
97265: ST_TO_ADDR
// if not tmp then
97266: LD_VAR 0 2
97270: NOT
97271: IFFALSE 97275
// exit ;
97273: GO 97437
// un := tmp [ rand ( 1 , tmp ) ] ;
97275: LD_ADDR_VAR 0 3
97279: PUSH
97280: LD_VAR 0 2
97284: PUSH
97285: LD_INT 1
97287: PPUSH
97288: LD_VAR 0 2
97292: PPUSH
97293: CALL_OW 12
97297: ARRAY
97298: ST_TO_ADDR
// if Crawls ( un ) then
97299: LD_VAR 0 3
97303: PPUSH
97304: CALL_OW 318
97308: IFFALSE 97319
// ComWalk ( un ) ;
97310: LD_VAR 0 3
97314: PPUSH
97315: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97319: LD_VAR 0 3
97323: PPUSH
97324: LD_INT 8
97326: PPUSH
97327: CALL_OW 336
// end ; 4 :
97331: GO 97437
97333: LD_INT 4
97335: DOUBLE
97336: EQUAL
97337: IFTRUE 97341
97339: GO 97415
97341: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97342: LD_ADDR_VAR 0 2
97346: PUSH
97347: LD_INT 22
97349: PUSH
97350: LD_OWVAR 2
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 30
97361: PUSH
97362: LD_INT 29
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PPUSH
97373: CALL_OW 69
97377: ST_TO_ADDR
// if not tmp then
97378: LD_VAR 0 2
97382: NOT
97383: IFFALSE 97387
// exit ;
97385: GO 97437
// CenterNowOnUnits ( tmp [ 1 ] ) ;
97387: LD_VAR 0 2
97391: PUSH
97392: LD_INT 1
97394: ARRAY
97395: PPUSH
97396: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97400: LD_VAR 0 2
97404: PUSH
97405: LD_INT 1
97407: ARRAY
97408: PPUSH
97409: CALL_OW 65
// end ; 5 .. 7 :
97413: GO 97437
97415: LD_INT 5
97417: DOUBLE
97418: GREATEREQUAL
97419: IFFALSE 97427
97421: LD_INT 7
97423: DOUBLE
97424: LESSEQUAL
97425: IFTRUE 97429
97427: GO 97436
97429: POP
// StreamSibBomb ; end ;
97430: CALL 93674 0 0
97434: GO 97437
97436: POP
// end ;
97437: PPOPN 3
97439: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97440: LD_EXP 96
97444: PUSH
97445: LD_EXP 146
97449: AND
97450: IFFALSE 97606
97452: GO 97454
97454: DISABLE
97455: LD_INT 0
97457: PPUSH
97458: PPUSH
97459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97460: LD_ADDR_VAR 0 2
97464: PUSH
97465: LD_INT 81
97467: PUSH
97468: LD_OWVAR 2
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 2
97479: PUSH
97480: LD_INT 21
97482: PUSH
97483: LD_INT 1
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 21
97492: PUSH
97493: LD_INT 2
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: LIST
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PPUSH
97509: CALL_OW 69
97513: ST_TO_ADDR
// if not tmp then
97514: LD_VAR 0 2
97518: NOT
97519: IFFALSE 97523
// exit ;
97521: GO 97606
// p := 0 ;
97523: LD_ADDR_VAR 0 3
97527: PUSH
97528: LD_INT 0
97530: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97531: LD_INT 35
97533: PPUSH
97534: CALL_OW 67
// p := p + 1 ;
97538: LD_ADDR_VAR 0 3
97542: PUSH
97543: LD_VAR 0 3
97547: PUSH
97548: LD_INT 1
97550: PLUS
97551: ST_TO_ADDR
// for i in tmp do
97552: LD_ADDR_VAR 0 1
97556: PUSH
97557: LD_VAR 0 2
97561: PUSH
97562: FOR_IN
97563: IFFALSE 97594
// if GetLives ( i ) < 1000 then
97565: LD_VAR 0 1
97569: PPUSH
97570: CALL_OW 256
97574: PUSH
97575: LD_INT 1000
97577: LESS
97578: IFFALSE 97592
// SetLives ( i , 1000 ) ;
97580: LD_VAR 0 1
97584: PPUSH
97585: LD_INT 1000
97587: PPUSH
97588: CALL_OW 234
97592: GO 97562
97594: POP
97595: POP
// until p > 20 ;
97596: LD_VAR 0 3
97600: PUSH
97601: LD_INT 20
97603: GREATER
97604: IFFALSE 97531
// end ;
97606: PPOPN 3
97608: END
// every 0 0$1 trigger StreamModeActive and sTime do
97609: LD_EXP 96
97613: PUSH
97614: LD_EXP 147
97618: AND
97619: IFFALSE 97654
97621: GO 97623
97623: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97624: LD_INT 28
97626: PPUSH
97627: LD_OWVAR 2
97631: PPUSH
97632: LD_INT 2
97634: PPUSH
97635: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97639: LD_INT 30
97641: PPUSH
97642: LD_OWVAR 2
97646: PPUSH
97647: LD_INT 2
97649: PPUSH
97650: CALL_OW 322
// end ;
97654: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97655: LD_EXP 96
97659: PUSH
97660: LD_EXP 148
97664: AND
97665: IFFALSE 97786
97667: GO 97669
97669: DISABLE
97670: LD_INT 0
97672: PPUSH
97673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97674: LD_ADDR_VAR 0 2
97678: PUSH
97679: LD_INT 22
97681: PUSH
97682: LD_OWVAR 2
97686: PUSH
97687: EMPTY
97688: LIST
97689: LIST
97690: PUSH
97691: LD_INT 21
97693: PUSH
97694: LD_INT 1
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: PUSH
97701: LD_INT 3
97703: PUSH
97704: LD_INT 23
97706: PUSH
97707: LD_INT 0
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: PUSH
97714: EMPTY
97715: LIST
97716: LIST
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: LIST
97722: PPUSH
97723: CALL_OW 69
97727: ST_TO_ADDR
// if not tmp then
97728: LD_VAR 0 2
97732: NOT
97733: IFFALSE 97737
// exit ;
97735: GO 97786
// for i in tmp do
97737: LD_ADDR_VAR 0 1
97741: PUSH
97742: LD_VAR 0 2
97746: PUSH
97747: FOR_IN
97748: IFFALSE 97784
// begin if Crawls ( i ) then
97750: LD_VAR 0 1
97754: PPUSH
97755: CALL_OW 318
97759: IFFALSE 97770
// ComWalk ( i ) ;
97761: LD_VAR 0 1
97765: PPUSH
97766: CALL_OW 138
// SetClass ( i , 2 ) ;
97770: LD_VAR 0 1
97774: PPUSH
97775: LD_INT 2
97777: PPUSH
97778: CALL_OW 336
// end ;
97782: GO 97747
97784: POP
97785: POP
// end ;
97786: PPOPN 2
97788: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97789: LD_EXP 96
97793: PUSH
97794: LD_EXP 149
97798: AND
97799: IFFALSE 98087
97801: GO 97803
97803: DISABLE
97804: LD_INT 0
97806: PPUSH
97807: PPUSH
97808: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97809: LD_OWVAR 2
97813: PPUSH
97814: LD_INT 9
97816: PPUSH
97817: LD_INT 1
97819: PPUSH
97820: LD_INT 1
97822: PPUSH
97823: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97827: LD_INT 9
97829: PPUSH
97830: LD_OWVAR 2
97834: PPUSH
97835: CALL_OW 343
// uc_side := 9 ;
97839: LD_ADDR_OWVAR 20
97843: PUSH
97844: LD_INT 9
97846: ST_TO_ADDR
// uc_nation := 2 ;
97847: LD_ADDR_OWVAR 21
97851: PUSH
97852: LD_INT 2
97854: ST_TO_ADDR
// hc_name := Dark Warrior ;
97855: LD_ADDR_OWVAR 26
97859: PUSH
97860: LD_STRING Dark Warrior
97862: ST_TO_ADDR
// hc_gallery :=  ;
97863: LD_ADDR_OWVAR 33
97867: PUSH
97868: LD_STRING 
97870: ST_TO_ADDR
// hc_noskilllimit := true ;
97871: LD_ADDR_OWVAR 76
97875: PUSH
97876: LD_INT 1
97878: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97879: LD_ADDR_OWVAR 31
97883: PUSH
97884: LD_INT 30
97886: PUSH
97887: LD_INT 30
97889: PUSH
97890: LD_INT 30
97892: PUSH
97893: LD_INT 30
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: ST_TO_ADDR
// un := CreateHuman ;
97902: LD_ADDR_VAR 0 3
97906: PUSH
97907: CALL_OW 44
97911: ST_TO_ADDR
// hc_noskilllimit := false ;
97912: LD_ADDR_OWVAR 76
97916: PUSH
97917: LD_INT 0
97919: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97920: LD_VAR 0 3
97924: PPUSH
97925: LD_INT 1
97927: PPUSH
97928: CALL_OW 51
// ToLua ( playRanger() ) ;
97932: LD_STRING playRanger()
97934: PPUSH
97935: CALL_OW 559
// p := 0 ;
97939: LD_ADDR_VAR 0 2
97943: PUSH
97944: LD_INT 0
97946: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97947: LD_INT 35
97949: PPUSH
97950: CALL_OW 67
// p := p + 1 ;
97954: LD_ADDR_VAR 0 2
97958: PUSH
97959: LD_VAR 0 2
97963: PUSH
97964: LD_INT 1
97966: PLUS
97967: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97968: LD_VAR 0 3
97972: PPUSH
97973: CALL_OW 256
97977: PUSH
97978: LD_INT 1000
97980: LESS
97981: IFFALSE 97995
// SetLives ( un , 1000 ) ;
97983: LD_VAR 0 3
97987: PPUSH
97988: LD_INT 1000
97990: PPUSH
97991: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97995: LD_VAR 0 3
97999: PPUSH
98000: LD_INT 81
98002: PUSH
98003: LD_OWVAR 2
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: PUSH
98012: LD_INT 91
98014: PUSH
98015: LD_VAR 0 3
98019: PUSH
98020: LD_INT 30
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: LIST
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: PPUSH
98032: CALL_OW 69
98036: PPUSH
98037: LD_VAR 0 3
98041: PPUSH
98042: CALL_OW 74
98046: PPUSH
98047: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
98051: LD_VAR 0 2
98055: PUSH
98056: LD_INT 80
98058: GREATER
98059: PUSH
98060: LD_VAR 0 3
98064: PPUSH
98065: CALL_OW 301
98069: OR
98070: IFFALSE 97947
// if un then
98072: LD_VAR 0 3
98076: IFFALSE 98087
// RemoveUnit ( un ) ;
98078: LD_VAR 0 3
98082: PPUSH
98083: CALL_OW 64
// end ;
98087: PPOPN 3
98089: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
98090: LD_EXP 150
98094: IFFALSE 98210
98096: GO 98098
98098: DISABLE
98099: LD_INT 0
98101: PPUSH
98102: PPUSH
98103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98104: LD_ADDR_VAR 0 2
98108: PUSH
98109: LD_INT 81
98111: PUSH
98112: LD_OWVAR 2
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: PUSH
98121: LD_INT 21
98123: PUSH
98124: LD_INT 1
98126: PUSH
98127: EMPTY
98128: LIST
98129: LIST
98130: PUSH
98131: EMPTY
98132: LIST
98133: LIST
98134: PPUSH
98135: CALL_OW 69
98139: ST_TO_ADDR
// ToLua ( playComputer() ) ;
98140: LD_STRING playComputer()
98142: PPUSH
98143: CALL_OW 559
// if not tmp then
98147: LD_VAR 0 2
98151: NOT
98152: IFFALSE 98156
// exit ;
98154: GO 98210
// for i in tmp do
98156: LD_ADDR_VAR 0 1
98160: PUSH
98161: LD_VAR 0 2
98165: PUSH
98166: FOR_IN
98167: IFFALSE 98208
// for j := 1 to 4 do
98169: LD_ADDR_VAR 0 3
98173: PUSH
98174: DOUBLE
98175: LD_INT 1
98177: DEC
98178: ST_TO_ADDR
98179: LD_INT 4
98181: PUSH
98182: FOR_TO
98183: IFFALSE 98204
// SetSkill ( i , j , 10 ) ;
98185: LD_VAR 0 1
98189: PPUSH
98190: LD_VAR 0 3
98194: PPUSH
98195: LD_INT 10
98197: PPUSH
98198: CALL_OW 237
98202: GO 98182
98204: POP
98205: POP
98206: GO 98166
98208: POP
98209: POP
// end ;
98210: PPOPN 3
98212: END
// every 0 0$1 trigger s30 do var i , tmp ;
98213: LD_EXP 151
98217: IFFALSE 98286
98219: GO 98221
98221: DISABLE
98222: LD_INT 0
98224: PPUSH
98225: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98226: LD_ADDR_VAR 0 2
98230: PUSH
98231: LD_INT 22
98233: PUSH
98234: LD_OWVAR 2
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PPUSH
98243: CALL_OW 69
98247: ST_TO_ADDR
// if not tmp then
98248: LD_VAR 0 2
98252: NOT
98253: IFFALSE 98257
// exit ;
98255: GO 98286
// for i in tmp do
98257: LD_ADDR_VAR 0 1
98261: PUSH
98262: LD_VAR 0 2
98266: PUSH
98267: FOR_IN
98268: IFFALSE 98284
// SetLives ( i , 300 ) ;
98270: LD_VAR 0 1
98274: PPUSH
98275: LD_INT 300
98277: PPUSH
98278: CALL_OW 234
98282: GO 98267
98284: POP
98285: POP
// end ;
98286: PPOPN 2
98288: END
// every 0 0$1 trigger s60 do var i , tmp ;
98289: LD_EXP 152
98293: IFFALSE 98362
98295: GO 98297
98297: DISABLE
98298: LD_INT 0
98300: PPUSH
98301: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98302: LD_ADDR_VAR 0 2
98306: PUSH
98307: LD_INT 22
98309: PUSH
98310: LD_OWVAR 2
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: PPUSH
98319: CALL_OW 69
98323: ST_TO_ADDR
// if not tmp then
98324: LD_VAR 0 2
98328: NOT
98329: IFFALSE 98333
// exit ;
98331: GO 98362
// for i in tmp do
98333: LD_ADDR_VAR 0 1
98337: PUSH
98338: LD_VAR 0 2
98342: PUSH
98343: FOR_IN
98344: IFFALSE 98360
// SetLives ( i , 600 ) ;
98346: LD_VAR 0 1
98350: PPUSH
98351: LD_INT 600
98353: PPUSH
98354: CALL_OW 234
98358: GO 98343
98360: POP
98361: POP
// end ;
98362: PPOPN 2
98364: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98365: LD_INT 0
98367: PPUSH
// case cmd of 301 :
98368: LD_VAR 0 1
98372: PUSH
98373: LD_INT 301
98375: DOUBLE
98376: EQUAL
98377: IFTRUE 98381
98379: GO 98413
98381: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98382: LD_VAR 0 6
98386: PPUSH
98387: LD_VAR 0 7
98391: PPUSH
98392: LD_VAR 0 8
98396: PPUSH
98397: LD_VAR 0 4
98401: PPUSH
98402: LD_VAR 0 5
98406: PPUSH
98407: CALL 99622 0 5
98411: GO 98534
98413: LD_INT 302
98415: DOUBLE
98416: EQUAL
98417: IFTRUE 98421
98419: GO 98458
98421: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98422: LD_VAR 0 6
98426: PPUSH
98427: LD_VAR 0 7
98431: PPUSH
98432: LD_VAR 0 8
98436: PPUSH
98437: LD_VAR 0 9
98441: PPUSH
98442: LD_VAR 0 4
98446: PPUSH
98447: LD_VAR 0 5
98451: PPUSH
98452: CALL 99713 0 6
98456: GO 98534
98458: LD_INT 303
98460: DOUBLE
98461: EQUAL
98462: IFTRUE 98466
98464: GO 98503
98466: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98467: LD_VAR 0 6
98471: PPUSH
98472: LD_VAR 0 7
98476: PPUSH
98477: LD_VAR 0 8
98481: PPUSH
98482: LD_VAR 0 9
98486: PPUSH
98487: LD_VAR 0 4
98491: PPUSH
98492: LD_VAR 0 5
98496: PPUSH
98497: CALL 98539 0 6
98501: GO 98534
98503: LD_INT 304
98505: DOUBLE
98506: EQUAL
98507: IFTRUE 98511
98509: GO 98533
98511: POP
// hHackTeleport ( unit , x , y ) ; end ;
98512: LD_VAR 0 2
98516: PPUSH
98517: LD_VAR 0 4
98521: PPUSH
98522: LD_VAR 0 5
98526: PPUSH
98527: CALL 100306 0 3
98531: GO 98534
98533: POP
// end ;
98534: LD_VAR 0 12
98538: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98539: LD_INT 0
98541: PPUSH
98542: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98543: LD_VAR 0 1
98547: PUSH
98548: LD_INT 1
98550: LESS
98551: PUSH
98552: LD_VAR 0 1
98556: PUSH
98557: LD_INT 3
98559: GREATER
98560: OR
98561: PUSH
98562: LD_VAR 0 5
98566: PPUSH
98567: LD_VAR 0 6
98571: PPUSH
98572: CALL_OW 428
98576: OR
98577: IFFALSE 98581
// exit ;
98579: GO 99309
// uc_side := your_side ;
98581: LD_ADDR_OWVAR 20
98585: PUSH
98586: LD_OWVAR 2
98590: ST_TO_ADDR
// uc_nation := nation ;
98591: LD_ADDR_OWVAR 21
98595: PUSH
98596: LD_VAR 0 1
98600: ST_TO_ADDR
// bc_level = 1 ;
98601: LD_ADDR_OWVAR 43
98605: PUSH
98606: LD_INT 1
98608: ST_TO_ADDR
// case btype of 1 :
98609: LD_VAR 0 2
98613: PUSH
98614: LD_INT 1
98616: DOUBLE
98617: EQUAL
98618: IFTRUE 98622
98620: GO 98633
98622: POP
// bc_type := b_depot ; 2 :
98623: LD_ADDR_OWVAR 42
98627: PUSH
98628: LD_INT 0
98630: ST_TO_ADDR
98631: GO 99253
98633: LD_INT 2
98635: DOUBLE
98636: EQUAL
98637: IFTRUE 98641
98639: GO 98652
98641: POP
// bc_type := b_warehouse ; 3 :
98642: LD_ADDR_OWVAR 42
98646: PUSH
98647: LD_INT 1
98649: ST_TO_ADDR
98650: GO 99253
98652: LD_INT 3
98654: DOUBLE
98655: EQUAL
98656: IFTRUE 98660
98658: GO 98671
98660: POP
// bc_type := b_lab ; 4 .. 9 :
98661: LD_ADDR_OWVAR 42
98665: PUSH
98666: LD_INT 6
98668: ST_TO_ADDR
98669: GO 99253
98671: LD_INT 4
98673: DOUBLE
98674: GREATEREQUAL
98675: IFFALSE 98683
98677: LD_INT 9
98679: DOUBLE
98680: LESSEQUAL
98681: IFTRUE 98685
98683: GO 98745
98685: POP
// begin bc_type := b_lab_half ;
98686: LD_ADDR_OWVAR 42
98690: PUSH
98691: LD_INT 7
98693: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98694: LD_ADDR_OWVAR 44
98698: PUSH
98699: LD_INT 10
98701: PUSH
98702: LD_INT 11
98704: PUSH
98705: LD_INT 12
98707: PUSH
98708: LD_INT 15
98710: PUSH
98711: LD_INT 14
98713: PUSH
98714: LD_INT 13
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: LIST
98723: LIST
98724: PUSH
98725: LD_VAR 0 2
98729: PUSH
98730: LD_INT 3
98732: MINUS
98733: ARRAY
98734: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
98735: LD_ADDR_OWVAR 45
98739: PUSH
98740: LD_INT 9
98742: ST_TO_ADDR
// end ; 10 .. 13 :
98743: GO 99253
98745: LD_INT 10
98747: DOUBLE
98748: GREATEREQUAL
98749: IFFALSE 98757
98751: LD_INT 13
98753: DOUBLE
98754: LESSEQUAL
98755: IFTRUE 98759
98757: GO 98836
98759: POP
// begin bc_type := b_lab_full ;
98760: LD_ADDR_OWVAR 42
98764: PUSH
98765: LD_INT 8
98767: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98768: LD_ADDR_OWVAR 44
98772: PUSH
98773: LD_INT 10
98775: PUSH
98776: LD_INT 12
98778: PUSH
98779: LD_INT 14
98781: PUSH
98782: LD_INT 13
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: PUSH
98791: LD_VAR 0 2
98795: PUSH
98796: LD_INT 9
98798: MINUS
98799: ARRAY
98800: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98801: LD_ADDR_OWVAR 45
98805: PUSH
98806: LD_INT 11
98808: PUSH
98809: LD_INT 15
98811: PUSH
98812: LD_INT 12
98814: PUSH
98815: LD_INT 15
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: PUSH
98824: LD_VAR 0 2
98828: PUSH
98829: LD_INT 9
98831: MINUS
98832: ARRAY
98833: ST_TO_ADDR
// end ; 14 :
98834: GO 99253
98836: LD_INT 14
98838: DOUBLE
98839: EQUAL
98840: IFTRUE 98844
98842: GO 98855
98844: POP
// bc_type := b_workshop ; 15 :
98845: LD_ADDR_OWVAR 42
98849: PUSH
98850: LD_INT 2
98852: ST_TO_ADDR
98853: GO 99253
98855: LD_INT 15
98857: DOUBLE
98858: EQUAL
98859: IFTRUE 98863
98861: GO 98874
98863: POP
// bc_type := b_factory ; 16 :
98864: LD_ADDR_OWVAR 42
98868: PUSH
98869: LD_INT 3
98871: ST_TO_ADDR
98872: GO 99253
98874: LD_INT 16
98876: DOUBLE
98877: EQUAL
98878: IFTRUE 98882
98880: GO 98893
98882: POP
// bc_type := b_ext_gun ; 17 :
98883: LD_ADDR_OWVAR 42
98887: PUSH
98888: LD_INT 17
98890: ST_TO_ADDR
98891: GO 99253
98893: LD_INT 17
98895: DOUBLE
98896: EQUAL
98897: IFTRUE 98901
98899: GO 98929
98901: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98902: LD_ADDR_OWVAR 42
98906: PUSH
98907: LD_INT 19
98909: PUSH
98910: LD_INT 23
98912: PUSH
98913: LD_INT 19
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: LIST
98920: PUSH
98921: LD_VAR 0 1
98925: ARRAY
98926: ST_TO_ADDR
98927: GO 99253
98929: LD_INT 18
98931: DOUBLE
98932: EQUAL
98933: IFTRUE 98937
98935: GO 98948
98937: POP
// bc_type := b_ext_radar ; 19 :
98938: LD_ADDR_OWVAR 42
98942: PUSH
98943: LD_INT 20
98945: ST_TO_ADDR
98946: GO 99253
98948: LD_INT 19
98950: DOUBLE
98951: EQUAL
98952: IFTRUE 98956
98954: GO 98967
98956: POP
// bc_type := b_ext_radio ; 20 :
98957: LD_ADDR_OWVAR 42
98961: PUSH
98962: LD_INT 22
98964: ST_TO_ADDR
98965: GO 99253
98967: LD_INT 20
98969: DOUBLE
98970: EQUAL
98971: IFTRUE 98975
98973: GO 98986
98975: POP
// bc_type := b_ext_siberium ; 21 :
98976: LD_ADDR_OWVAR 42
98980: PUSH
98981: LD_INT 21
98983: ST_TO_ADDR
98984: GO 99253
98986: LD_INT 21
98988: DOUBLE
98989: EQUAL
98990: IFTRUE 98994
98992: GO 99005
98994: POP
// bc_type := b_ext_computer ; 22 :
98995: LD_ADDR_OWVAR 42
98999: PUSH
99000: LD_INT 24
99002: ST_TO_ADDR
99003: GO 99253
99005: LD_INT 22
99007: DOUBLE
99008: EQUAL
99009: IFTRUE 99013
99011: GO 99024
99013: POP
// bc_type := b_ext_track ; 23 :
99014: LD_ADDR_OWVAR 42
99018: PUSH
99019: LD_INT 16
99021: ST_TO_ADDR
99022: GO 99253
99024: LD_INT 23
99026: DOUBLE
99027: EQUAL
99028: IFTRUE 99032
99030: GO 99043
99032: POP
// bc_type := b_ext_laser ; 24 :
99033: LD_ADDR_OWVAR 42
99037: PUSH
99038: LD_INT 25
99040: ST_TO_ADDR
99041: GO 99253
99043: LD_INT 24
99045: DOUBLE
99046: EQUAL
99047: IFTRUE 99051
99049: GO 99062
99051: POP
// bc_type := b_control_tower ; 25 :
99052: LD_ADDR_OWVAR 42
99056: PUSH
99057: LD_INT 36
99059: ST_TO_ADDR
99060: GO 99253
99062: LD_INT 25
99064: DOUBLE
99065: EQUAL
99066: IFTRUE 99070
99068: GO 99081
99070: POP
// bc_type := b_breastwork ; 26 :
99071: LD_ADDR_OWVAR 42
99075: PUSH
99076: LD_INT 31
99078: ST_TO_ADDR
99079: GO 99253
99081: LD_INT 26
99083: DOUBLE
99084: EQUAL
99085: IFTRUE 99089
99087: GO 99100
99089: POP
// bc_type := b_bunker ; 27 :
99090: LD_ADDR_OWVAR 42
99094: PUSH
99095: LD_INT 32
99097: ST_TO_ADDR
99098: GO 99253
99100: LD_INT 27
99102: DOUBLE
99103: EQUAL
99104: IFTRUE 99108
99106: GO 99119
99108: POP
// bc_type := b_turret ; 28 :
99109: LD_ADDR_OWVAR 42
99113: PUSH
99114: LD_INT 33
99116: ST_TO_ADDR
99117: GO 99253
99119: LD_INT 28
99121: DOUBLE
99122: EQUAL
99123: IFTRUE 99127
99125: GO 99138
99127: POP
// bc_type := b_armoury ; 29 :
99128: LD_ADDR_OWVAR 42
99132: PUSH
99133: LD_INT 4
99135: ST_TO_ADDR
99136: GO 99253
99138: LD_INT 29
99140: DOUBLE
99141: EQUAL
99142: IFTRUE 99146
99144: GO 99157
99146: POP
// bc_type := b_barracks ; 30 :
99147: LD_ADDR_OWVAR 42
99151: PUSH
99152: LD_INT 5
99154: ST_TO_ADDR
99155: GO 99253
99157: LD_INT 30
99159: DOUBLE
99160: EQUAL
99161: IFTRUE 99165
99163: GO 99176
99165: POP
// bc_type := b_solar_power ; 31 :
99166: LD_ADDR_OWVAR 42
99170: PUSH
99171: LD_INT 27
99173: ST_TO_ADDR
99174: GO 99253
99176: LD_INT 31
99178: DOUBLE
99179: EQUAL
99180: IFTRUE 99184
99182: GO 99195
99184: POP
// bc_type := b_oil_power ; 32 :
99185: LD_ADDR_OWVAR 42
99189: PUSH
99190: LD_INT 26
99192: ST_TO_ADDR
99193: GO 99253
99195: LD_INT 32
99197: DOUBLE
99198: EQUAL
99199: IFTRUE 99203
99201: GO 99214
99203: POP
// bc_type := b_siberite_power ; 33 :
99204: LD_ADDR_OWVAR 42
99208: PUSH
99209: LD_INT 28
99211: ST_TO_ADDR
99212: GO 99253
99214: LD_INT 33
99216: DOUBLE
99217: EQUAL
99218: IFTRUE 99222
99220: GO 99233
99222: POP
// bc_type := b_oil_mine ; 34 :
99223: LD_ADDR_OWVAR 42
99227: PUSH
99228: LD_INT 29
99230: ST_TO_ADDR
99231: GO 99253
99233: LD_INT 34
99235: DOUBLE
99236: EQUAL
99237: IFTRUE 99241
99239: GO 99252
99241: POP
// bc_type := b_siberite_mine ; end ;
99242: LD_ADDR_OWVAR 42
99246: PUSH
99247: LD_INT 30
99249: ST_TO_ADDR
99250: GO 99253
99252: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99253: LD_ADDR_VAR 0 8
99257: PUSH
99258: LD_VAR 0 5
99262: PPUSH
99263: LD_VAR 0 6
99267: PPUSH
99268: LD_VAR 0 3
99272: PPUSH
99273: CALL_OW 47
99277: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99278: LD_OWVAR 42
99282: PUSH
99283: LD_INT 32
99285: PUSH
99286: LD_INT 33
99288: PUSH
99289: EMPTY
99290: LIST
99291: LIST
99292: IN
99293: IFFALSE 99309
// PlaceWeaponTurret ( b , weapon ) ;
99295: LD_VAR 0 8
99299: PPUSH
99300: LD_VAR 0 4
99304: PPUSH
99305: CALL_OW 431
// end ;
99309: LD_VAR 0 7
99313: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99314: LD_INT 0
99316: PPUSH
99317: PPUSH
99318: PPUSH
99319: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99320: LD_ADDR_VAR 0 4
99324: PUSH
99325: LD_INT 22
99327: PUSH
99328: LD_OWVAR 2
99332: PUSH
99333: EMPTY
99334: LIST
99335: LIST
99336: PUSH
99337: LD_INT 2
99339: PUSH
99340: LD_INT 30
99342: PUSH
99343: LD_INT 0
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: PUSH
99350: LD_INT 30
99352: PUSH
99353: LD_INT 1
99355: PUSH
99356: EMPTY
99357: LIST
99358: LIST
99359: PUSH
99360: EMPTY
99361: LIST
99362: LIST
99363: LIST
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: PPUSH
99369: CALL_OW 69
99373: ST_TO_ADDR
// if not tmp then
99374: LD_VAR 0 4
99378: NOT
99379: IFFALSE 99383
// exit ;
99381: GO 99442
// for i in tmp do
99383: LD_ADDR_VAR 0 2
99387: PUSH
99388: LD_VAR 0 4
99392: PUSH
99393: FOR_IN
99394: IFFALSE 99440
// for j = 1 to 3 do
99396: LD_ADDR_VAR 0 3
99400: PUSH
99401: DOUBLE
99402: LD_INT 1
99404: DEC
99405: ST_TO_ADDR
99406: LD_INT 3
99408: PUSH
99409: FOR_TO
99410: IFFALSE 99436
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99412: LD_VAR 0 2
99416: PPUSH
99417: CALL_OW 274
99421: PPUSH
99422: LD_VAR 0 3
99426: PPUSH
99427: LD_INT 99999
99429: PPUSH
99430: CALL_OW 277
99434: GO 99409
99436: POP
99437: POP
99438: GO 99393
99440: POP
99441: POP
// end ;
99442: LD_VAR 0 1
99446: RET
// export function hHackSetLevel10 ; var i , j ; begin
99447: LD_INT 0
99449: PPUSH
99450: PPUSH
99451: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99452: LD_ADDR_VAR 0 2
99456: PUSH
99457: LD_INT 21
99459: PUSH
99460: LD_INT 1
99462: PUSH
99463: EMPTY
99464: LIST
99465: LIST
99466: PPUSH
99467: CALL_OW 69
99471: PUSH
99472: FOR_IN
99473: IFFALSE 99525
// if IsSelected ( i ) then
99475: LD_VAR 0 2
99479: PPUSH
99480: CALL_OW 306
99484: IFFALSE 99523
// begin for j := 1 to 4 do
99486: LD_ADDR_VAR 0 3
99490: PUSH
99491: DOUBLE
99492: LD_INT 1
99494: DEC
99495: ST_TO_ADDR
99496: LD_INT 4
99498: PUSH
99499: FOR_TO
99500: IFFALSE 99521
// SetSkill ( i , j , 10 ) ;
99502: LD_VAR 0 2
99506: PPUSH
99507: LD_VAR 0 3
99511: PPUSH
99512: LD_INT 10
99514: PPUSH
99515: CALL_OW 237
99519: GO 99499
99521: POP
99522: POP
// end ;
99523: GO 99472
99525: POP
99526: POP
// end ;
99527: LD_VAR 0 1
99531: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99532: LD_INT 0
99534: PPUSH
99535: PPUSH
99536: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99537: LD_ADDR_VAR 0 2
99541: PUSH
99542: LD_INT 22
99544: PUSH
99545: LD_OWVAR 2
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: PUSH
99554: LD_INT 21
99556: PUSH
99557: LD_INT 1
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: PPUSH
99568: CALL_OW 69
99572: PUSH
99573: FOR_IN
99574: IFFALSE 99615
// begin for j := 1 to 4 do
99576: LD_ADDR_VAR 0 3
99580: PUSH
99581: DOUBLE
99582: LD_INT 1
99584: DEC
99585: ST_TO_ADDR
99586: LD_INT 4
99588: PUSH
99589: FOR_TO
99590: IFFALSE 99611
// SetSkill ( i , j , 10 ) ;
99592: LD_VAR 0 2
99596: PPUSH
99597: LD_VAR 0 3
99601: PPUSH
99602: LD_INT 10
99604: PPUSH
99605: CALL_OW 237
99609: GO 99589
99611: POP
99612: POP
// end ;
99613: GO 99573
99615: POP
99616: POP
// end ;
99617: LD_VAR 0 1
99621: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99622: LD_INT 0
99624: PPUSH
// uc_side := your_side ;
99625: LD_ADDR_OWVAR 20
99629: PUSH
99630: LD_OWVAR 2
99634: ST_TO_ADDR
// uc_nation := nation ;
99635: LD_ADDR_OWVAR 21
99639: PUSH
99640: LD_VAR 0 1
99644: ST_TO_ADDR
// InitHc ;
99645: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99649: LD_INT 0
99651: PPUSH
99652: LD_VAR 0 2
99656: PPUSH
99657: LD_VAR 0 3
99661: PPUSH
99662: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99666: LD_VAR 0 4
99670: PPUSH
99671: LD_VAR 0 5
99675: PPUSH
99676: CALL_OW 428
99680: PUSH
99681: LD_INT 0
99683: EQUAL
99684: IFFALSE 99708
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99686: CALL_OW 44
99690: PPUSH
99691: LD_VAR 0 4
99695: PPUSH
99696: LD_VAR 0 5
99700: PPUSH
99701: LD_INT 1
99703: PPUSH
99704: CALL_OW 48
// end ;
99708: LD_VAR 0 6
99712: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99713: LD_INT 0
99715: PPUSH
99716: PPUSH
// uc_side := your_side ;
99717: LD_ADDR_OWVAR 20
99721: PUSH
99722: LD_OWVAR 2
99726: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99727: LD_VAR 0 1
99731: PUSH
99732: LD_INT 1
99734: PUSH
99735: LD_INT 2
99737: PUSH
99738: LD_INT 3
99740: PUSH
99741: LD_INT 4
99743: PUSH
99744: LD_INT 5
99746: PUSH
99747: EMPTY
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: IN
99754: IFFALSE 99766
// uc_nation := nation_american else
99756: LD_ADDR_OWVAR 21
99760: PUSH
99761: LD_INT 1
99763: ST_TO_ADDR
99764: GO 99809
// if chassis in [ 11 , 12 , 13 , 14 ] then
99766: LD_VAR 0 1
99770: PUSH
99771: LD_INT 11
99773: PUSH
99774: LD_INT 12
99776: PUSH
99777: LD_INT 13
99779: PUSH
99780: LD_INT 14
99782: PUSH
99783: EMPTY
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: IN
99789: IFFALSE 99801
// uc_nation := nation_arabian else
99791: LD_ADDR_OWVAR 21
99795: PUSH
99796: LD_INT 2
99798: ST_TO_ADDR
99799: GO 99809
// uc_nation := nation_russian ;
99801: LD_ADDR_OWVAR 21
99805: PUSH
99806: LD_INT 3
99808: ST_TO_ADDR
// vc_chassis := chassis ;
99809: LD_ADDR_OWVAR 37
99813: PUSH
99814: LD_VAR 0 1
99818: ST_TO_ADDR
// vc_engine := engine ;
99819: LD_ADDR_OWVAR 39
99823: PUSH
99824: LD_VAR 0 2
99828: ST_TO_ADDR
// vc_control := control ;
99829: LD_ADDR_OWVAR 38
99833: PUSH
99834: LD_VAR 0 3
99838: ST_TO_ADDR
// vc_weapon := weapon ;
99839: LD_ADDR_OWVAR 40
99843: PUSH
99844: LD_VAR 0 4
99848: ST_TO_ADDR
// un := CreateVehicle ;
99849: LD_ADDR_VAR 0 8
99853: PUSH
99854: CALL_OW 45
99858: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99859: LD_VAR 0 8
99863: PPUSH
99864: LD_INT 0
99866: PPUSH
99867: LD_INT 5
99869: PPUSH
99870: CALL_OW 12
99874: PPUSH
99875: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99879: LD_VAR 0 8
99883: PPUSH
99884: LD_VAR 0 5
99888: PPUSH
99889: LD_VAR 0 6
99893: PPUSH
99894: LD_INT 1
99896: PPUSH
99897: CALL_OW 48
// end ;
99901: LD_VAR 0 7
99905: RET
// export hInvincible ; every 1 do
99906: GO 99908
99908: DISABLE
// hInvincible := [ ] ;
99909: LD_ADDR_EXP 153
99913: PUSH
99914: EMPTY
99915: ST_TO_ADDR
99916: END
// every 10 do var i ;
99917: GO 99919
99919: DISABLE
99920: LD_INT 0
99922: PPUSH
// begin enable ;
99923: ENABLE
// if not hInvincible then
99924: LD_EXP 153
99928: NOT
99929: IFFALSE 99933
// exit ;
99931: GO 99977
// for i in hInvincible do
99933: LD_ADDR_VAR 0 1
99937: PUSH
99938: LD_EXP 153
99942: PUSH
99943: FOR_IN
99944: IFFALSE 99975
// if GetLives ( i ) < 1000 then
99946: LD_VAR 0 1
99950: PPUSH
99951: CALL_OW 256
99955: PUSH
99956: LD_INT 1000
99958: LESS
99959: IFFALSE 99973
// SetLives ( i , 1000 ) ;
99961: LD_VAR 0 1
99965: PPUSH
99966: LD_INT 1000
99968: PPUSH
99969: CALL_OW 234
99973: GO 99943
99975: POP
99976: POP
// end ;
99977: PPOPN 1
99979: END
// export function hHackInvincible ; var i ; begin
99980: LD_INT 0
99982: PPUSH
99983: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99984: LD_ADDR_VAR 0 2
99988: PUSH
99989: LD_INT 2
99991: PUSH
99992: LD_INT 21
99994: PUSH
99995: LD_INT 1
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PUSH
100002: LD_INT 21
100004: PUSH
100005: LD_INT 2
100007: PUSH
100008: EMPTY
100009: LIST
100010: LIST
100011: PUSH
100012: EMPTY
100013: LIST
100014: LIST
100015: LIST
100016: PPUSH
100017: CALL_OW 69
100021: PUSH
100022: FOR_IN
100023: IFFALSE 100084
// if IsSelected ( i ) then
100025: LD_VAR 0 2
100029: PPUSH
100030: CALL_OW 306
100034: IFFALSE 100082
// begin if i in hInvincible then
100036: LD_VAR 0 2
100040: PUSH
100041: LD_EXP 153
100045: IN
100046: IFFALSE 100066
// hInvincible := hInvincible diff i else
100048: LD_ADDR_EXP 153
100052: PUSH
100053: LD_EXP 153
100057: PUSH
100058: LD_VAR 0 2
100062: DIFF
100063: ST_TO_ADDR
100064: GO 100082
// hInvincible := hInvincible union i ;
100066: LD_ADDR_EXP 153
100070: PUSH
100071: LD_EXP 153
100075: PUSH
100076: LD_VAR 0 2
100080: UNION
100081: ST_TO_ADDR
// end ;
100082: GO 100022
100084: POP
100085: POP
// end ;
100086: LD_VAR 0 1
100090: RET
// export function hHackInvisible ; var i , j ; begin
100091: LD_INT 0
100093: PPUSH
100094: PPUSH
100095: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100096: LD_ADDR_VAR 0 2
100100: PUSH
100101: LD_INT 21
100103: PUSH
100104: LD_INT 1
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: PPUSH
100111: CALL_OW 69
100115: PUSH
100116: FOR_IN
100117: IFFALSE 100141
// if IsSelected ( i ) then
100119: LD_VAR 0 2
100123: PPUSH
100124: CALL_OW 306
100128: IFFALSE 100139
// ComForceInvisible ( i ) ;
100130: LD_VAR 0 2
100134: PPUSH
100135: CALL_OW 496
100139: GO 100116
100141: POP
100142: POP
// end ;
100143: LD_VAR 0 1
100147: RET
// export function hHackChangeYourSide ; begin
100148: LD_INT 0
100150: PPUSH
// if your_side = 8 then
100151: LD_OWVAR 2
100155: PUSH
100156: LD_INT 8
100158: EQUAL
100159: IFFALSE 100171
// your_side := 0 else
100161: LD_ADDR_OWVAR 2
100165: PUSH
100166: LD_INT 0
100168: ST_TO_ADDR
100169: GO 100185
// your_side := your_side + 1 ;
100171: LD_ADDR_OWVAR 2
100175: PUSH
100176: LD_OWVAR 2
100180: PUSH
100181: LD_INT 1
100183: PLUS
100184: ST_TO_ADDR
// end ;
100185: LD_VAR 0 1
100189: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100190: LD_INT 0
100192: PPUSH
100193: PPUSH
100194: PPUSH
// for i in all_units do
100195: LD_ADDR_VAR 0 2
100199: PUSH
100200: LD_OWVAR 3
100204: PUSH
100205: FOR_IN
100206: IFFALSE 100284
// if IsSelected ( i ) then
100208: LD_VAR 0 2
100212: PPUSH
100213: CALL_OW 306
100217: IFFALSE 100282
// begin j := GetSide ( i ) ;
100219: LD_ADDR_VAR 0 3
100223: PUSH
100224: LD_VAR 0 2
100228: PPUSH
100229: CALL_OW 255
100233: ST_TO_ADDR
// if j = 8 then
100234: LD_VAR 0 3
100238: PUSH
100239: LD_INT 8
100241: EQUAL
100242: IFFALSE 100254
// j := 0 else
100244: LD_ADDR_VAR 0 3
100248: PUSH
100249: LD_INT 0
100251: ST_TO_ADDR
100252: GO 100268
// j := j + 1 ;
100254: LD_ADDR_VAR 0 3
100258: PUSH
100259: LD_VAR 0 3
100263: PUSH
100264: LD_INT 1
100266: PLUS
100267: ST_TO_ADDR
// SetSide ( i , j ) ;
100268: LD_VAR 0 2
100272: PPUSH
100273: LD_VAR 0 3
100277: PPUSH
100278: CALL_OW 235
// end ;
100282: GO 100205
100284: POP
100285: POP
// end ;
100286: LD_VAR 0 1
100290: RET
// export function hHackFog ; begin
100291: LD_INT 0
100293: PPUSH
// FogOff ( true ) ;
100294: LD_INT 1
100296: PPUSH
100297: CALL_OW 344
// end ;
100301: LD_VAR 0 1
100305: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100306: LD_INT 0
100308: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100309: LD_VAR 0 1
100313: PPUSH
100314: LD_VAR 0 2
100318: PPUSH
100319: LD_VAR 0 3
100323: PPUSH
100324: LD_INT 1
100326: PPUSH
100327: LD_INT 1
100329: PPUSH
100330: CALL_OW 483
// CenterOnXY ( x , y ) ;
100334: LD_VAR 0 2
100338: PPUSH
100339: LD_VAR 0 3
100343: PPUSH
100344: CALL_OW 84
// end ;
100348: LD_VAR 0 4
100352: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
100353: LD_INT 0
100355: PPUSH
100356: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
100357: LD_VAR 0 1
100361: NOT
100362: PUSH
100363: LD_VAR 0 2
100367: PPUSH
100368: LD_VAR 0 3
100372: PPUSH
100373: CALL_OW 488
100377: NOT
100378: OR
100379: PUSH
100380: LD_VAR 0 1
100384: PPUSH
100385: CALL_OW 266
100389: PUSH
100390: LD_INT 3
100392: NONEQUAL
100393: PUSH
100394: LD_VAR 0 1
100398: PPUSH
100399: CALL_OW 247
100403: PUSH
100404: LD_INT 1
100406: EQUAL
100407: NOT
100408: AND
100409: OR
100410: IFFALSE 100414
// exit ;
100412: GO 100563
// if GetType ( factory ) = unit_human then
100414: LD_VAR 0 1
100418: PPUSH
100419: CALL_OW 247
100423: PUSH
100424: LD_INT 1
100426: EQUAL
100427: IFFALSE 100444
// factory := IsInUnit ( factory ) ;
100429: LD_ADDR_VAR 0 1
100433: PUSH
100434: LD_VAR 0 1
100438: PPUSH
100439: CALL_OW 310
100443: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100444: LD_VAR 0 1
100448: PPUSH
100449: CALL_OW 266
100453: PUSH
100454: LD_INT 3
100456: NONEQUAL
100457: IFFALSE 100461
// exit ;
100459: GO 100563
// if HexInfo ( x , y ) = factory then
100461: LD_VAR 0 2
100465: PPUSH
100466: LD_VAR 0 3
100470: PPUSH
100471: CALL_OW 428
100475: PUSH
100476: LD_VAR 0 1
100480: EQUAL
100481: IFFALSE 100508
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100483: LD_ADDR_EXP 154
100487: PUSH
100488: LD_EXP 154
100492: PPUSH
100493: LD_VAR 0 1
100497: PPUSH
100498: LD_INT 0
100500: PPUSH
100501: CALL_OW 1
100505: ST_TO_ADDR
100506: GO 100559
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100508: LD_ADDR_EXP 154
100512: PUSH
100513: LD_EXP 154
100517: PPUSH
100518: LD_VAR 0 1
100522: PPUSH
100523: LD_VAR 0 1
100527: PPUSH
100528: CALL_OW 255
100532: PUSH
100533: LD_VAR 0 1
100537: PUSH
100538: LD_VAR 0 2
100542: PUSH
100543: LD_VAR 0 3
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: PPUSH
100554: CALL_OW 1
100558: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100559: CALL 100568 0 0
// end ;
100563: LD_VAR 0 4
100567: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
100568: LD_INT 0
100570: PPUSH
100571: PPUSH
100572: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100573: LD_STRING resetFactoryWaypoint();
100575: PPUSH
100576: CALL_OW 559
// if factoryWaypoints then
100580: LD_EXP 154
100584: IFFALSE 100710
// begin list := PrepareArray ( factoryWaypoints ) ;
100586: LD_ADDR_VAR 0 3
100590: PUSH
100591: LD_EXP 154
100595: PPUSH
100596: CALL 54690 0 1
100600: ST_TO_ADDR
// for i := 1 to list do
100601: LD_ADDR_VAR 0 2
100605: PUSH
100606: DOUBLE
100607: LD_INT 1
100609: DEC
100610: ST_TO_ADDR
100611: LD_VAR 0 3
100615: PUSH
100616: FOR_TO
100617: IFFALSE 100708
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100619: LD_STRING setFactoryWaypointXY(
100621: PUSH
100622: LD_VAR 0 3
100626: PUSH
100627: LD_VAR 0 2
100631: ARRAY
100632: PUSH
100633: LD_INT 1
100635: ARRAY
100636: STR
100637: PUSH
100638: LD_STRING ,
100640: STR
100641: PUSH
100642: LD_VAR 0 3
100646: PUSH
100647: LD_VAR 0 2
100651: ARRAY
100652: PUSH
100653: LD_INT 2
100655: ARRAY
100656: STR
100657: PUSH
100658: LD_STRING ,
100660: STR
100661: PUSH
100662: LD_VAR 0 3
100666: PUSH
100667: LD_VAR 0 2
100671: ARRAY
100672: PUSH
100673: LD_INT 3
100675: ARRAY
100676: STR
100677: PUSH
100678: LD_STRING ,
100680: STR
100681: PUSH
100682: LD_VAR 0 3
100686: PUSH
100687: LD_VAR 0 2
100691: ARRAY
100692: PUSH
100693: LD_INT 4
100695: ARRAY
100696: STR
100697: PUSH
100698: LD_STRING )
100700: STR
100701: PPUSH
100702: CALL_OW 559
100706: GO 100616
100708: POP
100709: POP
// end ; end ;
100710: LD_VAR 0 1
100714: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
100715: LD_INT 0
100717: PPUSH
// if HexInfo ( x , y ) = warehouse then
100718: LD_VAR 0 2
100722: PPUSH
100723: LD_VAR 0 3
100727: PPUSH
100728: CALL_OW 428
100732: PUSH
100733: LD_VAR 0 1
100737: EQUAL
100738: IFFALSE 100765
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
100740: LD_ADDR_EXP 155
100744: PUSH
100745: LD_EXP 155
100749: PPUSH
100750: LD_VAR 0 1
100754: PPUSH
100755: LD_INT 0
100757: PPUSH
100758: CALL_OW 1
100762: ST_TO_ADDR
100763: GO 100816
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
100765: LD_ADDR_EXP 155
100769: PUSH
100770: LD_EXP 155
100774: PPUSH
100775: LD_VAR 0 1
100779: PPUSH
100780: LD_VAR 0 1
100784: PPUSH
100785: CALL_OW 255
100789: PUSH
100790: LD_VAR 0 1
100794: PUSH
100795: LD_VAR 0 2
100799: PUSH
100800: LD_VAR 0 3
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: LIST
100809: LIST
100810: PPUSH
100811: CALL_OW 1
100815: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
100816: CALL 100825 0 0
// end ;
100820: LD_VAR 0 4
100824: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
100825: LD_INT 0
100827: PPUSH
100828: PPUSH
100829: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
100830: LD_STRING resetWarehouseGatheringPoints();
100832: PPUSH
100833: CALL_OW 559
// if warehouseGatheringPoints then
100837: LD_EXP 155
100841: IFFALSE 100967
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
100843: LD_ADDR_VAR 0 3
100847: PUSH
100848: LD_EXP 155
100852: PPUSH
100853: CALL 54690 0 1
100857: ST_TO_ADDR
// for i := 1 to list do
100858: LD_ADDR_VAR 0 2
100862: PUSH
100863: DOUBLE
100864: LD_INT 1
100866: DEC
100867: ST_TO_ADDR
100868: LD_VAR 0 3
100872: PUSH
100873: FOR_TO
100874: IFFALSE 100965
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
100876: LD_STRING setWarehouseGatheringPointXY(
100878: PUSH
100879: LD_VAR 0 3
100883: PUSH
100884: LD_VAR 0 2
100888: ARRAY
100889: PUSH
100890: LD_INT 1
100892: ARRAY
100893: STR
100894: PUSH
100895: LD_STRING ,
100897: STR
100898: PUSH
100899: LD_VAR 0 3
100903: PUSH
100904: LD_VAR 0 2
100908: ARRAY
100909: PUSH
100910: LD_INT 2
100912: ARRAY
100913: STR
100914: PUSH
100915: LD_STRING ,
100917: STR
100918: PUSH
100919: LD_VAR 0 3
100923: PUSH
100924: LD_VAR 0 2
100928: ARRAY
100929: PUSH
100930: LD_INT 3
100932: ARRAY
100933: STR
100934: PUSH
100935: LD_STRING ,
100937: STR
100938: PUSH
100939: LD_VAR 0 3
100943: PUSH
100944: LD_VAR 0 2
100948: ARRAY
100949: PUSH
100950: LD_INT 4
100952: ARRAY
100953: STR
100954: PUSH
100955: LD_STRING )
100957: STR
100958: PPUSH
100959: CALL_OW 559
100963: GO 100873
100965: POP
100966: POP
// end ; end ;
100967: LD_VAR 0 1
100971: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
100972: LD_EXP 155
100976: IFFALSE 101661
100978: GO 100980
100980: DISABLE
100981: LD_INT 0
100983: PPUSH
100984: PPUSH
100985: PPUSH
100986: PPUSH
100987: PPUSH
100988: PPUSH
100989: PPUSH
100990: PPUSH
100991: PPUSH
// begin enable ;
100992: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
100993: LD_ADDR_VAR 0 3
100997: PUSH
100998: LD_EXP 155
101002: PPUSH
101003: CALL 54690 0 1
101007: ST_TO_ADDR
// if not list then
101008: LD_VAR 0 3
101012: NOT
101013: IFFALSE 101017
// exit ;
101015: GO 101661
// for i := 1 to list do
101017: LD_ADDR_VAR 0 1
101021: PUSH
101022: DOUBLE
101023: LD_INT 1
101025: DEC
101026: ST_TO_ADDR
101027: LD_VAR 0 3
101031: PUSH
101032: FOR_TO
101033: IFFALSE 101659
// begin depot := list [ i ] [ 2 ] ;
101035: LD_ADDR_VAR 0 8
101039: PUSH
101040: LD_VAR 0 3
101044: PUSH
101045: LD_VAR 0 1
101049: ARRAY
101050: PUSH
101051: LD_INT 2
101053: ARRAY
101054: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
101055: LD_ADDR_VAR 0 5
101059: PUSH
101060: LD_VAR 0 3
101064: PUSH
101065: LD_VAR 0 1
101069: ARRAY
101070: PUSH
101071: LD_INT 1
101073: ARRAY
101074: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
101075: LD_VAR 0 8
101079: PPUSH
101080: CALL_OW 301
101084: PUSH
101085: LD_VAR 0 5
101089: PUSH
101090: LD_VAR 0 8
101094: PPUSH
101095: CALL_OW 255
101099: NONEQUAL
101100: OR
101101: IFFALSE 101130
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
101103: LD_ADDR_EXP 155
101107: PUSH
101108: LD_EXP 155
101112: PPUSH
101113: LD_VAR 0 8
101117: PPUSH
101118: LD_INT 0
101120: PPUSH
101121: CALL_OW 1
101125: ST_TO_ADDR
// exit ;
101126: POP
101127: POP
101128: GO 101661
// end ; x := list [ i ] [ 3 ] ;
101130: LD_ADDR_VAR 0 6
101134: PUSH
101135: LD_VAR 0 3
101139: PUSH
101140: LD_VAR 0 1
101144: ARRAY
101145: PUSH
101146: LD_INT 3
101148: ARRAY
101149: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
101150: LD_ADDR_VAR 0 7
101154: PUSH
101155: LD_VAR 0 3
101159: PUSH
101160: LD_VAR 0 1
101164: ARRAY
101165: PUSH
101166: LD_INT 4
101168: ARRAY
101169: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
101170: LD_ADDR_VAR 0 9
101174: PUSH
101175: LD_VAR 0 6
101179: PPUSH
101180: LD_VAR 0 7
101184: PPUSH
101185: LD_INT 16
101187: PPUSH
101188: CALL 53278 0 3
101192: ST_TO_ADDR
// if not cratesNearbyPoint then
101193: LD_VAR 0 9
101197: NOT
101198: IFFALSE 101204
// exit ;
101200: POP
101201: POP
101202: GO 101661
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
101204: LD_ADDR_VAR 0 4
101208: PUSH
101209: LD_INT 22
101211: PUSH
101212: LD_VAR 0 5
101216: PUSH
101217: EMPTY
101218: LIST
101219: LIST
101220: PUSH
101221: LD_INT 3
101223: PUSH
101224: LD_INT 60
101226: PUSH
101227: EMPTY
101228: LIST
101229: PUSH
101230: EMPTY
101231: LIST
101232: LIST
101233: PUSH
101234: LD_INT 91
101236: PUSH
101237: LD_VAR 0 8
101241: PUSH
101242: LD_INT 6
101244: PUSH
101245: EMPTY
101246: LIST
101247: LIST
101248: LIST
101249: PUSH
101250: LD_INT 2
101252: PUSH
101253: LD_INT 25
101255: PUSH
101256: LD_INT 2
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 25
101265: PUSH
101266: LD_INT 16
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: LIST
101277: PUSH
101278: EMPTY
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: PPUSH
101284: CALL_OW 69
101288: PUSH
101289: LD_VAR 0 8
101293: PPUSH
101294: CALL_OW 313
101298: PPUSH
101299: LD_INT 3
101301: PUSH
101302: LD_INT 60
101304: PUSH
101305: EMPTY
101306: LIST
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PUSH
101312: LD_INT 2
101314: PUSH
101315: LD_INT 25
101317: PUSH
101318: LD_INT 2
101320: PUSH
101321: EMPTY
101322: LIST
101323: LIST
101324: PUSH
101325: LD_INT 25
101327: PUSH
101328: LD_INT 16
101330: PUSH
101331: EMPTY
101332: LIST
101333: LIST
101334: PUSH
101335: EMPTY
101336: LIST
101337: LIST
101338: LIST
101339: PUSH
101340: EMPTY
101341: LIST
101342: LIST
101343: PPUSH
101344: CALL_OW 72
101348: UNION
101349: ST_TO_ADDR
// if tmp then
101350: LD_VAR 0 4
101354: IFFALSE 101434
// begin tmp := ShrinkArray ( tmp , 3 ) ;
101356: LD_ADDR_VAR 0 4
101360: PUSH
101361: LD_VAR 0 4
101365: PPUSH
101366: LD_INT 3
101368: PPUSH
101369: CALL 51247 0 2
101373: ST_TO_ADDR
// for j in tmp do
101374: LD_ADDR_VAR 0 2
101378: PUSH
101379: LD_VAR 0 4
101383: PUSH
101384: FOR_IN
101385: IFFALSE 101428
// begin if IsInUnit ( j ) then
101387: LD_VAR 0 2
101391: PPUSH
101392: CALL_OW 310
101396: IFFALSE 101407
// ComExit ( j ) ;
101398: LD_VAR 0 2
101402: PPUSH
101403: CALL 51330 0 1
// AddComCollect ( j , x , y ) ;
101407: LD_VAR 0 2
101411: PPUSH
101412: LD_VAR 0 6
101416: PPUSH
101417: LD_VAR 0 7
101421: PPUSH
101422: CALL_OW 177
// end ;
101426: GO 101384
101428: POP
101429: POP
// exit ;
101430: POP
101431: POP
101432: GO 101661
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
101434: LD_ADDR_VAR 0 4
101438: PUSH
101439: LD_INT 22
101441: PUSH
101442: LD_VAR 0 5
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: PUSH
101451: LD_INT 91
101453: PUSH
101454: LD_VAR 0 8
101458: PUSH
101459: LD_INT 8
101461: PUSH
101462: EMPTY
101463: LIST
101464: LIST
101465: LIST
101466: PUSH
101467: LD_INT 2
101469: PUSH
101470: LD_INT 34
101472: PUSH
101473: LD_INT 12
101475: PUSH
101476: EMPTY
101477: LIST
101478: LIST
101479: PUSH
101480: LD_INT 34
101482: PUSH
101483: LD_INT 51
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PUSH
101490: LD_INT 34
101492: PUSH
101493: LD_INT 32
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: PUSH
101500: LD_INT 34
101502: PUSH
101503: LD_INT 89
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: LIST
101521: PPUSH
101522: CALL_OW 69
101526: ST_TO_ADDR
// if tmp then
101527: LD_VAR 0 4
101531: IFFALSE 101657
// begin for j in tmp do
101533: LD_ADDR_VAR 0 2
101537: PUSH
101538: LD_VAR 0 4
101542: PUSH
101543: FOR_IN
101544: IFFALSE 101655
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
101546: LD_VAR 0 2
101550: PPUSH
101551: CALL_OW 262
101555: PUSH
101556: LD_INT 3
101558: EQUAL
101559: PUSH
101560: LD_VAR 0 2
101564: PPUSH
101565: CALL_OW 261
101569: PUSH
101570: LD_INT 20
101572: GREATER
101573: OR
101574: PUSH
101575: LD_VAR 0 2
101579: PPUSH
101580: CALL_OW 314
101584: NOT
101585: AND
101586: PUSH
101587: LD_VAR 0 2
101591: PPUSH
101592: CALL_OW 263
101596: PUSH
101597: LD_INT 1
101599: NONEQUAL
101600: PUSH
101601: LD_VAR 0 2
101605: PPUSH
101606: CALL_OW 311
101610: OR
101611: AND
101612: IFFALSE 101653
// begin ComCollect ( j , x , y ) ;
101614: LD_VAR 0 2
101618: PPUSH
101619: LD_VAR 0 6
101623: PPUSH
101624: LD_VAR 0 7
101628: PPUSH
101629: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
101633: LD_VAR 0 2
101637: PPUSH
101638: LD_VAR 0 8
101642: PPUSH
101643: CALL_OW 172
// exit ;
101647: POP
101648: POP
101649: POP
101650: POP
101651: GO 101661
// end ;
101653: GO 101543
101655: POP
101656: POP
// end ; end ;
101657: GO 101032
101659: POP
101660: POP
// end ; end_of_file
101661: PPOPN 9
101663: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
101664: LD_INT 0
101666: PPUSH
101667: PPUSH
101668: PPUSH
101669: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
101670: LD_VAR 0 1
101674: PPUSH
101675: CALL_OW 264
101679: PUSH
101680: LD_INT 91
101682: EQUAL
101683: IFFALSE 101755
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
101685: LD_INT 68
101687: PPUSH
101688: LD_VAR 0 1
101692: PPUSH
101693: CALL_OW 255
101697: PPUSH
101698: CALL_OW 321
101702: PUSH
101703: LD_INT 2
101705: EQUAL
101706: IFFALSE 101718
// eff := 70 else
101708: LD_ADDR_VAR 0 4
101712: PUSH
101713: LD_INT 70
101715: ST_TO_ADDR
101716: GO 101726
// eff := 30 ;
101718: LD_ADDR_VAR 0 4
101722: PUSH
101723: LD_INT 30
101725: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
101726: LD_VAR 0 1
101730: PPUSH
101731: CALL_OW 250
101735: PPUSH
101736: LD_VAR 0 1
101740: PPUSH
101741: CALL_OW 251
101745: PPUSH
101746: LD_VAR 0 4
101750: PPUSH
101751: CALL_OW 495
// end ; end ;
101755: LD_VAR 0 2
101759: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
101760: LD_INT 0
101762: PPUSH
// end ;
101763: LD_VAR 0 4
101767: RET
// export function SOS_Command ( cmd ) ; begin
101768: LD_INT 0
101770: PPUSH
// end ;
101771: LD_VAR 0 2
101775: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
101776: LD_INT 0
101778: PPUSH
// end ;
101779: LD_VAR 0 6
101783: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
101784: LD_INT 0
101786: PPUSH
101787: PPUSH
// if not vehicle or not factory then
101788: LD_VAR 0 1
101792: NOT
101793: PUSH
101794: LD_VAR 0 2
101798: NOT
101799: OR
101800: IFFALSE 101804
// exit ;
101802: GO 102035
// if factoryWaypoints >= factory then
101804: LD_EXP 154
101808: PUSH
101809: LD_VAR 0 2
101813: GREATEREQUAL
101814: IFFALSE 102035
// if factoryWaypoints [ factory ] then
101816: LD_EXP 154
101820: PUSH
101821: LD_VAR 0 2
101825: ARRAY
101826: IFFALSE 102035
// begin if GetControl ( vehicle ) = control_manual then
101828: LD_VAR 0 1
101832: PPUSH
101833: CALL_OW 263
101837: PUSH
101838: LD_INT 1
101840: EQUAL
101841: IFFALSE 101922
// begin driver := IsDrivenBy ( vehicle ) ;
101843: LD_ADDR_VAR 0 4
101847: PUSH
101848: LD_VAR 0 1
101852: PPUSH
101853: CALL_OW 311
101857: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101858: LD_VAR 0 4
101862: PPUSH
101863: LD_EXP 154
101867: PUSH
101868: LD_VAR 0 2
101872: ARRAY
101873: PUSH
101874: LD_INT 3
101876: ARRAY
101877: PPUSH
101878: LD_EXP 154
101882: PUSH
101883: LD_VAR 0 2
101887: ARRAY
101888: PUSH
101889: LD_INT 4
101891: ARRAY
101892: PPUSH
101893: CALL_OW 171
// AddComExitVehicle ( driver ) ;
101897: LD_VAR 0 4
101901: PPUSH
101902: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
101906: LD_VAR 0 4
101910: PPUSH
101911: LD_VAR 0 2
101915: PPUSH
101916: CALL_OW 180
// end else
101920: GO 102035
// if GetControl ( vehicle ) = control_remote then
101922: LD_VAR 0 1
101926: PPUSH
101927: CALL_OW 263
101931: PUSH
101932: LD_INT 2
101934: EQUAL
101935: IFFALSE 101996
// begin wait ( 0 0$2 ) ;
101937: LD_INT 70
101939: PPUSH
101940: CALL_OW 67
// if Connect ( vehicle ) then
101944: LD_VAR 0 1
101948: PPUSH
101949: CALL 21551 0 1
101953: IFFALSE 101994
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101955: LD_VAR 0 1
101959: PPUSH
101960: LD_EXP 154
101964: PUSH
101965: LD_VAR 0 2
101969: ARRAY
101970: PUSH
101971: LD_INT 3
101973: ARRAY
101974: PPUSH
101975: LD_EXP 154
101979: PUSH
101980: LD_VAR 0 2
101984: ARRAY
101985: PUSH
101986: LD_INT 4
101988: ARRAY
101989: PPUSH
101990: CALL_OW 171
// end else
101994: GO 102035
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
101996: LD_VAR 0 1
102000: PPUSH
102001: LD_EXP 154
102005: PUSH
102006: LD_VAR 0 2
102010: ARRAY
102011: PUSH
102012: LD_INT 3
102014: ARRAY
102015: PPUSH
102016: LD_EXP 154
102020: PUSH
102021: LD_VAR 0 2
102025: ARRAY
102026: PUSH
102027: LD_INT 4
102029: ARRAY
102030: PPUSH
102031: CALL_OW 171
// end ; end ;
102035: LD_VAR 0 3
102039: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102040: LD_INT 0
102042: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102043: LD_VAR 0 1
102047: PUSH
102048: LD_INT 250
102050: EQUAL
102051: PUSH
102052: LD_VAR 0 2
102056: PPUSH
102057: CALL_OW 264
102061: PUSH
102062: LD_INT 81
102064: EQUAL
102065: AND
102066: IFFALSE 102087
// MinerPlaceMine ( unit , x , y ) ;
102068: LD_VAR 0 2
102072: PPUSH
102073: LD_VAR 0 4
102077: PPUSH
102078: LD_VAR 0 5
102082: PPUSH
102083: CALL 104472 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102087: LD_VAR 0 1
102091: PUSH
102092: LD_INT 251
102094: EQUAL
102095: PUSH
102096: LD_VAR 0 2
102100: PPUSH
102101: CALL_OW 264
102105: PUSH
102106: LD_INT 81
102108: EQUAL
102109: AND
102110: IFFALSE 102131
// MinerDetonateMine ( unit , x , y ) ;
102112: LD_VAR 0 2
102116: PPUSH
102117: LD_VAR 0 4
102121: PPUSH
102122: LD_VAR 0 5
102126: PPUSH
102127: CALL 104747 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102131: LD_VAR 0 1
102135: PUSH
102136: LD_INT 252
102138: EQUAL
102139: PUSH
102140: LD_VAR 0 2
102144: PPUSH
102145: CALL_OW 264
102149: PUSH
102150: LD_INT 81
102152: EQUAL
102153: AND
102154: IFFALSE 102175
// MinerCreateMinefield ( unit , x , y ) ;
102156: LD_VAR 0 2
102160: PPUSH
102161: LD_VAR 0 4
102165: PPUSH
102166: LD_VAR 0 5
102170: PPUSH
102171: CALL 105164 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
102175: LD_VAR 0 1
102179: PUSH
102180: LD_INT 253
102182: EQUAL
102183: PUSH
102184: LD_VAR 0 2
102188: PPUSH
102189: CALL_OW 257
102193: PUSH
102194: LD_INT 5
102196: EQUAL
102197: AND
102198: IFFALSE 102219
// ComBinocular ( unit , x , y ) ;
102200: LD_VAR 0 2
102204: PPUSH
102205: LD_VAR 0 4
102209: PPUSH
102210: LD_VAR 0 5
102214: PPUSH
102215: CALL 105533 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
102219: LD_VAR 0 1
102223: PUSH
102224: LD_INT 254
102226: EQUAL
102227: PUSH
102228: LD_VAR 0 2
102232: PPUSH
102233: CALL_OW 264
102237: PUSH
102238: LD_INT 99
102240: EQUAL
102241: AND
102242: PUSH
102243: LD_VAR 0 3
102247: PPUSH
102248: CALL_OW 263
102252: PUSH
102253: LD_INT 3
102255: EQUAL
102256: AND
102257: IFFALSE 102273
// HackDestroyVehicle ( unit , selectedUnit ) ;
102259: LD_VAR 0 2
102263: PPUSH
102264: LD_VAR 0 3
102268: PPUSH
102269: CALL 103836 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
102273: LD_VAR 0 1
102277: PUSH
102278: LD_INT 255
102280: EQUAL
102281: PUSH
102282: LD_VAR 0 2
102286: PPUSH
102287: CALL_OW 264
102291: PUSH
102292: LD_INT 14
102294: PUSH
102295: LD_INT 53
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: IN
102302: AND
102303: PUSH
102304: LD_VAR 0 4
102308: PPUSH
102309: LD_VAR 0 5
102313: PPUSH
102314: CALL_OW 488
102318: AND
102319: IFFALSE 102343
// CutTreeXYR ( unit , x , y , 12 ) ;
102321: LD_VAR 0 2
102325: PPUSH
102326: LD_VAR 0 4
102330: PPUSH
102331: LD_VAR 0 5
102335: PPUSH
102336: LD_INT 12
102338: PPUSH
102339: CALL 102406 0 4
// if cmd = 256 then
102343: LD_VAR 0 1
102347: PUSH
102348: LD_INT 256
102350: EQUAL
102351: IFFALSE 102372
// SetFactoryWaypoint ( unit , x , y ) ;
102353: LD_VAR 0 2
102357: PPUSH
102358: LD_VAR 0 4
102362: PPUSH
102363: LD_VAR 0 5
102367: PPUSH
102368: CALL 100353 0 3
// if cmd = 257 then
102372: LD_VAR 0 1
102376: PUSH
102377: LD_INT 257
102379: EQUAL
102380: IFFALSE 102401
// SetWarehouseGatheringPoint ( unit , x , y ) ;
102382: LD_VAR 0 2
102386: PPUSH
102387: LD_VAR 0 4
102391: PPUSH
102392: LD_VAR 0 5
102396: PPUSH
102397: CALL 100715 0 3
// end ;
102401: LD_VAR 0 6
102405: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
102406: LD_INT 0
102408: PPUSH
102409: PPUSH
102410: PPUSH
102411: PPUSH
102412: PPUSH
102413: PPUSH
102414: PPUSH
102415: PPUSH
102416: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
102417: LD_VAR 0 1
102421: NOT
102422: PUSH
102423: LD_VAR 0 2
102427: PPUSH
102428: LD_VAR 0 3
102432: PPUSH
102433: CALL_OW 488
102437: NOT
102438: OR
102439: PUSH
102440: LD_VAR 0 4
102444: NOT
102445: OR
102446: IFFALSE 102450
// exit ;
102448: GO 102790
// list := [ ] ;
102450: LD_ADDR_VAR 0 13
102454: PUSH
102455: EMPTY
102456: ST_TO_ADDR
// if x - r < 0 then
102457: LD_VAR 0 2
102461: PUSH
102462: LD_VAR 0 4
102466: MINUS
102467: PUSH
102468: LD_INT 0
102470: LESS
102471: IFFALSE 102483
// min_x := 0 else
102473: LD_ADDR_VAR 0 7
102477: PUSH
102478: LD_INT 0
102480: ST_TO_ADDR
102481: GO 102499
// min_x := x - r ;
102483: LD_ADDR_VAR 0 7
102487: PUSH
102488: LD_VAR 0 2
102492: PUSH
102493: LD_VAR 0 4
102497: MINUS
102498: ST_TO_ADDR
// if y - r < 0 then
102499: LD_VAR 0 3
102503: PUSH
102504: LD_VAR 0 4
102508: MINUS
102509: PUSH
102510: LD_INT 0
102512: LESS
102513: IFFALSE 102525
// min_y := 0 else
102515: LD_ADDR_VAR 0 8
102519: PUSH
102520: LD_INT 0
102522: ST_TO_ADDR
102523: GO 102541
// min_y := y - r ;
102525: LD_ADDR_VAR 0 8
102529: PUSH
102530: LD_VAR 0 3
102534: PUSH
102535: LD_VAR 0 4
102539: MINUS
102540: ST_TO_ADDR
// max_x := x + r ;
102541: LD_ADDR_VAR 0 9
102545: PUSH
102546: LD_VAR 0 2
102550: PUSH
102551: LD_VAR 0 4
102555: PLUS
102556: ST_TO_ADDR
// max_y := y + r ;
102557: LD_ADDR_VAR 0 10
102561: PUSH
102562: LD_VAR 0 3
102566: PUSH
102567: LD_VAR 0 4
102571: PLUS
102572: ST_TO_ADDR
// for _x = min_x to max_x do
102573: LD_ADDR_VAR 0 11
102577: PUSH
102578: DOUBLE
102579: LD_VAR 0 7
102583: DEC
102584: ST_TO_ADDR
102585: LD_VAR 0 9
102589: PUSH
102590: FOR_TO
102591: IFFALSE 102708
// for _y = min_y to max_y do
102593: LD_ADDR_VAR 0 12
102597: PUSH
102598: DOUBLE
102599: LD_VAR 0 8
102603: DEC
102604: ST_TO_ADDR
102605: LD_VAR 0 10
102609: PUSH
102610: FOR_TO
102611: IFFALSE 102704
// begin if not ValidHex ( _x , _y ) then
102613: LD_VAR 0 11
102617: PPUSH
102618: LD_VAR 0 12
102622: PPUSH
102623: CALL_OW 488
102627: NOT
102628: IFFALSE 102632
// continue ;
102630: GO 102610
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
102632: LD_VAR 0 11
102636: PPUSH
102637: LD_VAR 0 12
102641: PPUSH
102642: CALL_OW 351
102646: PUSH
102647: LD_VAR 0 11
102651: PPUSH
102652: LD_VAR 0 12
102656: PPUSH
102657: CALL_OW 554
102661: AND
102662: IFFALSE 102702
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
102664: LD_ADDR_VAR 0 13
102668: PUSH
102669: LD_VAR 0 13
102673: PPUSH
102674: LD_VAR 0 13
102678: PUSH
102679: LD_INT 1
102681: PLUS
102682: PPUSH
102683: LD_VAR 0 11
102687: PUSH
102688: LD_VAR 0 12
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: PPUSH
102697: CALL_OW 2
102701: ST_TO_ADDR
// end ;
102702: GO 102610
102704: POP
102705: POP
102706: GO 102590
102708: POP
102709: POP
// if not list then
102710: LD_VAR 0 13
102714: NOT
102715: IFFALSE 102719
// exit ;
102717: GO 102790
// for i in list do
102719: LD_ADDR_VAR 0 6
102723: PUSH
102724: LD_VAR 0 13
102728: PUSH
102729: FOR_IN
102730: IFFALSE 102788
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
102732: LD_VAR 0 1
102736: PPUSH
102737: LD_STRING M
102739: PUSH
102740: LD_VAR 0 6
102744: PUSH
102745: LD_INT 1
102747: ARRAY
102748: PUSH
102749: LD_VAR 0 6
102753: PUSH
102754: LD_INT 2
102756: ARRAY
102757: PUSH
102758: LD_INT 0
102760: PUSH
102761: LD_INT 0
102763: PUSH
102764: LD_INT 0
102766: PUSH
102767: LD_INT 0
102769: PUSH
102770: EMPTY
102771: LIST
102772: LIST
102773: LIST
102774: LIST
102775: LIST
102776: LIST
102777: LIST
102778: PUSH
102779: EMPTY
102780: LIST
102781: PPUSH
102782: CALL_OW 447
102786: GO 102729
102788: POP
102789: POP
// end ;
102790: LD_VAR 0 5
102794: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
102795: LD_EXP 157
102799: NOT
102800: IFFALSE 102850
102802: GO 102804
102804: DISABLE
// begin initHack := true ;
102805: LD_ADDR_EXP 157
102809: PUSH
102810: LD_INT 1
102812: ST_TO_ADDR
// hackTanks := [ ] ;
102813: LD_ADDR_EXP 158
102817: PUSH
102818: EMPTY
102819: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
102820: LD_ADDR_EXP 159
102824: PUSH
102825: EMPTY
102826: ST_TO_ADDR
// hackLimit := 3 ;
102827: LD_ADDR_EXP 160
102831: PUSH
102832: LD_INT 3
102834: ST_TO_ADDR
// hackDist := 12 ;
102835: LD_ADDR_EXP 161
102839: PUSH
102840: LD_INT 12
102842: ST_TO_ADDR
// hackCounter := [ ] ;
102843: LD_ADDR_EXP 162
102847: PUSH
102848: EMPTY
102849: ST_TO_ADDR
// end ;
102850: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
102851: LD_EXP 157
102855: PUSH
102856: LD_INT 34
102858: PUSH
102859: LD_INT 99
102861: PUSH
102862: EMPTY
102863: LIST
102864: LIST
102865: PPUSH
102866: CALL_OW 69
102870: AND
102871: IFFALSE 103124
102873: GO 102875
102875: DISABLE
102876: LD_INT 0
102878: PPUSH
102879: PPUSH
// begin enable ;
102880: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
102881: LD_ADDR_VAR 0 1
102885: PUSH
102886: LD_INT 34
102888: PUSH
102889: LD_INT 99
102891: PUSH
102892: EMPTY
102893: LIST
102894: LIST
102895: PPUSH
102896: CALL_OW 69
102900: PUSH
102901: FOR_IN
102902: IFFALSE 103122
// begin if not i in hackTanks then
102904: LD_VAR 0 1
102908: PUSH
102909: LD_EXP 158
102913: IN
102914: NOT
102915: IFFALSE 102998
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
102917: LD_ADDR_EXP 158
102921: PUSH
102922: LD_EXP 158
102926: PPUSH
102927: LD_EXP 158
102931: PUSH
102932: LD_INT 1
102934: PLUS
102935: PPUSH
102936: LD_VAR 0 1
102940: PPUSH
102941: CALL_OW 1
102945: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
102946: LD_ADDR_EXP 159
102950: PUSH
102951: LD_EXP 159
102955: PPUSH
102956: LD_EXP 159
102960: PUSH
102961: LD_INT 1
102963: PLUS
102964: PPUSH
102965: EMPTY
102966: PPUSH
102967: CALL_OW 1
102971: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
102972: LD_ADDR_EXP 162
102976: PUSH
102977: LD_EXP 162
102981: PPUSH
102982: LD_EXP 162
102986: PUSH
102987: LD_INT 1
102989: PLUS
102990: PPUSH
102991: EMPTY
102992: PPUSH
102993: CALL_OW 1
102997: ST_TO_ADDR
// end ; if not IsOk ( i ) then
102998: LD_VAR 0 1
103002: PPUSH
103003: CALL_OW 302
103007: NOT
103008: IFFALSE 103021
// begin HackUnlinkAll ( i ) ;
103010: LD_VAR 0 1
103014: PPUSH
103015: CALL 103127 0 1
// continue ;
103019: GO 102901
// end ; HackCheckCapturedStatus ( i ) ;
103021: LD_VAR 0 1
103025: PPUSH
103026: CALL 103570 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
103030: LD_ADDR_VAR 0 2
103034: PUSH
103035: LD_INT 81
103037: PUSH
103038: LD_VAR 0 1
103042: PPUSH
103043: CALL_OW 255
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PUSH
103052: LD_INT 33
103054: PUSH
103055: LD_INT 3
103057: PUSH
103058: EMPTY
103059: LIST
103060: LIST
103061: PUSH
103062: LD_INT 91
103064: PUSH
103065: LD_VAR 0 1
103069: PUSH
103070: LD_EXP 161
103074: PUSH
103075: EMPTY
103076: LIST
103077: LIST
103078: LIST
103079: PUSH
103080: LD_INT 50
103082: PUSH
103083: EMPTY
103084: LIST
103085: PUSH
103086: EMPTY
103087: LIST
103088: LIST
103089: LIST
103090: LIST
103091: PPUSH
103092: CALL_OW 69
103096: ST_TO_ADDR
// if not tmp then
103097: LD_VAR 0 2
103101: NOT
103102: IFFALSE 103106
// continue ;
103104: GO 102901
// HackLink ( i , tmp ) ;
103106: LD_VAR 0 1
103110: PPUSH
103111: LD_VAR 0 2
103115: PPUSH
103116: CALL 103263 0 2
// end ;
103120: GO 102901
103122: POP
103123: POP
// end ;
103124: PPOPN 2
103126: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103127: LD_INT 0
103129: PPUSH
103130: PPUSH
103131: PPUSH
// if not hack in hackTanks then
103132: LD_VAR 0 1
103136: PUSH
103137: LD_EXP 158
103141: IN
103142: NOT
103143: IFFALSE 103147
// exit ;
103145: GO 103258
// index := GetElementIndex ( hackTanks , hack ) ;
103147: LD_ADDR_VAR 0 4
103151: PUSH
103152: LD_EXP 158
103156: PPUSH
103157: LD_VAR 0 1
103161: PPUSH
103162: CALL 18358 0 2
103166: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
103167: LD_EXP 159
103171: PUSH
103172: LD_VAR 0 4
103176: ARRAY
103177: IFFALSE 103258
// begin for i in hackTanksCaptured [ index ] do
103179: LD_ADDR_VAR 0 3
103183: PUSH
103184: LD_EXP 159
103188: PUSH
103189: LD_VAR 0 4
103193: ARRAY
103194: PUSH
103195: FOR_IN
103196: IFFALSE 103222
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
103198: LD_VAR 0 3
103202: PUSH
103203: LD_INT 1
103205: ARRAY
103206: PPUSH
103207: LD_VAR 0 3
103211: PUSH
103212: LD_INT 2
103214: ARRAY
103215: PPUSH
103216: CALL_OW 235
103220: GO 103195
103222: POP
103223: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
103224: LD_ADDR_EXP 159
103228: PUSH
103229: LD_EXP 159
103233: PPUSH
103234: LD_VAR 0 4
103238: PPUSH
103239: EMPTY
103240: PPUSH
103241: CALL_OW 1
103245: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
103246: LD_VAR 0 1
103250: PPUSH
103251: LD_INT 0
103253: PPUSH
103254: CALL_OW 505
// end ; end ;
103258: LD_VAR 0 2
103262: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
103263: LD_INT 0
103265: PPUSH
103266: PPUSH
103267: PPUSH
// if not hack in hackTanks or not vehicles then
103268: LD_VAR 0 1
103272: PUSH
103273: LD_EXP 158
103277: IN
103278: NOT
103279: PUSH
103280: LD_VAR 0 2
103284: NOT
103285: OR
103286: IFFALSE 103290
// exit ;
103288: GO 103565
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
103290: LD_ADDR_VAR 0 2
103294: PUSH
103295: LD_VAR 0 1
103299: PPUSH
103300: LD_VAR 0 2
103304: PPUSH
103305: LD_INT 1
103307: PPUSH
103308: LD_INT 1
103310: PPUSH
103311: CALL 19008 0 4
103315: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
103316: LD_ADDR_VAR 0 5
103320: PUSH
103321: LD_EXP 158
103325: PPUSH
103326: LD_VAR 0 1
103330: PPUSH
103331: CALL 18358 0 2
103335: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
103336: LD_EXP 159
103340: PUSH
103341: LD_VAR 0 5
103345: ARRAY
103346: PUSH
103347: LD_EXP 160
103351: LESS
103352: IFFALSE 103541
// begin for i := 1 to vehicles do
103354: LD_ADDR_VAR 0 4
103358: PUSH
103359: DOUBLE
103360: LD_INT 1
103362: DEC
103363: ST_TO_ADDR
103364: LD_VAR 0 2
103368: PUSH
103369: FOR_TO
103370: IFFALSE 103539
// begin if hackTanksCaptured [ index ] = hackLimit then
103372: LD_EXP 159
103376: PUSH
103377: LD_VAR 0 5
103381: ARRAY
103382: PUSH
103383: LD_EXP 160
103387: EQUAL
103388: IFFALSE 103392
// break ;
103390: GO 103539
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
103392: LD_ADDR_EXP 162
103396: PUSH
103397: LD_EXP 162
103401: PPUSH
103402: LD_VAR 0 5
103406: PPUSH
103407: LD_EXP 162
103411: PUSH
103412: LD_VAR 0 5
103416: ARRAY
103417: PUSH
103418: LD_INT 1
103420: PLUS
103421: PPUSH
103422: CALL_OW 1
103426: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
103427: LD_ADDR_EXP 159
103431: PUSH
103432: LD_EXP 159
103436: PPUSH
103437: LD_VAR 0 5
103441: PUSH
103442: LD_EXP 159
103446: PUSH
103447: LD_VAR 0 5
103451: ARRAY
103452: PUSH
103453: LD_INT 1
103455: PLUS
103456: PUSH
103457: EMPTY
103458: LIST
103459: LIST
103460: PPUSH
103461: LD_VAR 0 2
103465: PUSH
103466: LD_VAR 0 4
103470: ARRAY
103471: PUSH
103472: LD_VAR 0 2
103476: PUSH
103477: LD_VAR 0 4
103481: ARRAY
103482: PPUSH
103483: CALL_OW 255
103487: PUSH
103488: EMPTY
103489: LIST
103490: LIST
103491: PPUSH
103492: CALL 18573 0 3
103496: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
103497: LD_VAR 0 2
103501: PUSH
103502: LD_VAR 0 4
103506: ARRAY
103507: PPUSH
103508: LD_VAR 0 1
103512: PPUSH
103513: CALL_OW 255
103517: PPUSH
103518: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
103522: LD_VAR 0 2
103526: PUSH
103527: LD_VAR 0 4
103531: ARRAY
103532: PPUSH
103533: CALL_OW 141
// end ;
103537: GO 103369
103539: POP
103540: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103541: LD_VAR 0 1
103545: PPUSH
103546: LD_EXP 159
103550: PUSH
103551: LD_VAR 0 5
103555: ARRAY
103556: PUSH
103557: LD_INT 0
103559: PLUS
103560: PPUSH
103561: CALL_OW 505
// end ;
103565: LD_VAR 0 3
103569: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
103570: LD_INT 0
103572: PPUSH
103573: PPUSH
103574: PPUSH
103575: PPUSH
// if not hack in hackTanks then
103576: LD_VAR 0 1
103580: PUSH
103581: LD_EXP 158
103585: IN
103586: NOT
103587: IFFALSE 103591
// exit ;
103589: GO 103831
// index := GetElementIndex ( hackTanks , hack ) ;
103591: LD_ADDR_VAR 0 4
103595: PUSH
103596: LD_EXP 158
103600: PPUSH
103601: LD_VAR 0 1
103605: PPUSH
103606: CALL 18358 0 2
103610: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
103611: LD_ADDR_VAR 0 3
103615: PUSH
103616: DOUBLE
103617: LD_EXP 159
103621: PUSH
103622: LD_VAR 0 4
103626: ARRAY
103627: INC
103628: ST_TO_ADDR
103629: LD_INT 1
103631: PUSH
103632: FOR_DOWNTO
103633: IFFALSE 103805
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
103635: LD_ADDR_VAR 0 5
103639: PUSH
103640: LD_EXP 159
103644: PUSH
103645: LD_VAR 0 4
103649: ARRAY
103650: PUSH
103651: LD_VAR 0 3
103655: ARRAY
103656: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
103657: LD_VAR 0 5
103661: PUSH
103662: LD_INT 1
103664: ARRAY
103665: PPUSH
103666: CALL_OW 302
103670: NOT
103671: PUSH
103672: LD_VAR 0 5
103676: PUSH
103677: LD_INT 1
103679: ARRAY
103680: PPUSH
103681: CALL_OW 255
103685: PUSH
103686: LD_VAR 0 1
103690: PPUSH
103691: CALL_OW 255
103695: NONEQUAL
103696: OR
103697: IFFALSE 103803
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
103699: LD_VAR 0 5
103703: PUSH
103704: LD_INT 1
103706: ARRAY
103707: PPUSH
103708: CALL_OW 305
103712: PUSH
103713: LD_VAR 0 5
103717: PUSH
103718: LD_INT 1
103720: ARRAY
103721: PPUSH
103722: CALL_OW 255
103726: PUSH
103727: LD_VAR 0 1
103731: PPUSH
103732: CALL_OW 255
103736: EQUAL
103737: AND
103738: IFFALSE 103762
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
103740: LD_VAR 0 5
103744: PUSH
103745: LD_INT 1
103747: ARRAY
103748: PPUSH
103749: LD_VAR 0 5
103753: PUSH
103754: LD_INT 2
103756: ARRAY
103757: PPUSH
103758: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
103762: LD_ADDR_EXP 159
103766: PUSH
103767: LD_EXP 159
103771: PPUSH
103772: LD_VAR 0 4
103776: PPUSH
103777: LD_EXP 159
103781: PUSH
103782: LD_VAR 0 4
103786: ARRAY
103787: PPUSH
103788: LD_VAR 0 3
103792: PPUSH
103793: CALL_OW 3
103797: PPUSH
103798: CALL_OW 1
103802: ST_TO_ADDR
// end ; end ;
103803: GO 103632
103805: POP
103806: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
103807: LD_VAR 0 1
103811: PPUSH
103812: LD_EXP 159
103816: PUSH
103817: LD_VAR 0 4
103821: ARRAY
103822: PUSH
103823: LD_INT 0
103825: PLUS
103826: PPUSH
103827: CALL_OW 505
// end ;
103831: LD_VAR 0 2
103835: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
103836: LD_INT 0
103838: PPUSH
103839: PPUSH
103840: PPUSH
103841: PPUSH
// if not hack in hackTanks then
103842: LD_VAR 0 1
103846: PUSH
103847: LD_EXP 158
103851: IN
103852: NOT
103853: IFFALSE 103857
// exit ;
103855: GO 103942
// index := GetElementIndex ( hackTanks , hack ) ;
103857: LD_ADDR_VAR 0 5
103861: PUSH
103862: LD_EXP 158
103866: PPUSH
103867: LD_VAR 0 1
103871: PPUSH
103872: CALL 18358 0 2
103876: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
103877: LD_ADDR_VAR 0 4
103881: PUSH
103882: DOUBLE
103883: LD_INT 1
103885: DEC
103886: ST_TO_ADDR
103887: LD_EXP 159
103891: PUSH
103892: LD_VAR 0 5
103896: ARRAY
103897: PUSH
103898: FOR_TO
103899: IFFALSE 103940
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
103901: LD_EXP 159
103905: PUSH
103906: LD_VAR 0 5
103910: ARRAY
103911: PUSH
103912: LD_VAR 0 4
103916: ARRAY
103917: PUSH
103918: LD_INT 1
103920: ARRAY
103921: PUSH
103922: LD_VAR 0 2
103926: EQUAL
103927: IFFALSE 103938
// KillUnit ( vehicle ) ;
103929: LD_VAR 0 2
103933: PPUSH
103934: CALL_OW 66
103938: GO 103898
103940: POP
103941: POP
// end ;
103942: LD_VAR 0 3
103946: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
103947: LD_EXP 163
103951: NOT
103952: IFFALSE 103987
103954: GO 103956
103956: DISABLE
// begin initMiner := true ;
103957: LD_ADDR_EXP 163
103961: PUSH
103962: LD_INT 1
103964: ST_TO_ADDR
// minersList := [ ] ;
103965: LD_ADDR_EXP 164
103969: PUSH
103970: EMPTY
103971: ST_TO_ADDR
// minerMinesList := [ ] ;
103972: LD_ADDR_EXP 165
103976: PUSH
103977: EMPTY
103978: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
103979: LD_ADDR_EXP 166
103983: PUSH
103984: LD_INT 5
103986: ST_TO_ADDR
// end ;
103987: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
103988: LD_EXP 163
103992: PUSH
103993: LD_INT 34
103995: PUSH
103996: LD_INT 81
103998: PUSH
103999: EMPTY
104000: LIST
104001: LIST
104002: PPUSH
104003: CALL_OW 69
104007: AND
104008: IFFALSE 104469
104010: GO 104012
104012: DISABLE
104013: LD_INT 0
104015: PPUSH
104016: PPUSH
104017: PPUSH
104018: PPUSH
// begin enable ;
104019: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
104020: LD_ADDR_VAR 0 1
104024: PUSH
104025: LD_INT 34
104027: PUSH
104028: LD_INT 81
104030: PUSH
104031: EMPTY
104032: LIST
104033: LIST
104034: PPUSH
104035: CALL_OW 69
104039: PUSH
104040: FOR_IN
104041: IFFALSE 104113
// begin if not i in minersList then
104043: LD_VAR 0 1
104047: PUSH
104048: LD_EXP 164
104052: IN
104053: NOT
104054: IFFALSE 104111
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
104056: LD_ADDR_EXP 164
104060: PUSH
104061: LD_EXP 164
104065: PPUSH
104066: LD_EXP 164
104070: PUSH
104071: LD_INT 1
104073: PLUS
104074: PPUSH
104075: LD_VAR 0 1
104079: PPUSH
104080: CALL_OW 1
104084: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104085: LD_ADDR_EXP 165
104089: PUSH
104090: LD_EXP 165
104094: PPUSH
104095: LD_EXP 165
104099: PUSH
104100: LD_INT 1
104102: PLUS
104103: PPUSH
104104: EMPTY
104105: PPUSH
104106: CALL_OW 1
104110: ST_TO_ADDR
// end end ;
104111: GO 104040
104113: POP
104114: POP
// for i := minerMinesList downto 1 do
104115: LD_ADDR_VAR 0 1
104119: PUSH
104120: DOUBLE
104121: LD_EXP 165
104125: INC
104126: ST_TO_ADDR
104127: LD_INT 1
104129: PUSH
104130: FOR_DOWNTO
104131: IFFALSE 104467
// begin if IsLive ( minersList [ i ] ) then
104133: LD_EXP 164
104137: PUSH
104138: LD_VAR 0 1
104142: ARRAY
104143: PPUSH
104144: CALL_OW 300
104148: IFFALSE 104176
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
104150: LD_EXP 164
104154: PUSH
104155: LD_VAR 0 1
104159: ARRAY
104160: PPUSH
104161: LD_EXP 165
104165: PUSH
104166: LD_VAR 0 1
104170: ARRAY
104171: PPUSH
104172: CALL_OW 505
// if not minerMinesList [ i ] then
104176: LD_EXP 165
104180: PUSH
104181: LD_VAR 0 1
104185: ARRAY
104186: NOT
104187: IFFALSE 104191
// continue ;
104189: GO 104130
// for j := minerMinesList [ i ] downto 1 do
104191: LD_ADDR_VAR 0 2
104195: PUSH
104196: DOUBLE
104197: LD_EXP 165
104201: PUSH
104202: LD_VAR 0 1
104206: ARRAY
104207: INC
104208: ST_TO_ADDR
104209: LD_INT 1
104211: PUSH
104212: FOR_DOWNTO
104213: IFFALSE 104463
// begin side := GetSide ( minersList [ i ] ) ;
104215: LD_ADDR_VAR 0 3
104219: PUSH
104220: LD_EXP 164
104224: PUSH
104225: LD_VAR 0 1
104229: ARRAY
104230: PPUSH
104231: CALL_OW 255
104235: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
104236: LD_ADDR_VAR 0 4
104240: PUSH
104241: LD_EXP 165
104245: PUSH
104246: LD_VAR 0 1
104250: ARRAY
104251: PUSH
104252: LD_VAR 0 2
104256: ARRAY
104257: PUSH
104258: LD_INT 1
104260: ARRAY
104261: PPUSH
104262: LD_EXP 165
104266: PUSH
104267: LD_VAR 0 1
104271: ARRAY
104272: PUSH
104273: LD_VAR 0 2
104277: ARRAY
104278: PUSH
104279: LD_INT 2
104281: ARRAY
104282: PPUSH
104283: CALL_OW 428
104287: ST_TO_ADDR
// if not tmp then
104288: LD_VAR 0 4
104292: NOT
104293: IFFALSE 104297
// continue ;
104295: GO 104212
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
104297: LD_VAR 0 4
104301: PUSH
104302: LD_INT 81
104304: PUSH
104305: LD_VAR 0 3
104309: PUSH
104310: EMPTY
104311: LIST
104312: LIST
104313: PPUSH
104314: CALL_OW 69
104318: IN
104319: PUSH
104320: LD_EXP 165
104324: PUSH
104325: LD_VAR 0 1
104329: ARRAY
104330: PUSH
104331: LD_VAR 0 2
104335: ARRAY
104336: PUSH
104337: LD_INT 1
104339: ARRAY
104340: PPUSH
104341: LD_EXP 165
104345: PUSH
104346: LD_VAR 0 1
104350: ARRAY
104351: PUSH
104352: LD_VAR 0 2
104356: ARRAY
104357: PUSH
104358: LD_INT 2
104360: ARRAY
104361: PPUSH
104362: CALL_OW 458
104366: AND
104367: IFFALSE 104461
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
104369: LD_EXP 165
104373: PUSH
104374: LD_VAR 0 1
104378: ARRAY
104379: PUSH
104380: LD_VAR 0 2
104384: ARRAY
104385: PUSH
104386: LD_INT 1
104388: ARRAY
104389: PPUSH
104390: LD_EXP 165
104394: PUSH
104395: LD_VAR 0 1
104399: ARRAY
104400: PUSH
104401: LD_VAR 0 2
104405: ARRAY
104406: PUSH
104407: LD_INT 2
104409: ARRAY
104410: PPUSH
104411: LD_VAR 0 3
104415: PPUSH
104416: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
104420: LD_ADDR_EXP 165
104424: PUSH
104425: LD_EXP 165
104429: PPUSH
104430: LD_VAR 0 1
104434: PPUSH
104435: LD_EXP 165
104439: PUSH
104440: LD_VAR 0 1
104444: ARRAY
104445: PPUSH
104446: LD_VAR 0 2
104450: PPUSH
104451: CALL_OW 3
104455: PPUSH
104456: CALL_OW 1
104460: ST_TO_ADDR
// end ; end ;
104461: GO 104212
104463: POP
104464: POP
// end ;
104465: GO 104130
104467: POP
104468: POP
// end ;
104469: PPOPN 4
104471: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
104472: LD_INT 0
104474: PPUSH
104475: PPUSH
// result := false ;
104476: LD_ADDR_VAR 0 4
104480: PUSH
104481: LD_INT 0
104483: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
104484: LD_VAR 0 1
104488: PPUSH
104489: CALL_OW 264
104493: PUSH
104494: LD_INT 81
104496: EQUAL
104497: NOT
104498: IFFALSE 104502
// exit ;
104500: GO 104742
// index := GetElementIndex ( minersList , unit ) ;
104502: LD_ADDR_VAR 0 5
104506: PUSH
104507: LD_EXP 164
104511: PPUSH
104512: LD_VAR 0 1
104516: PPUSH
104517: CALL 18358 0 2
104521: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
104522: LD_EXP 165
104526: PUSH
104527: LD_VAR 0 5
104531: ARRAY
104532: PUSH
104533: LD_EXP 166
104537: GREATEREQUAL
104538: IFFALSE 104542
// exit ;
104540: GO 104742
// ComMoveXY ( unit , x , y ) ;
104542: LD_VAR 0 1
104546: PPUSH
104547: LD_VAR 0 2
104551: PPUSH
104552: LD_VAR 0 3
104556: PPUSH
104557: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104561: LD_INT 35
104563: PPUSH
104564: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
104568: LD_VAR 0 1
104572: PPUSH
104573: LD_VAR 0 2
104577: PPUSH
104578: LD_VAR 0 3
104582: PPUSH
104583: CALL 49742 0 3
104587: NOT
104588: PUSH
104589: LD_VAR 0 1
104593: PPUSH
104594: CALL_OW 314
104598: AND
104599: IFFALSE 104603
// exit ;
104601: GO 104742
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
104603: LD_VAR 0 2
104607: PPUSH
104608: LD_VAR 0 3
104612: PPUSH
104613: CALL_OW 428
104617: PUSH
104618: LD_VAR 0 1
104622: EQUAL
104623: PUSH
104624: LD_VAR 0 1
104628: PPUSH
104629: CALL_OW 314
104633: NOT
104634: AND
104635: IFFALSE 104561
// PlaySoundXY ( x , y , PlantMine ) ;
104637: LD_VAR 0 2
104641: PPUSH
104642: LD_VAR 0 3
104646: PPUSH
104647: LD_STRING PlantMine
104649: PPUSH
104650: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
104654: LD_VAR 0 2
104658: PPUSH
104659: LD_VAR 0 3
104663: PPUSH
104664: LD_VAR 0 1
104668: PPUSH
104669: CALL_OW 255
104673: PPUSH
104674: LD_INT 0
104676: PPUSH
104677: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
104681: LD_ADDR_EXP 165
104685: PUSH
104686: LD_EXP 165
104690: PPUSH
104691: LD_VAR 0 5
104695: PUSH
104696: LD_EXP 165
104700: PUSH
104701: LD_VAR 0 5
104705: ARRAY
104706: PUSH
104707: LD_INT 1
104709: PLUS
104710: PUSH
104711: EMPTY
104712: LIST
104713: LIST
104714: PPUSH
104715: LD_VAR 0 2
104719: PUSH
104720: LD_VAR 0 3
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: PPUSH
104729: CALL 18573 0 3
104733: ST_TO_ADDR
// result := true ;
104734: LD_ADDR_VAR 0 4
104738: PUSH
104739: LD_INT 1
104741: ST_TO_ADDR
// end ;
104742: LD_VAR 0 4
104746: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
104747: LD_INT 0
104749: PPUSH
104750: PPUSH
104751: PPUSH
// if not unit in minersList then
104752: LD_VAR 0 1
104756: PUSH
104757: LD_EXP 164
104761: IN
104762: NOT
104763: IFFALSE 104767
// exit ;
104765: GO 105159
// index := GetElementIndex ( minersList , unit ) ;
104767: LD_ADDR_VAR 0 6
104771: PUSH
104772: LD_EXP 164
104776: PPUSH
104777: LD_VAR 0 1
104781: PPUSH
104782: CALL 18358 0 2
104786: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
104787: LD_ADDR_VAR 0 5
104791: PUSH
104792: DOUBLE
104793: LD_EXP 165
104797: PUSH
104798: LD_VAR 0 6
104802: ARRAY
104803: INC
104804: ST_TO_ADDR
104805: LD_INT 1
104807: PUSH
104808: FOR_DOWNTO
104809: IFFALSE 104970
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
104811: LD_EXP 165
104815: PUSH
104816: LD_VAR 0 6
104820: ARRAY
104821: PUSH
104822: LD_VAR 0 5
104826: ARRAY
104827: PUSH
104828: LD_INT 1
104830: ARRAY
104831: PUSH
104832: LD_VAR 0 2
104836: EQUAL
104837: PUSH
104838: LD_EXP 165
104842: PUSH
104843: LD_VAR 0 6
104847: ARRAY
104848: PUSH
104849: LD_VAR 0 5
104853: ARRAY
104854: PUSH
104855: LD_INT 2
104857: ARRAY
104858: PUSH
104859: LD_VAR 0 3
104863: EQUAL
104864: AND
104865: IFFALSE 104968
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
104867: LD_EXP 165
104871: PUSH
104872: LD_VAR 0 6
104876: ARRAY
104877: PUSH
104878: LD_VAR 0 5
104882: ARRAY
104883: PUSH
104884: LD_INT 1
104886: ARRAY
104887: PPUSH
104888: LD_EXP 165
104892: PUSH
104893: LD_VAR 0 6
104897: ARRAY
104898: PUSH
104899: LD_VAR 0 5
104903: ARRAY
104904: PUSH
104905: LD_INT 2
104907: ARRAY
104908: PPUSH
104909: LD_VAR 0 1
104913: PPUSH
104914: CALL_OW 255
104918: PPUSH
104919: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
104923: LD_ADDR_EXP 165
104927: PUSH
104928: LD_EXP 165
104932: PPUSH
104933: LD_VAR 0 6
104937: PPUSH
104938: LD_EXP 165
104942: PUSH
104943: LD_VAR 0 6
104947: ARRAY
104948: PPUSH
104949: LD_VAR 0 5
104953: PPUSH
104954: CALL_OW 3
104958: PPUSH
104959: CALL_OW 1
104963: ST_TO_ADDR
// exit ;
104964: POP
104965: POP
104966: GO 105159
// end ; end ;
104968: GO 104808
104970: POP
104971: POP
// for i := minerMinesList [ index ] downto 1 do
104972: LD_ADDR_VAR 0 5
104976: PUSH
104977: DOUBLE
104978: LD_EXP 165
104982: PUSH
104983: LD_VAR 0 6
104987: ARRAY
104988: INC
104989: ST_TO_ADDR
104990: LD_INT 1
104992: PUSH
104993: FOR_DOWNTO
104994: IFFALSE 105157
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
104996: LD_EXP 165
105000: PUSH
105001: LD_VAR 0 6
105005: ARRAY
105006: PUSH
105007: LD_VAR 0 5
105011: ARRAY
105012: PUSH
105013: LD_INT 1
105015: ARRAY
105016: PPUSH
105017: LD_EXP 165
105021: PUSH
105022: LD_VAR 0 6
105026: ARRAY
105027: PUSH
105028: LD_VAR 0 5
105032: ARRAY
105033: PUSH
105034: LD_INT 2
105036: ARRAY
105037: PPUSH
105038: LD_VAR 0 2
105042: PPUSH
105043: LD_VAR 0 3
105047: PPUSH
105048: CALL_OW 298
105052: PUSH
105053: LD_INT 6
105055: LESS
105056: IFFALSE 105155
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105058: LD_EXP 165
105062: PUSH
105063: LD_VAR 0 6
105067: ARRAY
105068: PUSH
105069: LD_VAR 0 5
105073: ARRAY
105074: PUSH
105075: LD_INT 1
105077: ARRAY
105078: PPUSH
105079: LD_EXP 165
105083: PUSH
105084: LD_VAR 0 6
105088: ARRAY
105089: PUSH
105090: LD_VAR 0 5
105094: ARRAY
105095: PUSH
105096: LD_INT 2
105098: ARRAY
105099: PPUSH
105100: LD_VAR 0 1
105104: PPUSH
105105: CALL_OW 255
105109: PPUSH
105110: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105114: LD_ADDR_EXP 165
105118: PUSH
105119: LD_EXP 165
105123: PPUSH
105124: LD_VAR 0 6
105128: PPUSH
105129: LD_EXP 165
105133: PUSH
105134: LD_VAR 0 6
105138: ARRAY
105139: PPUSH
105140: LD_VAR 0 5
105144: PPUSH
105145: CALL_OW 3
105149: PPUSH
105150: CALL_OW 1
105154: ST_TO_ADDR
// end ; end ;
105155: GO 104993
105157: POP
105158: POP
// end ;
105159: LD_VAR 0 4
105163: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
105164: LD_INT 0
105166: PPUSH
105167: PPUSH
105168: PPUSH
105169: PPUSH
105170: PPUSH
105171: PPUSH
105172: PPUSH
105173: PPUSH
105174: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
105175: LD_VAR 0 1
105179: PPUSH
105180: CALL_OW 264
105184: PUSH
105185: LD_INT 81
105187: EQUAL
105188: NOT
105189: PUSH
105190: LD_VAR 0 1
105194: PUSH
105195: LD_EXP 164
105199: IN
105200: NOT
105201: OR
105202: IFFALSE 105206
// exit ;
105204: GO 105528
// index := GetElementIndex ( minersList , unit ) ;
105206: LD_ADDR_VAR 0 6
105210: PUSH
105211: LD_EXP 164
105215: PPUSH
105216: LD_VAR 0 1
105220: PPUSH
105221: CALL 18358 0 2
105225: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
105226: LD_ADDR_VAR 0 8
105230: PUSH
105231: LD_EXP 166
105235: PUSH
105236: LD_EXP 165
105240: PUSH
105241: LD_VAR 0 6
105245: ARRAY
105246: MINUS
105247: ST_TO_ADDR
// if not minesFreeAmount then
105248: LD_VAR 0 8
105252: NOT
105253: IFFALSE 105257
// exit ;
105255: GO 105528
// tmp := [ ] ;
105257: LD_ADDR_VAR 0 7
105261: PUSH
105262: EMPTY
105263: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
105264: LD_ADDR_VAR 0 5
105268: PUSH
105269: DOUBLE
105270: LD_INT 1
105272: DEC
105273: ST_TO_ADDR
105274: LD_VAR 0 8
105278: PUSH
105279: FOR_TO
105280: IFFALSE 105475
// begin _d := rand ( 0 , 5 ) ;
105282: LD_ADDR_VAR 0 11
105286: PUSH
105287: LD_INT 0
105289: PPUSH
105290: LD_INT 5
105292: PPUSH
105293: CALL_OW 12
105297: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
105298: LD_ADDR_VAR 0 12
105302: PUSH
105303: LD_INT 2
105305: PPUSH
105306: LD_INT 6
105308: PPUSH
105309: CALL_OW 12
105313: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
105314: LD_ADDR_VAR 0 9
105318: PUSH
105319: LD_VAR 0 2
105323: PPUSH
105324: LD_VAR 0 11
105328: PPUSH
105329: LD_VAR 0 12
105333: PPUSH
105334: CALL_OW 272
105338: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
105339: LD_ADDR_VAR 0 10
105343: PUSH
105344: LD_VAR 0 3
105348: PPUSH
105349: LD_VAR 0 11
105353: PPUSH
105354: LD_VAR 0 12
105358: PPUSH
105359: CALL_OW 273
105363: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
105364: LD_VAR 0 9
105368: PPUSH
105369: LD_VAR 0 10
105373: PPUSH
105374: CALL_OW 488
105378: PUSH
105379: LD_VAR 0 9
105383: PUSH
105384: LD_VAR 0 10
105388: PUSH
105389: EMPTY
105390: LIST
105391: LIST
105392: PUSH
105393: LD_VAR 0 7
105397: IN
105398: NOT
105399: AND
105400: PUSH
105401: LD_VAR 0 9
105405: PPUSH
105406: LD_VAR 0 10
105410: PPUSH
105411: CALL_OW 458
105415: NOT
105416: AND
105417: IFFALSE 105459
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
105419: LD_ADDR_VAR 0 7
105423: PUSH
105424: LD_VAR 0 7
105428: PPUSH
105429: LD_VAR 0 7
105433: PUSH
105434: LD_INT 1
105436: PLUS
105437: PPUSH
105438: LD_VAR 0 9
105442: PUSH
105443: LD_VAR 0 10
105447: PUSH
105448: EMPTY
105449: LIST
105450: LIST
105451: PPUSH
105452: CALL_OW 1
105456: ST_TO_ADDR
105457: GO 105473
// i := i - 1 ;
105459: LD_ADDR_VAR 0 5
105463: PUSH
105464: LD_VAR 0 5
105468: PUSH
105469: LD_INT 1
105471: MINUS
105472: ST_TO_ADDR
// end ;
105473: GO 105279
105475: POP
105476: POP
// for i in tmp do
105477: LD_ADDR_VAR 0 5
105481: PUSH
105482: LD_VAR 0 7
105486: PUSH
105487: FOR_IN
105488: IFFALSE 105526
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
105490: LD_VAR 0 1
105494: PPUSH
105495: LD_VAR 0 5
105499: PUSH
105500: LD_INT 1
105502: ARRAY
105503: PPUSH
105504: LD_VAR 0 5
105508: PUSH
105509: LD_INT 2
105511: ARRAY
105512: PPUSH
105513: CALL 104472 0 3
105517: NOT
105518: IFFALSE 105524
// exit ;
105520: POP
105521: POP
105522: GO 105528
105524: GO 105487
105526: POP
105527: POP
// end ;
105528: LD_VAR 0 4
105532: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
105533: LD_INT 0
105535: PPUSH
105536: PPUSH
105537: PPUSH
105538: PPUSH
105539: PPUSH
105540: PPUSH
105541: PPUSH
// if not GetClass ( unit ) = class_sniper then
105542: LD_VAR 0 1
105546: PPUSH
105547: CALL_OW 257
105551: PUSH
105552: LD_INT 5
105554: EQUAL
105555: NOT
105556: IFFALSE 105560
// exit ;
105558: GO 105948
// dist := 8 ;
105560: LD_ADDR_VAR 0 5
105564: PUSH
105565: LD_INT 8
105567: ST_TO_ADDR
// viewRange := 12 ;
105568: LD_ADDR_VAR 0 7
105572: PUSH
105573: LD_INT 12
105575: ST_TO_ADDR
// side := GetSide ( unit ) ;
105576: LD_ADDR_VAR 0 6
105580: PUSH
105581: LD_VAR 0 1
105585: PPUSH
105586: CALL_OW 255
105590: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
105591: LD_INT 61
105593: PPUSH
105594: LD_VAR 0 6
105598: PPUSH
105599: CALL_OW 321
105603: PUSH
105604: LD_INT 2
105606: EQUAL
105607: IFFALSE 105617
// viewRange := 16 ;
105609: LD_ADDR_VAR 0 7
105613: PUSH
105614: LD_INT 16
105616: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
105617: LD_VAR 0 1
105621: PPUSH
105622: LD_VAR 0 2
105626: PPUSH
105627: LD_VAR 0 3
105631: PPUSH
105632: CALL_OW 297
105636: PUSH
105637: LD_VAR 0 5
105641: GREATER
105642: IFFALSE 105721
// begin ComMoveXY ( unit , x , y ) ;
105644: LD_VAR 0 1
105648: PPUSH
105649: LD_VAR 0 2
105653: PPUSH
105654: LD_VAR 0 3
105658: PPUSH
105659: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105663: LD_INT 35
105665: PPUSH
105666: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
105670: LD_VAR 0 1
105674: PPUSH
105675: LD_VAR 0 2
105679: PPUSH
105680: LD_VAR 0 3
105684: PPUSH
105685: CALL 49742 0 3
105689: NOT
105690: IFFALSE 105694
// exit ;
105692: GO 105948
// until GetDistUnitXY ( unit , x , y ) < dist ;
105694: LD_VAR 0 1
105698: PPUSH
105699: LD_VAR 0 2
105703: PPUSH
105704: LD_VAR 0 3
105708: PPUSH
105709: CALL_OW 297
105713: PUSH
105714: LD_VAR 0 5
105718: LESS
105719: IFFALSE 105663
// end ; ComTurnXY ( unit , x , y ) ;
105721: LD_VAR 0 1
105725: PPUSH
105726: LD_VAR 0 2
105730: PPUSH
105731: LD_VAR 0 3
105735: PPUSH
105736: CALL_OW 118
// wait ( 5 ) ;
105740: LD_INT 5
105742: PPUSH
105743: CALL_OW 67
// _d := GetDir ( unit ) ;
105747: LD_ADDR_VAR 0 10
105751: PUSH
105752: LD_VAR 0 1
105756: PPUSH
105757: CALL_OW 254
105761: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
105762: LD_ADDR_VAR 0 8
105766: PUSH
105767: LD_VAR 0 1
105771: PPUSH
105772: CALL_OW 250
105776: PPUSH
105777: LD_VAR 0 10
105781: PPUSH
105782: LD_VAR 0 5
105786: PPUSH
105787: CALL_OW 272
105791: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
105792: LD_ADDR_VAR 0 9
105796: PUSH
105797: LD_VAR 0 1
105801: PPUSH
105802: CALL_OW 251
105806: PPUSH
105807: LD_VAR 0 10
105811: PPUSH
105812: LD_VAR 0 5
105816: PPUSH
105817: CALL_OW 273
105821: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
105822: LD_VAR 0 8
105826: PPUSH
105827: LD_VAR 0 9
105831: PPUSH
105832: CALL_OW 488
105836: NOT
105837: IFFALSE 105841
// exit ;
105839: GO 105948
// ComAnimCustom ( unit , 1 ) ;
105841: LD_VAR 0 1
105845: PPUSH
105846: LD_INT 1
105848: PPUSH
105849: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
105853: LD_VAR 0 8
105857: PPUSH
105858: LD_VAR 0 9
105862: PPUSH
105863: LD_VAR 0 6
105867: PPUSH
105868: LD_VAR 0 7
105872: PPUSH
105873: CALL_OW 330
// repeat wait ( 1 ) ;
105877: LD_INT 1
105879: PPUSH
105880: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
105884: LD_VAR 0 1
105888: PPUSH
105889: CALL_OW 316
105893: PUSH
105894: LD_VAR 0 1
105898: PPUSH
105899: CALL_OW 314
105903: OR
105904: PUSH
105905: LD_VAR 0 1
105909: PPUSH
105910: CALL_OW 302
105914: NOT
105915: OR
105916: PUSH
105917: LD_VAR 0 1
105921: PPUSH
105922: CALL_OW 301
105926: OR
105927: IFFALSE 105877
// RemoveSeeing ( _x , _y , side ) ;
105929: LD_VAR 0 8
105933: PPUSH
105934: LD_VAR 0 9
105938: PPUSH
105939: LD_VAR 0 6
105943: PPUSH
105944: CALL_OW 331
// end ; end_of_file
105948: LD_VAR 0 4
105952: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
105953: LD_INT 0
105955: PPUSH
105956: PPUSH
105957: PPUSH
105958: PPUSH
105959: PPUSH
105960: PPUSH
105961: PPUSH
105962: PPUSH
105963: PPUSH
105964: PPUSH
105965: PPUSH
105966: PPUSH
105967: PPUSH
105968: PPUSH
105969: PPUSH
105970: PPUSH
105971: PPUSH
105972: PPUSH
105973: PPUSH
105974: PPUSH
105975: PPUSH
105976: PPUSH
105977: PPUSH
105978: PPUSH
105979: PPUSH
105980: PPUSH
105981: PPUSH
105982: PPUSH
105983: PPUSH
105984: PPUSH
105985: PPUSH
105986: PPUSH
105987: PPUSH
105988: PPUSH
// if not list then
105989: LD_VAR 0 1
105993: NOT
105994: IFFALSE 105998
// exit ;
105996: GO 110657
// base := list [ 1 ] ;
105998: LD_ADDR_VAR 0 3
106002: PUSH
106003: LD_VAR 0 1
106007: PUSH
106008: LD_INT 1
106010: ARRAY
106011: ST_TO_ADDR
// group := list [ 2 ] ;
106012: LD_ADDR_VAR 0 4
106016: PUSH
106017: LD_VAR 0 1
106021: PUSH
106022: LD_INT 2
106024: ARRAY
106025: ST_TO_ADDR
// path := list [ 3 ] ;
106026: LD_ADDR_VAR 0 5
106030: PUSH
106031: LD_VAR 0 1
106035: PUSH
106036: LD_INT 3
106038: ARRAY
106039: ST_TO_ADDR
// flags := list [ 4 ] ;
106040: LD_ADDR_VAR 0 6
106044: PUSH
106045: LD_VAR 0 1
106049: PUSH
106050: LD_INT 4
106052: ARRAY
106053: ST_TO_ADDR
// mined := [ ] ;
106054: LD_ADDR_VAR 0 27
106058: PUSH
106059: EMPTY
106060: ST_TO_ADDR
// bombed := [ ] ;
106061: LD_ADDR_VAR 0 28
106065: PUSH
106066: EMPTY
106067: ST_TO_ADDR
// healers := [ ] ;
106068: LD_ADDR_VAR 0 31
106072: PUSH
106073: EMPTY
106074: ST_TO_ADDR
// to_heal := [ ] ;
106075: LD_ADDR_VAR 0 30
106079: PUSH
106080: EMPTY
106081: ST_TO_ADDR
// repairs := [ ] ;
106082: LD_ADDR_VAR 0 33
106086: PUSH
106087: EMPTY
106088: ST_TO_ADDR
// to_repair := [ ] ;
106089: LD_ADDR_VAR 0 32
106093: PUSH
106094: EMPTY
106095: ST_TO_ADDR
// if not group or not path then
106096: LD_VAR 0 4
106100: NOT
106101: PUSH
106102: LD_VAR 0 5
106106: NOT
106107: OR
106108: IFFALSE 106112
// exit ;
106110: GO 110657
// side := GetSide ( group [ 1 ] ) ;
106112: LD_ADDR_VAR 0 35
106116: PUSH
106117: LD_VAR 0 4
106121: PUSH
106122: LD_INT 1
106124: ARRAY
106125: PPUSH
106126: CALL_OW 255
106130: ST_TO_ADDR
// if flags then
106131: LD_VAR 0 6
106135: IFFALSE 106279
// begin f_ignore_area := flags [ 1 ] ;
106137: LD_ADDR_VAR 0 17
106141: PUSH
106142: LD_VAR 0 6
106146: PUSH
106147: LD_INT 1
106149: ARRAY
106150: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
106151: LD_ADDR_VAR 0 18
106155: PUSH
106156: LD_VAR 0 6
106160: PUSH
106161: LD_INT 2
106163: ARRAY
106164: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
106165: LD_ADDR_VAR 0 19
106169: PUSH
106170: LD_VAR 0 6
106174: PUSH
106175: LD_INT 3
106177: ARRAY
106178: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
106179: LD_ADDR_VAR 0 20
106183: PUSH
106184: LD_VAR 0 6
106188: PUSH
106189: LD_INT 4
106191: ARRAY
106192: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
106193: LD_ADDR_VAR 0 21
106197: PUSH
106198: LD_VAR 0 6
106202: PUSH
106203: LD_INT 5
106205: ARRAY
106206: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
106207: LD_ADDR_VAR 0 22
106211: PUSH
106212: LD_VAR 0 6
106216: PUSH
106217: LD_INT 6
106219: ARRAY
106220: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
106221: LD_ADDR_VAR 0 23
106225: PUSH
106226: LD_VAR 0 6
106230: PUSH
106231: LD_INT 7
106233: ARRAY
106234: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
106235: LD_ADDR_VAR 0 24
106239: PUSH
106240: LD_VAR 0 6
106244: PUSH
106245: LD_INT 8
106247: ARRAY
106248: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
106249: LD_ADDR_VAR 0 25
106253: PUSH
106254: LD_VAR 0 6
106258: PUSH
106259: LD_INT 9
106261: ARRAY
106262: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
106263: LD_ADDR_VAR 0 26
106267: PUSH
106268: LD_VAR 0 6
106272: PUSH
106273: LD_INT 10
106275: ARRAY
106276: ST_TO_ADDR
// end else
106277: GO 106359
// begin f_ignore_area := false ;
106279: LD_ADDR_VAR 0 17
106283: PUSH
106284: LD_INT 0
106286: ST_TO_ADDR
// f_capture := false ;
106287: LD_ADDR_VAR 0 18
106291: PUSH
106292: LD_INT 0
106294: ST_TO_ADDR
// f_ignore_civ := false ;
106295: LD_ADDR_VAR 0 19
106299: PUSH
106300: LD_INT 0
106302: ST_TO_ADDR
// f_murder := false ;
106303: LD_ADDR_VAR 0 20
106307: PUSH
106308: LD_INT 0
106310: ST_TO_ADDR
// f_mines := false ;
106311: LD_ADDR_VAR 0 21
106315: PUSH
106316: LD_INT 0
106318: ST_TO_ADDR
// f_repair := false ;
106319: LD_ADDR_VAR 0 22
106323: PUSH
106324: LD_INT 0
106326: ST_TO_ADDR
// f_heal := false ;
106327: LD_ADDR_VAR 0 23
106331: PUSH
106332: LD_INT 0
106334: ST_TO_ADDR
// f_spacetime := false ;
106335: LD_ADDR_VAR 0 24
106339: PUSH
106340: LD_INT 0
106342: ST_TO_ADDR
// f_attack_depot := false ;
106343: LD_ADDR_VAR 0 25
106347: PUSH
106348: LD_INT 0
106350: ST_TO_ADDR
// f_crawl := false ;
106351: LD_ADDR_VAR 0 26
106355: PUSH
106356: LD_INT 0
106358: ST_TO_ADDR
// end ; if f_heal then
106359: LD_VAR 0 23
106363: IFFALSE 106390
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
106365: LD_ADDR_VAR 0 31
106369: PUSH
106370: LD_VAR 0 4
106374: PPUSH
106375: LD_INT 25
106377: PUSH
106378: LD_INT 4
106380: PUSH
106381: EMPTY
106382: LIST
106383: LIST
106384: PPUSH
106385: CALL_OW 72
106389: ST_TO_ADDR
// if f_repair then
106390: LD_VAR 0 22
106394: IFFALSE 106421
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
106396: LD_ADDR_VAR 0 33
106400: PUSH
106401: LD_VAR 0 4
106405: PPUSH
106406: LD_INT 25
106408: PUSH
106409: LD_INT 3
106411: PUSH
106412: EMPTY
106413: LIST
106414: LIST
106415: PPUSH
106416: CALL_OW 72
106420: ST_TO_ADDR
// units_path := [ ] ;
106421: LD_ADDR_VAR 0 16
106425: PUSH
106426: EMPTY
106427: ST_TO_ADDR
// for i = 1 to group do
106428: LD_ADDR_VAR 0 7
106432: PUSH
106433: DOUBLE
106434: LD_INT 1
106436: DEC
106437: ST_TO_ADDR
106438: LD_VAR 0 4
106442: PUSH
106443: FOR_TO
106444: IFFALSE 106473
// units_path := Replace ( units_path , i , path ) ;
106446: LD_ADDR_VAR 0 16
106450: PUSH
106451: LD_VAR 0 16
106455: PPUSH
106456: LD_VAR 0 7
106460: PPUSH
106461: LD_VAR 0 5
106465: PPUSH
106466: CALL_OW 1
106470: ST_TO_ADDR
106471: GO 106443
106473: POP
106474: POP
// repeat for i = group downto 1 do
106475: LD_ADDR_VAR 0 7
106479: PUSH
106480: DOUBLE
106481: LD_VAR 0 4
106485: INC
106486: ST_TO_ADDR
106487: LD_INT 1
106489: PUSH
106490: FOR_DOWNTO
106491: IFFALSE 110613
// begin wait ( 5 ) ;
106493: LD_INT 5
106495: PPUSH
106496: CALL_OW 67
// tmp := [ ] ;
106500: LD_ADDR_VAR 0 14
106504: PUSH
106505: EMPTY
106506: ST_TO_ADDR
// attacking := false ;
106507: LD_ADDR_VAR 0 29
106511: PUSH
106512: LD_INT 0
106514: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
106515: LD_VAR 0 4
106519: PUSH
106520: LD_VAR 0 7
106524: ARRAY
106525: PPUSH
106526: CALL_OW 301
106530: PUSH
106531: LD_VAR 0 4
106535: PUSH
106536: LD_VAR 0 7
106540: ARRAY
106541: NOT
106542: OR
106543: IFFALSE 106652
// begin if GetType ( group [ i ] ) = unit_human then
106545: LD_VAR 0 4
106549: PUSH
106550: LD_VAR 0 7
106554: ARRAY
106555: PPUSH
106556: CALL_OW 247
106560: PUSH
106561: LD_INT 1
106563: EQUAL
106564: IFFALSE 106610
// begin to_heal := to_heal diff group [ i ] ;
106566: LD_ADDR_VAR 0 30
106570: PUSH
106571: LD_VAR 0 30
106575: PUSH
106576: LD_VAR 0 4
106580: PUSH
106581: LD_VAR 0 7
106585: ARRAY
106586: DIFF
106587: ST_TO_ADDR
// healers := healers diff group [ i ] ;
106588: LD_ADDR_VAR 0 31
106592: PUSH
106593: LD_VAR 0 31
106597: PUSH
106598: LD_VAR 0 4
106602: PUSH
106603: LD_VAR 0 7
106607: ARRAY
106608: DIFF
106609: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
106610: LD_ADDR_VAR 0 4
106614: PUSH
106615: LD_VAR 0 4
106619: PPUSH
106620: LD_VAR 0 7
106624: PPUSH
106625: CALL_OW 3
106629: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
106630: LD_ADDR_VAR 0 16
106634: PUSH
106635: LD_VAR 0 16
106639: PPUSH
106640: LD_VAR 0 7
106644: PPUSH
106645: CALL_OW 3
106649: ST_TO_ADDR
// continue ;
106650: GO 106490
// end ; if f_repair then
106652: LD_VAR 0 22
106656: IFFALSE 107145
// begin if GetType ( group [ i ] ) = unit_vehicle then
106658: LD_VAR 0 4
106662: PUSH
106663: LD_VAR 0 7
106667: ARRAY
106668: PPUSH
106669: CALL_OW 247
106673: PUSH
106674: LD_INT 2
106676: EQUAL
106677: IFFALSE 106867
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
106679: LD_VAR 0 4
106683: PUSH
106684: LD_VAR 0 7
106688: ARRAY
106689: PPUSH
106690: CALL_OW 256
106694: PUSH
106695: LD_INT 700
106697: LESS
106698: PUSH
106699: LD_VAR 0 4
106703: PUSH
106704: LD_VAR 0 7
106708: ARRAY
106709: PUSH
106710: LD_VAR 0 32
106714: IN
106715: NOT
106716: AND
106717: IFFALSE 106741
// to_repair := to_repair union group [ i ] ;
106719: LD_ADDR_VAR 0 32
106723: PUSH
106724: LD_VAR 0 32
106728: PUSH
106729: LD_VAR 0 4
106733: PUSH
106734: LD_VAR 0 7
106738: ARRAY
106739: UNION
106740: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
106741: LD_VAR 0 4
106745: PUSH
106746: LD_VAR 0 7
106750: ARRAY
106751: PPUSH
106752: CALL_OW 256
106756: PUSH
106757: LD_INT 1000
106759: EQUAL
106760: PUSH
106761: LD_VAR 0 4
106765: PUSH
106766: LD_VAR 0 7
106770: ARRAY
106771: PUSH
106772: LD_VAR 0 32
106776: IN
106777: AND
106778: IFFALSE 106802
// to_repair := to_repair diff group [ i ] ;
106780: LD_ADDR_VAR 0 32
106784: PUSH
106785: LD_VAR 0 32
106789: PUSH
106790: LD_VAR 0 4
106794: PUSH
106795: LD_VAR 0 7
106799: ARRAY
106800: DIFF
106801: ST_TO_ADDR
// if group [ i ] in to_repair then
106802: LD_VAR 0 4
106806: PUSH
106807: LD_VAR 0 7
106811: ARRAY
106812: PUSH
106813: LD_VAR 0 32
106817: IN
106818: IFFALSE 106865
// begin if not IsInArea ( group [ i ] , f_repair ) then
106820: LD_VAR 0 4
106824: PUSH
106825: LD_VAR 0 7
106829: ARRAY
106830: PPUSH
106831: LD_VAR 0 22
106835: PPUSH
106836: CALL_OW 308
106840: NOT
106841: IFFALSE 106863
// ComMoveToArea ( group [ i ] , f_repair ) ;
106843: LD_VAR 0 4
106847: PUSH
106848: LD_VAR 0 7
106852: ARRAY
106853: PPUSH
106854: LD_VAR 0 22
106858: PPUSH
106859: CALL_OW 113
// continue ;
106863: GO 106490
// end ; end else
106865: GO 107145
// if group [ i ] in repairs then
106867: LD_VAR 0 4
106871: PUSH
106872: LD_VAR 0 7
106876: ARRAY
106877: PUSH
106878: LD_VAR 0 33
106882: IN
106883: IFFALSE 107145
// begin if IsInUnit ( group [ i ] ) then
106885: LD_VAR 0 4
106889: PUSH
106890: LD_VAR 0 7
106894: ARRAY
106895: PPUSH
106896: CALL_OW 310
106900: IFFALSE 106968
// begin z := IsInUnit ( group [ i ] ) ;
106902: LD_ADDR_VAR 0 13
106906: PUSH
106907: LD_VAR 0 4
106911: PUSH
106912: LD_VAR 0 7
106916: ARRAY
106917: PPUSH
106918: CALL_OW 310
106922: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
106923: LD_VAR 0 13
106927: PUSH
106928: LD_VAR 0 32
106932: IN
106933: PUSH
106934: LD_VAR 0 13
106938: PPUSH
106939: LD_VAR 0 22
106943: PPUSH
106944: CALL_OW 308
106948: AND
106949: IFFALSE 106966
// ComExitVehicle ( group [ i ] ) ;
106951: LD_VAR 0 4
106955: PUSH
106956: LD_VAR 0 7
106960: ARRAY
106961: PPUSH
106962: CALL_OW 121
// end else
106966: GO 107145
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
106968: LD_ADDR_VAR 0 13
106972: PUSH
106973: LD_VAR 0 4
106977: PPUSH
106978: LD_INT 95
106980: PUSH
106981: LD_VAR 0 22
106985: PUSH
106986: EMPTY
106987: LIST
106988: LIST
106989: PUSH
106990: LD_INT 58
106992: PUSH
106993: EMPTY
106994: LIST
106995: PUSH
106996: EMPTY
106997: LIST
106998: LIST
106999: PPUSH
107000: CALL_OW 72
107004: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107005: LD_VAR 0 4
107009: PUSH
107010: LD_VAR 0 7
107014: ARRAY
107015: PPUSH
107016: CALL_OW 314
107020: NOT
107021: IFFALSE 107143
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
107023: LD_ADDR_VAR 0 10
107027: PUSH
107028: LD_VAR 0 13
107032: PPUSH
107033: LD_VAR 0 4
107037: PUSH
107038: LD_VAR 0 7
107042: ARRAY
107043: PPUSH
107044: CALL_OW 74
107048: ST_TO_ADDR
// if not x then
107049: LD_VAR 0 10
107053: NOT
107054: IFFALSE 107058
// continue ;
107056: GO 106490
// if GetLives ( x ) < 1000 then
107058: LD_VAR 0 10
107062: PPUSH
107063: CALL_OW 256
107067: PUSH
107068: LD_INT 1000
107070: LESS
107071: IFFALSE 107095
// ComRepairVehicle ( group [ i ] , x ) else
107073: LD_VAR 0 4
107077: PUSH
107078: LD_VAR 0 7
107082: ARRAY
107083: PPUSH
107084: LD_VAR 0 10
107088: PPUSH
107089: CALL_OW 129
107093: GO 107143
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107095: LD_VAR 0 23
107099: PUSH
107100: LD_VAR 0 4
107104: PUSH
107105: LD_VAR 0 7
107109: ARRAY
107110: PPUSH
107111: CALL_OW 256
107115: PUSH
107116: LD_INT 1000
107118: LESS
107119: AND
107120: NOT
107121: IFFALSE 107143
// ComEnterUnit ( group [ i ] , x ) ;
107123: LD_VAR 0 4
107127: PUSH
107128: LD_VAR 0 7
107132: ARRAY
107133: PPUSH
107134: LD_VAR 0 10
107138: PPUSH
107139: CALL_OW 120
// end ; continue ;
107143: GO 106490
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
107145: LD_VAR 0 23
107149: PUSH
107150: LD_VAR 0 4
107154: PUSH
107155: LD_VAR 0 7
107159: ARRAY
107160: PPUSH
107161: CALL_OW 247
107165: PUSH
107166: LD_INT 1
107168: EQUAL
107169: AND
107170: IFFALSE 107648
// begin if group [ i ] in healers then
107172: LD_VAR 0 4
107176: PUSH
107177: LD_VAR 0 7
107181: ARRAY
107182: PUSH
107183: LD_VAR 0 31
107187: IN
107188: IFFALSE 107461
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
107190: LD_VAR 0 4
107194: PUSH
107195: LD_VAR 0 7
107199: ARRAY
107200: PPUSH
107201: LD_VAR 0 23
107205: PPUSH
107206: CALL_OW 308
107210: NOT
107211: PUSH
107212: LD_VAR 0 4
107216: PUSH
107217: LD_VAR 0 7
107221: ARRAY
107222: PPUSH
107223: CALL_OW 314
107227: NOT
107228: AND
107229: IFFALSE 107253
// ComMoveToArea ( group [ i ] , f_heal ) else
107231: LD_VAR 0 4
107235: PUSH
107236: LD_VAR 0 7
107240: ARRAY
107241: PPUSH
107242: LD_VAR 0 23
107246: PPUSH
107247: CALL_OW 113
107251: GO 107459
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
107253: LD_VAR 0 4
107257: PUSH
107258: LD_VAR 0 7
107262: ARRAY
107263: PPUSH
107264: CALL 48325 0 1
107268: PPUSH
107269: CALL_OW 256
107273: PUSH
107274: LD_INT 1000
107276: EQUAL
107277: IFFALSE 107296
// ComStop ( group [ i ] ) else
107279: LD_VAR 0 4
107283: PUSH
107284: LD_VAR 0 7
107288: ARRAY
107289: PPUSH
107290: CALL_OW 141
107294: GO 107459
// if not HasTask ( group [ i ] ) and to_heal then
107296: LD_VAR 0 4
107300: PUSH
107301: LD_VAR 0 7
107305: ARRAY
107306: PPUSH
107307: CALL_OW 314
107311: NOT
107312: PUSH
107313: LD_VAR 0 30
107317: AND
107318: IFFALSE 107459
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
107320: LD_ADDR_VAR 0 13
107324: PUSH
107325: LD_VAR 0 30
107329: PPUSH
107330: LD_INT 3
107332: PUSH
107333: LD_INT 54
107335: PUSH
107336: EMPTY
107337: LIST
107338: PUSH
107339: EMPTY
107340: LIST
107341: LIST
107342: PPUSH
107343: CALL_OW 72
107347: PPUSH
107348: LD_VAR 0 4
107352: PUSH
107353: LD_VAR 0 7
107357: ARRAY
107358: PPUSH
107359: CALL_OW 74
107363: ST_TO_ADDR
// if z then
107364: LD_VAR 0 13
107368: IFFALSE 107459
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
107370: LD_INT 91
107372: PUSH
107373: LD_VAR 0 13
107377: PUSH
107378: LD_INT 10
107380: PUSH
107381: EMPTY
107382: LIST
107383: LIST
107384: LIST
107385: PUSH
107386: LD_INT 81
107388: PUSH
107389: LD_VAR 0 13
107393: PPUSH
107394: CALL_OW 255
107398: PUSH
107399: EMPTY
107400: LIST
107401: LIST
107402: PUSH
107403: EMPTY
107404: LIST
107405: LIST
107406: PPUSH
107407: CALL_OW 69
107411: PUSH
107412: LD_INT 0
107414: EQUAL
107415: IFFALSE 107439
// ComHeal ( group [ i ] , z ) else
107417: LD_VAR 0 4
107421: PUSH
107422: LD_VAR 0 7
107426: ARRAY
107427: PPUSH
107428: LD_VAR 0 13
107432: PPUSH
107433: CALL_OW 128
107437: GO 107459
// ComMoveToArea ( group [ i ] , f_heal ) ;
107439: LD_VAR 0 4
107443: PUSH
107444: LD_VAR 0 7
107448: ARRAY
107449: PPUSH
107450: LD_VAR 0 23
107454: PPUSH
107455: CALL_OW 113
// end ; continue ;
107459: GO 106490
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
107461: LD_VAR 0 4
107465: PUSH
107466: LD_VAR 0 7
107470: ARRAY
107471: PPUSH
107472: CALL_OW 256
107476: PUSH
107477: LD_INT 700
107479: LESS
107480: PUSH
107481: LD_VAR 0 4
107485: PUSH
107486: LD_VAR 0 7
107490: ARRAY
107491: PUSH
107492: LD_VAR 0 30
107496: IN
107497: NOT
107498: AND
107499: IFFALSE 107523
// to_heal := to_heal union group [ i ] ;
107501: LD_ADDR_VAR 0 30
107505: PUSH
107506: LD_VAR 0 30
107510: PUSH
107511: LD_VAR 0 4
107515: PUSH
107516: LD_VAR 0 7
107520: ARRAY
107521: UNION
107522: ST_TO_ADDR
// if group [ i ] in to_heal then
107523: LD_VAR 0 4
107527: PUSH
107528: LD_VAR 0 7
107532: ARRAY
107533: PUSH
107534: LD_VAR 0 30
107538: IN
107539: IFFALSE 107648
// begin if GetLives ( group [ i ] ) = 1000 then
107541: LD_VAR 0 4
107545: PUSH
107546: LD_VAR 0 7
107550: ARRAY
107551: PPUSH
107552: CALL_OW 256
107556: PUSH
107557: LD_INT 1000
107559: EQUAL
107560: IFFALSE 107586
// to_heal := to_heal diff group [ i ] else
107562: LD_ADDR_VAR 0 30
107566: PUSH
107567: LD_VAR 0 30
107571: PUSH
107572: LD_VAR 0 4
107576: PUSH
107577: LD_VAR 0 7
107581: ARRAY
107582: DIFF
107583: ST_TO_ADDR
107584: GO 107648
// begin if not IsInArea ( group [ i ] , to_heal ) then
107586: LD_VAR 0 4
107590: PUSH
107591: LD_VAR 0 7
107595: ARRAY
107596: PPUSH
107597: LD_VAR 0 30
107601: PPUSH
107602: CALL_OW 308
107606: NOT
107607: IFFALSE 107631
// ComMoveToArea ( group [ i ] , f_heal ) else
107609: LD_VAR 0 4
107613: PUSH
107614: LD_VAR 0 7
107618: ARRAY
107619: PPUSH
107620: LD_VAR 0 23
107624: PPUSH
107625: CALL_OW 113
107629: GO 107646
// ComHold ( group [ i ] ) ;
107631: LD_VAR 0 4
107635: PUSH
107636: LD_VAR 0 7
107640: ARRAY
107641: PPUSH
107642: CALL_OW 140
// continue ;
107646: GO 106490
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
107648: LD_VAR 0 4
107652: PUSH
107653: LD_VAR 0 7
107657: ARRAY
107658: PPUSH
107659: LD_INT 10
107661: PPUSH
107662: CALL 46096 0 2
107666: NOT
107667: PUSH
107668: LD_VAR 0 16
107672: PUSH
107673: LD_VAR 0 7
107677: ARRAY
107678: PUSH
107679: EMPTY
107680: EQUAL
107681: NOT
107682: AND
107683: IFFALSE 107949
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
107685: LD_VAR 0 4
107689: PUSH
107690: LD_VAR 0 7
107694: ARRAY
107695: PPUSH
107696: CALL_OW 262
107700: PUSH
107701: LD_INT 1
107703: PUSH
107704: LD_INT 2
107706: PUSH
107707: EMPTY
107708: LIST
107709: LIST
107710: IN
107711: IFFALSE 107752
// if GetFuel ( group [ i ] ) < 10 then
107713: LD_VAR 0 4
107717: PUSH
107718: LD_VAR 0 7
107722: ARRAY
107723: PPUSH
107724: CALL_OW 261
107728: PUSH
107729: LD_INT 10
107731: LESS
107732: IFFALSE 107752
// SetFuel ( group [ i ] , 12 ) ;
107734: LD_VAR 0 4
107738: PUSH
107739: LD_VAR 0 7
107743: ARRAY
107744: PPUSH
107745: LD_INT 12
107747: PPUSH
107748: CALL_OW 240
// if units_path [ i ] then
107752: LD_VAR 0 16
107756: PUSH
107757: LD_VAR 0 7
107761: ARRAY
107762: IFFALSE 107947
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
107764: LD_VAR 0 4
107768: PUSH
107769: LD_VAR 0 7
107773: ARRAY
107774: PPUSH
107775: LD_VAR 0 16
107779: PUSH
107780: LD_VAR 0 7
107784: ARRAY
107785: PUSH
107786: LD_INT 1
107788: ARRAY
107789: PUSH
107790: LD_INT 1
107792: ARRAY
107793: PPUSH
107794: LD_VAR 0 16
107798: PUSH
107799: LD_VAR 0 7
107803: ARRAY
107804: PUSH
107805: LD_INT 1
107807: ARRAY
107808: PUSH
107809: LD_INT 2
107811: ARRAY
107812: PPUSH
107813: CALL_OW 297
107817: PUSH
107818: LD_INT 6
107820: GREATER
107821: IFFALSE 107896
// begin if not HasTask ( group [ i ] ) then
107823: LD_VAR 0 4
107827: PUSH
107828: LD_VAR 0 7
107832: ARRAY
107833: PPUSH
107834: CALL_OW 314
107838: NOT
107839: IFFALSE 107894
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
107841: LD_VAR 0 4
107845: PUSH
107846: LD_VAR 0 7
107850: ARRAY
107851: PPUSH
107852: LD_VAR 0 16
107856: PUSH
107857: LD_VAR 0 7
107861: ARRAY
107862: PUSH
107863: LD_INT 1
107865: ARRAY
107866: PUSH
107867: LD_INT 1
107869: ARRAY
107870: PPUSH
107871: LD_VAR 0 16
107875: PUSH
107876: LD_VAR 0 7
107880: ARRAY
107881: PUSH
107882: LD_INT 1
107884: ARRAY
107885: PUSH
107886: LD_INT 2
107888: ARRAY
107889: PPUSH
107890: CALL_OW 114
// end else
107894: GO 107947
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
107896: LD_ADDR_VAR 0 15
107900: PUSH
107901: LD_VAR 0 16
107905: PUSH
107906: LD_VAR 0 7
107910: ARRAY
107911: PPUSH
107912: LD_INT 1
107914: PPUSH
107915: CALL_OW 3
107919: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
107920: LD_ADDR_VAR 0 16
107924: PUSH
107925: LD_VAR 0 16
107929: PPUSH
107930: LD_VAR 0 7
107934: PPUSH
107935: LD_VAR 0 15
107939: PPUSH
107940: CALL_OW 1
107944: ST_TO_ADDR
// continue ;
107945: GO 106490
// end ; end ; end else
107947: GO 110611
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
107949: LD_ADDR_VAR 0 14
107953: PUSH
107954: LD_INT 81
107956: PUSH
107957: LD_VAR 0 4
107961: PUSH
107962: LD_VAR 0 7
107966: ARRAY
107967: PPUSH
107968: CALL_OW 255
107972: PUSH
107973: EMPTY
107974: LIST
107975: LIST
107976: PPUSH
107977: CALL_OW 69
107981: ST_TO_ADDR
// if not tmp then
107982: LD_VAR 0 14
107986: NOT
107987: IFFALSE 107991
// continue ;
107989: GO 106490
// if f_ignore_area then
107991: LD_VAR 0 17
107995: IFFALSE 108083
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
107997: LD_ADDR_VAR 0 15
108001: PUSH
108002: LD_VAR 0 14
108006: PPUSH
108007: LD_INT 3
108009: PUSH
108010: LD_INT 92
108012: PUSH
108013: LD_VAR 0 17
108017: PUSH
108018: LD_INT 1
108020: ARRAY
108021: PUSH
108022: LD_VAR 0 17
108026: PUSH
108027: LD_INT 2
108029: ARRAY
108030: PUSH
108031: LD_VAR 0 17
108035: PUSH
108036: LD_INT 3
108038: ARRAY
108039: PUSH
108040: EMPTY
108041: LIST
108042: LIST
108043: LIST
108044: LIST
108045: PUSH
108046: EMPTY
108047: LIST
108048: LIST
108049: PPUSH
108050: CALL_OW 72
108054: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108055: LD_VAR 0 14
108059: PUSH
108060: LD_VAR 0 15
108064: DIFF
108065: IFFALSE 108083
// tmp := tmp diff tmp2 ;
108067: LD_ADDR_VAR 0 14
108071: PUSH
108072: LD_VAR 0 14
108076: PUSH
108077: LD_VAR 0 15
108081: DIFF
108082: ST_TO_ADDR
// end ; if not f_murder then
108083: LD_VAR 0 20
108087: NOT
108088: IFFALSE 108146
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108090: LD_ADDR_VAR 0 15
108094: PUSH
108095: LD_VAR 0 14
108099: PPUSH
108100: LD_INT 3
108102: PUSH
108103: LD_INT 50
108105: PUSH
108106: EMPTY
108107: LIST
108108: PUSH
108109: EMPTY
108110: LIST
108111: LIST
108112: PPUSH
108113: CALL_OW 72
108117: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108118: LD_VAR 0 14
108122: PUSH
108123: LD_VAR 0 15
108127: DIFF
108128: IFFALSE 108146
// tmp := tmp diff tmp2 ;
108130: LD_ADDR_VAR 0 14
108134: PUSH
108135: LD_VAR 0 14
108139: PUSH
108140: LD_VAR 0 15
108144: DIFF
108145: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
108146: LD_ADDR_VAR 0 14
108150: PUSH
108151: LD_VAR 0 4
108155: PUSH
108156: LD_VAR 0 7
108160: ARRAY
108161: PPUSH
108162: LD_VAR 0 14
108166: PPUSH
108167: LD_INT 1
108169: PPUSH
108170: LD_INT 1
108172: PPUSH
108173: CALL 19008 0 4
108177: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
108178: LD_VAR 0 4
108182: PUSH
108183: LD_VAR 0 7
108187: ARRAY
108188: PPUSH
108189: CALL_OW 257
108193: PUSH
108194: LD_INT 1
108196: EQUAL
108197: IFFALSE 108645
// begin if WantPlant ( group [ i ] ) then
108199: LD_VAR 0 4
108203: PUSH
108204: LD_VAR 0 7
108208: ARRAY
108209: PPUSH
108210: CALL 18509 0 1
108214: IFFALSE 108218
// continue ;
108216: GO 106490
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
108218: LD_VAR 0 18
108222: PUSH
108223: LD_VAR 0 4
108227: PUSH
108228: LD_VAR 0 7
108232: ARRAY
108233: PPUSH
108234: CALL_OW 310
108238: NOT
108239: AND
108240: PUSH
108241: LD_VAR 0 14
108245: PUSH
108246: LD_INT 1
108248: ARRAY
108249: PUSH
108250: LD_VAR 0 14
108254: PPUSH
108255: LD_INT 21
108257: PUSH
108258: LD_INT 2
108260: PUSH
108261: EMPTY
108262: LIST
108263: LIST
108264: PUSH
108265: LD_INT 58
108267: PUSH
108268: EMPTY
108269: LIST
108270: PUSH
108271: EMPTY
108272: LIST
108273: LIST
108274: PPUSH
108275: CALL_OW 72
108279: IN
108280: AND
108281: IFFALSE 108317
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
108283: LD_VAR 0 4
108287: PUSH
108288: LD_VAR 0 7
108292: ARRAY
108293: PPUSH
108294: LD_VAR 0 14
108298: PUSH
108299: LD_INT 1
108301: ARRAY
108302: PPUSH
108303: CALL_OW 120
// attacking := true ;
108307: LD_ADDR_VAR 0 29
108311: PUSH
108312: LD_INT 1
108314: ST_TO_ADDR
// continue ;
108315: GO 106490
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
108317: LD_VAR 0 26
108321: PUSH
108322: LD_VAR 0 4
108326: PUSH
108327: LD_VAR 0 7
108331: ARRAY
108332: PPUSH
108333: CALL_OW 257
108337: PUSH
108338: LD_INT 1
108340: EQUAL
108341: AND
108342: PUSH
108343: LD_VAR 0 4
108347: PUSH
108348: LD_VAR 0 7
108352: ARRAY
108353: PPUSH
108354: CALL_OW 256
108358: PUSH
108359: LD_INT 800
108361: LESS
108362: AND
108363: PUSH
108364: LD_VAR 0 4
108368: PUSH
108369: LD_VAR 0 7
108373: ARRAY
108374: PPUSH
108375: CALL_OW 318
108379: NOT
108380: AND
108381: IFFALSE 108398
// ComCrawl ( group [ i ] ) ;
108383: LD_VAR 0 4
108387: PUSH
108388: LD_VAR 0 7
108392: ARRAY
108393: PPUSH
108394: CALL_OW 137
// if f_mines then
108398: LD_VAR 0 21
108402: IFFALSE 108645
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
108404: LD_VAR 0 14
108408: PUSH
108409: LD_INT 1
108411: ARRAY
108412: PPUSH
108413: CALL_OW 247
108417: PUSH
108418: LD_INT 3
108420: EQUAL
108421: PUSH
108422: LD_VAR 0 14
108426: PUSH
108427: LD_INT 1
108429: ARRAY
108430: PUSH
108431: LD_VAR 0 27
108435: IN
108436: NOT
108437: AND
108438: IFFALSE 108645
// begin x := GetX ( tmp [ 1 ] ) ;
108440: LD_ADDR_VAR 0 10
108444: PUSH
108445: LD_VAR 0 14
108449: PUSH
108450: LD_INT 1
108452: ARRAY
108453: PPUSH
108454: CALL_OW 250
108458: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
108459: LD_ADDR_VAR 0 11
108463: PUSH
108464: LD_VAR 0 14
108468: PUSH
108469: LD_INT 1
108471: ARRAY
108472: PPUSH
108473: CALL_OW 251
108477: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
108478: LD_ADDR_VAR 0 12
108482: PUSH
108483: LD_VAR 0 4
108487: PUSH
108488: LD_VAR 0 7
108492: ARRAY
108493: PPUSH
108494: CALL 46181 0 1
108498: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
108499: LD_VAR 0 4
108503: PUSH
108504: LD_VAR 0 7
108508: ARRAY
108509: PPUSH
108510: LD_VAR 0 10
108514: PPUSH
108515: LD_VAR 0 11
108519: PPUSH
108520: LD_VAR 0 14
108524: PUSH
108525: LD_INT 1
108527: ARRAY
108528: PPUSH
108529: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
108533: LD_VAR 0 4
108537: PUSH
108538: LD_VAR 0 7
108542: ARRAY
108543: PPUSH
108544: LD_VAR 0 10
108548: PPUSH
108549: LD_VAR 0 12
108553: PPUSH
108554: LD_INT 7
108556: PPUSH
108557: CALL_OW 272
108561: PPUSH
108562: LD_VAR 0 11
108566: PPUSH
108567: LD_VAR 0 12
108571: PPUSH
108572: LD_INT 7
108574: PPUSH
108575: CALL_OW 273
108579: PPUSH
108580: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
108584: LD_VAR 0 4
108588: PUSH
108589: LD_VAR 0 7
108593: ARRAY
108594: PPUSH
108595: LD_INT 71
108597: PPUSH
108598: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
108602: LD_ADDR_VAR 0 27
108606: PUSH
108607: LD_VAR 0 27
108611: PPUSH
108612: LD_VAR 0 27
108616: PUSH
108617: LD_INT 1
108619: PLUS
108620: PPUSH
108621: LD_VAR 0 14
108625: PUSH
108626: LD_INT 1
108628: ARRAY
108629: PPUSH
108630: CALL_OW 1
108634: ST_TO_ADDR
// attacking := true ;
108635: LD_ADDR_VAR 0 29
108639: PUSH
108640: LD_INT 1
108642: ST_TO_ADDR
// continue ;
108643: GO 106490
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
108645: LD_VAR 0 4
108649: PUSH
108650: LD_VAR 0 7
108654: ARRAY
108655: PPUSH
108656: CALL_OW 257
108660: PUSH
108661: LD_INT 17
108663: EQUAL
108664: PUSH
108665: LD_VAR 0 4
108669: PUSH
108670: LD_VAR 0 7
108674: ARRAY
108675: PPUSH
108676: CALL_OW 110
108680: PUSH
108681: LD_INT 71
108683: EQUAL
108684: NOT
108685: AND
108686: IFFALSE 108832
// begin attacking := false ;
108688: LD_ADDR_VAR 0 29
108692: PUSH
108693: LD_INT 0
108695: ST_TO_ADDR
// k := 5 ;
108696: LD_ADDR_VAR 0 9
108700: PUSH
108701: LD_INT 5
108703: ST_TO_ADDR
// if tmp < k then
108704: LD_VAR 0 14
108708: PUSH
108709: LD_VAR 0 9
108713: LESS
108714: IFFALSE 108726
// k := tmp ;
108716: LD_ADDR_VAR 0 9
108720: PUSH
108721: LD_VAR 0 14
108725: ST_TO_ADDR
// for j = 1 to k do
108726: LD_ADDR_VAR 0 8
108730: PUSH
108731: DOUBLE
108732: LD_INT 1
108734: DEC
108735: ST_TO_ADDR
108736: LD_VAR 0 9
108740: PUSH
108741: FOR_TO
108742: IFFALSE 108830
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
108744: LD_VAR 0 14
108748: PUSH
108749: LD_VAR 0 8
108753: ARRAY
108754: PUSH
108755: LD_VAR 0 14
108759: PPUSH
108760: LD_INT 58
108762: PUSH
108763: EMPTY
108764: LIST
108765: PPUSH
108766: CALL_OW 72
108770: IN
108771: NOT
108772: IFFALSE 108828
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108774: LD_VAR 0 4
108778: PUSH
108779: LD_VAR 0 7
108783: ARRAY
108784: PPUSH
108785: LD_VAR 0 14
108789: PUSH
108790: LD_VAR 0 8
108794: ARRAY
108795: PPUSH
108796: CALL_OW 115
// attacking := true ;
108800: LD_ADDR_VAR 0 29
108804: PUSH
108805: LD_INT 1
108807: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
108808: LD_VAR 0 4
108812: PUSH
108813: LD_VAR 0 7
108817: ARRAY
108818: PPUSH
108819: LD_INT 71
108821: PPUSH
108822: CALL_OW 109
// continue ;
108826: GO 108741
// end ; end ;
108828: GO 108741
108830: POP
108831: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
108832: LD_VAR 0 4
108836: PUSH
108837: LD_VAR 0 7
108841: ARRAY
108842: PPUSH
108843: CALL_OW 257
108847: PUSH
108848: LD_INT 8
108850: EQUAL
108851: PUSH
108852: LD_VAR 0 4
108856: PUSH
108857: LD_VAR 0 7
108861: ARRAY
108862: PPUSH
108863: CALL_OW 264
108867: PUSH
108868: LD_INT 28
108870: PUSH
108871: LD_INT 45
108873: PUSH
108874: LD_INT 7
108876: PUSH
108877: LD_INT 47
108879: PUSH
108880: EMPTY
108881: LIST
108882: LIST
108883: LIST
108884: LIST
108885: IN
108886: OR
108887: IFFALSE 109143
// begin attacking := false ;
108889: LD_ADDR_VAR 0 29
108893: PUSH
108894: LD_INT 0
108896: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
108897: LD_VAR 0 14
108901: PUSH
108902: LD_INT 1
108904: ARRAY
108905: PPUSH
108906: CALL_OW 266
108910: PUSH
108911: LD_INT 32
108913: PUSH
108914: LD_INT 31
108916: PUSH
108917: LD_INT 33
108919: PUSH
108920: LD_INT 4
108922: PUSH
108923: LD_INT 5
108925: PUSH
108926: EMPTY
108927: LIST
108928: LIST
108929: LIST
108930: LIST
108931: LIST
108932: IN
108933: IFFALSE 109119
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
108935: LD_ADDR_VAR 0 9
108939: PUSH
108940: LD_VAR 0 14
108944: PUSH
108945: LD_INT 1
108947: ARRAY
108948: PPUSH
108949: CALL_OW 266
108953: PPUSH
108954: LD_VAR 0 14
108958: PUSH
108959: LD_INT 1
108961: ARRAY
108962: PPUSH
108963: CALL_OW 250
108967: PPUSH
108968: LD_VAR 0 14
108972: PUSH
108973: LD_INT 1
108975: ARRAY
108976: PPUSH
108977: CALL_OW 251
108981: PPUSH
108982: LD_VAR 0 14
108986: PUSH
108987: LD_INT 1
108989: ARRAY
108990: PPUSH
108991: CALL_OW 254
108995: PPUSH
108996: LD_VAR 0 14
109000: PUSH
109001: LD_INT 1
109003: ARRAY
109004: PPUSH
109005: CALL_OW 248
109009: PPUSH
109010: LD_INT 0
109012: PPUSH
109013: CALL 27551 0 6
109017: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
109018: LD_ADDR_VAR 0 8
109022: PUSH
109023: LD_VAR 0 4
109027: PUSH
109028: LD_VAR 0 7
109032: ARRAY
109033: PPUSH
109034: LD_VAR 0 9
109038: PPUSH
109039: CALL 46294 0 2
109043: ST_TO_ADDR
// if j then
109044: LD_VAR 0 8
109048: IFFALSE 109117
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
109050: LD_VAR 0 8
109054: PUSH
109055: LD_INT 1
109057: ARRAY
109058: PPUSH
109059: LD_VAR 0 8
109063: PUSH
109064: LD_INT 2
109066: ARRAY
109067: PPUSH
109068: CALL_OW 488
109072: IFFALSE 109117
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109074: LD_VAR 0 4
109078: PUSH
109079: LD_VAR 0 7
109083: ARRAY
109084: PPUSH
109085: LD_VAR 0 8
109089: PUSH
109090: LD_INT 1
109092: ARRAY
109093: PPUSH
109094: LD_VAR 0 8
109098: PUSH
109099: LD_INT 2
109101: ARRAY
109102: PPUSH
109103: CALL_OW 116
// attacking := true ;
109107: LD_ADDR_VAR 0 29
109111: PUSH
109112: LD_INT 1
109114: ST_TO_ADDR
// continue ;
109115: GO 106490
// end ; end else
109117: GO 109143
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109119: LD_VAR 0 4
109123: PUSH
109124: LD_VAR 0 7
109128: ARRAY
109129: PPUSH
109130: LD_VAR 0 14
109134: PUSH
109135: LD_INT 1
109137: ARRAY
109138: PPUSH
109139: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
109143: LD_VAR 0 4
109147: PUSH
109148: LD_VAR 0 7
109152: ARRAY
109153: PPUSH
109154: CALL_OW 265
109158: PUSH
109159: LD_INT 11
109161: EQUAL
109162: IFFALSE 109440
// begin k := 10 ;
109164: LD_ADDR_VAR 0 9
109168: PUSH
109169: LD_INT 10
109171: ST_TO_ADDR
// x := 0 ;
109172: LD_ADDR_VAR 0 10
109176: PUSH
109177: LD_INT 0
109179: ST_TO_ADDR
// if tmp < k then
109180: LD_VAR 0 14
109184: PUSH
109185: LD_VAR 0 9
109189: LESS
109190: IFFALSE 109202
// k := tmp ;
109192: LD_ADDR_VAR 0 9
109196: PUSH
109197: LD_VAR 0 14
109201: ST_TO_ADDR
// for j = k downto 1 do
109202: LD_ADDR_VAR 0 8
109206: PUSH
109207: DOUBLE
109208: LD_VAR 0 9
109212: INC
109213: ST_TO_ADDR
109214: LD_INT 1
109216: PUSH
109217: FOR_DOWNTO
109218: IFFALSE 109293
// begin if GetType ( tmp [ j ] ) = unit_human then
109220: LD_VAR 0 14
109224: PUSH
109225: LD_VAR 0 8
109229: ARRAY
109230: PPUSH
109231: CALL_OW 247
109235: PUSH
109236: LD_INT 1
109238: EQUAL
109239: IFFALSE 109291
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
109241: LD_VAR 0 4
109245: PUSH
109246: LD_VAR 0 7
109250: ARRAY
109251: PPUSH
109252: LD_VAR 0 14
109256: PUSH
109257: LD_VAR 0 8
109261: ARRAY
109262: PPUSH
109263: CALL 46548 0 2
// x := tmp [ j ] ;
109267: LD_ADDR_VAR 0 10
109271: PUSH
109272: LD_VAR 0 14
109276: PUSH
109277: LD_VAR 0 8
109281: ARRAY
109282: ST_TO_ADDR
// attacking := true ;
109283: LD_ADDR_VAR 0 29
109287: PUSH
109288: LD_INT 1
109290: ST_TO_ADDR
// end ; end ;
109291: GO 109217
109293: POP
109294: POP
// if not x then
109295: LD_VAR 0 10
109299: NOT
109300: IFFALSE 109440
// begin attacking := true ;
109302: LD_ADDR_VAR 0 29
109306: PUSH
109307: LD_INT 1
109309: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
109310: LD_VAR 0 4
109314: PUSH
109315: LD_VAR 0 7
109319: ARRAY
109320: PPUSH
109321: CALL_OW 250
109325: PPUSH
109326: LD_VAR 0 4
109330: PUSH
109331: LD_VAR 0 7
109335: ARRAY
109336: PPUSH
109337: CALL_OW 251
109341: PPUSH
109342: CALL_OW 546
109346: PUSH
109347: LD_INT 2
109349: ARRAY
109350: PUSH
109351: LD_VAR 0 14
109355: PUSH
109356: LD_INT 1
109358: ARRAY
109359: PPUSH
109360: CALL_OW 250
109364: PPUSH
109365: LD_VAR 0 14
109369: PUSH
109370: LD_INT 1
109372: ARRAY
109373: PPUSH
109374: CALL_OW 251
109378: PPUSH
109379: CALL_OW 546
109383: PUSH
109384: LD_INT 2
109386: ARRAY
109387: EQUAL
109388: IFFALSE 109416
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
109390: LD_VAR 0 4
109394: PUSH
109395: LD_VAR 0 7
109399: ARRAY
109400: PPUSH
109401: LD_VAR 0 14
109405: PUSH
109406: LD_INT 1
109408: ARRAY
109409: PPUSH
109410: CALL 46548 0 2
109414: GO 109440
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109416: LD_VAR 0 4
109420: PUSH
109421: LD_VAR 0 7
109425: ARRAY
109426: PPUSH
109427: LD_VAR 0 14
109431: PUSH
109432: LD_INT 1
109434: ARRAY
109435: PPUSH
109436: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
109440: LD_VAR 0 4
109444: PUSH
109445: LD_VAR 0 7
109449: ARRAY
109450: PPUSH
109451: CALL_OW 264
109455: PUSH
109456: LD_INT 29
109458: EQUAL
109459: IFFALSE 109825
// begin if WantsToAttack ( group [ i ] ) in bombed then
109461: LD_VAR 0 4
109465: PUSH
109466: LD_VAR 0 7
109470: ARRAY
109471: PPUSH
109472: CALL_OW 319
109476: PUSH
109477: LD_VAR 0 28
109481: IN
109482: IFFALSE 109486
// continue ;
109484: GO 106490
// k := 8 ;
109486: LD_ADDR_VAR 0 9
109490: PUSH
109491: LD_INT 8
109493: ST_TO_ADDR
// x := 0 ;
109494: LD_ADDR_VAR 0 10
109498: PUSH
109499: LD_INT 0
109501: ST_TO_ADDR
// if tmp < k then
109502: LD_VAR 0 14
109506: PUSH
109507: LD_VAR 0 9
109511: LESS
109512: IFFALSE 109524
// k := tmp ;
109514: LD_ADDR_VAR 0 9
109518: PUSH
109519: LD_VAR 0 14
109523: ST_TO_ADDR
// for j = 1 to k do
109524: LD_ADDR_VAR 0 8
109528: PUSH
109529: DOUBLE
109530: LD_INT 1
109532: DEC
109533: ST_TO_ADDR
109534: LD_VAR 0 9
109538: PUSH
109539: FOR_TO
109540: IFFALSE 109672
// begin if GetType ( tmp [ j ] ) = unit_building then
109542: LD_VAR 0 14
109546: PUSH
109547: LD_VAR 0 8
109551: ARRAY
109552: PPUSH
109553: CALL_OW 247
109557: PUSH
109558: LD_INT 3
109560: EQUAL
109561: IFFALSE 109670
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
109563: LD_VAR 0 14
109567: PUSH
109568: LD_VAR 0 8
109572: ARRAY
109573: PUSH
109574: LD_VAR 0 28
109578: IN
109579: NOT
109580: PUSH
109581: LD_VAR 0 14
109585: PUSH
109586: LD_VAR 0 8
109590: ARRAY
109591: PPUSH
109592: CALL_OW 313
109596: AND
109597: IFFALSE 109670
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109599: LD_VAR 0 4
109603: PUSH
109604: LD_VAR 0 7
109608: ARRAY
109609: PPUSH
109610: LD_VAR 0 14
109614: PUSH
109615: LD_VAR 0 8
109619: ARRAY
109620: PPUSH
109621: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
109625: LD_ADDR_VAR 0 28
109629: PUSH
109630: LD_VAR 0 28
109634: PPUSH
109635: LD_VAR 0 28
109639: PUSH
109640: LD_INT 1
109642: PLUS
109643: PPUSH
109644: LD_VAR 0 14
109648: PUSH
109649: LD_VAR 0 8
109653: ARRAY
109654: PPUSH
109655: CALL_OW 1
109659: ST_TO_ADDR
// attacking := true ;
109660: LD_ADDR_VAR 0 29
109664: PUSH
109665: LD_INT 1
109667: ST_TO_ADDR
// break ;
109668: GO 109672
// end ; end ;
109670: GO 109539
109672: POP
109673: POP
// if not attacking and f_attack_depot then
109674: LD_VAR 0 29
109678: NOT
109679: PUSH
109680: LD_VAR 0 25
109684: AND
109685: IFFALSE 109780
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109687: LD_ADDR_VAR 0 13
109691: PUSH
109692: LD_VAR 0 14
109696: PPUSH
109697: LD_INT 2
109699: PUSH
109700: LD_INT 30
109702: PUSH
109703: LD_INT 0
109705: PUSH
109706: EMPTY
109707: LIST
109708: LIST
109709: PUSH
109710: LD_INT 30
109712: PUSH
109713: LD_INT 1
109715: PUSH
109716: EMPTY
109717: LIST
109718: LIST
109719: PUSH
109720: EMPTY
109721: LIST
109722: LIST
109723: LIST
109724: PPUSH
109725: CALL_OW 72
109729: ST_TO_ADDR
// if z then
109730: LD_VAR 0 13
109734: IFFALSE 109780
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
109736: LD_VAR 0 4
109740: PUSH
109741: LD_VAR 0 7
109745: ARRAY
109746: PPUSH
109747: LD_VAR 0 13
109751: PPUSH
109752: LD_VAR 0 4
109756: PUSH
109757: LD_VAR 0 7
109761: ARRAY
109762: PPUSH
109763: CALL_OW 74
109767: PPUSH
109768: CALL_OW 115
// attacking := true ;
109772: LD_ADDR_VAR 0 29
109776: PUSH
109777: LD_INT 1
109779: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
109780: LD_VAR 0 4
109784: PUSH
109785: LD_VAR 0 7
109789: ARRAY
109790: PPUSH
109791: CALL_OW 256
109795: PUSH
109796: LD_INT 500
109798: LESS
109799: IFFALSE 109825
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109801: LD_VAR 0 4
109805: PUSH
109806: LD_VAR 0 7
109810: ARRAY
109811: PPUSH
109812: LD_VAR 0 14
109816: PUSH
109817: LD_INT 1
109819: ARRAY
109820: PPUSH
109821: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
109825: LD_VAR 0 4
109829: PUSH
109830: LD_VAR 0 7
109834: ARRAY
109835: PPUSH
109836: CALL_OW 264
109840: PUSH
109841: LD_INT 49
109843: EQUAL
109844: IFFALSE 109965
// begin if not HasTask ( group [ i ] ) then
109846: LD_VAR 0 4
109850: PUSH
109851: LD_VAR 0 7
109855: ARRAY
109856: PPUSH
109857: CALL_OW 314
109861: NOT
109862: IFFALSE 109965
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
109864: LD_ADDR_VAR 0 9
109868: PUSH
109869: LD_INT 81
109871: PUSH
109872: LD_VAR 0 4
109876: PUSH
109877: LD_VAR 0 7
109881: ARRAY
109882: PPUSH
109883: CALL_OW 255
109887: PUSH
109888: EMPTY
109889: LIST
109890: LIST
109891: PPUSH
109892: CALL_OW 69
109896: PPUSH
109897: LD_VAR 0 4
109901: PUSH
109902: LD_VAR 0 7
109906: ARRAY
109907: PPUSH
109908: CALL_OW 74
109912: ST_TO_ADDR
// if k then
109913: LD_VAR 0 9
109917: IFFALSE 109965
// if GetDistUnits ( group [ i ] , k ) > 10 then
109919: LD_VAR 0 4
109923: PUSH
109924: LD_VAR 0 7
109928: ARRAY
109929: PPUSH
109930: LD_VAR 0 9
109934: PPUSH
109935: CALL_OW 296
109939: PUSH
109940: LD_INT 10
109942: GREATER
109943: IFFALSE 109965
// ComMoveUnit ( group [ i ] , k ) ;
109945: LD_VAR 0 4
109949: PUSH
109950: LD_VAR 0 7
109954: ARRAY
109955: PPUSH
109956: LD_VAR 0 9
109960: PPUSH
109961: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
109965: LD_VAR 0 4
109969: PUSH
109970: LD_VAR 0 7
109974: ARRAY
109975: PPUSH
109976: CALL_OW 256
109980: PUSH
109981: LD_INT 250
109983: LESS
109984: PUSH
109985: LD_VAR 0 4
109989: PUSH
109990: LD_VAR 0 7
109994: ARRAY
109995: PUSH
109996: LD_INT 21
109998: PUSH
109999: LD_INT 2
110001: PUSH
110002: EMPTY
110003: LIST
110004: LIST
110005: PUSH
110006: LD_INT 23
110008: PUSH
110009: LD_INT 2
110011: PUSH
110012: EMPTY
110013: LIST
110014: LIST
110015: PUSH
110016: EMPTY
110017: LIST
110018: LIST
110019: PPUSH
110020: CALL_OW 69
110024: IN
110025: AND
110026: IFFALSE 110151
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
110028: LD_ADDR_VAR 0 9
110032: PUSH
110033: LD_OWVAR 3
110037: PUSH
110038: LD_VAR 0 4
110042: PUSH
110043: LD_VAR 0 7
110047: ARRAY
110048: DIFF
110049: PPUSH
110050: LD_VAR 0 4
110054: PUSH
110055: LD_VAR 0 7
110059: ARRAY
110060: PPUSH
110061: CALL_OW 74
110065: ST_TO_ADDR
// if not k then
110066: LD_VAR 0 9
110070: NOT
110071: IFFALSE 110075
// continue ;
110073: GO 106490
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110075: LD_VAR 0 9
110079: PUSH
110080: LD_INT 81
110082: PUSH
110083: LD_VAR 0 4
110087: PUSH
110088: LD_VAR 0 7
110092: ARRAY
110093: PPUSH
110094: CALL_OW 255
110098: PUSH
110099: EMPTY
110100: LIST
110101: LIST
110102: PPUSH
110103: CALL_OW 69
110107: IN
110108: PUSH
110109: LD_VAR 0 9
110113: PPUSH
110114: LD_VAR 0 4
110118: PUSH
110119: LD_VAR 0 7
110123: ARRAY
110124: PPUSH
110125: CALL_OW 296
110129: PUSH
110130: LD_INT 5
110132: LESS
110133: AND
110134: IFFALSE 110151
// ComAutodestruct ( group [ i ] ) ;
110136: LD_VAR 0 4
110140: PUSH
110141: LD_VAR 0 7
110145: ARRAY
110146: PPUSH
110147: CALL 46446 0 1
// end ; if f_attack_depot then
110151: LD_VAR 0 25
110155: IFFALSE 110267
// begin k := 6 ;
110157: LD_ADDR_VAR 0 9
110161: PUSH
110162: LD_INT 6
110164: ST_TO_ADDR
// if tmp < k then
110165: LD_VAR 0 14
110169: PUSH
110170: LD_VAR 0 9
110174: LESS
110175: IFFALSE 110187
// k := tmp ;
110177: LD_ADDR_VAR 0 9
110181: PUSH
110182: LD_VAR 0 14
110186: ST_TO_ADDR
// for j = 1 to k do
110187: LD_ADDR_VAR 0 8
110191: PUSH
110192: DOUBLE
110193: LD_INT 1
110195: DEC
110196: ST_TO_ADDR
110197: LD_VAR 0 9
110201: PUSH
110202: FOR_TO
110203: IFFALSE 110265
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
110205: LD_VAR 0 8
110209: PPUSH
110210: CALL_OW 266
110214: PUSH
110215: LD_INT 0
110217: PUSH
110218: LD_INT 1
110220: PUSH
110221: EMPTY
110222: LIST
110223: LIST
110224: IN
110225: IFFALSE 110263
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110227: LD_VAR 0 4
110231: PUSH
110232: LD_VAR 0 7
110236: ARRAY
110237: PPUSH
110238: LD_VAR 0 14
110242: PUSH
110243: LD_VAR 0 8
110247: ARRAY
110248: PPUSH
110249: CALL_OW 115
// attacking := true ;
110253: LD_ADDR_VAR 0 29
110257: PUSH
110258: LD_INT 1
110260: ST_TO_ADDR
// break ;
110261: GO 110265
// end ;
110263: GO 110202
110265: POP
110266: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
110267: LD_VAR 0 4
110271: PUSH
110272: LD_VAR 0 7
110276: ARRAY
110277: PPUSH
110278: CALL_OW 302
110282: PUSH
110283: LD_VAR 0 29
110287: NOT
110288: AND
110289: IFFALSE 110611
// begin if GetTag ( group [ i ] ) = 71 then
110291: LD_VAR 0 4
110295: PUSH
110296: LD_VAR 0 7
110300: ARRAY
110301: PPUSH
110302: CALL_OW 110
110306: PUSH
110307: LD_INT 71
110309: EQUAL
110310: IFFALSE 110351
// begin if HasTask ( group [ i ] ) then
110312: LD_VAR 0 4
110316: PUSH
110317: LD_VAR 0 7
110321: ARRAY
110322: PPUSH
110323: CALL_OW 314
110327: IFFALSE 110333
// continue else
110329: GO 106490
110331: GO 110351
// SetTag ( group [ i ] , 0 ) ;
110333: LD_VAR 0 4
110337: PUSH
110338: LD_VAR 0 7
110342: ARRAY
110343: PPUSH
110344: LD_INT 0
110346: PPUSH
110347: CALL_OW 109
// end ; k := 8 ;
110351: LD_ADDR_VAR 0 9
110355: PUSH
110356: LD_INT 8
110358: ST_TO_ADDR
// x := 0 ;
110359: LD_ADDR_VAR 0 10
110363: PUSH
110364: LD_INT 0
110366: ST_TO_ADDR
// if tmp < k then
110367: LD_VAR 0 14
110371: PUSH
110372: LD_VAR 0 9
110376: LESS
110377: IFFALSE 110389
// k := tmp ;
110379: LD_ADDR_VAR 0 9
110383: PUSH
110384: LD_VAR 0 14
110388: ST_TO_ADDR
// for j = 1 to k do
110389: LD_ADDR_VAR 0 8
110393: PUSH
110394: DOUBLE
110395: LD_INT 1
110397: DEC
110398: ST_TO_ADDR
110399: LD_VAR 0 9
110403: PUSH
110404: FOR_TO
110405: IFFALSE 110503
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
110407: LD_VAR 0 14
110411: PUSH
110412: LD_VAR 0 8
110416: ARRAY
110417: PPUSH
110418: CALL_OW 247
110422: PUSH
110423: LD_INT 1
110425: EQUAL
110426: PUSH
110427: LD_VAR 0 14
110431: PUSH
110432: LD_VAR 0 8
110436: ARRAY
110437: PPUSH
110438: CALL_OW 256
110442: PUSH
110443: LD_INT 250
110445: LESS
110446: PUSH
110447: LD_VAR 0 20
110451: AND
110452: PUSH
110453: LD_VAR 0 20
110457: NOT
110458: PUSH
110459: LD_VAR 0 14
110463: PUSH
110464: LD_VAR 0 8
110468: ARRAY
110469: PPUSH
110470: CALL_OW 256
110474: PUSH
110475: LD_INT 250
110477: GREATEREQUAL
110478: AND
110479: OR
110480: AND
110481: IFFALSE 110501
// begin x := tmp [ j ] ;
110483: LD_ADDR_VAR 0 10
110487: PUSH
110488: LD_VAR 0 14
110492: PUSH
110493: LD_VAR 0 8
110497: ARRAY
110498: ST_TO_ADDR
// break ;
110499: GO 110503
// end ;
110501: GO 110404
110503: POP
110504: POP
// if x then
110505: LD_VAR 0 10
110509: IFFALSE 110533
// ComAttackUnit ( group [ i ] , x ) else
110511: LD_VAR 0 4
110515: PUSH
110516: LD_VAR 0 7
110520: ARRAY
110521: PPUSH
110522: LD_VAR 0 10
110526: PPUSH
110527: CALL_OW 115
110531: GO 110557
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110533: LD_VAR 0 4
110537: PUSH
110538: LD_VAR 0 7
110542: ARRAY
110543: PPUSH
110544: LD_VAR 0 14
110548: PUSH
110549: LD_INT 1
110551: ARRAY
110552: PPUSH
110553: CALL_OW 115
// if not HasTask ( group [ i ] ) then
110557: LD_VAR 0 4
110561: PUSH
110562: LD_VAR 0 7
110566: ARRAY
110567: PPUSH
110568: CALL_OW 314
110572: NOT
110573: IFFALSE 110611
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
110575: LD_VAR 0 4
110579: PUSH
110580: LD_VAR 0 7
110584: ARRAY
110585: PPUSH
110586: LD_VAR 0 14
110590: PPUSH
110591: LD_VAR 0 4
110595: PUSH
110596: LD_VAR 0 7
110600: ARRAY
110601: PPUSH
110602: CALL_OW 74
110606: PPUSH
110607: CALL_OW 115
// end ; end ; end ;
110611: GO 106490
110613: POP
110614: POP
// wait ( 0 0$2 ) ;
110615: LD_INT 70
110617: PPUSH
110618: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
110622: LD_VAR 0 4
110626: NOT
110627: PUSH
110628: LD_VAR 0 4
110632: PUSH
110633: EMPTY
110634: EQUAL
110635: OR
110636: PUSH
110637: LD_INT 81
110639: PUSH
110640: LD_VAR 0 35
110644: PUSH
110645: EMPTY
110646: LIST
110647: LIST
110648: PPUSH
110649: CALL_OW 69
110653: NOT
110654: OR
110655: IFFALSE 106475
// end ;
110657: LD_VAR 0 2
110661: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
110662: LD_INT 0
110664: PPUSH
110665: PPUSH
110666: PPUSH
110667: PPUSH
110668: PPUSH
110669: PPUSH
// if not base or not mc_bases [ base ] or not solds then
110670: LD_VAR 0 1
110674: NOT
110675: PUSH
110676: LD_EXP 50
110680: PUSH
110681: LD_VAR 0 1
110685: ARRAY
110686: NOT
110687: OR
110688: PUSH
110689: LD_VAR 0 2
110693: NOT
110694: OR
110695: IFFALSE 110699
// exit ;
110697: GO 111253
// side := mc_sides [ base ] ;
110699: LD_ADDR_VAR 0 6
110703: PUSH
110704: LD_EXP 76
110708: PUSH
110709: LD_VAR 0 1
110713: ARRAY
110714: ST_TO_ADDR
// if not side then
110715: LD_VAR 0 6
110719: NOT
110720: IFFALSE 110724
// exit ;
110722: GO 111253
// for i in solds do
110724: LD_ADDR_VAR 0 7
110728: PUSH
110729: LD_VAR 0 2
110733: PUSH
110734: FOR_IN
110735: IFFALSE 110796
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
110737: LD_VAR 0 7
110741: PPUSH
110742: CALL_OW 310
110746: PPUSH
110747: CALL_OW 266
110751: PUSH
110752: LD_INT 32
110754: PUSH
110755: LD_INT 31
110757: PUSH
110758: EMPTY
110759: LIST
110760: LIST
110761: IN
110762: IFFALSE 110782
// solds := solds diff i else
110764: LD_ADDR_VAR 0 2
110768: PUSH
110769: LD_VAR 0 2
110773: PUSH
110774: LD_VAR 0 7
110778: DIFF
110779: ST_TO_ADDR
110780: GO 110794
// SetTag ( i , 18 ) ;
110782: LD_VAR 0 7
110786: PPUSH
110787: LD_INT 18
110789: PPUSH
110790: CALL_OW 109
110794: GO 110734
110796: POP
110797: POP
// if not solds then
110798: LD_VAR 0 2
110802: NOT
110803: IFFALSE 110807
// exit ;
110805: GO 111253
// repeat wait ( 0 0$2 ) ;
110807: LD_INT 70
110809: PPUSH
110810: CALL_OW 67
// enemy := mc_scan [ base ] ;
110814: LD_ADDR_VAR 0 4
110818: PUSH
110819: LD_EXP 73
110823: PUSH
110824: LD_VAR 0 1
110828: ARRAY
110829: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110830: LD_EXP 50
110834: PUSH
110835: LD_VAR 0 1
110839: ARRAY
110840: NOT
110841: PUSH
110842: LD_EXP 50
110846: PUSH
110847: LD_VAR 0 1
110851: ARRAY
110852: PUSH
110853: EMPTY
110854: EQUAL
110855: OR
110856: IFFALSE 110893
// begin for i in solds do
110858: LD_ADDR_VAR 0 7
110862: PUSH
110863: LD_VAR 0 2
110867: PUSH
110868: FOR_IN
110869: IFFALSE 110882
// ComStop ( i ) ;
110871: LD_VAR 0 7
110875: PPUSH
110876: CALL_OW 141
110880: GO 110868
110882: POP
110883: POP
// solds := [ ] ;
110884: LD_ADDR_VAR 0 2
110888: PUSH
110889: EMPTY
110890: ST_TO_ADDR
// exit ;
110891: GO 111253
// end ; for i in solds do
110893: LD_ADDR_VAR 0 7
110897: PUSH
110898: LD_VAR 0 2
110902: PUSH
110903: FOR_IN
110904: IFFALSE 111225
// begin if IsInUnit ( i ) then
110906: LD_VAR 0 7
110910: PPUSH
110911: CALL_OW 310
110915: IFFALSE 110926
// ComExitBuilding ( i ) ;
110917: LD_VAR 0 7
110921: PPUSH
110922: CALL_OW 122
// if GetLives ( i ) > 500 then
110926: LD_VAR 0 7
110930: PPUSH
110931: CALL_OW 256
110935: PUSH
110936: LD_INT 500
110938: GREATER
110939: IFFALSE 110992
// begin e := NearestUnitToUnit ( enemy , i ) ;
110941: LD_ADDR_VAR 0 5
110945: PUSH
110946: LD_VAR 0 4
110950: PPUSH
110951: LD_VAR 0 7
110955: PPUSH
110956: CALL_OW 74
110960: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
110961: LD_VAR 0 7
110965: PPUSH
110966: LD_VAR 0 5
110970: PPUSH
110971: CALL_OW 250
110975: PPUSH
110976: LD_VAR 0 5
110980: PPUSH
110981: CALL_OW 251
110985: PPUSH
110986: CALL_OW 114
// end else
110990: GO 111223
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
110992: LD_VAR 0 7
110996: PPUSH
110997: LD_EXP 50
111001: PUSH
111002: LD_VAR 0 1
111006: ARRAY
111007: PPUSH
111008: LD_INT 2
111010: PUSH
111011: LD_INT 30
111013: PUSH
111014: LD_INT 0
111016: PUSH
111017: EMPTY
111018: LIST
111019: LIST
111020: PUSH
111021: LD_INT 30
111023: PUSH
111024: LD_INT 1
111026: PUSH
111027: EMPTY
111028: LIST
111029: LIST
111030: PUSH
111031: LD_INT 30
111033: PUSH
111034: LD_INT 6
111036: PUSH
111037: EMPTY
111038: LIST
111039: LIST
111040: PUSH
111041: EMPTY
111042: LIST
111043: LIST
111044: LIST
111045: LIST
111046: PPUSH
111047: CALL_OW 72
111051: PPUSH
111052: LD_VAR 0 7
111056: PPUSH
111057: CALL_OW 74
111061: PPUSH
111062: CALL_OW 296
111066: PUSH
111067: LD_INT 10
111069: GREATER
111070: IFFALSE 111223
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
111072: LD_ADDR_VAR 0 8
111076: PUSH
111077: LD_EXP 50
111081: PUSH
111082: LD_VAR 0 1
111086: ARRAY
111087: PPUSH
111088: LD_INT 2
111090: PUSH
111091: LD_INT 30
111093: PUSH
111094: LD_INT 0
111096: PUSH
111097: EMPTY
111098: LIST
111099: LIST
111100: PUSH
111101: LD_INT 30
111103: PUSH
111104: LD_INT 1
111106: PUSH
111107: EMPTY
111108: LIST
111109: LIST
111110: PUSH
111111: LD_INT 30
111113: PUSH
111114: LD_INT 6
111116: PUSH
111117: EMPTY
111118: LIST
111119: LIST
111120: PUSH
111121: EMPTY
111122: LIST
111123: LIST
111124: LIST
111125: LIST
111126: PPUSH
111127: CALL_OW 72
111131: PPUSH
111132: LD_VAR 0 7
111136: PPUSH
111137: CALL_OW 74
111141: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
111142: LD_VAR 0 7
111146: PPUSH
111147: LD_VAR 0 8
111151: PPUSH
111152: CALL_OW 250
111156: PPUSH
111157: LD_INT 3
111159: PPUSH
111160: LD_INT 5
111162: PPUSH
111163: CALL_OW 272
111167: PPUSH
111168: LD_VAR 0 8
111172: PPUSH
111173: CALL_OW 251
111177: PPUSH
111178: LD_INT 3
111180: PPUSH
111181: LD_INT 5
111183: PPUSH
111184: CALL_OW 273
111188: PPUSH
111189: CALL_OW 111
// SetTag ( i , 0 ) ;
111193: LD_VAR 0 7
111197: PPUSH
111198: LD_INT 0
111200: PPUSH
111201: CALL_OW 109
// solds := solds diff i ;
111205: LD_ADDR_VAR 0 2
111209: PUSH
111210: LD_VAR 0 2
111214: PUSH
111215: LD_VAR 0 7
111219: DIFF
111220: ST_TO_ADDR
// continue ;
111221: GO 110903
// end ; end ;
111223: GO 110903
111225: POP
111226: POP
// until not solds or not enemy ;
111227: LD_VAR 0 2
111231: NOT
111232: PUSH
111233: LD_VAR 0 4
111237: NOT
111238: OR
111239: IFFALSE 110807
// MC_Reset ( base , 18 ) ;
111241: LD_VAR 0 1
111245: PPUSH
111246: LD_INT 18
111248: PPUSH
111249: CALL 59323 0 2
// end ;
111253: LD_VAR 0 3
111257: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
111258: LD_INT 0
111260: PPUSH
111261: PPUSH
111262: PPUSH
111263: PPUSH
111264: PPUSH
111265: PPUSH
111266: PPUSH
111267: PPUSH
111268: PPUSH
111269: PPUSH
111270: PPUSH
111271: PPUSH
111272: PPUSH
111273: PPUSH
111274: PPUSH
111275: PPUSH
111276: PPUSH
111277: PPUSH
111278: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
111279: LD_ADDR_VAR 0 12
111283: PUSH
111284: LD_EXP 50
111288: PUSH
111289: LD_VAR 0 1
111293: ARRAY
111294: PPUSH
111295: LD_INT 25
111297: PUSH
111298: LD_INT 3
111300: PUSH
111301: EMPTY
111302: LIST
111303: LIST
111304: PPUSH
111305: CALL_OW 72
111309: ST_TO_ADDR
// if mc_remote_driver [ base ] then
111310: LD_EXP 90
111314: PUSH
111315: LD_VAR 0 1
111319: ARRAY
111320: IFFALSE 111344
// mechs := mechs diff mc_remote_driver [ base ] ;
111322: LD_ADDR_VAR 0 12
111326: PUSH
111327: LD_VAR 0 12
111331: PUSH
111332: LD_EXP 90
111336: PUSH
111337: LD_VAR 0 1
111341: ARRAY
111342: DIFF
111343: ST_TO_ADDR
// for i in mechs do
111344: LD_ADDR_VAR 0 4
111348: PUSH
111349: LD_VAR 0 12
111353: PUSH
111354: FOR_IN
111355: IFFALSE 111390
// if GetTag ( i ) > 0 then
111357: LD_VAR 0 4
111361: PPUSH
111362: CALL_OW 110
111366: PUSH
111367: LD_INT 0
111369: GREATER
111370: IFFALSE 111388
// mechs := mechs diff i ;
111372: LD_ADDR_VAR 0 12
111376: PUSH
111377: LD_VAR 0 12
111381: PUSH
111382: LD_VAR 0 4
111386: DIFF
111387: ST_TO_ADDR
111388: GO 111354
111390: POP
111391: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111392: LD_ADDR_VAR 0 8
111396: PUSH
111397: LD_EXP 50
111401: PUSH
111402: LD_VAR 0 1
111406: ARRAY
111407: PPUSH
111408: LD_INT 2
111410: PUSH
111411: LD_INT 25
111413: PUSH
111414: LD_INT 1
111416: PUSH
111417: EMPTY
111418: LIST
111419: LIST
111420: PUSH
111421: LD_INT 25
111423: PUSH
111424: LD_INT 5
111426: PUSH
111427: EMPTY
111428: LIST
111429: LIST
111430: PUSH
111431: LD_INT 25
111433: PUSH
111434: LD_INT 8
111436: PUSH
111437: EMPTY
111438: LIST
111439: LIST
111440: PUSH
111441: LD_INT 25
111443: PUSH
111444: LD_INT 9
111446: PUSH
111447: EMPTY
111448: LIST
111449: LIST
111450: PUSH
111451: EMPTY
111452: LIST
111453: LIST
111454: LIST
111455: LIST
111456: LIST
111457: PPUSH
111458: CALL_OW 72
111462: ST_TO_ADDR
// if not defenders and not solds then
111463: LD_VAR 0 2
111467: NOT
111468: PUSH
111469: LD_VAR 0 8
111473: NOT
111474: AND
111475: IFFALSE 111479
// exit ;
111477: GO 113249
// depot_under_attack := false ;
111479: LD_ADDR_VAR 0 16
111483: PUSH
111484: LD_INT 0
111486: ST_TO_ADDR
// sold_defenders := [ ] ;
111487: LD_ADDR_VAR 0 17
111491: PUSH
111492: EMPTY
111493: ST_TO_ADDR
// if mechs then
111494: LD_VAR 0 12
111498: IFFALSE 111651
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
111500: LD_ADDR_VAR 0 4
111504: PUSH
111505: LD_VAR 0 2
111509: PPUSH
111510: LD_INT 21
111512: PUSH
111513: LD_INT 2
111515: PUSH
111516: EMPTY
111517: LIST
111518: LIST
111519: PPUSH
111520: CALL_OW 72
111524: PUSH
111525: FOR_IN
111526: IFFALSE 111649
// begin if GetTag ( i ) <> 20 then
111528: LD_VAR 0 4
111532: PPUSH
111533: CALL_OW 110
111537: PUSH
111538: LD_INT 20
111540: NONEQUAL
111541: IFFALSE 111555
// SetTag ( i , 20 ) ;
111543: LD_VAR 0 4
111547: PPUSH
111548: LD_INT 20
111550: PPUSH
111551: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
111555: LD_VAR 0 4
111559: PPUSH
111560: CALL_OW 263
111564: PUSH
111565: LD_INT 1
111567: EQUAL
111568: PUSH
111569: LD_VAR 0 4
111573: PPUSH
111574: CALL_OW 311
111578: NOT
111579: AND
111580: IFFALSE 111647
// begin un := mechs [ 1 ] ;
111582: LD_ADDR_VAR 0 10
111586: PUSH
111587: LD_VAR 0 12
111591: PUSH
111592: LD_INT 1
111594: ARRAY
111595: ST_TO_ADDR
// ComExit ( un ) ;
111596: LD_VAR 0 10
111600: PPUSH
111601: CALL 51330 0 1
// AddComEnterUnit ( un , i ) ;
111605: LD_VAR 0 10
111609: PPUSH
111610: LD_VAR 0 4
111614: PPUSH
111615: CALL_OW 180
// SetTag ( un , 19 ) ;
111619: LD_VAR 0 10
111623: PPUSH
111624: LD_INT 19
111626: PPUSH
111627: CALL_OW 109
// mechs := mechs diff un ;
111631: LD_ADDR_VAR 0 12
111635: PUSH
111636: LD_VAR 0 12
111640: PUSH
111641: LD_VAR 0 10
111645: DIFF
111646: ST_TO_ADDR
// end ; end ;
111647: GO 111525
111649: POP
111650: POP
// if solds then
111651: LD_VAR 0 8
111655: IFFALSE 111714
// for i in solds do
111657: LD_ADDR_VAR 0 4
111661: PUSH
111662: LD_VAR 0 8
111666: PUSH
111667: FOR_IN
111668: IFFALSE 111712
// if not GetTag ( i ) then
111670: LD_VAR 0 4
111674: PPUSH
111675: CALL_OW 110
111679: NOT
111680: IFFALSE 111710
// begin defenders := defenders union i ;
111682: LD_ADDR_VAR 0 2
111686: PUSH
111687: LD_VAR 0 2
111691: PUSH
111692: LD_VAR 0 4
111696: UNION
111697: ST_TO_ADDR
// SetTag ( i , 18 ) ;
111698: LD_VAR 0 4
111702: PPUSH
111703: LD_INT 18
111705: PPUSH
111706: CALL_OW 109
// end ;
111710: GO 111667
111712: POP
111713: POP
// repeat wait ( 0 0$2 ) ;
111714: LD_INT 70
111716: PPUSH
111717: CALL_OW 67
// enemy := mc_scan [ base ] ;
111721: LD_ADDR_VAR 0 21
111725: PUSH
111726: LD_EXP 73
111730: PUSH
111731: LD_VAR 0 1
111735: ARRAY
111736: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111737: LD_EXP 50
111741: PUSH
111742: LD_VAR 0 1
111746: ARRAY
111747: NOT
111748: PUSH
111749: LD_EXP 50
111753: PUSH
111754: LD_VAR 0 1
111758: ARRAY
111759: PUSH
111760: EMPTY
111761: EQUAL
111762: OR
111763: IFFALSE 111800
// begin for i in defenders do
111765: LD_ADDR_VAR 0 4
111769: PUSH
111770: LD_VAR 0 2
111774: PUSH
111775: FOR_IN
111776: IFFALSE 111789
// ComStop ( i ) ;
111778: LD_VAR 0 4
111782: PPUSH
111783: CALL_OW 141
111787: GO 111775
111789: POP
111790: POP
// defenders := [ ] ;
111791: LD_ADDR_VAR 0 2
111795: PUSH
111796: EMPTY
111797: ST_TO_ADDR
// exit ;
111798: GO 113249
// end ; for i in defenders do
111800: LD_ADDR_VAR 0 4
111804: PUSH
111805: LD_VAR 0 2
111809: PUSH
111810: FOR_IN
111811: IFFALSE 112709
// begin e := NearestUnitToUnit ( enemy , i ) ;
111813: LD_ADDR_VAR 0 13
111817: PUSH
111818: LD_VAR 0 21
111822: PPUSH
111823: LD_VAR 0 4
111827: PPUSH
111828: CALL_OW 74
111832: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111833: LD_ADDR_VAR 0 7
111837: PUSH
111838: LD_EXP 50
111842: PUSH
111843: LD_VAR 0 1
111847: ARRAY
111848: PPUSH
111849: LD_INT 2
111851: PUSH
111852: LD_INT 30
111854: PUSH
111855: LD_INT 0
111857: PUSH
111858: EMPTY
111859: LIST
111860: LIST
111861: PUSH
111862: LD_INT 30
111864: PUSH
111865: LD_INT 1
111867: PUSH
111868: EMPTY
111869: LIST
111870: LIST
111871: PUSH
111872: EMPTY
111873: LIST
111874: LIST
111875: LIST
111876: PPUSH
111877: CALL_OW 72
111881: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
111882: LD_ADDR_VAR 0 16
111886: PUSH
111887: LD_VAR 0 7
111891: NOT
111892: PUSH
111893: LD_VAR 0 7
111897: PPUSH
111898: LD_INT 3
111900: PUSH
111901: LD_INT 24
111903: PUSH
111904: LD_INT 600
111906: PUSH
111907: EMPTY
111908: LIST
111909: LIST
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: PPUSH
111915: CALL_OW 72
111919: OR
111920: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
111921: LD_VAR 0 4
111925: PPUSH
111926: CALL_OW 247
111930: PUSH
111931: LD_INT 2
111933: DOUBLE
111934: EQUAL
111935: IFTRUE 111939
111937: GO 112335
111939: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
111940: LD_VAR 0 4
111944: PPUSH
111945: CALL_OW 256
111949: PUSH
111950: LD_INT 1000
111952: EQUAL
111953: PUSH
111954: LD_VAR 0 4
111958: PPUSH
111959: LD_VAR 0 13
111963: PPUSH
111964: CALL_OW 296
111968: PUSH
111969: LD_INT 40
111971: LESS
111972: PUSH
111973: LD_VAR 0 13
111977: PPUSH
111978: LD_EXP 75
111982: PUSH
111983: LD_VAR 0 1
111987: ARRAY
111988: PPUSH
111989: CALL_OW 308
111993: OR
111994: AND
111995: IFFALSE 112117
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
111997: LD_VAR 0 4
112001: PPUSH
112002: CALL_OW 262
112006: PUSH
112007: LD_INT 1
112009: EQUAL
112010: PUSH
112011: LD_VAR 0 4
112015: PPUSH
112016: CALL_OW 261
112020: PUSH
112021: LD_INT 30
112023: LESS
112024: AND
112025: PUSH
112026: LD_VAR 0 7
112030: AND
112031: IFFALSE 112101
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
112033: LD_VAR 0 4
112037: PPUSH
112038: LD_VAR 0 7
112042: PPUSH
112043: LD_VAR 0 4
112047: PPUSH
112048: CALL_OW 74
112052: PPUSH
112053: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
112057: LD_VAR 0 4
112061: PPUSH
112062: LD_VAR 0 7
112066: PPUSH
112067: LD_VAR 0 4
112071: PPUSH
112072: CALL_OW 74
112076: PPUSH
112077: CALL_OW 296
112081: PUSH
112082: LD_INT 6
112084: LESS
112085: IFFALSE 112099
// SetFuel ( i , 100 ) ;
112087: LD_VAR 0 4
112091: PPUSH
112092: LD_INT 100
112094: PPUSH
112095: CALL_OW 240
// end else
112099: GO 112115
// ComAttackUnit ( i , e ) ;
112101: LD_VAR 0 4
112105: PPUSH
112106: LD_VAR 0 13
112110: PPUSH
112111: CALL_OW 115
// end else
112115: GO 112218
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112117: LD_VAR 0 13
112121: PPUSH
112122: LD_EXP 75
112126: PUSH
112127: LD_VAR 0 1
112131: ARRAY
112132: PPUSH
112133: CALL_OW 308
112137: NOT
112138: PUSH
112139: LD_VAR 0 4
112143: PPUSH
112144: LD_VAR 0 13
112148: PPUSH
112149: CALL_OW 296
112153: PUSH
112154: LD_INT 40
112156: GREATEREQUAL
112157: AND
112158: PUSH
112159: LD_VAR 0 4
112163: PPUSH
112164: CALL_OW 256
112168: PUSH
112169: LD_INT 650
112171: LESSEQUAL
112172: OR
112173: PUSH
112174: LD_VAR 0 4
112178: PPUSH
112179: LD_EXP 74
112183: PUSH
112184: LD_VAR 0 1
112188: ARRAY
112189: PPUSH
112190: CALL_OW 308
112194: NOT
112195: AND
112196: IFFALSE 112218
// ComMoveToArea ( i , mc_parking [ base ] ) ;
112198: LD_VAR 0 4
112202: PPUSH
112203: LD_EXP 74
112207: PUSH
112208: LD_VAR 0 1
112212: ARRAY
112213: PPUSH
112214: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
112218: LD_VAR 0 4
112222: PPUSH
112223: CALL_OW 256
112227: PUSH
112228: LD_INT 1000
112230: LESS
112231: PUSH
112232: LD_VAR 0 4
112236: PPUSH
112237: CALL_OW 263
112241: PUSH
112242: LD_INT 1
112244: EQUAL
112245: AND
112246: PUSH
112247: LD_VAR 0 4
112251: PPUSH
112252: CALL_OW 311
112256: AND
112257: PUSH
112258: LD_VAR 0 4
112262: PPUSH
112263: LD_EXP 74
112267: PUSH
112268: LD_VAR 0 1
112272: ARRAY
112273: PPUSH
112274: CALL_OW 308
112278: AND
112279: IFFALSE 112333
// begin mech := IsDrivenBy ( i ) ;
112281: LD_ADDR_VAR 0 9
112285: PUSH
112286: LD_VAR 0 4
112290: PPUSH
112291: CALL_OW 311
112295: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
112296: LD_VAR 0 9
112300: PPUSH
112301: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
112305: LD_VAR 0 9
112309: PPUSH
112310: LD_VAR 0 4
112314: PPUSH
112315: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
112319: LD_VAR 0 9
112323: PPUSH
112324: LD_VAR 0 4
112328: PPUSH
112329: CALL_OW 180
// end ; end ; unit_human :
112333: GO 112680
112335: LD_INT 1
112337: DOUBLE
112338: EQUAL
112339: IFTRUE 112343
112341: GO 112679
112343: POP
// begin b := IsInUnit ( i ) ;
112344: LD_ADDR_VAR 0 18
112348: PUSH
112349: LD_VAR 0 4
112353: PPUSH
112354: CALL_OW 310
112358: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
112359: LD_ADDR_VAR 0 19
112363: PUSH
112364: LD_VAR 0 18
112368: NOT
112369: PUSH
112370: LD_VAR 0 18
112374: PPUSH
112375: CALL_OW 266
112379: PUSH
112380: LD_INT 32
112382: PUSH
112383: LD_INT 31
112385: PUSH
112386: EMPTY
112387: LIST
112388: LIST
112389: IN
112390: OR
112391: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
112392: LD_VAR 0 18
112396: PPUSH
112397: CALL_OW 266
112401: PUSH
112402: LD_INT 5
112404: EQUAL
112405: PUSH
112406: LD_VAR 0 4
112410: PPUSH
112411: CALL_OW 257
112415: PUSH
112416: LD_INT 1
112418: PUSH
112419: LD_INT 2
112421: PUSH
112422: LD_INT 3
112424: PUSH
112425: LD_INT 4
112427: PUSH
112428: EMPTY
112429: LIST
112430: LIST
112431: LIST
112432: LIST
112433: IN
112434: AND
112435: IFFALSE 112472
// begin class := AllowSpecClass ( i ) ;
112437: LD_ADDR_VAR 0 20
112441: PUSH
112442: LD_VAR 0 4
112446: PPUSH
112447: CALL 15397 0 1
112451: ST_TO_ADDR
// if class then
112452: LD_VAR 0 20
112456: IFFALSE 112472
// ComChangeProfession ( i , class ) ;
112458: LD_VAR 0 4
112462: PPUSH
112463: LD_VAR 0 20
112467: PPUSH
112468: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
112472: LD_VAR 0 16
112476: PUSH
112477: LD_VAR 0 2
112481: PPUSH
112482: LD_INT 21
112484: PUSH
112485: LD_INT 2
112487: PUSH
112488: EMPTY
112489: LIST
112490: LIST
112491: PPUSH
112492: CALL_OW 72
112496: PUSH
112497: LD_INT 1
112499: LESSEQUAL
112500: OR
112501: PUSH
112502: LD_VAR 0 19
112506: AND
112507: PUSH
112508: LD_VAR 0 4
112512: PUSH
112513: LD_VAR 0 17
112517: IN
112518: NOT
112519: AND
112520: IFFALSE 112613
// begin if b then
112522: LD_VAR 0 18
112526: IFFALSE 112575
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
112528: LD_VAR 0 18
112532: PPUSH
112533: LD_VAR 0 21
112537: PPUSH
112538: LD_VAR 0 18
112542: PPUSH
112543: CALL_OW 74
112547: PPUSH
112548: CALL_OW 296
112552: PUSH
112553: LD_INT 10
112555: LESS
112556: PUSH
112557: LD_VAR 0 18
112561: PPUSH
112562: CALL_OW 461
112566: PUSH
112567: LD_INT 7
112569: NONEQUAL
112570: AND
112571: IFFALSE 112575
// continue ;
112573: GO 111810
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
112575: LD_ADDR_VAR 0 17
112579: PUSH
112580: LD_VAR 0 17
112584: PPUSH
112585: LD_VAR 0 17
112589: PUSH
112590: LD_INT 1
112592: PLUS
112593: PPUSH
112594: LD_VAR 0 4
112598: PPUSH
112599: CALL_OW 1
112603: ST_TO_ADDR
// ComExitBuilding ( i ) ;
112604: LD_VAR 0 4
112608: PPUSH
112609: CALL_OW 122
// end ; if sold_defenders then
112613: LD_VAR 0 17
112617: IFFALSE 112677
// if i in sold_defenders then
112619: LD_VAR 0 4
112623: PUSH
112624: LD_VAR 0 17
112628: IN
112629: IFFALSE 112677
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
112631: LD_VAR 0 4
112635: PPUSH
112636: CALL_OW 314
112640: NOT
112641: PUSH
112642: LD_VAR 0 4
112646: PPUSH
112647: LD_VAR 0 13
112651: PPUSH
112652: CALL_OW 296
112656: PUSH
112657: LD_INT 30
112659: LESS
112660: AND
112661: IFFALSE 112677
// ComAttackUnit ( i , e ) ;
112663: LD_VAR 0 4
112667: PPUSH
112668: LD_VAR 0 13
112672: PPUSH
112673: CALL_OW 115
// end ; end ; end ;
112677: GO 112680
112679: POP
// if IsDead ( i ) then
112680: LD_VAR 0 4
112684: PPUSH
112685: CALL_OW 301
112689: IFFALSE 112707
// defenders := defenders diff i ;
112691: LD_ADDR_VAR 0 2
112695: PUSH
112696: LD_VAR 0 2
112700: PUSH
112701: LD_VAR 0 4
112705: DIFF
112706: ST_TO_ADDR
// end ;
112707: GO 111810
112709: POP
112710: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
112711: LD_VAR 0 21
112715: NOT
112716: PUSH
112717: LD_VAR 0 2
112721: NOT
112722: OR
112723: PUSH
112724: LD_EXP 50
112728: PUSH
112729: LD_VAR 0 1
112733: ARRAY
112734: NOT
112735: OR
112736: IFFALSE 111714
// MC_Reset ( base , 18 ) ;
112738: LD_VAR 0 1
112742: PPUSH
112743: LD_INT 18
112745: PPUSH
112746: CALL 59323 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112750: LD_ADDR_VAR 0 2
112754: PUSH
112755: LD_VAR 0 2
112759: PUSH
112760: LD_VAR 0 2
112764: PPUSH
112765: LD_INT 2
112767: PUSH
112768: LD_INT 25
112770: PUSH
112771: LD_INT 1
112773: PUSH
112774: EMPTY
112775: LIST
112776: LIST
112777: PUSH
112778: LD_INT 25
112780: PUSH
112781: LD_INT 5
112783: PUSH
112784: EMPTY
112785: LIST
112786: LIST
112787: PUSH
112788: LD_INT 25
112790: PUSH
112791: LD_INT 8
112793: PUSH
112794: EMPTY
112795: LIST
112796: LIST
112797: PUSH
112798: LD_INT 25
112800: PUSH
112801: LD_INT 9
112803: PUSH
112804: EMPTY
112805: LIST
112806: LIST
112807: PUSH
112808: EMPTY
112809: LIST
112810: LIST
112811: LIST
112812: LIST
112813: LIST
112814: PPUSH
112815: CALL_OW 72
112819: DIFF
112820: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
112821: LD_VAR 0 21
112825: NOT
112826: PUSH
112827: LD_VAR 0 2
112831: PPUSH
112832: LD_INT 21
112834: PUSH
112835: LD_INT 2
112837: PUSH
112838: EMPTY
112839: LIST
112840: LIST
112841: PPUSH
112842: CALL_OW 72
112846: AND
112847: IFFALSE 113185
// begin tmp := FilterByTag ( defenders , 19 ) ;
112849: LD_ADDR_VAR 0 11
112853: PUSH
112854: LD_VAR 0 2
112858: PPUSH
112859: LD_INT 19
112861: PPUSH
112862: CALL 48514 0 2
112866: ST_TO_ADDR
// if tmp then
112867: LD_VAR 0 11
112871: IFFALSE 112941
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
112873: LD_ADDR_VAR 0 11
112877: PUSH
112878: LD_VAR 0 11
112882: PPUSH
112883: LD_INT 25
112885: PUSH
112886: LD_INT 3
112888: PUSH
112889: EMPTY
112890: LIST
112891: LIST
112892: PPUSH
112893: CALL_OW 72
112897: ST_TO_ADDR
// if tmp then
112898: LD_VAR 0 11
112902: IFFALSE 112941
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
112904: LD_ADDR_EXP 62
112908: PUSH
112909: LD_EXP 62
112913: PPUSH
112914: LD_VAR 0 1
112918: PPUSH
112919: LD_EXP 62
112923: PUSH
112924: LD_VAR 0 1
112928: ARRAY
112929: PUSH
112930: LD_VAR 0 11
112934: UNION
112935: PPUSH
112936: CALL_OW 1
112940: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
112941: LD_VAR 0 1
112945: PPUSH
112946: LD_INT 19
112948: PPUSH
112949: CALL 59323 0 2
// repeat wait ( 0 0$1 ) ;
112953: LD_INT 35
112955: PPUSH
112956: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112960: LD_EXP 50
112964: PUSH
112965: LD_VAR 0 1
112969: ARRAY
112970: NOT
112971: PUSH
112972: LD_EXP 50
112976: PUSH
112977: LD_VAR 0 1
112981: ARRAY
112982: PUSH
112983: EMPTY
112984: EQUAL
112985: OR
112986: IFFALSE 113023
// begin for i in defenders do
112988: LD_ADDR_VAR 0 4
112992: PUSH
112993: LD_VAR 0 2
112997: PUSH
112998: FOR_IN
112999: IFFALSE 113012
// ComStop ( i ) ;
113001: LD_VAR 0 4
113005: PPUSH
113006: CALL_OW 141
113010: GO 112998
113012: POP
113013: POP
// defenders := [ ] ;
113014: LD_ADDR_VAR 0 2
113018: PUSH
113019: EMPTY
113020: ST_TO_ADDR
// exit ;
113021: GO 113249
// end ; for i in defenders do
113023: LD_ADDR_VAR 0 4
113027: PUSH
113028: LD_VAR 0 2
113032: PUSH
113033: FOR_IN
113034: IFFALSE 113123
// begin if not IsInArea ( i , mc_parking [ base ] ) then
113036: LD_VAR 0 4
113040: PPUSH
113041: LD_EXP 74
113045: PUSH
113046: LD_VAR 0 1
113050: ARRAY
113051: PPUSH
113052: CALL_OW 308
113056: NOT
113057: IFFALSE 113081
// ComMoveToArea ( i , mc_parking [ base ] ) else
113059: LD_VAR 0 4
113063: PPUSH
113064: LD_EXP 74
113068: PUSH
113069: LD_VAR 0 1
113073: ARRAY
113074: PPUSH
113075: CALL_OW 113
113079: GO 113121
// if GetControl ( i ) = control_manual then
113081: LD_VAR 0 4
113085: PPUSH
113086: CALL_OW 263
113090: PUSH
113091: LD_INT 1
113093: EQUAL
113094: IFFALSE 113121
// if IsDrivenBy ( i ) then
113096: LD_VAR 0 4
113100: PPUSH
113101: CALL_OW 311
113105: IFFALSE 113121
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
113107: LD_VAR 0 4
113111: PPUSH
113112: CALL_OW 311
113116: PPUSH
113117: CALL_OW 121
// end ;
113121: GO 113033
113123: POP
113124: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
113125: LD_VAR 0 2
113129: PPUSH
113130: LD_INT 95
113132: PUSH
113133: LD_EXP 74
113137: PUSH
113138: LD_VAR 0 1
113142: ARRAY
113143: PUSH
113144: EMPTY
113145: LIST
113146: LIST
113147: PPUSH
113148: CALL_OW 72
113152: PUSH
113153: LD_VAR 0 2
113157: EQUAL
113158: PUSH
113159: LD_EXP 73
113163: PUSH
113164: LD_VAR 0 1
113168: ARRAY
113169: OR
113170: PUSH
113171: LD_EXP 50
113175: PUSH
113176: LD_VAR 0 1
113180: ARRAY
113181: NOT
113182: OR
113183: IFFALSE 112953
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
113185: LD_ADDR_EXP 72
113189: PUSH
113190: LD_EXP 72
113194: PPUSH
113195: LD_VAR 0 1
113199: PPUSH
113200: LD_VAR 0 2
113204: PPUSH
113205: LD_INT 21
113207: PUSH
113208: LD_INT 2
113210: PUSH
113211: EMPTY
113212: LIST
113213: LIST
113214: PPUSH
113215: CALL_OW 72
113219: PPUSH
113220: CALL_OW 1
113224: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
113225: LD_VAR 0 1
113229: PPUSH
113230: LD_INT 19
113232: PPUSH
113233: CALL 59323 0 2
// MC_Reset ( base , 20 ) ;
113237: LD_VAR 0 1
113241: PPUSH
113242: LD_INT 20
113244: PPUSH
113245: CALL 59323 0 2
// end ; end_of_file
113249: LD_VAR 0 3
113253: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
113254: LD_VAR 0 1
113258: PUSH
113259: LD_INT 200
113261: DOUBLE
113262: GREATEREQUAL
113263: IFFALSE 113271
113265: LD_INT 299
113267: DOUBLE
113268: LESSEQUAL
113269: IFTRUE 113273
113271: GO 113305
113273: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
113274: LD_VAR 0 1
113278: PPUSH
113279: LD_VAR 0 2
113283: PPUSH
113284: LD_VAR 0 3
113288: PPUSH
113289: LD_VAR 0 4
113293: PPUSH
113294: LD_VAR 0 5
113298: PPUSH
113299: CALL 102040 0 5
113303: GO 113382
113305: LD_INT 300
113307: DOUBLE
113308: GREATEREQUAL
113309: IFFALSE 113317
113311: LD_INT 399
113313: DOUBLE
113314: LESSEQUAL
113315: IFTRUE 113319
113317: GO 113381
113319: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
113320: LD_VAR 0 1
113324: PPUSH
113325: LD_VAR 0 2
113329: PPUSH
113330: LD_VAR 0 3
113334: PPUSH
113335: LD_VAR 0 4
113339: PPUSH
113340: LD_VAR 0 5
113344: PPUSH
113345: LD_VAR 0 6
113349: PPUSH
113350: LD_VAR 0 7
113354: PPUSH
113355: LD_VAR 0 8
113359: PPUSH
113360: LD_VAR 0 9
113364: PPUSH
113365: LD_VAR 0 10
113369: PPUSH
113370: LD_VAR 0 11
113374: PPUSH
113375: CALL 98365 0 11
113379: GO 113382
113381: POP
// end ;
113382: PPOPN 11
113384: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
113385: LD_VAR 0 1
113389: PPUSH
113390: LD_VAR 0 2
113394: PPUSH
113395: LD_VAR 0 3
113399: PPUSH
113400: LD_VAR 0 4
113404: PPUSH
113405: LD_VAR 0 5
113409: PPUSH
113410: CALL 101776 0 5
// end ; end_of_file
113414: PPOPN 5
113416: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
113417: LD_VAR 0 1
113421: PPUSH
113422: LD_VAR 0 2
113426: PPUSH
113427: LD_VAR 0 3
113431: PPUSH
113432: LD_VAR 0 4
113436: PPUSH
113437: LD_VAR 0 5
113441: PPUSH
113442: LD_VAR 0 6
113446: PPUSH
113447: CALL 86017 0 6
// end ;
113451: PPOPN 6
113453: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
113454: LD_INT 0
113456: PPUSH
// begin if not units then
113457: LD_VAR 0 1
113461: NOT
113462: IFFALSE 113466
// exit ;
113464: GO 113466
// end ;
113466: PPOPN 7
113468: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
113469: CALL 85921 0 0
// end ;
113473: PPOPN 1
113475: END
