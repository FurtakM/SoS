// export MissionStart ; export southAreaBlocker ; starting begin southAreaBlocker = true ;
   0: LD_ADDR_EXP 2
   4: PUSH
   5: LD_INT 1
   7: ST_TO_ADDR
// ResetFog ;
   8: CALL_OW 335
// AnimateTrees ( true ) ;
  12: LD_INT 1
  14: PPUSH
  15: CALL_OW 573
// RevealFogArea ( 1 , BetaArea ) ;
  19: LD_INT 1
  21: PPUSH
  22: LD_INT 8
  24: PPUSH
  25: CALL_OW 332
// GameType ;
  29: CALL 5514 0 0
// SetBName ( BetaA , beta ) ;
  33: LD_INT 1
  35: PPUSH
  36: LD_STRING beta
  38: PPUSH
  39: CALL_OW 500
// SetBName ( BetaB , beta ) ;
  43: LD_INT 3
  45: PPUSH
  46: LD_STRING beta
  48: PPUSH
  49: CALL_OW 500
// SetResourceType ( GetBase ( BetaA ) , mat_cans , startCrates [ 1 ] ) ;
  53: LD_INT 1
  55: PPUSH
  56: CALL_OW 274
  60: PPUSH
  61: LD_INT 1
  63: PPUSH
  64: LD_EXP 43
  68: PUSH
  69: LD_INT 1
  71: ARRAY
  72: PPUSH
  73: CALL_OW 277
// SetResourceType ( GetBase ( BetaB ) , mat_cans , startCrates [ 2 ] ) ;
  77: LD_INT 3
  79: PPUSH
  80: CALL_OW 274
  84: PPUSH
  85: LD_INT 1
  87: PPUSH
  88: LD_EXP 43
  92: PUSH
  93: LD_INT 2
  95: ARRAY
  96: PPUSH
  97: CALL_OW 277
// PrepareHeroes ;
 101: CALL 2677 0 0
// PrepareBeta ;
 105: CALL 3066 0 0
// HideArea ( 1 , SouthArea ) ;
 109: LD_INT 1
 111: PPUSH
 112: LD_INT 16
 114: PPUSH
 115: CALL_OW 333
// InGameOn ;
 119: CALL_OW 8
// ComHold ( Brighton ) ;
 123: LD_EXP 9
 127: PPUSH
 128: CALL_OW 140
// CenterNowOnUnits ( Brighton ) ;
 132: LD_EXP 9
 136: PPUSH
 137: CALL_OW 87
// ComMoveXY ( Megan , 50 , 42 ) ;
 141: LD_EXP 11
 145: PPUSH
 146: LD_INT 50
 148: PPUSH
 149: LD_INT 42
 151: PPUSH
 152: CALL_OW 111
// repeat wait ( 0 0$1 ) until GetDistUnits ( Megan , Brighton ) < 3 ;
 156: LD_INT 35
 158: PPUSH
 159: CALL_OW 67
 163: LD_EXP 11
 167: PPUSH
 168: LD_EXP 9
 172: PPUSH
 173: CALL_OW 296
 177: PUSH
 178: LD_INT 3
 180: LESS
 181: IFFALSE 156
// ComTurnUnit ( Megan , Brighton ) ;
 183: LD_EXP 11
 187: PPUSH
 188: LD_EXP 9
 192: PPUSH
 193: CALL_OW 119
// Say ( Megan , DMegan-1a ) ;
 197: LD_EXP 11
 201: PPUSH
 202: LD_STRING DMegan-1a
 204: PPUSH
 205: CALL_OW 88
// wait ( 0 0$0.3 ) ;
 209: LD_INT 10
 211: PPUSH
 212: CALL_OW 67
// ComTurnUnit ( Brighton , Megan ) ;
 216: LD_EXP 9
 220: PPUSH
 221: LD_EXP 11
 225: PPUSH
 226: CALL_OW 119
// Say ( Brighton , DBrighton-1a ) ;
 230: LD_EXP 9
 234: PPUSH
 235: LD_STRING DBrighton-1a
 237: PPUSH
 238: CALL_OW 88
// Say ( Megan , DMegan-2a ) ;
 242: LD_EXP 11
 246: PPUSH
 247: LD_STRING DMegan-2a
 249: PPUSH
 250: CALL_OW 88
// Say ( Brighton , DBrighton-2a ) ;
 254: LD_EXP 9
 258: PPUSH
 259: LD_STRING DBrighton-2a
 261: PPUSH
 262: CALL_OW 88
// ComMoveXY ( Megan , 40 , 37 ) ;
 266: LD_EXP 11
 270: PPUSH
 271: LD_INT 40
 273: PPUSH
 274: LD_INT 37
 276: PPUSH
 277: CALL_OW 111
// AddComTurnUnit ( Megan , Brighton ) ;
 281: LD_EXP 11
 285: PPUSH
 286: LD_EXP 9
 290: PPUSH
 291: CALL_OW 179
// ComMoveXY ( Palmer , 50 , 42 ) ;
 295: LD_EXP 10
 299: PPUSH
 300: LD_INT 50
 302: PPUSH
 303: LD_INT 42
 305: PPUSH
 306: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 310: LD_INT 35
 312: PPUSH
 313: CALL_OW 67
// until GetDistUnits ( Brighton , Palmer ) < 6 ;
 317: LD_EXP 9
 321: PPUSH
 322: LD_EXP 10
 326: PPUSH
 327: CALL_OW 296
 331: PUSH
 332: LD_INT 6
 334: LESS
 335: IFFALSE 310
// ComTurnUnit ( Brighton , Palmer ) ;
 337: LD_EXP 9
 341: PPUSH
 342: LD_EXP 10
 346: PPUSH
 347: CALL_OW 119
// ComTurnUnit ( Palmer , Brighton ) ;
 351: LD_EXP 10
 355: PPUSH
 356: LD_EXP 9
 360: PPUSH
 361: CALL_OW 119
// Say ( Palmer , DPalmer-1 ) ;
 365: LD_EXP 10
 369: PPUSH
 370: LD_STRING DPalmer-1
 372: PPUSH
 373: CALL_OW 88
// Say ( Brighton , DBrighton-1 ) ;
 377: LD_EXP 9
 381: PPUSH
 382: LD_STRING DBrighton-1
 384: PPUSH
 385: CALL_OW 88
// Say ( Palmer , DPalmer-2 ) ;
 389: LD_EXP 10
 393: PPUSH
 394: LD_STRING DPalmer-2
 396: PPUSH
 397: CALL_OW 88
// Say ( Brighton , DBrighton-2 ) ;
 401: LD_EXP 9
 405: PPUSH
 406: LD_STRING DBrighton-2
 408: PPUSH
 409: CALL_OW 88
// Say ( Palmer , DPalmer-3 ) ;
 413: LD_EXP 10
 417: PPUSH
 418: LD_STRING DPalmer-3
 420: PPUSH
 421: CALL_OW 88
// Say ( Brighton , DBrighton-3 ) ;
 425: LD_EXP 9
 429: PPUSH
 430: LD_STRING DBrighton-3
 432: PPUSH
 433: CALL_OW 88
// Say ( Palmer , DPalmer-4 ) ;
 437: LD_EXP 10
 441: PPUSH
 442: LD_STRING DPalmer-4
 444: PPUSH
 445: CALL_OW 88
// ComEnterUnit ( Palmer , AmTower ) ;
 449: LD_EXP 10
 453: PPUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
 461: LD_INT 35
 463: PPUSH
 464: CALL_OW 67
// until IsInUnit ( Palmer ) = AmTower ;
 468: LD_EXP 10
 472: PPUSH
 473: CALL_OW 310
 477: PUSH
 478: LD_INT 6
 480: EQUAL
 481: IFFALSE 461
// SayRadio ( Palmer , DPalmer-5 ) ;
 483: LD_EXP 10
 487: PPUSH
 488: LD_STRING DPalmer-5
 490: PPUSH
 491: CALL_OW 94
// ComMoveXY ( Brighton , 59 , 36 ) ;
 495: LD_EXP 9
 499: PPUSH
 500: LD_INT 59
 502: PPUSH
 503: LD_INT 36
 505: PPUSH
 506: CALL_OW 111
// ComMoveXY ( Megan , 60 , 35 ) ;
 510: LD_EXP 11
 514: PPUSH
 515: LD_INT 60
 517: PPUSH
 518: LD_INT 35
 520: PPUSH
 521: CALL_OW 111
// ComMoveXY ( Palmer , 60 , 34 ) ;
 525: LD_EXP 10
 529: PPUSH
 530: LD_INT 60
 532: PPUSH
 533: LD_INT 34
 535: PPUSH
 536: CALL_OW 111
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 540: LD_EXP 9
 544: PPUSH
 545: LD_INT 99
 547: PPUSH
 548: LD_INT 37
 550: PPUSH
 551: CALL_OW 178
// AddComTurnUnit ( Megan , Brighton ) ;
 555: LD_EXP 11
 559: PPUSH
 560: LD_EXP 9
 564: PPUSH
 565: CALL_OW 179
// AddComTurnUnit ( Palmer , Brighton ) ;
 569: LD_EXP 10
 573: PPUSH
 574: LD_EXP 9
 578: PPUSH
 579: CALL_OW 179
// CenterOnXY ( 64 , 40 ) ;
 583: LD_INT 64
 585: PPUSH
 586: LD_INT 40
 588: PPUSH
 589: CALL_OW 84
// ComMeeting ( BetaSquad , SpotArea ) ;
 593: LD_EXP 12
 597: PPUSH
 598: LD_INT 13
 600: PPUSH
 601: CALL 12746 0 2
// wait ( 0 0$30 ) ;
 605: LD_INT 1050
 607: PPUSH
 608: CALL_OW 67
// Say ( Brighton , DBrighton-4 ) ;
 612: LD_EXP 9
 616: PPUSH
 617: LD_STRING DBrighton-4
 619: PPUSH
 620: CALL_OW 88
// Say ( Brighton , DBrighton-5 ) ;
 624: LD_EXP 9
 628: PPUSH
 629: LD_STRING DBrighton-5
 631: PPUSH
 632: CALL_OW 88
// AddComTurnUnit ( Brighton , Megan ) ;
 636: LD_EXP 9
 640: PPUSH
 641: LD_EXP 11
 645: PPUSH
 646: CALL_OW 179
// Say ( Brighton , DBrighton-6 ) ;
 650: LD_EXP 9
 654: PPUSH
 655: LD_STRING DBrighton-6
 657: PPUSH
 658: CALL_OW 88
// Say ( Megan , DMegan-1 ) ;
 662: LD_EXP 11
 666: PPUSH
 667: LD_STRING DMegan-1
 669: PPUSH
 670: CALL_OW 88
// Say ( Brighton , DBrighton-7 ) ;
 674: LD_EXP 9
 678: PPUSH
 679: LD_STRING DBrighton-7
 681: PPUSH
 682: CALL_OW 88
// AddComTurnXY ( Brighton , 99 , 37 ) ;
 686: LD_EXP 9
 690: PPUSH
 691: LD_INT 99
 693: PPUSH
 694: LD_INT 37
 696: PPUSH
 697: CALL_OW 178
// Say ( Brighton , DBrighton-8 ) ;
 701: LD_EXP 9
 705: PPUSH
 706: LD_STRING DBrighton-8
 708: PPUSH
 709: CALL_OW 88
// ChangeMissionObjectives ( C1 ) ;
 713: LD_STRING C1
 715: PPUSH
 716: CALL_OW 337
// InGameOff ;
 720: CALL_OW 9
// SaveForQuickRestart ;
 724: CALL_OW 22
// MissionStart := true ;
 728: LD_ADDR_EXP 1
 732: PUSH
 733: LD_INT 1
 735: ST_TO_ADDR
// PrepareRUBase_v2 ;
 736: CALL 4789 0 0
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
 740: LD_ADDR_EXP 65
 744: PUSH
 745: LD_EXP 65
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: PPUSH
 763: CALL_OW 69
 767: PPUSH
 768: CALL_OW 1
 772: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , RU_SecondPersonnel ) ;
 773: LD_ADDR_EXP 65
 777: PUSH
 778: LD_EXP 65
 782: PPUSH
 783: LD_INT 2
 785: PPUSH
 786: LD_EXP 36
 790: PPUSH
 791: CALL_OW 1
 795: ST_TO_ADDR
// MC_Start ( ) ;
 796: CALL 52531 0 0
// music_nat := 1 ;
 800: LD_ADDR_OWVAR 71
 804: PUSH
 805: LD_INT 1
 807: ST_TO_ADDR
// end ;
 808: END
// export ArmadaArrived , FirstAssaultRepelled ; export RuSpeaker ; every 0 0$1 trigger MissionStart do var i , tmp ;
 809: LD_EXP 1
 813: IFFALSE 1446
 815: GO 817
 817: DISABLE
 818: LD_INT 0
 820: PPUSH
 821: PPUSH
// begin wait ( ruArrival ) ;
 822: LD_EXP 42
 826: PPUSH
 827: CALL_OW 67
// PrepareRUArmada ;
 831: CALL 3648 0 0
// wait ( 0 0$3 ) ;
 835: LD_INT 105
 837: PPUSH
 838: CALL_OW 67
// tmp := AreaToList ( RUArrivalParkingArea , 0 ) ;
 842: LD_ADDR_VAR 0 2
 846: PUSH
 847: LD_INT 15
 849: PPUSH
 850: LD_INT 0
 852: PPUSH
 853: CALL_OW 517
 857: ST_TO_ADDR
// for i = 1 to RUArmada do
 858: LD_ADDR_VAR 0 1
 862: PUSH
 863: DOUBLE
 864: LD_INT 1
 866: DEC
 867: ST_TO_ADDR
 868: LD_EXP 17
 872: PUSH
 873: FOR_TO
 874: IFFALSE 923
// ComMoveXY ( RUArmada [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
 876: LD_EXP 17
 880: PUSH
 881: LD_VAR 0 1
 885: ARRAY
 886: PPUSH
 887: LD_VAR 0 2
 891: PUSH
 892: LD_INT 1
 894: ARRAY
 895: PUSH
 896: LD_VAR 0 1
 900: ARRAY
 901: PPUSH
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 2
 909: ARRAY
 910: PUSH
 911: LD_VAR 0 1
 915: ARRAY
 916: PPUSH
 917: CALL_OW 111
 921: GO 873
 923: POP
 924: POP
// ArmadaArrived := true ;
 925: LD_ADDR_EXP 3
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// Say ( Palmer , DPalmer-A1 ) ;
 933: LD_EXP 10
 937: PPUSH
 938: LD_STRING DPalmer-A1
 940: PPUSH
 941: CALL_OW 88
// Say ( Brighton , DBrighton-A1 ) ;
 945: LD_EXP 9
 949: PPUSH
 950: LD_STRING DBrighton-A1
 952: PPUSH
 953: CALL_OW 88
// wait ( 0 0$20 ) ;
 957: LD_INT 700
 959: PPUSH
 960: CALL_OW 67
// PrepareRUBase ;
 964: CALL 4373 0 0
// wait ( 1 1$20 ) ;
 968: LD_INT 2800
 970: PPUSH
 971: CALL_OW 67
// PrepareRUBulldozers ;
 975: CALL 4260 0 0
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
 979: LD_EXP 18
 983: PUSH
 984: LD_INT 1
 986: ARRAY
 987: PPUSH
 988: LD_INT 9
 990: PPUSH
 991: CALL 12603 0 2
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
 995: LD_EXP 18
 999: PUSH
1000: LD_INT 2
1002: ARRAY
1003: PPUSH
1004: LD_INT 11
1006: PPUSH
1007: CALL 12603 0 2
// DoNotAttack ( 1 , Bulldozers [ 1 ] ) ;
1011: LD_INT 1
1013: PPUSH
1014: LD_EXP 18
1018: PUSH
1019: LD_INT 1
1021: ARRAY
1022: PPUSH
1023: CALL_OW 471
// DoNotAttack ( 1 , Bulldozers [ 2 ] ) ;
1027: LD_INT 1
1029: PPUSH
1030: LD_EXP 18
1034: PUSH
1035: LD_INT 2
1037: ARRAY
1038: PPUSH
1039: CALL_OW 471
// wait ( 0 0$50 ) ;
1043: LD_INT 1750
1045: PPUSH
1046: CALL_OW 67
// ShowArea ( 1 , SouthArea ) ;
1050: LD_INT 1
1052: PPUSH
1053: LD_INT 16
1055: PPUSH
1056: CALL_OW 334
// InGameOn ;
1060: CALL_OW 8
// PlaceSeeing ( 95 , 93 , 1 , - 30 ) ;
1064: LD_INT 95
1066: PPUSH
1067: LD_INT 93
1069: PPUSH
1070: LD_INT 1
1072: PPUSH
1073: LD_INT 30
1075: NEG
1076: PPUSH
1077: CALL_OW 330
// ComMoveXY ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) , 63 , 39 ) ;
1081: LD_INT 10
1083: PPUSH
1084: LD_INT 22
1086: PUSH
1087: LD_INT 1
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: PPUSH
1094: CALL_OW 70
1098: PPUSH
1099: LD_INT 63
1101: PPUSH
1102: LD_INT 39
1104: PPUSH
1105: CALL_OW 111
// CenterOnXY ( 95 , 93 ) ;
1109: LD_INT 95
1111: PPUSH
1112: LD_INT 93
1114: PPUSH
1115: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
1119: LD_INT 35
1121: PPUSH
1122: CALL_OW 67
// if not HasTask ( Bulldozers [ 1 ] ) then
1126: LD_EXP 18
1130: PUSH
1131: LD_INT 1
1133: ARRAY
1134: PPUSH
1135: CALL_OW 314
1139: NOT
1140: IFFALSE 1158
// CutTreeInArea ( Bulldozers [ 1 ] , BulldozerArea ) ;
1142: LD_EXP 18
1146: PUSH
1147: LD_INT 1
1149: ARRAY
1150: PPUSH
1151: LD_INT 9
1153: PPUSH
1154: CALL 12603 0 2
// if not HasTask ( Bulldozers [ 2 ] ) then
1158: LD_EXP 18
1162: PUSH
1163: LD_INT 2
1165: ARRAY
1166: PPUSH
1167: CALL_OW 314
1171: NOT
1172: IFFALSE 1190
// CutTreeInArea ( Bulldozers [ 2 ] , BulldozerArea2 ) ;
1174: LD_EXP 18
1178: PUSH
1179: LD_INT 2
1181: ARRAY
1182: PPUSH
1183: LD_INT 11
1185: PPUSH
1186: CALL 12603 0 2
// until ListEnvironmentArea ( BulldozerArea ) < 2 or ListEnvironmentArea ( BulldozerArea2 ) < 2 or IsDead ( Bulldozers [ 1 ] ) ;
1190: LD_INT 9
1192: PPUSH
1193: CALL_OW 353
1197: PUSH
1198: LD_INT 2
1200: LESS
1201: PUSH
1202: LD_INT 11
1204: PPUSH
1205: CALL_OW 353
1209: PUSH
1210: LD_INT 2
1212: LESS
1213: OR
1214: PUSH
1215: LD_EXP 18
1219: PUSH
1220: LD_INT 1
1222: ARRAY
1223: PPUSH
1224: CALL_OW 301
1228: OR
1229: IFFALSE 1119
// if UnitFilter ( Bulldozers , [ f_ok ] ) then
1231: LD_EXP 18
1235: PPUSH
1236: LD_INT 50
1238: PUSH
1239: EMPTY
1240: LIST
1241: PPUSH
1242: CALL_OW 72
1246: IFFALSE 1299
// begin wait ( 0 0$10 ) ;
1248: LD_INT 350
1250: PPUSH
1251: CALL_OW 67
// ComMoveXY ( Bulldozers , 120 , 131 ) ;
1255: LD_EXP 18
1259: PPUSH
1260: LD_INT 120
1262: PPUSH
1263: LD_INT 131
1265: PPUSH
1266: CALL_OW 111
// for i in Bulldozers do
1270: LD_ADDR_VAR 0 1
1274: PUSH
1275: LD_EXP 18
1279: PUSH
1280: FOR_IN
1281: IFFALSE 1297
// NormalAttack ( 1 , i ) ;
1283: LD_INT 1
1285: PPUSH
1286: LD_VAR 0 1
1290: PPUSH
1291: CALL_OW 472
1295: GO 1280
1297: POP
1298: POP
// end ; wait ( 0 0$10 ) ;
1299: LD_INT 350
1301: PPUSH
1302: CALL_OW 67
// RemoveSeeing ( 95 , 93 , 1 ) ;
1306: LD_INT 95
1308: PPUSH
1309: LD_INT 93
1311: PPUSH
1312: LD_INT 1
1314: PPUSH
1315: CALL_OW 331
// southAreaBlocker = false ;
1319: LD_ADDR_EXP 2
1323: PUSH
1324: LD_INT 0
1326: ST_TO_ADDR
// wait ( 0 0$3 ) ;
1327: LD_INT 105
1329: PPUSH
1330: CALL_OW 67
// InGameOff ;
1334: CALL_OW 9
// SayEffect ( DRuSol-A1 ) ;
1338: LD_STRING DRuSol-A1
1340: PPUSH
1341: CALL_OW 96
// AssaultStarted := true ;
1345: LD_ADDR_EXP 8
1349: PUSH
1350: LD_INT 1
1352: ST_TO_ADDR
// wait ( 0 0$2 ) ;
1353: LD_INT 70
1355: PPUSH
1356: CALL_OW 67
// Say ( Yashin , DDeath-Yas-1 ) ;
1360: LD_EXP 13
1364: PPUSH
1365: LD_STRING DDeath-Yas-1
1367: PPUSH
1368: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-2 ) ;
1372: LD_EXP 15
1376: PPUSH
1377: LD_STRING DDeath-Gay-2
1379: PPUSH
1380: CALL_OW 88
// wait ( 0 0$2 ) ;
1384: LD_INT 70
1386: PPUSH
1387: CALL_OW 67
// Say ( Popov , DDeath-Pop-1 ) ;
1391: LD_EXP 14
1395: PPUSH
1396: LD_STRING DDeath-Pop-1
1398: PPUSH
1399: CALL_OW 88
// Say ( Gaydar , DDeath-Gay-1 ) ;
1403: LD_EXP 15
1407: PPUSH
1408: LD_STRING DDeath-Gay-1
1410: PPUSH
1411: CALL_OW 88
// wait ( 0 0$5 ) ;
1415: LD_INT 175
1417: PPUSH
1418: CALL_OW 67
// Say ( Sevi , DDeath-Vse-1 ) ;
1422: LD_EXP 16
1426: PPUSH
1427: LD_STRING DDeath-Vse-1
1429: PPUSH
1430: CALL_OW 88
// Say ( Popov , DDeath-Pop-2 ) ;
1434: LD_EXP 14
1438: PPUSH
1439: LD_STRING DDeath-Pop-2
1441: PPUSH
1442: CALL_OW 88
// end ;
1446: PPOPN 2
1448: END
// every 0 0$1 trigger AssaultStarted do var i , tmp ;
1449: LD_EXP 8
1453: IFFALSE 1905
1455: GO 1457
1457: DISABLE
1458: LD_INT 0
1460: PPUSH
1461: PPUSH
// begin PriorityAttack ( 6 , BetaA ) ;
1462: LD_INT 6
1464: PPUSH
1465: LD_INT 1
1467: PPUSH
1468: CALL_OW 470
// PriorityAttack ( 6 , BetaB ) ;
1472: LD_INT 6
1474: PPUSH
1475: LD_INT 3
1477: PPUSH
1478: CALL_OW 470
// repeat for i in RuArmada do
1482: LD_ADDR_VAR 0 1
1486: PUSH
1487: LD_EXP 17
1491: PUSH
1492: FOR_IN
1493: IFFALSE 1531
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
1495: LD_VAR 0 1
1499: PPUSH
1500: LD_INT 22
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: PPUSH
1510: CALL_OW 69
1514: PPUSH
1515: LD_VAR 0 1
1519: PPUSH
1520: CALL_OW 74
1524: PPUSH
1525: CALL_OW 115
1529: GO 1492
1531: POP
1532: POP
// wait ( 0 0$1 ) until FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_type , unit_human ] ] ) < 10 and IsDead ( Yashin ) and IsDead ( Popov ) and IsDead ( Gaydar ) and IsDead ( Sevi ) ;
1533: LD_INT 35
1535: PPUSH
1536: CALL_OW 67
1540: LD_INT 1
1542: PUSH
1543: LD_INT 22
1545: PUSH
1546: LD_INT 6
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: PUSH
1553: LD_INT 21
1555: PUSH
1556: LD_INT 1
1558: PUSH
1559: EMPTY
1560: LIST
1561: LIST
1562: PUSH
1563: EMPTY
1564: LIST
1565: LIST
1566: LIST
1567: PPUSH
1568: CALL_OW 69
1572: PUSH
1573: LD_INT 10
1575: LESS
1576: PUSH
1577: LD_EXP 13
1581: PPUSH
1582: CALL_OW 301
1586: AND
1587: PUSH
1588: LD_EXP 14
1592: PPUSH
1593: CALL_OW 301
1597: AND
1598: PUSH
1599: LD_EXP 15
1603: PPUSH
1604: CALL_OW 301
1608: AND
1609: PUSH
1610: LD_EXP 16
1614: PPUSH
1615: CALL_OW 301
1619: AND
1620: IFFALSE 1482
// AssaultStarted := false ;
1622: LD_ADDR_EXP 8
1626: PUSH
1627: LD_INT 0
1629: ST_TO_ADDR
// ComMoveToArea ( FilterAllUnits ( [ f_side , 6 ] ) , RUArrivalArea ) ;
1630: LD_INT 22
1632: PUSH
1633: LD_INT 6
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: PPUSH
1640: CALL_OW 69
1644: PPUSH
1645: LD_INT 5
1647: PPUSH
1648: CALL_OW 113
// RuSpeaker := FilterAllUnits ( [ f_and , [ f_side , 6 ] , [ f_sex , sex_male ] , [ f_type , unit_human ] , [ f_lives , 500 ] ] ) ;
1652: LD_ADDR_EXP 5
1656: PUSH
1657: LD_INT 1
1659: PUSH
1660: LD_INT 22
1662: PUSH
1663: LD_INT 6
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: PUSH
1670: LD_INT 26
1672: PUSH
1673: LD_INT 1
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: PUSH
1680: LD_INT 21
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: EMPTY
1687: LIST
1688: LIST
1689: PUSH
1690: LD_INT 24
1692: PUSH
1693: LD_INT 500
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: PUSH
1700: EMPTY
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PPUSH
1707: CALL_OW 69
1711: ST_TO_ADDR
// if RuSpeaker then
1712: LD_EXP 5
1716: IFFALSE 1734
// Say ( RuSpeaker [ 1 ] , DRuSol-A2 ) ;
1718: LD_EXP 5
1722: PUSH
1723: LD_INT 1
1725: ARRAY
1726: PPUSH
1727: LD_STRING DRuSol-A2
1729: PPUSH
1730: CALL_OW 88
// wait ( 0 0$30 ) ;
1734: LD_INT 1050
1736: PPUSH
1737: CALL_OW 67
// DialogueOn ;
1741: CALL_OW 6
// Say ( Brighton , DBrighton-B1 ) ;
1745: LD_EXP 9
1749: PPUSH
1750: LD_STRING DBrighton-B1
1752: PPUSH
1753: CALL_OW 88
// Say ( Palmer , DPalmer-B1 ) ;
1757: LD_EXP 10
1761: PPUSH
1762: LD_STRING DPalmer-B1
1764: PPUSH
1765: CALL_OW 88
// Say ( Brighton , DBrighton-B2 ) ;
1769: LD_EXP 9
1773: PPUSH
1774: LD_STRING DBrighton-B2
1776: PPUSH
1777: CALL_OW 88
// SayRadio ( Burlak , DBurlak-B1 ) ;
1781: LD_EXP 19
1785: PPUSH
1786: LD_STRING DBurlak-B1
1788: PPUSH
1789: CALL_OW 94
// Say ( Brighton , DBrighton-B3 ) ;
1793: LD_EXP 9
1797: PPUSH
1798: LD_STRING DBrighton-B3
1800: PPUSH
1801: CALL_OW 88
// Say ( Palmer , DPalmer-B2 ) ;
1805: LD_EXP 10
1809: PPUSH
1810: LD_STRING DPalmer-B2
1812: PPUSH
1813: CALL_OW 88
// Say ( Brighton , DBrighton-B4 ) ;
1817: LD_EXP 9
1821: PPUSH
1822: LD_STRING DBrighton-B4
1824: PPUSH
1825: CALL_OW 88
// Say ( Brighton , DBrighton-B5 ) ;
1829: LD_EXP 9
1833: PPUSH
1834: LD_STRING DBrighton-B5
1836: PPUSH
1837: CALL_OW 88
// DialogueOff ;
1841: CALL_OW 7
// ChangeMissionObjectives ( C2 ) ;
1845: LD_STRING C2
1847: PPUSH
1848: CALL_OW 337
// FirstAssaultRepelled := true ;
1852: LD_ADDR_EXP 4
1856: PUSH
1857: LD_INT 1
1859: ST_TO_ADDR
// RemoveUnit ( Bulldozers [ 1 ] ) ;
1860: LD_EXP 18
1864: PUSH
1865: LD_INT 1
1867: ARRAY
1868: PPUSH
1869: CALL_OW 64
// RemoveUnit ( Bulldozers [ 2 ] ) ;
1873: LD_EXP 18
1877: PUSH
1878: LD_INT 2
1880: ARRAY
1881: PPUSH
1882: CALL_OW 64
// AddComExitVehicle ( FilterAllUnits ( [ f_side , 6 ] ) ) ;
1886: LD_INT 22
1888: PUSH
1889: LD_INT 6
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PPUSH
1896: CALL_OW 69
1900: PPUSH
1901: CALL_OW 181
// end ;
1905: PPOPN 2
1907: END
// every 0 0$1 trigger FirstAssaultRepelled do var unit , insideUnit ;
1908: LD_EXP 4
1912: IFFALSE 2077
1914: GO 1916
1916: DISABLE
1917: LD_INT 0
1919: PPUSH
1920: PPUSH
// begin enable ;
1921: ENABLE
// if FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) = 0 then
1922: LD_INT 5
1924: PPUSH
1925: LD_INT 22
1927: PUSH
1928: LD_INT 6
1930: PUSH
1931: EMPTY
1932: LIST
1933: LIST
1934: PUSH
1935: EMPTY
1936: LIST
1937: PPUSH
1938: CALL_OW 70
1942: PUSH
1943: LD_INT 0
1945: EQUAL
1946: IFFALSE 1950
// exit ;
1948: GO 2077
// for unit in FilterUnitsInArea ( RUArrivalArea , [ [ f_side , 6 ] ] ) do
1950: LD_ADDR_VAR 0 1
1954: PUSH
1955: LD_INT 5
1957: PPUSH
1958: LD_INT 22
1960: PUSH
1961: LD_INT 6
1963: PUSH
1964: EMPTY
1965: LIST
1966: LIST
1967: PUSH
1968: EMPTY
1969: LIST
1970: PPUSH
1971: CALL_OW 70
1975: PUSH
1976: FOR_IN
1977: IFFALSE 2075
// begin SetSide ( unit , 3 ) ;
1979: LD_VAR 0 1
1983: PPUSH
1984: LD_INT 3
1986: PPUSH
1987: CALL_OW 235
// if ( GetType ( unit ) = unit_vehicle ) then
1991: LD_VAR 0 1
1995: PPUSH
1996: CALL_OW 247
2000: PUSH
2001: LD_INT 2
2003: EQUAL
2004: IFFALSE 2040
// for insideUnit in UnitsInside ( unit ) do
2006: LD_ADDR_VAR 0 2
2010: PUSH
2011: LD_VAR 0 1
2015: PPUSH
2016: CALL_OW 313
2020: PUSH
2021: FOR_IN
2022: IFFALSE 2038
// SetSide ( insideUnit , 3 ) ;
2024: LD_VAR 0 2
2028: PPUSH
2029: LD_INT 3
2031: PPUSH
2032: CALL_OW 235
2036: GO 2021
2038: POP
2039: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ f_side , 3 ] ) ) ;
2040: LD_ADDR_EXP 65
2044: PUSH
2045: LD_EXP 65
2049: PPUSH
2050: LD_INT 1
2052: PPUSH
2053: LD_INT 22
2055: PUSH
2056: LD_INT 3
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: PPUSH
2063: CALL_OW 69
2067: PPUSH
2068: CALL_OW 1
2072: ST_TO_ADDR
// end ;
2073: GO 1976
2075: POP
2076: POP
// end ;
2077: PPOPN 2
2079: END
// every 0 0$1 trigger FirstAssaultRepelled and jmmArrival > 0 0$00 do
2080: LD_EXP 4
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_INT 0
2092: GREATER
2093: AND
2094: IFFALSE 2114
2096: GO 2098
2098: DISABLE
// begin enable ;
2099: ENABLE
// jmmArrival := jmmArrival - 0 0$01 ;
2100: LD_ADDR_EXP 41
2104: PUSH
2105: LD_EXP 41
2109: PUSH
2110: LD_INT 35
2112: MINUS
2113: ST_TO_ADDR
// end ;
2114: END
// export JMM_Arrived ; every 0 0$1 trigger jmmArrival = 0 0$00 do
2115: LD_EXP 41
2119: PUSH
2120: LD_INT 0
2122: EQUAL
2123: IFFALSE 2229
2125: GO 2127
2127: DISABLE
// begin JMMReinforcement ;
2128: CALL 5117 0 0
// DialogueOn ;
2132: CALL_OW 6
// CenterOnUnits ( JMM ) ;
2136: LD_EXP 37
2140: PPUSH
2141: CALL_OW 85
// Say ( JMM , DJMM-F1 ) ;
2145: LD_EXP 37
2149: PPUSH
2150: LD_STRING DJMM-F1
2152: PPUSH
2153: CALL_OW 88
// if RussiansDefeated then
2157: LD_EXP 44
2161: IFFALSE 2187
// begin AddMedal ( Russians , 1 ) ;
2163: LD_STRING Russians
2165: PPUSH
2166: LD_INT 1
2168: PPUSH
2169: CALL_OW 101
// Say ( Brighton , DBrighton-F1a ) ;
2173: LD_EXP 9
2177: PPUSH
2178: LD_STRING DBrighton-F1a
2180: PPUSH
2181: CALL_OW 88
// end else
2185: GO 2217
// begin AddMedal ( Russians , - 1 ) ;
2187: LD_STRING Russians
2189: PPUSH
2190: LD_INT 1
2192: NEG
2193: PPUSH
2194: CALL_OW 101
// Say ( Brighton , DBrighton-F1 ) ;
2198: LD_EXP 9
2202: PPUSH
2203: LD_STRING DBrighton-F1
2205: PPUSH
2206: CALL_OW 88
// ChangeMissionObjectives ( C3 ) ;
2210: LD_STRING C3
2212: PPUSH
2213: CALL_OW 337
// end ; DialogueOff ;
2217: CALL_OW 7
// JMM_Arrived := true ;
2221: LD_ADDR_EXP 6
2225: PUSH
2226: LD_INT 1
2228: ST_TO_ADDR
// end ;
2229: END
// every 0 0$1 trigger JMM_Arrived and See ( 1 , Burlak ) do
2230: LD_EXP 6
2234: PUSH
2235: LD_INT 1
2237: PPUSH
2238: LD_EXP 19
2242: PPUSH
2243: CALL_OW 292
2247: AND
2248: IFFALSE 2277
2250: GO 2252
2252: DISABLE
// begin Say ( Burlak , DBurlak ) ;
2253: LD_EXP 19
2257: PPUSH
2258: LD_STRING DBurlak
2260: PPUSH
2261: CALL_OW 88
// Say ( JMM , DJMM ) ;
2265: LD_EXP 37
2269: PPUSH
2270: LD_STRING DJMM
2272: PPUSH
2273: CALL_OW 88
// end ;
2277: END
// export LaserBuilt ; every 0 0$1 trigger FilterAllUnits ( [ f_and , [ f_side , 1 ] , [ f_or , [ f_weapon , us_laser ] , [ f_bweapon , us_laser ] ] ] ) > 1 do
2278: LD_INT 1
2280: PUSH
2281: LD_INT 22
2283: PUSH
2284: LD_INT 1
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: PUSH
2291: LD_INT 2
2293: PUSH
2294: LD_INT 34
2296: PUSH
2297: LD_INT 9
2299: PUSH
2300: EMPTY
2301: LIST
2302: LIST
2303: PUSH
2304: LD_INT 35
2306: PUSH
2307: LD_INT 9
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: PUSH
2314: EMPTY
2315: LIST
2316: LIST
2317: LIST
2318: PUSH
2319: EMPTY
2320: LIST
2321: LIST
2322: LIST
2323: PPUSH
2324: CALL_OW 69
2328: PUSH
2329: LD_INT 1
2331: GREATER
2332: IFFALSE 2345
2334: GO 2336
2336: DISABLE
// LaserBuilt := true ;
2337: LD_ADDR_EXP 7
2341: PUSH
2342: LD_INT 1
2344: ST_TO_ADDR
2345: END
// export AssaultStarted ; every 0 0$1 trigger AssaultStarted and See ( 6 , NearestUnitToUnit ( FilterAllUnits ( [ f_and , [ [ f_side , 1 ] , [ f_bweapon , us_laser ] ] ] ) , IsInUnit ( Sevi ) ) ) do
2346: LD_EXP 8
2350: PUSH
2351: LD_INT 6
2353: PPUSH
2354: LD_INT 1
2356: PUSH
2357: LD_INT 22
2359: PUSH
2360: LD_INT 1
2362: PUSH
2363: EMPTY
2364: LIST
2365: LIST
2366: PUSH
2367: LD_INT 35
2369: PUSH
2370: LD_INT 9
2372: PUSH
2373: EMPTY
2374: LIST
2375: LIST
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: EMPTY
2382: LIST
2383: LIST
2384: PPUSH
2385: CALL_OW 69
2389: PPUSH
2390: LD_EXP 16
2394: PPUSH
2395: CALL_OW 310
2399: PPUSH
2400: CALL_OW 74
2404: PPUSH
2405: CALL_OW 292
2409: AND
2410: IFFALSE 2439
2412: GO 2414
2414: DISABLE
// begin Say ( Sevi , DDeath-Vse-2 ) ;
2415: LD_EXP 16
2419: PPUSH
2420: LD_STRING DDeath-Vse-2
2422: PPUSH
2423: CALL_OW 88
// Say ( Yashin , DDeath-Yas-2 ) ;
2427: LD_EXP 13
2431: PPUSH
2432: LD_STRING DDeath-Yas-2
2434: PPUSH
2435: CALL_OW 88
// end ;
2439: END
// every 0 0$1 trigger MissionStart and GetResourceArea ( CratesArea , mat_cans ) < 20 do
2440: LD_EXP 1
2444: PUSH
2445: LD_INT 12
2447: PPUSH
2448: LD_INT 1
2450: PPUSH
2451: CALL_OW 287
2455: PUSH
2456: LD_INT 20
2458: LESS
2459: AND
2460: IFFALSE 2502
2462: GO 2464
2464: DISABLE
// begin wait ( rand ( 0 0$50 , 2 2$20 ) ) ;
2465: LD_INT 1750
2467: PPUSH
2468: LD_INT 4900
2470: PPUSH
2471: CALL_OW 12
2475: PPUSH
2476: CALL_OW 67
// CreateCratesArea ( Rand ( 2 , 5 ) , CratesArea , true ) ;
2480: LD_INT 2
2482: PPUSH
2483: LD_INT 5
2485: PPUSH
2486: CALL_OW 12
2490: PPUSH
2491: LD_INT 12
2493: PPUSH
2494: LD_INT 1
2496: PPUSH
2497: CALL_OW 55
// enable ;
2501: ENABLE
// end ;
2502: END
// every 0 0$1 trigger FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) do var un , x , y ;
2503: LD_INT 17
2505: PPUSH
2506: LD_INT 81
2508: PUSH
2509: LD_INT 1
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PPUSH
2516: CALL_OW 70
2520: IFFALSE 2646
2522: GO 2524
2524: DISABLE
2525: LD_INT 0
2527: PPUSH
2528: PPUSH
2529: PPUSH
// begin un := FilterUnitsInArea ( EastFlankArea , [ f_enemy , 1 ] ) [ 1 ] ;
2530: LD_ADDR_VAR 0 1
2534: PUSH
2535: LD_INT 17
2537: PPUSH
2538: LD_INT 81
2540: PUSH
2541: LD_INT 1
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: PPUSH
2548: CALL_OW 70
2552: PUSH
2553: LD_INT 1
2555: ARRAY
2556: ST_TO_ADDR
// x := GetX ( un ) ;
2557: LD_ADDR_VAR 0 2
2561: PUSH
2562: LD_VAR 0 1
2566: PPUSH
2567: CALL_OW 250
2571: ST_TO_ADDR
// y := GetY ( un ) ;
2572: LD_ADDR_VAR 0 3
2576: PUSH
2577: LD_VAR 0 1
2581: PPUSH
2582: CALL_OW 251
2586: ST_TO_ADDR
// PlaceSeeing ( x , y , 1 , - 12 ) ;
2587: LD_VAR 0 2
2591: PPUSH
2592: LD_VAR 0 3
2596: PPUSH
2597: LD_INT 1
2599: PPUSH
2600: LD_INT 12
2602: NEG
2603: PPUSH
2604: CALL_OW 330
// CenterNowOnUnits ( un ) ;
2608: LD_VAR 0 1
2612: PPUSH
2613: CALL_OW 87
// Say ( Brighton , DBrighton-E1 ) ;
2617: LD_EXP 9
2621: PPUSH
2622: LD_STRING DBrighton-E1
2624: PPUSH
2625: CALL_OW 88
// RemoveSeeing ( x , y , 1 ) ;
2629: LD_VAR 0 2
2633: PPUSH
2634: LD_VAR 0 3
2638: PPUSH
2639: LD_INT 1
2641: PPUSH
2642: CALL_OW 331
// end ;
2646: PPOPN 3
2648: END
// every 0 0$1 trigger MissionStart do
2649: LD_EXP 1
2653: IFFALSE 2676
2655: GO 2657
2657: DISABLE
// begin enable ;
2658: ENABLE
// display_Strings := [ #tick , tick ] ;
2659: LD_ADDR_OWVAR 47
2663: PUSH
2664: LD_STRING #tick
2666: PUSH
2667: LD_OWVAR 1
2671: PUSH
2672: EMPTY
2673: LIST
2674: LIST
2675: ST_TO_ADDR
// end ; end_of_file
2676: END
// export Brighton , Palmer , Megan ; export BetaSquad ; export function PrepareHeroes ; begin
2677: LD_INT 0
2679: PPUSH
// uc_side := 1 ;
2680: LD_ADDR_OWVAR 20
2684: PUSH
2685: LD_INT 1
2687: ST_TO_ADDR
// hc_class = class_soldier ;
2688: LD_ADDR_OWVAR 28
2692: PUSH
2693: LD_INT 1
2695: ST_TO_ADDR
// uc_nation := nation_american ;
2696: LD_ADDR_OWVAR 21
2700: PUSH
2701: LD_INT 1
2703: ST_TO_ADDR
// hc_sex = sex_male ;
2704: LD_ADDR_OWVAR 27
2708: PUSH
2709: LD_INT 1
2711: ST_TO_ADDR
// hc_importance = 110 ;
2712: LD_ADDR_OWVAR 32
2716: PUSH
2717: LD_INT 110
2719: ST_TO_ADDR
// hc_basic_skills = [ 5 , 4 , 5 , 3 ] ;
2720: LD_ADDR_OWVAR 30
2724: PUSH
2725: LD_INT 5
2727: PUSH
2728: LD_INT 4
2730: PUSH
2731: LD_INT 5
2733: PUSH
2734: LD_INT 3
2736: PUSH
2737: EMPTY
2738: LIST
2739: LIST
2740: LIST
2741: LIST
2742: ST_TO_ADDR
// hc_skills = [ 9 , 6 , 7 , 6 ] ;
2743: LD_ADDR_OWVAR 31
2747: PUSH
2748: LD_INT 9
2750: PUSH
2751: LD_INT 6
2753: PUSH
2754: LD_INT 7
2756: PUSH
2757: LD_INT 6
2759: PUSH
2760: EMPTY
2761: LIST
2762: LIST
2763: LIST
2764: LIST
2765: ST_TO_ADDR
// hc_attr = [ 12 , 10 ] ;
2766: LD_ADDR_OWVAR 29
2770: PUSH
2771: LD_INT 12
2773: PUSH
2774: LD_INT 10
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: ST_TO_ADDR
// hc_name := Gerard Brighton ;
2781: LD_ADDR_OWVAR 26
2785: PUSH
2786: LD_STRING Gerard Brighton
2788: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2789: LD_ADDR_OWVAR 33
2793: PUSH
2794: LD_STRING Beta_Skirmish
2796: ST_TO_ADDR
// hc_face_number := 1 ;
2797: LD_ADDR_OWVAR 34
2801: PUSH
2802: LD_INT 1
2804: ST_TO_ADDR
// Brighton := CreateHuman ;
2805: LD_ADDR_EXP 9
2809: PUSH
2810: CALL_OW 44
2814: ST_TO_ADDR
// uc_nation := nation_american ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 1
2822: ST_TO_ADDR
// hc_importance = 80 ;
2823: LD_ADDR_OWVAR 32
2827: PUSH
2828: LD_INT 80
2830: ST_TO_ADDR
// hc_sex = sex_male ;
2831: LD_ADDR_OWVAR 27
2835: PUSH
2836: LD_INT 1
2838: ST_TO_ADDR
// hc_basic_skills = [ 5 , 5 , 3 , 1 ] ;
2839: LD_ADDR_OWVAR 30
2843: PUSH
2844: LD_INT 5
2846: PUSH
2847: LD_INT 5
2849: PUSH
2850: LD_INT 3
2852: PUSH
2853: LD_INT 1
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: ST_TO_ADDR
// hc_skills = [ 7 , 6 , 5 , 3 ] ;
2862: LD_ADDR_OWVAR 31
2866: PUSH
2867: LD_INT 7
2869: PUSH
2870: LD_INT 6
2872: PUSH
2873: LD_INT 5
2875: PUSH
2876: LD_INT 3
2878: PUSH
2879: EMPTY
2880: LIST
2881: LIST
2882: LIST
2883: LIST
2884: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
2885: LD_ADDR_OWVAR 29
2889: PUSH
2890: LD_INT 10
2892: PUSH
2893: LD_INT 10
2895: PUSH
2896: EMPTY
2897: LIST
2898: LIST
2899: ST_TO_ADDR
// hc_name := Brian Palmer ;
2900: LD_ADDR_OWVAR 26
2904: PUSH
2905: LD_STRING Brian Palmer
2907: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
2908: LD_ADDR_OWVAR 33
2912: PUSH
2913: LD_STRING Beta_Skirmish
2915: ST_TO_ADDR
// hc_face_number := 3 ;
2916: LD_ADDR_OWVAR 34
2920: PUSH
2921: LD_INT 3
2923: ST_TO_ADDR
// Palmer := CreateHuman ;
2924: LD_ADDR_EXP 10
2928: PUSH
2929: CALL_OW 44
2933: ST_TO_ADDR
// hc_class = class_scientistic ;
2934: LD_ADDR_OWVAR 28
2938: PUSH
2939: LD_INT 4
2941: ST_TO_ADDR
// uc_nation := nation_american ;
2942: LD_ADDR_OWVAR 21
2946: PUSH
2947: LD_INT 1
2949: ST_TO_ADDR
// hc_importance = 70 ;
2950: LD_ADDR_OWVAR 32
2954: PUSH
2955: LD_INT 70
2957: ST_TO_ADDR
// hc_sex = sex_female ;
2958: LD_ADDR_OWVAR 27
2962: PUSH
2963: LD_INT 2
2965: ST_TO_ADDR
// hc_basic_skills = [ 3 , 2 , 4 , 6 ] ;
2966: LD_ADDR_OWVAR 30
2970: PUSH
2971: LD_INT 3
2973: PUSH
2974: LD_INT 2
2976: PUSH
2977: LD_INT 4
2979: PUSH
2980: LD_INT 6
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: ST_TO_ADDR
// hc_skills = [ 4 , 2 , 5 , 8 ] ;
2989: LD_ADDR_OWVAR 31
2993: PUSH
2994: LD_INT 4
2996: PUSH
2997: LD_INT 2
2999: PUSH
3000: LD_INT 5
3002: PUSH
3003: LD_INT 8
3005: PUSH
3006: EMPTY
3007: LIST
3008: LIST
3009: LIST
3010: LIST
3011: ST_TO_ADDR
// hc_attr = [ 10 , 10 ] ;
3012: LD_ADDR_OWVAR 29
3016: PUSH
3017: LD_INT 10
3019: PUSH
3020: LD_INT 10
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: ST_TO_ADDR
// hc_name := Megan Armitage ;
3027: LD_ADDR_OWVAR 26
3031: PUSH
3032: LD_STRING Megan Armitage
3034: ST_TO_ADDR
// hc_gallery := Beta_Skirmish ;
3035: LD_ADDR_OWVAR 33
3039: PUSH
3040: LD_STRING Beta_Skirmish
3042: ST_TO_ADDR
// hc_face_number := 4 ;
3043: LD_ADDR_OWVAR 34
3047: PUSH
3048: LD_INT 4
3050: ST_TO_ADDR
// Megan := CreateHuman ;
3051: LD_ADDR_EXP 11
3055: PUSH
3056: CALL_OW 44
3060: ST_TO_ADDR
// end ;
3061: LD_VAR 0 1
3065: RET
// export function PrepareBeta ; var i , filter , un , soldiers ; begin
3066: LD_INT 0
3068: PPUSH
3069: PPUSH
3070: PPUSH
3071: PPUSH
3072: PPUSH
// uc_side := 1 ;
3073: LD_ADDR_OWVAR 20
3077: PUSH
3078: LD_INT 1
3080: ST_TO_ADDR
// uc_nation := nation_american ;
3081: LD_ADDR_OWVAR 21
3085: PUSH
3086: LD_INT 1
3088: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) do
3089: LD_ADDR_VAR 0 2
3093: PUSH
3094: LD_INT 22
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 30
3106: PUSH
3107: LD_INT 32
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PPUSH
3118: CALL_OW 69
3122: PUSH
3123: FOR_IN
3124: IFFALSE 3179
// PlaceWeaponTurret ( i , [ us_light_gun , us_light_gun , us_gatling_gun , us_double_gun , us_radar , us_light_gun , us_gatling_gun ] [ rand ( 1 , 7 ) ] ) ;
3126: LD_VAR 0 2
3130: PPUSH
3131: LD_INT 3
3133: PUSH
3134: LD_INT 3
3136: PUSH
3137: LD_INT 4
3139: PUSH
3140: LD_INT 5
3142: PUSH
3143: LD_INT 11
3145: PUSH
3146: LD_INT 3
3148: PUSH
3149: LD_INT 4
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: LIST
3160: PUSH
3161: LD_INT 1
3163: PPUSH
3164: LD_INT 7
3166: PPUSH
3167: CALL_OW 12
3171: ARRAY
3172: PPUSH
3173: CALL_OW 431
3177: GO 3123
3179: POP
3180: POP
// hc_name :=  ;
3181: LD_ADDR_OWVAR 26
3185: PUSH
3186: LD_STRING 
3188: ST_TO_ADDR
// hc_gallery :=  ;
3189: LD_ADDR_OWVAR 33
3193: PUSH
3194: LD_STRING 
3196: ST_TO_ADDR
// for i = 1 to [ 6 , 5 , 5 ] [ Difficulty ] do
3197: LD_ADDR_VAR 0 2
3201: PUSH
3202: DOUBLE
3203: LD_INT 1
3205: DEC
3206: ST_TO_ADDR
3207: LD_INT 6
3209: PUSH
3210: LD_INT 5
3212: PUSH
3213: LD_INT 5
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: LIST
3220: PUSH
3221: LD_OWVAR 67
3225: ARRAY
3226: PUSH
3227: FOR_TO
3228: IFFALSE 3286
// begin PrepareSoldier ( 1 , game_skill ) ;
3230: LD_INT 1
3232: PPUSH
3233: LD_EXP 39
3237: PPUSH
3238: CALL_OW 381
// un := CreateHuman ;
3242: LD_ADDR_VAR 0 4
3246: PUSH
3247: CALL_OW 44
3251: ST_TO_ADDR
// filter := filter ^ un ;
3252: LD_ADDR_VAR 0 3
3256: PUSH
3257: LD_VAR 0 3
3261: PUSH
3262: LD_VAR 0 4
3266: ADD
3267: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3268: LD_ADDR_VAR 0 5
3272: PUSH
3273: LD_VAR 0 5
3277: PUSH
3278: LD_VAR 0 4
3282: ADD
3283: ST_TO_ADDR
// end ;
3284: GO 3227
3286: POP
3287: POP
// for i = 1 to [ 3 , 2 , 2 ] [ Difficulty ] do
3288: LD_ADDR_VAR 0 2
3292: PUSH
3293: DOUBLE
3294: LD_INT 1
3296: DEC
3297: ST_TO_ADDR
3298: LD_INT 3
3300: PUSH
3301: LD_INT 2
3303: PUSH
3304: LD_INT 2
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: LIST
3311: PUSH
3312: LD_OWVAR 67
3316: ARRAY
3317: PUSH
3318: FOR_TO
3319: IFFALSE 3373
// begin PrepareEngineer ( 0 , game_skill ) ;
3321: LD_INT 0
3323: PPUSH
3324: LD_EXP 39
3328: PPUSH
3329: CALL_OW 382
// un := CreateHuman ;
3333: LD_ADDR_VAR 0 4
3337: PUSH
3338: CALL_OW 44
3342: ST_TO_ADDR
// filter := filter ^ un ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 3
3352: PUSH
3353: LD_VAR 0 4
3357: ADD
3358: ST_TO_ADDR
// PlaceHumanInUnit ( un , BetaB ) ;
3359: LD_VAR 0 4
3363: PPUSH
3364: LD_INT 3
3366: PPUSH
3367: CALL_OW 52
// end ;
3371: GO 3318
3373: POP
3374: POP
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3375: LD_ADDR_VAR 0 2
3379: PUSH
3380: DOUBLE
3381: LD_INT 1
3383: DEC
3384: ST_TO_ADDR
3385: LD_INT 4
3387: PUSH
3388: LD_INT 3
3390: PUSH
3391: LD_INT 3
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_OWVAR 67
3403: ARRAY
3404: PUSH
3405: FOR_TO
3406: IFFALSE 3460
// begin PrepareMechanic ( 0 , game_skill ) ;
3408: LD_INT 0
3410: PPUSH
3411: LD_EXP 39
3415: PPUSH
3416: CALL_OW 383
// un := CreateHuman ;
3420: LD_ADDR_VAR 0 4
3424: PUSH
3425: CALL_OW 44
3429: ST_TO_ADDR
// filter := filter ^ un ;
3430: LD_ADDR_VAR 0 3
3434: PUSH
3435: LD_VAR 0 3
3439: PUSH
3440: LD_VAR 0 4
3444: ADD
3445: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmFac ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_INT 8
3453: PPUSH
3454: CALL_OW 52
// end ;
3458: GO 3405
3460: POP
3461: POP
// for i = 1 to 2 do
3462: LD_ADDR_VAR 0 2
3466: PUSH
3467: DOUBLE
3468: LD_INT 1
3470: DEC
3471: ST_TO_ADDR
3472: LD_INT 2
3474: PUSH
3475: FOR_TO
3476: IFFALSE 3530
// begin PrepareScientist ( 0 , game_skill ) ;
3478: LD_INT 0
3480: PPUSH
3481: LD_EXP 39
3485: PPUSH
3486: CALL_OW 384
// un := CreateHuman ;
3490: LD_ADDR_VAR 0 4
3494: PUSH
3495: CALL_OW 44
3499: ST_TO_ADDR
// filter := filter ^ un ;
3500: LD_ADDR_VAR 0 3
3504: PUSH
3505: LD_VAR 0 3
3509: PUSH
3510: LD_VAR 0 4
3514: ADD
3515: ST_TO_ADDR
// PlaceHumanInUnit ( un , AmLab ) ;
3516: LD_VAR 0 4
3520: PPUSH
3521: LD_INT 14
3523: PPUSH
3524: CALL_OW 52
// end ;
3528: GO 3475
3530: POP
3531: POP
// for i = 1 to soldiers do
3532: LD_ADDR_VAR 0 2
3536: PUSH
3537: DOUBLE
3538: LD_INT 1
3540: DEC
3541: ST_TO_ADDR
3542: LD_VAR 0 5
3546: PUSH
3547: FOR_TO
3548: IFFALSE 3573
// PlaceUnitArea ( soldiers [ i ] , spawn_area , false ) ;
3550: LD_VAR 0 5
3554: PUSH
3555: LD_VAR 0 2
3559: ARRAY
3560: PPUSH
3561: LD_INT 1
3563: PPUSH
3564: LD_INT 0
3566: PPUSH
3567: CALL_OW 49
3571: GO 3547
3573: POP
3574: POP
// PlaceUnitXY ( Brighton , 51 , 43 , false ) ;
3575: LD_EXP 9
3579: PPUSH
3580: LD_INT 51
3582: PPUSH
3583: LD_INT 43
3585: PPUSH
3586: LD_INT 0
3588: PPUSH
3589: CALL_OW 48
// PlaceUnitXY ( Palmer , 55 , 58 , false ) ;
3593: LD_EXP 10
3597: PPUSH
3598: LD_INT 55
3600: PPUSH
3601: LD_INT 58
3603: PPUSH
3604: LD_INT 0
3606: PPUSH
3607: CALL_OW 48
// PlaceUnitXY ( Megan , 39 , 36 , false ) ;
3611: LD_EXP 11
3615: PPUSH
3616: LD_INT 39
3618: PPUSH
3619: LD_INT 36
3621: PPUSH
3622: LD_INT 0
3624: PPUSH
3625: CALL_OW 48
// BetaSquad := filter diff 0 ;
3629: LD_ADDR_EXP 12
3633: PUSH
3634: LD_VAR 0 3
3638: PUSH
3639: LD_INT 0
3641: DIFF
3642: ST_TO_ADDR
// end ;
3643: LD_VAR 0 1
3647: RET
// export Yashin , Popov , Gaydar , Sevi ; export RUArmada ; export function PrepareRUArmada ; var i , vehicle , soldiers , un , vehs ; begin
3648: LD_INT 0
3650: PPUSH
3651: PPUSH
3652: PPUSH
3653: PPUSH
3654: PPUSH
3655: PPUSH
// uc_side := 6 ;
3656: LD_ADDR_OWVAR 20
3660: PUSH
3661: LD_INT 6
3663: ST_TO_ADDR
// uc_nation := nation_russian ;
3664: LD_ADDR_OWVAR 21
3668: PUSH
3669: LD_INT 3
3671: ST_TO_ADDR
// soldiers := [ ] ;
3672: LD_ADDR_VAR 0 4
3676: PUSH
3677: EMPTY
3678: ST_TO_ADDR
// vehs := [ ] ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: EMPTY
3685: ST_TO_ADDR
// RUArmada := [ ] ;
3686: LD_ADDR_EXP 17
3690: PUSH
3691: EMPTY
3692: ST_TO_ADDR
// Yashin := NewCharacter ( Yashin ) ;
3693: LD_ADDR_EXP 13
3697: PUSH
3698: LD_STRING Yashin
3700: PPUSH
3701: CALL_OW 25
3705: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
3706: LD_ADDR_EXP 14
3710: PUSH
3711: LD_STRING Popov
3713: PPUSH
3714: CALL_OW 25
3718: ST_TO_ADDR
// Gaydar := NewCharacter ( Gaydar ) ;
3719: LD_ADDR_EXP 15
3723: PUSH
3724: LD_STRING Gaydar
3726: PPUSH
3727: CALL_OW 25
3731: ST_TO_ADDR
// Sevi := NewCharacter ( Vsevolod ) ;
3732: LD_ADDR_EXP 16
3736: PUSH
3737: LD_STRING Vsevolod
3739: PPUSH
3740: CALL_OW 25
3744: ST_TO_ADDR
// for i = 1 to 16 do
3745: LD_ADDR_VAR 0 2
3749: PUSH
3750: DOUBLE
3751: LD_INT 1
3753: DEC
3754: ST_TO_ADDR
3755: LD_INT 16
3757: PUSH
3758: FOR_TO
3759: IFFALSE 3801
// begin PrepareSoldier ( 0 , game_eskill ) ;
3761: LD_INT 0
3763: PPUSH
3764: LD_EXP 40
3768: PPUSH
3769: CALL_OW 381
// un := CreateHuman ;
3773: LD_ADDR_VAR 0 5
3777: PUSH
3778: CALL_OW 44
3782: ST_TO_ADDR
// soldiers := soldiers ^ un ;
3783: LD_ADDR_VAR 0 4
3787: PUSH
3788: LD_VAR 0 4
3792: PUSH
3793: LD_VAR 0 5
3797: ADD
3798: ST_TO_ADDR
// end ;
3799: GO 3758
3801: POP
3802: POP
// soldiers := Yashin ^ Popov ^ Gaydar ^ Sevi ^ soldiers ;
3803: LD_ADDR_VAR 0 4
3807: PUSH
3808: LD_EXP 13
3812: PUSH
3813: LD_EXP 14
3817: ADD
3818: PUSH
3819: LD_EXP 15
3823: ADD
3824: PUSH
3825: LD_EXP 16
3829: ADD
3830: PUSH
3831: LD_VAR 0 4
3835: ADD
3836: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_heavy_gun , 100 ) ;
3837: LD_INT 24
3839: PPUSH
3840: LD_INT 3
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: LD_INT 46
3848: PPUSH
3849: LD_INT 100
3851: PPUSH
3852: CALL 18457 0 5
// for i = 1 to 8 do
3856: LD_ADDR_VAR 0 2
3860: PUSH
3861: DOUBLE
3862: LD_INT 1
3864: DEC
3865: ST_TO_ADDR
3866: LD_INT 8
3868: PUSH
3869: FOR_TO
3870: IFFALSE 3953
// begin vehicle := CreateVehicle ;
3872: LD_ADDR_VAR 0 3
3876: PUSH
3877: CALL_OW 45
3881: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
3882: LD_VAR 0 4
3886: PUSH
3887: LD_INT 1
3889: ARRAY
3890: PPUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
3900: LD_ADDR_VAR 0 4
3904: PUSH
3905: LD_VAR 0 4
3909: PUSH
3910: LD_VAR 0 4
3914: PUSH
3915: LD_INT 1
3917: ARRAY
3918: DIFF
3919: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
3920: LD_VAR 0 3
3924: PPUSH
3925: LD_INT 5
3927: PPUSH
3928: LD_INT 0
3930: PPUSH
3931: CALL_OW 49
// vehs := vehs ^ vehicle ;
3935: LD_ADDR_VAR 0 6
3939: PUSH
3940: LD_VAR 0 6
3944: PUSH
3945: LD_VAR 0 3
3949: ADD
3950: ST_TO_ADDR
// end ;
3951: GO 3869
3953: POP
3954: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_gatling_gun , 100 ) ;
3955: LD_INT 24
3957: PPUSH
3958: LD_INT 3
3960: PPUSH
3961: LD_INT 1
3963: PPUSH
3964: LD_INT 43
3966: PPUSH
3967: LD_INT 100
3969: PPUSH
3970: CALL 18457 0 5
// for i = 1 to 8 do
3974: LD_ADDR_VAR 0 2
3978: PUSH
3979: DOUBLE
3980: LD_INT 1
3982: DEC
3983: ST_TO_ADDR
3984: LD_INT 8
3986: PUSH
3987: FOR_TO
3988: IFFALSE 4071
// begin vehicle := CreateVehicle ;
3990: LD_ADDR_VAR 0 3
3994: PUSH
3995: CALL_OW 45
3999: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4000: LD_VAR 0 4
4004: PUSH
4005: LD_INT 1
4007: ARRAY
4008: PPUSH
4009: LD_VAR 0 3
4013: PPUSH
4014: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4018: LD_ADDR_VAR 0 4
4022: PUSH
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 4
4032: PUSH
4033: LD_INT 1
4035: ARRAY
4036: DIFF
4037: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4038: LD_VAR 0 3
4042: PPUSH
4043: LD_INT 5
4045: PPUSH
4046: LD_INT 0
4048: PPUSH
4049: CALL_OW 49
// vehs := vehs ^ vehicle ;
4053: LD_ADDR_VAR 0 6
4057: PUSH
4058: LD_VAR 0 6
4062: PUSH
4063: LD_VAR 0 3
4067: ADD
4068: ST_TO_ADDR
// end ;
4069: GO 3987
4071: POP
4072: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_gun , 100 ) ;
4073: LD_INT 22
4075: PPUSH
4076: LD_INT 3
4078: PPUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 44
4084: PPUSH
4085: LD_INT 100
4087: PPUSH
4088: CALL 18457 0 5
// for i = 1 to 4 do
4092: LD_ADDR_VAR 0 2
4096: PUSH
4097: DOUBLE
4098: LD_INT 1
4100: DEC
4101: ST_TO_ADDR
4102: LD_INT 4
4104: PUSH
4105: FOR_TO
4106: IFFALSE 4189
// begin vehicle := CreateVehicle ;
4108: LD_ADDR_VAR 0 3
4112: PUSH
4113: CALL_OW 45
4117: ST_TO_ADDR
// PlaceHumanInUnit ( soldiers [ 1 ] , vehicle ) ;
4118: LD_VAR 0 4
4122: PUSH
4123: LD_INT 1
4125: ARRAY
4126: PPUSH
4127: LD_VAR 0 3
4131: PPUSH
4132: CALL_OW 52
// soldiers := soldiers diff soldiers [ 1 ] ;
4136: LD_ADDR_VAR 0 4
4140: PUSH
4141: LD_VAR 0 4
4145: PUSH
4146: LD_VAR 0 4
4150: PUSH
4151: LD_INT 1
4153: ARRAY
4154: DIFF
4155: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4156: LD_VAR 0 3
4160: PPUSH
4161: LD_INT 5
4163: PPUSH
4164: LD_INT 0
4166: PPUSH
4167: CALL_OW 49
// vehs := vehs ^ vehicle ;
4171: LD_ADDR_VAR 0 6
4175: PUSH
4176: LD_VAR 0 6
4180: PUSH
4181: LD_VAR 0 3
4185: ADD
4186: ST_TO_ADDR
// end ;
4187: GO 4105
4189: POP
4190: POP
// RUArmada := vehs ;
4191: LD_ADDR_EXP 17
4195: PUSH
4196: LD_VAR 0 6
4200: ST_TO_ADDR
// SetMark ( [ IsInUnit ( Yashin ) , IsInUnit ( Popov ) , IsInUnit ( Gaydar ) , IsInUnit ( Sevi ) ] , - 6 ) ;
4201: LD_EXP 13
4205: PPUSH
4206: CALL_OW 310
4210: PUSH
4211: LD_EXP 14
4215: PPUSH
4216: CALL_OW 310
4220: PUSH
4221: LD_EXP 15
4225: PPUSH
4226: CALL_OW 310
4230: PUSH
4231: LD_EXP 16
4235: PPUSH
4236: CALL_OW 310
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: LIST
4245: LIST
4246: PPUSH
4247: LD_INT 6
4249: NEG
4250: PPUSH
4251: CALL_OW 242
// end ;
4255: LD_VAR 0 1
4259: RET
// export Bulldozers ; export function PrepareRUBulldozers ; var i , vehicle ; begin
4260: LD_INT 0
4262: PPUSH
4263: PPUSH
4264: PPUSH
// uc_side := 6 ;
4265: LD_ADDR_OWVAR 20
4269: PUSH
4270: LD_INT 6
4272: ST_TO_ADDR
// uc_nation := nation_russian ;
4273: LD_ADDR_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: ST_TO_ADDR
// Bulldozers := [ ] ;
4281: LD_ADDR_EXP 18
4285: PUSH
4286: EMPTY
4287: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_bulldozer , 100 ) ;
4288: LD_INT 24
4290: PPUSH
4291: LD_INT 3
4293: PPUSH
4294: LD_INT 3
4296: PPUSH
4297: LD_INT 53
4299: PPUSH
4300: LD_INT 100
4302: PPUSH
4303: CALL 18457 0 5
// for i = 1 to 2 do
4307: LD_ADDR_VAR 0 2
4311: PUSH
4312: DOUBLE
4313: LD_INT 1
4315: DEC
4316: ST_TO_ADDR
4317: LD_INT 2
4319: PUSH
4320: FOR_TO
4321: IFFALSE 4366
// begin vehicle := CreateVehicle ;
4323: LD_ADDR_VAR 0 3
4327: PUSH
4328: CALL_OW 45
4332: ST_TO_ADDR
// PlaceUnitArea ( vehicle , RUArrivalArea , false ) ;
4333: LD_VAR 0 3
4337: PPUSH
4338: LD_INT 5
4340: PPUSH
4341: LD_INT 0
4343: PPUSH
4344: CALL_OW 49
// Bulldozers := Bulldozers ^ vehicle ;
4348: LD_ADDR_EXP 18
4352: PUSH
4353: LD_EXP 18
4357: PUSH
4358: LD_VAR 0 3
4362: ADD
4363: ST_TO_ADDR
// end ;
4364: GO 4320
4366: POP
4367: POP
// end ;
4368: LD_VAR 0 1
4372: RET
// export Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ; export function PrepareRUBase ; var i , filter , un ; begin
4373: LD_INT 0
4375: PPUSH
4376: PPUSH
4377: PPUSH
4378: PPUSH
// uc_side := 3 ;
4379: LD_ADDR_OWVAR 20
4383: PUSH
4384: LD_INT 3
4386: ST_TO_ADDR
// uc_nation := nation_russian ;
4387: LD_ADDR_OWVAR 21
4391: PUSH
4392: LD_INT 3
4394: ST_TO_ADDR
// hc_name :=  ;
4395: LD_ADDR_OWVAR 26
4399: PUSH
4400: LD_STRING 
4402: ST_TO_ADDR
// hc_gallery :=  ;
4403: LD_ADDR_OWVAR 33
4407: PUSH
4408: LD_STRING 
4410: ST_TO_ADDR
// Burlak := NewCharacter ( Burlak ) ;
4411: LD_ADDR_EXP 19
4415: PUSH
4416: LD_STRING Burlak
4418: PPUSH
4419: CALL_OW 25
4423: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
4424: LD_ADDR_EXP 20
4428: PUSH
4429: LD_STRING Gleb
4431: PPUSH
4432: CALL_OW 25
4436: ST_TO_ADDR
// Furmanov := NewCharacter ( Furmanov ) ;
4437: LD_ADDR_EXP 21
4441: PUSH
4442: LD_STRING Furmanov
4444: PPUSH
4445: CALL_OW 25
4449: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
4450: LD_ADDR_EXP 22
4454: PUSH
4455: LD_STRING Titov
4457: PPUSH
4458: CALL_OW 25
4462: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
4463: LD_ADDR_EXP 23
4467: PUSH
4468: LD_STRING Scholtze
4470: PPUSH
4471: CALL_OW 25
4475: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
4476: LD_ADDR_EXP 24
4480: PUSH
4481: LD_STRING Dolgov
4483: PPUSH
4484: CALL_OW 25
4488: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
4489: LD_ADDR_EXP 25
4493: PUSH
4494: LD_STRING Kapitsova
4496: PPUSH
4497: CALL_OW 25
4501: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
4502: LD_ADDR_EXP 26
4506: PUSH
4507: LD_STRING Karamazov
4509: PPUSH
4510: CALL_OW 25
4514: ST_TO_ADDR
// Kirlenkova := NewCharacter ( Kirlenkova ) ;
4515: LD_ADDR_EXP 27
4519: PUSH
4520: LD_STRING Kirlenkova
4522: PPUSH
4523: CALL_OW 25
4527: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
4528: LD_ADDR_EXP 28
4532: PUSH
4533: LD_STRING Kovalyuk
4535: PPUSH
4536: CALL_OW 25
4540: ST_TO_ADDR
// Kozlov := NewCharacter ( Kozlov ) ;
4541: LD_ADDR_EXP 29
4545: PUSH
4546: LD_STRING Kozlov
4548: PPUSH
4549: CALL_OW 25
4553: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
4554: LD_ADDR_EXP 30
4558: PUSH
4559: LD_STRING Kuzmov
4561: PPUSH
4562: CALL_OW 25
4566: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
4567: LD_ADDR_EXP 31
4571: PUSH
4572: LD_STRING Lipshchin
4574: PPUSH
4575: CALL_OW 25
4579: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
4580: LD_ADDR_EXP 32
4584: PUSH
4585: LD_STRING Oblukov
4587: PPUSH
4588: CALL_OW 25
4592: ST_TO_ADDR
// Xavier2 := NewCharacter ( Xavier2 ) ;
4593: LD_ADDR_EXP 33
4597: PUSH
4598: LD_STRING Xavier2
4600: PPUSH
4601: CALL_OW 25
4605: ST_TO_ADDR
// Gnyevko := NewCharacter ( Gnyevko ) ;
4606: LD_ADDR_EXP 34
4610: PUSH
4611: LD_STRING Gnyevko
4613: PPUSH
4614: CALL_OW 25
4618: ST_TO_ADDR
// Belkov := NewCharacter ( Belkov ) ;
4619: LD_ADDR_EXP 35
4623: PUSH
4624: LD_STRING Belkov
4626: PPUSH
4627: CALL_OW 25
4631: ST_TO_ADDR
// filter := [ Burlak , Gleb , Furmanov , Titov , Scholtze , Dolgov , Kapitsova , Karamazov , Kirlenkova , Kovalyuk , Kozlov , Kuzmov , Lipshchin , Oblukov , Xavier2 , Gnyevko , Belkov ] ;
4632: LD_ADDR_VAR 0 3
4636: PUSH
4637: LD_EXP 19
4641: PUSH
4642: LD_EXP 20
4646: PUSH
4647: LD_EXP 21
4651: PUSH
4652: LD_EXP 22
4656: PUSH
4657: LD_EXP 23
4661: PUSH
4662: LD_EXP 24
4666: PUSH
4667: LD_EXP 25
4671: PUSH
4672: LD_EXP 26
4676: PUSH
4677: LD_EXP 27
4681: PUSH
4682: LD_EXP 28
4686: PUSH
4687: LD_EXP 29
4691: PUSH
4692: LD_EXP 30
4696: PUSH
4697: LD_EXP 31
4701: PUSH
4702: LD_EXP 32
4706: PUSH
4707: LD_EXP 33
4711: PUSH
4712: LD_EXP 34
4716: PUSH
4717: LD_EXP 35
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: LIST
4733: LIST
4734: LIST
4735: LIST
4736: LIST
4737: LIST
4738: LIST
4739: LIST
4740: ST_TO_ADDR
// for i = 1 to filter do
4741: LD_ADDR_VAR 0 2
4745: PUSH
4746: DOUBLE
4747: LD_INT 1
4749: DEC
4750: ST_TO_ADDR
4751: LD_VAR 0 3
4755: PUSH
4756: FOR_TO
4757: IFFALSE 4782
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
4759: LD_VAR 0 3
4763: PUSH
4764: LD_VAR 0 2
4768: ARRAY
4769: PPUSH
4770: LD_INT 6
4772: PPUSH
4773: LD_INT 0
4775: PPUSH
4776: CALL_OW 49
4780: GO 4756
4782: POP
4783: POP
// end ;
4784: LD_VAR 0 1
4788: RET
// export RU_SecondPersonnel ; export function PrepareRUBase_v2 ; var i , filter , un ; begin
4789: LD_INT 0
4791: PPUSH
4792: PPUSH
4793: PPUSH
4794: PPUSH
// uc_side := 3 ;
4795: LD_ADDR_OWVAR 20
4799: PUSH
4800: LD_INT 3
4802: ST_TO_ADDR
// uc_nation := nation_russian ;
4803: LD_ADDR_OWVAR 21
4807: PUSH
4808: LD_INT 3
4810: ST_TO_ADDR
// hc_name :=  ;
4811: LD_ADDR_OWVAR 26
4815: PUSH
4816: LD_STRING 
4818: ST_TO_ADDR
// hc_gallery :=  ;
4819: LD_ADDR_OWVAR 33
4823: PUSH
4824: LD_STRING 
4826: ST_TO_ADDR
// for i = 1 to 8 do
4827: LD_ADDR_VAR 0 2
4831: PUSH
4832: DOUBLE
4833: LD_INT 1
4835: DEC
4836: ST_TO_ADDR
4837: LD_INT 8
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4883
// begin PrepareSoldier ( 0 , game_eskill ) ;
4843: LD_INT 0
4845: PPUSH
4846: LD_EXP 40
4850: PPUSH
4851: CALL_OW 381
// un := CreateHuman ;
4855: LD_ADDR_VAR 0 4
4859: PUSH
4860: CALL_OW 44
4864: ST_TO_ADDR
// filter := filter ^ un ;
4865: LD_ADDR_VAR 0 3
4869: PUSH
4870: LD_VAR 0 3
4874: PUSH
4875: LD_VAR 0 4
4879: ADD
4880: ST_TO_ADDR
// end ;
4881: GO 4840
4883: POP
4884: POP
// for i = 1 to 4 do
4885: LD_ADDR_VAR 0 2
4889: PUSH
4890: DOUBLE
4891: LD_INT 1
4893: DEC
4894: ST_TO_ADDR
4895: LD_INT 4
4897: PUSH
4898: FOR_TO
4899: IFFALSE 4941
// begin PrepareEngineer ( 0 , game_eskill ) ;
4901: LD_INT 0
4903: PPUSH
4904: LD_EXP 40
4908: PPUSH
4909: CALL_OW 382
// un := CreateHuman ;
4913: LD_ADDR_VAR 0 4
4917: PUSH
4918: CALL_OW 44
4922: ST_TO_ADDR
// filter := filter ^ un ;
4923: LD_ADDR_VAR 0 3
4927: PUSH
4928: LD_VAR 0 3
4932: PUSH
4933: LD_VAR 0 4
4937: ADD
4938: ST_TO_ADDR
// end ;
4939: GO 4898
4941: POP
4942: POP
// for i = 1 to 6 do
4943: LD_ADDR_VAR 0 2
4947: PUSH
4948: DOUBLE
4949: LD_INT 1
4951: DEC
4952: ST_TO_ADDR
4953: LD_INT 6
4955: PUSH
4956: FOR_TO
4957: IFFALSE 4999
// begin PrepareMechanic ( 0 , game_eskill ) ;
4959: LD_INT 0
4961: PPUSH
4962: LD_EXP 40
4966: PPUSH
4967: CALL_OW 383
// un := CreateHuman ;
4971: LD_ADDR_VAR 0 4
4975: PUSH
4976: CALL_OW 44
4980: ST_TO_ADDR
// filter := filter ^ un ;
4981: LD_ADDR_VAR 0 3
4985: PUSH
4986: LD_VAR 0 3
4990: PUSH
4991: LD_VAR 0 4
4995: ADD
4996: ST_TO_ADDR
// end ;
4997: GO 4956
4999: POP
5000: POP
// for i = 1 to 4 do
5001: LD_ADDR_VAR 0 2
5005: PUSH
5006: DOUBLE
5007: LD_INT 1
5009: DEC
5010: ST_TO_ADDR
5011: LD_INT 4
5013: PUSH
5014: FOR_TO
5015: IFFALSE 5057
// begin PrepareScientist ( 0 , game_eskill ) ;
5017: LD_INT 0
5019: PPUSH
5020: LD_EXP 40
5024: PPUSH
5025: CALL_OW 384
// un := CreateHuman ;
5029: LD_ADDR_VAR 0 4
5033: PUSH
5034: CALL_OW 44
5038: ST_TO_ADDR
// filter := filter ^ un ;
5039: LD_ADDR_VAR 0 3
5043: PUSH
5044: LD_VAR 0 3
5048: PUSH
5049: LD_VAR 0 4
5053: ADD
5054: ST_TO_ADDR
// end ;
5055: GO 5014
5057: POP
5058: POP
// for i = 1 to filter do
5059: LD_ADDR_VAR 0 2
5063: PUSH
5064: DOUBLE
5065: LD_INT 1
5067: DEC
5068: ST_TO_ADDR
5069: LD_VAR 0 3
5073: PUSH
5074: FOR_TO
5075: IFFALSE 5100
// PlaceUnitArea ( filter [ i ] , RUArrivalArea2 , false ) ;
5077: LD_VAR 0 3
5081: PUSH
5082: LD_VAR 0 2
5086: ARRAY
5087: PPUSH
5088: LD_INT 6
5090: PPUSH
5091: LD_INT 0
5093: PPUSH
5094: CALL_OW 49
5098: GO 5074
5100: POP
5101: POP
// RU_SecondPersonnel := filter ;
5102: LD_ADDR_EXP 36
5106: PUSH
5107: LD_VAR 0 3
5111: ST_TO_ADDR
// end ;
5112: LD_VAR 0 1
5116: RET
// export JMM ; export function JMMReinforcement ; var i , soldiers , un , vehs , vehicle , mechs ; begin
5117: LD_INT 0
5119: PPUSH
5120: PPUSH
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
5125: PPUSH
// uc_side := 1 ;
5126: LD_ADDR_OWVAR 20
5130: PUSH
5131: LD_INT 1
5133: ST_TO_ADDR
// uc_nation := nation_american ;
5134: LD_ADDR_OWVAR 21
5138: PUSH
5139: LD_INT 1
5141: ST_TO_ADDR
// JMM := NewCharacter ( JMM ) ;
5142: LD_ADDR_EXP 37
5146: PUSH
5147: LD_STRING JMM
5149: PPUSH
5150: CALL_OW 25
5154: ST_TO_ADDR
// SetDir ( JMM , 1 ) ;
5155: LD_EXP 37
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: CALL_OW 233
// PlaceUnitArea ( JMM , JMMArrivalArea , false ) ;
5167: LD_EXP 37
5171: PPUSH
5172: LD_INT 7
5174: PPUSH
5175: LD_INT 0
5177: PPUSH
5178: CALL_OW 49
// mechs := [ ] ;
5182: LD_ADDR_VAR 0 7
5186: PUSH
5187: EMPTY
5188: ST_TO_ADDR
// for i = 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
5189: LD_ADDR_VAR 0 2
5193: PUSH
5194: DOUBLE
5195: LD_INT 1
5197: DEC
5198: ST_TO_ADDR
5199: LD_INT 4
5201: PUSH
5202: LD_INT 3
5204: PUSH
5205: LD_INT 3
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PUSH
5213: LD_OWVAR 67
5217: ARRAY
5218: PUSH
5219: FOR_TO
5220: IFFALSE 5281
// begin PrepareSoldier ( 0 , game_skill + 1 ) ;
5222: LD_INT 0
5224: PPUSH
5225: LD_EXP 39
5229: PUSH
5230: LD_INT 1
5232: PLUS
5233: PPUSH
5234: CALL_OW 381
// un := CreateHuman ;
5238: LD_ADDR_VAR 0 4
5242: PUSH
5243: CALL_OW 44
5247: ST_TO_ADDR
// soldiers := soldiers ^ un ;
5248: LD_ADDR_VAR 0 3
5252: PUSH
5253: LD_VAR 0 3
5257: PUSH
5258: LD_VAR 0 4
5262: ADD
5263: ST_TO_ADDR
// PlaceUnitArea ( un , JMMArrivalArea , false ) ;
5264: LD_VAR 0 4
5268: PPUSH
5269: LD_INT 7
5271: PPUSH
5272: LD_INT 0
5274: PPUSH
5275: CALL_OW 49
// end ;
5279: GO 5219
5281: POP
5282: POP
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5283: LD_ADDR_VAR 0 2
5287: PUSH
5288: DOUBLE
5289: LD_INT 1
5291: DEC
5292: ST_TO_ADDR
5293: LD_INT 7
5295: PUSH
5296: LD_INT 6
5298: PUSH
5299: LD_INT 4
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: LIST
5306: PUSH
5307: LD_OWVAR 67
5311: ARRAY
5312: PUSH
5313: FOR_TO
5314: IFFALSE 5360
// begin PrepareMechanic ( 0 , game_skill + 1 ) ;
5316: LD_INT 0
5318: PPUSH
5319: LD_EXP 39
5323: PUSH
5324: LD_INT 1
5326: PLUS
5327: PPUSH
5328: CALL_OW 383
// un := CreateHuman ;
5332: LD_ADDR_VAR 0 4
5336: PUSH
5337: CALL_OW 44
5341: ST_TO_ADDR
// mechs := mechs ^ un ;
5342: LD_ADDR_VAR 0 7
5346: PUSH
5347: LD_VAR 0 7
5351: PUSH
5352: LD_VAR 0 4
5356: ADD
5357: ST_TO_ADDR
// end ;
5358: GO 5313
5360: POP
5361: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
5362: LD_INT 3
5364: PPUSH
5365: LD_INT 3
5367: PPUSH
5368: LD_INT 1
5370: PPUSH
5371: LD_INT 5
5373: PPUSH
5374: LD_INT 100
5376: PPUSH
5377: CALL 18457 0 5
// for i = 1 to [ 7 , 6 , 4 ] [ Difficulty ] do
5381: LD_ADDR_VAR 0 2
5385: PUSH
5386: DOUBLE
5387: LD_INT 1
5389: DEC
5390: ST_TO_ADDR
5391: LD_INT 7
5393: PUSH
5394: LD_INT 6
5396: PUSH
5397: LD_INT 4
5399: PUSH
5400: EMPTY
5401: LIST
5402: LIST
5403: LIST
5404: PUSH
5405: LD_OWVAR 67
5409: ARRAY
5410: PUSH
5411: FOR_TO
5412: IFFALSE 5507
// begin vehicle := CreateVehicle ;
5414: LD_ADDR_VAR 0 6
5418: PUSH
5419: CALL_OW 45
5423: ST_TO_ADDR
// PlaceHumanInUnit ( mechs [ 1 ] , vehicle ) ;
5424: LD_VAR 0 7
5428: PUSH
5429: LD_INT 1
5431: ARRAY
5432: PPUSH
5433: LD_VAR 0 6
5437: PPUSH
5438: CALL_OW 52
// mechs := mechs diff mechs [ 1 ] ;
5442: LD_ADDR_VAR 0 7
5446: PUSH
5447: LD_VAR 0 7
5451: PUSH
5452: LD_VAR 0 7
5456: PUSH
5457: LD_INT 1
5459: ARRAY
5460: DIFF
5461: ST_TO_ADDR
// SetDir ( vehicle , 1 ) ;
5462: LD_VAR 0 6
5466: PPUSH
5467: LD_INT 1
5469: PPUSH
5470: CALL_OW 233
// PlaceUnitArea ( vehicle , JMMArrivalArea , false ) ;
5474: LD_VAR 0 6
5478: PPUSH
5479: LD_INT 7
5481: PPUSH
5482: LD_INT 0
5484: PPUSH
5485: CALL_OW 49
// vehs := vehs ^ vehicle ;
5489: LD_ADDR_VAR 0 5
5493: PUSH
5494: LD_VAR 0 5
5498: PUSH
5499: LD_VAR 0 6
5503: ADD
5504: ST_TO_ADDR
// end ;
5505: GO 5411
5507: POP
5508: POP
// end ; end_of_file
5509: LD_VAR 0 1
5513: RET
// export game_diff ; export game_skill , game_eskill ; export jmmArrival , ruArrival ; export startCrates ; export function GameType ; var i , ruStartTechs ; begin
5514: LD_INT 0
5516: PPUSH
5517: PPUSH
5518: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
5519: LD_ADDR_OWVAR 67
5523: PUSH
5524: LD_INT 0
5526: PPUSH
5527: CALL_OW 426
5531: ST_TO_ADDR
// game_diff := Difficulty ;
5532: LD_ADDR_EXP 38
5536: PUSH
5537: LD_OWVAR 67
5541: ST_TO_ADDR
// game_skill := [ 7 , 6 , 6 ] [ game_diff ] ;
5542: LD_ADDR_EXP 39
5546: PUSH
5547: LD_INT 7
5549: PUSH
5550: LD_INT 6
5552: PUSH
5553: LD_INT 6
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: LIST
5560: PUSH
5561: LD_EXP 38
5565: ARRAY
5566: ST_TO_ADDR
// game_eskill := [ 6 , 7 , 8 ] [ game_diff ] ;
5567: LD_ADDR_EXP 40
5571: PUSH
5572: LD_INT 6
5574: PUSH
5575: LD_INT 7
5577: PUSH
5578: LD_INT 8
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_EXP 38
5590: ARRAY
5591: ST_TO_ADDR
// ruArrival := [ 5 5$00 , 3 3$00 , 2 2$00 ] [ game_diff ] ;
5592: LD_ADDR_EXP 42
5596: PUSH
5597: LD_INT 10500
5599: PUSH
5600: LD_INT 6300
5602: PUSH
5603: LD_INT 4200
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PUSH
5611: LD_EXP 38
5615: ARRAY
5616: ST_TO_ADDR
// jmmArrival := [ 35 35$00 , 45 45$00 , 55 55$00 ] [ game_diff ] ;
5617: LD_ADDR_EXP 41
5621: PUSH
5622: LD_INT 73500
5624: PUSH
5625: LD_INT 94500
5627: PUSH
5628: LD_INT 115500
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: LIST
5635: PUSH
5636: LD_EXP 38
5640: ARRAY
5641: ST_TO_ADDR
// ruStartTechs = [ [ tech_Weap1 ] , [ tech_Weap1 , tech_Comp1 ] , [ tech_Weap1 , tech_Weap2 , tech_Comp1 ] ] ;
5642: LD_ADDR_VAR 0 3
5646: PUSH
5647: LD_INT 51
5649: PUSH
5650: EMPTY
5651: LIST
5652: PUSH
5653: LD_INT 51
5655: PUSH
5656: LD_INT 57
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: PUSH
5663: LD_INT 51
5665: PUSH
5666: LD_INT 52
5668: PUSH
5669: LD_INT 57
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: ST_TO_ADDR
// startCrates = [ [ 300 , 350 ] , [ 230 , 200 ] , [ 150 , 100 ] ] [ game_diff ] ;
5682: LD_ADDR_EXP 43
5686: PUSH
5687: LD_INT 300
5689: PUSH
5690: LD_INT 350
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: PUSH
5697: LD_INT 230
5699: PUSH
5700: LD_INT 200
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 150
5709: PUSH
5710: LD_INT 100
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: LIST
5721: PUSH
5722: LD_EXP 38
5726: ARRAY
5727: ST_TO_ADDR
// for i := 1 to ruStartTechs [ game_diff ] do
5728: LD_ADDR_VAR 0 2
5732: PUSH
5733: DOUBLE
5734: LD_INT 1
5736: DEC
5737: ST_TO_ADDR
5738: LD_VAR 0 3
5742: PUSH
5743: LD_EXP 38
5747: ARRAY
5748: PUSH
5749: FOR_TO
5750: IFFALSE 5808
// begin SetTech ( ruStartTechs [ game_diff ] [ i ] , 3 , state_researched ) ;
5752: LD_VAR 0 3
5756: PUSH
5757: LD_EXP 38
5761: ARRAY
5762: PUSH
5763: LD_VAR 0 2
5767: ARRAY
5768: PPUSH
5769: LD_INT 3
5771: PPUSH
5772: LD_INT 2
5774: PPUSH
5775: CALL_OW 322
// SetTech ( ruStartTechs [ game_diff ] [ i ] , 6 , state_researched ) ;
5779: LD_VAR 0 3
5783: PUSH
5784: LD_EXP 38
5788: ARRAY
5789: PUSH
5790: LD_VAR 0 2
5794: ARRAY
5795: PPUSH
5796: LD_INT 6
5798: PPUSH
5799: LD_INT 2
5801: PPUSH
5802: CALL_OW 322
// end ;
5806: GO 5749
5808: POP
5809: POP
// end ; end_of_file
5810: LD_VAR 0 1
5814: RET
// export function CustomEvent ( event ) ; begin
5815: LD_INT 0
5817: PPUSH
// end ;
5818: LD_VAR 0 2
5822: RET
// export function CustomInitMacro ( ) ; begin
5823: LD_INT 0
5825: PPUSH
// MC_SetScanArea ( 1 , RU_Base_Area ) ;
5826: LD_INT 1
5828: PPUSH
5829: LD_INT 3
5831: PPUSH
5832: CALL 75371 0 2
// MC_SetParkingArea ( 1 , RU_Base_Parking ) ;
5836: LD_INT 1
5838: PPUSH
5839: LD_INT 4
5841: PPUSH
5842: CALL 75315 0 2
// MC_SetDepositsXY ( 1 , [ [ 136 , 130 , 0 ] , [ 145 , 123 , 0 ] , ] ) ;
5846: LD_INT 1
5848: PPUSH
5849: LD_INT 136
5851: PUSH
5852: LD_INT 130
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_INT 145
5865: PUSH
5866: LD_INT 123
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: LIST
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: PPUSH
5881: CALL 74374 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
5885: LD_INT 1
5887: PPUSH
5888: LD_INT 43
5890: PUSH
5891: LD_INT 46
5893: PUSH
5894: LD_INT 45
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: PPUSH
5902: CALL 75203 0 2
// MC_SetCratesArea ( 1 , RU_Base_Area ) ;
5906: LD_INT 1
5908: PPUSH
5909: LD_INT 3
5911: PPUSH
5912: CALL 74885 0 2
// MC_SetTame ( 1 , RU_Base_Area ) ;
5916: LD_INT 1
5918: PPUSH
5919: LD_INT 3
5921: PPUSH
5922: CALL 74616 0 2
// MC_SetDefenderLimit ( 1 , 8 ) ;
5926: LD_INT 1
5928: PPUSH
5929: LD_INT 8
5931: PPUSH
5932: CALL 74235 0 2
// MC_SetProduceList ( 1 , [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] ] ) ;
5936: LD_INT 1
5938: PPUSH
5939: LD_INT 22
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 3
5947: PUSH
5948: LD_INT 43
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 22
5959: PUSH
5960: LD_INT 1
5962: PUSH
5963: LD_INT 3
5965: PUSH
5966: LD_INT 44
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 22
5977: PUSH
5978: LD_INT 1
5980: PUSH
5981: LD_INT 3
5983: PUSH
5984: LD_INT 45
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: PUSH
5993: LD_INT 24
5995: PUSH
5996: LD_INT 1
5998: PUSH
5999: LD_INT 3
6001: PUSH
6002: LD_INT 43
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: LIST
6009: LIST
6010: PUSH
6011: LD_INT 24
6013: PUSH
6014: LD_INT 1
6016: PUSH
6017: LD_INT 3
6019: PUSH
6020: LD_INT 43
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_INT 24
6031: PUSH
6032: LD_INT 1
6034: PUSH
6035: LD_INT 3
6037: PUSH
6038: LD_INT 46
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 22
6049: PUSH
6050: LD_INT 1
6052: PUSH
6053: LD_INT 3
6055: PUSH
6056: LD_INT 43
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: PUSH
6065: LD_INT 22
6067: PUSH
6068: LD_INT 1
6070: PUSH
6071: LD_INT 3
6073: PUSH
6074: LD_INT 44
6076: PUSH
6077: EMPTY
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: LIST
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL 74050 0 2
// MC_SetBuildingList ( 1 , [ [ b_depot , 127 , 125 , 5 ] , [ b_lab , 124 , 132 , 0 ] , [ b_oil_mine , 136 , 130 , 1 ] , [ b_armoury , 118 , 114 , 2 ] , [ b_oil_mine , 145 , 123 , 1 ] , [ b_oil_power , 150 , 135 , 1 ] , [ b_oil_power , 140 , 134 , 2 ] , [ b_oil_power , 137 , 121 , 5 ] , [ b_workshop , 155 , 130 , 0 ] , [ b_bunker , 155 , 130 , 0 ] , [ b_bunker , 130 , 114 , 3 ] , [ b_bunker , 142 , 115 , 3 ] , [ b_bunker , 153 , 120 , 3 ] , ] ) ;
6097: LD_INT 1
6099: PPUSH
6100: LD_INT 0
6102: PUSH
6103: LD_INT 127
6105: PUSH
6106: LD_INT 125
6108: PUSH
6109: LD_INT 5
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 6
6120: PUSH
6121: LD_INT 124
6123: PUSH
6124: LD_INT 132
6126: PUSH
6127: LD_INT 0
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_INT 29
6138: PUSH
6139: LD_INT 136
6141: PUSH
6142: LD_INT 130
6144: PUSH
6145: LD_INT 1
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 4
6156: PUSH
6157: LD_INT 118
6159: PUSH
6160: LD_INT 114
6162: PUSH
6163: LD_INT 2
6165: PUSH
6166: EMPTY
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PUSH
6172: LD_INT 29
6174: PUSH
6175: LD_INT 145
6177: PUSH
6178: LD_INT 123
6180: PUSH
6181: LD_INT 1
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: PUSH
6190: LD_INT 26
6192: PUSH
6193: LD_INT 150
6195: PUSH
6196: LD_INT 135
6198: PUSH
6199: LD_INT 1
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 26
6210: PUSH
6211: LD_INT 140
6213: PUSH
6214: LD_INT 134
6216: PUSH
6217: LD_INT 2
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 26
6228: PUSH
6229: LD_INT 137
6231: PUSH
6232: LD_INT 121
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 2
6246: PUSH
6247: LD_INT 155
6249: PUSH
6250: LD_INT 130
6252: PUSH
6253: LD_INT 0
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 32
6264: PUSH
6265: LD_INT 155
6267: PUSH
6268: LD_INT 130
6270: PUSH
6271: LD_INT 0
6273: PUSH
6274: EMPTY
6275: LIST
6276: LIST
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 32
6282: PUSH
6283: LD_INT 130
6285: PUSH
6286: LD_INT 114
6288: PUSH
6289: LD_INT 3
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 32
6300: PUSH
6301: LD_INT 142
6303: PUSH
6304: LD_INT 115
6306: PUSH
6307: LD_INT 3
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PUSH
6316: LD_INT 32
6318: PUSH
6319: LD_INT 153
6321: PUSH
6322: LD_INT 120
6324: PUSH
6325: LD_INT 3
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: PUSH
6334: EMPTY
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: LIST
6345: LIST
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL 73942 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_computer ] ) ;
6353: LD_INT 1
6355: PPUSH
6356: LD_INT 10
6358: PUSH
6359: LD_INT 12
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PPUSH
6366: CALL 74792 0 2
// MC_SetFactoryExtension ( 1 , 155 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6370: LD_INT 1
6372: PPUSH
6373: LD_INT 155
6375: PPUSH
6376: LD_INT 130
6378: PPUSH
6379: LD_INT 0
6381: PPUSH
6382: LD_INT 24
6384: PUSH
6385: LD_INT 16
6387: PUSH
6388: LD_INT 17
6390: PUSH
6391: LD_INT 18
6393: PUSH
6394: LD_INT 21
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: PPUSH
6404: CALL 74997 0 5
// MC_SetScanArea ( 2 , RU_Base_Area ) ;
6408: LD_INT 2
6410: PPUSH
6411: LD_INT 3
6413: PPUSH
6414: CALL 75371 0 2
// MC_SetParkingArea ( 2 , RU_Base_Parking ) ;
6418: LD_INT 2
6420: PPUSH
6421: LD_INT 4
6423: PPUSH
6424: CALL 75315 0 2
// MC_SetDepositsXY ( 2 , [ [ 84 , 125 , 1 ] , ] ) ;
6428: LD_INT 2
6430: PPUSH
6431: LD_INT 84
6433: PUSH
6434: LD_INT 125
6436: PUSH
6437: LD_INT 1
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: PUSH
6445: EMPTY
6446: LIST
6447: PPUSH
6448: CALL 74374 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_heavy_gun , ru_rocket_launcher ] ) ;
6452: LD_INT 2
6454: PPUSH
6455: LD_INT 43
6457: PUSH
6458: LD_INT 46
6460: PUSH
6461: LD_INT 45
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: PPUSH
6469: CALL 75203 0 2
// MC_SetCratesArea ( 2 , RU_Base_Area ) ;
6473: LD_INT 2
6475: PPUSH
6476: LD_INT 3
6478: PPUSH
6479: CALL 74885 0 2
// MC_SetTame ( 2 , RU_Base_Area ) ;
6483: LD_INT 2
6485: PPUSH
6486: LD_INT 3
6488: PPUSH
6489: CALL 74616 0 2
// MC_SetDefenderLimit ( 2 , 8 ) ;
6493: LD_INT 2
6495: PPUSH
6496: LD_INT 8
6498: PPUSH
6499: CALL 74235 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gun ] ] ) ;
6503: LD_INT 2
6505: PPUSH
6506: LD_INT 22
6508: PUSH
6509: LD_INT 3
6511: PUSH
6512: LD_INT 3
6514: PUSH
6515: LD_INT 43
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 22
6526: PUSH
6527: LD_INT 3
6529: PUSH
6530: LD_INT 3
6532: PUSH
6533: LD_INT 44
6535: PUSH
6536: EMPTY
6537: LIST
6538: LIST
6539: LIST
6540: LIST
6541: PUSH
6542: LD_INT 22
6544: PUSH
6545: LD_INT 3
6547: PUSH
6548: LD_INT 3
6550: PUSH
6551: LD_INT 45
6553: PUSH
6554: EMPTY
6555: LIST
6556: LIST
6557: LIST
6558: LIST
6559: PUSH
6560: LD_INT 24
6562: PUSH
6563: LD_INT 3
6565: PUSH
6566: LD_INT 3
6568: PUSH
6569: LD_INT 43
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: LIST
6576: LIST
6577: PUSH
6578: LD_INT 24
6580: PUSH
6581: LD_INT 3
6583: PUSH
6584: LD_INT 3
6586: PUSH
6587: LD_INT 43
6589: PUSH
6590: EMPTY
6591: LIST
6592: LIST
6593: LIST
6594: LIST
6595: PUSH
6596: LD_INT 24
6598: PUSH
6599: LD_INT 3
6601: PUSH
6602: LD_INT 3
6604: PUSH
6605: LD_INT 46
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: LIST
6612: LIST
6613: PUSH
6614: LD_INT 22
6616: PUSH
6617: LD_INT 3
6619: PUSH
6620: LD_INT 3
6622: PUSH
6623: LD_INT 43
6625: PUSH
6626: EMPTY
6627: LIST
6628: LIST
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 22
6634: PUSH
6635: LD_INT 3
6637: PUSH
6638: LD_INT 3
6640: PUSH
6641: LD_INT 44
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: LIST
6648: LIST
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: LIST
6654: LIST
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: PPUSH
6660: CALL 74050 0 2
// MC_SetBuildingList ( 2 , [ [ b_depot , 96 , 125 , 0 ] , [ b_lab , 74 , 122 , 1 ] , [ b_siberite_mine , 84 , 125 , 1 ] , [ b_siberite_power , 86 , 128 , 1 ] , [ b_siberite_power , 85 , 130 , 2 ] , [ b_siberite_power , 88 , 132 , 5 ] , [ b_workshop , 106 , 130 , 0 ] , [ b_armoury , 99 , 114 , 3 ] , [ b_bunker , 72 , 112 , 2 ] , [ b_bunker , 78 , 110 , 3 ] , [ b_bunker , 84 , 110 , 2 ] , [ b_bunker , 105 , 117 , 3 ] , ] ) ;
6664: LD_INT 2
6666: PPUSH
6667: LD_INT 0
6669: PUSH
6670: LD_INT 96
6672: PUSH
6673: LD_INT 125
6675: PUSH
6676: LD_INT 0
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: PUSH
6685: LD_INT 6
6687: PUSH
6688: LD_INT 74
6690: PUSH
6691: LD_INT 122
6693: PUSH
6694: LD_INT 1
6696: PUSH
6697: EMPTY
6698: LIST
6699: LIST
6700: LIST
6701: LIST
6702: PUSH
6703: LD_INT 30
6705: PUSH
6706: LD_INT 84
6708: PUSH
6709: LD_INT 125
6711: PUSH
6712: LD_INT 1
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: LIST
6719: LIST
6720: PUSH
6721: LD_INT 28
6723: PUSH
6724: LD_INT 86
6726: PUSH
6727: LD_INT 128
6729: PUSH
6730: LD_INT 1
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: PUSH
6739: LD_INT 28
6741: PUSH
6742: LD_INT 85
6744: PUSH
6745: LD_INT 130
6747: PUSH
6748: LD_INT 2
6750: PUSH
6751: EMPTY
6752: LIST
6753: LIST
6754: LIST
6755: LIST
6756: PUSH
6757: LD_INT 28
6759: PUSH
6760: LD_INT 88
6762: PUSH
6763: LD_INT 132
6765: PUSH
6766: LD_INT 5
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: LIST
6773: LIST
6774: PUSH
6775: LD_INT 2
6777: PUSH
6778: LD_INT 106
6780: PUSH
6781: LD_INT 130
6783: PUSH
6784: LD_INT 0
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: LIST
6791: LIST
6792: PUSH
6793: LD_INT 4
6795: PUSH
6796: LD_INT 99
6798: PUSH
6799: LD_INT 114
6801: PUSH
6802: LD_INT 3
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_INT 32
6813: PUSH
6814: LD_INT 72
6816: PUSH
6817: LD_INT 112
6819: PUSH
6820: LD_INT 2
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 32
6831: PUSH
6832: LD_INT 78
6834: PUSH
6835: LD_INT 110
6837: PUSH
6838: LD_INT 3
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: LIST
6845: LIST
6846: PUSH
6847: LD_INT 32
6849: PUSH
6850: LD_INT 84
6852: PUSH
6853: LD_INT 110
6855: PUSH
6856: LD_INT 2
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 32
6867: PUSH
6868: LD_INT 105
6870: PUSH
6871: LD_INT 117
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: LIST
6887: LIST
6888: LIST
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: LIST
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL 73942 0 2
// MC_SetLabKind ( 2 , [ b_lab_spacetime , b_lab_siberium ] ) ;
6901: LD_INT 2
6903: PPUSH
6904: LD_INT 14
6906: PUSH
6907: LD_INT 11
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: CALL 74792 0 2
// MC_SetFactoryExtension ( 2 , 106 , 130 , 0 , [ b_ext_computer , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_siberium ] ) ;
6918: LD_INT 2
6920: PPUSH
6921: LD_INT 106
6923: PPUSH
6924: LD_INT 130
6926: PPUSH
6927: LD_INT 0
6929: PPUSH
6930: LD_INT 24
6932: PUSH
6933: LD_INT 16
6935: PUSH
6936: LD_INT 17
6938: PUSH
6939: LD_INT 18
6941: PUSH
6942: LD_INT 21
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PPUSH
6952: CALL 74997 0 5
// end ;
6956: LD_VAR 0 1
6960: RET
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
6961: LD_INT 22
6963: PUSH
6964: LD_INT 3
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 30
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: IFFALSE 8132
6991: GO 6993
6993: DISABLE
6994: LD_INT 0
6996: PPUSH
6997: PPUSH
6998: PPUSH
6999: PPUSH
7000: PPUSH
7001: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
7002: LD_INT 6300
7004: PUSH
7005: LD_INT 4200
7007: PUSH
7008: LD_INT 2100
7010: PUSH
7011: EMPTY
7012: LIST
7013: LIST
7014: LIST
7015: PUSH
7016: LD_OWVAR 67
7020: ARRAY
7021: PPUSH
7022: CALL_OW 67
// base := 2 ;
7026: LD_ADDR_VAR 0 2
7030: PUSH
7031: LD_INT 2
7033: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
7034: LD_INT 22
7036: PUSH
7037: LD_INT 3
7039: PUSH
7040: EMPTY
7041: LIST
7042: LIST
7043: PUSH
7044: LD_INT 30
7046: PUSH
7047: LD_INT 3
7049: PUSH
7050: EMPTY
7051: LIST
7052: LIST
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PPUSH
7058: CALL_OW 69
7062: NOT
7063: IFFALSE 7067
// continue ;
7065: GO 7002
// case Rand ( 1 , 3 ) of 1 :
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: PUSH
7078: LD_INT 1
7080: DOUBLE
7081: EQUAL
7082: IFTRUE 7086
7084: GO 7262
7086: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7087: LD_ADDR_VAR 0 3
7091: PUSH
7092: LD_INT 22
7094: PUSH
7095: LD_INT 3
7097: PUSH
7098: LD_INT 3
7100: PUSH
7101: LD_INT 43
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: PUSH
7110: LD_INT 24
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: LD_INT 3
7118: PUSH
7119: LD_INT 46
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 24
7130: PUSH
7131: LD_INT 3
7133: PUSH
7134: LD_INT 3
7136: PUSH
7137: LD_INT 43
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: LD_INT 24
7148: PUSH
7149: LD_INT 3
7151: PUSH
7152: LD_INT 3
7154: PUSH
7155: LD_INT 46
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 22
7166: PUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 3
7172: PUSH
7173: LD_INT 45
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: PUSH
7182: LD_INT 22
7184: PUSH
7185: LD_INT 3
7187: PUSH
7188: LD_INT 3
7190: PUSH
7191: LD_INT 43
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 24
7202: PUSH
7203: LD_INT 3
7205: PUSH
7206: LD_INT 3
7208: PUSH
7209: LD_INT 46
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: LIST
7217: PUSH
7218: LD_INT 22
7220: PUSH
7221: LD_INT 3
7223: PUSH
7224: LD_INT 3
7226: PUSH
7227: LD_INT 45
7229: PUSH
7230: EMPTY
7231: LIST
7232: LIST
7233: LIST
7234: LIST
7235: PUSH
7236: EMPTY
7237: LIST
7238: LIST
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: LIST
7244: LIST
7245: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7246: LD_VAR 0 2
7250: PPUSH
7251: LD_VAR 0 3
7255: PPUSH
7256: CALL 74098 0 2
// end ; 2 :
7260: GO 7593
7262: LD_INT 2
7264: DOUBLE
7265: EQUAL
7266: IFTRUE 7270
7268: GO 7408
7270: POP
// begin tmp := [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7271: LD_ADDR_VAR 0 3
7275: PUSH
7276: LD_INT 24
7278: PUSH
7279: LD_INT 3
7281: PUSH
7282: LD_INT 3
7284: PUSH
7285: LD_INT 43
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: LIST
7292: LIST
7293: PUSH
7294: LD_INT 24
7296: PUSH
7297: LD_INT 3
7299: PUSH
7300: LD_INT 3
7302: PUSH
7303: LD_INT 46
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: LIST
7310: LIST
7311: PUSH
7312: LD_INT 24
7314: PUSH
7315: LD_INT 3
7317: PUSH
7318: LD_INT 3
7320: PUSH
7321: LD_INT 43
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: LIST
7329: PUSH
7330: LD_INT 24
7332: PUSH
7333: LD_INT 3
7335: PUSH
7336: LD_INT 3
7338: PUSH
7339: LD_INT 46
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: LIST
7346: LIST
7347: PUSH
7348: LD_INT 22
7350: PUSH
7351: LD_INT 3
7353: PUSH
7354: LD_INT 3
7356: PUSH
7357: LD_INT 45
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 22
7368: PUSH
7369: LD_INT 3
7371: PUSH
7372: LD_INT 3
7374: PUSH
7375: LD_INT 45
7377: PUSH
7378: EMPTY
7379: LIST
7380: LIST
7381: LIST
7382: LIST
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: LIST
7391: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7392: LD_VAR 0 2
7396: PPUSH
7397: LD_VAR 0 3
7401: PPUSH
7402: CALL 74098 0 2
// end ; 3 :
7406: GO 7593
7408: LD_INT 3
7410: DOUBLE
7411: EQUAL
7412: IFTRUE 7416
7414: GO 7592
7416: POP
// begin tmp := [ [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ;
7417: LD_ADDR_VAR 0 3
7421: PUSH
7422: LD_INT 22
7424: PUSH
7425: LD_INT 3
7427: PUSH
7428: LD_INT 3
7430: PUSH
7431: LD_INT 43
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 24
7442: PUSH
7443: LD_INT 3
7445: PUSH
7446: LD_INT 3
7448: PUSH
7449: LD_INT 46
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: PUSH
7458: LD_INT 22
7460: PUSH
7461: LD_INT 3
7463: PUSH
7464: LD_INT 3
7466: PUSH
7467: LD_INT 43
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: PUSH
7476: LD_INT 24
7478: PUSH
7479: LD_INT 3
7481: PUSH
7482: LD_INT 3
7484: PUSH
7485: LD_INT 46
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 22
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: LD_INT 3
7502: PUSH
7503: LD_INT 45
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: LIST
7511: PUSH
7512: LD_INT 22
7514: PUSH
7515: LD_INT 3
7517: PUSH
7518: LD_INT 3
7520: PUSH
7521: LD_INT 43
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 24
7532: PUSH
7533: LD_INT 3
7535: PUSH
7536: LD_INT 3
7538: PUSH
7539: LD_INT 46
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 22
7550: PUSH
7551: LD_INT 3
7553: PUSH
7554: LD_INT 3
7556: PUSH
7557: LD_INT 45
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7576: LD_VAR 0 2
7580: PPUSH
7581: LD_VAR 0 3
7585: PPUSH
7586: CALL 74098 0 2
// end ; end ;
7590: GO 7593
7592: POP
// repeat wait ( 0 0$1 ) ;
7593: LD_INT 35
7595: PPUSH
7596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7600: LD_VAR 0 2
7604: PPUSH
7605: CALL 74446 0 1
7609: PUSH
7610: LD_INT 0
7612: EQUAL
7613: IFFALSE 7593
// wait ( 0 0$30 ) ;
7615: LD_INT 1050
7617: PPUSH
7618: CALL_OW 67
// _target := [ [ 86 , 77 ] , [ 63 , 38 ] ] ;
7622: LD_ADDR_VAR 0 5
7626: PUSH
7627: LD_INT 86
7629: PUSH
7630: LD_INT 77
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PUSH
7637: LD_INT 63
7639: PUSH
7640: LD_INT 38
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7651: LD_ADDR_VAR 0 4
7655: PUSH
7656: LD_INT 0
7658: PUSH
7659: LD_INT 0
7661: PUSH
7662: LD_INT 0
7664: PUSH
7665: LD_INT 1
7667: PUSH
7668: LD_INT 0
7670: PUSH
7671: LD_INT 0
7673: PUSH
7674: LD_INT 0
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: LD_INT 1
7682: PUSH
7683: LD_INT 0
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: LIST
7696: LIST
7697: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
7698: LD_ADDR_VAR 0 6
7702: PUSH
7703: LD_EXP 84
7707: PUSH
7708: LD_VAR 0 2
7712: ARRAY
7713: PUSH
7714: LD_EXP 87
7718: PUSH
7719: LD_VAR 0 2
7723: ARRAY
7724: DIFF
7725: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7726: LD_ADDR_EXP 84
7730: PUSH
7731: LD_EXP 84
7735: PPUSH
7736: LD_VAR 0 2
7740: PPUSH
7741: LD_EXP 84
7745: PUSH
7746: LD_VAR 0 2
7750: ARRAY
7751: PUSH
7752: LD_VAR 0 6
7756: DIFF
7757: PPUSH
7758: CALL_OW 1
7762: ST_TO_ADDR
// if not attackers then
7763: LD_VAR 0 6
7767: NOT
7768: IFFALSE 7772
// continue ;
7770: GO 7002
// repeat wait ( 0 0$1 ) ;
7772: LD_INT 35
7774: PPUSH
7775: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
7779: LD_VAR 0 6
7783: PPUSH
7784: LD_INT 60
7786: PUSH
7787: EMPTY
7788: LIST
7789: PPUSH
7790: CALL_OW 72
7794: NOT
7795: IFFALSE 7772
// repeat wait ( 0 0$1 ) ;
7797: LD_INT 35
7799: PPUSH
7800: CALL_OW 67
// for i in attackers do
7804: LD_ADDR_VAR 0 1
7808: PUSH
7809: LD_VAR 0 6
7813: PUSH
7814: FOR_IN
7815: IFFALSE 8099
// begin if IsDead ( i ) then
7817: LD_VAR 0 1
7821: PPUSH
7822: CALL_OW 301
7826: IFFALSE 7844
// attackers := attackers diff i ;
7828: LD_ADDR_VAR 0 6
7832: PUSH
7833: LD_VAR 0 6
7837: PUSH
7838: LD_VAR 0 1
7842: DIFF
7843: ST_TO_ADDR
// if not HasTask ( i ) then
7844: LD_VAR 0 1
7848: PPUSH
7849: CALL_OW 314
7853: NOT
7854: IFFALSE 8097
// begin if not GetTag ( i ) then
7856: LD_VAR 0 1
7860: PPUSH
7861: CALL_OW 110
7865: NOT
7866: IFFALSE 7958
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
7868: LD_VAR 0 1
7872: PPUSH
7873: LD_VAR 0 5
7877: PUSH
7878: LD_INT 1
7880: ARRAY
7881: PUSH
7882: LD_INT 1
7884: ARRAY
7885: PPUSH
7886: LD_VAR 0 5
7890: PUSH
7891: LD_INT 1
7893: ARRAY
7894: PUSH
7895: LD_INT 2
7897: ARRAY
7898: PPUSH
7899: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
7903: LD_VAR 0 1
7907: PPUSH
7908: LD_VAR 0 5
7912: PUSH
7913: LD_INT 1
7915: ARRAY
7916: PUSH
7917: LD_INT 1
7919: ARRAY
7920: PPUSH
7921: LD_VAR 0 5
7925: PUSH
7926: LD_INT 1
7928: ARRAY
7929: PUSH
7930: LD_INT 2
7932: ARRAY
7933: PPUSH
7934: CALL_OW 297
7938: PUSH
7939: LD_INT 8
7941: LESS
7942: IFFALSE 7956
// SetTag ( i , 1 ) ;
7944: LD_VAR 0 1
7948: PPUSH
7949: LD_INT 1
7951: PPUSH
7952: CALL_OW 109
// end else
7956: GO 8097
// if GetTag ( i ) = 1 then
7958: LD_VAR 0 1
7962: PPUSH
7963: CALL_OW 110
7967: PUSH
7968: LD_INT 1
7970: EQUAL
7971: IFFALSE 8063
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
7973: LD_VAR 0 1
7977: PPUSH
7978: LD_VAR 0 5
7982: PUSH
7983: LD_INT 2
7985: ARRAY
7986: PUSH
7987: LD_INT 1
7989: ARRAY
7990: PPUSH
7991: LD_VAR 0 5
7995: PUSH
7996: LD_INT 2
7998: ARRAY
7999: PUSH
8000: LD_INT 2
8002: ARRAY
8003: PPUSH
8004: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_VAR 0 5
8017: PUSH
8018: LD_INT 2
8020: ARRAY
8021: PUSH
8022: LD_INT 1
8024: ARRAY
8025: PPUSH
8026: LD_VAR 0 5
8030: PUSH
8031: LD_INT 2
8033: ARRAY
8034: PUSH
8035: LD_INT 2
8037: ARRAY
8038: PPUSH
8039: CALL_OW 297
8043: PUSH
8044: LD_INT 8
8046: LESS
8047: IFFALSE 8061
// SetTag ( i , 2 ) ;
8049: LD_VAR 0 1
8053: PPUSH
8054: LD_INT 2
8056: PPUSH
8057: CALL_OW 109
// end else
8061: GO 8097
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8063: LD_VAR 0 1
8067: PPUSH
8068: LD_INT 81
8070: PUSH
8071: LD_INT 3
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: PPUSH
8078: CALL_OW 69
8082: PPUSH
8083: LD_VAR 0 1
8087: PPUSH
8088: CALL_OW 74
8092: PPUSH
8093: CALL_OW 115
// end ; end ;
8097: GO 7814
8099: POP
8100: POP
// until not attackers ;
8101: LD_VAR 0 6
8105: NOT
8106: IFFALSE 7797
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
8108: LD_EXP 65
8112: PUSH
8113: LD_VAR 0 2
8117: ARRAY
8118: PPUSH
8119: LD_INT 50
8121: PUSH
8122: EMPTY
8123: LIST
8124: PPUSH
8125: CALL_OW 72
8129: NOT
8130: IFFALSE 7002
// end ;
8132: PPOPN 6
8134: END
// every 1 1$00 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) do var i , base , tmp , flags , _target , attackers ;
8135: LD_INT 22
8137: PUSH
8138: LD_INT 3
8140: PUSH
8141: EMPTY
8142: LIST
8143: LIST
8144: PUSH
8145: LD_INT 30
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PPUSH
8159: CALL_OW 69
8163: IFFALSE 9347
8165: GO 8167
8167: DISABLE
8168: LD_INT 0
8170: PPUSH
8171: PPUSH
8172: PPUSH
8173: PPUSH
8174: PPUSH
8175: PPUSH
// begin repeat wait ( [ 3 3$00 , 2 2$00 , 1 1$00 ] [ Difficulty ] ) ;
8176: LD_INT 6300
8178: PUSH
8179: LD_INT 4200
8181: PUSH
8182: LD_INT 2100
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: LIST
8189: PUSH
8190: LD_OWVAR 67
8194: ARRAY
8195: PPUSH
8196: CALL_OW 67
// base := 1 ;
8200: LD_ADDR_VAR 0 2
8204: PUSH
8205: LD_INT 1
8207: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8208: LD_INT 22
8210: PUSH
8211: LD_INT 3
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: LD_INT 30
8220: PUSH
8221: LD_INT 3
8223: PUSH
8224: EMPTY
8225: LIST
8226: LIST
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: PPUSH
8232: CALL_OW 69
8236: NOT
8237: IFFALSE 8241
// continue ;
8239: GO 8176
// case Rand ( 1 , 3 ) of 1 :
8241: LD_INT 1
8243: PPUSH
8244: LD_INT 3
8246: PPUSH
8247: CALL_OW 12
8251: PUSH
8252: LD_INT 1
8254: DOUBLE
8255: EQUAL
8256: IFTRUE 8260
8258: GO 8436
8260: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8261: LD_ADDR_VAR 0 3
8265: PUSH
8266: LD_INT 22
8268: PUSH
8269: LD_INT 1
8271: PUSH
8272: LD_INT 3
8274: PUSH
8275: LD_INT 43
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: LIST
8282: LIST
8283: PUSH
8284: LD_INT 24
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: LD_INT 3
8292: PUSH
8293: LD_INT 46
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: LIST
8300: LIST
8301: PUSH
8302: LD_INT 24
8304: PUSH
8305: LD_INT 1
8307: PUSH
8308: LD_INT 3
8310: PUSH
8311: LD_INT 43
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: LIST
8318: LIST
8319: PUSH
8320: LD_INT 24
8322: PUSH
8323: LD_INT 1
8325: PUSH
8326: LD_INT 3
8328: PUSH
8329: LD_INT 46
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: LIST
8337: PUSH
8338: LD_INT 22
8340: PUSH
8341: LD_INT 1
8343: PUSH
8344: LD_INT 3
8346: PUSH
8347: LD_INT 45
8349: PUSH
8350: EMPTY
8351: LIST
8352: LIST
8353: LIST
8354: LIST
8355: PUSH
8356: LD_INT 22
8358: PUSH
8359: LD_INT 1
8361: PUSH
8362: LD_INT 3
8364: PUSH
8365: LD_INT 43
8367: PUSH
8368: EMPTY
8369: LIST
8370: LIST
8371: LIST
8372: LIST
8373: PUSH
8374: LD_INT 24
8376: PUSH
8377: LD_INT 1
8379: PUSH
8380: LD_INT 3
8382: PUSH
8383: LD_INT 46
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: LIST
8390: LIST
8391: PUSH
8392: LD_INT 22
8394: PUSH
8395: LD_INT 1
8397: PUSH
8398: LD_INT 3
8400: PUSH
8401: LD_INT 45
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: LIST
8414: LIST
8415: LIST
8416: LIST
8417: LIST
8418: LIST
8419: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8420: LD_VAR 0 2
8424: PPUSH
8425: LD_VAR 0 3
8429: PPUSH
8430: CALL 74098 0 2
// end ; 2 :
8434: GO 8805
8436: LD_INT 2
8438: DOUBLE
8439: EQUAL
8440: IFTRUE 8444
8442: GO 8620
8444: POP
// begin tmp := [ [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8445: LD_ADDR_VAR 0 3
8449: PUSH
8450: LD_INT 24
8452: PUSH
8453: LD_INT 1
8455: PUSH
8456: LD_INT 3
8458: PUSH
8459: LD_INT 43
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_INT 24
8470: PUSH
8471: LD_INT 1
8473: PUSH
8474: LD_INT 3
8476: PUSH
8477: LD_INT 46
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_INT 24
8488: PUSH
8489: LD_INT 1
8491: PUSH
8492: LD_INT 3
8494: PUSH
8495: LD_INT 43
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: LIST
8503: PUSH
8504: LD_INT 24
8506: PUSH
8507: LD_INT 1
8509: PUSH
8510: LD_INT 3
8512: PUSH
8513: LD_INT 46
8515: PUSH
8516: EMPTY
8517: LIST
8518: LIST
8519: LIST
8520: LIST
8521: PUSH
8522: LD_INT 22
8524: PUSH
8525: LD_INT 1
8527: PUSH
8528: LD_INT 3
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: LIST
8539: PUSH
8540: LD_INT 22
8542: PUSH
8543: LD_INT 1
8545: PUSH
8546: LD_INT 3
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 1
8563: PUSH
8564: LD_INT 3
8566: PUSH
8567: LD_INT 45
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: LIST
8574: LIST
8575: PUSH
8576: LD_INT 22
8578: PUSH
8579: LD_INT 1
8581: PUSH
8582: LD_INT 3
8584: PUSH
8585: LD_INT 45
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: LIST
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8604: LD_VAR 0 2
8608: PPUSH
8609: LD_VAR 0 3
8613: PPUSH
8614: CALL 74098 0 2
// end ; 3 :
8618: GO 8805
8620: LD_INT 3
8622: DOUBLE
8623: EQUAL
8624: IFTRUE 8628
8626: GO 8804
8628: POP
// begin tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] ] ;
8629: LD_ADDR_VAR 0 3
8633: PUSH
8634: LD_INT 22
8636: PUSH
8637: LD_INT 1
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: LD_INT 43
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: LIST
8650: LIST
8651: PUSH
8652: LD_INT 24
8654: PUSH
8655: LD_INT 1
8657: PUSH
8658: LD_INT 3
8660: PUSH
8661: LD_INT 46
8663: PUSH
8664: EMPTY
8665: LIST
8666: LIST
8667: LIST
8668: LIST
8669: PUSH
8670: LD_INT 22
8672: PUSH
8673: LD_INT 1
8675: PUSH
8676: LD_INT 3
8678: PUSH
8679: LD_INT 43
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: PUSH
8688: LD_INT 24
8690: PUSH
8691: LD_INT 1
8693: PUSH
8694: LD_INT 3
8696: PUSH
8697: LD_INT 46
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: LIST
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 1
8711: PUSH
8712: LD_INT 3
8714: PUSH
8715: LD_INT 45
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: LIST
8722: LIST
8723: PUSH
8724: LD_INT 22
8726: PUSH
8727: LD_INT 1
8729: PUSH
8730: LD_INT 3
8732: PUSH
8733: LD_INT 43
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: PUSH
8742: LD_INT 24
8744: PUSH
8745: LD_INT 1
8747: PUSH
8748: LD_INT 3
8750: PUSH
8751: LD_INT 46
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_INT 1
8765: PUSH
8766: LD_INT 3
8768: PUSH
8769: LD_INT 45
8771: PUSH
8772: EMPTY
8773: LIST
8774: LIST
8775: LIST
8776: LIST
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: LIST
8782: LIST
8783: LIST
8784: LIST
8785: LIST
8786: LIST
8787: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
8788: LD_VAR 0 2
8792: PPUSH
8793: LD_VAR 0 3
8797: PPUSH
8798: CALL 74098 0 2
// end ; end ;
8802: GO 8805
8804: POP
// repeat wait ( 0 0$1 ) ;
8805: LD_INT 35
8807: PPUSH
8808: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= 8 ;
8812: LD_VAR 0 2
8816: PPUSH
8817: LD_INT 1
8819: PPUSH
8820: CALL 75516 0 2
8824: PUSH
8825: LD_INT 8
8827: GREATEREQUAL
8828: IFFALSE 8805
// wait ( 0 0$30 ) ;
8830: LD_INT 1050
8832: PPUSH
8833: CALL_OW 67
// _target := [ [ 144 , 65 ] , [ 63 , 38 ] ] ;
8837: LD_ADDR_VAR 0 5
8841: PUSH
8842: LD_INT 144
8844: PUSH
8845: LD_INT 65
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: PUSH
8852: LD_INT 63
8854: PUSH
8855: LD_INT 38
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
8866: LD_ADDR_VAR 0 4
8870: PUSH
8871: LD_INT 0
8873: PUSH
8874: LD_INT 0
8876: PUSH
8877: LD_INT 0
8879: PUSH
8880: LD_INT 1
8882: PUSH
8883: LD_INT 0
8885: PUSH
8886: LD_INT 0
8888: PUSH
8889: LD_INT 0
8891: PUSH
8892: LD_INT 0
8894: PUSH
8895: LD_INT 1
8897: PUSH
8898: LD_INT 0
8900: PUSH
8901: EMPTY
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: LIST
8907: LIST
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] ) ;
8913: LD_ADDR_VAR 0 6
8917: PUSH
8918: LD_EXP 84
8922: PUSH
8923: LD_VAR 0 2
8927: ARRAY
8928: PUSH
8929: LD_EXP 87
8933: PUSH
8934: LD_VAR 0 2
8938: ARRAY
8939: DIFF
8940: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8941: LD_ADDR_EXP 84
8945: PUSH
8946: LD_EXP 84
8950: PPUSH
8951: LD_VAR 0 2
8955: PPUSH
8956: LD_EXP 84
8960: PUSH
8961: LD_VAR 0 2
8965: ARRAY
8966: PUSH
8967: LD_VAR 0 6
8971: DIFF
8972: PPUSH
8973: CALL_OW 1
8977: ST_TO_ADDR
// if not attackers then
8978: LD_VAR 0 6
8982: NOT
8983: IFFALSE 8987
// continue ;
8985: GO 8176
// repeat wait ( 0 0$1 ) ;
8987: LD_INT 35
8989: PPUSH
8990: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8994: LD_VAR 0 6
8998: PPUSH
8999: LD_INT 60
9001: PUSH
9002: EMPTY
9003: LIST
9004: PPUSH
9005: CALL_OW 72
9009: NOT
9010: IFFALSE 8987
// repeat wait ( 0 0$1 ) ;
9012: LD_INT 35
9014: PPUSH
9015: CALL_OW 67
// for i in attackers do
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 6
9028: PUSH
9029: FOR_IN
9030: IFFALSE 9314
// begin if IsDead ( i ) then
9032: LD_VAR 0 1
9036: PPUSH
9037: CALL_OW 301
9041: IFFALSE 9059
// attackers := attackers diff i ;
9043: LD_ADDR_VAR 0 6
9047: PUSH
9048: LD_VAR 0 6
9052: PUSH
9053: LD_VAR 0 1
9057: DIFF
9058: ST_TO_ADDR
// if not HasTask ( i ) then
9059: LD_VAR 0 1
9063: PPUSH
9064: CALL_OW 314
9068: NOT
9069: IFFALSE 9312
// begin if not GetTag ( i ) then
9071: LD_VAR 0 1
9075: PPUSH
9076: CALL_OW 110
9080: NOT
9081: IFFALSE 9173
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
9083: LD_VAR 0 1
9087: PPUSH
9088: LD_VAR 0 5
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PUSH
9097: LD_INT 1
9099: ARRAY
9100: PPUSH
9101: LD_VAR 0 5
9105: PUSH
9106: LD_INT 1
9108: ARRAY
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
9118: LD_VAR 0 1
9122: PPUSH
9123: LD_VAR 0 5
9127: PUSH
9128: LD_INT 1
9130: ARRAY
9131: PUSH
9132: LD_INT 1
9134: ARRAY
9135: PPUSH
9136: LD_VAR 0 5
9140: PUSH
9141: LD_INT 1
9143: ARRAY
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: CALL_OW 297
9153: PUSH
9154: LD_INT 8
9156: LESS
9157: IFFALSE 9171
// SetTag ( i , 1 ) ;
9159: LD_VAR 0 1
9163: PPUSH
9164: LD_INT 1
9166: PPUSH
9167: CALL_OW 109
// end else
9171: GO 9312
// if GetTag ( i ) = 1 then
9173: LD_VAR 0 1
9177: PPUSH
9178: CALL_OW 110
9182: PUSH
9183: LD_INT 1
9185: EQUAL
9186: IFFALSE 9278
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
9188: LD_VAR 0 1
9192: PPUSH
9193: LD_VAR 0 5
9197: PUSH
9198: LD_INT 2
9200: ARRAY
9201: PUSH
9202: LD_INT 1
9204: ARRAY
9205: PPUSH
9206: LD_VAR 0 5
9210: PUSH
9211: LD_INT 2
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
9223: LD_VAR 0 1
9227: PPUSH
9228: LD_VAR 0 5
9232: PUSH
9233: LD_INT 2
9235: ARRAY
9236: PUSH
9237: LD_INT 1
9239: ARRAY
9240: PPUSH
9241: LD_VAR 0 5
9245: PUSH
9246: LD_INT 2
9248: ARRAY
9249: PUSH
9250: LD_INT 2
9252: ARRAY
9253: PPUSH
9254: CALL_OW 297
9258: PUSH
9259: LD_INT 8
9261: LESS
9262: IFFALSE 9276
// SetTag ( i , 2 ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 109
// end else
9276: GO 9312
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9278: LD_VAR 0 1
9282: PPUSH
9283: LD_INT 81
9285: PUSH
9286: LD_INT 3
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PPUSH
9293: CALL_OW 69
9297: PPUSH
9298: LD_VAR 0 1
9302: PPUSH
9303: CALL_OW 74
9307: PPUSH
9308: CALL_OW 115
// end ; end ;
9312: GO 9029
9314: POP
9315: POP
// until not attackers ;
9316: LD_VAR 0 6
9320: NOT
9321: IFFALSE 9012
// until not UnitFilter ( mc_bases [ base ] , [ f_ok ] ) ;
9323: LD_EXP 65
9327: PUSH
9328: LD_VAR 0 2
9332: ARRAY
9333: PPUSH
9334: LD_INT 50
9336: PUSH
9337: EMPTY
9338: LIST
9339: PPUSH
9340: CALL_OW 72
9344: NOT
9345: IFFALSE 8176
// end ;
9347: PPOPN 6
9349: END
// export RussiansDefeated ; every 0 0$1 trigger FirstAssaultRepelled and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9350: LD_EXP 4
9354: PUSH
9355: LD_INT 22
9357: PUSH
9358: LD_INT 3
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: PUSH
9365: LD_INT 21
9367: PUSH
9368: LD_INT 1
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PPUSH
9379: CALL_OW 69
9383: PUSH
9384: LD_INT 0
9386: EQUAL
9387: AND
9388: IFFALSE 9401
9390: GO 9392
9392: DISABLE
// RussiansDefeated := true ;
9393: LD_ADDR_EXP 44
9397: PUSH
9398: LD_INT 1
9400: ST_TO_ADDR
9401: END
// every 0 0$1 trigger FirstAssaultRepelled and not JMM_Arrived do var i , un , filter , soldiers , bazookas , vehs , vehicle , medics , squad , attackers , _target , flags ;
9402: LD_EXP 4
9406: PUSH
9407: LD_EXP 6
9411: NOT
9412: AND
9413: IFFALSE 10837
9415: GO 9417
9417: DISABLE
9418: LD_INT 0
9420: PPUSH
9421: PPUSH
9422: PPUSH
9423: PPUSH
9424: PPUSH
9425: PPUSH
9426: PPUSH
9427: PPUSH
9428: PPUSH
9429: PPUSH
9430: PPUSH
9431: PPUSH
// begin wait ( [ Rand ( 4 4$00 , 4 4$30 ) , Rand ( 4 4$30 , 3 3$30 ) , Rand ( 3 3$00 , 2 2$00 ) ] [ Difficulty ] ) ;
9432: LD_INT 8400
9434: PPUSH
9435: LD_INT 9450
9437: PPUSH
9438: CALL_OW 12
9442: PUSH
9443: LD_INT 9450
9445: PPUSH
9446: LD_INT 7350
9448: PPUSH
9449: CALL_OW 12
9453: PUSH
9454: LD_INT 6300
9456: PPUSH
9457: LD_INT 4200
9459: PPUSH
9460: CALL_OW 12
9464: PUSH
9465: EMPTY
9466: LIST
9467: LIST
9468: LIST
9469: PUSH
9470: LD_OWVAR 67
9474: ARRAY
9475: PPUSH
9476: CALL_OW 67
// filter := [ ] ;
9480: LD_ADDR_VAR 0 3
9484: PUSH
9485: EMPTY
9486: ST_TO_ADDR
// soldiers := [ Rand ( 2 , 3 ) , Rand ( 3 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9487: LD_ADDR_VAR 0 4
9491: PUSH
9492: LD_INT 2
9494: PPUSH
9495: LD_INT 3
9497: PPUSH
9498: CALL_OW 12
9502: PUSH
9503: LD_INT 3
9505: PPUSH
9506: LD_INT 4
9508: PPUSH
9509: CALL_OW 12
9513: PUSH
9514: LD_INT 3
9516: PPUSH
9517: LD_INT 5
9519: PPUSH
9520: CALL_OW 12
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: LIST
9529: PUSH
9530: LD_OWVAR 67
9534: ARRAY
9535: ST_TO_ADDR
// bazookas := [ 1 , Rand ( 1 , 2 ) , Rand ( 2 , 3 ) ] [ Difficulty ] ;
9536: LD_ADDR_VAR 0 5
9540: PUSH
9541: LD_INT 1
9543: PUSH
9544: LD_INT 1
9546: PPUSH
9547: LD_INT 2
9549: PPUSH
9550: CALL_OW 12
9554: PUSH
9555: LD_INT 2
9557: PPUSH
9558: LD_INT 3
9560: PPUSH
9561: CALL_OW 12
9565: PUSH
9566: EMPTY
9567: LIST
9568: LIST
9569: LIST
9570: PUSH
9571: LD_OWVAR 67
9575: ARRAY
9576: ST_TO_ADDR
// vehs := [ Rand ( 2 , 3 ) , Rand ( 2 , 4 ) , Rand ( 3 , 5 ) ] [ Difficulty ] ;
9577: LD_ADDR_VAR 0 6
9581: PUSH
9582: LD_INT 2
9584: PPUSH
9585: LD_INT 3
9587: PPUSH
9588: CALL_OW 12
9592: PUSH
9593: LD_INT 2
9595: PPUSH
9596: LD_INT 4
9598: PPUSH
9599: CALL_OW 12
9603: PUSH
9604: LD_INT 3
9606: PPUSH
9607: LD_INT 5
9609: PPUSH
9610: CALL_OW 12
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_OWVAR 67
9624: ARRAY
9625: ST_TO_ADDR
// medics := [ 1 , 2 , 2 ] [ Difficulty ] ;
9626: LD_ADDR_VAR 0 8
9630: PUSH
9631: LD_INT 1
9633: PUSH
9634: LD_INT 2
9636: PUSH
9637: LD_INT 2
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_OWVAR 67
9649: ARRAY
9650: ST_TO_ADDR
// uc_side := 3 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 3
9658: ST_TO_ADDR
// uc_nation := nation_russian ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// for i = 1 to soldiers do
9667: LD_ADDR_VAR 0 1
9671: PUSH
9672: DOUBLE
9673: LD_INT 1
9675: DEC
9676: ST_TO_ADDR
9677: LD_VAR 0 4
9681: PUSH
9682: FOR_TO
9683: IFFALSE 9725
// begin PrepareSoldier ( 0 , game_eskill ) ;
9685: LD_INT 0
9687: PPUSH
9688: LD_EXP 40
9692: PPUSH
9693: CALL_OW 381
// un := CreateHuman ;
9697: LD_ADDR_VAR 0 2
9701: PUSH
9702: CALL_OW 44
9706: ST_TO_ADDR
// filter := filter ^ un ;
9707: LD_ADDR_VAR 0 3
9711: PUSH
9712: LD_VAR 0 3
9716: PUSH
9717: LD_VAR 0 2
9721: ADD
9722: ST_TO_ADDR
// end ;
9723: GO 9682
9725: POP
9726: POP
// for i = 1 to bazookas do
9727: LD_ADDR_VAR 0 1
9731: PUSH
9732: DOUBLE
9733: LD_INT 1
9735: DEC
9736: ST_TO_ADDR
9737: LD_VAR 0 5
9741: PUSH
9742: FOR_TO
9743: IFFALSE 9793
// begin PrepareSoldier ( 0 , game_eskill ) ;
9745: LD_INT 0
9747: PPUSH
9748: LD_EXP 40
9752: PPUSH
9753: CALL_OW 381
// hc_class := class_bazooker ;
9757: LD_ADDR_OWVAR 28
9761: PUSH
9762: LD_INT 9
9764: ST_TO_ADDR
// un := CreateHuman ;
9765: LD_ADDR_VAR 0 2
9769: PUSH
9770: CALL_OW 44
9774: ST_TO_ADDR
// filter := filter ^ un ;
9775: LD_ADDR_VAR 0 3
9779: PUSH
9780: LD_VAR 0 3
9784: PUSH
9785: LD_VAR 0 2
9789: ADD
9790: ST_TO_ADDR
// end ;
9791: GO 9742
9793: POP
9794: POP
// for i = 1 to medics do
9795: LD_ADDR_VAR 0 1
9799: PUSH
9800: DOUBLE
9801: LD_INT 1
9803: DEC
9804: ST_TO_ADDR
9805: LD_VAR 0 8
9809: PUSH
9810: FOR_TO
9811: IFFALSE 9853
// begin PrepareScientist ( 0 , game_eskill ) ;
9813: LD_INT 0
9815: PPUSH
9816: LD_EXP 40
9820: PPUSH
9821: CALL_OW 384
// un := CreateHuman ;
9825: LD_ADDR_VAR 0 2
9829: PUSH
9830: CALL_OW 44
9834: ST_TO_ADDR
// filter := filter ^ un ;
9835: LD_ADDR_VAR 0 3
9839: PUSH
9840: LD_VAR 0 3
9844: PUSH
9845: LD_VAR 0 2
9849: ADD
9850: ST_TO_ADDR
// end ;
9851: GO 9810
9853: POP
9854: POP
// for i = 1 to vehs do
9855: LD_ADDR_VAR 0 1
9859: PUSH
9860: DOUBLE
9861: LD_INT 1
9863: DEC
9864: ST_TO_ADDR
9865: LD_VAR 0 6
9869: PUSH
9870: FOR_TO
9871: IFFALSE 10063
// begin case Rand ( 1 , 5 ) of 1 :
9873: LD_INT 1
9875: PPUSH
9876: LD_INT 5
9878: PPUSH
9879: CALL_OW 12
9883: PUSH
9884: LD_INT 1
9886: DOUBLE
9887: EQUAL
9888: IFTRUE 9892
9890: GO 9914
9892: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 2 :
9893: LD_INT 22
9895: PPUSH
9896: LD_INT 3
9898: PPUSH
9899: LD_INT 3
9901: PPUSH
9902: LD_INT 43
9904: PPUSH
9905: LD_INT 100
9907: PPUSH
9908: CALL 18457 0 5
9912: GO 10035
9914: LD_INT 2
9916: DOUBLE
9917: EQUAL
9918: IFTRUE 9922
9920: GO 9944
9922: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gun , 100 ) ; 3 :
9923: LD_INT 22
9925: PPUSH
9926: LD_INT 3
9928: PPUSH
9929: LD_INT 3
9931: PPUSH
9932: LD_INT 44
9934: PPUSH
9935: LD_INT 100
9937: PPUSH
9938: CALL 18457 0 5
9942: GO 10035
9944: LD_INT 3
9946: DOUBLE
9947: EQUAL
9948: IFTRUE 9952
9950: GO 9974
9952: POP
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_rocket_launcher , 100 ) ; 4 :
9953: LD_INT 22
9955: PPUSH
9956: LD_INT 3
9958: PPUSH
9959: LD_INT 3
9961: PPUSH
9962: LD_INT 45
9964: PPUSH
9965: LD_INT 100
9967: PPUSH
9968: CALL 18457 0 5
9972: GO 10035
9974: LD_INT 4
9976: DOUBLE
9977: EQUAL
9978: IFTRUE 9982
9980: GO 10004
9982: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ; 5 :
9983: LD_INT 24
9985: PPUSH
9986: LD_INT 3
9988: PPUSH
9989: LD_INT 3
9991: PPUSH
9992: LD_INT 43
9994: PPUSH
9995: LD_INT 100
9997: PPUSH
9998: CALL 18457 0 5
10002: GO 10035
10004: LD_INT 5
10006: DOUBLE
10007: EQUAL
10008: IFTRUE 10012
10010: GO 10034
10012: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun , 100 ) ; end ;
10013: LD_INT 24
10015: PPUSH
10016: LD_INT 3
10018: PPUSH
10019: LD_INT 3
10021: PPUSH
10022: LD_INT 46
10024: PPUSH
10025: LD_INT 100
10027: PPUSH
10028: CALL 18457 0 5
10032: GO 10035
10034: POP
// vehicle := CreateVehicle ;
10035: LD_ADDR_VAR 0 7
10039: PUSH
10040: CALL_OW 45
10044: ST_TO_ADDR
// filter := filter ^ vehicle ;
10045: LD_ADDR_VAR 0 3
10049: PUSH
10050: LD_VAR 0 3
10054: PUSH
10055: LD_VAR 0 7
10059: ADD
10060: ST_TO_ADDR
// end ;
10061: GO 9870
10063: POP
10064: POP
// for i = 1 to filter do
10065: LD_ADDR_VAR 0 1
10069: PUSH
10070: DOUBLE
10071: LD_INT 1
10073: DEC
10074: ST_TO_ADDR
10075: LD_VAR 0 3
10079: PUSH
10080: FOR_TO
10081: IFFALSE 10106
// PlaceUnitArea ( filter [ i ] , RUAttackSpawn1 , false ) ;
10083: LD_VAR 0 3
10087: PUSH
10088: LD_VAR 0 1
10092: ARRAY
10093: PPUSH
10094: LD_INT 14
10096: PPUSH
10097: LD_INT 0
10099: PPUSH
10100: CALL_OW 49
10104: GO 10080
10106: POP
10107: POP
// case Rand ( 1 , 3 ) of 1 :
10108: LD_INT 1
10110: PPUSH
10111: LD_INT 3
10113: PPUSH
10114: CALL_OW 12
10118: PUSH
10119: LD_INT 1
10121: DOUBLE
10122: EQUAL
10123: IFTRUE 10127
10125: GO 10181
10127: POP
// _target := [ [ 165 , 114 ] , [ 104 , 108 ] , [ 86 , 77 ] , [ 63 , 38 ] ] ; 2 :
10128: LD_ADDR_VAR 0 11
10132: PUSH
10133: LD_INT 165
10135: PUSH
10136: LD_INT 114
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: LD_INT 104
10145: PUSH
10146: LD_INT 108
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: PUSH
10153: LD_INT 86
10155: PUSH
10156: LD_INT 77
10158: PUSH
10159: EMPTY
10160: LIST
10161: LIST
10162: PUSH
10163: LD_INT 63
10165: PUSH
10166: LD_INT 38
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: LIST
10177: LIST
10178: ST_TO_ADDR
10179: GO 10306
10181: LD_INT 2
10183: DOUBLE
10184: EQUAL
10185: IFTRUE 10189
10187: GO 10243
10189: POP
// _target := [ [ 165 , 114 ] , [ 146 , 71 ] , [ 112 , 41 ] , [ 63 , 38 ] ] ; 3 :
10190: LD_ADDR_VAR 0 11
10194: PUSH
10195: LD_INT 165
10197: PUSH
10198: LD_INT 114
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 146
10207: PUSH
10208: LD_INT 71
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: LD_INT 112
10217: PUSH
10218: LD_INT 41
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 63
10227: PUSH
10228: LD_INT 38
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: EMPTY
10236: LIST
10237: LIST
10238: LIST
10239: LIST
10240: ST_TO_ADDR
10241: GO 10306
10243: LD_INT 3
10245: DOUBLE
10246: EQUAL
10247: IFTRUE 10251
10249: GO 10305
10251: POP
// _target := [ [ 165 , 114 ] , [ 63 , 99 ] , [ 55 , 77 ] , [ 63 , 38 ] ] ; end ;
10252: LD_ADDR_VAR 0 11
10256: PUSH
10257: LD_INT 165
10259: PUSH
10260: LD_INT 114
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 63
10269: PUSH
10270: LD_INT 99
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 55
10279: PUSH
10280: LD_INT 77
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: LD_INT 63
10289: PUSH
10290: LD_INT 38
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: ST_TO_ADDR
10303: GO 10306
10305: POP
// attackers := filter ;
10306: LD_ADDR_VAR 0 10
10310: PUSH
10311: LD_VAR 0 3
10315: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10316: LD_INT 35
10318: PPUSH
10319: CALL_OW 67
// for i in attackers do
10323: LD_ADDR_VAR 0 1
10327: PUSH
10328: LD_VAR 0 10
10332: PUSH
10333: FOR_IN
10334: IFFALSE 10828
// begin if IsDead ( i ) then
10336: LD_VAR 0 1
10340: PPUSH
10341: CALL_OW 301
10345: IFFALSE 10363
// attackers := attackers diff i ;
10347: LD_ADDR_VAR 0 10
10351: PUSH
10352: LD_VAR 0 10
10356: PUSH
10357: LD_VAR 0 1
10361: DIFF
10362: ST_TO_ADDR
// if not HasTask ( i ) then
10363: LD_VAR 0 1
10367: PPUSH
10368: CALL_OW 314
10372: NOT
10373: IFFALSE 10826
// begin if not GetTag ( i ) then
10375: LD_VAR 0 1
10379: PPUSH
10380: CALL_OW 110
10384: NOT
10385: IFFALSE 10477
// begin ComAgressiveMove ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) ;
10387: LD_VAR 0 1
10391: PPUSH
10392: LD_VAR 0 11
10396: PUSH
10397: LD_INT 1
10399: ARRAY
10400: PUSH
10401: LD_INT 1
10403: ARRAY
10404: PPUSH
10405: LD_VAR 0 11
10409: PUSH
10410: LD_INT 1
10412: ARRAY
10413: PUSH
10414: LD_INT 2
10416: ARRAY
10417: PPUSH
10418: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 1 ] [ 1 ] , _target [ 1 ] [ 2 ] ) < 8 then
10422: LD_VAR 0 1
10426: PPUSH
10427: LD_VAR 0 11
10431: PUSH
10432: LD_INT 1
10434: ARRAY
10435: PUSH
10436: LD_INT 1
10438: ARRAY
10439: PPUSH
10440: LD_VAR 0 11
10444: PUSH
10445: LD_INT 1
10447: ARRAY
10448: PUSH
10449: LD_INT 2
10451: ARRAY
10452: PPUSH
10453: CALL_OW 297
10457: PUSH
10458: LD_INT 8
10460: LESS
10461: IFFALSE 10475
// SetTag ( i , 1 ) ;
10463: LD_VAR 0 1
10467: PPUSH
10468: LD_INT 1
10470: PPUSH
10471: CALL_OW 109
// end else
10475: GO 10826
// if GetTag ( i ) = 1 then
10477: LD_VAR 0 1
10481: PPUSH
10482: CALL_OW 110
10486: PUSH
10487: LD_INT 1
10489: EQUAL
10490: IFFALSE 10582
// begin ComAgressiveMove ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) ;
10492: LD_VAR 0 1
10496: PPUSH
10497: LD_VAR 0 11
10501: PUSH
10502: LD_INT 2
10504: ARRAY
10505: PUSH
10506: LD_INT 1
10508: ARRAY
10509: PPUSH
10510: LD_VAR 0 11
10514: PUSH
10515: LD_INT 2
10517: ARRAY
10518: PUSH
10519: LD_INT 2
10521: ARRAY
10522: PPUSH
10523: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 2 ] [ 1 ] , _target [ 2 ] [ 2 ] ) < 8 then
10527: LD_VAR 0 1
10531: PPUSH
10532: LD_VAR 0 11
10536: PUSH
10537: LD_INT 2
10539: ARRAY
10540: PUSH
10541: LD_INT 1
10543: ARRAY
10544: PPUSH
10545: LD_VAR 0 11
10549: PUSH
10550: LD_INT 2
10552: ARRAY
10553: PUSH
10554: LD_INT 2
10556: ARRAY
10557: PPUSH
10558: CALL_OW 297
10562: PUSH
10563: LD_INT 8
10565: LESS
10566: IFFALSE 10580
// SetTag ( i , 2 ) ;
10568: LD_VAR 0 1
10572: PPUSH
10573: LD_INT 2
10575: PPUSH
10576: CALL_OW 109
// end else
10580: GO 10826
// if GetTag ( i ) = 2 then
10582: LD_VAR 0 1
10586: PPUSH
10587: CALL_OW 110
10591: PUSH
10592: LD_INT 2
10594: EQUAL
10595: IFFALSE 10687
// begin ComAgressiveMove ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) ;
10597: LD_VAR 0 1
10601: PPUSH
10602: LD_VAR 0 11
10606: PUSH
10607: LD_INT 3
10609: ARRAY
10610: PUSH
10611: LD_INT 1
10613: ARRAY
10614: PPUSH
10615: LD_VAR 0 11
10619: PUSH
10620: LD_INT 3
10622: ARRAY
10623: PUSH
10624: LD_INT 2
10626: ARRAY
10627: PPUSH
10628: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 3 ] [ 1 ] , _target [ 3 ] [ 2 ] ) < 8 then
10632: LD_VAR 0 1
10636: PPUSH
10637: LD_VAR 0 11
10641: PUSH
10642: LD_INT 3
10644: ARRAY
10645: PUSH
10646: LD_INT 1
10648: ARRAY
10649: PPUSH
10650: LD_VAR 0 11
10654: PUSH
10655: LD_INT 3
10657: ARRAY
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PPUSH
10663: CALL_OW 297
10667: PUSH
10668: LD_INT 8
10670: LESS
10671: IFFALSE 10685
// SetTag ( i , 3 ) ;
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_INT 3
10680: PPUSH
10681: CALL_OW 109
// end else
10685: GO 10826
// if GetTag ( i ) = 3 then
10687: LD_VAR 0 1
10691: PPUSH
10692: CALL_OW 110
10696: PUSH
10697: LD_INT 3
10699: EQUAL
10700: IFFALSE 10792
// begin ComAgressiveMove ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) ;
10702: LD_VAR 0 1
10706: PPUSH
10707: LD_VAR 0 11
10711: PUSH
10712: LD_INT 4
10714: ARRAY
10715: PUSH
10716: LD_INT 1
10718: ARRAY
10719: PPUSH
10720: LD_VAR 0 11
10724: PUSH
10725: LD_INT 4
10727: ARRAY
10728: PUSH
10729: LD_INT 2
10731: ARRAY
10732: PPUSH
10733: CALL_OW 114
// if GetDistUnitXY ( i , _target [ 4 ] [ 1 ] , _target [ 4 ] [ 2 ] ) < 8 then
10737: LD_VAR 0 1
10741: PPUSH
10742: LD_VAR 0 11
10746: PUSH
10747: LD_INT 4
10749: ARRAY
10750: PUSH
10751: LD_INT 1
10753: ARRAY
10754: PPUSH
10755: LD_VAR 0 11
10759: PUSH
10760: LD_INT 4
10762: ARRAY
10763: PUSH
10764: LD_INT 2
10766: ARRAY
10767: PPUSH
10768: CALL_OW 297
10772: PUSH
10773: LD_INT 8
10775: LESS
10776: IFFALSE 10790
// SetTag ( i , 4 ) ;
10778: LD_VAR 0 1
10782: PPUSH
10783: LD_INT 4
10785: PPUSH
10786: CALL_OW 109
// end else
10790: GO 10826
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10792: LD_VAR 0 1
10796: PPUSH
10797: LD_INT 81
10799: PUSH
10800: LD_INT 3
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PPUSH
10807: CALL_OW 69
10811: PPUSH
10812: LD_VAR 0 1
10816: PPUSH
10817: CALL_OW 74
10821: PPUSH
10822: CALL_OW 115
// end ; end ;
10826: GO 10333
10828: POP
10829: POP
// until not attackers ;
10830: LD_VAR 0 10
10834: NOT
10835: IFFALSE 10316
// end ;
10837: PPOPN 12
10839: END
// every 0 0$1 do var i , tmp ;
10840: GO 10842
10842: DISABLE
10843: LD_INT 0
10845: PPUSH
10846: PPUSH
// begin enable ;
10847: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
10848: LD_ADDR_VAR 0 2
10852: PUSH
10853: LD_INT 3
10855: PUSH
10856: LD_INT 22
10858: PUSH
10859: LD_INT 1
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PUSH
10866: EMPTY
10867: LIST
10868: LIST
10869: PUSH
10870: LD_INT 32
10872: PUSH
10873: LD_INT 1
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PPUSH
10884: CALL_OW 69
10888: ST_TO_ADDR
// if tmp then
10889: LD_VAR 0 2
10893: IFFALSE 10939
// for i in tmp do
10895: LD_ADDR_VAR 0 1
10899: PUSH
10900: LD_VAR 0 2
10904: PUSH
10905: FOR_IN
10906: IFFALSE 10937
// if GetFuel ( i ) < 3 then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 261
10917: PUSH
10918: LD_INT 3
10920: LESS
10921: IFFALSE 10935
// SetFuel ( i , 3 ) ;
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 3
10930: PPUSH
10931: CALL_OW 240
10935: GO 10905
10937: POP
10938: POP
// end ;
10939: PPOPN 2
10941: END
// every 0 0$1 trigger ( FilterUnitsInArea ( RU_Base_Area , [ f_side , 1 ] ) and not JMMArrival ) or ( FilterUnitsInArea ( US_BackOffArea , [ f_side , 1 ] ) and not FirstAssaultRepelled ) do
10942: LD_INT 3
10944: PPUSH
10945: LD_INT 22
10947: PUSH
10948: LD_INT 1
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: PPUSH
10955: CALL_OW 70
10959: PUSH
10960: LD_EXP 41
10964: NOT
10965: AND
10966: PUSH
10967: LD_INT 10
10969: PPUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 70
10984: PUSH
10985: LD_EXP 4
10989: NOT
10990: AND
10991: OR
10992: IFFALSE 11001
10994: GO 10996
10996: DISABLE
// Antirush ;
10997: CALL 11002 0 0
11001: END
// export function Antirush ; var i , veh , tmp , num ; begin
11002: LD_INT 0
11004: PPUSH
11005: PPUSH
11006: PPUSH
11007: PPUSH
11008: PPUSH
// tmp := [ ] ;
11009: LD_ADDR_VAR 0 4
11013: PUSH
11014: EMPTY
11015: ST_TO_ADDR
// if not FirstAssaultRepelled then
11016: LD_EXP 4
11020: NOT
11021: IFFALSE 11033
// num := 12 else
11023: LD_ADDR_VAR 0 5
11027: PUSH
11028: LD_INT 12
11030: ST_TO_ADDR
11031: GO 11041
// num := 10 ;
11033: LD_ADDR_VAR 0 5
11037: PUSH
11038: LD_INT 10
11040: ST_TO_ADDR
// num := num - [ 4 , 2 , 0 ] [ Difficulty ] ;
11041: LD_ADDR_VAR 0 5
11045: PUSH
11046: LD_VAR 0 5
11050: PUSH
11051: LD_INT 4
11053: PUSH
11054: LD_INT 2
11056: PUSH
11057: LD_INT 0
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: LIST
11064: PUSH
11065: LD_OWVAR 67
11069: ARRAY
11070: MINUS
11071: ST_TO_ADDR
// for i := 1 to num do
11072: LD_ADDR_VAR 0 2
11076: PUSH
11077: DOUBLE
11078: LD_INT 1
11080: DEC
11081: ST_TO_ADDR
11082: LD_VAR 0 5
11086: PUSH
11087: FOR_TO
11088: IFFALSE 11227
// begin uc_side := 3 ;
11090: LD_ADDR_OWVAR 20
11094: PUSH
11095: LD_INT 3
11097: ST_TO_ADDR
// uc_nation := 3 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 3
11105: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_computer , [ ru_heavy_gun , ru_gatling_gun ] [ rand ( 1 , 2 ) ] , 100 ) ;
11106: LD_INT 23
11108: PPUSH
11109: LD_INT 3
11111: PPUSH
11112: LD_INT 3
11114: PPUSH
11115: LD_INT 46
11117: PUSH
11118: LD_INT 43
11120: PUSH
11121: EMPTY
11122: LIST
11123: LIST
11124: PUSH
11125: LD_INT 1
11127: PPUSH
11128: LD_INT 2
11130: PPUSH
11131: CALL_OW 12
11135: ARRAY
11136: PPUSH
11137: LD_INT 100
11139: PPUSH
11140: CALL 18457 0 5
// veh := CreateVehicle ;
11144: LD_ADDR_VAR 0 3
11148: PUSH
11149: CALL_OW 45
11153: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
11154: LD_VAR 0 3
11158: PPUSH
11159: LD_INT 5
11161: PPUSH
11162: CALL_OW 233
// PlaceUnitXYR ( veh , 199 , 135 , 3 , false ) ;
11166: LD_VAR 0 3
11170: PPUSH
11171: LD_INT 199
11173: PPUSH
11174: LD_INT 135
11176: PPUSH
11177: LD_INT 3
11179: PPUSH
11180: LD_INT 0
11182: PPUSH
11183: CALL_OW 50
// tmp := tmp ^ veh ;
11187: LD_ADDR_VAR 0 4
11191: PUSH
11192: LD_VAR 0 4
11196: PUSH
11197: LD_VAR 0 3
11201: ADD
11202: ST_TO_ADDR
// ComMoveXY ( veh , 173 , 118 ) ;
11203: LD_VAR 0 3
11207: PPUSH
11208: LD_INT 173
11210: PPUSH
11211: LD_INT 118
11213: PPUSH
11214: CALL_OW 111
// wait ( 0 0$2 ) ;
11218: LD_INT 70
11220: PPUSH
11221: CALL_OW 67
// end ;
11225: GO 11087
11227: POP
11228: POP
// repeat wait ( 0 0$1 ) ;
11229: LD_INT 35
11231: PPUSH
11232: CALL_OW 67
// for i in tmp do
11236: LD_ADDR_VAR 0 2
11240: PUSH
11241: LD_VAR 0 4
11245: PUSH
11246: FOR_IN
11247: IFFALSE 11314
// if IsDead ( i ) then
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 301
11258: IFFALSE 11278
// tmp := tmp diff i else
11260: LD_ADDR_VAR 0 4
11264: PUSH
11265: LD_VAR 0 4
11269: PUSH
11270: LD_VAR 0 2
11274: DIFF
11275: ST_TO_ADDR
11276: GO 11312
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
11278: LD_VAR 0 2
11282: PPUSH
11283: LD_INT 22
11285: PUSH
11286: LD_INT 1
11288: PUSH
11289: EMPTY
11290: LIST
11291: LIST
11292: PPUSH
11293: CALL_OW 69
11297: PPUSH
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 74
11307: PPUSH
11308: CALL_OW 115
11312: GO 11246
11314: POP
11315: POP
// until not tmp ;
11316: LD_VAR 0 4
11320: NOT
11321: IFFALSE 11229
// end ; end_of_file
11323: LD_VAR 0 1
11327: RET
// export Losses ; on UnitDestroyed ( un ) do begin if un = Brighton then
11328: LD_VAR 0 1
11332: PUSH
11333: LD_EXP 9
11337: EQUAL
11338: IFFALSE 11354
// begin wait ( 0 0$1 ) ;
11340: LD_INT 35
11342: PPUSH
11343: CALL_OW 67
// YouLost ( Brighton ) ;
11347: LD_STRING Brighton
11349: PPUSH
11350: CALL_OW 104
// end ; if un = JMM then
11354: LD_VAR 0 1
11358: PUSH
11359: LD_EXP 37
11363: EQUAL
11364: IFFALSE 11380
// begin wait ( 0 0$1 ) ;
11366: LD_INT 35
11368: PPUSH
11369: CALL_OW 67
// YouLost ( JMM ) ;
11373: LD_STRING JMM
11375: PPUSH
11376: CALL_OW 104
// end ; if un = Megan then
11380: LD_VAR 0 1
11384: PUSH
11385: LD_EXP 11
11389: EQUAL
11390: IFFALSE 11404
// begin Say ( Brighton , DBrighton-MeganDeath ) ;
11392: LD_EXP 9
11396: PPUSH
11397: LD_STRING DBrighton-MeganDeath
11399: PPUSH
11400: CALL_OW 88
// end ; if un = Palmer then
11404: LD_VAR 0 1
11408: PUSH
11409: LD_EXP 10
11413: EQUAL
11414: IFFALSE 11428
// begin Say ( Brighton , DBrighton-PalmerDeath ) ;
11416: LD_EXP 9
11420: PPUSH
11421: LD_STRING DBrighton-PalmerDeath
11423: PPUSH
11424: CALL_OW 88
// end ; if un = Burlak then
11428: LD_VAR 0 1
11432: PUSH
11433: LD_EXP 19
11437: EQUAL
11438: IFFALSE 11470
// begin if JMM_Arrived then
11440: LD_EXP 6
11444: IFFALSE 11458
// Say ( JMM , DJMM-BurlakDead ) ;
11446: LD_EXP 37
11450: PPUSH
11451: LD_STRING DJMM-BurlakDead
11453: PPUSH
11454: CALL_OW 88
// Say ( Palmer , DSol-BurlakDead ) ;
11458: LD_EXP 10
11462: PPUSH
11463: LD_STRING DSol-BurlakDead
11465: PPUSH
11466: CALL_OW 88
// end ; if un = BetaA or un = BetaB then
11470: LD_VAR 0 1
11474: PUSH
11475: LD_INT 1
11477: EQUAL
11478: PUSH
11479: LD_VAR 0 1
11483: PUSH
11484: LD_INT 3
11486: EQUAL
11487: OR
11488: IFFALSE 11504
// begin wait ( 0 0$1 ) ;
11490: LD_INT 35
11492: PPUSH
11493: CALL_OW 67
// YouLost ( Depot ) ;
11497: LD_STRING Depot
11499: PPUSH
11500: CALL_OW 104
// end ; if GetSide ( un ) = 1 and GetType ( un ) = unit_human then
11504: LD_VAR 0 1
11508: PPUSH
11509: CALL_OW 255
11513: PUSH
11514: LD_INT 1
11516: EQUAL
11517: PUSH
11518: LD_VAR 0 1
11522: PPUSH
11523: CALL_OW 247
11527: PUSH
11528: LD_INT 1
11530: EQUAL
11531: AND
11532: IFFALSE 11548
// Losses := Losses + 1 ;
11534: LD_ADDR_EXP 45
11538: PUSH
11539: LD_EXP 45
11543: PUSH
11544: LD_INT 1
11546: PLUS
11547: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11548: LD_VAR 0 1
11552: PPUSH
11553: CALL 77490 0 1
// end ;
11557: PPOPN 1
11559: END
// on UnitGoesToRed ( un ) do begin if un = Yashin then
11560: LD_VAR 0 1
11564: PUSH
11565: LD_EXP 13
11569: EQUAL
11570: IFFALSE 11584
// ForceSay ( Yashin , DDeath-Yas-3 ) ;
11572: LD_EXP 13
11576: PPUSH
11577: LD_STRING DDeath-Yas-3
11579: PPUSH
11580: CALL_OW 91
// if un = Popov then
11584: LD_VAR 0 1
11588: PUSH
11589: LD_EXP 14
11593: EQUAL
11594: IFFALSE 11608
// ForceSay ( Popov , DDeath-Pop-3 ) ;
11596: LD_EXP 14
11600: PPUSH
11601: LD_STRING DDeath-Pop-3
11603: PPUSH
11604: CALL_OW 91
// if un = Gaydar then
11608: LD_VAR 0 1
11612: PUSH
11613: LD_EXP 15
11617: EQUAL
11618: IFFALSE 11632
// ForceSay ( Gaydar , DDeath-Gay-3 ) ;
11620: LD_EXP 15
11624: PPUSH
11625: LD_STRING DDeath-Gay-3
11627: PPUSH
11628: CALL_OW 91
// if un = Sevi then
11632: LD_VAR 0 1
11636: PUSH
11637: LD_EXP 16
11641: EQUAL
11642: IFFALSE 11656
// ForceSay ( Sevi , DDeath-Vse-3 ) ;
11644: LD_EXP 16
11648: PPUSH
11649: LD_STRING DDeath-Vse-3
11651: PPUSH
11652: CALL_OW 91
// end ;
11656: PPOPN 1
11658: END
// on ResearchComplete ( tech , lab ) do begin if tech = tech_laser then
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 10
11666: EQUAL
11667: IFFALSE 11705
// begin Say ( Brighton , DBrighton-C1 ) ;
11669: LD_EXP 9
11673: PPUSH
11674: LD_STRING DBrighton-C1
11676: PPUSH
11677: CALL_OW 88
// Say ( Megan , DMegan-C1 ) ;
11681: LD_EXP 11
11685: PPUSH
11686: LD_STRING DMegan-C1
11688: PPUSH
11689: CALL_OW 88
// Say ( Brighton , DBrighton-C2 ) ;
11693: LD_EXP 9
11697: PPUSH
11698: LD_STRING DBrighton-C2
11700: PPUSH
11701: CALL_OW 88
// end ; MCE_ResearchComplete ( tech , lab ) ;
11705: LD_VAR 0 1
11709: PPUSH
11710: LD_VAR 0 2
11714: PPUSH
11715: CALL 77186 0 2
// end ;
11719: PPOPN 2
11721: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_VAR 0 2
11731: PPUSH
11732: CALL 79824 0 2
// end ;
11736: PPOPN 2
11738: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11739: LD_VAR 0 1
11743: PPUSH
11744: CALL 78892 0 1
// end ;
11748: PPOPN 1
11750: END
// export RUFirstDepot ; on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 3 then
11751: LD_VAR 0 1
11755: PPUSH
11756: CALL_OW 266
11760: PUSH
11761: LD_INT 0
11763: EQUAL
11764: PUSH
11765: LD_VAR 0 1
11769: PPUSH
11770: CALL_OW 255
11774: PUSH
11775: LD_INT 3
11777: EQUAL
11778: AND
11779: IFFALSE 11841
// begin SetResourceType ( GetBase ( b ) , mat_cans , 10000 ) ;
11781: LD_VAR 0 1
11785: PPUSH
11786: CALL_OW 274
11790: PPUSH
11791: LD_INT 1
11793: PPUSH
11794: LD_INT 10000
11796: PPUSH
11797: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_oil , 250 ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: CALL_OW 274
11810: PPUSH
11811: LD_INT 2
11813: PPUSH
11814: LD_INT 250
11816: PPUSH
11817: CALL_OW 277
// SetResourceType ( GetBase ( b ) , mat_siberit , 100 ) ;
11821: LD_VAR 0 1
11825: PPUSH
11826: CALL_OW 274
11830: PPUSH
11831: LD_INT 3
11833: PPUSH
11834: LD_INT 100
11836: PPUSH
11837: CALL_OW 277
// end ; MCE_BuildingComplete ( b ) ;
11841: LD_VAR 0 1
11845: PPUSH
11846: CALL 79133 0 1
// end ;
11850: PPOPN 1
11852: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11853: LD_VAR 0 1
11857: PPUSH
11858: LD_VAR 0 2
11862: PPUSH
11863: LD_VAR 0 3
11867: PPUSH
11868: LD_VAR 0 4
11872: PPUSH
11873: LD_VAR 0 5
11877: PPUSH
11878: CALL 76806 0 5
// end ;
11882: PPOPN 5
11884: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11885: LD_VAR 0 1
11889: PPUSH
11890: LD_VAR 0 2
11894: PPUSH
11895: CALL 76402 0 2
// end ;
11899: PPOPN 2
11901: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11902: LD_VAR 0 1
11906: PPUSH
11907: LD_VAR 0 2
11911: PPUSH
11912: LD_VAR 0 3
11916: PPUSH
11917: LD_VAR 0 4
11921: PPUSH
11922: CALL 76240 0 4
// end ;
11926: PPOPN 4
11928: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11929: LD_VAR 0 1
11933: PPUSH
11934: LD_VAR 0 2
11938: PPUSH
11939: LD_VAR 0 3
11943: PPUSH
11944: CALL 76015 0 3
// end ;
11948: PPOPN 3
11950: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11951: LD_VAR 0 1
11955: PPUSH
11956: LD_VAR 0 2
11960: PPUSH
11961: CALL 75900 0 2
// end ;
11965: PPOPN 2
11967: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11968: LD_VAR 0 1
11972: PPUSH
11973: LD_VAR 0 2
11977: PPUSH
11978: CALL 80085 0 2
// end ;
11982: PPOPN 2
11984: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 6 then
11985: LD_VAR 0 1
11989: PPUSH
11990: CALL_OW 255
11994: PUSH
11995: LD_INT 6
11997: EQUAL
11998: IFFALSE 12128
// begin if driver in [ Yashin , Sevi , Gaydar , Popov ] then
12000: LD_VAR 0 1
12004: PUSH
12005: LD_EXP 13
12009: PUSH
12010: LD_EXP 16
12014: PUSH
12015: LD_EXP 15
12019: PUSH
12020: LD_EXP 14
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: LIST
12029: LIST
12030: IN
12031: IFFALSE 12035
// exit ;
12033: GO 12152
// if AssaultStarted then
12035: LD_EXP 8
12039: IFFALSE 12113
// case Rand ( 1 , 4 ) of 1 .. 3 :
12041: LD_INT 1
12043: PPUSH
12044: LD_INT 4
12046: PPUSH
12047: CALL_OW 12
12051: PUSH
12052: LD_INT 1
12054: DOUBLE
12055: GREATEREQUAL
12056: IFFALSE 12064
12058: LD_INT 3
12060: DOUBLE
12061: LESSEQUAL
12062: IFTRUE 12066
12064: GO 12084
12066: POP
// ComAgressiveMove ( driver , 67 , 37 ) ; 4 :
12067: LD_VAR 0 1
12071: PPUSH
12072: LD_INT 67
12074: PPUSH
12075: LD_INT 37
12077: PPUSH
12078: CALL_OW 114
12082: GO 12111
12084: LD_INT 4
12086: DOUBLE
12087: EQUAL
12088: IFTRUE 12092
12090: GO 12110
12092: POP
// ComMoveXY ( driver , 120 , 131 ) ; end else
12093: LD_VAR 0 1
12097: PPUSH
12098: LD_INT 120
12100: PPUSH
12101: LD_INT 131
12103: PPUSH
12104: CALL_OW 111
12108: GO 12111
12110: POP
12111: GO 12128
// ComMoveXY ( driver , 120 , 131 ) ;
12113: LD_VAR 0 1
12117: PPUSH
12118: LD_INT 120
12120: PPUSH
12121: LD_INT 131
12123: PPUSH
12124: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12128: LD_VAR 0 1
12132: PPUSH
12133: LD_VAR 0 2
12137: PPUSH
12138: LD_VAR 0 3
12142: PPUSH
12143: LD_VAR 0 4
12147: PPUSH
12148: CALL 80301 0 4
// end ;
12152: PPOPN 4
12154: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12155: LD_VAR 0 1
12159: PPUSH
12160: LD_VAR 0 2
12164: PPUSH
12165: CALL 75709 0 2
// end ;
12169: PPOPN 2
12171: END
// on Command ( cmd ) do var i ;
12172: LD_INT 0
12174: PPUSH
// begin if cmd = 77 and southAreaBlocker then
12175: LD_VAR 0 1
12179: PUSH
12180: LD_INT 77
12182: EQUAL
12183: PUSH
12184: LD_EXP 2
12188: AND
12189: IFFALSE 12265
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12191: LD_ADDR_VAR 0 2
12195: PUSH
12196: LD_INT 22
12198: PUSH
12199: LD_INT 1
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 2
12208: PUSH
12209: LD_INT 21
12211: PUSH
12212: LD_INT 1
12214: PUSH
12215: EMPTY
12216: LIST
12217: LIST
12218: PUSH
12219: LD_INT 21
12221: PUSH
12222: LD_INT 2
12224: PUSH
12225: EMPTY
12226: LIST
12227: LIST
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: LIST
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PPUSH
12238: CALL_OW 69
12242: PUSH
12243: FOR_IN
12244: IFFALSE 12263
// NotGoToAreaUnit ( i , SouthAreaBlock , SouthAreaGoAway ) ;
12246: LD_VAR 0 2
12250: PPUSH
12251: LD_INT 20
12253: PPUSH
12254: LD_INT 19
12256: PPUSH
12257: CALL 50113 0 3
12261: GO 12243
12263: POP
12264: POP
// end ; SOS_Command ( cmd ) ;
12265: LD_VAR 0 1
12269: PPUSH
12270: CALL 93715 0 1
// end ;
12274: PPOPN 2
12276: END
// every 0 0$1 trigger southAreaBlocker and FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do var i ;
12277: LD_EXP 2
12281: PUSH
12282: LD_INT 16
12284: PPUSH
12285: LD_INT 22
12287: PUSH
12288: LD_INT 1
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: LD_INT 2
12297: PUSH
12298: LD_INT 21
12300: PUSH
12301: LD_INT 1
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: PUSH
12308: LD_INT 21
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: LIST
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: PPUSH
12327: CALL_OW 70
12331: AND
12332: IFFALSE 12418
12334: GO 12336
12336: DISABLE
12337: LD_INT 0
12339: PPUSH
// begin enable ;
12340: ENABLE
// for i in FilterUnitsInArea ( SouthArea , [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) do
12341: LD_ADDR_VAR 0 1
12345: PUSH
12346: LD_INT 16
12348: PPUSH
12349: LD_INT 22
12351: PUSH
12352: LD_INT 1
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: PUSH
12359: LD_INT 2
12361: PUSH
12362: LD_INT 21
12364: PUSH
12365: LD_INT 1
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: LD_INT 21
12374: PUSH
12375: LD_INT 2
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: LIST
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PPUSH
12391: CALL_OW 70
12395: PUSH
12396: FOR_IN
12397: IFFALSE 12416
// NotGoToAreaUnit ( i , SouthAreaOutside , SouthAreaGoAway ) ;
12399: LD_VAR 0 1
12403: PPUSH
12404: LD_INT 18
12406: PPUSH
12407: LD_INT 19
12409: PPUSH
12410: CALL 50113 0 3
12414: GO 12396
12416: POP
12417: POP
// end ; end_of_file
12418: PPOPN 1
12420: END
// every 0 0$1 trigger JMM_Arrived and RussiansDefeated do
12421: LD_EXP 6
12425: PUSH
12426: LD_EXP 44
12430: AND
12431: IFFALSE 12602
12433: GO 12435
12435: DISABLE
// begin wait ( 0 0$2 ) ;
12436: LD_INT 70
12438: PPUSH
12439: CALL_OW 67
// Say ( Brighton , DBrighton-G1 ) ;
12443: LD_EXP 9
12447: PPUSH
12448: LD_STRING DBrighton-G1
12450: PPUSH
12451: CALL_OW 88
// if Losses < 1 then
12455: LD_EXP 45
12459: PUSH
12460: LD_INT 1
12462: LESS
12463: IFFALSE 12477
// AddMedal ( Losses , 1 ) else
12465: LD_STRING Losses
12467: PPUSH
12468: LD_INT 1
12470: PPUSH
12471: CALL_OW 101
12475: GO 12510
// if Losses < 5 then
12477: LD_EXP 45
12481: PUSH
12482: LD_INT 5
12484: LESS
12485: IFFALSE 12499
// AddMedal ( Losses , 2 ) else
12487: LD_STRING Losses
12489: PPUSH
12490: LD_INT 2
12492: PPUSH
12493: CALL_OW 101
12497: GO 12510
// AddMedal ( Losses , - 1 ) ;
12499: LD_STRING Losses
12501: PPUSH
12502: LD_INT 1
12504: NEG
12505: PPUSH
12506: CALL_OW 101
// if LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12510: LD_EXP 7
12514: PUSH
12515: LD_INT 10
12517: PPUSH
12518: LD_INT 1
12520: PPUSH
12521: CALL_OW 321
12525: PUSH
12526: LD_INT 2
12528: EQUAL
12529: AND
12530: IFFALSE 12544
// AddMedal ( Laser , 1 ) else
12532: LD_STRING Laser
12534: PPUSH
12535: LD_INT 1
12537: PPUSH
12538: CALL_OW 101
12542: GO 12591
// if not LaserBuilt and GetTech ( tech_laser , 1 ) = state_researched then
12544: LD_EXP 7
12548: NOT
12549: PUSH
12550: LD_INT 10
12552: PPUSH
12553: LD_INT 1
12555: PPUSH
12556: CALL_OW 321
12560: PUSH
12561: LD_INT 2
12563: EQUAL
12564: AND
12565: IFFALSE 12580
// AddMedal ( Laser , - 1 ) else
12567: LD_STRING Laser
12569: PPUSH
12570: LD_INT 1
12572: NEG
12573: PPUSH
12574: CALL_OW 101
12578: GO 12591
// AddMedal ( Laser , - 2 ) ;
12580: LD_STRING Laser
12582: PPUSH
12583: LD_INT 2
12585: NEG
12586: PPUSH
12587: CALL_OW 101
// GiveMedals ( BaseMain ) ;
12591: LD_STRING BaseMain
12593: PPUSH
12594: CALL_OW 102
// YouWin ;
12598: CALL_OW 103
// end ; end_of_file
12602: END
// export rows ; export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
12603: LD_INT 0
12605: PPUSH
12606: PPUSH
// area = ListEnvironmentArea ( area ) ;
12607: LD_ADDR_VAR 0 2
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 353
12621: ST_TO_ADDR
// if bulldozer > 0 then
12622: LD_VAR 0 1
12626: PUSH
12627: LD_INT 0
12629: GREATER
12630: IFFALSE 12741
// for i = area downto 1 do
12632: LD_ADDR_VAR 0 4
12636: PUSH
12637: DOUBLE
12638: LD_VAR 0 2
12642: INC
12643: ST_TO_ADDR
12644: LD_INT 1
12646: PUSH
12647: FOR_DOWNTO
12648: IFFALSE 12739
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
12650: LD_VAR 0 2
12654: PUSH
12655: LD_VAR 0 4
12659: ARRAY
12660: PUSH
12661: LD_INT 1
12663: ARRAY
12664: PPUSH
12665: LD_VAR 0 2
12669: PUSH
12670: LD_VAR 0 4
12674: ARRAY
12675: PUSH
12676: LD_INT 2
12678: ARRAY
12679: PPUSH
12680: CALL_OW 351
12684: IFFALSE 12737
// if not HasTask ( bulldozer ) then
12686: LD_VAR 0 1
12690: PPUSH
12691: CALL_OW 314
12695: NOT
12696: IFFALSE 12737
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
12698: LD_VAR 0 1
12702: PPUSH
12703: LD_VAR 0 2
12707: PUSH
12708: LD_VAR 0 4
12712: ARRAY
12713: PUSH
12714: LD_INT 1
12716: ARRAY
12717: PPUSH
12718: LD_VAR 0 2
12722: PUSH
12723: LD_VAR 0 4
12727: ARRAY
12728: PUSH
12729: LD_INT 2
12731: ARRAY
12732: PPUSH
12733: CALL_OW 171
12737: GO 12647
12739: POP
12740: POP
// end ;
12741: LD_VAR 0 3
12745: RET
// export function ComMeeting ( team , area ) ; var i , x , tmp , offset , sold_team , civil_team ; begin
12746: LD_INT 0
12748: PPUSH
12749: PPUSH
12750: PPUSH
12751: PPUSH
12752: PPUSH
12753: PPUSH
12754: PPUSH
// sold_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_class , class_soldier ] ] ) ;
12755: LD_ADDR_VAR 0 8
12759: PUSH
12760: LD_VAR 0 1
12764: PPUSH
12765: LD_INT 22
12767: PUSH
12768: LD_INT 1
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 21
12777: PUSH
12778: LD_INT 1
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 1
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: PPUSH
12800: CALL_OW 72
12804: ST_TO_ADDR
// civil_team = UnitFilter ( team , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_class , class_soldier ] ] ] ) ;
12805: LD_ADDR_VAR 0 9
12809: PUSH
12810: LD_VAR 0 1
12814: PPUSH
12815: LD_INT 22
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 21
12827: PUSH
12828: LD_INT 1
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: PUSH
12835: LD_INT 3
12837: PUSH
12838: LD_INT 25
12840: PUSH
12841: LD_INT 1
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 72
12861: ST_TO_ADDR
// rows = MakeRows ( sold_team , civil_team ) ;
12862: LD_ADDR_EXP 47
12866: PUSH
12867: LD_VAR 0 8
12871: PPUSH
12872: LD_VAR 0 9
12876: PPUSH
12877: CALL 13270 0 2
12881: ST_TO_ADDR
// offset = 0 ;
12882: LD_ADDR_VAR 0 7
12886: PUSH
12887: LD_INT 0
12889: ST_TO_ADDR
// for i := 1 to sold_team do
12890: LD_ADDR_VAR 0 4
12894: PUSH
12895: DOUBLE
12896: LD_INT 1
12898: DEC
12899: ST_TO_ADDR
12900: LD_VAR 0 8
12904: PUSH
12905: FOR_TO
12906: IFFALSE 13037
// begin if IsInUnit ( sold_team [ i ] ) then
12908: LD_VAR 0 8
12912: PUSH
12913: LD_VAR 0 4
12917: ARRAY
12918: PPUSH
12919: CALL_OW 310
12923: IFFALSE 12940
// ComExitBuilding ( sold_team [ i ] ) ;
12925: LD_VAR 0 8
12929: PUSH
12930: LD_VAR 0 4
12934: ARRAY
12935: PPUSH
12936: CALL_OW 122
// AddComMoveXY ( sold_team [ i ] , rows [ 1 ] [ i + offset ] , rows [ 1 ] [ i + 1 + offset ] ) ;
12940: LD_VAR 0 8
12944: PUSH
12945: LD_VAR 0 4
12949: ARRAY
12950: PPUSH
12951: LD_EXP 47
12955: PUSH
12956: LD_INT 1
12958: ARRAY
12959: PUSH
12960: LD_VAR 0 4
12964: PUSH
12965: LD_VAR 0 7
12969: PLUS
12970: ARRAY
12971: PPUSH
12972: LD_EXP 47
12976: PUSH
12977: LD_INT 1
12979: ARRAY
12980: PUSH
12981: LD_VAR 0 4
12985: PUSH
12986: LD_INT 1
12988: PLUS
12989: PUSH
12990: LD_VAR 0 7
12994: PLUS
12995: ARRAY
12996: PPUSH
12997: CALL_OW 171
// AddComTurnUnit ( sold_team [ i ] , Brighton ) ;
13001: LD_VAR 0 8
13005: PUSH
13006: LD_VAR 0 4
13010: ARRAY
13011: PPUSH
13012: LD_EXP 9
13016: PPUSH
13017: CALL_OW 179
// offset = offset + 1 ;
13021: LD_ADDR_VAR 0 7
13025: PUSH
13026: LD_VAR 0 7
13030: PUSH
13031: LD_INT 1
13033: PLUS
13034: ST_TO_ADDR
// end ;
13035: GO 12905
13037: POP
13038: POP
// offset = 0 ;
13039: LD_ADDR_VAR 0 7
13043: PUSH
13044: LD_INT 0
13046: ST_TO_ADDR
// tmp = 1 ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// for i := 2 to rows do
13055: LD_ADDR_VAR 0 4
13059: PUSH
13060: DOUBLE
13061: LD_INT 2
13063: DEC
13064: ST_TO_ADDR
13065: LD_EXP 47
13069: PUSH
13070: FOR_TO
13071: IFFALSE 13263
// begin for x := 1 to sold_team do
13073: LD_ADDR_VAR 0 5
13077: PUSH
13078: DOUBLE
13079: LD_INT 1
13081: DEC
13082: ST_TO_ADDR
13083: LD_VAR 0 8
13087: PUSH
13088: FOR_TO
13089: IFFALSE 13251
// begin if IsInUnit ( civil_team [ tmp ] ) then
13091: LD_VAR 0 9
13095: PUSH
13096: LD_VAR 0 6
13100: ARRAY
13101: PPUSH
13102: CALL_OW 310
13106: IFFALSE 13123
// ComExitBuilding ( civil_team [ tmp ] ) ;
13108: LD_VAR 0 9
13112: PUSH
13113: LD_VAR 0 6
13117: ARRAY
13118: PPUSH
13119: CALL_OW 122
// AddComMoveXY ( civil_team [ tmp ] , rows [ i ] [ x + offset ] , rows [ i ] [ x + 1 + offset ] ) ;
13123: LD_VAR 0 9
13127: PUSH
13128: LD_VAR 0 6
13132: ARRAY
13133: PPUSH
13134: LD_EXP 47
13138: PUSH
13139: LD_VAR 0 4
13143: ARRAY
13144: PUSH
13145: LD_VAR 0 5
13149: PUSH
13150: LD_VAR 0 7
13154: PLUS
13155: ARRAY
13156: PPUSH
13157: LD_EXP 47
13161: PUSH
13162: LD_VAR 0 4
13166: ARRAY
13167: PUSH
13168: LD_VAR 0 5
13172: PUSH
13173: LD_INT 1
13175: PLUS
13176: PUSH
13177: LD_VAR 0 7
13181: PLUS
13182: ARRAY
13183: PPUSH
13184: CALL_OW 171
// AddComTurnUnit ( civil_team [ tmp ] , Brighton ) ;
13188: LD_VAR 0 9
13192: PUSH
13193: LD_VAR 0 6
13197: ARRAY
13198: PPUSH
13199: LD_EXP 9
13203: PPUSH
13204: CALL_OW 179
// offset = offset + 1 ;
13208: LD_ADDR_VAR 0 7
13212: PUSH
13213: LD_VAR 0 7
13217: PUSH
13218: LD_INT 1
13220: PLUS
13221: ST_TO_ADDR
// if not ( tmp = civil_team ) then
13222: LD_VAR 0 6
13226: PUSH
13227: LD_VAR 0 9
13231: EQUAL
13232: NOT
13233: IFFALSE 13249
// tmp = tmp + 1 ;
13235: LD_ADDR_VAR 0 6
13239: PUSH
13240: LD_VAR 0 6
13244: PUSH
13245: LD_INT 1
13247: PLUS
13248: ST_TO_ADDR
// end ;
13249: GO 13088
13251: POP
13252: POP
// offset = 0 ;
13253: LD_ADDR_VAR 0 7
13257: PUSH
13258: LD_INT 0
13260: ST_TO_ADDR
// end ;
13261: GO 13070
13263: POP
13264: POP
// end ;
13265: LD_VAR 0 3
13269: RET
// export function MakeRows ( sold_team , civil_team ) ; var i , x , start_pos , row_size , new_row , result_rows , civil_rows , offsetX , offsetY ; begin
13270: LD_INT 0
13272: PPUSH
13273: PPUSH
13274: PPUSH
13275: PPUSH
13276: PPUSH
13277: PPUSH
13278: PPUSH
13279: PPUSH
13280: PPUSH
13281: PPUSH
// start_pos = [ 65 , 34 ] ;
13282: LD_ADDR_VAR 0 6
13286: PUSH
13287: LD_INT 65
13289: PUSH
13290: LD_INT 34
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: ST_TO_ADDR
// row_size = 0 ;
13297: LD_ADDR_VAR 0 7
13301: PUSH
13302: LD_INT 0
13304: ST_TO_ADDR
// result_rows = [ ] ;
13305: LD_ADDR_VAR 0 9
13309: PUSH
13310: EMPTY
13311: ST_TO_ADDR
// new_row = [ ] ;
13312: LD_ADDR_VAR 0 8
13316: PUSH
13317: EMPTY
13318: ST_TO_ADDR
// for i := 1 to sold_team do
13319: LD_ADDR_VAR 0 4
13323: PUSH
13324: DOUBLE
13325: LD_INT 1
13327: DEC
13328: ST_TO_ADDR
13329: LD_VAR 0 1
13333: PUSH
13334: FOR_TO
13335: IFFALSE 13389
// begin new_row = new_row ^ start_pos [ 1 ] ^ start_pos [ 2 ] + i ;
13337: LD_ADDR_VAR 0 8
13341: PUSH
13342: LD_VAR 0 8
13346: PUSH
13347: LD_VAR 0 6
13351: PUSH
13352: LD_INT 1
13354: ARRAY
13355: ADD
13356: PUSH
13357: LD_VAR 0 6
13361: PUSH
13362: LD_INT 2
13364: ARRAY
13365: PUSH
13366: LD_VAR 0 4
13370: PLUS
13371: ADD
13372: ST_TO_ADDR
// row_size = row_size + 1 ;
13373: LD_ADDR_VAR 0 7
13377: PUSH
13378: LD_VAR 0 7
13382: PUSH
13383: LD_INT 1
13385: PLUS
13386: ST_TO_ADDR
// end ;
13387: GO 13334
13389: POP
13390: POP
// result_rows = result_rows ^ [ new_row ] ;
13391: LD_ADDR_VAR 0 9
13395: PUSH
13396: LD_VAR 0 9
13400: PUSH
13401: LD_VAR 0 8
13405: PUSH
13406: EMPTY
13407: LIST
13408: ADD
13409: ST_TO_ADDR
// civil_rows = civil_team div sold_team ;
13410: LD_ADDR_VAR 0 10
13414: PUSH
13415: LD_VAR 0 2
13419: PUSH
13420: LD_VAR 0 1
13424: DIV
13425: ST_TO_ADDR
// if ( civil_rows mod sold_team > 0 ) then
13426: LD_VAR 0 10
13430: PUSH
13431: LD_VAR 0 1
13435: MOD
13436: PUSH
13437: LD_INT 0
13439: GREATER
13440: IFFALSE 13456
// civil_rows = civil_rows + 1 ;
13442: LD_ADDR_VAR 0 10
13446: PUSH
13447: LD_VAR 0 10
13451: PUSH
13452: LD_INT 1
13454: PLUS
13455: ST_TO_ADDR
// offsetX = 2 ;
13456: LD_ADDR_VAR 0 11
13460: PUSH
13461: LD_INT 2
13463: ST_TO_ADDR
// offsetY = 1 ;
13464: LD_ADDR_VAR 0 12
13468: PUSH
13469: LD_INT 1
13471: ST_TO_ADDR
// for i := 1 to civil_rows do
13472: LD_ADDR_VAR 0 4
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 10
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13616
// begin new_row = [ ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: EMPTY
13496: ST_TO_ADDR
// for x := 1 to row_size do
13497: LD_ADDR_VAR 0 5
13501: PUSH
13502: DOUBLE
13503: LD_INT 1
13505: DEC
13506: ST_TO_ADDR
13507: LD_VAR 0 7
13511: PUSH
13512: FOR_TO
13513: IFFALSE 13565
// begin new_row = new_row ^ start_pos [ 1 ] + offsetX ^ start_pos [ 2 ] + offsetY + x ;
13515: LD_ADDR_VAR 0 8
13519: PUSH
13520: LD_VAR 0 8
13524: PUSH
13525: LD_VAR 0 6
13529: PUSH
13530: LD_INT 1
13532: ARRAY
13533: PUSH
13534: LD_VAR 0 11
13538: PLUS
13539: ADD
13540: PUSH
13541: LD_VAR 0 6
13545: PUSH
13546: LD_INT 2
13548: ARRAY
13549: PUSH
13550: LD_VAR 0 12
13554: PLUS
13555: PUSH
13556: LD_VAR 0 5
13560: PLUS
13561: ADD
13562: ST_TO_ADDR
// end ;
13563: GO 13512
13565: POP
13566: POP
// result_rows = result_rows ^ [ new_row ] ;
13567: LD_ADDR_VAR 0 9
13571: PUSH
13572: LD_VAR 0 9
13576: PUSH
13577: LD_VAR 0 8
13581: PUSH
13582: EMPTY
13583: LIST
13584: ADD
13585: ST_TO_ADDR
// offsetX = offsetX + 2 ;
13586: LD_ADDR_VAR 0 11
13590: PUSH
13591: LD_VAR 0 11
13595: PUSH
13596: LD_INT 2
13598: PLUS
13599: ST_TO_ADDR
// offsetY = offsetY + 1 ;
13600: LD_ADDR_VAR 0 12
13604: PUSH
13605: LD_VAR 0 12
13609: PUSH
13610: LD_INT 1
13612: PLUS
13613: ST_TO_ADDR
// end ;
13614: GO 13487
13616: POP
13617: POP
// result = result_rows ;
13618: LD_ADDR_VAR 0 3
13622: PUSH
13623: LD_VAR 0 9
13627: ST_TO_ADDR
// end ; end_of_file
13628: LD_VAR 0 3
13632: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13633: LD_INT 0
13635: PPUSH
13636: PPUSH
// if exist_mode then
13637: LD_VAR 0 2
13641: IFFALSE 13666
// unit := CreateCharacter ( prefix & ident ) else
13643: LD_ADDR_VAR 0 5
13647: PUSH
13648: LD_VAR 0 3
13652: PUSH
13653: LD_VAR 0 1
13657: STR
13658: PPUSH
13659: CALL_OW 34
13663: ST_TO_ADDR
13664: GO 13681
// unit := NewCharacter ( ident ) ;
13666: LD_ADDR_VAR 0 5
13670: PUSH
13671: LD_VAR 0 1
13675: PPUSH
13676: CALL_OW 25
13680: ST_TO_ADDR
// result := unit ;
13681: LD_ADDR_VAR 0 4
13685: PUSH
13686: LD_VAR 0 5
13690: ST_TO_ADDR
// end ;
13691: LD_VAR 0 4
13695: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13696: LD_INT 0
13698: PPUSH
13699: PPUSH
// if not side or not nation then
13700: LD_VAR 0 1
13704: NOT
13705: PUSH
13706: LD_VAR 0 2
13710: NOT
13711: OR
13712: IFFALSE 13716
// exit ;
13714: GO 14480
// case nation of nation_american :
13716: LD_VAR 0 2
13720: PUSH
13721: LD_INT 1
13723: DOUBLE
13724: EQUAL
13725: IFTRUE 13729
13727: GO 13943
13729: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
13730: LD_ADDR_VAR 0 4
13734: PUSH
13735: LD_INT 35
13737: PUSH
13738: LD_INT 45
13740: PUSH
13741: LD_INT 46
13743: PUSH
13744: LD_INT 47
13746: PUSH
13747: LD_INT 82
13749: PUSH
13750: LD_INT 83
13752: PUSH
13753: LD_INT 84
13755: PUSH
13756: LD_INT 85
13758: PUSH
13759: LD_INT 86
13761: PUSH
13762: LD_INT 1
13764: PUSH
13765: LD_INT 2
13767: PUSH
13768: LD_INT 6
13770: PUSH
13771: LD_INT 15
13773: PUSH
13774: LD_INT 16
13776: PUSH
13777: LD_INT 7
13779: PUSH
13780: LD_INT 12
13782: PUSH
13783: LD_INT 13
13785: PUSH
13786: LD_INT 10
13788: PUSH
13789: LD_INT 14
13791: PUSH
13792: LD_INT 20
13794: PUSH
13795: LD_INT 21
13797: PUSH
13798: LD_INT 22
13800: PUSH
13801: LD_INT 25
13803: PUSH
13804: LD_INT 32
13806: PUSH
13807: LD_INT 27
13809: PUSH
13810: LD_INT 36
13812: PUSH
13813: LD_INT 69
13815: PUSH
13816: LD_INT 39
13818: PUSH
13819: LD_INT 34
13821: PUSH
13822: LD_INT 40
13824: PUSH
13825: LD_INT 48
13827: PUSH
13828: LD_INT 49
13830: PUSH
13831: LD_INT 50
13833: PUSH
13834: LD_INT 51
13836: PUSH
13837: LD_INT 52
13839: PUSH
13840: LD_INT 53
13842: PUSH
13843: LD_INT 54
13845: PUSH
13846: LD_INT 55
13848: PUSH
13849: LD_INT 56
13851: PUSH
13852: LD_INT 57
13854: PUSH
13855: LD_INT 58
13857: PUSH
13858: LD_INT 59
13860: PUSH
13861: LD_INT 60
13863: PUSH
13864: LD_INT 61
13866: PUSH
13867: LD_INT 62
13869: PUSH
13870: LD_INT 80
13872: PUSH
13873: LD_INT 82
13875: PUSH
13876: LD_INT 83
13878: PUSH
13879: LD_INT 84
13881: PUSH
13882: LD_INT 85
13884: PUSH
13885: LD_INT 86
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: ST_TO_ADDR
13941: GO 14404
13943: LD_INT 2
13945: DOUBLE
13946: EQUAL
13947: IFTRUE 13951
13949: GO 14173
13951: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
13952: LD_ADDR_VAR 0 4
13956: PUSH
13957: LD_INT 35
13959: PUSH
13960: LD_INT 45
13962: PUSH
13963: LD_INT 46
13965: PUSH
13966: LD_INT 47
13968: PUSH
13969: LD_INT 82
13971: PUSH
13972: LD_INT 83
13974: PUSH
13975: LD_INT 84
13977: PUSH
13978: LD_INT 85
13980: PUSH
13981: LD_INT 87
13983: PUSH
13984: LD_INT 70
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 11
13992: PUSH
13993: LD_INT 3
13995: PUSH
13996: LD_INT 4
13998: PUSH
13999: LD_INT 5
14001: PUSH
14002: LD_INT 6
14004: PUSH
14005: LD_INT 15
14007: PUSH
14008: LD_INT 18
14010: PUSH
14011: LD_INT 7
14013: PUSH
14014: LD_INT 17
14016: PUSH
14017: LD_INT 8
14019: PUSH
14020: LD_INT 20
14022: PUSH
14023: LD_INT 21
14025: PUSH
14026: LD_INT 22
14028: PUSH
14029: LD_INT 72
14031: PUSH
14032: LD_INT 26
14034: PUSH
14035: LD_INT 69
14037: PUSH
14038: LD_INT 39
14040: PUSH
14041: LD_INT 40
14043: PUSH
14044: LD_INT 41
14046: PUSH
14047: LD_INT 42
14049: PUSH
14050: LD_INT 43
14052: PUSH
14053: LD_INT 48
14055: PUSH
14056: LD_INT 49
14058: PUSH
14059: LD_INT 50
14061: PUSH
14062: LD_INT 51
14064: PUSH
14065: LD_INT 52
14067: PUSH
14068: LD_INT 53
14070: PUSH
14071: LD_INT 54
14073: PUSH
14074: LD_INT 55
14076: PUSH
14077: LD_INT 56
14079: PUSH
14080: LD_INT 60
14082: PUSH
14083: LD_INT 61
14085: PUSH
14086: LD_INT 62
14088: PUSH
14089: LD_INT 66
14091: PUSH
14092: LD_INT 67
14094: PUSH
14095: LD_INT 68
14097: PUSH
14098: LD_INT 81
14100: PUSH
14101: LD_INT 82
14103: PUSH
14104: LD_INT 83
14106: PUSH
14107: LD_INT 84
14109: PUSH
14110: LD_INT 85
14112: PUSH
14113: LD_INT 87
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: ST_TO_ADDR
14171: GO 14404
14173: LD_INT 3
14175: DOUBLE
14176: EQUAL
14177: IFTRUE 14181
14179: GO 14403
14181: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14182: LD_ADDR_VAR 0 4
14186: PUSH
14187: LD_INT 46
14189: PUSH
14190: LD_INT 47
14192: PUSH
14193: LD_INT 1
14195: PUSH
14196: LD_INT 2
14198: PUSH
14199: LD_INT 82
14201: PUSH
14202: LD_INT 83
14204: PUSH
14205: LD_INT 84
14207: PUSH
14208: LD_INT 85
14210: PUSH
14211: LD_INT 86
14213: PUSH
14214: LD_INT 11
14216: PUSH
14217: LD_INT 9
14219: PUSH
14220: LD_INT 20
14222: PUSH
14223: LD_INT 19
14225: PUSH
14226: LD_INT 21
14228: PUSH
14229: LD_INT 24
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 25
14237: PUSH
14238: LD_INT 28
14240: PUSH
14241: LD_INT 29
14243: PUSH
14244: LD_INT 30
14246: PUSH
14247: LD_INT 31
14249: PUSH
14250: LD_INT 37
14252: PUSH
14253: LD_INT 38
14255: PUSH
14256: LD_INT 32
14258: PUSH
14259: LD_INT 27
14261: PUSH
14262: LD_INT 33
14264: PUSH
14265: LD_INT 69
14267: PUSH
14268: LD_INT 39
14270: PUSH
14271: LD_INT 34
14273: PUSH
14274: LD_INT 40
14276: PUSH
14277: LD_INT 71
14279: PUSH
14280: LD_INT 23
14282: PUSH
14283: LD_INT 44
14285: PUSH
14286: LD_INT 48
14288: PUSH
14289: LD_INT 49
14291: PUSH
14292: LD_INT 50
14294: PUSH
14295: LD_INT 51
14297: PUSH
14298: LD_INT 52
14300: PUSH
14301: LD_INT 53
14303: PUSH
14304: LD_INT 54
14306: PUSH
14307: LD_INT 55
14309: PUSH
14310: LD_INT 56
14312: PUSH
14313: LD_INT 57
14315: PUSH
14316: LD_INT 58
14318: PUSH
14319: LD_INT 59
14321: PUSH
14322: LD_INT 63
14324: PUSH
14325: LD_INT 64
14327: PUSH
14328: LD_INT 65
14330: PUSH
14331: LD_INT 82
14333: PUSH
14334: LD_INT 83
14336: PUSH
14337: LD_INT 84
14339: PUSH
14340: LD_INT 85
14342: PUSH
14343: LD_INT 86
14345: PUSH
14346: EMPTY
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: ST_TO_ADDR
14401: GO 14404
14403: POP
// if state > - 1 and state < 3 then
14404: LD_VAR 0 3
14408: PUSH
14409: LD_INT 1
14411: NEG
14412: GREATER
14413: PUSH
14414: LD_VAR 0 3
14418: PUSH
14419: LD_INT 3
14421: LESS
14422: AND
14423: IFFALSE 14480
// for i in result do
14425: LD_ADDR_VAR 0 5
14429: PUSH
14430: LD_VAR 0 4
14434: PUSH
14435: FOR_IN
14436: IFFALSE 14478
// if GetTech ( i , side ) <> state then
14438: LD_VAR 0 5
14442: PPUSH
14443: LD_VAR 0 1
14447: PPUSH
14448: CALL_OW 321
14452: PUSH
14453: LD_VAR 0 3
14457: NONEQUAL
14458: IFFALSE 14476
// result := result diff i ;
14460: LD_ADDR_VAR 0 4
14464: PUSH
14465: LD_VAR 0 4
14469: PUSH
14470: LD_VAR 0 5
14474: DIFF
14475: ST_TO_ADDR
14476: GO 14435
14478: POP
14479: POP
// end ;
14480: LD_VAR 0 4
14484: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14485: LD_INT 0
14487: PPUSH
14488: PPUSH
14489: PPUSH
// result := true ;
14490: LD_ADDR_VAR 0 3
14494: PUSH
14495: LD_INT 1
14497: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14498: LD_ADDR_VAR 0 5
14502: PUSH
14503: LD_VAR 0 2
14507: PPUSH
14508: CALL_OW 480
14512: ST_TO_ADDR
// if not tmp then
14513: LD_VAR 0 5
14517: NOT
14518: IFFALSE 14522
// exit ;
14520: GO 14571
// for i in tmp do
14522: LD_ADDR_VAR 0 4
14526: PUSH
14527: LD_VAR 0 5
14531: PUSH
14532: FOR_IN
14533: IFFALSE 14569
// if GetTech ( i , side ) <> state_researched then
14535: LD_VAR 0 4
14539: PPUSH
14540: LD_VAR 0 1
14544: PPUSH
14545: CALL_OW 321
14549: PUSH
14550: LD_INT 2
14552: NONEQUAL
14553: IFFALSE 14567
// begin result := false ;
14555: LD_ADDR_VAR 0 3
14559: PUSH
14560: LD_INT 0
14562: ST_TO_ADDR
// exit ;
14563: POP
14564: POP
14565: GO 14571
// end ;
14567: GO 14532
14569: POP
14570: POP
// end ;
14571: LD_VAR 0 3
14575: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14576: LD_INT 0
14578: PPUSH
14579: PPUSH
14580: PPUSH
14581: PPUSH
14582: PPUSH
14583: PPUSH
14584: PPUSH
14585: PPUSH
14586: PPUSH
14587: PPUSH
14588: PPUSH
14589: PPUSH
14590: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14591: LD_VAR 0 1
14595: NOT
14596: PUSH
14597: LD_VAR 0 1
14601: PPUSH
14602: CALL_OW 257
14606: PUSH
14607: LD_INT 9
14609: NONEQUAL
14610: OR
14611: IFFALSE 14615
// exit ;
14613: GO 15188
// side := GetSide ( unit ) ;
14615: LD_ADDR_VAR 0 9
14619: PUSH
14620: LD_VAR 0 1
14624: PPUSH
14625: CALL_OW 255
14629: ST_TO_ADDR
// tech_space := tech_spacanom ;
14630: LD_ADDR_VAR 0 12
14634: PUSH
14635: LD_INT 29
14637: ST_TO_ADDR
// tech_time := tech_taurad ;
14638: LD_ADDR_VAR 0 13
14642: PUSH
14643: LD_INT 28
14645: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14646: LD_ADDR_VAR 0 11
14650: PUSH
14651: LD_VAR 0 1
14655: PPUSH
14656: CALL_OW 310
14660: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14661: LD_VAR 0 11
14665: PPUSH
14666: CALL_OW 247
14670: PUSH
14671: LD_INT 2
14673: EQUAL
14674: IFFALSE 14678
// exit ;
14676: GO 15188
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14678: LD_ADDR_VAR 0 8
14682: PUSH
14683: LD_INT 81
14685: PUSH
14686: LD_VAR 0 9
14690: PUSH
14691: EMPTY
14692: LIST
14693: LIST
14694: PUSH
14695: LD_INT 3
14697: PUSH
14698: LD_INT 21
14700: PUSH
14701: LD_INT 3
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: PUSH
14712: EMPTY
14713: LIST
14714: LIST
14715: PPUSH
14716: CALL_OW 69
14720: ST_TO_ADDR
// if not tmp then
14721: LD_VAR 0 8
14725: NOT
14726: IFFALSE 14730
// exit ;
14728: GO 15188
// if in_unit then
14730: LD_VAR 0 11
14734: IFFALSE 14758
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14736: LD_ADDR_VAR 0 10
14740: PUSH
14741: LD_VAR 0 8
14745: PPUSH
14746: LD_VAR 0 11
14750: PPUSH
14751: CALL_OW 74
14755: ST_TO_ADDR
14756: GO 14778
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14758: LD_ADDR_VAR 0 10
14762: PUSH
14763: LD_VAR 0 8
14767: PPUSH
14768: LD_VAR 0 1
14772: PPUSH
14773: CALL_OW 74
14777: ST_TO_ADDR
// if not enemy then
14778: LD_VAR 0 10
14782: NOT
14783: IFFALSE 14787
// exit ;
14785: GO 15188
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14787: LD_VAR 0 11
14791: PUSH
14792: LD_VAR 0 11
14796: PPUSH
14797: LD_VAR 0 10
14801: PPUSH
14802: CALL_OW 296
14806: PUSH
14807: LD_INT 13
14809: GREATER
14810: AND
14811: PUSH
14812: LD_VAR 0 1
14816: PPUSH
14817: LD_VAR 0 10
14821: PPUSH
14822: CALL_OW 296
14826: PUSH
14827: LD_INT 12
14829: GREATER
14830: OR
14831: IFFALSE 14835
// exit ;
14833: GO 15188
// missile := [ 1 ] ;
14835: LD_ADDR_VAR 0 14
14839: PUSH
14840: LD_INT 1
14842: PUSH
14843: EMPTY
14844: LIST
14845: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14846: LD_VAR 0 9
14850: PPUSH
14851: LD_VAR 0 12
14855: PPUSH
14856: CALL_OW 325
14860: IFFALSE 14889
// missile := Insert ( missile , missile + 1 , 2 ) ;
14862: LD_ADDR_VAR 0 14
14866: PUSH
14867: LD_VAR 0 14
14871: PPUSH
14872: LD_VAR 0 14
14876: PUSH
14877: LD_INT 1
14879: PLUS
14880: PPUSH
14881: LD_INT 2
14883: PPUSH
14884: CALL_OW 2
14888: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14889: LD_VAR 0 9
14893: PPUSH
14894: LD_VAR 0 13
14898: PPUSH
14899: CALL_OW 325
14903: PUSH
14904: LD_VAR 0 10
14908: PPUSH
14909: CALL_OW 255
14913: PPUSH
14914: LD_VAR 0 13
14918: PPUSH
14919: CALL_OW 325
14923: NOT
14924: AND
14925: IFFALSE 14954
// missile := Insert ( missile , missile + 1 , 3 ) ;
14927: LD_ADDR_VAR 0 14
14931: PUSH
14932: LD_VAR 0 14
14936: PPUSH
14937: LD_VAR 0 14
14941: PUSH
14942: LD_INT 1
14944: PLUS
14945: PPUSH
14946: LD_INT 3
14948: PPUSH
14949: CALL_OW 2
14953: ST_TO_ADDR
// if missile < 2 then
14954: LD_VAR 0 14
14958: PUSH
14959: LD_INT 2
14961: LESS
14962: IFFALSE 14966
// exit ;
14964: GO 15188
// x := GetX ( enemy ) ;
14966: LD_ADDR_VAR 0 4
14970: PUSH
14971: LD_VAR 0 10
14975: PPUSH
14976: CALL_OW 250
14980: ST_TO_ADDR
// y := GetY ( enemy ) ;
14981: LD_ADDR_VAR 0 5
14985: PUSH
14986: LD_VAR 0 10
14990: PPUSH
14991: CALL_OW 251
14995: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14996: LD_ADDR_VAR 0 6
15000: PUSH
15001: LD_VAR 0 4
15005: PUSH
15006: LD_INT 1
15008: NEG
15009: PPUSH
15010: LD_INT 1
15012: PPUSH
15013: CALL_OW 12
15017: PLUS
15018: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15019: LD_ADDR_VAR 0 7
15023: PUSH
15024: LD_VAR 0 5
15028: PUSH
15029: LD_INT 1
15031: NEG
15032: PPUSH
15033: LD_INT 1
15035: PPUSH
15036: CALL_OW 12
15040: PLUS
15041: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15042: LD_VAR 0 6
15046: PPUSH
15047: LD_VAR 0 7
15051: PPUSH
15052: CALL_OW 488
15056: NOT
15057: IFFALSE 15079
// begin _x := x ;
15059: LD_ADDR_VAR 0 6
15063: PUSH
15064: LD_VAR 0 4
15068: ST_TO_ADDR
// _y := y ;
15069: LD_ADDR_VAR 0 7
15073: PUSH
15074: LD_VAR 0 5
15078: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15079: LD_ADDR_VAR 0 3
15083: PUSH
15084: LD_INT 1
15086: PPUSH
15087: LD_VAR 0 14
15091: PPUSH
15092: CALL_OW 12
15096: ST_TO_ADDR
// case i of 1 :
15097: LD_VAR 0 3
15101: PUSH
15102: LD_INT 1
15104: DOUBLE
15105: EQUAL
15106: IFTRUE 15110
15108: GO 15127
15110: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15111: LD_VAR 0 1
15115: PPUSH
15116: LD_VAR 0 10
15120: PPUSH
15121: CALL_OW 115
15125: GO 15188
15127: LD_INT 2
15129: DOUBLE
15130: EQUAL
15131: IFTRUE 15135
15133: GO 15157
15135: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15136: LD_VAR 0 1
15140: PPUSH
15141: LD_VAR 0 6
15145: PPUSH
15146: LD_VAR 0 7
15150: PPUSH
15151: CALL_OW 153
15155: GO 15188
15157: LD_INT 3
15159: DOUBLE
15160: EQUAL
15161: IFTRUE 15165
15163: GO 15187
15165: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 6
15175: PPUSH
15176: LD_VAR 0 7
15180: PPUSH
15181: CALL_OW 154
15185: GO 15188
15187: POP
// end ;
15188: LD_VAR 0 2
15192: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15193: LD_INT 0
15195: PPUSH
15196: PPUSH
15197: PPUSH
15198: PPUSH
15199: PPUSH
15200: PPUSH
// if not unit or not building then
15201: LD_VAR 0 1
15205: NOT
15206: PUSH
15207: LD_VAR 0 2
15211: NOT
15212: OR
15213: IFFALSE 15217
// exit ;
15215: GO 15375
// x := GetX ( building ) ;
15217: LD_ADDR_VAR 0 5
15221: PUSH
15222: LD_VAR 0 2
15226: PPUSH
15227: CALL_OW 250
15231: ST_TO_ADDR
// y := GetY ( building ) ;
15232: LD_ADDR_VAR 0 6
15236: PUSH
15237: LD_VAR 0 2
15241: PPUSH
15242: CALL_OW 251
15246: ST_TO_ADDR
// for i = 0 to 5 do
15247: LD_ADDR_VAR 0 4
15251: PUSH
15252: DOUBLE
15253: LD_INT 0
15255: DEC
15256: ST_TO_ADDR
15257: LD_INT 5
15259: PUSH
15260: FOR_TO
15261: IFFALSE 15373
// begin _x := ShiftX ( x , i , 3 ) ;
15263: LD_ADDR_VAR 0 7
15267: PUSH
15268: LD_VAR 0 5
15272: PPUSH
15273: LD_VAR 0 4
15277: PPUSH
15278: LD_INT 3
15280: PPUSH
15281: CALL_OW 272
15285: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15286: LD_ADDR_VAR 0 8
15290: PUSH
15291: LD_VAR 0 6
15295: PPUSH
15296: LD_VAR 0 4
15300: PPUSH
15301: LD_INT 3
15303: PPUSH
15304: CALL_OW 273
15308: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15309: LD_VAR 0 7
15313: PPUSH
15314: LD_VAR 0 8
15318: PPUSH
15319: CALL_OW 488
15323: NOT
15324: IFFALSE 15328
// continue ;
15326: GO 15260
// if HexInfo ( _x , _y ) = 0 then
15328: LD_VAR 0 7
15332: PPUSH
15333: LD_VAR 0 8
15337: PPUSH
15338: CALL_OW 428
15342: PUSH
15343: LD_INT 0
15345: EQUAL
15346: IFFALSE 15371
// begin ComMoveXY ( unit , _x , _y ) ;
15348: LD_VAR 0 1
15352: PPUSH
15353: LD_VAR 0 7
15357: PPUSH
15358: LD_VAR 0 8
15362: PPUSH
15363: CALL_OW 111
// exit ;
15367: POP
15368: POP
15369: GO 15375
// end ; end ;
15371: GO 15260
15373: POP
15374: POP
// end ;
15375: LD_VAR 0 3
15379: RET
// export function ScanBase ( side , base_area ) ; begin
15380: LD_INT 0
15382: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15383: LD_ADDR_VAR 0 3
15387: PUSH
15388: LD_VAR 0 2
15392: PPUSH
15393: LD_INT 81
15395: PUSH
15396: LD_VAR 0 1
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: PPUSH
15405: CALL_OW 70
15409: ST_TO_ADDR
// end ;
15410: LD_VAR 0 3
15414: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
15415: LD_INT 0
15417: PPUSH
15418: PPUSH
15419: PPUSH
15420: PPUSH
// result := false ;
15421: LD_ADDR_VAR 0 2
15425: PUSH
15426: LD_INT 0
15428: ST_TO_ADDR
// side := GetSide ( unit ) ;
15429: LD_ADDR_VAR 0 3
15433: PUSH
15434: LD_VAR 0 1
15438: PPUSH
15439: CALL_OW 255
15443: ST_TO_ADDR
// nat := GetNation ( unit ) ;
15444: LD_ADDR_VAR 0 4
15448: PUSH
15449: LD_VAR 0 1
15453: PPUSH
15454: CALL_OW 248
15458: ST_TO_ADDR
// case nat of 1 :
15459: LD_VAR 0 4
15463: PUSH
15464: LD_INT 1
15466: DOUBLE
15467: EQUAL
15468: IFTRUE 15472
15470: GO 15483
15472: POP
// tech := tech_lassight ; 2 :
15473: LD_ADDR_VAR 0 5
15477: PUSH
15478: LD_INT 12
15480: ST_TO_ADDR
15481: GO 15522
15483: LD_INT 2
15485: DOUBLE
15486: EQUAL
15487: IFTRUE 15491
15489: GO 15502
15491: POP
// tech := tech_mortar ; 3 :
15492: LD_ADDR_VAR 0 5
15496: PUSH
15497: LD_INT 41
15499: ST_TO_ADDR
15500: GO 15522
15502: LD_INT 3
15504: DOUBLE
15505: EQUAL
15506: IFTRUE 15510
15508: GO 15521
15510: POP
// tech := tech_bazooka ; end ;
15511: LD_ADDR_VAR 0 5
15515: PUSH
15516: LD_INT 44
15518: ST_TO_ADDR
15519: GO 15522
15521: POP
// if Researched ( side , tech ) then
15522: LD_VAR 0 3
15526: PPUSH
15527: LD_VAR 0 5
15531: PPUSH
15532: CALL_OW 325
15536: IFFALSE 15563
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
15538: LD_ADDR_VAR 0 2
15542: PUSH
15543: LD_INT 5
15545: PUSH
15546: LD_INT 8
15548: PUSH
15549: LD_INT 9
15551: PUSH
15552: EMPTY
15553: LIST
15554: LIST
15555: LIST
15556: PUSH
15557: LD_VAR 0 4
15561: ARRAY
15562: ST_TO_ADDR
// end ;
15563: LD_VAR 0 2
15567: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
15568: LD_INT 0
15570: PPUSH
15571: PPUSH
15572: PPUSH
// if not mines then
15573: LD_VAR 0 2
15577: NOT
15578: IFFALSE 15582
// exit ;
15580: GO 15726
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15582: LD_ADDR_VAR 0 5
15586: PUSH
15587: LD_INT 81
15589: PUSH
15590: LD_VAR 0 1
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: LD_INT 3
15601: PUSH
15602: LD_INT 21
15604: PUSH
15605: LD_INT 3
15607: PUSH
15608: EMPTY
15609: LIST
15610: LIST
15611: PUSH
15612: EMPTY
15613: LIST
15614: LIST
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PPUSH
15620: CALL_OW 69
15624: ST_TO_ADDR
// for i in mines do
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 2
15634: PUSH
15635: FOR_IN
15636: IFFALSE 15724
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
15638: LD_VAR 0 4
15642: PUSH
15643: LD_INT 1
15645: ARRAY
15646: PPUSH
15647: LD_VAR 0 4
15651: PUSH
15652: LD_INT 2
15654: ARRAY
15655: PPUSH
15656: CALL_OW 458
15660: NOT
15661: IFFALSE 15665
// continue ;
15663: GO 15635
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
15665: LD_VAR 0 4
15669: PUSH
15670: LD_INT 1
15672: ARRAY
15673: PPUSH
15674: LD_VAR 0 4
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: CALL_OW 428
15687: PUSH
15688: LD_VAR 0 5
15692: IN
15693: IFFALSE 15722
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
15695: LD_VAR 0 4
15699: PUSH
15700: LD_INT 1
15702: ARRAY
15703: PPUSH
15704: LD_VAR 0 4
15708: PUSH
15709: LD_INT 2
15711: ARRAY
15712: PPUSH
15713: LD_VAR 0 1
15717: PPUSH
15718: CALL_OW 456
// end ;
15722: GO 15635
15724: POP
15725: POP
// end ;
15726: LD_VAR 0 3
15730: RET
// export function Count ( array ) ; var i ; begin
15731: LD_INT 0
15733: PPUSH
15734: PPUSH
// result := 0 ;
15735: LD_ADDR_VAR 0 2
15739: PUSH
15740: LD_INT 0
15742: ST_TO_ADDR
// for i in array do
15743: LD_ADDR_VAR 0 3
15747: PUSH
15748: LD_VAR 0 1
15752: PUSH
15753: FOR_IN
15754: IFFALSE 15778
// if i then
15756: LD_VAR 0 3
15760: IFFALSE 15776
// result := result + 1 ;
15762: LD_ADDR_VAR 0 2
15766: PUSH
15767: LD_VAR 0 2
15771: PUSH
15772: LD_INT 1
15774: PLUS
15775: ST_TO_ADDR
15776: GO 15753
15778: POP
15779: POP
// end ;
15780: LD_VAR 0 2
15784: RET
// export function IsEmpty ( building ) ; begin
15785: LD_INT 0
15787: PPUSH
// if not building then
15788: LD_VAR 0 1
15792: NOT
15793: IFFALSE 15797
// exit ;
15795: GO 15840
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
15797: LD_ADDR_VAR 0 2
15801: PUSH
15802: LD_VAR 0 1
15806: PUSH
15807: LD_INT 22
15809: PUSH
15810: LD_VAR 0 1
15814: PPUSH
15815: CALL_OW 255
15819: PUSH
15820: EMPTY
15821: LIST
15822: LIST
15823: PUSH
15824: LD_INT 58
15826: PUSH
15827: EMPTY
15828: LIST
15829: PUSH
15830: EMPTY
15831: LIST
15832: LIST
15833: PPUSH
15834: CALL_OW 69
15838: IN
15839: ST_TO_ADDR
// end ;
15840: LD_VAR 0 2
15844: RET
// export function IsNotFull ( building ) ; begin
15845: LD_INT 0
15847: PPUSH
// if not building then
15848: LD_VAR 0 1
15852: NOT
15853: IFFALSE 15857
// exit ;
15855: GO 15876
// result := UnitsInside ( building ) < 6 ;
15857: LD_ADDR_VAR 0 2
15861: PUSH
15862: LD_VAR 0 1
15866: PPUSH
15867: CALL_OW 313
15871: PUSH
15872: LD_INT 6
15874: LESS
15875: ST_TO_ADDR
// end ;
15876: LD_VAR 0 2
15880: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
15881: LD_INT 0
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
// tmp := [ ] ;
15887: LD_ADDR_VAR 0 3
15891: PUSH
15892: EMPTY
15893: ST_TO_ADDR
// list := [ ] ;
15894: LD_ADDR_VAR 0 5
15898: PUSH
15899: EMPTY
15900: ST_TO_ADDR
// for i = 16 to 25 do
15901: LD_ADDR_VAR 0 4
15905: PUSH
15906: DOUBLE
15907: LD_INT 16
15909: DEC
15910: ST_TO_ADDR
15911: LD_INT 25
15913: PUSH
15914: FOR_TO
15915: IFFALSE 15988
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
15917: LD_ADDR_VAR 0 3
15921: PUSH
15922: LD_VAR 0 3
15926: PUSH
15927: LD_INT 22
15929: PUSH
15930: LD_VAR 0 1
15934: PPUSH
15935: CALL_OW 255
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 91
15946: PUSH
15947: LD_VAR 0 1
15951: PUSH
15952: LD_INT 6
15954: PUSH
15955: EMPTY
15956: LIST
15957: LIST
15958: LIST
15959: PUSH
15960: LD_INT 30
15962: PUSH
15963: LD_VAR 0 4
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: PUSH
15972: EMPTY
15973: LIST
15974: LIST
15975: LIST
15976: PUSH
15977: EMPTY
15978: LIST
15979: PPUSH
15980: CALL_OW 69
15984: ADD
15985: ST_TO_ADDR
15986: GO 15914
15988: POP
15989: POP
// for i = 1 to tmp do
15990: LD_ADDR_VAR 0 4
15994: PUSH
15995: DOUBLE
15996: LD_INT 1
15998: DEC
15999: ST_TO_ADDR
16000: LD_VAR 0 3
16004: PUSH
16005: FOR_TO
16006: IFFALSE 16094
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16008: LD_ADDR_VAR 0 5
16012: PUSH
16013: LD_VAR 0 5
16017: PUSH
16018: LD_VAR 0 3
16022: PUSH
16023: LD_VAR 0 4
16027: ARRAY
16028: PPUSH
16029: CALL_OW 266
16033: PUSH
16034: LD_VAR 0 3
16038: PUSH
16039: LD_VAR 0 4
16043: ARRAY
16044: PPUSH
16045: CALL_OW 250
16049: PUSH
16050: LD_VAR 0 3
16054: PUSH
16055: LD_VAR 0 4
16059: ARRAY
16060: PPUSH
16061: CALL_OW 251
16065: PUSH
16066: LD_VAR 0 3
16070: PUSH
16071: LD_VAR 0 4
16075: ARRAY
16076: PPUSH
16077: CALL_OW 254
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: LIST
16086: LIST
16087: PUSH
16088: EMPTY
16089: LIST
16090: ADD
16091: ST_TO_ADDR
16092: GO 16005
16094: POP
16095: POP
// result := list ;
16096: LD_ADDR_VAR 0 2
16100: PUSH
16101: LD_VAR 0 5
16105: ST_TO_ADDR
// end ;
16106: LD_VAR 0 2
16110: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16111: LD_INT 0
16113: PPUSH
16114: PPUSH
16115: PPUSH
16116: PPUSH
16117: PPUSH
16118: PPUSH
16119: PPUSH
// if not factory then
16120: LD_VAR 0 1
16124: NOT
16125: IFFALSE 16129
// exit ;
16127: GO 16722
// if control = control_apeman then
16129: LD_VAR 0 4
16133: PUSH
16134: LD_INT 5
16136: EQUAL
16137: IFFALSE 16246
// begin tmp := UnitsInside ( factory ) ;
16139: LD_ADDR_VAR 0 8
16143: PUSH
16144: LD_VAR 0 1
16148: PPUSH
16149: CALL_OW 313
16153: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16154: LD_VAR 0 8
16158: PPUSH
16159: LD_INT 25
16161: PUSH
16162: LD_INT 12
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PPUSH
16169: CALL_OW 72
16173: NOT
16174: IFFALSE 16184
// control := control_manual ;
16176: LD_ADDR_VAR 0 4
16180: PUSH
16181: LD_INT 1
16183: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16184: LD_ADDR_VAR 0 8
16188: PUSH
16189: LD_VAR 0 1
16193: PPUSH
16194: CALL 15881 0 1
16198: ST_TO_ADDR
// if tmp then
16199: LD_VAR 0 8
16203: IFFALSE 16246
// begin for i in tmp do
16205: LD_ADDR_VAR 0 7
16209: PUSH
16210: LD_VAR 0 8
16214: PUSH
16215: FOR_IN
16216: IFFALSE 16244
// if i [ 1 ] = b_ext_radio then
16218: LD_VAR 0 7
16222: PUSH
16223: LD_INT 1
16225: ARRAY
16226: PUSH
16227: LD_INT 22
16229: EQUAL
16230: IFFALSE 16242
// begin control := control_remote ;
16232: LD_ADDR_VAR 0 4
16236: PUSH
16237: LD_INT 2
16239: ST_TO_ADDR
// break ;
16240: GO 16244
// end ;
16242: GO 16215
16244: POP
16245: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16246: LD_VAR 0 1
16250: PPUSH
16251: LD_VAR 0 2
16255: PPUSH
16256: LD_VAR 0 3
16260: PPUSH
16261: LD_VAR 0 4
16265: PPUSH
16266: LD_VAR 0 5
16270: PPUSH
16271: CALL_OW 448
16275: IFFALSE 16310
// begin result := [ chassis , engine , control , weapon ] ;
16277: LD_ADDR_VAR 0 6
16281: PUSH
16282: LD_VAR 0 2
16286: PUSH
16287: LD_VAR 0 3
16291: PUSH
16292: LD_VAR 0 4
16296: PUSH
16297: LD_VAR 0 5
16301: PUSH
16302: EMPTY
16303: LIST
16304: LIST
16305: LIST
16306: LIST
16307: ST_TO_ADDR
// exit ;
16308: GO 16722
// end ; _chassis := AvailableChassisList ( factory ) ;
16310: LD_ADDR_VAR 0 9
16314: PUSH
16315: LD_VAR 0 1
16319: PPUSH
16320: CALL_OW 475
16324: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16325: LD_ADDR_VAR 0 11
16329: PUSH
16330: LD_VAR 0 1
16334: PPUSH
16335: CALL_OW 476
16339: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16340: LD_ADDR_VAR 0 12
16344: PUSH
16345: LD_VAR 0 1
16349: PPUSH
16350: CALL_OW 477
16354: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
16355: LD_ADDR_VAR 0 10
16359: PUSH
16360: LD_VAR 0 1
16364: PPUSH
16365: CALL_OW 478
16369: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
16370: LD_VAR 0 9
16374: NOT
16375: PUSH
16376: LD_VAR 0 11
16380: NOT
16381: OR
16382: PUSH
16383: LD_VAR 0 12
16387: NOT
16388: OR
16389: PUSH
16390: LD_VAR 0 10
16394: NOT
16395: OR
16396: IFFALSE 16431
// begin result := [ chassis , engine , control , weapon ] ;
16398: LD_ADDR_VAR 0 6
16402: PUSH
16403: LD_VAR 0 2
16407: PUSH
16408: LD_VAR 0 3
16412: PUSH
16413: LD_VAR 0 4
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: LIST
16427: LIST
16428: ST_TO_ADDR
// exit ;
16429: GO 16722
// end ; if not chassis in _chassis then
16431: LD_VAR 0 2
16435: PUSH
16436: LD_VAR 0 9
16440: IN
16441: NOT
16442: IFFALSE 16468
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
16444: LD_ADDR_VAR 0 2
16448: PUSH
16449: LD_VAR 0 9
16453: PUSH
16454: LD_INT 1
16456: PPUSH
16457: LD_VAR 0 9
16461: PPUSH
16462: CALL_OW 12
16466: ARRAY
16467: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
16468: LD_VAR 0 2
16472: PPUSH
16473: LD_VAR 0 3
16477: PPUSH
16478: CALL 16727 0 2
16482: NOT
16483: IFFALSE 16542
// repeat engine := _engine [ 1 ] ;
16485: LD_ADDR_VAR 0 3
16489: PUSH
16490: LD_VAR 0 11
16494: PUSH
16495: LD_INT 1
16497: ARRAY
16498: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
16499: LD_ADDR_VAR 0 11
16503: PUSH
16504: LD_VAR 0 11
16508: PPUSH
16509: LD_INT 1
16511: PPUSH
16512: CALL_OW 3
16516: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
16517: LD_VAR 0 2
16521: PPUSH
16522: LD_VAR 0 3
16526: PPUSH
16527: CALL 16727 0 2
16531: PUSH
16532: LD_VAR 0 11
16536: PUSH
16537: EMPTY
16538: EQUAL
16539: OR
16540: IFFALSE 16485
// if not control in _control then
16542: LD_VAR 0 4
16546: PUSH
16547: LD_VAR 0 12
16551: IN
16552: NOT
16553: IFFALSE 16579
// control := _control [ rand ( 1 , _control ) ] ;
16555: LD_ADDR_VAR 0 4
16559: PUSH
16560: LD_VAR 0 12
16564: PUSH
16565: LD_INT 1
16567: PPUSH
16568: LD_VAR 0 12
16572: PPUSH
16573: CALL_OW 12
16577: ARRAY
16578: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
16579: LD_VAR 0 2
16583: PPUSH
16584: LD_VAR 0 5
16588: PPUSH
16589: CALL 16947 0 2
16593: NOT
16594: IFFALSE 16653
// repeat weapon := _weapon [ 1 ] ;
16596: LD_ADDR_VAR 0 5
16600: PUSH
16601: LD_VAR 0 10
16605: PUSH
16606: LD_INT 1
16608: ARRAY
16609: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
16610: LD_ADDR_VAR 0 10
16614: PUSH
16615: LD_VAR 0 10
16619: PPUSH
16620: LD_INT 1
16622: PPUSH
16623: CALL_OW 3
16627: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
16628: LD_VAR 0 2
16632: PPUSH
16633: LD_VAR 0 5
16637: PPUSH
16638: CALL 16947 0 2
16642: PUSH
16643: LD_VAR 0 10
16647: PUSH
16648: EMPTY
16649: EQUAL
16650: OR
16651: IFFALSE 16596
// result := [ ] ;
16653: LD_ADDR_VAR 0 6
16657: PUSH
16658: EMPTY
16659: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16660: LD_VAR 0 1
16664: PPUSH
16665: LD_VAR 0 2
16669: PPUSH
16670: LD_VAR 0 3
16674: PPUSH
16675: LD_VAR 0 4
16679: PPUSH
16680: LD_VAR 0 5
16684: PPUSH
16685: CALL_OW 448
16689: IFFALSE 16722
// result := [ chassis , engine , control , weapon ] ;
16691: LD_ADDR_VAR 0 6
16695: PUSH
16696: LD_VAR 0 2
16700: PUSH
16701: LD_VAR 0 3
16705: PUSH
16706: LD_VAR 0 4
16710: PUSH
16711: LD_VAR 0 5
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: LIST
16720: LIST
16721: ST_TO_ADDR
// end ;
16722: LD_VAR 0 6
16726: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
16727: LD_INT 0
16729: PPUSH
// if not chassis or not engine then
16730: LD_VAR 0 1
16734: NOT
16735: PUSH
16736: LD_VAR 0 2
16740: NOT
16741: OR
16742: IFFALSE 16746
// exit ;
16744: GO 16942
// case engine of engine_solar :
16746: LD_VAR 0 2
16750: PUSH
16751: LD_INT 2
16753: DOUBLE
16754: EQUAL
16755: IFTRUE 16759
16757: GO 16797
16759: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
16760: LD_ADDR_VAR 0 3
16764: PUSH
16765: LD_INT 11
16767: PUSH
16768: LD_INT 12
16770: PUSH
16771: LD_INT 13
16773: PUSH
16774: LD_INT 14
16776: PUSH
16777: LD_INT 1
16779: PUSH
16780: LD_INT 2
16782: PUSH
16783: LD_INT 3
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: LIST
16794: ST_TO_ADDR
16795: GO 16926
16797: LD_INT 1
16799: DOUBLE
16800: EQUAL
16801: IFTRUE 16805
16803: GO 16867
16805: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
16806: LD_ADDR_VAR 0 3
16810: PUSH
16811: LD_INT 11
16813: PUSH
16814: LD_INT 12
16816: PUSH
16817: LD_INT 13
16819: PUSH
16820: LD_INT 14
16822: PUSH
16823: LD_INT 1
16825: PUSH
16826: LD_INT 2
16828: PUSH
16829: LD_INT 3
16831: PUSH
16832: LD_INT 4
16834: PUSH
16835: LD_INT 5
16837: PUSH
16838: LD_INT 21
16840: PUSH
16841: LD_INT 23
16843: PUSH
16844: LD_INT 22
16846: PUSH
16847: LD_INT 24
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: LIST
16857: LIST
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: LIST
16863: LIST
16864: ST_TO_ADDR
16865: GO 16926
16867: LD_INT 3
16869: DOUBLE
16870: EQUAL
16871: IFTRUE 16875
16873: GO 16925
16875: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
16876: LD_ADDR_VAR 0 3
16880: PUSH
16881: LD_INT 13
16883: PUSH
16884: LD_INT 14
16886: PUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 3
16892: PUSH
16893: LD_INT 4
16895: PUSH
16896: LD_INT 5
16898: PUSH
16899: LD_INT 21
16901: PUSH
16902: LD_INT 22
16904: PUSH
16905: LD_INT 23
16907: PUSH
16908: LD_INT 24
16910: PUSH
16911: EMPTY
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: ST_TO_ADDR
16923: GO 16926
16925: POP
// result := ( chassis in result ) ;
16926: LD_ADDR_VAR 0 3
16930: PUSH
16931: LD_VAR 0 1
16935: PUSH
16936: LD_VAR 0 3
16940: IN
16941: ST_TO_ADDR
// end ;
16942: LD_VAR 0 3
16946: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
16947: LD_INT 0
16949: PPUSH
// if not chassis or not weapon then
16950: LD_VAR 0 1
16954: NOT
16955: PUSH
16956: LD_VAR 0 2
16960: NOT
16961: OR
16962: IFFALSE 16966
// exit ;
16964: GO 17992
// case weapon of us_machine_gun :
16966: LD_VAR 0 2
16970: PUSH
16971: LD_INT 2
16973: DOUBLE
16974: EQUAL
16975: IFTRUE 16979
16977: GO 17009
16979: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
16980: LD_ADDR_VAR 0 3
16984: PUSH
16985: LD_INT 1
16987: PUSH
16988: LD_INT 2
16990: PUSH
16991: LD_INT 3
16993: PUSH
16994: LD_INT 4
16996: PUSH
16997: LD_INT 5
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: ST_TO_ADDR
17007: GO 17976
17009: LD_INT 3
17011: DOUBLE
17012: EQUAL
17013: IFTRUE 17017
17015: GO 17047
17017: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17018: LD_ADDR_VAR 0 3
17022: PUSH
17023: LD_INT 1
17025: PUSH
17026: LD_INT 2
17028: PUSH
17029: LD_INT 3
17031: PUSH
17032: LD_INT 4
17034: PUSH
17035: LD_INT 5
17037: PUSH
17038: EMPTY
17039: LIST
17040: LIST
17041: LIST
17042: LIST
17043: LIST
17044: ST_TO_ADDR
17045: GO 17976
17047: LD_INT 11
17049: DOUBLE
17050: EQUAL
17051: IFTRUE 17055
17053: GO 17085
17055: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17056: LD_ADDR_VAR 0 3
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: LD_INT 2
17066: PUSH
17067: LD_INT 3
17069: PUSH
17070: LD_INT 4
17072: PUSH
17073: LD_INT 5
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: LIST
17081: LIST
17082: ST_TO_ADDR
17083: GO 17976
17085: LD_INT 4
17087: DOUBLE
17088: EQUAL
17089: IFTRUE 17093
17091: GO 17119
17093: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17094: LD_ADDR_VAR 0 3
17098: PUSH
17099: LD_INT 2
17101: PUSH
17102: LD_INT 3
17104: PUSH
17105: LD_INT 4
17107: PUSH
17108: LD_INT 5
17110: PUSH
17111: EMPTY
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: ST_TO_ADDR
17117: GO 17976
17119: LD_INT 5
17121: DOUBLE
17122: EQUAL
17123: IFTRUE 17127
17125: GO 17153
17127: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17128: LD_ADDR_VAR 0 3
17132: PUSH
17133: LD_INT 2
17135: PUSH
17136: LD_INT 3
17138: PUSH
17139: LD_INT 4
17141: PUSH
17142: LD_INT 5
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: LIST
17149: LIST
17150: ST_TO_ADDR
17151: GO 17976
17153: LD_INT 9
17155: DOUBLE
17156: EQUAL
17157: IFTRUE 17161
17159: GO 17187
17161: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17162: LD_ADDR_VAR 0 3
17166: PUSH
17167: LD_INT 2
17169: PUSH
17170: LD_INT 3
17172: PUSH
17173: LD_INT 4
17175: PUSH
17176: LD_INT 5
17178: PUSH
17179: EMPTY
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: ST_TO_ADDR
17185: GO 17976
17187: LD_INT 7
17189: DOUBLE
17190: EQUAL
17191: IFTRUE 17195
17193: GO 17221
17195: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17196: LD_ADDR_VAR 0 3
17200: PUSH
17201: LD_INT 2
17203: PUSH
17204: LD_INT 3
17206: PUSH
17207: LD_INT 4
17209: PUSH
17210: LD_INT 5
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: LIST
17217: LIST
17218: ST_TO_ADDR
17219: GO 17976
17221: LD_INT 12
17223: DOUBLE
17224: EQUAL
17225: IFTRUE 17229
17227: GO 17255
17229: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17230: LD_ADDR_VAR 0 3
17234: PUSH
17235: LD_INT 2
17237: PUSH
17238: LD_INT 3
17240: PUSH
17241: LD_INT 4
17243: PUSH
17244: LD_INT 5
17246: PUSH
17247: EMPTY
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: ST_TO_ADDR
17253: GO 17976
17255: LD_INT 13
17257: DOUBLE
17258: EQUAL
17259: IFTRUE 17263
17261: GO 17289
17263: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17264: LD_ADDR_VAR 0 3
17268: PUSH
17269: LD_INT 2
17271: PUSH
17272: LD_INT 3
17274: PUSH
17275: LD_INT 4
17277: PUSH
17278: LD_INT 5
17280: PUSH
17281: EMPTY
17282: LIST
17283: LIST
17284: LIST
17285: LIST
17286: ST_TO_ADDR
17287: GO 17976
17289: LD_INT 14
17291: DOUBLE
17292: EQUAL
17293: IFTRUE 17297
17295: GO 17315
17297: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17298: LD_ADDR_VAR 0 3
17302: PUSH
17303: LD_INT 4
17305: PUSH
17306: LD_INT 5
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: ST_TO_ADDR
17313: GO 17976
17315: LD_INT 6
17317: DOUBLE
17318: EQUAL
17319: IFTRUE 17323
17321: GO 17341
17323: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17324: LD_ADDR_VAR 0 3
17328: PUSH
17329: LD_INT 4
17331: PUSH
17332: LD_INT 5
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: ST_TO_ADDR
17339: GO 17976
17341: LD_INT 10
17343: DOUBLE
17344: EQUAL
17345: IFTRUE 17349
17347: GO 17367
17349: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
17350: LD_ADDR_VAR 0 3
17354: PUSH
17355: LD_INT 4
17357: PUSH
17358: LD_INT 5
17360: PUSH
17361: EMPTY
17362: LIST
17363: LIST
17364: ST_TO_ADDR
17365: GO 17976
17367: LD_INT 22
17369: DOUBLE
17370: EQUAL
17371: IFTRUE 17375
17373: GO 17401
17375: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
17376: LD_ADDR_VAR 0 3
17380: PUSH
17381: LD_INT 11
17383: PUSH
17384: LD_INT 12
17386: PUSH
17387: LD_INT 13
17389: PUSH
17390: LD_INT 14
17392: PUSH
17393: EMPTY
17394: LIST
17395: LIST
17396: LIST
17397: LIST
17398: ST_TO_ADDR
17399: GO 17976
17401: LD_INT 23
17403: DOUBLE
17404: EQUAL
17405: IFTRUE 17409
17407: GO 17435
17409: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
17410: LD_ADDR_VAR 0 3
17414: PUSH
17415: LD_INT 11
17417: PUSH
17418: LD_INT 12
17420: PUSH
17421: LD_INT 13
17423: PUSH
17424: LD_INT 14
17426: PUSH
17427: EMPTY
17428: LIST
17429: LIST
17430: LIST
17431: LIST
17432: ST_TO_ADDR
17433: GO 17976
17435: LD_INT 24
17437: DOUBLE
17438: EQUAL
17439: IFTRUE 17443
17441: GO 17469
17443: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
17444: LD_ADDR_VAR 0 3
17448: PUSH
17449: LD_INT 11
17451: PUSH
17452: LD_INT 12
17454: PUSH
17455: LD_INT 13
17457: PUSH
17458: LD_INT 14
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: LIST
17465: LIST
17466: ST_TO_ADDR
17467: GO 17976
17469: LD_INT 30
17471: DOUBLE
17472: EQUAL
17473: IFTRUE 17477
17475: GO 17503
17477: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
17478: LD_ADDR_VAR 0 3
17482: PUSH
17483: LD_INT 11
17485: PUSH
17486: LD_INT 12
17488: PUSH
17489: LD_INT 13
17491: PUSH
17492: LD_INT 14
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: ST_TO_ADDR
17501: GO 17976
17503: LD_INT 25
17505: DOUBLE
17506: EQUAL
17507: IFTRUE 17511
17509: GO 17529
17511: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
17512: LD_ADDR_VAR 0 3
17516: PUSH
17517: LD_INT 13
17519: PUSH
17520: LD_INT 14
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: ST_TO_ADDR
17527: GO 17976
17529: LD_INT 27
17531: DOUBLE
17532: EQUAL
17533: IFTRUE 17537
17535: GO 17555
17537: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
17538: LD_ADDR_VAR 0 3
17542: PUSH
17543: LD_INT 13
17545: PUSH
17546: LD_INT 14
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: ST_TO_ADDR
17553: GO 17976
17555: LD_INT 28
17557: DOUBLE
17558: EQUAL
17559: IFTRUE 17563
17561: GO 17581
17563: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
17564: LD_ADDR_VAR 0 3
17568: PUSH
17569: LD_INT 13
17571: PUSH
17572: LD_INT 14
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: ST_TO_ADDR
17579: GO 17976
17581: LD_INT 29
17583: DOUBLE
17584: EQUAL
17585: IFTRUE 17589
17587: GO 17607
17589: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
17590: LD_ADDR_VAR 0 3
17594: PUSH
17595: LD_INT 13
17597: PUSH
17598: LD_INT 14
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: ST_TO_ADDR
17605: GO 17976
17607: LD_INT 31
17609: DOUBLE
17610: EQUAL
17611: IFTRUE 17615
17613: GO 17633
17615: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
17616: LD_ADDR_VAR 0 3
17620: PUSH
17621: LD_INT 13
17623: PUSH
17624: LD_INT 14
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: ST_TO_ADDR
17631: GO 17976
17633: LD_INT 26
17635: DOUBLE
17636: EQUAL
17637: IFTRUE 17641
17639: GO 17659
17641: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
17642: LD_ADDR_VAR 0 3
17646: PUSH
17647: LD_INT 13
17649: PUSH
17650: LD_INT 14
17652: PUSH
17653: EMPTY
17654: LIST
17655: LIST
17656: ST_TO_ADDR
17657: GO 17976
17659: LD_INT 42
17661: DOUBLE
17662: EQUAL
17663: IFTRUE 17667
17665: GO 17693
17667: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
17668: LD_ADDR_VAR 0 3
17672: PUSH
17673: LD_INT 21
17675: PUSH
17676: LD_INT 22
17678: PUSH
17679: LD_INT 23
17681: PUSH
17682: LD_INT 24
17684: PUSH
17685: EMPTY
17686: LIST
17687: LIST
17688: LIST
17689: LIST
17690: ST_TO_ADDR
17691: GO 17976
17693: LD_INT 43
17695: DOUBLE
17696: EQUAL
17697: IFTRUE 17701
17699: GO 17727
17701: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
17702: LD_ADDR_VAR 0 3
17706: PUSH
17707: LD_INT 21
17709: PUSH
17710: LD_INT 22
17712: PUSH
17713: LD_INT 23
17715: PUSH
17716: LD_INT 24
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: ST_TO_ADDR
17725: GO 17976
17727: LD_INT 44
17729: DOUBLE
17730: EQUAL
17731: IFTRUE 17735
17733: GO 17761
17735: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
17736: LD_ADDR_VAR 0 3
17740: PUSH
17741: LD_INT 21
17743: PUSH
17744: LD_INT 22
17746: PUSH
17747: LD_INT 23
17749: PUSH
17750: LD_INT 24
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: ST_TO_ADDR
17759: GO 17976
17761: LD_INT 45
17763: DOUBLE
17764: EQUAL
17765: IFTRUE 17769
17767: GO 17795
17769: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
17770: LD_ADDR_VAR 0 3
17774: PUSH
17775: LD_INT 21
17777: PUSH
17778: LD_INT 22
17780: PUSH
17781: LD_INT 23
17783: PUSH
17784: LD_INT 24
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: ST_TO_ADDR
17793: GO 17976
17795: LD_INT 49
17797: DOUBLE
17798: EQUAL
17799: IFTRUE 17803
17801: GO 17829
17803: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
17804: LD_ADDR_VAR 0 3
17808: PUSH
17809: LD_INT 21
17811: PUSH
17812: LD_INT 22
17814: PUSH
17815: LD_INT 23
17817: PUSH
17818: LD_INT 24
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: ST_TO_ADDR
17827: GO 17976
17829: LD_INT 51
17831: DOUBLE
17832: EQUAL
17833: IFTRUE 17837
17835: GO 17863
17837: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
17838: LD_ADDR_VAR 0 3
17842: PUSH
17843: LD_INT 21
17845: PUSH
17846: LD_INT 22
17848: PUSH
17849: LD_INT 23
17851: PUSH
17852: LD_INT 24
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: ST_TO_ADDR
17861: GO 17976
17863: LD_INT 52
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17897
17871: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
17872: LD_ADDR_VAR 0 3
17876: PUSH
17877: LD_INT 21
17879: PUSH
17880: LD_INT 22
17882: PUSH
17883: LD_INT 23
17885: PUSH
17886: LD_INT 24
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: ST_TO_ADDR
17895: GO 17976
17897: LD_INT 53
17899: DOUBLE
17900: EQUAL
17901: IFTRUE 17905
17903: GO 17923
17905: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
17906: LD_ADDR_VAR 0 3
17910: PUSH
17911: LD_INT 23
17913: PUSH
17914: LD_INT 24
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: ST_TO_ADDR
17921: GO 17976
17923: LD_INT 46
17925: DOUBLE
17926: EQUAL
17927: IFTRUE 17931
17929: GO 17949
17931: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
17932: LD_ADDR_VAR 0 3
17936: PUSH
17937: LD_INT 23
17939: PUSH
17940: LD_INT 24
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: ST_TO_ADDR
17947: GO 17976
17949: LD_INT 47
17951: DOUBLE
17952: EQUAL
17953: IFTRUE 17957
17955: GO 17975
17957: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17958: LD_ADDR_VAR 0 3
17962: PUSH
17963: LD_INT 23
17965: PUSH
17966: LD_INT 24
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: ST_TO_ADDR
17973: GO 17976
17975: POP
// result := ( chassis in result ) ;
17976: LD_ADDR_VAR 0 3
17980: PUSH
17981: LD_VAR 0 1
17985: PUSH
17986: LD_VAR 0 3
17990: IN
17991: ST_TO_ADDR
// end ;
17992: LD_VAR 0 3
17996: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
17997: LD_INT 0
17999: PPUSH
18000: PPUSH
18001: PPUSH
18002: PPUSH
18003: PPUSH
18004: PPUSH
18005: PPUSH
// result := array ;
18006: LD_ADDR_VAR 0 5
18010: PUSH
18011: LD_VAR 0 1
18015: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18016: LD_VAR 0 1
18020: NOT
18021: PUSH
18022: LD_VAR 0 2
18026: NOT
18027: OR
18028: PUSH
18029: LD_VAR 0 3
18033: NOT
18034: OR
18035: PUSH
18036: LD_VAR 0 2
18040: PUSH
18041: LD_VAR 0 1
18045: GREATER
18046: OR
18047: PUSH
18048: LD_VAR 0 3
18052: PUSH
18053: LD_VAR 0 1
18057: GREATER
18058: OR
18059: IFFALSE 18063
// exit ;
18061: GO 18359
// if direction then
18063: LD_VAR 0 4
18067: IFFALSE 18131
// begin d := 1 ;
18069: LD_ADDR_VAR 0 9
18073: PUSH
18074: LD_INT 1
18076: ST_TO_ADDR
// if i_from > i_to then
18077: LD_VAR 0 2
18081: PUSH
18082: LD_VAR 0 3
18086: GREATER
18087: IFFALSE 18113
// length := ( array - i_from ) + i_to else
18089: LD_ADDR_VAR 0 11
18093: PUSH
18094: LD_VAR 0 1
18098: PUSH
18099: LD_VAR 0 2
18103: MINUS
18104: PUSH
18105: LD_VAR 0 3
18109: PLUS
18110: ST_TO_ADDR
18111: GO 18129
// length := i_to - i_from ;
18113: LD_ADDR_VAR 0 11
18117: PUSH
18118: LD_VAR 0 3
18122: PUSH
18123: LD_VAR 0 2
18127: MINUS
18128: ST_TO_ADDR
// end else
18129: GO 18192
// begin d := - 1 ;
18131: LD_ADDR_VAR 0 9
18135: PUSH
18136: LD_INT 1
18138: NEG
18139: ST_TO_ADDR
// if i_from > i_to then
18140: LD_VAR 0 2
18144: PUSH
18145: LD_VAR 0 3
18149: GREATER
18150: IFFALSE 18170
// length := i_from - i_to else
18152: LD_ADDR_VAR 0 11
18156: PUSH
18157: LD_VAR 0 2
18161: PUSH
18162: LD_VAR 0 3
18166: MINUS
18167: ST_TO_ADDR
18168: GO 18192
// length := ( array - i_to ) + i_from ;
18170: LD_ADDR_VAR 0 11
18174: PUSH
18175: LD_VAR 0 1
18179: PUSH
18180: LD_VAR 0 3
18184: MINUS
18185: PUSH
18186: LD_VAR 0 2
18190: PLUS
18191: ST_TO_ADDR
// end ; if not length then
18192: LD_VAR 0 11
18196: NOT
18197: IFFALSE 18201
// exit ;
18199: GO 18359
// tmp := array ;
18201: LD_ADDR_VAR 0 10
18205: PUSH
18206: LD_VAR 0 1
18210: ST_TO_ADDR
// for i = 1 to length do
18211: LD_ADDR_VAR 0 6
18215: PUSH
18216: DOUBLE
18217: LD_INT 1
18219: DEC
18220: ST_TO_ADDR
18221: LD_VAR 0 11
18225: PUSH
18226: FOR_TO
18227: IFFALSE 18347
// begin for j = 1 to array do
18229: LD_ADDR_VAR 0 7
18233: PUSH
18234: DOUBLE
18235: LD_INT 1
18237: DEC
18238: ST_TO_ADDR
18239: LD_VAR 0 1
18243: PUSH
18244: FOR_TO
18245: IFFALSE 18333
// begin k := j + d ;
18247: LD_ADDR_VAR 0 8
18251: PUSH
18252: LD_VAR 0 7
18256: PUSH
18257: LD_VAR 0 9
18261: PLUS
18262: ST_TO_ADDR
// if k > array then
18263: LD_VAR 0 8
18267: PUSH
18268: LD_VAR 0 1
18272: GREATER
18273: IFFALSE 18283
// k := 1 ;
18275: LD_ADDR_VAR 0 8
18279: PUSH
18280: LD_INT 1
18282: ST_TO_ADDR
// if not k then
18283: LD_VAR 0 8
18287: NOT
18288: IFFALSE 18300
// k := array ;
18290: LD_ADDR_VAR 0 8
18294: PUSH
18295: LD_VAR 0 1
18299: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18300: LD_ADDR_VAR 0 10
18304: PUSH
18305: LD_VAR 0 10
18309: PPUSH
18310: LD_VAR 0 8
18314: PPUSH
18315: LD_VAR 0 1
18319: PUSH
18320: LD_VAR 0 7
18324: ARRAY
18325: PPUSH
18326: CALL_OW 1
18330: ST_TO_ADDR
// end ;
18331: GO 18244
18333: POP
18334: POP
// array := tmp ;
18335: LD_ADDR_VAR 0 1
18339: PUSH
18340: LD_VAR 0 10
18344: ST_TO_ADDR
// end ;
18345: GO 18226
18347: POP
18348: POP
// result := array ;
18349: LD_ADDR_VAR 0 5
18353: PUSH
18354: LD_VAR 0 1
18358: ST_TO_ADDR
// end ;
18359: LD_VAR 0 5
18363: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
// result := 0 ;
18368: LD_ADDR_VAR 0 3
18372: PUSH
18373: LD_INT 0
18375: ST_TO_ADDR
// if not array or not value in array then
18376: LD_VAR 0 1
18380: NOT
18381: PUSH
18382: LD_VAR 0 2
18386: PUSH
18387: LD_VAR 0 1
18391: IN
18392: NOT
18393: OR
18394: IFFALSE 18398
// exit ;
18396: GO 18452
// for i = 1 to array do
18398: LD_ADDR_VAR 0 4
18402: PUSH
18403: DOUBLE
18404: LD_INT 1
18406: DEC
18407: ST_TO_ADDR
18408: LD_VAR 0 1
18412: PUSH
18413: FOR_TO
18414: IFFALSE 18450
// if value = array [ i ] then
18416: LD_VAR 0 2
18420: PUSH
18421: LD_VAR 0 1
18425: PUSH
18426: LD_VAR 0 4
18430: ARRAY
18431: EQUAL
18432: IFFALSE 18448
// begin result := i ;
18434: LD_ADDR_VAR 0 3
18438: PUSH
18439: LD_VAR 0 4
18443: ST_TO_ADDR
// exit ;
18444: POP
18445: POP
18446: GO 18452
// end ;
18448: GO 18413
18450: POP
18451: POP
// end ;
18452: LD_VAR 0 3
18456: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
18457: LD_INT 0
18459: PPUSH
// vc_chassis := chassis ;
18460: LD_ADDR_OWVAR 37
18464: PUSH
18465: LD_VAR 0 1
18469: ST_TO_ADDR
// vc_engine := engine ;
18470: LD_ADDR_OWVAR 39
18474: PUSH
18475: LD_VAR 0 2
18479: ST_TO_ADDR
// vc_control := control ;
18480: LD_ADDR_OWVAR 38
18484: PUSH
18485: LD_VAR 0 3
18489: ST_TO_ADDR
// vc_weapon := weapon ;
18490: LD_ADDR_OWVAR 40
18494: PUSH
18495: LD_VAR 0 4
18499: ST_TO_ADDR
// vc_fuel_battery := fuel ;
18500: LD_ADDR_OWVAR 41
18504: PUSH
18505: LD_VAR 0 5
18509: ST_TO_ADDR
// end ;
18510: LD_VAR 0 6
18514: RET
// export function WantPlant ( unit ) ; var task ; begin
18515: LD_INT 0
18517: PPUSH
18518: PPUSH
// result := false ;
18519: LD_ADDR_VAR 0 2
18523: PUSH
18524: LD_INT 0
18526: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
18527: LD_ADDR_VAR 0 3
18531: PUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: CALL_OW 437
18541: ST_TO_ADDR
// if task then
18542: LD_VAR 0 3
18546: IFFALSE 18574
// if task [ 1 ] [ 1 ] = p then
18548: LD_VAR 0 3
18552: PUSH
18553: LD_INT 1
18555: ARRAY
18556: PUSH
18557: LD_INT 1
18559: ARRAY
18560: PUSH
18561: LD_STRING p
18563: EQUAL
18564: IFFALSE 18574
// result := true ;
18566: LD_ADDR_VAR 0 2
18570: PUSH
18571: LD_INT 1
18573: ST_TO_ADDR
// end ;
18574: LD_VAR 0 2
18578: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
18579: LD_INT 0
18581: PPUSH
18582: PPUSH
18583: PPUSH
18584: PPUSH
// if pos < 1 then
18585: LD_VAR 0 2
18589: PUSH
18590: LD_INT 1
18592: LESS
18593: IFFALSE 18597
// exit ;
18595: GO 18900
// if pos = 1 then
18597: LD_VAR 0 2
18601: PUSH
18602: LD_INT 1
18604: EQUAL
18605: IFFALSE 18638
// result := Replace ( arr , pos [ 1 ] , value ) else
18607: LD_ADDR_VAR 0 4
18611: PUSH
18612: LD_VAR 0 1
18616: PPUSH
18617: LD_VAR 0 2
18621: PUSH
18622: LD_INT 1
18624: ARRAY
18625: PPUSH
18626: LD_VAR 0 3
18630: PPUSH
18631: CALL_OW 1
18635: ST_TO_ADDR
18636: GO 18900
// begin tmp := arr ;
18638: LD_ADDR_VAR 0 6
18642: PUSH
18643: LD_VAR 0 1
18647: ST_TO_ADDR
// s_arr := [ tmp ] ;
18648: LD_ADDR_VAR 0 7
18652: PUSH
18653: LD_VAR 0 6
18657: PUSH
18658: EMPTY
18659: LIST
18660: ST_TO_ADDR
// for i = 1 to pos - 1 do
18661: LD_ADDR_VAR 0 5
18665: PUSH
18666: DOUBLE
18667: LD_INT 1
18669: DEC
18670: ST_TO_ADDR
18671: LD_VAR 0 2
18675: PUSH
18676: LD_INT 1
18678: MINUS
18679: PUSH
18680: FOR_TO
18681: IFFALSE 18726
// begin tmp := tmp [ pos [ i ] ] ;
18683: LD_ADDR_VAR 0 6
18687: PUSH
18688: LD_VAR 0 6
18692: PUSH
18693: LD_VAR 0 2
18697: PUSH
18698: LD_VAR 0 5
18702: ARRAY
18703: ARRAY
18704: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
18705: LD_ADDR_VAR 0 7
18709: PUSH
18710: LD_VAR 0 7
18714: PUSH
18715: LD_VAR 0 6
18719: PUSH
18720: EMPTY
18721: LIST
18722: ADD
18723: ST_TO_ADDR
// end ;
18724: GO 18680
18726: POP
18727: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
18728: LD_ADDR_VAR 0 6
18732: PUSH
18733: LD_VAR 0 6
18737: PPUSH
18738: LD_VAR 0 2
18742: PUSH
18743: LD_VAR 0 2
18747: ARRAY
18748: PPUSH
18749: LD_VAR 0 3
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
18759: LD_ADDR_VAR 0 7
18763: PUSH
18764: LD_VAR 0 7
18768: PPUSH
18769: LD_VAR 0 7
18773: PPUSH
18774: LD_VAR 0 6
18778: PPUSH
18779: CALL_OW 1
18783: ST_TO_ADDR
// for i = s_arr downto 2 do
18784: LD_ADDR_VAR 0 5
18788: PUSH
18789: DOUBLE
18790: LD_VAR 0 7
18794: INC
18795: ST_TO_ADDR
18796: LD_INT 2
18798: PUSH
18799: FOR_DOWNTO
18800: IFFALSE 18884
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
18802: LD_ADDR_VAR 0 6
18806: PUSH
18807: LD_VAR 0 7
18811: PUSH
18812: LD_VAR 0 5
18816: PUSH
18817: LD_INT 1
18819: MINUS
18820: ARRAY
18821: PPUSH
18822: LD_VAR 0 2
18826: PUSH
18827: LD_VAR 0 5
18831: PUSH
18832: LD_INT 1
18834: MINUS
18835: ARRAY
18836: PPUSH
18837: LD_VAR 0 7
18841: PUSH
18842: LD_VAR 0 5
18846: ARRAY
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
18853: LD_ADDR_VAR 0 7
18857: PUSH
18858: LD_VAR 0 7
18862: PPUSH
18863: LD_VAR 0 5
18867: PUSH
18868: LD_INT 1
18870: MINUS
18871: PPUSH
18872: LD_VAR 0 6
18876: PPUSH
18877: CALL_OW 1
18881: ST_TO_ADDR
// end ;
18882: GO 18799
18884: POP
18885: POP
// result := s_arr [ 1 ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_VAR 0 7
18895: PUSH
18896: LD_INT 1
18898: ARRAY
18899: ST_TO_ADDR
// end ; end ;
18900: LD_VAR 0 4
18904: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
18905: LD_INT 0
18907: PPUSH
18908: PPUSH
// if not list then
18909: LD_VAR 0 1
18913: NOT
18914: IFFALSE 18918
// exit ;
18916: GO 19009
// i := list [ pos1 ] ;
18918: LD_ADDR_VAR 0 5
18922: PUSH
18923: LD_VAR 0 1
18927: PUSH
18928: LD_VAR 0 2
18932: ARRAY
18933: ST_TO_ADDR
// if not i then
18934: LD_VAR 0 5
18938: NOT
18939: IFFALSE 18943
// exit ;
18941: GO 19009
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_VAR 0 1
18952: PPUSH
18953: LD_VAR 0 2
18957: PPUSH
18958: LD_VAR 0 1
18962: PUSH
18963: LD_VAR 0 3
18967: ARRAY
18968: PPUSH
18969: CALL_OW 1
18973: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
18974: LD_ADDR_VAR 0 1
18978: PUSH
18979: LD_VAR 0 1
18983: PPUSH
18984: LD_VAR 0 3
18988: PPUSH
18989: LD_VAR 0 5
18993: PPUSH
18994: CALL_OW 1
18998: ST_TO_ADDR
// result := list ;
18999: LD_ADDR_VAR 0 4
19003: PUSH
19004: LD_VAR 0 1
19008: ST_TO_ADDR
// end ;
19009: LD_VAR 0 4
19013: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19014: LD_INT 0
19016: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19017: LD_ADDR_VAR 0 5
19021: PUSH
19022: LD_VAR 0 1
19026: PPUSH
19027: CALL_OW 250
19031: PPUSH
19032: LD_VAR 0 1
19036: PPUSH
19037: CALL_OW 251
19041: PPUSH
19042: LD_VAR 0 2
19046: PPUSH
19047: LD_VAR 0 3
19051: PPUSH
19052: LD_VAR 0 4
19056: PPUSH
19057: CALL 19067 0 5
19061: ST_TO_ADDR
// end ;
19062: LD_VAR 0 5
19066: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19067: LD_INT 0
19069: PPUSH
19070: PPUSH
19071: PPUSH
19072: PPUSH
// if not list then
19073: LD_VAR 0 3
19077: NOT
19078: IFFALSE 19082
// exit ;
19080: GO 19470
// result := [ ] ;
19082: LD_ADDR_VAR 0 6
19086: PUSH
19087: EMPTY
19088: ST_TO_ADDR
// for i in list do
19089: LD_ADDR_VAR 0 7
19093: PUSH
19094: LD_VAR 0 3
19098: PUSH
19099: FOR_IN
19100: IFFALSE 19302
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19102: LD_ADDR_VAR 0 9
19106: PUSH
19107: LD_VAR 0 7
19111: PPUSH
19112: LD_VAR 0 1
19116: PPUSH
19117: LD_VAR 0 2
19121: PPUSH
19122: CALL_OW 297
19126: ST_TO_ADDR
// if not result then
19127: LD_VAR 0 6
19131: NOT
19132: IFFALSE 19158
// result := [ [ i , tmp ] ] else
19134: LD_ADDR_VAR 0 6
19138: PUSH
19139: LD_VAR 0 7
19143: PUSH
19144: LD_VAR 0 9
19148: PUSH
19149: EMPTY
19150: LIST
19151: LIST
19152: PUSH
19153: EMPTY
19154: LIST
19155: ST_TO_ADDR
19156: GO 19300
// begin if result [ result ] [ 2 ] < tmp then
19158: LD_VAR 0 6
19162: PUSH
19163: LD_VAR 0 6
19167: ARRAY
19168: PUSH
19169: LD_INT 2
19171: ARRAY
19172: PUSH
19173: LD_VAR 0 9
19177: LESS
19178: IFFALSE 19220
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19180: LD_ADDR_VAR 0 6
19184: PUSH
19185: LD_VAR 0 6
19189: PPUSH
19190: LD_VAR 0 6
19194: PUSH
19195: LD_INT 1
19197: PLUS
19198: PPUSH
19199: LD_VAR 0 7
19203: PUSH
19204: LD_VAR 0 9
19208: PUSH
19209: EMPTY
19210: LIST
19211: LIST
19212: PPUSH
19213: CALL_OW 2
19217: ST_TO_ADDR
19218: GO 19300
// for j = 1 to result do
19220: LD_ADDR_VAR 0 8
19224: PUSH
19225: DOUBLE
19226: LD_INT 1
19228: DEC
19229: ST_TO_ADDR
19230: LD_VAR 0 6
19234: PUSH
19235: FOR_TO
19236: IFFALSE 19298
// begin if tmp < result [ j ] [ 2 ] then
19238: LD_VAR 0 9
19242: PUSH
19243: LD_VAR 0 6
19247: PUSH
19248: LD_VAR 0 8
19252: ARRAY
19253: PUSH
19254: LD_INT 2
19256: ARRAY
19257: LESS
19258: IFFALSE 19296
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19260: LD_ADDR_VAR 0 6
19264: PUSH
19265: LD_VAR 0 6
19269: PPUSH
19270: LD_VAR 0 8
19274: PPUSH
19275: LD_VAR 0 7
19279: PUSH
19280: LD_VAR 0 9
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PPUSH
19289: CALL_OW 2
19293: ST_TO_ADDR
// break ;
19294: GO 19298
// end ; end ;
19296: GO 19235
19298: POP
19299: POP
// end ; end ;
19300: GO 19099
19302: POP
19303: POP
// if result and not asc then
19304: LD_VAR 0 6
19308: PUSH
19309: LD_VAR 0 4
19313: NOT
19314: AND
19315: IFFALSE 19390
// begin tmp := result ;
19317: LD_ADDR_VAR 0 9
19321: PUSH
19322: LD_VAR 0 6
19326: ST_TO_ADDR
// for i = tmp downto 1 do
19327: LD_ADDR_VAR 0 7
19331: PUSH
19332: DOUBLE
19333: LD_VAR 0 9
19337: INC
19338: ST_TO_ADDR
19339: LD_INT 1
19341: PUSH
19342: FOR_DOWNTO
19343: IFFALSE 19388
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
19345: LD_ADDR_VAR 0 6
19349: PUSH
19350: LD_VAR 0 6
19354: PPUSH
19355: LD_VAR 0 9
19359: PUSH
19360: LD_VAR 0 7
19364: MINUS
19365: PUSH
19366: LD_INT 1
19368: PLUS
19369: PPUSH
19370: LD_VAR 0 9
19374: PUSH
19375: LD_VAR 0 7
19379: ARRAY
19380: PPUSH
19381: CALL_OW 1
19385: ST_TO_ADDR
19386: GO 19342
19388: POP
19389: POP
// end ; tmp := [ ] ;
19390: LD_ADDR_VAR 0 9
19394: PUSH
19395: EMPTY
19396: ST_TO_ADDR
// if mode then
19397: LD_VAR 0 5
19401: IFFALSE 19470
// begin for i = 1 to result do
19403: LD_ADDR_VAR 0 7
19407: PUSH
19408: DOUBLE
19409: LD_INT 1
19411: DEC
19412: ST_TO_ADDR
19413: LD_VAR 0 6
19417: PUSH
19418: FOR_TO
19419: IFFALSE 19458
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
19421: LD_ADDR_VAR 0 9
19425: PUSH
19426: LD_VAR 0 9
19430: PPUSH
19431: LD_VAR 0 7
19435: PPUSH
19436: LD_VAR 0 6
19440: PUSH
19441: LD_VAR 0 7
19445: ARRAY
19446: PUSH
19447: LD_INT 1
19449: ARRAY
19450: PPUSH
19451: CALL_OW 1
19455: ST_TO_ADDR
19456: GO 19418
19458: POP
19459: POP
// result := tmp ;
19460: LD_ADDR_VAR 0 6
19464: PUSH
19465: LD_VAR 0 9
19469: ST_TO_ADDR
// end ; end ;
19470: LD_VAR 0 6
19474: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
19475: LD_INT 0
19477: PPUSH
19478: PPUSH
19479: PPUSH
19480: PPUSH
19481: PPUSH
19482: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
19483: LD_ADDR_VAR 0 5
19487: PUSH
19488: LD_INT 0
19490: PUSH
19491: LD_INT 0
19493: PUSH
19494: LD_INT 0
19496: PUSH
19497: EMPTY
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: ST_TO_ADDR
// if not x or not y then
19505: LD_VAR 0 2
19509: NOT
19510: PUSH
19511: LD_VAR 0 3
19515: NOT
19516: OR
19517: IFFALSE 19521
// exit ;
19519: GO 21167
// if not range then
19521: LD_VAR 0 4
19525: NOT
19526: IFFALSE 19536
// range := 10 ;
19528: LD_ADDR_VAR 0 4
19532: PUSH
19533: LD_INT 10
19535: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19536: LD_ADDR_VAR 0 8
19540: PUSH
19541: LD_INT 81
19543: PUSH
19544: LD_VAR 0 1
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PUSH
19553: LD_INT 92
19555: PUSH
19556: LD_VAR 0 2
19560: PUSH
19561: LD_VAR 0 3
19565: PUSH
19566: LD_VAR 0 4
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: LIST
19575: LIST
19576: PUSH
19577: LD_INT 3
19579: PUSH
19580: LD_INT 21
19582: PUSH
19583: LD_INT 3
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: PUSH
19594: EMPTY
19595: LIST
19596: LIST
19597: LIST
19598: PPUSH
19599: CALL_OW 69
19603: ST_TO_ADDR
// if not tmp then
19604: LD_VAR 0 8
19608: NOT
19609: IFFALSE 19613
// exit ;
19611: GO 21167
// for i in tmp do
19613: LD_ADDR_VAR 0 6
19617: PUSH
19618: LD_VAR 0 8
19622: PUSH
19623: FOR_IN
19624: IFFALSE 21142
// begin points := [ 0 , 0 , 0 ] ;
19626: LD_ADDR_VAR 0 9
19630: PUSH
19631: LD_INT 0
19633: PUSH
19634: LD_INT 0
19636: PUSH
19637: LD_INT 0
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: ST_TO_ADDR
// bpoints := 1 ;
19645: LD_ADDR_VAR 0 10
19649: PUSH
19650: LD_INT 1
19652: ST_TO_ADDR
// case GetType ( i ) of unit_human :
19653: LD_VAR 0 6
19657: PPUSH
19658: CALL_OW 247
19662: PUSH
19663: LD_INT 1
19665: DOUBLE
19666: EQUAL
19667: IFTRUE 19671
19669: GO 20249
19671: POP
// begin if GetClass ( i ) = 1 then
19672: LD_VAR 0 6
19676: PPUSH
19677: CALL_OW 257
19681: PUSH
19682: LD_INT 1
19684: EQUAL
19685: IFFALSE 19706
// points := [ 10 , 5 , 3 ] ;
19687: LD_ADDR_VAR 0 9
19691: PUSH
19692: LD_INT 10
19694: PUSH
19695: LD_INT 5
19697: PUSH
19698: LD_INT 3
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: LIST
19705: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
19706: LD_VAR 0 6
19710: PPUSH
19711: CALL_OW 257
19715: PUSH
19716: LD_INT 2
19718: PUSH
19719: LD_INT 3
19721: PUSH
19722: LD_INT 4
19724: PUSH
19725: EMPTY
19726: LIST
19727: LIST
19728: LIST
19729: IN
19730: IFFALSE 19751
// points := [ 3 , 2 , 1 ] ;
19732: LD_ADDR_VAR 0 9
19736: PUSH
19737: LD_INT 3
19739: PUSH
19740: LD_INT 2
19742: PUSH
19743: LD_INT 1
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: LIST
19750: ST_TO_ADDR
// if GetClass ( i ) = 5 then
19751: LD_VAR 0 6
19755: PPUSH
19756: CALL_OW 257
19760: PUSH
19761: LD_INT 5
19763: EQUAL
19764: IFFALSE 19785
// points := [ 130 , 5 , 2 ] ;
19766: LD_ADDR_VAR 0 9
19770: PUSH
19771: LD_INT 130
19773: PUSH
19774: LD_INT 5
19776: PUSH
19777: LD_INT 2
19779: PUSH
19780: EMPTY
19781: LIST
19782: LIST
19783: LIST
19784: ST_TO_ADDR
// if GetClass ( i ) = 8 then
19785: LD_VAR 0 6
19789: PPUSH
19790: CALL_OW 257
19794: PUSH
19795: LD_INT 8
19797: EQUAL
19798: IFFALSE 19819
// points := [ 35 , 35 , 30 ] ;
19800: LD_ADDR_VAR 0 9
19804: PUSH
19805: LD_INT 35
19807: PUSH
19808: LD_INT 35
19810: PUSH
19811: LD_INT 30
19813: PUSH
19814: EMPTY
19815: LIST
19816: LIST
19817: LIST
19818: ST_TO_ADDR
// if GetClass ( i ) = 9 then
19819: LD_VAR 0 6
19823: PPUSH
19824: CALL_OW 257
19828: PUSH
19829: LD_INT 9
19831: EQUAL
19832: IFFALSE 19853
// points := [ 20 , 55 , 40 ] ;
19834: LD_ADDR_VAR 0 9
19838: PUSH
19839: LD_INT 20
19841: PUSH
19842: LD_INT 55
19844: PUSH
19845: LD_INT 40
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: LIST
19852: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
19853: LD_VAR 0 6
19857: PPUSH
19858: CALL_OW 257
19862: PUSH
19863: LD_INT 12
19865: PUSH
19866: LD_INT 16
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: IN
19873: IFFALSE 19894
// points := [ 5 , 3 , 2 ] ;
19875: LD_ADDR_VAR 0 9
19879: PUSH
19880: LD_INT 5
19882: PUSH
19883: LD_INT 3
19885: PUSH
19886: LD_INT 2
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: ST_TO_ADDR
// if GetClass ( i ) = 17 then
19894: LD_VAR 0 6
19898: PPUSH
19899: CALL_OW 257
19903: PUSH
19904: LD_INT 17
19906: EQUAL
19907: IFFALSE 19928
// points := [ 100 , 50 , 75 ] ;
19909: LD_ADDR_VAR 0 9
19913: PUSH
19914: LD_INT 100
19916: PUSH
19917: LD_INT 50
19919: PUSH
19920: LD_INT 75
19922: PUSH
19923: EMPTY
19924: LIST
19925: LIST
19926: LIST
19927: ST_TO_ADDR
// if GetClass ( i ) = 15 then
19928: LD_VAR 0 6
19932: PPUSH
19933: CALL_OW 257
19937: PUSH
19938: LD_INT 15
19940: EQUAL
19941: IFFALSE 19962
// points := [ 10 , 5 , 3 ] ;
19943: LD_ADDR_VAR 0 9
19947: PUSH
19948: LD_INT 10
19950: PUSH
19951: LD_INT 5
19953: PUSH
19954: LD_INT 3
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: ST_TO_ADDR
// if GetClass ( i ) = 14 then
19962: LD_VAR 0 6
19966: PPUSH
19967: CALL_OW 257
19971: PUSH
19972: LD_INT 14
19974: EQUAL
19975: IFFALSE 19996
// points := [ 10 , 0 , 0 ] ;
19977: LD_ADDR_VAR 0 9
19981: PUSH
19982: LD_INT 10
19984: PUSH
19985: LD_INT 0
19987: PUSH
19988: LD_INT 0
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: ST_TO_ADDR
// if GetClass ( i ) = 11 then
19996: LD_VAR 0 6
20000: PPUSH
20001: CALL_OW 257
20005: PUSH
20006: LD_INT 11
20008: EQUAL
20009: IFFALSE 20030
// points := [ 30 , 10 , 5 ] ;
20011: LD_ADDR_VAR 0 9
20015: PUSH
20016: LD_INT 30
20018: PUSH
20019: LD_INT 10
20021: PUSH
20022: LD_INT 5
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20030: LD_VAR 0 1
20034: PPUSH
20035: LD_INT 5
20037: PPUSH
20038: CALL_OW 321
20042: PUSH
20043: LD_INT 2
20045: EQUAL
20046: IFFALSE 20063
// bpoints := bpoints * 1.8 ;
20048: LD_ADDR_VAR 0 10
20052: PUSH
20053: LD_VAR 0 10
20057: PUSH
20058: LD_REAL  1.80000000000000E+0000
20061: MUL
20062: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20063: LD_VAR 0 6
20067: PPUSH
20068: CALL_OW 257
20072: PUSH
20073: LD_INT 1
20075: PUSH
20076: LD_INT 2
20078: PUSH
20079: LD_INT 3
20081: PUSH
20082: LD_INT 4
20084: PUSH
20085: EMPTY
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: IN
20091: PUSH
20092: LD_VAR 0 1
20096: PPUSH
20097: LD_INT 51
20099: PPUSH
20100: CALL_OW 321
20104: PUSH
20105: LD_INT 2
20107: EQUAL
20108: AND
20109: IFFALSE 20126
// bpoints := bpoints * 1.2 ;
20111: LD_ADDR_VAR 0 10
20115: PUSH
20116: LD_VAR 0 10
20120: PUSH
20121: LD_REAL  1.20000000000000E+0000
20124: MUL
20125: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20126: LD_VAR 0 6
20130: PPUSH
20131: CALL_OW 257
20135: PUSH
20136: LD_INT 5
20138: PUSH
20139: LD_INT 7
20141: PUSH
20142: LD_INT 9
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: LIST
20149: IN
20150: PUSH
20151: LD_VAR 0 1
20155: PPUSH
20156: LD_INT 52
20158: PPUSH
20159: CALL_OW 321
20163: PUSH
20164: LD_INT 2
20166: EQUAL
20167: AND
20168: IFFALSE 20185
// bpoints := bpoints * 1.5 ;
20170: LD_ADDR_VAR 0 10
20174: PUSH
20175: LD_VAR 0 10
20179: PUSH
20180: LD_REAL  1.50000000000000E+0000
20183: MUL
20184: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20185: LD_VAR 0 1
20189: PPUSH
20190: LD_INT 66
20192: PPUSH
20193: CALL_OW 321
20197: PUSH
20198: LD_INT 2
20200: EQUAL
20201: IFFALSE 20218
// bpoints := bpoints * 1.1 ;
20203: LD_ADDR_VAR 0 10
20207: PUSH
20208: LD_VAR 0 10
20212: PUSH
20213: LD_REAL  1.10000000000000E+0000
20216: MUL
20217: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20218: LD_ADDR_VAR 0 10
20222: PUSH
20223: LD_VAR 0 10
20227: PUSH
20228: LD_VAR 0 6
20232: PPUSH
20233: LD_INT 1
20235: PPUSH
20236: CALL_OW 259
20240: PUSH
20241: LD_REAL  1.15000000000000E+0000
20244: MUL
20245: MUL
20246: ST_TO_ADDR
// end ; unit_vehicle :
20247: GO 21071
20249: LD_INT 2
20251: DOUBLE
20252: EQUAL
20253: IFTRUE 20257
20255: GO 21059
20257: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20258: LD_VAR 0 6
20262: PPUSH
20263: CALL_OW 264
20267: PUSH
20268: LD_INT 2
20270: PUSH
20271: LD_INT 42
20273: PUSH
20274: LD_INT 24
20276: PUSH
20277: EMPTY
20278: LIST
20279: LIST
20280: LIST
20281: IN
20282: IFFALSE 20303
// points := [ 25 , 5 , 3 ] ;
20284: LD_ADDR_VAR 0 9
20288: PUSH
20289: LD_INT 25
20291: PUSH
20292: LD_INT 5
20294: PUSH
20295: LD_INT 3
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: LIST
20302: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20303: LD_VAR 0 6
20307: PPUSH
20308: CALL_OW 264
20312: PUSH
20313: LD_INT 4
20315: PUSH
20316: LD_INT 43
20318: PUSH
20319: LD_INT 25
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: LIST
20326: IN
20327: IFFALSE 20348
// points := [ 40 , 15 , 5 ] ;
20329: LD_ADDR_VAR 0 9
20333: PUSH
20334: LD_INT 40
20336: PUSH
20337: LD_INT 15
20339: PUSH
20340: LD_INT 5
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: LIST
20347: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
20348: LD_VAR 0 6
20352: PPUSH
20353: CALL_OW 264
20357: PUSH
20358: LD_INT 3
20360: PUSH
20361: LD_INT 23
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: IN
20368: IFFALSE 20389
// points := [ 7 , 25 , 8 ] ;
20370: LD_ADDR_VAR 0 9
20374: PUSH
20375: LD_INT 7
20377: PUSH
20378: LD_INT 25
20380: PUSH
20381: LD_INT 8
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
20389: LD_VAR 0 6
20393: PPUSH
20394: CALL_OW 264
20398: PUSH
20399: LD_INT 5
20401: PUSH
20402: LD_INT 27
20404: PUSH
20405: LD_INT 44
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: LIST
20412: IN
20413: IFFALSE 20434
// points := [ 14 , 50 , 16 ] ;
20415: LD_ADDR_VAR 0 9
20419: PUSH
20420: LD_INT 14
20422: PUSH
20423: LD_INT 50
20425: PUSH
20426: LD_INT 16
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: LIST
20433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
20434: LD_VAR 0 6
20438: PPUSH
20439: CALL_OW 264
20443: PUSH
20444: LD_INT 6
20446: PUSH
20447: LD_INT 46
20449: PUSH
20450: EMPTY
20451: LIST
20452: LIST
20453: IN
20454: IFFALSE 20475
// points := [ 32 , 120 , 70 ] ;
20456: LD_ADDR_VAR 0 9
20460: PUSH
20461: LD_INT 32
20463: PUSH
20464: LD_INT 120
20466: PUSH
20467: LD_INT 70
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: LIST
20474: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
20475: LD_VAR 0 6
20479: PPUSH
20480: CALL_OW 264
20484: PUSH
20485: LD_INT 7
20487: PUSH
20488: LD_INT 28
20490: PUSH
20491: LD_INT 45
20493: PUSH
20494: EMPTY
20495: LIST
20496: LIST
20497: LIST
20498: IN
20499: IFFALSE 20520
// points := [ 35 , 20 , 45 ] ;
20501: LD_ADDR_VAR 0 9
20505: PUSH
20506: LD_INT 35
20508: PUSH
20509: LD_INT 20
20511: PUSH
20512: LD_INT 45
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: LIST
20519: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
20520: LD_VAR 0 6
20524: PPUSH
20525: CALL_OW 264
20529: PUSH
20530: LD_INT 47
20532: PUSH
20533: EMPTY
20534: LIST
20535: IN
20536: IFFALSE 20557
// points := [ 67 , 45 , 75 ] ;
20538: LD_ADDR_VAR 0 9
20542: PUSH
20543: LD_INT 67
20545: PUSH
20546: LD_INT 45
20548: PUSH
20549: LD_INT 75
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: LIST
20556: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
20557: LD_VAR 0 6
20561: PPUSH
20562: CALL_OW 264
20566: PUSH
20567: LD_INT 26
20569: PUSH
20570: EMPTY
20571: LIST
20572: IN
20573: IFFALSE 20594
// points := [ 120 , 30 , 80 ] ;
20575: LD_ADDR_VAR 0 9
20579: PUSH
20580: LD_INT 120
20582: PUSH
20583: LD_INT 30
20585: PUSH
20586: LD_INT 80
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: LIST
20593: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
20594: LD_VAR 0 6
20598: PPUSH
20599: CALL_OW 264
20603: PUSH
20604: LD_INT 22
20606: PUSH
20607: EMPTY
20608: LIST
20609: IN
20610: IFFALSE 20631
// points := [ 40 , 1 , 1 ] ;
20612: LD_ADDR_VAR 0 9
20616: PUSH
20617: LD_INT 40
20619: PUSH
20620: LD_INT 1
20622: PUSH
20623: LD_INT 1
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: LIST
20630: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
20631: LD_VAR 0 6
20635: PPUSH
20636: CALL_OW 264
20640: PUSH
20641: LD_INT 29
20643: PUSH
20644: EMPTY
20645: LIST
20646: IN
20647: IFFALSE 20668
// points := [ 70 , 200 , 400 ] ;
20649: LD_ADDR_VAR 0 9
20653: PUSH
20654: LD_INT 70
20656: PUSH
20657: LD_INT 200
20659: PUSH
20660: LD_INT 400
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: LIST
20667: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
20668: LD_VAR 0 6
20672: PPUSH
20673: CALL_OW 264
20677: PUSH
20678: LD_INT 14
20680: PUSH
20681: LD_INT 53
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: IN
20688: IFFALSE 20709
// points := [ 40 , 10 , 20 ] ;
20690: LD_ADDR_VAR 0 9
20694: PUSH
20695: LD_INT 40
20697: PUSH
20698: LD_INT 10
20700: PUSH
20701: LD_INT 20
20703: PUSH
20704: EMPTY
20705: LIST
20706: LIST
20707: LIST
20708: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
20709: LD_VAR 0 6
20713: PPUSH
20714: CALL_OW 264
20718: PUSH
20719: LD_INT 9
20721: PUSH
20722: EMPTY
20723: LIST
20724: IN
20725: IFFALSE 20746
// points := [ 5 , 70 , 20 ] ;
20727: LD_ADDR_VAR 0 9
20731: PUSH
20732: LD_INT 5
20734: PUSH
20735: LD_INT 70
20737: PUSH
20738: LD_INT 20
20740: PUSH
20741: EMPTY
20742: LIST
20743: LIST
20744: LIST
20745: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
20746: LD_VAR 0 6
20750: PPUSH
20751: CALL_OW 264
20755: PUSH
20756: LD_INT 10
20758: PUSH
20759: EMPTY
20760: LIST
20761: IN
20762: IFFALSE 20783
// points := [ 35 , 110 , 70 ] ;
20764: LD_ADDR_VAR 0 9
20768: PUSH
20769: LD_INT 35
20771: PUSH
20772: LD_INT 110
20774: PUSH
20775: LD_INT 70
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: LIST
20782: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
20783: LD_VAR 0 6
20787: PPUSH
20788: CALL_OW 265
20792: PUSH
20793: LD_INT 25
20795: EQUAL
20796: IFFALSE 20817
// points := [ 80 , 65 , 100 ] ;
20798: LD_ADDR_VAR 0 9
20802: PUSH
20803: LD_INT 80
20805: PUSH
20806: LD_INT 65
20808: PUSH
20809: LD_INT 100
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: LIST
20816: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
20817: LD_VAR 0 6
20821: PPUSH
20822: CALL_OW 263
20826: PUSH
20827: LD_INT 1
20829: EQUAL
20830: IFFALSE 20865
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
20832: LD_ADDR_VAR 0 10
20836: PUSH
20837: LD_VAR 0 10
20841: PUSH
20842: LD_VAR 0 6
20846: PPUSH
20847: CALL_OW 311
20851: PPUSH
20852: LD_INT 3
20854: PPUSH
20855: CALL_OW 259
20859: PUSH
20860: LD_INT 4
20862: MUL
20863: MUL
20864: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
20865: LD_VAR 0 6
20869: PPUSH
20870: CALL_OW 263
20874: PUSH
20875: LD_INT 2
20877: EQUAL
20878: IFFALSE 20929
// begin j := IsControledBy ( i ) ;
20880: LD_ADDR_VAR 0 7
20884: PUSH
20885: LD_VAR 0 6
20889: PPUSH
20890: CALL_OW 312
20894: ST_TO_ADDR
// if j then
20895: LD_VAR 0 7
20899: IFFALSE 20929
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
20901: LD_ADDR_VAR 0 10
20905: PUSH
20906: LD_VAR 0 10
20910: PUSH
20911: LD_VAR 0 7
20915: PPUSH
20916: LD_INT 3
20918: PPUSH
20919: CALL_OW 259
20923: PUSH
20924: LD_INT 3
20926: MUL
20927: MUL
20928: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
20929: LD_VAR 0 6
20933: PPUSH
20934: CALL_OW 264
20938: PUSH
20939: LD_INT 5
20941: PUSH
20942: LD_INT 6
20944: PUSH
20945: LD_INT 46
20947: PUSH
20948: LD_INT 44
20950: PUSH
20951: LD_INT 47
20953: PUSH
20954: LD_INT 45
20956: PUSH
20957: LD_INT 28
20959: PUSH
20960: LD_INT 7
20962: PUSH
20963: LD_INT 27
20965: PUSH
20966: LD_INT 29
20968: PUSH
20969: EMPTY
20970: LIST
20971: LIST
20972: LIST
20973: LIST
20974: LIST
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: LIST
20980: IN
20981: PUSH
20982: LD_VAR 0 1
20986: PPUSH
20987: LD_INT 52
20989: PPUSH
20990: CALL_OW 321
20994: PUSH
20995: LD_INT 2
20997: EQUAL
20998: AND
20999: IFFALSE 21016
// bpoints := bpoints * 1.2 ;
21001: LD_ADDR_VAR 0 10
21005: PUSH
21006: LD_VAR 0 10
21010: PUSH
21011: LD_REAL  1.20000000000000E+0000
21014: MUL
21015: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21016: LD_VAR 0 6
21020: PPUSH
21021: CALL_OW 264
21025: PUSH
21026: LD_INT 6
21028: PUSH
21029: LD_INT 46
21031: PUSH
21032: LD_INT 47
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: LIST
21039: IN
21040: IFFALSE 21057
// bpoints := bpoints * 1.2 ;
21042: LD_ADDR_VAR 0 10
21046: PUSH
21047: LD_VAR 0 10
21051: PUSH
21052: LD_REAL  1.20000000000000E+0000
21055: MUL
21056: ST_TO_ADDR
// end ; unit_building :
21057: GO 21071
21059: LD_INT 3
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21070
21067: POP
// ; end ;
21068: GO 21071
21070: POP
// for j = 1 to 3 do
21071: LD_ADDR_VAR 0 7
21075: PUSH
21076: DOUBLE
21077: LD_INT 1
21079: DEC
21080: ST_TO_ADDR
21081: LD_INT 3
21083: PUSH
21084: FOR_TO
21085: IFFALSE 21138
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21087: LD_ADDR_VAR 0 5
21091: PUSH
21092: LD_VAR 0 5
21096: PPUSH
21097: LD_VAR 0 7
21101: PPUSH
21102: LD_VAR 0 5
21106: PUSH
21107: LD_VAR 0 7
21111: ARRAY
21112: PUSH
21113: LD_VAR 0 9
21117: PUSH
21118: LD_VAR 0 7
21122: ARRAY
21123: PUSH
21124: LD_VAR 0 10
21128: MUL
21129: PLUS
21130: PPUSH
21131: CALL_OW 1
21135: ST_TO_ADDR
21136: GO 21084
21138: POP
21139: POP
// end ;
21140: GO 19623
21142: POP
21143: POP
// result := Replace ( result , 4 , tmp ) ;
21144: LD_ADDR_VAR 0 5
21148: PUSH
21149: LD_VAR 0 5
21153: PPUSH
21154: LD_INT 4
21156: PPUSH
21157: LD_VAR 0 8
21161: PPUSH
21162: CALL_OW 1
21166: ST_TO_ADDR
// end ;
21167: LD_VAR 0 5
21171: RET
// export function DangerAtRange ( unit , range ) ; begin
21172: LD_INT 0
21174: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21175: LD_ADDR_VAR 0 3
21179: PUSH
21180: LD_VAR 0 1
21184: PPUSH
21185: CALL_OW 255
21189: PPUSH
21190: LD_VAR 0 1
21194: PPUSH
21195: CALL_OW 250
21199: PPUSH
21200: LD_VAR 0 1
21204: PPUSH
21205: CALL_OW 251
21209: PPUSH
21210: LD_VAR 0 2
21214: PPUSH
21215: CALL 19475 0 4
21219: ST_TO_ADDR
// end ;
21220: LD_VAR 0 3
21224: RET
// export function DangerInArea ( side , area ) ; begin
21225: LD_INT 0
21227: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21228: LD_ADDR_VAR 0 3
21232: PUSH
21233: LD_VAR 0 2
21237: PPUSH
21238: LD_INT 81
21240: PUSH
21241: LD_VAR 0 1
21245: PUSH
21246: EMPTY
21247: LIST
21248: LIST
21249: PPUSH
21250: CALL_OW 70
21254: ST_TO_ADDR
// end ;
21255: LD_VAR 0 3
21259: RET
// export function IsExtension ( b ) ; begin
21260: LD_INT 0
21262: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21263: LD_ADDR_VAR 0 2
21267: PUSH
21268: LD_VAR 0 1
21272: PUSH
21273: LD_INT 23
21275: PUSH
21276: LD_INT 20
21278: PUSH
21279: LD_INT 22
21281: PUSH
21282: LD_INT 17
21284: PUSH
21285: LD_INT 24
21287: PUSH
21288: LD_INT 21
21290: PUSH
21291: LD_INT 19
21293: PUSH
21294: LD_INT 16
21296: PUSH
21297: LD_INT 25
21299: PUSH
21300: LD_INT 18
21302: PUSH
21303: EMPTY
21304: LIST
21305: LIST
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: LIST
21313: LIST
21314: IN
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 2
21320: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21321: LD_INT 0
21323: PPUSH
21324: PPUSH
21325: PPUSH
// result := [ ] ;
21326: LD_ADDR_VAR 0 3
21330: PUSH
21331: EMPTY
21332: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21333: LD_ADDR_VAR 0 4
21337: PUSH
21338: LD_VAR 0 2
21342: PPUSH
21343: LD_INT 21
21345: PUSH
21346: LD_INT 3
21348: PUSH
21349: EMPTY
21350: LIST
21351: LIST
21352: PPUSH
21353: CALL_OW 70
21357: ST_TO_ADDR
// if not tmp then
21358: LD_VAR 0 4
21362: NOT
21363: IFFALSE 21367
// exit ;
21365: GO 21425
// for i in tmp do
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_VAR 0 4
21376: PUSH
21377: FOR_IN
21378: IFFALSE 21413
// if GetBase ( i ) <> base then
21380: LD_VAR 0 5
21384: PPUSH
21385: CALL_OW 274
21389: PUSH
21390: LD_VAR 0 1
21394: NONEQUAL
21395: IFFALSE 21411
// ComLinkToBase ( base , i ) ;
21397: LD_VAR 0 1
21401: PPUSH
21402: LD_VAR 0 5
21406: PPUSH
21407: CALL_OW 169
21411: GO 21377
21413: POP
21414: POP
// result := tmp ;
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_VAR 0 4
21424: ST_TO_ADDR
// end ;
21425: LD_VAR 0 3
21429: RET
// export function ComComplete ( unit , b ) ; var i ; begin
21430: LD_INT 0
21432: PPUSH
21433: PPUSH
// if BuildingStatus ( b ) = bs_build then
21434: LD_VAR 0 2
21438: PPUSH
21439: CALL_OW 461
21443: PUSH
21444: LD_INT 1
21446: EQUAL
21447: IFFALSE 21507
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
21449: LD_VAR 0 1
21453: PPUSH
21454: LD_STRING h
21456: PUSH
21457: LD_VAR 0 2
21461: PPUSH
21462: CALL_OW 250
21466: PUSH
21467: LD_VAR 0 2
21471: PPUSH
21472: CALL_OW 251
21476: PUSH
21477: LD_VAR 0 2
21481: PUSH
21482: LD_INT 0
21484: PUSH
21485: LD_INT 0
21487: PUSH
21488: LD_INT 0
21490: PUSH
21491: EMPTY
21492: LIST
21493: LIST
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: LIST
21499: PUSH
21500: EMPTY
21501: LIST
21502: PPUSH
21503: CALL_OW 446
// end ;
21507: LD_VAR 0 3
21511: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
21517: PPUSH
21518: PPUSH
21519: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
21520: LD_VAR 0 1
21524: NOT
21525: PUSH
21526: LD_VAR 0 1
21530: PPUSH
21531: CALL_OW 263
21535: PUSH
21536: LD_INT 2
21538: EQUAL
21539: NOT
21540: OR
21541: IFFALSE 21545
// exit ;
21543: GO 21861
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
21545: LD_ADDR_VAR 0 6
21549: PUSH
21550: LD_INT 22
21552: PUSH
21553: LD_VAR 0 1
21557: PPUSH
21558: CALL_OW 255
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: PUSH
21567: LD_INT 2
21569: PUSH
21570: LD_INT 30
21572: PUSH
21573: LD_INT 36
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: PUSH
21580: LD_INT 34
21582: PUSH
21583: LD_INT 31
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: LIST
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PPUSH
21599: CALL_OW 69
21603: ST_TO_ADDR
// if not tmp then
21604: LD_VAR 0 6
21608: NOT
21609: IFFALSE 21613
// exit ;
21611: GO 21861
// result := [ ] ;
21613: LD_ADDR_VAR 0 2
21617: PUSH
21618: EMPTY
21619: ST_TO_ADDR
// for i in tmp do
21620: LD_ADDR_VAR 0 3
21624: PUSH
21625: LD_VAR 0 6
21629: PUSH
21630: FOR_IN
21631: IFFALSE 21702
// begin t := UnitsInside ( i ) ;
21633: LD_ADDR_VAR 0 4
21637: PUSH
21638: LD_VAR 0 3
21642: PPUSH
21643: CALL_OW 313
21647: ST_TO_ADDR
// if t then
21648: LD_VAR 0 4
21652: IFFALSE 21700
// for j in t do
21654: LD_ADDR_VAR 0 7
21658: PUSH
21659: LD_VAR 0 4
21663: PUSH
21664: FOR_IN
21665: IFFALSE 21698
// result := Insert ( result , result + 1 , j ) ;
21667: LD_ADDR_VAR 0 2
21671: PUSH
21672: LD_VAR 0 2
21676: PPUSH
21677: LD_VAR 0 2
21681: PUSH
21682: LD_INT 1
21684: PLUS
21685: PPUSH
21686: LD_VAR 0 7
21690: PPUSH
21691: CALL_OW 2
21695: ST_TO_ADDR
21696: GO 21664
21698: POP
21699: POP
// end ;
21700: GO 21630
21702: POP
21703: POP
// if not result then
21704: LD_VAR 0 2
21708: NOT
21709: IFFALSE 21713
// exit ;
21711: GO 21861
// mech := result [ 1 ] ;
21713: LD_ADDR_VAR 0 5
21717: PUSH
21718: LD_VAR 0 2
21722: PUSH
21723: LD_INT 1
21725: ARRAY
21726: ST_TO_ADDR
// if result > 1 then
21727: LD_VAR 0 2
21731: PUSH
21732: LD_INT 1
21734: GREATER
21735: IFFALSE 21847
// for i = 2 to result do
21737: LD_ADDR_VAR 0 3
21741: PUSH
21742: DOUBLE
21743: LD_INT 2
21745: DEC
21746: ST_TO_ADDR
21747: LD_VAR 0 2
21751: PUSH
21752: FOR_TO
21753: IFFALSE 21845
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
21755: LD_ADDR_VAR 0 4
21759: PUSH
21760: LD_VAR 0 2
21764: PUSH
21765: LD_VAR 0 3
21769: ARRAY
21770: PPUSH
21771: LD_INT 3
21773: PPUSH
21774: CALL_OW 259
21778: PUSH
21779: LD_VAR 0 2
21783: PUSH
21784: LD_VAR 0 3
21788: ARRAY
21789: PPUSH
21790: CALL_OW 432
21794: MINUS
21795: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
21796: LD_VAR 0 4
21800: PUSH
21801: LD_VAR 0 5
21805: PPUSH
21806: LD_INT 3
21808: PPUSH
21809: CALL_OW 259
21813: PUSH
21814: LD_VAR 0 5
21818: PPUSH
21819: CALL_OW 432
21823: MINUS
21824: GREATEREQUAL
21825: IFFALSE 21843
// mech := result [ i ] ;
21827: LD_ADDR_VAR 0 5
21831: PUSH
21832: LD_VAR 0 2
21836: PUSH
21837: LD_VAR 0 3
21841: ARRAY
21842: ST_TO_ADDR
// end ;
21843: GO 21752
21845: POP
21846: POP
// ComLinkTo ( vehicle , mech ) ;
21847: LD_VAR 0 1
21851: PPUSH
21852: LD_VAR 0 5
21856: PPUSH
21857: CALL_OW 135
// end ;
21861: LD_VAR 0 2
21865: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
21866: LD_INT 0
21868: PPUSH
21869: PPUSH
21870: PPUSH
21871: PPUSH
21872: PPUSH
21873: PPUSH
21874: PPUSH
21875: PPUSH
21876: PPUSH
21877: PPUSH
21878: PPUSH
21879: PPUSH
21880: PPUSH
// result := [ ] ;
21881: LD_ADDR_VAR 0 7
21885: PUSH
21886: EMPTY
21887: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
21888: LD_VAR 0 1
21892: PPUSH
21893: CALL_OW 266
21897: PUSH
21898: LD_INT 0
21900: PUSH
21901: LD_INT 1
21903: PUSH
21904: EMPTY
21905: LIST
21906: LIST
21907: IN
21908: NOT
21909: IFFALSE 21913
// exit ;
21911: GO 23544
// if name then
21913: LD_VAR 0 3
21917: IFFALSE 21933
// SetBName ( base_dep , name ) ;
21919: LD_VAR 0 1
21923: PPUSH
21924: LD_VAR 0 3
21928: PPUSH
21929: CALL_OW 500
// base := GetBase ( base_dep ) ;
21933: LD_ADDR_VAR 0 15
21937: PUSH
21938: LD_VAR 0 1
21942: PPUSH
21943: CALL_OW 274
21947: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
21948: LD_ADDR_VAR 0 16
21952: PUSH
21953: LD_VAR 0 1
21957: PPUSH
21958: CALL_OW 255
21962: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
21963: LD_ADDR_VAR 0 17
21967: PUSH
21968: LD_VAR 0 1
21972: PPUSH
21973: CALL_OW 248
21977: ST_TO_ADDR
// if sources then
21978: LD_VAR 0 5
21982: IFFALSE 22029
// for i = 1 to 3 do
21984: LD_ADDR_VAR 0 8
21988: PUSH
21989: DOUBLE
21990: LD_INT 1
21992: DEC
21993: ST_TO_ADDR
21994: LD_INT 3
21996: PUSH
21997: FOR_TO
21998: IFFALSE 22027
// AddResourceType ( base , i , sources [ i ] ) ;
22000: LD_VAR 0 15
22004: PPUSH
22005: LD_VAR 0 8
22009: PPUSH
22010: LD_VAR 0 5
22014: PUSH
22015: LD_VAR 0 8
22019: ARRAY
22020: PPUSH
22021: CALL_OW 276
22025: GO 21997
22027: POP
22028: POP
// buildings := GetBaseBuildings ( base , area ) ;
22029: LD_ADDR_VAR 0 18
22033: PUSH
22034: LD_VAR 0 15
22038: PPUSH
22039: LD_VAR 0 2
22043: PPUSH
22044: CALL 21321 0 2
22048: ST_TO_ADDR
// InitHc ;
22049: CALL_OW 19
// InitUc ;
22053: CALL_OW 18
// uc_side := side ;
22057: LD_ADDR_OWVAR 20
22061: PUSH
22062: LD_VAR 0 16
22066: ST_TO_ADDR
// uc_nation := nation ;
22067: LD_ADDR_OWVAR 21
22071: PUSH
22072: LD_VAR 0 17
22076: ST_TO_ADDR
// if buildings then
22077: LD_VAR 0 18
22081: IFFALSE 23403
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22083: LD_ADDR_VAR 0 19
22087: PUSH
22088: LD_VAR 0 18
22092: PPUSH
22093: LD_INT 2
22095: PUSH
22096: LD_INT 30
22098: PUSH
22099: LD_INT 29
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PUSH
22106: LD_INT 30
22108: PUSH
22109: LD_INT 30
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: LIST
22120: PPUSH
22121: CALL_OW 72
22125: ST_TO_ADDR
// if tmp then
22126: LD_VAR 0 19
22130: IFFALSE 22178
// for i in tmp do
22132: LD_ADDR_VAR 0 8
22136: PUSH
22137: LD_VAR 0 19
22141: PUSH
22142: FOR_IN
22143: IFFALSE 22176
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22145: LD_VAR 0 8
22149: PPUSH
22150: CALL_OW 250
22154: PPUSH
22155: LD_VAR 0 8
22159: PPUSH
22160: CALL_OW 251
22164: PPUSH
22165: LD_VAR 0 16
22169: PPUSH
22170: CALL_OW 441
22174: GO 22142
22176: POP
22177: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22178: LD_VAR 0 18
22182: PPUSH
22183: LD_INT 2
22185: PUSH
22186: LD_INT 30
22188: PUSH
22189: LD_INT 32
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: LD_INT 30
22198: PUSH
22199: LD_INT 33
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: PPUSH
22211: CALL_OW 72
22215: IFFALSE 22303
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22217: LD_ADDR_VAR 0 8
22221: PUSH
22222: LD_VAR 0 18
22226: PPUSH
22227: LD_INT 2
22229: PUSH
22230: LD_INT 30
22232: PUSH
22233: LD_INT 32
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: PUSH
22240: LD_INT 30
22242: PUSH
22243: LD_INT 33
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: PUSH
22250: EMPTY
22251: LIST
22252: LIST
22253: LIST
22254: PPUSH
22255: CALL_OW 72
22259: PUSH
22260: FOR_IN
22261: IFFALSE 22301
// begin if not GetBWeapon ( i ) then
22263: LD_VAR 0 8
22267: PPUSH
22268: CALL_OW 269
22272: NOT
22273: IFFALSE 22299
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22275: LD_VAR 0 8
22279: PPUSH
22280: LD_VAR 0 8
22284: PPUSH
22285: LD_VAR 0 2
22289: PPUSH
22290: CALL 23549 0 2
22294: PPUSH
22295: CALL_OW 431
// end ;
22299: GO 22260
22301: POP
22302: POP
// end ; for i = 1 to personel do
22303: LD_ADDR_VAR 0 8
22307: PUSH
22308: DOUBLE
22309: LD_INT 1
22311: DEC
22312: ST_TO_ADDR
22313: LD_VAR 0 6
22317: PUSH
22318: FOR_TO
22319: IFFALSE 23383
// begin if i > 4 then
22321: LD_VAR 0 8
22325: PUSH
22326: LD_INT 4
22328: GREATER
22329: IFFALSE 22333
// break ;
22331: GO 23383
// case i of 1 :
22333: LD_VAR 0 8
22337: PUSH
22338: LD_INT 1
22340: DOUBLE
22341: EQUAL
22342: IFTRUE 22346
22344: GO 22426
22346: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
22347: LD_ADDR_VAR 0 12
22351: PUSH
22352: LD_VAR 0 18
22356: PPUSH
22357: LD_INT 22
22359: PUSH
22360: LD_VAR 0 16
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: PUSH
22369: LD_INT 58
22371: PUSH
22372: EMPTY
22373: LIST
22374: PUSH
22375: LD_INT 2
22377: PUSH
22378: LD_INT 30
22380: PUSH
22381: LD_INT 32
22383: PUSH
22384: EMPTY
22385: LIST
22386: LIST
22387: PUSH
22388: LD_INT 30
22390: PUSH
22391: LD_INT 4
22393: PUSH
22394: EMPTY
22395: LIST
22396: LIST
22397: PUSH
22398: LD_INT 30
22400: PUSH
22401: LD_INT 5
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: LIST
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: LIST
22418: PPUSH
22419: CALL_OW 72
22423: ST_TO_ADDR
22424: GO 22648
22426: LD_INT 2
22428: DOUBLE
22429: EQUAL
22430: IFTRUE 22434
22432: GO 22496
22434: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
22435: LD_ADDR_VAR 0 12
22439: PUSH
22440: LD_VAR 0 18
22444: PPUSH
22445: LD_INT 22
22447: PUSH
22448: LD_VAR 0 16
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: LD_INT 2
22459: PUSH
22460: LD_INT 30
22462: PUSH
22463: LD_INT 0
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: PUSH
22470: LD_INT 30
22472: PUSH
22473: LD_INT 1
22475: PUSH
22476: EMPTY
22477: LIST
22478: LIST
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: LIST
22484: PUSH
22485: EMPTY
22486: LIST
22487: LIST
22488: PPUSH
22489: CALL_OW 72
22493: ST_TO_ADDR
22494: GO 22648
22496: LD_INT 3
22498: DOUBLE
22499: EQUAL
22500: IFTRUE 22504
22502: GO 22566
22504: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
22505: LD_ADDR_VAR 0 12
22509: PUSH
22510: LD_VAR 0 18
22514: PPUSH
22515: LD_INT 22
22517: PUSH
22518: LD_VAR 0 16
22522: PUSH
22523: EMPTY
22524: LIST
22525: LIST
22526: PUSH
22527: LD_INT 2
22529: PUSH
22530: LD_INT 30
22532: PUSH
22533: LD_INT 2
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: LD_INT 30
22542: PUSH
22543: LD_INT 3
22545: PUSH
22546: EMPTY
22547: LIST
22548: LIST
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PPUSH
22559: CALL_OW 72
22563: ST_TO_ADDR
22564: GO 22648
22566: LD_INT 4
22568: DOUBLE
22569: EQUAL
22570: IFTRUE 22574
22572: GO 22647
22574: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
22575: LD_ADDR_VAR 0 12
22579: PUSH
22580: LD_VAR 0 18
22584: PPUSH
22585: LD_INT 22
22587: PUSH
22588: LD_VAR 0 16
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: PUSH
22597: LD_INT 2
22599: PUSH
22600: LD_INT 30
22602: PUSH
22603: LD_INT 6
22605: PUSH
22606: EMPTY
22607: LIST
22608: LIST
22609: PUSH
22610: LD_INT 30
22612: PUSH
22613: LD_INT 7
22615: PUSH
22616: EMPTY
22617: LIST
22618: LIST
22619: PUSH
22620: LD_INT 30
22622: PUSH
22623: LD_INT 8
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: PUSH
22630: EMPTY
22631: LIST
22632: LIST
22633: LIST
22634: LIST
22635: PUSH
22636: EMPTY
22637: LIST
22638: LIST
22639: PPUSH
22640: CALL_OW 72
22644: ST_TO_ADDR
22645: GO 22648
22647: POP
// if i = 1 then
22648: LD_VAR 0 8
22652: PUSH
22653: LD_INT 1
22655: EQUAL
22656: IFFALSE 22767
// begin tmp := [ ] ;
22658: LD_ADDR_VAR 0 19
22662: PUSH
22663: EMPTY
22664: ST_TO_ADDR
// for j in f do
22665: LD_ADDR_VAR 0 9
22669: PUSH
22670: LD_VAR 0 12
22674: PUSH
22675: FOR_IN
22676: IFFALSE 22749
// if GetBType ( j ) = b_bunker then
22678: LD_VAR 0 9
22682: PPUSH
22683: CALL_OW 266
22687: PUSH
22688: LD_INT 32
22690: EQUAL
22691: IFFALSE 22718
// tmp := Insert ( tmp , 1 , j ) else
22693: LD_ADDR_VAR 0 19
22697: PUSH
22698: LD_VAR 0 19
22702: PPUSH
22703: LD_INT 1
22705: PPUSH
22706: LD_VAR 0 9
22710: PPUSH
22711: CALL_OW 2
22715: ST_TO_ADDR
22716: GO 22747
// tmp := Insert ( tmp , tmp + 1 , j ) ;
22718: LD_ADDR_VAR 0 19
22722: PUSH
22723: LD_VAR 0 19
22727: PPUSH
22728: LD_VAR 0 19
22732: PUSH
22733: LD_INT 1
22735: PLUS
22736: PPUSH
22737: LD_VAR 0 9
22741: PPUSH
22742: CALL_OW 2
22746: ST_TO_ADDR
22747: GO 22675
22749: POP
22750: POP
// if tmp then
22751: LD_VAR 0 19
22755: IFFALSE 22767
// f := tmp ;
22757: LD_ADDR_VAR 0 12
22761: PUSH
22762: LD_VAR 0 19
22766: ST_TO_ADDR
// end ; x := personel [ i ] ;
22767: LD_ADDR_VAR 0 13
22771: PUSH
22772: LD_VAR 0 6
22776: PUSH
22777: LD_VAR 0 8
22781: ARRAY
22782: ST_TO_ADDR
// if x = - 1 then
22783: LD_VAR 0 13
22787: PUSH
22788: LD_INT 1
22790: NEG
22791: EQUAL
22792: IFFALSE 23001
// begin for j in f do
22794: LD_ADDR_VAR 0 9
22798: PUSH
22799: LD_VAR 0 12
22803: PUSH
22804: FOR_IN
22805: IFFALSE 22997
// repeat InitHc ;
22807: CALL_OW 19
// if GetBType ( j ) = b_barracks then
22811: LD_VAR 0 9
22815: PPUSH
22816: CALL_OW 266
22820: PUSH
22821: LD_INT 5
22823: EQUAL
22824: IFFALSE 22894
// begin if UnitsInside ( j ) < 3 then
22826: LD_VAR 0 9
22830: PPUSH
22831: CALL_OW 313
22835: PUSH
22836: LD_INT 3
22838: LESS
22839: IFFALSE 22875
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
22841: LD_INT 0
22843: PPUSH
22844: LD_INT 5
22846: PUSH
22847: LD_INT 8
22849: PUSH
22850: LD_INT 9
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: LIST
22857: PUSH
22858: LD_VAR 0 17
22862: ARRAY
22863: PPUSH
22864: LD_VAR 0 4
22868: PPUSH
22869: CALL_OW 380
22873: GO 22892
// PrepareHuman ( false , i , skill ) ;
22875: LD_INT 0
22877: PPUSH
22878: LD_VAR 0 8
22882: PPUSH
22883: LD_VAR 0 4
22887: PPUSH
22888: CALL_OW 380
// end else
22892: GO 22911
// PrepareHuman ( false , i , skill ) ;
22894: LD_INT 0
22896: PPUSH
22897: LD_VAR 0 8
22901: PPUSH
22902: LD_VAR 0 4
22906: PPUSH
22907: CALL_OW 380
// un := CreateHuman ;
22911: LD_ADDR_VAR 0 14
22915: PUSH
22916: CALL_OW 44
22920: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
22921: LD_ADDR_VAR 0 7
22925: PUSH
22926: LD_VAR 0 7
22930: PPUSH
22931: LD_INT 1
22933: PPUSH
22934: LD_VAR 0 14
22938: PPUSH
22939: CALL_OW 2
22943: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
22944: LD_VAR 0 14
22948: PPUSH
22949: LD_VAR 0 9
22953: PPUSH
22954: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
22958: LD_VAR 0 9
22962: PPUSH
22963: CALL_OW 313
22967: PUSH
22968: LD_INT 6
22970: EQUAL
22971: PUSH
22972: LD_VAR 0 9
22976: PPUSH
22977: CALL_OW 266
22981: PUSH
22982: LD_INT 32
22984: PUSH
22985: LD_INT 31
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: IN
22992: OR
22993: IFFALSE 22807
22995: GO 22804
22997: POP
22998: POP
// end else
22999: GO 23381
// for j = 1 to x do
23001: LD_ADDR_VAR 0 9
23005: PUSH
23006: DOUBLE
23007: LD_INT 1
23009: DEC
23010: ST_TO_ADDR
23011: LD_VAR 0 13
23015: PUSH
23016: FOR_TO
23017: IFFALSE 23379
// begin InitHc ;
23019: CALL_OW 19
// if not f then
23023: LD_VAR 0 12
23027: NOT
23028: IFFALSE 23117
// begin PrepareHuman ( false , i , skill ) ;
23030: LD_INT 0
23032: PPUSH
23033: LD_VAR 0 8
23037: PPUSH
23038: LD_VAR 0 4
23042: PPUSH
23043: CALL_OW 380
// un := CreateHuman ;
23047: LD_ADDR_VAR 0 14
23051: PUSH
23052: CALL_OW 44
23056: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23057: LD_ADDR_VAR 0 7
23061: PUSH
23062: LD_VAR 0 7
23066: PPUSH
23067: LD_INT 1
23069: PPUSH
23070: LD_VAR 0 14
23074: PPUSH
23075: CALL_OW 2
23079: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23080: LD_VAR 0 14
23084: PPUSH
23085: LD_VAR 0 1
23089: PPUSH
23090: CALL_OW 250
23094: PPUSH
23095: LD_VAR 0 1
23099: PPUSH
23100: CALL_OW 251
23104: PPUSH
23105: LD_INT 10
23107: PPUSH
23108: LD_INT 0
23110: PPUSH
23111: CALL_OW 50
// continue ;
23115: GO 23016
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23117: LD_VAR 0 12
23121: PUSH
23122: LD_INT 1
23124: ARRAY
23125: PPUSH
23126: CALL_OW 313
23130: PUSH
23131: LD_VAR 0 12
23135: PUSH
23136: LD_INT 1
23138: ARRAY
23139: PPUSH
23140: CALL_OW 266
23144: PUSH
23145: LD_INT 32
23147: PUSH
23148: LD_INT 31
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: IN
23155: AND
23156: PUSH
23157: LD_VAR 0 12
23161: PUSH
23162: LD_INT 1
23164: ARRAY
23165: PPUSH
23166: CALL_OW 313
23170: PUSH
23171: LD_INT 6
23173: EQUAL
23174: OR
23175: IFFALSE 23195
// f := Delete ( f , 1 ) ;
23177: LD_ADDR_VAR 0 12
23181: PUSH
23182: LD_VAR 0 12
23186: PPUSH
23187: LD_INT 1
23189: PPUSH
23190: CALL_OW 3
23194: ST_TO_ADDR
// if not f then
23195: LD_VAR 0 12
23199: NOT
23200: IFFALSE 23218
// begin x := x + 2 ;
23202: LD_ADDR_VAR 0 13
23206: PUSH
23207: LD_VAR 0 13
23211: PUSH
23212: LD_INT 2
23214: PLUS
23215: ST_TO_ADDR
// continue ;
23216: GO 23016
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23218: LD_VAR 0 12
23222: PUSH
23223: LD_INT 1
23225: ARRAY
23226: PPUSH
23227: CALL_OW 266
23231: PUSH
23232: LD_INT 5
23234: EQUAL
23235: IFFALSE 23309
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23237: LD_VAR 0 12
23241: PUSH
23242: LD_INT 1
23244: ARRAY
23245: PPUSH
23246: CALL_OW 313
23250: PUSH
23251: LD_INT 3
23253: LESS
23254: IFFALSE 23290
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23256: LD_INT 0
23258: PPUSH
23259: LD_INT 5
23261: PUSH
23262: LD_INT 8
23264: PUSH
23265: LD_INT 9
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: LIST
23272: PUSH
23273: LD_VAR 0 17
23277: ARRAY
23278: PPUSH
23279: LD_VAR 0 4
23283: PPUSH
23284: CALL_OW 380
23288: GO 23307
// PrepareHuman ( false , i , skill ) ;
23290: LD_INT 0
23292: PPUSH
23293: LD_VAR 0 8
23297: PPUSH
23298: LD_VAR 0 4
23302: PPUSH
23303: CALL_OW 380
// end else
23307: GO 23326
// PrepareHuman ( false , i , skill ) ;
23309: LD_INT 0
23311: PPUSH
23312: LD_VAR 0 8
23316: PPUSH
23317: LD_VAR 0 4
23321: PPUSH
23322: CALL_OW 380
// un := CreateHuman ;
23326: LD_ADDR_VAR 0 14
23330: PUSH
23331: CALL_OW 44
23335: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23336: LD_ADDR_VAR 0 7
23340: PUSH
23341: LD_VAR 0 7
23345: PPUSH
23346: LD_INT 1
23348: PPUSH
23349: LD_VAR 0 14
23353: PPUSH
23354: CALL_OW 2
23358: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
23359: LD_VAR 0 14
23363: PPUSH
23364: LD_VAR 0 12
23368: PUSH
23369: LD_INT 1
23371: ARRAY
23372: PPUSH
23373: CALL_OW 52
// end ;
23377: GO 23016
23379: POP
23380: POP
// end ;
23381: GO 22318
23383: POP
23384: POP
// result := result ^ buildings ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 7
23394: PUSH
23395: LD_VAR 0 18
23399: ADD
23400: ST_TO_ADDR
// end else
23401: GO 23544
// begin for i = 1 to personel do
23403: LD_ADDR_VAR 0 8
23407: PUSH
23408: DOUBLE
23409: LD_INT 1
23411: DEC
23412: ST_TO_ADDR
23413: LD_VAR 0 6
23417: PUSH
23418: FOR_TO
23419: IFFALSE 23542
// begin if i > 4 then
23421: LD_VAR 0 8
23425: PUSH
23426: LD_INT 4
23428: GREATER
23429: IFFALSE 23433
// break ;
23431: GO 23542
// x := personel [ i ] ;
23433: LD_ADDR_VAR 0 13
23437: PUSH
23438: LD_VAR 0 6
23442: PUSH
23443: LD_VAR 0 8
23447: ARRAY
23448: ST_TO_ADDR
// if x = - 1 then
23449: LD_VAR 0 13
23453: PUSH
23454: LD_INT 1
23456: NEG
23457: EQUAL
23458: IFFALSE 23462
// continue ;
23460: GO 23418
// PrepareHuman ( false , i , skill ) ;
23462: LD_INT 0
23464: PPUSH
23465: LD_VAR 0 8
23469: PPUSH
23470: LD_VAR 0 4
23474: PPUSH
23475: CALL_OW 380
// un := CreateHuman ;
23479: LD_ADDR_VAR 0 14
23483: PUSH
23484: CALL_OW 44
23488: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23489: LD_VAR 0 14
23493: PPUSH
23494: LD_VAR 0 1
23498: PPUSH
23499: CALL_OW 250
23503: PPUSH
23504: LD_VAR 0 1
23508: PPUSH
23509: CALL_OW 251
23513: PPUSH
23514: LD_INT 10
23516: PPUSH
23517: LD_INT 0
23519: PPUSH
23520: CALL_OW 50
// result := result ^ un ;
23524: LD_ADDR_VAR 0 7
23528: PUSH
23529: LD_VAR 0 7
23533: PUSH
23534: LD_VAR 0 14
23538: ADD
23539: ST_TO_ADDR
// end ;
23540: GO 23418
23542: POP
23543: POP
// end ; end ;
23544: LD_VAR 0 7
23548: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
23549: LD_INT 0
23551: PPUSH
23552: PPUSH
23553: PPUSH
23554: PPUSH
23555: PPUSH
23556: PPUSH
23557: PPUSH
23558: PPUSH
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
// result := false ;
23567: LD_ADDR_VAR 0 3
23571: PUSH
23572: LD_INT 0
23574: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
23575: LD_VAR 0 1
23579: NOT
23580: PUSH
23581: LD_VAR 0 1
23585: PPUSH
23586: CALL_OW 266
23590: PUSH
23591: LD_INT 32
23593: PUSH
23594: LD_INT 33
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: IN
23601: NOT
23602: OR
23603: IFFALSE 23607
// exit ;
23605: GO 24743
// nat := GetNation ( tower ) ;
23607: LD_ADDR_VAR 0 12
23611: PUSH
23612: LD_VAR 0 1
23616: PPUSH
23617: CALL_OW 248
23621: ST_TO_ADDR
// side := GetSide ( tower ) ;
23622: LD_ADDR_VAR 0 16
23626: PUSH
23627: LD_VAR 0 1
23631: PPUSH
23632: CALL_OW 255
23636: ST_TO_ADDR
// x := GetX ( tower ) ;
23637: LD_ADDR_VAR 0 10
23641: PUSH
23642: LD_VAR 0 1
23646: PPUSH
23647: CALL_OW 250
23651: ST_TO_ADDR
// y := GetY ( tower ) ;
23652: LD_ADDR_VAR 0 11
23656: PUSH
23657: LD_VAR 0 1
23661: PPUSH
23662: CALL_OW 251
23666: ST_TO_ADDR
// if not x or not y then
23667: LD_VAR 0 10
23671: NOT
23672: PUSH
23673: LD_VAR 0 11
23677: NOT
23678: OR
23679: IFFALSE 23683
// exit ;
23681: GO 24743
// weapon := 0 ;
23683: LD_ADDR_VAR 0 18
23687: PUSH
23688: LD_INT 0
23690: ST_TO_ADDR
// fac_list := [ ] ;
23691: LD_ADDR_VAR 0 17
23695: PUSH
23696: EMPTY
23697: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
23698: LD_ADDR_VAR 0 6
23702: PUSH
23703: LD_VAR 0 1
23707: PPUSH
23708: CALL_OW 274
23712: PPUSH
23713: LD_VAR 0 2
23717: PPUSH
23718: CALL 21321 0 2
23722: PPUSH
23723: LD_INT 30
23725: PUSH
23726: LD_INT 3
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: PPUSH
23733: CALL_OW 72
23737: ST_TO_ADDR
// if not factories then
23738: LD_VAR 0 6
23742: NOT
23743: IFFALSE 23747
// exit ;
23745: GO 24743
// for i in factories do
23747: LD_ADDR_VAR 0 8
23751: PUSH
23752: LD_VAR 0 6
23756: PUSH
23757: FOR_IN
23758: IFFALSE 23783
// fac_list := fac_list union AvailableWeaponList ( i ) ;
23760: LD_ADDR_VAR 0 17
23764: PUSH
23765: LD_VAR 0 17
23769: PUSH
23770: LD_VAR 0 8
23774: PPUSH
23775: CALL_OW 478
23779: UNION
23780: ST_TO_ADDR
23781: GO 23757
23783: POP
23784: POP
// if not fac_list then
23785: LD_VAR 0 17
23789: NOT
23790: IFFALSE 23794
// exit ;
23792: GO 24743
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
23794: LD_ADDR_VAR 0 5
23798: PUSH
23799: LD_INT 4
23801: PUSH
23802: LD_INT 5
23804: PUSH
23805: LD_INT 9
23807: PUSH
23808: LD_INT 10
23810: PUSH
23811: LD_INT 6
23813: PUSH
23814: LD_INT 7
23816: PUSH
23817: LD_INT 11
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: LIST
23824: LIST
23825: LIST
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 27
23831: PUSH
23832: LD_INT 28
23834: PUSH
23835: LD_INT 26
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: LIST
23845: LIST
23846: PUSH
23847: LD_INT 43
23849: PUSH
23850: LD_INT 44
23852: PUSH
23853: LD_INT 46
23855: PUSH
23856: LD_INT 45
23858: PUSH
23859: LD_INT 47
23861: PUSH
23862: LD_INT 49
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: LIST
23877: PUSH
23878: LD_VAR 0 12
23882: ARRAY
23883: ST_TO_ADDR
// for i in list do
23884: LD_ADDR_VAR 0 8
23888: PUSH
23889: LD_VAR 0 5
23893: PUSH
23894: FOR_IN
23895: IFFALSE 23928
// if not i in fac_list then
23897: LD_VAR 0 8
23901: PUSH
23902: LD_VAR 0 17
23906: IN
23907: NOT
23908: IFFALSE 23926
// list := list diff i ;
23910: LD_ADDR_VAR 0 5
23914: PUSH
23915: LD_VAR 0 5
23919: PUSH
23920: LD_VAR 0 8
23924: DIFF
23925: ST_TO_ADDR
23926: GO 23894
23928: POP
23929: POP
// if not list then
23930: LD_VAR 0 5
23934: NOT
23935: IFFALSE 23939
// exit ;
23937: GO 24743
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
23939: LD_VAR 0 12
23943: PUSH
23944: LD_INT 3
23946: EQUAL
23947: PUSH
23948: LD_INT 49
23950: PUSH
23951: LD_VAR 0 5
23955: IN
23956: AND
23957: PUSH
23958: LD_INT 31
23960: PPUSH
23961: LD_VAR 0 16
23965: PPUSH
23966: CALL_OW 321
23970: PUSH
23971: LD_INT 2
23973: EQUAL
23974: AND
23975: IFFALSE 24035
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
23977: LD_INT 22
23979: PUSH
23980: LD_VAR 0 16
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 35
23991: PUSH
23992: LD_INT 49
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 91
24001: PUSH
24002: LD_VAR 0 1
24006: PUSH
24007: LD_INT 10
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: LIST
24014: PUSH
24015: EMPTY
24016: LIST
24017: LIST
24018: LIST
24019: PPUSH
24020: CALL_OW 69
24024: NOT
24025: IFFALSE 24035
// weapon := ru_time_lapser ;
24027: LD_ADDR_VAR 0 18
24031: PUSH
24032: LD_INT 49
24034: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24035: LD_VAR 0 12
24039: PUSH
24040: LD_INT 1
24042: PUSH
24043: LD_INT 2
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: IN
24050: PUSH
24051: LD_INT 11
24053: PUSH
24054: LD_VAR 0 5
24058: IN
24059: PUSH
24060: LD_INT 30
24062: PUSH
24063: LD_VAR 0 5
24067: IN
24068: OR
24069: AND
24070: PUSH
24071: LD_INT 6
24073: PPUSH
24074: LD_VAR 0 16
24078: PPUSH
24079: CALL_OW 321
24083: PUSH
24084: LD_INT 2
24086: EQUAL
24087: AND
24088: IFFALSE 24253
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24090: LD_INT 22
24092: PUSH
24093: LD_VAR 0 16
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 2
24104: PUSH
24105: LD_INT 35
24107: PUSH
24108: LD_INT 11
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: PUSH
24115: LD_INT 35
24117: PUSH
24118: LD_INT 30
24120: PUSH
24121: EMPTY
24122: LIST
24123: LIST
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 91
24132: PUSH
24133: LD_VAR 0 1
24137: PUSH
24138: LD_INT 18
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: LIST
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: LIST
24150: PPUSH
24151: CALL_OW 69
24155: NOT
24156: PUSH
24157: LD_INT 22
24159: PUSH
24160: LD_VAR 0 16
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PUSH
24169: LD_INT 2
24171: PUSH
24172: LD_INT 30
24174: PUSH
24175: LD_INT 32
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: PUSH
24182: LD_INT 30
24184: PUSH
24185: LD_INT 33
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: LIST
24196: PUSH
24197: LD_INT 91
24199: PUSH
24200: LD_VAR 0 1
24204: PUSH
24205: LD_INT 12
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: LIST
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: LIST
24217: PUSH
24218: EMPTY
24219: LIST
24220: PPUSH
24221: CALL_OW 69
24225: PUSH
24226: LD_INT 2
24228: GREATER
24229: AND
24230: IFFALSE 24253
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24232: LD_ADDR_VAR 0 18
24236: PUSH
24237: LD_INT 11
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: EMPTY
24244: LIST
24245: LIST
24246: PUSH
24247: LD_VAR 0 12
24251: ARRAY
24252: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24253: LD_VAR 0 18
24257: NOT
24258: PUSH
24259: LD_INT 40
24261: PPUSH
24262: LD_VAR 0 16
24266: PPUSH
24267: CALL_OW 321
24271: PUSH
24272: LD_INT 2
24274: EQUAL
24275: AND
24276: PUSH
24277: LD_INT 7
24279: PUSH
24280: LD_VAR 0 5
24284: IN
24285: PUSH
24286: LD_INT 28
24288: PUSH
24289: LD_VAR 0 5
24293: IN
24294: OR
24295: PUSH
24296: LD_INT 45
24298: PUSH
24299: LD_VAR 0 5
24303: IN
24304: OR
24305: AND
24306: IFFALSE 24560
// begin hex := GetHexInfo ( x , y ) ;
24308: LD_ADDR_VAR 0 4
24312: PUSH
24313: LD_VAR 0 10
24317: PPUSH
24318: LD_VAR 0 11
24322: PPUSH
24323: CALL_OW 546
24327: ST_TO_ADDR
// if hex [ 1 ] then
24328: LD_VAR 0 4
24332: PUSH
24333: LD_INT 1
24335: ARRAY
24336: IFFALSE 24340
// exit ;
24338: GO 24743
// height := hex [ 2 ] ;
24340: LD_ADDR_VAR 0 15
24344: PUSH
24345: LD_VAR 0 4
24349: PUSH
24350: LD_INT 2
24352: ARRAY
24353: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
24354: LD_ADDR_VAR 0 14
24358: PUSH
24359: LD_INT 0
24361: PUSH
24362: LD_INT 2
24364: PUSH
24365: LD_INT 3
24367: PUSH
24368: LD_INT 5
24370: PUSH
24371: EMPTY
24372: LIST
24373: LIST
24374: LIST
24375: LIST
24376: ST_TO_ADDR
// for i in tmp do
24377: LD_ADDR_VAR 0 8
24381: PUSH
24382: LD_VAR 0 14
24386: PUSH
24387: FOR_IN
24388: IFFALSE 24558
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
24390: LD_ADDR_VAR 0 9
24394: PUSH
24395: LD_VAR 0 10
24399: PPUSH
24400: LD_VAR 0 8
24404: PPUSH
24405: LD_INT 5
24407: PPUSH
24408: CALL_OW 272
24412: PUSH
24413: LD_VAR 0 11
24417: PPUSH
24418: LD_VAR 0 8
24422: PPUSH
24423: LD_INT 5
24425: PPUSH
24426: CALL_OW 273
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
24435: LD_VAR 0 9
24439: PUSH
24440: LD_INT 1
24442: ARRAY
24443: PPUSH
24444: LD_VAR 0 9
24448: PUSH
24449: LD_INT 2
24451: ARRAY
24452: PPUSH
24453: CALL_OW 488
24457: IFFALSE 24556
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
24459: LD_ADDR_VAR 0 4
24463: PUSH
24464: LD_VAR 0 9
24468: PUSH
24469: LD_INT 1
24471: ARRAY
24472: PPUSH
24473: LD_VAR 0 9
24477: PUSH
24478: LD_INT 2
24480: ARRAY
24481: PPUSH
24482: CALL_OW 546
24486: ST_TO_ADDR
// if hex [ 1 ] then
24487: LD_VAR 0 4
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: IFFALSE 24499
// continue ;
24497: GO 24387
// h := hex [ 2 ] ;
24499: LD_ADDR_VAR 0 13
24503: PUSH
24504: LD_VAR 0 4
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: ST_TO_ADDR
// if h + 7 < height then
24513: LD_VAR 0 13
24517: PUSH
24518: LD_INT 7
24520: PLUS
24521: PUSH
24522: LD_VAR 0 15
24526: LESS
24527: IFFALSE 24556
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
24529: LD_ADDR_VAR 0 18
24533: PUSH
24534: LD_INT 7
24536: PUSH
24537: LD_INT 28
24539: PUSH
24540: LD_INT 45
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: LIST
24547: PUSH
24548: LD_VAR 0 12
24552: ARRAY
24553: ST_TO_ADDR
// break ;
24554: GO 24558
// end ; end ; end ;
24556: GO 24387
24558: POP
24559: POP
// end ; if not weapon then
24560: LD_VAR 0 18
24564: NOT
24565: IFFALSE 24625
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
24567: LD_ADDR_VAR 0 5
24571: PUSH
24572: LD_VAR 0 5
24576: PUSH
24577: LD_INT 11
24579: PUSH
24580: LD_INT 30
24582: PUSH
24583: LD_INT 49
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: LIST
24590: DIFF
24591: ST_TO_ADDR
// if not list then
24592: LD_VAR 0 5
24596: NOT
24597: IFFALSE 24601
// exit ;
24599: GO 24743
// weapon := list [ rand ( 1 , list ) ] ;
24601: LD_ADDR_VAR 0 18
24605: PUSH
24606: LD_VAR 0 5
24610: PUSH
24611: LD_INT 1
24613: PPUSH
24614: LD_VAR 0 5
24618: PPUSH
24619: CALL_OW 12
24623: ARRAY
24624: ST_TO_ADDR
// end ; if weapon then
24625: LD_VAR 0 18
24629: IFFALSE 24743
// begin tmp := CostOfWeapon ( weapon ) ;
24631: LD_ADDR_VAR 0 14
24635: PUSH
24636: LD_VAR 0 18
24640: PPUSH
24641: CALL_OW 451
24645: ST_TO_ADDR
// j := GetBase ( tower ) ;
24646: LD_ADDR_VAR 0 9
24650: PUSH
24651: LD_VAR 0 1
24655: PPUSH
24656: CALL_OW 274
24660: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
24661: LD_VAR 0 9
24665: PPUSH
24666: LD_INT 1
24668: PPUSH
24669: CALL_OW 275
24673: PUSH
24674: LD_VAR 0 14
24678: PUSH
24679: LD_INT 1
24681: ARRAY
24682: GREATEREQUAL
24683: PUSH
24684: LD_VAR 0 9
24688: PPUSH
24689: LD_INT 2
24691: PPUSH
24692: CALL_OW 275
24696: PUSH
24697: LD_VAR 0 14
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: GREATEREQUAL
24706: AND
24707: PUSH
24708: LD_VAR 0 9
24712: PPUSH
24713: LD_INT 3
24715: PPUSH
24716: CALL_OW 275
24720: PUSH
24721: LD_VAR 0 14
24725: PUSH
24726: LD_INT 3
24728: ARRAY
24729: GREATEREQUAL
24730: AND
24731: IFFALSE 24743
// result := weapon ;
24733: LD_ADDR_VAR 0 3
24737: PUSH
24738: LD_VAR 0 18
24742: ST_TO_ADDR
// end ; end ;
24743: LD_VAR 0 3
24747: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
24748: LD_INT 0
24750: PPUSH
24751: PPUSH
// result := true ;
24752: LD_ADDR_VAR 0 3
24756: PUSH
24757: LD_INT 1
24759: ST_TO_ADDR
// if array1 = array2 then
24760: LD_VAR 0 1
24764: PUSH
24765: LD_VAR 0 2
24769: EQUAL
24770: IFFALSE 24830
// begin for i = 1 to array1 do
24772: LD_ADDR_VAR 0 4
24776: PUSH
24777: DOUBLE
24778: LD_INT 1
24780: DEC
24781: ST_TO_ADDR
24782: LD_VAR 0 1
24786: PUSH
24787: FOR_TO
24788: IFFALSE 24826
// if array1 [ i ] <> array2 [ i ] then
24790: LD_VAR 0 1
24794: PUSH
24795: LD_VAR 0 4
24799: ARRAY
24800: PUSH
24801: LD_VAR 0 2
24805: PUSH
24806: LD_VAR 0 4
24810: ARRAY
24811: NONEQUAL
24812: IFFALSE 24824
// begin result := false ;
24814: LD_ADDR_VAR 0 3
24818: PUSH
24819: LD_INT 0
24821: ST_TO_ADDR
// break ;
24822: GO 24826
// end ;
24824: GO 24787
24826: POP
24827: POP
// end else
24828: GO 24838
// result := false ;
24830: LD_ADDR_VAR 0 3
24834: PUSH
24835: LD_INT 0
24837: ST_TO_ADDR
// end ;
24838: LD_VAR 0 3
24842: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
24843: LD_INT 0
24845: PPUSH
24846: PPUSH
24847: PPUSH
// pom := GetBase ( fac ) ;
24848: LD_ADDR_VAR 0 5
24852: PUSH
24853: LD_VAR 0 1
24857: PPUSH
24858: CALL_OW 274
24862: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 2
24872: PUSH
24873: LD_INT 1
24875: ARRAY
24876: PPUSH
24877: LD_VAR 0 2
24881: PUSH
24882: LD_INT 2
24884: ARRAY
24885: PPUSH
24886: LD_VAR 0 2
24890: PUSH
24891: LD_INT 3
24893: ARRAY
24894: PPUSH
24895: LD_VAR 0 2
24899: PUSH
24900: LD_INT 4
24902: ARRAY
24903: PPUSH
24904: CALL_OW 449
24908: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
24909: LD_ADDR_VAR 0 3
24913: PUSH
24914: LD_VAR 0 5
24918: PPUSH
24919: LD_INT 1
24921: PPUSH
24922: CALL_OW 275
24926: PUSH
24927: LD_VAR 0 4
24931: PUSH
24932: LD_INT 1
24934: ARRAY
24935: GREATEREQUAL
24936: PUSH
24937: LD_VAR 0 5
24941: PPUSH
24942: LD_INT 2
24944: PPUSH
24945: CALL_OW 275
24949: PUSH
24950: LD_VAR 0 4
24954: PUSH
24955: LD_INT 2
24957: ARRAY
24958: GREATEREQUAL
24959: AND
24960: PUSH
24961: LD_VAR 0 5
24965: PPUSH
24966: LD_INT 3
24968: PPUSH
24969: CALL_OW 275
24973: PUSH
24974: LD_VAR 0 4
24978: PUSH
24979: LD_INT 3
24981: ARRAY
24982: GREATEREQUAL
24983: AND
24984: ST_TO_ADDR
// end ;
24985: LD_VAR 0 3
24989: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
24990: LD_INT 0
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
// pom := GetBase ( building ) ;
24996: LD_ADDR_VAR 0 3
25000: PUSH
25001: LD_VAR 0 1
25005: PPUSH
25006: CALL_OW 274
25010: ST_TO_ADDR
// if not pom then
25011: LD_VAR 0 3
25015: NOT
25016: IFFALSE 25020
// exit ;
25018: GO 25190
// btype := GetBType ( building ) ;
25020: LD_ADDR_VAR 0 5
25024: PUSH
25025: LD_VAR 0 1
25029: PPUSH
25030: CALL_OW 266
25034: ST_TO_ADDR
// if btype = b_armoury then
25035: LD_VAR 0 5
25039: PUSH
25040: LD_INT 4
25042: EQUAL
25043: IFFALSE 25053
// btype := b_barracks ;
25045: LD_ADDR_VAR 0 5
25049: PUSH
25050: LD_INT 5
25052: ST_TO_ADDR
// if btype = b_depot then
25053: LD_VAR 0 5
25057: PUSH
25058: LD_INT 0
25060: EQUAL
25061: IFFALSE 25071
// btype := b_warehouse ;
25063: LD_ADDR_VAR 0 5
25067: PUSH
25068: LD_INT 1
25070: ST_TO_ADDR
// if btype = b_workshop then
25071: LD_VAR 0 5
25075: PUSH
25076: LD_INT 2
25078: EQUAL
25079: IFFALSE 25089
// btype := b_factory ;
25081: LD_ADDR_VAR 0 5
25085: PUSH
25086: LD_INT 3
25088: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25089: LD_ADDR_VAR 0 4
25093: PUSH
25094: LD_VAR 0 5
25098: PPUSH
25099: LD_VAR 0 1
25103: PPUSH
25104: CALL_OW 248
25108: PPUSH
25109: CALL_OW 450
25113: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25114: LD_ADDR_VAR 0 2
25118: PUSH
25119: LD_VAR 0 3
25123: PPUSH
25124: LD_INT 1
25126: PPUSH
25127: CALL_OW 275
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: ARRAY
25140: GREATEREQUAL
25141: PUSH
25142: LD_VAR 0 3
25146: PPUSH
25147: LD_INT 2
25149: PPUSH
25150: CALL_OW 275
25154: PUSH
25155: LD_VAR 0 4
25159: PUSH
25160: LD_INT 2
25162: ARRAY
25163: GREATEREQUAL
25164: AND
25165: PUSH
25166: LD_VAR 0 3
25170: PPUSH
25171: LD_INT 3
25173: PPUSH
25174: CALL_OW 275
25178: PUSH
25179: LD_VAR 0 4
25183: PUSH
25184: LD_INT 3
25186: ARRAY
25187: GREATEREQUAL
25188: AND
25189: ST_TO_ADDR
// end ;
25190: LD_VAR 0 2
25194: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25195: LD_INT 0
25197: PPUSH
25198: PPUSH
25199: PPUSH
// pom := GetBase ( building ) ;
25200: LD_ADDR_VAR 0 4
25204: PUSH
25205: LD_VAR 0 1
25209: PPUSH
25210: CALL_OW 274
25214: ST_TO_ADDR
// if not pom then
25215: LD_VAR 0 4
25219: NOT
25220: IFFALSE 25224
// exit ;
25222: GO 25325
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25224: LD_ADDR_VAR 0 5
25228: PUSH
25229: LD_VAR 0 2
25233: PPUSH
25234: LD_VAR 0 1
25238: PPUSH
25239: CALL_OW 248
25243: PPUSH
25244: CALL_OW 450
25248: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25249: LD_ADDR_VAR 0 3
25253: PUSH
25254: LD_VAR 0 4
25258: PPUSH
25259: LD_INT 1
25261: PPUSH
25262: CALL_OW 275
25266: PUSH
25267: LD_VAR 0 5
25271: PUSH
25272: LD_INT 1
25274: ARRAY
25275: GREATEREQUAL
25276: PUSH
25277: LD_VAR 0 4
25281: PPUSH
25282: LD_INT 2
25284: PPUSH
25285: CALL_OW 275
25289: PUSH
25290: LD_VAR 0 5
25294: PUSH
25295: LD_INT 2
25297: ARRAY
25298: GREATEREQUAL
25299: AND
25300: PUSH
25301: LD_VAR 0 4
25305: PPUSH
25306: LD_INT 3
25308: PPUSH
25309: CALL_OW 275
25313: PUSH
25314: LD_VAR 0 5
25318: PUSH
25319: LD_INT 3
25321: ARRAY
25322: GREATEREQUAL
25323: AND
25324: ST_TO_ADDR
// end ;
25325: LD_VAR 0 3
25329: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25330: LD_INT 0
25332: PPUSH
25333: PPUSH
25334: PPUSH
25335: PPUSH
25336: PPUSH
25337: PPUSH
25338: PPUSH
25339: PPUSH
25340: PPUSH
25341: PPUSH
// result := false ;
25342: LD_ADDR_VAR 0 6
25346: PUSH
25347: LD_INT 0
25349: ST_TO_ADDR
// if not base or not btype or not x or not y then
25350: LD_VAR 0 1
25354: NOT
25355: PUSH
25356: LD_VAR 0 2
25360: NOT
25361: OR
25362: PUSH
25363: LD_VAR 0 3
25367: NOT
25368: OR
25369: PUSH
25370: LD_VAR 0 4
25374: NOT
25375: OR
25376: IFFALSE 25380
// exit ;
25378: GO 25989
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
25380: LD_ADDR_VAR 0 12
25384: PUSH
25385: LD_VAR 0 2
25389: PPUSH
25390: LD_VAR 0 3
25394: PPUSH
25395: LD_VAR 0 4
25399: PPUSH
25400: LD_VAR 0 5
25404: PPUSH
25405: LD_VAR 0 1
25409: PUSH
25410: LD_INT 1
25412: ARRAY
25413: PPUSH
25414: CALL_OW 248
25418: PPUSH
25419: LD_INT 0
25421: PPUSH
25422: CALL 26826 0 6
25426: ST_TO_ADDR
// if not hexes then
25427: LD_VAR 0 12
25431: NOT
25432: IFFALSE 25436
// exit ;
25434: GO 25989
// for i = 1 to hexes do
25436: LD_ADDR_VAR 0 7
25440: PUSH
25441: DOUBLE
25442: LD_INT 1
25444: DEC
25445: ST_TO_ADDR
25446: LD_VAR 0 12
25450: PUSH
25451: FOR_TO
25452: IFFALSE 25987
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25454: LD_ADDR_VAR 0 11
25458: PUSH
25459: LD_VAR 0 12
25463: PUSH
25464: LD_VAR 0 7
25468: ARRAY
25469: PUSH
25470: LD_INT 1
25472: ARRAY
25473: PPUSH
25474: LD_VAR 0 12
25478: PUSH
25479: LD_VAR 0 7
25483: ARRAY
25484: PUSH
25485: LD_INT 2
25487: ARRAY
25488: PPUSH
25489: CALL_OW 428
25493: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
25494: LD_VAR 0 12
25498: PUSH
25499: LD_VAR 0 7
25503: ARRAY
25504: PUSH
25505: LD_INT 1
25507: ARRAY
25508: PPUSH
25509: LD_VAR 0 12
25513: PUSH
25514: LD_VAR 0 7
25518: ARRAY
25519: PUSH
25520: LD_INT 2
25522: ARRAY
25523: PPUSH
25524: CALL_OW 351
25528: PUSH
25529: LD_VAR 0 12
25533: PUSH
25534: LD_VAR 0 7
25538: ARRAY
25539: PUSH
25540: LD_INT 1
25542: ARRAY
25543: PPUSH
25544: LD_VAR 0 12
25548: PUSH
25549: LD_VAR 0 7
25553: ARRAY
25554: PUSH
25555: LD_INT 2
25557: ARRAY
25558: PPUSH
25559: CALL_OW 488
25563: NOT
25564: OR
25565: PUSH
25566: LD_VAR 0 11
25570: PPUSH
25571: CALL_OW 247
25575: PUSH
25576: LD_INT 3
25578: EQUAL
25579: OR
25580: IFFALSE 25586
// exit ;
25582: POP
25583: POP
25584: GO 25989
// if not tmp or not tmp in base then
25586: LD_VAR 0 11
25590: NOT
25591: PUSH
25592: LD_VAR 0 11
25596: PUSH
25597: LD_VAR 0 1
25601: IN
25602: NOT
25603: OR
25604: IFFALSE 25608
// continue ;
25606: GO 25451
// result := true ;
25608: LD_ADDR_VAR 0 6
25612: PUSH
25613: LD_INT 1
25615: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
25616: LD_ADDR_VAR 0 15
25620: PUSH
25621: LD_VAR 0 1
25625: PPUSH
25626: LD_INT 22
25628: PUSH
25629: LD_VAR 0 11
25633: PPUSH
25634: CALL_OW 255
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 30
25648: PUSH
25649: LD_INT 0
25651: PUSH
25652: EMPTY
25653: LIST
25654: LIST
25655: PUSH
25656: LD_INT 30
25658: PUSH
25659: LD_INT 1
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: LIST
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: PPUSH
25675: CALL_OW 72
25679: ST_TO_ADDR
// if dep then
25680: LD_VAR 0 15
25684: IFFALSE 25820
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
25686: LD_ADDR_VAR 0 14
25690: PUSH
25691: LD_VAR 0 15
25695: PUSH
25696: LD_INT 1
25698: ARRAY
25699: PPUSH
25700: CALL_OW 250
25704: PPUSH
25705: LD_VAR 0 15
25709: PUSH
25710: LD_INT 1
25712: ARRAY
25713: PPUSH
25714: CALL_OW 254
25718: PPUSH
25719: LD_INT 5
25721: PPUSH
25722: CALL_OW 272
25726: PUSH
25727: LD_VAR 0 15
25731: PUSH
25732: LD_INT 1
25734: ARRAY
25735: PPUSH
25736: CALL_OW 251
25740: PPUSH
25741: LD_VAR 0 15
25745: PUSH
25746: LD_INT 1
25748: ARRAY
25749: PPUSH
25750: CALL_OW 254
25754: PPUSH
25755: LD_INT 5
25757: PPUSH
25758: CALL_OW 273
25762: PUSH
25763: EMPTY
25764: LIST
25765: LIST
25766: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
25767: LD_VAR 0 14
25771: PUSH
25772: LD_INT 1
25774: ARRAY
25775: PPUSH
25776: LD_VAR 0 14
25780: PUSH
25781: LD_INT 2
25783: ARRAY
25784: PPUSH
25785: CALL_OW 488
25789: IFFALSE 25820
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
25791: LD_VAR 0 11
25795: PPUSH
25796: LD_VAR 0 14
25800: PUSH
25801: LD_INT 1
25803: ARRAY
25804: PPUSH
25805: LD_VAR 0 14
25809: PUSH
25810: LD_INT 2
25812: ARRAY
25813: PPUSH
25814: CALL_OW 111
// continue ;
25818: GO 25451
// end ; end ; r := GetDir ( tmp ) ;
25820: LD_ADDR_VAR 0 13
25824: PUSH
25825: LD_VAR 0 11
25829: PPUSH
25830: CALL_OW 254
25834: ST_TO_ADDR
// if r = 5 then
25835: LD_VAR 0 13
25839: PUSH
25840: LD_INT 5
25842: EQUAL
25843: IFFALSE 25853
// r := 0 ;
25845: LD_ADDR_VAR 0 13
25849: PUSH
25850: LD_INT 0
25852: ST_TO_ADDR
// for j = r to 5 do
25853: LD_ADDR_VAR 0 8
25857: PUSH
25858: DOUBLE
25859: LD_VAR 0 13
25863: DEC
25864: ST_TO_ADDR
25865: LD_INT 5
25867: PUSH
25868: FOR_TO
25869: IFFALSE 25983
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
25871: LD_ADDR_VAR 0 9
25875: PUSH
25876: LD_VAR 0 11
25880: PPUSH
25881: CALL_OW 250
25885: PPUSH
25886: LD_VAR 0 8
25890: PPUSH
25891: LD_INT 2
25893: PPUSH
25894: CALL_OW 272
25898: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
25899: LD_ADDR_VAR 0 10
25903: PUSH
25904: LD_VAR 0 11
25908: PPUSH
25909: CALL_OW 251
25913: PPUSH
25914: LD_VAR 0 8
25918: PPUSH
25919: LD_INT 2
25921: PPUSH
25922: CALL_OW 273
25926: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
25927: LD_VAR 0 9
25931: PPUSH
25932: LD_VAR 0 10
25936: PPUSH
25937: CALL_OW 488
25941: PUSH
25942: LD_VAR 0 9
25946: PPUSH
25947: LD_VAR 0 10
25951: PPUSH
25952: CALL_OW 428
25956: NOT
25957: AND
25958: IFFALSE 25981
// begin ComMoveXY ( tmp , _x , _y ) ;
25960: LD_VAR 0 11
25964: PPUSH
25965: LD_VAR 0 9
25969: PPUSH
25970: LD_VAR 0 10
25974: PPUSH
25975: CALL_OW 111
// break ;
25979: GO 25983
// end ; end ;
25981: GO 25868
25983: POP
25984: POP
// end ;
25985: GO 25451
25987: POP
25988: POP
// end ;
25989: LD_VAR 0 6
25993: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
25994: LD_INT 0
25996: PPUSH
25997: PPUSH
25998: PPUSH
25999: PPUSH
26000: PPUSH
26001: PPUSH
26002: PPUSH
26003: PPUSH
26004: PPUSH
26005: PPUSH
// result := false ;
26006: LD_ADDR_VAR 0 6
26010: PUSH
26011: LD_INT 0
26013: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26014: LD_VAR 0 1
26018: NOT
26019: PUSH
26020: LD_VAR 0 1
26024: PPUSH
26025: CALL_OW 266
26029: PUSH
26030: LD_INT 0
26032: PUSH
26033: LD_INT 1
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: IN
26040: NOT
26041: OR
26042: PUSH
26043: LD_VAR 0 2
26047: NOT
26048: OR
26049: PUSH
26050: LD_VAR 0 5
26054: PUSH
26055: LD_INT 0
26057: PUSH
26058: LD_INT 1
26060: PUSH
26061: LD_INT 2
26063: PUSH
26064: LD_INT 3
26066: PUSH
26067: LD_INT 4
26069: PUSH
26070: LD_INT 5
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: LIST
26077: LIST
26078: LIST
26079: LIST
26080: IN
26081: NOT
26082: OR
26083: PUSH
26084: LD_VAR 0 3
26088: PPUSH
26089: LD_VAR 0 4
26093: PPUSH
26094: CALL_OW 488
26098: NOT
26099: OR
26100: IFFALSE 26104
// exit ;
26102: GO 26821
// pom := GetBase ( depot ) ;
26104: LD_ADDR_VAR 0 10
26108: PUSH
26109: LD_VAR 0 1
26113: PPUSH
26114: CALL_OW 274
26118: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26119: LD_ADDR_VAR 0 11
26123: PUSH
26124: LD_VAR 0 2
26128: PPUSH
26129: LD_VAR 0 1
26133: PPUSH
26134: CALL_OW 248
26138: PPUSH
26139: CALL_OW 450
26143: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26144: LD_VAR 0 10
26148: PPUSH
26149: LD_INT 1
26151: PPUSH
26152: CALL_OW 275
26156: PUSH
26157: LD_VAR 0 11
26161: PUSH
26162: LD_INT 1
26164: ARRAY
26165: GREATEREQUAL
26166: PUSH
26167: LD_VAR 0 10
26171: PPUSH
26172: LD_INT 2
26174: PPUSH
26175: CALL_OW 275
26179: PUSH
26180: LD_VAR 0 11
26184: PUSH
26185: LD_INT 2
26187: ARRAY
26188: GREATEREQUAL
26189: AND
26190: PUSH
26191: LD_VAR 0 10
26195: PPUSH
26196: LD_INT 3
26198: PPUSH
26199: CALL_OW 275
26203: PUSH
26204: LD_VAR 0 11
26208: PUSH
26209: LD_INT 3
26211: ARRAY
26212: GREATEREQUAL
26213: AND
26214: NOT
26215: IFFALSE 26219
// exit ;
26217: GO 26821
// if GetBType ( depot ) = b_depot then
26219: LD_VAR 0 1
26223: PPUSH
26224: CALL_OW 266
26228: PUSH
26229: LD_INT 0
26231: EQUAL
26232: IFFALSE 26244
// dist := 28 else
26234: LD_ADDR_VAR 0 14
26238: PUSH
26239: LD_INT 28
26241: ST_TO_ADDR
26242: GO 26252
// dist := 36 ;
26244: LD_ADDR_VAR 0 14
26248: PUSH
26249: LD_INT 36
26251: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26252: LD_VAR 0 1
26256: PPUSH
26257: LD_VAR 0 3
26261: PPUSH
26262: LD_VAR 0 4
26266: PPUSH
26267: CALL_OW 297
26271: PUSH
26272: LD_VAR 0 14
26276: GREATER
26277: IFFALSE 26281
// exit ;
26279: GO 26821
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26281: LD_ADDR_VAR 0 12
26285: PUSH
26286: LD_VAR 0 2
26290: PPUSH
26291: LD_VAR 0 3
26295: PPUSH
26296: LD_VAR 0 4
26300: PPUSH
26301: LD_VAR 0 5
26305: PPUSH
26306: LD_VAR 0 1
26310: PPUSH
26311: CALL_OW 248
26315: PPUSH
26316: LD_INT 0
26318: PPUSH
26319: CALL 26826 0 6
26323: ST_TO_ADDR
// if not hexes then
26324: LD_VAR 0 12
26328: NOT
26329: IFFALSE 26333
// exit ;
26331: GO 26821
// hex := GetHexInfo ( x , y ) ;
26333: LD_ADDR_VAR 0 15
26337: PUSH
26338: LD_VAR 0 3
26342: PPUSH
26343: LD_VAR 0 4
26347: PPUSH
26348: CALL_OW 546
26352: ST_TO_ADDR
// if hex [ 1 ] then
26353: LD_VAR 0 15
26357: PUSH
26358: LD_INT 1
26360: ARRAY
26361: IFFALSE 26365
// exit ;
26363: GO 26821
// height := hex [ 2 ] ;
26365: LD_ADDR_VAR 0 13
26369: PUSH
26370: LD_VAR 0 15
26374: PUSH
26375: LD_INT 2
26377: ARRAY
26378: ST_TO_ADDR
// for i = 1 to hexes do
26379: LD_ADDR_VAR 0 7
26383: PUSH
26384: DOUBLE
26385: LD_INT 1
26387: DEC
26388: ST_TO_ADDR
26389: LD_VAR 0 12
26393: PUSH
26394: FOR_TO
26395: IFFALSE 26725
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
26397: LD_VAR 0 12
26401: PUSH
26402: LD_VAR 0 7
26406: ARRAY
26407: PUSH
26408: LD_INT 1
26410: ARRAY
26411: PPUSH
26412: LD_VAR 0 12
26416: PUSH
26417: LD_VAR 0 7
26421: ARRAY
26422: PUSH
26423: LD_INT 2
26425: ARRAY
26426: PPUSH
26427: CALL_OW 488
26431: NOT
26432: PUSH
26433: LD_VAR 0 12
26437: PUSH
26438: LD_VAR 0 7
26442: ARRAY
26443: PUSH
26444: LD_INT 1
26446: ARRAY
26447: PPUSH
26448: LD_VAR 0 12
26452: PUSH
26453: LD_VAR 0 7
26457: ARRAY
26458: PUSH
26459: LD_INT 2
26461: ARRAY
26462: PPUSH
26463: CALL_OW 428
26467: PUSH
26468: LD_INT 0
26470: GREATER
26471: OR
26472: PUSH
26473: LD_VAR 0 12
26477: PUSH
26478: LD_VAR 0 7
26482: ARRAY
26483: PUSH
26484: LD_INT 1
26486: ARRAY
26487: PPUSH
26488: LD_VAR 0 12
26492: PUSH
26493: LD_VAR 0 7
26497: ARRAY
26498: PUSH
26499: LD_INT 2
26501: ARRAY
26502: PPUSH
26503: CALL_OW 351
26507: OR
26508: IFFALSE 26514
// exit ;
26510: POP
26511: POP
26512: GO 26821
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26514: LD_ADDR_VAR 0 8
26518: PUSH
26519: LD_VAR 0 12
26523: PUSH
26524: LD_VAR 0 7
26528: ARRAY
26529: PUSH
26530: LD_INT 1
26532: ARRAY
26533: PPUSH
26534: LD_VAR 0 12
26538: PUSH
26539: LD_VAR 0 7
26543: ARRAY
26544: PUSH
26545: LD_INT 2
26547: ARRAY
26548: PPUSH
26549: CALL_OW 546
26553: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
26554: LD_VAR 0 8
26558: PUSH
26559: LD_INT 1
26561: ARRAY
26562: PUSH
26563: LD_VAR 0 8
26567: PUSH
26568: LD_INT 2
26570: ARRAY
26571: PUSH
26572: LD_VAR 0 13
26576: PUSH
26577: LD_INT 2
26579: PLUS
26580: GREATER
26581: OR
26582: PUSH
26583: LD_VAR 0 8
26587: PUSH
26588: LD_INT 2
26590: ARRAY
26591: PUSH
26592: LD_VAR 0 13
26596: PUSH
26597: LD_INT 2
26599: MINUS
26600: LESS
26601: OR
26602: PUSH
26603: LD_VAR 0 8
26607: PUSH
26608: LD_INT 3
26610: ARRAY
26611: PUSH
26612: LD_INT 0
26614: PUSH
26615: LD_INT 8
26617: PUSH
26618: LD_INT 9
26620: PUSH
26621: LD_INT 10
26623: PUSH
26624: LD_INT 11
26626: PUSH
26627: LD_INT 12
26629: PUSH
26630: LD_INT 13
26632: PUSH
26633: LD_INT 16
26635: PUSH
26636: LD_INT 17
26638: PUSH
26639: LD_INT 18
26641: PUSH
26642: LD_INT 19
26644: PUSH
26645: LD_INT 20
26647: PUSH
26648: LD_INT 21
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: IN
26666: NOT
26667: OR
26668: PUSH
26669: LD_VAR 0 8
26673: PUSH
26674: LD_INT 5
26676: ARRAY
26677: NOT
26678: OR
26679: PUSH
26680: LD_VAR 0 8
26684: PUSH
26685: LD_INT 6
26687: ARRAY
26688: PUSH
26689: LD_INT 1
26691: PUSH
26692: LD_INT 2
26694: PUSH
26695: LD_INT 7
26697: PUSH
26698: LD_INT 9
26700: PUSH
26701: LD_INT 10
26703: PUSH
26704: LD_INT 11
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: LIST
26711: LIST
26712: LIST
26713: LIST
26714: IN
26715: NOT
26716: OR
26717: IFFALSE 26723
// exit ;
26719: POP
26720: POP
26721: GO 26821
// end ;
26723: GO 26394
26725: POP
26726: POP
// side := GetSide ( depot ) ;
26727: LD_ADDR_VAR 0 9
26731: PUSH
26732: LD_VAR 0 1
26736: PPUSH
26737: CALL_OW 255
26741: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
26742: LD_VAR 0 9
26746: PPUSH
26747: LD_VAR 0 3
26751: PPUSH
26752: LD_VAR 0 4
26756: PPUSH
26757: LD_INT 20
26759: PPUSH
26760: CALL 19475 0 4
26764: PUSH
26765: LD_INT 4
26767: ARRAY
26768: IFFALSE 26772
// exit ;
26770: GO 26821
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
26772: LD_VAR 0 2
26776: PUSH
26777: LD_INT 29
26779: PUSH
26780: LD_INT 30
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: IN
26787: PUSH
26788: LD_VAR 0 3
26792: PPUSH
26793: LD_VAR 0 4
26797: PPUSH
26798: LD_VAR 0 9
26802: PPUSH
26803: CALL_OW 440
26807: NOT
26808: AND
26809: IFFALSE 26813
// exit ;
26811: GO 26821
// result := true ;
26813: LD_ADDR_VAR 0 6
26817: PUSH
26818: LD_INT 1
26820: ST_TO_ADDR
// end ;
26821: LD_VAR 0 6
26825: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
26826: LD_INT 0
26828: PPUSH
26829: PPUSH
26830: PPUSH
26831: PPUSH
26832: PPUSH
26833: PPUSH
26834: PPUSH
26835: PPUSH
26836: PPUSH
26837: PPUSH
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
26844: PPUSH
26845: PPUSH
26846: PPUSH
26847: PPUSH
26848: PPUSH
26849: PPUSH
26850: PPUSH
26851: PPUSH
26852: PPUSH
26853: PPUSH
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
26866: PPUSH
26867: PPUSH
26868: PPUSH
26869: PPUSH
26870: PPUSH
26871: PPUSH
26872: PPUSH
26873: PPUSH
26874: PPUSH
26875: PPUSH
26876: PPUSH
26877: PPUSH
26878: PPUSH
26879: PPUSH
26880: PPUSH
26881: PPUSH
26882: PPUSH
26883: PPUSH
26884: PPUSH
26885: PPUSH
// result = [ ] ;
26886: LD_ADDR_VAR 0 7
26890: PUSH
26891: EMPTY
26892: ST_TO_ADDR
// temp_list = [ ] ;
26893: LD_ADDR_VAR 0 9
26897: PUSH
26898: EMPTY
26899: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
26900: LD_VAR 0 4
26904: PUSH
26905: LD_INT 0
26907: PUSH
26908: LD_INT 1
26910: PUSH
26911: LD_INT 2
26913: PUSH
26914: LD_INT 3
26916: PUSH
26917: LD_INT 4
26919: PUSH
26920: LD_INT 5
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: IN
26931: NOT
26932: PUSH
26933: LD_VAR 0 1
26937: PUSH
26938: LD_INT 0
26940: PUSH
26941: LD_INT 1
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: IN
26948: PUSH
26949: LD_VAR 0 5
26953: PUSH
26954: LD_INT 1
26956: PUSH
26957: LD_INT 2
26959: PUSH
26960: LD_INT 3
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: LIST
26967: IN
26968: NOT
26969: AND
26970: OR
26971: IFFALSE 26975
// exit ;
26973: GO 45366
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
26975: LD_VAR 0 1
26979: PUSH
26980: LD_INT 6
26982: PUSH
26983: LD_INT 7
26985: PUSH
26986: LD_INT 8
26988: PUSH
26989: LD_INT 13
26991: PUSH
26992: LD_INT 12
26994: PUSH
26995: LD_INT 15
26997: PUSH
26998: LD_INT 11
27000: PUSH
27001: LD_INT 14
27003: PUSH
27004: LD_INT 10
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: IN
27018: IFFALSE 27028
// btype = b_lab ;
27020: LD_ADDR_VAR 0 1
27024: PUSH
27025: LD_INT 6
27027: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27028: LD_VAR 0 6
27032: PUSH
27033: LD_INT 0
27035: PUSH
27036: LD_INT 1
27038: PUSH
27039: LD_INT 2
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: LIST
27046: IN
27047: NOT
27048: PUSH
27049: LD_VAR 0 1
27053: PUSH
27054: LD_INT 0
27056: PUSH
27057: LD_INT 1
27059: PUSH
27060: LD_INT 2
27062: PUSH
27063: LD_INT 3
27065: PUSH
27066: LD_INT 6
27068: PUSH
27069: LD_INT 36
27071: PUSH
27072: LD_INT 4
27074: PUSH
27075: LD_INT 5
27077: PUSH
27078: LD_INT 31
27080: PUSH
27081: LD_INT 32
27083: PUSH
27084: LD_INT 33
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: IN
27100: NOT
27101: PUSH
27102: LD_VAR 0 6
27106: PUSH
27107: LD_INT 1
27109: EQUAL
27110: AND
27111: OR
27112: PUSH
27113: LD_VAR 0 1
27117: PUSH
27118: LD_INT 2
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: IN
27128: NOT
27129: PUSH
27130: LD_VAR 0 6
27134: PUSH
27135: LD_INT 2
27137: EQUAL
27138: AND
27139: OR
27140: IFFALSE 27150
// mode = 0 ;
27142: LD_ADDR_VAR 0 6
27146: PUSH
27147: LD_INT 0
27149: ST_TO_ADDR
// case mode of 0 :
27150: LD_VAR 0 6
27154: PUSH
27155: LD_INT 0
27157: DOUBLE
27158: EQUAL
27159: IFTRUE 27163
27161: GO 38616
27163: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27164: LD_ADDR_VAR 0 11
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 0
27181: PUSH
27182: LD_INT 1
27184: NEG
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 1
27192: PUSH
27193: LD_INT 0
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 1
27202: PUSH
27203: LD_INT 1
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 0
27212: PUSH
27213: LD_INT 1
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: LD_INT 1
27222: NEG
27223: PUSH
27224: LD_INT 0
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 1
27233: NEG
27234: PUSH
27235: LD_INT 1
27237: NEG
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 1
27245: NEG
27246: PUSH
27247: LD_INT 2
27249: NEG
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PUSH
27255: LD_INT 0
27257: PUSH
27258: LD_INT 2
27260: NEG
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 1
27268: PUSH
27269: LD_INT 1
27271: NEG
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 1
27279: PUSH
27280: LD_INT 2
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 0
27289: PUSH
27290: LD_INT 2
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: PUSH
27297: LD_INT 1
27299: NEG
27300: PUSH
27301: LD_INT 1
27303: PUSH
27304: EMPTY
27305: LIST
27306: LIST
27307: PUSH
27308: LD_INT 1
27310: PUSH
27311: LD_INT 3
27313: PUSH
27314: EMPTY
27315: LIST
27316: LIST
27317: PUSH
27318: LD_INT 0
27320: PUSH
27321: LD_INT 3
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: LD_INT 2
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: LIST
27344: LIST
27345: LIST
27346: LIST
27347: LIST
27348: LIST
27349: LIST
27350: LIST
27351: LIST
27352: LIST
27353: LIST
27354: LIST
27355: LIST
27356: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
27357: LD_ADDR_VAR 0 12
27361: PUSH
27362: LD_INT 0
27364: PUSH
27365: LD_INT 0
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 0
27374: PUSH
27375: LD_INT 1
27377: NEG
27378: PUSH
27379: EMPTY
27380: LIST
27381: LIST
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 1
27395: PUSH
27396: LD_INT 1
27398: PUSH
27399: EMPTY
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 0
27405: PUSH
27406: LD_INT 1
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: LD_INT 1
27415: NEG
27416: PUSH
27417: LD_INT 0
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: LD_INT 1
27426: NEG
27427: PUSH
27428: LD_INT 1
27430: NEG
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 1
27438: PUSH
27439: LD_INT 1
27441: NEG
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 2
27449: PUSH
27450: LD_INT 0
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 2
27459: PUSH
27460: LD_INT 1
27462: PUSH
27463: EMPTY
27464: LIST
27465: LIST
27466: PUSH
27467: LD_INT 1
27469: NEG
27470: PUSH
27471: LD_INT 1
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: PUSH
27478: LD_INT 2
27480: NEG
27481: PUSH
27482: LD_INT 0
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 2
27491: NEG
27492: PUSH
27493: LD_INT 1
27495: NEG
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: PUSH
27501: LD_INT 2
27503: NEG
27504: PUSH
27505: LD_INT 1
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 3
27514: NEG
27515: PUSH
27516: LD_INT 0
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 3
27525: NEG
27526: PUSH
27527: LD_INT 1
27529: NEG
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
27553: LD_ADDR_VAR 0 13
27557: PUSH
27558: LD_INT 0
27560: PUSH
27561: LD_INT 0
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 0
27570: PUSH
27571: LD_INT 1
27573: NEG
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PUSH
27592: LD_INT 1
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 0
27601: PUSH
27602: LD_INT 1
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: LD_INT 1
27611: NEG
27612: PUSH
27613: LD_INT 0
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: NEG
27623: PUSH
27624: LD_INT 1
27626: NEG
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: PUSH
27632: LD_INT 1
27634: NEG
27635: PUSH
27636: LD_INT 2
27638: NEG
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 2
27646: PUSH
27647: LD_INT 1
27649: PUSH
27650: EMPTY
27651: LIST
27652: LIST
27653: PUSH
27654: LD_INT 2
27656: PUSH
27657: LD_INT 2
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PUSH
27664: LD_INT 1
27666: PUSH
27667: LD_INT 2
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 2
27676: NEG
27677: PUSH
27678: LD_INT 1
27680: NEG
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: LD_INT 2
27692: NEG
27693: PUSH
27694: EMPTY
27695: LIST
27696: LIST
27697: PUSH
27698: LD_INT 2
27700: NEG
27701: PUSH
27702: LD_INT 3
27704: NEG
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: LD_INT 3
27712: NEG
27713: PUSH
27714: LD_INT 2
27716: NEG
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 3
27724: NEG
27725: PUSH
27726: LD_INT 3
27728: NEG
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: LIST
27738: LIST
27739: LIST
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
27752: LD_ADDR_VAR 0 14
27756: PUSH
27757: LD_INT 0
27759: PUSH
27760: LD_INT 0
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: LD_INT 1
27772: NEG
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: LD_INT 1
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 1
27790: PUSH
27791: LD_INT 1
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 0
27800: PUSH
27801: LD_INT 1
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 1
27810: NEG
27811: PUSH
27812: LD_INT 0
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 1
27821: NEG
27822: PUSH
27823: LD_INT 1
27825: NEG
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PUSH
27831: LD_INT 1
27833: NEG
27834: PUSH
27835: LD_INT 2
27837: NEG
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: PUSH
27843: LD_INT 0
27845: PUSH
27846: LD_INT 2
27848: NEG
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 1
27856: PUSH
27857: LD_INT 1
27859: NEG
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: PUSH
27868: LD_INT 2
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: LD_INT 2
27880: PUSH
27881: EMPTY
27882: LIST
27883: LIST
27884: PUSH
27885: LD_INT 1
27887: NEG
27888: PUSH
27889: LD_INT 1
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 1
27898: NEG
27899: PUSH
27900: LD_INT 3
27902: NEG
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: LD_INT 0
27910: PUSH
27911: LD_INT 3
27913: NEG
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: PUSH
27919: LD_INT 1
27921: PUSH
27922: LD_INT 2
27924: NEG
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: LIST
27947: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
27948: LD_ADDR_VAR 0 15
27952: PUSH
27953: LD_INT 0
27955: PUSH
27956: LD_INT 0
27958: PUSH
27959: EMPTY
27960: LIST
27961: LIST
27962: PUSH
27963: LD_INT 0
27965: PUSH
27966: LD_INT 1
27968: NEG
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 1
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 1
27986: PUSH
27987: LD_INT 1
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 0
27996: PUSH
27997: LD_INT 1
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 1
28006: NEG
28007: PUSH
28008: LD_INT 0
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: PUSH
28015: LD_INT 1
28017: NEG
28018: PUSH
28019: LD_INT 1
28021: NEG
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: PUSH
28027: LD_INT 1
28029: PUSH
28030: LD_INT 1
28032: NEG
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 2
28040: PUSH
28041: LD_INT 0
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: LD_INT 2
28050: PUSH
28051: LD_INT 1
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 1
28060: NEG
28061: PUSH
28062: LD_INT 1
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PUSH
28069: LD_INT 2
28071: NEG
28072: PUSH
28073: LD_INT 0
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 2
28082: NEG
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 2
28094: PUSH
28095: LD_INT 1
28097: NEG
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: PUSH
28103: LD_INT 3
28105: PUSH
28106: LD_INT 0
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: LD_INT 3
28115: PUSH
28116: LD_INT 1
28118: PUSH
28119: EMPTY
28120: LIST
28121: LIST
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: LIST
28130: LIST
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: LIST
28140: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28141: LD_ADDR_VAR 0 16
28145: PUSH
28146: LD_INT 0
28148: PUSH
28149: LD_INT 0
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 0
28158: PUSH
28159: LD_INT 1
28161: NEG
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 1
28169: PUSH
28170: LD_INT 0
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: LD_INT 1
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 0
28189: PUSH
28190: LD_INT 1
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 1
28199: NEG
28200: PUSH
28201: LD_INT 0
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 1
28210: NEG
28211: PUSH
28212: LD_INT 1
28214: NEG
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: LD_INT 1
28222: NEG
28223: PUSH
28224: LD_INT 2
28226: NEG
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 2
28234: PUSH
28235: LD_INT 1
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 2
28244: PUSH
28245: LD_INT 2
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 1
28254: PUSH
28255: LD_INT 2
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PUSH
28262: LD_INT 2
28264: NEG
28265: PUSH
28266: LD_INT 1
28268: NEG
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 2
28276: NEG
28277: PUSH
28278: LD_INT 2
28280: NEG
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 3
28288: PUSH
28289: LD_INT 2
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 3
28298: PUSH
28299: LD_INT 3
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 2
28308: PUSH
28309: LD_INT 3
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: EMPTY
28317: LIST
28318: LIST
28319: LIST
28320: LIST
28321: LIST
28322: LIST
28323: LIST
28324: LIST
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28334: LD_ADDR_VAR 0 17
28338: PUSH
28339: LD_INT 0
28341: PUSH
28342: LD_INT 0
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: LD_INT 1
28354: NEG
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 1
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: LD_INT 1
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: LD_INT 1
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: PUSH
28401: LD_INT 1
28403: NEG
28404: PUSH
28405: LD_INT 1
28407: NEG
28408: PUSH
28409: EMPTY
28410: LIST
28411: LIST
28412: PUSH
28413: LD_INT 1
28415: NEG
28416: PUSH
28417: LD_INT 2
28419: NEG
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 0
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: LD_INT 1
28441: NEG
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 2
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 2
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 2
28469: PUSH
28470: LD_INT 2
28472: PUSH
28473: EMPTY
28474: LIST
28475: LIST
28476: PUSH
28477: LD_INT 1
28479: PUSH
28480: LD_INT 2
28482: PUSH
28483: EMPTY
28484: LIST
28485: LIST
28486: PUSH
28487: LD_INT 0
28489: PUSH
28490: LD_INT 2
28492: PUSH
28493: EMPTY
28494: LIST
28495: LIST
28496: PUSH
28497: LD_INT 1
28499: NEG
28500: PUSH
28501: LD_INT 1
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 2
28510: NEG
28511: PUSH
28512: LD_INT 0
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: LD_INT 2
28521: NEG
28522: PUSH
28523: LD_INT 1
28525: NEG
28526: PUSH
28527: EMPTY
28528: LIST
28529: LIST
28530: PUSH
28531: LD_INT 2
28533: NEG
28534: PUSH
28535: LD_INT 2
28537: NEG
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: LIST
28547: LIST
28548: LIST
28549: LIST
28550: LIST
28551: LIST
28552: LIST
28553: LIST
28554: LIST
28555: LIST
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28564: LD_ADDR_VAR 0 18
28568: PUSH
28569: LD_INT 0
28571: PUSH
28572: LD_INT 0
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 0
28581: PUSH
28582: LD_INT 1
28584: NEG
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 1
28592: PUSH
28593: LD_INT 0
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 1
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 0
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: LD_INT 1
28622: NEG
28623: PUSH
28624: LD_INT 0
28626: PUSH
28627: EMPTY
28628: LIST
28629: LIST
28630: PUSH
28631: LD_INT 1
28633: NEG
28634: PUSH
28635: LD_INT 1
28637: NEG
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: NEG
28646: PUSH
28647: LD_INT 2
28649: NEG
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PUSH
28655: LD_INT 0
28657: PUSH
28658: LD_INT 2
28660: NEG
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: PUSH
28669: LD_INT 1
28671: NEG
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: PUSH
28687: LD_INT 2
28689: PUSH
28690: LD_INT 1
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 2
28699: PUSH
28700: LD_INT 2
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 1
28709: PUSH
28710: LD_INT 2
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 0
28719: PUSH
28720: LD_INT 2
28722: PUSH
28723: EMPTY
28724: LIST
28725: LIST
28726: PUSH
28727: LD_INT 1
28729: NEG
28730: PUSH
28731: LD_INT 1
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PUSH
28738: LD_INT 2
28740: NEG
28741: PUSH
28742: LD_INT 0
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: LD_INT 2
28751: NEG
28752: PUSH
28753: LD_INT 1
28755: NEG
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 2
28763: NEG
28764: PUSH
28765: LD_INT 2
28767: NEG
28768: PUSH
28769: EMPTY
28770: LIST
28771: LIST
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28794: LD_ADDR_VAR 0 19
28798: PUSH
28799: LD_INT 0
28801: PUSH
28802: LD_INT 0
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 0
28811: PUSH
28812: LD_INT 1
28814: NEG
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 1
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 0
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: LD_INT 1
28852: NEG
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: EMPTY
28858: LIST
28859: LIST
28860: PUSH
28861: LD_INT 1
28863: NEG
28864: PUSH
28865: LD_INT 1
28867: NEG
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 1
28875: NEG
28876: PUSH
28877: LD_INT 2
28879: NEG
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 0
28887: PUSH
28888: LD_INT 2
28890: NEG
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 1
28898: PUSH
28899: LD_INT 1
28901: NEG
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 2
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 2
28919: PUSH
28920: LD_INT 1
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 2
28929: PUSH
28930: LD_INT 2
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 1
28939: PUSH
28940: LD_INT 2
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 0
28949: PUSH
28950: LD_INT 2
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: LD_INT 1
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: LD_INT 2
28970: NEG
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 2
28981: NEG
28982: PUSH
28983: LD_INT 1
28985: NEG
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 2
28993: NEG
28994: PUSH
28995: LD_INT 2
28997: NEG
28998: PUSH
28999: EMPTY
29000: LIST
29001: LIST
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29024: LD_ADDR_VAR 0 20
29028: PUSH
29029: LD_INT 0
29031: PUSH
29032: LD_INT 0
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: NEG
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: PUSH
29050: LD_INT 1
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: LD_INT 0
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 1
29082: NEG
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: LD_INT 1
29097: NEG
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PUSH
29103: LD_INT 1
29105: NEG
29106: PUSH
29107: LD_INT 2
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 2
29120: NEG
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 1
29128: PUSH
29129: LD_INT 1
29131: NEG
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 2
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 2
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 0
29179: PUSH
29180: LD_INT 2
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 1
29189: NEG
29190: PUSH
29191: LD_INT 1
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 2
29200: NEG
29201: PUSH
29202: LD_INT 0
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 2
29211: NEG
29212: PUSH
29213: LD_INT 1
29215: NEG
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 2
29223: NEG
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29254: LD_ADDR_VAR 0 21
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: NEG
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: LD_INT 0
29302: PUSH
29303: LD_INT 1
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 1
29312: NEG
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: NEG
29324: PUSH
29325: LD_INT 1
29327: NEG
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 1
29335: NEG
29336: PUSH
29337: LD_INT 2
29339: NEG
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 0
29347: PUSH
29348: LD_INT 2
29350: NEG
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: PUSH
29359: LD_INT 1
29361: NEG
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 2
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 2
29379: PUSH
29380: LD_INT 1
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 2
29389: PUSH
29390: LD_INT 2
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: PUSH
29400: LD_INT 2
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 0
29409: PUSH
29410: LD_INT 2
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 1
29419: NEG
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: PUSH
29439: LD_INT 2
29441: NEG
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 2
29453: NEG
29454: PUSH
29455: LD_INT 2
29457: NEG
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29484: LD_ADDR_VAR 0 22
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: LD_INT 0
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: NEG
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 1
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: PUSH
29523: LD_INT 1
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 0
29532: PUSH
29533: LD_INT 1
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 1
29542: NEG
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: PUSH
29551: LD_INT 1
29553: NEG
29554: PUSH
29555: LD_INT 1
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 1
29565: NEG
29566: PUSH
29567: LD_INT 2
29569: NEG
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 0
29577: PUSH
29578: LD_INT 2
29580: NEG
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 1
29591: NEG
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: LD_INT 0
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 2
29609: PUSH
29610: LD_INT 1
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 2
29619: PUSH
29620: LD_INT 2
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: LD_INT 2
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 0
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: NEG
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 2
29660: NEG
29661: PUSH
29662: LD_INT 0
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: NEG
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: LD_INT 2
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
29714: LD_ADDR_VAR 0 23
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: EMPTY
29757: LIST
29758: LIST
29759: PUSH
29760: LD_INT 0
29762: PUSH
29763: LD_INT 1
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 1
29772: NEG
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: EMPTY
29778: LIST
29779: LIST
29780: PUSH
29781: LD_INT 1
29783: NEG
29784: PUSH
29785: LD_INT 1
29787: NEG
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: LD_INT 1
29795: NEG
29796: PUSH
29797: LD_INT 2
29799: NEG
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 0
29807: PUSH
29808: LD_INT 2
29810: NEG
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 1
29821: NEG
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 2
29829: PUSH
29830: LD_INT 0
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 2
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 2
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 1
29859: PUSH
29860: LD_INT 2
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: LD_INT 0
29869: PUSH
29870: LD_INT 2
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 1
29879: NEG
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 2
29890: NEG
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 2
29901: NEG
29902: PUSH
29903: LD_INT 1
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 2
29913: NEG
29914: PUSH
29915: LD_INT 2
29917: NEG
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 2
29925: NEG
29926: PUSH
29927: LD_INT 3
29929: NEG
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 1
29937: NEG
29938: PUSH
29939: LD_INT 3
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 1
29949: PUSH
29950: LD_INT 2
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 2
29960: PUSH
29961: LD_INT 1
29963: NEG
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: LIST
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: LIST
29993: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
29994: LD_ADDR_VAR 0 24
29998: PUSH
29999: LD_INT 0
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: LD_INT 0
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 1
30063: NEG
30064: PUSH
30065: LD_INT 1
30067: NEG
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: LD_INT 2
30079: NEG
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 0
30087: PUSH
30088: LD_INT 2
30090: NEG
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 1
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: LD_INT 0
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 2
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 2
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: PUSH
30140: LD_INT 2
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 0
30149: PUSH
30150: LD_INT 2
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 1
30159: NEG
30160: PUSH
30161: LD_INT 1
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 2
30170: NEG
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 2
30181: NEG
30182: PUSH
30183: LD_INT 1
30185: NEG
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 2
30193: NEG
30194: PUSH
30195: LD_INT 2
30197: NEG
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: LD_INT 1
30205: PUSH
30206: LD_INT 2
30208: NEG
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 2
30216: PUSH
30217: LD_INT 1
30219: NEG
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 3
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 3
30237: PUSH
30238: LD_INT 2
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: LIST
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30270: LD_ADDR_VAR 0 25
30274: PUSH
30275: LD_INT 0
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 1
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 0
30318: PUSH
30319: LD_INT 1
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: NEG
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: NEG
30352: PUSH
30353: LD_INT 2
30355: NEG
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: LD_INT 2
30366: NEG
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: LD_INT 1
30377: NEG
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 2
30385: PUSH
30386: LD_INT 0
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: LD_INT 1
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 2
30405: PUSH
30406: LD_INT 2
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 1
30415: PUSH
30416: LD_INT 2
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 0
30425: PUSH
30426: LD_INT 2
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 1
30435: NEG
30436: PUSH
30437: LD_INT 1
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 2
30446: NEG
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 2
30457: NEG
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: LD_INT 2
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 3
30481: PUSH
30482: LD_INT 1
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 3
30491: PUSH
30492: LD_INT 2
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: LD_INT 3
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 1
30511: PUSH
30512: LD_INT 3
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
30544: LD_ADDR_VAR 0 26
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 0
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 1
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 0
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 1
30602: NEG
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: EMPTY
30620: LIST
30621: LIST
30622: PUSH
30623: LD_INT 1
30625: NEG
30626: PUSH
30627: LD_INT 2
30629: NEG
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: LD_INT 2
30640: NEG
30641: PUSH
30642: EMPTY
30643: LIST
30644: LIST
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: LD_INT 1
30651: NEG
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 2
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 2
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 2
30679: PUSH
30680: LD_INT 2
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 1
30689: PUSH
30690: LD_INT 2
30692: PUSH
30693: EMPTY
30694: LIST
30695: LIST
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 2
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 1
30709: NEG
30710: PUSH
30711: LD_INT 1
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 2
30720: NEG
30721: PUSH
30722: LD_INT 0
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 2
30731: NEG
30732: PUSH
30733: LD_INT 1
30735: NEG
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 2
30743: NEG
30744: PUSH
30745: LD_INT 2
30747: NEG
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 2
30755: PUSH
30756: LD_INT 3
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: LD_INT 3
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: LD_INT 2
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 2
30786: NEG
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30820: LD_ADDR_VAR 0 27
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: LD_INT 0
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 1
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 1
30858: PUSH
30859: LD_INT 1
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: LD_INT 1
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: LD_INT 0
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: NEG
30890: PUSH
30891: LD_INT 1
30893: NEG
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 1
30901: NEG
30902: PUSH
30903: LD_INT 2
30905: NEG
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 0
30913: PUSH
30914: LD_INT 2
30916: NEG
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 1
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 2
30935: PUSH
30936: LD_INT 0
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: LD_INT 1
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 2
30955: PUSH
30956: LD_INT 2
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: LD_INT 2
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 2
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 1
30985: NEG
30986: PUSH
30987: LD_INT 1
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 2
30996: NEG
30997: PUSH
30998: LD_INT 0
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 2
31007: NEG
31008: PUSH
31009: LD_INT 1
31011: NEG
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 2
31019: NEG
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 1
31031: NEG
31032: PUSH
31033: LD_INT 2
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 2
31042: NEG
31043: PUSH
31044: LD_INT 1
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 3
31053: NEG
31054: PUSH
31055: LD_INT 1
31057: NEG
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 3
31065: NEG
31066: PUSH
31067: LD_INT 2
31069: NEG
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31100: LD_ADDR_VAR 0 28
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: LD_INT 0
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 1
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: LD_INT 1
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 0
31148: PUSH
31149: LD_INT 1
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 1
31158: NEG
31159: PUSH
31160: LD_INT 0
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: PUSH
31179: LD_INT 1
31181: NEG
31182: PUSH
31183: LD_INT 2
31185: NEG
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PUSH
31191: LD_INT 0
31193: PUSH
31194: LD_INT 2
31196: NEG
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 2
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 2
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 2
31235: PUSH
31236: LD_INT 2
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: LD_INT 2
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 0
31255: PUSH
31256: LD_INT 2
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 2
31276: NEG
31277: PUSH
31278: LD_INT 0
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: LD_INT 2
31287: NEG
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: LD_INT 2
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 2
31311: NEG
31312: PUSH
31313: LD_INT 3
31315: NEG
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: NEG
31324: PUSH
31325: LD_INT 3
31327: NEG
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 3
31335: NEG
31336: PUSH
31337: LD_INT 1
31339: NEG
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 3
31347: NEG
31348: PUSH
31349: LD_INT 2
31351: NEG
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31382: LD_ADDR_VAR 0 29
31386: PUSH
31387: LD_INT 0
31389: PUSH
31390: LD_INT 0
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 1
31410: PUSH
31411: LD_INT 0
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 1
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 1
31440: NEG
31441: PUSH
31442: LD_INT 0
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 1
31451: NEG
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 1
31463: NEG
31464: PUSH
31465: LD_INT 2
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 0
31475: PUSH
31476: LD_INT 2
31478: NEG
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 1
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 2
31497: PUSH
31498: LD_INT 0
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 2
31507: PUSH
31508: LD_INT 1
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: LD_INT 2
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: LD_INT 1
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 2
31548: NEG
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 2
31560: NEG
31561: PUSH
31562: LD_INT 2
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 2
31572: NEG
31573: PUSH
31574: LD_INT 3
31576: NEG
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 2
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 3
31595: PUSH
31596: LD_INT 1
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 1
31605: PUSH
31606: LD_INT 3
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: NEG
31616: PUSH
31617: LD_INT 2
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 3
31626: NEG
31627: PUSH
31628: LD_INT 2
31630: NEG
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: EMPTY
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31661: LD_ADDR_VAR 0 30
31665: PUSH
31666: LD_INT 0
31668: PUSH
31669: LD_INT 0
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: LD_INT 1
31681: NEG
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 1
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 1
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: LD_INT 1
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 1
31719: NEG
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: LD_INT 1
31730: NEG
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: LD_INT 2
31757: NEG
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 1
31765: PUSH
31766: LD_INT 1
31768: NEG
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 2
31776: PUSH
31777: LD_INT 0
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: PUSH
31784: LD_INT 2
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 2
31796: PUSH
31797: LD_INT 2
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 1
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 1
31816: NEG
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 2
31827: NEG
31828: PUSH
31829: LD_INT 0
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 2
31838: NEG
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: LD_INT 3
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 1
31862: PUSH
31863: LD_INT 2
31865: NEG
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 3
31873: PUSH
31874: LD_INT 2
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 2
31883: PUSH
31884: LD_INT 3
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 2
31893: NEG
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 3
31904: NEG
31905: PUSH
31906: LD_INT 1
31908: NEG
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31939: LD_ADDR_VAR 0 31
31943: PUSH
31944: LD_INT 0
31946: PUSH
31947: LD_INT 0
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: LD_INT 1
31959: NEG
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: PUSH
31968: LD_INT 0
31970: PUSH
31971: EMPTY
31972: LIST
31973: LIST
31974: PUSH
31975: LD_INT 1
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 0
31987: PUSH
31988: LD_INT 1
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 1
31997: NEG
31998: PUSH
31999: LD_INT 0
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 1
32008: NEG
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PUSH
32018: LD_INT 1
32020: NEG
32021: PUSH
32022: LD_INT 2
32024: NEG
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: PUSH
32033: LD_INT 1
32035: NEG
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 2
32043: PUSH
32044: LD_INT 0
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 2
32053: PUSH
32054: LD_INT 1
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: PUSH
32064: LD_INT 2
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 1
32073: PUSH
32074: LD_INT 2
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: LD_INT 2
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: NEG
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 2
32104: NEG
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 2
32116: NEG
32117: PUSH
32118: LD_INT 2
32120: NEG
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 2
32128: NEG
32129: PUSH
32130: LD_INT 3
32132: NEG
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 3
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 3
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: LD_INT 2
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 3
32182: NEG
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32217: LD_ADDR_VAR 0 32
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 0
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 0
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 2
32332: PUSH
32333: LD_INT 1
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 1
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 1
32372: NEG
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 2
32383: NEG
32384: PUSH
32385: LD_INT 0
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 2
32394: NEG
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 1
32406: NEG
32407: PUSH
32408: LD_INT 3
32410: NEG
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 1
32418: PUSH
32419: LD_INT 2
32421: NEG
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 3
32429: PUSH
32430: LD_INT 2
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: PUSH
32440: LD_INT 3
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 2
32449: NEG
32450: PUSH
32451: LD_INT 1
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 3
32460: NEG
32461: PUSH
32462: LD_INT 1
32464: NEG
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32495: LD_ADDR_VAR 0 33
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: LD_INT 1
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: PUSH
32524: LD_INT 0
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: PUSH
32534: LD_INT 1
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 0
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: NEG
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 1
32564: NEG
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 1
32576: NEG
32577: PUSH
32578: LD_INT 2
32580: NEG
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: LD_INT 2
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 2
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: NEG
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 2
32673: NEG
32674: PUSH
32675: LD_INT 2
32677: NEG
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: LD_INT 3
32689: NEG
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 2
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 3
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 1
32718: PUSH
32719: LD_INT 3
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: NEG
32729: PUSH
32730: LD_INT 2
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 3
32739: NEG
32740: PUSH
32741: LD_INT 2
32743: NEG
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32774: LD_ADDR_VAR 0 34
32778: PUSH
32779: LD_INT 0
32781: PUSH
32782: LD_INT 0
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: LD_INT 1
32794: NEG
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 1
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 1
32812: PUSH
32813: LD_INT 1
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 1
32832: NEG
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 2
32859: NEG
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 0
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: LD_INT 1
32881: NEG
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 2
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 2
32899: PUSH
32900: LD_INT 2
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 1
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 1
32919: NEG
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 2
32930: NEG
32931: PUSH
32932: LD_INT 0
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 2
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 2
32953: NEG
32954: PUSH
32955: LD_INT 2
32957: NEG
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 1
32965: NEG
32966: PUSH
32967: LD_INT 3
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: LD_INT 2
32980: NEG
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 3
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 2
32998: PUSH
32999: LD_INT 3
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 2
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 3
33019: NEG
33020: PUSH
33021: LD_INT 1
33023: NEG
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33054: LD_ADDR_VAR 0 35
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 0
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: NEG
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 1
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: LD_INT 1
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: PUSH
33136: LD_INT 1
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 2
33145: NEG
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: EMPTY
33152: LIST
33153: LIST
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33166: LD_ADDR_VAR 0 36
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: LD_INT 0
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 1
33186: NEG
33187: PUSH
33188: EMPTY
33189: LIST
33190: LIST
33191: PUSH
33192: LD_INT 1
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: PUSH
33205: LD_INT 1
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 1
33224: NEG
33225: PUSH
33226: LD_INT 0
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: NEG
33248: PUSH
33249: LD_INT 2
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: PUSH
33260: LD_INT 2
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33278: LD_ADDR_VAR 0 37
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 0
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 1
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 1
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 0
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: NEG
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 1
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 1
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33390: LD_ADDR_VAR 0 38
33394: PUSH
33395: LD_INT 0
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 0
33407: PUSH
33408: LD_INT 1
33410: NEG
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: PUSH
33419: LD_INT 0
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 1
33428: PUSH
33429: LD_INT 1
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 0
33438: PUSH
33439: LD_INT 1
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 1
33459: NEG
33460: PUSH
33461: LD_INT 1
33463: NEG
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 2
33471: PUSH
33472: LD_INT 1
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 2
33481: NEG
33482: PUSH
33483: LD_INT 1
33485: NEG
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33502: LD_ADDR_VAR 0 39
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 1
33522: NEG
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 1
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: LD_INT 1
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: PUSH
33596: LD_INT 2
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33614: LD_ADDR_VAR 0 40
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: LD_INT 0
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 1
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: LD_INT 1
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: NEG
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33726: LD_ADDR_VAR 0 41
33730: PUSH
33731: LD_INT 0
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: LD_INT 1
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 0
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 1
33784: NEG
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: LD_INT 1
33799: NEG
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 2
33811: NEG
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 1
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: PUSH
33841: LD_INT 1
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 2
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: LD_INT 2
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 1
33870: NEG
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: LD_INT 2
33881: NEG
33882: PUSH
33883: LD_INT 0
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 2
33892: NEG
33893: PUSH
33894: LD_INT 1
33896: NEG
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 2
33904: NEG
33905: PUSH
33906: LD_INT 2
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 2
33916: NEG
33917: PUSH
33918: LD_INT 3
33920: NEG
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 3
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 3
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 3
33959: PUSH
33960: LD_INT 2
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 3
33969: PUSH
33970: LD_INT 3
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: LD_INT 3
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 2
33989: NEG
33990: PUSH
33991: LD_INT 1
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 3
34000: NEG
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 3
34011: NEG
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 3
34023: NEG
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 3
34035: NEG
34036: PUSH
34037: LD_INT 3
34039: NEG
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34076: LD_ADDR_VAR 0 42
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 1
34096: NEG
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 1
34114: PUSH
34115: LD_INT 1
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 1
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 1
34134: NEG
34135: PUSH
34136: LD_INT 0
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: NEG
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 1
34157: NEG
34158: PUSH
34159: LD_INT 2
34161: NEG
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: PUSH
34167: LD_INT 0
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 1
34180: PUSH
34181: LD_INT 1
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 2
34191: PUSH
34192: LD_INT 1
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 2
34201: PUSH
34202: LD_INT 2
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: LD_INT 2
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 0
34221: PUSH
34222: LD_INT 2
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 1
34231: NEG
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 2
34242: NEG
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 2
34266: NEG
34267: PUSH
34268: LD_INT 3
34270: NEG
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 1
34278: NEG
34279: PUSH
34280: LD_INT 3
34282: NEG
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 3
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 2
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 3
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 3
34322: PUSH
34323: LD_INT 3
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 2
34332: PUSH
34333: LD_INT 3
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: PUSH
34343: LD_INT 3
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: LD_INT 3
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: NEG
34363: PUSH
34364: LD_INT 2
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 3
34373: NEG
34374: PUSH
34375: LD_INT 2
34377: NEG
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 3
34385: NEG
34386: PUSH
34387: LD_INT 3
34389: NEG
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: LIST
34425: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34426: LD_ADDR_VAR 0 43
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: NEG
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 0
34474: PUSH
34475: LD_INT 1
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: NEG
34485: PUSH
34486: LD_INT 0
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: NEG
34508: PUSH
34509: LD_INT 2
34511: NEG
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: LD_INT 2
34522: NEG
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 2
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 1
34561: PUSH
34562: LD_INT 2
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 0
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 1
34581: NEG
34582: PUSH
34583: LD_INT 1
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 1
34615: NEG
34616: PUSH
34617: LD_INT 3
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 0
34627: PUSH
34628: LD_INT 3
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: PUSH
34639: LD_INT 2
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 2
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 3
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: PUSH
34671: LD_INT 1
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: LD_INT 3
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 3
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: LD_INT 2
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 2
34711: NEG
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 3
34722: NEG
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 3
34733: NEG
34734: PUSH
34735: LD_INT 1
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34774: LD_ADDR_VAR 0 44
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: LD_INT 0
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 1
34794: NEG
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 1
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 1
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: NEG
34844: PUSH
34845: LD_INT 1
34847: NEG
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: LD_INT 1
34855: NEG
34856: PUSH
34857: LD_INT 2
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: LD_INT 1
34870: NEG
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 2
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 2
34888: PUSH
34889: LD_INT 1
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: LD_INT 2
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: PUSH
34909: LD_INT 2
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 1
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 2
34929: NEG
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: LD_INT 1
34944: NEG
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: NEG
34953: PUSH
34954: LD_INT 2
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 2
34964: NEG
34965: PUSH
34966: LD_INT 3
34968: NEG
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: PUSH
34974: LD_INT 2
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 3
34987: PUSH
34988: LD_INT 0
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 3
34997: PUSH
34998: LD_INT 1
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 3
35007: PUSH
35008: LD_INT 2
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 3
35017: PUSH
35018: LD_INT 3
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 2
35027: PUSH
35028: LD_INT 3
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 2
35037: NEG
35038: PUSH
35039: LD_INT 1
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: LD_INT 0
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 3
35059: NEG
35060: PUSH
35061: LD_INT 1
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 3
35071: NEG
35072: PUSH
35073: LD_INT 2
35075: NEG
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 3
35083: NEG
35084: PUSH
35085: LD_INT 3
35087: NEG
35088: PUSH
35089: EMPTY
35090: LIST
35091: LIST
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35124: LD_ADDR_VAR 0 45
35128: PUSH
35129: LD_INT 0
35131: PUSH
35132: LD_INT 0
35134: PUSH
35135: EMPTY
35136: LIST
35137: LIST
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: LD_INT 1
35144: NEG
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 1
35152: PUSH
35153: LD_INT 0
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: PUSH
35163: LD_INT 1
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: LD_INT 1
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 1
35182: NEG
35183: PUSH
35184: LD_INT 0
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: NEG
35194: PUSH
35195: LD_INT 1
35197: NEG
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 1
35205: NEG
35206: PUSH
35207: LD_INT 2
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 2
35239: PUSH
35240: LD_INT 1
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 2
35249: PUSH
35250: LD_INT 2
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: LD_INT 2
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: LD_INT 2
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 1
35279: NEG
35280: PUSH
35281: LD_INT 1
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 2
35290: NEG
35291: PUSH
35292: LD_INT 1
35294: NEG
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 2
35302: NEG
35303: PUSH
35304: LD_INT 2
35306: NEG
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 2
35314: NEG
35315: PUSH
35316: LD_INT 3
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 1
35326: NEG
35327: PUSH
35328: LD_INT 3
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 0
35338: PUSH
35339: LD_INT 3
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: LD_INT 2
35352: NEG
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 3
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 3
35370: PUSH
35371: LD_INT 3
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 2
35380: PUSH
35381: LD_INT 3
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: LD_INT 3
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 0
35400: PUSH
35401: LD_INT 3
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: LD_INT 2
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 3
35421: NEG
35422: PUSH
35423: LD_INT 2
35425: NEG
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 3
35433: NEG
35434: PUSH
35435: LD_INT 3
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35474: LD_ADDR_VAR 0 46
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: LD_INT 0
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 0
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: PUSH
35503: LD_INT 0
35505: PUSH
35506: EMPTY
35507: LIST
35508: LIST
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 1
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 1
35555: NEG
35556: PUSH
35557: LD_INT 2
35559: NEG
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 0
35567: PUSH
35568: LD_INT 2
35570: NEG
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: PUSH
35576: LD_INT 1
35578: PUSH
35579: LD_INT 1
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 2
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: PUSH
35600: LD_INT 1
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: LD_INT 2
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 0
35619: PUSH
35620: LD_INT 2
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 1
35629: NEG
35630: PUSH
35631: LD_INT 1
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 2
35651: NEG
35652: PUSH
35653: LD_INT 1
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: LD_INT 3
35667: NEG
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 0
35675: PUSH
35676: LD_INT 3
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: LD_INT 2
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 2
35697: PUSH
35698: LD_INT 1
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 3
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: PUSH
35719: LD_INT 1
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: LD_INT 3
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 0
35738: PUSH
35739: LD_INT 3
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: LD_INT 2
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 2
35759: NEG
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 3
35770: NEG
35771: PUSH
35772: LD_INT 0
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 3
35781: NEG
35782: PUSH
35783: LD_INT 1
35785: NEG
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35822: LD_ADDR_VAR 0 47
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: LD_INT 0
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: LD_INT 1
35842: NEG
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: PUSH
35851: LD_INT 0
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 1
35860: PUSH
35861: LD_INT 1
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 0
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: LD_INT 1
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 1
35903: NEG
35904: PUSH
35905: LD_INT 2
35907: NEG
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 0
35915: PUSH
35916: LD_INT 2
35918: NEG
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: LD_INT 1
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 2
35937: NEG
35938: PUSH
35939: LD_INT 1
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 2
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
35973: LD_ADDR_VAR 0 48
35977: PUSH
35978: LD_INT 0
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 0
35990: PUSH
35991: LD_INT 1
35993: NEG
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 1
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 0
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: NEG
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: NEG
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: LD_INT 2
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 0
36066: PUSH
36067: LD_INT 2
36069: NEG
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: LD_INT 0
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 2
36098: PUSH
36099: LD_INT 1
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36120: LD_ADDR_VAR 0 49
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 1
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 2
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 2
36222: PUSH
36223: LD_INT 1
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 2
36232: PUSH
36233: LD_INT 2
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36264: LD_ADDR_VAR 0 50
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 0
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 0
36281: PUSH
36282: LD_INT 1
36284: NEG
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: LD_INT 1
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 0
36312: PUSH
36313: LD_INT 1
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 0
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: LD_INT 1
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 2
36345: PUSH
36346: LD_INT 1
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 2
36355: PUSH
36356: LD_INT 2
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 1
36365: PUSH
36366: LD_INT 2
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: LD_INT 2
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 1
36385: NEG
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36408: LD_ADDR_VAR 0 51
36412: PUSH
36413: LD_INT 0
36415: PUSH
36416: LD_INT 0
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: LD_INT 1
36428: NEG
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 1
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: LD_INT 1
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 1
36466: NEG
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: NEG
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: LD_INT 2
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 0
36499: PUSH
36500: LD_INT 2
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: NEG
36510: PUSH
36511: LD_INT 1
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 2
36520: NEG
36521: PUSH
36522: LD_INT 0
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: LD_INT 1
36535: NEG
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36555: LD_ADDR_VAR 0 52
36559: PUSH
36560: LD_INT 0
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 0
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 1
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: LD_INT 0
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: LD_INT 0
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: LD_INT 1
36628: NEG
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: NEG
36637: PUSH
36638: LD_INT 2
36640: NEG
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: LD_INT 1
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: LD_INT 2
36659: NEG
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 2
36670: NEG
36671: PUSH
36672: LD_INT 1
36674: NEG
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: LD_INT 2
36682: NEG
36683: PUSH
36684: LD_INT 2
36686: NEG
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36706: LD_ADDR_VAR 0 53
36710: PUSH
36711: LD_INT 0
36713: PUSH
36714: LD_INT 0
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 0
36754: PUSH
36755: LD_INT 1
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: LD_INT 0
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: NEG
36788: PUSH
36789: LD_INT 2
36791: NEG
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 0
36799: PUSH
36800: LD_INT 2
36802: NEG
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: LD_INT 1
36813: NEG
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 2
36821: PUSH
36822: LD_INT 0
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: LD_INT 1
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 1
36851: PUSH
36852: LD_INT 2
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: LD_INT 2
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 1
36871: NEG
36872: PUSH
36873: LD_INT 1
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: LD_INT 1
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 2
36905: NEG
36906: PUSH
36907: LD_INT 2
36909: NEG
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: LIST
36923: LIST
36924: LIST
36925: LIST
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36936: LD_ADDR_VAR 0 54
36940: PUSH
36941: LD_INT 0
36943: PUSH
36944: LD_INT 0
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 0
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: LD_INT 1
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 1
36994: NEG
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: LD_INT 1
37009: NEG
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: NEG
37018: PUSH
37019: LD_INT 2
37021: NEG
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: LD_INT 2
37032: NEG
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: LD_INT 1
37043: NEG
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 0
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 2
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: PUSH
37072: LD_INT 2
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: PUSH
37082: LD_INT 2
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 0
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 1
37101: NEG
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: NEG
37113: PUSH
37114: LD_INT 0
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 2
37123: NEG
37124: PUSH
37125: LD_INT 1
37127: NEG
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 2
37135: NEG
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: LIST
37159: LIST
37160: LIST
37161: LIST
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37166: LD_ADDR_VAR 0 55
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 1
37186: NEG
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: LD_INT 1
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 0
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 1
37224: NEG
37225: PUSH
37226: LD_INT 0
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 1
37235: NEG
37236: PUSH
37237: LD_INT 1
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: LD_INT 2
37251: NEG
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 0
37259: PUSH
37260: LD_INT 2
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 1
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 0
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 2
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 2
37301: PUSH
37302: LD_INT 2
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 1
37331: NEG
37332: PUSH
37333: LD_INT 1
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 2
37342: NEG
37343: PUSH
37344: LD_INT 0
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: NEG
37354: PUSH
37355: LD_INT 1
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: LD_INT 2
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37396: LD_ADDR_VAR 0 56
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: LD_INT 0
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: NEG
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 1
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: LD_INT 1
37437: PUSH
37438: EMPTY
37439: LIST
37440: LIST
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: LD_INT 1
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 1
37454: NEG
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: NEG
37466: PUSH
37467: LD_INT 1
37469: NEG
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: LD_INT 2
37481: NEG
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 0
37489: PUSH
37490: LD_INT 2
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 2
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 2
37521: PUSH
37522: LD_INT 1
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 2
37531: PUSH
37532: LD_INT 2
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: PUSH
37542: LD_INT 2
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 0
37551: PUSH
37552: LD_INT 2
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 1
37561: NEG
37562: PUSH
37563: LD_INT 1
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 2
37572: NEG
37573: PUSH
37574: LD_INT 0
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 2
37583: NEG
37584: PUSH
37585: LD_INT 1
37587: NEG
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: LD_INT 2
37595: NEG
37596: PUSH
37597: LD_INT 2
37599: NEG
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: LIST
37619: LIST
37620: LIST
37621: LIST
37622: LIST
37623: LIST
37624: LIST
37625: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37626: LD_ADDR_VAR 0 57
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 0
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: NEG
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: PUSH
37665: LD_INT 1
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: NEG
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: NEG
37696: PUSH
37697: LD_INT 1
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 1
37707: NEG
37708: PUSH
37709: LD_INT 2
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: LD_INT 2
37722: NEG
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 1
37730: PUSH
37731: LD_INT 1
37733: NEG
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 2
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 2
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: LD_INT 2
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: LD_INT 2
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: LD_INT 2
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 2
37802: NEG
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 2
37813: NEG
37814: PUSH
37815: LD_INT 1
37817: NEG
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 2
37825: NEG
37826: PUSH
37827: LD_INT 2
37829: NEG
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: LIST
37855: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37856: LD_ADDR_VAR 0 58
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 1
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: PUSH
37895: LD_INT 1
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: LD_INT 1
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 1
37914: NEG
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 1
37925: NEG
37926: PUSH
37927: LD_INT 1
37929: NEG
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 1
37937: NEG
37938: PUSH
37939: LD_INT 2
37941: NEG
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: LD_INT 0
37949: PUSH
37950: LD_INT 2
37952: NEG
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: LD_INT 1
37963: NEG
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 2
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 2
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: PUSH
37992: LD_INT 2
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 2
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 0
38011: PUSH
38012: LD_INT 2
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 1
38021: NEG
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 2
38032: NEG
38033: PUSH
38034: LD_INT 0
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 2
38043: NEG
38044: PUSH
38045: LD_INT 1
38047: NEG
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 2
38055: NEG
38056: PUSH
38057: LD_INT 2
38059: NEG
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: EMPTY
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38086: LD_ADDR_VAR 0 59
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 0
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: NEG
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 1
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 1
38144: NEG
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: LIST
38173: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38174: LD_ADDR_VAR 0 60
38178: PUSH
38179: LD_INT 0
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: EMPTY
38186: LIST
38187: LIST
38188: PUSH
38189: LD_INT 0
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 0
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: NEG
38233: PUSH
38234: LD_INT 0
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 1
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38262: LD_ADDR_VAR 0 61
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 0
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: LD_INT 1
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 0
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 0
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 1
38320: NEG
38321: PUSH
38322: LD_INT 0
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 1
38331: NEG
38332: PUSH
38333: LD_INT 1
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38350: LD_ADDR_VAR 0 62
38354: PUSH
38355: LD_INT 0
38357: PUSH
38358: LD_INT 0
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 0
38367: PUSH
38368: LD_INT 1
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 1
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: PUSH
38389: LD_INT 1
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: LD_INT 0
38398: PUSH
38399: LD_INT 1
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: NEG
38420: PUSH
38421: LD_INT 1
38423: NEG
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38438: LD_ADDR_VAR 0 63
38442: PUSH
38443: LD_INT 0
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 1
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 1
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 1
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: LD_INT 1
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: LD_INT 0
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 1
38507: NEG
38508: PUSH
38509: LD_INT 1
38511: NEG
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38526: LD_ADDR_VAR 0 64
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 0
38543: PUSH
38544: LD_INT 1
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 1
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: NEG
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: ST_TO_ADDR
// end ; 1 :
38614: GO 44511
38616: LD_INT 1
38618: DOUBLE
38619: EQUAL
38620: IFTRUE 38624
38622: GO 41247
38624: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38625: LD_ADDR_VAR 0 11
38629: PUSH
38630: LD_INT 1
38632: NEG
38633: PUSH
38634: LD_INT 3
38636: NEG
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: LD_INT 3
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 1
38655: PUSH
38656: LD_INT 2
38658: NEG
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: LIST
38668: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38669: LD_ADDR_VAR 0 12
38673: PUSH
38674: LD_INT 2
38676: PUSH
38677: LD_INT 1
38679: NEG
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 3
38687: PUSH
38688: LD_INT 0
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 3
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: LIST
38709: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38710: LD_ADDR_VAR 0 13
38714: PUSH
38715: LD_INT 3
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 3
38727: PUSH
38728: LD_INT 3
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 2
38737: PUSH
38738: LD_INT 3
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: LIST
38749: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38750: LD_ADDR_VAR 0 14
38754: PUSH
38755: LD_INT 1
38757: PUSH
38758: LD_INT 3
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 0
38767: PUSH
38768: LD_INT 3
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 1
38777: NEG
38778: PUSH
38779: LD_INT 2
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: LIST
38790: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38791: LD_ADDR_VAR 0 15
38795: PUSH
38796: LD_INT 2
38798: NEG
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 3
38809: NEG
38810: PUSH
38811: LD_INT 0
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 3
38820: NEG
38821: PUSH
38822: LD_INT 1
38824: NEG
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: LIST
38834: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38835: LD_ADDR_VAR 0 16
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: LD_INT 3
38846: NEG
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 3
38854: NEG
38855: PUSH
38856: LD_INT 2
38858: NEG
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 3
38866: NEG
38867: PUSH
38868: LD_INT 3
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: LIST
38880: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38881: LD_ADDR_VAR 0 17
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: LD_INT 3
38892: NEG
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: LD_INT 3
38903: NEG
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 1
38911: PUSH
38912: LD_INT 2
38914: NEG
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: LIST
38924: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38925: LD_ADDR_VAR 0 18
38929: PUSH
38930: LD_INT 2
38932: PUSH
38933: LD_INT 1
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 3
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 3
38953: PUSH
38954: LD_INT 1
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: LIST
38965: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38966: LD_ADDR_VAR 0 19
38970: PUSH
38971: LD_INT 3
38973: PUSH
38974: LD_INT 2
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 3
38983: PUSH
38984: LD_INT 3
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: LD_INT 3
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: LIST
39005: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39006: LD_ADDR_VAR 0 20
39010: PUSH
39011: LD_INT 1
39013: PUSH
39014: LD_INT 3
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 0
39023: PUSH
39024: LD_INT 3
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 1
39033: NEG
39034: PUSH
39035: LD_INT 2
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: LIST
39046: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39047: LD_ADDR_VAR 0 21
39051: PUSH
39052: LD_INT 2
39054: NEG
39055: PUSH
39056: LD_INT 1
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 3
39065: NEG
39066: PUSH
39067: LD_INT 0
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 3
39076: NEG
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: LIST
39090: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39091: LD_ADDR_VAR 0 22
39095: PUSH
39096: LD_INT 2
39098: NEG
39099: PUSH
39100: LD_INT 3
39102: NEG
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 3
39110: NEG
39111: PUSH
39112: LD_INT 2
39114: NEG
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 3
39122: NEG
39123: PUSH
39124: LD_INT 3
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39137: LD_ADDR_VAR 0 23
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 3
39147: NEG
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 4
39159: NEG
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: LD_INT 3
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39181: LD_ADDR_VAR 0 24
39185: PUSH
39186: LD_INT 3
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 3
39198: PUSH
39199: LD_INT 1
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 4
39209: PUSH
39210: LD_INT 1
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: LIST
39221: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39222: LD_ADDR_VAR 0 25
39226: PUSH
39227: LD_INT 3
39229: PUSH
39230: LD_INT 3
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 4
39239: PUSH
39240: LD_INT 3
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 3
39249: PUSH
39250: LD_INT 4
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: LIST
39261: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39262: LD_ADDR_VAR 0 26
39266: PUSH
39267: LD_INT 0
39269: PUSH
39270: LD_INT 3
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: PUSH
39280: LD_INT 4
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 1
39289: NEG
39290: PUSH
39291: LD_INT 3
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: LIST
39302: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39303: LD_ADDR_VAR 0 27
39307: PUSH
39308: LD_INT 3
39310: NEG
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 3
39321: NEG
39322: PUSH
39323: LD_INT 1
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 4
39332: NEG
39333: PUSH
39334: LD_INT 1
39336: NEG
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: LIST
39346: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
39347: LD_ADDR_VAR 0 28
39351: PUSH
39352: LD_INT 3
39354: NEG
39355: PUSH
39356: LD_INT 3
39358: NEG
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 3
39366: NEG
39367: PUSH
39368: LD_INT 4
39370: NEG
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 4
39378: NEG
39379: PUSH
39380: LD_INT 3
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: LIST
39392: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
39393: LD_ADDR_VAR 0 29
39397: PUSH
39398: LD_INT 1
39400: NEG
39401: PUSH
39402: LD_INT 3
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 0
39412: PUSH
39413: LD_INT 3
39415: NEG
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: PUSH
39424: LD_INT 2
39426: NEG
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: LD_INT 4
39438: NEG
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: LD_INT 4
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: PUSH
39458: LD_INT 3
39460: NEG
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: LD_INT 5
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 0
39480: PUSH
39481: LD_INT 5
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 1
39491: PUSH
39492: LD_INT 4
39494: NEG
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: NEG
39503: PUSH
39504: LD_INT 6
39506: NEG
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: LD_INT 6
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: LD_INT 5
39528: NEG
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
39548: LD_ADDR_VAR 0 30
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 3
39566: PUSH
39567: LD_INT 0
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 3
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 4
39597: PUSH
39598: LD_INT 0
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 4
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 4
39617: PUSH
39618: LD_INT 1
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 5
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 5
39638: PUSH
39639: LD_INT 1
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 5
39648: PUSH
39649: LD_INT 1
39651: NEG
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 6
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 6
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
39691: LD_ADDR_VAR 0 31
39695: PUSH
39696: LD_INT 3
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: LD_INT 3
39708: PUSH
39709: LD_INT 3
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 2
39718: PUSH
39719: LD_INT 3
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 4
39728: PUSH
39729: LD_INT 3
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 4
39738: PUSH
39739: LD_INT 4
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 3
39748: PUSH
39749: LD_INT 4
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 5
39758: PUSH
39759: LD_INT 4
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 5
39768: PUSH
39769: LD_INT 5
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 4
39778: PUSH
39779: LD_INT 5
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 6
39788: PUSH
39789: LD_INT 5
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 6
39798: PUSH
39799: LD_INT 6
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 5
39808: PUSH
39809: LD_INT 6
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
39830: LD_ADDR_VAR 0 32
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: LD_INT 3
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: LD_INT 3
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: NEG
39858: PUSH
39859: LD_INT 2
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: LD_INT 4
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 4
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 3
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 5
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 5
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 1
39930: PUSH
39931: LD_INT 6
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: LD_INT 6
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 1
39950: NEG
39951: PUSH
39952: LD_INT 5
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
39973: LD_ADDR_VAR 0 33
39977: PUSH
39978: LD_INT 2
39980: NEG
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 3
39991: NEG
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 3
40002: NEG
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 3
40014: NEG
40015: PUSH
40016: LD_INT 1
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 4
40025: NEG
40026: PUSH
40027: LD_INT 0
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 4
40036: NEG
40037: PUSH
40038: LD_INT 1
40040: NEG
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 4
40048: NEG
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 5
40059: NEG
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 5
40070: NEG
40071: PUSH
40072: LD_INT 1
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 5
40082: NEG
40083: PUSH
40084: LD_INT 1
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 6
40093: NEG
40094: PUSH
40095: LD_INT 0
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 6
40104: NEG
40105: PUSH
40106: LD_INT 1
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: LIST
40118: LIST
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40128: LD_ADDR_VAR 0 34
40132: PUSH
40133: LD_INT 2
40135: NEG
40136: PUSH
40137: LD_INT 3
40139: NEG
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 3
40159: NEG
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 3
40171: NEG
40172: PUSH
40173: LD_INT 4
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 4
40183: NEG
40184: PUSH
40185: LD_INT 3
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 4
40195: NEG
40196: PUSH
40197: LD_INT 4
40199: NEG
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: LD_INT 5
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 5
40219: NEG
40220: PUSH
40221: LD_INT 4
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 5
40231: NEG
40232: PUSH
40233: LD_INT 5
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 5
40243: NEG
40244: PUSH
40245: LD_INT 6
40247: NEG
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 6
40255: NEG
40256: PUSH
40257: LD_INT 5
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 6
40267: NEG
40268: PUSH
40269: LD_INT 6
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40291: LD_ADDR_VAR 0 41
40295: PUSH
40296: LD_INT 0
40298: PUSH
40299: LD_INT 2
40301: NEG
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 1
40309: NEG
40310: PUSH
40311: LD_INT 3
40313: NEG
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: LD_INT 2
40324: NEG
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: LIST
40334: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40335: LD_ADDR_VAR 0 42
40339: PUSH
40340: LD_INT 2
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 2
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 3
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: LIST
40375: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
40376: LD_ADDR_VAR 0 43
40380: PUSH
40381: LD_INT 2
40383: PUSH
40384: LD_INT 2
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 3
40393: PUSH
40394: LD_INT 2
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: PUSH
40404: LD_INT 3
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: LIST
40415: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
40416: LD_ADDR_VAR 0 44
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: LD_INT 2
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 1
40433: PUSH
40434: LD_INT 3
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 1
40443: NEG
40444: PUSH
40445: LD_INT 2
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: LIST
40456: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
40457: LD_ADDR_VAR 0 45
40461: PUSH
40462: LD_INT 2
40464: NEG
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 2
40475: NEG
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 3
40486: NEG
40487: PUSH
40488: LD_INT 1
40490: NEG
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: LIST
40500: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
40501: LD_ADDR_VAR 0 46
40505: PUSH
40506: LD_INT 2
40508: NEG
40509: PUSH
40510: LD_INT 2
40512: NEG
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 2
40520: NEG
40521: PUSH
40522: LD_INT 3
40524: NEG
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 3
40532: NEG
40533: PUSH
40534: LD_INT 2
40536: NEG
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: LIST
40546: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
40547: LD_ADDR_VAR 0 47
40551: PUSH
40552: LD_INT 2
40554: NEG
40555: PUSH
40556: LD_INT 3
40558: NEG
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: LD_INT 1
40566: NEG
40567: PUSH
40568: LD_INT 3
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
40580: LD_ADDR_VAR 0 48
40584: PUSH
40585: LD_INT 1
40587: PUSH
40588: LD_INT 2
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 2
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
40611: LD_ADDR_VAR 0 49
40615: PUSH
40616: LD_INT 3
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 3
40628: PUSH
40629: LD_INT 2
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
40640: LD_ADDR_VAR 0 50
40644: PUSH
40645: LD_INT 2
40647: PUSH
40648: LD_INT 3
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 1
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
40669: LD_ADDR_VAR 0 51
40673: PUSH
40674: LD_INT 1
40676: NEG
40677: PUSH
40678: LD_INT 2
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 2
40687: NEG
40688: PUSH
40689: LD_INT 1
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
40700: LD_ADDR_VAR 0 52
40704: PUSH
40705: LD_INT 3
40707: NEG
40708: PUSH
40709: LD_INT 1
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 2
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40733: LD_ADDR_VAR 0 53
40737: PUSH
40738: LD_INT 1
40740: NEG
40741: PUSH
40742: LD_INT 3
40744: NEG
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 0
40752: PUSH
40753: LD_INT 3
40755: NEG
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 1
40763: PUSH
40764: LD_INT 2
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: LIST
40776: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40777: LD_ADDR_VAR 0 54
40781: PUSH
40782: LD_INT 2
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 3
40805: PUSH
40806: LD_INT 1
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40818: LD_ADDR_VAR 0 55
40822: PUSH
40823: LD_INT 3
40825: PUSH
40826: LD_INT 2
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 3
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 2
40845: PUSH
40846: LD_INT 3
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: LIST
40857: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40858: LD_ADDR_VAR 0 56
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: LD_INT 3
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: LD_INT 3
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: LD_INT 2
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: LIST
40898: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40899: LD_ADDR_VAR 0 57
40903: PUSH
40904: LD_INT 2
40906: NEG
40907: PUSH
40908: LD_INT 1
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 3
40917: NEG
40918: PUSH
40919: LD_INT 0
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 3
40928: NEG
40929: PUSH
40930: LD_INT 1
40932: NEG
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: LIST
40942: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40943: LD_ADDR_VAR 0 58
40947: PUSH
40948: LD_INT 2
40950: NEG
40951: PUSH
40952: LD_INT 3
40954: NEG
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 3
40962: NEG
40963: PUSH
40964: LD_INT 2
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 3
40974: NEG
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: LIST
40988: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
40989: LD_ADDR_VAR 0 59
40993: PUSH
40994: LD_INT 1
40996: NEG
40997: PUSH
40998: LD_INT 2
41000: NEG
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 2
41011: NEG
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 1
41019: PUSH
41020: LD_INT 1
41022: NEG
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: LIST
41032: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41033: LD_ADDR_VAR 0 60
41037: PUSH
41038: LD_INT 1
41040: PUSH
41041: LD_INT 1
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 2
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: PUSH
41062: LD_INT 1
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41074: LD_ADDR_VAR 0 61
41078: PUSH
41079: LD_INT 2
41081: PUSH
41082: LD_INT 1
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 2
41091: PUSH
41092: LD_INT 2
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: PUSH
41102: LD_INT 2
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: LIST
41113: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41114: LD_ADDR_VAR 0 62
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: LD_INT 2
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: LD_INT 2
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 1
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: LIST
41154: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41155: LD_ADDR_VAR 0 63
41159: PUSH
41160: LD_INT 1
41162: NEG
41163: PUSH
41164: LD_INT 1
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 2
41173: NEG
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 2
41184: NEG
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: LIST
41198: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41199: LD_ADDR_VAR 0 64
41203: PUSH
41204: LD_INT 1
41206: NEG
41207: PUSH
41208: LD_INT 2
41210: NEG
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 2
41218: NEG
41219: PUSH
41220: LD_INT 1
41222: NEG
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 2
41230: NEG
41231: PUSH
41232: LD_INT 2
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: LIST
41244: ST_TO_ADDR
// end ; 2 :
41245: GO 44511
41247: LD_INT 2
41249: DOUBLE
41250: EQUAL
41251: IFTRUE 41255
41253: GO 44510
41255: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41256: LD_ADDR_VAR 0 29
41260: PUSH
41261: LD_INT 4
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 4
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 5
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 5
41294: PUSH
41295: LD_INT 1
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 4
41304: PUSH
41305: LD_INT 1
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 3
41314: PUSH
41315: LD_INT 0
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 3
41324: PUSH
41325: LD_INT 1
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: LD_INT 2
41338: NEG
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 5
41346: PUSH
41347: LD_INT 2
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 3
41356: PUSH
41357: LD_INT 3
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 3
41366: PUSH
41367: LD_INT 2
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 4
41376: PUSH
41377: LD_INT 3
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 4
41386: PUSH
41387: LD_INT 4
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 3
41396: PUSH
41397: LD_INT 4
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 2
41406: PUSH
41407: LD_INT 3
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 2
41416: PUSH
41417: LD_INT 2
41419: PUSH
41420: EMPTY
41421: LIST
41422: LIST
41423: PUSH
41424: LD_INT 4
41426: PUSH
41427: LD_INT 2
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 2
41436: PUSH
41437: LD_INT 4
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: LD_INT 4
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: PUSH
41454: LD_INT 0
41456: PUSH
41457: LD_INT 3
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 1
41466: PUSH
41467: LD_INT 4
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 1
41476: PUSH
41477: LD_INT 5
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 0
41486: PUSH
41487: LD_INT 5
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 1
41496: NEG
41497: PUSH
41498: LD_INT 4
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 1
41507: NEG
41508: PUSH
41509: LD_INT 3
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 2
41518: PUSH
41519: LD_INT 5
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 2
41528: NEG
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 3
41539: NEG
41540: PUSH
41541: LD_INT 0
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 3
41550: NEG
41551: PUSH
41552: LD_INT 1
41554: NEG
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 2
41562: NEG
41563: PUSH
41564: LD_INT 0
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 2
41573: NEG
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 3
41584: NEG
41585: PUSH
41586: LD_INT 1
41588: PUSH
41589: EMPTY
41590: LIST
41591: LIST
41592: PUSH
41593: LD_INT 4
41595: NEG
41596: PUSH
41597: LD_INT 0
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 4
41606: NEG
41607: PUSH
41608: LD_INT 1
41610: NEG
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 4
41618: NEG
41619: PUSH
41620: LD_INT 2
41622: NEG
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: LD_INT 2
41630: NEG
41631: PUSH
41632: LD_INT 2
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 4
41641: NEG
41642: PUSH
41643: LD_INT 4
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: LD_INT 4
41653: NEG
41654: PUSH
41655: LD_INT 5
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 3
41665: NEG
41666: PUSH
41667: LD_INT 4
41669: NEG
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 3
41677: NEG
41678: PUSH
41679: LD_INT 3
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 4
41689: NEG
41690: PUSH
41691: LD_INT 3
41693: NEG
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 5
41701: NEG
41702: PUSH
41703: LD_INT 4
41705: NEG
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 5
41713: NEG
41714: PUSH
41715: LD_INT 5
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 3
41725: NEG
41726: PUSH
41727: LD_INT 5
41729: NEG
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 5
41737: NEG
41738: PUSH
41739: LD_INT 3
41741: NEG
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
41794: LD_ADDR_VAR 0 30
41798: PUSH
41799: LD_INT 4
41801: PUSH
41802: LD_INT 4
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: LD_INT 4
41811: PUSH
41812: LD_INT 3
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 5
41821: PUSH
41822: LD_INT 4
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 5
41831: PUSH
41832: LD_INT 5
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 4
41841: PUSH
41842: LD_INT 5
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 3
41851: PUSH
41852: LD_INT 4
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 3
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 5
41871: PUSH
41872: LD_INT 3
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 3
41881: PUSH
41882: LD_INT 5
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: LD_INT 3
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 0
41901: PUSH
41902: LD_INT 2
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 1
41911: PUSH
41912: LD_INT 3
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 1
41921: PUSH
41922: LD_INT 4
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 0
41931: PUSH
41932: LD_INT 4
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 1
41941: NEG
41942: PUSH
41943: LD_INT 3
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 1
41952: NEG
41953: PUSH
41954: LD_INT 2
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 2
41963: PUSH
41964: LD_INT 4
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 2
41973: NEG
41974: PUSH
41975: LD_INT 2
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 4
41984: NEG
41985: PUSH
41986: LD_INT 0
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 4
41995: NEG
41996: PUSH
41997: LD_INT 1
41999: NEG
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 3
42007: NEG
42008: PUSH
42009: LD_INT 0
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 3
42018: NEG
42019: PUSH
42020: LD_INT 1
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 4
42029: NEG
42030: PUSH
42031: LD_INT 1
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 5
42040: NEG
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 5
42051: NEG
42052: PUSH
42053: LD_INT 1
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 5
42063: NEG
42064: PUSH
42065: LD_INT 2
42067: NEG
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 3
42075: NEG
42076: PUSH
42077: LD_INT 2
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 3
42086: NEG
42087: PUSH
42088: LD_INT 3
42090: NEG
42091: PUSH
42092: EMPTY
42093: LIST
42094: LIST
42095: PUSH
42096: LD_INT 3
42098: NEG
42099: PUSH
42100: LD_INT 4
42102: NEG
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 2
42110: NEG
42111: PUSH
42112: LD_INT 3
42114: NEG
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 2
42122: NEG
42123: PUSH
42124: LD_INT 2
42126: NEG
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 3
42134: NEG
42135: PUSH
42136: LD_INT 2
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 4
42146: NEG
42147: PUSH
42148: LD_INT 3
42150: NEG
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 4
42158: NEG
42159: PUSH
42160: LD_INT 4
42162: NEG
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 2
42170: NEG
42171: PUSH
42172: LD_INT 4
42174: NEG
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 4
42182: NEG
42183: PUSH
42184: LD_INT 2
42186: NEG
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 0
42194: PUSH
42195: LD_INT 4
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 0
42205: PUSH
42206: LD_INT 5
42208: NEG
42209: PUSH
42210: EMPTY
42211: LIST
42212: LIST
42213: PUSH
42214: LD_INT 1
42216: PUSH
42217: LD_INT 4
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 1
42227: PUSH
42228: LD_INT 3
42230: NEG
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 0
42238: PUSH
42239: LD_INT 3
42241: NEG
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 1
42249: NEG
42250: PUSH
42251: LD_INT 4
42253: NEG
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 1
42261: NEG
42262: PUSH
42263: LD_INT 5
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 2
42273: PUSH
42274: LD_INT 3
42276: NEG
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 2
42284: NEG
42285: PUSH
42286: LD_INT 5
42288: NEG
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: LIST
42336: LIST
42337: LIST
42338: LIST
42339: LIST
42340: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
42341: LD_ADDR_VAR 0 31
42345: PUSH
42346: LD_INT 0
42348: PUSH
42349: LD_INT 4
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 0
42358: PUSH
42359: LD_INT 3
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 1
42368: PUSH
42369: LD_INT 4
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 1
42378: PUSH
42379: LD_INT 5
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 0
42388: PUSH
42389: LD_INT 5
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: LD_INT 1
42398: NEG
42399: PUSH
42400: LD_INT 4
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: LD_INT 1
42409: NEG
42410: PUSH
42411: LD_INT 3
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 2
42420: PUSH
42421: LD_INT 5
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PUSH
42428: LD_INT 2
42430: NEG
42431: PUSH
42432: LD_INT 3
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 3
42441: NEG
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 3
42452: NEG
42453: PUSH
42454: LD_INT 1
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: LD_INT 2
42464: NEG
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 2
42475: NEG
42476: PUSH
42477: LD_INT 1
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: LD_INT 3
42486: NEG
42487: PUSH
42488: LD_INT 1
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 4
42497: NEG
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 4
42508: NEG
42509: PUSH
42510: LD_INT 1
42512: NEG
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 4
42520: NEG
42521: PUSH
42522: LD_INT 2
42524: NEG
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: LD_INT 2
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 4
42543: NEG
42544: PUSH
42545: LD_INT 4
42547: NEG
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 4
42555: NEG
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: LD_INT 3
42567: NEG
42568: PUSH
42569: LD_INT 4
42571: NEG
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: LD_INT 3
42579: NEG
42580: PUSH
42581: LD_INT 3
42583: NEG
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 4
42591: NEG
42592: PUSH
42593: LD_INT 3
42595: NEG
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 5
42603: NEG
42604: PUSH
42605: LD_INT 4
42607: NEG
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 5
42615: NEG
42616: PUSH
42617: LD_INT 5
42619: NEG
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: LD_INT 5
42631: NEG
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: PUSH
42637: LD_INT 5
42639: NEG
42640: PUSH
42641: LD_INT 3
42643: NEG
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 0
42651: PUSH
42652: LD_INT 3
42654: NEG
42655: PUSH
42656: EMPTY
42657: LIST
42658: LIST
42659: PUSH
42660: LD_INT 0
42662: PUSH
42663: LD_INT 4
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: PUSH
42674: LD_INT 3
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: LD_INT 2
42687: NEG
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 0
42695: PUSH
42696: LD_INT 2
42698: NEG
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 1
42706: NEG
42707: PUSH
42708: LD_INT 3
42710: NEG
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 1
42718: NEG
42719: PUSH
42720: LD_INT 4
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 2
42730: PUSH
42731: LD_INT 2
42733: NEG
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 2
42741: NEG
42742: PUSH
42743: LD_INT 4
42745: NEG
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: LD_INT 4
42753: PUSH
42754: LD_INT 0
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PUSH
42761: LD_INT 4
42763: PUSH
42764: LD_INT 1
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 5
42774: PUSH
42775: LD_INT 0
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 5
42784: PUSH
42785: LD_INT 1
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 4
42794: PUSH
42795: LD_INT 1
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 3
42804: PUSH
42805: LD_INT 0
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 3
42814: PUSH
42815: LD_INT 1
42817: NEG
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 3
42825: PUSH
42826: LD_INT 2
42828: NEG
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 5
42836: PUSH
42837: LD_INT 2
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
42891: LD_ADDR_VAR 0 32
42895: PUSH
42896: LD_INT 4
42898: NEG
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 4
42909: NEG
42910: PUSH
42911: LD_INT 1
42913: NEG
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PUSH
42919: LD_INT 3
42921: NEG
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 3
42932: NEG
42933: PUSH
42934: LD_INT 1
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 4
42943: NEG
42944: PUSH
42945: LD_INT 1
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 5
42954: NEG
42955: PUSH
42956: LD_INT 0
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 5
42965: NEG
42966: PUSH
42967: LD_INT 1
42969: NEG
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 5
42977: NEG
42978: PUSH
42979: LD_INT 2
42981: NEG
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 3
42989: NEG
42990: PUSH
42991: LD_INT 2
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 3
43000: NEG
43001: PUSH
43002: LD_INT 3
43004: NEG
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 3
43012: NEG
43013: PUSH
43014: LD_INT 4
43016: NEG
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 2
43024: NEG
43025: PUSH
43026: LD_INT 3
43028: NEG
43029: PUSH
43030: EMPTY
43031: LIST
43032: LIST
43033: PUSH
43034: LD_INT 2
43036: NEG
43037: PUSH
43038: LD_INT 2
43040: NEG
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: LD_INT 3
43048: NEG
43049: PUSH
43050: LD_INT 2
43052: NEG
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 4
43060: NEG
43061: PUSH
43062: LD_INT 3
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 4
43072: NEG
43073: PUSH
43074: LD_INT 4
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 2
43084: NEG
43085: PUSH
43086: LD_INT 4
43088: NEG
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: LD_INT 4
43096: NEG
43097: PUSH
43098: LD_INT 2
43100: NEG
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: LD_INT 4
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 0
43119: PUSH
43120: LD_INT 5
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 1
43130: PUSH
43131: LD_INT 4
43133: NEG
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: LD_INT 1
43141: PUSH
43142: LD_INT 3
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 0
43152: PUSH
43153: LD_INT 3
43155: NEG
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: PUSH
43161: LD_INT 1
43163: NEG
43164: PUSH
43165: LD_INT 4
43167: NEG
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: LD_INT 5
43179: NEG
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 2
43187: PUSH
43188: LD_INT 3
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 2
43198: NEG
43199: PUSH
43200: LD_INT 5
43202: NEG
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 3
43210: PUSH
43211: LD_INT 0
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 3
43220: PUSH
43221: LD_INT 1
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 4
43231: PUSH
43232: LD_INT 0
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 4
43241: PUSH
43242: LD_INT 1
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 3
43251: PUSH
43252: LD_INT 1
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 2
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 2
43271: PUSH
43272: LD_INT 1
43274: NEG
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 2
43282: PUSH
43283: LD_INT 2
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 4
43293: PUSH
43294: LD_INT 2
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 4
43303: PUSH
43304: LD_INT 4
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: LD_INT 4
43313: PUSH
43314: LD_INT 3
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 5
43323: PUSH
43324: LD_INT 4
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 5
43333: PUSH
43334: LD_INT 5
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 4
43343: PUSH
43344: LD_INT 5
43346: PUSH
43347: EMPTY
43348: LIST
43349: LIST
43350: PUSH
43351: LD_INT 3
43353: PUSH
43354: LD_INT 4
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: LD_INT 3
43363: PUSH
43364: LD_INT 3
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PUSH
43371: LD_INT 5
43373: PUSH
43374: LD_INT 3
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 3
43383: PUSH
43384: LD_INT 5
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: PUSH
43391: EMPTY
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: LIST
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
43438: LD_ADDR_VAR 0 33
43442: PUSH
43443: LD_INT 4
43445: NEG
43446: PUSH
43447: LD_INT 4
43449: NEG
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PUSH
43455: LD_INT 4
43457: NEG
43458: PUSH
43459: LD_INT 5
43461: NEG
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 3
43469: NEG
43470: PUSH
43471: LD_INT 4
43473: NEG
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 3
43481: NEG
43482: PUSH
43483: LD_INT 3
43485: NEG
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 4
43493: NEG
43494: PUSH
43495: LD_INT 3
43497: NEG
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: LD_INT 5
43505: NEG
43506: PUSH
43507: LD_INT 4
43509: NEG
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 5
43517: NEG
43518: PUSH
43519: LD_INT 5
43521: NEG
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 3
43529: NEG
43530: PUSH
43531: LD_INT 5
43533: NEG
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 5
43541: NEG
43542: PUSH
43543: LD_INT 3
43545: NEG
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 3
43556: NEG
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 0
43564: PUSH
43565: LD_INT 4
43567: NEG
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 1
43575: PUSH
43576: LD_INT 3
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 1
43586: PUSH
43587: LD_INT 2
43589: NEG
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 0
43597: PUSH
43598: LD_INT 2
43600: NEG
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: NEG
43609: PUSH
43610: LD_INT 3
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 1
43620: NEG
43621: PUSH
43622: LD_INT 4
43624: NEG
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 2
43632: PUSH
43633: LD_INT 2
43635: NEG
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 2
43643: NEG
43644: PUSH
43645: LD_INT 4
43647: NEG
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 4
43655: PUSH
43656: LD_INT 0
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: LD_INT 1
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 5
43676: PUSH
43677: LD_INT 0
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 5
43686: PUSH
43687: LD_INT 1
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 4
43696: PUSH
43697: LD_INT 1
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 3
43716: PUSH
43717: LD_INT 1
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 3
43727: PUSH
43728: LD_INT 2
43730: NEG
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 5
43738: PUSH
43739: LD_INT 2
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 3
43748: PUSH
43749: LD_INT 3
43751: PUSH
43752: EMPTY
43753: LIST
43754: LIST
43755: PUSH
43756: LD_INT 3
43758: PUSH
43759: LD_INT 2
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 4
43768: PUSH
43769: LD_INT 3
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 4
43778: PUSH
43779: LD_INT 4
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 3
43788: PUSH
43789: LD_INT 4
43791: PUSH
43792: EMPTY
43793: LIST
43794: LIST
43795: PUSH
43796: LD_INT 2
43798: PUSH
43799: LD_INT 3
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 2
43808: PUSH
43809: LD_INT 2
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 4
43818: PUSH
43819: LD_INT 2
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 2
43828: PUSH
43829: LD_INT 4
43831: PUSH
43832: EMPTY
43833: LIST
43834: LIST
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: LD_INT 4
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 0
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 1
43858: PUSH
43859: LD_INT 4
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 1
43868: PUSH
43869: LD_INT 5
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: LD_INT 5
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 1
43888: NEG
43889: PUSH
43890: LD_INT 4
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 1
43899: NEG
43900: PUSH
43901: LD_INT 3
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 2
43910: PUSH
43911: LD_INT 5
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 2
43920: NEG
43921: PUSH
43922: LD_INT 3
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: LIST
43935: LIST
43936: LIST
43937: LIST
43938: LIST
43939: LIST
43940: LIST
43941: LIST
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
43976: LD_ADDR_VAR 0 34
43980: PUSH
43981: LD_INT 0
43983: PUSH
43984: LD_INT 4
43986: NEG
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: LD_INT 0
43994: PUSH
43995: LD_INT 5
43997: NEG
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 1
44005: PUSH
44006: LD_INT 4
44008: NEG
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 1
44016: PUSH
44017: LD_INT 3
44019: NEG
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 0
44027: PUSH
44028: LD_INT 3
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 1
44038: NEG
44039: PUSH
44040: LD_INT 4
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 1
44050: NEG
44051: PUSH
44052: LD_INT 5
44054: NEG
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 2
44062: PUSH
44063: LD_INT 3
44065: NEG
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 2
44073: NEG
44074: PUSH
44075: LD_INT 5
44077: NEG
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 3
44085: PUSH
44086: LD_INT 0
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 3
44095: PUSH
44096: LD_INT 1
44098: NEG
44099: PUSH
44100: EMPTY
44101: LIST
44102: LIST
44103: PUSH
44104: LD_INT 4
44106: PUSH
44107: LD_INT 0
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: PUSH
44117: LD_INT 1
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 3
44126: PUSH
44127: LD_INT 1
44129: PUSH
44130: EMPTY
44131: LIST
44132: LIST
44133: PUSH
44134: LD_INT 2
44136: PUSH
44137: LD_INT 0
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 2
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 2
44157: PUSH
44158: LD_INT 2
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 4
44168: PUSH
44169: LD_INT 2
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 4
44178: PUSH
44179: LD_INT 4
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 4
44188: PUSH
44189: LD_INT 3
44191: PUSH
44192: EMPTY
44193: LIST
44194: LIST
44195: PUSH
44196: LD_INT 5
44198: PUSH
44199: LD_INT 4
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: PUSH
44206: LD_INT 5
44208: PUSH
44209: LD_INT 5
44211: PUSH
44212: EMPTY
44213: LIST
44214: LIST
44215: PUSH
44216: LD_INT 4
44218: PUSH
44219: LD_INT 5
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 3
44228: PUSH
44229: LD_INT 4
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 3
44238: PUSH
44239: LD_INT 3
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 5
44248: PUSH
44249: LD_INT 3
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 3
44258: PUSH
44259: LD_INT 5
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 0
44268: PUSH
44269: LD_INT 3
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: LD_INT 2
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 1
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 4
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 0
44308: PUSH
44309: LD_INT 4
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 1
44318: NEG
44319: PUSH
44320: LD_INT 3
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 2
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 2
44340: PUSH
44341: LD_INT 4
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 2
44350: NEG
44351: PUSH
44352: LD_INT 2
44354: PUSH
44355: EMPTY
44356: LIST
44357: LIST
44358: PUSH
44359: LD_INT 4
44361: NEG
44362: PUSH
44363: LD_INT 0
44365: PUSH
44366: EMPTY
44367: LIST
44368: LIST
44369: PUSH
44370: LD_INT 4
44372: NEG
44373: PUSH
44374: LD_INT 1
44376: NEG
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 3
44384: NEG
44385: PUSH
44386: LD_INT 0
44388: PUSH
44389: EMPTY
44390: LIST
44391: LIST
44392: PUSH
44393: LD_INT 3
44395: NEG
44396: PUSH
44397: LD_INT 1
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 4
44406: NEG
44407: PUSH
44408: LD_INT 1
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 5
44417: NEG
44418: PUSH
44419: LD_INT 0
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 5
44428: NEG
44429: PUSH
44430: LD_INT 1
44432: NEG
44433: PUSH
44434: EMPTY
44435: LIST
44436: LIST
44437: PUSH
44438: LD_INT 5
44440: NEG
44441: PUSH
44442: LD_INT 2
44444: NEG
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 3
44452: NEG
44453: PUSH
44454: LD_INT 2
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: LIST
44481: LIST
44482: LIST
44483: LIST
44484: LIST
44485: LIST
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: LIST
44507: ST_TO_ADDR
// end ; end ;
44508: GO 44511
44510: POP
// case btype of b_depot , b_warehouse :
44511: LD_VAR 0 1
44515: PUSH
44516: LD_INT 0
44518: DOUBLE
44519: EQUAL
44520: IFTRUE 44530
44522: LD_INT 1
44524: DOUBLE
44525: EQUAL
44526: IFTRUE 44530
44528: GO 44731
44530: POP
// case nation of nation_american :
44531: LD_VAR 0 5
44535: PUSH
44536: LD_INT 1
44538: DOUBLE
44539: EQUAL
44540: IFTRUE 44544
44542: GO 44600
44544: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
44545: LD_ADDR_VAR 0 9
44549: PUSH
44550: LD_VAR 0 11
44554: PUSH
44555: LD_VAR 0 12
44559: PUSH
44560: LD_VAR 0 13
44564: PUSH
44565: LD_VAR 0 14
44569: PUSH
44570: LD_VAR 0 15
44574: PUSH
44575: LD_VAR 0 16
44579: PUSH
44580: EMPTY
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: LIST
44586: LIST
44587: PUSH
44588: LD_VAR 0 4
44592: PUSH
44593: LD_INT 1
44595: PLUS
44596: ARRAY
44597: ST_TO_ADDR
44598: GO 44729
44600: LD_INT 2
44602: DOUBLE
44603: EQUAL
44604: IFTRUE 44608
44606: GO 44664
44608: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
44609: LD_ADDR_VAR 0 9
44613: PUSH
44614: LD_VAR 0 17
44618: PUSH
44619: LD_VAR 0 18
44623: PUSH
44624: LD_VAR 0 19
44628: PUSH
44629: LD_VAR 0 20
44633: PUSH
44634: LD_VAR 0 21
44638: PUSH
44639: LD_VAR 0 22
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: PUSH
44652: LD_VAR 0 4
44656: PUSH
44657: LD_INT 1
44659: PLUS
44660: ARRAY
44661: ST_TO_ADDR
44662: GO 44729
44664: LD_INT 3
44666: DOUBLE
44667: EQUAL
44668: IFTRUE 44672
44670: GO 44728
44672: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
44673: LD_ADDR_VAR 0 9
44677: PUSH
44678: LD_VAR 0 23
44682: PUSH
44683: LD_VAR 0 24
44687: PUSH
44688: LD_VAR 0 25
44692: PUSH
44693: LD_VAR 0 26
44697: PUSH
44698: LD_VAR 0 27
44702: PUSH
44703: LD_VAR 0 28
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: PUSH
44716: LD_VAR 0 4
44720: PUSH
44721: LD_INT 1
44723: PLUS
44724: ARRAY
44725: ST_TO_ADDR
44726: GO 44729
44728: POP
44729: GO 45284
44731: LD_INT 2
44733: DOUBLE
44734: EQUAL
44735: IFTRUE 44745
44737: LD_INT 3
44739: DOUBLE
44740: EQUAL
44741: IFTRUE 44745
44743: GO 44801
44745: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
44746: LD_ADDR_VAR 0 9
44750: PUSH
44751: LD_VAR 0 29
44755: PUSH
44756: LD_VAR 0 30
44760: PUSH
44761: LD_VAR 0 31
44765: PUSH
44766: LD_VAR 0 32
44770: PUSH
44771: LD_VAR 0 33
44775: PUSH
44776: LD_VAR 0 34
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: PUSH
44789: LD_VAR 0 4
44793: PUSH
44794: LD_INT 1
44796: PLUS
44797: ARRAY
44798: ST_TO_ADDR
44799: GO 45284
44801: LD_INT 16
44803: DOUBLE
44804: EQUAL
44805: IFTRUE 44863
44807: LD_INT 17
44809: DOUBLE
44810: EQUAL
44811: IFTRUE 44863
44813: LD_INT 18
44815: DOUBLE
44816: EQUAL
44817: IFTRUE 44863
44819: LD_INT 19
44821: DOUBLE
44822: EQUAL
44823: IFTRUE 44863
44825: LD_INT 22
44827: DOUBLE
44828: EQUAL
44829: IFTRUE 44863
44831: LD_INT 20
44833: DOUBLE
44834: EQUAL
44835: IFTRUE 44863
44837: LD_INT 21
44839: DOUBLE
44840: EQUAL
44841: IFTRUE 44863
44843: LD_INT 23
44845: DOUBLE
44846: EQUAL
44847: IFTRUE 44863
44849: LD_INT 24
44851: DOUBLE
44852: EQUAL
44853: IFTRUE 44863
44855: LD_INT 25
44857: DOUBLE
44858: EQUAL
44859: IFTRUE 44863
44861: GO 44919
44863: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
44864: LD_ADDR_VAR 0 9
44868: PUSH
44869: LD_VAR 0 35
44873: PUSH
44874: LD_VAR 0 36
44878: PUSH
44879: LD_VAR 0 37
44883: PUSH
44884: LD_VAR 0 38
44888: PUSH
44889: LD_VAR 0 39
44893: PUSH
44894: LD_VAR 0 40
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: PUSH
44907: LD_VAR 0 4
44911: PUSH
44912: LD_INT 1
44914: PLUS
44915: ARRAY
44916: ST_TO_ADDR
44917: GO 45284
44919: LD_INT 6
44921: DOUBLE
44922: EQUAL
44923: IFTRUE 44975
44925: LD_INT 7
44927: DOUBLE
44928: EQUAL
44929: IFTRUE 44975
44931: LD_INT 8
44933: DOUBLE
44934: EQUAL
44935: IFTRUE 44975
44937: LD_INT 13
44939: DOUBLE
44940: EQUAL
44941: IFTRUE 44975
44943: LD_INT 12
44945: DOUBLE
44946: EQUAL
44947: IFTRUE 44975
44949: LD_INT 15
44951: DOUBLE
44952: EQUAL
44953: IFTRUE 44975
44955: LD_INT 11
44957: DOUBLE
44958: EQUAL
44959: IFTRUE 44975
44961: LD_INT 14
44963: DOUBLE
44964: EQUAL
44965: IFTRUE 44975
44967: LD_INT 10
44969: DOUBLE
44970: EQUAL
44971: IFTRUE 44975
44973: GO 45031
44975: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
44976: LD_ADDR_VAR 0 9
44980: PUSH
44981: LD_VAR 0 41
44985: PUSH
44986: LD_VAR 0 42
44990: PUSH
44991: LD_VAR 0 43
44995: PUSH
44996: LD_VAR 0 44
45000: PUSH
45001: LD_VAR 0 45
45005: PUSH
45006: LD_VAR 0 46
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: PUSH
45019: LD_VAR 0 4
45023: PUSH
45024: LD_INT 1
45026: PLUS
45027: ARRAY
45028: ST_TO_ADDR
45029: GO 45284
45031: LD_INT 36
45033: DOUBLE
45034: EQUAL
45035: IFTRUE 45039
45037: GO 45095
45039: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45040: LD_ADDR_VAR 0 9
45044: PUSH
45045: LD_VAR 0 47
45049: PUSH
45050: LD_VAR 0 48
45054: PUSH
45055: LD_VAR 0 49
45059: PUSH
45060: LD_VAR 0 50
45064: PUSH
45065: LD_VAR 0 51
45069: PUSH
45070: LD_VAR 0 52
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: PUSH
45083: LD_VAR 0 4
45087: PUSH
45088: LD_INT 1
45090: PLUS
45091: ARRAY
45092: ST_TO_ADDR
45093: GO 45284
45095: LD_INT 4
45097: DOUBLE
45098: EQUAL
45099: IFTRUE 45121
45101: LD_INT 5
45103: DOUBLE
45104: EQUAL
45105: IFTRUE 45121
45107: LD_INT 34
45109: DOUBLE
45110: EQUAL
45111: IFTRUE 45121
45113: LD_INT 37
45115: DOUBLE
45116: EQUAL
45117: IFTRUE 45121
45119: GO 45177
45121: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45122: LD_ADDR_VAR 0 9
45126: PUSH
45127: LD_VAR 0 53
45131: PUSH
45132: LD_VAR 0 54
45136: PUSH
45137: LD_VAR 0 55
45141: PUSH
45142: LD_VAR 0 56
45146: PUSH
45147: LD_VAR 0 57
45151: PUSH
45152: LD_VAR 0 58
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: PUSH
45165: LD_VAR 0 4
45169: PUSH
45170: LD_INT 1
45172: PLUS
45173: ARRAY
45174: ST_TO_ADDR
45175: GO 45284
45177: LD_INT 31
45179: DOUBLE
45180: EQUAL
45181: IFTRUE 45227
45183: LD_INT 32
45185: DOUBLE
45186: EQUAL
45187: IFTRUE 45227
45189: LD_INT 33
45191: DOUBLE
45192: EQUAL
45193: IFTRUE 45227
45195: LD_INT 27
45197: DOUBLE
45198: EQUAL
45199: IFTRUE 45227
45201: LD_INT 26
45203: DOUBLE
45204: EQUAL
45205: IFTRUE 45227
45207: LD_INT 28
45209: DOUBLE
45210: EQUAL
45211: IFTRUE 45227
45213: LD_INT 29
45215: DOUBLE
45216: EQUAL
45217: IFTRUE 45227
45219: LD_INT 30
45221: DOUBLE
45222: EQUAL
45223: IFTRUE 45227
45225: GO 45283
45227: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45228: LD_ADDR_VAR 0 9
45232: PUSH
45233: LD_VAR 0 59
45237: PUSH
45238: LD_VAR 0 60
45242: PUSH
45243: LD_VAR 0 61
45247: PUSH
45248: LD_VAR 0 62
45252: PUSH
45253: LD_VAR 0 63
45257: PUSH
45258: LD_VAR 0 64
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: PUSH
45271: LD_VAR 0 4
45275: PUSH
45276: LD_INT 1
45278: PLUS
45279: ARRAY
45280: ST_TO_ADDR
45281: GO 45284
45283: POP
// temp_list2 = [ ] ;
45284: LD_ADDR_VAR 0 10
45288: PUSH
45289: EMPTY
45290: ST_TO_ADDR
// for i in temp_list do
45291: LD_ADDR_VAR 0 8
45295: PUSH
45296: LD_VAR 0 9
45300: PUSH
45301: FOR_IN
45302: IFFALSE 45354
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45304: LD_ADDR_VAR 0 10
45308: PUSH
45309: LD_VAR 0 10
45313: PUSH
45314: LD_VAR 0 8
45318: PUSH
45319: LD_INT 1
45321: ARRAY
45322: PUSH
45323: LD_VAR 0 2
45327: PLUS
45328: PUSH
45329: LD_VAR 0 8
45333: PUSH
45334: LD_INT 2
45336: ARRAY
45337: PUSH
45338: LD_VAR 0 3
45342: PLUS
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: EMPTY
45349: LIST
45350: ADD
45351: ST_TO_ADDR
45352: GO 45301
45354: POP
45355: POP
// result = temp_list2 ;
45356: LD_ADDR_VAR 0 7
45360: PUSH
45361: LD_VAR 0 10
45365: ST_TO_ADDR
// end ;
45366: LD_VAR 0 7
45370: RET
// export function EnemyInRange ( unit , dist ) ; begin
45371: LD_INT 0
45373: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
45374: LD_ADDR_VAR 0 3
45378: PUSH
45379: LD_VAR 0 1
45383: PPUSH
45384: CALL_OW 255
45388: PPUSH
45389: LD_VAR 0 1
45393: PPUSH
45394: CALL_OW 250
45398: PPUSH
45399: LD_VAR 0 1
45403: PPUSH
45404: CALL_OW 251
45408: PPUSH
45409: LD_VAR 0 2
45413: PPUSH
45414: CALL 19475 0 4
45418: PUSH
45419: LD_INT 4
45421: ARRAY
45422: ST_TO_ADDR
// end ;
45423: LD_VAR 0 3
45427: RET
// export function PlayerSeeMe ( unit ) ; begin
45428: LD_INT 0
45430: PPUSH
// result := See ( your_side , unit ) ;
45431: LD_ADDR_VAR 0 2
45435: PUSH
45436: LD_OWVAR 2
45440: PPUSH
45441: LD_VAR 0 1
45445: PPUSH
45446: CALL_OW 292
45450: ST_TO_ADDR
// end ;
45451: LD_VAR 0 2
45455: RET
// export function ReverseDir ( unit ) ; begin
45456: LD_INT 0
45458: PPUSH
// if not unit then
45459: LD_VAR 0 1
45463: NOT
45464: IFFALSE 45468
// exit ;
45466: GO 45491
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
45468: LD_ADDR_VAR 0 2
45472: PUSH
45473: LD_VAR 0 1
45477: PPUSH
45478: CALL_OW 254
45482: PUSH
45483: LD_INT 3
45485: PLUS
45486: PUSH
45487: LD_INT 6
45489: MOD
45490: ST_TO_ADDR
// end ;
45491: LD_VAR 0 2
45495: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
45496: LD_INT 0
45498: PPUSH
45499: PPUSH
45500: PPUSH
45501: PPUSH
45502: PPUSH
// if not hexes then
45503: LD_VAR 0 2
45507: NOT
45508: IFFALSE 45512
// exit ;
45510: GO 45660
// dist := 9999 ;
45512: LD_ADDR_VAR 0 5
45516: PUSH
45517: LD_INT 9999
45519: ST_TO_ADDR
// for i = 1 to hexes do
45520: LD_ADDR_VAR 0 4
45524: PUSH
45525: DOUBLE
45526: LD_INT 1
45528: DEC
45529: ST_TO_ADDR
45530: LD_VAR 0 2
45534: PUSH
45535: FOR_TO
45536: IFFALSE 45648
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
45538: LD_VAR 0 1
45542: PPUSH
45543: LD_VAR 0 2
45547: PUSH
45548: LD_VAR 0 4
45552: ARRAY
45553: PUSH
45554: LD_INT 1
45556: ARRAY
45557: PPUSH
45558: LD_VAR 0 2
45562: PUSH
45563: LD_VAR 0 4
45567: ARRAY
45568: PUSH
45569: LD_INT 2
45571: ARRAY
45572: PPUSH
45573: CALL_OW 297
45577: PUSH
45578: LD_VAR 0 5
45582: LESS
45583: IFFALSE 45646
// begin hex := hexes [ i ] ;
45585: LD_ADDR_VAR 0 7
45589: PUSH
45590: LD_VAR 0 2
45594: PUSH
45595: LD_VAR 0 4
45599: ARRAY
45600: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
45601: LD_ADDR_VAR 0 5
45605: PUSH
45606: LD_VAR 0 1
45610: PPUSH
45611: LD_VAR 0 2
45615: PUSH
45616: LD_VAR 0 4
45620: ARRAY
45621: PUSH
45622: LD_INT 1
45624: ARRAY
45625: PPUSH
45626: LD_VAR 0 2
45630: PUSH
45631: LD_VAR 0 4
45635: ARRAY
45636: PUSH
45637: LD_INT 2
45639: ARRAY
45640: PPUSH
45641: CALL_OW 297
45645: ST_TO_ADDR
// end ; end ;
45646: GO 45535
45648: POP
45649: POP
// result := hex ;
45650: LD_ADDR_VAR 0 3
45654: PUSH
45655: LD_VAR 0 7
45659: ST_TO_ADDR
// end ;
45660: LD_VAR 0 3
45664: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
45665: LD_INT 0
45667: PPUSH
45668: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
45669: LD_VAR 0 1
45673: NOT
45674: PUSH
45675: LD_VAR 0 1
45679: PUSH
45680: LD_INT 21
45682: PUSH
45683: LD_INT 2
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: LD_INT 23
45692: PUSH
45693: LD_INT 2
45695: PUSH
45696: EMPTY
45697: LIST
45698: LIST
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PPUSH
45704: CALL_OW 69
45708: IN
45709: NOT
45710: OR
45711: IFFALSE 45715
// exit ;
45713: GO 45762
// for i = 1 to 3 do
45715: LD_ADDR_VAR 0 3
45719: PUSH
45720: DOUBLE
45721: LD_INT 1
45723: DEC
45724: ST_TO_ADDR
45725: LD_INT 3
45727: PUSH
45728: FOR_TO
45729: IFFALSE 45760
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
45731: LD_VAR 0 1
45735: PPUSH
45736: CALL_OW 250
45740: PPUSH
45741: LD_VAR 0 1
45745: PPUSH
45746: CALL_OW 251
45750: PPUSH
45751: LD_INT 1
45753: PPUSH
45754: CALL_OW 453
45758: GO 45728
45760: POP
45761: POP
// end ;
45762: LD_VAR 0 2
45766: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
45767: LD_INT 0
45769: PPUSH
45770: PPUSH
45771: PPUSH
45772: PPUSH
45773: PPUSH
45774: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
45775: LD_VAR 0 1
45779: NOT
45780: PUSH
45781: LD_VAR 0 2
45785: NOT
45786: OR
45787: PUSH
45788: LD_VAR 0 1
45792: PPUSH
45793: CALL_OW 314
45797: OR
45798: IFFALSE 45802
// exit ;
45800: GO 46243
// x := GetX ( enemy_unit ) ;
45802: LD_ADDR_VAR 0 7
45806: PUSH
45807: LD_VAR 0 2
45811: PPUSH
45812: CALL_OW 250
45816: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
45817: LD_ADDR_VAR 0 8
45821: PUSH
45822: LD_VAR 0 2
45826: PPUSH
45827: CALL_OW 251
45831: ST_TO_ADDR
// if not x or not y then
45832: LD_VAR 0 7
45836: NOT
45837: PUSH
45838: LD_VAR 0 8
45842: NOT
45843: OR
45844: IFFALSE 45848
// exit ;
45846: GO 46243
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
45848: LD_ADDR_VAR 0 6
45852: PUSH
45853: LD_VAR 0 7
45857: PPUSH
45858: LD_INT 0
45860: PPUSH
45861: LD_INT 4
45863: PPUSH
45864: CALL_OW 272
45868: PUSH
45869: LD_VAR 0 8
45873: PPUSH
45874: LD_INT 0
45876: PPUSH
45877: LD_INT 4
45879: PPUSH
45880: CALL_OW 273
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_VAR 0 7
45893: PPUSH
45894: LD_INT 1
45896: PPUSH
45897: LD_INT 4
45899: PPUSH
45900: CALL_OW 272
45904: PUSH
45905: LD_VAR 0 8
45909: PPUSH
45910: LD_INT 1
45912: PPUSH
45913: LD_INT 4
45915: PPUSH
45916: CALL_OW 273
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_VAR 0 7
45929: PPUSH
45930: LD_INT 2
45932: PPUSH
45933: LD_INT 4
45935: PPUSH
45936: CALL_OW 272
45940: PUSH
45941: LD_VAR 0 8
45945: PPUSH
45946: LD_INT 2
45948: PPUSH
45949: LD_INT 4
45951: PPUSH
45952: CALL_OW 273
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_VAR 0 7
45965: PPUSH
45966: LD_INT 3
45968: PPUSH
45969: LD_INT 4
45971: PPUSH
45972: CALL_OW 272
45976: PUSH
45977: LD_VAR 0 8
45981: PPUSH
45982: LD_INT 3
45984: PPUSH
45985: LD_INT 4
45987: PPUSH
45988: CALL_OW 273
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: LD_VAR 0 7
46001: PPUSH
46002: LD_INT 4
46004: PPUSH
46005: LD_INT 4
46007: PPUSH
46008: CALL_OW 272
46012: PUSH
46013: LD_VAR 0 8
46017: PPUSH
46018: LD_INT 4
46020: PPUSH
46021: LD_INT 4
46023: PPUSH
46024: CALL_OW 273
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PUSH
46033: LD_VAR 0 7
46037: PPUSH
46038: LD_INT 5
46040: PPUSH
46041: LD_INT 4
46043: PPUSH
46044: CALL_OW 272
46048: PUSH
46049: LD_VAR 0 8
46053: PPUSH
46054: LD_INT 5
46056: PPUSH
46057: LD_INT 4
46059: PPUSH
46060: CALL_OW 273
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: ST_TO_ADDR
// for i = tmp downto 1 do
46077: LD_ADDR_VAR 0 4
46081: PUSH
46082: DOUBLE
46083: LD_VAR 0 6
46087: INC
46088: ST_TO_ADDR
46089: LD_INT 1
46091: PUSH
46092: FOR_DOWNTO
46093: IFFALSE 46194
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46095: LD_VAR 0 6
46099: PUSH
46100: LD_VAR 0 4
46104: ARRAY
46105: PUSH
46106: LD_INT 1
46108: ARRAY
46109: PPUSH
46110: LD_VAR 0 6
46114: PUSH
46115: LD_VAR 0 4
46119: ARRAY
46120: PUSH
46121: LD_INT 2
46123: ARRAY
46124: PPUSH
46125: CALL_OW 488
46129: NOT
46130: PUSH
46131: LD_VAR 0 6
46135: PUSH
46136: LD_VAR 0 4
46140: ARRAY
46141: PUSH
46142: LD_INT 1
46144: ARRAY
46145: PPUSH
46146: LD_VAR 0 6
46150: PUSH
46151: LD_VAR 0 4
46155: ARRAY
46156: PUSH
46157: LD_INT 2
46159: ARRAY
46160: PPUSH
46161: CALL_OW 428
46165: PUSH
46166: LD_INT 0
46168: NONEQUAL
46169: OR
46170: IFFALSE 46192
// tmp := Delete ( tmp , i ) ;
46172: LD_ADDR_VAR 0 6
46176: PUSH
46177: LD_VAR 0 6
46181: PPUSH
46182: LD_VAR 0 4
46186: PPUSH
46187: CALL_OW 3
46191: ST_TO_ADDR
46192: GO 46092
46194: POP
46195: POP
// j := GetClosestHex ( unit , tmp ) ;
46196: LD_ADDR_VAR 0 5
46200: PUSH
46201: LD_VAR 0 1
46205: PPUSH
46206: LD_VAR 0 6
46210: PPUSH
46211: CALL 45496 0 2
46215: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46216: LD_VAR 0 1
46220: PPUSH
46221: LD_VAR 0 5
46225: PUSH
46226: LD_INT 1
46228: ARRAY
46229: PPUSH
46230: LD_VAR 0 5
46234: PUSH
46235: LD_INT 2
46237: ARRAY
46238: PPUSH
46239: CALL_OW 111
// end ;
46243: LD_VAR 0 3
46247: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46248: LD_INT 0
46250: PPUSH
46251: PPUSH
46252: PPUSH
// uc_side = 0 ;
46253: LD_ADDR_OWVAR 20
46257: PUSH
46258: LD_INT 0
46260: ST_TO_ADDR
// uc_nation = 0 ;
46261: LD_ADDR_OWVAR 21
46265: PUSH
46266: LD_INT 0
46268: ST_TO_ADDR
// InitHc ;
46269: CALL_OW 19
// InitVc ;
46273: CALL_OW 20
// if mastodonts then
46277: LD_VAR 0 6
46281: IFFALSE 46348
// for i = 1 to mastodonts do
46283: LD_ADDR_VAR 0 11
46287: PUSH
46288: DOUBLE
46289: LD_INT 1
46291: DEC
46292: ST_TO_ADDR
46293: LD_VAR 0 6
46297: PUSH
46298: FOR_TO
46299: IFFALSE 46346
// begin vc_chassis := 31 ;
46301: LD_ADDR_OWVAR 37
46305: PUSH
46306: LD_INT 31
46308: ST_TO_ADDR
// vc_control := control_rider ;
46309: LD_ADDR_OWVAR 38
46313: PUSH
46314: LD_INT 4
46316: ST_TO_ADDR
// animal := CreateVehicle ;
46317: LD_ADDR_VAR 0 12
46321: PUSH
46322: CALL_OW 45
46326: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46327: LD_VAR 0 12
46331: PPUSH
46332: LD_VAR 0 8
46336: PPUSH
46337: LD_INT 0
46339: PPUSH
46340: CALL 48417 0 3
// end ;
46344: GO 46298
46346: POP
46347: POP
// if horses then
46348: LD_VAR 0 5
46352: IFFALSE 46419
// for i = 1 to horses do
46354: LD_ADDR_VAR 0 11
46358: PUSH
46359: DOUBLE
46360: LD_INT 1
46362: DEC
46363: ST_TO_ADDR
46364: LD_VAR 0 5
46368: PUSH
46369: FOR_TO
46370: IFFALSE 46417
// begin hc_class := 21 ;
46372: LD_ADDR_OWVAR 28
46376: PUSH
46377: LD_INT 21
46379: ST_TO_ADDR
// hc_gallery :=  ;
46380: LD_ADDR_OWVAR 33
46384: PUSH
46385: LD_STRING 
46387: ST_TO_ADDR
// animal := CreateHuman ;
46388: LD_ADDR_VAR 0 12
46392: PUSH
46393: CALL_OW 44
46397: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46398: LD_VAR 0 12
46402: PPUSH
46403: LD_VAR 0 8
46407: PPUSH
46408: LD_INT 0
46410: PPUSH
46411: CALL 48417 0 3
// end ;
46415: GO 46369
46417: POP
46418: POP
// if birds then
46419: LD_VAR 0 1
46423: IFFALSE 46490
// for i = 1 to birds do
46425: LD_ADDR_VAR 0 11
46429: PUSH
46430: DOUBLE
46431: LD_INT 1
46433: DEC
46434: ST_TO_ADDR
46435: LD_VAR 0 1
46439: PUSH
46440: FOR_TO
46441: IFFALSE 46488
// begin hc_class = 18 ;
46443: LD_ADDR_OWVAR 28
46447: PUSH
46448: LD_INT 18
46450: ST_TO_ADDR
// hc_gallery =  ;
46451: LD_ADDR_OWVAR 33
46455: PUSH
46456: LD_STRING 
46458: ST_TO_ADDR
// animal := CreateHuman ;
46459: LD_ADDR_VAR 0 12
46463: PUSH
46464: CALL_OW 44
46468: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46469: LD_VAR 0 12
46473: PPUSH
46474: LD_VAR 0 8
46478: PPUSH
46479: LD_INT 0
46481: PPUSH
46482: CALL 48417 0 3
// end ;
46486: GO 46440
46488: POP
46489: POP
// if tigers then
46490: LD_VAR 0 2
46494: IFFALSE 46578
// for i = 1 to tigers do
46496: LD_ADDR_VAR 0 11
46500: PUSH
46501: DOUBLE
46502: LD_INT 1
46504: DEC
46505: ST_TO_ADDR
46506: LD_VAR 0 2
46510: PUSH
46511: FOR_TO
46512: IFFALSE 46576
// begin hc_class = class_tiger ;
46514: LD_ADDR_OWVAR 28
46518: PUSH
46519: LD_INT 14
46521: ST_TO_ADDR
// hc_gallery =  ;
46522: LD_ADDR_OWVAR 33
46526: PUSH
46527: LD_STRING 
46529: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46530: LD_ADDR_OWVAR 35
46534: PUSH
46535: LD_INT 7
46537: NEG
46538: PPUSH
46539: LD_INT 7
46541: PPUSH
46542: CALL_OW 12
46546: ST_TO_ADDR
// animal := CreateHuman ;
46547: LD_ADDR_VAR 0 12
46551: PUSH
46552: CALL_OW 44
46556: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46557: LD_VAR 0 12
46561: PPUSH
46562: LD_VAR 0 8
46566: PPUSH
46567: LD_INT 0
46569: PPUSH
46570: CALL 48417 0 3
// end ;
46574: GO 46511
46576: POP
46577: POP
// if apemans then
46578: LD_VAR 0 3
46582: IFFALSE 46705
// for i = 1 to apemans do
46584: LD_ADDR_VAR 0 11
46588: PUSH
46589: DOUBLE
46590: LD_INT 1
46592: DEC
46593: ST_TO_ADDR
46594: LD_VAR 0 3
46598: PUSH
46599: FOR_TO
46600: IFFALSE 46703
// begin hc_class = class_apeman ;
46602: LD_ADDR_OWVAR 28
46606: PUSH
46607: LD_INT 12
46609: ST_TO_ADDR
// hc_gallery =  ;
46610: LD_ADDR_OWVAR 33
46614: PUSH
46615: LD_STRING 
46617: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
46618: LD_ADDR_OWVAR 35
46622: PUSH
46623: LD_INT 5
46625: NEG
46626: PPUSH
46627: LD_INT 5
46629: PPUSH
46630: CALL_OW 12
46634: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46635: LD_ADDR_OWVAR 31
46639: PUSH
46640: LD_INT 1
46642: PPUSH
46643: LD_INT 3
46645: PPUSH
46646: CALL_OW 12
46650: PUSH
46651: LD_INT 1
46653: PPUSH
46654: LD_INT 3
46656: PPUSH
46657: CALL_OW 12
46661: PUSH
46662: LD_INT 0
46664: PUSH
46665: LD_INT 0
46667: PUSH
46668: EMPTY
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// animal := CreateHuman ;
46674: LD_ADDR_VAR 0 12
46678: PUSH
46679: CALL_OW 44
46683: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46684: LD_VAR 0 12
46688: PPUSH
46689: LD_VAR 0 8
46693: PPUSH
46694: LD_INT 0
46696: PPUSH
46697: CALL 48417 0 3
// end ;
46701: GO 46599
46703: POP
46704: POP
// if enchidnas then
46705: LD_VAR 0 4
46709: IFFALSE 46776
// for i = 1 to enchidnas do
46711: LD_ADDR_VAR 0 11
46715: PUSH
46716: DOUBLE
46717: LD_INT 1
46719: DEC
46720: ST_TO_ADDR
46721: LD_VAR 0 4
46725: PUSH
46726: FOR_TO
46727: IFFALSE 46774
// begin hc_class = 13 ;
46729: LD_ADDR_OWVAR 28
46733: PUSH
46734: LD_INT 13
46736: ST_TO_ADDR
// hc_gallery =  ;
46737: LD_ADDR_OWVAR 33
46741: PUSH
46742: LD_STRING 
46744: ST_TO_ADDR
// animal := CreateHuman ;
46745: LD_ADDR_VAR 0 12
46749: PUSH
46750: CALL_OW 44
46754: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46755: LD_VAR 0 12
46759: PPUSH
46760: LD_VAR 0 8
46764: PPUSH
46765: LD_INT 0
46767: PPUSH
46768: CALL 48417 0 3
// end ;
46772: GO 46726
46774: POP
46775: POP
// if fishes then
46776: LD_VAR 0 7
46780: IFFALSE 46847
// for i = 1 to fishes do
46782: LD_ADDR_VAR 0 11
46786: PUSH
46787: DOUBLE
46788: LD_INT 1
46790: DEC
46791: ST_TO_ADDR
46792: LD_VAR 0 7
46796: PUSH
46797: FOR_TO
46798: IFFALSE 46845
// begin hc_class = 20 ;
46800: LD_ADDR_OWVAR 28
46804: PUSH
46805: LD_INT 20
46807: ST_TO_ADDR
// hc_gallery =  ;
46808: LD_ADDR_OWVAR 33
46812: PUSH
46813: LD_STRING 
46815: ST_TO_ADDR
// animal := CreateHuman ;
46816: LD_ADDR_VAR 0 12
46820: PUSH
46821: CALL_OW 44
46825: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46826: LD_VAR 0 12
46830: PPUSH
46831: LD_VAR 0 9
46835: PPUSH
46836: LD_INT 0
46838: PPUSH
46839: CALL 48417 0 3
// end ;
46843: GO 46797
46845: POP
46846: POP
// end ;
46847: LD_VAR 0 10
46851: RET
// export function WantHeal ( sci , unit ) ; begin
46852: LD_INT 0
46854: PPUSH
// if GetTaskList ( sci ) > 0 then
46855: LD_VAR 0 1
46859: PPUSH
46860: CALL_OW 437
46864: PUSH
46865: LD_INT 0
46867: GREATER
46868: IFFALSE 46938
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46870: LD_VAR 0 1
46874: PPUSH
46875: CALL_OW 437
46879: PUSH
46880: LD_INT 1
46882: ARRAY
46883: PUSH
46884: LD_INT 1
46886: ARRAY
46887: PUSH
46888: LD_STRING l
46890: EQUAL
46891: PUSH
46892: LD_VAR 0 1
46896: PPUSH
46897: CALL_OW 437
46901: PUSH
46902: LD_INT 1
46904: ARRAY
46905: PUSH
46906: LD_INT 4
46908: ARRAY
46909: PUSH
46910: LD_VAR 0 2
46914: EQUAL
46915: AND
46916: IFFALSE 46928
// result := true else
46918: LD_ADDR_VAR 0 3
46922: PUSH
46923: LD_INT 1
46925: ST_TO_ADDR
46926: GO 46936
// result := false ;
46928: LD_ADDR_VAR 0 3
46932: PUSH
46933: LD_INT 0
46935: ST_TO_ADDR
// end else
46936: GO 46946
// result := false ;
46938: LD_ADDR_VAR 0 3
46942: PUSH
46943: LD_INT 0
46945: ST_TO_ADDR
// end ;
46946: LD_VAR 0 3
46950: RET
// export function HealTarget ( sci ) ; begin
46951: LD_INT 0
46953: PPUSH
// if not sci then
46954: LD_VAR 0 1
46958: NOT
46959: IFFALSE 46963
// exit ;
46961: GO 47028
// result := 0 ;
46963: LD_ADDR_VAR 0 2
46967: PUSH
46968: LD_INT 0
46970: ST_TO_ADDR
// if GetTaskList ( sci ) then
46971: LD_VAR 0 1
46975: PPUSH
46976: CALL_OW 437
46980: IFFALSE 47028
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46982: LD_VAR 0 1
46986: PPUSH
46987: CALL_OW 437
46991: PUSH
46992: LD_INT 1
46994: ARRAY
46995: PUSH
46996: LD_INT 1
46998: ARRAY
46999: PUSH
47000: LD_STRING l
47002: EQUAL
47003: IFFALSE 47028
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47005: LD_ADDR_VAR 0 2
47009: PUSH
47010: LD_VAR 0 1
47014: PPUSH
47015: CALL_OW 437
47019: PUSH
47020: LD_INT 1
47022: ARRAY
47023: PUSH
47024: LD_INT 4
47026: ARRAY
47027: ST_TO_ADDR
// end ;
47028: LD_VAR 0 2
47032: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47033: LD_INT 0
47035: PPUSH
47036: PPUSH
47037: PPUSH
47038: PPUSH
// if not base_units then
47039: LD_VAR 0 1
47043: NOT
47044: IFFALSE 47048
// exit ;
47046: GO 47135
// result := false ;
47048: LD_ADDR_VAR 0 2
47052: PUSH
47053: LD_INT 0
47055: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47056: LD_ADDR_VAR 0 5
47060: PUSH
47061: LD_VAR 0 1
47065: PPUSH
47066: LD_INT 21
47068: PUSH
47069: LD_INT 3
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PPUSH
47076: CALL_OW 72
47080: ST_TO_ADDR
// if not tmp then
47081: LD_VAR 0 5
47085: NOT
47086: IFFALSE 47090
// exit ;
47088: GO 47135
// for i in tmp do
47090: LD_ADDR_VAR 0 3
47094: PUSH
47095: LD_VAR 0 5
47099: PUSH
47100: FOR_IN
47101: IFFALSE 47133
// begin result := EnemyInRange ( i , 22 ) ;
47103: LD_ADDR_VAR 0 2
47107: PUSH
47108: LD_VAR 0 3
47112: PPUSH
47113: LD_INT 22
47115: PPUSH
47116: CALL 45371 0 2
47120: ST_TO_ADDR
// if result then
47121: LD_VAR 0 2
47125: IFFALSE 47131
// exit ;
47127: POP
47128: POP
47129: GO 47135
// end ;
47131: GO 47100
47133: POP
47134: POP
// end ;
47135: LD_VAR 0 2
47139: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47140: LD_INT 0
47142: PPUSH
47143: PPUSH
// if not units then
47144: LD_VAR 0 1
47148: NOT
47149: IFFALSE 47153
// exit ;
47151: GO 47223
// result := [ ] ;
47153: LD_ADDR_VAR 0 3
47157: PUSH
47158: EMPTY
47159: ST_TO_ADDR
// for i in units do
47160: LD_ADDR_VAR 0 4
47164: PUSH
47165: LD_VAR 0 1
47169: PUSH
47170: FOR_IN
47171: IFFALSE 47221
// if GetTag ( i ) = tag then
47173: LD_VAR 0 4
47177: PPUSH
47178: CALL_OW 110
47182: PUSH
47183: LD_VAR 0 2
47187: EQUAL
47188: IFFALSE 47219
// result := Insert ( result , result + 1 , i ) ;
47190: LD_ADDR_VAR 0 3
47194: PUSH
47195: LD_VAR 0 3
47199: PPUSH
47200: LD_VAR 0 3
47204: PUSH
47205: LD_INT 1
47207: PLUS
47208: PPUSH
47209: LD_VAR 0 4
47213: PPUSH
47214: CALL_OW 2
47218: ST_TO_ADDR
47219: GO 47170
47221: POP
47222: POP
// end ;
47223: LD_VAR 0 3
47227: RET
// export function IsDriver ( un ) ; begin
47228: LD_INT 0
47230: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47231: LD_ADDR_VAR 0 2
47235: PUSH
47236: LD_VAR 0 1
47240: PUSH
47241: LD_INT 55
47243: PUSH
47244: EMPTY
47245: LIST
47246: PPUSH
47247: CALL_OW 69
47251: IN
47252: ST_TO_ADDR
// end ;
47253: LD_VAR 0 2
47257: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47258: LD_INT 0
47260: PPUSH
47261: PPUSH
// list := [ ] ;
47262: LD_ADDR_VAR 0 5
47266: PUSH
47267: EMPTY
47268: ST_TO_ADDR
// case d of 0 :
47269: LD_VAR 0 3
47273: PUSH
47274: LD_INT 0
47276: DOUBLE
47277: EQUAL
47278: IFTRUE 47282
47280: GO 47415
47282: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47283: LD_ADDR_VAR 0 5
47287: PUSH
47288: LD_VAR 0 1
47292: PUSH
47293: LD_INT 4
47295: MINUS
47296: PUSH
47297: LD_VAR 0 2
47301: PUSH
47302: LD_INT 4
47304: MINUS
47305: PUSH
47306: LD_INT 2
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: LIST
47313: PUSH
47314: LD_VAR 0 1
47318: PUSH
47319: LD_INT 3
47321: MINUS
47322: PUSH
47323: LD_VAR 0 2
47327: PUSH
47328: LD_INT 1
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: LIST
47335: PUSH
47336: LD_VAR 0 1
47340: PUSH
47341: LD_INT 4
47343: PLUS
47344: PUSH
47345: LD_VAR 0 2
47349: PUSH
47350: LD_INT 4
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: LIST
47357: PUSH
47358: LD_VAR 0 1
47362: PUSH
47363: LD_INT 3
47365: PLUS
47366: PUSH
47367: LD_VAR 0 2
47371: PUSH
47372: LD_INT 3
47374: PLUS
47375: PUSH
47376: LD_INT 5
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: LIST
47383: PUSH
47384: LD_VAR 0 1
47388: PUSH
47389: LD_VAR 0 2
47393: PUSH
47394: LD_INT 4
47396: PLUS
47397: PUSH
47398: LD_INT 0
47400: PUSH
47401: EMPTY
47402: LIST
47403: LIST
47404: LIST
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: ST_TO_ADDR
// end ; 1 :
47413: GO 48113
47415: LD_INT 1
47417: DOUBLE
47418: EQUAL
47419: IFTRUE 47423
47421: GO 47556
47423: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47424: LD_ADDR_VAR 0 5
47428: PUSH
47429: LD_VAR 0 1
47433: PUSH
47434: LD_VAR 0 2
47438: PUSH
47439: LD_INT 4
47441: MINUS
47442: PUSH
47443: LD_INT 3
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: LIST
47450: PUSH
47451: LD_VAR 0 1
47455: PUSH
47456: LD_INT 3
47458: MINUS
47459: PUSH
47460: LD_VAR 0 2
47464: PUSH
47465: LD_INT 3
47467: MINUS
47468: PUSH
47469: LD_INT 2
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: LIST
47476: PUSH
47477: LD_VAR 0 1
47481: PUSH
47482: LD_INT 4
47484: MINUS
47485: PUSH
47486: LD_VAR 0 2
47490: PUSH
47491: LD_INT 1
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: LIST
47498: PUSH
47499: LD_VAR 0 1
47503: PUSH
47504: LD_VAR 0 2
47508: PUSH
47509: LD_INT 3
47511: PLUS
47512: PUSH
47513: LD_INT 0
47515: PUSH
47516: EMPTY
47517: LIST
47518: LIST
47519: LIST
47520: PUSH
47521: LD_VAR 0 1
47525: PUSH
47526: LD_INT 4
47528: PLUS
47529: PUSH
47530: LD_VAR 0 2
47534: PUSH
47535: LD_INT 4
47537: PLUS
47538: PUSH
47539: LD_INT 5
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: LIST
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: ST_TO_ADDR
// end ; 2 :
47554: GO 48113
47556: LD_INT 2
47558: DOUBLE
47559: EQUAL
47560: IFTRUE 47564
47562: GO 47693
47564: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47565: LD_ADDR_VAR 0 5
47569: PUSH
47570: LD_VAR 0 1
47574: PUSH
47575: LD_VAR 0 2
47579: PUSH
47580: LD_INT 3
47582: MINUS
47583: PUSH
47584: LD_INT 3
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: LIST
47591: PUSH
47592: LD_VAR 0 1
47596: PUSH
47597: LD_INT 4
47599: PLUS
47600: PUSH
47601: LD_VAR 0 2
47605: PUSH
47606: LD_INT 4
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: LIST
47613: PUSH
47614: LD_VAR 0 1
47618: PUSH
47619: LD_VAR 0 2
47623: PUSH
47624: LD_INT 4
47626: PLUS
47627: PUSH
47628: LD_INT 0
47630: PUSH
47631: EMPTY
47632: LIST
47633: LIST
47634: LIST
47635: PUSH
47636: LD_VAR 0 1
47640: PUSH
47641: LD_INT 3
47643: MINUS
47644: PUSH
47645: LD_VAR 0 2
47649: PUSH
47650: LD_INT 1
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: LIST
47657: PUSH
47658: LD_VAR 0 1
47662: PUSH
47663: LD_INT 4
47665: MINUS
47666: PUSH
47667: LD_VAR 0 2
47671: PUSH
47672: LD_INT 4
47674: MINUS
47675: PUSH
47676: LD_INT 2
47678: PUSH
47679: EMPTY
47680: LIST
47681: LIST
47682: LIST
47683: PUSH
47684: EMPTY
47685: LIST
47686: LIST
47687: LIST
47688: LIST
47689: LIST
47690: ST_TO_ADDR
// end ; 3 :
47691: GO 48113
47693: LD_INT 3
47695: DOUBLE
47696: EQUAL
47697: IFTRUE 47701
47699: GO 47834
47701: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47702: LD_ADDR_VAR 0 5
47706: PUSH
47707: LD_VAR 0 1
47711: PUSH
47712: LD_INT 3
47714: PLUS
47715: PUSH
47716: LD_VAR 0 2
47720: PUSH
47721: LD_INT 4
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: LIST
47728: PUSH
47729: LD_VAR 0 1
47733: PUSH
47734: LD_INT 4
47736: PLUS
47737: PUSH
47738: LD_VAR 0 2
47742: PUSH
47743: LD_INT 4
47745: PLUS
47746: PUSH
47747: LD_INT 5
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: LIST
47754: PUSH
47755: LD_VAR 0 1
47759: PUSH
47760: LD_INT 4
47762: MINUS
47763: PUSH
47764: LD_VAR 0 2
47768: PUSH
47769: LD_INT 1
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: LIST
47776: PUSH
47777: LD_VAR 0 1
47781: PUSH
47782: LD_VAR 0 2
47786: PUSH
47787: LD_INT 4
47789: MINUS
47790: PUSH
47791: LD_INT 3
47793: PUSH
47794: EMPTY
47795: LIST
47796: LIST
47797: LIST
47798: PUSH
47799: LD_VAR 0 1
47803: PUSH
47804: LD_INT 3
47806: MINUS
47807: PUSH
47808: LD_VAR 0 2
47812: PUSH
47813: LD_INT 3
47815: MINUS
47816: PUSH
47817: LD_INT 2
47819: PUSH
47820: EMPTY
47821: LIST
47822: LIST
47823: LIST
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: ST_TO_ADDR
// end ; 4 :
47832: GO 48113
47834: LD_INT 4
47836: DOUBLE
47837: EQUAL
47838: IFTRUE 47842
47840: GO 47975
47842: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47843: LD_ADDR_VAR 0 5
47847: PUSH
47848: LD_VAR 0 1
47852: PUSH
47853: LD_VAR 0 2
47857: PUSH
47858: LD_INT 4
47860: PLUS
47861: PUSH
47862: LD_INT 0
47864: PUSH
47865: EMPTY
47866: LIST
47867: LIST
47868: LIST
47869: PUSH
47870: LD_VAR 0 1
47874: PUSH
47875: LD_INT 3
47877: PLUS
47878: PUSH
47879: LD_VAR 0 2
47883: PUSH
47884: LD_INT 3
47886: PLUS
47887: PUSH
47888: LD_INT 5
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: LIST
47895: PUSH
47896: LD_VAR 0 1
47900: PUSH
47901: LD_INT 4
47903: PLUS
47904: PUSH
47905: LD_VAR 0 2
47909: PUSH
47910: LD_INT 4
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: LIST
47917: PUSH
47918: LD_VAR 0 1
47922: PUSH
47923: LD_VAR 0 2
47927: PUSH
47928: LD_INT 3
47930: MINUS
47931: PUSH
47932: LD_INT 3
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: LIST
47939: PUSH
47940: LD_VAR 0 1
47944: PUSH
47945: LD_INT 4
47947: MINUS
47948: PUSH
47949: LD_VAR 0 2
47953: PUSH
47954: LD_INT 4
47956: MINUS
47957: PUSH
47958: LD_INT 2
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: LIST
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: ST_TO_ADDR
// end ; 5 :
47973: GO 48113
47975: LD_INT 5
47977: DOUBLE
47978: EQUAL
47979: IFTRUE 47983
47981: GO 48112
47983: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47984: LD_ADDR_VAR 0 5
47988: PUSH
47989: LD_VAR 0 1
47993: PUSH
47994: LD_INT 4
47996: MINUS
47997: PUSH
47998: LD_VAR 0 2
48002: PUSH
48003: LD_INT 1
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: LIST
48010: PUSH
48011: LD_VAR 0 1
48015: PUSH
48016: LD_VAR 0 2
48020: PUSH
48021: LD_INT 4
48023: MINUS
48024: PUSH
48025: LD_INT 3
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: LIST
48032: PUSH
48033: LD_VAR 0 1
48037: PUSH
48038: LD_INT 4
48040: PLUS
48041: PUSH
48042: LD_VAR 0 2
48046: PUSH
48047: LD_INT 4
48049: PLUS
48050: PUSH
48051: LD_INT 5
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: LIST
48058: PUSH
48059: LD_VAR 0 1
48063: PUSH
48064: LD_INT 3
48066: PLUS
48067: PUSH
48068: LD_VAR 0 2
48072: PUSH
48073: LD_INT 4
48075: PUSH
48076: EMPTY
48077: LIST
48078: LIST
48079: LIST
48080: PUSH
48081: LD_VAR 0 1
48085: PUSH
48086: LD_VAR 0 2
48090: PUSH
48091: LD_INT 3
48093: PLUS
48094: PUSH
48095: LD_INT 0
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: LIST
48102: PUSH
48103: EMPTY
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: LIST
48109: ST_TO_ADDR
// end ; end ;
48110: GO 48113
48112: POP
// result := list ;
48113: LD_ADDR_VAR 0 4
48117: PUSH
48118: LD_VAR 0 5
48122: ST_TO_ADDR
// end ;
48123: LD_VAR 0 4
48127: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48128: LD_INT 0
48130: PPUSH
48131: PPUSH
48132: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48133: LD_VAR 0 1
48137: NOT
48138: PUSH
48139: LD_VAR 0 2
48143: PUSH
48144: LD_INT 1
48146: PUSH
48147: LD_INT 2
48149: PUSH
48150: LD_INT 3
48152: PUSH
48153: LD_INT 4
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: IN
48162: NOT
48163: OR
48164: IFFALSE 48168
// exit ;
48166: GO 48260
// tmp := [ ] ;
48168: LD_ADDR_VAR 0 5
48172: PUSH
48173: EMPTY
48174: ST_TO_ADDR
// for i in units do
48175: LD_ADDR_VAR 0 4
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: FOR_IN
48186: IFFALSE 48229
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48188: LD_ADDR_VAR 0 5
48192: PUSH
48193: LD_VAR 0 5
48197: PPUSH
48198: LD_VAR 0 5
48202: PUSH
48203: LD_INT 1
48205: PLUS
48206: PPUSH
48207: LD_VAR 0 4
48211: PPUSH
48212: LD_VAR 0 2
48216: PPUSH
48217: CALL_OW 259
48221: PPUSH
48222: CALL_OW 2
48226: ST_TO_ADDR
48227: GO 48185
48229: POP
48230: POP
// if not tmp then
48231: LD_VAR 0 5
48235: NOT
48236: IFFALSE 48240
// exit ;
48238: GO 48260
// result := SortListByListDesc ( units , tmp ) ;
48240: LD_ADDR_VAR 0 3
48244: PUSH
48245: LD_VAR 0 1
48249: PPUSH
48250: LD_VAR 0 5
48254: PPUSH
48255: CALL_OW 77
48259: ST_TO_ADDR
// end ;
48260: LD_VAR 0 3
48264: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48265: LD_INT 0
48267: PPUSH
48268: PPUSH
48269: PPUSH
// x := GetX ( building ) ;
48270: LD_ADDR_VAR 0 4
48274: PUSH
48275: LD_VAR 0 2
48279: PPUSH
48280: CALL_OW 250
48284: ST_TO_ADDR
// y := GetY ( building ) ;
48285: LD_ADDR_VAR 0 5
48289: PUSH
48290: LD_VAR 0 2
48294: PPUSH
48295: CALL_OW 251
48299: ST_TO_ADDR
// if GetTaskList ( unit ) then
48300: LD_VAR 0 1
48304: PPUSH
48305: CALL_OW 437
48309: IFFALSE 48404
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48311: LD_STRING e
48313: PUSH
48314: LD_VAR 0 1
48318: PPUSH
48319: CALL_OW 437
48323: PUSH
48324: LD_INT 1
48326: ARRAY
48327: PUSH
48328: LD_INT 1
48330: ARRAY
48331: EQUAL
48332: PUSH
48333: LD_VAR 0 4
48337: PUSH
48338: LD_VAR 0 1
48342: PPUSH
48343: CALL_OW 437
48347: PUSH
48348: LD_INT 1
48350: ARRAY
48351: PUSH
48352: LD_INT 2
48354: ARRAY
48355: EQUAL
48356: AND
48357: PUSH
48358: LD_VAR 0 5
48362: PUSH
48363: LD_VAR 0 1
48367: PPUSH
48368: CALL_OW 437
48372: PUSH
48373: LD_INT 1
48375: ARRAY
48376: PUSH
48377: LD_INT 3
48379: ARRAY
48380: EQUAL
48381: AND
48382: IFFALSE 48394
// result := true else
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_INT 1
48391: ST_TO_ADDR
48392: GO 48402
// result := false ;
48394: LD_ADDR_VAR 0 3
48398: PUSH
48399: LD_INT 0
48401: ST_TO_ADDR
// end else
48402: GO 48412
// result := false ;
48404: LD_ADDR_VAR 0 3
48408: PUSH
48409: LD_INT 0
48411: ST_TO_ADDR
// end ;
48412: LD_VAR 0 3
48416: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48417: LD_INT 0
48419: PPUSH
48420: PPUSH
48421: PPUSH
48422: PPUSH
// if not unit or not area then
48423: LD_VAR 0 1
48427: NOT
48428: PUSH
48429: LD_VAR 0 2
48433: NOT
48434: OR
48435: IFFALSE 48439
// exit ;
48437: GO 48603
// tmp := AreaToList ( area , i ) ;
48439: LD_ADDR_VAR 0 6
48443: PUSH
48444: LD_VAR 0 2
48448: PPUSH
48449: LD_VAR 0 5
48453: PPUSH
48454: CALL_OW 517
48458: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48459: LD_ADDR_VAR 0 5
48463: PUSH
48464: DOUBLE
48465: LD_INT 1
48467: DEC
48468: ST_TO_ADDR
48469: LD_VAR 0 6
48473: PUSH
48474: LD_INT 1
48476: ARRAY
48477: PUSH
48478: FOR_TO
48479: IFFALSE 48601
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48481: LD_ADDR_VAR 0 7
48485: PUSH
48486: LD_VAR 0 6
48490: PUSH
48491: LD_INT 1
48493: ARRAY
48494: PUSH
48495: LD_VAR 0 5
48499: ARRAY
48500: PUSH
48501: LD_VAR 0 6
48505: PUSH
48506: LD_INT 2
48508: ARRAY
48509: PUSH
48510: LD_VAR 0 5
48514: ARRAY
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
48520: LD_VAR 0 7
48524: PUSH
48525: LD_INT 1
48527: ARRAY
48528: PPUSH
48529: LD_VAR 0 7
48533: PUSH
48534: LD_INT 2
48536: ARRAY
48537: PPUSH
48538: CALL_OW 428
48542: PUSH
48543: LD_INT 0
48545: EQUAL
48546: IFFALSE 48599
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48548: LD_VAR 0 1
48552: PPUSH
48553: LD_VAR 0 7
48557: PUSH
48558: LD_INT 1
48560: ARRAY
48561: PPUSH
48562: LD_VAR 0 7
48566: PUSH
48567: LD_INT 2
48569: ARRAY
48570: PPUSH
48571: LD_VAR 0 3
48575: PPUSH
48576: CALL_OW 48
// result := IsPlaced ( unit ) ;
48580: LD_ADDR_VAR 0 4
48584: PUSH
48585: LD_VAR 0 1
48589: PPUSH
48590: CALL_OW 305
48594: ST_TO_ADDR
// exit ;
48595: POP
48596: POP
48597: GO 48603
// end ; end ;
48599: GO 48478
48601: POP
48602: POP
// end ;
48603: LD_VAR 0 4
48607: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
// if not side or side > 8 then
48613: LD_VAR 0 1
48617: NOT
48618: PUSH
48619: LD_VAR 0 1
48623: PUSH
48624: LD_INT 8
48626: GREATER
48627: OR
48628: IFFALSE 48632
// exit ;
48630: GO 48819
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48632: LD_ADDR_VAR 0 4
48636: PUSH
48637: LD_INT 22
48639: PUSH
48640: LD_VAR 0 1
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 21
48651: PUSH
48652: LD_INT 3
48654: PUSH
48655: EMPTY
48656: LIST
48657: LIST
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PPUSH
48663: CALL_OW 69
48667: ST_TO_ADDR
// if not tmp then
48668: LD_VAR 0 4
48672: NOT
48673: IFFALSE 48677
// exit ;
48675: GO 48819
// enable_addtolog := true ;
48677: LD_ADDR_OWVAR 81
48681: PUSH
48682: LD_INT 1
48684: ST_TO_ADDR
// AddToLog ( [ ) ;
48685: LD_STRING [
48687: PPUSH
48688: CALL_OW 561
// for i in tmp do
48692: LD_ADDR_VAR 0 3
48696: PUSH
48697: LD_VAR 0 4
48701: PUSH
48702: FOR_IN
48703: IFFALSE 48810
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48705: LD_STRING [
48707: PUSH
48708: LD_VAR 0 3
48712: PPUSH
48713: CALL_OW 266
48717: STR
48718: PUSH
48719: LD_STRING , 
48721: STR
48722: PUSH
48723: LD_VAR 0 3
48727: PPUSH
48728: CALL_OW 250
48732: STR
48733: PUSH
48734: LD_STRING , 
48736: STR
48737: PUSH
48738: LD_VAR 0 3
48742: PPUSH
48743: CALL_OW 251
48747: STR
48748: PUSH
48749: LD_STRING , 
48751: STR
48752: PUSH
48753: LD_VAR 0 3
48757: PPUSH
48758: CALL_OW 254
48762: STR
48763: PUSH
48764: LD_STRING , 
48766: STR
48767: PUSH
48768: LD_VAR 0 3
48772: PPUSH
48773: LD_INT 1
48775: PPUSH
48776: CALL_OW 268
48780: STR
48781: PUSH
48782: LD_STRING , 
48784: STR
48785: PUSH
48786: LD_VAR 0 3
48790: PPUSH
48791: LD_INT 2
48793: PPUSH
48794: CALL_OW 268
48798: STR
48799: PUSH
48800: LD_STRING ],
48802: STR
48803: PPUSH
48804: CALL_OW 561
// end ;
48808: GO 48702
48810: POP
48811: POP
// AddToLog ( ]; ) ;
48812: LD_STRING ];
48814: PPUSH
48815: CALL_OW 561
// end ;
48819: LD_VAR 0 2
48823: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48824: LD_INT 0
48826: PPUSH
48827: PPUSH
48828: PPUSH
48829: PPUSH
48830: PPUSH
// if not area or not rate or not max then
48831: LD_VAR 0 1
48835: NOT
48836: PUSH
48837: LD_VAR 0 2
48841: NOT
48842: OR
48843: PUSH
48844: LD_VAR 0 4
48848: NOT
48849: OR
48850: IFFALSE 48854
// exit ;
48852: GO 49046
// while 1 do
48854: LD_INT 1
48856: IFFALSE 49046
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48858: LD_ADDR_VAR 0 9
48862: PUSH
48863: LD_VAR 0 1
48867: PPUSH
48868: LD_INT 1
48870: PPUSH
48871: CALL_OW 287
48875: PUSH
48876: LD_INT 10
48878: MUL
48879: ST_TO_ADDR
// r := rate / 10 ;
48880: LD_ADDR_VAR 0 7
48884: PUSH
48885: LD_VAR 0 2
48889: PUSH
48890: LD_INT 10
48892: DIVREAL
48893: ST_TO_ADDR
// time := 1 1$00 ;
48894: LD_ADDR_VAR 0 8
48898: PUSH
48899: LD_INT 2100
48901: ST_TO_ADDR
// if amount < min then
48902: LD_VAR 0 9
48906: PUSH
48907: LD_VAR 0 3
48911: LESS
48912: IFFALSE 48930
// r := r * 2 else
48914: LD_ADDR_VAR 0 7
48918: PUSH
48919: LD_VAR 0 7
48923: PUSH
48924: LD_INT 2
48926: MUL
48927: ST_TO_ADDR
48928: GO 48956
// if amount > max then
48930: LD_VAR 0 9
48934: PUSH
48935: LD_VAR 0 4
48939: GREATER
48940: IFFALSE 48956
// r := r / 2 ;
48942: LD_ADDR_VAR 0 7
48946: PUSH
48947: LD_VAR 0 7
48951: PUSH
48952: LD_INT 2
48954: DIVREAL
48955: ST_TO_ADDR
// time := time / r ;
48956: LD_ADDR_VAR 0 8
48960: PUSH
48961: LD_VAR 0 8
48965: PUSH
48966: LD_VAR 0 7
48970: DIVREAL
48971: ST_TO_ADDR
// if time < 0 then
48972: LD_VAR 0 8
48976: PUSH
48977: LD_INT 0
48979: LESS
48980: IFFALSE 48997
// time := time * - 1 ;
48982: LD_ADDR_VAR 0 8
48986: PUSH
48987: LD_VAR 0 8
48991: PUSH
48992: LD_INT 1
48994: NEG
48995: MUL
48996: ST_TO_ADDR
// wait ( time ) ;
48997: LD_VAR 0 8
49001: PPUSH
49002: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49006: LD_INT 35
49008: PPUSH
49009: LD_INT 875
49011: PPUSH
49012: CALL_OW 12
49016: PPUSH
49017: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49021: LD_INT 1
49023: PPUSH
49024: LD_INT 5
49026: PPUSH
49027: CALL_OW 12
49031: PPUSH
49032: LD_VAR 0 1
49036: PPUSH
49037: LD_INT 1
49039: PPUSH
49040: CALL_OW 55
// end ;
49044: GO 48854
// end ;
49046: LD_VAR 0 5
49050: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49051: LD_INT 0
49053: PPUSH
49054: PPUSH
49055: PPUSH
49056: PPUSH
49057: PPUSH
49058: PPUSH
49059: PPUSH
49060: PPUSH
// if not turrets or not factories then
49061: LD_VAR 0 1
49065: NOT
49066: PUSH
49067: LD_VAR 0 2
49071: NOT
49072: OR
49073: IFFALSE 49077
// exit ;
49075: GO 49384
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49077: LD_ADDR_VAR 0 10
49081: PUSH
49082: LD_INT 5
49084: PUSH
49085: LD_INT 6
49087: PUSH
49088: EMPTY
49089: LIST
49090: LIST
49091: PUSH
49092: LD_INT 2
49094: PUSH
49095: LD_INT 4
49097: PUSH
49098: EMPTY
49099: LIST
49100: LIST
49101: PUSH
49102: LD_INT 3
49104: PUSH
49105: LD_INT 5
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PUSH
49112: EMPTY
49113: LIST
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 24
49119: PUSH
49120: LD_INT 25
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 23
49129: PUSH
49130: LD_INT 27
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: LD_INT 42
49143: PUSH
49144: LD_INT 43
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 44
49153: PUSH
49154: LD_INT 46
49156: PUSH
49157: EMPTY
49158: LIST
49159: LIST
49160: PUSH
49161: LD_INT 45
49163: PUSH
49164: LD_INT 47
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: PUSH
49171: EMPTY
49172: LIST
49173: LIST
49174: LIST
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: LIST
49180: ST_TO_ADDR
// result := [ ] ;
49181: LD_ADDR_VAR 0 3
49185: PUSH
49186: EMPTY
49187: ST_TO_ADDR
// for i in turrets do
49188: LD_ADDR_VAR 0 4
49192: PUSH
49193: LD_VAR 0 1
49197: PUSH
49198: FOR_IN
49199: IFFALSE 49382
// begin nat := GetNation ( i ) ;
49201: LD_ADDR_VAR 0 7
49205: PUSH
49206: LD_VAR 0 4
49210: PPUSH
49211: CALL_OW 248
49215: ST_TO_ADDR
// weapon := 0 ;
49216: LD_ADDR_VAR 0 8
49220: PUSH
49221: LD_INT 0
49223: ST_TO_ADDR
// if not nat then
49224: LD_VAR 0 7
49228: NOT
49229: IFFALSE 49233
// continue ;
49231: GO 49198
// for j in list [ nat ] do
49233: LD_ADDR_VAR 0 5
49237: PUSH
49238: LD_VAR 0 10
49242: PUSH
49243: LD_VAR 0 7
49247: ARRAY
49248: PUSH
49249: FOR_IN
49250: IFFALSE 49291
// if GetBWeapon ( i ) = j [ 1 ] then
49252: LD_VAR 0 4
49256: PPUSH
49257: CALL_OW 269
49261: PUSH
49262: LD_VAR 0 5
49266: PUSH
49267: LD_INT 1
49269: ARRAY
49270: EQUAL
49271: IFFALSE 49289
// begin weapon := j [ 2 ] ;
49273: LD_ADDR_VAR 0 8
49277: PUSH
49278: LD_VAR 0 5
49282: PUSH
49283: LD_INT 2
49285: ARRAY
49286: ST_TO_ADDR
// break ;
49287: GO 49291
// end ;
49289: GO 49249
49291: POP
49292: POP
// if not weapon then
49293: LD_VAR 0 8
49297: NOT
49298: IFFALSE 49302
// continue ;
49300: GO 49198
// for k in factories do
49302: LD_ADDR_VAR 0 6
49306: PUSH
49307: LD_VAR 0 2
49311: PUSH
49312: FOR_IN
49313: IFFALSE 49378
// begin weapons := AvailableWeaponList ( k ) ;
49315: LD_ADDR_VAR 0 9
49319: PUSH
49320: LD_VAR 0 6
49324: PPUSH
49325: CALL_OW 478
49329: ST_TO_ADDR
// if not weapons then
49330: LD_VAR 0 9
49334: NOT
49335: IFFALSE 49339
// continue ;
49337: GO 49312
// if weapon in weapons then
49339: LD_VAR 0 8
49343: PUSH
49344: LD_VAR 0 9
49348: IN
49349: IFFALSE 49376
// begin result := [ i , weapon ] ;
49351: LD_ADDR_VAR 0 3
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: LD_VAR 0 8
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: ST_TO_ADDR
// exit ;
49370: POP
49371: POP
49372: POP
49373: POP
49374: GO 49384
// end ; end ;
49376: GO 49312
49378: POP
49379: POP
// end ;
49380: GO 49198
49382: POP
49383: POP
// end ;
49384: LD_VAR 0 3
49388: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49389: LD_INT 0
49391: PPUSH
// if not side or side > 8 then
49392: LD_VAR 0 3
49396: NOT
49397: PUSH
49398: LD_VAR 0 3
49402: PUSH
49403: LD_INT 8
49405: GREATER
49406: OR
49407: IFFALSE 49411
// exit ;
49409: GO 49470
// if not range then
49411: LD_VAR 0 4
49415: NOT
49416: IFFALSE 49427
// range := - 12 ;
49418: LD_ADDR_VAR 0 4
49422: PUSH
49423: LD_INT 12
49425: NEG
49426: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49427: LD_VAR 0 1
49431: PPUSH
49432: LD_VAR 0 2
49436: PPUSH
49437: LD_VAR 0 3
49441: PPUSH
49442: LD_VAR 0 4
49446: PPUSH
49447: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49451: LD_VAR 0 1
49455: PPUSH
49456: LD_VAR 0 2
49460: PPUSH
49461: LD_VAR 0 3
49465: PPUSH
49466: CALL_OW 331
// end ;
49470: LD_VAR 0 5
49474: RET
// export function Video ( mode ) ; begin
49475: LD_INT 0
49477: PPUSH
// ingame_video = mode ;
49478: LD_ADDR_OWVAR 52
49482: PUSH
49483: LD_VAR 0 1
49487: ST_TO_ADDR
// interface_hidden = mode ;
49488: LD_ADDR_OWVAR 54
49492: PUSH
49493: LD_VAR 0 1
49497: ST_TO_ADDR
// end ;
49498: LD_VAR 0 2
49502: RET
// export function Join ( array , element ) ; begin
49503: LD_INT 0
49505: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49506: LD_ADDR_VAR 0 3
49510: PUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: LD_VAR 0 1
49520: PUSH
49521: LD_INT 1
49523: PLUS
49524: PPUSH
49525: LD_VAR 0 2
49529: PPUSH
49530: CALL_OW 1
49534: ST_TO_ADDR
// end ;
49535: LD_VAR 0 3
49539: RET
// export function JoinUnion ( array , element ) ; begin
49540: LD_INT 0
49542: PPUSH
// result := array union element ;
49543: LD_ADDR_VAR 0 3
49547: PUSH
49548: LD_VAR 0 1
49552: PUSH
49553: LD_VAR 0 2
49557: UNION
49558: ST_TO_ADDR
// end ;
49559: LD_VAR 0 3
49563: RET
// export function GetBehemoths ( side ) ; begin
49564: LD_INT 0
49566: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
49567: LD_ADDR_VAR 0 2
49571: PUSH
49572: LD_INT 22
49574: PUSH
49575: LD_VAR 0 1
49579: PUSH
49580: EMPTY
49581: LIST
49582: LIST
49583: PUSH
49584: LD_INT 31
49586: PUSH
49587: LD_INT 25
49589: PUSH
49590: EMPTY
49591: LIST
49592: LIST
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PPUSH
49598: CALL_OW 69
49602: ST_TO_ADDR
// end ;
49603: LD_VAR 0 2
49607: RET
// export function Shuffle ( array ) ; var i , index ; begin
49608: LD_INT 0
49610: PPUSH
49611: PPUSH
49612: PPUSH
// result := [ ] ;
49613: LD_ADDR_VAR 0 2
49617: PUSH
49618: EMPTY
49619: ST_TO_ADDR
// if not array then
49620: LD_VAR 0 1
49624: NOT
49625: IFFALSE 49629
// exit ;
49627: GO 49728
// Randomize ;
49629: CALL_OW 10
// for i = array downto 1 do
49633: LD_ADDR_VAR 0 3
49637: PUSH
49638: DOUBLE
49639: LD_VAR 0 1
49643: INC
49644: ST_TO_ADDR
49645: LD_INT 1
49647: PUSH
49648: FOR_DOWNTO
49649: IFFALSE 49726
// begin index := rand ( 1 , array ) ;
49651: LD_ADDR_VAR 0 4
49655: PUSH
49656: LD_INT 1
49658: PPUSH
49659: LD_VAR 0 1
49663: PPUSH
49664: CALL_OW 12
49668: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49669: LD_ADDR_VAR 0 2
49673: PUSH
49674: LD_VAR 0 2
49678: PPUSH
49679: LD_VAR 0 2
49683: PUSH
49684: LD_INT 1
49686: PLUS
49687: PPUSH
49688: LD_VAR 0 1
49692: PUSH
49693: LD_VAR 0 4
49697: ARRAY
49698: PPUSH
49699: CALL_OW 2
49703: ST_TO_ADDR
// array := Delete ( array , index ) ;
49704: LD_ADDR_VAR 0 1
49708: PUSH
49709: LD_VAR 0 1
49713: PPUSH
49714: LD_VAR 0 4
49718: PPUSH
49719: CALL_OW 3
49723: ST_TO_ADDR
// end ;
49724: GO 49648
49726: POP
49727: POP
// end ;
49728: LD_VAR 0 2
49732: RET
// export function GetBaseMaterials ( base ) ; begin
49733: LD_INT 0
49735: PPUSH
// result := [ 0 , 0 , 0 ] ;
49736: LD_ADDR_VAR 0 2
49740: PUSH
49741: LD_INT 0
49743: PUSH
49744: LD_INT 0
49746: PUSH
49747: LD_INT 0
49749: PUSH
49750: EMPTY
49751: LIST
49752: LIST
49753: LIST
49754: ST_TO_ADDR
// if not base then
49755: LD_VAR 0 1
49759: NOT
49760: IFFALSE 49764
// exit ;
49762: GO 49813
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49764: LD_ADDR_VAR 0 2
49768: PUSH
49769: LD_VAR 0 1
49773: PPUSH
49774: LD_INT 1
49776: PPUSH
49777: CALL_OW 275
49781: PUSH
49782: LD_VAR 0 1
49786: PPUSH
49787: LD_INT 2
49789: PPUSH
49790: CALL_OW 275
49794: PUSH
49795: LD_VAR 0 1
49799: PPUSH
49800: LD_INT 3
49802: PPUSH
49803: CALL_OW 275
49807: PUSH
49808: EMPTY
49809: LIST
49810: LIST
49811: LIST
49812: ST_TO_ADDR
// end ;
49813: LD_VAR 0 2
49817: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49818: LD_INT 0
49820: PPUSH
49821: PPUSH
// result := array ;
49822: LD_ADDR_VAR 0 3
49826: PUSH
49827: LD_VAR 0 1
49831: ST_TO_ADDR
// if size > 0 then
49832: LD_VAR 0 2
49836: PUSH
49837: LD_INT 0
49839: GREATER
49840: IFFALSE 49886
// for i := array downto size do
49842: LD_ADDR_VAR 0 4
49846: PUSH
49847: DOUBLE
49848: LD_VAR 0 1
49852: INC
49853: ST_TO_ADDR
49854: LD_VAR 0 2
49858: PUSH
49859: FOR_DOWNTO
49860: IFFALSE 49884
// result := Delete ( result , result ) ;
49862: LD_ADDR_VAR 0 3
49866: PUSH
49867: LD_VAR 0 3
49871: PPUSH
49872: LD_VAR 0 3
49876: PPUSH
49877: CALL_OW 3
49881: ST_TO_ADDR
49882: GO 49859
49884: POP
49885: POP
// end ;
49886: LD_VAR 0 3
49890: RET
// export function ComExit ( unit ) ; var tmp ; begin
49891: LD_INT 0
49893: PPUSH
49894: PPUSH
// if not IsInUnit ( unit ) then
49895: LD_VAR 0 1
49899: PPUSH
49900: CALL_OW 310
49904: NOT
49905: IFFALSE 49909
// exit ;
49907: GO 49969
// tmp := IsInUnit ( unit ) ;
49909: LD_ADDR_VAR 0 3
49913: PUSH
49914: LD_VAR 0 1
49918: PPUSH
49919: CALL_OW 310
49923: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49924: LD_VAR 0 3
49928: PPUSH
49929: CALL_OW 247
49933: PUSH
49934: LD_INT 2
49936: EQUAL
49937: IFFALSE 49950
// ComExitVehicle ( unit ) else
49939: LD_VAR 0 1
49943: PPUSH
49944: CALL_OW 121
49948: GO 49959
// ComExitBuilding ( unit ) ;
49950: LD_VAR 0 1
49954: PPUSH
49955: CALL_OW 122
// result := tmp ;
49959: LD_ADDR_VAR 0 2
49963: PUSH
49964: LD_VAR 0 3
49968: ST_TO_ADDR
// end ;
49969: LD_VAR 0 2
49973: RET
// export function ResetHc ; begin
49974: LD_INT 0
49976: PPUSH
// InitHc ;
49977: CALL_OW 19
// hc_importance := 0 ;
49981: LD_ADDR_OWVAR 32
49985: PUSH
49986: LD_INT 0
49988: ST_TO_ADDR
// end ;
49989: LD_VAR 0 1
49993: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49994: LD_INT 0
49996: PPUSH
49997: PPUSH
49998: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49999: LD_ADDR_VAR 0 6
50003: PUSH
50004: LD_VAR 0 1
50008: PUSH
50009: LD_VAR 0 3
50013: PLUS
50014: PUSH
50015: LD_INT 2
50017: DIV
50018: ST_TO_ADDR
// if _x < 0 then
50019: LD_VAR 0 6
50023: PUSH
50024: LD_INT 0
50026: LESS
50027: IFFALSE 50044
// _x := _x * - 1 ;
50029: LD_ADDR_VAR 0 6
50033: PUSH
50034: LD_VAR 0 6
50038: PUSH
50039: LD_INT 1
50041: NEG
50042: MUL
50043: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50044: LD_ADDR_VAR 0 7
50048: PUSH
50049: LD_VAR 0 2
50053: PUSH
50054: LD_VAR 0 4
50058: PLUS
50059: PUSH
50060: LD_INT 2
50062: DIV
50063: ST_TO_ADDR
// if _y < 0 then
50064: LD_VAR 0 7
50068: PUSH
50069: LD_INT 0
50071: LESS
50072: IFFALSE 50089
// _y := _y * - 1 ;
50074: LD_ADDR_VAR 0 7
50078: PUSH
50079: LD_VAR 0 7
50083: PUSH
50084: LD_INT 1
50086: NEG
50087: MUL
50088: ST_TO_ADDR
// result := [ _x , _y ] ;
50089: LD_ADDR_VAR 0 5
50093: PUSH
50094: LD_VAR 0 6
50098: PUSH
50099: LD_VAR 0 7
50103: PUSH
50104: EMPTY
50105: LIST
50106: LIST
50107: ST_TO_ADDR
// end ;
50108: LD_VAR 0 5
50112: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50113: LD_INT 0
50115: PPUSH
50116: PPUSH
50117: PPUSH
50118: PPUSH
// task := GetTaskList ( unit ) ;
50119: LD_ADDR_VAR 0 7
50123: PUSH
50124: LD_VAR 0 1
50128: PPUSH
50129: CALL_OW 437
50133: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50134: LD_VAR 0 7
50138: NOT
50139: PUSH
50140: LD_VAR 0 1
50144: PPUSH
50145: LD_VAR 0 2
50149: PPUSH
50150: CALL_OW 308
50154: NOT
50155: AND
50156: IFFALSE 50160
// exit ;
50158: GO 50278
// if IsInArea ( unit , area ) then
50160: LD_VAR 0 1
50164: PPUSH
50165: LD_VAR 0 2
50169: PPUSH
50170: CALL_OW 308
50174: IFFALSE 50192
// begin ComMoveToArea ( unit , goAway ) ;
50176: LD_VAR 0 1
50180: PPUSH
50181: LD_VAR 0 3
50185: PPUSH
50186: CALL_OW 113
// exit ;
50190: GO 50278
// end ; if task [ 1 ] [ 1 ] <> M then
50192: LD_VAR 0 7
50196: PUSH
50197: LD_INT 1
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PUSH
50205: LD_STRING M
50207: NONEQUAL
50208: IFFALSE 50212
// exit ;
50210: GO 50278
// x := task [ 1 ] [ 2 ] ;
50212: LD_ADDR_VAR 0 5
50216: PUSH
50217: LD_VAR 0 7
50221: PUSH
50222: LD_INT 1
50224: ARRAY
50225: PUSH
50226: LD_INT 2
50228: ARRAY
50229: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50230: LD_ADDR_VAR 0 6
50234: PUSH
50235: LD_VAR 0 7
50239: PUSH
50240: LD_INT 1
50242: ARRAY
50243: PUSH
50244: LD_INT 3
50246: ARRAY
50247: ST_TO_ADDR
// if InArea ( x , y , area ) then
50248: LD_VAR 0 5
50252: PPUSH
50253: LD_VAR 0 6
50257: PPUSH
50258: LD_VAR 0 2
50262: PPUSH
50263: CALL_OW 309
50267: IFFALSE 50278
// ComStop ( unit ) ;
50269: LD_VAR 0 1
50273: PPUSH
50274: CALL_OW 141
// end ; end_of_file
50278: LD_VAR 0 4
50282: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
50283: LD_INT 0
50285: PPUSH
// ar_crane := 88 ;
50286: LD_ADDR_EXP 54
50290: PUSH
50291: LD_INT 88
50293: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
50294: LD_ADDR_EXP 49
50298: PUSH
50299: LD_INT 89
50301: ST_TO_ADDR
// us_hack := 99 ;
50302: LD_ADDR_EXP 50
50306: PUSH
50307: LD_INT 99
50309: ST_TO_ADDR
// us_artillery := 97 ;
50310: LD_ADDR_EXP 51
50314: PUSH
50315: LD_INT 97
50317: ST_TO_ADDR
// ar_bio_bomb := 91 ;
50318: LD_ADDR_EXP 52
50322: PUSH
50323: LD_INT 91
50325: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
50326: LD_ADDR_EXP 53
50330: PUSH
50331: LD_INT 92
50333: ST_TO_ADDR
// ru_radar := 98 ;
50334: LD_ADDR_EXP 48
50338: PUSH
50339: LD_INT 98
50341: ST_TO_ADDR
// tech_Artillery := 80 ;
50342: LD_ADDR_EXP 55
50346: PUSH
50347: LD_INT 80
50349: ST_TO_ADDR
// tech_RadMat := 81 ;
50350: LD_ADDR_EXP 56
50354: PUSH
50355: LD_INT 81
50357: ST_TO_ADDR
// tech_BasicTools := 82 ;
50358: LD_ADDR_EXP 57
50362: PUSH
50363: LD_INT 82
50365: ST_TO_ADDR
// tech_Cargo := 83 ;
50366: LD_ADDR_EXP 58
50370: PUSH
50371: LD_INT 83
50373: ST_TO_ADDR
// tech_Track := 84 ;
50374: LD_ADDR_EXP 59
50378: PUSH
50379: LD_INT 84
50381: ST_TO_ADDR
// tech_Crane := 85 ;
50382: LD_ADDR_EXP 60
50386: PUSH
50387: LD_INT 85
50389: ST_TO_ADDR
// tech_Bulldozer := 86 ;
50390: LD_ADDR_EXP 61
50394: PUSH
50395: LD_INT 86
50397: ST_TO_ADDR
// tech_Hovercraft := 87 ;
50398: LD_ADDR_EXP 62
50402: PUSH
50403: LD_INT 87
50405: ST_TO_ADDR
// end ;
50406: LD_VAR 0 1
50410: RET
// every 1 do
50411: GO 50413
50413: DISABLE
// InitGlobalVariables ; end_of_file
50414: CALL 50283 0 0
50418: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50419: LD_INT 0
50421: PPUSH
50422: PPUSH
// skirmish := false ;
50423: LD_ADDR_EXP 63
50427: PUSH
50428: LD_INT 0
50430: ST_TO_ADDR
// debug_mc := false ;
50431: LD_ADDR_EXP 64
50435: PUSH
50436: LD_INT 0
50438: ST_TO_ADDR
// mc_bases := [ ] ;
50439: LD_ADDR_EXP 65
50443: PUSH
50444: EMPTY
50445: ST_TO_ADDR
// mc_sides := [ ] ;
50446: LD_ADDR_EXP 91
50450: PUSH
50451: EMPTY
50452: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50453: LD_ADDR_EXP 66
50457: PUSH
50458: EMPTY
50459: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50460: LD_ADDR_EXP 67
50464: PUSH
50465: EMPTY
50466: ST_TO_ADDR
// mc_need_heal := [ ] ;
50467: LD_ADDR_EXP 68
50471: PUSH
50472: EMPTY
50473: ST_TO_ADDR
// mc_healers := [ ] ;
50474: LD_ADDR_EXP 69
50478: PUSH
50479: EMPTY
50480: ST_TO_ADDR
// mc_build_list := [ ] ;
50481: LD_ADDR_EXP 70
50485: PUSH
50486: EMPTY
50487: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50488: LD_ADDR_EXP 97
50492: PUSH
50493: EMPTY
50494: ST_TO_ADDR
// mc_builders := [ ] ;
50495: LD_ADDR_EXP 71
50499: PUSH
50500: EMPTY
50501: ST_TO_ADDR
// mc_construct_list := [ ] ;
50502: LD_ADDR_EXP 72
50506: PUSH
50507: EMPTY
50508: ST_TO_ADDR
// mc_turret_list := [ ] ;
50509: LD_ADDR_EXP 73
50513: PUSH
50514: EMPTY
50515: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50516: LD_ADDR_EXP 74
50520: PUSH
50521: EMPTY
50522: ST_TO_ADDR
// mc_miners := [ ] ;
50523: LD_ADDR_EXP 79
50527: PUSH
50528: EMPTY
50529: ST_TO_ADDR
// mc_mines := [ ] ;
50530: LD_ADDR_EXP 78
50534: PUSH
50535: EMPTY
50536: ST_TO_ADDR
// mc_minefields := [ ] ;
50537: LD_ADDR_EXP 80
50541: PUSH
50542: EMPTY
50543: ST_TO_ADDR
// mc_crates := [ ] ;
50544: LD_ADDR_EXP 81
50548: PUSH
50549: EMPTY
50550: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50551: LD_ADDR_EXP 82
50555: PUSH
50556: EMPTY
50557: ST_TO_ADDR
// mc_crates_area := [ ] ;
50558: LD_ADDR_EXP 83
50562: PUSH
50563: EMPTY
50564: ST_TO_ADDR
// mc_vehicles := [ ] ;
50565: LD_ADDR_EXP 84
50569: PUSH
50570: EMPTY
50571: ST_TO_ADDR
// mc_attack := [ ] ;
50572: LD_ADDR_EXP 85
50576: PUSH
50577: EMPTY
50578: ST_TO_ADDR
// mc_produce := [ ] ;
50579: LD_ADDR_EXP 86
50583: PUSH
50584: EMPTY
50585: ST_TO_ADDR
// mc_defender := [ ] ;
50586: LD_ADDR_EXP 87
50590: PUSH
50591: EMPTY
50592: ST_TO_ADDR
// mc_parking := [ ] ;
50593: LD_ADDR_EXP 89
50597: PUSH
50598: EMPTY
50599: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50600: LD_ADDR_EXP 75
50604: PUSH
50605: EMPTY
50606: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50607: LD_ADDR_EXP 77
50611: PUSH
50612: EMPTY
50613: ST_TO_ADDR
// mc_scan := [ ] ;
50614: LD_ADDR_EXP 88
50618: PUSH
50619: EMPTY
50620: ST_TO_ADDR
// mc_scan_area := [ ] ;
50621: LD_ADDR_EXP 90
50625: PUSH
50626: EMPTY
50627: ST_TO_ADDR
// mc_tech := [ ] ;
50628: LD_ADDR_EXP 92
50632: PUSH
50633: EMPTY
50634: ST_TO_ADDR
// mc_class := [ ] ;
50635: LD_ADDR_EXP 106
50639: PUSH
50640: EMPTY
50641: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50642: LD_ADDR_EXP 107
50646: PUSH
50647: EMPTY
50648: ST_TO_ADDR
// end ;
50649: LD_VAR 0 1
50653: RET
// export function MC_Kill ( base ) ; begin
50654: LD_INT 0
50656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50657: LD_ADDR_EXP 65
50661: PUSH
50662: LD_EXP 65
50666: PPUSH
50667: LD_VAR 0 1
50671: PPUSH
50672: EMPTY
50673: PPUSH
50674: CALL_OW 1
50678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50679: LD_ADDR_EXP 66
50683: PUSH
50684: LD_EXP 66
50688: PPUSH
50689: LD_VAR 0 1
50693: PPUSH
50694: EMPTY
50695: PPUSH
50696: CALL_OW 1
50700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50701: LD_ADDR_EXP 67
50705: PUSH
50706: LD_EXP 67
50710: PPUSH
50711: LD_VAR 0 1
50715: PPUSH
50716: EMPTY
50717: PPUSH
50718: CALL_OW 1
50722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50723: LD_ADDR_EXP 68
50727: PUSH
50728: LD_EXP 68
50732: PPUSH
50733: LD_VAR 0 1
50737: PPUSH
50738: EMPTY
50739: PPUSH
50740: CALL_OW 1
50744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50745: LD_ADDR_EXP 69
50749: PUSH
50750: LD_EXP 69
50754: PPUSH
50755: LD_VAR 0 1
50759: PPUSH
50760: EMPTY
50761: PPUSH
50762: CALL_OW 1
50766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50767: LD_ADDR_EXP 70
50771: PUSH
50772: LD_EXP 70
50776: PPUSH
50777: LD_VAR 0 1
50781: PPUSH
50782: EMPTY
50783: PPUSH
50784: CALL_OW 1
50788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50789: LD_ADDR_EXP 71
50793: PUSH
50794: LD_EXP 71
50798: PPUSH
50799: LD_VAR 0 1
50803: PPUSH
50804: EMPTY
50805: PPUSH
50806: CALL_OW 1
50810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50811: LD_ADDR_EXP 72
50815: PUSH
50816: LD_EXP 72
50820: PPUSH
50821: LD_VAR 0 1
50825: PPUSH
50826: EMPTY
50827: PPUSH
50828: CALL_OW 1
50832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50833: LD_ADDR_EXP 73
50837: PUSH
50838: LD_EXP 73
50842: PPUSH
50843: LD_VAR 0 1
50847: PPUSH
50848: EMPTY
50849: PPUSH
50850: CALL_OW 1
50854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50855: LD_ADDR_EXP 74
50859: PUSH
50860: LD_EXP 74
50864: PPUSH
50865: LD_VAR 0 1
50869: PPUSH
50870: EMPTY
50871: PPUSH
50872: CALL_OW 1
50876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50877: LD_ADDR_EXP 75
50881: PUSH
50882: LD_EXP 75
50886: PPUSH
50887: LD_VAR 0 1
50891: PPUSH
50892: EMPTY
50893: PPUSH
50894: CALL_OW 1
50898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50899: LD_ADDR_EXP 76
50903: PUSH
50904: LD_EXP 76
50908: PPUSH
50909: LD_VAR 0 1
50913: PPUSH
50914: LD_INT 0
50916: PPUSH
50917: CALL_OW 1
50921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50922: LD_ADDR_EXP 77
50926: PUSH
50927: LD_EXP 77
50931: PPUSH
50932: LD_VAR 0 1
50936: PPUSH
50937: EMPTY
50938: PPUSH
50939: CALL_OW 1
50943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50944: LD_ADDR_EXP 78
50948: PUSH
50949: LD_EXP 78
50953: PPUSH
50954: LD_VAR 0 1
50958: PPUSH
50959: EMPTY
50960: PPUSH
50961: CALL_OW 1
50965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50966: LD_ADDR_EXP 79
50970: PUSH
50971: LD_EXP 79
50975: PPUSH
50976: LD_VAR 0 1
50980: PPUSH
50981: EMPTY
50982: PPUSH
50983: CALL_OW 1
50987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50988: LD_ADDR_EXP 80
50992: PUSH
50993: LD_EXP 80
50997: PPUSH
50998: LD_VAR 0 1
51002: PPUSH
51003: EMPTY
51004: PPUSH
51005: CALL_OW 1
51009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51010: LD_ADDR_EXP 81
51014: PUSH
51015: LD_EXP 81
51019: PPUSH
51020: LD_VAR 0 1
51024: PPUSH
51025: EMPTY
51026: PPUSH
51027: CALL_OW 1
51031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51032: LD_ADDR_EXP 82
51036: PUSH
51037: LD_EXP 82
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: EMPTY
51048: PPUSH
51049: CALL_OW 1
51053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51054: LD_ADDR_EXP 83
51058: PUSH
51059: LD_EXP 83
51063: PPUSH
51064: LD_VAR 0 1
51068: PPUSH
51069: EMPTY
51070: PPUSH
51071: CALL_OW 1
51075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51076: LD_ADDR_EXP 84
51080: PUSH
51081: LD_EXP 84
51085: PPUSH
51086: LD_VAR 0 1
51090: PPUSH
51091: EMPTY
51092: PPUSH
51093: CALL_OW 1
51097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51098: LD_ADDR_EXP 85
51102: PUSH
51103: LD_EXP 85
51107: PPUSH
51108: LD_VAR 0 1
51112: PPUSH
51113: EMPTY
51114: PPUSH
51115: CALL_OW 1
51119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51120: LD_ADDR_EXP 86
51124: PUSH
51125: LD_EXP 86
51129: PPUSH
51130: LD_VAR 0 1
51134: PPUSH
51135: EMPTY
51136: PPUSH
51137: CALL_OW 1
51141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51142: LD_ADDR_EXP 87
51146: PUSH
51147: LD_EXP 87
51151: PPUSH
51152: LD_VAR 0 1
51156: PPUSH
51157: EMPTY
51158: PPUSH
51159: CALL_OW 1
51163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51164: LD_ADDR_EXP 88
51168: PUSH
51169: LD_EXP 88
51173: PPUSH
51174: LD_VAR 0 1
51178: PPUSH
51179: EMPTY
51180: PPUSH
51181: CALL_OW 1
51185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51186: LD_ADDR_EXP 89
51190: PUSH
51191: LD_EXP 89
51195: PPUSH
51196: LD_VAR 0 1
51200: PPUSH
51201: EMPTY
51202: PPUSH
51203: CALL_OW 1
51207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51208: LD_ADDR_EXP 90
51212: PUSH
51213: LD_EXP 90
51217: PPUSH
51218: LD_VAR 0 1
51222: PPUSH
51223: EMPTY
51224: PPUSH
51225: CALL_OW 1
51229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51230: LD_ADDR_EXP 92
51234: PUSH
51235: LD_EXP 92
51239: PPUSH
51240: LD_VAR 0 1
51244: PPUSH
51245: EMPTY
51246: PPUSH
51247: CALL_OW 1
51251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51252: LD_ADDR_EXP 94
51256: PUSH
51257: LD_EXP 94
51261: PPUSH
51262: LD_VAR 0 1
51266: PPUSH
51267: EMPTY
51268: PPUSH
51269: CALL_OW 1
51273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51274: LD_ADDR_EXP 95
51278: PUSH
51279: LD_EXP 95
51283: PPUSH
51284: LD_VAR 0 1
51288: PPUSH
51289: EMPTY
51290: PPUSH
51291: CALL_OW 1
51295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51296: LD_ADDR_EXP 96
51300: PUSH
51301: LD_EXP 96
51305: PPUSH
51306: LD_VAR 0 1
51310: PPUSH
51311: EMPTY
51312: PPUSH
51313: CALL_OW 1
51317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51318: LD_ADDR_EXP 97
51322: PUSH
51323: LD_EXP 97
51327: PPUSH
51328: LD_VAR 0 1
51332: PPUSH
51333: EMPTY
51334: PPUSH
51335: CALL_OW 1
51339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51340: LD_ADDR_EXP 98
51344: PUSH
51345: LD_EXP 98
51349: PPUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: EMPTY
51356: PPUSH
51357: CALL_OW 1
51361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51362: LD_ADDR_EXP 99
51366: PUSH
51367: LD_EXP 99
51371: PPUSH
51372: LD_VAR 0 1
51376: PPUSH
51377: EMPTY
51378: PPUSH
51379: CALL_OW 1
51383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51384: LD_ADDR_EXP 100
51388: PUSH
51389: LD_EXP 100
51393: PPUSH
51394: LD_VAR 0 1
51398: PPUSH
51399: EMPTY
51400: PPUSH
51401: CALL_OW 1
51405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51406: LD_ADDR_EXP 101
51410: PUSH
51411: LD_EXP 101
51415: PPUSH
51416: LD_VAR 0 1
51420: PPUSH
51421: EMPTY
51422: PPUSH
51423: CALL_OW 1
51427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51428: LD_ADDR_EXP 102
51432: PUSH
51433: LD_EXP 102
51437: PPUSH
51438: LD_VAR 0 1
51442: PPUSH
51443: EMPTY
51444: PPUSH
51445: CALL_OW 1
51449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51450: LD_ADDR_EXP 103
51454: PUSH
51455: LD_EXP 103
51459: PPUSH
51460: LD_VAR 0 1
51464: PPUSH
51465: EMPTY
51466: PPUSH
51467: CALL_OW 1
51471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51472: LD_ADDR_EXP 104
51476: PUSH
51477: LD_EXP 104
51481: PPUSH
51482: LD_VAR 0 1
51486: PPUSH
51487: EMPTY
51488: PPUSH
51489: CALL_OW 1
51493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51494: LD_ADDR_EXP 105
51498: PUSH
51499: LD_EXP 105
51503: PPUSH
51504: LD_VAR 0 1
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL_OW 1
51515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51516: LD_ADDR_EXP 106
51520: PUSH
51521: LD_EXP 106
51525: PPUSH
51526: LD_VAR 0 1
51530: PPUSH
51531: EMPTY
51532: PPUSH
51533: CALL_OW 1
51537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51538: LD_ADDR_EXP 107
51542: PUSH
51543: LD_EXP 107
51547: PPUSH
51548: LD_VAR 0 1
51552: PPUSH
51553: LD_INT 0
51555: PPUSH
51556: CALL_OW 1
51560: ST_TO_ADDR
// end ;
51561: LD_VAR 0 2
51565: RET
// export function MC_Add ( side , units ) ; var base ; begin
51566: LD_INT 0
51568: PPUSH
51569: PPUSH
// base := mc_bases + 1 ;
51570: LD_ADDR_VAR 0 4
51574: PUSH
51575: LD_EXP 65
51579: PUSH
51580: LD_INT 1
51582: PLUS
51583: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51584: LD_ADDR_EXP 91
51588: PUSH
51589: LD_EXP 91
51593: PPUSH
51594: LD_VAR 0 4
51598: PPUSH
51599: LD_VAR 0 1
51603: PPUSH
51604: CALL_OW 1
51608: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51609: LD_ADDR_EXP 65
51613: PUSH
51614: LD_EXP 65
51618: PPUSH
51619: LD_VAR 0 4
51623: PPUSH
51624: LD_VAR 0 2
51628: PPUSH
51629: CALL_OW 1
51633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51634: LD_ADDR_EXP 66
51638: PUSH
51639: LD_EXP 66
51643: PPUSH
51644: LD_VAR 0 4
51648: PPUSH
51649: EMPTY
51650: PPUSH
51651: CALL_OW 1
51655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51656: LD_ADDR_EXP 67
51660: PUSH
51661: LD_EXP 67
51665: PPUSH
51666: LD_VAR 0 4
51670: PPUSH
51671: EMPTY
51672: PPUSH
51673: CALL_OW 1
51677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51678: LD_ADDR_EXP 68
51682: PUSH
51683: LD_EXP 68
51687: PPUSH
51688: LD_VAR 0 4
51692: PPUSH
51693: EMPTY
51694: PPUSH
51695: CALL_OW 1
51699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51700: LD_ADDR_EXP 69
51704: PUSH
51705: LD_EXP 69
51709: PPUSH
51710: LD_VAR 0 4
51714: PPUSH
51715: EMPTY
51716: PPUSH
51717: CALL_OW 1
51721: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51722: LD_ADDR_EXP 70
51726: PUSH
51727: LD_EXP 70
51731: PPUSH
51732: LD_VAR 0 4
51736: PPUSH
51737: EMPTY
51738: PPUSH
51739: CALL_OW 1
51743: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51744: LD_ADDR_EXP 71
51748: PUSH
51749: LD_EXP 71
51753: PPUSH
51754: LD_VAR 0 4
51758: PPUSH
51759: EMPTY
51760: PPUSH
51761: CALL_OW 1
51765: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51766: LD_ADDR_EXP 72
51770: PUSH
51771: LD_EXP 72
51775: PPUSH
51776: LD_VAR 0 4
51780: PPUSH
51781: EMPTY
51782: PPUSH
51783: CALL_OW 1
51787: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51788: LD_ADDR_EXP 73
51792: PUSH
51793: LD_EXP 73
51797: PPUSH
51798: LD_VAR 0 4
51802: PPUSH
51803: EMPTY
51804: PPUSH
51805: CALL_OW 1
51809: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51810: LD_ADDR_EXP 74
51814: PUSH
51815: LD_EXP 74
51819: PPUSH
51820: LD_VAR 0 4
51824: PPUSH
51825: EMPTY
51826: PPUSH
51827: CALL_OW 1
51831: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51832: LD_ADDR_EXP 75
51836: PUSH
51837: LD_EXP 75
51841: PPUSH
51842: LD_VAR 0 4
51846: PPUSH
51847: EMPTY
51848: PPUSH
51849: CALL_OW 1
51853: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51854: LD_ADDR_EXP 76
51858: PUSH
51859: LD_EXP 76
51863: PPUSH
51864: LD_VAR 0 4
51868: PPUSH
51869: LD_INT 0
51871: PPUSH
51872: CALL_OW 1
51876: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51877: LD_ADDR_EXP 77
51881: PUSH
51882: LD_EXP 77
51886: PPUSH
51887: LD_VAR 0 4
51891: PPUSH
51892: EMPTY
51893: PPUSH
51894: CALL_OW 1
51898: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51899: LD_ADDR_EXP 78
51903: PUSH
51904: LD_EXP 78
51908: PPUSH
51909: LD_VAR 0 4
51913: PPUSH
51914: EMPTY
51915: PPUSH
51916: CALL_OW 1
51920: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51921: LD_ADDR_EXP 79
51925: PUSH
51926: LD_EXP 79
51930: PPUSH
51931: LD_VAR 0 4
51935: PPUSH
51936: EMPTY
51937: PPUSH
51938: CALL_OW 1
51942: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51943: LD_ADDR_EXP 80
51947: PUSH
51948: LD_EXP 80
51952: PPUSH
51953: LD_VAR 0 4
51957: PPUSH
51958: EMPTY
51959: PPUSH
51960: CALL_OW 1
51964: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51965: LD_ADDR_EXP 81
51969: PUSH
51970: LD_EXP 81
51974: PPUSH
51975: LD_VAR 0 4
51979: PPUSH
51980: EMPTY
51981: PPUSH
51982: CALL_OW 1
51986: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51987: LD_ADDR_EXP 82
51991: PUSH
51992: LD_EXP 82
51996: PPUSH
51997: LD_VAR 0 4
52001: PPUSH
52002: EMPTY
52003: PPUSH
52004: CALL_OW 1
52008: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52009: LD_ADDR_EXP 83
52013: PUSH
52014: LD_EXP 83
52018: PPUSH
52019: LD_VAR 0 4
52023: PPUSH
52024: EMPTY
52025: PPUSH
52026: CALL_OW 1
52030: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52031: LD_ADDR_EXP 84
52035: PUSH
52036: LD_EXP 84
52040: PPUSH
52041: LD_VAR 0 4
52045: PPUSH
52046: EMPTY
52047: PPUSH
52048: CALL_OW 1
52052: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52053: LD_ADDR_EXP 85
52057: PUSH
52058: LD_EXP 85
52062: PPUSH
52063: LD_VAR 0 4
52067: PPUSH
52068: EMPTY
52069: PPUSH
52070: CALL_OW 1
52074: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52075: LD_ADDR_EXP 86
52079: PUSH
52080: LD_EXP 86
52084: PPUSH
52085: LD_VAR 0 4
52089: PPUSH
52090: EMPTY
52091: PPUSH
52092: CALL_OW 1
52096: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52097: LD_ADDR_EXP 87
52101: PUSH
52102: LD_EXP 87
52106: PPUSH
52107: LD_VAR 0 4
52111: PPUSH
52112: EMPTY
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52119: LD_ADDR_EXP 88
52123: PUSH
52124: LD_EXP 88
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: EMPTY
52135: PPUSH
52136: CALL_OW 1
52140: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52141: LD_ADDR_EXP 89
52145: PUSH
52146: LD_EXP 89
52150: PPUSH
52151: LD_VAR 0 4
52155: PPUSH
52156: EMPTY
52157: PPUSH
52158: CALL_OW 1
52162: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52163: LD_ADDR_EXP 90
52167: PUSH
52168: LD_EXP 90
52172: PPUSH
52173: LD_VAR 0 4
52177: PPUSH
52178: EMPTY
52179: PPUSH
52180: CALL_OW 1
52184: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52185: LD_ADDR_EXP 92
52189: PUSH
52190: LD_EXP 92
52194: PPUSH
52195: LD_VAR 0 4
52199: PPUSH
52200: EMPTY
52201: PPUSH
52202: CALL_OW 1
52206: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52207: LD_ADDR_EXP 94
52211: PUSH
52212: LD_EXP 94
52216: PPUSH
52217: LD_VAR 0 4
52221: PPUSH
52222: EMPTY
52223: PPUSH
52224: CALL_OW 1
52228: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52229: LD_ADDR_EXP 95
52233: PUSH
52234: LD_EXP 95
52238: PPUSH
52239: LD_VAR 0 4
52243: PPUSH
52244: EMPTY
52245: PPUSH
52246: CALL_OW 1
52250: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52251: LD_ADDR_EXP 96
52255: PUSH
52256: LD_EXP 96
52260: PPUSH
52261: LD_VAR 0 4
52265: PPUSH
52266: EMPTY
52267: PPUSH
52268: CALL_OW 1
52272: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52273: LD_ADDR_EXP 97
52277: PUSH
52278: LD_EXP 97
52282: PPUSH
52283: LD_VAR 0 4
52287: PPUSH
52288: EMPTY
52289: PPUSH
52290: CALL_OW 1
52294: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52295: LD_ADDR_EXP 98
52299: PUSH
52300: LD_EXP 98
52304: PPUSH
52305: LD_VAR 0 4
52309: PPUSH
52310: EMPTY
52311: PPUSH
52312: CALL_OW 1
52316: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52317: LD_ADDR_EXP 99
52321: PUSH
52322: LD_EXP 99
52326: PPUSH
52327: LD_VAR 0 4
52331: PPUSH
52332: EMPTY
52333: PPUSH
52334: CALL_OW 1
52338: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52339: LD_ADDR_EXP 100
52343: PUSH
52344: LD_EXP 100
52348: PPUSH
52349: LD_VAR 0 4
52353: PPUSH
52354: EMPTY
52355: PPUSH
52356: CALL_OW 1
52360: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52361: LD_ADDR_EXP 101
52365: PUSH
52366: LD_EXP 101
52370: PPUSH
52371: LD_VAR 0 4
52375: PPUSH
52376: EMPTY
52377: PPUSH
52378: CALL_OW 1
52382: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52383: LD_ADDR_EXP 102
52387: PUSH
52388: LD_EXP 102
52392: PPUSH
52393: LD_VAR 0 4
52397: PPUSH
52398: EMPTY
52399: PPUSH
52400: CALL_OW 1
52404: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52405: LD_ADDR_EXP 103
52409: PUSH
52410: LD_EXP 103
52414: PPUSH
52415: LD_VAR 0 4
52419: PPUSH
52420: EMPTY
52421: PPUSH
52422: CALL_OW 1
52426: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52427: LD_ADDR_EXP 104
52431: PUSH
52432: LD_EXP 104
52436: PPUSH
52437: LD_VAR 0 4
52441: PPUSH
52442: EMPTY
52443: PPUSH
52444: CALL_OW 1
52448: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52449: LD_ADDR_EXP 105
52453: PUSH
52454: LD_EXP 105
52458: PPUSH
52459: LD_VAR 0 4
52463: PPUSH
52464: EMPTY
52465: PPUSH
52466: CALL_OW 1
52470: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52471: LD_ADDR_EXP 106
52475: PUSH
52476: LD_EXP 106
52480: PPUSH
52481: LD_VAR 0 4
52485: PPUSH
52486: EMPTY
52487: PPUSH
52488: CALL_OW 1
52492: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52493: LD_ADDR_EXP 107
52497: PUSH
52498: LD_EXP 107
52502: PPUSH
52503: LD_VAR 0 4
52507: PPUSH
52508: LD_INT 0
52510: PPUSH
52511: CALL_OW 1
52515: ST_TO_ADDR
// result := base ;
52516: LD_ADDR_VAR 0 3
52520: PUSH
52521: LD_VAR 0 4
52525: ST_TO_ADDR
// end ;
52526: LD_VAR 0 3
52530: RET
// export function MC_Start ( ) ; var i ; begin
52531: LD_INT 0
52533: PPUSH
52534: PPUSH
// for i = 1 to mc_bases do
52535: LD_ADDR_VAR 0 2
52539: PUSH
52540: DOUBLE
52541: LD_INT 1
52543: DEC
52544: ST_TO_ADDR
52545: LD_EXP 65
52549: PUSH
52550: FOR_TO
52551: IFFALSE 53628
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52553: LD_ADDR_EXP 65
52557: PUSH
52558: LD_EXP 65
52562: PPUSH
52563: LD_VAR 0 2
52567: PPUSH
52568: LD_EXP 65
52572: PUSH
52573: LD_VAR 0 2
52577: ARRAY
52578: PUSH
52579: LD_INT 0
52581: DIFF
52582: PPUSH
52583: CALL_OW 1
52587: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52588: LD_ADDR_EXP 66
52592: PUSH
52593: LD_EXP 66
52597: PPUSH
52598: LD_VAR 0 2
52602: PPUSH
52603: EMPTY
52604: PPUSH
52605: CALL_OW 1
52609: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52610: LD_ADDR_EXP 67
52614: PUSH
52615: LD_EXP 67
52619: PPUSH
52620: LD_VAR 0 2
52624: PPUSH
52625: EMPTY
52626: PPUSH
52627: CALL_OW 1
52631: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52632: LD_ADDR_EXP 68
52636: PUSH
52637: LD_EXP 68
52641: PPUSH
52642: LD_VAR 0 2
52646: PPUSH
52647: EMPTY
52648: PPUSH
52649: CALL_OW 1
52653: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52654: LD_ADDR_EXP 69
52658: PUSH
52659: LD_EXP 69
52663: PPUSH
52664: LD_VAR 0 2
52668: PPUSH
52669: EMPTY
52670: PUSH
52671: EMPTY
52672: PUSH
52673: EMPTY
52674: LIST
52675: LIST
52676: PPUSH
52677: CALL_OW 1
52681: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52682: LD_ADDR_EXP 70
52686: PUSH
52687: LD_EXP 70
52691: PPUSH
52692: LD_VAR 0 2
52696: PPUSH
52697: EMPTY
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52704: LD_ADDR_EXP 97
52708: PUSH
52709: LD_EXP 97
52713: PPUSH
52714: LD_VAR 0 2
52718: PPUSH
52719: EMPTY
52720: PPUSH
52721: CALL_OW 1
52725: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52726: LD_ADDR_EXP 71
52730: PUSH
52731: LD_EXP 71
52735: PPUSH
52736: LD_VAR 0 2
52740: PPUSH
52741: EMPTY
52742: PPUSH
52743: CALL_OW 1
52747: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52748: LD_ADDR_EXP 72
52752: PUSH
52753: LD_EXP 72
52757: PPUSH
52758: LD_VAR 0 2
52762: PPUSH
52763: EMPTY
52764: PPUSH
52765: CALL_OW 1
52769: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52770: LD_ADDR_EXP 73
52774: PUSH
52775: LD_EXP 73
52779: PPUSH
52780: LD_VAR 0 2
52784: PPUSH
52785: LD_EXP 65
52789: PUSH
52790: LD_VAR 0 2
52794: ARRAY
52795: PPUSH
52796: LD_INT 2
52798: PUSH
52799: LD_INT 30
52801: PUSH
52802: LD_INT 32
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 30
52811: PUSH
52812: LD_INT 33
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: LIST
52823: PPUSH
52824: CALL_OW 72
52828: PPUSH
52829: CALL_OW 1
52833: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52834: LD_ADDR_EXP 74
52838: PUSH
52839: LD_EXP 74
52843: PPUSH
52844: LD_VAR 0 2
52848: PPUSH
52849: LD_EXP 65
52853: PUSH
52854: LD_VAR 0 2
52858: ARRAY
52859: PPUSH
52860: LD_INT 2
52862: PUSH
52863: LD_INT 30
52865: PUSH
52866: LD_INT 32
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: PUSH
52873: LD_INT 30
52875: PUSH
52876: LD_INT 31
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: PUSH
52883: EMPTY
52884: LIST
52885: LIST
52886: LIST
52887: PUSH
52888: LD_INT 58
52890: PUSH
52891: EMPTY
52892: LIST
52893: PUSH
52894: EMPTY
52895: LIST
52896: LIST
52897: PPUSH
52898: CALL_OW 72
52902: PPUSH
52903: CALL_OW 1
52907: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52908: LD_ADDR_EXP 75
52912: PUSH
52913: LD_EXP 75
52917: PPUSH
52918: LD_VAR 0 2
52922: PPUSH
52923: EMPTY
52924: PPUSH
52925: CALL_OW 1
52929: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52930: LD_ADDR_EXP 79
52934: PUSH
52935: LD_EXP 79
52939: PPUSH
52940: LD_VAR 0 2
52944: PPUSH
52945: EMPTY
52946: PPUSH
52947: CALL_OW 1
52951: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52952: LD_ADDR_EXP 78
52956: PUSH
52957: LD_EXP 78
52961: PPUSH
52962: LD_VAR 0 2
52966: PPUSH
52967: EMPTY
52968: PPUSH
52969: CALL_OW 1
52973: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52974: LD_ADDR_EXP 80
52978: PUSH
52979: LD_EXP 80
52983: PPUSH
52984: LD_VAR 0 2
52988: PPUSH
52989: EMPTY
52990: PPUSH
52991: CALL_OW 1
52995: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52996: LD_ADDR_EXP 81
53000: PUSH
53001: LD_EXP 81
53005: PPUSH
53006: LD_VAR 0 2
53010: PPUSH
53011: EMPTY
53012: PPUSH
53013: CALL_OW 1
53017: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53018: LD_ADDR_EXP 82
53022: PUSH
53023: LD_EXP 82
53027: PPUSH
53028: LD_VAR 0 2
53032: PPUSH
53033: EMPTY
53034: PPUSH
53035: CALL_OW 1
53039: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53040: LD_ADDR_EXP 83
53044: PUSH
53045: LD_EXP 83
53049: PPUSH
53050: LD_VAR 0 2
53054: PPUSH
53055: EMPTY
53056: PPUSH
53057: CALL_OW 1
53061: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53062: LD_ADDR_EXP 84
53066: PUSH
53067: LD_EXP 84
53071: PPUSH
53072: LD_VAR 0 2
53076: PPUSH
53077: EMPTY
53078: PPUSH
53079: CALL_OW 1
53083: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53084: LD_ADDR_EXP 85
53088: PUSH
53089: LD_EXP 85
53093: PPUSH
53094: LD_VAR 0 2
53098: PPUSH
53099: EMPTY
53100: PPUSH
53101: CALL_OW 1
53105: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53106: LD_ADDR_EXP 86
53110: PUSH
53111: LD_EXP 86
53115: PPUSH
53116: LD_VAR 0 2
53120: PPUSH
53121: EMPTY
53122: PPUSH
53123: CALL_OW 1
53127: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53128: LD_ADDR_EXP 87
53132: PUSH
53133: LD_EXP 87
53137: PPUSH
53138: LD_VAR 0 2
53142: PPUSH
53143: EMPTY
53144: PPUSH
53145: CALL_OW 1
53149: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53150: LD_ADDR_EXP 76
53154: PUSH
53155: LD_EXP 76
53159: PPUSH
53160: LD_VAR 0 2
53164: PPUSH
53165: LD_INT 0
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53173: LD_ADDR_EXP 89
53177: PUSH
53178: LD_EXP 89
53182: PPUSH
53183: LD_VAR 0 2
53187: PPUSH
53188: LD_INT 0
53190: PPUSH
53191: CALL_OW 1
53195: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53196: LD_ADDR_EXP 77
53200: PUSH
53201: LD_EXP 77
53205: PPUSH
53206: LD_VAR 0 2
53210: PPUSH
53211: EMPTY
53212: PPUSH
53213: CALL_OW 1
53217: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53218: LD_ADDR_EXP 88
53222: PUSH
53223: LD_EXP 88
53227: PPUSH
53228: LD_VAR 0 2
53232: PPUSH
53233: LD_INT 0
53235: PPUSH
53236: CALL_OW 1
53240: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53241: LD_ADDR_EXP 90
53245: PUSH
53246: LD_EXP 90
53250: PPUSH
53251: LD_VAR 0 2
53255: PPUSH
53256: EMPTY
53257: PPUSH
53258: CALL_OW 1
53262: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53263: LD_ADDR_EXP 93
53267: PUSH
53268: LD_EXP 93
53272: PPUSH
53273: LD_VAR 0 2
53277: PPUSH
53278: LD_INT 0
53280: PPUSH
53281: CALL_OW 1
53285: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53286: LD_ADDR_EXP 94
53290: PUSH
53291: LD_EXP 94
53295: PPUSH
53296: LD_VAR 0 2
53300: PPUSH
53301: EMPTY
53302: PPUSH
53303: CALL_OW 1
53307: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53308: LD_ADDR_EXP 95
53312: PUSH
53313: LD_EXP 95
53317: PPUSH
53318: LD_VAR 0 2
53322: PPUSH
53323: EMPTY
53324: PPUSH
53325: CALL_OW 1
53329: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53330: LD_ADDR_EXP 96
53334: PUSH
53335: LD_EXP 96
53339: PPUSH
53340: LD_VAR 0 2
53344: PPUSH
53345: EMPTY
53346: PPUSH
53347: CALL_OW 1
53351: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53352: LD_ADDR_EXP 98
53356: PUSH
53357: LD_EXP 98
53361: PPUSH
53362: LD_VAR 0 2
53366: PPUSH
53367: LD_EXP 65
53371: PUSH
53372: LD_VAR 0 2
53376: ARRAY
53377: PPUSH
53378: LD_INT 2
53380: PUSH
53381: LD_INT 30
53383: PUSH
53384: LD_INT 6
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 30
53393: PUSH
53394: LD_INT 7
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: PUSH
53401: LD_INT 30
53403: PUSH
53404: LD_INT 8
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: LIST
53416: PPUSH
53417: CALL_OW 72
53421: PPUSH
53422: CALL_OW 1
53426: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53427: LD_ADDR_EXP 99
53431: PUSH
53432: LD_EXP 99
53436: PPUSH
53437: LD_VAR 0 2
53441: PPUSH
53442: EMPTY
53443: PPUSH
53444: CALL_OW 1
53448: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53449: LD_ADDR_EXP 100
53453: PUSH
53454: LD_EXP 100
53458: PPUSH
53459: LD_VAR 0 2
53463: PPUSH
53464: EMPTY
53465: PPUSH
53466: CALL_OW 1
53470: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53471: LD_ADDR_EXP 101
53475: PUSH
53476: LD_EXP 101
53480: PPUSH
53481: LD_VAR 0 2
53485: PPUSH
53486: EMPTY
53487: PPUSH
53488: CALL_OW 1
53492: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53493: LD_ADDR_EXP 102
53497: PUSH
53498: LD_EXP 102
53502: PPUSH
53503: LD_VAR 0 2
53507: PPUSH
53508: EMPTY
53509: PPUSH
53510: CALL_OW 1
53514: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53515: LD_ADDR_EXP 103
53519: PUSH
53520: LD_EXP 103
53524: PPUSH
53525: LD_VAR 0 2
53529: PPUSH
53530: EMPTY
53531: PPUSH
53532: CALL_OW 1
53536: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53537: LD_ADDR_EXP 104
53541: PUSH
53542: LD_EXP 104
53546: PPUSH
53547: LD_VAR 0 2
53551: PPUSH
53552: EMPTY
53553: PPUSH
53554: CALL_OW 1
53558: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53559: LD_ADDR_EXP 105
53563: PUSH
53564: LD_EXP 105
53568: PPUSH
53569: LD_VAR 0 2
53573: PPUSH
53574: EMPTY
53575: PPUSH
53576: CALL_OW 1
53580: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53581: LD_ADDR_EXP 106
53585: PUSH
53586: LD_EXP 106
53590: PPUSH
53591: LD_VAR 0 2
53595: PPUSH
53596: EMPTY
53597: PPUSH
53598: CALL_OW 1
53602: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53603: LD_ADDR_EXP 107
53607: PUSH
53608: LD_EXP 107
53612: PPUSH
53613: LD_VAR 0 2
53617: PPUSH
53618: LD_INT 0
53620: PPUSH
53621: CALL_OW 1
53625: ST_TO_ADDR
// end ;
53626: GO 52550
53628: POP
53629: POP
// MC_InitSides ( ) ;
53630: CALL 53916 0 0
// MC_InitResearch ( ) ;
53634: CALL 53655 0 0
// CustomInitMacro ( ) ;
53638: CALL 5823 0 0
// skirmish := true ;
53642: LD_ADDR_EXP 63
53646: PUSH
53647: LD_INT 1
53649: ST_TO_ADDR
// end ;
53650: LD_VAR 0 1
53654: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53655: LD_INT 0
53657: PPUSH
53658: PPUSH
53659: PPUSH
53660: PPUSH
53661: PPUSH
53662: PPUSH
// if not mc_bases then
53663: LD_EXP 65
53667: NOT
53668: IFFALSE 53672
// exit ;
53670: GO 53911
// for i = 1 to 8 do
53672: LD_ADDR_VAR 0 2
53676: PUSH
53677: DOUBLE
53678: LD_INT 1
53680: DEC
53681: ST_TO_ADDR
53682: LD_INT 8
53684: PUSH
53685: FOR_TO
53686: IFFALSE 53712
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53688: LD_ADDR_EXP 92
53692: PUSH
53693: LD_EXP 92
53697: PPUSH
53698: LD_VAR 0 2
53702: PPUSH
53703: EMPTY
53704: PPUSH
53705: CALL_OW 1
53709: ST_TO_ADDR
53710: GO 53685
53712: POP
53713: POP
// tmp := [ ] ;
53714: LD_ADDR_VAR 0 5
53718: PUSH
53719: EMPTY
53720: ST_TO_ADDR
// for i = 1 to mc_sides do
53721: LD_ADDR_VAR 0 2
53725: PUSH
53726: DOUBLE
53727: LD_INT 1
53729: DEC
53730: ST_TO_ADDR
53731: LD_EXP 91
53735: PUSH
53736: FOR_TO
53737: IFFALSE 53795
// if not mc_sides [ i ] in tmp then
53739: LD_EXP 91
53743: PUSH
53744: LD_VAR 0 2
53748: ARRAY
53749: PUSH
53750: LD_VAR 0 5
53754: IN
53755: NOT
53756: IFFALSE 53793
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53758: LD_ADDR_VAR 0 5
53762: PUSH
53763: LD_VAR 0 5
53767: PPUSH
53768: LD_VAR 0 5
53772: PUSH
53773: LD_INT 1
53775: PLUS
53776: PPUSH
53777: LD_EXP 91
53781: PUSH
53782: LD_VAR 0 2
53786: ARRAY
53787: PPUSH
53788: CALL_OW 2
53792: ST_TO_ADDR
53793: GO 53736
53795: POP
53796: POP
// if not tmp then
53797: LD_VAR 0 5
53801: NOT
53802: IFFALSE 53806
// exit ;
53804: GO 53911
// for j in tmp do
53806: LD_ADDR_VAR 0 3
53810: PUSH
53811: LD_VAR 0 5
53815: PUSH
53816: FOR_IN
53817: IFFALSE 53909
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53819: LD_ADDR_VAR 0 6
53823: PUSH
53824: LD_INT 22
53826: PUSH
53827: LD_VAR 0 3
53831: PUSH
53832: EMPTY
53833: LIST
53834: LIST
53835: PPUSH
53836: CALL_OW 69
53840: ST_TO_ADDR
// if not un then
53841: LD_VAR 0 6
53845: NOT
53846: IFFALSE 53850
// continue ;
53848: GO 53816
// nation := GetNation ( un [ 1 ] ) ;
53850: LD_ADDR_VAR 0 4
53854: PUSH
53855: LD_VAR 0 6
53859: PUSH
53860: LD_INT 1
53862: ARRAY
53863: PPUSH
53864: CALL_OW 248
53868: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53869: LD_ADDR_EXP 92
53873: PUSH
53874: LD_EXP 92
53878: PPUSH
53879: LD_VAR 0 3
53883: PPUSH
53884: LD_VAR 0 3
53888: PPUSH
53889: LD_VAR 0 4
53893: PPUSH
53894: LD_INT 1
53896: PPUSH
53897: CALL 13696 0 3
53901: PPUSH
53902: CALL_OW 1
53906: ST_TO_ADDR
// end ;
53907: GO 53816
53909: POP
53910: POP
// end ;
53911: LD_VAR 0 1
53915: RET
// export function MC_InitSides ( ) ; var i ; begin
53916: LD_INT 0
53918: PPUSH
53919: PPUSH
// if not mc_bases then
53920: LD_EXP 65
53924: NOT
53925: IFFALSE 53929
// exit ;
53927: GO 54003
// for i = 1 to mc_bases do
53929: LD_ADDR_VAR 0 2
53933: PUSH
53934: DOUBLE
53935: LD_INT 1
53937: DEC
53938: ST_TO_ADDR
53939: LD_EXP 65
53943: PUSH
53944: FOR_TO
53945: IFFALSE 54001
// if mc_bases [ i ] then
53947: LD_EXP 65
53951: PUSH
53952: LD_VAR 0 2
53956: ARRAY
53957: IFFALSE 53999
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53959: LD_ADDR_EXP 91
53963: PUSH
53964: LD_EXP 91
53968: PPUSH
53969: LD_VAR 0 2
53973: PPUSH
53974: LD_EXP 65
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PUSH
53985: LD_INT 1
53987: ARRAY
53988: PPUSH
53989: CALL_OW 255
53993: PPUSH
53994: CALL_OW 1
53998: ST_TO_ADDR
53999: GO 53944
54001: POP
54002: POP
// end ;
54003: LD_VAR 0 1
54007: RET
// every 0 0$01 trigger skirmish do
54008: LD_EXP 63
54012: IFFALSE 54166
54014: GO 54016
54016: DISABLE
// begin enable ;
54017: ENABLE
// MC_CheckBuildings ( ) ;
54018: CALL 58664 0 0
// MC_CheckPeopleLife ( ) ;
54022: CALL 58789 0 0
// RaiseSailEvent ( 100 ) ;
54026: LD_INT 100
54028: PPUSH
54029: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54033: LD_INT 103
54035: PPUSH
54036: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54040: LD_INT 104
54042: PPUSH
54043: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54047: LD_INT 105
54049: PPUSH
54050: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54054: LD_INT 106
54056: PPUSH
54057: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54061: LD_INT 107
54063: PPUSH
54064: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54068: LD_INT 108
54070: PPUSH
54071: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54075: LD_INT 109
54077: PPUSH
54078: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54082: LD_INT 110
54084: PPUSH
54085: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54089: LD_INT 111
54091: PPUSH
54092: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54096: LD_INT 112
54098: PPUSH
54099: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54103: LD_INT 113
54105: PPUSH
54106: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54110: LD_INT 120
54112: PPUSH
54113: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54117: LD_INT 121
54119: PPUSH
54120: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54124: LD_INT 122
54126: PPUSH
54127: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54131: LD_INT 123
54133: PPUSH
54134: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54138: LD_INT 124
54140: PPUSH
54141: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54145: LD_INT 125
54147: PPUSH
54148: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54152: LD_INT 126
54154: PPUSH
54155: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54159: LD_INT 200
54161: PPUSH
54162: CALL_OW 427
// end ;
54166: END
// on SailEvent ( event ) do begin if event < 100 then
54167: LD_VAR 0 1
54171: PUSH
54172: LD_INT 100
54174: LESS
54175: IFFALSE 54186
// CustomEvent ( event ) ;
54177: LD_VAR 0 1
54181: PPUSH
54182: CALL 5815 0 1
// if event = 100 then
54186: LD_VAR 0 1
54190: PUSH
54191: LD_INT 100
54193: EQUAL
54194: IFFALSE 54200
// MC_ClassManager ( ) ;
54196: CALL 54592 0 0
// if event = 101 then
54200: LD_VAR 0 1
54204: PUSH
54205: LD_INT 101
54207: EQUAL
54208: IFFALSE 54214
// MC_RepairBuildings ( ) ;
54210: CALL 59374 0 0
// if event = 102 then
54214: LD_VAR 0 1
54218: PUSH
54219: LD_INT 102
54221: EQUAL
54222: IFFALSE 54228
// MC_Heal ( ) ;
54224: CALL 60233 0 0
// if event = 103 then
54228: LD_VAR 0 1
54232: PUSH
54233: LD_INT 103
54235: EQUAL
54236: IFFALSE 54242
// MC_Build ( ) ;
54238: CALL 60655 0 0
// if event = 104 then
54242: LD_VAR 0 1
54246: PUSH
54247: LD_INT 104
54249: EQUAL
54250: IFFALSE 54256
// MC_TurretWeapon ( ) ;
54252: CALL 62268 0 0
// if event = 105 then
54256: LD_VAR 0 1
54260: PUSH
54261: LD_INT 105
54263: EQUAL
54264: IFFALSE 54270
// MC_BuildUpgrade ( ) ;
54266: CALL 61819 0 0
// if event = 106 then
54270: LD_VAR 0 1
54274: PUSH
54275: LD_INT 106
54277: EQUAL
54278: IFFALSE 54284
// MC_PlantMines ( ) ;
54280: CALL 62698 0 0
// if event = 107 then
54284: LD_VAR 0 1
54288: PUSH
54289: LD_INT 107
54291: EQUAL
54292: IFFALSE 54298
// MC_CollectCrates ( ) ;
54294: CALL 63496 0 0
// if event = 108 then
54298: LD_VAR 0 1
54302: PUSH
54303: LD_INT 108
54305: EQUAL
54306: IFFALSE 54312
// MC_LinkRemoteControl ( ) ;
54308: CALL 65272 0 0
// if event = 109 then
54312: LD_VAR 0 1
54316: PUSH
54317: LD_INT 109
54319: EQUAL
54320: IFFALSE 54326
// MC_ProduceVehicle ( ) ;
54322: CALL 65453 0 0
// if event = 110 then
54326: LD_VAR 0 1
54330: PUSH
54331: LD_INT 110
54333: EQUAL
54334: IFFALSE 54340
// MC_SendAttack ( ) ;
54336: CALL 65919 0 0
// if event = 111 then
54340: LD_VAR 0 1
54344: PUSH
54345: LD_INT 111
54347: EQUAL
54348: IFFALSE 54354
// MC_Defend ( ) ;
54350: CALL 66027 0 0
// if event = 112 then
54354: LD_VAR 0 1
54358: PUSH
54359: LD_INT 112
54361: EQUAL
54362: IFFALSE 54368
// MC_Research ( ) ;
54364: CALL 66632 0 0
// if event = 113 then
54368: LD_VAR 0 1
54372: PUSH
54373: LD_INT 113
54375: EQUAL
54376: IFFALSE 54382
// MC_MinesTrigger ( ) ;
54378: CALL 67746 0 0
// if event = 120 then
54382: LD_VAR 0 1
54386: PUSH
54387: LD_INT 120
54389: EQUAL
54390: IFFALSE 54396
// MC_RepairVehicle ( ) ;
54392: CALL 67845 0 0
// if event = 121 then
54396: LD_VAR 0 1
54400: PUSH
54401: LD_INT 121
54403: EQUAL
54404: IFFALSE 54410
// MC_TameApe ( ) ;
54406: CALL 68575 0 0
// if event = 122 then
54410: LD_VAR 0 1
54414: PUSH
54415: LD_INT 122
54417: EQUAL
54418: IFFALSE 54424
// MC_ChangeApeClass ( ) ;
54420: CALL 69404 0 0
// if event = 123 then
54424: LD_VAR 0 1
54428: PUSH
54429: LD_INT 123
54431: EQUAL
54432: IFFALSE 54438
// MC_Bazooka ( ) ;
54434: CALL 70054 0 0
// if event = 124 then
54438: LD_VAR 0 1
54442: PUSH
54443: LD_INT 124
54445: EQUAL
54446: IFFALSE 54452
// MC_TeleportExit ( ) ;
54448: CALL 70252 0 0
// if event = 125 then
54452: LD_VAR 0 1
54456: PUSH
54457: LD_INT 125
54459: EQUAL
54460: IFFALSE 54466
// MC_Deposits ( ) ;
54462: CALL 70899 0 0
// if event = 126 then
54466: LD_VAR 0 1
54470: PUSH
54471: LD_INT 126
54473: EQUAL
54474: IFFALSE 54480
// MC_RemoteDriver ( ) ;
54476: CALL 71524 0 0
// if event = 200 then
54480: LD_VAR 0 1
54484: PUSH
54485: LD_INT 200
54487: EQUAL
54488: IFFALSE 54494
// MC_Idle ( ) ;
54490: CALL 73473 0 0
// end ;
54494: PPOPN 1
54496: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54497: LD_INT 0
54499: PPUSH
54500: PPUSH
// if not mc_bases [ base ] or not tag then
54501: LD_EXP 65
54505: PUSH
54506: LD_VAR 0 1
54510: ARRAY
54511: NOT
54512: PUSH
54513: LD_VAR 0 2
54517: NOT
54518: OR
54519: IFFALSE 54523
// exit ;
54521: GO 54587
// for i in mc_bases [ base ] union mc_ape [ base ] do
54523: LD_ADDR_VAR 0 4
54527: PUSH
54528: LD_EXP 65
54532: PUSH
54533: LD_VAR 0 1
54537: ARRAY
54538: PUSH
54539: LD_EXP 94
54543: PUSH
54544: LD_VAR 0 1
54548: ARRAY
54549: UNION
54550: PUSH
54551: FOR_IN
54552: IFFALSE 54585
// if GetTag ( i ) = tag then
54554: LD_VAR 0 4
54558: PPUSH
54559: CALL_OW 110
54563: PUSH
54564: LD_VAR 0 2
54568: EQUAL
54569: IFFALSE 54583
// SetTag ( i , 0 ) ;
54571: LD_VAR 0 4
54575: PPUSH
54576: LD_INT 0
54578: PPUSH
54579: CALL_OW 109
54583: GO 54551
54585: POP
54586: POP
// end ;
54587: LD_VAR 0 3
54591: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
54598: PPUSH
54599: PPUSH
54600: PPUSH
54601: PPUSH
// if not mc_bases then
54602: LD_EXP 65
54606: NOT
54607: IFFALSE 54611
// exit ;
54609: GO 55069
// for i = 1 to mc_bases do
54611: LD_ADDR_VAR 0 2
54615: PUSH
54616: DOUBLE
54617: LD_INT 1
54619: DEC
54620: ST_TO_ADDR
54621: LD_EXP 65
54625: PUSH
54626: FOR_TO
54627: IFFALSE 55067
// begin tmp := MC_ClassCheckReq ( i ) ;
54629: LD_ADDR_VAR 0 4
54633: PUSH
54634: LD_VAR 0 2
54638: PPUSH
54639: CALL 55074 0 1
54643: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54644: LD_ADDR_EXP 106
54648: PUSH
54649: LD_EXP 106
54653: PPUSH
54654: LD_VAR 0 2
54658: PPUSH
54659: LD_VAR 0 4
54663: PPUSH
54664: CALL_OW 1
54668: ST_TO_ADDR
// if not tmp then
54669: LD_VAR 0 4
54673: NOT
54674: IFFALSE 54678
// continue ;
54676: GO 54626
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54678: LD_ADDR_VAR 0 6
54682: PUSH
54683: LD_EXP 65
54687: PUSH
54688: LD_VAR 0 2
54692: ARRAY
54693: PPUSH
54694: LD_INT 2
54696: PUSH
54697: LD_INT 30
54699: PUSH
54700: LD_INT 4
54702: PUSH
54703: EMPTY
54704: LIST
54705: LIST
54706: PUSH
54707: LD_INT 30
54709: PUSH
54710: LD_INT 5
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: LIST
54721: PPUSH
54722: CALL_OW 72
54726: PUSH
54727: LD_EXP 65
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: PPUSH
54738: LD_INT 2
54740: PUSH
54741: LD_INT 30
54743: PUSH
54744: LD_INT 0
54746: PUSH
54747: EMPTY
54748: LIST
54749: LIST
54750: PUSH
54751: LD_INT 30
54753: PUSH
54754: LD_INT 1
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: PPUSH
54766: CALL_OW 72
54770: PUSH
54771: LD_EXP 65
54775: PUSH
54776: LD_VAR 0 2
54780: ARRAY
54781: PPUSH
54782: LD_INT 30
54784: PUSH
54785: LD_INT 3
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: PPUSH
54792: CALL_OW 72
54796: PUSH
54797: LD_EXP 65
54801: PUSH
54802: LD_VAR 0 2
54806: ARRAY
54807: PPUSH
54808: LD_INT 2
54810: PUSH
54811: LD_INT 30
54813: PUSH
54814: LD_INT 6
54816: PUSH
54817: EMPTY
54818: LIST
54819: LIST
54820: PUSH
54821: LD_INT 30
54823: PUSH
54824: LD_INT 7
54826: PUSH
54827: EMPTY
54828: LIST
54829: LIST
54830: PUSH
54831: LD_INT 30
54833: PUSH
54834: LD_INT 8
54836: PUSH
54837: EMPTY
54838: LIST
54839: LIST
54840: PUSH
54841: EMPTY
54842: LIST
54843: LIST
54844: LIST
54845: LIST
54846: PPUSH
54847: CALL_OW 72
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: LIST
54856: LIST
54857: ST_TO_ADDR
// for j = 1 to 4 do
54858: LD_ADDR_VAR 0 3
54862: PUSH
54863: DOUBLE
54864: LD_INT 1
54866: DEC
54867: ST_TO_ADDR
54868: LD_INT 4
54870: PUSH
54871: FOR_TO
54872: IFFALSE 55063
// begin if not tmp [ j ] then
54874: LD_VAR 0 4
54878: PUSH
54879: LD_VAR 0 3
54883: ARRAY
54884: NOT
54885: IFFALSE 54889
// continue ;
54887: GO 54871
// for p in tmp [ j ] do
54889: LD_ADDR_VAR 0 5
54893: PUSH
54894: LD_VAR 0 4
54898: PUSH
54899: LD_VAR 0 3
54903: ARRAY
54904: PUSH
54905: FOR_IN
54906: IFFALSE 55059
// begin if not b [ j ] then
54908: LD_VAR 0 6
54912: PUSH
54913: LD_VAR 0 3
54917: ARRAY
54918: NOT
54919: IFFALSE 54923
// break ;
54921: GO 55059
// e := 0 ;
54923: LD_ADDR_VAR 0 7
54927: PUSH
54928: LD_INT 0
54930: ST_TO_ADDR
// for k in b [ j ] do
54931: LD_ADDR_VAR 0 8
54935: PUSH
54936: LD_VAR 0 6
54940: PUSH
54941: LD_VAR 0 3
54945: ARRAY
54946: PUSH
54947: FOR_IN
54948: IFFALSE 54975
// if IsNotFull ( k ) then
54950: LD_VAR 0 8
54954: PPUSH
54955: CALL 15845 0 1
54959: IFFALSE 54973
// begin e := k ;
54961: LD_ADDR_VAR 0 7
54965: PUSH
54966: LD_VAR 0 8
54970: ST_TO_ADDR
// break ;
54971: GO 54975
// end ;
54973: GO 54947
54975: POP
54976: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54977: LD_VAR 0 7
54981: PUSH
54982: LD_VAR 0 5
54986: PPUSH
54987: LD_VAR 0 7
54991: PPUSH
54992: CALL 48265 0 2
54996: NOT
54997: AND
54998: IFFALSE 55057
// begin if IsInUnit ( p ) then
55000: LD_VAR 0 5
55004: PPUSH
55005: CALL_OW 310
55009: IFFALSE 55020
// ComExitBuilding ( p ) ;
55011: LD_VAR 0 5
55015: PPUSH
55016: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55020: LD_VAR 0 5
55024: PPUSH
55025: LD_VAR 0 7
55029: PPUSH
55030: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55034: LD_VAR 0 5
55038: PPUSH
55039: LD_VAR 0 3
55043: PPUSH
55044: CALL_OW 183
// AddComExitBuilding ( p ) ;
55048: LD_VAR 0 5
55052: PPUSH
55053: CALL_OW 182
// end ; end ;
55057: GO 54905
55059: POP
55060: POP
// end ;
55061: GO 54871
55063: POP
55064: POP
// end ;
55065: GO 54626
55067: POP
55068: POP
// end ;
55069: LD_VAR 0 1
55073: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55074: LD_INT 0
55076: PPUSH
55077: PPUSH
55078: PPUSH
55079: PPUSH
55080: PPUSH
55081: PPUSH
55082: PPUSH
55083: PPUSH
55084: PPUSH
55085: PPUSH
55086: PPUSH
55087: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55088: LD_VAR 0 1
55092: NOT
55093: PUSH
55094: LD_EXP 65
55098: PUSH
55099: LD_VAR 0 1
55103: ARRAY
55104: NOT
55105: OR
55106: PUSH
55107: LD_EXP 65
55111: PUSH
55112: LD_VAR 0 1
55116: ARRAY
55117: PPUSH
55118: LD_INT 2
55120: PUSH
55121: LD_INT 30
55123: PUSH
55124: LD_INT 0
55126: PUSH
55127: EMPTY
55128: LIST
55129: LIST
55130: PUSH
55131: LD_INT 30
55133: PUSH
55134: LD_INT 1
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: LIST
55145: PPUSH
55146: CALL_OW 72
55150: NOT
55151: OR
55152: IFFALSE 55156
// exit ;
55154: GO 58659
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55156: LD_ADDR_VAR 0 4
55160: PUSH
55161: LD_EXP 65
55165: PUSH
55166: LD_VAR 0 1
55170: ARRAY
55171: PPUSH
55172: LD_INT 2
55174: PUSH
55175: LD_INT 25
55177: PUSH
55178: LD_INT 1
55180: PUSH
55181: EMPTY
55182: LIST
55183: LIST
55184: PUSH
55185: LD_INT 25
55187: PUSH
55188: LD_INT 2
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: PUSH
55195: LD_INT 25
55197: PUSH
55198: LD_INT 3
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: PUSH
55205: LD_INT 25
55207: PUSH
55208: LD_INT 4
55210: PUSH
55211: EMPTY
55212: LIST
55213: LIST
55214: PUSH
55215: LD_INT 25
55217: PUSH
55218: LD_INT 5
55220: PUSH
55221: EMPTY
55222: LIST
55223: LIST
55224: PUSH
55225: LD_INT 25
55227: PUSH
55228: LD_INT 8
55230: PUSH
55231: EMPTY
55232: LIST
55233: LIST
55234: PUSH
55235: LD_INT 25
55237: PUSH
55238: LD_INT 9
55240: PUSH
55241: EMPTY
55242: LIST
55243: LIST
55244: PUSH
55245: EMPTY
55246: LIST
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: PPUSH
55255: CALL_OW 72
55259: ST_TO_ADDR
// if not tmp then
55260: LD_VAR 0 4
55264: NOT
55265: IFFALSE 55269
// exit ;
55267: GO 58659
// for i in tmp do
55269: LD_ADDR_VAR 0 3
55273: PUSH
55274: LD_VAR 0 4
55278: PUSH
55279: FOR_IN
55280: IFFALSE 55311
// if GetTag ( i ) then
55282: LD_VAR 0 3
55286: PPUSH
55287: CALL_OW 110
55291: IFFALSE 55309
// tmp := tmp diff i ;
55293: LD_ADDR_VAR 0 4
55297: PUSH
55298: LD_VAR 0 4
55302: PUSH
55303: LD_VAR 0 3
55307: DIFF
55308: ST_TO_ADDR
55309: GO 55279
55311: POP
55312: POP
// if not tmp then
55313: LD_VAR 0 4
55317: NOT
55318: IFFALSE 55322
// exit ;
55320: GO 58659
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55322: LD_ADDR_VAR 0 5
55326: PUSH
55327: LD_EXP 65
55331: PUSH
55332: LD_VAR 0 1
55336: ARRAY
55337: PPUSH
55338: LD_INT 2
55340: PUSH
55341: LD_INT 25
55343: PUSH
55344: LD_INT 1
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: PUSH
55351: LD_INT 25
55353: PUSH
55354: LD_INT 5
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: PUSH
55361: LD_INT 25
55363: PUSH
55364: LD_INT 8
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: LD_INT 25
55373: PUSH
55374: LD_INT 9
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: PUSH
55381: EMPTY
55382: LIST
55383: LIST
55384: LIST
55385: LIST
55386: LIST
55387: PPUSH
55388: CALL_OW 72
55392: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55393: LD_ADDR_VAR 0 6
55397: PUSH
55398: LD_EXP 65
55402: PUSH
55403: LD_VAR 0 1
55407: ARRAY
55408: PPUSH
55409: LD_INT 25
55411: PUSH
55412: LD_INT 2
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: PPUSH
55419: CALL_OW 72
55423: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55424: LD_ADDR_VAR 0 7
55428: PUSH
55429: LD_EXP 65
55433: PUSH
55434: LD_VAR 0 1
55438: ARRAY
55439: PPUSH
55440: LD_INT 25
55442: PUSH
55443: LD_INT 3
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: PPUSH
55450: CALL_OW 72
55454: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55455: LD_ADDR_VAR 0 8
55459: PUSH
55460: LD_EXP 65
55464: PUSH
55465: LD_VAR 0 1
55469: ARRAY
55470: PPUSH
55471: LD_INT 25
55473: PUSH
55474: LD_INT 4
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: PUSH
55481: LD_INT 24
55483: PUSH
55484: LD_INT 251
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: PPUSH
55495: CALL_OW 72
55499: ST_TO_ADDR
// if mc_scan [ base ] then
55500: LD_EXP 88
55504: PUSH
55505: LD_VAR 0 1
55509: ARRAY
55510: IFFALSE 55971
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55512: LD_ADDR_EXP 107
55516: PUSH
55517: LD_EXP 107
55521: PPUSH
55522: LD_VAR 0 1
55526: PPUSH
55527: LD_INT 4
55529: PPUSH
55530: CALL_OW 1
55534: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55535: LD_ADDR_VAR 0 12
55539: PUSH
55540: LD_EXP 65
55544: PUSH
55545: LD_VAR 0 1
55549: ARRAY
55550: PPUSH
55551: LD_INT 2
55553: PUSH
55554: LD_INT 30
55556: PUSH
55557: LD_INT 4
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: LD_INT 30
55566: PUSH
55567: LD_INT 5
55569: PUSH
55570: EMPTY
55571: LIST
55572: LIST
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: LIST
55578: PPUSH
55579: CALL_OW 72
55583: ST_TO_ADDR
// if not b then
55584: LD_VAR 0 12
55588: NOT
55589: IFFALSE 55593
// exit ;
55591: GO 58659
// p := [ ] ;
55593: LD_ADDR_VAR 0 11
55597: PUSH
55598: EMPTY
55599: ST_TO_ADDR
// if sci >= 2 then
55600: LD_VAR 0 8
55604: PUSH
55605: LD_INT 2
55607: GREATEREQUAL
55608: IFFALSE 55639
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55610: LD_ADDR_VAR 0 8
55614: PUSH
55615: LD_VAR 0 8
55619: PUSH
55620: LD_INT 1
55622: ARRAY
55623: PUSH
55624: LD_VAR 0 8
55628: PUSH
55629: LD_INT 2
55631: ARRAY
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: ST_TO_ADDR
55637: GO 55700
// if sci = 1 then
55639: LD_VAR 0 8
55643: PUSH
55644: LD_INT 1
55646: EQUAL
55647: IFFALSE 55668
// sci := [ sci [ 1 ] ] else
55649: LD_ADDR_VAR 0 8
55653: PUSH
55654: LD_VAR 0 8
55658: PUSH
55659: LD_INT 1
55661: ARRAY
55662: PUSH
55663: EMPTY
55664: LIST
55665: ST_TO_ADDR
55666: GO 55700
// if sci = 0 then
55668: LD_VAR 0 8
55672: PUSH
55673: LD_INT 0
55675: EQUAL
55676: IFFALSE 55700
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55678: LD_ADDR_VAR 0 11
55682: PUSH
55683: LD_VAR 0 4
55687: PPUSH
55688: LD_INT 4
55690: PPUSH
55691: CALL 48128 0 2
55695: PUSH
55696: LD_INT 1
55698: ARRAY
55699: ST_TO_ADDR
// if eng > 4 then
55700: LD_VAR 0 6
55704: PUSH
55705: LD_INT 4
55707: GREATER
55708: IFFALSE 55754
// for i = eng downto 4 do
55710: LD_ADDR_VAR 0 3
55714: PUSH
55715: DOUBLE
55716: LD_VAR 0 6
55720: INC
55721: ST_TO_ADDR
55722: LD_INT 4
55724: PUSH
55725: FOR_DOWNTO
55726: IFFALSE 55752
// eng := eng diff eng [ i ] ;
55728: LD_ADDR_VAR 0 6
55732: PUSH
55733: LD_VAR 0 6
55737: PUSH
55738: LD_VAR 0 6
55742: PUSH
55743: LD_VAR 0 3
55747: ARRAY
55748: DIFF
55749: ST_TO_ADDR
55750: GO 55725
55752: POP
55753: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55754: LD_ADDR_VAR 0 4
55758: PUSH
55759: LD_VAR 0 4
55763: PUSH
55764: LD_VAR 0 5
55768: PUSH
55769: LD_VAR 0 6
55773: UNION
55774: PUSH
55775: LD_VAR 0 7
55779: UNION
55780: PUSH
55781: LD_VAR 0 8
55785: UNION
55786: DIFF
55787: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55788: LD_ADDR_VAR 0 13
55792: PUSH
55793: LD_EXP 65
55797: PUSH
55798: LD_VAR 0 1
55802: ARRAY
55803: PPUSH
55804: LD_INT 2
55806: PUSH
55807: LD_INT 30
55809: PUSH
55810: LD_INT 32
55812: PUSH
55813: EMPTY
55814: LIST
55815: LIST
55816: PUSH
55817: LD_INT 30
55819: PUSH
55820: LD_INT 31
55822: PUSH
55823: EMPTY
55824: LIST
55825: LIST
55826: PUSH
55827: EMPTY
55828: LIST
55829: LIST
55830: LIST
55831: PPUSH
55832: CALL_OW 72
55836: PUSH
55837: LD_EXP 65
55841: PUSH
55842: LD_VAR 0 1
55846: ARRAY
55847: PPUSH
55848: LD_INT 2
55850: PUSH
55851: LD_INT 30
55853: PUSH
55854: LD_INT 4
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: PUSH
55861: LD_INT 30
55863: PUSH
55864: LD_INT 5
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: PUSH
55871: EMPTY
55872: LIST
55873: LIST
55874: LIST
55875: PPUSH
55876: CALL_OW 72
55880: PUSH
55881: LD_INT 6
55883: MUL
55884: PLUS
55885: ST_TO_ADDR
// if bcount < tmp then
55886: LD_VAR 0 13
55890: PUSH
55891: LD_VAR 0 4
55895: LESS
55896: IFFALSE 55942
// for i = tmp downto bcount do
55898: LD_ADDR_VAR 0 3
55902: PUSH
55903: DOUBLE
55904: LD_VAR 0 4
55908: INC
55909: ST_TO_ADDR
55910: LD_VAR 0 13
55914: PUSH
55915: FOR_DOWNTO
55916: IFFALSE 55940
// tmp := Delete ( tmp , tmp ) ;
55918: LD_ADDR_VAR 0 4
55922: PUSH
55923: LD_VAR 0 4
55927: PPUSH
55928: LD_VAR 0 4
55932: PPUSH
55933: CALL_OW 3
55937: ST_TO_ADDR
55938: GO 55915
55940: POP
55941: POP
// result := [ tmp , 0 , 0 , p ] ;
55942: LD_ADDR_VAR 0 2
55946: PUSH
55947: LD_VAR 0 4
55951: PUSH
55952: LD_INT 0
55954: PUSH
55955: LD_INT 0
55957: PUSH
55958: LD_VAR 0 11
55962: PUSH
55963: EMPTY
55964: LIST
55965: LIST
55966: LIST
55967: LIST
55968: ST_TO_ADDR
// exit ;
55969: GO 58659
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55971: LD_EXP 65
55975: PUSH
55976: LD_VAR 0 1
55980: ARRAY
55981: PPUSH
55982: LD_INT 2
55984: PUSH
55985: LD_INT 30
55987: PUSH
55988: LD_INT 6
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: PUSH
55995: LD_INT 30
55997: PUSH
55998: LD_INT 7
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: PUSH
56005: LD_INT 30
56007: PUSH
56008: LD_INT 8
56010: PUSH
56011: EMPTY
56012: LIST
56013: LIST
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: LIST
56019: LIST
56020: PPUSH
56021: CALL_OW 72
56025: NOT
56026: PUSH
56027: LD_EXP 65
56031: PUSH
56032: LD_VAR 0 1
56036: ARRAY
56037: PPUSH
56038: LD_INT 30
56040: PUSH
56041: LD_INT 3
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: PPUSH
56048: CALL_OW 72
56052: NOT
56053: AND
56054: IFFALSE 56126
// begin if eng = tmp then
56056: LD_VAR 0 6
56060: PUSH
56061: LD_VAR 0 4
56065: EQUAL
56066: IFFALSE 56070
// exit ;
56068: GO 58659
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56070: LD_ADDR_EXP 107
56074: PUSH
56075: LD_EXP 107
56079: PPUSH
56080: LD_VAR 0 1
56084: PPUSH
56085: LD_INT 1
56087: PPUSH
56088: CALL_OW 1
56092: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56093: LD_ADDR_VAR 0 2
56097: PUSH
56098: LD_INT 0
56100: PUSH
56101: LD_VAR 0 4
56105: PUSH
56106: LD_VAR 0 6
56110: DIFF
56111: PUSH
56112: LD_INT 0
56114: PUSH
56115: LD_INT 0
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: ST_TO_ADDR
// exit ;
56124: GO 58659
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56126: LD_EXP 92
56130: PUSH
56131: LD_EXP 91
56135: PUSH
56136: LD_VAR 0 1
56140: ARRAY
56141: ARRAY
56142: PUSH
56143: LD_EXP 65
56147: PUSH
56148: LD_VAR 0 1
56152: ARRAY
56153: PPUSH
56154: LD_INT 2
56156: PUSH
56157: LD_INT 30
56159: PUSH
56160: LD_INT 6
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: PUSH
56167: LD_INT 30
56169: PUSH
56170: LD_INT 7
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PUSH
56177: LD_INT 30
56179: PUSH
56180: LD_INT 8
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: PPUSH
56193: CALL_OW 72
56197: AND
56198: PUSH
56199: LD_EXP 65
56203: PUSH
56204: LD_VAR 0 1
56208: ARRAY
56209: PPUSH
56210: LD_INT 30
56212: PUSH
56213: LD_INT 3
56215: PUSH
56216: EMPTY
56217: LIST
56218: LIST
56219: PPUSH
56220: CALL_OW 72
56224: NOT
56225: AND
56226: IFFALSE 56440
// begin if sci >= 6 then
56228: LD_VAR 0 8
56232: PUSH
56233: LD_INT 6
56235: GREATEREQUAL
56236: IFFALSE 56240
// exit ;
56238: GO 58659
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56240: LD_ADDR_EXP 107
56244: PUSH
56245: LD_EXP 107
56249: PPUSH
56250: LD_VAR 0 1
56254: PPUSH
56255: LD_INT 2
56257: PPUSH
56258: CALL_OW 1
56262: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56263: LD_ADDR_VAR 0 9
56267: PUSH
56268: LD_VAR 0 4
56272: PUSH
56273: LD_VAR 0 8
56277: DIFF
56278: PPUSH
56279: LD_INT 4
56281: PPUSH
56282: CALL 48128 0 2
56286: ST_TO_ADDR
// p := [ ] ;
56287: LD_ADDR_VAR 0 11
56291: PUSH
56292: EMPTY
56293: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56294: LD_VAR 0 8
56298: PUSH
56299: LD_INT 6
56301: LESS
56302: PUSH
56303: LD_VAR 0 9
56307: PUSH
56308: LD_INT 6
56310: GREATER
56311: AND
56312: IFFALSE 56393
// begin for i = 1 to 6 - sci do
56314: LD_ADDR_VAR 0 3
56318: PUSH
56319: DOUBLE
56320: LD_INT 1
56322: DEC
56323: ST_TO_ADDR
56324: LD_INT 6
56326: PUSH
56327: LD_VAR 0 8
56331: MINUS
56332: PUSH
56333: FOR_TO
56334: IFFALSE 56389
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56336: LD_ADDR_VAR 0 11
56340: PUSH
56341: LD_VAR 0 11
56345: PPUSH
56346: LD_VAR 0 11
56350: PUSH
56351: LD_INT 1
56353: PLUS
56354: PPUSH
56355: LD_VAR 0 9
56359: PUSH
56360: LD_INT 1
56362: ARRAY
56363: PPUSH
56364: CALL_OW 2
56368: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56369: LD_ADDR_VAR 0 9
56373: PUSH
56374: LD_VAR 0 9
56378: PPUSH
56379: LD_INT 1
56381: PPUSH
56382: CALL_OW 3
56386: ST_TO_ADDR
// end ;
56387: GO 56333
56389: POP
56390: POP
// end else
56391: GO 56413
// if sort then
56393: LD_VAR 0 9
56397: IFFALSE 56413
// p := sort [ 1 ] ;
56399: LD_ADDR_VAR 0 11
56403: PUSH
56404: LD_VAR 0 9
56408: PUSH
56409: LD_INT 1
56411: ARRAY
56412: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56413: LD_ADDR_VAR 0 2
56417: PUSH
56418: LD_INT 0
56420: PUSH
56421: LD_INT 0
56423: PUSH
56424: LD_INT 0
56426: PUSH
56427: LD_VAR 0 11
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: LIST
56436: LIST
56437: ST_TO_ADDR
// exit ;
56438: GO 58659
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56440: LD_EXP 92
56444: PUSH
56445: LD_EXP 91
56449: PUSH
56450: LD_VAR 0 1
56454: ARRAY
56455: ARRAY
56456: PUSH
56457: LD_EXP 65
56461: PUSH
56462: LD_VAR 0 1
56466: ARRAY
56467: PPUSH
56468: LD_INT 2
56470: PUSH
56471: LD_INT 30
56473: PUSH
56474: LD_INT 6
56476: PUSH
56477: EMPTY
56478: LIST
56479: LIST
56480: PUSH
56481: LD_INT 30
56483: PUSH
56484: LD_INT 7
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: PUSH
56491: LD_INT 30
56493: PUSH
56494: LD_INT 8
56496: PUSH
56497: EMPTY
56498: LIST
56499: LIST
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: LIST
56505: LIST
56506: PPUSH
56507: CALL_OW 72
56511: AND
56512: PUSH
56513: LD_EXP 65
56517: PUSH
56518: LD_VAR 0 1
56522: ARRAY
56523: PPUSH
56524: LD_INT 30
56526: PUSH
56527: LD_INT 3
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PPUSH
56534: CALL_OW 72
56538: AND
56539: IFFALSE 57273
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56541: LD_ADDR_EXP 107
56545: PUSH
56546: LD_EXP 107
56550: PPUSH
56551: LD_VAR 0 1
56555: PPUSH
56556: LD_INT 3
56558: PPUSH
56559: CALL_OW 1
56563: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56564: LD_ADDR_VAR 0 2
56568: PUSH
56569: LD_INT 0
56571: PUSH
56572: LD_INT 0
56574: PUSH
56575: LD_INT 0
56577: PUSH
56578: LD_INT 0
56580: PUSH
56581: EMPTY
56582: LIST
56583: LIST
56584: LIST
56585: LIST
56586: ST_TO_ADDR
// if not eng then
56587: LD_VAR 0 6
56591: NOT
56592: IFFALSE 56655
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56594: LD_ADDR_VAR 0 11
56598: PUSH
56599: LD_VAR 0 4
56603: PPUSH
56604: LD_INT 2
56606: PPUSH
56607: CALL 48128 0 2
56611: PUSH
56612: LD_INT 1
56614: ARRAY
56615: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56616: LD_ADDR_VAR 0 2
56620: PUSH
56621: LD_VAR 0 2
56625: PPUSH
56626: LD_INT 2
56628: PPUSH
56629: LD_VAR 0 11
56633: PPUSH
56634: CALL_OW 1
56638: ST_TO_ADDR
// tmp := tmp diff p ;
56639: LD_ADDR_VAR 0 4
56643: PUSH
56644: LD_VAR 0 4
56648: PUSH
56649: LD_VAR 0 11
56653: DIFF
56654: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56655: LD_VAR 0 4
56659: PUSH
56660: LD_VAR 0 8
56664: PUSH
56665: LD_INT 6
56667: LESS
56668: AND
56669: IFFALSE 56857
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56671: LD_ADDR_VAR 0 9
56675: PUSH
56676: LD_VAR 0 4
56680: PUSH
56681: LD_VAR 0 8
56685: PUSH
56686: LD_VAR 0 7
56690: UNION
56691: DIFF
56692: PPUSH
56693: LD_INT 4
56695: PPUSH
56696: CALL 48128 0 2
56700: ST_TO_ADDR
// p := [ ] ;
56701: LD_ADDR_VAR 0 11
56705: PUSH
56706: EMPTY
56707: ST_TO_ADDR
// if sort then
56708: LD_VAR 0 9
56712: IFFALSE 56828
// for i = 1 to 6 - sci do
56714: LD_ADDR_VAR 0 3
56718: PUSH
56719: DOUBLE
56720: LD_INT 1
56722: DEC
56723: ST_TO_ADDR
56724: LD_INT 6
56726: PUSH
56727: LD_VAR 0 8
56731: MINUS
56732: PUSH
56733: FOR_TO
56734: IFFALSE 56826
// begin if i = sort then
56736: LD_VAR 0 3
56740: PUSH
56741: LD_VAR 0 9
56745: EQUAL
56746: IFFALSE 56750
// break ;
56748: GO 56826
// if GetClass ( i ) = 4 then
56750: LD_VAR 0 3
56754: PPUSH
56755: CALL_OW 257
56759: PUSH
56760: LD_INT 4
56762: EQUAL
56763: IFFALSE 56767
// continue ;
56765: GO 56733
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56767: LD_ADDR_VAR 0 11
56771: PUSH
56772: LD_VAR 0 11
56776: PPUSH
56777: LD_VAR 0 11
56781: PUSH
56782: LD_INT 1
56784: PLUS
56785: PPUSH
56786: LD_VAR 0 9
56790: PUSH
56791: LD_VAR 0 3
56795: ARRAY
56796: PPUSH
56797: CALL_OW 2
56801: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56802: LD_ADDR_VAR 0 4
56806: PUSH
56807: LD_VAR 0 4
56811: PUSH
56812: LD_VAR 0 9
56816: PUSH
56817: LD_VAR 0 3
56821: ARRAY
56822: DIFF
56823: ST_TO_ADDR
// end ;
56824: GO 56733
56826: POP
56827: POP
// if p then
56828: LD_VAR 0 11
56832: IFFALSE 56857
// result := Replace ( result , 4 , p ) ;
56834: LD_ADDR_VAR 0 2
56838: PUSH
56839: LD_VAR 0 2
56843: PPUSH
56844: LD_INT 4
56846: PPUSH
56847: LD_VAR 0 11
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56857: LD_VAR 0 4
56861: PUSH
56862: LD_VAR 0 7
56866: PUSH
56867: LD_INT 6
56869: LESS
56870: AND
56871: IFFALSE 57059
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56873: LD_ADDR_VAR 0 9
56877: PUSH
56878: LD_VAR 0 4
56882: PUSH
56883: LD_VAR 0 8
56887: PUSH
56888: LD_VAR 0 7
56892: UNION
56893: DIFF
56894: PPUSH
56895: LD_INT 3
56897: PPUSH
56898: CALL 48128 0 2
56902: ST_TO_ADDR
// p := [ ] ;
56903: LD_ADDR_VAR 0 11
56907: PUSH
56908: EMPTY
56909: ST_TO_ADDR
// if sort then
56910: LD_VAR 0 9
56914: IFFALSE 57030
// for i = 1 to 6 - mech do
56916: LD_ADDR_VAR 0 3
56920: PUSH
56921: DOUBLE
56922: LD_INT 1
56924: DEC
56925: ST_TO_ADDR
56926: LD_INT 6
56928: PUSH
56929: LD_VAR 0 7
56933: MINUS
56934: PUSH
56935: FOR_TO
56936: IFFALSE 57028
// begin if i = sort then
56938: LD_VAR 0 3
56942: PUSH
56943: LD_VAR 0 9
56947: EQUAL
56948: IFFALSE 56952
// break ;
56950: GO 57028
// if GetClass ( i ) = 3 then
56952: LD_VAR 0 3
56956: PPUSH
56957: CALL_OW 257
56961: PUSH
56962: LD_INT 3
56964: EQUAL
56965: IFFALSE 56969
// continue ;
56967: GO 56935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56969: LD_ADDR_VAR 0 11
56973: PUSH
56974: LD_VAR 0 11
56978: PPUSH
56979: LD_VAR 0 11
56983: PUSH
56984: LD_INT 1
56986: PLUS
56987: PPUSH
56988: LD_VAR 0 9
56992: PUSH
56993: LD_VAR 0 3
56997: ARRAY
56998: PPUSH
56999: CALL_OW 2
57003: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57004: LD_ADDR_VAR 0 4
57008: PUSH
57009: LD_VAR 0 4
57013: PUSH
57014: LD_VAR 0 9
57018: PUSH
57019: LD_VAR 0 3
57023: ARRAY
57024: DIFF
57025: ST_TO_ADDR
// end ;
57026: GO 56935
57028: POP
57029: POP
// if p then
57030: LD_VAR 0 11
57034: IFFALSE 57059
// result := Replace ( result , 3 , p ) ;
57036: LD_ADDR_VAR 0 2
57040: PUSH
57041: LD_VAR 0 2
57045: PPUSH
57046: LD_INT 3
57048: PPUSH
57049: LD_VAR 0 11
57053: PPUSH
57054: CALL_OW 1
57058: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57059: LD_VAR 0 4
57063: PUSH
57064: LD_INT 6
57066: GREATER
57067: PUSH
57068: LD_VAR 0 6
57072: PUSH
57073: LD_INT 6
57075: LESS
57076: AND
57077: IFFALSE 57271
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57079: LD_ADDR_VAR 0 9
57083: PUSH
57084: LD_VAR 0 4
57088: PUSH
57089: LD_VAR 0 8
57093: PUSH
57094: LD_VAR 0 7
57098: UNION
57099: PUSH
57100: LD_VAR 0 6
57104: UNION
57105: DIFF
57106: PPUSH
57107: LD_INT 2
57109: PPUSH
57110: CALL 48128 0 2
57114: ST_TO_ADDR
// p := [ ] ;
57115: LD_ADDR_VAR 0 11
57119: PUSH
57120: EMPTY
57121: ST_TO_ADDR
// if sort then
57122: LD_VAR 0 9
57126: IFFALSE 57242
// for i = 1 to 6 - eng do
57128: LD_ADDR_VAR 0 3
57132: PUSH
57133: DOUBLE
57134: LD_INT 1
57136: DEC
57137: ST_TO_ADDR
57138: LD_INT 6
57140: PUSH
57141: LD_VAR 0 6
57145: MINUS
57146: PUSH
57147: FOR_TO
57148: IFFALSE 57240
// begin if i = sort then
57150: LD_VAR 0 3
57154: PUSH
57155: LD_VAR 0 9
57159: EQUAL
57160: IFFALSE 57164
// break ;
57162: GO 57240
// if GetClass ( i ) = 2 then
57164: LD_VAR 0 3
57168: PPUSH
57169: CALL_OW 257
57173: PUSH
57174: LD_INT 2
57176: EQUAL
57177: IFFALSE 57181
// continue ;
57179: GO 57147
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57181: LD_ADDR_VAR 0 11
57185: PUSH
57186: LD_VAR 0 11
57190: PPUSH
57191: LD_VAR 0 11
57195: PUSH
57196: LD_INT 1
57198: PLUS
57199: PPUSH
57200: LD_VAR 0 9
57204: PUSH
57205: LD_VAR 0 3
57209: ARRAY
57210: PPUSH
57211: CALL_OW 2
57215: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57216: LD_ADDR_VAR 0 4
57220: PUSH
57221: LD_VAR 0 4
57225: PUSH
57226: LD_VAR 0 9
57230: PUSH
57231: LD_VAR 0 3
57235: ARRAY
57236: DIFF
57237: ST_TO_ADDR
// end ;
57238: GO 57147
57240: POP
57241: POP
// if p then
57242: LD_VAR 0 11
57246: IFFALSE 57271
// result := Replace ( result , 2 , p ) ;
57248: LD_ADDR_VAR 0 2
57252: PUSH
57253: LD_VAR 0 2
57257: PPUSH
57258: LD_INT 2
57260: PPUSH
57261: LD_VAR 0 11
57265: PPUSH
57266: CALL_OW 1
57270: ST_TO_ADDR
// end ; exit ;
57271: GO 58659
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57273: LD_EXP 92
57277: PUSH
57278: LD_EXP 91
57282: PUSH
57283: LD_VAR 0 1
57287: ARRAY
57288: ARRAY
57289: NOT
57290: PUSH
57291: LD_EXP 65
57295: PUSH
57296: LD_VAR 0 1
57300: ARRAY
57301: PPUSH
57302: LD_INT 30
57304: PUSH
57305: LD_INT 3
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PPUSH
57312: CALL_OW 72
57316: AND
57317: PUSH
57318: LD_EXP 70
57322: PUSH
57323: LD_VAR 0 1
57327: ARRAY
57328: AND
57329: IFFALSE 57937
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57331: LD_ADDR_EXP 107
57335: PUSH
57336: LD_EXP 107
57340: PPUSH
57341: LD_VAR 0 1
57345: PPUSH
57346: LD_INT 5
57348: PPUSH
57349: CALL_OW 1
57353: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57354: LD_ADDR_VAR 0 2
57358: PUSH
57359: LD_INT 0
57361: PUSH
57362: LD_INT 0
57364: PUSH
57365: LD_INT 0
57367: PUSH
57368: LD_INT 0
57370: PUSH
57371: EMPTY
57372: LIST
57373: LIST
57374: LIST
57375: LIST
57376: ST_TO_ADDR
// if sci > 1 then
57377: LD_VAR 0 8
57381: PUSH
57382: LD_INT 1
57384: GREATER
57385: IFFALSE 57413
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57387: LD_ADDR_VAR 0 4
57391: PUSH
57392: LD_VAR 0 4
57396: PUSH
57397: LD_VAR 0 8
57401: PUSH
57402: LD_VAR 0 8
57406: PUSH
57407: LD_INT 1
57409: ARRAY
57410: DIFF
57411: DIFF
57412: ST_TO_ADDR
// if tmp and not sci then
57413: LD_VAR 0 4
57417: PUSH
57418: LD_VAR 0 8
57422: NOT
57423: AND
57424: IFFALSE 57493
// begin sort := SortBySkill ( tmp , 4 ) ;
57426: LD_ADDR_VAR 0 9
57430: PUSH
57431: LD_VAR 0 4
57435: PPUSH
57436: LD_INT 4
57438: PPUSH
57439: CALL 48128 0 2
57443: ST_TO_ADDR
// if sort then
57444: LD_VAR 0 9
57448: IFFALSE 57464
// p := sort [ 1 ] ;
57450: LD_ADDR_VAR 0 11
57454: PUSH
57455: LD_VAR 0 9
57459: PUSH
57460: LD_INT 1
57462: ARRAY
57463: ST_TO_ADDR
// if p then
57464: LD_VAR 0 11
57468: IFFALSE 57493
// result := Replace ( result , 4 , p ) ;
57470: LD_ADDR_VAR 0 2
57474: PUSH
57475: LD_VAR 0 2
57479: PPUSH
57480: LD_INT 4
57482: PPUSH
57483: LD_VAR 0 11
57487: PPUSH
57488: CALL_OW 1
57492: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57493: LD_ADDR_VAR 0 4
57497: PUSH
57498: LD_VAR 0 4
57502: PUSH
57503: LD_VAR 0 7
57507: DIFF
57508: ST_TO_ADDR
// if tmp and mech < 6 then
57509: LD_VAR 0 4
57513: PUSH
57514: LD_VAR 0 7
57518: PUSH
57519: LD_INT 6
57521: LESS
57522: AND
57523: IFFALSE 57711
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57525: LD_ADDR_VAR 0 9
57529: PUSH
57530: LD_VAR 0 4
57534: PUSH
57535: LD_VAR 0 8
57539: PUSH
57540: LD_VAR 0 7
57544: UNION
57545: DIFF
57546: PPUSH
57547: LD_INT 3
57549: PPUSH
57550: CALL 48128 0 2
57554: ST_TO_ADDR
// p := [ ] ;
57555: LD_ADDR_VAR 0 11
57559: PUSH
57560: EMPTY
57561: ST_TO_ADDR
// if sort then
57562: LD_VAR 0 9
57566: IFFALSE 57682
// for i = 1 to 6 - mech do
57568: LD_ADDR_VAR 0 3
57572: PUSH
57573: DOUBLE
57574: LD_INT 1
57576: DEC
57577: ST_TO_ADDR
57578: LD_INT 6
57580: PUSH
57581: LD_VAR 0 7
57585: MINUS
57586: PUSH
57587: FOR_TO
57588: IFFALSE 57680
// begin if i = sort then
57590: LD_VAR 0 3
57594: PUSH
57595: LD_VAR 0 9
57599: EQUAL
57600: IFFALSE 57604
// break ;
57602: GO 57680
// if GetClass ( i ) = 3 then
57604: LD_VAR 0 3
57608: PPUSH
57609: CALL_OW 257
57613: PUSH
57614: LD_INT 3
57616: EQUAL
57617: IFFALSE 57621
// continue ;
57619: GO 57587
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57621: LD_ADDR_VAR 0 11
57625: PUSH
57626: LD_VAR 0 11
57630: PPUSH
57631: LD_VAR 0 11
57635: PUSH
57636: LD_INT 1
57638: PLUS
57639: PPUSH
57640: LD_VAR 0 9
57644: PUSH
57645: LD_VAR 0 3
57649: ARRAY
57650: PPUSH
57651: CALL_OW 2
57655: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57656: LD_ADDR_VAR 0 4
57660: PUSH
57661: LD_VAR 0 4
57665: PUSH
57666: LD_VAR 0 9
57670: PUSH
57671: LD_VAR 0 3
57675: ARRAY
57676: DIFF
57677: ST_TO_ADDR
// end ;
57678: GO 57587
57680: POP
57681: POP
// if p then
57682: LD_VAR 0 11
57686: IFFALSE 57711
// result := Replace ( result , 3 , p ) ;
57688: LD_ADDR_VAR 0 2
57692: PUSH
57693: LD_VAR 0 2
57697: PPUSH
57698: LD_INT 3
57700: PPUSH
57701: LD_VAR 0 11
57705: PPUSH
57706: CALL_OW 1
57710: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57711: LD_ADDR_VAR 0 4
57715: PUSH
57716: LD_VAR 0 4
57720: PUSH
57721: LD_VAR 0 6
57725: DIFF
57726: ST_TO_ADDR
// if tmp and eng < 6 then
57727: LD_VAR 0 4
57731: PUSH
57732: LD_VAR 0 6
57736: PUSH
57737: LD_INT 6
57739: LESS
57740: AND
57741: IFFALSE 57935
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57743: LD_ADDR_VAR 0 9
57747: PUSH
57748: LD_VAR 0 4
57752: PUSH
57753: LD_VAR 0 8
57757: PUSH
57758: LD_VAR 0 7
57762: UNION
57763: PUSH
57764: LD_VAR 0 6
57768: UNION
57769: DIFF
57770: PPUSH
57771: LD_INT 2
57773: PPUSH
57774: CALL 48128 0 2
57778: ST_TO_ADDR
// p := [ ] ;
57779: LD_ADDR_VAR 0 11
57783: PUSH
57784: EMPTY
57785: ST_TO_ADDR
// if sort then
57786: LD_VAR 0 9
57790: IFFALSE 57906
// for i = 1 to 6 - eng do
57792: LD_ADDR_VAR 0 3
57796: PUSH
57797: DOUBLE
57798: LD_INT 1
57800: DEC
57801: ST_TO_ADDR
57802: LD_INT 6
57804: PUSH
57805: LD_VAR 0 6
57809: MINUS
57810: PUSH
57811: FOR_TO
57812: IFFALSE 57904
// begin if i = sort then
57814: LD_VAR 0 3
57818: PUSH
57819: LD_VAR 0 9
57823: EQUAL
57824: IFFALSE 57828
// break ;
57826: GO 57904
// if GetClass ( i ) = 2 then
57828: LD_VAR 0 3
57832: PPUSH
57833: CALL_OW 257
57837: PUSH
57838: LD_INT 2
57840: EQUAL
57841: IFFALSE 57845
// continue ;
57843: GO 57811
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57845: LD_ADDR_VAR 0 11
57849: PUSH
57850: LD_VAR 0 11
57854: PPUSH
57855: LD_VAR 0 11
57859: PUSH
57860: LD_INT 1
57862: PLUS
57863: PPUSH
57864: LD_VAR 0 9
57868: PUSH
57869: LD_VAR 0 3
57873: ARRAY
57874: PPUSH
57875: CALL_OW 2
57879: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57880: LD_ADDR_VAR 0 4
57884: PUSH
57885: LD_VAR 0 4
57889: PUSH
57890: LD_VAR 0 9
57894: PUSH
57895: LD_VAR 0 3
57899: ARRAY
57900: DIFF
57901: ST_TO_ADDR
// end ;
57902: GO 57811
57904: POP
57905: POP
// if p then
57906: LD_VAR 0 11
57910: IFFALSE 57935
// result := Replace ( result , 2 , p ) ;
57912: LD_ADDR_VAR 0 2
57916: PUSH
57917: LD_VAR 0 2
57921: PPUSH
57922: LD_INT 2
57924: PPUSH
57925: LD_VAR 0 11
57929: PPUSH
57930: CALL_OW 1
57934: ST_TO_ADDR
// end ; exit ;
57935: GO 58659
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57937: LD_EXP 92
57941: PUSH
57942: LD_EXP 91
57946: PUSH
57947: LD_VAR 0 1
57951: ARRAY
57952: ARRAY
57953: NOT
57954: PUSH
57955: LD_EXP 65
57959: PUSH
57960: LD_VAR 0 1
57964: ARRAY
57965: PPUSH
57966: LD_INT 30
57968: PUSH
57969: LD_INT 3
57971: PUSH
57972: EMPTY
57973: LIST
57974: LIST
57975: PPUSH
57976: CALL_OW 72
57980: AND
57981: PUSH
57982: LD_EXP 70
57986: PUSH
57987: LD_VAR 0 1
57991: ARRAY
57992: NOT
57993: AND
57994: IFFALSE 58659
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57996: LD_ADDR_EXP 107
58000: PUSH
58001: LD_EXP 107
58005: PPUSH
58006: LD_VAR 0 1
58010: PPUSH
58011: LD_INT 6
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58019: LD_ADDR_VAR 0 2
58023: PUSH
58024: LD_INT 0
58026: PUSH
58027: LD_INT 0
58029: PUSH
58030: LD_INT 0
58032: PUSH
58033: LD_INT 0
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: LIST
58040: LIST
58041: ST_TO_ADDR
// if sci >= 1 then
58042: LD_VAR 0 8
58046: PUSH
58047: LD_INT 1
58049: GREATEREQUAL
58050: IFFALSE 58072
// tmp := tmp diff sci [ 1 ] ;
58052: LD_ADDR_VAR 0 4
58056: PUSH
58057: LD_VAR 0 4
58061: PUSH
58062: LD_VAR 0 8
58066: PUSH
58067: LD_INT 1
58069: ARRAY
58070: DIFF
58071: ST_TO_ADDR
// if tmp and not sci then
58072: LD_VAR 0 4
58076: PUSH
58077: LD_VAR 0 8
58081: NOT
58082: AND
58083: IFFALSE 58152
// begin sort := SortBySkill ( tmp , 4 ) ;
58085: LD_ADDR_VAR 0 9
58089: PUSH
58090: LD_VAR 0 4
58094: PPUSH
58095: LD_INT 4
58097: PPUSH
58098: CALL 48128 0 2
58102: ST_TO_ADDR
// if sort then
58103: LD_VAR 0 9
58107: IFFALSE 58123
// p := sort [ 1 ] ;
58109: LD_ADDR_VAR 0 11
58113: PUSH
58114: LD_VAR 0 9
58118: PUSH
58119: LD_INT 1
58121: ARRAY
58122: ST_TO_ADDR
// if p then
58123: LD_VAR 0 11
58127: IFFALSE 58152
// result := Replace ( result , 4 , p ) ;
58129: LD_ADDR_VAR 0 2
58133: PUSH
58134: LD_VAR 0 2
58138: PPUSH
58139: LD_INT 4
58141: PPUSH
58142: LD_VAR 0 11
58146: PPUSH
58147: CALL_OW 1
58151: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58152: LD_ADDR_VAR 0 4
58156: PUSH
58157: LD_VAR 0 4
58161: PUSH
58162: LD_VAR 0 7
58166: DIFF
58167: ST_TO_ADDR
// if tmp and mech < 6 then
58168: LD_VAR 0 4
58172: PUSH
58173: LD_VAR 0 7
58177: PUSH
58178: LD_INT 6
58180: LESS
58181: AND
58182: IFFALSE 58364
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58184: LD_ADDR_VAR 0 9
58188: PUSH
58189: LD_VAR 0 4
58193: PUSH
58194: LD_VAR 0 7
58198: DIFF
58199: PPUSH
58200: LD_INT 3
58202: PPUSH
58203: CALL 48128 0 2
58207: ST_TO_ADDR
// p := [ ] ;
58208: LD_ADDR_VAR 0 11
58212: PUSH
58213: EMPTY
58214: ST_TO_ADDR
// if sort then
58215: LD_VAR 0 9
58219: IFFALSE 58335
// for i = 1 to 6 - mech do
58221: LD_ADDR_VAR 0 3
58225: PUSH
58226: DOUBLE
58227: LD_INT 1
58229: DEC
58230: ST_TO_ADDR
58231: LD_INT 6
58233: PUSH
58234: LD_VAR 0 7
58238: MINUS
58239: PUSH
58240: FOR_TO
58241: IFFALSE 58333
// begin if i = sort then
58243: LD_VAR 0 3
58247: PUSH
58248: LD_VAR 0 9
58252: EQUAL
58253: IFFALSE 58257
// break ;
58255: GO 58333
// if GetClass ( i ) = 3 then
58257: LD_VAR 0 3
58261: PPUSH
58262: CALL_OW 257
58266: PUSH
58267: LD_INT 3
58269: EQUAL
58270: IFFALSE 58274
// continue ;
58272: GO 58240
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58274: LD_ADDR_VAR 0 11
58278: PUSH
58279: LD_VAR 0 11
58283: PPUSH
58284: LD_VAR 0 11
58288: PUSH
58289: LD_INT 1
58291: PLUS
58292: PPUSH
58293: LD_VAR 0 9
58297: PUSH
58298: LD_VAR 0 3
58302: ARRAY
58303: PPUSH
58304: CALL_OW 2
58308: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58309: LD_ADDR_VAR 0 4
58313: PUSH
58314: LD_VAR 0 4
58318: PUSH
58319: LD_VAR 0 9
58323: PUSH
58324: LD_VAR 0 3
58328: ARRAY
58329: DIFF
58330: ST_TO_ADDR
// end ;
58331: GO 58240
58333: POP
58334: POP
// if p then
58335: LD_VAR 0 11
58339: IFFALSE 58364
// result := Replace ( result , 3 , p ) ;
58341: LD_ADDR_VAR 0 2
58345: PUSH
58346: LD_VAR 0 2
58350: PPUSH
58351: LD_INT 3
58353: PPUSH
58354: LD_VAR 0 11
58358: PPUSH
58359: CALL_OW 1
58363: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58364: LD_ADDR_VAR 0 4
58368: PUSH
58369: LD_VAR 0 4
58373: PUSH
58374: LD_VAR 0 6
58378: DIFF
58379: ST_TO_ADDR
// if tmp and eng < 4 then
58380: LD_VAR 0 4
58384: PUSH
58385: LD_VAR 0 6
58389: PUSH
58390: LD_INT 4
58392: LESS
58393: AND
58394: IFFALSE 58584
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58396: LD_ADDR_VAR 0 9
58400: PUSH
58401: LD_VAR 0 4
58405: PUSH
58406: LD_VAR 0 7
58410: PUSH
58411: LD_VAR 0 6
58415: UNION
58416: DIFF
58417: PPUSH
58418: LD_INT 2
58420: PPUSH
58421: CALL 48128 0 2
58425: ST_TO_ADDR
// p := [ ] ;
58426: LD_ADDR_VAR 0 11
58430: PUSH
58431: EMPTY
58432: ST_TO_ADDR
// if sort then
58433: LD_VAR 0 9
58437: IFFALSE 58553
// for i = 1 to 4 - eng do
58439: LD_ADDR_VAR 0 3
58443: PUSH
58444: DOUBLE
58445: LD_INT 1
58447: DEC
58448: ST_TO_ADDR
58449: LD_INT 4
58451: PUSH
58452: LD_VAR 0 6
58456: MINUS
58457: PUSH
58458: FOR_TO
58459: IFFALSE 58551
// begin if i = sort then
58461: LD_VAR 0 3
58465: PUSH
58466: LD_VAR 0 9
58470: EQUAL
58471: IFFALSE 58475
// break ;
58473: GO 58551
// if GetClass ( i ) = 2 then
58475: LD_VAR 0 3
58479: PPUSH
58480: CALL_OW 257
58484: PUSH
58485: LD_INT 2
58487: EQUAL
58488: IFFALSE 58492
// continue ;
58490: GO 58458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58492: LD_ADDR_VAR 0 11
58496: PUSH
58497: LD_VAR 0 11
58501: PPUSH
58502: LD_VAR 0 11
58506: PUSH
58507: LD_INT 1
58509: PLUS
58510: PPUSH
58511: LD_VAR 0 9
58515: PUSH
58516: LD_VAR 0 3
58520: ARRAY
58521: PPUSH
58522: CALL_OW 2
58526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58527: LD_ADDR_VAR 0 4
58531: PUSH
58532: LD_VAR 0 4
58536: PUSH
58537: LD_VAR 0 9
58541: PUSH
58542: LD_VAR 0 3
58546: ARRAY
58547: DIFF
58548: ST_TO_ADDR
// end ;
58549: GO 58458
58551: POP
58552: POP
// if p then
58553: LD_VAR 0 11
58557: IFFALSE 58582
// result := Replace ( result , 2 , p ) ;
58559: LD_ADDR_VAR 0 2
58563: PUSH
58564: LD_VAR 0 2
58568: PPUSH
58569: LD_INT 2
58571: PPUSH
58572: LD_VAR 0 11
58576: PPUSH
58577: CALL_OW 1
58581: ST_TO_ADDR
// end else
58582: GO 58628
// for i = eng downto 5 do
58584: LD_ADDR_VAR 0 3
58588: PUSH
58589: DOUBLE
58590: LD_VAR 0 6
58594: INC
58595: ST_TO_ADDR
58596: LD_INT 5
58598: PUSH
58599: FOR_DOWNTO
58600: IFFALSE 58626
// tmp := tmp union eng [ i ] ;
58602: LD_ADDR_VAR 0 4
58606: PUSH
58607: LD_VAR 0 4
58611: PUSH
58612: LD_VAR 0 6
58616: PUSH
58617: LD_VAR 0 3
58621: ARRAY
58622: UNION
58623: ST_TO_ADDR
58624: GO 58599
58626: POP
58627: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58628: LD_ADDR_VAR 0 2
58632: PUSH
58633: LD_VAR 0 2
58637: PPUSH
58638: LD_INT 1
58640: PPUSH
58641: LD_VAR 0 4
58645: PUSH
58646: LD_VAR 0 5
58650: DIFF
58651: PPUSH
58652: CALL_OW 1
58656: ST_TO_ADDR
// exit ;
58657: GO 58659
// end ; end ;
58659: LD_VAR 0 2
58663: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58664: LD_INT 0
58666: PPUSH
58667: PPUSH
58668: PPUSH
// if not mc_bases then
58669: LD_EXP 65
58673: NOT
58674: IFFALSE 58678
// exit ;
58676: GO 58784
// for i = 1 to mc_bases do
58678: LD_ADDR_VAR 0 2
58682: PUSH
58683: DOUBLE
58684: LD_INT 1
58686: DEC
58687: ST_TO_ADDR
58688: LD_EXP 65
58692: PUSH
58693: FOR_TO
58694: IFFALSE 58775
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58696: LD_ADDR_VAR 0 3
58700: PUSH
58701: LD_EXP 65
58705: PUSH
58706: LD_VAR 0 2
58710: ARRAY
58711: PPUSH
58712: LD_INT 21
58714: PUSH
58715: LD_INT 3
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: PUSH
58722: LD_INT 3
58724: PUSH
58725: LD_INT 24
58727: PUSH
58728: LD_INT 1000
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: PPUSH
58743: CALL_OW 72
58747: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58748: LD_ADDR_EXP 66
58752: PUSH
58753: LD_EXP 66
58757: PPUSH
58758: LD_VAR 0 2
58762: PPUSH
58763: LD_VAR 0 3
58767: PPUSH
58768: CALL_OW 1
58772: ST_TO_ADDR
// end ;
58773: GO 58693
58775: POP
58776: POP
// RaiseSailEvent ( 101 ) ;
58777: LD_INT 101
58779: PPUSH
58780: CALL_OW 427
// end ;
58784: LD_VAR 0 1
58788: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58789: LD_INT 0
58791: PPUSH
58792: PPUSH
58793: PPUSH
58794: PPUSH
58795: PPUSH
58796: PPUSH
58797: PPUSH
// if not mc_bases then
58798: LD_EXP 65
58802: NOT
58803: IFFALSE 58807
// exit ;
58805: GO 59369
// for i = 1 to mc_bases do
58807: LD_ADDR_VAR 0 2
58811: PUSH
58812: DOUBLE
58813: LD_INT 1
58815: DEC
58816: ST_TO_ADDR
58817: LD_EXP 65
58821: PUSH
58822: FOR_TO
58823: IFFALSE 59360
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
58825: LD_ADDR_VAR 0 5
58829: PUSH
58830: LD_EXP 65
58834: PUSH
58835: LD_VAR 0 2
58839: ARRAY
58840: PUSH
58841: LD_EXP 94
58845: PUSH
58846: LD_VAR 0 2
58850: ARRAY
58851: UNION
58852: PPUSH
58853: LD_INT 21
58855: PUSH
58856: LD_INT 1
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PUSH
58863: LD_INT 1
58865: PUSH
58866: LD_INT 3
58868: PUSH
58869: LD_INT 54
58871: PUSH
58872: EMPTY
58873: LIST
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 3
58881: PUSH
58882: LD_INT 24
58884: PUSH
58885: LD_INT 800
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: PUSH
58892: EMPTY
58893: LIST
58894: LIST
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: LIST
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: PPUSH
58905: CALL_OW 72
58909: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58910: LD_ADDR_VAR 0 6
58914: PUSH
58915: LD_EXP 65
58919: PUSH
58920: LD_VAR 0 2
58924: ARRAY
58925: PPUSH
58926: LD_INT 21
58928: PUSH
58929: LD_INT 1
58931: PUSH
58932: EMPTY
58933: LIST
58934: LIST
58935: PUSH
58936: LD_INT 1
58938: PUSH
58939: LD_INT 3
58941: PUSH
58942: LD_INT 54
58944: PUSH
58945: EMPTY
58946: LIST
58947: PUSH
58948: EMPTY
58949: LIST
58950: LIST
58951: PUSH
58952: LD_INT 3
58954: PUSH
58955: LD_INT 24
58957: PUSH
58958: LD_INT 250
58960: PUSH
58961: EMPTY
58962: LIST
58963: LIST
58964: PUSH
58965: EMPTY
58966: LIST
58967: LIST
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: LIST
58973: PUSH
58974: EMPTY
58975: LIST
58976: LIST
58977: PPUSH
58978: CALL_OW 72
58982: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58983: LD_ADDR_VAR 0 7
58987: PUSH
58988: LD_VAR 0 5
58992: PUSH
58993: LD_VAR 0 6
58997: DIFF
58998: ST_TO_ADDR
// if not need_heal_1 then
58999: LD_VAR 0 6
59003: NOT
59004: IFFALSE 59037
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59006: LD_ADDR_EXP 68
59010: PUSH
59011: LD_EXP 68
59015: PPUSH
59016: LD_VAR 0 2
59020: PUSH
59021: LD_INT 1
59023: PUSH
59024: EMPTY
59025: LIST
59026: LIST
59027: PPUSH
59028: EMPTY
59029: PPUSH
59030: CALL 18579 0 3
59034: ST_TO_ADDR
59035: GO 59107
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59037: LD_ADDR_EXP 68
59041: PUSH
59042: LD_EXP 68
59046: PPUSH
59047: LD_VAR 0 2
59051: PUSH
59052: LD_INT 1
59054: PUSH
59055: EMPTY
59056: LIST
59057: LIST
59058: PPUSH
59059: LD_EXP 68
59063: PUSH
59064: LD_VAR 0 2
59068: ARRAY
59069: PUSH
59070: LD_INT 1
59072: ARRAY
59073: PPUSH
59074: LD_INT 3
59076: PUSH
59077: LD_INT 24
59079: PUSH
59080: LD_INT 1000
59082: PUSH
59083: EMPTY
59084: LIST
59085: LIST
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: PPUSH
59091: CALL_OW 72
59095: PUSH
59096: LD_VAR 0 6
59100: UNION
59101: PPUSH
59102: CALL 18579 0 3
59106: ST_TO_ADDR
// if not need_heal_2 then
59107: LD_VAR 0 7
59111: NOT
59112: IFFALSE 59145
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59114: LD_ADDR_EXP 68
59118: PUSH
59119: LD_EXP 68
59123: PPUSH
59124: LD_VAR 0 2
59128: PUSH
59129: LD_INT 2
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PPUSH
59136: EMPTY
59137: PPUSH
59138: CALL 18579 0 3
59142: ST_TO_ADDR
59143: GO 59177
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59145: LD_ADDR_EXP 68
59149: PUSH
59150: LD_EXP 68
59154: PPUSH
59155: LD_VAR 0 2
59159: PUSH
59160: LD_INT 2
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: PPUSH
59167: LD_VAR 0 7
59171: PPUSH
59172: CALL 18579 0 3
59176: ST_TO_ADDR
// if need_heal_2 then
59177: LD_VAR 0 7
59181: IFFALSE 59342
// for j in need_heal_2 do
59183: LD_ADDR_VAR 0 3
59187: PUSH
59188: LD_VAR 0 7
59192: PUSH
59193: FOR_IN
59194: IFFALSE 59340
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59196: LD_ADDR_VAR 0 5
59200: PUSH
59201: LD_EXP 65
59205: PUSH
59206: LD_VAR 0 2
59210: ARRAY
59211: PPUSH
59212: LD_INT 2
59214: PUSH
59215: LD_INT 30
59217: PUSH
59218: LD_INT 6
59220: PUSH
59221: EMPTY
59222: LIST
59223: LIST
59224: PUSH
59225: LD_INT 30
59227: PUSH
59228: LD_INT 7
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: PUSH
59235: LD_INT 30
59237: PUSH
59238: LD_INT 8
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PUSH
59245: LD_INT 30
59247: PUSH
59248: LD_INT 0
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PUSH
59255: LD_INT 30
59257: PUSH
59258: LD_INT 1
59260: PUSH
59261: EMPTY
59262: LIST
59263: LIST
59264: PUSH
59265: EMPTY
59266: LIST
59267: LIST
59268: LIST
59269: LIST
59270: LIST
59271: LIST
59272: PPUSH
59273: CALL_OW 72
59277: ST_TO_ADDR
// if tmp then
59278: LD_VAR 0 5
59282: IFFALSE 59338
// begin k := NearestUnitToUnit ( tmp , j ) ;
59284: LD_ADDR_VAR 0 4
59288: PUSH
59289: LD_VAR 0 5
59293: PPUSH
59294: LD_VAR 0 3
59298: PPUSH
59299: CALL_OW 74
59303: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59304: LD_VAR 0 3
59308: PPUSH
59309: LD_VAR 0 4
59313: PPUSH
59314: CALL_OW 296
59318: PUSH
59319: LD_INT 5
59321: GREATER
59322: IFFALSE 59338
// ComMoveUnit ( j , k ) ;
59324: LD_VAR 0 3
59328: PPUSH
59329: LD_VAR 0 4
59333: PPUSH
59334: CALL_OW 112
// end ; end ;
59338: GO 59193
59340: POP
59341: POP
// if not need_heal_1 and not need_heal_2 then
59342: LD_VAR 0 6
59346: NOT
59347: PUSH
59348: LD_VAR 0 7
59352: NOT
59353: AND
59354: IFFALSE 59358
// continue ;
59356: GO 58822
// end ;
59358: GO 58822
59360: POP
59361: POP
// RaiseSailEvent ( 102 ) ;
59362: LD_INT 102
59364: PPUSH
59365: CALL_OW 427
// end ;
59369: LD_VAR 0 1
59373: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59374: LD_INT 0
59376: PPUSH
59377: PPUSH
59378: PPUSH
59379: PPUSH
59380: PPUSH
59381: PPUSH
59382: PPUSH
59383: PPUSH
// if not mc_bases then
59384: LD_EXP 65
59388: NOT
59389: IFFALSE 59393
// exit ;
59391: GO 60228
// for i = 1 to mc_bases do
59393: LD_ADDR_VAR 0 2
59397: PUSH
59398: DOUBLE
59399: LD_INT 1
59401: DEC
59402: ST_TO_ADDR
59403: LD_EXP 65
59407: PUSH
59408: FOR_TO
59409: IFFALSE 60226
// begin if not mc_building_need_repair [ i ] then
59411: LD_EXP 66
59415: PUSH
59416: LD_VAR 0 2
59420: ARRAY
59421: NOT
59422: IFFALSE 59596
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59424: LD_ADDR_VAR 0 6
59428: PUSH
59429: LD_EXP 84
59433: PUSH
59434: LD_VAR 0 2
59438: ARRAY
59439: PPUSH
59440: LD_INT 3
59442: PUSH
59443: LD_INT 24
59445: PUSH
59446: LD_INT 1000
59448: PUSH
59449: EMPTY
59450: LIST
59451: LIST
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 2
59459: PUSH
59460: LD_INT 34
59462: PUSH
59463: LD_INT 13
59465: PUSH
59466: EMPTY
59467: LIST
59468: LIST
59469: PUSH
59470: LD_INT 34
59472: PUSH
59473: LD_INT 52
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: LIST
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: PPUSH
59489: CALL_OW 72
59493: ST_TO_ADDR
// if cranes then
59494: LD_VAR 0 6
59498: IFFALSE 59560
// for j in cranes do
59500: LD_ADDR_VAR 0 3
59504: PUSH
59505: LD_VAR 0 6
59509: PUSH
59510: FOR_IN
59511: IFFALSE 59558
// if not IsInArea ( j , mc_parking [ i ] ) then
59513: LD_VAR 0 3
59517: PPUSH
59518: LD_EXP 89
59522: PUSH
59523: LD_VAR 0 2
59527: ARRAY
59528: PPUSH
59529: CALL_OW 308
59533: NOT
59534: IFFALSE 59556
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59536: LD_VAR 0 3
59540: PPUSH
59541: LD_EXP 89
59545: PUSH
59546: LD_VAR 0 2
59550: ARRAY
59551: PPUSH
59552: CALL_OW 113
59556: GO 59510
59558: POP
59559: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59560: LD_ADDR_EXP 67
59564: PUSH
59565: LD_EXP 67
59569: PPUSH
59570: LD_VAR 0 2
59574: PPUSH
59575: EMPTY
59576: PPUSH
59577: CALL_OW 1
59581: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59582: LD_VAR 0 2
59586: PPUSH
59587: LD_INT 101
59589: PPUSH
59590: CALL 54497 0 2
// continue ;
59594: GO 59408
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59596: LD_ADDR_EXP 71
59600: PUSH
59601: LD_EXP 71
59605: PPUSH
59606: LD_VAR 0 2
59610: PPUSH
59611: EMPTY
59612: PPUSH
59613: CALL_OW 1
59617: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59618: LD_VAR 0 2
59622: PPUSH
59623: LD_INT 103
59625: PPUSH
59626: CALL 54497 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59630: LD_ADDR_VAR 0 5
59634: PUSH
59635: LD_EXP 65
59639: PUSH
59640: LD_VAR 0 2
59644: ARRAY
59645: PUSH
59646: LD_EXP 94
59650: PUSH
59651: LD_VAR 0 2
59655: ARRAY
59656: UNION
59657: PPUSH
59658: LD_INT 2
59660: PUSH
59661: LD_INT 25
59663: PUSH
59664: LD_INT 2
59666: PUSH
59667: EMPTY
59668: LIST
59669: LIST
59670: PUSH
59671: LD_INT 25
59673: PUSH
59674: LD_INT 16
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: LIST
59685: PUSH
59686: EMPTY
59687: LIST
59688: PPUSH
59689: CALL_OW 72
59693: PUSH
59694: LD_EXP 68
59698: PUSH
59699: LD_VAR 0 2
59703: ARRAY
59704: PUSH
59705: LD_INT 1
59707: ARRAY
59708: PUSH
59709: LD_EXP 68
59713: PUSH
59714: LD_VAR 0 2
59718: ARRAY
59719: PUSH
59720: LD_INT 2
59722: ARRAY
59723: UNION
59724: DIFF
59725: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59726: LD_ADDR_VAR 0 6
59730: PUSH
59731: LD_EXP 84
59735: PUSH
59736: LD_VAR 0 2
59740: ARRAY
59741: PPUSH
59742: LD_INT 2
59744: PUSH
59745: LD_INT 34
59747: PUSH
59748: LD_INT 13
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: LD_INT 34
59757: PUSH
59758: LD_INT 52
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: LIST
59769: PPUSH
59770: CALL_OW 72
59774: ST_TO_ADDR
// if cranes then
59775: LD_VAR 0 6
59779: IFFALSE 59915
// begin for j in cranes do
59781: LD_ADDR_VAR 0 3
59785: PUSH
59786: LD_VAR 0 6
59790: PUSH
59791: FOR_IN
59792: IFFALSE 59913
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
59794: LD_VAR 0 3
59798: PPUSH
59799: CALL_OW 256
59803: PUSH
59804: LD_INT 500
59806: GREATEREQUAL
59807: PUSH
59808: LD_VAR 0 3
59812: PPUSH
59813: CALL_OW 314
59817: NOT
59818: AND
59819: IFFALSE 59853
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59821: LD_VAR 0 3
59825: PPUSH
59826: LD_EXP 66
59830: PUSH
59831: LD_VAR 0 2
59835: ARRAY
59836: PPUSH
59837: LD_VAR 0 3
59841: PPUSH
59842: CALL_OW 74
59846: PPUSH
59847: CALL_OW 130
59851: GO 59911
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59853: LD_VAR 0 3
59857: PPUSH
59858: CALL_OW 256
59862: PUSH
59863: LD_INT 500
59865: LESS
59866: PUSH
59867: LD_VAR 0 3
59871: PPUSH
59872: LD_EXP 89
59876: PUSH
59877: LD_VAR 0 2
59881: ARRAY
59882: PPUSH
59883: CALL_OW 308
59887: NOT
59888: AND
59889: IFFALSE 59911
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59891: LD_VAR 0 3
59895: PPUSH
59896: LD_EXP 89
59900: PUSH
59901: LD_VAR 0 2
59905: ARRAY
59906: PPUSH
59907: CALL_OW 113
59911: GO 59791
59913: POP
59914: POP
// end ; if tmp > 3 then
59915: LD_VAR 0 5
59919: PUSH
59920: LD_INT 3
59922: GREATER
59923: IFFALSE 59943
// tmp := ShrinkArray ( tmp , 4 ) ;
59925: LD_ADDR_VAR 0 5
59929: PUSH
59930: LD_VAR 0 5
59934: PPUSH
59935: LD_INT 4
59937: PPUSH
59938: CALL 49818 0 2
59942: ST_TO_ADDR
// if not tmp then
59943: LD_VAR 0 5
59947: NOT
59948: IFFALSE 59952
// continue ;
59950: GO 59408
// for j in tmp do
59952: LD_ADDR_VAR 0 3
59956: PUSH
59957: LD_VAR 0 5
59961: PUSH
59962: FOR_IN
59963: IFFALSE 60222
// begin if IsInUnit ( j ) then
59965: LD_VAR 0 3
59969: PPUSH
59970: CALL_OW 310
59974: IFFALSE 59985
// ComExitBuilding ( j ) ;
59976: LD_VAR 0 3
59980: PPUSH
59981: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
59985: LD_VAR 0 3
59989: PUSH
59990: LD_EXP 67
59994: PUSH
59995: LD_VAR 0 2
59999: ARRAY
60000: IN
60001: NOT
60002: IFFALSE 60060
// begin SetTag ( j , 101 ) ;
60004: LD_VAR 0 3
60008: PPUSH
60009: LD_INT 101
60011: PPUSH
60012: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60016: LD_ADDR_EXP 67
60020: PUSH
60021: LD_EXP 67
60025: PPUSH
60026: LD_VAR 0 2
60030: PUSH
60031: LD_EXP 67
60035: PUSH
60036: LD_VAR 0 2
60040: ARRAY
60041: PUSH
60042: LD_INT 1
60044: PLUS
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: PPUSH
60050: LD_VAR 0 3
60054: PPUSH
60055: CALL 18579 0 3
60059: ST_TO_ADDR
// end ; wait ( 1 ) ;
60060: LD_INT 1
60062: PPUSH
60063: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60067: LD_ADDR_VAR 0 7
60071: PUSH
60072: LD_EXP 66
60076: PUSH
60077: LD_VAR 0 2
60081: ARRAY
60082: ST_TO_ADDR
// if mc_scan [ i ] then
60083: LD_EXP 88
60087: PUSH
60088: LD_VAR 0 2
60092: ARRAY
60093: IFFALSE 60155
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60095: LD_ADDR_VAR 0 7
60099: PUSH
60100: LD_EXP 66
60104: PUSH
60105: LD_VAR 0 2
60109: ARRAY
60110: PPUSH
60111: LD_INT 3
60113: PUSH
60114: LD_INT 30
60116: PUSH
60117: LD_INT 32
60119: PUSH
60120: EMPTY
60121: LIST
60122: LIST
60123: PUSH
60124: LD_INT 30
60126: PUSH
60127: LD_INT 33
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PUSH
60134: LD_INT 30
60136: PUSH
60137: LD_INT 31
60139: PUSH
60140: EMPTY
60141: LIST
60142: LIST
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: LIST
60148: LIST
60149: PPUSH
60150: CALL_OW 72
60154: ST_TO_ADDR
// if not to_repair_tmp then
60155: LD_VAR 0 7
60159: NOT
60160: IFFALSE 60164
// continue ;
60162: GO 59962
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60164: LD_ADDR_VAR 0 8
60168: PUSH
60169: LD_VAR 0 7
60173: PPUSH
60174: LD_VAR 0 3
60178: PPUSH
60179: CALL_OW 74
60183: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
60184: LD_VAR 0 8
60188: PPUSH
60189: LD_INT 16
60191: PPUSH
60192: CALL 21172 0 2
60196: PUSH
60197: LD_INT 4
60199: ARRAY
60200: PUSH
60201: LD_INT 5
60203: LESS
60204: IFFALSE 60220
// ComRepairBuilding ( j , to_repair ) ;
60206: LD_VAR 0 3
60210: PPUSH
60211: LD_VAR 0 8
60215: PPUSH
60216: CALL_OW 130
// end ;
60220: GO 59962
60222: POP
60223: POP
// end ;
60224: GO 59408
60226: POP
60227: POP
// end ;
60228: LD_VAR 0 1
60232: RET
// export function MC_Heal ; var i , j , tmp ; begin
60233: LD_INT 0
60235: PPUSH
60236: PPUSH
60237: PPUSH
60238: PPUSH
// if not mc_bases then
60239: LD_EXP 65
60243: NOT
60244: IFFALSE 60248
// exit ;
60246: GO 60650
// for i = 1 to mc_bases do
60248: LD_ADDR_VAR 0 2
60252: PUSH
60253: DOUBLE
60254: LD_INT 1
60256: DEC
60257: ST_TO_ADDR
60258: LD_EXP 65
60262: PUSH
60263: FOR_TO
60264: IFFALSE 60648
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60266: LD_EXP 68
60270: PUSH
60271: LD_VAR 0 2
60275: ARRAY
60276: PUSH
60277: LD_INT 1
60279: ARRAY
60280: NOT
60281: PUSH
60282: LD_EXP 68
60286: PUSH
60287: LD_VAR 0 2
60291: ARRAY
60292: PUSH
60293: LD_INT 2
60295: ARRAY
60296: NOT
60297: AND
60298: IFFALSE 60336
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60300: LD_ADDR_EXP 69
60304: PUSH
60305: LD_EXP 69
60309: PPUSH
60310: LD_VAR 0 2
60314: PPUSH
60315: EMPTY
60316: PPUSH
60317: CALL_OW 1
60321: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60322: LD_VAR 0 2
60326: PPUSH
60327: LD_INT 102
60329: PPUSH
60330: CALL 54497 0 2
// continue ;
60334: GO 60263
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60336: LD_ADDR_VAR 0 4
60340: PUSH
60341: LD_EXP 65
60345: PUSH
60346: LD_VAR 0 2
60350: ARRAY
60351: PPUSH
60352: LD_INT 25
60354: PUSH
60355: LD_INT 4
60357: PUSH
60358: EMPTY
60359: LIST
60360: LIST
60361: PPUSH
60362: CALL_OW 72
60366: ST_TO_ADDR
// if not tmp then
60367: LD_VAR 0 4
60371: NOT
60372: IFFALSE 60376
// continue ;
60374: GO 60263
// if mc_taming [ i ] then
60376: LD_EXP 96
60380: PUSH
60381: LD_VAR 0 2
60385: ARRAY
60386: IFFALSE 60410
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60388: LD_ADDR_EXP 96
60392: PUSH
60393: LD_EXP 96
60397: PPUSH
60398: LD_VAR 0 2
60402: PPUSH
60403: EMPTY
60404: PPUSH
60405: CALL_OW 1
60409: ST_TO_ADDR
// for j in tmp do
60410: LD_ADDR_VAR 0 3
60414: PUSH
60415: LD_VAR 0 4
60419: PUSH
60420: FOR_IN
60421: IFFALSE 60644
// begin if IsInUnit ( j ) then
60423: LD_VAR 0 3
60427: PPUSH
60428: CALL_OW 310
60432: IFFALSE 60443
// ComExitBuilding ( j ) ;
60434: LD_VAR 0 3
60438: PPUSH
60439: CALL_OW 122
// if not j in mc_healers [ i ] then
60443: LD_VAR 0 3
60447: PUSH
60448: LD_EXP 69
60452: PUSH
60453: LD_VAR 0 2
60457: ARRAY
60458: IN
60459: NOT
60460: IFFALSE 60506
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60462: LD_ADDR_EXP 69
60466: PUSH
60467: LD_EXP 69
60471: PPUSH
60472: LD_VAR 0 2
60476: PUSH
60477: LD_EXP 69
60481: PUSH
60482: LD_VAR 0 2
60486: ARRAY
60487: PUSH
60488: LD_INT 1
60490: PLUS
60491: PUSH
60492: EMPTY
60493: LIST
60494: LIST
60495: PPUSH
60496: LD_VAR 0 3
60500: PPUSH
60501: CALL 18579 0 3
60505: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60506: LD_VAR 0 3
60510: PPUSH
60511: CALL_OW 110
60515: PUSH
60516: LD_INT 102
60518: NONEQUAL
60519: IFFALSE 60533
// SetTag ( j , 102 ) ;
60521: LD_VAR 0 3
60525: PPUSH
60526: LD_INT 102
60528: PPUSH
60529: CALL_OW 109
// Wait ( 3 ) ;
60533: LD_INT 3
60535: PPUSH
60536: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60540: LD_EXP 68
60544: PUSH
60545: LD_VAR 0 2
60549: ARRAY
60550: PUSH
60551: LD_INT 1
60553: ARRAY
60554: IFFALSE 60586
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60556: LD_VAR 0 3
60560: PPUSH
60561: LD_EXP 68
60565: PUSH
60566: LD_VAR 0 2
60570: ARRAY
60571: PUSH
60572: LD_INT 1
60574: ARRAY
60575: PUSH
60576: LD_INT 1
60578: ARRAY
60579: PPUSH
60580: CALL_OW 128
60584: GO 60642
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60586: LD_VAR 0 3
60590: PPUSH
60591: CALL_OW 314
60595: NOT
60596: PUSH
60597: LD_EXP 68
60601: PUSH
60602: LD_VAR 0 2
60606: ARRAY
60607: PUSH
60608: LD_INT 2
60610: ARRAY
60611: AND
60612: IFFALSE 60642
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60614: LD_VAR 0 3
60618: PPUSH
60619: LD_EXP 68
60623: PUSH
60624: LD_VAR 0 2
60628: ARRAY
60629: PUSH
60630: LD_INT 2
60632: ARRAY
60633: PUSH
60634: LD_INT 1
60636: ARRAY
60637: PPUSH
60638: CALL_OW 128
// end ;
60642: GO 60420
60644: POP
60645: POP
// end ;
60646: GO 60263
60648: POP
60649: POP
// end ;
60650: LD_VAR 0 1
60654: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60655: LD_INT 0
60657: PPUSH
60658: PPUSH
60659: PPUSH
60660: PPUSH
60661: PPUSH
// if not mc_bases then
60662: LD_EXP 65
60666: NOT
60667: IFFALSE 60671
// exit ;
60669: GO 61814
// for i = 1 to mc_bases do
60671: LD_ADDR_VAR 0 2
60675: PUSH
60676: DOUBLE
60677: LD_INT 1
60679: DEC
60680: ST_TO_ADDR
60681: LD_EXP 65
60685: PUSH
60686: FOR_TO
60687: IFFALSE 61812
// begin if mc_scan [ i ] then
60689: LD_EXP 88
60693: PUSH
60694: LD_VAR 0 2
60698: ARRAY
60699: IFFALSE 60703
// continue ;
60701: GO 60686
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60703: LD_EXP 70
60707: PUSH
60708: LD_VAR 0 2
60712: ARRAY
60713: NOT
60714: PUSH
60715: LD_EXP 72
60719: PUSH
60720: LD_VAR 0 2
60724: ARRAY
60725: NOT
60726: AND
60727: PUSH
60728: LD_EXP 71
60732: PUSH
60733: LD_VAR 0 2
60737: ARRAY
60738: AND
60739: IFFALSE 60777
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60741: LD_ADDR_EXP 71
60745: PUSH
60746: LD_EXP 71
60750: PPUSH
60751: LD_VAR 0 2
60755: PPUSH
60756: EMPTY
60757: PPUSH
60758: CALL_OW 1
60762: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60763: LD_VAR 0 2
60767: PPUSH
60768: LD_INT 103
60770: PPUSH
60771: CALL 54497 0 2
// continue ;
60775: GO 60686
// end ; if mc_construct_list [ i ] then
60777: LD_EXP 72
60781: PUSH
60782: LD_VAR 0 2
60786: ARRAY
60787: IFFALSE 61007
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60789: LD_ADDR_VAR 0 4
60793: PUSH
60794: LD_EXP 65
60798: PUSH
60799: LD_VAR 0 2
60803: ARRAY
60804: PPUSH
60805: LD_INT 25
60807: PUSH
60808: LD_INT 2
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PPUSH
60815: CALL_OW 72
60819: PUSH
60820: LD_EXP 67
60824: PUSH
60825: LD_VAR 0 2
60829: ARRAY
60830: DIFF
60831: ST_TO_ADDR
// if not tmp then
60832: LD_VAR 0 4
60836: NOT
60837: IFFALSE 60841
// continue ;
60839: GO 60686
// for j in tmp do
60841: LD_ADDR_VAR 0 3
60845: PUSH
60846: LD_VAR 0 4
60850: PUSH
60851: FOR_IN
60852: IFFALSE 61003
// begin if not mc_builders [ i ] then
60854: LD_EXP 71
60858: PUSH
60859: LD_VAR 0 2
60863: ARRAY
60864: NOT
60865: IFFALSE 60923
// begin SetTag ( j , 103 ) ;
60867: LD_VAR 0 3
60871: PPUSH
60872: LD_INT 103
60874: PPUSH
60875: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60879: LD_ADDR_EXP 71
60883: PUSH
60884: LD_EXP 71
60888: PPUSH
60889: LD_VAR 0 2
60893: PUSH
60894: LD_EXP 71
60898: PUSH
60899: LD_VAR 0 2
60903: ARRAY
60904: PUSH
60905: LD_INT 1
60907: PLUS
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PPUSH
60913: LD_VAR 0 3
60917: PPUSH
60918: CALL 18579 0 3
60922: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60923: LD_VAR 0 3
60927: PPUSH
60928: CALL_OW 310
60932: IFFALSE 60943
// ComExitBuilding ( j ) ;
60934: LD_VAR 0 3
60938: PPUSH
60939: CALL_OW 122
// wait ( 3 ) ;
60943: LD_INT 3
60945: PPUSH
60946: CALL_OW 67
// if not mc_construct_list [ i ] then
60950: LD_EXP 72
60954: PUSH
60955: LD_VAR 0 2
60959: ARRAY
60960: NOT
60961: IFFALSE 60965
// break ;
60963: GO 61003
// if not HasTask ( j ) then
60965: LD_VAR 0 3
60969: PPUSH
60970: CALL_OW 314
60974: NOT
60975: IFFALSE 61001
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60977: LD_VAR 0 3
60981: PPUSH
60982: LD_EXP 72
60986: PUSH
60987: LD_VAR 0 2
60991: ARRAY
60992: PUSH
60993: LD_INT 1
60995: ARRAY
60996: PPUSH
60997: CALL 21430 0 2
// end ;
61001: GO 60851
61003: POP
61004: POP
// end else
61005: GO 61810
// if mc_build_list [ i ] then
61007: LD_EXP 70
61011: PUSH
61012: LD_VAR 0 2
61016: ARRAY
61017: IFFALSE 61810
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61019: LD_ADDR_VAR 0 5
61023: PUSH
61024: LD_EXP 65
61028: PUSH
61029: LD_VAR 0 2
61033: ARRAY
61034: PPUSH
61035: LD_INT 2
61037: PUSH
61038: LD_INT 30
61040: PUSH
61041: LD_INT 0
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: PUSH
61048: LD_INT 30
61050: PUSH
61051: LD_INT 1
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: LIST
61062: PPUSH
61063: CALL_OW 72
61067: ST_TO_ADDR
// if depot then
61068: LD_VAR 0 5
61072: IFFALSE 61090
// depot := depot [ 1 ] else
61074: LD_ADDR_VAR 0 5
61078: PUSH
61079: LD_VAR 0 5
61083: PUSH
61084: LD_INT 1
61086: ARRAY
61087: ST_TO_ADDR
61088: GO 61098
// depot := 0 ;
61090: LD_ADDR_VAR 0 5
61094: PUSH
61095: LD_INT 0
61097: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61098: LD_EXP 70
61102: PUSH
61103: LD_VAR 0 2
61107: ARRAY
61108: PUSH
61109: LD_INT 1
61111: ARRAY
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: PPUSH
61117: CALL 21260 0 1
61121: PUSH
61122: LD_EXP 65
61126: PUSH
61127: LD_VAR 0 2
61131: ARRAY
61132: PPUSH
61133: LD_INT 2
61135: PUSH
61136: LD_INT 30
61138: PUSH
61139: LD_INT 2
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 30
61148: PUSH
61149: LD_INT 3
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: LIST
61160: PPUSH
61161: CALL_OW 72
61165: NOT
61166: AND
61167: IFFALSE 61272
// begin for j = 1 to mc_build_list [ i ] do
61169: LD_ADDR_VAR 0 3
61173: PUSH
61174: DOUBLE
61175: LD_INT 1
61177: DEC
61178: ST_TO_ADDR
61179: LD_EXP 70
61183: PUSH
61184: LD_VAR 0 2
61188: ARRAY
61189: PUSH
61190: FOR_TO
61191: IFFALSE 61270
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61193: LD_EXP 70
61197: PUSH
61198: LD_VAR 0 2
61202: ARRAY
61203: PUSH
61204: LD_VAR 0 3
61208: ARRAY
61209: PUSH
61210: LD_INT 1
61212: ARRAY
61213: PUSH
61214: LD_INT 2
61216: EQUAL
61217: IFFALSE 61268
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61219: LD_ADDR_EXP 70
61223: PUSH
61224: LD_EXP 70
61228: PPUSH
61229: LD_VAR 0 2
61233: PPUSH
61234: LD_EXP 70
61238: PUSH
61239: LD_VAR 0 2
61243: ARRAY
61244: PPUSH
61245: LD_VAR 0 3
61249: PPUSH
61250: LD_INT 1
61252: PPUSH
61253: LD_INT 0
61255: PPUSH
61256: CALL 17997 0 4
61260: PPUSH
61261: CALL_OW 1
61265: ST_TO_ADDR
// break ;
61266: GO 61270
// end ;
61268: GO 61190
61270: POP
61271: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61272: LD_EXP 70
61276: PUSH
61277: LD_VAR 0 2
61281: ARRAY
61282: PUSH
61283: LD_INT 1
61285: ARRAY
61286: PUSH
61287: LD_INT 1
61289: ARRAY
61290: PUSH
61291: LD_INT 0
61293: EQUAL
61294: PUSH
61295: LD_VAR 0 5
61299: PUSH
61300: LD_VAR 0 5
61304: PPUSH
61305: LD_EXP 70
61309: PUSH
61310: LD_VAR 0 2
61314: ARRAY
61315: PUSH
61316: LD_INT 1
61318: ARRAY
61319: PUSH
61320: LD_INT 1
61322: ARRAY
61323: PPUSH
61324: LD_EXP 70
61328: PUSH
61329: LD_VAR 0 2
61333: ARRAY
61334: PUSH
61335: LD_INT 1
61337: ARRAY
61338: PUSH
61339: LD_INT 2
61341: ARRAY
61342: PPUSH
61343: LD_EXP 70
61347: PUSH
61348: LD_VAR 0 2
61352: ARRAY
61353: PUSH
61354: LD_INT 1
61356: ARRAY
61357: PUSH
61358: LD_INT 3
61360: ARRAY
61361: PPUSH
61362: LD_EXP 70
61366: PUSH
61367: LD_VAR 0 2
61371: ARRAY
61372: PUSH
61373: LD_INT 1
61375: ARRAY
61376: PUSH
61377: LD_INT 4
61379: ARRAY
61380: PPUSH
61381: CALL 25994 0 5
61385: AND
61386: OR
61387: IFFALSE 61668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61389: LD_ADDR_VAR 0 4
61393: PUSH
61394: LD_EXP 65
61398: PUSH
61399: LD_VAR 0 2
61403: ARRAY
61404: PPUSH
61405: LD_INT 25
61407: PUSH
61408: LD_INT 2
61410: PUSH
61411: EMPTY
61412: LIST
61413: LIST
61414: PPUSH
61415: CALL_OW 72
61419: PUSH
61420: LD_EXP 67
61424: PUSH
61425: LD_VAR 0 2
61429: ARRAY
61430: DIFF
61431: ST_TO_ADDR
// if not tmp then
61432: LD_VAR 0 4
61436: NOT
61437: IFFALSE 61441
// continue ;
61439: GO 60686
// for j in tmp do
61441: LD_ADDR_VAR 0 3
61445: PUSH
61446: LD_VAR 0 4
61450: PUSH
61451: FOR_IN
61452: IFFALSE 61664
// begin if not mc_builders [ i ] then
61454: LD_EXP 71
61458: PUSH
61459: LD_VAR 0 2
61463: ARRAY
61464: NOT
61465: IFFALSE 61523
// begin SetTag ( j , 103 ) ;
61467: LD_VAR 0 3
61471: PPUSH
61472: LD_INT 103
61474: PPUSH
61475: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61479: LD_ADDR_EXP 71
61483: PUSH
61484: LD_EXP 71
61488: PPUSH
61489: LD_VAR 0 2
61493: PUSH
61494: LD_EXP 71
61498: PUSH
61499: LD_VAR 0 2
61503: ARRAY
61504: PUSH
61505: LD_INT 1
61507: PLUS
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: PPUSH
61513: LD_VAR 0 3
61517: PPUSH
61518: CALL 18579 0 3
61522: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61523: LD_VAR 0 3
61527: PPUSH
61528: CALL_OW 310
61532: IFFALSE 61543
// ComExitBuilding ( j ) ;
61534: LD_VAR 0 3
61538: PPUSH
61539: CALL_OW 122
// wait ( 3 ) ;
61543: LD_INT 3
61545: PPUSH
61546: CALL_OW 67
// if not mc_build_list [ i ] then
61550: LD_EXP 70
61554: PUSH
61555: LD_VAR 0 2
61559: ARRAY
61560: NOT
61561: IFFALSE 61565
// break ;
61563: GO 61664
// if not HasTask ( j ) then
61565: LD_VAR 0 3
61569: PPUSH
61570: CALL_OW 314
61574: NOT
61575: IFFALSE 61662
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61577: LD_VAR 0 3
61581: PPUSH
61582: LD_EXP 70
61586: PUSH
61587: LD_VAR 0 2
61591: ARRAY
61592: PUSH
61593: LD_INT 1
61595: ARRAY
61596: PUSH
61597: LD_INT 1
61599: ARRAY
61600: PPUSH
61601: LD_EXP 70
61605: PUSH
61606: LD_VAR 0 2
61610: ARRAY
61611: PUSH
61612: LD_INT 1
61614: ARRAY
61615: PUSH
61616: LD_INT 2
61618: ARRAY
61619: PPUSH
61620: LD_EXP 70
61624: PUSH
61625: LD_VAR 0 2
61629: ARRAY
61630: PUSH
61631: LD_INT 1
61633: ARRAY
61634: PUSH
61635: LD_INT 3
61637: ARRAY
61638: PPUSH
61639: LD_EXP 70
61643: PUSH
61644: LD_VAR 0 2
61648: ARRAY
61649: PUSH
61650: LD_INT 1
61652: ARRAY
61653: PUSH
61654: LD_INT 4
61656: ARRAY
61657: PPUSH
61658: CALL_OW 145
// end ;
61662: GO 61451
61664: POP
61665: POP
// end else
61666: GO 61810
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61668: LD_EXP 65
61672: PUSH
61673: LD_VAR 0 2
61677: ARRAY
61678: PPUSH
61679: LD_EXP 70
61683: PUSH
61684: LD_VAR 0 2
61688: ARRAY
61689: PUSH
61690: LD_INT 1
61692: ARRAY
61693: PUSH
61694: LD_INT 1
61696: ARRAY
61697: PPUSH
61698: LD_EXP 70
61702: PUSH
61703: LD_VAR 0 2
61707: ARRAY
61708: PUSH
61709: LD_INT 1
61711: ARRAY
61712: PUSH
61713: LD_INT 2
61715: ARRAY
61716: PPUSH
61717: LD_EXP 70
61721: PUSH
61722: LD_VAR 0 2
61726: ARRAY
61727: PUSH
61728: LD_INT 1
61730: ARRAY
61731: PUSH
61732: LD_INT 3
61734: ARRAY
61735: PPUSH
61736: LD_EXP 70
61740: PUSH
61741: LD_VAR 0 2
61745: ARRAY
61746: PUSH
61747: LD_INT 1
61749: ARRAY
61750: PUSH
61751: LD_INT 4
61753: ARRAY
61754: PPUSH
61755: CALL 25330 0 5
61759: NOT
61760: IFFALSE 61810
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61762: LD_ADDR_EXP 70
61766: PUSH
61767: LD_EXP 70
61771: PPUSH
61772: LD_VAR 0 2
61776: PPUSH
61777: LD_EXP 70
61781: PUSH
61782: LD_VAR 0 2
61786: ARRAY
61787: PPUSH
61788: LD_INT 1
61790: PPUSH
61791: LD_INT 1
61793: NEG
61794: PPUSH
61795: LD_INT 0
61797: PPUSH
61798: CALL 17997 0 4
61802: PPUSH
61803: CALL_OW 1
61807: ST_TO_ADDR
// continue ;
61808: GO 60686
// end ; end ; end ;
61810: GO 60686
61812: POP
61813: POP
// end ;
61814: LD_VAR 0 1
61818: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61819: LD_INT 0
61821: PPUSH
61822: PPUSH
61823: PPUSH
61824: PPUSH
61825: PPUSH
61826: PPUSH
// if not mc_bases then
61827: LD_EXP 65
61831: NOT
61832: IFFALSE 61836
// exit ;
61834: GO 62263
// for i = 1 to mc_bases do
61836: LD_ADDR_VAR 0 2
61840: PUSH
61841: DOUBLE
61842: LD_INT 1
61844: DEC
61845: ST_TO_ADDR
61846: LD_EXP 65
61850: PUSH
61851: FOR_TO
61852: IFFALSE 62261
// begin tmp := mc_build_upgrade [ i ] ;
61854: LD_ADDR_VAR 0 4
61858: PUSH
61859: LD_EXP 97
61863: PUSH
61864: LD_VAR 0 2
61868: ARRAY
61869: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61870: LD_ADDR_VAR 0 6
61874: PUSH
61875: LD_EXP 98
61879: PUSH
61880: LD_VAR 0 2
61884: ARRAY
61885: PPUSH
61886: LD_INT 2
61888: PUSH
61889: LD_INT 30
61891: PUSH
61892: LD_INT 6
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PUSH
61899: LD_INT 30
61901: PUSH
61902: LD_INT 7
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PUSH
61909: EMPTY
61910: LIST
61911: LIST
61912: LIST
61913: PPUSH
61914: CALL_OW 72
61918: ST_TO_ADDR
// if not tmp and not lab then
61919: LD_VAR 0 4
61923: NOT
61924: PUSH
61925: LD_VAR 0 6
61929: NOT
61930: AND
61931: IFFALSE 61935
// continue ;
61933: GO 61851
// if tmp then
61935: LD_VAR 0 4
61939: IFFALSE 62059
// for j in tmp do
61941: LD_ADDR_VAR 0 3
61945: PUSH
61946: LD_VAR 0 4
61950: PUSH
61951: FOR_IN
61952: IFFALSE 62057
// begin if UpgradeCost ( j ) then
61954: LD_VAR 0 3
61958: PPUSH
61959: CALL 24990 0 1
61963: IFFALSE 62055
// begin ComUpgrade ( j ) ;
61965: LD_VAR 0 3
61969: PPUSH
61970: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61974: LD_ADDR_EXP 97
61978: PUSH
61979: LD_EXP 97
61983: PPUSH
61984: LD_VAR 0 2
61988: PPUSH
61989: LD_EXP 97
61993: PUSH
61994: LD_VAR 0 2
61998: ARRAY
61999: PUSH
62000: LD_VAR 0 3
62004: DIFF
62005: PPUSH
62006: CALL_OW 1
62010: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62011: LD_ADDR_EXP 72
62015: PUSH
62016: LD_EXP 72
62020: PPUSH
62021: LD_VAR 0 2
62025: PUSH
62026: LD_EXP 72
62030: PUSH
62031: LD_VAR 0 2
62035: ARRAY
62036: PUSH
62037: LD_INT 1
62039: PLUS
62040: PUSH
62041: EMPTY
62042: LIST
62043: LIST
62044: PPUSH
62045: LD_VAR 0 3
62049: PPUSH
62050: CALL 18579 0 3
62054: ST_TO_ADDR
// end ; end ;
62055: GO 61951
62057: POP
62058: POP
// if not lab or not mc_lab_upgrade [ i ] then
62059: LD_VAR 0 6
62063: NOT
62064: PUSH
62065: LD_EXP 99
62069: PUSH
62070: LD_VAR 0 2
62074: ARRAY
62075: NOT
62076: OR
62077: IFFALSE 62081
// continue ;
62079: GO 61851
// for j in lab do
62081: LD_ADDR_VAR 0 3
62085: PUSH
62086: LD_VAR 0 6
62090: PUSH
62091: FOR_IN
62092: IFFALSE 62257
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62094: LD_VAR 0 3
62098: PPUSH
62099: CALL_OW 266
62103: PUSH
62104: LD_INT 6
62106: PUSH
62107: LD_INT 7
62109: PUSH
62110: EMPTY
62111: LIST
62112: LIST
62113: IN
62114: PUSH
62115: LD_VAR 0 3
62119: PPUSH
62120: CALL_OW 461
62124: PUSH
62125: LD_INT 1
62127: NONEQUAL
62128: AND
62129: IFFALSE 62255
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62131: LD_VAR 0 3
62135: PPUSH
62136: LD_EXP 99
62140: PUSH
62141: LD_VAR 0 2
62145: ARRAY
62146: PUSH
62147: LD_INT 1
62149: ARRAY
62150: PPUSH
62151: CALL 25195 0 2
62155: IFFALSE 62255
// begin ComCancel ( j ) ;
62157: LD_VAR 0 3
62161: PPUSH
62162: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62166: LD_VAR 0 3
62170: PPUSH
62171: LD_EXP 99
62175: PUSH
62176: LD_VAR 0 2
62180: ARRAY
62181: PUSH
62182: LD_INT 1
62184: ARRAY
62185: PPUSH
62186: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62190: LD_VAR 0 3
62194: PUSH
62195: LD_EXP 72
62199: PUSH
62200: LD_VAR 0 2
62204: ARRAY
62205: IN
62206: NOT
62207: IFFALSE 62253
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62209: LD_ADDR_EXP 72
62213: PUSH
62214: LD_EXP 72
62218: PPUSH
62219: LD_VAR 0 2
62223: PUSH
62224: LD_EXP 72
62228: PUSH
62229: LD_VAR 0 2
62233: ARRAY
62234: PUSH
62235: LD_INT 1
62237: PLUS
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: PPUSH
62243: LD_VAR 0 3
62247: PPUSH
62248: CALL 18579 0 3
62252: ST_TO_ADDR
// break ;
62253: GO 62257
// end ; end ; end ;
62255: GO 62091
62257: POP
62258: POP
// end ;
62259: GO 61851
62261: POP
62262: POP
// end ;
62263: LD_VAR 0 1
62267: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62268: LD_INT 0
62270: PPUSH
62271: PPUSH
62272: PPUSH
62273: PPUSH
62274: PPUSH
62275: PPUSH
62276: PPUSH
62277: PPUSH
62278: PPUSH
// if not mc_bases then
62279: LD_EXP 65
62283: NOT
62284: IFFALSE 62288
// exit ;
62286: GO 62693
// for i = 1 to mc_bases do
62288: LD_ADDR_VAR 0 2
62292: PUSH
62293: DOUBLE
62294: LD_INT 1
62296: DEC
62297: ST_TO_ADDR
62298: LD_EXP 65
62302: PUSH
62303: FOR_TO
62304: IFFALSE 62691
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62306: LD_EXP 73
62310: PUSH
62311: LD_VAR 0 2
62315: ARRAY
62316: NOT
62317: PUSH
62318: LD_EXP 65
62322: PUSH
62323: LD_VAR 0 2
62327: ARRAY
62328: PPUSH
62329: LD_INT 30
62331: PUSH
62332: LD_INT 3
62334: PUSH
62335: EMPTY
62336: LIST
62337: LIST
62338: PPUSH
62339: CALL_OW 72
62343: NOT
62344: OR
62345: IFFALSE 62349
// continue ;
62347: GO 62303
// busy := false ;
62349: LD_ADDR_VAR 0 8
62353: PUSH
62354: LD_INT 0
62356: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62357: LD_ADDR_VAR 0 4
62361: PUSH
62362: LD_EXP 65
62366: PUSH
62367: LD_VAR 0 2
62371: ARRAY
62372: PPUSH
62373: LD_INT 30
62375: PUSH
62376: LD_INT 3
62378: PUSH
62379: EMPTY
62380: LIST
62381: LIST
62382: PPUSH
62383: CALL_OW 72
62387: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62388: LD_ADDR_VAR 0 6
62392: PUSH
62393: LD_EXP 73
62397: PUSH
62398: LD_VAR 0 2
62402: ARRAY
62403: PPUSH
62404: LD_INT 2
62406: PUSH
62407: LD_INT 30
62409: PUSH
62410: LD_INT 32
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PUSH
62417: LD_INT 30
62419: PUSH
62420: LD_INT 33
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: LIST
62431: PPUSH
62432: CALL_OW 72
62436: ST_TO_ADDR
// if not t then
62437: LD_VAR 0 6
62441: NOT
62442: IFFALSE 62446
// continue ;
62444: GO 62303
// for j in tmp do
62446: LD_ADDR_VAR 0 3
62450: PUSH
62451: LD_VAR 0 4
62455: PUSH
62456: FOR_IN
62457: IFFALSE 62487
// if not BuildingStatus ( j ) = bs_idle then
62459: LD_VAR 0 3
62463: PPUSH
62464: CALL_OW 461
62468: PUSH
62469: LD_INT 2
62471: EQUAL
62472: NOT
62473: IFFALSE 62485
// begin busy := true ;
62475: LD_ADDR_VAR 0 8
62479: PUSH
62480: LD_INT 1
62482: ST_TO_ADDR
// break ;
62483: GO 62487
// end ;
62485: GO 62456
62487: POP
62488: POP
// if busy then
62489: LD_VAR 0 8
62493: IFFALSE 62497
// continue ;
62495: GO 62303
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62497: LD_ADDR_VAR 0 7
62501: PUSH
62502: LD_VAR 0 6
62506: PPUSH
62507: LD_INT 35
62509: PUSH
62510: LD_INT 0
62512: PUSH
62513: EMPTY
62514: LIST
62515: LIST
62516: PPUSH
62517: CALL_OW 72
62521: ST_TO_ADDR
// if tw then
62522: LD_VAR 0 7
62526: IFFALSE 62603
// begin tw := tw [ 1 ] ;
62528: LD_ADDR_VAR 0 7
62532: PUSH
62533: LD_VAR 0 7
62537: PUSH
62538: LD_INT 1
62540: ARRAY
62541: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62542: LD_ADDR_VAR 0 9
62546: PUSH
62547: LD_VAR 0 7
62551: PPUSH
62552: LD_EXP 90
62556: PUSH
62557: LD_VAR 0 2
62561: ARRAY
62562: PPUSH
62563: CALL 23549 0 2
62567: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62568: LD_EXP 104
62572: PUSH
62573: LD_VAR 0 2
62577: ARRAY
62578: IFFALSE 62601
// if not weapon in mc_allowed_tower_weapons [ i ] then
62580: LD_VAR 0 9
62584: PUSH
62585: LD_EXP 104
62589: PUSH
62590: LD_VAR 0 2
62594: ARRAY
62595: IN
62596: NOT
62597: IFFALSE 62601
// continue ;
62599: GO 62303
// end else
62601: GO 62666
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62603: LD_ADDR_VAR 0 5
62607: PUSH
62608: LD_EXP 73
62612: PUSH
62613: LD_VAR 0 2
62617: ARRAY
62618: PPUSH
62619: LD_VAR 0 4
62623: PPUSH
62624: CALL 49051 0 2
62628: ST_TO_ADDR
// if not tmp2 then
62629: LD_VAR 0 5
62633: NOT
62634: IFFALSE 62638
// continue ;
62636: GO 62303
// tw := tmp2 [ 1 ] ;
62638: LD_ADDR_VAR 0 7
62642: PUSH
62643: LD_VAR 0 5
62647: PUSH
62648: LD_INT 1
62650: ARRAY
62651: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62652: LD_ADDR_VAR 0 9
62656: PUSH
62657: LD_VAR 0 5
62661: PUSH
62662: LD_INT 2
62664: ARRAY
62665: ST_TO_ADDR
// end ; if not weapon then
62666: LD_VAR 0 9
62670: NOT
62671: IFFALSE 62675
// continue ;
62673: GO 62303
// ComPlaceWeapon ( tw , weapon ) ;
62675: LD_VAR 0 7
62679: PPUSH
62680: LD_VAR 0 9
62684: PPUSH
62685: CALL_OW 148
// end ;
62689: GO 62303
62691: POP
62692: POP
// end ;
62693: LD_VAR 0 1
62697: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62698: LD_INT 0
62700: PPUSH
62701: PPUSH
62702: PPUSH
62703: PPUSH
62704: PPUSH
62705: PPUSH
// if not mc_bases then
62706: LD_EXP 65
62710: NOT
62711: IFFALSE 62715
// exit ;
62713: GO 63491
// for i = 1 to mc_bases do
62715: LD_ADDR_VAR 0 2
62719: PUSH
62720: DOUBLE
62721: LD_INT 1
62723: DEC
62724: ST_TO_ADDR
62725: LD_EXP 65
62729: PUSH
62730: FOR_TO
62731: IFFALSE 63489
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62733: LD_EXP 78
62737: PUSH
62738: LD_VAR 0 2
62742: ARRAY
62743: NOT
62744: PUSH
62745: LD_EXP 78
62749: PUSH
62750: LD_VAR 0 2
62754: ARRAY
62755: PUSH
62756: LD_EXP 79
62760: PUSH
62761: LD_VAR 0 2
62765: ARRAY
62766: EQUAL
62767: OR
62768: PUSH
62769: LD_EXP 88
62773: PUSH
62774: LD_VAR 0 2
62778: ARRAY
62779: OR
62780: IFFALSE 62784
// continue ;
62782: GO 62730
// if mc_miners [ i ] then
62784: LD_EXP 79
62788: PUSH
62789: LD_VAR 0 2
62793: ARRAY
62794: IFFALSE 63176
// begin for j = mc_miners [ i ] downto 1 do
62796: LD_ADDR_VAR 0 3
62800: PUSH
62801: DOUBLE
62802: LD_EXP 79
62806: PUSH
62807: LD_VAR 0 2
62811: ARRAY
62812: INC
62813: ST_TO_ADDR
62814: LD_INT 1
62816: PUSH
62817: FOR_DOWNTO
62818: IFFALSE 63174
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62820: LD_EXP 79
62824: PUSH
62825: LD_VAR 0 2
62829: ARRAY
62830: PUSH
62831: LD_VAR 0 3
62835: ARRAY
62836: PPUSH
62837: CALL_OW 301
62841: PUSH
62842: LD_EXP 79
62846: PUSH
62847: LD_VAR 0 2
62851: ARRAY
62852: PUSH
62853: LD_VAR 0 3
62857: ARRAY
62858: PPUSH
62859: CALL_OW 257
62863: PUSH
62864: LD_INT 1
62866: NONEQUAL
62867: OR
62868: IFFALSE 62931
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62870: LD_ADDR_VAR 0 5
62874: PUSH
62875: LD_EXP 79
62879: PUSH
62880: LD_VAR 0 2
62884: ARRAY
62885: PUSH
62886: LD_EXP 79
62890: PUSH
62891: LD_VAR 0 2
62895: ARRAY
62896: PUSH
62897: LD_VAR 0 3
62901: ARRAY
62902: DIFF
62903: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62904: LD_ADDR_EXP 79
62908: PUSH
62909: LD_EXP 79
62913: PPUSH
62914: LD_VAR 0 2
62918: PPUSH
62919: LD_VAR 0 5
62923: PPUSH
62924: CALL_OW 1
62928: ST_TO_ADDR
// continue ;
62929: GO 62817
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62931: LD_EXP 79
62935: PUSH
62936: LD_VAR 0 2
62940: ARRAY
62941: PUSH
62942: LD_VAR 0 3
62946: ARRAY
62947: PPUSH
62948: CALL_OW 257
62952: PUSH
62953: LD_INT 1
62955: EQUAL
62956: PUSH
62957: LD_EXP 79
62961: PUSH
62962: LD_VAR 0 2
62966: ARRAY
62967: PUSH
62968: LD_VAR 0 3
62972: ARRAY
62973: PPUSH
62974: CALL_OW 459
62978: NOT
62979: AND
62980: PUSH
62981: LD_EXP 79
62985: PUSH
62986: LD_VAR 0 2
62990: ARRAY
62991: PUSH
62992: LD_VAR 0 3
62996: ARRAY
62997: PPUSH
62998: CALL_OW 314
63002: NOT
63003: AND
63004: IFFALSE 63172
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63006: LD_EXP 79
63010: PUSH
63011: LD_VAR 0 2
63015: ARRAY
63016: PUSH
63017: LD_VAR 0 3
63021: ARRAY
63022: PPUSH
63023: CALL_OW 310
63027: IFFALSE 63050
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63029: LD_EXP 79
63033: PUSH
63034: LD_VAR 0 2
63038: ARRAY
63039: PUSH
63040: LD_VAR 0 3
63044: ARRAY
63045: PPUSH
63046: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63050: LD_EXP 79
63054: PUSH
63055: LD_VAR 0 2
63059: ARRAY
63060: PUSH
63061: LD_VAR 0 3
63065: ARRAY
63066: PPUSH
63067: CALL_OW 314
63071: NOT
63072: IFFALSE 63172
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63074: LD_EXP 79
63078: PUSH
63079: LD_VAR 0 2
63083: ARRAY
63084: PUSH
63085: LD_VAR 0 3
63089: ARRAY
63090: PPUSH
63091: LD_EXP 78
63095: PUSH
63096: LD_VAR 0 2
63100: ARRAY
63101: PUSH
63102: LD_VAR 0 3
63106: PUSH
63107: LD_EXP 78
63111: PUSH
63112: LD_VAR 0 2
63116: ARRAY
63117: MOD
63118: PUSH
63119: LD_INT 1
63121: PLUS
63122: ARRAY
63123: PUSH
63124: LD_INT 1
63126: ARRAY
63127: PPUSH
63128: LD_EXP 78
63132: PUSH
63133: LD_VAR 0 2
63137: ARRAY
63138: PUSH
63139: LD_VAR 0 3
63143: PUSH
63144: LD_EXP 78
63148: PUSH
63149: LD_VAR 0 2
63153: ARRAY
63154: MOD
63155: PUSH
63156: LD_INT 1
63158: PLUS
63159: ARRAY
63160: PUSH
63161: LD_INT 2
63163: ARRAY
63164: PPUSH
63165: LD_INT 0
63167: PPUSH
63168: CALL_OW 193
// end ; end ;
63172: GO 62817
63174: POP
63175: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63176: LD_ADDR_VAR 0 5
63180: PUSH
63181: LD_EXP 65
63185: PUSH
63186: LD_VAR 0 2
63190: ARRAY
63191: PPUSH
63192: LD_INT 2
63194: PUSH
63195: LD_INT 30
63197: PUSH
63198: LD_INT 4
63200: PUSH
63201: EMPTY
63202: LIST
63203: LIST
63204: PUSH
63205: LD_INT 30
63207: PUSH
63208: LD_INT 5
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 30
63217: PUSH
63218: LD_INT 32
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: PPUSH
63231: CALL_OW 72
63235: ST_TO_ADDR
// if not tmp then
63236: LD_VAR 0 5
63240: NOT
63241: IFFALSE 63245
// continue ;
63243: GO 62730
// list := [ ] ;
63245: LD_ADDR_VAR 0 6
63249: PUSH
63250: EMPTY
63251: ST_TO_ADDR
// for j in tmp do
63252: LD_ADDR_VAR 0 3
63256: PUSH
63257: LD_VAR 0 5
63261: PUSH
63262: FOR_IN
63263: IFFALSE 63332
// begin for k in UnitsInside ( j ) do
63265: LD_ADDR_VAR 0 4
63269: PUSH
63270: LD_VAR 0 3
63274: PPUSH
63275: CALL_OW 313
63279: PUSH
63280: FOR_IN
63281: IFFALSE 63328
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63283: LD_VAR 0 4
63287: PPUSH
63288: CALL_OW 257
63292: PUSH
63293: LD_INT 1
63295: EQUAL
63296: PUSH
63297: LD_VAR 0 4
63301: PPUSH
63302: CALL_OW 459
63306: NOT
63307: AND
63308: IFFALSE 63326
// list := list ^ k ;
63310: LD_ADDR_VAR 0 6
63314: PUSH
63315: LD_VAR 0 6
63319: PUSH
63320: LD_VAR 0 4
63324: ADD
63325: ST_TO_ADDR
63326: GO 63280
63328: POP
63329: POP
// end ;
63330: GO 63262
63332: POP
63333: POP
// list := list diff mc_miners [ i ] ;
63334: LD_ADDR_VAR 0 6
63338: PUSH
63339: LD_VAR 0 6
63343: PUSH
63344: LD_EXP 79
63348: PUSH
63349: LD_VAR 0 2
63353: ARRAY
63354: DIFF
63355: ST_TO_ADDR
// if not list then
63356: LD_VAR 0 6
63360: NOT
63361: IFFALSE 63365
// continue ;
63363: GO 62730
// k := mc_mines [ i ] - mc_miners [ i ] ;
63365: LD_ADDR_VAR 0 4
63369: PUSH
63370: LD_EXP 78
63374: PUSH
63375: LD_VAR 0 2
63379: ARRAY
63380: PUSH
63381: LD_EXP 79
63385: PUSH
63386: LD_VAR 0 2
63390: ARRAY
63391: MINUS
63392: ST_TO_ADDR
// if k > list then
63393: LD_VAR 0 4
63397: PUSH
63398: LD_VAR 0 6
63402: GREATER
63403: IFFALSE 63415
// k := list ;
63405: LD_ADDR_VAR 0 4
63409: PUSH
63410: LD_VAR 0 6
63414: ST_TO_ADDR
// for j = 1 to k do
63415: LD_ADDR_VAR 0 3
63419: PUSH
63420: DOUBLE
63421: LD_INT 1
63423: DEC
63424: ST_TO_ADDR
63425: LD_VAR 0 4
63429: PUSH
63430: FOR_TO
63431: IFFALSE 63485
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63433: LD_ADDR_EXP 79
63437: PUSH
63438: LD_EXP 79
63442: PPUSH
63443: LD_VAR 0 2
63447: PUSH
63448: LD_EXP 79
63452: PUSH
63453: LD_VAR 0 2
63457: ARRAY
63458: PUSH
63459: LD_INT 1
63461: PLUS
63462: PUSH
63463: EMPTY
63464: LIST
63465: LIST
63466: PPUSH
63467: LD_VAR 0 6
63471: PUSH
63472: LD_VAR 0 3
63476: ARRAY
63477: PPUSH
63478: CALL 18579 0 3
63482: ST_TO_ADDR
63483: GO 63430
63485: POP
63486: POP
// end ;
63487: GO 62730
63489: POP
63490: POP
// end ;
63491: LD_VAR 0 1
63495: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63496: LD_INT 0
63498: PPUSH
63499: PPUSH
63500: PPUSH
63501: PPUSH
63502: PPUSH
63503: PPUSH
63504: PPUSH
63505: PPUSH
63506: PPUSH
63507: PPUSH
// if not mc_bases then
63508: LD_EXP 65
63512: NOT
63513: IFFALSE 63517
// exit ;
63515: GO 65267
// for i = 1 to mc_bases do
63517: LD_ADDR_VAR 0 2
63521: PUSH
63522: DOUBLE
63523: LD_INT 1
63525: DEC
63526: ST_TO_ADDR
63527: LD_EXP 65
63531: PUSH
63532: FOR_TO
63533: IFFALSE 65265
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63535: LD_EXP 65
63539: PUSH
63540: LD_VAR 0 2
63544: ARRAY
63545: NOT
63546: PUSH
63547: LD_EXP 72
63551: PUSH
63552: LD_VAR 0 2
63556: ARRAY
63557: OR
63558: IFFALSE 63562
// continue ;
63560: GO 63532
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63562: LD_EXP 81
63566: PUSH
63567: LD_VAR 0 2
63571: ARRAY
63572: NOT
63573: PUSH
63574: LD_EXP 82
63578: PUSH
63579: LD_VAR 0 2
63583: ARRAY
63584: AND
63585: IFFALSE 63623
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63587: LD_ADDR_EXP 82
63591: PUSH
63592: LD_EXP 82
63596: PPUSH
63597: LD_VAR 0 2
63601: PPUSH
63602: EMPTY
63603: PPUSH
63604: CALL_OW 1
63608: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63609: LD_VAR 0 2
63613: PPUSH
63614: LD_INT 107
63616: PPUSH
63617: CALL 54497 0 2
// continue ;
63621: GO 63532
// end ; target := [ ] ;
63623: LD_ADDR_VAR 0 6
63627: PUSH
63628: EMPTY
63629: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63630: LD_ADDR_VAR 0 3
63634: PUSH
63635: DOUBLE
63636: LD_EXP 81
63640: PUSH
63641: LD_VAR 0 2
63645: ARRAY
63646: INC
63647: ST_TO_ADDR
63648: LD_INT 1
63650: PUSH
63651: FOR_DOWNTO
63652: IFFALSE 63912
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63654: LD_EXP 81
63658: PUSH
63659: LD_VAR 0 2
63663: ARRAY
63664: PUSH
63665: LD_VAR 0 3
63669: ARRAY
63670: PUSH
63671: LD_INT 2
63673: ARRAY
63674: PPUSH
63675: LD_EXP 81
63679: PUSH
63680: LD_VAR 0 2
63684: ARRAY
63685: PUSH
63686: LD_VAR 0 3
63690: ARRAY
63691: PUSH
63692: LD_INT 3
63694: ARRAY
63695: PPUSH
63696: CALL_OW 488
63700: PUSH
63701: LD_EXP 81
63705: PUSH
63706: LD_VAR 0 2
63710: ARRAY
63711: PUSH
63712: LD_VAR 0 3
63716: ARRAY
63717: PUSH
63718: LD_INT 2
63720: ARRAY
63721: PPUSH
63722: LD_EXP 81
63726: PUSH
63727: LD_VAR 0 2
63731: ARRAY
63732: PUSH
63733: LD_VAR 0 3
63737: ARRAY
63738: PUSH
63739: LD_INT 3
63741: ARRAY
63742: PPUSH
63743: CALL_OW 284
63747: PUSH
63748: LD_INT 0
63750: EQUAL
63751: AND
63752: IFFALSE 63807
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63754: LD_ADDR_VAR 0 5
63758: PUSH
63759: LD_EXP 81
63763: PUSH
63764: LD_VAR 0 2
63768: ARRAY
63769: PPUSH
63770: LD_VAR 0 3
63774: PPUSH
63775: CALL_OW 3
63779: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63780: LD_ADDR_EXP 81
63784: PUSH
63785: LD_EXP 81
63789: PPUSH
63790: LD_VAR 0 2
63794: PPUSH
63795: LD_VAR 0 5
63799: PPUSH
63800: CALL_OW 1
63804: ST_TO_ADDR
// continue ;
63805: GO 63651
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63807: LD_EXP 65
63811: PUSH
63812: LD_VAR 0 2
63816: ARRAY
63817: PUSH
63818: LD_INT 1
63820: ARRAY
63821: PPUSH
63822: CALL_OW 255
63826: PPUSH
63827: LD_EXP 81
63831: PUSH
63832: LD_VAR 0 2
63836: ARRAY
63837: PUSH
63838: LD_VAR 0 3
63842: ARRAY
63843: PUSH
63844: LD_INT 2
63846: ARRAY
63847: PPUSH
63848: LD_EXP 81
63852: PUSH
63853: LD_VAR 0 2
63857: ARRAY
63858: PUSH
63859: LD_VAR 0 3
63863: ARRAY
63864: PUSH
63865: LD_INT 3
63867: ARRAY
63868: PPUSH
63869: LD_INT 30
63871: PPUSH
63872: CALL 19475 0 4
63876: PUSH
63877: LD_INT 4
63879: ARRAY
63880: PUSH
63881: LD_INT 0
63883: EQUAL
63884: IFFALSE 63910
// begin target := mc_crates [ i ] [ j ] ;
63886: LD_ADDR_VAR 0 6
63890: PUSH
63891: LD_EXP 81
63895: PUSH
63896: LD_VAR 0 2
63900: ARRAY
63901: PUSH
63902: LD_VAR 0 3
63906: ARRAY
63907: ST_TO_ADDR
// break ;
63908: GO 63912
// end ; end ;
63910: GO 63651
63912: POP
63913: POP
// if not target then
63914: LD_VAR 0 6
63918: NOT
63919: IFFALSE 63923
// continue ;
63921: GO 63532
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63923: LD_ADDR_VAR 0 7
63927: PUSH
63928: LD_EXP 84
63932: PUSH
63933: LD_VAR 0 2
63937: ARRAY
63938: PPUSH
63939: LD_INT 2
63941: PUSH
63942: LD_INT 3
63944: PUSH
63945: LD_INT 58
63947: PUSH
63948: EMPTY
63949: LIST
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PUSH
63955: LD_INT 61
63957: PUSH
63958: EMPTY
63959: LIST
63960: PUSH
63961: LD_INT 33
63963: PUSH
63964: LD_INT 5
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PUSH
63971: LD_INT 33
63973: PUSH
63974: LD_INT 3
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: LIST
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 2
63990: PUSH
63991: LD_INT 34
63993: PUSH
63994: LD_INT 32
63996: PUSH
63997: EMPTY
63998: LIST
63999: LIST
64000: PUSH
64001: LD_INT 34
64003: PUSH
64004: LD_INT 51
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PUSH
64011: LD_INT 34
64013: PUSH
64014: LD_INT 12
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: LIST
64025: LIST
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PPUSH
64031: CALL_OW 72
64035: ST_TO_ADDR
// if not cargo then
64036: LD_VAR 0 7
64040: NOT
64041: IFFALSE 64684
// begin if mc_crates_collector [ i ] < 5 then
64043: LD_EXP 82
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: PUSH
64054: LD_INT 5
64056: LESS
64057: IFFALSE 64423
// begin if mc_ape [ i ] then
64059: LD_EXP 94
64063: PUSH
64064: LD_VAR 0 2
64068: ARRAY
64069: IFFALSE 64116
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64071: LD_ADDR_VAR 0 5
64075: PUSH
64076: LD_EXP 94
64080: PUSH
64081: LD_VAR 0 2
64085: ARRAY
64086: PPUSH
64087: LD_INT 25
64089: PUSH
64090: LD_INT 16
64092: PUSH
64093: EMPTY
64094: LIST
64095: LIST
64096: PUSH
64097: LD_INT 24
64099: PUSH
64100: LD_INT 750
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PPUSH
64111: CALL_OW 72
64115: ST_TO_ADDR
// if not tmp then
64116: LD_VAR 0 5
64120: NOT
64121: IFFALSE 64168
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64123: LD_ADDR_VAR 0 5
64127: PUSH
64128: LD_EXP 65
64132: PUSH
64133: LD_VAR 0 2
64137: ARRAY
64138: PPUSH
64139: LD_INT 25
64141: PUSH
64142: LD_INT 2
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: LD_INT 24
64151: PUSH
64152: LD_INT 750
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PPUSH
64163: CALL_OW 72
64167: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64168: LD_EXP 94
64172: PUSH
64173: LD_VAR 0 2
64177: ARRAY
64178: PUSH
64179: LD_EXP 65
64183: PUSH
64184: LD_VAR 0 2
64188: ARRAY
64189: PPUSH
64190: LD_INT 25
64192: PUSH
64193: LD_INT 2
64195: PUSH
64196: EMPTY
64197: LIST
64198: LIST
64199: PUSH
64200: LD_INT 24
64202: PUSH
64203: LD_INT 750
64205: PUSH
64206: EMPTY
64207: LIST
64208: LIST
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PPUSH
64214: CALL_OW 72
64218: AND
64219: PUSH
64220: LD_VAR 0 5
64224: PUSH
64225: LD_INT 5
64227: LESS
64228: AND
64229: IFFALSE 64311
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64231: LD_ADDR_VAR 0 3
64235: PUSH
64236: LD_EXP 65
64240: PUSH
64241: LD_VAR 0 2
64245: ARRAY
64246: PPUSH
64247: LD_INT 25
64249: PUSH
64250: LD_INT 2
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 24
64259: PUSH
64260: LD_INT 750
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: EMPTY
64268: LIST
64269: LIST
64270: PPUSH
64271: CALL_OW 72
64275: PUSH
64276: FOR_IN
64277: IFFALSE 64309
// begin tmp := tmp union j ;
64279: LD_ADDR_VAR 0 5
64283: PUSH
64284: LD_VAR 0 5
64288: PUSH
64289: LD_VAR 0 3
64293: UNION
64294: ST_TO_ADDR
// if tmp >= 5 then
64295: LD_VAR 0 5
64299: PUSH
64300: LD_INT 5
64302: GREATEREQUAL
64303: IFFALSE 64307
// break ;
64305: GO 64309
// end ;
64307: GO 64276
64309: POP
64310: POP
// end ; if not tmp then
64311: LD_VAR 0 5
64315: NOT
64316: IFFALSE 64320
// continue ;
64318: GO 63532
// for j in tmp do
64320: LD_ADDR_VAR 0 3
64324: PUSH
64325: LD_VAR 0 5
64329: PUSH
64330: FOR_IN
64331: IFFALSE 64421
// if not GetTag ( j ) then
64333: LD_VAR 0 3
64337: PPUSH
64338: CALL_OW 110
64342: NOT
64343: IFFALSE 64419
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64345: LD_ADDR_EXP 82
64349: PUSH
64350: LD_EXP 82
64354: PPUSH
64355: LD_VAR 0 2
64359: PUSH
64360: LD_EXP 82
64364: PUSH
64365: LD_VAR 0 2
64369: ARRAY
64370: PUSH
64371: LD_INT 1
64373: PLUS
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PPUSH
64379: LD_VAR 0 3
64383: PPUSH
64384: CALL 18579 0 3
64388: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64389: LD_VAR 0 3
64393: PPUSH
64394: LD_INT 107
64396: PPUSH
64397: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64401: LD_EXP 82
64405: PUSH
64406: LD_VAR 0 2
64410: ARRAY
64411: PUSH
64412: LD_INT 5
64414: GREATEREQUAL
64415: IFFALSE 64419
// break ;
64417: GO 64421
// end ;
64419: GO 64330
64421: POP
64422: POP
// end ; if mc_crates_collector [ i ] and target then
64423: LD_EXP 82
64427: PUSH
64428: LD_VAR 0 2
64432: ARRAY
64433: PUSH
64434: LD_VAR 0 6
64438: AND
64439: IFFALSE 64682
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64441: LD_EXP 82
64445: PUSH
64446: LD_VAR 0 2
64450: ARRAY
64451: PUSH
64452: LD_VAR 0 6
64456: PUSH
64457: LD_INT 1
64459: ARRAY
64460: LESS
64461: IFFALSE 64481
// tmp := mc_crates_collector [ i ] else
64463: LD_ADDR_VAR 0 5
64467: PUSH
64468: LD_EXP 82
64472: PUSH
64473: LD_VAR 0 2
64477: ARRAY
64478: ST_TO_ADDR
64479: GO 64495
// tmp := target [ 1 ] ;
64481: LD_ADDR_VAR 0 5
64485: PUSH
64486: LD_VAR 0 6
64490: PUSH
64491: LD_INT 1
64493: ARRAY
64494: ST_TO_ADDR
// k := 0 ;
64495: LD_ADDR_VAR 0 4
64499: PUSH
64500: LD_INT 0
64502: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64503: LD_ADDR_VAR 0 3
64507: PUSH
64508: LD_EXP 82
64512: PUSH
64513: LD_VAR 0 2
64517: ARRAY
64518: PUSH
64519: FOR_IN
64520: IFFALSE 64680
// begin k := k + 1 ;
64522: LD_ADDR_VAR 0 4
64526: PUSH
64527: LD_VAR 0 4
64531: PUSH
64532: LD_INT 1
64534: PLUS
64535: ST_TO_ADDR
// if k > tmp then
64536: LD_VAR 0 4
64540: PUSH
64541: LD_VAR 0 5
64545: GREATER
64546: IFFALSE 64550
// break ;
64548: GO 64680
// if not GetClass ( j ) in [ 2 , 16 ] then
64550: LD_VAR 0 3
64554: PPUSH
64555: CALL_OW 257
64559: PUSH
64560: LD_INT 2
64562: PUSH
64563: LD_INT 16
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: IN
64570: NOT
64571: IFFALSE 64624
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64573: LD_ADDR_EXP 82
64577: PUSH
64578: LD_EXP 82
64582: PPUSH
64583: LD_VAR 0 2
64587: PPUSH
64588: LD_EXP 82
64592: PUSH
64593: LD_VAR 0 2
64597: ARRAY
64598: PUSH
64599: LD_VAR 0 3
64603: DIFF
64604: PPUSH
64605: CALL_OW 1
64609: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64610: LD_VAR 0 3
64614: PPUSH
64615: LD_INT 0
64617: PPUSH
64618: CALL_OW 109
// continue ;
64622: GO 64519
// end ; if IsInUnit ( j ) then
64624: LD_VAR 0 3
64628: PPUSH
64629: CALL_OW 310
64633: IFFALSE 64644
// ComExitBuilding ( j ) ;
64635: LD_VAR 0 3
64639: PPUSH
64640: CALL_OW 122
// wait ( 3 ) ;
64644: LD_INT 3
64646: PPUSH
64647: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64651: LD_VAR 0 3
64655: PPUSH
64656: LD_VAR 0 6
64660: PUSH
64661: LD_INT 2
64663: ARRAY
64664: PPUSH
64665: LD_VAR 0 6
64669: PUSH
64670: LD_INT 3
64672: ARRAY
64673: PPUSH
64674: CALL_OW 117
// end ;
64678: GO 64519
64680: POP
64681: POP
// end ; end else
64682: GO 65263
// begin for j in cargo do
64684: LD_ADDR_VAR 0 3
64688: PUSH
64689: LD_VAR 0 7
64693: PUSH
64694: FOR_IN
64695: IFFALSE 65261
// begin if GetTag ( j ) <> 0 then
64697: LD_VAR 0 3
64701: PPUSH
64702: CALL_OW 110
64706: PUSH
64707: LD_INT 0
64709: NONEQUAL
64710: IFFALSE 64714
// continue ;
64712: GO 64694
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64714: LD_VAR 0 3
64718: PPUSH
64719: CALL_OW 256
64723: PUSH
64724: LD_INT 1000
64726: LESS
64727: PUSH
64728: LD_VAR 0 3
64732: PPUSH
64733: LD_EXP 89
64737: PUSH
64738: LD_VAR 0 2
64742: ARRAY
64743: PPUSH
64744: CALL_OW 308
64748: NOT
64749: AND
64750: IFFALSE 64772
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64752: LD_VAR 0 3
64756: PPUSH
64757: LD_EXP 89
64761: PUSH
64762: LD_VAR 0 2
64766: ARRAY
64767: PPUSH
64768: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64772: LD_VAR 0 3
64776: PPUSH
64777: CALL_OW 256
64781: PUSH
64782: LD_INT 1000
64784: LESS
64785: PUSH
64786: LD_VAR 0 3
64790: PPUSH
64791: LD_EXP 89
64795: PUSH
64796: LD_VAR 0 2
64800: ARRAY
64801: PPUSH
64802: CALL_OW 308
64806: AND
64807: IFFALSE 64811
// continue ;
64809: GO 64694
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64811: LD_VAR 0 3
64815: PPUSH
64816: CALL_OW 262
64820: PUSH
64821: LD_INT 2
64823: EQUAL
64824: PUSH
64825: LD_VAR 0 3
64829: PPUSH
64830: CALL_OW 261
64834: PUSH
64835: LD_INT 15
64837: LESS
64838: AND
64839: IFFALSE 64843
// continue ;
64841: GO 64694
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64843: LD_VAR 0 3
64847: PPUSH
64848: CALL_OW 262
64852: PUSH
64853: LD_INT 1
64855: EQUAL
64856: PUSH
64857: LD_VAR 0 3
64861: PPUSH
64862: CALL_OW 261
64866: PUSH
64867: LD_INT 10
64869: LESS
64870: AND
64871: IFFALSE 65200
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64873: LD_ADDR_VAR 0 8
64877: PUSH
64878: LD_EXP 65
64882: PUSH
64883: LD_VAR 0 2
64887: ARRAY
64888: PPUSH
64889: LD_INT 2
64891: PUSH
64892: LD_INT 30
64894: PUSH
64895: LD_INT 0
64897: PUSH
64898: EMPTY
64899: LIST
64900: LIST
64901: PUSH
64902: LD_INT 30
64904: PUSH
64905: LD_INT 1
64907: PUSH
64908: EMPTY
64909: LIST
64910: LIST
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: LIST
64916: PPUSH
64917: CALL_OW 72
64921: ST_TO_ADDR
// if not depot then
64922: LD_VAR 0 8
64926: NOT
64927: IFFALSE 64931
// continue ;
64929: GO 64694
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64931: LD_VAR 0 3
64935: PPUSH
64936: LD_VAR 0 8
64940: PPUSH
64941: LD_VAR 0 3
64945: PPUSH
64946: CALL_OW 74
64950: PPUSH
64951: CALL_OW 296
64955: PUSH
64956: LD_INT 6
64958: LESS
64959: IFFALSE 64975
// SetFuel ( j , 100 ) else
64961: LD_VAR 0 3
64965: PPUSH
64966: LD_INT 100
64968: PPUSH
64969: CALL_OW 240
64973: GO 65200
// if GetFuel ( j ) = 0 then
64975: LD_VAR 0 3
64979: PPUSH
64980: CALL_OW 261
64984: PUSH
64985: LD_INT 0
64987: EQUAL
64988: IFFALSE 65200
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64990: LD_ADDR_EXP 84
64994: PUSH
64995: LD_EXP 84
64999: PPUSH
65000: LD_VAR 0 2
65004: PPUSH
65005: LD_EXP 84
65009: PUSH
65010: LD_VAR 0 2
65014: ARRAY
65015: PUSH
65016: LD_VAR 0 3
65020: DIFF
65021: PPUSH
65022: CALL_OW 1
65026: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65027: LD_VAR 0 3
65031: PPUSH
65032: CALL_OW 263
65036: PUSH
65037: LD_INT 1
65039: EQUAL
65040: IFFALSE 65056
// ComExitVehicle ( IsInUnit ( j ) ) ;
65042: LD_VAR 0 3
65046: PPUSH
65047: CALL_OW 310
65051: PPUSH
65052: CALL_OW 121
// if GetControl ( j ) = control_remote then
65056: LD_VAR 0 3
65060: PPUSH
65061: CALL_OW 263
65065: PUSH
65066: LD_INT 2
65068: EQUAL
65069: IFFALSE 65080
// ComUnlink ( j ) ;
65071: LD_VAR 0 3
65075: PPUSH
65076: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65080: LD_ADDR_VAR 0 9
65084: PUSH
65085: LD_VAR 0 2
65089: PPUSH
65090: LD_INT 3
65092: PPUSH
65093: CALL 74553 0 2
65097: ST_TO_ADDR
// if fac then
65098: LD_VAR 0 9
65102: IFFALSE 65198
// begin for k in fac do
65104: LD_ADDR_VAR 0 4
65108: PUSH
65109: LD_VAR 0 9
65113: PUSH
65114: FOR_IN
65115: IFFALSE 65196
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65117: LD_ADDR_VAR 0 10
65121: PUSH
65122: LD_VAR 0 9
65126: PPUSH
65127: LD_VAR 0 3
65131: PPUSH
65132: CALL_OW 265
65136: PPUSH
65137: LD_VAR 0 3
65141: PPUSH
65142: CALL_OW 262
65146: PPUSH
65147: LD_VAR 0 3
65151: PPUSH
65152: CALL_OW 263
65156: PPUSH
65157: LD_VAR 0 3
65161: PPUSH
65162: CALL_OW 264
65166: PPUSH
65167: CALL 16111 0 5
65171: ST_TO_ADDR
// if components then
65172: LD_VAR 0 10
65176: IFFALSE 65194
// begin MC_InsertProduceList ( i , components ) ;
65178: LD_VAR 0 2
65182: PPUSH
65183: LD_VAR 0 10
65187: PPUSH
65188: CALL 74098 0 2
// break ;
65192: GO 65196
// end ; end ;
65194: GO 65114
65196: POP
65197: POP
// end ; continue ;
65198: GO 64694
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65200: LD_VAR 0 3
65204: PPUSH
65205: LD_INT 1
65207: PPUSH
65208: CALL_OW 289
65212: PUSH
65213: LD_INT 100
65215: LESS
65216: PUSH
65217: LD_VAR 0 3
65221: PPUSH
65222: CALL_OW 314
65226: NOT
65227: AND
65228: IFFALSE 65257
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65230: LD_VAR 0 3
65234: PPUSH
65235: LD_VAR 0 6
65239: PUSH
65240: LD_INT 2
65242: ARRAY
65243: PPUSH
65244: LD_VAR 0 6
65248: PUSH
65249: LD_INT 3
65251: ARRAY
65252: PPUSH
65253: CALL_OW 117
// break ;
65257: GO 65261
// end ;
65259: GO 64694
65261: POP
65262: POP
// end ; end ;
65263: GO 63532
65265: POP
65266: POP
// end ;
65267: LD_VAR 0 1
65271: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65272: LD_INT 0
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
// if not mc_bases then
65278: LD_EXP 65
65282: NOT
65283: IFFALSE 65287
// exit ;
65285: GO 65448
// for i = 1 to mc_bases do
65287: LD_ADDR_VAR 0 2
65291: PUSH
65292: DOUBLE
65293: LD_INT 1
65295: DEC
65296: ST_TO_ADDR
65297: LD_EXP 65
65301: PUSH
65302: FOR_TO
65303: IFFALSE 65446
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65305: LD_ADDR_VAR 0 4
65309: PUSH
65310: LD_EXP 84
65314: PUSH
65315: LD_VAR 0 2
65319: ARRAY
65320: PUSH
65321: LD_EXP 87
65325: PUSH
65326: LD_VAR 0 2
65330: ARRAY
65331: UNION
65332: PPUSH
65333: LD_INT 33
65335: PUSH
65336: LD_INT 2
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PPUSH
65343: CALL_OW 72
65347: ST_TO_ADDR
// if tmp then
65348: LD_VAR 0 4
65352: IFFALSE 65444
// for j in tmp do
65354: LD_ADDR_VAR 0 3
65358: PUSH
65359: LD_VAR 0 4
65363: PUSH
65364: FOR_IN
65365: IFFALSE 65442
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65367: LD_VAR 0 3
65371: PPUSH
65372: CALL_OW 312
65376: NOT
65377: PUSH
65378: LD_VAR 0 3
65382: PPUSH
65383: CALL_OW 256
65387: PUSH
65388: LD_INT 250
65390: GREATEREQUAL
65391: AND
65392: IFFALSE 65405
// Connect ( j ) else
65394: LD_VAR 0 3
65398: PPUSH
65399: CALL 21512 0 1
65403: GO 65440
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65405: LD_VAR 0 3
65409: PPUSH
65410: CALL_OW 256
65414: PUSH
65415: LD_INT 250
65417: LESS
65418: PUSH
65419: LD_VAR 0 3
65423: PPUSH
65424: CALL_OW 312
65428: AND
65429: IFFALSE 65440
// ComUnlink ( j ) ;
65431: LD_VAR 0 3
65435: PPUSH
65436: CALL_OW 136
65440: GO 65364
65442: POP
65443: POP
// end ;
65444: GO 65302
65446: POP
65447: POP
// end ;
65448: LD_VAR 0 1
65452: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65453: LD_INT 0
65455: PPUSH
65456: PPUSH
65457: PPUSH
65458: PPUSH
65459: PPUSH
// if not mc_bases then
65460: LD_EXP 65
65464: NOT
65465: IFFALSE 65469
// exit ;
65467: GO 65914
// for i = 1 to mc_bases do
65469: LD_ADDR_VAR 0 2
65473: PUSH
65474: DOUBLE
65475: LD_INT 1
65477: DEC
65478: ST_TO_ADDR
65479: LD_EXP 65
65483: PUSH
65484: FOR_TO
65485: IFFALSE 65912
// begin if not mc_produce [ i ] then
65487: LD_EXP 86
65491: PUSH
65492: LD_VAR 0 2
65496: ARRAY
65497: NOT
65498: IFFALSE 65502
// continue ;
65500: GO 65484
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65502: LD_ADDR_VAR 0 5
65506: PUSH
65507: LD_EXP 65
65511: PUSH
65512: LD_VAR 0 2
65516: ARRAY
65517: PPUSH
65518: LD_INT 30
65520: PUSH
65521: LD_INT 3
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PPUSH
65528: CALL_OW 72
65532: ST_TO_ADDR
// if not fac then
65533: LD_VAR 0 5
65537: NOT
65538: IFFALSE 65542
// continue ;
65540: GO 65484
// for j in fac do
65542: LD_ADDR_VAR 0 3
65546: PUSH
65547: LD_VAR 0 5
65551: PUSH
65552: FOR_IN
65553: IFFALSE 65908
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65555: LD_VAR 0 3
65559: PPUSH
65560: CALL_OW 461
65564: PUSH
65565: LD_INT 2
65567: NONEQUAL
65568: PUSH
65569: LD_VAR 0 3
65573: PPUSH
65574: LD_INT 15
65576: PPUSH
65577: CALL 21172 0 2
65581: PUSH
65582: LD_INT 4
65584: ARRAY
65585: OR
65586: IFFALSE 65590
// continue ;
65588: GO 65552
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65590: LD_VAR 0 3
65594: PPUSH
65595: LD_EXP 86
65599: PUSH
65600: LD_VAR 0 2
65604: ARRAY
65605: PUSH
65606: LD_INT 1
65608: ARRAY
65609: PUSH
65610: LD_INT 1
65612: ARRAY
65613: PPUSH
65614: LD_EXP 86
65618: PUSH
65619: LD_VAR 0 2
65623: ARRAY
65624: PUSH
65625: LD_INT 1
65627: ARRAY
65628: PUSH
65629: LD_INT 2
65631: ARRAY
65632: PPUSH
65633: LD_EXP 86
65637: PUSH
65638: LD_VAR 0 2
65642: ARRAY
65643: PUSH
65644: LD_INT 1
65646: ARRAY
65647: PUSH
65648: LD_INT 3
65650: ARRAY
65651: PPUSH
65652: LD_EXP 86
65656: PUSH
65657: LD_VAR 0 2
65661: ARRAY
65662: PUSH
65663: LD_INT 1
65665: ARRAY
65666: PUSH
65667: LD_INT 4
65669: ARRAY
65670: PPUSH
65671: CALL_OW 448
65675: PUSH
65676: LD_VAR 0 3
65680: PPUSH
65681: LD_EXP 86
65685: PUSH
65686: LD_VAR 0 2
65690: ARRAY
65691: PUSH
65692: LD_INT 1
65694: ARRAY
65695: PUSH
65696: LD_INT 1
65698: ARRAY
65699: PUSH
65700: LD_EXP 86
65704: PUSH
65705: LD_VAR 0 2
65709: ARRAY
65710: PUSH
65711: LD_INT 1
65713: ARRAY
65714: PUSH
65715: LD_INT 2
65717: ARRAY
65718: PUSH
65719: LD_EXP 86
65723: PUSH
65724: LD_VAR 0 2
65728: ARRAY
65729: PUSH
65730: LD_INT 1
65732: ARRAY
65733: PUSH
65734: LD_INT 3
65736: ARRAY
65737: PUSH
65738: LD_EXP 86
65742: PUSH
65743: LD_VAR 0 2
65747: ARRAY
65748: PUSH
65749: LD_INT 1
65751: ARRAY
65752: PUSH
65753: LD_INT 4
65755: ARRAY
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: PPUSH
65763: CALL 24843 0 2
65767: AND
65768: IFFALSE 65906
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65770: LD_VAR 0 3
65774: PPUSH
65775: LD_EXP 86
65779: PUSH
65780: LD_VAR 0 2
65784: ARRAY
65785: PUSH
65786: LD_INT 1
65788: ARRAY
65789: PUSH
65790: LD_INT 1
65792: ARRAY
65793: PPUSH
65794: LD_EXP 86
65798: PUSH
65799: LD_VAR 0 2
65803: ARRAY
65804: PUSH
65805: LD_INT 1
65807: ARRAY
65808: PUSH
65809: LD_INT 2
65811: ARRAY
65812: PPUSH
65813: LD_EXP 86
65817: PUSH
65818: LD_VAR 0 2
65822: ARRAY
65823: PUSH
65824: LD_INT 1
65826: ARRAY
65827: PUSH
65828: LD_INT 3
65830: ARRAY
65831: PPUSH
65832: LD_EXP 86
65836: PUSH
65837: LD_VAR 0 2
65841: ARRAY
65842: PUSH
65843: LD_INT 1
65845: ARRAY
65846: PUSH
65847: LD_INT 4
65849: ARRAY
65850: PPUSH
65851: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65855: LD_ADDR_VAR 0 4
65859: PUSH
65860: LD_EXP 86
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: PPUSH
65871: LD_INT 1
65873: PPUSH
65874: CALL_OW 3
65878: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65879: LD_ADDR_EXP 86
65883: PUSH
65884: LD_EXP 86
65888: PPUSH
65889: LD_VAR 0 2
65893: PPUSH
65894: LD_VAR 0 4
65898: PPUSH
65899: CALL_OW 1
65903: ST_TO_ADDR
// break ;
65904: GO 65908
// end ; end ;
65906: GO 65552
65908: POP
65909: POP
// end ;
65910: GO 65484
65912: POP
65913: POP
// end ;
65914: LD_VAR 0 1
65918: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65919: LD_INT 0
65921: PPUSH
65922: PPUSH
65923: PPUSH
// if not mc_bases then
65924: LD_EXP 65
65928: NOT
65929: IFFALSE 65933
// exit ;
65931: GO 66022
// for i = 1 to mc_bases do
65933: LD_ADDR_VAR 0 2
65937: PUSH
65938: DOUBLE
65939: LD_INT 1
65941: DEC
65942: ST_TO_ADDR
65943: LD_EXP 65
65947: PUSH
65948: FOR_TO
65949: IFFALSE 66020
// begin if mc_attack [ i ] then
65951: LD_EXP 85
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: IFFALSE 66018
// begin tmp := mc_attack [ i ] [ 1 ] ;
65963: LD_ADDR_VAR 0 3
65967: PUSH
65968: LD_EXP 85
65972: PUSH
65973: LD_VAR 0 2
65977: ARRAY
65978: PUSH
65979: LD_INT 1
65981: ARRAY
65982: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65983: LD_ADDR_EXP 85
65987: PUSH
65988: LD_EXP 85
65992: PPUSH
65993: LD_VAR 0 2
65997: PPUSH
65998: EMPTY
65999: PPUSH
66000: CALL_OW 1
66004: ST_TO_ADDR
// Attack ( tmp ) ;
66005: LD_VAR 0 3
66009: PPUSH
66010: CALL 95402 0 1
// exit ;
66014: POP
66015: POP
66016: GO 66022
// end ; end ;
66018: GO 65948
66020: POP
66021: POP
// end ;
66022: LD_VAR 0 1
66026: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66027: LD_INT 0
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
66034: PPUSH
66035: PPUSH
// if not mc_bases then
66036: LD_EXP 65
66040: NOT
66041: IFFALSE 66045
// exit ;
66043: GO 66627
// for i = 1 to mc_bases do
66045: LD_ADDR_VAR 0 2
66049: PUSH
66050: DOUBLE
66051: LD_INT 1
66053: DEC
66054: ST_TO_ADDR
66055: LD_EXP 65
66059: PUSH
66060: FOR_TO
66061: IFFALSE 66625
// begin if not mc_bases [ i ] then
66063: LD_EXP 65
66067: PUSH
66068: LD_VAR 0 2
66072: ARRAY
66073: NOT
66074: IFFALSE 66078
// continue ;
66076: GO 66060
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66078: LD_ADDR_VAR 0 7
66082: PUSH
66083: LD_EXP 65
66087: PUSH
66088: LD_VAR 0 2
66092: ARRAY
66093: PUSH
66094: LD_INT 1
66096: ARRAY
66097: PPUSH
66098: CALL 15415 0 1
66102: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66103: LD_ADDR_EXP 88
66107: PUSH
66108: LD_EXP 88
66112: PPUSH
66113: LD_VAR 0 2
66117: PPUSH
66118: LD_EXP 65
66122: PUSH
66123: LD_VAR 0 2
66127: ARRAY
66128: PUSH
66129: LD_INT 1
66131: ARRAY
66132: PPUSH
66133: CALL_OW 255
66137: PPUSH
66138: LD_EXP 90
66142: PUSH
66143: LD_VAR 0 2
66147: ARRAY
66148: PPUSH
66149: CALL 15380 0 2
66153: PPUSH
66154: CALL_OW 1
66158: ST_TO_ADDR
// if not mc_scan [ i ] then
66159: LD_EXP 88
66163: PUSH
66164: LD_VAR 0 2
66168: ARRAY
66169: NOT
66170: IFFALSE 66325
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66172: LD_ADDR_VAR 0 4
66176: PUSH
66177: LD_EXP 65
66181: PUSH
66182: LD_VAR 0 2
66186: ARRAY
66187: PPUSH
66188: LD_INT 2
66190: PUSH
66191: LD_INT 25
66193: PUSH
66194: LD_INT 5
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: LD_INT 25
66203: PUSH
66204: LD_INT 8
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PUSH
66211: LD_INT 25
66213: PUSH
66214: LD_INT 9
66216: PUSH
66217: EMPTY
66218: LIST
66219: LIST
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: PPUSH
66227: CALL_OW 72
66231: ST_TO_ADDR
// if not tmp then
66232: LD_VAR 0 4
66236: NOT
66237: IFFALSE 66241
// continue ;
66239: GO 66060
// for j in tmp do
66241: LD_ADDR_VAR 0 3
66245: PUSH
66246: LD_VAR 0 4
66250: PUSH
66251: FOR_IN
66252: IFFALSE 66323
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66254: LD_VAR 0 3
66258: PPUSH
66259: CALL_OW 310
66263: PPUSH
66264: CALL_OW 266
66268: PUSH
66269: LD_INT 5
66271: EQUAL
66272: PUSH
66273: LD_VAR 0 3
66277: PPUSH
66278: CALL_OW 257
66282: PUSH
66283: LD_INT 1
66285: EQUAL
66286: AND
66287: PUSH
66288: LD_VAR 0 3
66292: PPUSH
66293: CALL_OW 459
66297: NOT
66298: AND
66299: PUSH
66300: LD_VAR 0 7
66304: AND
66305: IFFALSE 66321
// ComChangeProfession ( j , class ) ;
66307: LD_VAR 0 3
66311: PPUSH
66312: LD_VAR 0 7
66316: PPUSH
66317: CALL_OW 123
66321: GO 66251
66323: POP
66324: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66325: LD_EXP 88
66329: PUSH
66330: LD_VAR 0 2
66334: ARRAY
66335: PUSH
66336: LD_EXP 87
66340: PUSH
66341: LD_VAR 0 2
66345: ARRAY
66346: NOT
66347: AND
66348: PUSH
66349: LD_EXP 65
66353: PUSH
66354: LD_VAR 0 2
66358: ARRAY
66359: PPUSH
66360: LD_INT 30
66362: PUSH
66363: LD_INT 32
66365: PUSH
66366: EMPTY
66367: LIST
66368: LIST
66369: PPUSH
66370: CALL_OW 72
66374: NOT
66375: AND
66376: PUSH
66377: LD_EXP 65
66381: PUSH
66382: LD_VAR 0 2
66386: ARRAY
66387: PPUSH
66388: LD_INT 2
66390: PUSH
66391: LD_INT 30
66393: PUSH
66394: LD_INT 4
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 30
66403: PUSH
66404: LD_INT 5
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: LIST
66415: PPUSH
66416: CALL_OW 72
66420: NOT
66421: AND
66422: IFFALSE 66554
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66424: LD_ADDR_VAR 0 4
66428: PUSH
66429: LD_EXP 65
66433: PUSH
66434: LD_VAR 0 2
66438: ARRAY
66439: PPUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 25
66445: PUSH
66446: LD_INT 1
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 25
66455: PUSH
66456: LD_INT 5
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 25
66465: PUSH
66466: LD_INT 8
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: LD_INT 25
66475: PUSH
66476: LD_INT 9
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: PPUSH
66490: CALL_OW 72
66494: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66495: LD_ADDR_VAR 0 4
66499: PUSH
66500: LD_VAR 0 4
66504: PUSH
66505: LD_VAR 0 4
66509: PPUSH
66510: LD_INT 18
66512: PPUSH
66513: CALL 47140 0 2
66517: DIFF
66518: ST_TO_ADDR
// if tmp then
66519: LD_VAR 0 4
66523: IFFALSE 66554
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66525: LD_VAR 0 2
66529: PPUSH
66530: LD_VAR 0 4
66534: PPUSH
66535: LD_EXP 90
66539: PUSH
66540: LD_VAR 0 2
66544: ARRAY
66545: PPUSH
66546: CALL 100111 0 3
// exit ;
66550: POP
66551: POP
66552: GO 66627
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66554: LD_EXP 88
66558: PUSH
66559: LD_VAR 0 2
66563: ARRAY
66564: PUSH
66565: LD_EXP 87
66569: PUSH
66570: LD_VAR 0 2
66574: ARRAY
66575: AND
66576: IFFALSE 66623
// begin tmp := mc_defender [ i ] ;
66578: LD_ADDR_VAR 0 4
66582: PUSH
66583: LD_EXP 87
66587: PUSH
66588: LD_VAR 0 2
66592: ARRAY
66593: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66594: LD_VAR 0 2
66598: PPUSH
66599: LD_VAR 0 4
66603: PPUSH
66604: LD_EXP 88
66608: PUSH
66609: LD_VAR 0 2
66613: ARRAY
66614: PPUSH
66615: CALL 100672 0 3
// exit ;
66619: POP
66620: POP
66621: GO 66627
// end ; end ;
66623: GO 66060
66625: POP
66626: POP
// end ;
66627: LD_VAR 0 1
66631: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66632: LD_INT 0
66634: PPUSH
66635: PPUSH
66636: PPUSH
66637: PPUSH
66638: PPUSH
66639: PPUSH
66640: PPUSH
66641: PPUSH
66642: PPUSH
66643: PPUSH
66644: PPUSH
// if not mc_bases then
66645: LD_EXP 65
66649: NOT
66650: IFFALSE 66654
// exit ;
66652: GO 67741
// for i = 1 to mc_bases do
66654: LD_ADDR_VAR 0 2
66658: PUSH
66659: DOUBLE
66660: LD_INT 1
66662: DEC
66663: ST_TO_ADDR
66664: LD_EXP 65
66668: PUSH
66669: FOR_TO
66670: IFFALSE 67739
// begin tmp := mc_lab [ i ] ;
66672: LD_ADDR_VAR 0 6
66676: PUSH
66677: LD_EXP 98
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: ST_TO_ADDR
// if not tmp then
66688: LD_VAR 0 6
66692: NOT
66693: IFFALSE 66697
// continue ;
66695: GO 66669
// idle_lab := 0 ;
66697: LD_ADDR_VAR 0 11
66701: PUSH
66702: LD_INT 0
66704: ST_TO_ADDR
// for j in tmp do
66705: LD_ADDR_VAR 0 3
66709: PUSH
66710: LD_VAR 0 6
66714: PUSH
66715: FOR_IN
66716: IFFALSE 67735
// begin researching := false ;
66718: LD_ADDR_VAR 0 10
66722: PUSH
66723: LD_INT 0
66725: ST_TO_ADDR
// side := GetSide ( j ) ;
66726: LD_ADDR_VAR 0 4
66730: PUSH
66731: LD_VAR 0 3
66735: PPUSH
66736: CALL_OW 255
66740: ST_TO_ADDR
// if not mc_tech [ side ] then
66741: LD_EXP 92
66745: PUSH
66746: LD_VAR 0 4
66750: ARRAY
66751: NOT
66752: IFFALSE 66756
// continue ;
66754: GO 66715
// if BuildingStatus ( j ) = bs_idle then
66756: LD_VAR 0 3
66760: PPUSH
66761: CALL_OW 461
66765: PUSH
66766: LD_INT 2
66768: EQUAL
66769: IFFALSE 66957
// begin if idle_lab and UnitsInside ( j ) < 6 then
66771: LD_VAR 0 11
66775: PUSH
66776: LD_VAR 0 3
66780: PPUSH
66781: CALL_OW 313
66785: PUSH
66786: LD_INT 6
66788: LESS
66789: AND
66790: IFFALSE 66861
// begin tmp2 := UnitsInside ( idle_lab ) ;
66792: LD_ADDR_VAR 0 9
66796: PUSH
66797: LD_VAR 0 11
66801: PPUSH
66802: CALL_OW 313
66806: ST_TO_ADDR
// if tmp2 then
66807: LD_VAR 0 9
66811: IFFALSE 66853
// for x in tmp2 do
66813: LD_ADDR_VAR 0 7
66817: PUSH
66818: LD_VAR 0 9
66822: PUSH
66823: FOR_IN
66824: IFFALSE 66851
// begin ComExitBuilding ( x ) ;
66826: LD_VAR 0 7
66830: PPUSH
66831: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66835: LD_VAR 0 7
66839: PPUSH
66840: LD_VAR 0 3
66844: PPUSH
66845: CALL_OW 180
// end ;
66849: GO 66823
66851: POP
66852: POP
// idle_lab := 0 ;
66853: LD_ADDR_VAR 0 11
66857: PUSH
66858: LD_INT 0
66860: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66861: LD_ADDR_VAR 0 5
66865: PUSH
66866: LD_EXP 92
66870: PUSH
66871: LD_VAR 0 4
66875: ARRAY
66876: PUSH
66877: FOR_IN
66878: IFFALSE 66938
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66880: LD_VAR 0 3
66884: PPUSH
66885: LD_VAR 0 5
66889: PPUSH
66890: CALL_OW 430
66894: PUSH
66895: LD_VAR 0 4
66899: PPUSH
66900: LD_VAR 0 5
66904: PPUSH
66905: CALL 14485 0 2
66909: AND
66910: IFFALSE 66936
// begin researching := true ;
66912: LD_ADDR_VAR 0 10
66916: PUSH
66917: LD_INT 1
66919: ST_TO_ADDR
// ComResearch ( j , t ) ;
66920: LD_VAR 0 3
66924: PPUSH
66925: LD_VAR 0 5
66929: PPUSH
66930: CALL_OW 124
// break ;
66934: GO 66938
// end ;
66936: GO 66877
66938: POP
66939: POP
// if not researching then
66940: LD_VAR 0 10
66944: NOT
66945: IFFALSE 66957
// idle_lab := j ;
66947: LD_ADDR_VAR 0 11
66951: PUSH
66952: LD_VAR 0 3
66956: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
66957: LD_VAR 0 3
66961: PPUSH
66962: CALL_OW 461
66966: PUSH
66967: LD_INT 10
66969: EQUAL
66970: IFFALSE 67558
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
66972: LD_EXP 94
66976: PUSH
66977: LD_VAR 0 2
66981: ARRAY
66982: NOT
66983: PUSH
66984: LD_EXP 95
66988: PUSH
66989: LD_VAR 0 2
66993: ARRAY
66994: NOT
66995: AND
66996: PUSH
66997: LD_EXP 92
67001: PUSH
67002: LD_VAR 0 4
67006: ARRAY
67007: PUSH
67008: LD_INT 1
67010: GREATER
67011: AND
67012: IFFALSE 67143
// begin ComCancel ( j ) ;
67014: LD_VAR 0 3
67018: PPUSH
67019: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67023: LD_ADDR_EXP 92
67027: PUSH
67028: LD_EXP 92
67032: PPUSH
67033: LD_VAR 0 4
67037: PPUSH
67038: LD_EXP 92
67042: PUSH
67043: LD_VAR 0 4
67047: ARRAY
67048: PPUSH
67049: LD_EXP 92
67053: PUSH
67054: LD_VAR 0 4
67058: ARRAY
67059: PUSH
67060: LD_INT 1
67062: MINUS
67063: PPUSH
67064: LD_EXP 92
67068: PUSH
67069: LD_VAR 0 4
67073: ARRAY
67074: PPUSH
67075: LD_INT 0
67077: PPUSH
67078: CALL 17997 0 4
67082: PPUSH
67083: CALL_OW 1
67087: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67088: LD_ADDR_EXP 92
67092: PUSH
67093: LD_EXP 92
67097: PPUSH
67098: LD_VAR 0 4
67102: PPUSH
67103: LD_EXP 92
67107: PUSH
67108: LD_VAR 0 4
67112: ARRAY
67113: PPUSH
67114: LD_EXP 92
67118: PUSH
67119: LD_VAR 0 4
67123: ARRAY
67124: PPUSH
67125: LD_INT 1
67127: PPUSH
67128: LD_INT 0
67130: PPUSH
67131: CALL 17997 0 4
67135: PPUSH
67136: CALL_OW 1
67140: ST_TO_ADDR
// continue ;
67141: GO 66715
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67143: LD_EXP 94
67147: PUSH
67148: LD_VAR 0 2
67152: ARRAY
67153: PUSH
67154: LD_EXP 95
67158: PUSH
67159: LD_VAR 0 2
67163: ARRAY
67164: NOT
67165: AND
67166: IFFALSE 67293
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67168: LD_ADDR_EXP 95
67172: PUSH
67173: LD_EXP 95
67177: PPUSH
67178: LD_VAR 0 2
67182: PUSH
67183: LD_EXP 95
67187: PUSH
67188: LD_VAR 0 2
67192: ARRAY
67193: PUSH
67194: LD_INT 1
67196: PLUS
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PPUSH
67202: LD_EXP 94
67206: PUSH
67207: LD_VAR 0 2
67211: ARRAY
67212: PUSH
67213: LD_INT 1
67215: ARRAY
67216: PPUSH
67217: CALL 18579 0 3
67221: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67222: LD_EXP 94
67226: PUSH
67227: LD_VAR 0 2
67231: ARRAY
67232: PUSH
67233: LD_INT 1
67235: ARRAY
67236: PPUSH
67237: LD_INT 112
67239: PPUSH
67240: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67244: LD_ADDR_VAR 0 9
67248: PUSH
67249: LD_EXP 94
67253: PUSH
67254: LD_VAR 0 2
67258: ARRAY
67259: PPUSH
67260: LD_INT 1
67262: PPUSH
67263: CALL_OW 3
67267: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67268: LD_ADDR_EXP 94
67272: PUSH
67273: LD_EXP 94
67277: PPUSH
67278: LD_VAR 0 2
67282: PPUSH
67283: LD_VAR 0 9
67287: PPUSH
67288: CALL_OW 1
67292: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67293: LD_EXP 94
67297: PUSH
67298: LD_VAR 0 2
67302: ARRAY
67303: PUSH
67304: LD_EXP 95
67308: PUSH
67309: LD_VAR 0 2
67313: ARRAY
67314: AND
67315: PUSH
67316: LD_EXP 95
67320: PUSH
67321: LD_VAR 0 2
67325: ARRAY
67326: PUSH
67327: LD_INT 1
67329: ARRAY
67330: PPUSH
67331: CALL_OW 310
67335: NOT
67336: AND
67337: PUSH
67338: LD_VAR 0 3
67342: PPUSH
67343: CALL_OW 313
67347: PUSH
67348: LD_INT 6
67350: EQUAL
67351: AND
67352: IFFALSE 67408
// begin tmp2 := UnitsInside ( j ) ;
67354: LD_ADDR_VAR 0 9
67358: PUSH
67359: LD_VAR 0 3
67363: PPUSH
67364: CALL_OW 313
67368: ST_TO_ADDR
// if tmp2 = 6 then
67369: LD_VAR 0 9
67373: PUSH
67374: LD_INT 6
67376: EQUAL
67377: IFFALSE 67408
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67379: LD_VAR 0 9
67383: PUSH
67384: LD_INT 1
67386: ARRAY
67387: PPUSH
67388: LD_INT 112
67390: PPUSH
67391: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67395: LD_VAR 0 9
67399: PUSH
67400: LD_INT 1
67402: ARRAY
67403: PPUSH
67404: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67408: LD_EXP 95
67412: PUSH
67413: LD_VAR 0 2
67417: ARRAY
67418: PUSH
67419: LD_EXP 95
67423: PUSH
67424: LD_VAR 0 2
67428: ARRAY
67429: PUSH
67430: LD_INT 1
67432: ARRAY
67433: PPUSH
67434: CALL_OW 314
67438: NOT
67439: AND
67440: PUSH
67441: LD_EXP 95
67445: PUSH
67446: LD_VAR 0 2
67450: ARRAY
67451: PUSH
67452: LD_INT 1
67454: ARRAY
67455: PPUSH
67456: CALL_OW 310
67460: NOT
67461: AND
67462: IFFALSE 67488
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67464: LD_EXP 95
67468: PUSH
67469: LD_VAR 0 2
67473: ARRAY
67474: PUSH
67475: LD_INT 1
67477: ARRAY
67478: PPUSH
67479: LD_VAR 0 3
67483: PPUSH
67484: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67488: LD_EXP 95
67492: PUSH
67493: LD_VAR 0 2
67497: ARRAY
67498: PUSH
67499: LD_INT 1
67501: ARRAY
67502: PPUSH
67503: CALL_OW 310
67507: PUSH
67508: LD_EXP 95
67512: PUSH
67513: LD_VAR 0 2
67517: ARRAY
67518: PUSH
67519: LD_INT 1
67521: ARRAY
67522: PPUSH
67523: CALL_OW 310
67527: PPUSH
67528: CALL_OW 461
67532: PUSH
67533: LD_INT 3
67535: NONEQUAL
67536: AND
67537: IFFALSE 67558
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67539: LD_EXP 95
67543: PUSH
67544: LD_VAR 0 2
67548: ARRAY
67549: PUSH
67550: LD_INT 1
67552: ARRAY
67553: PPUSH
67554: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67558: LD_VAR 0 3
67562: PPUSH
67563: CALL_OW 461
67567: PUSH
67568: LD_INT 6
67570: EQUAL
67571: PUSH
67572: LD_VAR 0 6
67576: PUSH
67577: LD_INT 1
67579: GREATER
67580: AND
67581: IFFALSE 67733
// begin sci := [ ] ;
67583: LD_ADDR_VAR 0 8
67587: PUSH
67588: EMPTY
67589: ST_TO_ADDR
// for x in ( tmp diff j ) do
67590: LD_ADDR_VAR 0 7
67594: PUSH
67595: LD_VAR 0 6
67599: PUSH
67600: LD_VAR 0 3
67604: DIFF
67605: PUSH
67606: FOR_IN
67607: IFFALSE 67659
// begin if sci = 6 then
67609: LD_VAR 0 8
67613: PUSH
67614: LD_INT 6
67616: EQUAL
67617: IFFALSE 67621
// break ;
67619: GO 67659
// if BuildingStatus ( x ) = bs_idle then
67621: LD_VAR 0 7
67625: PPUSH
67626: CALL_OW 461
67630: PUSH
67631: LD_INT 2
67633: EQUAL
67634: IFFALSE 67657
// sci := sci ^ UnitsInside ( x ) ;
67636: LD_ADDR_VAR 0 8
67640: PUSH
67641: LD_VAR 0 8
67645: PUSH
67646: LD_VAR 0 7
67650: PPUSH
67651: CALL_OW 313
67655: ADD
67656: ST_TO_ADDR
// end ;
67657: GO 67606
67659: POP
67660: POP
// if not sci then
67661: LD_VAR 0 8
67665: NOT
67666: IFFALSE 67670
// continue ;
67668: GO 66715
// for x in sci do
67670: LD_ADDR_VAR 0 7
67674: PUSH
67675: LD_VAR 0 8
67679: PUSH
67680: FOR_IN
67681: IFFALSE 67731
// if IsInUnit ( x ) and not HasTask ( x ) then
67683: LD_VAR 0 7
67687: PPUSH
67688: CALL_OW 310
67692: PUSH
67693: LD_VAR 0 7
67697: PPUSH
67698: CALL_OW 314
67702: NOT
67703: AND
67704: IFFALSE 67729
// begin ComExitBuilding ( x ) ;
67706: LD_VAR 0 7
67710: PPUSH
67711: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67715: LD_VAR 0 7
67719: PPUSH
67720: LD_VAR 0 3
67724: PPUSH
67725: CALL_OW 180
// end ;
67729: GO 67680
67731: POP
67732: POP
// end ; end ;
67733: GO 66715
67735: POP
67736: POP
// end ;
67737: GO 66669
67739: POP
67740: POP
// end ;
67741: LD_VAR 0 1
67745: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67746: LD_INT 0
67748: PPUSH
67749: PPUSH
// if not mc_bases then
67750: LD_EXP 65
67754: NOT
67755: IFFALSE 67759
// exit ;
67757: GO 67840
// for i = 1 to mc_bases do
67759: LD_ADDR_VAR 0 2
67763: PUSH
67764: DOUBLE
67765: LD_INT 1
67767: DEC
67768: ST_TO_ADDR
67769: LD_EXP 65
67773: PUSH
67774: FOR_TO
67775: IFFALSE 67838
// if mc_mines [ i ] and mc_miners [ i ] then
67777: LD_EXP 78
67781: PUSH
67782: LD_VAR 0 2
67786: ARRAY
67787: PUSH
67788: LD_EXP 79
67792: PUSH
67793: LD_VAR 0 2
67797: ARRAY
67798: AND
67799: IFFALSE 67836
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67801: LD_EXP 79
67805: PUSH
67806: LD_VAR 0 2
67810: ARRAY
67811: PUSH
67812: LD_INT 1
67814: ARRAY
67815: PPUSH
67816: CALL_OW 255
67820: PPUSH
67821: LD_EXP 78
67825: PUSH
67826: LD_VAR 0 2
67830: ARRAY
67831: PPUSH
67832: CALL 15568 0 2
67836: GO 67774
67838: POP
67839: POP
// end ;
67840: LD_VAR 0 1
67844: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67845: LD_INT 0
67847: PPUSH
67848: PPUSH
67849: PPUSH
67850: PPUSH
67851: PPUSH
67852: PPUSH
67853: PPUSH
67854: PPUSH
// if not mc_bases or not mc_parking then
67855: LD_EXP 65
67859: NOT
67860: PUSH
67861: LD_EXP 89
67865: NOT
67866: OR
67867: IFFALSE 67871
// exit ;
67869: GO 68570
// for i = 1 to mc_bases do
67871: LD_ADDR_VAR 0 2
67875: PUSH
67876: DOUBLE
67877: LD_INT 1
67879: DEC
67880: ST_TO_ADDR
67881: LD_EXP 65
67885: PUSH
67886: FOR_TO
67887: IFFALSE 68568
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67889: LD_EXP 65
67893: PUSH
67894: LD_VAR 0 2
67898: ARRAY
67899: NOT
67900: PUSH
67901: LD_EXP 89
67905: PUSH
67906: LD_VAR 0 2
67910: ARRAY
67911: NOT
67912: OR
67913: IFFALSE 67917
// continue ;
67915: GO 67886
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67917: LD_ADDR_VAR 0 5
67921: PUSH
67922: LD_EXP 65
67926: PUSH
67927: LD_VAR 0 2
67931: ARRAY
67932: PUSH
67933: LD_INT 1
67935: ARRAY
67936: PPUSH
67937: CALL_OW 255
67941: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67942: LD_ADDR_VAR 0 6
67946: PUSH
67947: LD_EXP 65
67951: PUSH
67952: LD_VAR 0 2
67956: ARRAY
67957: PPUSH
67958: LD_INT 30
67960: PUSH
67961: LD_INT 3
67963: PUSH
67964: EMPTY
67965: LIST
67966: LIST
67967: PPUSH
67968: CALL_OW 72
67972: ST_TO_ADDR
// if not fac then
67973: LD_VAR 0 6
67977: NOT
67978: IFFALSE 68029
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67980: LD_ADDR_VAR 0 6
67984: PUSH
67985: LD_EXP 65
67989: PUSH
67990: LD_VAR 0 2
67994: ARRAY
67995: PPUSH
67996: LD_INT 2
67998: PUSH
67999: LD_INT 30
68001: PUSH
68002: LD_INT 0
68004: PUSH
68005: EMPTY
68006: LIST
68007: LIST
68008: PUSH
68009: LD_INT 30
68011: PUSH
68012: LD_INT 1
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: LIST
68023: PPUSH
68024: CALL_OW 72
68028: ST_TO_ADDR
// if not fac then
68029: LD_VAR 0 6
68033: NOT
68034: IFFALSE 68038
// continue ;
68036: GO 67886
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68038: LD_ADDR_VAR 0 7
68042: PUSH
68043: LD_EXP 89
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PPUSH
68054: LD_INT 22
68056: PUSH
68057: LD_VAR 0 5
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PUSH
68066: LD_INT 21
68068: PUSH
68069: LD_INT 2
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: PUSH
68076: LD_INT 3
68078: PUSH
68079: LD_INT 24
68081: PUSH
68082: LD_INT 1000
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: LIST
68097: PPUSH
68098: CALL_OW 70
68102: ST_TO_ADDR
// for j in fac do
68103: LD_ADDR_VAR 0 3
68107: PUSH
68108: LD_VAR 0 6
68112: PUSH
68113: FOR_IN
68114: IFFALSE 68195
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68116: LD_ADDR_VAR 0 7
68120: PUSH
68121: LD_VAR 0 7
68125: PUSH
68126: LD_INT 22
68128: PUSH
68129: LD_VAR 0 5
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 91
68140: PUSH
68141: LD_VAR 0 3
68145: PUSH
68146: LD_INT 15
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 21
68156: PUSH
68157: LD_INT 2
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PUSH
68164: LD_INT 3
68166: PUSH
68167: LD_INT 24
68169: PUSH
68170: LD_INT 1000
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: PPUSH
68187: CALL_OW 69
68191: UNION
68192: ST_TO_ADDR
68193: GO 68113
68195: POP
68196: POP
// if not vehs then
68197: LD_VAR 0 7
68201: NOT
68202: IFFALSE 68228
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68204: LD_ADDR_EXP 77
68208: PUSH
68209: LD_EXP 77
68213: PPUSH
68214: LD_VAR 0 2
68218: PPUSH
68219: EMPTY
68220: PPUSH
68221: CALL_OW 1
68225: ST_TO_ADDR
// continue ;
68226: GO 67886
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68228: LD_ADDR_VAR 0 8
68232: PUSH
68233: LD_EXP 65
68237: PUSH
68238: LD_VAR 0 2
68242: ARRAY
68243: PPUSH
68244: LD_INT 30
68246: PUSH
68247: LD_INT 3
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PPUSH
68254: CALL_OW 72
68258: ST_TO_ADDR
// if tmp then
68259: LD_VAR 0 8
68263: IFFALSE 68366
// begin for j in tmp do
68265: LD_ADDR_VAR 0 3
68269: PUSH
68270: LD_VAR 0 8
68274: PUSH
68275: FOR_IN
68276: IFFALSE 68364
// for k in UnitsInside ( j ) do
68278: LD_ADDR_VAR 0 4
68282: PUSH
68283: LD_VAR 0 3
68287: PPUSH
68288: CALL_OW 313
68292: PUSH
68293: FOR_IN
68294: IFFALSE 68360
// if k then
68296: LD_VAR 0 4
68300: IFFALSE 68358
// if not k in mc_repair_vehicle [ i ] then
68302: LD_VAR 0 4
68306: PUSH
68307: LD_EXP 77
68311: PUSH
68312: LD_VAR 0 2
68316: ARRAY
68317: IN
68318: NOT
68319: IFFALSE 68358
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68321: LD_ADDR_EXP 77
68325: PUSH
68326: LD_EXP 77
68330: PPUSH
68331: LD_VAR 0 2
68335: PPUSH
68336: LD_EXP 77
68340: PUSH
68341: LD_VAR 0 2
68345: ARRAY
68346: PUSH
68347: LD_VAR 0 4
68351: UNION
68352: PPUSH
68353: CALL_OW 1
68357: ST_TO_ADDR
68358: GO 68293
68360: POP
68361: POP
68362: GO 68275
68364: POP
68365: POP
// end ; if not mc_repair_vehicle [ i ] then
68366: LD_EXP 77
68370: PUSH
68371: LD_VAR 0 2
68375: ARRAY
68376: NOT
68377: IFFALSE 68381
// continue ;
68379: GO 67886
// for j in mc_repair_vehicle [ i ] do
68381: LD_ADDR_VAR 0 3
68385: PUSH
68386: LD_EXP 77
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: PUSH
68397: FOR_IN
68398: IFFALSE 68564
// begin if GetClass ( j ) <> 3 then
68400: LD_VAR 0 3
68404: PPUSH
68405: CALL_OW 257
68409: PUSH
68410: LD_INT 3
68412: NONEQUAL
68413: IFFALSE 68454
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68415: LD_ADDR_EXP 77
68419: PUSH
68420: LD_EXP 77
68424: PPUSH
68425: LD_VAR 0 2
68429: PPUSH
68430: LD_EXP 77
68434: PUSH
68435: LD_VAR 0 2
68439: ARRAY
68440: PUSH
68441: LD_VAR 0 3
68445: DIFF
68446: PPUSH
68447: CALL_OW 1
68451: ST_TO_ADDR
// continue ;
68452: GO 68397
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68454: LD_VAR 0 3
68458: PPUSH
68459: CALL_OW 311
68463: NOT
68464: PUSH
68465: LD_VAR 0 3
68469: PUSH
68470: LD_EXP 68
68474: PUSH
68475: LD_VAR 0 2
68479: ARRAY
68480: PUSH
68481: LD_INT 1
68483: ARRAY
68484: IN
68485: NOT
68486: AND
68487: PUSH
68488: LD_VAR 0 3
68492: PUSH
68493: LD_EXP 68
68497: PUSH
68498: LD_VAR 0 2
68502: ARRAY
68503: PUSH
68504: LD_INT 2
68506: ARRAY
68507: IN
68508: NOT
68509: AND
68510: IFFALSE 68562
// begin if IsInUnit ( j ) then
68512: LD_VAR 0 3
68516: PPUSH
68517: CALL_OW 310
68521: IFFALSE 68532
// ComExitBuilding ( j ) ;
68523: LD_VAR 0 3
68527: PPUSH
68528: CALL_OW 122
// if not HasTask ( j ) then
68532: LD_VAR 0 3
68536: PPUSH
68537: CALL_OW 314
68541: NOT
68542: IFFALSE 68562
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68544: LD_VAR 0 3
68548: PPUSH
68549: LD_VAR 0 7
68553: PUSH
68554: LD_INT 1
68556: ARRAY
68557: PPUSH
68558: CALL_OW 189
// end ; end ;
68562: GO 68397
68564: POP
68565: POP
// end ;
68566: GO 67886
68568: POP
68569: POP
// end ;
68570: LD_VAR 0 1
68574: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68575: LD_INT 0
68577: PPUSH
68578: PPUSH
68579: PPUSH
68580: PPUSH
68581: PPUSH
68582: PPUSH
68583: PPUSH
68584: PPUSH
68585: PPUSH
68586: PPUSH
68587: PPUSH
// if not mc_bases then
68588: LD_EXP 65
68592: NOT
68593: IFFALSE 68597
// exit ;
68595: GO 69399
// for i = 1 to mc_bases do
68597: LD_ADDR_VAR 0 2
68601: PUSH
68602: DOUBLE
68603: LD_INT 1
68605: DEC
68606: ST_TO_ADDR
68607: LD_EXP 65
68611: PUSH
68612: FOR_TO
68613: IFFALSE 69397
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68615: LD_EXP 93
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: NOT
68626: PUSH
68627: LD_EXP 68
68631: PUSH
68632: LD_VAR 0 2
68636: ARRAY
68637: PUSH
68638: LD_INT 1
68640: ARRAY
68641: OR
68642: PUSH
68643: LD_EXP 68
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PUSH
68654: LD_INT 2
68656: ARRAY
68657: OR
68658: PUSH
68659: LD_EXP 91
68663: PUSH
68664: LD_VAR 0 2
68668: ARRAY
68669: PPUSH
68670: LD_INT 1
68672: PPUSH
68673: CALL_OW 325
68677: NOT
68678: OR
68679: PUSH
68680: LD_EXP 88
68684: PUSH
68685: LD_VAR 0 2
68689: ARRAY
68690: OR
68691: IFFALSE 68695
// continue ;
68693: GO 68612
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68695: LD_ADDR_VAR 0 8
68699: PUSH
68700: LD_EXP 65
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: PPUSH
68711: LD_INT 25
68713: PUSH
68714: LD_INT 4
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 50
68723: PUSH
68724: EMPTY
68725: LIST
68726: PUSH
68727: LD_INT 3
68729: PUSH
68730: LD_INT 60
68732: PUSH
68733: EMPTY
68734: LIST
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: LIST
68744: PPUSH
68745: CALL_OW 72
68749: PUSH
68750: LD_EXP 69
68754: PUSH
68755: LD_VAR 0 2
68759: ARRAY
68760: DIFF
68761: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68762: LD_ADDR_VAR 0 9
68766: PUSH
68767: LD_EXP 65
68771: PUSH
68772: LD_VAR 0 2
68776: ARRAY
68777: PPUSH
68778: LD_INT 2
68780: PUSH
68781: LD_INT 30
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 30
68793: PUSH
68794: LD_INT 1
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: LIST
68805: PPUSH
68806: CALL_OW 72
68810: ST_TO_ADDR
// if not tmp or not dep then
68811: LD_VAR 0 8
68815: NOT
68816: PUSH
68817: LD_VAR 0 9
68821: NOT
68822: OR
68823: IFFALSE 68827
// continue ;
68825: GO 68612
// side := GetSide ( tmp [ 1 ] ) ;
68827: LD_ADDR_VAR 0 11
68831: PUSH
68832: LD_VAR 0 8
68836: PUSH
68837: LD_INT 1
68839: ARRAY
68840: PPUSH
68841: CALL_OW 255
68845: ST_TO_ADDR
// dep := dep [ 1 ] ;
68846: LD_ADDR_VAR 0 9
68850: PUSH
68851: LD_VAR 0 9
68855: PUSH
68856: LD_INT 1
68858: ARRAY
68859: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68860: LD_ADDR_VAR 0 7
68864: PUSH
68865: LD_EXP 93
68869: PUSH
68870: LD_VAR 0 2
68874: ARRAY
68875: PPUSH
68876: LD_INT 22
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 25
68888: PUSH
68889: LD_INT 12
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PPUSH
68900: CALL_OW 70
68904: PUSH
68905: LD_INT 22
68907: PUSH
68908: LD_INT 0
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: PUSH
68915: LD_INT 25
68917: PUSH
68918: LD_INT 12
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 91
68927: PUSH
68928: LD_VAR 0 9
68932: PUSH
68933: LD_INT 20
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: LIST
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: LIST
68945: PPUSH
68946: CALL_OW 69
68950: UNION
68951: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
68952: LD_ADDR_VAR 0 10
68956: PUSH
68957: LD_EXP 93
68961: PUSH
68962: LD_VAR 0 2
68966: ARRAY
68967: PPUSH
68968: LD_INT 81
68970: PUSH
68971: LD_VAR 0 11
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PPUSH
68980: CALL_OW 70
68984: ST_TO_ADDR
// if not apes or danger_at_area then
68985: LD_VAR 0 7
68989: NOT
68990: PUSH
68991: LD_VAR 0 10
68995: OR
68996: IFFALSE 69046
// begin if mc_taming [ i ] then
68998: LD_EXP 96
69002: PUSH
69003: LD_VAR 0 2
69007: ARRAY
69008: IFFALSE 69044
// begin MC_Reset ( i , 121 ) ;
69010: LD_VAR 0 2
69014: PPUSH
69015: LD_INT 121
69017: PPUSH
69018: CALL 54497 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69022: LD_ADDR_EXP 96
69026: PUSH
69027: LD_EXP 96
69031: PPUSH
69032: LD_VAR 0 2
69036: PPUSH
69037: EMPTY
69038: PPUSH
69039: CALL_OW 1
69043: ST_TO_ADDR
// end ; continue ;
69044: GO 68612
// end ; for j in tmp do
69046: LD_ADDR_VAR 0 3
69050: PUSH
69051: LD_VAR 0 8
69055: PUSH
69056: FOR_IN
69057: IFFALSE 69393
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69059: LD_VAR 0 3
69063: PUSH
69064: LD_EXP 96
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: IN
69075: NOT
69076: PUSH
69077: LD_EXP 96
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: PUSH
69088: LD_INT 3
69090: LESS
69091: AND
69092: IFFALSE 69150
// begin SetTag ( j , 121 ) ;
69094: LD_VAR 0 3
69098: PPUSH
69099: LD_INT 121
69101: PPUSH
69102: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69106: LD_ADDR_EXP 96
69110: PUSH
69111: LD_EXP 96
69115: PPUSH
69116: LD_VAR 0 2
69120: PUSH
69121: LD_EXP 96
69125: PUSH
69126: LD_VAR 0 2
69130: ARRAY
69131: PUSH
69132: LD_INT 1
69134: PLUS
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PPUSH
69140: LD_VAR 0 3
69144: PPUSH
69145: CALL 18579 0 3
69149: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69150: LD_VAR 0 3
69154: PUSH
69155: LD_EXP 96
69159: PUSH
69160: LD_VAR 0 2
69164: ARRAY
69165: IN
69166: IFFALSE 69391
// begin if GetClass ( j ) <> 4 then
69168: LD_VAR 0 3
69172: PPUSH
69173: CALL_OW 257
69177: PUSH
69178: LD_INT 4
69180: NONEQUAL
69181: IFFALSE 69234
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69183: LD_ADDR_EXP 96
69187: PUSH
69188: LD_EXP 96
69192: PPUSH
69193: LD_VAR 0 2
69197: PPUSH
69198: LD_EXP 96
69202: PUSH
69203: LD_VAR 0 2
69207: ARRAY
69208: PUSH
69209: LD_VAR 0 3
69213: DIFF
69214: PPUSH
69215: CALL_OW 1
69219: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69220: LD_VAR 0 3
69224: PPUSH
69225: LD_INT 0
69227: PPUSH
69228: CALL_OW 109
// continue ;
69232: GO 69056
// end ; if IsInUnit ( j ) then
69234: LD_VAR 0 3
69238: PPUSH
69239: CALL_OW 310
69243: IFFALSE 69254
// ComExitBuilding ( j ) ;
69245: LD_VAR 0 3
69249: PPUSH
69250: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69254: LD_ADDR_VAR 0 6
69258: PUSH
69259: LD_VAR 0 7
69263: PPUSH
69264: LD_VAR 0 3
69268: PPUSH
69269: CALL_OW 74
69273: ST_TO_ADDR
// if not ape then
69274: LD_VAR 0 6
69278: NOT
69279: IFFALSE 69283
// break ;
69281: GO 69393
// x := GetX ( ape ) ;
69283: LD_ADDR_VAR 0 4
69287: PUSH
69288: LD_VAR 0 6
69292: PPUSH
69293: CALL_OW 250
69297: ST_TO_ADDR
// y := GetY ( ape ) ;
69298: LD_ADDR_VAR 0 5
69302: PUSH
69303: LD_VAR 0 6
69307: PPUSH
69308: CALL_OW 251
69312: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69313: LD_VAR 0 4
69317: PPUSH
69318: LD_VAR 0 5
69322: PPUSH
69323: CALL_OW 488
69327: NOT
69328: PUSH
69329: LD_VAR 0 11
69333: PPUSH
69334: LD_VAR 0 4
69338: PPUSH
69339: LD_VAR 0 5
69343: PPUSH
69344: LD_INT 20
69346: PPUSH
69347: CALL 19475 0 4
69351: PUSH
69352: LD_INT 4
69354: ARRAY
69355: OR
69356: IFFALSE 69360
// break ;
69358: GO 69393
// if not HasTask ( j ) then
69360: LD_VAR 0 3
69364: PPUSH
69365: CALL_OW 314
69369: NOT
69370: IFFALSE 69391
// ComTameXY ( j , x , y ) ;
69372: LD_VAR 0 3
69376: PPUSH
69377: LD_VAR 0 4
69381: PPUSH
69382: LD_VAR 0 5
69386: PPUSH
69387: CALL_OW 131
// end ; end ;
69391: GO 69056
69393: POP
69394: POP
// end ;
69395: GO 68612
69397: POP
69398: POP
// end ;
69399: LD_VAR 0 1
69403: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69404: LD_INT 0
69406: PPUSH
69407: PPUSH
69408: PPUSH
69409: PPUSH
69410: PPUSH
69411: PPUSH
69412: PPUSH
69413: PPUSH
// if not mc_bases then
69414: LD_EXP 65
69418: NOT
69419: IFFALSE 69423
// exit ;
69421: GO 70049
// for i = 1 to mc_bases do
69423: LD_ADDR_VAR 0 2
69427: PUSH
69428: DOUBLE
69429: LD_INT 1
69431: DEC
69432: ST_TO_ADDR
69433: LD_EXP 65
69437: PUSH
69438: FOR_TO
69439: IFFALSE 70047
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69441: LD_EXP 94
69445: PUSH
69446: LD_VAR 0 2
69450: ARRAY
69451: NOT
69452: PUSH
69453: LD_EXP 94
69457: PUSH
69458: LD_VAR 0 2
69462: ARRAY
69463: PPUSH
69464: LD_INT 25
69466: PUSH
69467: LD_INT 12
69469: PUSH
69470: EMPTY
69471: LIST
69472: LIST
69473: PPUSH
69474: CALL_OW 72
69478: NOT
69479: OR
69480: IFFALSE 69484
// continue ;
69482: GO 69438
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69484: LD_ADDR_VAR 0 5
69488: PUSH
69489: LD_EXP 94
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: PUSH
69500: LD_INT 1
69502: ARRAY
69503: PPUSH
69504: CALL_OW 255
69508: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69509: LD_VAR 0 5
69513: PPUSH
69514: LD_INT 2
69516: PPUSH
69517: CALL_OW 325
69521: IFFALSE 69774
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69523: LD_ADDR_VAR 0 4
69527: PUSH
69528: LD_EXP 94
69532: PUSH
69533: LD_VAR 0 2
69537: ARRAY
69538: PPUSH
69539: LD_INT 25
69541: PUSH
69542: LD_INT 16
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PPUSH
69549: CALL_OW 72
69553: ST_TO_ADDR
// if tmp < 6 then
69554: LD_VAR 0 4
69558: PUSH
69559: LD_INT 6
69561: LESS
69562: IFFALSE 69774
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69564: LD_ADDR_VAR 0 6
69568: PUSH
69569: LD_EXP 65
69573: PUSH
69574: LD_VAR 0 2
69578: ARRAY
69579: PPUSH
69580: LD_INT 2
69582: PUSH
69583: LD_INT 30
69585: PUSH
69586: LD_INT 0
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 30
69595: PUSH
69596: LD_INT 1
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: LIST
69607: PPUSH
69608: CALL_OW 72
69612: ST_TO_ADDR
// if depot then
69613: LD_VAR 0 6
69617: IFFALSE 69774
// begin selected := 0 ;
69619: LD_ADDR_VAR 0 7
69623: PUSH
69624: LD_INT 0
69626: ST_TO_ADDR
// for j in depot do
69627: LD_ADDR_VAR 0 3
69631: PUSH
69632: LD_VAR 0 6
69636: PUSH
69637: FOR_IN
69638: IFFALSE 69669
// begin if UnitsInside ( j ) < 6 then
69640: LD_VAR 0 3
69644: PPUSH
69645: CALL_OW 313
69649: PUSH
69650: LD_INT 6
69652: LESS
69653: IFFALSE 69667
// begin selected := j ;
69655: LD_ADDR_VAR 0 7
69659: PUSH
69660: LD_VAR 0 3
69664: ST_TO_ADDR
// break ;
69665: GO 69669
// end ; end ;
69667: GO 69637
69669: POP
69670: POP
// if selected then
69671: LD_VAR 0 7
69675: IFFALSE 69774
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69677: LD_ADDR_VAR 0 3
69681: PUSH
69682: LD_EXP 94
69686: PUSH
69687: LD_VAR 0 2
69691: ARRAY
69692: PPUSH
69693: LD_INT 25
69695: PUSH
69696: LD_INT 12
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PPUSH
69703: CALL_OW 72
69707: PUSH
69708: FOR_IN
69709: IFFALSE 69772
// if not HasTask ( j ) then
69711: LD_VAR 0 3
69715: PPUSH
69716: CALL_OW 314
69720: NOT
69721: IFFALSE 69770
// begin if not IsInUnit ( j ) then
69723: LD_VAR 0 3
69727: PPUSH
69728: CALL_OW 310
69732: NOT
69733: IFFALSE 69749
// ComEnterUnit ( j , selected ) ;
69735: LD_VAR 0 3
69739: PPUSH
69740: LD_VAR 0 7
69744: PPUSH
69745: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69749: LD_VAR 0 3
69753: PPUSH
69754: LD_INT 16
69756: PPUSH
69757: CALL_OW 183
// AddComExitBuilding ( j ) ;
69761: LD_VAR 0 3
69765: PPUSH
69766: CALL_OW 182
// end ;
69770: GO 69708
69772: POP
69773: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69774: LD_VAR 0 5
69778: PPUSH
69779: LD_INT 11
69781: PPUSH
69782: CALL_OW 325
69786: IFFALSE 70045
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69788: LD_ADDR_VAR 0 4
69792: PUSH
69793: LD_EXP 94
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: PPUSH
69804: LD_INT 25
69806: PUSH
69807: LD_INT 16
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PPUSH
69814: CALL_OW 72
69818: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69819: LD_VAR 0 4
69823: PUSH
69824: LD_INT 6
69826: GREATEREQUAL
69827: PUSH
69828: LD_VAR 0 5
69832: PPUSH
69833: LD_INT 2
69835: PPUSH
69836: CALL_OW 325
69840: NOT
69841: OR
69842: IFFALSE 70045
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69844: LD_ADDR_VAR 0 8
69848: PUSH
69849: LD_EXP 65
69853: PUSH
69854: LD_VAR 0 2
69858: ARRAY
69859: PPUSH
69860: LD_INT 2
69862: PUSH
69863: LD_INT 30
69865: PUSH
69866: LD_INT 4
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 30
69875: PUSH
69876: LD_INT 5
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: LIST
69887: PPUSH
69888: CALL_OW 72
69892: ST_TO_ADDR
// if barracks then
69893: LD_VAR 0 8
69897: IFFALSE 70045
// begin selected := 0 ;
69899: LD_ADDR_VAR 0 7
69903: PUSH
69904: LD_INT 0
69906: ST_TO_ADDR
// for j in barracks do
69907: LD_ADDR_VAR 0 3
69911: PUSH
69912: LD_VAR 0 8
69916: PUSH
69917: FOR_IN
69918: IFFALSE 69949
// begin if UnitsInside ( j ) < 6 then
69920: LD_VAR 0 3
69924: PPUSH
69925: CALL_OW 313
69929: PUSH
69930: LD_INT 6
69932: LESS
69933: IFFALSE 69947
// begin selected := j ;
69935: LD_ADDR_VAR 0 7
69939: PUSH
69940: LD_VAR 0 3
69944: ST_TO_ADDR
// break ;
69945: GO 69949
// end ; end ;
69947: GO 69917
69949: POP
69950: POP
// if selected then
69951: LD_VAR 0 7
69955: IFFALSE 70045
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69957: LD_ADDR_VAR 0 3
69961: PUSH
69962: LD_EXP 94
69966: PUSH
69967: LD_VAR 0 2
69971: ARRAY
69972: PPUSH
69973: LD_INT 25
69975: PUSH
69976: LD_INT 12
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PPUSH
69983: CALL_OW 72
69987: PUSH
69988: FOR_IN
69989: IFFALSE 70043
// if not IsInUnit ( j ) and not HasTask ( j ) then
69991: LD_VAR 0 3
69995: PPUSH
69996: CALL_OW 310
70000: NOT
70001: PUSH
70002: LD_VAR 0 3
70006: PPUSH
70007: CALL_OW 314
70011: NOT
70012: AND
70013: IFFALSE 70041
// begin ComEnterUnit ( j , selected ) ;
70015: LD_VAR 0 3
70019: PPUSH
70020: LD_VAR 0 7
70024: PPUSH
70025: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70029: LD_VAR 0 3
70033: PPUSH
70034: LD_INT 15
70036: PPUSH
70037: CALL_OW 183
// end ;
70041: GO 69988
70043: POP
70044: POP
// end ; end ; end ; end ; end ;
70045: GO 69438
70047: POP
70048: POP
// end ;
70049: LD_VAR 0 1
70053: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70054: LD_INT 0
70056: PPUSH
70057: PPUSH
70058: PPUSH
70059: PPUSH
// if not mc_bases then
70060: LD_EXP 65
70064: NOT
70065: IFFALSE 70069
// exit ;
70067: GO 70247
// for i = 1 to mc_bases do
70069: LD_ADDR_VAR 0 2
70073: PUSH
70074: DOUBLE
70075: LD_INT 1
70077: DEC
70078: ST_TO_ADDR
70079: LD_EXP 65
70083: PUSH
70084: FOR_TO
70085: IFFALSE 70245
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70087: LD_ADDR_VAR 0 4
70091: PUSH
70092: LD_EXP 65
70096: PUSH
70097: LD_VAR 0 2
70101: ARRAY
70102: PPUSH
70103: LD_INT 25
70105: PUSH
70106: LD_INT 9
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PPUSH
70113: CALL_OW 72
70117: ST_TO_ADDR
// if not tmp then
70118: LD_VAR 0 4
70122: NOT
70123: IFFALSE 70127
// continue ;
70125: GO 70084
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70127: LD_EXP 91
70131: PUSH
70132: LD_VAR 0 2
70136: ARRAY
70137: PPUSH
70138: LD_INT 29
70140: PPUSH
70141: CALL_OW 325
70145: NOT
70146: PUSH
70147: LD_EXP 91
70151: PUSH
70152: LD_VAR 0 2
70156: ARRAY
70157: PPUSH
70158: LD_INT 28
70160: PPUSH
70161: CALL_OW 325
70165: NOT
70166: AND
70167: IFFALSE 70171
// continue ;
70169: GO 70084
// for j in tmp do
70171: LD_ADDR_VAR 0 3
70175: PUSH
70176: LD_VAR 0 4
70180: PUSH
70181: FOR_IN
70182: IFFALSE 70241
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70184: LD_VAR 0 3
70188: PUSH
70189: LD_EXP 68
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PUSH
70200: LD_INT 1
70202: ARRAY
70203: IN
70204: NOT
70205: PUSH
70206: LD_VAR 0 3
70210: PUSH
70211: LD_EXP 68
70215: PUSH
70216: LD_VAR 0 2
70220: ARRAY
70221: PUSH
70222: LD_INT 2
70224: ARRAY
70225: IN
70226: NOT
70227: AND
70228: IFFALSE 70239
// ComSpaceTimeShoot ( j ) ;
70230: LD_VAR 0 3
70234: PPUSH
70235: CALL 14576 0 1
70239: GO 70181
70241: POP
70242: POP
// end ;
70243: GO 70084
70245: POP
70246: POP
// end ;
70247: LD_VAR 0 1
70251: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70252: LD_INT 0
70254: PPUSH
70255: PPUSH
70256: PPUSH
70257: PPUSH
70258: PPUSH
70259: PPUSH
70260: PPUSH
70261: PPUSH
70262: PPUSH
// if not mc_bases then
70263: LD_EXP 65
70267: NOT
70268: IFFALSE 70272
// exit ;
70270: GO 70894
// for i = 1 to mc_bases do
70272: LD_ADDR_VAR 0 2
70276: PUSH
70277: DOUBLE
70278: LD_INT 1
70280: DEC
70281: ST_TO_ADDR
70282: LD_EXP 65
70286: PUSH
70287: FOR_TO
70288: IFFALSE 70892
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70290: LD_EXP 100
70294: PUSH
70295: LD_VAR 0 2
70299: ARRAY
70300: NOT
70301: PUSH
70302: LD_INT 38
70304: PPUSH
70305: LD_EXP 91
70309: PUSH
70310: LD_VAR 0 2
70314: ARRAY
70315: PPUSH
70316: CALL_OW 321
70320: PUSH
70321: LD_INT 2
70323: NONEQUAL
70324: OR
70325: IFFALSE 70329
// continue ;
70327: GO 70287
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70329: LD_ADDR_VAR 0 8
70333: PUSH
70334: LD_EXP 65
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PPUSH
70345: LD_INT 30
70347: PUSH
70348: LD_INT 34
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PPUSH
70355: CALL_OW 72
70359: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70360: LD_ADDR_VAR 0 9
70364: PUSH
70365: LD_EXP 65
70369: PUSH
70370: LD_VAR 0 2
70374: ARRAY
70375: PPUSH
70376: LD_INT 25
70378: PUSH
70379: LD_INT 4
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PPUSH
70386: CALL_OW 72
70390: PPUSH
70391: LD_INT 0
70393: PPUSH
70394: CALL 47140 0 2
70398: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70399: LD_VAR 0 9
70403: NOT
70404: PUSH
70405: LD_VAR 0 8
70409: NOT
70410: OR
70411: PUSH
70412: LD_EXP 65
70416: PUSH
70417: LD_VAR 0 2
70421: ARRAY
70422: PPUSH
70423: LD_INT 124
70425: PPUSH
70426: CALL 47140 0 2
70430: OR
70431: IFFALSE 70435
// continue ;
70433: GO 70287
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70435: LD_EXP 101
70439: PUSH
70440: LD_VAR 0 2
70444: ARRAY
70445: PUSH
70446: LD_EXP 100
70450: PUSH
70451: LD_VAR 0 2
70455: ARRAY
70456: LESS
70457: PUSH
70458: LD_EXP 101
70462: PUSH
70463: LD_VAR 0 2
70467: ARRAY
70468: PUSH
70469: LD_VAR 0 8
70473: LESS
70474: AND
70475: IFFALSE 70890
// begin tmp := sci [ 1 ] ;
70477: LD_ADDR_VAR 0 7
70481: PUSH
70482: LD_VAR 0 9
70486: PUSH
70487: LD_INT 1
70489: ARRAY
70490: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70491: LD_VAR 0 7
70495: PPUSH
70496: LD_INT 124
70498: PPUSH
70499: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70503: LD_ADDR_VAR 0 3
70507: PUSH
70508: DOUBLE
70509: LD_EXP 100
70513: PUSH
70514: LD_VAR 0 2
70518: ARRAY
70519: INC
70520: ST_TO_ADDR
70521: LD_EXP 100
70525: PUSH
70526: LD_VAR 0 2
70530: ARRAY
70531: PUSH
70532: FOR_DOWNTO
70533: IFFALSE 70876
// begin if IsInUnit ( tmp ) then
70535: LD_VAR 0 7
70539: PPUSH
70540: CALL_OW 310
70544: IFFALSE 70555
// ComExitBuilding ( tmp ) ;
70546: LD_VAR 0 7
70550: PPUSH
70551: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70555: LD_INT 35
70557: PPUSH
70558: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70562: LD_VAR 0 7
70566: PPUSH
70567: CALL_OW 310
70571: NOT
70572: PUSH
70573: LD_VAR 0 7
70577: PPUSH
70578: CALL_OW 314
70582: NOT
70583: AND
70584: IFFALSE 70555
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70586: LD_ADDR_VAR 0 6
70590: PUSH
70591: LD_VAR 0 7
70595: PPUSH
70596: CALL_OW 250
70600: PUSH
70601: LD_VAR 0 7
70605: PPUSH
70606: CALL_OW 251
70610: PUSH
70611: EMPTY
70612: LIST
70613: LIST
70614: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70615: LD_INT 35
70617: PPUSH
70618: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70622: LD_ADDR_VAR 0 4
70626: PUSH
70627: LD_EXP 100
70631: PUSH
70632: LD_VAR 0 2
70636: ARRAY
70637: PUSH
70638: LD_VAR 0 3
70642: ARRAY
70643: PUSH
70644: LD_INT 1
70646: ARRAY
70647: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70648: LD_ADDR_VAR 0 5
70652: PUSH
70653: LD_EXP 100
70657: PUSH
70658: LD_VAR 0 2
70662: ARRAY
70663: PUSH
70664: LD_VAR 0 3
70668: ARRAY
70669: PUSH
70670: LD_INT 2
70672: ARRAY
70673: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70674: LD_VAR 0 7
70678: PPUSH
70679: LD_INT 10
70681: PPUSH
70682: CALL 21172 0 2
70686: PUSH
70687: LD_INT 4
70689: ARRAY
70690: IFFALSE 70728
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70692: LD_VAR 0 7
70696: PPUSH
70697: LD_VAR 0 6
70701: PUSH
70702: LD_INT 1
70704: ARRAY
70705: PPUSH
70706: LD_VAR 0 6
70710: PUSH
70711: LD_INT 2
70713: ARRAY
70714: PPUSH
70715: CALL_OW 111
// wait ( 0 0$10 ) ;
70719: LD_INT 350
70721: PPUSH
70722: CALL_OW 67
// end else
70726: GO 70754
// begin ComMoveXY ( tmp , x , y ) ;
70728: LD_VAR 0 7
70732: PPUSH
70733: LD_VAR 0 4
70737: PPUSH
70738: LD_VAR 0 5
70742: PPUSH
70743: CALL_OW 111
// wait ( 0 0$3 ) ;
70747: LD_INT 105
70749: PPUSH
70750: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70754: LD_VAR 0 7
70758: PPUSH
70759: LD_VAR 0 4
70763: PPUSH
70764: LD_VAR 0 5
70768: PPUSH
70769: CALL_OW 307
70773: IFFALSE 70615
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70775: LD_VAR 0 7
70779: PPUSH
70780: LD_VAR 0 4
70784: PPUSH
70785: LD_VAR 0 5
70789: PPUSH
70790: LD_VAR 0 8
70794: PUSH
70795: LD_VAR 0 3
70799: ARRAY
70800: PPUSH
70801: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70805: LD_INT 35
70807: PPUSH
70808: CALL_OW 67
// until not HasTask ( tmp ) ;
70812: LD_VAR 0 7
70816: PPUSH
70817: CALL_OW 314
70821: NOT
70822: IFFALSE 70805
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70824: LD_ADDR_EXP 101
70828: PUSH
70829: LD_EXP 101
70833: PPUSH
70834: LD_VAR 0 2
70838: PUSH
70839: LD_EXP 101
70843: PUSH
70844: LD_VAR 0 2
70848: ARRAY
70849: PUSH
70850: LD_INT 1
70852: PLUS
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PPUSH
70858: LD_VAR 0 8
70862: PUSH
70863: LD_VAR 0 3
70867: ARRAY
70868: PPUSH
70869: CALL 18579 0 3
70873: ST_TO_ADDR
// end ;
70874: GO 70532
70876: POP
70877: POP
// MC_Reset ( i , 124 ) ;
70878: LD_VAR 0 2
70882: PPUSH
70883: LD_INT 124
70885: PPUSH
70886: CALL 54497 0 2
// end ; end ;
70890: GO 70287
70892: POP
70893: POP
// end ;
70894: LD_VAR 0 1
70898: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70899: LD_INT 0
70901: PPUSH
70902: PPUSH
70903: PPUSH
// if not mc_bases then
70904: LD_EXP 65
70908: NOT
70909: IFFALSE 70913
// exit ;
70911: GO 71519
// for i = 1 to mc_bases do
70913: LD_ADDR_VAR 0 2
70917: PUSH
70918: DOUBLE
70919: LD_INT 1
70921: DEC
70922: ST_TO_ADDR
70923: LD_EXP 65
70927: PUSH
70928: FOR_TO
70929: IFFALSE 71517
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70931: LD_ADDR_VAR 0 3
70935: PUSH
70936: LD_EXP 65
70940: PUSH
70941: LD_VAR 0 2
70945: ARRAY
70946: PPUSH
70947: LD_INT 25
70949: PUSH
70950: LD_INT 4
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PPUSH
70957: CALL_OW 72
70961: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70962: LD_VAR 0 3
70966: NOT
70967: PUSH
70968: LD_EXP 102
70972: PUSH
70973: LD_VAR 0 2
70977: ARRAY
70978: NOT
70979: OR
70980: PUSH
70981: LD_EXP 65
70985: PUSH
70986: LD_VAR 0 2
70990: ARRAY
70991: PPUSH
70992: LD_INT 2
70994: PUSH
70995: LD_INT 30
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: LD_INT 30
71007: PUSH
71008: LD_INT 1
71010: PUSH
71011: EMPTY
71012: LIST
71013: LIST
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: LIST
71019: PPUSH
71020: CALL_OW 72
71024: NOT
71025: OR
71026: IFFALSE 71076
// begin if mc_deposits_finder [ i ] then
71028: LD_EXP 103
71032: PUSH
71033: LD_VAR 0 2
71037: ARRAY
71038: IFFALSE 71074
// begin MC_Reset ( i , 125 ) ;
71040: LD_VAR 0 2
71044: PPUSH
71045: LD_INT 125
71047: PPUSH
71048: CALL 54497 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71052: LD_ADDR_EXP 103
71056: PUSH
71057: LD_EXP 103
71061: PPUSH
71062: LD_VAR 0 2
71066: PPUSH
71067: EMPTY
71068: PPUSH
71069: CALL_OW 1
71073: ST_TO_ADDR
// end ; continue ;
71074: GO 70928
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71076: LD_EXP 102
71080: PUSH
71081: LD_VAR 0 2
71085: ARRAY
71086: PUSH
71087: LD_INT 1
71089: ARRAY
71090: PUSH
71091: LD_INT 3
71093: ARRAY
71094: PUSH
71095: LD_INT 1
71097: EQUAL
71098: PUSH
71099: LD_INT 20
71101: PPUSH
71102: LD_EXP 91
71106: PUSH
71107: LD_VAR 0 2
71111: ARRAY
71112: PPUSH
71113: CALL_OW 321
71117: PUSH
71118: LD_INT 2
71120: NONEQUAL
71121: AND
71122: IFFALSE 71172
// begin if mc_deposits_finder [ i ] then
71124: LD_EXP 103
71128: PUSH
71129: LD_VAR 0 2
71133: ARRAY
71134: IFFALSE 71170
// begin MC_Reset ( i , 125 ) ;
71136: LD_VAR 0 2
71140: PPUSH
71141: LD_INT 125
71143: PPUSH
71144: CALL 54497 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71148: LD_ADDR_EXP 103
71152: PUSH
71153: LD_EXP 103
71157: PPUSH
71158: LD_VAR 0 2
71162: PPUSH
71163: EMPTY
71164: PPUSH
71165: CALL_OW 1
71169: ST_TO_ADDR
// end ; continue ;
71170: GO 70928
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71172: LD_EXP 102
71176: PUSH
71177: LD_VAR 0 2
71181: ARRAY
71182: PUSH
71183: LD_INT 1
71185: ARRAY
71186: PUSH
71187: LD_INT 1
71189: ARRAY
71190: PPUSH
71191: LD_EXP 102
71195: PUSH
71196: LD_VAR 0 2
71200: ARRAY
71201: PUSH
71202: LD_INT 1
71204: ARRAY
71205: PUSH
71206: LD_INT 2
71208: ARRAY
71209: PPUSH
71210: LD_EXP 91
71214: PUSH
71215: LD_VAR 0 2
71219: ARRAY
71220: PPUSH
71221: CALL_OW 440
71225: IFFALSE 71268
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71227: LD_ADDR_EXP 102
71231: PUSH
71232: LD_EXP 102
71236: PPUSH
71237: LD_VAR 0 2
71241: PPUSH
71242: LD_EXP 102
71246: PUSH
71247: LD_VAR 0 2
71251: ARRAY
71252: PPUSH
71253: LD_INT 1
71255: PPUSH
71256: CALL_OW 3
71260: PPUSH
71261: CALL_OW 1
71265: ST_TO_ADDR
71266: GO 71515
// begin if not mc_deposits_finder [ i ] then
71268: LD_EXP 103
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: NOT
71279: IFFALSE 71331
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71281: LD_ADDR_EXP 103
71285: PUSH
71286: LD_EXP 103
71290: PPUSH
71291: LD_VAR 0 2
71295: PPUSH
71296: LD_VAR 0 3
71300: PUSH
71301: LD_INT 1
71303: ARRAY
71304: PUSH
71305: EMPTY
71306: LIST
71307: PPUSH
71308: CALL_OW 1
71312: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71313: LD_VAR 0 3
71317: PUSH
71318: LD_INT 1
71320: ARRAY
71321: PPUSH
71322: LD_INT 125
71324: PPUSH
71325: CALL_OW 109
// end else
71329: GO 71515
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71331: LD_EXP 103
71335: PUSH
71336: LD_VAR 0 2
71340: ARRAY
71341: PUSH
71342: LD_INT 1
71344: ARRAY
71345: PPUSH
71346: CALL_OW 310
71350: IFFALSE 71373
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71352: LD_EXP 103
71356: PUSH
71357: LD_VAR 0 2
71361: ARRAY
71362: PUSH
71363: LD_INT 1
71365: ARRAY
71366: PPUSH
71367: CALL_OW 122
71371: GO 71515
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71373: LD_EXP 103
71377: PUSH
71378: LD_VAR 0 2
71382: ARRAY
71383: PUSH
71384: LD_INT 1
71386: ARRAY
71387: PPUSH
71388: CALL_OW 314
71392: NOT
71393: PUSH
71394: LD_EXP 103
71398: PUSH
71399: LD_VAR 0 2
71403: ARRAY
71404: PUSH
71405: LD_INT 1
71407: ARRAY
71408: PPUSH
71409: LD_EXP 102
71413: PUSH
71414: LD_VAR 0 2
71418: ARRAY
71419: PUSH
71420: LD_INT 1
71422: ARRAY
71423: PUSH
71424: LD_INT 1
71426: ARRAY
71427: PPUSH
71428: LD_EXP 102
71432: PUSH
71433: LD_VAR 0 2
71437: ARRAY
71438: PUSH
71439: LD_INT 1
71441: ARRAY
71442: PUSH
71443: LD_INT 2
71445: ARRAY
71446: PPUSH
71447: CALL_OW 297
71451: PUSH
71452: LD_INT 6
71454: GREATER
71455: AND
71456: IFFALSE 71515
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71458: LD_EXP 103
71462: PUSH
71463: LD_VAR 0 2
71467: ARRAY
71468: PUSH
71469: LD_INT 1
71471: ARRAY
71472: PPUSH
71473: LD_EXP 102
71477: PUSH
71478: LD_VAR 0 2
71482: ARRAY
71483: PUSH
71484: LD_INT 1
71486: ARRAY
71487: PUSH
71488: LD_INT 1
71490: ARRAY
71491: PPUSH
71492: LD_EXP 102
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: PUSH
71503: LD_INT 1
71505: ARRAY
71506: PUSH
71507: LD_INT 2
71509: ARRAY
71510: PPUSH
71511: CALL_OW 111
// end ; end ; end ;
71515: GO 70928
71517: POP
71518: POP
// end ;
71519: LD_VAR 0 1
71523: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71524: LD_INT 0
71526: PPUSH
71527: PPUSH
71528: PPUSH
71529: PPUSH
71530: PPUSH
71531: PPUSH
71532: PPUSH
71533: PPUSH
71534: PPUSH
71535: PPUSH
71536: PPUSH
// if not mc_bases then
71537: LD_EXP 65
71541: NOT
71542: IFFALSE 71546
// exit ;
71544: GO 72486
// for i = 1 to mc_bases do
71546: LD_ADDR_VAR 0 2
71550: PUSH
71551: DOUBLE
71552: LD_INT 1
71554: DEC
71555: ST_TO_ADDR
71556: LD_EXP 65
71560: PUSH
71561: FOR_TO
71562: IFFALSE 72484
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71564: LD_EXP 65
71568: PUSH
71569: LD_VAR 0 2
71573: ARRAY
71574: NOT
71575: PUSH
71576: LD_EXP 88
71580: PUSH
71581: LD_VAR 0 2
71585: ARRAY
71586: OR
71587: IFFALSE 71591
// continue ;
71589: GO 71561
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71591: LD_ADDR_VAR 0 7
71595: PUSH
71596: LD_EXP 65
71600: PUSH
71601: LD_VAR 0 2
71605: ARRAY
71606: PUSH
71607: LD_INT 1
71609: ARRAY
71610: PPUSH
71611: CALL_OW 248
71615: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71616: LD_VAR 0 7
71620: PUSH
71621: LD_INT 3
71623: EQUAL
71624: PUSH
71625: LD_EXP 84
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: PUSH
71636: LD_EXP 87
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: UNION
71647: PPUSH
71648: LD_INT 33
71650: PUSH
71651: LD_INT 2
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PPUSH
71658: CALL_OW 72
71662: NOT
71663: OR
71664: IFFALSE 71668
// continue ;
71666: GO 71561
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71668: LD_ADDR_VAR 0 9
71672: PUSH
71673: LD_EXP 65
71677: PUSH
71678: LD_VAR 0 2
71682: ARRAY
71683: PPUSH
71684: LD_INT 30
71686: PUSH
71687: LD_INT 36
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: PPUSH
71694: CALL_OW 72
71698: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71699: LD_ADDR_VAR 0 10
71703: PUSH
71704: LD_EXP 84
71708: PUSH
71709: LD_VAR 0 2
71713: ARRAY
71714: PPUSH
71715: LD_INT 34
71717: PUSH
71718: LD_INT 31
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PPUSH
71725: CALL_OW 72
71729: ST_TO_ADDR
// if not cts and not mcts then
71730: LD_VAR 0 9
71734: NOT
71735: PUSH
71736: LD_VAR 0 10
71740: NOT
71741: AND
71742: IFFALSE 71746
// continue ;
71744: GO 71561
// x := cts ;
71746: LD_ADDR_VAR 0 11
71750: PUSH
71751: LD_VAR 0 9
71755: ST_TO_ADDR
// if not x then
71756: LD_VAR 0 11
71760: NOT
71761: IFFALSE 71773
// x := mcts ;
71763: LD_ADDR_VAR 0 11
71767: PUSH
71768: LD_VAR 0 10
71772: ST_TO_ADDR
// if not x then
71773: LD_VAR 0 11
71777: NOT
71778: IFFALSE 71782
// continue ;
71780: GO 71561
// if mc_remote_driver [ i ] then
71782: LD_EXP 105
71786: PUSH
71787: LD_VAR 0 2
71791: ARRAY
71792: IFFALSE 72179
// for j in mc_remote_driver [ i ] do
71794: LD_ADDR_VAR 0 3
71798: PUSH
71799: LD_EXP 105
71803: PUSH
71804: LD_VAR 0 2
71808: ARRAY
71809: PUSH
71810: FOR_IN
71811: IFFALSE 72177
// begin if GetClass ( j ) <> 3 then
71813: LD_VAR 0 3
71817: PPUSH
71818: CALL_OW 257
71822: PUSH
71823: LD_INT 3
71825: NONEQUAL
71826: IFFALSE 71879
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71828: LD_ADDR_EXP 105
71832: PUSH
71833: LD_EXP 105
71837: PPUSH
71838: LD_VAR 0 2
71842: PPUSH
71843: LD_EXP 105
71847: PUSH
71848: LD_VAR 0 2
71852: ARRAY
71853: PUSH
71854: LD_VAR 0 3
71858: DIFF
71859: PPUSH
71860: CALL_OW 1
71864: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71865: LD_VAR 0 3
71869: PPUSH
71870: LD_INT 0
71872: PPUSH
71873: CALL_OW 109
// continue ;
71877: GO 71810
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71879: LD_EXP 84
71883: PUSH
71884: LD_VAR 0 2
71888: ARRAY
71889: PPUSH
71890: LD_INT 34
71892: PUSH
71893: LD_INT 31
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 58
71902: PUSH
71903: EMPTY
71904: LIST
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PPUSH
71910: CALL_OW 72
71914: PUSH
71915: LD_VAR 0 3
71919: PPUSH
71920: CALL 47228 0 1
71924: NOT
71925: AND
71926: IFFALSE 71997
// begin if IsInUnit ( j ) then
71928: LD_VAR 0 3
71932: PPUSH
71933: CALL_OW 310
71937: IFFALSE 71948
// ComExitBuilding ( j ) ;
71939: LD_VAR 0 3
71943: PPUSH
71944: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
71948: LD_VAR 0 3
71952: PPUSH
71953: LD_EXP 84
71957: PUSH
71958: LD_VAR 0 2
71962: ARRAY
71963: PPUSH
71964: LD_INT 34
71966: PUSH
71967: LD_INT 31
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 58
71976: PUSH
71977: EMPTY
71978: LIST
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PPUSH
71984: CALL_OW 72
71988: PUSH
71989: LD_INT 1
71991: ARRAY
71992: PPUSH
71993: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
71997: LD_VAR 0 3
72001: PPUSH
72002: CALL_OW 310
72006: NOT
72007: PUSH
72008: LD_VAR 0 3
72012: PPUSH
72013: CALL_OW 310
72017: PPUSH
72018: CALL_OW 266
72022: PUSH
72023: LD_INT 36
72025: NONEQUAL
72026: PUSH
72027: LD_VAR 0 3
72031: PPUSH
72032: CALL 47228 0 1
72036: NOT
72037: AND
72038: OR
72039: IFFALSE 72175
// begin if IsInUnit ( j ) then
72041: LD_VAR 0 3
72045: PPUSH
72046: CALL_OW 310
72050: IFFALSE 72061
// ComExitBuilding ( j ) ;
72052: LD_VAR 0 3
72056: PPUSH
72057: CALL_OW 122
// ct := 0 ;
72061: LD_ADDR_VAR 0 8
72065: PUSH
72066: LD_INT 0
72068: ST_TO_ADDR
// for k in x do
72069: LD_ADDR_VAR 0 4
72073: PUSH
72074: LD_VAR 0 11
72078: PUSH
72079: FOR_IN
72080: IFFALSE 72153
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72082: LD_VAR 0 4
72086: PPUSH
72087: CALL_OW 264
72091: PUSH
72092: LD_INT 31
72094: EQUAL
72095: PUSH
72096: LD_VAR 0 4
72100: PPUSH
72101: CALL_OW 311
72105: NOT
72106: AND
72107: PUSH
72108: LD_VAR 0 4
72112: PPUSH
72113: CALL_OW 266
72117: PUSH
72118: LD_INT 36
72120: EQUAL
72121: PUSH
72122: LD_VAR 0 4
72126: PPUSH
72127: CALL_OW 313
72131: PUSH
72132: LD_INT 3
72134: LESS
72135: AND
72136: OR
72137: IFFALSE 72151
// begin ct := k ;
72139: LD_ADDR_VAR 0 8
72143: PUSH
72144: LD_VAR 0 4
72148: ST_TO_ADDR
// break ;
72149: GO 72153
// end ;
72151: GO 72079
72153: POP
72154: POP
// if ct then
72155: LD_VAR 0 8
72159: IFFALSE 72175
// ComEnterUnit ( j , ct ) ;
72161: LD_VAR 0 3
72165: PPUSH
72166: LD_VAR 0 8
72170: PPUSH
72171: CALL_OW 120
// end ; end ;
72175: GO 71810
72177: POP
72178: POP
// places := 0 ;
72179: LD_ADDR_VAR 0 5
72183: PUSH
72184: LD_INT 0
72186: ST_TO_ADDR
// for j = 1 to x do
72187: LD_ADDR_VAR 0 3
72191: PUSH
72192: DOUBLE
72193: LD_INT 1
72195: DEC
72196: ST_TO_ADDR
72197: LD_VAR 0 11
72201: PUSH
72202: FOR_TO
72203: IFFALSE 72279
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72205: LD_VAR 0 11
72209: PUSH
72210: LD_VAR 0 3
72214: ARRAY
72215: PPUSH
72216: CALL_OW 264
72220: PUSH
72221: LD_INT 31
72223: EQUAL
72224: IFFALSE 72242
// places := places + 1 else
72226: LD_ADDR_VAR 0 5
72230: PUSH
72231: LD_VAR 0 5
72235: PUSH
72236: LD_INT 1
72238: PLUS
72239: ST_TO_ADDR
72240: GO 72277
// if GetBType ( x [ j ] ) = b_control_tower then
72242: LD_VAR 0 11
72246: PUSH
72247: LD_VAR 0 3
72251: ARRAY
72252: PPUSH
72253: CALL_OW 266
72257: PUSH
72258: LD_INT 36
72260: EQUAL
72261: IFFALSE 72277
// places := places + 3 ;
72263: LD_ADDR_VAR 0 5
72267: PUSH
72268: LD_VAR 0 5
72272: PUSH
72273: LD_INT 3
72275: PLUS
72276: ST_TO_ADDR
72277: GO 72202
72279: POP
72280: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72281: LD_VAR 0 5
72285: PUSH
72286: LD_INT 0
72288: EQUAL
72289: PUSH
72290: LD_VAR 0 5
72294: PUSH
72295: LD_EXP 105
72299: PUSH
72300: LD_VAR 0 2
72304: ARRAY
72305: LESSEQUAL
72306: OR
72307: IFFALSE 72311
// continue ;
72309: GO 71561
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72311: LD_ADDR_VAR 0 6
72315: PUSH
72316: LD_EXP 65
72320: PUSH
72321: LD_VAR 0 2
72325: ARRAY
72326: PPUSH
72327: LD_INT 25
72329: PUSH
72330: LD_INT 3
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PPUSH
72337: CALL_OW 72
72341: PUSH
72342: LD_EXP 105
72346: PUSH
72347: LD_VAR 0 2
72351: ARRAY
72352: DIFF
72353: PPUSH
72354: LD_INT 3
72356: PPUSH
72357: CALL 48128 0 2
72361: ST_TO_ADDR
// for j in tmp do
72362: LD_ADDR_VAR 0 3
72366: PUSH
72367: LD_VAR 0 6
72371: PUSH
72372: FOR_IN
72373: IFFALSE 72408
// if GetTag ( j ) > 0 then
72375: LD_VAR 0 3
72379: PPUSH
72380: CALL_OW 110
72384: PUSH
72385: LD_INT 0
72387: GREATER
72388: IFFALSE 72406
// tmp := tmp diff j ;
72390: LD_ADDR_VAR 0 6
72394: PUSH
72395: LD_VAR 0 6
72399: PUSH
72400: LD_VAR 0 3
72404: DIFF
72405: ST_TO_ADDR
72406: GO 72372
72408: POP
72409: POP
// if not tmp then
72410: LD_VAR 0 6
72414: NOT
72415: IFFALSE 72419
// continue ;
72417: GO 71561
// if places then
72419: LD_VAR 0 5
72423: IFFALSE 72482
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72425: LD_ADDR_EXP 105
72429: PUSH
72430: LD_EXP 105
72434: PPUSH
72435: LD_VAR 0 2
72439: PPUSH
72440: LD_EXP 105
72444: PUSH
72445: LD_VAR 0 2
72449: ARRAY
72450: PUSH
72451: LD_VAR 0 6
72455: PUSH
72456: LD_INT 1
72458: ARRAY
72459: UNION
72460: PPUSH
72461: CALL_OW 1
72465: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72466: LD_VAR 0 6
72470: PUSH
72471: LD_INT 1
72473: ARRAY
72474: PPUSH
72475: LD_INT 126
72477: PPUSH
72478: CALL_OW 109
// end ; end ;
72482: GO 71561
72484: POP
72485: POP
// end ;
72486: LD_VAR 0 1
72490: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72491: LD_INT 0
72493: PPUSH
72494: PPUSH
72495: PPUSH
72496: PPUSH
72497: PPUSH
72498: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72499: LD_VAR 0 1
72503: NOT
72504: PUSH
72505: LD_VAR 0 2
72509: NOT
72510: OR
72511: PUSH
72512: LD_VAR 0 3
72516: NOT
72517: OR
72518: PUSH
72519: LD_VAR 0 4
72523: PUSH
72524: LD_INT 1
72526: PUSH
72527: LD_INT 2
72529: PUSH
72530: LD_INT 3
72532: PUSH
72533: LD_INT 4
72535: PUSH
72536: LD_INT 5
72538: PUSH
72539: LD_INT 8
72541: PUSH
72542: LD_INT 9
72544: PUSH
72545: LD_INT 15
72547: PUSH
72548: LD_INT 16
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: LIST
72558: LIST
72559: LIST
72560: LIST
72561: IN
72562: NOT
72563: OR
72564: IFFALSE 72568
// exit ;
72566: GO 73468
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72568: LD_ADDR_VAR 0 2
72572: PUSH
72573: LD_VAR 0 2
72577: PPUSH
72578: LD_INT 21
72580: PUSH
72581: LD_INT 3
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: LD_INT 24
72590: PUSH
72591: LD_INT 250
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PPUSH
72602: CALL_OW 72
72606: ST_TO_ADDR
// case class of 1 , 15 :
72607: LD_VAR 0 4
72611: PUSH
72612: LD_INT 1
72614: DOUBLE
72615: EQUAL
72616: IFTRUE 72626
72618: LD_INT 15
72620: DOUBLE
72621: EQUAL
72622: IFTRUE 72626
72624: GO 72711
72626: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72627: LD_ADDR_VAR 0 8
72631: PUSH
72632: LD_VAR 0 2
72636: PPUSH
72637: LD_INT 2
72639: PUSH
72640: LD_INT 30
72642: PUSH
72643: LD_INT 32
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 30
72652: PUSH
72653: LD_INT 31
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: LIST
72664: PPUSH
72665: CALL_OW 72
72669: PUSH
72670: LD_VAR 0 2
72674: PPUSH
72675: LD_INT 2
72677: PUSH
72678: LD_INT 30
72680: PUSH
72681: LD_INT 4
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 30
72690: PUSH
72691: LD_INT 5
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: LIST
72702: PPUSH
72703: CALL_OW 72
72707: ADD
72708: ST_TO_ADDR
72709: GO 72957
72711: LD_INT 2
72713: DOUBLE
72714: EQUAL
72715: IFTRUE 72725
72717: LD_INT 16
72719: DOUBLE
72720: EQUAL
72721: IFTRUE 72725
72723: GO 72771
72725: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72726: LD_ADDR_VAR 0 8
72730: PUSH
72731: LD_VAR 0 2
72735: PPUSH
72736: LD_INT 2
72738: PUSH
72739: LD_INT 30
72741: PUSH
72742: LD_INT 0
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: LD_INT 30
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: EMPTY
72756: LIST
72757: LIST
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: LIST
72763: PPUSH
72764: CALL_OW 72
72768: ST_TO_ADDR
72769: GO 72957
72771: LD_INT 3
72773: DOUBLE
72774: EQUAL
72775: IFTRUE 72779
72777: GO 72825
72779: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72780: LD_ADDR_VAR 0 8
72784: PUSH
72785: LD_VAR 0 2
72789: PPUSH
72790: LD_INT 2
72792: PUSH
72793: LD_INT 30
72795: PUSH
72796: LD_INT 2
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 30
72805: PUSH
72806: LD_INT 3
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: PPUSH
72818: CALL_OW 72
72822: ST_TO_ADDR
72823: GO 72957
72825: LD_INT 4
72827: DOUBLE
72828: EQUAL
72829: IFTRUE 72833
72831: GO 72890
72833: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72834: LD_ADDR_VAR 0 8
72838: PUSH
72839: LD_VAR 0 2
72843: PPUSH
72844: LD_INT 2
72846: PUSH
72847: LD_INT 30
72849: PUSH
72850: LD_INT 6
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 30
72859: PUSH
72860: LD_INT 7
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 30
72869: PUSH
72870: LD_INT 8
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: PPUSH
72883: CALL_OW 72
72887: ST_TO_ADDR
72888: GO 72957
72890: LD_INT 5
72892: DOUBLE
72893: EQUAL
72894: IFTRUE 72910
72896: LD_INT 8
72898: DOUBLE
72899: EQUAL
72900: IFTRUE 72910
72902: LD_INT 9
72904: DOUBLE
72905: EQUAL
72906: IFTRUE 72910
72908: GO 72956
72910: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72911: LD_ADDR_VAR 0 8
72915: PUSH
72916: LD_VAR 0 2
72920: PPUSH
72921: LD_INT 2
72923: PUSH
72924: LD_INT 30
72926: PUSH
72927: LD_INT 4
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 30
72936: PUSH
72937: LD_INT 5
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: LIST
72948: PPUSH
72949: CALL_OW 72
72953: ST_TO_ADDR
72954: GO 72957
72956: POP
// if not tmp then
72957: LD_VAR 0 8
72961: NOT
72962: IFFALSE 72966
// exit ;
72964: GO 73468
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
72966: LD_VAR 0 4
72970: PUSH
72971: LD_INT 1
72973: PUSH
72974: LD_INT 15
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: IN
72981: PUSH
72982: LD_EXP 74
72986: PUSH
72987: LD_VAR 0 1
72991: ARRAY
72992: AND
72993: IFFALSE 73149
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
72995: LD_ADDR_VAR 0 9
72999: PUSH
73000: LD_EXP 74
73004: PUSH
73005: LD_VAR 0 1
73009: ARRAY
73010: PUSH
73011: LD_INT 1
73013: ARRAY
73014: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73015: LD_VAR 0 9
73019: PUSH
73020: LD_EXP 75
73024: PUSH
73025: LD_VAR 0 1
73029: ARRAY
73030: IN
73031: NOT
73032: IFFALSE 73147
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73034: LD_ADDR_EXP 75
73038: PUSH
73039: LD_EXP 75
73043: PPUSH
73044: LD_VAR 0 1
73048: PUSH
73049: LD_EXP 75
73053: PUSH
73054: LD_VAR 0 1
73058: ARRAY
73059: PUSH
73060: LD_INT 1
73062: PLUS
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PPUSH
73068: LD_VAR 0 9
73072: PPUSH
73073: CALL 18579 0 3
73077: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73078: LD_ADDR_EXP 74
73082: PUSH
73083: LD_EXP 74
73087: PPUSH
73088: LD_VAR 0 1
73092: PPUSH
73093: LD_EXP 74
73097: PUSH
73098: LD_VAR 0 1
73102: ARRAY
73103: PUSH
73104: LD_VAR 0 9
73108: DIFF
73109: PPUSH
73110: CALL_OW 1
73114: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73115: LD_VAR 0 3
73119: PPUSH
73120: LD_EXP 75
73124: PUSH
73125: LD_VAR 0 1
73129: ARRAY
73130: PUSH
73131: LD_EXP 75
73135: PUSH
73136: LD_VAR 0 1
73140: ARRAY
73141: ARRAY
73142: PPUSH
73143: CALL_OW 120
// end ; exit ;
73147: GO 73468
// end ; if tmp > 1 then
73149: LD_VAR 0 8
73153: PUSH
73154: LD_INT 1
73156: GREATER
73157: IFFALSE 73261
// for i = 2 to tmp do
73159: LD_ADDR_VAR 0 6
73163: PUSH
73164: DOUBLE
73165: LD_INT 2
73167: DEC
73168: ST_TO_ADDR
73169: LD_VAR 0 8
73173: PUSH
73174: FOR_TO
73175: IFFALSE 73259
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73177: LD_VAR 0 8
73181: PUSH
73182: LD_VAR 0 6
73186: ARRAY
73187: PPUSH
73188: CALL_OW 461
73192: PUSH
73193: LD_INT 6
73195: EQUAL
73196: IFFALSE 73257
// begin x := tmp [ i ] ;
73198: LD_ADDR_VAR 0 9
73202: PUSH
73203: LD_VAR 0 8
73207: PUSH
73208: LD_VAR 0 6
73212: ARRAY
73213: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73214: LD_ADDR_VAR 0 8
73218: PUSH
73219: LD_VAR 0 8
73223: PPUSH
73224: LD_VAR 0 6
73228: PPUSH
73229: CALL_OW 3
73233: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73234: LD_ADDR_VAR 0 8
73238: PUSH
73239: LD_VAR 0 8
73243: PPUSH
73244: LD_INT 1
73246: PPUSH
73247: LD_VAR 0 9
73251: PPUSH
73252: CALL_OW 2
73256: ST_TO_ADDR
// end ;
73257: GO 73174
73259: POP
73260: POP
// for i in tmp do
73261: LD_ADDR_VAR 0 6
73265: PUSH
73266: LD_VAR 0 8
73270: PUSH
73271: FOR_IN
73272: IFFALSE 73341
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73274: LD_VAR 0 6
73278: PPUSH
73279: CALL_OW 313
73283: PUSH
73284: LD_INT 6
73286: LESS
73287: PUSH
73288: LD_VAR 0 6
73292: PPUSH
73293: CALL_OW 266
73297: PUSH
73298: LD_INT 31
73300: PUSH
73301: LD_INT 32
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: IN
73308: NOT
73309: AND
73310: PUSH
73311: LD_VAR 0 6
73315: PPUSH
73316: CALL_OW 313
73320: PUSH
73321: LD_INT 0
73323: EQUAL
73324: OR
73325: IFFALSE 73339
// begin j := i ;
73327: LD_ADDR_VAR 0 7
73331: PUSH
73332: LD_VAR 0 6
73336: ST_TO_ADDR
// break ;
73337: GO 73341
// end ; end ;
73339: GO 73271
73341: POP
73342: POP
// if j then
73343: LD_VAR 0 7
73347: IFFALSE 73365
// ComEnterUnit ( unit , j ) else
73349: LD_VAR 0 3
73353: PPUSH
73354: LD_VAR 0 7
73358: PPUSH
73359: CALL_OW 120
73363: GO 73468
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73365: LD_ADDR_VAR 0 10
73369: PUSH
73370: LD_VAR 0 2
73374: PPUSH
73375: LD_INT 2
73377: PUSH
73378: LD_INT 30
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 30
73390: PUSH
73391: LD_INT 1
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: LIST
73402: PPUSH
73403: CALL_OW 72
73407: ST_TO_ADDR
// if depot then
73408: LD_VAR 0 10
73412: IFFALSE 73468
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73414: LD_ADDR_VAR 0 10
73418: PUSH
73419: LD_VAR 0 10
73423: PPUSH
73424: LD_VAR 0 3
73428: PPUSH
73429: CALL_OW 74
73433: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73434: LD_VAR 0 3
73438: PPUSH
73439: LD_VAR 0 10
73443: PPUSH
73444: CALL_OW 296
73448: PUSH
73449: LD_INT 10
73451: GREATER
73452: IFFALSE 73468
// ComStandNearbyBuilding ( unit , depot ) ;
73454: LD_VAR 0 3
73458: PPUSH
73459: LD_VAR 0 10
73463: PPUSH
73464: CALL 15193 0 2
// end ; end ; end ;
73468: LD_VAR 0 5
73472: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73473: LD_INT 0
73475: PPUSH
73476: PPUSH
73477: PPUSH
73478: PPUSH
// if not mc_bases then
73479: LD_EXP 65
73483: NOT
73484: IFFALSE 73488
// exit ;
73486: GO 73727
// for i = 1 to mc_bases do
73488: LD_ADDR_VAR 0 2
73492: PUSH
73493: DOUBLE
73494: LD_INT 1
73496: DEC
73497: ST_TO_ADDR
73498: LD_EXP 65
73502: PUSH
73503: FOR_TO
73504: IFFALSE 73725
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73506: LD_ADDR_VAR 0 4
73510: PUSH
73511: LD_EXP 65
73515: PUSH
73516: LD_VAR 0 2
73520: ARRAY
73521: PPUSH
73522: LD_INT 21
73524: PUSH
73525: LD_INT 1
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PPUSH
73532: CALL_OW 72
73536: PUSH
73537: LD_EXP 94
73541: PUSH
73542: LD_VAR 0 2
73546: ARRAY
73547: UNION
73548: ST_TO_ADDR
// if not tmp then
73549: LD_VAR 0 4
73553: NOT
73554: IFFALSE 73558
// continue ;
73556: GO 73503
// for j in tmp do
73558: LD_ADDR_VAR 0 3
73562: PUSH
73563: LD_VAR 0 4
73567: PUSH
73568: FOR_IN
73569: IFFALSE 73721
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73571: LD_VAR 0 3
73575: PPUSH
73576: CALL_OW 110
73580: NOT
73581: PUSH
73582: LD_VAR 0 3
73586: PPUSH
73587: CALL_OW 314
73591: NOT
73592: AND
73593: PUSH
73594: LD_VAR 0 3
73598: PPUSH
73599: CALL_OW 311
73603: NOT
73604: AND
73605: PUSH
73606: LD_VAR 0 3
73610: PPUSH
73611: CALL_OW 310
73615: NOT
73616: AND
73617: PUSH
73618: LD_VAR 0 3
73622: PUSH
73623: LD_EXP 68
73627: PUSH
73628: LD_VAR 0 2
73632: ARRAY
73633: PUSH
73634: LD_INT 1
73636: ARRAY
73637: IN
73638: NOT
73639: AND
73640: PUSH
73641: LD_VAR 0 3
73645: PUSH
73646: LD_EXP 68
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: PUSH
73657: LD_INT 2
73659: ARRAY
73660: IN
73661: NOT
73662: AND
73663: PUSH
73664: LD_VAR 0 3
73668: PUSH
73669: LD_EXP 77
73673: PUSH
73674: LD_VAR 0 2
73678: ARRAY
73679: IN
73680: NOT
73681: AND
73682: IFFALSE 73719
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73684: LD_VAR 0 2
73688: PPUSH
73689: LD_EXP 65
73693: PUSH
73694: LD_VAR 0 2
73698: ARRAY
73699: PPUSH
73700: LD_VAR 0 3
73704: PPUSH
73705: LD_VAR 0 3
73709: PPUSH
73710: CALL_OW 257
73714: PPUSH
73715: CALL 72491 0 4
// end ;
73719: GO 73568
73721: POP
73722: POP
// end ;
73723: GO 73503
73725: POP
73726: POP
// end ;
73727: LD_VAR 0 1
73731: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73732: LD_INT 0
73734: PPUSH
73735: PPUSH
73736: PPUSH
73737: PPUSH
73738: PPUSH
73739: PPUSH
// if not mc_bases [ base ] then
73740: LD_EXP 65
73744: PUSH
73745: LD_VAR 0 1
73749: ARRAY
73750: NOT
73751: IFFALSE 73755
// exit ;
73753: GO 73937
// tmp := [ ] ;
73755: LD_ADDR_VAR 0 6
73759: PUSH
73760: EMPTY
73761: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73762: LD_ADDR_VAR 0 7
73766: PUSH
73767: LD_VAR 0 3
73771: PPUSH
73772: LD_INT 0
73774: PPUSH
73775: CALL_OW 517
73779: ST_TO_ADDR
// if not list then
73780: LD_VAR 0 7
73784: NOT
73785: IFFALSE 73789
// exit ;
73787: GO 73937
// for i = 1 to amount do
73789: LD_ADDR_VAR 0 5
73793: PUSH
73794: DOUBLE
73795: LD_INT 1
73797: DEC
73798: ST_TO_ADDR
73799: LD_VAR 0 2
73803: PUSH
73804: FOR_TO
73805: IFFALSE 73885
// begin x := rand ( 1 , list [ 1 ] ) ;
73807: LD_ADDR_VAR 0 8
73811: PUSH
73812: LD_INT 1
73814: PPUSH
73815: LD_VAR 0 7
73819: PUSH
73820: LD_INT 1
73822: ARRAY
73823: PPUSH
73824: CALL_OW 12
73828: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73829: LD_ADDR_VAR 0 6
73833: PUSH
73834: LD_VAR 0 6
73838: PPUSH
73839: LD_VAR 0 5
73843: PPUSH
73844: LD_VAR 0 7
73848: PUSH
73849: LD_INT 1
73851: ARRAY
73852: PUSH
73853: LD_VAR 0 8
73857: ARRAY
73858: PUSH
73859: LD_VAR 0 7
73863: PUSH
73864: LD_INT 2
73866: ARRAY
73867: PUSH
73868: LD_VAR 0 8
73872: ARRAY
73873: PUSH
73874: EMPTY
73875: LIST
73876: LIST
73877: PPUSH
73878: CALL_OW 1
73882: ST_TO_ADDR
// end ;
73883: GO 73804
73885: POP
73886: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73887: LD_ADDR_EXP 78
73891: PUSH
73892: LD_EXP 78
73896: PPUSH
73897: LD_VAR 0 1
73901: PPUSH
73902: LD_VAR 0 6
73906: PPUSH
73907: CALL_OW 1
73911: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73912: LD_ADDR_EXP 80
73916: PUSH
73917: LD_EXP 80
73921: PPUSH
73922: LD_VAR 0 1
73926: PPUSH
73927: LD_VAR 0 3
73931: PPUSH
73932: CALL_OW 1
73936: ST_TO_ADDR
// end ;
73937: LD_VAR 0 4
73941: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
73942: LD_INT 0
73944: PPUSH
// if not mc_bases [ base ] then
73945: LD_EXP 65
73949: PUSH
73950: LD_VAR 0 1
73954: ARRAY
73955: NOT
73956: IFFALSE 73960
// exit ;
73958: GO 73985
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
73960: LD_ADDR_EXP 70
73964: PUSH
73965: LD_EXP 70
73969: PPUSH
73970: LD_VAR 0 1
73974: PPUSH
73975: LD_VAR 0 2
73979: PPUSH
73980: CALL_OW 1
73984: ST_TO_ADDR
// end ;
73985: LD_VAR 0 3
73989: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
73990: LD_INT 0
73992: PPUSH
// if not mc_bases [ base ] then
73993: LD_EXP 65
73997: PUSH
73998: LD_VAR 0 1
74002: ARRAY
74003: NOT
74004: IFFALSE 74008
// exit ;
74006: GO 74045
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74008: LD_ADDR_EXP 70
74012: PUSH
74013: LD_EXP 70
74017: PPUSH
74018: LD_VAR 0 1
74022: PPUSH
74023: LD_EXP 70
74027: PUSH
74028: LD_VAR 0 1
74032: ARRAY
74033: PUSH
74034: LD_VAR 0 2
74038: UNION
74039: PPUSH
74040: CALL_OW 1
74044: ST_TO_ADDR
// end ;
74045: LD_VAR 0 3
74049: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74050: LD_INT 0
74052: PPUSH
// if not mc_bases [ base ] then
74053: LD_EXP 65
74057: PUSH
74058: LD_VAR 0 1
74062: ARRAY
74063: NOT
74064: IFFALSE 74068
// exit ;
74066: GO 74093
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74068: LD_ADDR_EXP 86
74072: PUSH
74073: LD_EXP 86
74077: PPUSH
74078: LD_VAR 0 1
74082: PPUSH
74083: LD_VAR 0 2
74087: PPUSH
74088: CALL_OW 1
74092: ST_TO_ADDR
// end ;
74093: LD_VAR 0 3
74097: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74098: LD_INT 0
74100: PPUSH
// if not mc_bases [ base ] then
74101: LD_EXP 65
74105: PUSH
74106: LD_VAR 0 1
74110: ARRAY
74111: NOT
74112: IFFALSE 74116
// exit ;
74114: GO 74153
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74116: LD_ADDR_EXP 86
74120: PUSH
74121: LD_EXP 86
74125: PPUSH
74126: LD_VAR 0 1
74130: PPUSH
74131: LD_EXP 86
74135: PUSH
74136: LD_VAR 0 1
74140: ARRAY
74141: PUSH
74142: LD_VAR 0 2
74146: ADD
74147: PPUSH
74148: CALL_OW 1
74152: ST_TO_ADDR
// end ;
74153: LD_VAR 0 3
74157: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74158: LD_INT 0
74160: PPUSH
// if not mc_bases [ base ] then
74161: LD_EXP 65
74165: PUSH
74166: LD_VAR 0 1
74170: ARRAY
74171: NOT
74172: IFFALSE 74176
// exit ;
74174: GO 74230
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74176: LD_ADDR_EXP 87
74180: PUSH
74181: LD_EXP 87
74185: PPUSH
74186: LD_VAR 0 1
74190: PPUSH
74191: LD_VAR 0 2
74195: PPUSH
74196: CALL_OW 1
74200: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74201: LD_ADDR_EXP 76
74205: PUSH
74206: LD_EXP 76
74210: PPUSH
74211: LD_VAR 0 1
74215: PPUSH
74216: LD_VAR 0 2
74220: PUSH
74221: LD_INT 0
74223: PLUS
74224: PPUSH
74225: CALL_OW 1
74229: ST_TO_ADDR
// end ;
74230: LD_VAR 0 3
74234: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74235: LD_INT 0
74237: PPUSH
// if not mc_bases [ base ] then
74238: LD_EXP 65
74242: PUSH
74243: LD_VAR 0 1
74247: ARRAY
74248: NOT
74249: IFFALSE 74253
// exit ;
74251: GO 74278
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74253: LD_ADDR_EXP 76
74257: PUSH
74258: LD_EXP 76
74262: PPUSH
74263: LD_VAR 0 1
74267: PPUSH
74268: LD_VAR 0 2
74272: PPUSH
74273: CALL_OW 1
74277: ST_TO_ADDR
// end ;
74278: LD_VAR 0 3
74282: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74283: LD_INT 0
74285: PPUSH
74286: PPUSH
74287: PPUSH
74288: PPUSH
// if not mc_bases [ base ] then
74289: LD_EXP 65
74293: PUSH
74294: LD_VAR 0 1
74298: ARRAY
74299: NOT
74300: IFFALSE 74304
// exit ;
74302: GO 74369
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74304: LD_ADDR_EXP 85
74308: PUSH
74309: LD_EXP 85
74313: PPUSH
74314: LD_VAR 0 1
74318: PUSH
74319: LD_EXP 85
74323: PUSH
74324: LD_VAR 0 1
74328: ARRAY
74329: PUSH
74330: LD_INT 1
74332: PLUS
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PPUSH
74338: LD_VAR 0 1
74342: PUSH
74343: LD_VAR 0 2
74347: PUSH
74348: LD_VAR 0 3
74352: PUSH
74353: LD_VAR 0 4
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: LIST
74362: LIST
74363: PPUSH
74364: CALL 18579 0 3
74368: ST_TO_ADDR
// end ;
74369: LD_VAR 0 5
74373: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74374: LD_INT 0
74376: PPUSH
// if not mc_bases [ base ] then
74377: LD_EXP 65
74381: PUSH
74382: LD_VAR 0 1
74386: ARRAY
74387: NOT
74388: IFFALSE 74392
// exit ;
74390: GO 74417
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74392: LD_ADDR_EXP 102
74396: PUSH
74397: LD_EXP 102
74401: PPUSH
74402: LD_VAR 0 1
74406: PPUSH
74407: LD_VAR 0 2
74411: PPUSH
74412: CALL_OW 1
74416: ST_TO_ADDR
// end ;
74417: LD_VAR 0 3
74421: RET
// export function MC_GetMinesField ( base ) ; begin
74422: LD_INT 0
74424: PPUSH
// result := mc_mines [ base ] ;
74425: LD_ADDR_VAR 0 2
74429: PUSH
74430: LD_EXP 78
74434: PUSH
74435: LD_VAR 0 1
74439: ARRAY
74440: ST_TO_ADDR
// end ;
74441: LD_VAR 0 2
74445: RET
// export function MC_GetProduceList ( base ) ; begin
74446: LD_INT 0
74448: PPUSH
// result := mc_produce [ base ] ;
74449: LD_ADDR_VAR 0 2
74453: PUSH
74454: LD_EXP 86
74458: PUSH
74459: LD_VAR 0 1
74463: ARRAY
74464: ST_TO_ADDR
// end ;
74465: LD_VAR 0 2
74469: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74470: LD_INT 0
74472: PPUSH
74473: PPUSH
// if not mc_bases then
74474: LD_EXP 65
74478: NOT
74479: IFFALSE 74483
// exit ;
74481: GO 74548
// if mc_bases [ base ] then
74483: LD_EXP 65
74487: PUSH
74488: LD_VAR 0 1
74492: ARRAY
74493: IFFALSE 74548
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74495: LD_ADDR_VAR 0 3
74499: PUSH
74500: LD_EXP 65
74504: PUSH
74505: LD_VAR 0 1
74509: ARRAY
74510: PPUSH
74511: LD_INT 30
74513: PUSH
74514: LD_VAR 0 2
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PPUSH
74523: CALL_OW 72
74527: ST_TO_ADDR
// if result then
74528: LD_VAR 0 3
74532: IFFALSE 74548
// result := result [ 1 ] ;
74534: LD_ADDR_VAR 0 3
74538: PUSH
74539: LD_VAR 0 3
74543: PUSH
74544: LD_INT 1
74546: ARRAY
74547: ST_TO_ADDR
// end ; end ;
74548: LD_VAR 0 3
74552: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74553: LD_INT 0
74555: PPUSH
74556: PPUSH
// if not mc_bases then
74557: LD_EXP 65
74561: NOT
74562: IFFALSE 74566
// exit ;
74564: GO 74611
// if mc_bases [ base ] then
74566: LD_EXP 65
74570: PUSH
74571: LD_VAR 0 1
74575: ARRAY
74576: IFFALSE 74611
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74578: LD_ADDR_VAR 0 3
74582: PUSH
74583: LD_EXP 65
74587: PUSH
74588: LD_VAR 0 1
74592: ARRAY
74593: PPUSH
74594: LD_INT 30
74596: PUSH
74597: LD_VAR 0 2
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PPUSH
74606: CALL_OW 72
74610: ST_TO_ADDR
// end ;
74611: LD_VAR 0 3
74615: RET
// export function MC_SetTame ( base , area ) ; begin
74616: LD_INT 0
74618: PPUSH
// if not mc_bases or not base then
74619: LD_EXP 65
74623: NOT
74624: PUSH
74625: LD_VAR 0 1
74629: NOT
74630: OR
74631: IFFALSE 74635
// exit ;
74633: GO 74660
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74635: LD_ADDR_EXP 93
74639: PUSH
74640: LD_EXP 93
74644: PPUSH
74645: LD_VAR 0 1
74649: PPUSH
74650: LD_VAR 0 2
74654: PPUSH
74655: CALL_OW 1
74659: ST_TO_ADDR
// end ;
74660: LD_VAR 0 3
74664: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74665: LD_INT 0
74667: PPUSH
74668: PPUSH
// if not mc_bases or not base then
74669: LD_EXP 65
74673: NOT
74674: PUSH
74675: LD_VAR 0 1
74679: NOT
74680: OR
74681: IFFALSE 74685
// exit ;
74683: GO 74787
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74685: LD_ADDR_VAR 0 4
74689: PUSH
74690: LD_EXP 65
74694: PUSH
74695: LD_VAR 0 1
74699: ARRAY
74700: PPUSH
74701: LD_INT 30
74703: PUSH
74704: LD_VAR 0 2
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PPUSH
74713: CALL_OW 72
74717: ST_TO_ADDR
// if not tmp then
74718: LD_VAR 0 4
74722: NOT
74723: IFFALSE 74727
// exit ;
74725: GO 74787
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74727: LD_ADDR_EXP 97
74731: PUSH
74732: LD_EXP 97
74736: PPUSH
74737: LD_VAR 0 1
74741: PPUSH
74742: LD_EXP 97
74746: PUSH
74747: LD_VAR 0 1
74751: ARRAY
74752: PPUSH
74753: LD_EXP 97
74757: PUSH
74758: LD_VAR 0 1
74762: ARRAY
74763: PUSH
74764: LD_INT 1
74766: PLUS
74767: PPUSH
74768: LD_VAR 0 4
74772: PUSH
74773: LD_INT 1
74775: ARRAY
74776: PPUSH
74777: CALL_OW 2
74781: PPUSH
74782: CALL_OW 1
74786: ST_TO_ADDR
// end ;
74787: LD_VAR 0 3
74791: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74792: LD_INT 0
74794: PPUSH
74795: PPUSH
// if not mc_bases or not base or not kinds then
74796: LD_EXP 65
74800: NOT
74801: PUSH
74802: LD_VAR 0 1
74806: NOT
74807: OR
74808: PUSH
74809: LD_VAR 0 2
74813: NOT
74814: OR
74815: IFFALSE 74819
// exit ;
74817: GO 74880
// for i in kinds do
74819: LD_ADDR_VAR 0 4
74823: PUSH
74824: LD_VAR 0 2
74828: PUSH
74829: FOR_IN
74830: IFFALSE 74878
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74832: LD_ADDR_EXP 99
74836: PUSH
74837: LD_EXP 99
74841: PPUSH
74842: LD_VAR 0 1
74846: PUSH
74847: LD_EXP 99
74851: PUSH
74852: LD_VAR 0 1
74856: ARRAY
74857: PUSH
74858: LD_INT 1
74860: PLUS
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PPUSH
74866: LD_VAR 0 4
74870: PPUSH
74871: CALL 18579 0 3
74875: ST_TO_ADDR
74876: GO 74829
74878: POP
74879: POP
// end ;
74880: LD_VAR 0 3
74884: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74885: LD_INT 0
74887: PPUSH
// if not mc_bases or not base or not areas then
74888: LD_EXP 65
74892: NOT
74893: PUSH
74894: LD_VAR 0 1
74898: NOT
74899: OR
74900: PUSH
74901: LD_VAR 0 2
74905: NOT
74906: OR
74907: IFFALSE 74911
// exit ;
74909: GO 74936
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74911: LD_ADDR_EXP 83
74915: PUSH
74916: LD_EXP 83
74920: PPUSH
74921: LD_VAR 0 1
74925: PPUSH
74926: LD_VAR 0 2
74930: PPUSH
74931: CALL_OW 1
74935: ST_TO_ADDR
// end ;
74936: LD_VAR 0 3
74940: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
74941: LD_INT 0
74943: PPUSH
// if not mc_bases or not base or not teleports_exit then
74944: LD_EXP 65
74948: NOT
74949: PUSH
74950: LD_VAR 0 1
74954: NOT
74955: OR
74956: PUSH
74957: LD_VAR 0 2
74961: NOT
74962: OR
74963: IFFALSE 74967
// exit ;
74965: GO 74992
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
74967: LD_ADDR_EXP 100
74971: PUSH
74972: LD_EXP 100
74976: PPUSH
74977: LD_VAR 0 1
74981: PPUSH
74982: LD_VAR 0 2
74986: PPUSH
74987: CALL_OW 1
74991: ST_TO_ADDR
// end ;
74992: LD_VAR 0 3
74996: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
74997: LD_INT 0
74999: PPUSH
75000: PPUSH
75001: PPUSH
// if not mc_bases or not base or not ext_list then
75002: LD_EXP 65
75006: NOT
75007: PUSH
75008: LD_VAR 0 1
75012: NOT
75013: OR
75014: PUSH
75015: LD_VAR 0 5
75019: NOT
75020: OR
75021: IFFALSE 75025
// exit ;
75023: GO 75198
// tmp := GetFacExtXYD ( x , y , d ) ;
75025: LD_ADDR_VAR 0 8
75029: PUSH
75030: LD_VAR 0 2
75034: PPUSH
75035: LD_VAR 0 3
75039: PPUSH
75040: LD_VAR 0 4
75044: PPUSH
75045: CALL 47258 0 3
75049: ST_TO_ADDR
// if not tmp then
75050: LD_VAR 0 8
75054: NOT
75055: IFFALSE 75059
// exit ;
75057: GO 75198
// for i in tmp do
75059: LD_ADDR_VAR 0 7
75063: PUSH
75064: LD_VAR 0 8
75068: PUSH
75069: FOR_IN
75070: IFFALSE 75196
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75072: LD_ADDR_EXP 70
75076: PUSH
75077: LD_EXP 70
75081: PPUSH
75082: LD_VAR 0 1
75086: PPUSH
75087: LD_EXP 70
75091: PUSH
75092: LD_VAR 0 1
75096: ARRAY
75097: PPUSH
75098: LD_EXP 70
75102: PUSH
75103: LD_VAR 0 1
75107: ARRAY
75108: PUSH
75109: LD_INT 1
75111: PLUS
75112: PPUSH
75113: LD_VAR 0 5
75117: PUSH
75118: LD_INT 1
75120: ARRAY
75121: PUSH
75122: LD_VAR 0 7
75126: PUSH
75127: LD_INT 1
75129: ARRAY
75130: PUSH
75131: LD_VAR 0 7
75135: PUSH
75136: LD_INT 2
75138: ARRAY
75139: PUSH
75140: LD_VAR 0 7
75144: PUSH
75145: LD_INT 3
75147: ARRAY
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: PPUSH
75155: CALL_OW 2
75159: PPUSH
75160: CALL_OW 1
75164: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75165: LD_ADDR_VAR 0 5
75169: PUSH
75170: LD_VAR 0 5
75174: PPUSH
75175: LD_INT 1
75177: PPUSH
75178: CALL_OW 3
75182: ST_TO_ADDR
// if not ext_list then
75183: LD_VAR 0 5
75187: NOT
75188: IFFALSE 75194
// exit ;
75190: POP
75191: POP
75192: GO 75198
// end ;
75194: GO 75069
75196: POP
75197: POP
// end ;
75198: LD_VAR 0 6
75202: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75203: LD_INT 0
75205: PPUSH
// if not mc_bases or not base or not weapon_list then
75206: LD_EXP 65
75210: NOT
75211: PUSH
75212: LD_VAR 0 1
75216: NOT
75217: OR
75218: PUSH
75219: LD_VAR 0 2
75223: NOT
75224: OR
75225: IFFALSE 75229
// exit ;
75227: GO 75254
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75229: LD_ADDR_EXP 104
75233: PUSH
75234: LD_EXP 104
75238: PPUSH
75239: LD_VAR 0 1
75243: PPUSH
75244: LD_VAR 0 2
75248: PPUSH
75249: CALL_OW 1
75253: ST_TO_ADDR
// end ;
75254: LD_VAR 0 3
75258: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75259: LD_INT 0
75261: PPUSH
// if not mc_bases or not base or not tech_list then
75262: LD_EXP 65
75266: NOT
75267: PUSH
75268: LD_VAR 0 1
75272: NOT
75273: OR
75274: PUSH
75275: LD_VAR 0 2
75279: NOT
75280: OR
75281: IFFALSE 75285
// exit ;
75283: GO 75310
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75285: LD_ADDR_EXP 92
75289: PUSH
75290: LD_EXP 92
75294: PPUSH
75295: LD_VAR 0 1
75299: PPUSH
75300: LD_VAR 0 2
75304: PPUSH
75305: CALL_OW 1
75309: ST_TO_ADDR
// end ;
75310: LD_VAR 0 3
75314: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75315: LD_INT 0
75317: PPUSH
// if not mc_bases or not parking_area or not base then
75318: LD_EXP 65
75322: NOT
75323: PUSH
75324: LD_VAR 0 2
75328: NOT
75329: OR
75330: PUSH
75331: LD_VAR 0 1
75335: NOT
75336: OR
75337: IFFALSE 75341
// exit ;
75339: GO 75366
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75341: LD_ADDR_EXP 89
75345: PUSH
75346: LD_EXP 89
75350: PPUSH
75351: LD_VAR 0 1
75355: PPUSH
75356: LD_VAR 0 2
75360: PPUSH
75361: CALL_OW 1
75365: ST_TO_ADDR
// end ;
75366: LD_VAR 0 3
75370: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75371: LD_INT 0
75373: PPUSH
// if not mc_bases or not base or not scan_area then
75374: LD_EXP 65
75378: NOT
75379: PUSH
75380: LD_VAR 0 1
75384: NOT
75385: OR
75386: PUSH
75387: LD_VAR 0 2
75391: NOT
75392: OR
75393: IFFALSE 75397
// exit ;
75395: GO 75422
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75397: LD_ADDR_EXP 90
75401: PUSH
75402: LD_EXP 90
75406: PPUSH
75407: LD_VAR 0 1
75411: PPUSH
75412: LD_VAR 0 2
75416: PPUSH
75417: CALL_OW 1
75421: ST_TO_ADDR
// end ;
75422: LD_VAR 0 3
75426: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75427: LD_INT 0
75429: PPUSH
75430: PPUSH
// if not mc_bases or not base then
75431: LD_EXP 65
75435: NOT
75436: PUSH
75437: LD_VAR 0 1
75441: NOT
75442: OR
75443: IFFALSE 75447
// exit ;
75445: GO 75511
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75447: LD_ADDR_VAR 0 3
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: LD_INT 2
75457: PUSH
75458: LD_INT 3
75460: PUSH
75461: LD_INT 4
75463: PUSH
75464: LD_INT 11
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: LIST
75473: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75474: LD_ADDR_EXP 92
75478: PUSH
75479: LD_EXP 92
75483: PPUSH
75484: LD_VAR 0 1
75488: PPUSH
75489: LD_EXP 92
75493: PUSH
75494: LD_VAR 0 1
75498: ARRAY
75499: PUSH
75500: LD_VAR 0 3
75504: DIFF
75505: PPUSH
75506: CALL_OW 1
75510: ST_TO_ADDR
// end ;
75511: LD_VAR 0 2
75515: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75516: LD_INT 0
75518: PPUSH
// result := mc_vehicles [ base ] ;
75519: LD_ADDR_VAR 0 3
75523: PUSH
75524: LD_EXP 84
75528: PUSH
75529: LD_VAR 0 1
75533: ARRAY
75534: ST_TO_ADDR
// if onlyCombat then
75535: LD_VAR 0 2
75539: IFFALSE 75704
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75541: LD_ADDR_VAR 0 3
75545: PUSH
75546: LD_VAR 0 3
75550: PUSH
75551: LD_VAR 0 3
75555: PPUSH
75556: LD_INT 2
75558: PUSH
75559: LD_INT 34
75561: PUSH
75562: LD_INT 12
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 34
75571: PUSH
75572: LD_INT 51
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 34
75581: PUSH
75582: LD_EXP 49
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PUSH
75591: LD_INT 34
75593: PUSH
75594: LD_INT 32
75596: PUSH
75597: EMPTY
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 34
75603: PUSH
75604: LD_INT 13
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 34
75613: PUSH
75614: LD_INT 52
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 34
75623: PUSH
75624: LD_INT 14
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 34
75633: PUSH
75634: LD_INT 53
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 34
75643: PUSH
75644: LD_EXP 48
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 34
75655: PUSH
75656: LD_INT 31
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 34
75665: PUSH
75666: LD_INT 48
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 34
75675: PUSH
75676: LD_INT 8
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: LIST
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: PPUSH
75698: CALL_OW 72
75702: DIFF
75703: ST_TO_ADDR
// end ; end_of_file
75704: LD_VAR 0 3
75708: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75709: LD_INT 0
75711: PPUSH
75712: PPUSH
75713: PPUSH
// if not mc_bases or not skirmish then
75714: LD_EXP 65
75718: NOT
75719: PUSH
75720: LD_EXP 63
75724: NOT
75725: OR
75726: IFFALSE 75730
// exit ;
75728: GO 75895
// for i = 1 to mc_bases do
75730: LD_ADDR_VAR 0 4
75734: PUSH
75735: DOUBLE
75736: LD_INT 1
75738: DEC
75739: ST_TO_ADDR
75740: LD_EXP 65
75744: PUSH
75745: FOR_TO
75746: IFFALSE 75893
// begin if sci in mc_bases [ i ] then
75748: LD_VAR 0 2
75752: PUSH
75753: LD_EXP 65
75757: PUSH
75758: LD_VAR 0 4
75762: ARRAY
75763: IN
75764: IFFALSE 75891
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75766: LD_ADDR_EXP 94
75770: PUSH
75771: LD_EXP 94
75775: PPUSH
75776: LD_VAR 0 4
75780: PUSH
75781: LD_EXP 94
75785: PUSH
75786: LD_VAR 0 4
75790: ARRAY
75791: PUSH
75792: LD_INT 1
75794: PLUS
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: PPUSH
75800: LD_VAR 0 1
75804: PPUSH
75805: CALL 18579 0 3
75809: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75810: LD_ADDR_VAR 0 5
75814: PUSH
75815: LD_EXP 65
75819: PUSH
75820: LD_VAR 0 4
75824: ARRAY
75825: PPUSH
75826: LD_INT 2
75828: PUSH
75829: LD_INT 30
75831: PUSH
75832: LD_INT 0
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 30
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: LIST
75853: PPUSH
75854: CALL_OW 72
75858: PPUSH
75859: LD_VAR 0 1
75863: PPUSH
75864: CALL_OW 74
75868: ST_TO_ADDR
// if tmp then
75869: LD_VAR 0 5
75873: IFFALSE 75889
// ComStandNearbyBuilding ( ape , tmp ) ;
75875: LD_VAR 0 1
75879: PPUSH
75880: LD_VAR 0 5
75884: PPUSH
75885: CALL 15193 0 2
// break ;
75889: GO 75893
// end ; end ;
75891: GO 75745
75893: POP
75894: POP
// end ;
75895: LD_VAR 0 3
75899: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75900: LD_INT 0
75902: PPUSH
75903: PPUSH
75904: PPUSH
// if not mc_bases or not skirmish then
75905: LD_EXP 65
75909: NOT
75910: PUSH
75911: LD_EXP 63
75915: NOT
75916: OR
75917: IFFALSE 75921
// exit ;
75919: GO 76010
// for i = 1 to mc_bases do
75921: LD_ADDR_VAR 0 4
75925: PUSH
75926: DOUBLE
75927: LD_INT 1
75929: DEC
75930: ST_TO_ADDR
75931: LD_EXP 65
75935: PUSH
75936: FOR_TO
75937: IFFALSE 76008
// begin if building in mc_busy_turret_list [ i ] then
75939: LD_VAR 0 1
75943: PUSH
75944: LD_EXP 75
75948: PUSH
75949: LD_VAR 0 4
75953: ARRAY
75954: IN
75955: IFFALSE 76006
// begin tmp := mc_busy_turret_list [ i ] diff building ;
75957: LD_ADDR_VAR 0 5
75961: PUSH
75962: LD_EXP 75
75966: PUSH
75967: LD_VAR 0 4
75971: ARRAY
75972: PUSH
75973: LD_VAR 0 1
75977: DIFF
75978: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
75979: LD_ADDR_EXP 75
75983: PUSH
75984: LD_EXP 75
75988: PPUSH
75989: LD_VAR 0 4
75993: PPUSH
75994: LD_VAR 0 5
75998: PPUSH
75999: CALL_OW 1
76003: ST_TO_ADDR
// break ;
76004: GO 76008
// end ; end ;
76006: GO 75936
76008: POP
76009: POP
// end ;
76010: LD_VAR 0 3
76014: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76015: LD_INT 0
76017: PPUSH
76018: PPUSH
76019: PPUSH
// if not mc_bases or not skirmish then
76020: LD_EXP 65
76024: NOT
76025: PUSH
76026: LD_EXP 63
76030: NOT
76031: OR
76032: IFFALSE 76036
// exit ;
76034: GO 76235
// for i = 1 to mc_bases do
76036: LD_ADDR_VAR 0 5
76040: PUSH
76041: DOUBLE
76042: LD_INT 1
76044: DEC
76045: ST_TO_ADDR
76046: LD_EXP 65
76050: PUSH
76051: FOR_TO
76052: IFFALSE 76233
// if building in mc_bases [ i ] then
76054: LD_VAR 0 1
76058: PUSH
76059: LD_EXP 65
76063: PUSH
76064: LD_VAR 0 5
76068: ARRAY
76069: IN
76070: IFFALSE 76231
// begin tmp := mc_bases [ i ] diff building ;
76072: LD_ADDR_VAR 0 6
76076: PUSH
76077: LD_EXP 65
76081: PUSH
76082: LD_VAR 0 5
76086: ARRAY
76087: PUSH
76088: LD_VAR 0 1
76092: DIFF
76093: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76094: LD_ADDR_EXP 65
76098: PUSH
76099: LD_EXP 65
76103: PPUSH
76104: LD_VAR 0 5
76108: PPUSH
76109: LD_VAR 0 6
76113: PPUSH
76114: CALL_OW 1
76118: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76119: LD_VAR 0 1
76123: PUSH
76124: LD_EXP 73
76128: PUSH
76129: LD_VAR 0 5
76133: ARRAY
76134: IN
76135: IFFALSE 76174
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76137: LD_ADDR_EXP 73
76141: PUSH
76142: LD_EXP 73
76146: PPUSH
76147: LD_VAR 0 5
76151: PPUSH
76152: LD_EXP 73
76156: PUSH
76157: LD_VAR 0 5
76161: ARRAY
76162: PUSH
76163: LD_VAR 0 1
76167: DIFF
76168: PPUSH
76169: CALL_OW 1
76173: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76174: LD_VAR 0 1
76178: PUSH
76179: LD_EXP 74
76183: PUSH
76184: LD_VAR 0 5
76188: ARRAY
76189: IN
76190: IFFALSE 76229
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76192: LD_ADDR_EXP 74
76196: PUSH
76197: LD_EXP 74
76201: PPUSH
76202: LD_VAR 0 5
76206: PPUSH
76207: LD_EXP 74
76211: PUSH
76212: LD_VAR 0 5
76216: ARRAY
76217: PUSH
76218: LD_VAR 0 1
76222: DIFF
76223: PPUSH
76224: CALL_OW 1
76228: ST_TO_ADDR
// break ;
76229: GO 76233
// end ;
76231: GO 76051
76233: POP
76234: POP
// end ;
76235: LD_VAR 0 4
76239: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76240: LD_INT 0
76242: PPUSH
76243: PPUSH
76244: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76245: LD_EXP 65
76249: NOT
76250: PUSH
76251: LD_EXP 63
76255: NOT
76256: OR
76257: PUSH
76258: LD_VAR 0 3
76262: PUSH
76263: LD_EXP 91
76267: IN
76268: NOT
76269: OR
76270: IFFALSE 76274
// exit ;
76272: GO 76397
// for i = 1 to mc_vehicles do
76274: LD_ADDR_VAR 0 6
76278: PUSH
76279: DOUBLE
76280: LD_INT 1
76282: DEC
76283: ST_TO_ADDR
76284: LD_EXP 84
76288: PUSH
76289: FOR_TO
76290: IFFALSE 76395
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76292: LD_VAR 0 2
76296: PUSH
76297: LD_EXP 84
76301: PUSH
76302: LD_VAR 0 6
76306: ARRAY
76307: IN
76308: PUSH
76309: LD_VAR 0 1
76313: PUSH
76314: LD_EXP 84
76318: PUSH
76319: LD_VAR 0 6
76323: ARRAY
76324: IN
76325: OR
76326: IFFALSE 76393
// begin tmp := mc_vehicles [ i ] diff old ;
76328: LD_ADDR_VAR 0 7
76332: PUSH
76333: LD_EXP 84
76337: PUSH
76338: LD_VAR 0 6
76342: ARRAY
76343: PUSH
76344: LD_VAR 0 2
76348: DIFF
76349: ST_TO_ADDR
// tmp := tmp diff new ;
76350: LD_ADDR_VAR 0 7
76354: PUSH
76355: LD_VAR 0 7
76359: PUSH
76360: LD_VAR 0 1
76364: DIFF
76365: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76366: LD_ADDR_EXP 84
76370: PUSH
76371: LD_EXP 84
76375: PPUSH
76376: LD_VAR 0 6
76380: PPUSH
76381: LD_VAR 0 7
76385: PPUSH
76386: CALL_OW 1
76390: ST_TO_ADDR
// break ;
76391: GO 76395
// end ;
76393: GO 76289
76395: POP
76396: POP
// end ;
76397: LD_VAR 0 5
76401: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76402: LD_INT 0
76404: PPUSH
76405: PPUSH
76406: PPUSH
76407: PPUSH
// if not mc_bases or not skirmish then
76408: LD_EXP 65
76412: NOT
76413: PUSH
76414: LD_EXP 63
76418: NOT
76419: OR
76420: IFFALSE 76424
// exit ;
76422: GO 76801
// side := GetSide ( vehicle ) ;
76424: LD_ADDR_VAR 0 5
76428: PUSH
76429: LD_VAR 0 1
76433: PPUSH
76434: CALL_OW 255
76438: ST_TO_ADDR
// for i = 1 to mc_bases do
76439: LD_ADDR_VAR 0 4
76443: PUSH
76444: DOUBLE
76445: LD_INT 1
76447: DEC
76448: ST_TO_ADDR
76449: LD_EXP 65
76453: PUSH
76454: FOR_TO
76455: IFFALSE 76799
// begin if factory in mc_bases [ i ] then
76457: LD_VAR 0 2
76461: PUSH
76462: LD_EXP 65
76466: PUSH
76467: LD_VAR 0 4
76471: ARRAY
76472: IN
76473: IFFALSE 76797
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76475: LD_EXP 87
76479: PUSH
76480: LD_VAR 0 4
76484: ARRAY
76485: PUSH
76486: LD_EXP 76
76490: PUSH
76491: LD_VAR 0 4
76495: ARRAY
76496: LESS
76497: PUSH
76498: LD_VAR 0 1
76502: PPUSH
76503: CALL_OW 264
76507: PUSH
76508: LD_INT 31
76510: PUSH
76511: LD_INT 32
76513: PUSH
76514: LD_INT 51
76516: PUSH
76517: LD_EXP 49
76521: PUSH
76522: LD_INT 12
76524: PUSH
76525: LD_INT 30
76527: PUSH
76528: LD_EXP 48
76532: PUSH
76533: LD_INT 11
76535: PUSH
76536: LD_INT 53
76538: PUSH
76539: LD_INT 14
76541: PUSH
76542: LD_EXP 52
76546: PUSH
76547: LD_INT 29
76549: PUSH
76550: LD_EXP 50
76554: PUSH
76555: LD_INT 13
76557: PUSH
76558: LD_INT 52
76560: PUSH
76561: LD_INT 48
76563: PUSH
76564: LD_INT 8
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: IN
76586: NOT
76587: AND
76588: IFFALSE 76636
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76590: LD_ADDR_EXP 87
76594: PUSH
76595: LD_EXP 87
76599: PPUSH
76600: LD_VAR 0 4
76604: PUSH
76605: LD_EXP 87
76609: PUSH
76610: LD_VAR 0 4
76614: ARRAY
76615: PUSH
76616: LD_INT 1
76618: PLUS
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PPUSH
76624: LD_VAR 0 1
76628: PPUSH
76629: CALL 18579 0 3
76633: ST_TO_ADDR
76634: GO 76680
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76636: LD_ADDR_EXP 84
76640: PUSH
76641: LD_EXP 84
76645: PPUSH
76646: LD_VAR 0 4
76650: PUSH
76651: LD_EXP 84
76655: PUSH
76656: LD_VAR 0 4
76660: ARRAY
76661: PUSH
76662: LD_INT 1
76664: PLUS
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PPUSH
76670: LD_VAR 0 1
76674: PPUSH
76675: CALL 18579 0 3
76679: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76680: LD_VAR 0 1
76684: PPUSH
76685: CALL_OW 263
76689: PUSH
76690: LD_INT 2
76692: EQUAL
76693: IFFALSE 76713
// begin repeat wait ( 0 0$1 ) ;
76695: LD_INT 35
76697: PPUSH
76698: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76702: LD_VAR 0 1
76706: PPUSH
76707: CALL_OW 312
76711: IFFALSE 76695
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76713: LD_VAR 0 1
76717: PPUSH
76718: LD_EXP 89
76722: PUSH
76723: LD_VAR 0 4
76727: ARRAY
76728: PPUSH
76729: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76733: LD_VAR 0 1
76737: PPUSH
76738: CALL_OW 263
76742: PUSH
76743: LD_INT 1
76745: NONEQUAL
76746: IFFALSE 76750
// break ;
76748: GO 76799
// repeat wait ( 0 0$1 ) ;
76750: LD_INT 35
76752: PPUSH
76753: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76757: LD_VAR 0 1
76761: PPUSH
76762: LD_EXP 89
76766: PUSH
76767: LD_VAR 0 4
76771: ARRAY
76772: PPUSH
76773: CALL_OW 308
76777: IFFALSE 76750
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76779: LD_VAR 0 1
76783: PPUSH
76784: CALL_OW 311
76788: PPUSH
76789: CALL_OW 121
// exit ;
76793: POP
76794: POP
76795: GO 76801
// end ; end ;
76797: GO 76454
76799: POP
76800: POP
// end ;
76801: LD_VAR 0 3
76805: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76806: LD_INT 0
76808: PPUSH
76809: PPUSH
76810: PPUSH
76811: PPUSH
// if not mc_bases or not skirmish then
76812: LD_EXP 65
76816: NOT
76817: PUSH
76818: LD_EXP 63
76822: NOT
76823: OR
76824: IFFALSE 76828
// exit ;
76826: GO 77181
// repeat wait ( 0 0$1 ) ;
76828: LD_INT 35
76830: PPUSH
76831: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76835: LD_VAR 0 2
76839: PPUSH
76840: LD_VAR 0 3
76844: PPUSH
76845: CALL_OW 284
76849: IFFALSE 76828
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76851: LD_VAR 0 2
76855: PPUSH
76856: LD_VAR 0 3
76860: PPUSH
76861: CALL_OW 283
76865: PUSH
76866: LD_INT 4
76868: EQUAL
76869: IFFALSE 76873
// exit ;
76871: GO 77181
// for i = 1 to mc_bases do
76873: LD_ADDR_VAR 0 7
76877: PUSH
76878: DOUBLE
76879: LD_INT 1
76881: DEC
76882: ST_TO_ADDR
76883: LD_EXP 65
76887: PUSH
76888: FOR_TO
76889: IFFALSE 77179
// begin if mc_crates_area [ i ] then
76891: LD_EXP 83
76895: PUSH
76896: LD_VAR 0 7
76900: ARRAY
76901: IFFALSE 77012
// for j in mc_crates_area [ i ] do
76903: LD_ADDR_VAR 0 8
76907: PUSH
76908: LD_EXP 83
76912: PUSH
76913: LD_VAR 0 7
76917: ARRAY
76918: PUSH
76919: FOR_IN
76920: IFFALSE 77010
// if InArea ( x , y , j ) then
76922: LD_VAR 0 2
76926: PPUSH
76927: LD_VAR 0 3
76931: PPUSH
76932: LD_VAR 0 8
76936: PPUSH
76937: CALL_OW 309
76941: IFFALSE 77008
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76943: LD_ADDR_EXP 81
76947: PUSH
76948: LD_EXP 81
76952: PPUSH
76953: LD_VAR 0 7
76957: PUSH
76958: LD_EXP 81
76962: PUSH
76963: LD_VAR 0 7
76967: ARRAY
76968: PUSH
76969: LD_INT 1
76971: PLUS
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PPUSH
76977: LD_VAR 0 4
76981: PUSH
76982: LD_VAR 0 2
76986: PUSH
76987: LD_VAR 0 3
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: LIST
76996: PPUSH
76997: CALL 18579 0 3
77001: ST_TO_ADDR
// exit ;
77002: POP
77003: POP
77004: POP
77005: POP
77006: GO 77181
// end ;
77008: GO 76919
77010: POP
77011: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77012: LD_ADDR_VAR 0 9
77016: PUSH
77017: LD_EXP 65
77021: PUSH
77022: LD_VAR 0 7
77026: ARRAY
77027: PPUSH
77028: LD_INT 2
77030: PUSH
77031: LD_INT 30
77033: PUSH
77034: LD_INT 0
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 30
77043: PUSH
77044: LD_INT 1
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: EMPTY
77052: LIST
77053: LIST
77054: LIST
77055: PPUSH
77056: CALL_OW 72
77060: ST_TO_ADDR
// if not depot then
77061: LD_VAR 0 9
77065: NOT
77066: IFFALSE 77070
// continue ;
77068: GO 76888
// for j in depot do
77070: LD_ADDR_VAR 0 8
77074: PUSH
77075: LD_VAR 0 9
77079: PUSH
77080: FOR_IN
77081: IFFALSE 77175
// if GetDistUnitXY ( j , x , y ) < 30 then
77083: LD_VAR 0 8
77087: PPUSH
77088: LD_VAR 0 2
77092: PPUSH
77093: LD_VAR 0 3
77097: PPUSH
77098: CALL_OW 297
77102: PUSH
77103: LD_INT 30
77105: LESS
77106: IFFALSE 77173
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77108: LD_ADDR_EXP 81
77112: PUSH
77113: LD_EXP 81
77117: PPUSH
77118: LD_VAR 0 7
77122: PUSH
77123: LD_EXP 81
77127: PUSH
77128: LD_VAR 0 7
77132: ARRAY
77133: PUSH
77134: LD_INT 1
77136: PLUS
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PPUSH
77142: LD_VAR 0 4
77146: PUSH
77147: LD_VAR 0 2
77151: PUSH
77152: LD_VAR 0 3
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: PPUSH
77162: CALL 18579 0 3
77166: ST_TO_ADDR
// exit ;
77167: POP
77168: POP
77169: POP
77170: POP
77171: GO 77181
// end ;
77173: GO 77080
77175: POP
77176: POP
// end ;
77177: GO 76888
77179: POP
77180: POP
// end ;
77181: LD_VAR 0 6
77185: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77186: LD_INT 0
77188: PPUSH
77189: PPUSH
77190: PPUSH
77191: PPUSH
// if not mc_bases or not skirmish then
77192: LD_EXP 65
77196: NOT
77197: PUSH
77198: LD_EXP 63
77202: NOT
77203: OR
77204: IFFALSE 77208
// exit ;
77206: GO 77485
// side := GetSide ( lab ) ;
77208: LD_ADDR_VAR 0 4
77212: PUSH
77213: LD_VAR 0 2
77217: PPUSH
77218: CALL_OW 255
77222: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77223: LD_VAR 0 4
77227: PUSH
77228: LD_EXP 91
77232: IN
77233: NOT
77234: PUSH
77235: LD_EXP 92
77239: NOT
77240: OR
77241: PUSH
77242: LD_EXP 65
77246: NOT
77247: OR
77248: IFFALSE 77252
// exit ;
77250: GO 77485
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77252: LD_ADDR_EXP 92
77256: PUSH
77257: LD_EXP 92
77261: PPUSH
77262: LD_VAR 0 4
77266: PPUSH
77267: LD_EXP 92
77271: PUSH
77272: LD_VAR 0 4
77276: ARRAY
77277: PUSH
77278: LD_VAR 0 1
77282: DIFF
77283: PPUSH
77284: CALL_OW 1
77288: ST_TO_ADDR
// for i = 1 to mc_bases do
77289: LD_ADDR_VAR 0 5
77293: PUSH
77294: DOUBLE
77295: LD_INT 1
77297: DEC
77298: ST_TO_ADDR
77299: LD_EXP 65
77303: PUSH
77304: FOR_TO
77305: IFFALSE 77483
// begin if lab in mc_bases [ i ] then
77307: LD_VAR 0 2
77311: PUSH
77312: LD_EXP 65
77316: PUSH
77317: LD_VAR 0 5
77321: ARRAY
77322: IN
77323: IFFALSE 77481
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77325: LD_VAR 0 1
77329: PUSH
77330: LD_INT 11
77332: PUSH
77333: LD_INT 4
77335: PUSH
77336: LD_INT 3
77338: PUSH
77339: LD_INT 2
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: IN
77348: PUSH
77349: LD_EXP 95
77353: PUSH
77354: LD_VAR 0 5
77358: ARRAY
77359: AND
77360: IFFALSE 77481
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77362: LD_ADDR_VAR 0 6
77366: PUSH
77367: LD_EXP 95
77371: PUSH
77372: LD_VAR 0 5
77376: ARRAY
77377: PUSH
77378: LD_INT 1
77380: ARRAY
77381: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77382: LD_ADDR_EXP 95
77386: PUSH
77387: LD_EXP 95
77391: PPUSH
77392: LD_VAR 0 5
77396: PPUSH
77397: EMPTY
77398: PPUSH
77399: CALL_OW 1
77403: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77404: LD_VAR 0 6
77408: PPUSH
77409: LD_INT 0
77411: PPUSH
77412: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77416: LD_VAR 0 6
77420: PPUSH
77421: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77425: LD_ADDR_EXP 94
77429: PUSH
77430: LD_EXP 94
77434: PPUSH
77435: LD_VAR 0 5
77439: PPUSH
77440: LD_EXP 94
77444: PUSH
77445: LD_VAR 0 5
77449: ARRAY
77450: PPUSH
77451: LD_INT 1
77453: PPUSH
77454: LD_VAR 0 6
77458: PPUSH
77459: CALL_OW 2
77463: PPUSH
77464: CALL_OW 1
77468: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77469: LD_VAR 0 5
77473: PPUSH
77474: LD_INT 112
77476: PPUSH
77477: CALL 54497 0 2
// end ; end ; end ;
77481: GO 77304
77483: POP
77484: POP
// end ;
77485: LD_VAR 0 3
77489: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77490: LD_INT 0
77492: PPUSH
77493: PPUSH
77494: PPUSH
77495: PPUSH
77496: PPUSH
77497: PPUSH
77498: PPUSH
77499: PPUSH
// if not mc_bases or not skirmish then
77500: LD_EXP 65
77504: NOT
77505: PUSH
77506: LD_EXP 63
77510: NOT
77511: OR
77512: IFFALSE 77516
// exit ;
77514: GO 78887
// for i = 1 to mc_bases do
77516: LD_ADDR_VAR 0 3
77520: PUSH
77521: DOUBLE
77522: LD_INT 1
77524: DEC
77525: ST_TO_ADDR
77526: LD_EXP 65
77530: PUSH
77531: FOR_TO
77532: IFFALSE 78885
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77534: LD_VAR 0 1
77538: PUSH
77539: LD_EXP 65
77543: PUSH
77544: LD_VAR 0 3
77548: ARRAY
77549: IN
77550: PUSH
77551: LD_VAR 0 1
77555: PUSH
77556: LD_EXP 72
77560: PUSH
77561: LD_VAR 0 3
77565: ARRAY
77566: IN
77567: OR
77568: PUSH
77569: LD_VAR 0 1
77573: PUSH
77574: LD_EXP 87
77578: PUSH
77579: LD_VAR 0 3
77583: ARRAY
77584: IN
77585: OR
77586: PUSH
77587: LD_VAR 0 1
77591: PUSH
77592: LD_EXP 84
77596: PUSH
77597: LD_VAR 0 3
77601: ARRAY
77602: IN
77603: OR
77604: PUSH
77605: LD_VAR 0 1
77609: PUSH
77610: LD_EXP 94
77614: PUSH
77615: LD_VAR 0 3
77619: ARRAY
77620: IN
77621: OR
77622: PUSH
77623: LD_VAR 0 1
77627: PUSH
77628: LD_EXP 95
77632: PUSH
77633: LD_VAR 0 3
77637: ARRAY
77638: IN
77639: OR
77640: IFFALSE 78883
// begin if un in mc_ape [ i ] then
77642: LD_VAR 0 1
77646: PUSH
77647: LD_EXP 94
77651: PUSH
77652: LD_VAR 0 3
77656: ARRAY
77657: IN
77658: IFFALSE 77697
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77660: LD_ADDR_EXP 94
77664: PUSH
77665: LD_EXP 94
77669: PPUSH
77670: LD_VAR 0 3
77674: PPUSH
77675: LD_EXP 94
77679: PUSH
77680: LD_VAR 0 3
77684: ARRAY
77685: PUSH
77686: LD_VAR 0 1
77690: DIFF
77691: PPUSH
77692: CALL_OW 1
77696: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77697: LD_VAR 0 1
77701: PUSH
77702: LD_EXP 95
77706: PUSH
77707: LD_VAR 0 3
77711: ARRAY
77712: IN
77713: IFFALSE 77737
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77715: LD_ADDR_EXP 95
77719: PUSH
77720: LD_EXP 95
77724: PPUSH
77725: LD_VAR 0 3
77729: PPUSH
77730: EMPTY
77731: PPUSH
77732: CALL_OW 1
77736: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77737: LD_VAR 0 1
77741: PPUSH
77742: CALL_OW 247
77746: PUSH
77747: LD_INT 2
77749: EQUAL
77750: PUSH
77751: LD_VAR 0 1
77755: PPUSH
77756: CALL_OW 110
77760: PUSH
77761: LD_INT 20
77763: EQUAL
77764: PUSH
77765: LD_VAR 0 1
77769: PUSH
77770: LD_EXP 87
77774: PUSH
77775: LD_VAR 0 3
77779: ARRAY
77780: IN
77781: OR
77782: PUSH
77783: LD_VAR 0 1
77787: PPUSH
77788: CALL_OW 264
77792: PUSH
77793: LD_INT 12
77795: PUSH
77796: LD_INT 51
77798: PUSH
77799: LD_EXP 49
77803: PUSH
77804: LD_INT 32
77806: PUSH
77807: LD_INT 13
77809: PUSH
77810: LD_INT 52
77812: PUSH
77813: LD_INT 31
77815: PUSH
77816: EMPTY
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: IN
77825: OR
77826: AND
77827: IFFALSE 78135
// begin if un in mc_defender [ i ] then
77829: LD_VAR 0 1
77833: PUSH
77834: LD_EXP 87
77838: PUSH
77839: LD_VAR 0 3
77843: ARRAY
77844: IN
77845: IFFALSE 77884
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77847: LD_ADDR_EXP 87
77851: PUSH
77852: LD_EXP 87
77856: PPUSH
77857: LD_VAR 0 3
77861: PPUSH
77862: LD_EXP 87
77866: PUSH
77867: LD_VAR 0 3
77871: ARRAY
77872: PUSH
77873: LD_VAR 0 1
77877: DIFF
77878: PPUSH
77879: CALL_OW 1
77883: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77884: LD_ADDR_VAR 0 8
77888: PUSH
77889: LD_VAR 0 3
77893: PPUSH
77894: LD_INT 3
77896: PPUSH
77897: CALL 74553 0 2
77901: ST_TO_ADDR
// if fac then
77902: LD_VAR 0 8
77906: IFFALSE 78135
// begin for j in fac do
77908: LD_ADDR_VAR 0 4
77912: PUSH
77913: LD_VAR 0 8
77917: PUSH
77918: FOR_IN
77919: IFFALSE 78133
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77921: LD_ADDR_VAR 0 9
77925: PUSH
77926: LD_VAR 0 8
77930: PPUSH
77931: LD_VAR 0 1
77935: PPUSH
77936: CALL_OW 265
77940: PPUSH
77941: LD_VAR 0 1
77945: PPUSH
77946: CALL_OW 262
77950: PPUSH
77951: LD_VAR 0 1
77955: PPUSH
77956: CALL_OW 263
77960: PPUSH
77961: LD_VAR 0 1
77965: PPUSH
77966: CALL_OW 264
77970: PPUSH
77971: CALL 16111 0 5
77975: ST_TO_ADDR
// if components then
77976: LD_VAR 0 9
77980: IFFALSE 78131
// begin if GetWeapon ( un ) = ar_control_tower then
77982: LD_VAR 0 1
77986: PPUSH
77987: CALL_OW 264
77991: PUSH
77992: LD_INT 31
77994: EQUAL
77995: IFFALSE 78112
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
77997: LD_VAR 0 1
78001: PPUSH
78002: CALL_OW 311
78006: PPUSH
78007: LD_INT 0
78009: PPUSH
78010: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78014: LD_ADDR_EXP 105
78018: PUSH
78019: LD_EXP 105
78023: PPUSH
78024: LD_VAR 0 3
78028: PPUSH
78029: LD_EXP 105
78033: PUSH
78034: LD_VAR 0 3
78038: ARRAY
78039: PUSH
78040: LD_VAR 0 1
78044: PPUSH
78045: CALL_OW 311
78049: DIFF
78050: PPUSH
78051: CALL_OW 1
78055: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78056: LD_ADDR_VAR 0 7
78060: PUSH
78061: LD_EXP 86
78065: PUSH
78066: LD_VAR 0 3
78070: ARRAY
78071: PPUSH
78072: LD_INT 1
78074: PPUSH
78075: LD_VAR 0 9
78079: PPUSH
78080: CALL_OW 2
78084: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78085: LD_ADDR_EXP 86
78089: PUSH
78090: LD_EXP 86
78094: PPUSH
78095: LD_VAR 0 3
78099: PPUSH
78100: LD_VAR 0 7
78104: PPUSH
78105: CALL_OW 1
78109: ST_TO_ADDR
// end else
78110: GO 78129
// MC_InsertProduceList ( i , [ components ] ) ;
78112: LD_VAR 0 3
78116: PPUSH
78117: LD_VAR 0 9
78121: PUSH
78122: EMPTY
78123: LIST
78124: PPUSH
78125: CALL 74098 0 2
// break ;
78129: GO 78133
// end ; end ;
78131: GO 77918
78133: POP
78134: POP
// end ; end ; if GetType ( un ) = unit_building then
78135: LD_VAR 0 1
78139: PPUSH
78140: CALL_OW 247
78144: PUSH
78145: LD_INT 3
78147: EQUAL
78148: IFFALSE 78551
// begin btype := GetBType ( un ) ;
78150: LD_ADDR_VAR 0 5
78154: PUSH
78155: LD_VAR 0 1
78159: PPUSH
78160: CALL_OW 266
78164: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78165: LD_VAR 0 5
78169: PUSH
78170: LD_INT 29
78172: PUSH
78173: LD_INT 30
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: IN
78180: IFFALSE 78253
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78182: LD_VAR 0 1
78186: PPUSH
78187: CALL_OW 250
78191: PPUSH
78192: LD_VAR 0 1
78196: PPUSH
78197: CALL_OW 251
78201: PPUSH
78202: LD_VAR 0 1
78206: PPUSH
78207: CALL_OW 255
78211: PPUSH
78212: CALL_OW 440
78216: NOT
78217: IFFALSE 78253
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78219: LD_VAR 0 1
78223: PPUSH
78224: CALL_OW 250
78228: PPUSH
78229: LD_VAR 0 1
78233: PPUSH
78234: CALL_OW 251
78238: PPUSH
78239: LD_VAR 0 1
78243: PPUSH
78244: CALL_OW 255
78248: PPUSH
78249: CALL_OW 441
// end ; if btype = b_warehouse then
78253: LD_VAR 0 5
78257: PUSH
78258: LD_INT 1
78260: EQUAL
78261: IFFALSE 78279
// begin btype := b_depot ;
78263: LD_ADDR_VAR 0 5
78267: PUSH
78268: LD_INT 0
78270: ST_TO_ADDR
// pos := 1 ;
78271: LD_ADDR_VAR 0 6
78275: PUSH
78276: LD_INT 1
78278: ST_TO_ADDR
// end ; if btype = b_factory then
78279: LD_VAR 0 5
78283: PUSH
78284: LD_INT 3
78286: EQUAL
78287: IFFALSE 78305
// begin btype := b_workshop ;
78289: LD_ADDR_VAR 0 5
78293: PUSH
78294: LD_INT 2
78296: ST_TO_ADDR
// pos := 1 ;
78297: LD_ADDR_VAR 0 6
78301: PUSH
78302: LD_INT 1
78304: ST_TO_ADDR
// end ; if btype = b_barracks then
78305: LD_VAR 0 5
78309: PUSH
78310: LD_INT 5
78312: EQUAL
78313: IFFALSE 78323
// btype := b_armoury ;
78315: LD_ADDR_VAR 0 5
78319: PUSH
78320: LD_INT 4
78322: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78323: LD_VAR 0 5
78327: PUSH
78328: LD_INT 7
78330: PUSH
78331: LD_INT 8
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: IN
78338: IFFALSE 78348
// btype := b_lab ;
78340: LD_ADDR_VAR 0 5
78344: PUSH
78345: LD_INT 6
78347: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78348: LD_ADDR_EXP 70
78352: PUSH
78353: LD_EXP 70
78357: PPUSH
78358: LD_VAR 0 3
78362: PUSH
78363: LD_EXP 70
78367: PUSH
78368: LD_VAR 0 3
78372: ARRAY
78373: PUSH
78374: LD_INT 1
78376: PLUS
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PPUSH
78382: LD_VAR 0 5
78386: PUSH
78387: LD_VAR 0 1
78391: PPUSH
78392: CALL_OW 250
78396: PUSH
78397: LD_VAR 0 1
78401: PPUSH
78402: CALL_OW 251
78406: PUSH
78407: LD_VAR 0 1
78411: PPUSH
78412: CALL_OW 254
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: PPUSH
78423: CALL 18579 0 3
78427: ST_TO_ADDR
// if pos = 1 then
78428: LD_VAR 0 6
78432: PUSH
78433: LD_INT 1
78435: EQUAL
78436: IFFALSE 78551
// begin tmp := mc_build_list [ i ] ;
78438: LD_ADDR_VAR 0 7
78442: PUSH
78443: LD_EXP 70
78447: PUSH
78448: LD_VAR 0 3
78452: ARRAY
78453: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78454: LD_VAR 0 7
78458: PPUSH
78459: LD_INT 2
78461: PUSH
78462: LD_INT 30
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 30
78474: PUSH
78475: LD_INT 1
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: LIST
78486: PPUSH
78487: CALL_OW 72
78491: IFFALSE 78501
// pos := 2 ;
78493: LD_ADDR_VAR 0 6
78497: PUSH
78498: LD_INT 2
78500: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78501: LD_ADDR_VAR 0 7
78505: PUSH
78506: LD_VAR 0 7
78510: PPUSH
78511: LD_VAR 0 6
78515: PPUSH
78516: LD_VAR 0 7
78520: PPUSH
78521: CALL 18905 0 3
78525: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78526: LD_ADDR_EXP 70
78530: PUSH
78531: LD_EXP 70
78535: PPUSH
78536: LD_VAR 0 3
78540: PPUSH
78541: LD_VAR 0 7
78545: PPUSH
78546: CALL_OW 1
78550: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78551: LD_VAR 0 1
78555: PUSH
78556: LD_EXP 65
78560: PUSH
78561: LD_VAR 0 3
78565: ARRAY
78566: IN
78567: IFFALSE 78606
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78569: LD_ADDR_EXP 65
78573: PUSH
78574: LD_EXP 65
78578: PPUSH
78579: LD_VAR 0 3
78583: PPUSH
78584: LD_EXP 65
78588: PUSH
78589: LD_VAR 0 3
78593: ARRAY
78594: PUSH
78595: LD_VAR 0 1
78599: DIFF
78600: PPUSH
78601: CALL_OW 1
78605: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78606: LD_VAR 0 1
78610: PUSH
78611: LD_EXP 72
78615: PUSH
78616: LD_VAR 0 3
78620: ARRAY
78621: IN
78622: IFFALSE 78661
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78624: LD_ADDR_EXP 72
78628: PUSH
78629: LD_EXP 72
78633: PPUSH
78634: LD_VAR 0 3
78638: PPUSH
78639: LD_EXP 72
78643: PUSH
78644: LD_VAR 0 3
78648: ARRAY
78649: PUSH
78650: LD_VAR 0 1
78654: DIFF
78655: PPUSH
78656: CALL_OW 1
78660: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78661: LD_VAR 0 1
78665: PUSH
78666: LD_EXP 84
78670: PUSH
78671: LD_VAR 0 3
78675: ARRAY
78676: IN
78677: IFFALSE 78716
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78679: LD_ADDR_EXP 84
78683: PUSH
78684: LD_EXP 84
78688: PPUSH
78689: LD_VAR 0 3
78693: PPUSH
78694: LD_EXP 84
78698: PUSH
78699: LD_VAR 0 3
78703: ARRAY
78704: PUSH
78705: LD_VAR 0 1
78709: DIFF
78710: PPUSH
78711: CALL_OW 1
78715: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78716: LD_VAR 0 1
78720: PUSH
78721: LD_EXP 87
78725: PUSH
78726: LD_VAR 0 3
78730: ARRAY
78731: IN
78732: IFFALSE 78771
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78734: LD_ADDR_EXP 87
78738: PUSH
78739: LD_EXP 87
78743: PPUSH
78744: LD_VAR 0 3
78748: PPUSH
78749: LD_EXP 87
78753: PUSH
78754: LD_VAR 0 3
78758: ARRAY
78759: PUSH
78760: LD_VAR 0 1
78764: DIFF
78765: PPUSH
78766: CALL_OW 1
78770: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78771: LD_VAR 0 1
78775: PUSH
78776: LD_EXP 74
78780: PUSH
78781: LD_VAR 0 3
78785: ARRAY
78786: IN
78787: IFFALSE 78826
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78789: LD_ADDR_EXP 74
78793: PUSH
78794: LD_EXP 74
78798: PPUSH
78799: LD_VAR 0 3
78803: PPUSH
78804: LD_EXP 74
78808: PUSH
78809: LD_VAR 0 3
78813: ARRAY
78814: PUSH
78815: LD_VAR 0 1
78819: DIFF
78820: PPUSH
78821: CALL_OW 1
78825: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78826: LD_VAR 0 1
78830: PUSH
78831: LD_EXP 73
78835: PUSH
78836: LD_VAR 0 3
78840: ARRAY
78841: IN
78842: IFFALSE 78881
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78844: LD_ADDR_EXP 73
78848: PUSH
78849: LD_EXP 73
78853: PPUSH
78854: LD_VAR 0 3
78858: PPUSH
78859: LD_EXP 73
78863: PUSH
78864: LD_VAR 0 3
78868: ARRAY
78869: PUSH
78870: LD_VAR 0 1
78874: DIFF
78875: PPUSH
78876: CALL_OW 1
78880: ST_TO_ADDR
// end ; break ;
78881: GO 78885
// end ;
78883: GO 77531
78885: POP
78886: POP
// end ;
78887: LD_VAR 0 2
78891: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78892: LD_INT 0
78894: PPUSH
78895: PPUSH
78896: PPUSH
// if not mc_bases or not skirmish then
78897: LD_EXP 65
78901: NOT
78902: PUSH
78903: LD_EXP 63
78907: NOT
78908: OR
78909: IFFALSE 78913
// exit ;
78911: GO 79128
// for i = 1 to mc_bases do
78913: LD_ADDR_VAR 0 3
78917: PUSH
78918: DOUBLE
78919: LD_INT 1
78921: DEC
78922: ST_TO_ADDR
78923: LD_EXP 65
78927: PUSH
78928: FOR_TO
78929: IFFALSE 79126
// begin if building in mc_construct_list [ i ] then
78931: LD_VAR 0 1
78935: PUSH
78936: LD_EXP 72
78940: PUSH
78941: LD_VAR 0 3
78945: ARRAY
78946: IN
78947: IFFALSE 79124
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78949: LD_ADDR_EXP 72
78953: PUSH
78954: LD_EXP 72
78958: PPUSH
78959: LD_VAR 0 3
78963: PPUSH
78964: LD_EXP 72
78968: PUSH
78969: LD_VAR 0 3
78973: ARRAY
78974: PUSH
78975: LD_VAR 0 1
78979: DIFF
78980: PPUSH
78981: CALL_OW 1
78985: ST_TO_ADDR
// if building in mc_lab [ i ] then
78986: LD_VAR 0 1
78990: PUSH
78991: LD_EXP 98
78995: PUSH
78996: LD_VAR 0 3
79000: ARRAY
79001: IN
79002: IFFALSE 79057
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79004: LD_ADDR_EXP 99
79008: PUSH
79009: LD_EXP 99
79013: PPUSH
79014: LD_VAR 0 3
79018: PPUSH
79019: LD_EXP 99
79023: PUSH
79024: LD_VAR 0 3
79028: ARRAY
79029: PPUSH
79030: LD_INT 1
79032: PPUSH
79033: LD_EXP 99
79037: PUSH
79038: LD_VAR 0 3
79042: ARRAY
79043: PPUSH
79044: LD_INT 0
79046: PPUSH
79047: CALL 17997 0 4
79051: PPUSH
79052: CALL_OW 1
79056: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79057: LD_VAR 0 1
79061: PUSH
79062: LD_EXP 65
79066: PUSH
79067: LD_VAR 0 3
79071: ARRAY
79072: IN
79073: NOT
79074: IFFALSE 79120
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79076: LD_ADDR_EXP 65
79080: PUSH
79081: LD_EXP 65
79085: PPUSH
79086: LD_VAR 0 3
79090: PUSH
79091: LD_EXP 65
79095: PUSH
79096: LD_VAR 0 3
79100: ARRAY
79101: PUSH
79102: LD_INT 1
79104: PLUS
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PPUSH
79110: LD_VAR 0 1
79114: PPUSH
79115: CALL 18579 0 3
79119: ST_TO_ADDR
// exit ;
79120: POP
79121: POP
79122: GO 79128
// end ; end ;
79124: GO 78928
79126: POP
79127: POP
// end ;
79128: LD_VAR 0 2
79132: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79133: LD_INT 0
79135: PPUSH
79136: PPUSH
79137: PPUSH
79138: PPUSH
79139: PPUSH
79140: PPUSH
79141: PPUSH
// if not mc_bases or not skirmish then
79142: LD_EXP 65
79146: NOT
79147: PUSH
79148: LD_EXP 63
79152: NOT
79153: OR
79154: IFFALSE 79158
// exit ;
79156: GO 79819
// for i = 1 to mc_bases do
79158: LD_ADDR_VAR 0 3
79162: PUSH
79163: DOUBLE
79164: LD_INT 1
79166: DEC
79167: ST_TO_ADDR
79168: LD_EXP 65
79172: PUSH
79173: FOR_TO
79174: IFFALSE 79817
// begin if building in mc_construct_list [ i ] then
79176: LD_VAR 0 1
79180: PUSH
79181: LD_EXP 72
79185: PUSH
79186: LD_VAR 0 3
79190: ARRAY
79191: IN
79192: IFFALSE 79815
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79194: LD_ADDR_EXP 72
79198: PUSH
79199: LD_EXP 72
79203: PPUSH
79204: LD_VAR 0 3
79208: PPUSH
79209: LD_EXP 72
79213: PUSH
79214: LD_VAR 0 3
79218: ARRAY
79219: PUSH
79220: LD_VAR 0 1
79224: DIFF
79225: PPUSH
79226: CALL_OW 1
79230: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79231: LD_ADDR_EXP 65
79235: PUSH
79236: LD_EXP 65
79240: PPUSH
79241: LD_VAR 0 3
79245: PUSH
79246: LD_EXP 65
79250: PUSH
79251: LD_VAR 0 3
79255: ARRAY
79256: PUSH
79257: LD_INT 1
79259: PLUS
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PPUSH
79265: LD_VAR 0 1
79269: PPUSH
79270: CALL 18579 0 3
79274: ST_TO_ADDR
// btype := GetBType ( building ) ;
79275: LD_ADDR_VAR 0 5
79279: PUSH
79280: LD_VAR 0 1
79284: PPUSH
79285: CALL_OW 266
79289: ST_TO_ADDR
// side := GetSide ( building ) ;
79290: LD_ADDR_VAR 0 8
79294: PUSH
79295: LD_VAR 0 1
79299: PPUSH
79300: CALL_OW 255
79304: ST_TO_ADDR
// if btype = b_lab then
79305: LD_VAR 0 5
79309: PUSH
79310: LD_INT 6
79312: EQUAL
79313: IFFALSE 79363
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79315: LD_ADDR_EXP 98
79319: PUSH
79320: LD_EXP 98
79324: PPUSH
79325: LD_VAR 0 3
79329: PUSH
79330: LD_EXP 98
79334: PUSH
79335: LD_VAR 0 3
79339: ARRAY
79340: PUSH
79341: LD_INT 1
79343: PLUS
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PPUSH
79349: LD_VAR 0 1
79353: PPUSH
79354: CALL 18579 0 3
79358: ST_TO_ADDR
// exit ;
79359: POP
79360: POP
79361: GO 79819
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79363: LD_VAR 0 5
79367: PUSH
79368: LD_INT 0
79370: PUSH
79371: LD_INT 2
79373: PUSH
79374: LD_INT 4
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: LIST
79381: IN
79382: IFFALSE 79506
// begin if btype = b_armoury then
79384: LD_VAR 0 5
79388: PUSH
79389: LD_INT 4
79391: EQUAL
79392: IFFALSE 79402
// btype := b_barracks ;
79394: LD_ADDR_VAR 0 5
79398: PUSH
79399: LD_INT 5
79401: ST_TO_ADDR
// if btype = b_depot then
79402: LD_VAR 0 5
79406: PUSH
79407: LD_INT 0
79409: EQUAL
79410: IFFALSE 79420
// btype := b_warehouse ;
79412: LD_ADDR_VAR 0 5
79416: PUSH
79417: LD_INT 1
79419: ST_TO_ADDR
// if btype = b_workshop then
79420: LD_VAR 0 5
79424: PUSH
79425: LD_INT 2
79427: EQUAL
79428: IFFALSE 79438
// btype := b_factory ;
79430: LD_ADDR_VAR 0 5
79434: PUSH
79435: LD_INT 3
79437: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79438: LD_VAR 0 5
79442: PPUSH
79443: LD_VAR 0 8
79447: PPUSH
79448: CALL_OW 323
79452: PUSH
79453: LD_INT 1
79455: EQUAL
79456: IFFALSE 79502
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79458: LD_ADDR_EXP 97
79462: PUSH
79463: LD_EXP 97
79467: PPUSH
79468: LD_VAR 0 3
79472: PUSH
79473: LD_EXP 97
79477: PUSH
79478: LD_VAR 0 3
79482: ARRAY
79483: PUSH
79484: LD_INT 1
79486: PLUS
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PPUSH
79492: LD_VAR 0 1
79496: PPUSH
79497: CALL 18579 0 3
79501: ST_TO_ADDR
// exit ;
79502: POP
79503: POP
79504: GO 79819
// end ; if btype in [ b_bunker , b_turret ] then
79506: LD_VAR 0 5
79510: PUSH
79511: LD_INT 32
79513: PUSH
79514: LD_INT 33
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: IN
79521: IFFALSE 79811
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79523: LD_ADDR_EXP 73
79527: PUSH
79528: LD_EXP 73
79532: PPUSH
79533: LD_VAR 0 3
79537: PUSH
79538: LD_EXP 73
79542: PUSH
79543: LD_VAR 0 3
79547: ARRAY
79548: PUSH
79549: LD_INT 1
79551: PLUS
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PPUSH
79557: LD_VAR 0 1
79561: PPUSH
79562: CALL 18579 0 3
79566: ST_TO_ADDR
// if btype = b_bunker then
79567: LD_VAR 0 5
79571: PUSH
79572: LD_INT 32
79574: EQUAL
79575: IFFALSE 79811
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79577: LD_ADDR_EXP 74
79581: PUSH
79582: LD_EXP 74
79586: PPUSH
79587: LD_VAR 0 3
79591: PUSH
79592: LD_EXP 74
79596: PUSH
79597: LD_VAR 0 3
79601: ARRAY
79602: PUSH
79603: LD_INT 1
79605: PLUS
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PPUSH
79611: LD_VAR 0 1
79615: PPUSH
79616: CALL 18579 0 3
79620: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79621: LD_ADDR_VAR 0 6
79625: PUSH
79626: LD_EXP 65
79630: PUSH
79631: LD_VAR 0 3
79635: ARRAY
79636: PPUSH
79637: LD_INT 25
79639: PUSH
79640: LD_INT 1
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 3
79649: PUSH
79650: LD_INT 54
79652: PUSH
79653: EMPTY
79654: LIST
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PPUSH
79664: CALL_OW 72
79668: ST_TO_ADDR
// if tmp then
79669: LD_VAR 0 6
79673: IFFALSE 79679
// exit ;
79675: POP
79676: POP
79677: GO 79819
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79679: LD_ADDR_VAR 0 6
79683: PUSH
79684: LD_EXP 65
79688: PUSH
79689: LD_VAR 0 3
79693: ARRAY
79694: PPUSH
79695: LD_INT 2
79697: PUSH
79698: LD_INT 30
79700: PUSH
79701: LD_INT 4
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 30
79710: PUSH
79711: LD_INT 5
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: LIST
79722: PPUSH
79723: CALL_OW 72
79727: ST_TO_ADDR
// if not tmp then
79728: LD_VAR 0 6
79732: NOT
79733: IFFALSE 79739
// exit ;
79735: POP
79736: POP
79737: GO 79819
// for j in tmp do
79739: LD_ADDR_VAR 0 4
79743: PUSH
79744: LD_VAR 0 6
79748: PUSH
79749: FOR_IN
79750: IFFALSE 79809
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79752: LD_ADDR_VAR 0 7
79756: PUSH
79757: LD_VAR 0 4
79761: PPUSH
79762: CALL_OW 313
79766: PPUSH
79767: LD_INT 25
79769: PUSH
79770: LD_INT 1
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PPUSH
79777: CALL_OW 72
79781: ST_TO_ADDR
// if units then
79782: LD_VAR 0 7
79786: IFFALSE 79807
// begin ComExitBuilding ( units [ 1 ] ) ;
79788: LD_VAR 0 7
79792: PUSH
79793: LD_INT 1
79795: ARRAY
79796: PPUSH
79797: CALL_OW 122
// exit ;
79801: POP
79802: POP
79803: POP
79804: POP
79805: GO 79819
// end ; end ;
79807: GO 79749
79809: POP
79810: POP
// end ; end ; exit ;
79811: POP
79812: POP
79813: GO 79819
// end ; end ;
79815: GO 79173
79817: POP
79818: POP
// end ;
79819: LD_VAR 0 2
79823: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79824: LD_INT 0
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
// if not mc_bases or not skirmish then
79833: LD_EXP 65
79837: NOT
79838: PUSH
79839: LD_EXP 63
79843: NOT
79844: OR
79845: IFFALSE 79849
// exit ;
79847: GO 80080
// btype := GetBType ( building ) ;
79849: LD_ADDR_VAR 0 6
79853: PUSH
79854: LD_VAR 0 1
79858: PPUSH
79859: CALL_OW 266
79863: ST_TO_ADDR
// x := GetX ( building ) ;
79864: LD_ADDR_VAR 0 7
79868: PUSH
79869: LD_VAR 0 1
79873: PPUSH
79874: CALL_OW 250
79878: ST_TO_ADDR
// y := GetY ( building ) ;
79879: LD_ADDR_VAR 0 8
79883: PUSH
79884: LD_VAR 0 1
79888: PPUSH
79889: CALL_OW 251
79893: ST_TO_ADDR
// d := GetDir ( building ) ;
79894: LD_ADDR_VAR 0 9
79898: PUSH
79899: LD_VAR 0 1
79903: PPUSH
79904: CALL_OW 254
79908: ST_TO_ADDR
// for i = 1 to mc_bases do
79909: LD_ADDR_VAR 0 4
79913: PUSH
79914: DOUBLE
79915: LD_INT 1
79917: DEC
79918: ST_TO_ADDR
79919: LD_EXP 65
79923: PUSH
79924: FOR_TO
79925: IFFALSE 80078
// begin if not mc_build_list [ i ] then
79927: LD_EXP 70
79931: PUSH
79932: LD_VAR 0 4
79936: ARRAY
79937: NOT
79938: IFFALSE 79942
// continue ;
79940: GO 79924
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
79942: LD_VAR 0 6
79946: PUSH
79947: LD_VAR 0 7
79951: PUSH
79952: LD_VAR 0 8
79956: PUSH
79957: LD_VAR 0 9
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: PPUSH
79968: LD_EXP 70
79972: PUSH
79973: LD_VAR 0 4
79977: ARRAY
79978: PUSH
79979: LD_INT 1
79981: ARRAY
79982: PPUSH
79983: CALL 24748 0 2
79987: IFFALSE 80076
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
79989: LD_ADDR_EXP 70
79993: PUSH
79994: LD_EXP 70
79998: PPUSH
79999: LD_VAR 0 4
80003: PPUSH
80004: LD_EXP 70
80008: PUSH
80009: LD_VAR 0 4
80013: ARRAY
80014: PPUSH
80015: LD_INT 1
80017: PPUSH
80018: CALL_OW 3
80022: PPUSH
80023: CALL_OW 1
80027: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80028: LD_ADDR_EXP 72
80032: PUSH
80033: LD_EXP 72
80037: PPUSH
80038: LD_VAR 0 4
80042: PUSH
80043: LD_EXP 72
80047: PUSH
80048: LD_VAR 0 4
80052: ARRAY
80053: PUSH
80054: LD_INT 1
80056: PLUS
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: PPUSH
80062: LD_VAR 0 1
80066: PPUSH
80067: CALL 18579 0 3
80071: ST_TO_ADDR
// exit ;
80072: POP
80073: POP
80074: GO 80080
// end ; end ;
80076: GO 79924
80078: POP
80079: POP
// end ;
80080: LD_VAR 0 3
80084: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80085: LD_INT 0
80087: PPUSH
80088: PPUSH
80089: PPUSH
// if not mc_bases or not skirmish then
80090: LD_EXP 65
80094: NOT
80095: PUSH
80096: LD_EXP 63
80100: NOT
80101: OR
80102: IFFALSE 80106
// exit ;
80104: GO 80296
// for i = 1 to mc_bases do
80106: LD_ADDR_VAR 0 4
80110: PUSH
80111: DOUBLE
80112: LD_INT 1
80114: DEC
80115: ST_TO_ADDR
80116: LD_EXP 65
80120: PUSH
80121: FOR_TO
80122: IFFALSE 80209
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80124: LD_VAR 0 1
80128: PUSH
80129: LD_EXP 73
80133: PUSH
80134: LD_VAR 0 4
80138: ARRAY
80139: IN
80140: PUSH
80141: LD_VAR 0 1
80145: PUSH
80146: LD_EXP 74
80150: PUSH
80151: LD_VAR 0 4
80155: ARRAY
80156: IN
80157: NOT
80158: AND
80159: IFFALSE 80207
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80161: LD_ADDR_EXP 74
80165: PUSH
80166: LD_EXP 74
80170: PPUSH
80171: LD_VAR 0 4
80175: PUSH
80176: LD_EXP 74
80180: PUSH
80181: LD_VAR 0 4
80185: ARRAY
80186: PUSH
80187: LD_INT 1
80189: PLUS
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PPUSH
80195: LD_VAR 0 1
80199: PPUSH
80200: CALL 18579 0 3
80204: ST_TO_ADDR
// break ;
80205: GO 80209
// end ; end ;
80207: GO 80121
80209: POP
80210: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80211: LD_VAR 0 1
80215: PPUSH
80216: CALL_OW 257
80220: PUSH
80221: LD_EXP 91
80225: IN
80226: PUSH
80227: LD_VAR 0 1
80231: PPUSH
80232: CALL_OW 266
80236: PUSH
80237: LD_INT 5
80239: EQUAL
80240: AND
80241: PUSH
80242: LD_VAR 0 2
80246: PPUSH
80247: CALL_OW 110
80251: PUSH
80252: LD_INT 18
80254: NONEQUAL
80255: AND
80256: IFFALSE 80296
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80258: LD_VAR 0 2
80262: PPUSH
80263: CALL_OW 257
80267: PUSH
80268: LD_INT 5
80270: PUSH
80271: LD_INT 8
80273: PUSH
80274: LD_INT 9
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: LIST
80281: IN
80282: IFFALSE 80296
// SetClass ( unit , 1 ) ;
80284: LD_VAR 0 2
80288: PPUSH
80289: LD_INT 1
80291: PPUSH
80292: CALL_OW 336
// end ;
80296: LD_VAR 0 3
80300: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80301: LD_INT 0
80303: PPUSH
80304: PPUSH
// if not mc_bases or not skirmish then
80305: LD_EXP 65
80309: NOT
80310: PUSH
80311: LD_EXP 63
80315: NOT
80316: OR
80317: IFFALSE 80321
// exit ;
80319: GO 80437
// if GetLives ( abandoned_vehicle ) > 250 then
80321: LD_VAR 0 2
80325: PPUSH
80326: CALL_OW 256
80330: PUSH
80331: LD_INT 250
80333: GREATER
80334: IFFALSE 80338
// exit ;
80336: GO 80437
// for i = 1 to mc_bases do
80338: LD_ADDR_VAR 0 6
80342: PUSH
80343: DOUBLE
80344: LD_INT 1
80346: DEC
80347: ST_TO_ADDR
80348: LD_EXP 65
80352: PUSH
80353: FOR_TO
80354: IFFALSE 80435
// begin if driver in mc_bases [ i ] then
80356: LD_VAR 0 1
80360: PUSH
80361: LD_EXP 65
80365: PUSH
80366: LD_VAR 0 6
80370: ARRAY
80371: IN
80372: IFFALSE 80433
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80374: LD_VAR 0 1
80378: PPUSH
80379: LD_EXP 65
80383: PUSH
80384: LD_VAR 0 6
80388: ARRAY
80389: PPUSH
80390: LD_INT 2
80392: PUSH
80393: LD_INT 30
80395: PUSH
80396: LD_INT 0
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 30
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: LIST
80417: PPUSH
80418: CALL_OW 72
80422: PUSH
80423: LD_INT 1
80425: ARRAY
80426: PPUSH
80427: CALL_OW 112
// break ;
80431: GO 80435
// end ; end ;
80433: GO 80353
80435: POP
80436: POP
// end ; end_of_file end_of_file
80437: LD_VAR 0 5
80441: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
80442: LD_VAR 0 2
80446: PUSH
80447: LD_INT 100
80449: EQUAL
80450: IFFALSE 81399
// begin if not StreamModeActive then
80452: LD_EXP 108
80456: NOT
80457: IFFALSE 80467
// StreamModeActive := true ;
80459: LD_ADDR_EXP 108
80463: PUSH
80464: LD_INT 1
80466: ST_TO_ADDR
// if p3 = 0 then
80467: LD_VAR 0 3
80471: PUSH
80472: LD_INT 0
80474: EQUAL
80475: IFFALSE 80481
// InitStreamMode ;
80477: CALL 81557 0 0
// if p3 = 1 then
80481: LD_VAR 0 3
80485: PUSH
80486: LD_INT 1
80488: EQUAL
80489: IFFALSE 80499
// sRocket := true ;
80491: LD_ADDR_EXP 113
80495: PUSH
80496: LD_INT 1
80498: ST_TO_ADDR
// if p3 = 2 then
80499: LD_VAR 0 3
80503: PUSH
80504: LD_INT 2
80506: EQUAL
80507: IFFALSE 80517
// sSpeed := true ;
80509: LD_ADDR_EXP 112
80513: PUSH
80514: LD_INT 1
80516: ST_TO_ADDR
// if p3 = 3 then
80517: LD_VAR 0 3
80521: PUSH
80522: LD_INT 3
80524: EQUAL
80525: IFFALSE 80535
// sEngine := true ;
80527: LD_ADDR_EXP 114
80531: PUSH
80532: LD_INT 1
80534: ST_TO_ADDR
// if p3 = 4 then
80535: LD_VAR 0 3
80539: PUSH
80540: LD_INT 4
80542: EQUAL
80543: IFFALSE 80553
// sSpec := true ;
80545: LD_ADDR_EXP 111
80549: PUSH
80550: LD_INT 1
80552: ST_TO_ADDR
// if p3 = 5 then
80553: LD_VAR 0 3
80557: PUSH
80558: LD_INT 5
80560: EQUAL
80561: IFFALSE 80571
// sLevel := true ;
80563: LD_ADDR_EXP 115
80567: PUSH
80568: LD_INT 1
80570: ST_TO_ADDR
// if p3 = 6 then
80571: LD_VAR 0 3
80575: PUSH
80576: LD_INT 6
80578: EQUAL
80579: IFFALSE 80589
// sArmoury := true ;
80581: LD_ADDR_EXP 116
80585: PUSH
80586: LD_INT 1
80588: ST_TO_ADDR
// if p3 = 7 then
80589: LD_VAR 0 3
80593: PUSH
80594: LD_INT 7
80596: EQUAL
80597: IFFALSE 80607
// sRadar := true ;
80599: LD_ADDR_EXP 117
80603: PUSH
80604: LD_INT 1
80606: ST_TO_ADDR
// if p3 = 8 then
80607: LD_VAR 0 3
80611: PUSH
80612: LD_INT 8
80614: EQUAL
80615: IFFALSE 80625
// sBunker := true ;
80617: LD_ADDR_EXP 118
80621: PUSH
80622: LD_INT 1
80624: ST_TO_ADDR
// if p3 = 9 then
80625: LD_VAR 0 3
80629: PUSH
80630: LD_INT 9
80632: EQUAL
80633: IFFALSE 80643
// sHack := true ;
80635: LD_ADDR_EXP 119
80639: PUSH
80640: LD_INT 1
80642: ST_TO_ADDR
// if p3 = 10 then
80643: LD_VAR 0 3
80647: PUSH
80648: LD_INT 10
80650: EQUAL
80651: IFFALSE 80661
// sFire := true ;
80653: LD_ADDR_EXP 120
80657: PUSH
80658: LD_INT 1
80660: ST_TO_ADDR
// if p3 = 11 then
80661: LD_VAR 0 3
80665: PUSH
80666: LD_INT 11
80668: EQUAL
80669: IFFALSE 80679
// sRefresh := true ;
80671: LD_ADDR_EXP 121
80675: PUSH
80676: LD_INT 1
80678: ST_TO_ADDR
// if p3 = 12 then
80679: LD_VAR 0 3
80683: PUSH
80684: LD_INT 12
80686: EQUAL
80687: IFFALSE 80697
// sExp := true ;
80689: LD_ADDR_EXP 122
80693: PUSH
80694: LD_INT 1
80696: ST_TO_ADDR
// if p3 = 13 then
80697: LD_VAR 0 3
80701: PUSH
80702: LD_INT 13
80704: EQUAL
80705: IFFALSE 80715
// sDepot := true ;
80707: LD_ADDR_EXP 123
80711: PUSH
80712: LD_INT 1
80714: ST_TO_ADDR
// if p3 = 14 then
80715: LD_VAR 0 3
80719: PUSH
80720: LD_INT 14
80722: EQUAL
80723: IFFALSE 80733
// sFlag := true ;
80725: LD_ADDR_EXP 124
80729: PUSH
80730: LD_INT 1
80732: ST_TO_ADDR
// if p3 = 15 then
80733: LD_VAR 0 3
80737: PUSH
80738: LD_INT 15
80740: EQUAL
80741: IFFALSE 80751
// sKamikadze := true ;
80743: LD_ADDR_EXP 132
80747: PUSH
80748: LD_INT 1
80750: ST_TO_ADDR
// if p3 = 16 then
80751: LD_VAR 0 3
80755: PUSH
80756: LD_INT 16
80758: EQUAL
80759: IFFALSE 80769
// sTroll := true ;
80761: LD_ADDR_EXP 133
80765: PUSH
80766: LD_INT 1
80768: ST_TO_ADDR
// if p3 = 17 then
80769: LD_VAR 0 3
80773: PUSH
80774: LD_INT 17
80776: EQUAL
80777: IFFALSE 80787
// sSlow := true ;
80779: LD_ADDR_EXP 134
80783: PUSH
80784: LD_INT 1
80786: ST_TO_ADDR
// if p3 = 18 then
80787: LD_VAR 0 3
80791: PUSH
80792: LD_INT 18
80794: EQUAL
80795: IFFALSE 80805
// sLack := true ;
80797: LD_ADDR_EXP 135
80801: PUSH
80802: LD_INT 1
80804: ST_TO_ADDR
// if p3 = 19 then
80805: LD_VAR 0 3
80809: PUSH
80810: LD_INT 19
80812: EQUAL
80813: IFFALSE 80823
// sTank := true ;
80815: LD_ADDR_EXP 137
80819: PUSH
80820: LD_INT 1
80822: ST_TO_ADDR
// if p3 = 20 then
80823: LD_VAR 0 3
80827: PUSH
80828: LD_INT 20
80830: EQUAL
80831: IFFALSE 80841
// sRemote := true ;
80833: LD_ADDR_EXP 138
80837: PUSH
80838: LD_INT 1
80840: ST_TO_ADDR
// if p3 = 21 then
80841: LD_VAR 0 3
80845: PUSH
80846: LD_INT 21
80848: EQUAL
80849: IFFALSE 80859
// sPowell := true ;
80851: LD_ADDR_EXP 139
80855: PUSH
80856: LD_INT 1
80858: ST_TO_ADDR
// if p3 = 22 then
80859: LD_VAR 0 3
80863: PUSH
80864: LD_INT 22
80866: EQUAL
80867: IFFALSE 80877
// sTeleport := true ;
80869: LD_ADDR_EXP 142
80873: PUSH
80874: LD_INT 1
80876: ST_TO_ADDR
// if p3 = 23 then
80877: LD_VAR 0 3
80881: PUSH
80882: LD_INT 23
80884: EQUAL
80885: IFFALSE 80895
// sOilTower := true ;
80887: LD_ADDR_EXP 144
80891: PUSH
80892: LD_INT 1
80894: ST_TO_ADDR
// if p3 = 24 then
80895: LD_VAR 0 3
80899: PUSH
80900: LD_INT 24
80902: EQUAL
80903: IFFALSE 80913
// sShovel := true ;
80905: LD_ADDR_EXP 145
80909: PUSH
80910: LD_INT 1
80912: ST_TO_ADDR
// if p3 = 25 then
80913: LD_VAR 0 3
80917: PUSH
80918: LD_INT 25
80920: EQUAL
80921: IFFALSE 80931
// sSheik := true ;
80923: LD_ADDR_EXP 146
80927: PUSH
80928: LD_INT 1
80930: ST_TO_ADDR
// if p3 = 26 then
80931: LD_VAR 0 3
80935: PUSH
80936: LD_INT 26
80938: EQUAL
80939: IFFALSE 80949
// sEarthquake := true ;
80941: LD_ADDR_EXP 148
80945: PUSH
80946: LD_INT 1
80948: ST_TO_ADDR
// if p3 = 27 then
80949: LD_VAR 0 3
80953: PUSH
80954: LD_INT 27
80956: EQUAL
80957: IFFALSE 80967
// sAI := true ;
80959: LD_ADDR_EXP 149
80963: PUSH
80964: LD_INT 1
80966: ST_TO_ADDR
// if p3 = 28 then
80967: LD_VAR 0 3
80971: PUSH
80972: LD_INT 28
80974: EQUAL
80975: IFFALSE 80985
// sCargo := true ;
80977: LD_ADDR_EXP 152
80981: PUSH
80982: LD_INT 1
80984: ST_TO_ADDR
// if p3 = 29 then
80985: LD_VAR 0 3
80989: PUSH
80990: LD_INT 29
80992: EQUAL
80993: IFFALSE 81003
// sDLaser := true ;
80995: LD_ADDR_EXP 153
80999: PUSH
81000: LD_INT 1
81002: ST_TO_ADDR
// if p3 = 30 then
81003: LD_VAR 0 3
81007: PUSH
81008: LD_INT 30
81010: EQUAL
81011: IFFALSE 81021
// sExchange := true ;
81013: LD_ADDR_EXP 154
81017: PUSH
81018: LD_INT 1
81020: ST_TO_ADDR
// if p3 = 31 then
81021: LD_VAR 0 3
81025: PUSH
81026: LD_INT 31
81028: EQUAL
81029: IFFALSE 81039
// sFac := true ;
81031: LD_ADDR_EXP 155
81035: PUSH
81036: LD_INT 1
81038: ST_TO_ADDR
// if p3 = 32 then
81039: LD_VAR 0 3
81043: PUSH
81044: LD_INT 32
81046: EQUAL
81047: IFFALSE 81057
// sPower := true ;
81049: LD_ADDR_EXP 156
81053: PUSH
81054: LD_INT 1
81056: ST_TO_ADDR
// if p3 = 33 then
81057: LD_VAR 0 3
81061: PUSH
81062: LD_INT 33
81064: EQUAL
81065: IFFALSE 81075
// sRandom := true ;
81067: LD_ADDR_EXP 157
81071: PUSH
81072: LD_INT 1
81074: ST_TO_ADDR
// if p3 = 34 then
81075: LD_VAR 0 3
81079: PUSH
81080: LD_INT 34
81082: EQUAL
81083: IFFALSE 81093
// sShield := true ;
81085: LD_ADDR_EXP 158
81089: PUSH
81090: LD_INT 1
81092: ST_TO_ADDR
// if p3 = 35 then
81093: LD_VAR 0 3
81097: PUSH
81098: LD_INT 35
81100: EQUAL
81101: IFFALSE 81111
// sTime := true ;
81103: LD_ADDR_EXP 159
81107: PUSH
81108: LD_INT 1
81110: ST_TO_ADDR
// if p3 = 36 then
81111: LD_VAR 0 3
81115: PUSH
81116: LD_INT 36
81118: EQUAL
81119: IFFALSE 81129
// sTools := true ;
81121: LD_ADDR_EXP 160
81125: PUSH
81126: LD_INT 1
81128: ST_TO_ADDR
// if p3 = 101 then
81129: LD_VAR 0 3
81133: PUSH
81134: LD_INT 101
81136: EQUAL
81137: IFFALSE 81147
// sSold := true ;
81139: LD_ADDR_EXP 125
81143: PUSH
81144: LD_INT 1
81146: ST_TO_ADDR
// if p3 = 102 then
81147: LD_VAR 0 3
81151: PUSH
81152: LD_INT 102
81154: EQUAL
81155: IFFALSE 81165
// sDiff := true ;
81157: LD_ADDR_EXP 126
81161: PUSH
81162: LD_INT 1
81164: ST_TO_ADDR
// if p3 = 103 then
81165: LD_VAR 0 3
81169: PUSH
81170: LD_INT 103
81172: EQUAL
81173: IFFALSE 81183
// sFog := true ;
81175: LD_ADDR_EXP 129
81179: PUSH
81180: LD_INT 1
81182: ST_TO_ADDR
// if p3 = 104 then
81183: LD_VAR 0 3
81187: PUSH
81188: LD_INT 104
81190: EQUAL
81191: IFFALSE 81201
// sReset := true ;
81193: LD_ADDR_EXP 130
81197: PUSH
81198: LD_INT 1
81200: ST_TO_ADDR
// if p3 = 105 then
81201: LD_VAR 0 3
81205: PUSH
81206: LD_INT 105
81208: EQUAL
81209: IFFALSE 81219
// sSun := true ;
81211: LD_ADDR_EXP 131
81215: PUSH
81216: LD_INT 1
81218: ST_TO_ADDR
// if p3 = 106 then
81219: LD_VAR 0 3
81223: PUSH
81224: LD_INT 106
81226: EQUAL
81227: IFFALSE 81237
// sTiger := true ;
81229: LD_ADDR_EXP 127
81233: PUSH
81234: LD_INT 1
81236: ST_TO_ADDR
// if p3 = 107 then
81237: LD_VAR 0 3
81241: PUSH
81242: LD_INT 107
81244: EQUAL
81245: IFFALSE 81255
// sBomb := true ;
81247: LD_ADDR_EXP 128
81251: PUSH
81252: LD_INT 1
81254: ST_TO_ADDR
// if p3 = 108 then
81255: LD_VAR 0 3
81259: PUSH
81260: LD_INT 108
81262: EQUAL
81263: IFFALSE 81273
// sWound := true ;
81265: LD_ADDR_EXP 136
81269: PUSH
81270: LD_INT 1
81272: ST_TO_ADDR
// if p3 = 109 then
81273: LD_VAR 0 3
81277: PUSH
81278: LD_INT 109
81280: EQUAL
81281: IFFALSE 81291
// sBetray := true ;
81283: LD_ADDR_EXP 140
81287: PUSH
81288: LD_INT 1
81290: ST_TO_ADDR
// if p3 = 110 then
81291: LD_VAR 0 3
81295: PUSH
81296: LD_INT 110
81298: EQUAL
81299: IFFALSE 81309
// sContamin := true ;
81301: LD_ADDR_EXP 141
81305: PUSH
81306: LD_INT 1
81308: ST_TO_ADDR
// if p3 = 111 then
81309: LD_VAR 0 3
81313: PUSH
81314: LD_INT 111
81316: EQUAL
81317: IFFALSE 81327
// sOil := true ;
81319: LD_ADDR_EXP 143
81323: PUSH
81324: LD_INT 1
81326: ST_TO_ADDR
// if p3 = 112 then
81327: LD_VAR 0 3
81331: PUSH
81332: LD_INT 112
81334: EQUAL
81335: IFFALSE 81345
// sStu := true ;
81337: LD_ADDR_EXP 147
81341: PUSH
81342: LD_INT 1
81344: ST_TO_ADDR
// if p3 = 113 then
81345: LD_VAR 0 3
81349: PUSH
81350: LD_INT 113
81352: EQUAL
81353: IFFALSE 81363
// sBazooka := true ;
81355: LD_ADDR_EXP 150
81359: PUSH
81360: LD_INT 1
81362: ST_TO_ADDR
// if p3 = 114 then
81363: LD_VAR 0 3
81367: PUSH
81368: LD_INT 114
81370: EQUAL
81371: IFFALSE 81381
// sMortar := true ;
81373: LD_ADDR_EXP 151
81377: PUSH
81378: LD_INT 1
81380: ST_TO_ADDR
// if p3 = 115 then
81381: LD_VAR 0 3
81385: PUSH
81386: LD_INT 115
81388: EQUAL
81389: IFFALSE 81399
// sRanger := true ;
81391: LD_ADDR_EXP 161
81395: PUSH
81396: LD_INT 1
81398: ST_TO_ADDR
// end ; if p2 = 101 then
81399: LD_VAR 0 2
81403: PUSH
81404: LD_INT 101
81406: EQUAL
81407: IFFALSE 81535
// begin case p3 of 1 :
81409: LD_VAR 0 3
81413: PUSH
81414: LD_INT 1
81416: DOUBLE
81417: EQUAL
81418: IFTRUE 81422
81420: GO 81429
81422: POP
// hHackUnlimitedResources ; 2 :
81423: CALL 92570 0 0
81427: GO 81535
81429: LD_INT 2
81431: DOUBLE
81432: EQUAL
81433: IFTRUE 81437
81435: GO 81444
81437: POP
// hHackSetLevel10 ; 3 :
81438: CALL 92703 0 0
81442: GO 81535
81444: LD_INT 3
81446: DOUBLE
81447: EQUAL
81448: IFTRUE 81452
81450: GO 81459
81452: POP
// hHackSetLevel10YourUnits ; 4 :
81453: CALL 92788 0 0
81457: GO 81535
81459: LD_INT 4
81461: DOUBLE
81462: EQUAL
81463: IFTRUE 81467
81465: GO 81474
81467: POP
// hHackInvincible ; 5 :
81468: CALL 93236 0 0
81472: GO 81535
81474: LD_INT 5
81476: DOUBLE
81477: EQUAL
81478: IFTRUE 81482
81480: GO 81489
81482: POP
// hHackInvisible ; 6 :
81483: CALL 93347 0 0
81487: GO 81535
81489: LD_INT 6
81491: DOUBLE
81492: EQUAL
81493: IFTRUE 81497
81495: GO 81504
81497: POP
// hHackChangeYourSide ; 7 :
81498: CALL 93404 0 0
81502: GO 81535
81504: LD_INT 7
81506: DOUBLE
81507: EQUAL
81508: IFTRUE 81512
81510: GO 81519
81512: POP
// hHackChangeUnitSide ; 8 :
81513: CALL 93446 0 0
81517: GO 81535
81519: LD_INT 8
81521: DOUBLE
81522: EQUAL
81523: IFTRUE 81527
81525: GO 81534
81527: POP
// hHackFog ; end ;
81528: CALL 93547 0 0
81532: GO 81535
81534: POP
// end ; end ;
81535: PPOPN 6
81537: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
81538: GO 81540
81540: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
81541: LD_STRING initStreamRollete();
81543: PPUSH
81544: CALL_OW 559
// InitStreamMode ;
81548: CALL 81557 0 0
// DefineStreamItems ( ) ;
81552: CALL 81997 0 0
// end ;
81556: END
// function InitStreamMode ; begin
81557: LD_INT 0
81559: PPUSH
// streamModeActive := false ;
81560: LD_ADDR_EXP 108
81564: PUSH
81565: LD_INT 0
81567: ST_TO_ADDR
// normalCounter := 36 ;
81568: LD_ADDR_EXP 109
81572: PUSH
81573: LD_INT 36
81575: ST_TO_ADDR
// hardcoreCounter := 16 ;
81576: LD_ADDR_EXP 110
81580: PUSH
81581: LD_INT 16
81583: ST_TO_ADDR
// sRocket := false ;
81584: LD_ADDR_EXP 113
81588: PUSH
81589: LD_INT 0
81591: ST_TO_ADDR
// sSpeed := false ;
81592: LD_ADDR_EXP 112
81596: PUSH
81597: LD_INT 0
81599: ST_TO_ADDR
// sEngine := false ;
81600: LD_ADDR_EXP 114
81604: PUSH
81605: LD_INT 0
81607: ST_TO_ADDR
// sSpec := false ;
81608: LD_ADDR_EXP 111
81612: PUSH
81613: LD_INT 0
81615: ST_TO_ADDR
// sLevel := false ;
81616: LD_ADDR_EXP 115
81620: PUSH
81621: LD_INT 0
81623: ST_TO_ADDR
// sArmoury := false ;
81624: LD_ADDR_EXP 116
81628: PUSH
81629: LD_INT 0
81631: ST_TO_ADDR
// sRadar := false ;
81632: LD_ADDR_EXP 117
81636: PUSH
81637: LD_INT 0
81639: ST_TO_ADDR
// sBunker := false ;
81640: LD_ADDR_EXP 118
81644: PUSH
81645: LD_INT 0
81647: ST_TO_ADDR
// sHack := false ;
81648: LD_ADDR_EXP 119
81652: PUSH
81653: LD_INT 0
81655: ST_TO_ADDR
// sFire := false ;
81656: LD_ADDR_EXP 120
81660: PUSH
81661: LD_INT 0
81663: ST_TO_ADDR
// sRefresh := false ;
81664: LD_ADDR_EXP 121
81668: PUSH
81669: LD_INT 0
81671: ST_TO_ADDR
// sExp := false ;
81672: LD_ADDR_EXP 122
81676: PUSH
81677: LD_INT 0
81679: ST_TO_ADDR
// sDepot := false ;
81680: LD_ADDR_EXP 123
81684: PUSH
81685: LD_INT 0
81687: ST_TO_ADDR
// sFlag := false ;
81688: LD_ADDR_EXP 124
81692: PUSH
81693: LD_INT 0
81695: ST_TO_ADDR
// sKamikadze := false ;
81696: LD_ADDR_EXP 132
81700: PUSH
81701: LD_INT 0
81703: ST_TO_ADDR
// sTroll := false ;
81704: LD_ADDR_EXP 133
81708: PUSH
81709: LD_INT 0
81711: ST_TO_ADDR
// sSlow := false ;
81712: LD_ADDR_EXP 134
81716: PUSH
81717: LD_INT 0
81719: ST_TO_ADDR
// sLack := false ;
81720: LD_ADDR_EXP 135
81724: PUSH
81725: LD_INT 0
81727: ST_TO_ADDR
// sTank := false ;
81728: LD_ADDR_EXP 137
81732: PUSH
81733: LD_INT 0
81735: ST_TO_ADDR
// sRemote := false ;
81736: LD_ADDR_EXP 138
81740: PUSH
81741: LD_INT 0
81743: ST_TO_ADDR
// sPowell := false ;
81744: LD_ADDR_EXP 139
81748: PUSH
81749: LD_INT 0
81751: ST_TO_ADDR
// sTeleport := false ;
81752: LD_ADDR_EXP 142
81756: PUSH
81757: LD_INT 0
81759: ST_TO_ADDR
// sOilTower := false ;
81760: LD_ADDR_EXP 144
81764: PUSH
81765: LD_INT 0
81767: ST_TO_ADDR
// sShovel := false ;
81768: LD_ADDR_EXP 145
81772: PUSH
81773: LD_INT 0
81775: ST_TO_ADDR
// sSheik := false ;
81776: LD_ADDR_EXP 146
81780: PUSH
81781: LD_INT 0
81783: ST_TO_ADDR
// sEarthquake := false ;
81784: LD_ADDR_EXP 148
81788: PUSH
81789: LD_INT 0
81791: ST_TO_ADDR
// sAI := false ;
81792: LD_ADDR_EXP 149
81796: PUSH
81797: LD_INT 0
81799: ST_TO_ADDR
// sCargo := false ;
81800: LD_ADDR_EXP 152
81804: PUSH
81805: LD_INT 0
81807: ST_TO_ADDR
// sDLaser := false ;
81808: LD_ADDR_EXP 153
81812: PUSH
81813: LD_INT 0
81815: ST_TO_ADDR
// sExchange := false ;
81816: LD_ADDR_EXP 154
81820: PUSH
81821: LD_INT 0
81823: ST_TO_ADDR
// sFac := false ;
81824: LD_ADDR_EXP 155
81828: PUSH
81829: LD_INT 0
81831: ST_TO_ADDR
// sPower := false ;
81832: LD_ADDR_EXP 156
81836: PUSH
81837: LD_INT 0
81839: ST_TO_ADDR
// sRandom := false ;
81840: LD_ADDR_EXP 157
81844: PUSH
81845: LD_INT 0
81847: ST_TO_ADDR
// sShield := false ;
81848: LD_ADDR_EXP 158
81852: PUSH
81853: LD_INT 0
81855: ST_TO_ADDR
// sTime := false ;
81856: LD_ADDR_EXP 159
81860: PUSH
81861: LD_INT 0
81863: ST_TO_ADDR
// sTools := false ;
81864: LD_ADDR_EXP 160
81868: PUSH
81869: LD_INT 0
81871: ST_TO_ADDR
// sSold := false ;
81872: LD_ADDR_EXP 125
81876: PUSH
81877: LD_INT 0
81879: ST_TO_ADDR
// sDiff := false ;
81880: LD_ADDR_EXP 126
81884: PUSH
81885: LD_INT 0
81887: ST_TO_ADDR
// sFog := false ;
81888: LD_ADDR_EXP 129
81892: PUSH
81893: LD_INT 0
81895: ST_TO_ADDR
// sReset := false ;
81896: LD_ADDR_EXP 130
81900: PUSH
81901: LD_INT 0
81903: ST_TO_ADDR
// sSun := false ;
81904: LD_ADDR_EXP 131
81908: PUSH
81909: LD_INT 0
81911: ST_TO_ADDR
// sTiger := false ;
81912: LD_ADDR_EXP 127
81916: PUSH
81917: LD_INT 0
81919: ST_TO_ADDR
// sBomb := false ;
81920: LD_ADDR_EXP 128
81924: PUSH
81925: LD_INT 0
81927: ST_TO_ADDR
// sWound := false ;
81928: LD_ADDR_EXP 136
81932: PUSH
81933: LD_INT 0
81935: ST_TO_ADDR
// sBetray := false ;
81936: LD_ADDR_EXP 140
81940: PUSH
81941: LD_INT 0
81943: ST_TO_ADDR
// sContamin := false ;
81944: LD_ADDR_EXP 141
81948: PUSH
81949: LD_INT 0
81951: ST_TO_ADDR
// sOil := false ;
81952: LD_ADDR_EXP 143
81956: PUSH
81957: LD_INT 0
81959: ST_TO_ADDR
// sStu := false ;
81960: LD_ADDR_EXP 147
81964: PUSH
81965: LD_INT 0
81967: ST_TO_ADDR
// sBazooka := false ;
81968: LD_ADDR_EXP 150
81972: PUSH
81973: LD_INT 0
81975: ST_TO_ADDR
// sMortar := false ;
81976: LD_ADDR_EXP 151
81980: PUSH
81981: LD_INT 0
81983: ST_TO_ADDR
// sRanger := false ;
81984: LD_ADDR_EXP 161
81988: PUSH
81989: LD_INT 0
81991: ST_TO_ADDR
// end ;
81992: LD_VAR 0 1
81996: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
81997: LD_INT 0
81999: PPUSH
82000: PPUSH
82001: PPUSH
82002: PPUSH
82003: PPUSH
// result := [ ] ;
82004: LD_ADDR_VAR 0 1
82008: PUSH
82009: EMPTY
82010: ST_TO_ADDR
// if campaign_id = 1 then
82011: LD_OWVAR 69
82015: PUSH
82016: LD_INT 1
82018: EQUAL
82019: IFFALSE 84957
// begin case mission_number of 1 :
82021: LD_OWVAR 70
82025: PUSH
82026: LD_INT 1
82028: DOUBLE
82029: EQUAL
82030: IFTRUE 82034
82032: GO 82098
82034: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
82035: LD_ADDR_VAR 0 1
82039: PUSH
82040: LD_INT 2
82042: PUSH
82043: LD_INT 4
82045: PUSH
82046: LD_INT 11
82048: PUSH
82049: LD_INT 12
82051: PUSH
82052: LD_INT 15
82054: PUSH
82055: LD_INT 16
82057: PUSH
82058: LD_INT 22
82060: PUSH
82061: LD_INT 23
82063: PUSH
82064: LD_INT 26
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 101
82080: PUSH
82081: LD_INT 102
82083: PUSH
82084: LD_INT 106
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: LIST
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: ST_TO_ADDR
82096: GO 84955
82098: LD_INT 2
82100: DOUBLE
82101: EQUAL
82102: IFTRUE 82106
82104: GO 82178
82106: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
82107: LD_ADDR_VAR 0 1
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: LD_INT 4
82117: PUSH
82118: LD_INT 11
82120: PUSH
82121: LD_INT 12
82123: PUSH
82124: LD_INT 15
82126: PUSH
82127: LD_INT 16
82129: PUSH
82130: LD_INT 22
82132: PUSH
82133: LD_INT 23
82135: PUSH
82136: LD_INT 26
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 101
82152: PUSH
82153: LD_INT 102
82155: PUSH
82156: LD_INT 105
82158: PUSH
82159: LD_INT 106
82161: PUSH
82162: LD_INT 108
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: ST_TO_ADDR
82176: GO 84955
82178: LD_INT 3
82180: DOUBLE
82181: EQUAL
82182: IFTRUE 82186
82184: GO 82262
82186: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
82187: LD_ADDR_VAR 0 1
82191: PUSH
82192: LD_INT 2
82194: PUSH
82195: LD_INT 4
82197: PUSH
82198: LD_INT 5
82200: PUSH
82201: LD_INT 11
82203: PUSH
82204: LD_INT 12
82206: PUSH
82207: LD_INT 15
82209: PUSH
82210: LD_INT 16
82212: PUSH
82213: LD_INT 22
82215: PUSH
82216: LD_INT 26
82218: PUSH
82219: LD_INT 36
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 101
82236: PUSH
82237: LD_INT 102
82239: PUSH
82240: LD_INT 105
82242: PUSH
82243: LD_INT 106
82245: PUSH
82246: LD_INT 108
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: ST_TO_ADDR
82260: GO 84955
82262: LD_INT 4
82264: DOUBLE
82265: EQUAL
82266: IFTRUE 82270
82268: GO 82354
82270: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
82271: LD_ADDR_VAR 0 1
82275: PUSH
82276: LD_INT 2
82278: PUSH
82279: LD_INT 4
82281: PUSH
82282: LD_INT 5
82284: PUSH
82285: LD_INT 8
82287: PUSH
82288: LD_INT 11
82290: PUSH
82291: LD_INT 12
82293: PUSH
82294: LD_INT 15
82296: PUSH
82297: LD_INT 16
82299: PUSH
82300: LD_INT 22
82302: PUSH
82303: LD_INT 23
82305: PUSH
82306: LD_INT 26
82308: PUSH
82309: LD_INT 36
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 101
82328: PUSH
82329: LD_INT 102
82331: PUSH
82332: LD_INT 105
82334: PUSH
82335: LD_INT 106
82337: PUSH
82338: LD_INT 108
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: ST_TO_ADDR
82352: GO 84955
82354: LD_INT 5
82356: DOUBLE
82357: EQUAL
82358: IFTRUE 82362
82360: GO 82462
82362: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
82363: LD_ADDR_VAR 0 1
82367: PUSH
82368: LD_INT 2
82370: PUSH
82371: LD_INT 4
82373: PUSH
82374: LD_INT 5
82376: PUSH
82377: LD_INT 6
82379: PUSH
82380: LD_INT 8
82382: PUSH
82383: LD_INT 11
82385: PUSH
82386: LD_INT 12
82388: PUSH
82389: LD_INT 15
82391: PUSH
82392: LD_INT 16
82394: PUSH
82395: LD_INT 22
82397: PUSH
82398: LD_INT 23
82400: PUSH
82401: LD_INT 25
82403: PUSH
82404: LD_INT 26
82406: PUSH
82407: LD_INT 36
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 101
82428: PUSH
82429: LD_INT 102
82431: PUSH
82432: LD_INT 105
82434: PUSH
82435: LD_INT 106
82437: PUSH
82438: LD_INT 108
82440: PUSH
82441: LD_INT 109
82443: PUSH
82444: LD_INT 112
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: ST_TO_ADDR
82460: GO 84955
82462: LD_INT 6
82464: DOUBLE
82465: EQUAL
82466: IFTRUE 82470
82468: GO 82590
82470: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
82471: LD_ADDR_VAR 0 1
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: LD_INT 4
82481: PUSH
82482: LD_INT 5
82484: PUSH
82485: LD_INT 6
82487: PUSH
82488: LD_INT 8
82490: PUSH
82491: LD_INT 11
82493: PUSH
82494: LD_INT 12
82496: PUSH
82497: LD_INT 15
82499: PUSH
82500: LD_INT 16
82502: PUSH
82503: LD_INT 20
82505: PUSH
82506: LD_INT 21
82508: PUSH
82509: LD_INT 22
82511: PUSH
82512: LD_INT 23
82514: PUSH
82515: LD_INT 25
82517: PUSH
82518: LD_INT 26
82520: PUSH
82521: LD_INT 30
82523: PUSH
82524: LD_INT 31
82526: PUSH
82527: LD_INT 32
82529: PUSH
82530: LD_INT 36
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 101
82556: PUSH
82557: LD_INT 102
82559: PUSH
82560: LD_INT 105
82562: PUSH
82563: LD_INT 106
82565: PUSH
82566: LD_INT 108
82568: PUSH
82569: LD_INT 109
82571: PUSH
82572: LD_INT 112
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: ST_TO_ADDR
82588: GO 84955
82590: LD_INT 7
82592: DOUBLE
82593: EQUAL
82594: IFTRUE 82598
82596: GO 82698
82598: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
82599: LD_ADDR_VAR 0 1
82603: PUSH
82604: LD_INT 2
82606: PUSH
82607: LD_INT 4
82609: PUSH
82610: LD_INT 5
82612: PUSH
82613: LD_INT 7
82615: PUSH
82616: LD_INT 11
82618: PUSH
82619: LD_INT 12
82621: PUSH
82622: LD_INT 15
82624: PUSH
82625: LD_INT 16
82627: PUSH
82628: LD_INT 20
82630: PUSH
82631: LD_INT 21
82633: PUSH
82634: LD_INT 22
82636: PUSH
82637: LD_INT 23
82639: PUSH
82640: LD_INT 25
82642: PUSH
82643: LD_INT 26
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 101
82664: PUSH
82665: LD_INT 102
82667: PUSH
82668: LD_INT 103
82670: PUSH
82671: LD_INT 105
82673: PUSH
82674: LD_INT 106
82676: PUSH
82677: LD_INT 108
82679: PUSH
82680: LD_INT 112
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: ST_TO_ADDR
82696: GO 84955
82698: LD_INT 8
82700: DOUBLE
82701: EQUAL
82702: IFTRUE 82706
82704: GO 82834
82706: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
82707: LD_ADDR_VAR 0 1
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: LD_INT 4
82717: PUSH
82718: LD_INT 5
82720: PUSH
82721: LD_INT 6
82723: PUSH
82724: LD_INT 7
82726: PUSH
82727: LD_INT 8
82729: PUSH
82730: LD_INT 11
82732: PUSH
82733: LD_INT 12
82735: PUSH
82736: LD_INT 15
82738: PUSH
82739: LD_INT 16
82741: PUSH
82742: LD_INT 20
82744: PUSH
82745: LD_INT 21
82747: PUSH
82748: LD_INT 22
82750: PUSH
82751: LD_INT 23
82753: PUSH
82754: LD_INT 25
82756: PUSH
82757: LD_INT 26
82759: PUSH
82760: LD_INT 30
82762: PUSH
82763: LD_INT 31
82765: PUSH
82766: LD_INT 32
82768: PUSH
82769: LD_INT 36
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 101
82796: PUSH
82797: LD_INT 102
82799: PUSH
82800: LD_INT 103
82802: PUSH
82803: LD_INT 105
82805: PUSH
82806: LD_INT 106
82808: PUSH
82809: LD_INT 108
82811: PUSH
82812: LD_INT 109
82814: PUSH
82815: LD_INT 112
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: ST_TO_ADDR
82832: GO 84955
82834: LD_INT 9
82836: DOUBLE
82837: EQUAL
82838: IFTRUE 82842
82840: GO 82978
82842: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
82843: LD_ADDR_VAR 0 1
82847: PUSH
82848: LD_INT 2
82850: PUSH
82851: LD_INT 4
82853: PUSH
82854: LD_INT 5
82856: PUSH
82857: LD_INT 6
82859: PUSH
82860: LD_INT 7
82862: PUSH
82863: LD_INT 8
82865: PUSH
82866: LD_INT 11
82868: PUSH
82869: LD_INT 12
82871: PUSH
82872: LD_INT 15
82874: PUSH
82875: LD_INT 16
82877: PUSH
82878: LD_INT 20
82880: PUSH
82881: LD_INT 21
82883: PUSH
82884: LD_INT 22
82886: PUSH
82887: LD_INT 23
82889: PUSH
82890: LD_INT 25
82892: PUSH
82893: LD_INT 26
82895: PUSH
82896: LD_INT 28
82898: PUSH
82899: LD_INT 30
82901: PUSH
82902: LD_INT 31
82904: PUSH
82905: LD_INT 32
82907: PUSH
82908: LD_INT 36
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 101
82936: PUSH
82937: LD_INT 102
82939: PUSH
82940: LD_INT 103
82942: PUSH
82943: LD_INT 105
82945: PUSH
82946: LD_INT 106
82948: PUSH
82949: LD_INT 108
82951: PUSH
82952: LD_INT 109
82954: PUSH
82955: LD_INT 112
82957: PUSH
82958: LD_INT 114
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: ST_TO_ADDR
82976: GO 84955
82978: LD_INT 10
82980: DOUBLE
82981: EQUAL
82982: IFTRUE 82986
82984: GO 83170
82986: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
82987: LD_ADDR_VAR 0 1
82991: PUSH
82992: LD_INT 2
82994: PUSH
82995: LD_INT 4
82997: PUSH
82998: LD_INT 5
83000: PUSH
83001: LD_INT 6
83003: PUSH
83004: LD_INT 7
83006: PUSH
83007: LD_INT 8
83009: PUSH
83010: LD_INT 9
83012: PUSH
83013: LD_INT 10
83015: PUSH
83016: LD_INT 11
83018: PUSH
83019: LD_INT 12
83021: PUSH
83022: LD_INT 13
83024: PUSH
83025: LD_INT 14
83027: PUSH
83028: LD_INT 15
83030: PUSH
83031: LD_INT 16
83033: PUSH
83034: LD_INT 17
83036: PUSH
83037: LD_INT 18
83039: PUSH
83040: LD_INT 19
83042: PUSH
83043: LD_INT 20
83045: PUSH
83046: LD_INT 21
83048: PUSH
83049: LD_INT 22
83051: PUSH
83052: LD_INT 23
83054: PUSH
83055: LD_INT 24
83057: PUSH
83058: LD_INT 25
83060: PUSH
83061: LD_INT 26
83063: PUSH
83064: LD_INT 28
83066: PUSH
83067: LD_INT 30
83069: PUSH
83070: LD_INT 31
83072: PUSH
83073: LD_INT 32
83075: PUSH
83076: LD_INT 36
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 101
83112: PUSH
83113: LD_INT 102
83115: PUSH
83116: LD_INT 103
83118: PUSH
83119: LD_INT 104
83121: PUSH
83122: LD_INT 105
83124: PUSH
83125: LD_INT 106
83127: PUSH
83128: LD_INT 107
83130: PUSH
83131: LD_INT 108
83133: PUSH
83134: LD_INT 109
83136: PUSH
83137: LD_INT 110
83139: PUSH
83140: LD_INT 111
83142: PUSH
83143: LD_INT 112
83145: PUSH
83146: LD_INT 114
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: ST_TO_ADDR
83168: GO 84955
83170: LD_INT 11
83172: DOUBLE
83173: EQUAL
83174: IFTRUE 83178
83176: GO 83370
83178: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
83179: LD_ADDR_VAR 0 1
83183: PUSH
83184: LD_INT 2
83186: PUSH
83187: LD_INT 3
83189: PUSH
83190: LD_INT 4
83192: PUSH
83193: LD_INT 5
83195: PUSH
83196: LD_INT 6
83198: PUSH
83199: LD_INT 7
83201: PUSH
83202: LD_INT 8
83204: PUSH
83205: LD_INT 9
83207: PUSH
83208: LD_INT 10
83210: PUSH
83211: LD_INT 11
83213: PUSH
83214: LD_INT 12
83216: PUSH
83217: LD_INT 13
83219: PUSH
83220: LD_INT 14
83222: PUSH
83223: LD_INT 15
83225: PUSH
83226: LD_INT 16
83228: PUSH
83229: LD_INT 17
83231: PUSH
83232: LD_INT 18
83234: PUSH
83235: LD_INT 19
83237: PUSH
83238: LD_INT 20
83240: PUSH
83241: LD_INT 21
83243: PUSH
83244: LD_INT 22
83246: PUSH
83247: LD_INT 23
83249: PUSH
83250: LD_INT 24
83252: PUSH
83253: LD_INT 25
83255: PUSH
83256: LD_INT 26
83258: PUSH
83259: LD_INT 28
83261: PUSH
83262: LD_INT 30
83264: PUSH
83265: LD_INT 31
83267: PUSH
83268: LD_INT 32
83270: PUSH
83271: LD_INT 34
83273: PUSH
83274: LD_INT 36
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: PUSH
83310: LD_INT 101
83312: PUSH
83313: LD_INT 102
83315: PUSH
83316: LD_INT 103
83318: PUSH
83319: LD_INT 104
83321: PUSH
83322: LD_INT 105
83324: PUSH
83325: LD_INT 106
83327: PUSH
83328: LD_INT 107
83330: PUSH
83331: LD_INT 108
83333: PUSH
83334: LD_INT 109
83336: PUSH
83337: LD_INT 110
83339: PUSH
83340: LD_INT 111
83342: PUSH
83343: LD_INT 112
83345: PUSH
83346: LD_INT 114
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: LIST
83353: LIST
83354: LIST
83355: LIST
83356: LIST
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: ST_TO_ADDR
83368: GO 84955
83370: LD_INT 12
83372: DOUBLE
83373: EQUAL
83374: IFTRUE 83378
83376: GO 83586
83378: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
83379: LD_ADDR_VAR 0 1
83383: PUSH
83384: LD_INT 1
83386: PUSH
83387: LD_INT 2
83389: PUSH
83390: LD_INT 3
83392: PUSH
83393: LD_INT 4
83395: PUSH
83396: LD_INT 5
83398: PUSH
83399: LD_INT 6
83401: PUSH
83402: LD_INT 7
83404: PUSH
83405: LD_INT 8
83407: PUSH
83408: LD_INT 9
83410: PUSH
83411: LD_INT 10
83413: PUSH
83414: LD_INT 11
83416: PUSH
83417: LD_INT 12
83419: PUSH
83420: LD_INT 13
83422: PUSH
83423: LD_INT 14
83425: PUSH
83426: LD_INT 15
83428: PUSH
83429: LD_INT 16
83431: PUSH
83432: LD_INT 17
83434: PUSH
83435: LD_INT 18
83437: PUSH
83438: LD_INT 19
83440: PUSH
83441: LD_INT 20
83443: PUSH
83444: LD_INT 21
83446: PUSH
83447: LD_INT 22
83449: PUSH
83450: LD_INT 23
83452: PUSH
83453: LD_INT 24
83455: PUSH
83456: LD_INT 25
83458: PUSH
83459: LD_INT 26
83461: PUSH
83462: LD_INT 27
83464: PUSH
83465: LD_INT 28
83467: PUSH
83468: LD_INT 30
83470: PUSH
83471: LD_INT 31
83473: PUSH
83474: LD_INT 32
83476: PUSH
83477: LD_INT 33
83479: PUSH
83480: LD_INT 34
83482: PUSH
83483: LD_INT 36
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: LIST
83490: LIST
83491: LIST
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 101
83524: PUSH
83525: LD_INT 102
83527: PUSH
83528: LD_INT 103
83530: PUSH
83531: LD_INT 104
83533: PUSH
83534: LD_INT 105
83536: PUSH
83537: LD_INT 106
83539: PUSH
83540: LD_INT 107
83542: PUSH
83543: LD_INT 108
83545: PUSH
83546: LD_INT 109
83548: PUSH
83549: LD_INT 110
83551: PUSH
83552: LD_INT 111
83554: PUSH
83555: LD_INT 112
83557: PUSH
83558: LD_INT 113
83560: PUSH
83561: LD_INT 114
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: ST_TO_ADDR
83584: GO 84955
83586: LD_INT 13
83588: DOUBLE
83589: EQUAL
83590: IFTRUE 83594
83592: GO 83790
83594: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
83595: LD_ADDR_VAR 0 1
83599: PUSH
83600: LD_INT 1
83602: PUSH
83603: LD_INT 2
83605: PUSH
83606: LD_INT 3
83608: PUSH
83609: LD_INT 4
83611: PUSH
83612: LD_INT 5
83614: PUSH
83615: LD_INT 8
83617: PUSH
83618: LD_INT 9
83620: PUSH
83621: LD_INT 10
83623: PUSH
83624: LD_INT 11
83626: PUSH
83627: LD_INT 12
83629: PUSH
83630: LD_INT 14
83632: PUSH
83633: LD_INT 15
83635: PUSH
83636: LD_INT 16
83638: PUSH
83639: LD_INT 17
83641: PUSH
83642: LD_INT 18
83644: PUSH
83645: LD_INT 19
83647: PUSH
83648: LD_INT 20
83650: PUSH
83651: LD_INT 21
83653: PUSH
83654: LD_INT 22
83656: PUSH
83657: LD_INT 23
83659: PUSH
83660: LD_INT 24
83662: PUSH
83663: LD_INT 25
83665: PUSH
83666: LD_INT 26
83668: PUSH
83669: LD_INT 27
83671: PUSH
83672: LD_INT 28
83674: PUSH
83675: LD_INT 30
83677: PUSH
83678: LD_INT 31
83680: PUSH
83681: LD_INT 32
83683: PUSH
83684: LD_INT 33
83686: PUSH
83687: LD_INT 34
83689: PUSH
83690: LD_INT 36
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 101
83728: PUSH
83729: LD_INT 102
83731: PUSH
83732: LD_INT 103
83734: PUSH
83735: LD_INT 104
83737: PUSH
83738: LD_INT 105
83740: PUSH
83741: LD_INT 106
83743: PUSH
83744: LD_INT 107
83746: PUSH
83747: LD_INT 108
83749: PUSH
83750: LD_INT 109
83752: PUSH
83753: LD_INT 110
83755: PUSH
83756: LD_INT 111
83758: PUSH
83759: LD_INT 112
83761: PUSH
83762: LD_INT 113
83764: PUSH
83765: LD_INT 114
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: LIST
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: ST_TO_ADDR
83788: GO 84955
83790: LD_INT 14
83792: DOUBLE
83793: EQUAL
83794: IFTRUE 83798
83796: GO 84010
83798: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
83799: LD_ADDR_VAR 0 1
83803: PUSH
83804: LD_INT 1
83806: PUSH
83807: LD_INT 2
83809: PUSH
83810: LD_INT 3
83812: PUSH
83813: LD_INT 4
83815: PUSH
83816: LD_INT 5
83818: PUSH
83819: LD_INT 6
83821: PUSH
83822: LD_INT 7
83824: PUSH
83825: LD_INT 8
83827: PUSH
83828: LD_INT 9
83830: PUSH
83831: LD_INT 10
83833: PUSH
83834: LD_INT 11
83836: PUSH
83837: LD_INT 12
83839: PUSH
83840: LD_INT 13
83842: PUSH
83843: LD_INT 14
83845: PUSH
83846: LD_INT 15
83848: PUSH
83849: LD_INT 16
83851: PUSH
83852: LD_INT 17
83854: PUSH
83855: LD_INT 18
83857: PUSH
83858: LD_INT 19
83860: PUSH
83861: LD_INT 20
83863: PUSH
83864: LD_INT 21
83866: PUSH
83867: LD_INT 22
83869: PUSH
83870: LD_INT 23
83872: PUSH
83873: LD_INT 24
83875: PUSH
83876: LD_INT 25
83878: PUSH
83879: LD_INT 26
83881: PUSH
83882: LD_INT 27
83884: PUSH
83885: LD_INT 28
83887: PUSH
83888: LD_INT 29
83890: PUSH
83891: LD_INT 30
83893: PUSH
83894: LD_INT 31
83896: PUSH
83897: LD_INT 32
83899: PUSH
83900: LD_INT 33
83902: PUSH
83903: LD_INT 34
83905: PUSH
83906: LD_INT 36
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 101
83948: PUSH
83949: LD_INT 102
83951: PUSH
83952: LD_INT 103
83954: PUSH
83955: LD_INT 104
83957: PUSH
83958: LD_INT 105
83960: PUSH
83961: LD_INT 106
83963: PUSH
83964: LD_INT 107
83966: PUSH
83967: LD_INT 108
83969: PUSH
83970: LD_INT 109
83972: PUSH
83973: LD_INT 110
83975: PUSH
83976: LD_INT 111
83978: PUSH
83979: LD_INT 112
83981: PUSH
83982: LD_INT 113
83984: PUSH
83985: LD_INT 114
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: PUSH
84004: EMPTY
84005: LIST
84006: LIST
84007: ST_TO_ADDR
84008: GO 84955
84010: LD_INT 15
84012: DOUBLE
84013: EQUAL
84014: IFTRUE 84018
84016: GO 84230
84018: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
84019: LD_ADDR_VAR 0 1
84023: PUSH
84024: LD_INT 1
84026: PUSH
84027: LD_INT 2
84029: PUSH
84030: LD_INT 3
84032: PUSH
84033: LD_INT 4
84035: PUSH
84036: LD_INT 5
84038: PUSH
84039: LD_INT 6
84041: PUSH
84042: LD_INT 7
84044: PUSH
84045: LD_INT 8
84047: PUSH
84048: LD_INT 9
84050: PUSH
84051: LD_INT 10
84053: PUSH
84054: LD_INT 11
84056: PUSH
84057: LD_INT 12
84059: PUSH
84060: LD_INT 13
84062: PUSH
84063: LD_INT 14
84065: PUSH
84066: LD_INT 15
84068: PUSH
84069: LD_INT 16
84071: PUSH
84072: LD_INT 17
84074: PUSH
84075: LD_INT 18
84077: PUSH
84078: LD_INT 19
84080: PUSH
84081: LD_INT 20
84083: PUSH
84084: LD_INT 21
84086: PUSH
84087: LD_INT 22
84089: PUSH
84090: LD_INT 23
84092: PUSH
84093: LD_INT 24
84095: PUSH
84096: LD_INT 25
84098: PUSH
84099: LD_INT 26
84101: PUSH
84102: LD_INT 27
84104: PUSH
84105: LD_INT 28
84107: PUSH
84108: LD_INT 29
84110: PUSH
84111: LD_INT 30
84113: PUSH
84114: LD_INT 31
84116: PUSH
84117: LD_INT 32
84119: PUSH
84120: LD_INT 33
84122: PUSH
84123: LD_INT 34
84125: PUSH
84126: LD_INT 36
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 101
84168: PUSH
84169: LD_INT 102
84171: PUSH
84172: LD_INT 103
84174: PUSH
84175: LD_INT 104
84177: PUSH
84178: LD_INT 105
84180: PUSH
84181: LD_INT 106
84183: PUSH
84184: LD_INT 107
84186: PUSH
84187: LD_INT 108
84189: PUSH
84190: LD_INT 109
84192: PUSH
84193: LD_INT 110
84195: PUSH
84196: LD_INT 111
84198: PUSH
84199: LD_INT 112
84201: PUSH
84202: LD_INT 113
84204: PUSH
84205: LD_INT 114
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: ST_TO_ADDR
84228: GO 84955
84230: LD_INT 16
84232: DOUBLE
84233: EQUAL
84234: IFTRUE 84238
84236: GO 84362
84238: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
84239: LD_ADDR_VAR 0 1
84243: PUSH
84244: LD_INT 2
84246: PUSH
84247: LD_INT 4
84249: PUSH
84250: LD_INT 5
84252: PUSH
84253: LD_INT 7
84255: PUSH
84256: LD_INT 11
84258: PUSH
84259: LD_INT 12
84261: PUSH
84262: LD_INT 15
84264: PUSH
84265: LD_INT 16
84267: PUSH
84268: LD_INT 20
84270: PUSH
84271: LD_INT 21
84273: PUSH
84274: LD_INT 22
84276: PUSH
84277: LD_INT 23
84279: PUSH
84280: LD_INT 25
84282: PUSH
84283: LD_INT 26
84285: PUSH
84286: LD_INT 30
84288: PUSH
84289: LD_INT 31
84291: PUSH
84292: LD_INT 32
84294: PUSH
84295: LD_INT 33
84297: PUSH
84298: LD_INT 34
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 101
84324: PUSH
84325: LD_INT 102
84327: PUSH
84328: LD_INT 103
84330: PUSH
84331: LD_INT 106
84333: PUSH
84334: LD_INT 108
84336: PUSH
84337: LD_INT 112
84339: PUSH
84340: LD_INT 113
84342: PUSH
84343: LD_INT 114
84345: PUSH
84346: EMPTY
84347: LIST
84348: LIST
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: ST_TO_ADDR
84360: GO 84955
84362: LD_INT 17
84364: DOUBLE
84365: EQUAL
84366: IFTRUE 84370
84368: GO 84582
84370: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
84371: LD_ADDR_VAR 0 1
84375: PUSH
84376: LD_INT 1
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: LD_INT 3
84384: PUSH
84385: LD_INT 4
84387: PUSH
84388: LD_INT 5
84390: PUSH
84391: LD_INT 6
84393: PUSH
84394: LD_INT 7
84396: PUSH
84397: LD_INT 8
84399: PUSH
84400: LD_INT 9
84402: PUSH
84403: LD_INT 10
84405: PUSH
84406: LD_INT 11
84408: PUSH
84409: LD_INT 12
84411: PUSH
84412: LD_INT 13
84414: PUSH
84415: LD_INT 14
84417: PUSH
84418: LD_INT 15
84420: PUSH
84421: LD_INT 16
84423: PUSH
84424: LD_INT 17
84426: PUSH
84427: LD_INT 18
84429: PUSH
84430: LD_INT 19
84432: PUSH
84433: LD_INT 20
84435: PUSH
84436: LD_INT 21
84438: PUSH
84439: LD_INT 22
84441: PUSH
84442: LD_INT 23
84444: PUSH
84445: LD_INT 24
84447: PUSH
84448: LD_INT 25
84450: PUSH
84451: LD_INT 26
84453: PUSH
84454: LD_INT 27
84456: PUSH
84457: LD_INT 28
84459: PUSH
84460: LD_INT 29
84462: PUSH
84463: LD_INT 30
84465: PUSH
84466: LD_INT 31
84468: PUSH
84469: LD_INT 32
84471: PUSH
84472: LD_INT 33
84474: PUSH
84475: LD_INT 34
84477: PUSH
84478: LD_INT 36
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: LIST
84488: LIST
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 101
84520: PUSH
84521: LD_INT 102
84523: PUSH
84524: LD_INT 103
84526: PUSH
84527: LD_INT 104
84529: PUSH
84530: LD_INT 105
84532: PUSH
84533: LD_INT 106
84535: PUSH
84536: LD_INT 107
84538: PUSH
84539: LD_INT 108
84541: PUSH
84542: LD_INT 109
84544: PUSH
84545: LD_INT 110
84547: PUSH
84548: LD_INT 111
84550: PUSH
84551: LD_INT 112
84553: PUSH
84554: LD_INT 113
84556: PUSH
84557: LD_INT 114
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: ST_TO_ADDR
84580: GO 84955
84582: LD_INT 18
84584: DOUBLE
84585: EQUAL
84586: IFTRUE 84590
84588: GO 84726
84590: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
84591: LD_ADDR_VAR 0 1
84595: PUSH
84596: LD_INT 2
84598: PUSH
84599: LD_INT 4
84601: PUSH
84602: LD_INT 5
84604: PUSH
84605: LD_INT 7
84607: PUSH
84608: LD_INT 11
84610: PUSH
84611: LD_INT 12
84613: PUSH
84614: LD_INT 15
84616: PUSH
84617: LD_INT 16
84619: PUSH
84620: LD_INT 20
84622: PUSH
84623: LD_INT 21
84625: PUSH
84626: LD_INT 22
84628: PUSH
84629: LD_INT 23
84631: PUSH
84632: LD_INT 25
84634: PUSH
84635: LD_INT 26
84637: PUSH
84638: LD_INT 30
84640: PUSH
84641: LD_INT 31
84643: PUSH
84644: LD_INT 32
84646: PUSH
84647: LD_INT 33
84649: PUSH
84650: LD_INT 34
84652: PUSH
84653: LD_INT 35
84655: PUSH
84656: LD_INT 36
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 101
84684: PUSH
84685: LD_INT 102
84687: PUSH
84688: LD_INT 103
84690: PUSH
84691: LD_INT 106
84693: PUSH
84694: LD_INT 108
84696: PUSH
84697: LD_INT 112
84699: PUSH
84700: LD_INT 113
84702: PUSH
84703: LD_INT 114
84705: PUSH
84706: LD_INT 115
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: ST_TO_ADDR
84724: GO 84955
84726: LD_INT 19
84728: DOUBLE
84729: EQUAL
84730: IFTRUE 84734
84732: GO 84954
84734: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
84735: LD_ADDR_VAR 0 1
84739: PUSH
84740: LD_INT 1
84742: PUSH
84743: LD_INT 2
84745: PUSH
84746: LD_INT 3
84748: PUSH
84749: LD_INT 4
84751: PUSH
84752: LD_INT 5
84754: PUSH
84755: LD_INT 6
84757: PUSH
84758: LD_INT 7
84760: PUSH
84761: LD_INT 8
84763: PUSH
84764: LD_INT 9
84766: PUSH
84767: LD_INT 10
84769: PUSH
84770: LD_INT 11
84772: PUSH
84773: LD_INT 12
84775: PUSH
84776: LD_INT 13
84778: PUSH
84779: LD_INT 14
84781: PUSH
84782: LD_INT 15
84784: PUSH
84785: LD_INT 16
84787: PUSH
84788: LD_INT 17
84790: PUSH
84791: LD_INT 18
84793: PUSH
84794: LD_INT 19
84796: PUSH
84797: LD_INT 20
84799: PUSH
84800: LD_INT 21
84802: PUSH
84803: LD_INT 22
84805: PUSH
84806: LD_INT 23
84808: PUSH
84809: LD_INT 24
84811: PUSH
84812: LD_INT 25
84814: PUSH
84815: LD_INT 26
84817: PUSH
84818: LD_INT 27
84820: PUSH
84821: LD_INT 28
84823: PUSH
84824: LD_INT 29
84826: PUSH
84827: LD_INT 30
84829: PUSH
84830: LD_INT 31
84832: PUSH
84833: LD_INT 32
84835: PUSH
84836: LD_INT 33
84838: PUSH
84839: LD_INT 34
84841: PUSH
84842: LD_INT 35
84844: PUSH
84845: LD_INT 36
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 101
84888: PUSH
84889: LD_INT 102
84891: PUSH
84892: LD_INT 103
84894: PUSH
84895: LD_INT 104
84897: PUSH
84898: LD_INT 105
84900: PUSH
84901: LD_INT 106
84903: PUSH
84904: LD_INT 107
84906: PUSH
84907: LD_INT 108
84909: PUSH
84910: LD_INT 109
84912: PUSH
84913: LD_INT 110
84915: PUSH
84916: LD_INT 111
84918: PUSH
84919: LD_INT 112
84921: PUSH
84922: LD_INT 113
84924: PUSH
84925: LD_INT 114
84927: PUSH
84928: LD_INT 115
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: ST_TO_ADDR
84952: GO 84955
84954: POP
// end else
84955: GO 85174
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
84957: LD_ADDR_VAR 0 1
84961: PUSH
84962: LD_INT 1
84964: PUSH
84965: LD_INT 2
84967: PUSH
84968: LD_INT 3
84970: PUSH
84971: LD_INT 4
84973: PUSH
84974: LD_INT 5
84976: PUSH
84977: LD_INT 6
84979: PUSH
84980: LD_INT 7
84982: PUSH
84983: LD_INT 8
84985: PUSH
84986: LD_INT 9
84988: PUSH
84989: LD_INT 10
84991: PUSH
84992: LD_INT 11
84994: PUSH
84995: LD_INT 12
84997: PUSH
84998: LD_INT 13
85000: PUSH
85001: LD_INT 14
85003: PUSH
85004: LD_INT 15
85006: PUSH
85007: LD_INT 16
85009: PUSH
85010: LD_INT 17
85012: PUSH
85013: LD_INT 18
85015: PUSH
85016: LD_INT 19
85018: PUSH
85019: LD_INT 20
85021: PUSH
85022: LD_INT 21
85024: PUSH
85025: LD_INT 22
85027: PUSH
85028: LD_INT 23
85030: PUSH
85031: LD_INT 24
85033: PUSH
85034: LD_INT 25
85036: PUSH
85037: LD_INT 26
85039: PUSH
85040: LD_INT 27
85042: PUSH
85043: LD_INT 28
85045: PUSH
85046: LD_INT 29
85048: PUSH
85049: LD_INT 30
85051: PUSH
85052: LD_INT 31
85054: PUSH
85055: LD_INT 32
85057: PUSH
85058: LD_INT 33
85060: PUSH
85061: LD_INT 34
85063: PUSH
85064: LD_INT 35
85066: PUSH
85067: LD_INT 36
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: PUSH
85108: LD_INT 101
85110: PUSH
85111: LD_INT 102
85113: PUSH
85114: LD_INT 103
85116: PUSH
85117: LD_INT 104
85119: PUSH
85120: LD_INT 105
85122: PUSH
85123: LD_INT 106
85125: PUSH
85126: LD_INT 107
85128: PUSH
85129: LD_INT 108
85131: PUSH
85132: LD_INT 109
85134: PUSH
85135: LD_INT 110
85137: PUSH
85138: LD_INT 111
85140: PUSH
85141: LD_INT 112
85143: PUSH
85144: LD_INT 113
85146: PUSH
85147: LD_INT 114
85149: PUSH
85150: LD_INT 115
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: ST_TO_ADDR
// if result then
85174: LD_VAR 0 1
85178: IFFALSE 85467
// begin normal :=  ;
85180: LD_ADDR_VAR 0 3
85184: PUSH
85185: LD_STRING 
85187: ST_TO_ADDR
// hardcore :=  ;
85188: LD_ADDR_VAR 0 4
85192: PUSH
85193: LD_STRING 
85195: ST_TO_ADDR
// for i = 1 to normalCounter do
85196: LD_ADDR_VAR 0 5
85200: PUSH
85201: DOUBLE
85202: LD_INT 1
85204: DEC
85205: ST_TO_ADDR
85206: LD_EXP 109
85210: PUSH
85211: FOR_TO
85212: IFFALSE 85313
// begin tmp := 0 ;
85214: LD_ADDR_VAR 0 2
85218: PUSH
85219: LD_STRING 0
85221: ST_TO_ADDR
// if result [ 1 ] then
85222: LD_VAR 0 1
85226: PUSH
85227: LD_INT 1
85229: ARRAY
85230: IFFALSE 85295
// if result [ 1 ] [ 1 ] = i then
85232: LD_VAR 0 1
85236: PUSH
85237: LD_INT 1
85239: ARRAY
85240: PUSH
85241: LD_INT 1
85243: ARRAY
85244: PUSH
85245: LD_VAR 0 5
85249: EQUAL
85250: IFFALSE 85295
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
85252: LD_ADDR_VAR 0 1
85256: PUSH
85257: LD_VAR 0 1
85261: PPUSH
85262: LD_INT 1
85264: PPUSH
85265: LD_VAR 0 1
85269: PUSH
85270: LD_INT 1
85272: ARRAY
85273: PPUSH
85274: LD_INT 1
85276: PPUSH
85277: CALL_OW 3
85281: PPUSH
85282: CALL_OW 1
85286: ST_TO_ADDR
// tmp := 1 ;
85287: LD_ADDR_VAR 0 2
85291: PUSH
85292: LD_STRING 1
85294: ST_TO_ADDR
// end ; normal := normal & tmp ;
85295: LD_ADDR_VAR 0 3
85299: PUSH
85300: LD_VAR 0 3
85304: PUSH
85305: LD_VAR 0 2
85309: STR
85310: ST_TO_ADDR
// end ;
85311: GO 85211
85313: POP
85314: POP
// for i = 1 to hardcoreCounter do
85315: LD_ADDR_VAR 0 5
85319: PUSH
85320: DOUBLE
85321: LD_INT 1
85323: DEC
85324: ST_TO_ADDR
85325: LD_EXP 110
85329: PUSH
85330: FOR_TO
85331: IFFALSE 85436
// begin tmp := 0 ;
85333: LD_ADDR_VAR 0 2
85337: PUSH
85338: LD_STRING 0
85340: ST_TO_ADDR
// if result [ 2 ] then
85341: LD_VAR 0 1
85345: PUSH
85346: LD_INT 2
85348: ARRAY
85349: IFFALSE 85418
// if result [ 2 ] [ 1 ] = 100 + i then
85351: LD_VAR 0 1
85355: PUSH
85356: LD_INT 2
85358: ARRAY
85359: PUSH
85360: LD_INT 1
85362: ARRAY
85363: PUSH
85364: LD_INT 100
85366: PUSH
85367: LD_VAR 0 5
85371: PLUS
85372: EQUAL
85373: IFFALSE 85418
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
85375: LD_ADDR_VAR 0 1
85379: PUSH
85380: LD_VAR 0 1
85384: PPUSH
85385: LD_INT 2
85387: PPUSH
85388: LD_VAR 0 1
85392: PUSH
85393: LD_INT 2
85395: ARRAY
85396: PPUSH
85397: LD_INT 1
85399: PPUSH
85400: CALL_OW 3
85404: PPUSH
85405: CALL_OW 1
85409: ST_TO_ADDR
// tmp := 1 ;
85410: LD_ADDR_VAR 0 2
85414: PUSH
85415: LD_STRING 1
85417: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
85418: LD_ADDR_VAR 0 4
85422: PUSH
85423: LD_VAR 0 4
85427: PUSH
85428: LD_VAR 0 2
85432: STR
85433: ST_TO_ADDR
// end ;
85434: GO 85330
85436: POP
85437: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
85438: LD_STRING getStreamItemsFromMission("
85440: PUSH
85441: LD_VAR 0 3
85445: STR
85446: PUSH
85447: LD_STRING ","
85449: STR
85450: PUSH
85451: LD_VAR 0 4
85455: STR
85456: PUSH
85457: LD_STRING ")
85459: STR
85460: PPUSH
85461: CALL_OW 559
// end else
85465: GO 85474
// ToLua ( getStreamItemsFromMission("","") ) ;
85467: LD_STRING getStreamItemsFromMission("","")
85469: PPUSH
85470: CALL_OW 559
// end ;
85474: LD_VAR 0 1
85478: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85479: LD_EXP 108
85483: PUSH
85484: LD_EXP 113
85488: AND
85489: IFFALSE 85613
85491: GO 85493
85493: DISABLE
85494: LD_INT 0
85496: PPUSH
85497: PPUSH
// begin enable ;
85498: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85499: LD_ADDR_VAR 0 2
85503: PUSH
85504: LD_INT 22
85506: PUSH
85507: LD_OWVAR 2
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: PUSH
85519: LD_INT 34
85521: PUSH
85522: LD_INT 7
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: LD_INT 34
85531: PUSH
85532: LD_INT 45
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 34
85541: PUSH
85542: LD_INT 28
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 34
85551: PUSH
85552: LD_INT 47
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PPUSH
85570: CALL_OW 69
85574: ST_TO_ADDR
// if not tmp then
85575: LD_VAR 0 2
85579: NOT
85580: IFFALSE 85584
// exit ;
85582: GO 85613
// for i in tmp do
85584: LD_ADDR_VAR 0 1
85588: PUSH
85589: LD_VAR 0 2
85593: PUSH
85594: FOR_IN
85595: IFFALSE 85611
// begin SetLives ( i , 0 ) ;
85597: LD_VAR 0 1
85601: PPUSH
85602: LD_INT 0
85604: PPUSH
85605: CALL_OW 234
// end ;
85609: GO 85594
85611: POP
85612: POP
// end ;
85613: PPOPN 2
85615: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85616: LD_EXP 108
85620: PUSH
85621: LD_EXP 114
85625: AND
85626: IFFALSE 85710
85628: GO 85630
85630: DISABLE
85631: LD_INT 0
85633: PPUSH
85634: PPUSH
// begin enable ;
85635: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85636: LD_ADDR_VAR 0 2
85640: PUSH
85641: LD_INT 22
85643: PUSH
85644: LD_OWVAR 2
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 32
85655: PUSH
85656: LD_INT 3
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PPUSH
85667: CALL_OW 69
85671: ST_TO_ADDR
// if not tmp then
85672: LD_VAR 0 2
85676: NOT
85677: IFFALSE 85681
// exit ;
85679: GO 85710
// for i in tmp do
85681: LD_ADDR_VAR 0 1
85685: PUSH
85686: LD_VAR 0 2
85690: PUSH
85691: FOR_IN
85692: IFFALSE 85708
// begin SetLives ( i , 0 ) ;
85694: LD_VAR 0 1
85698: PPUSH
85699: LD_INT 0
85701: PPUSH
85702: CALL_OW 234
// end ;
85706: GO 85691
85708: POP
85709: POP
// end ;
85710: PPOPN 2
85712: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85713: LD_EXP 108
85717: PUSH
85718: LD_EXP 111
85722: AND
85723: IFFALSE 85816
85725: GO 85727
85727: DISABLE
85728: LD_INT 0
85730: PPUSH
// begin enable ;
85731: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85732: LD_ADDR_VAR 0 1
85736: PUSH
85737: LD_INT 22
85739: PUSH
85740: LD_OWVAR 2
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: LD_INT 25
85754: PUSH
85755: LD_INT 5
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 25
85764: PUSH
85765: LD_INT 9
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 25
85774: PUSH
85775: LD_INT 8
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PPUSH
85792: CALL_OW 69
85796: PUSH
85797: FOR_IN
85798: IFFALSE 85814
// begin SetClass ( i , 1 ) ;
85800: LD_VAR 0 1
85804: PPUSH
85805: LD_INT 1
85807: PPUSH
85808: CALL_OW 336
// end ;
85812: GO 85797
85814: POP
85815: POP
// end ;
85816: PPOPN 1
85818: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85819: LD_EXP 108
85823: PUSH
85824: LD_EXP 112
85828: AND
85829: PUSH
85830: LD_OWVAR 65
85834: PUSH
85835: LD_INT 7
85837: LESS
85838: AND
85839: IFFALSE 85853
85841: GO 85843
85843: DISABLE
// begin enable ;
85844: ENABLE
// game_speed := 7 ;
85845: LD_ADDR_OWVAR 65
85849: PUSH
85850: LD_INT 7
85852: ST_TO_ADDR
// end ;
85853: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85854: LD_EXP 108
85858: PUSH
85859: LD_EXP 115
85863: AND
85864: IFFALSE 86066
85866: GO 85868
85868: DISABLE
85869: LD_INT 0
85871: PPUSH
85872: PPUSH
85873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
85874: LD_ADDR_VAR 0 3
85878: PUSH
85879: LD_INT 81
85881: PUSH
85882: LD_OWVAR 2
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 21
85893: PUSH
85894: LD_INT 1
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PPUSH
85905: CALL_OW 69
85909: ST_TO_ADDR
// if not tmp then
85910: LD_VAR 0 3
85914: NOT
85915: IFFALSE 85919
// exit ;
85917: GO 86066
// if tmp > 5 then
85919: LD_VAR 0 3
85923: PUSH
85924: LD_INT 5
85926: GREATER
85927: IFFALSE 85939
// k := 5 else
85929: LD_ADDR_VAR 0 2
85933: PUSH
85934: LD_INT 5
85936: ST_TO_ADDR
85937: GO 85949
// k := tmp ;
85939: LD_ADDR_VAR 0 2
85943: PUSH
85944: LD_VAR 0 3
85948: ST_TO_ADDR
// for i := 1 to k do
85949: LD_ADDR_VAR 0 1
85953: PUSH
85954: DOUBLE
85955: LD_INT 1
85957: DEC
85958: ST_TO_ADDR
85959: LD_VAR 0 2
85963: PUSH
85964: FOR_TO
85965: IFFALSE 86064
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
85967: LD_VAR 0 3
85971: PUSH
85972: LD_VAR 0 1
85976: ARRAY
85977: PPUSH
85978: LD_VAR 0 1
85982: PUSH
85983: LD_INT 4
85985: MOD
85986: PUSH
85987: LD_INT 1
85989: PLUS
85990: PPUSH
85991: CALL_OW 259
85995: PUSH
85996: LD_INT 10
85998: LESS
85999: IFFALSE 86062
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86001: LD_VAR 0 3
86005: PUSH
86006: LD_VAR 0 1
86010: ARRAY
86011: PPUSH
86012: LD_VAR 0 1
86016: PUSH
86017: LD_INT 4
86019: MOD
86020: PUSH
86021: LD_INT 1
86023: PLUS
86024: PPUSH
86025: LD_VAR 0 3
86029: PUSH
86030: LD_VAR 0 1
86034: ARRAY
86035: PPUSH
86036: LD_VAR 0 1
86040: PUSH
86041: LD_INT 4
86043: MOD
86044: PUSH
86045: LD_INT 1
86047: PLUS
86048: PPUSH
86049: CALL_OW 259
86053: PUSH
86054: LD_INT 1
86056: PLUS
86057: PPUSH
86058: CALL_OW 237
86062: GO 85964
86064: POP
86065: POP
// end ;
86066: PPOPN 3
86068: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86069: LD_EXP 108
86073: PUSH
86074: LD_EXP 116
86078: AND
86079: IFFALSE 86099
86081: GO 86083
86083: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86084: LD_INT 4
86086: PPUSH
86087: LD_OWVAR 2
86091: PPUSH
86092: LD_INT 0
86094: PPUSH
86095: CALL_OW 324
86099: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86100: LD_EXP 108
86104: PUSH
86105: LD_EXP 145
86109: AND
86110: IFFALSE 86130
86112: GO 86114
86114: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86115: LD_INT 19
86117: PPUSH
86118: LD_OWVAR 2
86122: PPUSH
86123: LD_INT 0
86125: PPUSH
86126: CALL_OW 324
86130: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86131: LD_EXP 108
86135: PUSH
86136: LD_EXP 117
86140: AND
86141: IFFALSE 86243
86143: GO 86145
86145: DISABLE
86146: LD_INT 0
86148: PPUSH
86149: PPUSH
// begin enable ;
86150: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86151: LD_ADDR_VAR 0 2
86155: PUSH
86156: LD_INT 22
86158: PUSH
86159: LD_OWVAR 2
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: PUSH
86171: LD_INT 34
86173: PUSH
86174: LD_INT 11
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 34
86183: PUSH
86184: LD_INT 30
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: LIST
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PPUSH
86200: CALL_OW 69
86204: ST_TO_ADDR
// if not tmp then
86205: LD_VAR 0 2
86209: NOT
86210: IFFALSE 86214
// exit ;
86212: GO 86243
// for i in tmp do
86214: LD_ADDR_VAR 0 1
86218: PUSH
86219: LD_VAR 0 2
86223: PUSH
86224: FOR_IN
86225: IFFALSE 86241
// begin SetLives ( i , 0 ) ;
86227: LD_VAR 0 1
86231: PPUSH
86232: LD_INT 0
86234: PPUSH
86235: CALL_OW 234
// end ;
86239: GO 86224
86241: POP
86242: POP
// end ;
86243: PPOPN 2
86245: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86246: LD_EXP 108
86250: PUSH
86251: LD_EXP 118
86255: AND
86256: IFFALSE 86276
86258: GO 86260
86260: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86261: LD_INT 32
86263: PPUSH
86264: LD_OWVAR 2
86268: PPUSH
86269: LD_INT 0
86271: PPUSH
86272: CALL_OW 324
86276: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86277: LD_EXP 108
86281: PUSH
86282: LD_EXP 119
86286: AND
86287: IFFALSE 86468
86289: GO 86291
86291: DISABLE
86292: LD_INT 0
86294: PPUSH
86295: PPUSH
86296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86297: LD_ADDR_VAR 0 2
86301: PUSH
86302: LD_INT 22
86304: PUSH
86305: LD_OWVAR 2
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: LD_INT 33
86316: PUSH
86317: LD_INT 3
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PPUSH
86328: CALL_OW 69
86332: ST_TO_ADDR
// if not tmp then
86333: LD_VAR 0 2
86337: NOT
86338: IFFALSE 86342
// exit ;
86340: GO 86468
// side := 0 ;
86342: LD_ADDR_VAR 0 3
86346: PUSH
86347: LD_INT 0
86349: ST_TO_ADDR
// for i := 1 to 8 do
86350: LD_ADDR_VAR 0 1
86354: PUSH
86355: DOUBLE
86356: LD_INT 1
86358: DEC
86359: ST_TO_ADDR
86360: LD_INT 8
86362: PUSH
86363: FOR_TO
86364: IFFALSE 86412
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86366: LD_OWVAR 2
86370: PUSH
86371: LD_VAR 0 1
86375: NONEQUAL
86376: PUSH
86377: LD_OWVAR 2
86381: PPUSH
86382: LD_VAR 0 1
86386: PPUSH
86387: CALL_OW 81
86391: PUSH
86392: LD_INT 2
86394: EQUAL
86395: AND
86396: IFFALSE 86410
// begin side := i ;
86398: LD_ADDR_VAR 0 3
86402: PUSH
86403: LD_VAR 0 1
86407: ST_TO_ADDR
// break ;
86408: GO 86412
// end ;
86410: GO 86363
86412: POP
86413: POP
// if not side then
86414: LD_VAR 0 3
86418: NOT
86419: IFFALSE 86423
// exit ;
86421: GO 86468
// for i := 1 to tmp do
86423: LD_ADDR_VAR 0 1
86427: PUSH
86428: DOUBLE
86429: LD_INT 1
86431: DEC
86432: ST_TO_ADDR
86433: LD_VAR 0 2
86437: PUSH
86438: FOR_TO
86439: IFFALSE 86466
// if Prob ( 60 ) then
86441: LD_INT 60
86443: PPUSH
86444: CALL_OW 13
86448: IFFALSE 86464
// SetSide ( i , side ) ;
86450: LD_VAR 0 1
86454: PPUSH
86455: LD_VAR 0 3
86459: PPUSH
86460: CALL_OW 235
86464: GO 86438
86466: POP
86467: POP
// end ;
86468: PPOPN 3
86470: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86471: LD_EXP 108
86475: PUSH
86476: LD_EXP 121
86480: AND
86481: IFFALSE 86600
86483: GO 86485
86485: DISABLE
86486: LD_INT 0
86488: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86489: LD_ADDR_VAR 0 1
86493: PUSH
86494: LD_INT 22
86496: PUSH
86497: LD_OWVAR 2
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: PUSH
86506: LD_INT 21
86508: PUSH
86509: LD_INT 1
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 3
86518: PUSH
86519: LD_INT 23
86521: PUSH
86522: LD_INT 0
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: LIST
86537: PPUSH
86538: CALL_OW 69
86542: PUSH
86543: FOR_IN
86544: IFFALSE 86598
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86546: LD_VAR 0 1
86550: PPUSH
86551: CALL_OW 257
86555: PUSH
86556: LD_INT 1
86558: PUSH
86559: LD_INT 2
86561: PUSH
86562: LD_INT 3
86564: PUSH
86565: LD_INT 4
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: IN
86574: IFFALSE 86596
// SetClass ( un , rand ( 1 , 4 ) ) ;
86576: LD_VAR 0 1
86580: PPUSH
86581: LD_INT 1
86583: PPUSH
86584: LD_INT 4
86586: PPUSH
86587: CALL_OW 12
86591: PPUSH
86592: CALL_OW 336
86596: GO 86543
86598: POP
86599: POP
// end ;
86600: PPOPN 1
86602: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
86603: LD_EXP 108
86607: PUSH
86608: LD_EXP 120
86612: AND
86613: IFFALSE 86692
86615: GO 86617
86617: DISABLE
86618: LD_INT 0
86620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86621: LD_ADDR_VAR 0 1
86625: PUSH
86626: LD_INT 22
86628: PUSH
86629: LD_OWVAR 2
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: PUSH
86638: LD_INT 21
86640: PUSH
86641: LD_INT 3
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PPUSH
86652: CALL_OW 69
86656: ST_TO_ADDR
// if not tmp then
86657: LD_VAR 0 1
86661: NOT
86662: IFFALSE 86666
// exit ;
86664: GO 86692
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
86666: LD_VAR 0 1
86670: PUSH
86671: LD_INT 1
86673: PPUSH
86674: LD_VAR 0 1
86678: PPUSH
86679: CALL_OW 12
86683: ARRAY
86684: PPUSH
86685: LD_INT 100
86687: PPUSH
86688: CALL_OW 234
// end ;
86692: PPOPN 1
86694: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
86695: LD_EXP 108
86699: PUSH
86700: LD_EXP 122
86704: AND
86705: IFFALSE 86803
86707: GO 86709
86709: DISABLE
86710: LD_INT 0
86712: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
86713: LD_ADDR_VAR 0 1
86717: PUSH
86718: LD_INT 22
86720: PUSH
86721: LD_OWVAR 2
86725: PUSH
86726: EMPTY
86727: LIST
86728: LIST
86729: PUSH
86730: LD_INT 21
86732: PUSH
86733: LD_INT 1
86735: PUSH
86736: EMPTY
86737: LIST
86738: LIST
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PPUSH
86744: CALL_OW 69
86748: ST_TO_ADDR
// if not tmp then
86749: LD_VAR 0 1
86753: NOT
86754: IFFALSE 86758
// exit ;
86756: GO 86803
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86758: LD_VAR 0 1
86762: PUSH
86763: LD_INT 1
86765: PPUSH
86766: LD_VAR 0 1
86770: PPUSH
86771: CALL_OW 12
86775: ARRAY
86776: PPUSH
86777: LD_INT 1
86779: PPUSH
86780: LD_INT 4
86782: PPUSH
86783: CALL_OW 12
86787: PPUSH
86788: LD_INT 3000
86790: PPUSH
86791: LD_INT 9000
86793: PPUSH
86794: CALL_OW 12
86798: PPUSH
86799: CALL_OW 492
// end ;
86803: PPOPN 1
86805: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86806: LD_EXP 108
86810: PUSH
86811: LD_EXP 123
86815: AND
86816: IFFALSE 86836
86818: GO 86820
86820: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86821: LD_INT 1
86823: PPUSH
86824: LD_OWVAR 2
86828: PPUSH
86829: LD_INT 0
86831: PPUSH
86832: CALL_OW 324
86836: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86837: LD_EXP 108
86841: PUSH
86842: LD_EXP 124
86846: AND
86847: IFFALSE 86930
86849: GO 86851
86851: DISABLE
86852: LD_INT 0
86854: PPUSH
86855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86856: LD_ADDR_VAR 0 2
86860: PUSH
86861: LD_INT 22
86863: PUSH
86864: LD_OWVAR 2
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 21
86875: PUSH
86876: LD_INT 3
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PPUSH
86887: CALL_OW 69
86891: ST_TO_ADDR
// if not tmp then
86892: LD_VAR 0 2
86896: NOT
86897: IFFALSE 86901
// exit ;
86899: GO 86930
// for i in tmp do
86901: LD_ADDR_VAR 0 1
86905: PUSH
86906: LD_VAR 0 2
86910: PUSH
86911: FOR_IN
86912: IFFALSE 86928
// SetBLevel ( i , 10 ) ;
86914: LD_VAR 0 1
86918: PPUSH
86919: LD_INT 10
86921: PPUSH
86922: CALL_OW 241
86926: GO 86911
86928: POP
86929: POP
// end ;
86930: PPOPN 2
86932: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
86933: LD_EXP 108
86937: PUSH
86938: LD_EXP 125
86942: AND
86943: IFFALSE 87054
86945: GO 86947
86947: DISABLE
86948: LD_INT 0
86950: PPUSH
86951: PPUSH
86952: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
86953: LD_ADDR_VAR 0 3
86957: PUSH
86958: LD_INT 22
86960: PUSH
86961: LD_OWVAR 2
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 25
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PPUSH
86984: CALL_OW 69
86988: ST_TO_ADDR
// if not tmp then
86989: LD_VAR 0 3
86993: NOT
86994: IFFALSE 86998
// exit ;
86996: GO 87054
// un := tmp [ rand ( 1 , tmp ) ] ;
86998: LD_ADDR_VAR 0 2
87002: PUSH
87003: LD_VAR 0 3
87007: PUSH
87008: LD_INT 1
87010: PPUSH
87011: LD_VAR 0 3
87015: PPUSH
87016: CALL_OW 12
87020: ARRAY
87021: ST_TO_ADDR
// if Crawls ( un ) then
87022: LD_VAR 0 2
87026: PPUSH
87027: CALL_OW 318
87031: IFFALSE 87042
// ComWalk ( un ) ;
87033: LD_VAR 0 2
87037: PPUSH
87038: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87042: LD_VAR 0 2
87046: PPUSH
87047: LD_INT 5
87049: PPUSH
87050: CALL_OW 336
// end ;
87054: PPOPN 3
87056: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87057: LD_EXP 108
87061: PUSH
87062: LD_EXP 126
87066: AND
87067: PUSH
87068: LD_OWVAR 67
87072: PUSH
87073: LD_INT 3
87075: LESS
87076: AND
87077: IFFALSE 87096
87079: GO 87081
87081: DISABLE
// Difficulty := Difficulty + 1 ;
87082: LD_ADDR_OWVAR 67
87086: PUSH
87087: LD_OWVAR 67
87091: PUSH
87092: LD_INT 1
87094: PLUS
87095: ST_TO_ADDR
87096: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87097: LD_EXP 108
87101: PUSH
87102: LD_EXP 127
87106: AND
87107: IFFALSE 87210
87109: GO 87111
87111: DISABLE
87112: LD_INT 0
87114: PPUSH
// begin for i := 1 to 5 do
87115: LD_ADDR_VAR 0 1
87119: PUSH
87120: DOUBLE
87121: LD_INT 1
87123: DEC
87124: ST_TO_ADDR
87125: LD_INT 5
87127: PUSH
87128: FOR_TO
87129: IFFALSE 87208
// begin uc_nation := nation_nature ;
87131: LD_ADDR_OWVAR 21
87135: PUSH
87136: LD_INT 0
87138: ST_TO_ADDR
// uc_side := 0 ;
87139: LD_ADDR_OWVAR 20
87143: PUSH
87144: LD_INT 0
87146: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87147: LD_ADDR_OWVAR 29
87151: PUSH
87152: LD_INT 12
87154: PUSH
87155: LD_INT 12
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: ST_TO_ADDR
// hc_agressivity := 20 ;
87162: LD_ADDR_OWVAR 35
87166: PUSH
87167: LD_INT 20
87169: ST_TO_ADDR
// hc_class := class_tiger ;
87170: LD_ADDR_OWVAR 28
87174: PUSH
87175: LD_INT 14
87177: ST_TO_ADDR
// hc_gallery :=  ;
87178: LD_ADDR_OWVAR 33
87182: PUSH
87183: LD_STRING 
87185: ST_TO_ADDR
// hc_name :=  ;
87186: LD_ADDR_OWVAR 26
87190: PUSH
87191: LD_STRING 
87193: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87194: CALL_OW 44
87198: PPUSH
87199: LD_INT 0
87201: PPUSH
87202: CALL_OW 51
// end ;
87206: GO 87128
87208: POP
87209: POP
// end ;
87210: PPOPN 1
87212: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87213: LD_EXP 108
87217: PUSH
87218: LD_EXP 128
87222: AND
87223: IFFALSE 87232
87225: GO 87227
87227: DISABLE
// StreamSibBomb ;
87228: CALL 87233 0 0
87232: END
// export function StreamSibBomb ; var i , x , y ; begin
87233: LD_INT 0
87235: PPUSH
87236: PPUSH
87237: PPUSH
87238: PPUSH
// result := false ;
87239: LD_ADDR_VAR 0 1
87243: PUSH
87244: LD_INT 0
87246: ST_TO_ADDR
// for i := 1 to 16 do
87247: LD_ADDR_VAR 0 2
87251: PUSH
87252: DOUBLE
87253: LD_INT 1
87255: DEC
87256: ST_TO_ADDR
87257: LD_INT 16
87259: PUSH
87260: FOR_TO
87261: IFFALSE 87460
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87263: LD_ADDR_VAR 0 3
87267: PUSH
87268: LD_INT 10
87270: PUSH
87271: LD_INT 20
87273: PUSH
87274: LD_INT 30
87276: PUSH
87277: LD_INT 40
87279: PUSH
87280: LD_INT 50
87282: PUSH
87283: LD_INT 60
87285: PUSH
87286: LD_INT 70
87288: PUSH
87289: LD_INT 80
87291: PUSH
87292: LD_INT 90
87294: PUSH
87295: LD_INT 100
87297: PUSH
87298: LD_INT 110
87300: PUSH
87301: LD_INT 120
87303: PUSH
87304: LD_INT 130
87306: PUSH
87307: LD_INT 140
87309: PUSH
87310: LD_INT 150
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 1
87332: PPUSH
87333: LD_INT 15
87335: PPUSH
87336: CALL_OW 12
87340: ARRAY
87341: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87342: LD_ADDR_VAR 0 4
87346: PUSH
87347: LD_INT 10
87349: PUSH
87350: LD_INT 20
87352: PUSH
87353: LD_INT 30
87355: PUSH
87356: LD_INT 40
87358: PUSH
87359: LD_INT 50
87361: PUSH
87362: LD_INT 60
87364: PUSH
87365: LD_INT 70
87367: PUSH
87368: LD_INT 80
87370: PUSH
87371: LD_INT 90
87373: PUSH
87374: LD_INT 100
87376: PUSH
87377: LD_INT 110
87379: PUSH
87380: LD_INT 120
87382: PUSH
87383: LD_INT 130
87385: PUSH
87386: LD_INT 140
87388: PUSH
87389: LD_INT 150
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 1
87411: PPUSH
87412: LD_INT 15
87414: PPUSH
87415: CALL_OW 12
87419: ARRAY
87420: ST_TO_ADDR
// if ValidHex ( x , y ) then
87421: LD_VAR 0 3
87425: PPUSH
87426: LD_VAR 0 4
87430: PPUSH
87431: CALL_OW 488
87435: IFFALSE 87458
// begin result := [ x , y ] ;
87437: LD_ADDR_VAR 0 1
87441: PUSH
87442: LD_VAR 0 3
87446: PUSH
87447: LD_VAR 0 4
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: ST_TO_ADDR
// break ;
87456: GO 87460
// end ; end ;
87458: GO 87260
87460: POP
87461: POP
// if result then
87462: LD_VAR 0 1
87466: IFFALSE 87526
// begin ToLua ( playSibBomb() ) ;
87468: LD_STRING playSibBomb()
87470: PPUSH
87471: CALL_OW 559
// wait ( 0 0$14 ) ;
87475: LD_INT 490
87477: PPUSH
87478: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87482: LD_VAR 0 1
87486: PUSH
87487: LD_INT 1
87489: ARRAY
87490: PPUSH
87491: LD_VAR 0 1
87495: PUSH
87496: LD_INT 2
87498: ARRAY
87499: PPUSH
87500: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87504: LD_VAR 0 1
87508: PUSH
87509: LD_INT 1
87511: ARRAY
87512: PPUSH
87513: LD_VAR 0 1
87517: PUSH
87518: LD_INT 2
87520: ARRAY
87521: PPUSH
87522: CALL_OW 429
// end ; end ;
87526: LD_VAR 0 1
87530: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87531: LD_EXP 108
87535: PUSH
87536: LD_EXP 130
87540: AND
87541: IFFALSE 87553
87543: GO 87545
87545: DISABLE
// YouLost (  ) ;
87546: LD_STRING 
87548: PPUSH
87549: CALL_OW 104
87553: END
// every 0 0$1 trigger StreamModeActive and sFog do
87554: LD_EXP 108
87558: PUSH
87559: LD_EXP 129
87563: AND
87564: IFFALSE 87578
87566: GO 87568
87568: DISABLE
// FogOff ( your_side ) ;
87569: LD_OWVAR 2
87573: PPUSH
87574: CALL_OW 344
87578: END
// every 0 0$1 trigger StreamModeActive and sSun do
87579: LD_EXP 108
87583: PUSH
87584: LD_EXP 131
87588: AND
87589: IFFALSE 87617
87591: GO 87593
87593: DISABLE
// begin solar_recharge_percent := 0 ;
87594: LD_ADDR_OWVAR 79
87598: PUSH
87599: LD_INT 0
87601: ST_TO_ADDR
// wait ( 5 5$00 ) ;
87602: LD_INT 10500
87604: PPUSH
87605: CALL_OW 67
// solar_recharge_percent := 100 ;
87609: LD_ADDR_OWVAR 79
87613: PUSH
87614: LD_INT 100
87616: ST_TO_ADDR
// end ;
87617: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
87618: LD_EXP 108
87622: PUSH
87623: LD_EXP 132
87627: AND
87628: IFFALSE 87867
87630: GO 87632
87632: DISABLE
87633: LD_INT 0
87635: PPUSH
87636: PPUSH
87637: PPUSH
// begin tmp := [ ] ;
87638: LD_ADDR_VAR 0 3
87642: PUSH
87643: EMPTY
87644: ST_TO_ADDR
// for i := 1 to 6 do
87645: LD_ADDR_VAR 0 1
87649: PUSH
87650: DOUBLE
87651: LD_INT 1
87653: DEC
87654: ST_TO_ADDR
87655: LD_INT 6
87657: PUSH
87658: FOR_TO
87659: IFFALSE 87764
// begin uc_nation := nation_nature ;
87661: LD_ADDR_OWVAR 21
87665: PUSH
87666: LD_INT 0
87668: ST_TO_ADDR
// uc_side := 0 ;
87669: LD_ADDR_OWVAR 20
87673: PUSH
87674: LD_INT 0
87676: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87677: LD_ADDR_OWVAR 29
87681: PUSH
87682: LD_INT 12
87684: PUSH
87685: LD_INT 12
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: ST_TO_ADDR
// hc_agressivity := 20 ;
87692: LD_ADDR_OWVAR 35
87696: PUSH
87697: LD_INT 20
87699: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
87700: LD_ADDR_OWVAR 28
87704: PUSH
87705: LD_INT 17
87707: ST_TO_ADDR
// hc_gallery :=  ;
87708: LD_ADDR_OWVAR 33
87712: PUSH
87713: LD_STRING 
87715: ST_TO_ADDR
// hc_name :=  ;
87716: LD_ADDR_OWVAR 26
87720: PUSH
87721: LD_STRING 
87723: ST_TO_ADDR
// un := CreateHuman ;
87724: LD_ADDR_VAR 0 2
87728: PUSH
87729: CALL_OW 44
87733: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
87734: LD_VAR 0 2
87738: PPUSH
87739: LD_INT 1
87741: PPUSH
87742: CALL_OW 51
// tmp := tmp ^ un ;
87746: LD_ADDR_VAR 0 3
87750: PUSH
87751: LD_VAR 0 3
87755: PUSH
87756: LD_VAR 0 2
87760: ADD
87761: ST_TO_ADDR
// end ;
87762: GO 87658
87764: POP
87765: POP
// repeat wait ( 0 0$1 ) ;
87766: LD_INT 35
87768: PPUSH
87769: CALL_OW 67
// for un in tmp do
87773: LD_ADDR_VAR 0 2
87777: PUSH
87778: LD_VAR 0 3
87782: PUSH
87783: FOR_IN
87784: IFFALSE 87858
// begin if IsDead ( un ) then
87786: LD_VAR 0 2
87790: PPUSH
87791: CALL_OW 301
87795: IFFALSE 87815
// begin tmp := tmp diff un ;
87797: LD_ADDR_VAR 0 3
87801: PUSH
87802: LD_VAR 0 3
87806: PUSH
87807: LD_VAR 0 2
87811: DIFF
87812: ST_TO_ADDR
// continue ;
87813: GO 87783
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
87815: LD_VAR 0 2
87819: PPUSH
87820: LD_INT 3
87822: PUSH
87823: LD_INT 22
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PPUSH
87837: CALL_OW 69
87841: PPUSH
87842: LD_VAR 0 2
87846: PPUSH
87847: CALL_OW 74
87851: PPUSH
87852: CALL_OW 115
// end ;
87856: GO 87783
87858: POP
87859: POP
// until not tmp ;
87860: LD_VAR 0 3
87864: NOT
87865: IFFALSE 87766
// end ;
87867: PPOPN 3
87869: END
// every 0 0$1 trigger StreamModeActive and sTroll do
87870: LD_EXP 108
87874: PUSH
87875: LD_EXP 133
87879: AND
87880: IFFALSE 87934
87882: GO 87884
87884: DISABLE
// begin ToLua ( displayTroll(); ) ;
87885: LD_STRING displayTroll();
87887: PPUSH
87888: CALL_OW 559
// wait ( 3 3$00 ) ;
87892: LD_INT 6300
87894: PPUSH
87895: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87899: LD_STRING hideTroll();
87901: PPUSH
87902: CALL_OW 559
// wait ( 1 1$00 ) ;
87906: LD_INT 2100
87908: PPUSH
87909: CALL_OW 67
// ToLua ( displayTroll(); ) ;
87913: LD_STRING displayTroll();
87915: PPUSH
87916: CALL_OW 559
// wait ( 1 1$00 ) ;
87920: LD_INT 2100
87922: PPUSH
87923: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87927: LD_STRING hideTroll();
87929: PPUSH
87930: CALL_OW 559
// end ;
87934: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
87935: LD_EXP 108
87939: PUSH
87940: LD_EXP 134
87944: AND
87945: IFFALSE 88008
87947: GO 87949
87949: DISABLE
87950: LD_INT 0
87952: PPUSH
// begin p := 0 ;
87953: LD_ADDR_VAR 0 1
87957: PUSH
87958: LD_INT 0
87960: ST_TO_ADDR
// repeat game_speed := 1 ;
87961: LD_ADDR_OWVAR 65
87965: PUSH
87966: LD_INT 1
87968: ST_TO_ADDR
// wait ( 0 0$1 ) ;
87969: LD_INT 35
87971: PPUSH
87972: CALL_OW 67
// p := p + 1 ;
87976: LD_ADDR_VAR 0 1
87980: PUSH
87981: LD_VAR 0 1
87985: PUSH
87986: LD_INT 1
87988: PLUS
87989: ST_TO_ADDR
// until p >= 60 ;
87990: LD_VAR 0 1
87994: PUSH
87995: LD_INT 60
87997: GREATEREQUAL
87998: IFFALSE 87961
// game_speed := 4 ;
88000: LD_ADDR_OWVAR 65
88004: PUSH
88005: LD_INT 4
88007: ST_TO_ADDR
// end ;
88008: PPOPN 1
88010: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88011: LD_EXP 108
88015: PUSH
88016: LD_EXP 135
88020: AND
88021: IFFALSE 88167
88023: GO 88025
88025: DISABLE
88026: LD_INT 0
88028: PPUSH
88029: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88030: LD_ADDR_VAR 0 1
88034: PUSH
88035: LD_INT 22
88037: PUSH
88038: LD_OWVAR 2
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: LD_INT 2
88049: PUSH
88050: LD_INT 30
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 30
88062: PUSH
88063: LD_INT 1
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: LIST
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PPUSH
88079: CALL_OW 69
88083: ST_TO_ADDR
// if not depot then
88084: LD_VAR 0 1
88088: NOT
88089: IFFALSE 88093
// exit ;
88091: GO 88167
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88093: LD_ADDR_VAR 0 2
88097: PUSH
88098: LD_VAR 0 1
88102: PUSH
88103: LD_INT 1
88105: PPUSH
88106: LD_VAR 0 1
88110: PPUSH
88111: CALL_OW 12
88115: ARRAY
88116: PPUSH
88117: CALL_OW 274
88121: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88122: LD_VAR 0 2
88126: PPUSH
88127: LD_INT 1
88129: PPUSH
88130: LD_INT 0
88132: PPUSH
88133: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88137: LD_VAR 0 2
88141: PPUSH
88142: LD_INT 2
88144: PPUSH
88145: LD_INT 0
88147: PPUSH
88148: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88152: LD_VAR 0 2
88156: PPUSH
88157: LD_INT 3
88159: PPUSH
88160: LD_INT 0
88162: PPUSH
88163: CALL_OW 277
// end ;
88167: PPOPN 2
88169: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88170: LD_EXP 108
88174: PUSH
88175: LD_EXP 136
88179: AND
88180: IFFALSE 88277
88182: GO 88184
88184: DISABLE
88185: LD_INT 0
88187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88188: LD_ADDR_VAR 0 1
88192: PUSH
88193: LD_INT 22
88195: PUSH
88196: LD_OWVAR 2
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 21
88207: PUSH
88208: LD_INT 1
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 3
88217: PUSH
88218: LD_INT 23
88220: PUSH
88221: LD_INT 0
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: LIST
88236: PPUSH
88237: CALL_OW 69
88241: ST_TO_ADDR
// if not tmp then
88242: LD_VAR 0 1
88246: NOT
88247: IFFALSE 88251
// exit ;
88249: GO 88277
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88251: LD_VAR 0 1
88255: PUSH
88256: LD_INT 1
88258: PPUSH
88259: LD_VAR 0 1
88263: PPUSH
88264: CALL_OW 12
88268: ARRAY
88269: PPUSH
88270: LD_INT 200
88272: PPUSH
88273: CALL_OW 234
// end ;
88277: PPOPN 1
88279: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88280: LD_EXP 108
88284: PUSH
88285: LD_EXP 137
88289: AND
88290: IFFALSE 88369
88292: GO 88294
88294: DISABLE
88295: LD_INT 0
88297: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88298: LD_ADDR_VAR 0 1
88302: PUSH
88303: LD_INT 22
88305: PUSH
88306: LD_OWVAR 2
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 21
88317: PUSH
88318: LD_INT 2
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PPUSH
88329: CALL_OW 69
88333: ST_TO_ADDR
// if not tmp then
88334: LD_VAR 0 1
88338: NOT
88339: IFFALSE 88343
// exit ;
88341: GO 88369
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88343: LD_VAR 0 1
88347: PUSH
88348: LD_INT 1
88350: PPUSH
88351: LD_VAR 0 1
88355: PPUSH
88356: CALL_OW 12
88360: ARRAY
88361: PPUSH
88362: LD_INT 60
88364: PPUSH
88365: CALL_OW 234
// end ;
88369: PPOPN 1
88371: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88372: LD_EXP 108
88376: PUSH
88377: LD_EXP 138
88381: AND
88382: IFFALSE 88481
88384: GO 88386
88386: DISABLE
88387: LD_INT 0
88389: PPUSH
88390: PPUSH
// begin enable ;
88391: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88392: LD_ADDR_VAR 0 1
88396: PUSH
88397: LD_INT 22
88399: PUSH
88400: LD_OWVAR 2
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 61
88411: PUSH
88412: EMPTY
88413: LIST
88414: PUSH
88415: LD_INT 33
88417: PUSH
88418: LD_INT 2
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: LIST
88429: PPUSH
88430: CALL_OW 69
88434: ST_TO_ADDR
// if not tmp then
88435: LD_VAR 0 1
88439: NOT
88440: IFFALSE 88444
// exit ;
88442: GO 88481
// for i in tmp do
88444: LD_ADDR_VAR 0 2
88448: PUSH
88449: LD_VAR 0 1
88453: PUSH
88454: FOR_IN
88455: IFFALSE 88479
// if IsControledBy ( i ) then
88457: LD_VAR 0 2
88461: PPUSH
88462: CALL_OW 312
88466: IFFALSE 88477
// ComUnlink ( i ) ;
88468: LD_VAR 0 2
88472: PPUSH
88473: CALL_OW 136
88477: GO 88454
88479: POP
88480: POP
// end ;
88481: PPOPN 2
88483: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88484: LD_EXP 108
88488: PUSH
88489: LD_EXP 139
88493: AND
88494: IFFALSE 88634
88496: GO 88498
88498: DISABLE
88499: LD_INT 0
88501: PPUSH
88502: PPUSH
// begin ToLua ( displayPowell(); ) ;
88503: LD_STRING displayPowell();
88505: PPUSH
88506: CALL_OW 559
// uc_side := 0 ;
88510: LD_ADDR_OWVAR 20
88514: PUSH
88515: LD_INT 0
88517: ST_TO_ADDR
// uc_nation := 2 ;
88518: LD_ADDR_OWVAR 21
88522: PUSH
88523: LD_INT 2
88525: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88526: LD_ADDR_OWVAR 37
88530: PUSH
88531: LD_INT 14
88533: ST_TO_ADDR
// vc_engine := engine_siberite ;
88534: LD_ADDR_OWVAR 39
88538: PUSH
88539: LD_INT 3
88541: ST_TO_ADDR
// vc_control := control_apeman ;
88542: LD_ADDR_OWVAR 38
88546: PUSH
88547: LD_INT 5
88549: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88550: LD_ADDR_OWVAR 40
88554: PUSH
88555: LD_INT 29
88557: ST_TO_ADDR
// un := CreateVehicle ;
88558: LD_ADDR_VAR 0 2
88562: PUSH
88563: CALL_OW 45
88567: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
88568: LD_VAR 0 2
88572: PPUSH
88573: LD_INT 1
88575: PPUSH
88576: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
88580: LD_INT 35
88582: PPUSH
88583: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
88587: LD_VAR 0 2
88591: PPUSH
88592: LD_INT 22
88594: PUSH
88595: LD_OWVAR 2
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PPUSH
88604: CALL_OW 69
88608: PPUSH
88609: LD_VAR 0 2
88613: PPUSH
88614: CALL_OW 74
88618: PPUSH
88619: CALL_OW 115
// until IsDead ( un ) ;
88623: LD_VAR 0 2
88627: PPUSH
88628: CALL_OW 301
88632: IFFALSE 88580
// end ;
88634: PPOPN 2
88636: END
// every 0 0$1 trigger StreamModeActive and sStu do
88637: LD_EXP 108
88641: PUSH
88642: LD_EXP 147
88646: AND
88647: IFFALSE 88663
88649: GO 88651
88651: DISABLE
// begin ToLua ( displayStucuk(); ) ;
88652: LD_STRING displayStucuk();
88654: PPUSH
88655: CALL_OW 559
// ResetFog ;
88659: CALL_OW 335
// end ;
88663: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
88664: LD_EXP 108
88668: PUSH
88669: LD_EXP 140
88673: AND
88674: IFFALSE 88815
88676: GO 88678
88678: DISABLE
88679: LD_INT 0
88681: PPUSH
88682: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88683: LD_ADDR_VAR 0 2
88687: PUSH
88688: LD_INT 22
88690: PUSH
88691: LD_OWVAR 2
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 21
88702: PUSH
88703: LD_INT 1
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PPUSH
88714: CALL_OW 69
88718: ST_TO_ADDR
// if not tmp then
88719: LD_VAR 0 2
88723: NOT
88724: IFFALSE 88728
// exit ;
88726: GO 88815
// un := tmp [ rand ( 1 , tmp ) ] ;
88728: LD_ADDR_VAR 0 1
88732: PUSH
88733: LD_VAR 0 2
88737: PUSH
88738: LD_INT 1
88740: PPUSH
88741: LD_VAR 0 2
88745: PPUSH
88746: CALL_OW 12
88750: ARRAY
88751: ST_TO_ADDR
// SetSide ( un , 0 ) ;
88752: LD_VAR 0 1
88756: PPUSH
88757: LD_INT 0
88759: PPUSH
88760: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
88764: LD_VAR 0 1
88768: PPUSH
88769: LD_OWVAR 3
88773: PUSH
88774: LD_VAR 0 1
88778: DIFF
88779: PPUSH
88780: LD_VAR 0 1
88784: PPUSH
88785: CALL_OW 74
88789: PPUSH
88790: CALL_OW 115
// wait ( 0 0$20 ) ;
88794: LD_INT 700
88796: PPUSH
88797: CALL_OW 67
// SetSide ( un , your_side ) ;
88801: LD_VAR 0 1
88805: PPUSH
88806: LD_OWVAR 2
88810: PPUSH
88811: CALL_OW 235
// end ;
88815: PPOPN 2
88817: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
88818: LD_EXP 108
88822: PUSH
88823: LD_EXP 141
88827: AND
88828: IFFALSE 88934
88830: GO 88832
88832: DISABLE
88833: LD_INT 0
88835: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88836: LD_ADDR_VAR 0 1
88840: PUSH
88841: LD_INT 22
88843: PUSH
88844: LD_OWVAR 2
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PUSH
88853: LD_INT 2
88855: PUSH
88856: LD_INT 30
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: PUSH
88866: LD_INT 30
88868: PUSH
88869: LD_INT 1
88871: PUSH
88872: EMPTY
88873: LIST
88874: LIST
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: LIST
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: PPUSH
88885: CALL_OW 69
88889: ST_TO_ADDR
// if not depot then
88890: LD_VAR 0 1
88894: NOT
88895: IFFALSE 88899
// exit ;
88897: GO 88934
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
88899: LD_VAR 0 1
88903: PUSH
88904: LD_INT 1
88906: ARRAY
88907: PPUSH
88908: CALL_OW 250
88912: PPUSH
88913: LD_VAR 0 1
88917: PUSH
88918: LD_INT 1
88920: ARRAY
88921: PPUSH
88922: CALL_OW 251
88926: PPUSH
88927: LD_INT 70
88929: PPUSH
88930: CALL_OW 495
// end ;
88934: PPOPN 1
88936: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
88937: LD_EXP 108
88941: PUSH
88942: LD_EXP 142
88946: AND
88947: IFFALSE 89158
88949: GO 88951
88951: DISABLE
88952: LD_INT 0
88954: PPUSH
88955: PPUSH
88956: PPUSH
88957: PPUSH
88958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88959: LD_ADDR_VAR 0 5
88963: PUSH
88964: LD_INT 22
88966: PUSH
88967: LD_OWVAR 2
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 21
88978: PUSH
88979: LD_INT 1
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PPUSH
88990: CALL_OW 69
88994: ST_TO_ADDR
// if not tmp then
88995: LD_VAR 0 5
88999: NOT
89000: IFFALSE 89004
// exit ;
89002: GO 89158
// for i in tmp do
89004: LD_ADDR_VAR 0 1
89008: PUSH
89009: LD_VAR 0 5
89013: PUSH
89014: FOR_IN
89015: IFFALSE 89156
// begin d := rand ( 0 , 5 ) ;
89017: LD_ADDR_VAR 0 4
89021: PUSH
89022: LD_INT 0
89024: PPUSH
89025: LD_INT 5
89027: PPUSH
89028: CALL_OW 12
89032: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89033: LD_ADDR_VAR 0 2
89037: PUSH
89038: LD_VAR 0 1
89042: PPUSH
89043: CALL_OW 250
89047: PPUSH
89048: LD_VAR 0 4
89052: PPUSH
89053: LD_INT 3
89055: PPUSH
89056: LD_INT 12
89058: PPUSH
89059: CALL_OW 12
89063: PPUSH
89064: CALL_OW 272
89068: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89069: LD_ADDR_VAR 0 3
89073: PUSH
89074: LD_VAR 0 1
89078: PPUSH
89079: CALL_OW 251
89083: PPUSH
89084: LD_VAR 0 4
89088: PPUSH
89089: LD_INT 3
89091: PPUSH
89092: LD_INT 12
89094: PPUSH
89095: CALL_OW 12
89099: PPUSH
89100: CALL_OW 273
89104: ST_TO_ADDR
// if ValidHex ( x , y ) then
89105: LD_VAR 0 2
89109: PPUSH
89110: LD_VAR 0 3
89114: PPUSH
89115: CALL_OW 488
89119: IFFALSE 89154
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89121: LD_VAR 0 1
89125: PPUSH
89126: LD_VAR 0 2
89130: PPUSH
89131: LD_VAR 0 3
89135: PPUSH
89136: LD_INT 3
89138: PPUSH
89139: LD_INT 6
89141: PPUSH
89142: CALL_OW 12
89146: PPUSH
89147: LD_INT 1
89149: PPUSH
89150: CALL_OW 483
// end ;
89154: GO 89014
89156: POP
89157: POP
// end ;
89158: PPOPN 5
89160: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89161: LD_EXP 108
89165: PUSH
89166: LD_EXP 143
89170: AND
89171: IFFALSE 89265
89173: GO 89175
89175: DISABLE
89176: LD_INT 0
89178: PPUSH
89179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89180: LD_ADDR_VAR 0 2
89184: PUSH
89185: LD_INT 22
89187: PUSH
89188: LD_OWVAR 2
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 32
89199: PUSH
89200: LD_INT 1
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 21
89209: PUSH
89210: LD_INT 2
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: LIST
89221: PPUSH
89222: CALL_OW 69
89226: ST_TO_ADDR
// if not tmp then
89227: LD_VAR 0 2
89231: NOT
89232: IFFALSE 89236
// exit ;
89234: GO 89265
// for i in tmp do
89236: LD_ADDR_VAR 0 1
89240: PUSH
89241: LD_VAR 0 2
89245: PUSH
89246: FOR_IN
89247: IFFALSE 89263
// SetFuel ( i , 0 ) ;
89249: LD_VAR 0 1
89253: PPUSH
89254: LD_INT 0
89256: PPUSH
89257: CALL_OW 240
89261: GO 89246
89263: POP
89264: POP
// end ;
89265: PPOPN 2
89267: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89268: LD_EXP 108
89272: PUSH
89273: LD_EXP 144
89277: AND
89278: IFFALSE 89344
89280: GO 89282
89282: DISABLE
89283: LD_INT 0
89285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89286: LD_ADDR_VAR 0 1
89290: PUSH
89291: LD_INT 22
89293: PUSH
89294: LD_OWVAR 2
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 30
89305: PUSH
89306: LD_INT 29
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PPUSH
89317: CALL_OW 69
89321: ST_TO_ADDR
// if not tmp then
89322: LD_VAR 0 1
89326: NOT
89327: IFFALSE 89331
// exit ;
89329: GO 89344
// DestroyUnit ( tmp [ 1 ] ) ;
89331: LD_VAR 0 1
89335: PUSH
89336: LD_INT 1
89338: ARRAY
89339: PPUSH
89340: CALL_OW 65
// end ;
89344: PPOPN 1
89346: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89347: LD_EXP 108
89351: PUSH
89352: LD_EXP 146
89356: AND
89357: IFFALSE 89486
89359: GO 89361
89361: DISABLE
89362: LD_INT 0
89364: PPUSH
// begin uc_side := 0 ;
89365: LD_ADDR_OWVAR 20
89369: PUSH
89370: LD_INT 0
89372: ST_TO_ADDR
// uc_nation := nation_arabian ;
89373: LD_ADDR_OWVAR 21
89377: PUSH
89378: LD_INT 2
89380: ST_TO_ADDR
// hc_gallery :=  ;
89381: LD_ADDR_OWVAR 33
89385: PUSH
89386: LD_STRING 
89388: ST_TO_ADDR
// hc_name :=  ;
89389: LD_ADDR_OWVAR 26
89393: PUSH
89394: LD_STRING 
89396: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89397: LD_INT 1
89399: PPUSH
89400: LD_INT 11
89402: PPUSH
89403: LD_INT 10
89405: PPUSH
89406: CALL_OW 380
// un := CreateHuman ;
89410: LD_ADDR_VAR 0 1
89414: PUSH
89415: CALL_OW 44
89419: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89420: LD_VAR 0 1
89424: PPUSH
89425: LD_INT 1
89427: PPUSH
89428: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89432: LD_INT 35
89434: PPUSH
89435: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89439: LD_VAR 0 1
89443: PPUSH
89444: LD_INT 22
89446: PUSH
89447: LD_OWVAR 2
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PPUSH
89456: CALL_OW 69
89460: PPUSH
89461: LD_VAR 0 1
89465: PPUSH
89466: CALL_OW 74
89470: PPUSH
89471: CALL_OW 115
// until IsDead ( un ) ;
89475: LD_VAR 0 1
89479: PPUSH
89480: CALL_OW 301
89484: IFFALSE 89432
// end ;
89486: PPOPN 1
89488: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89489: LD_EXP 108
89493: PUSH
89494: LD_EXP 148
89498: AND
89499: IFFALSE 89511
89501: GO 89503
89503: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89504: LD_STRING earthquake(getX(game), 0, 32)
89506: PPUSH
89507: CALL_OW 559
89511: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89512: LD_EXP 108
89516: PUSH
89517: LD_EXP 149
89521: AND
89522: IFFALSE 89613
89524: GO 89526
89526: DISABLE
89527: LD_INT 0
89529: PPUSH
// begin enable ;
89530: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89531: LD_ADDR_VAR 0 1
89535: PUSH
89536: LD_INT 22
89538: PUSH
89539: LD_OWVAR 2
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 21
89550: PUSH
89551: LD_INT 2
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 33
89560: PUSH
89561: LD_INT 3
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: LIST
89572: PPUSH
89573: CALL_OW 69
89577: ST_TO_ADDR
// if not tmp then
89578: LD_VAR 0 1
89582: NOT
89583: IFFALSE 89587
// exit ;
89585: GO 89613
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
89587: LD_VAR 0 1
89591: PUSH
89592: LD_INT 1
89594: PPUSH
89595: LD_VAR 0 1
89599: PPUSH
89600: CALL_OW 12
89604: ARRAY
89605: PPUSH
89606: LD_INT 1
89608: PPUSH
89609: CALL_OW 234
// end ;
89613: PPOPN 1
89615: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
89616: LD_EXP 108
89620: PUSH
89621: LD_EXP 150
89625: AND
89626: IFFALSE 89767
89628: GO 89630
89630: DISABLE
89631: LD_INT 0
89633: PPUSH
89634: PPUSH
89635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89636: LD_ADDR_VAR 0 3
89640: PUSH
89641: LD_INT 22
89643: PUSH
89644: LD_OWVAR 2
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 25
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: PPUSH
89667: CALL_OW 69
89671: ST_TO_ADDR
// if not tmp then
89672: LD_VAR 0 3
89676: NOT
89677: IFFALSE 89681
// exit ;
89679: GO 89767
// un := tmp [ rand ( 1 , tmp ) ] ;
89681: LD_ADDR_VAR 0 2
89685: PUSH
89686: LD_VAR 0 3
89690: PUSH
89691: LD_INT 1
89693: PPUSH
89694: LD_VAR 0 3
89698: PPUSH
89699: CALL_OW 12
89703: ARRAY
89704: ST_TO_ADDR
// if Crawls ( un ) then
89705: LD_VAR 0 2
89709: PPUSH
89710: CALL_OW 318
89714: IFFALSE 89725
// ComWalk ( un ) ;
89716: LD_VAR 0 2
89720: PPUSH
89721: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
89725: LD_VAR 0 2
89729: PPUSH
89730: LD_INT 9
89732: PPUSH
89733: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
89737: LD_INT 28
89739: PPUSH
89740: LD_OWVAR 2
89744: PPUSH
89745: LD_INT 2
89747: PPUSH
89748: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
89752: LD_INT 29
89754: PPUSH
89755: LD_OWVAR 2
89759: PPUSH
89760: LD_INT 2
89762: PPUSH
89763: CALL_OW 322
// end ;
89767: PPOPN 3
89769: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
89770: LD_EXP 108
89774: PUSH
89775: LD_EXP 151
89779: AND
89780: IFFALSE 89891
89782: GO 89784
89784: DISABLE
89785: LD_INT 0
89787: PPUSH
89788: PPUSH
89789: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89790: LD_ADDR_VAR 0 3
89794: PUSH
89795: LD_INT 22
89797: PUSH
89798: LD_OWVAR 2
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: PUSH
89807: LD_INT 25
89809: PUSH
89810: LD_INT 1
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PPUSH
89821: CALL_OW 69
89825: ST_TO_ADDR
// if not tmp then
89826: LD_VAR 0 3
89830: NOT
89831: IFFALSE 89835
// exit ;
89833: GO 89891
// un := tmp [ rand ( 1 , tmp ) ] ;
89835: LD_ADDR_VAR 0 2
89839: PUSH
89840: LD_VAR 0 3
89844: PUSH
89845: LD_INT 1
89847: PPUSH
89848: LD_VAR 0 3
89852: PPUSH
89853: CALL_OW 12
89857: ARRAY
89858: ST_TO_ADDR
// if Crawls ( un ) then
89859: LD_VAR 0 2
89863: PPUSH
89864: CALL_OW 318
89868: IFFALSE 89879
// ComWalk ( un ) ;
89870: LD_VAR 0 2
89874: PPUSH
89875: CALL_OW 138
// SetClass ( un , class_mortar ) ;
89879: LD_VAR 0 2
89883: PPUSH
89884: LD_INT 8
89886: PPUSH
89887: CALL_OW 336
// end ;
89891: PPOPN 3
89893: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
89894: LD_EXP 108
89898: PUSH
89899: LD_EXP 152
89903: AND
89904: IFFALSE 90048
89906: GO 89908
89908: DISABLE
89909: LD_INT 0
89911: PPUSH
89912: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
89913: LD_ADDR_VAR 0 2
89917: PUSH
89918: LD_INT 22
89920: PUSH
89921: LD_OWVAR 2
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 21
89932: PUSH
89933: LD_INT 2
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 2
89942: PUSH
89943: LD_INT 34
89945: PUSH
89946: LD_INT 12
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 34
89955: PUSH
89956: LD_INT 51
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 34
89965: PUSH
89966: LD_INT 32
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: LIST
89983: PPUSH
89984: CALL_OW 69
89988: ST_TO_ADDR
// if not tmp then
89989: LD_VAR 0 2
89993: NOT
89994: IFFALSE 89998
// exit ;
89996: GO 90048
// for i in tmp do
89998: LD_ADDR_VAR 0 1
90002: PUSH
90003: LD_VAR 0 2
90007: PUSH
90008: FOR_IN
90009: IFFALSE 90046
// if GetCargo ( i , mat_artifact ) = 0 then
90011: LD_VAR 0 1
90015: PPUSH
90016: LD_INT 4
90018: PPUSH
90019: CALL_OW 289
90023: PUSH
90024: LD_INT 0
90026: EQUAL
90027: IFFALSE 90044
// SetCargo ( i , mat_siberit , 100 ) ;
90029: LD_VAR 0 1
90033: PPUSH
90034: LD_INT 3
90036: PPUSH
90037: LD_INT 100
90039: PPUSH
90040: CALL_OW 290
90044: GO 90008
90046: POP
90047: POP
// end ;
90048: PPOPN 2
90050: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90051: LD_EXP 108
90055: PUSH
90056: LD_EXP 153
90060: AND
90061: IFFALSE 90244
90063: GO 90065
90065: DISABLE
90066: LD_INT 0
90068: PPUSH
90069: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90070: LD_ADDR_VAR 0 2
90074: PUSH
90075: LD_INT 22
90077: PUSH
90078: LD_OWVAR 2
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: PPUSH
90087: CALL_OW 69
90091: ST_TO_ADDR
// if not tmp then
90092: LD_VAR 0 2
90096: NOT
90097: IFFALSE 90101
// exit ;
90099: GO 90244
// for i := 1 to 2 do
90101: LD_ADDR_VAR 0 1
90105: PUSH
90106: DOUBLE
90107: LD_INT 1
90109: DEC
90110: ST_TO_ADDR
90111: LD_INT 2
90113: PUSH
90114: FOR_TO
90115: IFFALSE 90242
// begin uc_side := your_side ;
90117: LD_ADDR_OWVAR 20
90121: PUSH
90122: LD_OWVAR 2
90126: ST_TO_ADDR
// uc_nation := nation_american ;
90127: LD_ADDR_OWVAR 21
90131: PUSH
90132: LD_INT 1
90134: ST_TO_ADDR
// vc_chassis := us_morphling ;
90135: LD_ADDR_OWVAR 37
90139: PUSH
90140: LD_INT 5
90142: ST_TO_ADDR
// vc_engine := engine_siberite ;
90143: LD_ADDR_OWVAR 39
90147: PUSH
90148: LD_INT 3
90150: ST_TO_ADDR
// vc_control := control_computer ;
90151: LD_ADDR_OWVAR 38
90155: PUSH
90156: LD_INT 3
90158: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90159: LD_ADDR_OWVAR 40
90163: PUSH
90164: LD_INT 10
90166: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
90167: LD_VAR 0 2
90171: PUSH
90172: LD_INT 1
90174: ARRAY
90175: PPUSH
90176: CALL_OW 310
90180: NOT
90181: IFFALSE 90228
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
90183: CALL_OW 45
90187: PPUSH
90188: LD_VAR 0 2
90192: PUSH
90193: LD_INT 1
90195: ARRAY
90196: PPUSH
90197: CALL_OW 250
90201: PPUSH
90202: LD_VAR 0 2
90206: PUSH
90207: LD_INT 1
90209: ARRAY
90210: PPUSH
90211: CALL_OW 251
90215: PPUSH
90216: LD_INT 12
90218: PPUSH
90219: LD_INT 1
90221: PPUSH
90222: CALL_OW 50
90226: GO 90240
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
90228: CALL_OW 45
90232: PPUSH
90233: LD_INT 1
90235: PPUSH
90236: CALL_OW 51
// end ;
90240: GO 90114
90242: POP
90243: POP
// end ;
90244: PPOPN 2
90246: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90247: LD_EXP 108
90251: PUSH
90252: LD_EXP 154
90256: AND
90257: IFFALSE 90479
90259: GO 90261
90261: DISABLE
90262: LD_INT 0
90264: PPUSH
90265: PPUSH
90266: PPUSH
90267: PPUSH
90268: PPUSH
90269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90270: LD_ADDR_VAR 0 6
90274: PUSH
90275: LD_INT 22
90277: PUSH
90278: LD_OWVAR 2
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 21
90289: PUSH
90290: LD_INT 1
90292: PUSH
90293: EMPTY
90294: LIST
90295: LIST
90296: PUSH
90297: LD_INT 3
90299: PUSH
90300: LD_INT 23
90302: PUSH
90303: LD_INT 0
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: LIST
90318: PPUSH
90319: CALL_OW 69
90323: ST_TO_ADDR
// if not tmp then
90324: LD_VAR 0 6
90328: NOT
90329: IFFALSE 90333
// exit ;
90331: GO 90479
// s1 := rand ( 1 , 4 ) ;
90333: LD_ADDR_VAR 0 2
90337: PUSH
90338: LD_INT 1
90340: PPUSH
90341: LD_INT 4
90343: PPUSH
90344: CALL_OW 12
90348: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90349: LD_ADDR_VAR 0 4
90353: PUSH
90354: LD_VAR 0 6
90358: PUSH
90359: LD_INT 1
90361: ARRAY
90362: PPUSH
90363: LD_VAR 0 2
90367: PPUSH
90368: CALL_OW 259
90372: ST_TO_ADDR
// if s1 = 1 then
90373: LD_VAR 0 2
90377: PUSH
90378: LD_INT 1
90380: EQUAL
90381: IFFALSE 90401
// s2 := rand ( 2 , 4 ) else
90383: LD_ADDR_VAR 0 3
90387: PUSH
90388: LD_INT 2
90390: PPUSH
90391: LD_INT 4
90393: PPUSH
90394: CALL_OW 12
90398: ST_TO_ADDR
90399: GO 90409
// s2 := 1 ;
90401: LD_ADDR_VAR 0 3
90405: PUSH
90406: LD_INT 1
90408: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90409: LD_ADDR_VAR 0 5
90413: PUSH
90414: LD_VAR 0 6
90418: PUSH
90419: LD_INT 1
90421: ARRAY
90422: PPUSH
90423: LD_VAR 0 3
90427: PPUSH
90428: CALL_OW 259
90432: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90433: LD_VAR 0 6
90437: PUSH
90438: LD_INT 1
90440: ARRAY
90441: PPUSH
90442: LD_VAR 0 2
90446: PPUSH
90447: LD_VAR 0 5
90451: PPUSH
90452: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90456: LD_VAR 0 6
90460: PUSH
90461: LD_INT 1
90463: ARRAY
90464: PPUSH
90465: LD_VAR 0 3
90469: PPUSH
90470: LD_VAR 0 4
90474: PPUSH
90475: CALL_OW 237
// end ;
90479: PPOPN 6
90481: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90482: LD_EXP 108
90486: PUSH
90487: LD_EXP 155
90491: AND
90492: IFFALSE 90571
90494: GO 90496
90496: DISABLE
90497: LD_INT 0
90499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90500: LD_ADDR_VAR 0 1
90504: PUSH
90505: LD_INT 22
90507: PUSH
90508: LD_OWVAR 2
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 30
90519: PUSH
90520: LD_INT 3
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PPUSH
90531: CALL_OW 69
90535: ST_TO_ADDR
// if not tmp then
90536: LD_VAR 0 1
90540: NOT
90541: IFFALSE 90545
// exit ;
90543: GO 90571
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90545: LD_VAR 0 1
90549: PUSH
90550: LD_INT 1
90552: PPUSH
90553: LD_VAR 0 1
90557: PPUSH
90558: CALL_OW 12
90562: ARRAY
90563: PPUSH
90564: LD_INT 1
90566: PPUSH
90567: CALL_OW 234
// end ;
90571: PPOPN 1
90573: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
90574: LD_EXP 108
90578: PUSH
90579: LD_EXP 156
90583: AND
90584: IFFALSE 90696
90586: GO 90588
90588: DISABLE
90589: LD_INT 0
90591: PPUSH
90592: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
90593: LD_ADDR_VAR 0 2
90597: PUSH
90598: LD_INT 22
90600: PUSH
90601: LD_OWVAR 2
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_INT 2
90612: PUSH
90613: LD_INT 30
90615: PUSH
90616: LD_INT 27
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 30
90625: PUSH
90626: LD_INT 26
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: LD_INT 30
90635: PUSH
90636: LD_INT 28
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PPUSH
90653: CALL_OW 69
90657: ST_TO_ADDR
// if not tmp then
90658: LD_VAR 0 2
90662: NOT
90663: IFFALSE 90667
// exit ;
90665: GO 90696
// for i in tmp do
90667: LD_ADDR_VAR 0 1
90671: PUSH
90672: LD_VAR 0 2
90676: PUSH
90677: FOR_IN
90678: IFFALSE 90694
// SetLives ( i , 1 ) ;
90680: LD_VAR 0 1
90684: PPUSH
90685: LD_INT 1
90687: PPUSH
90688: CALL_OW 234
90692: GO 90677
90694: POP
90695: POP
// end ;
90696: PPOPN 2
90698: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
90699: LD_EXP 108
90703: PUSH
90704: LD_EXP 157
90708: AND
90709: IFFALSE 90983
90711: GO 90713
90713: DISABLE
90714: LD_INT 0
90716: PPUSH
90717: PPUSH
90718: PPUSH
// begin i := rand ( 1 , 7 ) ;
90719: LD_ADDR_VAR 0 1
90723: PUSH
90724: LD_INT 1
90726: PPUSH
90727: LD_INT 7
90729: PPUSH
90730: CALL_OW 12
90734: ST_TO_ADDR
// case i of 1 :
90735: LD_VAR 0 1
90739: PUSH
90740: LD_INT 1
90742: DOUBLE
90743: EQUAL
90744: IFTRUE 90748
90746: GO 90758
90748: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
90749: LD_STRING earthquake(getX(game), 0, 32)
90751: PPUSH
90752: CALL_OW 559
90756: GO 90983
90758: LD_INT 2
90760: DOUBLE
90761: EQUAL
90762: IFTRUE 90766
90764: GO 90780
90766: POP
// begin ToLua ( displayStucuk(); ) ;
90767: LD_STRING displayStucuk();
90769: PPUSH
90770: CALL_OW 559
// ResetFog ;
90774: CALL_OW 335
// end ; 3 :
90778: GO 90983
90780: LD_INT 3
90782: DOUBLE
90783: EQUAL
90784: IFTRUE 90788
90786: GO 90892
90788: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90789: LD_ADDR_VAR 0 2
90793: PUSH
90794: LD_INT 22
90796: PUSH
90797: LD_OWVAR 2
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: PUSH
90806: LD_INT 25
90808: PUSH
90809: LD_INT 1
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PPUSH
90820: CALL_OW 69
90824: ST_TO_ADDR
// if not tmp then
90825: LD_VAR 0 2
90829: NOT
90830: IFFALSE 90834
// exit ;
90832: GO 90983
// un := tmp [ rand ( 1 , tmp ) ] ;
90834: LD_ADDR_VAR 0 3
90838: PUSH
90839: LD_VAR 0 2
90843: PUSH
90844: LD_INT 1
90846: PPUSH
90847: LD_VAR 0 2
90851: PPUSH
90852: CALL_OW 12
90856: ARRAY
90857: ST_TO_ADDR
// if Crawls ( un ) then
90858: LD_VAR 0 3
90862: PPUSH
90863: CALL_OW 318
90867: IFFALSE 90878
// ComWalk ( un ) ;
90869: LD_VAR 0 3
90873: PPUSH
90874: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90878: LD_VAR 0 3
90882: PPUSH
90883: LD_INT 8
90885: PPUSH
90886: CALL_OW 336
// end ; 4 :
90890: GO 90983
90892: LD_INT 4
90894: DOUBLE
90895: EQUAL
90896: IFTRUE 90900
90898: GO 90961
90900: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90901: LD_ADDR_VAR 0 2
90905: PUSH
90906: LD_INT 22
90908: PUSH
90909: LD_OWVAR 2
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 30
90920: PUSH
90921: LD_INT 29
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PPUSH
90932: CALL_OW 69
90936: ST_TO_ADDR
// if not tmp then
90937: LD_VAR 0 2
90941: NOT
90942: IFFALSE 90946
// exit ;
90944: GO 90983
// DestroyUnit ( tmp [ 1 ] ) ;
90946: LD_VAR 0 2
90950: PUSH
90951: LD_INT 1
90953: ARRAY
90954: PPUSH
90955: CALL_OW 65
// end ; 5 .. 7 :
90959: GO 90983
90961: LD_INT 5
90963: DOUBLE
90964: GREATEREQUAL
90965: IFFALSE 90973
90967: LD_INT 7
90969: DOUBLE
90970: LESSEQUAL
90971: IFTRUE 90975
90973: GO 90982
90975: POP
// StreamSibBomb ; end ;
90976: CALL 87233 0 0
90980: GO 90983
90982: POP
// end ;
90983: PPOPN 3
90985: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
90986: LD_EXP 108
90990: PUSH
90991: LD_EXP 158
90995: AND
90996: IFFALSE 91152
90998: GO 91000
91000: DISABLE
91001: LD_INT 0
91003: PPUSH
91004: PPUSH
91005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91006: LD_ADDR_VAR 0 2
91010: PUSH
91011: LD_INT 81
91013: PUSH
91014: LD_OWVAR 2
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 2
91025: PUSH
91026: LD_INT 21
91028: PUSH
91029: LD_INT 1
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 21
91038: PUSH
91039: LD_INT 2
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: LIST
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PPUSH
91055: CALL_OW 69
91059: ST_TO_ADDR
// if not tmp then
91060: LD_VAR 0 2
91064: NOT
91065: IFFALSE 91069
// exit ;
91067: GO 91152
// p := 0 ;
91069: LD_ADDR_VAR 0 3
91073: PUSH
91074: LD_INT 0
91076: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91077: LD_INT 35
91079: PPUSH
91080: CALL_OW 67
// p := p + 1 ;
91084: LD_ADDR_VAR 0 3
91088: PUSH
91089: LD_VAR 0 3
91093: PUSH
91094: LD_INT 1
91096: PLUS
91097: ST_TO_ADDR
// for i in tmp do
91098: LD_ADDR_VAR 0 1
91102: PUSH
91103: LD_VAR 0 2
91107: PUSH
91108: FOR_IN
91109: IFFALSE 91140
// if GetLives ( i ) < 1000 then
91111: LD_VAR 0 1
91115: PPUSH
91116: CALL_OW 256
91120: PUSH
91121: LD_INT 1000
91123: LESS
91124: IFFALSE 91138
// SetLives ( i , 1000 ) ;
91126: LD_VAR 0 1
91130: PPUSH
91131: LD_INT 1000
91133: PPUSH
91134: CALL_OW 234
91138: GO 91108
91140: POP
91141: POP
// until p > 20 ;
91142: LD_VAR 0 3
91146: PUSH
91147: LD_INT 20
91149: GREATER
91150: IFFALSE 91077
// end ;
91152: PPOPN 3
91154: END
// every 0 0$1 trigger StreamModeActive and sTime do
91155: LD_EXP 108
91159: PUSH
91160: LD_EXP 159
91164: AND
91165: IFFALSE 91200
91167: GO 91169
91169: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91170: LD_INT 28
91172: PPUSH
91173: LD_OWVAR 2
91177: PPUSH
91178: LD_INT 2
91180: PPUSH
91181: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91185: LD_INT 30
91187: PPUSH
91188: LD_OWVAR 2
91192: PPUSH
91193: LD_INT 2
91195: PPUSH
91196: CALL_OW 322
// end ;
91200: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91201: LD_EXP 108
91205: PUSH
91206: LD_EXP 160
91210: AND
91211: IFFALSE 91332
91213: GO 91215
91215: DISABLE
91216: LD_INT 0
91218: PPUSH
91219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91220: LD_ADDR_VAR 0 2
91224: PUSH
91225: LD_INT 22
91227: PUSH
91228: LD_OWVAR 2
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 21
91239: PUSH
91240: LD_INT 1
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 3
91249: PUSH
91250: LD_INT 23
91252: PUSH
91253: LD_INT 0
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: EMPTY
91265: LIST
91266: LIST
91267: LIST
91268: PPUSH
91269: CALL_OW 69
91273: ST_TO_ADDR
// if not tmp then
91274: LD_VAR 0 2
91278: NOT
91279: IFFALSE 91283
// exit ;
91281: GO 91332
// for i in tmp do
91283: LD_ADDR_VAR 0 1
91287: PUSH
91288: LD_VAR 0 2
91292: PUSH
91293: FOR_IN
91294: IFFALSE 91330
// begin if Crawls ( i ) then
91296: LD_VAR 0 1
91300: PPUSH
91301: CALL_OW 318
91305: IFFALSE 91316
// ComWalk ( i ) ;
91307: LD_VAR 0 1
91311: PPUSH
91312: CALL_OW 138
// SetClass ( i , 2 ) ;
91316: LD_VAR 0 1
91320: PPUSH
91321: LD_INT 2
91323: PPUSH
91324: CALL_OW 336
// end ;
91328: GO 91293
91330: POP
91331: POP
// end ;
91332: PPOPN 2
91334: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91335: LD_EXP 108
91339: PUSH
91340: LD_EXP 161
91344: AND
91345: IFFALSE 91626
91347: GO 91349
91349: DISABLE
91350: LD_INT 0
91352: PPUSH
91353: PPUSH
91354: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91355: LD_OWVAR 2
91359: PPUSH
91360: LD_INT 9
91362: PPUSH
91363: LD_INT 1
91365: PPUSH
91366: LD_INT 1
91368: PPUSH
91369: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91373: LD_INT 9
91375: PPUSH
91376: LD_OWVAR 2
91380: PPUSH
91381: CALL_OW 343
// uc_side := 9 ;
91385: LD_ADDR_OWVAR 20
91389: PUSH
91390: LD_INT 9
91392: ST_TO_ADDR
// uc_nation := 2 ;
91393: LD_ADDR_OWVAR 21
91397: PUSH
91398: LD_INT 2
91400: ST_TO_ADDR
// hc_name := Dark Warrior ;
91401: LD_ADDR_OWVAR 26
91405: PUSH
91406: LD_STRING Dark Warrior
91408: ST_TO_ADDR
// hc_gallery :=  ;
91409: LD_ADDR_OWVAR 33
91413: PUSH
91414: LD_STRING 
91416: ST_TO_ADDR
// hc_noskilllimit := true ;
91417: LD_ADDR_OWVAR 76
91421: PUSH
91422: LD_INT 1
91424: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91425: LD_ADDR_OWVAR 31
91429: PUSH
91430: LD_INT 30
91432: PUSH
91433: LD_INT 30
91435: PUSH
91436: LD_INT 30
91438: PUSH
91439: LD_INT 30
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: ST_TO_ADDR
// un := CreateHuman ;
91448: LD_ADDR_VAR 0 3
91452: PUSH
91453: CALL_OW 44
91457: ST_TO_ADDR
// hc_noskilllimit := false ;
91458: LD_ADDR_OWVAR 76
91462: PUSH
91463: LD_INT 0
91465: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91466: LD_VAR 0 3
91470: PPUSH
91471: LD_INT 1
91473: PPUSH
91474: CALL_OW 51
// p := 0 ;
91478: LD_ADDR_VAR 0 2
91482: PUSH
91483: LD_INT 0
91485: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91486: LD_INT 35
91488: PPUSH
91489: CALL_OW 67
// p := p + 1 ;
91493: LD_ADDR_VAR 0 2
91497: PUSH
91498: LD_VAR 0 2
91502: PUSH
91503: LD_INT 1
91505: PLUS
91506: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91507: LD_VAR 0 3
91511: PPUSH
91512: CALL_OW 256
91516: PUSH
91517: LD_INT 1000
91519: LESS
91520: IFFALSE 91534
// SetLives ( un , 1000 ) ;
91522: LD_VAR 0 3
91526: PPUSH
91527: LD_INT 1000
91529: PPUSH
91530: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91534: LD_VAR 0 3
91538: PPUSH
91539: LD_INT 81
91541: PUSH
91542: LD_OWVAR 2
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 91
91553: PUSH
91554: LD_VAR 0 3
91558: PUSH
91559: LD_INT 30
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: LIST
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PPUSH
91571: CALL_OW 69
91575: PPUSH
91576: LD_VAR 0 3
91580: PPUSH
91581: CALL_OW 74
91585: PPUSH
91586: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
91590: LD_VAR 0 2
91594: PUSH
91595: LD_INT 60
91597: GREATER
91598: PUSH
91599: LD_VAR 0 3
91603: PPUSH
91604: CALL_OW 301
91608: OR
91609: IFFALSE 91486
// if un then
91611: LD_VAR 0 3
91615: IFFALSE 91626
// RemoveUnit ( un ) ;
91617: LD_VAR 0 3
91621: PPUSH
91622: CALL_OW 64
// end ;
91626: PPOPN 3
91628: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91629: LD_INT 0
91631: PPUSH
// case cmd of 301 :
91632: LD_VAR 0 1
91636: PUSH
91637: LD_INT 301
91639: DOUBLE
91640: EQUAL
91641: IFTRUE 91645
91643: GO 91677
91645: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
91646: LD_VAR 0 6
91650: PPUSH
91651: LD_VAR 0 7
91655: PPUSH
91656: LD_VAR 0 8
91660: PPUSH
91661: LD_VAR 0 4
91665: PPUSH
91666: LD_VAR 0 5
91670: PPUSH
91671: CALL 92878 0 5
91675: GO 91798
91677: LD_INT 302
91679: DOUBLE
91680: EQUAL
91681: IFTRUE 91685
91683: GO 91722
91685: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
91686: LD_VAR 0 6
91690: PPUSH
91691: LD_VAR 0 7
91695: PPUSH
91696: LD_VAR 0 8
91700: PPUSH
91701: LD_VAR 0 9
91705: PPUSH
91706: LD_VAR 0 4
91710: PPUSH
91711: LD_VAR 0 5
91715: PPUSH
91716: CALL 92969 0 6
91720: GO 91798
91722: LD_INT 303
91724: DOUBLE
91725: EQUAL
91726: IFTRUE 91730
91728: GO 91767
91730: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
91731: LD_VAR 0 6
91735: PPUSH
91736: LD_VAR 0 7
91740: PPUSH
91741: LD_VAR 0 8
91745: PPUSH
91746: LD_VAR 0 9
91750: PPUSH
91751: LD_VAR 0 4
91755: PPUSH
91756: LD_VAR 0 5
91760: PPUSH
91761: CALL 91803 0 6
91765: GO 91798
91767: LD_INT 304
91769: DOUBLE
91770: EQUAL
91771: IFTRUE 91775
91773: GO 91797
91775: POP
// hHackTeleport ( unit , x , y ) ; end ;
91776: LD_VAR 0 2
91780: PPUSH
91781: LD_VAR 0 4
91785: PPUSH
91786: LD_VAR 0 5
91790: PPUSH
91791: CALL 93562 0 3
91795: GO 91798
91797: POP
// end ;
91798: LD_VAR 0 12
91802: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
91803: LD_INT 0
91805: PPUSH
91806: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
91807: LD_VAR 0 1
91811: PUSH
91812: LD_INT 1
91814: LESS
91815: PUSH
91816: LD_VAR 0 1
91820: PUSH
91821: LD_INT 3
91823: GREATER
91824: OR
91825: PUSH
91826: LD_VAR 0 5
91830: PPUSH
91831: LD_VAR 0 6
91835: PPUSH
91836: CALL_OW 428
91840: OR
91841: IFFALSE 91845
// exit ;
91843: GO 92565
// uc_side := your_side ;
91845: LD_ADDR_OWVAR 20
91849: PUSH
91850: LD_OWVAR 2
91854: ST_TO_ADDR
// uc_nation := nation ;
91855: LD_ADDR_OWVAR 21
91859: PUSH
91860: LD_VAR 0 1
91864: ST_TO_ADDR
// bc_level = 1 ;
91865: LD_ADDR_OWVAR 43
91869: PUSH
91870: LD_INT 1
91872: ST_TO_ADDR
// case btype of 1 :
91873: LD_VAR 0 2
91877: PUSH
91878: LD_INT 1
91880: DOUBLE
91881: EQUAL
91882: IFTRUE 91886
91884: GO 91897
91886: POP
// bc_type := b_depot ; 2 :
91887: LD_ADDR_OWVAR 42
91891: PUSH
91892: LD_INT 0
91894: ST_TO_ADDR
91895: GO 92509
91897: LD_INT 2
91899: DOUBLE
91900: EQUAL
91901: IFTRUE 91905
91903: GO 91916
91905: POP
// bc_type := b_warehouse ; 3 :
91906: LD_ADDR_OWVAR 42
91910: PUSH
91911: LD_INT 1
91913: ST_TO_ADDR
91914: GO 92509
91916: LD_INT 3
91918: DOUBLE
91919: EQUAL
91920: IFTRUE 91924
91922: GO 91935
91924: POP
// bc_type := b_lab ; 4 .. 9 :
91925: LD_ADDR_OWVAR 42
91929: PUSH
91930: LD_INT 6
91932: ST_TO_ADDR
91933: GO 92509
91935: LD_INT 4
91937: DOUBLE
91938: GREATEREQUAL
91939: IFFALSE 91947
91941: LD_INT 9
91943: DOUBLE
91944: LESSEQUAL
91945: IFTRUE 91949
91947: GO 92001
91949: POP
// begin bc_type := b_lab_half ;
91950: LD_ADDR_OWVAR 42
91954: PUSH
91955: LD_INT 7
91957: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
91958: LD_ADDR_OWVAR 44
91962: PUSH
91963: LD_INT 10
91965: PUSH
91966: LD_INT 11
91968: PUSH
91969: LD_INT 12
91971: PUSH
91972: LD_INT 15
91974: PUSH
91975: LD_INT 14
91977: PUSH
91978: LD_INT 13
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: PUSH
91989: LD_VAR 0 2
91993: PUSH
91994: LD_INT 3
91996: MINUS
91997: ARRAY
91998: ST_TO_ADDR
// end ; 10 .. 13 :
91999: GO 92509
92001: LD_INT 10
92003: DOUBLE
92004: GREATEREQUAL
92005: IFFALSE 92013
92007: LD_INT 13
92009: DOUBLE
92010: LESSEQUAL
92011: IFTRUE 92015
92013: GO 92092
92015: POP
// begin bc_type := b_lab_full ;
92016: LD_ADDR_OWVAR 42
92020: PUSH
92021: LD_INT 8
92023: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
92024: LD_ADDR_OWVAR 44
92028: PUSH
92029: LD_INT 10
92031: PUSH
92032: LD_INT 12
92034: PUSH
92035: LD_INT 14
92037: PUSH
92038: LD_INT 13
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: PUSH
92047: LD_VAR 0 2
92051: PUSH
92052: LD_INT 9
92054: MINUS
92055: ARRAY
92056: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
92057: LD_ADDR_OWVAR 45
92061: PUSH
92062: LD_INT 11
92064: PUSH
92065: LD_INT 15
92067: PUSH
92068: LD_INT 12
92070: PUSH
92071: LD_INT 15
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: PUSH
92080: LD_VAR 0 2
92084: PUSH
92085: LD_INT 9
92087: MINUS
92088: ARRAY
92089: ST_TO_ADDR
// end ; 14 :
92090: GO 92509
92092: LD_INT 14
92094: DOUBLE
92095: EQUAL
92096: IFTRUE 92100
92098: GO 92111
92100: POP
// bc_type := b_workshop ; 15 :
92101: LD_ADDR_OWVAR 42
92105: PUSH
92106: LD_INT 2
92108: ST_TO_ADDR
92109: GO 92509
92111: LD_INT 15
92113: DOUBLE
92114: EQUAL
92115: IFTRUE 92119
92117: GO 92130
92119: POP
// bc_type := b_factory ; 16 :
92120: LD_ADDR_OWVAR 42
92124: PUSH
92125: LD_INT 3
92127: ST_TO_ADDR
92128: GO 92509
92130: LD_INT 16
92132: DOUBLE
92133: EQUAL
92134: IFTRUE 92138
92136: GO 92149
92138: POP
// bc_type := b_ext_gun ; 17 :
92139: LD_ADDR_OWVAR 42
92143: PUSH
92144: LD_INT 17
92146: ST_TO_ADDR
92147: GO 92509
92149: LD_INT 17
92151: DOUBLE
92152: EQUAL
92153: IFTRUE 92157
92155: GO 92185
92157: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
92158: LD_ADDR_OWVAR 42
92162: PUSH
92163: LD_INT 19
92165: PUSH
92166: LD_INT 23
92168: PUSH
92169: LD_INT 19
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: LIST
92176: PUSH
92177: LD_VAR 0 1
92181: ARRAY
92182: ST_TO_ADDR
92183: GO 92509
92185: LD_INT 18
92187: DOUBLE
92188: EQUAL
92189: IFTRUE 92193
92191: GO 92204
92193: POP
// bc_type := b_ext_radar ; 19 :
92194: LD_ADDR_OWVAR 42
92198: PUSH
92199: LD_INT 20
92201: ST_TO_ADDR
92202: GO 92509
92204: LD_INT 19
92206: DOUBLE
92207: EQUAL
92208: IFTRUE 92212
92210: GO 92223
92212: POP
// bc_type := b_ext_radio ; 20 :
92213: LD_ADDR_OWVAR 42
92217: PUSH
92218: LD_INT 22
92220: ST_TO_ADDR
92221: GO 92509
92223: LD_INT 20
92225: DOUBLE
92226: EQUAL
92227: IFTRUE 92231
92229: GO 92242
92231: POP
// bc_type := b_ext_siberium ; 21 :
92232: LD_ADDR_OWVAR 42
92236: PUSH
92237: LD_INT 21
92239: ST_TO_ADDR
92240: GO 92509
92242: LD_INT 21
92244: DOUBLE
92245: EQUAL
92246: IFTRUE 92250
92248: GO 92261
92250: POP
// bc_type := b_ext_computer ; 22 :
92251: LD_ADDR_OWVAR 42
92255: PUSH
92256: LD_INT 24
92258: ST_TO_ADDR
92259: GO 92509
92261: LD_INT 22
92263: DOUBLE
92264: EQUAL
92265: IFTRUE 92269
92267: GO 92280
92269: POP
// bc_type := b_ext_track ; 23 :
92270: LD_ADDR_OWVAR 42
92274: PUSH
92275: LD_INT 16
92277: ST_TO_ADDR
92278: GO 92509
92280: LD_INT 23
92282: DOUBLE
92283: EQUAL
92284: IFTRUE 92288
92286: GO 92299
92288: POP
// bc_type := b_ext_laser ; 24 :
92289: LD_ADDR_OWVAR 42
92293: PUSH
92294: LD_INT 25
92296: ST_TO_ADDR
92297: GO 92509
92299: LD_INT 24
92301: DOUBLE
92302: EQUAL
92303: IFTRUE 92307
92305: GO 92318
92307: POP
// bc_type := b_control_tower ; 25 :
92308: LD_ADDR_OWVAR 42
92312: PUSH
92313: LD_INT 36
92315: ST_TO_ADDR
92316: GO 92509
92318: LD_INT 25
92320: DOUBLE
92321: EQUAL
92322: IFTRUE 92326
92324: GO 92337
92326: POP
// bc_type := b_breastwork ; 26 :
92327: LD_ADDR_OWVAR 42
92331: PUSH
92332: LD_INT 31
92334: ST_TO_ADDR
92335: GO 92509
92337: LD_INT 26
92339: DOUBLE
92340: EQUAL
92341: IFTRUE 92345
92343: GO 92356
92345: POP
// bc_type := b_bunker ; 27 :
92346: LD_ADDR_OWVAR 42
92350: PUSH
92351: LD_INT 32
92353: ST_TO_ADDR
92354: GO 92509
92356: LD_INT 27
92358: DOUBLE
92359: EQUAL
92360: IFTRUE 92364
92362: GO 92375
92364: POP
// bc_type := b_turret ; 28 :
92365: LD_ADDR_OWVAR 42
92369: PUSH
92370: LD_INT 33
92372: ST_TO_ADDR
92373: GO 92509
92375: LD_INT 28
92377: DOUBLE
92378: EQUAL
92379: IFTRUE 92383
92381: GO 92394
92383: POP
// bc_type := b_armoury ; 29 :
92384: LD_ADDR_OWVAR 42
92388: PUSH
92389: LD_INT 4
92391: ST_TO_ADDR
92392: GO 92509
92394: LD_INT 29
92396: DOUBLE
92397: EQUAL
92398: IFTRUE 92402
92400: GO 92413
92402: POP
// bc_type := b_barracks ; 30 :
92403: LD_ADDR_OWVAR 42
92407: PUSH
92408: LD_INT 5
92410: ST_TO_ADDR
92411: GO 92509
92413: LD_INT 30
92415: DOUBLE
92416: EQUAL
92417: IFTRUE 92421
92419: GO 92432
92421: POP
// bc_type := b_solar_power ; 31 :
92422: LD_ADDR_OWVAR 42
92426: PUSH
92427: LD_INT 27
92429: ST_TO_ADDR
92430: GO 92509
92432: LD_INT 31
92434: DOUBLE
92435: EQUAL
92436: IFTRUE 92440
92438: GO 92451
92440: POP
// bc_type := b_oil_power ; 32 :
92441: LD_ADDR_OWVAR 42
92445: PUSH
92446: LD_INT 26
92448: ST_TO_ADDR
92449: GO 92509
92451: LD_INT 32
92453: DOUBLE
92454: EQUAL
92455: IFTRUE 92459
92457: GO 92470
92459: POP
// bc_type := b_siberite_power ; 33 :
92460: LD_ADDR_OWVAR 42
92464: PUSH
92465: LD_INT 28
92467: ST_TO_ADDR
92468: GO 92509
92470: LD_INT 33
92472: DOUBLE
92473: EQUAL
92474: IFTRUE 92478
92476: GO 92489
92478: POP
// bc_type := b_oil_mine ; 34 :
92479: LD_ADDR_OWVAR 42
92483: PUSH
92484: LD_INT 29
92486: ST_TO_ADDR
92487: GO 92509
92489: LD_INT 34
92491: DOUBLE
92492: EQUAL
92493: IFTRUE 92497
92495: GO 92508
92497: POP
// bc_type := b_siberite_mine ; end ;
92498: LD_ADDR_OWVAR 42
92502: PUSH
92503: LD_INT 30
92505: ST_TO_ADDR
92506: GO 92509
92508: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
92509: LD_ADDR_VAR 0 8
92513: PUSH
92514: LD_VAR 0 5
92518: PPUSH
92519: LD_VAR 0 6
92523: PPUSH
92524: LD_VAR 0 3
92528: PPUSH
92529: CALL_OW 47
92533: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
92534: LD_OWVAR 42
92538: PUSH
92539: LD_INT 32
92541: PUSH
92542: LD_INT 33
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: IN
92549: IFFALSE 92565
// PlaceWeaponTurret ( b , weapon ) ;
92551: LD_VAR 0 8
92555: PPUSH
92556: LD_VAR 0 4
92560: PPUSH
92561: CALL_OW 431
// end ;
92565: LD_VAR 0 7
92569: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
92570: LD_INT 0
92572: PPUSH
92573: PPUSH
92574: PPUSH
92575: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92576: LD_ADDR_VAR 0 4
92580: PUSH
92581: LD_INT 22
92583: PUSH
92584: LD_OWVAR 2
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 2
92595: PUSH
92596: LD_INT 30
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 30
92608: PUSH
92609: LD_INT 1
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: LIST
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PPUSH
92625: CALL_OW 69
92629: ST_TO_ADDR
// if not tmp then
92630: LD_VAR 0 4
92634: NOT
92635: IFFALSE 92639
// exit ;
92637: GO 92698
// for i in tmp do
92639: LD_ADDR_VAR 0 2
92643: PUSH
92644: LD_VAR 0 4
92648: PUSH
92649: FOR_IN
92650: IFFALSE 92696
// for j = 1 to 3 do
92652: LD_ADDR_VAR 0 3
92656: PUSH
92657: DOUBLE
92658: LD_INT 1
92660: DEC
92661: ST_TO_ADDR
92662: LD_INT 3
92664: PUSH
92665: FOR_TO
92666: IFFALSE 92692
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
92668: LD_VAR 0 2
92672: PPUSH
92673: CALL_OW 274
92677: PPUSH
92678: LD_VAR 0 3
92682: PPUSH
92683: LD_INT 99999
92685: PPUSH
92686: CALL_OW 277
92690: GO 92665
92692: POP
92693: POP
92694: GO 92649
92696: POP
92697: POP
// end ;
92698: LD_VAR 0 1
92702: RET
// export function hHackSetLevel10 ; var i , j ; begin
92703: LD_INT 0
92705: PPUSH
92706: PPUSH
92707: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
92708: LD_ADDR_VAR 0 2
92712: PUSH
92713: LD_INT 21
92715: PUSH
92716: LD_INT 1
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: PPUSH
92723: CALL_OW 69
92727: PUSH
92728: FOR_IN
92729: IFFALSE 92781
// if IsSelected ( i ) then
92731: LD_VAR 0 2
92735: PPUSH
92736: CALL_OW 306
92740: IFFALSE 92779
// begin for j := 1 to 4 do
92742: LD_ADDR_VAR 0 3
92746: PUSH
92747: DOUBLE
92748: LD_INT 1
92750: DEC
92751: ST_TO_ADDR
92752: LD_INT 4
92754: PUSH
92755: FOR_TO
92756: IFFALSE 92777
// SetSkill ( i , j , 10 ) ;
92758: LD_VAR 0 2
92762: PPUSH
92763: LD_VAR 0 3
92767: PPUSH
92768: LD_INT 10
92770: PPUSH
92771: CALL_OW 237
92775: GO 92755
92777: POP
92778: POP
// end ;
92779: GO 92728
92781: POP
92782: POP
// end ;
92783: LD_VAR 0 1
92787: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
92788: LD_INT 0
92790: PPUSH
92791: PPUSH
92792: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
92793: LD_ADDR_VAR 0 2
92797: PUSH
92798: LD_INT 22
92800: PUSH
92801: LD_OWVAR 2
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 21
92812: PUSH
92813: LD_INT 1
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PPUSH
92824: CALL_OW 69
92828: PUSH
92829: FOR_IN
92830: IFFALSE 92871
// begin for j := 1 to 4 do
92832: LD_ADDR_VAR 0 3
92836: PUSH
92837: DOUBLE
92838: LD_INT 1
92840: DEC
92841: ST_TO_ADDR
92842: LD_INT 4
92844: PUSH
92845: FOR_TO
92846: IFFALSE 92867
// SetSkill ( i , j , 10 ) ;
92848: LD_VAR 0 2
92852: PPUSH
92853: LD_VAR 0 3
92857: PPUSH
92858: LD_INT 10
92860: PPUSH
92861: CALL_OW 237
92865: GO 92845
92867: POP
92868: POP
// end ;
92869: GO 92829
92871: POP
92872: POP
// end ;
92873: LD_VAR 0 1
92877: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
92878: LD_INT 0
92880: PPUSH
// uc_side := your_side ;
92881: LD_ADDR_OWVAR 20
92885: PUSH
92886: LD_OWVAR 2
92890: ST_TO_ADDR
// uc_nation := nation ;
92891: LD_ADDR_OWVAR 21
92895: PUSH
92896: LD_VAR 0 1
92900: ST_TO_ADDR
// InitHc ;
92901: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
92905: LD_INT 0
92907: PPUSH
92908: LD_VAR 0 2
92912: PPUSH
92913: LD_VAR 0 3
92917: PPUSH
92918: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
92922: LD_VAR 0 4
92926: PPUSH
92927: LD_VAR 0 5
92931: PPUSH
92932: CALL_OW 428
92936: PUSH
92937: LD_INT 0
92939: EQUAL
92940: IFFALSE 92964
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
92942: CALL_OW 44
92946: PPUSH
92947: LD_VAR 0 4
92951: PPUSH
92952: LD_VAR 0 5
92956: PPUSH
92957: LD_INT 1
92959: PPUSH
92960: CALL_OW 48
// end ;
92964: LD_VAR 0 6
92968: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
92969: LD_INT 0
92971: PPUSH
92972: PPUSH
// uc_side := your_side ;
92973: LD_ADDR_OWVAR 20
92977: PUSH
92978: LD_OWVAR 2
92982: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
92983: LD_VAR 0 1
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: LD_INT 2
92993: PUSH
92994: LD_INT 3
92996: PUSH
92997: LD_INT 4
92999: PUSH
93000: LD_INT 5
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: IN
93010: IFFALSE 93022
// uc_nation := nation_american else
93012: LD_ADDR_OWVAR 21
93016: PUSH
93017: LD_INT 1
93019: ST_TO_ADDR
93020: GO 93065
// if chassis in [ 11 , 12 , 13 , 14 ] then
93022: LD_VAR 0 1
93026: PUSH
93027: LD_INT 11
93029: PUSH
93030: LD_INT 12
93032: PUSH
93033: LD_INT 13
93035: PUSH
93036: LD_INT 14
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: IN
93045: IFFALSE 93057
// uc_nation := nation_arabian else
93047: LD_ADDR_OWVAR 21
93051: PUSH
93052: LD_INT 2
93054: ST_TO_ADDR
93055: GO 93065
// uc_nation := nation_russian ;
93057: LD_ADDR_OWVAR 21
93061: PUSH
93062: LD_INT 3
93064: ST_TO_ADDR
// vc_chassis := chassis ;
93065: LD_ADDR_OWVAR 37
93069: PUSH
93070: LD_VAR 0 1
93074: ST_TO_ADDR
// vc_engine := engine ;
93075: LD_ADDR_OWVAR 39
93079: PUSH
93080: LD_VAR 0 2
93084: ST_TO_ADDR
// vc_control := control ;
93085: LD_ADDR_OWVAR 38
93089: PUSH
93090: LD_VAR 0 3
93094: ST_TO_ADDR
// vc_weapon := weapon ;
93095: LD_ADDR_OWVAR 40
93099: PUSH
93100: LD_VAR 0 4
93104: ST_TO_ADDR
// un := CreateVehicle ;
93105: LD_ADDR_VAR 0 8
93109: PUSH
93110: CALL_OW 45
93114: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
93115: LD_VAR 0 8
93119: PPUSH
93120: LD_INT 0
93122: PPUSH
93123: LD_INT 5
93125: PPUSH
93126: CALL_OW 12
93130: PPUSH
93131: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
93135: LD_VAR 0 8
93139: PPUSH
93140: LD_VAR 0 5
93144: PPUSH
93145: LD_VAR 0 6
93149: PPUSH
93150: LD_INT 1
93152: PPUSH
93153: CALL_OW 48
// end ;
93157: LD_VAR 0 7
93161: RET
// export hInvincible ; every 1 do
93162: GO 93164
93164: DISABLE
// hInvincible := [ ] ;
93165: LD_ADDR_EXP 162
93169: PUSH
93170: EMPTY
93171: ST_TO_ADDR
93172: END
// every 10 do var i ;
93173: GO 93175
93175: DISABLE
93176: LD_INT 0
93178: PPUSH
// begin enable ;
93179: ENABLE
// if not hInvincible then
93180: LD_EXP 162
93184: NOT
93185: IFFALSE 93189
// exit ;
93187: GO 93233
// for i in hInvincible do
93189: LD_ADDR_VAR 0 1
93193: PUSH
93194: LD_EXP 162
93198: PUSH
93199: FOR_IN
93200: IFFALSE 93231
// if GetLives ( i ) < 1000 then
93202: LD_VAR 0 1
93206: PPUSH
93207: CALL_OW 256
93211: PUSH
93212: LD_INT 1000
93214: LESS
93215: IFFALSE 93229
// SetLives ( i , 1000 ) ;
93217: LD_VAR 0 1
93221: PPUSH
93222: LD_INT 1000
93224: PPUSH
93225: CALL_OW 234
93229: GO 93199
93231: POP
93232: POP
// end ;
93233: PPOPN 1
93235: END
// export function hHackInvincible ; var i ; begin
93236: LD_INT 0
93238: PPUSH
93239: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
93240: LD_ADDR_VAR 0 2
93244: PUSH
93245: LD_INT 2
93247: PUSH
93248: LD_INT 21
93250: PUSH
93251: LD_INT 1
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 21
93260: PUSH
93261: LD_INT 2
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: LIST
93272: PPUSH
93273: CALL_OW 69
93277: PUSH
93278: FOR_IN
93279: IFFALSE 93340
// if IsSelected ( i ) then
93281: LD_VAR 0 2
93285: PPUSH
93286: CALL_OW 306
93290: IFFALSE 93338
// begin if i in hInvincible then
93292: LD_VAR 0 2
93296: PUSH
93297: LD_EXP 162
93301: IN
93302: IFFALSE 93322
// hInvincible := hInvincible diff i else
93304: LD_ADDR_EXP 162
93308: PUSH
93309: LD_EXP 162
93313: PUSH
93314: LD_VAR 0 2
93318: DIFF
93319: ST_TO_ADDR
93320: GO 93338
// hInvincible := hInvincible union i ;
93322: LD_ADDR_EXP 162
93326: PUSH
93327: LD_EXP 162
93331: PUSH
93332: LD_VAR 0 2
93336: UNION
93337: ST_TO_ADDR
// end ;
93338: GO 93278
93340: POP
93341: POP
// end ;
93342: LD_VAR 0 1
93346: RET
// export function hHackInvisible ; var i , j ; begin
93347: LD_INT 0
93349: PPUSH
93350: PPUSH
93351: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93352: LD_ADDR_VAR 0 2
93356: PUSH
93357: LD_INT 21
93359: PUSH
93360: LD_INT 1
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: PPUSH
93367: CALL_OW 69
93371: PUSH
93372: FOR_IN
93373: IFFALSE 93397
// if IsSelected ( i ) then
93375: LD_VAR 0 2
93379: PPUSH
93380: CALL_OW 306
93384: IFFALSE 93395
// ComForceInvisible ( i ) ;
93386: LD_VAR 0 2
93390: PPUSH
93391: CALL_OW 496
93395: GO 93372
93397: POP
93398: POP
// end ;
93399: LD_VAR 0 1
93403: RET
// export function hHackChangeYourSide ; begin
93404: LD_INT 0
93406: PPUSH
// if your_side = 8 then
93407: LD_OWVAR 2
93411: PUSH
93412: LD_INT 8
93414: EQUAL
93415: IFFALSE 93427
// your_side := 0 else
93417: LD_ADDR_OWVAR 2
93421: PUSH
93422: LD_INT 0
93424: ST_TO_ADDR
93425: GO 93441
// your_side := your_side + 1 ;
93427: LD_ADDR_OWVAR 2
93431: PUSH
93432: LD_OWVAR 2
93436: PUSH
93437: LD_INT 1
93439: PLUS
93440: ST_TO_ADDR
// end ;
93441: LD_VAR 0 1
93445: RET
// export function hHackChangeUnitSide ; var i , j ; begin
93446: LD_INT 0
93448: PPUSH
93449: PPUSH
93450: PPUSH
// for i in all_units do
93451: LD_ADDR_VAR 0 2
93455: PUSH
93456: LD_OWVAR 3
93460: PUSH
93461: FOR_IN
93462: IFFALSE 93540
// if IsSelected ( i ) then
93464: LD_VAR 0 2
93468: PPUSH
93469: CALL_OW 306
93473: IFFALSE 93538
// begin j := GetSide ( i ) ;
93475: LD_ADDR_VAR 0 3
93479: PUSH
93480: LD_VAR 0 2
93484: PPUSH
93485: CALL_OW 255
93489: ST_TO_ADDR
// if j = 8 then
93490: LD_VAR 0 3
93494: PUSH
93495: LD_INT 8
93497: EQUAL
93498: IFFALSE 93510
// j := 0 else
93500: LD_ADDR_VAR 0 3
93504: PUSH
93505: LD_INT 0
93507: ST_TO_ADDR
93508: GO 93524
// j := j + 1 ;
93510: LD_ADDR_VAR 0 3
93514: PUSH
93515: LD_VAR 0 3
93519: PUSH
93520: LD_INT 1
93522: PLUS
93523: ST_TO_ADDR
// SetSide ( i , j ) ;
93524: LD_VAR 0 2
93528: PPUSH
93529: LD_VAR 0 3
93533: PPUSH
93534: CALL_OW 235
// end ;
93538: GO 93461
93540: POP
93541: POP
// end ;
93542: LD_VAR 0 1
93546: RET
// export function hHackFog ; begin
93547: LD_INT 0
93549: PPUSH
// FogOff ( true ) ;
93550: LD_INT 1
93552: PPUSH
93553: CALL_OW 344
// end ;
93557: LD_VAR 0 1
93561: RET
// export function hHackTeleport ( unit , x , y ) ; begin
93562: LD_INT 0
93564: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
93565: LD_VAR 0 1
93569: PPUSH
93570: LD_VAR 0 2
93574: PPUSH
93575: LD_VAR 0 3
93579: PPUSH
93580: LD_INT 1
93582: PPUSH
93583: LD_INT 1
93585: PPUSH
93586: CALL_OW 483
// CenterOnXY ( x , y ) ;
93590: LD_VAR 0 2
93594: PPUSH
93595: LD_VAR 0 3
93599: PPUSH
93600: CALL_OW 84
// end ; end_of_file
93604: LD_VAR 0 4
93608: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
93609: LD_INT 0
93611: PPUSH
93612: PPUSH
93613: PPUSH
93614: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93615: LD_VAR 0 1
93619: PPUSH
93620: CALL_OW 264
93624: PUSH
93625: LD_EXP 52
93629: EQUAL
93630: IFFALSE 93702
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93632: LD_INT 68
93634: PPUSH
93635: LD_VAR 0 1
93639: PPUSH
93640: CALL_OW 255
93644: PPUSH
93645: CALL_OW 321
93649: PUSH
93650: LD_INT 2
93652: EQUAL
93653: IFFALSE 93665
// eff := 70 else
93655: LD_ADDR_VAR 0 4
93659: PUSH
93660: LD_INT 70
93662: ST_TO_ADDR
93663: GO 93673
// eff := 30 ;
93665: LD_ADDR_VAR 0 4
93669: PUSH
93670: LD_INT 30
93672: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93673: LD_VAR 0 1
93677: PPUSH
93678: CALL_OW 250
93682: PPUSH
93683: LD_VAR 0 1
93687: PPUSH
93688: CALL_OW 251
93692: PPUSH
93693: LD_VAR 0 4
93697: PPUSH
93698: CALL_OW 495
// end ; end ;
93702: LD_VAR 0 2
93706: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93707: LD_INT 0
93709: PPUSH
// end ;
93710: LD_VAR 0 4
93714: RET
// export function SOS_Command ( cmd ) ; begin
93715: LD_INT 0
93717: PPUSH
// end ;
93718: LD_VAR 0 2
93722: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
93723: LD_INT 0
93725: PPUSH
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
93726: LD_VAR 0 1
93730: PUSH
93731: LD_INT 254
93733: EQUAL
93734: PUSH
93735: LD_VAR 0 2
93739: PPUSH
93740: CALL_OW 264
93744: PUSH
93745: LD_EXP 50
93749: EQUAL
93750: AND
93751: PUSH
93752: LD_VAR 0 3
93756: PPUSH
93757: CALL_OW 263
93761: PUSH
93762: LD_INT 3
93764: EQUAL
93765: AND
93766: IFFALSE 93782
// HackDestroyVehicle ( unit , selectedUnit ) ;
93768: LD_VAR 0 2
93772: PPUSH
93773: LD_VAR 0 3
93777: PPUSH
93778: CALL 95291 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
93782: LD_VAR 0 1
93786: PUSH
93787: LD_INT 255
93789: EQUAL
93790: PUSH
93791: LD_VAR 0 2
93795: PPUSH
93796: CALL_OW 264
93800: PUSH
93801: LD_INT 14
93803: PUSH
93804: LD_INT 53
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: IN
93811: AND
93812: PUSH
93813: LD_VAR 0 4
93817: PPUSH
93818: LD_VAR 0 5
93822: PPUSH
93823: CALL_OW 488
93827: AND
93828: IFFALSE 93852
// CutTreeXYR ( unit , x , y , 12 ) ;
93830: LD_VAR 0 2
93834: PPUSH
93835: LD_VAR 0 4
93839: PPUSH
93840: LD_VAR 0 5
93844: PPUSH
93845: LD_INT 12
93847: PPUSH
93848: CALL 93857 0 4
// end ;
93852: LD_VAR 0 6
93856: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93857: LD_INT 0
93859: PPUSH
93860: PPUSH
93861: PPUSH
93862: PPUSH
93863: PPUSH
93864: PPUSH
93865: PPUSH
93866: PPUSH
93867: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93868: LD_VAR 0 1
93872: NOT
93873: PUSH
93874: LD_VAR 0 2
93878: PPUSH
93879: LD_VAR 0 3
93883: PPUSH
93884: CALL_OW 488
93888: NOT
93889: OR
93890: PUSH
93891: LD_VAR 0 4
93895: NOT
93896: OR
93897: IFFALSE 93901
// exit ;
93899: GO 94241
// list := [ ] ;
93901: LD_ADDR_VAR 0 13
93905: PUSH
93906: EMPTY
93907: ST_TO_ADDR
// if x - r < 0 then
93908: LD_VAR 0 2
93912: PUSH
93913: LD_VAR 0 4
93917: MINUS
93918: PUSH
93919: LD_INT 0
93921: LESS
93922: IFFALSE 93934
// min_x := 0 else
93924: LD_ADDR_VAR 0 7
93928: PUSH
93929: LD_INT 0
93931: ST_TO_ADDR
93932: GO 93950
// min_x := x - r ;
93934: LD_ADDR_VAR 0 7
93938: PUSH
93939: LD_VAR 0 2
93943: PUSH
93944: LD_VAR 0 4
93948: MINUS
93949: ST_TO_ADDR
// if y - r < 0 then
93950: LD_VAR 0 3
93954: PUSH
93955: LD_VAR 0 4
93959: MINUS
93960: PUSH
93961: LD_INT 0
93963: LESS
93964: IFFALSE 93976
// min_y := 0 else
93966: LD_ADDR_VAR 0 8
93970: PUSH
93971: LD_INT 0
93973: ST_TO_ADDR
93974: GO 93992
// min_y := y - r ;
93976: LD_ADDR_VAR 0 8
93980: PUSH
93981: LD_VAR 0 3
93985: PUSH
93986: LD_VAR 0 4
93990: MINUS
93991: ST_TO_ADDR
// max_x := x + r ;
93992: LD_ADDR_VAR 0 9
93996: PUSH
93997: LD_VAR 0 2
94001: PUSH
94002: LD_VAR 0 4
94006: PLUS
94007: ST_TO_ADDR
// max_y := y + r ;
94008: LD_ADDR_VAR 0 10
94012: PUSH
94013: LD_VAR 0 3
94017: PUSH
94018: LD_VAR 0 4
94022: PLUS
94023: ST_TO_ADDR
// for _x = min_x to max_x do
94024: LD_ADDR_VAR 0 11
94028: PUSH
94029: DOUBLE
94030: LD_VAR 0 7
94034: DEC
94035: ST_TO_ADDR
94036: LD_VAR 0 9
94040: PUSH
94041: FOR_TO
94042: IFFALSE 94159
// for _y = min_y to max_y do
94044: LD_ADDR_VAR 0 12
94048: PUSH
94049: DOUBLE
94050: LD_VAR 0 8
94054: DEC
94055: ST_TO_ADDR
94056: LD_VAR 0 10
94060: PUSH
94061: FOR_TO
94062: IFFALSE 94155
// begin if not ValidHex ( _x , _y ) then
94064: LD_VAR 0 11
94068: PPUSH
94069: LD_VAR 0 12
94073: PPUSH
94074: CALL_OW 488
94078: NOT
94079: IFFALSE 94083
// continue ;
94081: GO 94061
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94083: LD_VAR 0 11
94087: PPUSH
94088: LD_VAR 0 12
94092: PPUSH
94093: CALL_OW 351
94097: PUSH
94098: LD_VAR 0 11
94102: PPUSH
94103: LD_VAR 0 12
94107: PPUSH
94108: CALL_OW 554
94112: AND
94113: IFFALSE 94153
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94115: LD_ADDR_VAR 0 13
94119: PUSH
94120: LD_VAR 0 13
94124: PPUSH
94125: LD_VAR 0 13
94129: PUSH
94130: LD_INT 1
94132: PLUS
94133: PPUSH
94134: LD_VAR 0 11
94138: PUSH
94139: LD_VAR 0 12
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PPUSH
94148: CALL_OW 2
94152: ST_TO_ADDR
// end ;
94153: GO 94061
94155: POP
94156: POP
94157: GO 94041
94159: POP
94160: POP
// if not list then
94161: LD_VAR 0 13
94165: NOT
94166: IFFALSE 94170
// exit ;
94168: GO 94241
// for i in list do
94170: LD_ADDR_VAR 0 6
94174: PUSH
94175: LD_VAR 0 13
94179: PUSH
94180: FOR_IN
94181: IFFALSE 94239
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94183: LD_VAR 0 1
94187: PPUSH
94188: LD_STRING M
94190: PUSH
94191: LD_VAR 0 6
94195: PUSH
94196: LD_INT 1
94198: ARRAY
94199: PUSH
94200: LD_VAR 0 6
94204: PUSH
94205: LD_INT 2
94207: ARRAY
94208: PUSH
94209: LD_INT 0
94211: PUSH
94212: LD_INT 0
94214: PUSH
94215: LD_INT 0
94217: PUSH
94218: LD_INT 0
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: PUSH
94230: EMPTY
94231: LIST
94232: PPUSH
94233: CALL_OW 447
94237: GO 94180
94239: POP
94240: POP
// end ;
94241: LD_VAR 0 5
94245: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
94246: LD_EXP 163
94250: NOT
94251: IFFALSE 94301
94253: GO 94255
94255: DISABLE
// begin initHack := true ;
94256: LD_ADDR_EXP 163
94260: PUSH
94261: LD_INT 1
94263: ST_TO_ADDR
// hackTanks := [ ] ;
94264: LD_ADDR_EXP 164
94268: PUSH
94269: EMPTY
94270: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
94271: LD_ADDR_EXP 165
94275: PUSH
94276: EMPTY
94277: ST_TO_ADDR
// hackLimit := 3 ;
94278: LD_ADDR_EXP 166
94282: PUSH
94283: LD_INT 3
94285: ST_TO_ADDR
// hackDist := 12 ;
94286: LD_ADDR_EXP 167
94290: PUSH
94291: LD_INT 12
94293: ST_TO_ADDR
// hackCounter := [ ] ;
94294: LD_ADDR_EXP 168
94298: PUSH
94299: EMPTY
94300: ST_TO_ADDR
// end ;
94301: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
94302: LD_EXP 163
94306: PUSH
94307: LD_INT 34
94309: PUSH
94310: LD_EXP 50
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PPUSH
94319: CALL_OW 69
94323: AND
94324: IFFALSE 94579
94326: GO 94328
94328: DISABLE
94329: LD_INT 0
94331: PPUSH
94332: PPUSH
// begin enable ;
94333: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
94334: LD_ADDR_VAR 0 1
94338: PUSH
94339: LD_INT 34
94341: PUSH
94342: LD_EXP 50
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PPUSH
94351: CALL_OW 69
94355: PUSH
94356: FOR_IN
94357: IFFALSE 94577
// begin if not i in hackTanks then
94359: LD_VAR 0 1
94363: PUSH
94364: LD_EXP 164
94368: IN
94369: NOT
94370: IFFALSE 94453
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
94372: LD_ADDR_EXP 164
94376: PUSH
94377: LD_EXP 164
94381: PPUSH
94382: LD_EXP 164
94386: PUSH
94387: LD_INT 1
94389: PLUS
94390: PPUSH
94391: LD_VAR 0 1
94395: PPUSH
94396: CALL_OW 1
94400: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
94401: LD_ADDR_EXP 165
94405: PUSH
94406: LD_EXP 165
94410: PPUSH
94411: LD_EXP 165
94415: PUSH
94416: LD_INT 1
94418: PLUS
94419: PPUSH
94420: EMPTY
94421: PPUSH
94422: CALL_OW 1
94426: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
94427: LD_ADDR_EXP 168
94431: PUSH
94432: LD_EXP 168
94436: PPUSH
94437: LD_EXP 168
94441: PUSH
94442: LD_INT 1
94444: PLUS
94445: PPUSH
94446: EMPTY
94447: PPUSH
94448: CALL_OW 1
94452: ST_TO_ADDR
// end ; if not IsOk ( i ) then
94453: LD_VAR 0 1
94457: PPUSH
94458: CALL_OW 302
94462: NOT
94463: IFFALSE 94476
// begin HackUnlinkAll ( i ) ;
94465: LD_VAR 0 1
94469: PPUSH
94470: CALL 94582 0 1
// continue ;
94474: GO 94356
// end ; HackCheckCapturedStatus ( i ) ;
94476: LD_VAR 0 1
94480: PPUSH
94481: CALL 95025 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
94485: LD_ADDR_VAR 0 2
94489: PUSH
94490: LD_INT 81
94492: PUSH
94493: LD_VAR 0 1
94497: PPUSH
94498: CALL_OW 255
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 33
94509: PUSH
94510: LD_INT 3
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 91
94519: PUSH
94520: LD_VAR 0 1
94524: PUSH
94525: LD_EXP 167
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 50
94537: PUSH
94538: EMPTY
94539: LIST
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: PPUSH
94547: CALL_OW 69
94551: ST_TO_ADDR
// if not tmp then
94552: LD_VAR 0 2
94556: NOT
94557: IFFALSE 94561
// continue ;
94559: GO 94356
// HackLink ( i , tmp ) ;
94561: LD_VAR 0 1
94565: PPUSH
94566: LD_VAR 0 2
94570: PPUSH
94571: CALL 94718 0 2
// end ;
94575: GO 94356
94577: POP
94578: POP
// end ;
94579: PPOPN 2
94581: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
94582: LD_INT 0
94584: PPUSH
94585: PPUSH
94586: PPUSH
// if not hack in hackTanks then
94587: LD_VAR 0 1
94591: PUSH
94592: LD_EXP 164
94596: IN
94597: NOT
94598: IFFALSE 94602
// exit ;
94600: GO 94713
// index := GetElementIndex ( hackTanks , hack ) ;
94602: LD_ADDR_VAR 0 4
94606: PUSH
94607: LD_EXP 164
94611: PPUSH
94612: LD_VAR 0 1
94616: PPUSH
94617: CALL 18364 0 2
94621: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
94622: LD_EXP 165
94626: PUSH
94627: LD_VAR 0 4
94631: ARRAY
94632: IFFALSE 94713
// begin for i in hackTanksCaptured [ index ] do
94634: LD_ADDR_VAR 0 3
94638: PUSH
94639: LD_EXP 165
94643: PUSH
94644: LD_VAR 0 4
94648: ARRAY
94649: PUSH
94650: FOR_IN
94651: IFFALSE 94677
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
94653: LD_VAR 0 3
94657: PUSH
94658: LD_INT 1
94660: ARRAY
94661: PPUSH
94662: LD_VAR 0 3
94666: PUSH
94667: LD_INT 2
94669: ARRAY
94670: PPUSH
94671: CALL_OW 235
94675: GO 94650
94677: POP
94678: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
94679: LD_ADDR_EXP 165
94683: PUSH
94684: LD_EXP 165
94688: PPUSH
94689: LD_VAR 0 4
94693: PPUSH
94694: EMPTY
94695: PPUSH
94696: CALL_OW 1
94700: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
94701: LD_VAR 0 1
94705: PPUSH
94706: LD_INT 0
94708: PPUSH
94709: CALL_OW 505
// end ; end ;
94713: LD_VAR 0 2
94717: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
94718: LD_INT 0
94720: PPUSH
94721: PPUSH
94722: PPUSH
// if not hack in hackTanks or not vehicles then
94723: LD_VAR 0 1
94727: PUSH
94728: LD_EXP 164
94732: IN
94733: NOT
94734: PUSH
94735: LD_VAR 0 2
94739: NOT
94740: OR
94741: IFFALSE 94745
// exit ;
94743: GO 95020
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
94745: LD_ADDR_VAR 0 2
94749: PUSH
94750: LD_VAR 0 1
94754: PPUSH
94755: LD_VAR 0 2
94759: PPUSH
94760: LD_INT 1
94762: PPUSH
94763: LD_INT 1
94765: PPUSH
94766: CALL 19014 0 4
94770: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
94771: LD_ADDR_VAR 0 5
94775: PUSH
94776: LD_EXP 164
94780: PPUSH
94781: LD_VAR 0 1
94785: PPUSH
94786: CALL 18364 0 2
94790: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
94791: LD_EXP 165
94795: PUSH
94796: LD_VAR 0 5
94800: ARRAY
94801: PUSH
94802: LD_EXP 166
94806: LESS
94807: IFFALSE 94996
// begin for i := 1 to vehicles do
94809: LD_ADDR_VAR 0 4
94813: PUSH
94814: DOUBLE
94815: LD_INT 1
94817: DEC
94818: ST_TO_ADDR
94819: LD_VAR 0 2
94823: PUSH
94824: FOR_TO
94825: IFFALSE 94994
// begin if hackTanksCaptured [ index ] = hackLimit then
94827: LD_EXP 165
94831: PUSH
94832: LD_VAR 0 5
94836: ARRAY
94837: PUSH
94838: LD_EXP 166
94842: EQUAL
94843: IFFALSE 94847
// break ;
94845: GO 94994
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
94847: LD_ADDR_EXP 168
94851: PUSH
94852: LD_EXP 168
94856: PPUSH
94857: LD_VAR 0 5
94861: PPUSH
94862: LD_EXP 168
94866: PUSH
94867: LD_VAR 0 5
94871: ARRAY
94872: PUSH
94873: LD_INT 1
94875: PLUS
94876: PPUSH
94877: CALL_OW 1
94881: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
94882: LD_ADDR_EXP 165
94886: PUSH
94887: LD_EXP 165
94891: PPUSH
94892: LD_VAR 0 5
94896: PUSH
94897: LD_EXP 165
94901: PUSH
94902: LD_VAR 0 5
94906: ARRAY
94907: PUSH
94908: LD_INT 1
94910: PLUS
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PPUSH
94916: LD_VAR 0 2
94920: PUSH
94921: LD_VAR 0 4
94925: ARRAY
94926: PUSH
94927: LD_VAR 0 2
94931: PUSH
94932: LD_VAR 0 4
94936: ARRAY
94937: PPUSH
94938: CALL_OW 255
94942: PUSH
94943: EMPTY
94944: LIST
94945: LIST
94946: PPUSH
94947: CALL 18579 0 3
94951: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
94952: LD_VAR 0 2
94956: PUSH
94957: LD_VAR 0 4
94961: ARRAY
94962: PPUSH
94963: LD_VAR 0 1
94967: PPUSH
94968: CALL_OW 255
94972: PPUSH
94973: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
94977: LD_VAR 0 2
94981: PUSH
94982: LD_VAR 0 4
94986: ARRAY
94987: PPUSH
94988: CALL_OW 141
// end ;
94992: GO 94824
94994: POP
94995: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94996: LD_VAR 0 1
95000: PPUSH
95001: LD_EXP 165
95005: PUSH
95006: LD_VAR 0 5
95010: ARRAY
95011: PUSH
95012: LD_INT 0
95014: PLUS
95015: PPUSH
95016: CALL_OW 505
// end ;
95020: LD_VAR 0 3
95024: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
95025: LD_INT 0
95027: PPUSH
95028: PPUSH
95029: PPUSH
95030: PPUSH
// if not hack in hackTanks then
95031: LD_VAR 0 1
95035: PUSH
95036: LD_EXP 164
95040: IN
95041: NOT
95042: IFFALSE 95046
// exit ;
95044: GO 95286
// index := GetElementIndex ( hackTanks , hack ) ;
95046: LD_ADDR_VAR 0 4
95050: PUSH
95051: LD_EXP 164
95055: PPUSH
95056: LD_VAR 0 1
95060: PPUSH
95061: CALL 18364 0 2
95065: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
95066: LD_ADDR_VAR 0 3
95070: PUSH
95071: DOUBLE
95072: LD_EXP 165
95076: PUSH
95077: LD_VAR 0 4
95081: ARRAY
95082: INC
95083: ST_TO_ADDR
95084: LD_INT 1
95086: PUSH
95087: FOR_DOWNTO
95088: IFFALSE 95260
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
95090: LD_ADDR_VAR 0 5
95094: PUSH
95095: LD_EXP 165
95099: PUSH
95100: LD_VAR 0 4
95104: ARRAY
95105: PUSH
95106: LD_VAR 0 3
95110: ARRAY
95111: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
95112: LD_VAR 0 5
95116: PUSH
95117: LD_INT 1
95119: ARRAY
95120: PPUSH
95121: CALL_OW 302
95125: NOT
95126: PUSH
95127: LD_VAR 0 5
95131: PUSH
95132: LD_INT 1
95134: ARRAY
95135: PPUSH
95136: CALL_OW 255
95140: PUSH
95141: LD_VAR 0 1
95145: PPUSH
95146: CALL_OW 255
95150: NONEQUAL
95151: OR
95152: IFFALSE 95258
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
95154: LD_VAR 0 5
95158: PUSH
95159: LD_INT 1
95161: ARRAY
95162: PPUSH
95163: CALL_OW 305
95167: PUSH
95168: LD_VAR 0 5
95172: PUSH
95173: LD_INT 1
95175: ARRAY
95176: PPUSH
95177: CALL_OW 255
95181: PUSH
95182: LD_VAR 0 1
95186: PPUSH
95187: CALL_OW 255
95191: EQUAL
95192: AND
95193: IFFALSE 95217
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
95195: LD_VAR 0 5
95199: PUSH
95200: LD_INT 1
95202: ARRAY
95203: PPUSH
95204: LD_VAR 0 5
95208: PUSH
95209: LD_INT 2
95211: ARRAY
95212: PPUSH
95213: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
95217: LD_ADDR_EXP 165
95221: PUSH
95222: LD_EXP 165
95226: PPUSH
95227: LD_VAR 0 4
95231: PPUSH
95232: LD_EXP 165
95236: PUSH
95237: LD_VAR 0 4
95241: ARRAY
95242: PPUSH
95243: LD_VAR 0 3
95247: PPUSH
95248: CALL_OW 3
95252: PPUSH
95253: CALL_OW 1
95257: ST_TO_ADDR
// end ; end ;
95258: GO 95087
95260: POP
95261: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95262: LD_VAR 0 1
95266: PPUSH
95267: LD_EXP 165
95271: PUSH
95272: LD_VAR 0 4
95276: ARRAY
95277: PUSH
95278: LD_INT 0
95280: PLUS
95281: PPUSH
95282: CALL_OW 505
// end ;
95286: LD_VAR 0 2
95290: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
95291: LD_INT 0
95293: PPUSH
95294: PPUSH
95295: PPUSH
95296: PPUSH
// if not hack in hackTanks then
95297: LD_VAR 0 1
95301: PUSH
95302: LD_EXP 164
95306: IN
95307: NOT
95308: IFFALSE 95312
// exit ;
95310: GO 95397
// index := GetElementIndex ( hackTanks , hack ) ;
95312: LD_ADDR_VAR 0 5
95316: PUSH
95317: LD_EXP 164
95321: PPUSH
95322: LD_VAR 0 1
95326: PPUSH
95327: CALL 18364 0 2
95331: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
95332: LD_ADDR_VAR 0 4
95336: PUSH
95337: DOUBLE
95338: LD_INT 1
95340: DEC
95341: ST_TO_ADDR
95342: LD_EXP 165
95346: PUSH
95347: LD_VAR 0 5
95351: ARRAY
95352: PUSH
95353: FOR_TO
95354: IFFALSE 95395
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
95356: LD_EXP 165
95360: PUSH
95361: LD_VAR 0 5
95365: ARRAY
95366: PUSH
95367: LD_VAR 0 4
95371: ARRAY
95372: PUSH
95373: LD_INT 1
95375: ARRAY
95376: PUSH
95377: LD_VAR 0 2
95381: EQUAL
95382: IFFALSE 95393
// KillUnit ( vehicle ) ;
95384: LD_VAR 0 2
95388: PPUSH
95389: CALL_OW 66
95393: GO 95353
95395: POP
95396: POP
// end ; end_of_file
95397: LD_VAR 0 3
95401: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
95402: LD_INT 0
95404: PPUSH
95405: PPUSH
95406: PPUSH
95407: PPUSH
95408: PPUSH
95409: PPUSH
95410: PPUSH
95411: PPUSH
95412: PPUSH
95413: PPUSH
95414: PPUSH
95415: PPUSH
95416: PPUSH
95417: PPUSH
95418: PPUSH
95419: PPUSH
95420: PPUSH
95421: PPUSH
95422: PPUSH
95423: PPUSH
95424: PPUSH
95425: PPUSH
95426: PPUSH
95427: PPUSH
95428: PPUSH
95429: PPUSH
95430: PPUSH
95431: PPUSH
95432: PPUSH
95433: PPUSH
95434: PPUSH
95435: PPUSH
95436: PPUSH
95437: PPUSH
// if not list then
95438: LD_VAR 0 1
95442: NOT
95443: IFFALSE 95447
// exit ;
95445: GO 100106
// base := list [ 1 ] ;
95447: LD_ADDR_VAR 0 3
95451: PUSH
95452: LD_VAR 0 1
95456: PUSH
95457: LD_INT 1
95459: ARRAY
95460: ST_TO_ADDR
// group := list [ 2 ] ;
95461: LD_ADDR_VAR 0 4
95465: PUSH
95466: LD_VAR 0 1
95470: PUSH
95471: LD_INT 2
95473: ARRAY
95474: ST_TO_ADDR
// path := list [ 3 ] ;
95475: LD_ADDR_VAR 0 5
95479: PUSH
95480: LD_VAR 0 1
95484: PUSH
95485: LD_INT 3
95487: ARRAY
95488: ST_TO_ADDR
// flags := list [ 4 ] ;
95489: LD_ADDR_VAR 0 6
95493: PUSH
95494: LD_VAR 0 1
95498: PUSH
95499: LD_INT 4
95501: ARRAY
95502: ST_TO_ADDR
// mined := [ ] ;
95503: LD_ADDR_VAR 0 27
95507: PUSH
95508: EMPTY
95509: ST_TO_ADDR
// bombed := [ ] ;
95510: LD_ADDR_VAR 0 28
95514: PUSH
95515: EMPTY
95516: ST_TO_ADDR
// healers := [ ] ;
95517: LD_ADDR_VAR 0 31
95521: PUSH
95522: EMPTY
95523: ST_TO_ADDR
// to_heal := [ ] ;
95524: LD_ADDR_VAR 0 30
95528: PUSH
95529: EMPTY
95530: ST_TO_ADDR
// repairs := [ ] ;
95531: LD_ADDR_VAR 0 33
95535: PUSH
95536: EMPTY
95537: ST_TO_ADDR
// to_repair := [ ] ;
95538: LD_ADDR_VAR 0 32
95542: PUSH
95543: EMPTY
95544: ST_TO_ADDR
// if not group or not path then
95545: LD_VAR 0 4
95549: NOT
95550: PUSH
95551: LD_VAR 0 5
95555: NOT
95556: OR
95557: IFFALSE 95561
// exit ;
95559: GO 100106
// side := GetSide ( group [ 1 ] ) ;
95561: LD_ADDR_VAR 0 35
95565: PUSH
95566: LD_VAR 0 4
95570: PUSH
95571: LD_INT 1
95573: ARRAY
95574: PPUSH
95575: CALL_OW 255
95579: ST_TO_ADDR
// if flags then
95580: LD_VAR 0 6
95584: IFFALSE 95728
// begin f_ignore_area := flags [ 1 ] ;
95586: LD_ADDR_VAR 0 17
95590: PUSH
95591: LD_VAR 0 6
95595: PUSH
95596: LD_INT 1
95598: ARRAY
95599: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
95600: LD_ADDR_VAR 0 18
95604: PUSH
95605: LD_VAR 0 6
95609: PUSH
95610: LD_INT 2
95612: ARRAY
95613: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
95614: LD_ADDR_VAR 0 19
95618: PUSH
95619: LD_VAR 0 6
95623: PUSH
95624: LD_INT 3
95626: ARRAY
95627: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
95628: LD_ADDR_VAR 0 20
95632: PUSH
95633: LD_VAR 0 6
95637: PUSH
95638: LD_INT 4
95640: ARRAY
95641: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
95642: LD_ADDR_VAR 0 21
95646: PUSH
95647: LD_VAR 0 6
95651: PUSH
95652: LD_INT 5
95654: ARRAY
95655: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
95656: LD_ADDR_VAR 0 22
95660: PUSH
95661: LD_VAR 0 6
95665: PUSH
95666: LD_INT 6
95668: ARRAY
95669: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
95670: LD_ADDR_VAR 0 23
95674: PUSH
95675: LD_VAR 0 6
95679: PUSH
95680: LD_INT 7
95682: ARRAY
95683: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
95684: LD_ADDR_VAR 0 24
95688: PUSH
95689: LD_VAR 0 6
95693: PUSH
95694: LD_INT 8
95696: ARRAY
95697: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
95698: LD_ADDR_VAR 0 25
95702: PUSH
95703: LD_VAR 0 6
95707: PUSH
95708: LD_INT 9
95710: ARRAY
95711: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
95712: LD_ADDR_VAR 0 26
95716: PUSH
95717: LD_VAR 0 6
95721: PUSH
95722: LD_INT 10
95724: ARRAY
95725: ST_TO_ADDR
// end else
95726: GO 95808
// begin f_ignore_area := false ;
95728: LD_ADDR_VAR 0 17
95732: PUSH
95733: LD_INT 0
95735: ST_TO_ADDR
// f_capture := false ;
95736: LD_ADDR_VAR 0 18
95740: PUSH
95741: LD_INT 0
95743: ST_TO_ADDR
// f_ignore_civ := false ;
95744: LD_ADDR_VAR 0 19
95748: PUSH
95749: LD_INT 0
95751: ST_TO_ADDR
// f_murder := false ;
95752: LD_ADDR_VAR 0 20
95756: PUSH
95757: LD_INT 0
95759: ST_TO_ADDR
// f_mines := false ;
95760: LD_ADDR_VAR 0 21
95764: PUSH
95765: LD_INT 0
95767: ST_TO_ADDR
// f_repair := false ;
95768: LD_ADDR_VAR 0 22
95772: PUSH
95773: LD_INT 0
95775: ST_TO_ADDR
// f_heal := false ;
95776: LD_ADDR_VAR 0 23
95780: PUSH
95781: LD_INT 0
95783: ST_TO_ADDR
// f_spacetime := false ;
95784: LD_ADDR_VAR 0 24
95788: PUSH
95789: LD_INT 0
95791: ST_TO_ADDR
// f_attack_depot := false ;
95792: LD_ADDR_VAR 0 25
95796: PUSH
95797: LD_INT 0
95799: ST_TO_ADDR
// f_crawl := false ;
95800: LD_ADDR_VAR 0 26
95804: PUSH
95805: LD_INT 0
95807: ST_TO_ADDR
// end ; if f_heal then
95808: LD_VAR 0 23
95812: IFFALSE 95839
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
95814: LD_ADDR_VAR 0 31
95818: PUSH
95819: LD_VAR 0 4
95823: PPUSH
95824: LD_INT 25
95826: PUSH
95827: LD_INT 4
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PPUSH
95834: CALL_OW 72
95838: ST_TO_ADDR
// if f_repair then
95839: LD_VAR 0 22
95843: IFFALSE 95870
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
95845: LD_ADDR_VAR 0 33
95849: PUSH
95850: LD_VAR 0 4
95854: PPUSH
95855: LD_INT 25
95857: PUSH
95858: LD_INT 3
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PPUSH
95865: CALL_OW 72
95869: ST_TO_ADDR
// units_path := [ ] ;
95870: LD_ADDR_VAR 0 16
95874: PUSH
95875: EMPTY
95876: ST_TO_ADDR
// for i = 1 to group do
95877: LD_ADDR_VAR 0 7
95881: PUSH
95882: DOUBLE
95883: LD_INT 1
95885: DEC
95886: ST_TO_ADDR
95887: LD_VAR 0 4
95891: PUSH
95892: FOR_TO
95893: IFFALSE 95922
// units_path := Replace ( units_path , i , path ) ;
95895: LD_ADDR_VAR 0 16
95899: PUSH
95900: LD_VAR 0 16
95904: PPUSH
95905: LD_VAR 0 7
95909: PPUSH
95910: LD_VAR 0 5
95914: PPUSH
95915: CALL_OW 1
95919: ST_TO_ADDR
95920: GO 95892
95922: POP
95923: POP
// repeat for i = group downto 1 do
95924: LD_ADDR_VAR 0 7
95928: PUSH
95929: DOUBLE
95930: LD_VAR 0 4
95934: INC
95935: ST_TO_ADDR
95936: LD_INT 1
95938: PUSH
95939: FOR_DOWNTO
95940: IFFALSE 100062
// begin wait ( 5 ) ;
95942: LD_INT 5
95944: PPUSH
95945: CALL_OW 67
// tmp := [ ] ;
95949: LD_ADDR_VAR 0 14
95953: PUSH
95954: EMPTY
95955: ST_TO_ADDR
// attacking := false ;
95956: LD_ADDR_VAR 0 29
95960: PUSH
95961: LD_INT 0
95963: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
95964: LD_VAR 0 4
95968: PUSH
95969: LD_VAR 0 7
95973: ARRAY
95974: PPUSH
95975: CALL_OW 301
95979: PUSH
95980: LD_VAR 0 4
95984: PUSH
95985: LD_VAR 0 7
95989: ARRAY
95990: NOT
95991: OR
95992: IFFALSE 96101
// begin if GetType ( group [ i ] ) = unit_human then
95994: LD_VAR 0 4
95998: PUSH
95999: LD_VAR 0 7
96003: ARRAY
96004: PPUSH
96005: CALL_OW 247
96009: PUSH
96010: LD_INT 1
96012: EQUAL
96013: IFFALSE 96059
// begin to_heal := to_heal diff group [ i ] ;
96015: LD_ADDR_VAR 0 30
96019: PUSH
96020: LD_VAR 0 30
96024: PUSH
96025: LD_VAR 0 4
96029: PUSH
96030: LD_VAR 0 7
96034: ARRAY
96035: DIFF
96036: ST_TO_ADDR
// healers := healers diff group [ i ] ;
96037: LD_ADDR_VAR 0 31
96041: PUSH
96042: LD_VAR 0 31
96046: PUSH
96047: LD_VAR 0 4
96051: PUSH
96052: LD_VAR 0 7
96056: ARRAY
96057: DIFF
96058: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
96059: LD_ADDR_VAR 0 4
96063: PUSH
96064: LD_VAR 0 4
96068: PPUSH
96069: LD_VAR 0 7
96073: PPUSH
96074: CALL_OW 3
96078: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
96079: LD_ADDR_VAR 0 16
96083: PUSH
96084: LD_VAR 0 16
96088: PPUSH
96089: LD_VAR 0 7
96093: PPUSH
96094: CALL_OW 3
96098: ST_TO_ADDR
// continue ;
96099: GO 95939
// end ; if f_repair then
96101: LD_VAR 0 22
96105: IFFALSE 96594
// begin if GetType ( group [ i ] ) = unit_vehicle then
96107: LD_VAR 0 4
96111: PUSH
96112: LD_VAR 0 7
96116: ARRAY
96117: PPUSH
96118: CALL_OW 247
96122: PUSH
96123: LD_INT 2
96125: EQUAL
96126: IFFALSE 96316
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
96128: LD_VAR 0 4
96132: PUSH
96133: LD_VAR 0 7
96137: ARRAY
96138: PPUSH
96139: CALL_OW 256
96143: PUSH
96144: LD_INT 700
96146: LESS
96147: PUSH
96148: LD_VAR 0 4
96152: PUSH
96153: LD_VAR 0 7
96157: ARRAY
96158: PUSH
96159: LD_VAR 0 32
96163: IN
96164: NOT
96165: AND
96166: IFFALSE 96190
// to_repair := to_repair union group [ i ] ;
96168: LD_ADDR_VAR 0 32
96172: PUSH
96173: LD_VAR 0 32
96177: PUSH
96178: LD_VAR 0 4
96182: PUSH
96183: LD_VAR 0 7
96187: ARRAY
96188: UNION
96189: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
96190: LD_VAR 0 4
96194: PUSH
96195: LD_VAR 0 7
96199: ARRAY
96200: PPUSH
96201: CALL_OW 256
96205: PUSH
96206: LD_INT 1000
96208: EQUAL
96209: PUSH
96210: LD_VAR 0 4
96214: PUSH
96215: LD_VAR 0 7
96219: ARRAY
96220: PUSH
96221: LD_VAR 0 32
96225: IN
96226: AND
96227: IFFALSE 96251
// to_repair := to_repair diff group [ i ] ;
96229: LD_ADDR_VAR 0 32
96233: PUSH
96234: LD_VAR 0 32
96238: PUSH
96239: LD_VAR 0 4
96243: PUSH
96244: LD_VAR 0 7
96248: ARRAY
96249: DIFF
96250: ST_TO_ADDR
// if group [ i ] in to_repair then
96251: LD_VAR 0 4
96255: PUSH
96256: LD_VAR 0 7
96260: ARRAY
96261: PUSH
96262: LD_VAR 0 32
96266: IN
96267: IFFALSE 96314
// begin if not IsInArea ( group [ i ] , f_repair ) then
96269: LD_VAR 0 4
96273: PUSH
96274: LD_VAR 0 7
96278: ARRAY
96279: PPUSH
96280: LD_VAR 0 22
96284: PPUSH
96285: CALL_OW 308
96289: NOT
96290: IFFALSE 96312
// ComMoveToArea ( group [ i ] , f_repair ) ;
96292: LD_VAR 0 4
96296: PUSH
96297: LD_VAR 0 7
96301: ARRAY
96302: PPUSH
96303: LD_VAR 0 22
96307: PPUSH
96308: CALL_OW 113
// continue ;
96312: GO 95939
// end ; end else
96314: GO 96594
// if group [ i ] in repairs then
96316: LD_VAR 0 4
96320: PUSH
96321: LD_VAR 0 7
96325: ARRAY
96326: PUSH
96327: LD_VAR 0 33
96331: IN
96332: IFFALSE 96594
// begin if IsInUnit ( group [ i ] ) then
96334: LD_VAR 0 4
96338: PUSH
96339: LD_VAR 0 7
96343: ARRAY
96344: PPUSH
96345: CALL_OW 310
96349: IFFALSE 96417
// begin z := IsInUnit ( group [ i ] ) ;
96351: LD_ADDR_VAR 0 13
96355: PUSH
96356: LD_VAR 0 4
96360: PUSH
96361: LD_VAR 0 7
96365: ARRAY
96366: PPUSH
96367: CALL_OW 310
96371: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
96372: LD_VAR 0 13
96376: PUSH
96377: LD_VAR 0 32
96381: IN
96382: PUSH
96383: LD_VAR 0 13
96387: PPUSH
96388: LD_VAR 0 22
96392: PPUSH
96393: CALL_OW 308
96397: AND
96398: IFFALSE 96415
// ComExitVehicle ( group [ i ] ) ;
96400: LD_VAR 0 4
96404: PUSH
96405: LD_VAR 0 7
96409: ARRAY
96410: PPUSH
96411: CALL_OW 121
// end else
96415: GO 96594
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
96417: LD_ADDR_VAR 0 13
96421: PUSH
96422: LD_VAR 0 4
96426: PPUSH
96427: LD_INT 95
96429: PUSH
96430: LD_VAR 0 22
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: LD_INT 58
96441: PUSH
96442: EMPTY
96443: LIST
96444: PUSH
96445: EMPTY
96446: LIST
96447: LIST
96448: PPUSH
96449: CALL_OW 72
96453: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
96454: LD_VAR 0 4
96458: PUSH
96459: LD_VAR 0 7
96463: ARRAY
96464: PPUSH
96465: CALL_OW 314
96469: NOT
96470: IFFALSE 96592
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
96472: LD_ADDR_VAR 0 10
96476: PUSH
96477: LD_VAR 0 13
96481: PPUSH
96482: LD_VAR 0 4
96486: PUSH
96487: LD_VAR 0 7
96491: ARRAY
96492: PPUSH
96493: CALL_OW 74
96497: ST_TO_ADDR
// if not x then
96498: LD_VAR 0 10
96502: NOT
96503: IFFALSE 96507
// continue ;
96505: GO 95939
// if GetLives ( x ) < 1000 then
96507: LD_VAR 0 10
96511: PPUSH
96512: CALL_OW 256
96516: PUSH
96517: LD_INT 1000
96519: LESS
96520: IFFALSE 96544
// ComRepairVehicle ( group [ i ] , x ) else
96522: LD_VAR 0 4
96526: PUSH
96527: LD_VAR 0 7
96531: ARRAY
96532: PPUSH
96533: LD_VAR 0 10
96537: PPUSH
96538: CALL_OW 129
96542: GO 96592
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
96544: LD_VAR 0 23
96548: PUSH
96549: LD_VAR 0 4
96553: PUSH
96554: LD_VAR 0 7
96558: ARRAY
96559: PPUSH
96560: CALL_OW 256
96564: PUSH
96565: LD_INT 1000
96567: LESS
96568: AND
96569: NOT
96570: IFFALSE 96592
// ComEnterUnit ( group [ i ] , x ) ;
96572: LD_VAR 0 4
96576: PUSH
96577: LD_VAR 0 7
96581: ARRAY
96582: PPUSH
96583: LD_VAR 0 10
96587: PPUSH
96588: CALL_OW 120
// end ; continue ;
96592: GO 95939
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
96594: LD_VAR 0 23
96598: PUSH
96599: LD_VAR 0 4
96603: PUSH
96604: LD_VAR 0 7
96608: ARRAY
96609: PPUSH
96610: CALL_OW 247
96614: PUSH
96615: LD_INT 1
96617: EQUAL
96618: AND
96619: IFFALSE 97097
// begin if group [ i ] in healers then
96621: LD_VAR 0 4
96625: PUSH
96626: LD_VAR 0 7
96630: ARRAY
96631: PUSH
96632: LD_VAR 0 31
96636: IN
96637: IFFALSE 96910
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
96639: LD_VAR 0 4
96643: PUSH
96644: LD_VAR 0 7
96648: ARRAY
96649: PPUSH
96650: LD_VAR 0 23
96654: PPUSH
96655: CALL_OW 308
96659: NOT
96660: PUSH
96661: LD_VAR 0 4
96665: PUSH
96666: LD_VAR 0 7
96670: ARRAY
96671: PPUSH
96672: CALL_OW 314
96676: NOT
96677: AND
96678: IFFALSE 96702
// ComMoveToArea ( group [ i ] , f_heal ) else
96680: LD_VAR 0 4
96684: PUSH
96685: LD_VAR 0 7
96689: ARRAY
96690: PPUSH
96691: LD_VAR 0 23
96695: PPUSH
96696: CALL_OW 113
96700: GO 96908
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
96702: LD_VAR 0 4
96706: PUSH
96707: LD_VAR 0 7
96711: ARRAY
96712: PPUSH
96713: CALL 46951 0 1
96717: PPUSH
96718: CALL_OW 256
96722: PUSH
96723: LD_INT 1000
96725: EQUAL
96726: IFFALSE 96745
// ComStop ( group [ i ] ) else
96728: LD_VAR 0 4
96732: PUSH
96733: LD_VAR 0 7
96737: ARRAY
96738: PPUSH
96739: CALL_OW 141
96743: GO 96908
// if not HasTask ( group [ i ] ) and to_heal then
96745: LD_VAR 0 4
96749: PUSH
96750: LD_VAR 0 7
96754: ARRAY
96755: PPUSH
96756: CALL_OW 314
96760: NOT
96761: PUSH
96762: LD_VAR 0 30
96766: AND
96767: IFFALSE 96908
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
96769: LD_ADDR_VAR 0 13
96773: PUSH
96774: LD_VAR 0 30
96778: PPUSH
96779: LD_INT 3
96781: PUSH
96782: LD_INT 54
96784: PUSH
96785: EMPTY
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PPUSH
96792: CALL_OW 72
96796: PPUSH
96797: LD_VAR 0 4
96801: PUSH
96802: LD_VAR 0 7
96806: ARRAY
96807: PPUSH
96808: CALL_OW 74
96812: ST_TO_ADDR
// if z then
96813: LD_VAR 0 13
96817: IFFALSE 96908
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
96819: LD_INT 91
96821: PUSH
96822: LD_VAR 0 13
96826: PUSH
96827: LD_INT 10
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 81
96837: PUSH
96838: LD_VAR 0 13
96842: PPUSH
96843: CALL_OW 255
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PPUSH
96856: CALL_OW 69
96860: PUSH
96861: LD_INT 0
96863: EQUAL
96864: IFFALSE 96888
// ComHeal ( group [ i ] , z ) else
96866: LD_VAR 0 4
96870: PUSH
96871: LD_VAR 0 7
96875: ARRAY
96876: PPUSH
96877: LD_VAR 0 13
96881: PPUSH
96882: CALL_OW 128
96886: GO 96908
// ComMoveToArea ( group [ i ] , f_heal ) ;
96888: LD_VAR 0 4
96892: PUSH
96893: LD_VAR 0 7
96897: ARRAY
96898: PPUSH
96899: LD_VAR 0 23
96903: PPUSH
96904: CALL_OW 113
// end ; continue ;
96908: GO 95939
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
96910: LD_VAR 0 4
96914: PUSH
96915: LD_VAR 0 7
96919: ARRAY
96920: PPUSH
96921: CALL_OW 256
96925: PUSH
96926: LD_INT 700
96928: LESS
96929: PUSH
96930: LD_VAR 0 4
96934: PUSH
96935: LD_VAR 0 7
96939: ARRAY
96940: PUSH
96941: LD_VAR 0 30
96945: IN
96946: NOT
96947: AND
96948: IFFALSE 96972
// to_heal := to_heal union group [ i ] ;
96950: LD_ADDR_VAR 0 30
96954: PUSH
96955: LD_VAR 0 30
96959: PUSH
96960: LD_VAR 0 4
96964: PUSH
96965: LD_VAR 0 7
96969: ARRAY
96970: UNION
96971: ST_TO_ADDR
// if group [ i ] in to_heal then
96972: LD_VAR 0 4
96976: PUSH
96977: LD_VAR 0 7
96981: ARRAY
96982: PUSH
96983: LD_VAR 0 30
96987: IN
96988: IFFALSE 97097
// begin if GetLives ( group [ i ] ) = 1000 then
96990: LD_VAR 0 4
96994: PUSH
96995: LD_VAR 0 7
96999: ARRAY
97000: PPUSH
97001: CALL_OW 256
97005: PUSH
97006: LD_INT 1000
97008: EQUAL
97009: IFFALSE 97035
// to_heal := to_heal diff group [ i ] else
97011: LD_ADDR_VAR 0 30
97015: PUSH
97016: LD_VAR 0 30
97020: PUSH
97021: LD_VAR 0 4
97025: PUSH
97026: LD_VAR 0 7
97030: ARRAY
97031: DIFF
97032: ST_TO_ADDR
97033: GO 97097
// begin if not IsInArea ( group [ i ] , to_heal ) then
97035: LD_VAR 0 4
97039: PUSH
97040: LD_VAR 0 7
97044: ARRAY
97045: PPUSH
97046: LD_VAR 0 30
97050: PPUSH
97051: CALL_OW 308
97055: NOT
97056: IFFALSE 97080
// ComMoveToArea ( group [ i ] , f_heal ) else
97058: LD_VAR 0 4
97062: PUSH
97063: LD_VAR 0 7
97067: ARRAY
97068: PPUSH
97069: LD_VAR 0 23
97073: PPUSH
97074: CALL_OW 113
97078: GO 97095
// ComHold ( group [ i ] ) ;
97080: LD_VAR 0 4
97084: PUSH
97085: LD_VAR 0 7
97089: ARRAY
97090: PPUSH
97091: CALL_OW 140
// continue ;
97095: GO 95939
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
97097: LD_VAR 0 4
97101: PUSH
97102: LD_VAR 0 7
97106: ARRAY
97107: PPUSH
97108: LD_INT 10
97110: PPUSH
97111: CALL 45371 0 2
97115: NOT
97116: PUSH
97117: LD_VAR 0 16
97121: PUSH
97122: LD_VAR 0 7
97126: ARRAY
97127: PUSH
97128: EMPTY
97129: EQUAL
97130: NOT
97131: AND
97132: IFFALSE 97398
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
97134: LD_VAR 0 4
97138: PUSH
97139: LD_VAR 0 7
97143: ARRAY
97144: PPUSH
97145: CALL_OW 262
97149: PUSH
97150: LD_INT 1
97152: PUSH
97153: LD_INT 2
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: IN
97160: IFFALSE 97201
// if GetFuel ( group [ i ] ) < 10 then
97162: LD_VAR 0 4
97166: PUSH
97167: LD_VAR 0 7
97171: ARRAY
97172: PPUSH
97173: CALL_OW 261
97177: PUSH
97178: LD_INT 10
97180: LESS
97181: IFFALSE 97201
// SetFuel ( group [ i ] , 12 ) ;
97183: LD_VAR 0 4
97187: PUSH
97188: LD_VAR 0 7
97192: ARRAY
97193: PPUSH
97194: LD_INT 12
97196: PPUSH
97197: CALL_OW 240
// if units_path [ i ] then
97201: LD_VAR 0 16
97205: PUSH
97206: LD_VAR 0 7
97210: ARRAY
97211: IFFALSE 97396
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
97213: LD_VAR 0 4
97217: PUSH
97218: LD_VAR 0 7
97222: ARRAY
97223: PPUSH
97224: LD_VAR 0 16
97228: PUSH
97229: LD_VAR 0 7
97233: ARRAY
97234: PUSH
97235: LD_INT 1
97237: ARRAY
97238: PUSH
97239: LD_INT 1
97241: ARRAY
97242: PPUSH
97243: LD_VAR 0 16
97247: PUSH
97248: LD_VAR 0 7
97252: ARRAY
97253: PUSH
97254: LD_INT 1
97256: ARRAY
97257: PUSH
97258: LD_INT 2
97260: ARRAY
97261: PPUSH
97262: CALL_OW 297
97266: PUSH
97267: LD_INT 6
97269: GREATER
97270: IFFALSE 97345
// begin if not HasTask ( group [ i ] ) then
97272: LD_VAR 0 4
97276: PUSH
97277: LD_VAR 0 7
97281: ARRAY
97282: PPUSH
97283: CALL_OW 314
97287: NOT
97288: IFFALSE 97343
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
97290: LD_VAR 0 4
97294: PUSH
97295: LD_VAR 0 7
97299: ARRAY
97300: PPUSH
97301: LD_VAR 0 16
97305: PUSH
97306: LD_VAR 0 7
97310: ARRAY
97311: PUSH
97312: LD_INT 1
97314: ARRAY
97315: PUSH
97316: LD_INT 1
97318: ARRAY
97319: PPUSH
97320: LD_VAR 0 16
97324: PUSH
97325: LD_VAR 0 7
97329: ARRAY
97330: PUSH
97331: LD_INT 1
97333: ARRAY
97334: PUSH
97335: LD_INT 2
97337: ARRAY
97338: PPUSH
97339: CALL_OW 114
// end else
97343: GO 97396
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
97345: LD_ADDR_VAR 0 15
97349: PUSH
97350: LD_VAR 0 16
97354: PUSH
97355: LD_VAR 0 7
97359: ARRAY
97360: PPUSH
97361: LD_INT 1
97363: PPUSH
97364: CALL_OW 3
97368: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
97369: LD_ADDR_VAR 0 16
97373: PUSH
97374: LD_VAR 0 16
97378: PPUSH
97379: LD_VAR 0 7
97383: PPUSH
97384: LD_VAR 0 15
97388: PPUSH
97389: CALL_OW 1
97393: ST_TO_ADDR
// continue ;
97394: GO 95939
// end ; end ; end else
97396: GO 100060
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
97398: LD_ADDR_VAR 0 14
97402: PUSH
97403: LD_INT 81
97405: PUSH
97406: LD_VAR 0 4
97410: PUSH
97411: LD_VAR 0 7
97415: ARRAY
97416: PPUSH
97417: CALL_OW 255
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PPUSH
97426: CALL_OW 69
97430: ST_TO_ADDR
// if not tmp then
97431: LD_VAR 0 14
97435: NOT
97436: IFFALSE 97440
// continue ;
97438: GO 95939
// if f_ignore_area then
97440: LD_VAR 0 17
97444: IFFALSE 97532
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
97446: LD_ADDR_VAR 0 15
97450: PUSH
97451: LD_VAR 0 14
97455: PPUSH
97456: LD_INT 3
97458: PUSH
97459: LD_INT 92
97461: PUSH
97462: LD_VAR 0 17
97466: PUSH
97467: LD_INT 1
97469: ARRAY
97470: PUSH
97471: LD_VAR 0 17
97475: PUSH
97476: LD_INT 2
97478: ARRAY
97479: PUSH
97480: LD_VAR 0 17
97484: PUSH
97485: LD_INT 3
97487: ARRAY
97488: PUSH
97489: EMPTY
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: PPUSH
97499: CALL_OW 72
97503: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97504: LD_VAR 0 14
97508: PUSH
97509: LD_VAR 0 15
97513: DIFF
97514: IFFALSE 97532
// tmp := tmp diff tmp2 ;
97516: LD_ADDR_VAR 0 14
97520: PUSH
97521: LD_VAR 0 14
97525: PUSH
97526: LD_VAR 0 15
97530: DIFF
97531: ST_TO_ADDR
// end ; if not f_murder then
97532: LD_VAR 0 20
97536: NOT
97537: IFFALSE 97595
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
97539: LD_ADDR_VAR 0 15
97543: PUSH
97544: LD_VAR 0 14
97548: PPUSH
97549: LD_INT 3
97551: PUSH
97552: LD_INT 50
97554: PUSH
97555: EMPTY
97556: LIST
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: PPUSH
97562: CALL_OW 72
97566: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97567: LD_VAR 0 14
97571: PUSH
97572: LD_VAR 0 15
97576: DIFF
97577: IFFALSE 97595
// tmp := tmp diff tmp2 ;
97579: LD_ADDR_VAR 0 14
97583: PUSH
97584: LD_VAR 0 14
97588: PUSH
97589: LD_VAR 0 15
97593: DIFF
97594: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
97595: LD_ADDR_VAR 0 14
97599: PUSH
97600: LD_VAR 0 4
97604: PUSH
97605: LD_VAR 0 7
97609: ARRAY
97610: PPUSH
97611: LD_VAR 0 14
97615: PPUSH
97616: LD_INT 1
97618: PPUSH
97619: LD_INT 1
97621: PPUSH
97622: CALL 19014 0 4
97626: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
97627: LD_VAR 0 4
97631: PUSH
97632: LD_VAR 0 7
97636: ARRAY
97637: PPUSH
97638: CALL_OW 257
97642: PUSH
97643: LD_INT 1
97645: EQUAL
97646: IFFALSE 98094
// begin if WantPlant ( group [ i ] ) then
97648: LD_VAR 0 4
97652: PUSH
97653: LD_VAR 0 7
97657: ARRAY
97658: PPUSH
97659: CALL 18515 0 1
97663: IFFALSE 97667
// continue ;
97665: GO 95939
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
97667: LD_VAR 0 18
97671: PUSH
97672: LD_VAR 0 4
97676: PUSH
97677: LD_VAR 0 7
97681: ARRAY
97682: PPUSH
97683: CALL_OW 310
97687: NOT
97688: AND
97689: PUSH
97690: LD_VAR 0 14
97694: PUSH
97695: LD_INT 1
97697: ARRAY
97698: PUSH
97699: LD_VAR 0 14
97703: PPUSH
97704: LD_INT 21
97706: PUSH
97707: LD_INT 2
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: PUSH
97714: LD_INT 58
97716: PUSH
97717: EMPTY
97718: LIST
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PPUSH
97724: CALL_OW 72
97728: IN
97729: AND
97730: IFFALSE 97766
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
97732: LD_VAR 0 4
97736: PUSH
97737: LD_VAR 0 7
97741: ARRAY
97742: PPUSH
97743: LD_VAR 0 14
97747: PUSH
97748: LD_INT 1
97750: ARRAY
97751: PPUSH
97752: CALL_OW 120
// attacking := true ;
97756: LD_ADDR_VAR 0 29
97760: PUSH
97761: LD_INT 1
97763: ST_TO_ADDR
// continue ;
97764: GO 95939
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
97766: LD_VAR 0 26
97770: PUSH
97771: LD_VAR 0 4
97775: PUSH
97776: LD_VAR 0 7
97780: ARRAY
97781: PPUSH
97782: CALL_OW 257
97786: PUSH
97787: LD_INT 1
97789: EQUAL
97790: AND
97791: PUSH
97792: LD_VAR 0 4
97796: PUSH
97797: LD_VAR 0 7
97801: ARRAY
97802: PPUSH
97803: CALL_OW 256
97807: PUSH
97808: LD_INT 800
97810: LESS
97811: AND
97812: PUSH
97813: LD_VAR 0 4
97817: PUSH
97818: LD_VAR 0 7
97822: ARRAY
97823: PPUSH
97824: CALL_OW 318
97828: NOT
97829: AND
97830: IFFALSE 97847
// ComCrawl ( group [ i ] ) ;
97832: LD_VAR 0 4
97836: PUSH
97837: LD_VAR 0 7
97841: ARRAY
97842: PPUSH
97843: CALL_OW 137
// if f_mines then
97847: LD_VAR 0 21
97851: IFFALSE 98094
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
97853: LD_VAR 0 14
97857: PUSH
97858: LD_INT 1
97860: ARRAY
97861: PPUSH
97862: CALL_OW 247
97866: PUSH
97867: LD_INT 3
97869: EQUAL
97870: PUSH
97871: LD_VAR 0 14
97875: PUSH
97876: LD_INT 1
97878: ARRAY
97879: PUSH
97880: LD_VAR 0 27
97884: IN
97885: NOT
97886: AND
97887: IFFALSE 98094
// begin x := GetX ( tmp [ 1 ] ) ;
97889: LD_ADDR_VAR 0 10
97893: PUSH
97894: LD_VAR 0 14
97898: PUSH
97899: LD_INT 1
97901: ARRAY
97902: PPUSH
97903: CALL_OW 250
97907: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
97908: LD_ADDR_VAR 0 11
97912: PUSH
97913: LD_VAR 0 14
97917: PUSH
97918: LD_INT 1
97920: ARRAY
97921: PPUSH
97922: CALL_OW 251
97926: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
97927: LD_ADDR_VAR 0 12
97931: PUSH
97932: LD_VAR 0 4
97936: PUSH
97937: LD_VAR 0 7
97941: ARRAY
97942: PPUSH
97943: CALL 45456 0 1
97947: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
97948: LD_VAR 0 4
97952: PUSH
97953: LD_VAR 0 7
97957: ARRAY
97958: PPUSH
97959: LD_VAR 0 10
97963: PPUSH
97964: LD_VAR 0 11
97968: PPUSH
97969: LD_VAR 0 14
97973: PUSH
97974: LD_INT 1
97976: ARRAY
97977: PPUSH
97978: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
97982: LD_VAR 0 4
97986: PUSH
97987: LD_VAR 0 7
97991: ARRAY
97992: PPUSH
97993: LD_VAR 0 10
97997: PPUSH
97998: LD_VAR 0 12
98002: PPUSH
98003: LD_INT 7
98005: PPUSH
98006: CALL_OW 272
98010: PPUSH
98011: LD_VAR 0 11
98015: PPUSH
98016: LD_VAR 0 12
98020: PPUSH
98021: LD_INT 7
98023: PPUSH
98024: CALL_OW 273
98028: PPUSH
98029: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
98033: LD_VAR 0 4
98037: PUSH
98038: LD_VAR 0 7
98042: ARRAY
98043: PPUSH
98044: LD_INT 71
98046: PPUSH
98047: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
98051: LD_ADDR_VAR 0 27
98055: PUSH
98056: LD_VAR 0 27
98060: PPUSH
98061: LD_VAR 0 27
98065: PUSH
98066: LD_INT 1
98068: PLUS
98069: PPUSH
98070: LD_VAR 0 14
98074: PUSH
98075: LD_INT 1
98077: ARRAY
98078: PPUSH
98079: CALL_OW 1
98083: ST_TO_ADDR
// attacking := true ;
98084: LD_ADDR_VAR 0 29
98088: PUSH
98089: LD_INT 1
98091: ST_TO_ADDR
// continue ;
98092: GO 95939
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
98094: LD_VAR 0 4
98098: PUSH
98099: LD_VAR 0 7
98103: ARRAY
98104: PPUSH
98105: CALL_OW 257
98109: PUSH
98110: LD_INT 17
98112: EQUAL
98113: PUSH
98114: LD_VAR 0 4
98118: PUSH
98119: LD_VAR 0 7
98123: ARRAY
98124: PPUSH
98125: CALL_OW 110
98129: PUSH
98130: LD_INT 71
98132: EQUAL
98133: NOT
98134: AND
98135: IFFALSE 98281
// begin attacking := false ;
98137: LD_ADDR_VAR 0 29
98141: PUSH
98142: LD_INT 0
98144: ST_TO_ADDR
// k := 5 ;
98145: LD_ADDR_VAR 0 9
98149: PUSH
98150: LD_INT 5
98152: ST_TO_ADDR
// if tmp < k then
98153: LD_VAR 0 14
98157: PUSH
98158: LD_VAR 0 9
98162: LESS
98163: IFFALSE 98175
// k := tmp ;
98165: LD_ADDR_VAR 0 9
98169: PUSH
98170: LD_VAR 0 14
98174: ST_TO_ADDR
// for j = 1 to k do
98175: LD_ADDR_VAR 0 8
98179: PUSH
98180: DOUBLE
98181: LD_INT 1
98183: DEC
98184: ST_TO_ADDR
98185: LD_VAR 0 9
98189: PUSH
98190: FOR_TO
98191: IFFALSE 98279
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
98193: LD_VAR 0 14
98197: PUSH
98198: LD_VAR 0 8
98202: ARRAY
98203: PUSH
98204: LD_VAR 0 14
98208: PPUSH
98209: LD_INT 58
98211: PUSH
98212: EMPTY
98213: LIST
98214: PPUSH
98215: CALL_OW 72
98219: IN
98220: NOT
98221: IFFALSE 98277
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98223: LD_VAR 0 4
98227: PUSH
98228: LD_VAR 0 7
98232: ARRAY
98233: PPUSH
98234: LD_VAR 0 14
98238: PUSH
98239: LD_VAR 0 8
98243: ARRAY
98244: PPUSH
98245: CALL_OW 115
// attacking := true ;
98249: LD_ADDR_VAR 0 29
98253: PUSH
98254: LD_INT 1
98256: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
98257: LD_VAR 0 4
98261: PUSH
98262: LD_VAR 0 7
98266: ARRAY
98267: PPUSH
98268: LD_INT 71
98270: PPUSH
98271: CALL_OW 109
// continue ;
98275: GO 98190
// end ; end ;
98277: GO 98190
98279: POP
98280: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
98281: LD_VAR 0 4
98285: PUSH
98286: LD_VAR 0 7
98290: ARRAY
98291: PPUSH
98292: CALL_OW 257
98296: PUSH
98297: LD_INT 8
98299: EQUAL
98300: PUSH
98301: LD_VAR 0 4
98305: PUSH
98306: LD_VAR 0 7
98310: ARRAY
98311: PPUSH
98312: CALL_OW 264
98316: PUSH
98317: LD_INT 28
98319: PUSH
98320: LD_INT 45
98322: PUSH
98323: LD_INT 7
98325: PUSH
98326: LD_INT 47
98328: PUSH
98329: EMPTY
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: IN
98335: OR
98336: IFFALSE 98592
// begin attacking := false ;
98338: LD_ADDR_VAR 0 29
98342: PUSH
98343: LD_INT 0
98345: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
98346: LD_VAR 0 14
98350: PUSH
98351: LD_INT 1
98353: ARRAY
98354: PPUSH
98355: CALL_OW 266
98359: PUSH
98360: LD_INT 32
98362: PUSH
98363: LD_INT 31
98365: PUSH
98366: LD_INT 33
98368: PUSH
98369: LD_INT 4
98371: PUSH
98372: LD_INT 5
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: IN
98382: IFFALSE 98568
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
98384: LD_ADDR_VAR 0 9
98388: PUSH
98389: LD_VAR 0 14
98393: PUSH
98394: LD_INT 1
98396: ARRAY
98397: PPUSH
98398: CALL_OW 266
98402: PPUSH
98403: LD_VAR 0 14
98407: PUSH
98408: LD_INT 1
98410: ARRAY
98411: PPUSH
98412: CALL_OW 250
98416: PPUSH
98417: LD_VAR 0 14
98421: PUSH
98422: LD_INT 1
98424: ARRAY
98425: PPUSH
98426: CALL_OW 251
98430: PPUSH
98431: LD_VAR 0 14
98435: PUSH
98436: LD_INT 1
98438: ARRAY
98439: PPUSH
98440: CALL_OW 254
98444: PPUSH
98445: LD_VAR 0 14
98449: PUSH
98450: LD_INT 1
98452: ARRAY
98453: PPUSH
98454: CALL_OW 248
98458: PPUSH
98459: LD_INT 0
98461: PPUSH
98462: CALL 26826 0 6
98466: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
98467: LD_ADDR_VAR 0 8
98471: PUSH
98472: LD_VAR 0 4
98476: PUSH
98477: LD_VAR 0 7
98481: ARRAY
98482: PPUSH
98483: LD_VAR 0 9
98487: PPUSH
98488: CALL 45496 0 2
98492: ST_TO_ADDR
// if j then
98493: LD_VAR 0 8
98497: IFFALSE 98566
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
98499: LD_VAR 0 8
98503: PUSH
98504: LD_INT 1
98506: ARRAY
98507: PPUSH
98508: LD_VAR 0 8
98512: PUSH
98513: LD_INT 2
98515: ARRAY
98516: PPUSH
98517: CALL_OW 488
98521: IFFALSE 98566
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
98523: LD_VAR 0 4
98527: PUSH
98528: LD_VAR 0 7
98532: ARRAY
98533: PPUSH
98534: LD_VAR 0 8
98538: PUSH
98539: LD_INT 1
98541: ARRAY
98542: PPUSH
98543: LD_VAR 0 8
98547: PUSH
98548: LD_INT 2
98550: ARRAY
98551: PPUSH
98552: CALL_OW 116
// attacking := true ;
98556: LD_ADDR_VAR 0 29
98560: PUSH
98561: LD_INT 1
98563: ST_TO_ADDR
// continue ;
98564: GO 95939
// end ; end else
98566: GO 98592
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98568: LD_VAR 0 4
98572: PUSH
98573: LD_VAR 0 7
98577: ARRAY
98578: PPUSH
98579: LD_VAR 0 14
98583: PUSH
98584: LD_INT 1
98586: ARRAY
98587: PPUSH
98588: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
98592: LD_VAR 0 4
98596: PUSH
98597: LD_VAR 0 7
98601: ARRAY
98602: PPUSH
98603: CALL_OW 265
98607: PUSH
98608: LD_INT 11
98610: EQUAL
98611: IFFALSE 98889
// begin k := 10 ;
98613: LD_ADDR_VAR 0 9
98617: PUSH
98618: LD_INT 10
98620: ST_TO_ADDR
// x := 0 ;
98621: LD_ADDR_VAR 0 10
98625: PUSH
98626: LD_INT 0
98628: ST_TO_ADDR
// if tmp < k then
98629: LD_VAR 0 14
98633: PUSH
98634: LD_VAR 0 9
98638: LESS
98639: IFFALSE 98651
// k := tmp ;
98641: LD_ADDR_VAR 0 9
98645: PUSH
98646: LD_VAR 0 14
98650: ST_TO_ADDR
// for j = k downto 1 do
98651: LD_ADDR_VAR 0 8
98655: PUSH
98656: DOUBLE
98657: LD_VAR 0 9
98661: INC
98662: ST_TO_ADDR
98663: LD_INT 1
98665: PUSH
98666: FOR_DOWNTO
98667: IFFALSE 98742
// begin if GetType ( tmp [ j ] ) = unit_human then
98669: LD_VAR 0 14
98673: PUSH
98674: LD_VAR 0 8
98678: ARRAY
98679: PPUSH
98680: CALL_OW 247
98684: PUSH
98685: LD_INT 1
98687: EQUAL
98688: IFFALSE 98740
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
98690: LD_VAR 0 4
98694: PUSH
98695: LD_VAR 0 7
98699: ARRAY
98700: PPUSH
98701: LD_VAR 0 14
98705: PUSH
98706: LD_VAR 0 8
98710: ARRAY
98711: PPUSH
98712: CALL 45767 0 2
// x := tmp [ j ] ;
98716: LD_ADDR_VAR 0 10
98720: PUSH
98721: LD_VAR 0 14
98725: PUSH
98726: LD_VAR 0 8
98730: ARRAY
98731: ST_TO_ADDR
// attacking := true ;
98732: LD_ADDR_VAR 0 29
98736: PUSH
98737: LD_INT 1
98739: ST_TO_ADDR
// end ; end ;
98740: GO 98666
98742: POP
98743: POP
// if not x then
98744: LD_VAR 0 10
98748: NOT
98749: IFFALSE 98889
// begin attacking := true ;
98751: LD_ADDR_VAR 0 29
98755: PUSH
98756: LD_INT 1
98758: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
98759: LD_VAR 0 4
98763: PUSH
98764: LD_VAR 0 7
98768: ARRAY
98769: PPUSH
98770: CALL_OW 250
98774: PPUSH
98775: LD_VAR 0 4
98779: PUSH
98780: LD_VAR 0 7
98784: ARRAY
98785: PPUSH
98786: CALL_OW 251
98790: PPUSH
98791: CALL_OW 546
98795: PUSH
98796: LD_INT 2
98798: ARRAY
98799: PUSH
98800: LD_VAR 0 14
98804: PUSH
98805: LD_INT 1
98807: ARRAY
98808: PPUSH
98809: CALL_OW 250
98813: PPUSH
98814: LD_VAR 0 14
98818: PUSH
98819: LD_INT 1
98821: ARRAY
98822: PPUSH
98823: CALL_OW 251
98827: PPUSH
98828: CALL_OW 546
98832: PUSH
98833: LD_INT 2
98835: ARRAY
98836: EQUAL
98837: IFFALSE 98865
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
98839: LD_VAR 0 4
98843: PUSH
98844: LD_VAR 0 7
98848: ARRAY
98849: PPUSH
98850: LD_VAR 0 14
98854: PUSH
98855: LD_INT 1
98857: ARRAY
98858: PPUSH
98859: CALL 45767 0 2
98863: GO 98889
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98865: LD_VAR 0 4
98869: PUSH
98870: LD_VAR 0 7
98874: ARRAY
98875: PPUSH
98876: LD_VAR 0 14
98880: PUSH
98881: LD_INT 1
98883: ARRAY
98884: PPUSH
98885: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
98889: LD_VAR 0 4
98893: PUSH
98894: LD_VAR 0 7
98898: ARRAY
98899: PPUSH
98900: CALL_OW 264
98904: PUSH
98905: LD_INT 29
98907: EQUAL
98908: IFFALSE 99274
// begin if WantsToAttack ( group [ i ] ) in bombed then
98910: LD_VAR 0 4
98914: PUSH
98915: LD_VAR 0 7
98919: ARRAY
98920: PPUSH
98921: CALL_OW 319
98925: PUSH
98926: LD_VAR 0 28
98930: IN
98931: IFFALSE 98935
// continue ;
98933: GO 95939
// k := 8 ;
98935: LD_ADDR_VAR 0 9
98939: PUSH
98940: LD_INT 8
98942: ST_TO_ADDR
// x := 0 ;
98943: LD_ADDR_VAR 0 10
98947: PUSH
98948: LD_INT 0
98950: ST_TO_ADDR
// if tmp < k then
98951: LD_VAR 0 14
98955: PUSH
98956: LD_VAR 0 9
98960: LESS
98961: IFFALSE 98973
// k := tmp ;
98963: LD_ADDR_VAR 0 9
98967: PUSH
98968: LD_VAR 0 14
98972: ST_TO_ADDR
// for j = 1 to k do
98973: LD_ADDR_VAR 0 8
98977: PUSH
98978: DOUBLE
98979: LD_INT 1
98981: DEC
98982: ST_TO_ADDR
98983: LD_VAR 0 9
98987: PUSH
98988: FOR_TO
98989: IFFALSE 99121
// begin if GetType ( tmp [ j ] ) = unit_building then
98991: LD_VAR 0 14
98995: PUSH
98996: LD_VAR 0 8
99000: ARRAY
99001: PPUSH
99002: CALL_OW 247
99006: PUSH
99007: LD_INT 3
99009: EQUAL
99010: IFFALSE 99119
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
99012: LD_VAR 0 14
99016: PUSH
99017: LD_VAR 0 8
99021: ARRAY
99022: PUSH
99023: LD_VAR 0 28
99027: IN
99028: NOT
99029: PUSH
99030: LD_VAR 0 14
99034: PUSH
99035: LD_VAR 0 8
99039: ARRAY
99040: PPUSH
99041: CALL_OW 313
99045: AND
99046: IFFALSE 99119
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99048: LD_VAR 0 4
99052: PUSH
99053: LD_VAR 0 7
99057: ARRAY
99058: PPUSH
99059: LD_VAR 0 14
99063: PUSH
99064: LD_VAR 0 8
99068: ARRAY
99069: PPUSH
99070: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
99074: LD_ADDR_VAR 0 28
99078: PUSH
99079: LD_VAR 0 28
99083: PPUSH
99084: LD_VAR 0 28
99088: PUSH
99089: LD_INT 1
99091: PLUS
99092: PPUSH
99093: LD_VAR 0 14
99097: PUSH
99098: LD_VAR 0 8
99102: ARRAY
99103: PPUSH
99104: CALL_OW 1
99108: ST_TO_ADDR
// attacking := true ;
99109: LD_ADDR_VAR 0 29
99113: PUSH
99114: LD_INT 1
99116: ST_TO_ADDR
// break ;
99117: GO 99121
// end ; end ;
99119: GO 98988
99121: POP
99122: POP
// if not attacking and f_attack_depot then
99123: LD_VAR 0 29
99127: NOT
99128: PUSH
99129: LD_VAR 0 25
99133: AND
99134: IFFALSE 99229
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
99136: LD_ADDR_VAR 0 13
99140: PUSH
99141: LD_VAR 0 14
99145: PPUSH
99146: LD_INT 2
99148: PUSH
99149: LD_INT 30
99151: PUSH
99152: LD_INT 0
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: LD_INT 30
99161: PUSH
99162: LD_INT 1
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: PPUSH
99174: CALL_OW 72
99178: ST_TO_ADDR
// if z then
99179: LD_VAR 0 13
99183: IFFALSE 99229
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
99185: LD_VAR 0 4
99189: PUSH
99190: LD_VAR 0 7
99194: ARRAY
99195: PPUSH
99196: LD_VAR 0 13
99200: PPUSH
99201: LD_VAR 0 4
99205: PUSH
99206: LD_VAR 0 7
99210: ARRAY
99211: PPUSH
99212: CALL_OW 74
99216: PPUSH
99217: CALL_OW 115
// attacking := true ;
99221: LD_ADDR_VAR 0 29
99225: PUSH
99226: LD_INT 1
99228: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
99229: LD_VAR 0 4
99233: PUSH
99234: LD_VAR 0 7
99238: ARRAY
99239: PPUSH
99240: CALL_OW 256
99244: PUSH
99245: LD_INT 500
99247: LESS
99248: IFFALSE 99274
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99250: LD_VAR 0 4
99254: PUSH
99255: LD_VAR 0 7
99259: ARRAY
99260: PPUSH
99261: LD_VAR 0 14
99265: PUSH
99266: LD_INT 1
99268: ARRAY
99269: PPUSH
99270: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
99274: LD_VAR 0 4
99278: PUSH
99279: LD_VAR 0 7
99283: ARRAY
99284: PPUSH
99285: CALL_OW 264
99289: PUSH
99290: LD_INT 49
99292: EQUAL
99293: IFFALSE 99414
// begin if not HasTask ( group [ i ] ) then
99295: LD_VAR 0 4
99299: PUSH
99300: LD_VAR 0 7
99304: ARRAY
99305: PPUSH
99306: CALL_OW 314
99310: NOT
99311: IFFALSE 99414
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
99313: LD_ADDR_VAR 0 9
99317: PUSH
99318: LD_INT 81
99320: PUSH
99321: LD_VAR 0 4
99325: PUSH
99326: LD_VAR 0 7
99330: ARRAY
99331: PPUSH
99332: CALL_OW 255
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: PPUSH
99341: CALL_OW 69
99345: PPUSH
99346: LD_VAR 0 4
99350: PUSH
99351: LD_VAR 0 7
99355: ARRAY
99356: PPUSH
99357: CALL_OW 74
99361: ST_TO_ADDR
// if k then
99362: LD_VAR 0 9
99366: IFFALSE 99414
// if GetDistUnits ( group [ i ] , k ) > 10 then
99368: LD_VAR 0 4
99372: PUSH
99373: LD_VAR 0 7
99377: ARRAY
99378: PPUSH
99379: LD_VAR 0 9
99383: PPUSH
99384: CALL_OW 296
99388: PUSH
99389: LD_INT 10
99391: GREATER
99392: IFFALSE 99414
// ComMoveUnit ( group [ i ] , k ) ;
99394: LD_VAR 0 4
99398: PUSH
99399: LD_VAR 0 7
99403: ARRAY
99404: PPUSH
99405: LD_VAR 0 9
99409: PPUSH
99410: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99414: LD_VAR 0 4
99418: PUSH
99419: LD_VAR 0 7
99423: ARRAY
99424: PPUSH
99425: CALL_OW 256
99429: PUSH
99430: LD_INT 250
99432: LESS
99433: PUSH
99434: LD_VAR 0 4
99438: PUSH
99439: LD_VAR 0 7
99443: ARRAY
99444: PUSH
99445: LD_INT 21
99447: PUSH
99448: LD_INT 2
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: PUSH
99455: LD_INT 23
99457: PUSH
99458: LD_INT 2
99460: PUSH
99461: EMPTY
99462: LIST
99463: LIST
99464: PUSH
99465: EMPTY
99466: LIST
99467: LIST
99468: PPUSH
99469: CALL_OW 69
99473: IN
99474: AND
99475: IFFALSE 99600
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
99477: LD_ADDR_VAR 0 9
99481: PUSH
99482: LD_OWVAR 3
99486: PUSH
99487: LD_VAR 0 4
99491: PUSH
99492: LD_VAR 0 7
99496: ARRAY
99497: DIFF
99498: PPUSH
99499: LD_VAR 0 4
99503: PUSH
99504: LD_VAR 0 7
99508: ARRAY
99509: PPUSH
99510: CALL_OW 74
99514: ST_TO_ADDR
// if not k then
99515: LD_VAR 0 9
99519: NOT
99520: IFFALSE 99524
// continue ;
99522: GO 95939
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
99524: LD_VAR 0 9
99528: PUSH
99529: LD_INT 81
99531: PUSH
99532: LD_VAR 0 4
99536: PUSH
99537: LD_VAR 0 7
99541: ARRAY
99542: PPUSH
99543: CALL_OW 255
99547: PUSH
99548: EMPTY
99549: LIST
99550: LIST
99551: PPUSH
99552: CALL_OW 69
99556: IN
99557: PUSH
99558: LD_VAR 0 9
99562: PPUSH
99563: LD_VAR 0 4
99567: PUSH
99568: LD_VAR 0 7
99572: ARRAY
99573: PPUSH
99574: CALL_OW 296
99578: PUSH
99579: LD_INT 5
99581: LESS
99582: AND
99583: IFFALSE 99600
// ComAutodestruct ( group [ i ] ) ;
99585: LD_VAR 0 4
99589: PUSH
99590: LD_VAR 0 7
99594: ARRAY
99595: PPUSH
99596: CALL 45665 0 1
// end ; if f_attack_depot then
99600: LD_VAR 0 25
99604: IFFALSE 99716
// begin k := 6 ;
99606: LD_ADDR_VAR 0 9
99610: PUSH
99611: LD_INT 6
99613: ST_TO_ADDR
// if tmp < k then
99614: LD_VAR 0 14
99618: PUSH
99619: LD_VAR 0 9
99623: LESS
99624: IFFALSE 99636
// k := tmp ;
99626: LD_ADDR_VAR 0 9
99630: PUSH
99631: LD_VAR 0 14
99635: ST_TO_ADDR
// for j = 1 to k do
99636: LD_ADDR_VAR 0 8
99640: PUSH
99641: DOUBLE
99642: LD_INT 1
99644: DEC
99645: ST_TO_ADDR
99646: LD_VAR 0 9
99650: PUSH
99651: FOR_TO
99652: IFFALSE 99714
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
99654: LD_VAR 0 8
99658: PPUSH
99659: CALL_OW 266
99663: PUSH
99664: LD_INT 0
99666: PUSH
99667: LD_INT 1
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: IN
99674: IFFALSE 99712
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99676: LD_VAR 0 4
99680: PUSH
99681: LD_VAR 0 7
99685: ARRAY
99686: PPUSH
99687: LD_VAR 0 14
99691: PUSH
99692: LD_VAR 0 8
99696: ARRAY
99697: PPUSH
99698: CALL_OW 115
// attacking := true ;
99702: LD_ADDR_VAR 0 29
99706: PUSH
99707: LD_INT 1
99709: ST_TO_ADDR
// break ;
99710: GO 99714
// end ;
99712: GO 99651
99714: POP
99715: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
99716: LD_VAR 0 4
99720: PUSH
99721: LD_VAR 0 7
99725: ARRAY
99726: PPUSH
99727: CALL_OW 302
99731: PUSH
99732: LD_VAR 0 29
99736: NOT
99737: AND
99738: IFFALSE 100060
// begin if GetTag ( group [ i ] ) = 71 then
99740: LD_VAR 0 4
99744: PUSH
99745: LD_VAR 0 7
99749: ARRAY
99750: PPUSH
99751: CALL_OW 110
99755: PUSH
99756: LD_INT 71
99758: EQUAL
99759: IFFALSE 99800
// begin if HasTask ( group [ i ] ) then
99761: LD_VAR 0 4
99765: PUSH
99766: LD_VAR 0 7
99770: ARRAY
99771: PPUSH
99772: CALL_OW 314
99776: IFFALSE 99782
// continue else
99778: GO 95939
99780: GO 99800
// SetTag ( group [ i ] , 0 ) ;
99782: LD_VAR 0 4
99786: PUSH
99787: LD_VAR 0 7
99791: ARRAY
99792: PPUSH
99793: LD_INT 0
99795: PPUSH
99796: CALL_OW 109
// end ; k := 8 ;
99800: LD_ADDR_VAR 0 9
99804: PUSH
99805: LD_INT 8
99807: ST_TO_ADDR
// x := 0 ;
99808: LD_ADDR_VAR 0 10
99812: PUSH
99813: LD_INT 0
99815: ST_TO_ADDR
// if tmp < k then
99816: LD_VAR 0 14
99820: PUSH
99821: LD_VAR 0 9
99825: LESS
99826: IFFALSE 99838
// k := tmp ;
99828: LD_ADDR_VAR 0 9
99832: PUSH
99833: LD_VAR 0 14
99837: ST_TO_ADDR
// for j = 1 to k do
99838: LD_ADDR_VAR 0 8
99842: PUSH
99843: DOUBLE
99844: LD_INT 1
99846: DEC
99847: ST_TO_ADDR
99848: LD_VAR 0 9
99852: PUSH
99853: FOR_TO
99854: IFFALSE 99952
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
99856: LD_VAR 0 14
99860: PUSH
99861: LD_VAR 0 8
99865: ARRAY
99866: PPUSH
99867: CALL_OW 247
99871: PUSH
99872: LD_INT 1
99874: EQUAL
99875: PUSH
99876: LD_VAR 0 14
99880: PUSH
99881: LD_VAR 0 8
99885: ARRAY
99886: PPUSH
99887: CALL_OW 256
99891: PUSH
99892: LD_INT 250
99894: LESS
99895: PUSH
99896: LD_VAR 0 20
99900: AND
99901: PUSH
99902: LD_VAR 0 20
99906: NOT
99907: PUSH
99908: LD_VAR 0 14
99912: PUSH
99913: LD_VAR 0 8
99917: ARRAY
99918: PPUSH
99919: CALL_OW 256
99923: PUSH
99924: LD_INT 250
99926: GREATEREQUAL
99927: AND
99928: OR
99929: AND
99930: IFFALSE 99950
// begin x := tmp [ j ] ;
99932: LD_ADDR_VAR 0 10
99936: PUSH
99937: LD_VAR 0 14
99941: PUSH
99942: LD_VAR 0 8
99946: ARRAY
99947: ST_TO_ADDR
// break ;
99948: GO 99952
// end ;
99950: GO 99853
99952: POP
99953: POP
// if x then
99954: LD_VAR 0 10
99958: IFFALSE 99982
// ComAttackUnit ( group [ i ] , x ) else
99960: LD_VAR 0 4
99964: PUSH
99965: LD_VAR 0 7
99969: ARRAY
99970: PPUSH
99971: LD_VAR 0 10
99975: PPUSH
99976: CALL_OW 115
99980: GO 100006
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99982: LD_VAR 0 4
99986: PUSH
99987: LD_VAR 0 7
99991: ARRAY
99992: PPUSH
99993: LD_VAR 0 14
99997: PUSH
99998: LD_INT 1
100000: ARRAY
100001: PPUSH
100002: CALL_OW 115
// if not HasTask ( group [ i ] ) then
100006: LD_VAR 0 4
100010: PUSH
100011: LD_VAR 0 7
100015: ARRAY
100016: PPUSH
100017: CALL_OW 314
100021: NOT
100022: IFFALSE 100060
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
100024: LD_VAR 0 4
100028: PUSH
100029: LD_VAR 0 7
100033: ARRAY
100034: PPUSH
100035: LD_VAR 0 14
100039: PPUSH
100040: LD_VAR 0 4
100044: PUSH
100045: LD_VAR 0 7
100049: ARRAY
100050: PPUSH
100051: CALL_OW 74
100055: PPUSH
100056: CALL_OW 115
// end ; end ; end ;
100060: GO 95939
100062: POP
100063: POP
// wait ( 0 0$2 ) ;
100064: LD_INT 70
100066: PPUSH
100067: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
100071: LD_VAR 0 4
100075: NOT
100076: PUSH
100077: LD_VAR 0 4
100081: PUSH
100082: EMPTY
100083: EQUAL
100084: OR
100085: PUSH
100086: LD_INT 81
100088: PUSH
100089: LD_VAR 0 35
100093: PUSH
100094: EMPTY
100095: LIST
100096: LIST
100097: PPUSH
100098: CALL_OW 69
100102: NOT
100103: OR
100104: IFFALSE 95924
// end ;
100106: LD_VAR 0 2
100110: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
100111: LD_INT 0
100113: PPUSH
100114: PPUSH
100115: PPUSH
100116: PPUSH
100117: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
100118: LD_VAR 0 1
100122: NOT
100123: PUSH
100124: LD_EXP 65
100128: PUSH
100129: LD_VAR 0 1
100133: ARRAY
100134: NOT
100135: OR
100136: PUSH
100137: LD_VAR 0 2
100141: NOT
100142: OR
100143: PUSH
100144: LD_VAR 0 3
100148: NOT
100149: OR
100150: IFFALSE 100154
// exit ;
100152: GO 100667
// side := mc_sides [ base ] ;
100154: LD_ADDR_VAR 0 6
100158: PUSH
100159: LD_EXP 91
100163: PUSH
100164: LD_VAR 0 1
100168: ARRAY
100169: ST_TO_ADDR
// if not side then
100170: LD_VAR 0 6
100174: NOT
100175: IFFALSE 100179
// exit ;
100177: GO 100667
// for i in solds do
100179: LD_ADDR_VAR 0 7
100183: PUSH
100184: LD_VAR 0 2
100188: PUSH
100189: FOR_IN
100190: IFFALSE 100251
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
100192: LD_VAR 0 7
100196: PPUSH
100197: CALL_OW 310
100201: PPUSH
100202: CALL_OW 266
100206: PUSH
100207: LD_INT 32
100209: PUSH
100210: LD_INT 31
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: IN
100217: IFFALSE 100237
// solds := solds diff i else
100219: LD_ADDR_VAR 0 2
100223: PUSH
100224: LD_VAR 0 2
100228: PUSH
100229: LD_VAR 0 7
100233: DIFF
100234: ST_TO_ADDR
100235: GO 100249
// SetTag ( i , 18 ) ;
100237: LD_VAR 0 7
100241: PPUSH
100242: LD_INT 18
100244: PPUSH
100245: CALL_OW 109
100249: GO 100189
100251: POP
100252: POP
// if not solds then
100253: LD_VAR 0 2
100257: NOT
100258: IFFALSE 100262
// exit ;
100260: GO 100667
// repeat wait ( 0 0$1 ) ;
100262: LD_INT 35
100264: PPUSH
100265: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
100269: LD_ADDR_VAR 0 5
100273: PUSH
100274: LD_VAR 0 6
100278: PPUSH
100279: LD_VAR 0 3
100283: PPUSH
100284: CALL 15380 0 2
100288: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
100289: LD_EXP 65
100293: PUSH
100294: LD_VAR 0 1
100298: ARRAY
100299: NOT
100300: PUSH
100301: LD_EXP 65
100305: PUSH
100306: LD_VAR 0 1
100310: ARRAY
100311: PUSH
100312: EMPTY
100313: EQUAL
100314: OR
100315: IFFALSE 100352
// begin for i in solds do
100317: LD_ADDR_VAR 0 7
100321: PUSH
100322: LD_VAR 0 2
100326: PUSH
100327: FOR_IN
100328: IFFALSE 100341
// ComStop ( i ) ;
100330: LD_VAR 0 7
100334: PPUSH
100335: CALL_OW 141
100339: GO 100327
100341: POP
100342: POP
// solds := [ ] ;
100343: LD_ADDR_VAR 0 2
100347: PUSH
100348: EMPTY
100349: ST_TO_ADDR
// exit ;
100350: GO 100667
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
100352: LD_VAR 0 5
100356: NOT
100357: PUSH
100358: LD_VAR 0 5
100362: PUSH
100363: LD_INT 3
100365: GREATER
100366: OR
100367: PUSH
100368: LD_EXP 87
100372: PUSH
100373: LD_VAR 0 1
100377: ARRAY
100378: OR
100379: IFFALSE 100420
// begin for i in solds do
100381: LD_ADDR_VAR 0 7
100385: PUSH
100386: LD_VAR 0 2
100390: PUSH
100391: FOR_IN
100392: IFFALSE 100416
// if HasTask ( i ) then
100394: LD_VAR 0 7
100398: PPUSH
100399: CALL_OW 314
100403: IFFALSE 100414
// ComStop ( i ) ;
100405: LD_VAR 0 7
100409: PPUSH
100410: CALL_OW 141
100414: GO 100391
100416: POP
100417: POP
// break ;
100418: GO 100655
// end ; for i in solds do
100420: LD_ADDR_VAR 0 7
100424: PUSH
100425: LD_VAR 0 2
100429: PUSH
100430: FOR_IN
100431: IFFALSE 100647
// begin if IsInUnit ( i ) then
100433: LD_VAR 0 7
100437: PPUSH
100438: CALL_OW 310
100442: IFFALSE 100453
// ComExitBuilding ( i ) ;
100444: LD_VAR 0 7
100448: PPUSH
100449: CALL_OW 122
// if GetLives ( i ) > 333 then
100453: LD_VAR 0 7
100457: PPUSH
100458: CALL_OW 256
100462: PUSH
100463: LD_INT 333
100465: GREATER
100466: IFFALSE 100494
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
100468: LD_VAR 0 7
100472: PPUSH
100473: LD_VAR 0 5
100477: PPUSH
100478: LD_VAR 0 7
100482: PPUSH
100483: CALL_OW 74
100487: PPUSH
100488: CALL_OW 115
100492: GO 100645
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
100494: LD_ADDR_VAR 0 8
100498: PUSH
100499: LD_EXP 65
100503: PUSH
100504: LD_VAR 0 1
100508: ARRAY
100509: PPUSH
100510: LD_INT 2
100512: PUSH
100513: LD_INT 30
100515: PUSH
100516: LD_INT 0
100518: PUSH
100519: EMPTY
100520: LIST
100521: LIST
100522: PUSH
100523: LD_INT 30
100525: PUSH
100526: LD_INT 1
100528: PUSH
100529: EMPTY
100530: LIST
100531: LIST
100532: PUSH
100533: LD_INT 30
100535: PUSH
100536: LD_INT 6
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: EMPTY
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: PPUSH
100549: CALL_OW 72
100553: PPUSH
100554: LD_VAR 0 7
100558: PPUSH
100559: CALL_OW 74
100563: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
100564: LD_VAR 0 7
100568: PPUSH
100569: LD_VAR 0 8
100573: PPUSH
100574: CALL_OW 250
100578: PPUSH
100579: LD_INT 3
100581: PPUSH
100582: LD_INT 5
100584: PPUSH
100585: CALL_OW 272
100589: PPUSH
100590: LD_VAR 0 8
100594: PPUSH
100595: CALL_OW 251
100599: PPUSH
100600: LD_INT 3
100602: PPUSH
100603: LD_INT 5
100605: PPUSH
100606: CALL_OW 273
100610: PPUSH
100611: CALL_OW 111
// SetTag ( i , 0 ) ;
100615: LD_VAR 0 7
100619: PPUSH
100620: LD_INT 0
100622: PPUSH
100623: CALL_OW 109
// solds := solds diff i ;
100627: LD_ADDR_VAR 0 2
100631: PUSH
100632: LD_VAR 0 2
100636: PUSH
100637: LD_VAR 0 7
100641: DIFF
100642: ST_TO_ADDR
// continue ;
100643: GO 100430
// end ; end ;
100645: GO 100430
100647: POP
100648: POP
// until solds ;
100649: LD_VAR 0 2
100653: IFFALSE 100262
// MC_Reset ( base , 18 ) ;
100655: LD_VAR 0 1
100659: PPUSH
100660: LD_INT 18
100662: PPUSH
100663: CALL 54497 0 2
// end ;
100667: LD_VAR 0 4
100671: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
100672: LD_INT 0
100674: PPUSH
100675: PPUSH
100676: PPUSH
100677: PPUSH
100678: PPUSH
100679: PPUSH
100680: PPUSH
100681: PPUSH
100682: PPUSH
100683: PPUSH
100684: PPUSH
100685: PPUSH
100686: PPUSH
100687: PPUSH
100688: PPUSH
100689: PPUSH
100690: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
100691: LD_ADDR_VAR 0 13
100695: PUSH
100696: LD_EXP 65
100700: PUSH
100701: LD_VAR 0 1
100705: ARRAY
100706: PPUSH
100707: LD_INT 25
100709: PUSH
100710: LD_INT 3
100712: PUSH
100713: EMPTY
100714: LIST
100715: LIST
100716: PPUSH
100717: CALL_OW 72
100721: ST_TO_ADDR
// if mc_remote_driver [ base ] then
100722: LD_EXP 105
100726: PUSH
100727: LD_VAR 0 1
100731: ARRAY
100732: IFFALSE 100756
// mechs := mechs diff mc_remote_driver [ base ] ;
100734: LD_ADDR_VAR 0 13
100738: PUSH
100739: LD_VAR 0 13
100743: PUSH
100744: LD_EXP 105
100748: PUSH
100749: LD_VAR 0 1
100753: ARRAY
100754: DIFF
100755: ST_TO_ADDR
// for i in mechs do
100756: LD_ADDR_VAR 0 5
100760: PUSH
100761: LD_VAR 0 13
100765: PUSH
100766: FOR_IN
100767: IFFALSE 100802
// if GetTag ( i ) > 0 then
100769: LD_VAR 0 5
100773: PPUSH
100774: CALL_OW 110
100778: PUSH
100779: LD_INT 0
100781: GREATER
100782: IFFALSE 100800
// mechs := mechs diff i ;
100784: LD_ADDR_VAR 0 13
100788: PUSH
100789: LD_VAR 0 13
100793: PUSH
100794: LD_VAR 0 5
100798: DIFF
100799: ST_TO_ADDR
100800: GO 100766
100802: POP
100803: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100804: LD_ADDR_VAR 0 9
100808: PUSH
100809: LD_EXP 65
100813: PUSH
100814: LD_VAR 0 1
100818: ARRAY
100819: PPUSH
100820: LD_INT 2
100822: PUSH
100823: LD_INT 25
100825: PUSH
100826: LD_INT 1
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 25
100835: PUSH
100836: LD_INT 5
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: LD_INT 25
100845: PUSH
100846: LD_INT 8
100848: PUSH
100849: EMPTY
100850: LIST
100851: LIST
100852: PUSH
100853: LD_INT 25
100855: PUSH
100856: LD_INT 9
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: LIST
100867: LIST
100868: LIST
100869: PPUSH
100870: CALL_OW 72
100874: ST_TO_ADDR
// if not defenders and not solds then
100875: LD_VAR 0 2
100879: NOT
100880: PUSH
100881: LD_VAR 0 9
100885: NOT
100886: AND
100887: IFFALSE 100891
// exit ;
100889: GO 102517
// depot_under_attack := false ;
100891: LD_ADDR_VAR 0 17
100895: PUSH
100896: LD_INT 0
100898: ST_TO_ADDR
// sold_defenders := [ ] ;
100899: LD_ADDR_VAR 0 18
100903: PUSH
100904: EMPTY
100905: ST_TO_ADDR
// if mechs then
100906: LD_VAR 0 13
100910: IFFALSE 101039
// for i in defenders do
100912: LD_ADDR_VAR 0 5
100916: PUSH
100917: LD_VAR 0 2
100921: PUSH
100922: FOR_IN
100923: IFFALSE 101037
// begin SetTag ( i , 20 ) ;
100925: LD_VAR 0 5
100929: PPUSH
100930: LD_INT 20
100932: PPUSH
100933: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
100937: LD_VAR 0 5
100941: PPUSH
100942: CALL_OW 263
100946: PUSH
100947: LD_INT 1
100949: EQUAL
100950: PUSH
100951: LD_VAR 0 5
100955: PPUSH
100956: CALL_OW 311
100960: NOT
100961: AND
100962: PUSH
100963: LD_VAR 0 13
100967: AND
100968: IFFALSE 101035
// begin un := mechs [ 1 ] ;
100970: LD_ADDR_VAR 0 11
100974: PUSH
100975: LD_VAR 0 13
100979: PUSH
100980: LD_INT 1
100982: ARRAY
100983: ST_TO_ADDR
// ComExitBuilding ( un ) ;
100984: LD_VAR 0 11
100988: PPUSH
100989: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
100993: LD_VAR 0 11
100997: PPUSH
100998: LD_VAR 0 5
101002: PPUSH
101003: CALL_OW 180
// SetTag ( un , 19 ) ;
101007: LD_VAR 0 11
101011: PPUSH
101012: LD_INT 19
101014: PPUSH
101015: CALL_OW 109
// mechs := mechs diff un ;
101019: LD_ADDR_VAR 0 13
101023: PUSH
101024: LD_VAR 0 13
101028: PUSH
101029: LD_VAR 0 11
101033: DIFF
101034: ST_TO_ADDR
// end ; end ;
101035: GO 100922
101037: POP
101038: POP
// if solds then
101039: LD_VAR 0 9
101043: IFFALSE 101102
// for i in solds do
101045: LD_ADDR_VAR 0 5
101049: PUSH
101050: LD_VAR 0 9
101054: PUSH
101055: FOR_IN
101056: IFFALSE 101100
// if not GetTag ( i ) then
101058: LD_VAR 0 5
101062: PPUSH
101063: CALL_OW 110
101067: NOT
101068: IFFALSE 101098
// begin defenders := defenders union i ;
101070: LD_ADDR_VAR 0 2
101074: PUSH
101075: LD_VAR 0 2
101079: PUSH
101080: LD_VAR 0 5
101084: UNION
101085: ST_TO_ADDR
// SetTag ( i , 18 ) ;
101086: LD_VAR 0 5
101090: PPUSH
101091: LD_INT 18
101093: PPUSH
101094: CALL_OW 109
// end ;
101098: GO 101055
101100: POP
101101: POP
// repeat wait ( 0 0$1 ) ;
101102: LD_INT 35
101104: PPUSH
101105: CALL_OW 67
// enemy := mc_scan [ base ] ;
101109: LD_ADDR_VAR 0 3
101113: PUSH
101114: LD_EXP 88
101118: PUSH
101119: LD_VAR 0 1
101123: ARRAY
101124: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
101125: LD_EXP 65
101129: PUSH
101130: LD_VAR 0 1
101134: ARRAY
101135: NOT
101136: PUSH
101137: LD_EXP 65
101141: PUSH
101142: LD_VAR 0 1
101146: ARRAY
101147: PUSH
101148: EMPTY
101149: EQUAL
101150: OR
101151: IFFALSE 101188
// begin for i in defenders do
101153: LD_ADDR_VAR 0 5
101157: PUSH
101158: LD_VAR 0 2
101162: PUSH
101163: FOR_IN
101164: IFFALSE 101177
// ComStop ( i ) ;
101166: LD_VAR 0 5
101170: PPUSH
101171: CALL_OW 141
101175: GO 101163
101177: POP
101178: POP
// defenders := [ ] ;
101179: LD_ADDR_VAR 0 2
101183: PUSH
101184: EMPTY
101185: ST_TO_ADDR
// exit ;
101186: GO 102517
// end ; for i in defenders do
101188: LD_ADDR_VAR 0 5
101192: PUSH
101193: LD_VAR 0 2
101197: PUSH
101198: FOR_IN
101199: IFFALSE 102017
// begin e := NearestUnitToUnit ( enemy , i ) ;
101201: LD_ADDR_VAR 0 14
101205: PUSH
101206: LD_VAR 0 3
101210: PPUSH
101211: LD_VAR 0 5
101215: PPUSH
101216: CALL_OW 74
101220: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101221: LD_ADDR_VAR 0 8
101225: PUSH
101226: LD_EXP 65
101230: PUSH
101231: LD_VAR 0 1
101235: ARRAY
101236: PPUSH
101237: LD_INT 2
101239: PUSH
101240: LD_INT 30
101242: PUSH
101243: LD_INT 0
101245: PUSH
101246: EMPTY
101247: LIST
101248: LIST
101249: PUSH
101250: LD_INT 30
101252: PUSH
101253: LD_INT 1
101255: PUSH
101256: EMPTY
101257: LIST
101258: LIST
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: LIST
101264: PPUSH
101265: CALL_OW 72
101269: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
101270: LD_ADDR_VAR 0 17
101274: PUSH
101275: LD_VAR 0 8
101279: NOT
101280: PUSH
101281: LD_VAR 0 8
101285: PPUSH
101286: LD_INT 3
101288: PUSH
101289: LD_INT 24
101291: PUSH
101292: LD_INT 600
101294: PUSH
101295: EMPTY
101296: LIST
101297: LIST
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: PPUSH
101303: CALL_OW 72
101307: OR
101308: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
101309: LD_VAR 0 5
101313: PPUSH
101314: CALL_OW 247
101318: PUSH
101319: LD_INT 2
101321: DOUBLE
101322: EQUAL
101323: IFTRUE 101327
101325: GO 101723
101327: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
101328: LD_VAR 0 5
101332: PPUSH
101333: CALL_OW 256
101337: PUSH
101338: LD_INT 650
101340: GREATER
101341: PUSH
101342: LD_VAR 0 5
101346: PPUSH
101347: LD_VAR 0 14
101351: PPUSH
101352: CALL_OW 296
101356: PUSH
101357: LD_INT 40
101359: LESS
101360: PUSH
101361: LD_VAR 0 14
101365: PPUSH
101366: LD_EXP 90
101370: PUSH
101371: LD_VAR 0 1
101375: ARRAY
101376: PPUSH
101377: CALL_OW 308
101381: OR
101382: AND
101383: IFFALSE 101505
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
101385: LD_VAR 0 5
101389: PPUSH
101390: CALL_OW 262
101394: PUSH
101395: LD_INT 1
101397: EQUAL
101398: PUSH
101399: LD_VAR 0 5
101403: PPUSH
101404: CALL_OW 261
101408: PUSH
101409: LD_INT 30
101411: LESS
101412: AND
101413: PUSH
101414: LD_VAR 0 8
101418: AND
101419: IFFALSE 101489
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
101421: LD_VAR 0 5
101425: PPUSH
101426: LD_VAR 0 8
101430: PPUSH
101431: LD_VAR 0 5
101435: PPUSH
101436: CALL_OW 74
101440: PPUSH
101441: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
101445: LD_VAR 0 5
101449: PPUSH
101450: LD_VAR 0 8
101454: PPUSH
101455: LD_VAR 0 5
101459: PPUSH
101460: CALL_OW 74
101464: PPUSH
101465: CALL_OW 296
101469: PUSH
101470: LD_INT 6
101472: LESS
101473: IFFALSE 101487
// SetFuel ( i , 100 ) ;
101475: LD_VAR 0 5
101479: PPUSH
101480: LD_INT 100
101482: PPUSH
101483: CALL_OW 240
// end else
101487: GO 101503
// ComAttackUnit ( i , e ) ;
101489: LD_VAR 0 5
101493: PPUSH
101494: LD_VAR 0 14
101498: PPUSH
101499: CALL_OW 115
// end else
101503: GO 101606
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
101505: LD_VAR 0 14
101509: PPUSH
101510: LD_EXP 90
101514: PUSH
101515: LD_VAR 0 1
101519: ARRAY
101520: PPUSH
101521: CALL_OW 308
101525: NOT
101526: PUSH
101527: LD_VAR 0 5
101531: PPUSH
101532: LD_VAR 0 14
101536: PPUSH
101537: CALL_OW 296
101541: PUSH
101542: LD_INT 40
101544: GREATEREQUAL
101545: AND
101546: PUSH
101547: LD_VAR 0 5
101551: PPUSH
101552: CALL_OW 256
101556: PUSH
101557: LD_INT 650
101559: LESSEQUAL
101560: OR
101561: PUSH
101562: LD_VAR 0 5
101566: PPUSH
101567: LD_EXP 89
101571: PUSH
101572: LD_VAR 0 1
101576: ARRAY
101577: PPUSH
101578: CALL_OW 308
101582: NOT
101583: AND
101584: IFFALSE 101606
// ComMoveToArea ( i , mc_parking [ base ] ) ;
101586: LD_VAR 0 5
101590: PPUSH
101591: LD_EXP 89
101595: PUSH
101596: LD_VAR 0 1
101600: ARRAY
101601: PPUSH
101602: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
101606: LD_VAR 0 5
101610: PPUSH
101611: CALL_OW 256
101615: PUSH
101616: LD_INT 998
101618: LESS
101619: PUSH
101620: LD_VAR 0 5
101624: PPUSH
101625: CALL_OW 263
101629: PUSH
101630: LD_INT 1
101632: EQUAL
101633: AND
101634: PUSH
101635: LD_VAR 0 5
101639: PPUSH
101640: CALL_OW 311
101644: AND
101645: PUSH
101646: LD_VAR 0 5
101650: PPUSH
101651: LD_EXP 89
101655: PUSH
101656: LD_VAR 0 1
101660: ARRAY
101661: PPUSH
101662: CALL_OW 308
101666: AND
101667: IFFALSE 101721
// begin mech := IsDrivenBy ( i ) ;
101669: LD_ADDR_VAR 0 10
101673: PUSH
101674: LD_VAR 0 5
101678: PPUSH
101679: CALL_OW 311
101683: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
101684: LD_VAR 0 10
101688: PPUSH
101689: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
101693: LD_VAR 0 10
101697: PPUSH
101698: LD_VAR 0 5
101702: PPUSH
101703: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
101707: LD_VAR 0 10
101711: PPUSH
101712: LD_VAR 0 5
101716: PPUSH
101717: CALL_OW 180
// end ; end ; unit_human :
101721: GO 101988
101723: LD_INT 1
101725: DOUBLE
101726: EQUAL
101727: IFTRUE 101731
101729: GO 101987
101731: POP
// begin b := IsInUnit ( i ) ;
101732: LD_ADDR_VAR 0 19
101736: PUSH
101737: LD_VAR 0 5
101741: PPUSH
101742: CALL_OW 310
101746: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
101747: LD_ADDR_VAR 0 20
101751: PUSH
101752: LD_VAR 0 19
101756: NOT
101757: PUSH
101758: LD_VAR 0 19
101762: PPUSH
101763: CALL_OW 266
101767: PUSH
101768: LD_INT 32
101770: PUSH
101771: LD_INT 31
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: IN
101778: OR
101779: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
101780: LD_VAR 0 17
101784: PUSH
101785: LD_VAR 0 2
101789: PPUSH
101790: LD_INT 21
101792: PUSH
101793: LD_INT 2
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PPUSH
101800: CALL_OW 72
101804: PUSH
101805: LD_INT 1
101807: LESSEQUAL
101808: OR
101809: PUSH
101810: LD_VAR 0 20
101814: AND
101815: PUSH
101816: LD_VAR 0 5
101820: PUSH
101821: LD_VAR 0 18
101825: IN
101826: NOT
101827: AND
101828: IFFALSE 101921
// begin if b then
101830: LD_VAR 0 19
101834: IFFALSE 101883
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
101836: LD_VAR 0 19
101840: PPUSH
101841: LD_VAR 0 3
101845: PPUSH
101846: LD_VAR 0 19
101850: PPUSH
101851: CALL_OW 74
101855: PPUSH
101856: CALL_OW 296
101860: PUSH
101861: LD_INT 10
101863: LESS
101864: PUSH
101865: LD_VAR 0 19
101869: PPUSH
101870: CALL_OW 461
101874: PUSH
101875: LD_INT 7
101877: NONEQUAL
101878: AND
101879: IFFALSE 101883
// continue ;
101881: GO 101198
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
101883: LD_ADDR_VAR 0 18
101887: PUSH
101888: LD_VAR 0 18
101892: PPUSH
101893: LD_VAR 0 18
101897: PUSH
101898: LD_INT 1
101900: PLUS
101901: PPUSH
101902: LD_VAR 0 5
101906: PPUSH
101907: CALL_OW 1
101911: ST_TO_ADDR
// ComExitBuilding ( i ) ;
101912: LD_VAR 0 5
101916: PPUSH
101917: CALL_OW 122
// end ; if sold_defenders then
101921: LD_VAR 0 18
101925: IFFALSE 101985
// if i in sold_defenders then
101927: LD_VAR 0 5
101931: PUSH
101932: LD_VAR 0 18
101936: IN
101937: IFFALSE 101985
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
101939: LD_VAR 0 5
101943: PPUSH
101944: CALL_OW 314
101948: NOT
101949: PUSH
101950: LD_VAR 0 5
101954: PPUSH
101955: LD_VAR 0 14
101959: PPUSH
101960: CALL_OW 296
101964: PUSH
101965: LD_INT 30
101967: LESS
101968: AND
101969: IFFALSE 101985
// ComAttackUnit ( i , e ) ;
101971: LD_VAR 0 5
101975: PPUSH
101976: LD_VAR 0 14
101980: PPUSH
101981: CALL_OW 115
// end ; end ; end ;
101985: GO 101988
101987: POP
// if IsDead ( i ) then
101988: LD_VAR 0 5
101992: PPUSH
101993: CALL_OW 301
101997: IFFALSE 102015
// defenders := defenders diff i ;
101999: LD_ADDR_VAR 0 2
102003: PUSH
102004: LD_VAR 0 2
102008: PUSH
102009: LD_VAR 0 5
102013: DIFF
102014: ST_TO_ADDR
// end ;
102015: GO 101198
102017: POP
102018: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
102019: LD_VAR 0 3
102023: NOT
102024: PUSH
102025: LD_VAR 0 2
102029: NOT
102030: OR
102031: PUSH
102032: LD_EXP 65
102036: PUSH
102037: LD_VAR 0 1
102041: ARRAY
102042: NOT
102043: OR
102044: IFFALSE 101102
// MC_Reset ( base , 18 ) ;
102046: LD_VAR 0 1
102050: PPUSH
102051: LD_INT 18
102053: PPUSH
102054: CALL 54497 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
102058: LD_ADDR_VAR 0 2
102062: PUSH
102063: LD_VAR 0 2
102067: PUSH
102068: LD_VAR 0 2
102072: PPUSH
102073: LD_INT 2
102075: PUSH
102076: LD_INT 25
102078: PUSH
102079: LD_INT 1
102081: PUSH
102082: EMPTY
102083: LIST
102084: LIST
102085: PUSH
102086: LD_INT 25
102088: PUSH
102089: LD_INT 5
102091: PUSH
102092: EMPTY
102093: LIST
102094: LIST
102095: PUSH
102096: LD_INT 25
102098: PUSH
102099: LD_INT 8
102101: PUSH
102102: EMPTY
102103: LIST
102104: LIST
102105: PUSH
102106: LD_INT 25
102108: PUSH
102109: LD_INT 9
102111: PUSH
102112: EMPTY
102113: LIST
102114: LIST
102115: PUSH
102116: EMPTY
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: PPUSH
102123: CALL_OW 72
102127: DIFF
102128: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
102129: LD_VAR 0 3
102133: NOT
102134: PUSH
102135: LD_VAR 0 2
102139: PPUSH
102140: LD_INT 21
102142: PUSH
102143: LD_INT 2
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: PPUSH
102150: CALL_OW 72
102154: AND
102155: IFFALSE 102493
// begin tmp := FilterByTag ( defenders , 19 ) ;
102157: LD_ADDR_VAR 0 12
102161: PUSH
102162: LD_VAR 0 2
102166: PPUSH
102167: LD_INT 19
102169: PPUSH
102170: CALL 47140 0 2
102174: ST_TO_ADDR
// if tmp then
102175: LD_VAR 0 12
102179: IFFALSE 102249
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
102181: LD_ADDR_VAR 0 12
102185: PUSH
102186: LD_VAR 0 12
102190: PPUSH
102191: LD_INT 25
102193: PUSH
102194: LD_INT 3
102196: PUSH
102197: EMPTY
102198: LIST
102199: LIST
102200: PPUSH
102201: CALL_OW 72
102205: ST_TO_ADDR
// if tmp then
102206: LD_VAR 0 12
102210: IFFALSE 102249
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
102212: LD_ADDR_EXP 77
102216: PUSH
102217: LD_EXP 77
102221: PPUSH
102222: LD_VAR 0 1
102226: PPUSH
102227: LD_EXP 77
102231: PUSH
102232: LD_VAR 0 1
102236: ARRAY
102237: PUSH
102238: LD_VAR 0 12
102242: UNION
102243: PPUSH
102244: CALL_OW 1
102248: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
102249: LD_VAR 0 1
102253: PPUSH
102254: LD_INT 19
102256: PPUSH
102257: CALL 54497 0 2
// repeat wait ( 0 0$1 ) ;
102261: LD_INT 35
102263: PPUSH
102264: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
102268: LD_EXP 65
102272: PUSH
102273: LD_VAR 0 1
102277: ARRAY
102278: NOT
102279: PUSH
102280: LD_EXP 65
102284: PUSH
102285: LD_VAR 0 1
102289: ARRAY
102290: PUSH
102291: EMPTY
102292: EQUAL
102293: OR
102294: IFFALSE 102331
// begin for i in defenders do
102296: LD_ADDR_VAR 0 5
102300: PUSH
102301: LD_VAR 0 2
102305: PUSH
102306: FOR_IN
102307: IFFALSE 102320
// ComStop ( i ) ;
102309: LD_VAR 0 5
102313: PPUSH
102314: CALL_OW 141
102318: GO 102306
102320: POP
102321: POP
// defenders := [ ] ;
102322: LD_ADDR_VAR 0 2
102326: PUSH
102327: EMPTY
102328: ST_TO_ADDR
// exit ;
102329: GO 102517
// end ; for i in defenders do
102331: LD_ADDR_VAR 0 5
102335: PUSH
102336: LD_VAR 0 2
102340: PUSH
102341: FOR_IN
102342: IFFALSE 102431
// begin if not IsInArea ( i , mc_parking [ base ] ) then
102344: LD_VAR 0 5
102348: PPUSH
102349: LD_EXP 89
102353: PUSH
102354: LD_VAR 0 1
102358: ARRAY
102359: PPUSH
102360: CALL_OW 308
102364: NOT
102365: IFFALSE 102389
// ComMoveToArea ( i , mc_parking [ base ] ) else
102367: LD_VAR 0 5
102371: PPUSH
102372: LD_EXP 89
102376: PUSH
102377: LD_VAR 0 1
102381: ARRAY
102382: PPUSH
102383: CALL_OW 113
102387: GO 102429
// if GetControl ( i ) = control_manual then
102389: LD_VAR 0 5
102393: PPUSH
102394: CALL_OW 263
102398: PUSH
102399: LD_INT 1
102401: EQUAL
102402: IFFALSE 102429
// if IsDrivenBy ( i ) then
102404: LD_VAR 0 5
102408: PPUSH
102409: CALL_OW 311
102413: IFFALSE 102429
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
102415: LD_VAR 0 5
102419: PPUSH
102420: CALL_OW 311
102424: PPUSH
102425: CALL_OW 121
// end ;
102429: GO 102341
102431: POP
102432: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
102433: LD_VAR 0 2
102437: PPUSH
102438: LD_INT 95
102440: PUSH
102441: LD_EXP 89
102445: PUSH
102446: LD_VAR 0 1
102450: ARRAY
102451: PUSH
102452: EMPTY
102453: LIST
102454: LIST
102455: PPUSH
102456: CALL_OW 72
102460: PUSH
102461: LD_VAR 0 2
102465: EQUAL
102466: PUSH
102467: LD_EXP 88
102471: PUSH
102472: LD_VAR 0 1
102476: ARRAY
102477: OR
102478: PUSH
102479: LD_EXP 65
102483: PUSH
102484: LD_VAR 0 1
102488: ARRAY
102489: NOT
102490: OR
102491: IFFALSE 102261
// end ; MC_Reset ( base , 19 ) ;
102493: LD_VAR 0 1
102497: PPUSH
102498: LD_INT 19
102500: PPUSH
102501: CALL 54497 0 2
// MC_Reset ( base , 20 ) ;
102505: LD_VAR 0 1
102509: PPUSH
102510: LD_INT 20
102512: PPUSH
102513: CALL 54497 0 2
// end ;
102517: LD_VAR 0 4
102521: RET
